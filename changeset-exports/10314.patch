# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1265909012 18000
#      Thu Feb 11 12:23:32 2010 -0500
# Node ID 07ebe522dac2276527d2a31e8704cd28acd430e5
# Parent  f3b65e1ae35568b4561c9686a36fb632f505fa40
untabify liboctave C++ sources

diff --git a/liboctave/Array-C.cc b/liboctave/Array-C.cc
--- a/liboctave/Array-C.cc
+++ b/liboctave/Array-C.cc
@@ -40,28 +40,28 @@ sort_isnan<Complex> (const Complex& x)
 {
   return xisnan (x);
 }
 
 static bool
 nan_ascending_compare (const Complex& x, const Complex& y)
 {
   return (xisnan (y)
-	  ? ! xisnan (x)
-	  : ((std::abs (x) < std::abs (x))
-	     || ((std::abs (x) == std::abs (x)) && (arg (x) < arg (x)))));
+          ? ! xisnan (x)
+          : ((std::abs (x) < std::abs (x))
+             || ((std::abs (x) == std::abs (x)) && (arg (x) < arg (x)))));
 }
 
 static bool
 nan_descending_compare (const Complex& x, const Complex& y)
 {
   return (xisnan (x)
-	  ? ! xisnan (y)
-	  : ((std::abs (x) > std::abs (x))
-	     || ((std::abs (x) == std::abs (x)) && (arg (x) > arg (x)))));
+          ? ! xisnan (y)
+          : ((std::abs (x) > std::abs (x))
+             || ((std::abs (x) == std::abs (x)) && (arg (x) > arg (x)))));
 }
 
 Array<Complex>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<Complex>& a , bool allow_chk)
 {
   Array<Complex>::compare_fcn_type result = 0;
 
   if (allow_chk)
diff --git a/liboctave/Array-fC.cc b/liboctave/Array-fC.cc
--- a/liboctave/Array-fC.cc
+++ b/liboctave/Array-fC.cc
@@ -40,33 +40,33 @@ sort_isnan<FloatComplex> (const FloatCom
 {
   return xisnan (x);
 }
 
 static bool
 nan_ascending_compare (const FloatComplex& x, const FloatComplex& y)
 {
   return (xisnan (y)
-	  ? ! xisnan (x)
-	  : ((std::abs (x) < std::abs (x))
-	     || ((std::abs (x) == std::abs (x)) && (arg (x) < arg (x)))));
+          ? ! xisnan (x)
+          : ((std::abs (x) < std::abs (x))
+             || ((std::abs (x) == std::abs (x)) && (arg (x) < arg (x)))));
 }
 
 static bool
 nan_descending_compare (const FloatComplex& x, const FloatComplex& y)
 {
   return (xisnan (x)
-	  ? ! xisnan (y)
-	  : ((std::abs (x) > std::abs (x))
-	     || ((std::abs (x) == std::abs (x)) && (arg (x) > arg (x)))));
+          ? ! xisnan (y)
+          : ((std::abs (x) > std::abs (x))
+             || ((std::abs (x) == std::abs (x)) && (arg (x) > arg (x)))));
 }
 
 Array<FloatComplex>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<FloatComplex>& a,
-		     bool allow_chk)
+                     bool allow_chk)
 {
   Array<FloatComplex>::compare_fcn_type result = 0;
 
   if (allow_chk)
     {
       octave_idx_type k = 0;
       for (; k < a.numel () && ! xisnan (a(k)); k++) ;
       if (k == a.numel ())
diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -27,90 +27,90 @@ along with Octave; see the file COPYING.
 
 #include "Array-util.h"
 #include "dim-vector.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 
 bool
 index_in_bounds (const Array<octave_idx_type>& ra_idx,
-		 const dim_vector& dimensions)
+                 const dim_vector& dimensions)
 {
   bool retval = true;
 
   int n = ra_idx.length ();
 
   if (n == dimensions.length ())
     {
       for (int i = 0; i < n; i++)
-	{
-	  if (ra_idx(i) < 0 || ra_idx(i) >= dimensions(i))
-	    {
-	      retval = false;
-	      break;
-	    }
-	}
+        {
+          if (ra_idx(i) < 0 || ra_idx(i) >= dimensions(i))
+            {
+              retval = false;
+              break;
+            }
+        }
     }
   else
     retval = false;
 
   return retval;
 }
 
 void
 increment_index (Array<octave_idx_type>& ra_idx, const dim_vector& dimensions,
-		 int start_dimension)
+                 int start_dimension)
 {
   ra_idx(start_dimension)++;
 
   int n = ra_idx.length () - 1;
   int nda = dimensions.length ();
 
   for (int i = start_dimension; i < n; i++)
     {
       if (ra_idx(i) < (i < nda ? dimensions(i) : 1))
- 	break;
+        break;
       else
- 	{
- 	  ra_idx(i) = 0;
- 	  ra_idx(i+1)++;
- 	}
+        {
+          ra_idx(i) = 0;
+          ra_idx(i+1)++;
+        }
     }
 }
 
 octave_idx_type
 get_scalar_idx (Array<octave_idx_type>& idx, dim_vector& dims)
 {
   octave_idx_type retval (-1);
 
   int n = idx.length ();
 
   if (n > 0)
     {
       retval = idx(--n);
 
       while (--n >= 0)
-	{      		
-	  retval *= dims (n);
-	
-	  retval += idx(n);
-	}
+        {               
+          retval *= dims (n);
+        
+          retval += idx(n);
+        }
     }
   return retval;
 }
 
 octave_idx_type
 num_ones (const Array<octave_idx_type>& ra_idx)
 {
   octave_idx_type retval = 0;
 
   for (octave_idx_type i = 0; i < ra_idx.length (); i++)
     {
       if (ra_idx (i) == 1)
-	retval++;
+        retval++;
     }
 
   return retval;
 }
 
 bool
 is_scalar (const dim_vector& dim)
 {
@@ -120,82 +120,82 @@ is_scalar (const dim_vector& dim)
 
   if (n == 0)
     {
       retval = false;
     }
   else
     {
       for (int i = 0; i < n; i ++)
-	{
-	  if (dim (i) != 1)
-	    {
-	      retval = false;
-	
-	      break;
-	    }
-	}
+        {
+          if (dim (i) != 1)
+            {
+              retval = false;
+        
+              break;
+            }
+        }
     }
   return retval;
 }
 
 bool
 is_vector (const dim_vector& dim)
 {
   int m = 0;
   int n = dim.length ();
 
   if (n == 0)
     m = 2;
   else
     {
       for (int i = 0; i < n; i ++)
-	if (dim (i) > 1)
-	  m++;
-	else if (dim(i) < 1)
-	  m += 2;
+        if (dim (i) > 1)
+          m++;
+        else if (dim(i) < 1)
+          m += 2;
     }
 
   return (m < 2);
 }
 
 bool
 any_ones (const Array<octave_idx_type>& arr)
 {
   bool retval = false;
 
   for (octave_idx_type i = 0; i < arr.length (); i++)
     {
       if (arr (i) == 1)
-	{
-	  retval = true;
-	
-	  break;
-	}
+        {
+          retval = true;
+        
+          break;
+        }
     }
   return retval;
 }
 
 octave_idx_type
 compute_index (const Array<octave_idx_type>& ra_idx, const dim_vector& dims)
 {
   octave_idx_type retval = -1;
 
   int n = dims.length ();
 
   if (n > 0 && n == ra_idx.length ())
     {
       retval = ra_idx(--n);
 
       while (--n >= 0)
-	{
-	  retval *= dims(n);
-	
-	  retval += ra_idx(n);
-	}
+        {
+          retval *= dims(n);
+        
+          retval += ra_idx(n);
+        }
     }
   else
     (*current_liboctave_error_handler)
       ("ArrayN<T>::compute_index: invalid ra_idxing operation");
 
   return retval;
 }
 
@@ -231,124 +231,124 @@ freeze (Array<idx_vector>& ra_idx, const
   assert (n == dimensions.length ());
 
   retval.resize (n);
 
   static const char *tag[3] = { "row", "column", 0 };
 
   for (int i = 0; i < n; i++)
     retval(i) = ra_idx(i).freeze (dimensions(i), tag[i < 2 ? i : 3],
-				  resize_ok);
+                                  resize_ok);
 
   return retval;
 }
 
 bool
 vector_equivalent (const dim_vector& dv)
 {
   int n = dv.length ();
 
   bool found_first = false;
 
   for (int i = 0; i < n; i++)
     {
       if (dv(i) != 1)
         {
-	  if (! found_first)
-	    found_first = true;
-	  else
-	    return false;
-	}
+          if (! found_first)
+            found_first = true;
+          else
+            return false;
+        }
     }
 
   return true;
 }
 
 bool
 all_ok (const Array<idx_vector>& ra_idx)
 {
   bool retval = true;
 
   octave_idx_type n = ra_idx.length ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (! ra_idx(i))
-	{
-	  retval = false;
-	  break;
-	}
+        {
+          retval = false;
+          break;
+        }
     }
 
   return retval;
 }
 
 bool
 any_orig_empty (const Array<idx_vector>& ra_idx)
 {
   bool retval = false;
 
   octave_idx_type n = ra_idx.length ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (ra_idx(i).orig_empty ())
-	{
-	  retval = true;
-	  break;
-	}
+        {
+          retval = true;
+          break;
+        }
     }
 
   return retval;
 }
 
 bool
 all_colon_equiv (const Array<idx_vector>& ra_idx,
-		 const dim_vector& frozen_lengths)
+                 const dim_vector& frozen_lengths)
 {
   bool retval = true;
 
   octave_idx_type idx_n = ra_idx.length ();
 
   int n = frozen_lengths.length ();
 
   assert (idx_n == n);
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (! ra_idx(i).is_colon_equiv (frozen_lengths(i)))
-	{
-	  retval = false;
-	  break;
-	}
+        {
+          retval = false;
+          break;
+        }
     }
 
   return retval;
 }
 
 bool
 all_ones (const Array<octave_idx_type>& arr)
 {
   bool retval = true;
 
   for (octave_idx_type i = 0; i < arr.length (); i++)
     {
       if (arr(i) != 1)
-	{
-	  retval = false;
-	  break;
-	}
+        {
+          retval = false;
+          break;
+        }
     }
 
   return retval;
 }
 
 Array<octave_idx_type>
 get_elt_idx (const Array<idx_vector>& ra_idx,
-	     const Array<octave_idx_type>& result_idx)
+             const Array<octave_idx_type>& result_idx)
 {
   octave_idx_type n = ra_idx.length ();
 
   Array<octave_idx_type> retval (n);
 
   for (octave_idx_type i = 0; i < n; i++)
     retval(i) = ra_idx(i).elem (result_idx(i));
 
@@ -375,17 +375,17 @@ get_ra_idx (octave_idx_type idx, const d
   // FIXME -- the solution using increment_index is not
   // efficient.
 
 #if 0
   octave_idx_type var = 1;
   for (int i = 0; i < n_dims; i++)
     {
       std::cout << "idx: " << idx << ", var: " << var
-		<< ", dims(" << i << "): " << dims(i) <<"\n";
+                << ", dims(" << i << "): " << dims(i) <<"\n";
       retval(i) = ((int)floor(((idx) / (double)var))) % dims(i);
       idx -= var * retval(i);
       var = dims(i);
     }
 #endif
 
   return retval;
 }
@@ -442,17 +442,17 @@ zero_dims_inquire (const Array<idx_vecto
   delete [] scalar;
   delete [] colon;
 
   return rdv;
 }
 
 dim_vector
 zero_dims_inquire (const idx_vector& i, const idx_vector& j,
-		   const dim_vector& rhdv)
+                   const dim_vector& rhdv)
 {
   bool icol = i.is_colon (), jcol = j.is_colon ();
   dim_vector rdv;
   if (icol && jcol && rhdv.length () == 2)
     {
       rdv(0) = rhdv(0);
       rdv(1) = rhdv(1);
     }
@@ -628,26 +628,26 @@ gripe_nonconformant (const char *op, int
 {
   (*current_liboctave_error_handler)
     ("%s: nonconformant arguments (op1 len: %d, op2 len: %d)",
      op, op1_len, op2_len);
 }
 
 void
 gripe_nonconformant (const char *op, int op1_nr, int op1_nc,
-		     int op2_nr, int op2_nc)
+                     int op2_nr, int op2_nc)
 {
   (*current_liboctave_error_handler)
     ("%s: nonconformant arguments (op1 is %dx%d, op2 is %dx%d)",
      op, op1_nr, op1_nc, op2_nr, op2_nc);
 }
 
 void
 gripe_nonconformant (const char *op, dim_vector& op1_dims,
-		     dim_vector& op2_dims)
+                     dim_vector& op2_dims)
 {
   std::string op1_dims_str = op1_dims.str ();
   std::string op2_dims_str = op2_dims.str ();
 
   (*current_liboctave_error_handler)
     ("%s: nonconformant arguments (op1 is %s, op2 is %s)",
      op, op1_dims_str.c_str (), op2_dims_str.c_str ());
 }
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -121,47 +121,47 @@ Array<T>::squeeze (void) const
     {
       bool dims_changed = false;
 
       dim_vector new_dimensions = dimensions;
 
       int k = 0;
 
       for (int i = 0; i < ndims (); i++)
-	{
-	  if (dimensions(i) == 1)
-	    dims_changed = true;
-	  else
-	    new_dimensions(k++) = dimensions(i);
-	}
+        {
+          if (dimensions(i) == 1)
+            dims_changed = true;
+          else
+            new_dimensions(k++) = dimensions(i);
+        }
 
       if (dims_changed)
-	{
-	  switch (k)
-	    {
-	    case 0:
-	      new_dimensions = dim_vector (1, 1);
-	      break;
-
-	    case 1:
-	      {
-		octave_idx_type tmp = new_dimensions(0);
-
-		new_dimensions.resize (2);
-
-		new_dimensions(0) = tmp;
-		new_dimensions(1) = 1;
-	      }
-	      break;
-
-	    default:
-	      new_dimensions.resize (k);
-	      break;
-	    }
-	}
+        {
+          switch (k)
+            {
+            case 0:
+              new_dimensions = dim_vector (1, 1);
+              break;
+
+            case 1:
+              {
+                octave_idx_type tmp = new_dimensions(0);
+
+                new_dimensions.resize (2);
+
+                new_dimensions(0) = tmp;
+                new_dimensions(1) = 1;
+              }
+              break;
+
+            default:
+              new_dimensions.resize (k);
+              break;
+            }
+        }
 
       retval = Array<T> (*this, new_dimensions);
     }
 
   return retval;
 }
 
 template <class T>
@@ -443,32 +443,32 @@ Array<T>::permute (const Array<octave_id
 
   bool identity = true;
 
   // Find dimension vector of permuted array.
   for (int i = 0; i < perm_vec_len; i++)
     {
       octave_idx_type perm_elt = perm_vec.elem (i);
       if (perm_elt >= perm_vec_len || perm_elt < 0)
-	{
-	  (*current_liboctave_error_handler)
-	    ("%s: permutation vector contains an invalid element",
-	     inv ? "ipermute" : "permute");
-
-	  return retval;
-	}
+        {
+          (*current_liboctave_error_handler)
+            ("%s: permutation vector contains an invalid element",
+             inv ? "ipermute" : "permute");
+
+          return retval;
+        }
 
       if (checked[perm_elt])
-	{
-	  (*current_liboctave_error_handler)
-	    ("%s: permutation vector cannot contain identical elements",
-	     inv ? "ipermute" : "permute");
-
-	  return retval;
-	}
+        {
+          (*current_liboctave_error_handler)
+            ("%s: permutation vector cannot contain identical elements",
+             inv ? "ipermute" : "permute");
+
+          return retval;
+        }
       else
         {
           checked[perm_elt] = true;
           identity = identity && perm_elt == i;
         }
     }
 
   if (identity)
@@ -1185,17 +1185,17 @@ Array<T>::assign (const idx_vector& i, c
       rdv(0) = i.extent (dv(0));
       rdv(1) = j.extent (dv(1));
     }
 
   bool isfill = rhs.numel () == 1;
   octave_idx_type il = i.length (rdv(0)), jl = j.length (rdv(1));
   rhdv.chop_all_singletons ();
   bool match = (isfill
-		|| (rhdv.length () == 2 && il == rhdv(0) && jl == rhdv(1)));
+                || (rhdv.length () == 2 && il == rhdv(0) && jl == rhdv(1)));
   match = match || (il == 1 && jl == rhdv(0) && rhdv(1) == 1);
 
   if (match)
     {
       bool all_colons = (i.is_colon_equiv (rdv(0)) 
                          && j.is_colon_equiv (rdv(1)));
       // Resize if requested.
       if (rdv != dv)
@@ -1550,18 +1550,18 @@ Array<T>::transpose (void) const
 
       return result;
     }
   else if (nr > 1 && nc > 1)
     {
       Array<T> result (dim_vector (nc, nr));
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  result.xelem (j, i) = xelem (i, j);
+        for (octave_idx_type i = 0; i < nr; i++)
+          result.xelem (j, i) = xelem (i, j);
 
       return result;
     }
   else
     {
       // Fast transpose for vectors and empty matrices.
       return Array<T> (*this, dim_vector (nc, nr));
     }
@@ -1593,52 +1593,52 @@ Array<T>::hermitian (T (*fcn) (const T&)
       // Blocked transpose to attempt to avoid cache misses.
 
       // Don't use OCTAVE_LOCAL_BUFFER here as it doesn't work with bool
       // on some compilers.
       T buf[64];
 
       octave_idx_type ii = 0, jj;
       for (jj = 0; jj < (nc - 8 + 1); jj += 8)
-	{
-	  for (ii = 0; ii < (nr - 8 + 1); ii += 8)
-	    {
-	      // Copy to buffer
-	      for (octave_idx_type j = jj, k = 0, idxj = jj * nr; 
-		   j < jj + 8; j++, idxj += nr)
-		for (octave_idx_type i = ii; i < ii + 8; i++)
-		  buf[k++] = xelem (i + idxj);
-
-	      // Copy from buffer
-	      for (octave_idx_type i = ii, idxi = ii * nc; i < ii + 8; 
-		   i++, idxi += nc)
-		for (octave_idx_type j = jj, k = i - ii; j < jj + 8; 
-		     j++, k+=8)
-		  result.xelem (j + idxi) = fcn (buf[k]);
-	    }
-
-	  if (ii < nr)
-	    for (octave_idx_type j = jj; j < jj + 8; j++)
-	      for (octave_idx_type i = ii; i < nr; i++)
-		result.xelem (j, i) = fcn (xelem (i, j));
-	} 
+        {
+          for (ii = 0; ii < (nr - 8 + 1); ii += 8)
+            {
+              // Copy to buffer
+              for (octave_idx_type j = jj, k = 0, idxj = jj * nr; 
+                   j < jj + 8; j++, idxj += nr)
+                for (octave_idx_type i = ii; i < ii + 8; i++)
+                  buf[k++] = xelem (i + idxj);
+
+              // Copy from buffer
+              for (octave_idx_type i = ii, idxi = ii * nc; i < ii + 8; 
+                   i++, idxi += nc)
+                for (octave_idx_type j = jj, k = i - ii; j < jj + 8; 
+                     j++, k+=8)
+                  result.xelem (j + idxi) = fcn (buf[k]);
+            }
+
+          if (ii < nr)
+            for (octave_idx_type j = jj; j < jj + 8; j++)
+              for (octave_idx_type i = ii; i < nr; i++)
+                result.xelem (j, i) = fcn (xelem (i, j));
+        } 
 
       for (octave_idx_type j = jj; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  result.xelem (j, i) = fcn (xelem (i, j));
+        for (octave_idx_type i = 0; i < nr; i++)
+          result.xelem (j, i) = fcn (xelem (i, j));
 
       return result;
     }
   else
     {
       Array<T> result (dim_vector (nc, nr));
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  result.xelem (j, i) = fcn (xelem (i, j));
+        for (octave_idx_type i = 0; i < nr; i++)
+          result.xelem (j, i) = fcn (xelem (i, j));
 
       return result;
     }
 }
 
 /*
 
 %% Tranpose tests for matrices of the tile size and plus or minus a row
@@ -1692,24 +1692,24 @@ Array<T>::maybe_delete_dims (void)
 
   bool delete_dims = true;
 
   for (int i = nd - 1; i >= 0; i--)
     {
       if (delete_dims)
         {
           if (dimensions(i) != 1)
-	    {
-	      delete_dims = false;
-
-	      new_dims = dim_vector (i + 1, dimensions(i));
-	    }
+            {
+              delete_dims = false;
+
+              new_dims = dim_vector (i + 1, dimensions(i));
+            }
         }
       else
-	new_dims(i) = dimensions(i);
+        new_dims(i) = dimensions(i);
     }
 
   if (nd != new_dims.length ())
     dimensions = new_dims;
 }
 
 // Non-real types don't have NaNs.
 template <class T>
@@ -1752,97 +1752,97 @@ Array<T>::sort (int dim, sortmode mode) 
   if (mode) 
     lsort.set_compare (mode);
   else
     return m;
 
   if (stride == 1)
     {
       for (octave_idx_type j = 0; j < iter; j++)
-	{
+        {
           // copy and partition out NaNs. 
           // FIXME: impact on integer types noticeable?
           octave_idx_type kl = 0, ku = ns;
           for (octave_idx_type i = 0; i < ns; i++)
             {
               T tmp = ov[i];
               if (sort_isnan<T> (tmp))
                 v[--ku] = tmp;
               else
                 v[kl++] = tmp;
             }
 
           // sort.
-	  lsort.sort (v, kl);
+          lsort.sort (v, kl);
 
           if (ku < ns)
             {
               // NaNs are in reverse order
               std::reverse (v + ku, v + ns);
               if (mode == DESCENDING)
                 std::rotate (v, v + ku, v + ns);
             }
 
-	  v += ns;
+          v += ns;
           ov += ns;
-	}
+        }
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (T, buf, ns);
 
       for (octave_idx_type j = 0; j < iter; j++) 
-	{
-	  octave_idx_type offset = j;
-	  octave_idx_type offset2 = 0;
-
-	  while (offset >= stride)
-	    {
-	      offset -= stride;
-	      offset2++;
-	    }
-
-	  offset += offset2 * stride * ns;
-	  
+        {
+          octave_idx_type offset = j;
+          octave_idx_type offset2 = 0;
+
+          while (offset >= stride)
+            {
+              offset -= stride;
+              offset2++;
+            }
+
+          offset += offset2 * stride * ns;
+          
           // gather and partition out NaNs. 
           // FIXME: impact on integer types noticeable?
           octave_idx_type kl = 0, ku = ns;
           for (octave_idx_type i = 0; i < ns; i++)
             {
               T tmp = ov[i*stride + offset];
               if (sort_isnan<T> (tmp))
                 buf[--ku] = tmp;
               else
                 buf[kl++] = tmp;
             }
 
           // sort.
-	  lsort.sort (buf, kl);
+          lsort.sort (buf, kl);
 
           if (ku < ns)
             {
               // NaNs are in reverse order
               std::reverse (buf + ku, buf + ns);
               if (mode == DESCENDING)
                 std::rotate (buf, buf + ku, buf + ns);
             }
 
           // scatter.
-	  for (octave_idx_type i = 0; i < ns; i++)
-	    v[i*stride + offset] = buf[i];
-	}
+          for (octave_idx_type i = 0; i < ns; i++)
+            v[i*stride + offset] = buf[i];
+        }
     }
 
   return m;
 }
 
 template <class T>
 Array<T>
 Array<T>::sort (Array<octave_idx_type> &sidx, int dim, 
-		sortmode mode) const
+                sortmode mode) const
 {
   if (dim < 0 || dim >= ndims ())
     {
       (*current_liboctave_error_handler)
         ("sort: invalid dimension");
       return Array<T> ();
     }
 
@@ -1874,17 +1874,17 @@ Array<T>::sort (Array<octave_idx_type> &
   if (mode) 
     lsort.set_compare (mode);
   else
     return m;
 
   if (stride == 1)
     {
       for (octave_idx_type j = 0; j < iter; j++)
-	{
+        {
           // copy and partition out NaNs. 
           // FIXME: impact on integer types noticeable?
           octave_idx_type kl = 0, ku = ns;
           for (octave_idx_type i = 0; i < ns; i++)
             {
               T tmp = ov[i];
               if (sort_isnan<T> (tmp))
                 {
@@ -1896,53 +1896,53 @@ Array<T>::sort (Array<octave_idx_type> &
                 {
                   v[kl] = tmp;
                   vi[kl] = i;
                   kl++;
                 }
             }
 
           // sort.
-	  lsort.sort (v, vi, kl);
+          lsort.sort (v, vi, kl);
 
           if (ku < ns)
             {
               // NaNs are in reverse order
               std::reverse (v + ku, v + ns);
               std::reverse (vi + ku, vi + ns);
               if (mode == DESCENDING)
                 {
                   std::rotate (v, v + ku, v + ns);
                   std::rotate (vi, vi + ku, vi + ns);
                 }
             }
 
-	  v += ns;
+          v += ns;
           vi += ns;
           ov += ns;
-	}
+        }
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (T, buf, ns);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, bufi, ns);
 
       for (octave_idx_type j = 0; j < iter; j++) 
-	{
-	  octave_idx_type offset = j;
-	  octave_idx_type offset2 = 0;
-
-	  while (offset >= stride)
-	    {
-	      offset -= stride;
-	      offset2++;
-	    }
-
-	  offset += offset2 * stride * ns;
-	  
+        {
+          octave_idx_type offset = j;
+          octave_idx_type offset2 = 0;
+
+          while (offset >= stride)
+            {
+              offset -= stride;
+              offset2++;
+            }
+
+          offset += offset2 * stride * ns;
+          
           // gather and partition out NaNs. 
           // FIXME: impact on integer types noticeable?
           octave_idx_type kl = 0, ku = ns;
           for (octave_idx_type i = 0; i < ns; i++)
             {
               T tmp = ov[i*stride + offset];
               if (sort_isnan<T> (tmp))
                 {
@@ -1954,36 +1954,36 @@ Array<T>::sort (Array<octave_idx_type> &
                 {
                   buf[kl] = tmp;
                   bufi[kl] = i;
                   kl++;
                 }
             }
 
           // sort.
-	  lsort.sort (buf, bufi, kl);
+          lsort.sort (buf, bufi, kl);
 
           if (ku < ns)
             {
               // NaNs are in reverse order
               std::reverse (buf + ku, buf + ns);
               std::reverse (bufi + ku, bufi + ns);
               if (mode == DESCENDING)
                 {
                   std::rotate (buf, buf + ku, buf + ns);
                   std::rotate (bufi, bufi + ku, bufi + ns);
                 }
             }
 
           // scatter.
-	  for (octave_idx_type i = 0; i < ns; i++)
-	    v[i*stride + offset] = buf[i];
-	  for (octave_idx_type i = 0; i < ns; i++)
-	    vi[i*stride + offset] = bufi[i];
-	}
+          for (octave_idx_type i = 0; i < ns; i++)
+            v[i*stride + offset] = buf[i];
+          for (octave_idx_type i = 0; i < ns; i++)
+            vi[i*stride + offset] = bufi[i];
+        }
     }
 
   return m;
 }
 
 template <class T>
 typename Array<T>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<T>& /* a */,
@@ -2007,17 +2007,17 @@ Array<T>::is_sorted (sortmode mode) cons
 
   if (n <= 1)
     return mode ? mode : ASCENDING;
 
   if (! mode)
     {
       // Auto-detect mode.
       compare_fcn_type compare
-	= safe_comparator (ASCENDING, *this, false);
+        = safe_comparator (ASCENDING, *this, false);
 
       if (compare (elem (n-1), elem (0)))
         mode = DESCENDING;
       else
         mode = ASCENDING;
     }
 
   if (mode)
@@ -2060,17 +2060,17 @@ Array<T>::is_sorted_rows (sortmode mode)
 
   if (r <= 1 || c == 0)
     return mode ? mode : ASCENDING;
 
   if (! mode)
     {
       // Auto-detect mode.
       compare_fcn_type compare
-	= safe_comparator (ASCENDING, *this, false);
+        = safe_comparator (ASCENDING, *this, false);
 
       octave_idx_type i;
       for (i = 0; i < cols (); i++)
         {
           T l = elem (0, i), u = elem (rows () - 1, i);
           if (compare (l, u))
             {
               if (mode == DESCENDING)
@@ -2473,82 +2473,82 @@ Array<T>::diag (octave_idx_type k) const
   if (nd > 2)
     (*current_liboctave_error_handler) ("Matrix must be 2-dimensional");    
   else
     {
       octave_idx_type nnr = dv (0);
       octave_idx_type nnc = dv (1);
 
       if (nnr == 0 || nnc == 0)
-	; // do nothing
+        ; // do nothing
       else if (nnr != 1 && nnc != 1)
-	{
-	  if (k > 0)
-	    nnc -= k;
-	  else if (k < 0)
-	    nnr += k;
-
-	  if (nnr > 0 && nnc > 0)
-	    {
-	      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
-
-	      d.resize (dim_vector (ndiag, 1));
-
-	      if (k > 0)
-		{
-		  for (octave_idx_type i = 0; i < ndiag; i++)
-		    d.xelem (i) = elem (i, i+k);
-		}
-	      else if (k < 0)
-		{
-		  for (octave_idx_type i = 0; i < ndiag; i++)
-		    d.xelem (i) = elem (i-k, i);
-		}
-	      else
-		{
-		  for (octave_idx_type i = 0; i < ndiag; i++)
-		    d.xelem (i) = elem (i, i);
-		}
-	    }
-	  else
-	    (*current_liboctave_error_handler)
-	      ("diag: requested diagonal out of range");
-	}
+        {
+          if (k > 0)
+            nnc -= k;
+          else if (k < 0)
+            nnr += k;
+
+          if (nnr > 0 && nnc > 0)
+            {
+              octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
+
+              d.resize (dim_vector (ndiag, 1));
+
+              if (k > 0)
+                {
+                  for (octave_idx_type i = 0; i < ndiag; i++)
+                    d.xelem (i) = elem (i, i+k);
+                }
+              else if (k < 0)
+                {
+                  for (octave_idx_type i = 0; i < ndiag; i++)
+                    d.xelem (i) = elem (i-k, i);
+                }
+              else
+                {
+                  for (octave_idx_type i = 0; i < ndiag; i++)
+                    d.xelem (i) = elem (i, i);
+                }
+            }
+          else
+            (*current_liboctave_error_handler)
+              ("diag: requested diagonal out of range");
+        }
       else if (nnr != 0 && nnc != 0)
-	{
-	  octave_idx_type roff = 0;
-	  octave_idx_type coff = 0;
-	  if (k > 0)
-	    {
-	      roff = 0;
-	      coff = k;
-	    }
-	  else if (k < 0)
-	    {
-	      roff = -k;
-	      coff = 0;
-	    }
-
-	  if (nnr == 1)
-	    {
-	      octave_idx_type n = nnc + std::abs (k);
-	      d = Array<T> (dim_vector (n, n), resize_fill_value ());
-
-	      for (octave_idx_type i = 0; i < nnc; i++)
-		d.xelem (i+roff, i+coff) = elem (0, i);
-	    }
-	  else
-	    {
-	      octave_idx_type n = nnr + std::abs (k);
-	      d = Array<T> (dim_vector (n, n), resize_fill_value ());
-
-	      for (octave_idx_type i = 0; i < nnr; i++)
-		d.xelem (i+roff, i+coff) = elem (i, 0);
-	    }
-	}
+        {
+          octave_idx_type roff = 0;
+          octave_idx_type coff = 0;
+          if (k > 0)
+            {
+              roff = 0;
+              coff = k;
+            }
+          else if (k < 0)
+            {
+              roff = -k;
+              coff = 0;
+            }
+
+          if (nnr == 1)
+            {
+              octave_idx_type n = nnc + std::abs (k);
+              d = Array<T> (dim_vector (n, n), resize_fill_value ());
+
+              for (octave_idx_type i = 0; i < nnc; i++)
+                d.xelem (i+roff, i+coff) = elem (0, i);
+            }
+          else
+            {
+              octave_idx_type n = nnr + std::abs (k);
+              d = Array<T> (dim_vector (n, n), resize_fill_value ());
+
+              for (octave_idx_type i = 0; i < nnr; i++)
+                d.xelem (i+roff, i+coff) = elem (i, 0);
+            }
+        }
     }
 
   return d;
 }
 
 template <class T>
 void
 Array<T>::print_info (std::ostream& os, const std::string& prefix) const
@@ -2600,83 +2600,83 @@ operator << (std::ostream& os, const Arr
       os << "data:";
 
       Array<octave_idx_type> ra_idx (n_dims, 0);
 
       // Number of times the first 2d-array is to be displayed.
 
       octave_idx_type m = 1;
       for (int i = 2; i < n_dims; i++)
-	m *= a_dims(i);
+        m *= a_dims(i);
 
       if (m == 1)
         {
           octave_idx_type rows = 0;
           octave_idx_type cols = 0;
 
           switch (n_dims)
             {
-	    case 2:
-	      rows = a_dims(0);
-	      cols = a_dims(1);
-
-	      for (octave_idx_type j = 0; j < rows; j++)
-		{
-		  ra_idx(0) = j;
-		  for (octave_idx_type k = 0; k < cols; k++)
-		    {
-		      ra_idx(1) = k;
-		      os << " " << a.elem(ra_idx);
-		    }
-		  os << "\n";
-		}
-	      break;
-
-	    default:
-	      rows = a_dims(0);
-
-	      for (octave_idx_type k = 0; k < rows; k++)
-		{
-		  ra_idx(0) = k;
-		  os << " " << a.elem(ra_idx);
-		}
-	      break;
-	    }
+            case 2:
+              rows = a_dims(0);
+              cols = a_dims(1);
+
+              for (octave_idx_type j = 0; j < rows; j++)
+                {
+                  ra_idx(0) = j;
+                  for (octave_idx_type k = 0; k < cols; k++)
+                    {
+                      ra_idx(1) = k;
+                      os << " " << a.elem(ra_idx);
+                    }
+                  os << "\n";
+                }
+              break;
+
+            default:
+              rows = a_dims(0);
+
+              for (octave_idx_type k = 0; k < rows; k++)
+                {
+                  ra_idx(0) = k;
+                  os << " " << a.elem(ra_idx);
+                }
+              break;
+            }
 
           os << "\n";
         }
       else
         {
           octave_idx_type rows = a_dims(0);
           octave_idx_type cols = a_dims(1);
 
           for (int i = 0; i < m; i++)
             {
               os << "\n(:,:,";
 
               for (int j = 2; j < n_dims - 1; j++)
-		os << ra_idx(j) + 1 << ",";
-
-	      os << ra_idx(n_dims - 1) + 1 << ") = \n";
-
-	      for (octave_idx_type j = 0; j < rows; j++)
-	        {
-	          ra_idx(0) = j;
-
-	          for (octave_idx_type k = 0; k < cols; k++)
-	            {
-		      ra_idx(1) = k;
-		      os << " " << a.elem(ra_idx);
-		    }
-
-	          os << "\n";
-	        }
-
-	      os << "\n";
-
-	      if (i != m - 1)
-		increment_index (ra_idx, a_dims, 2);
+                os << ra_idx(j) + 1 << ",";
+
+              os << ra_idx(n_dims - 1) + 1 << ") = \n";
+
+              for (octave_idx_type j = 0; j < rows; j++)
+                {
+                  ra_idx(0) = j;
+
+                  for (octave_idx_type k = 0; k < cols; k++)
+                    {
+                      ra_idx(1) = k;
+                      os << " " << a.elem(ra_idx);
+                    }
+
+                  os << "\n";
+                }
+
+              os << "\n";
+
+              if (i != m - 1)
+                increment_index (ra_idx, a_dims, 2);
             }
         }
     }
 
   return os;
 }
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -37,20 +37,20 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgemv, ZGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const Complex&,
-			   const Complex*, const octave_idx_type&, const Complex*,
-			   const octave_idx_type&, const Complex&, Complex*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, const octave_idx_type&, const Complex&,
+                           const Complex*, const octave_idx_type&, const Complex*,
+                           const octave_idx_type&, const Complex&, Complex*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL);
 }
 
 // Complex Column Vector class
 
 ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
    : MArray<Complex> (a.length ())
 {
   for (octave_idx_type i = 0; i < length (); i++)
@@ -85,17 +85,17 @@ ComplexColumnVector::insert (const Colum
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i) = a.elem (i);
+        xelem (r+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::insert (const ComplexColumnVector& a, octave_idx_type r)
 {
@@ -107,49 +107,49 @@ ComplexColumnVector::insert (const Compl
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i) = a.elem (i);
+        xelem (r+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (double val)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (const Complex& val)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (double val, octave_idx_type r1, octave_idx_type r2)
@@ -164,17 +164,17 @@ ComplexColumnVector::fill (double val, o
 
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
 
   if (r2 >= r1)
     {
       make_unique ();
 
       for (octave_idx_type i = r1; i <= r2; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (const Complex& val, octave_idx_type r1, octave_idx_type r2)
 {
@@ -188,17 +188,17 @@ ComplexColumnVector::fill (const Complex
 
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
 
   if (r2 >= r1)
     {
       make_unique ();
 
       for (octave_idx_type i = r1; i <= r2; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexColumnVector
 ComplexColumnVector::stack (const ColumnVector& a) const
 {
@@ -461,18 +461,18 @@ ComplexColumnVector::min (void) const
     return 0.0;
 
   Complex res = elem (0);
   double absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) < absres)
       {
-	res = elem (i);
-	absres = std::abs (res);
+        res = elem (i);
+        absres = std::abs (res);
       }
 
   return res;
 }
 
 Complex
 ComplexColumnVector::max (void) const
 {
@@ -481,18 +481,18 @@ ComplexColumnVector::max (void) const
     return 0.0;
 
   Complex res = elem (0);
   double absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) > absres)
       {
-	res = elem (i);
-	absres = std::abs (res);
+        res = elem (i);
+        absres = std::abs (res);
       }
 
   return res;
 }
 
 // i/o
 
 std::ostream&
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -245,17 +245,17 @@ ComplexDiagMatrix::abs (void) const
 
 ComplexDiagMatrix
 conj (const ComplexDiagMatrix& a)
 {
   ComplexDiagMatrix retval;
   octave_idx_type a_len = a.length ();
   if (a_len > 0)
     retval = ComplexDiagMatrix (mx_inline_conj_dup (a.data (), a_len),
-				a.rows (), a.cols ());
+                                a.rows (), a.cols ());
   return retval;
 }
 
 // resize is the destructive analog for this one
 
 ComplexMatrix
 ComplexDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
@@ -373,22 +373,22 @@ ComplexDiagMatrix::inverse (octave_idx_t
     }
 
   ComplexDiagMatrix retval (r, c);
 
   info = 0;
   for (octave_idx_type i = 0; i < length (); i++)
     {
       if (elem (i, i) == 0.0)
-	{
-	  info = -1;
-	  return *this;
-	}
+        {
+          info = -1;
+          return *this;
+        }
       else
-	retval.elem (i, i) = 1.0 / elem (i, i);
+        retval.elem (i, i) = 1.0 / elem (i, i);
     }
 
   return retval;
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::pseudo_inverse (void) const
 {
@@ -565,18 +565,18 @@ ComplexDiagMatrix::rcond (void) const
 std::ostream&
 operator << (std::ostream& os, const ComplexDiagMatrix& a)
 {
   Complex ZERO (0.0);
 //  int field_width = os.precision () + 7;
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
-	{
-	  if (i == j)
-	    os << " " /* setw (field_width) */ << a.elem (i, i);
-	  else
-	    os << " " /* setw (field_width) */ << ZERO;
-	}
+        {
+          if (i == j)
+            os << " " /* setw (field_width) */ << a.elem (i, i);
+          else
+            os << " " /* setw (field_width) */ << ZERO;
+        }
       os << "\n";
     }
   return os;
 }
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -61,176 +61,176 @@ along with Octave; see the file COPYING.
 #include "oct-norm.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (xilaenv, XILAENV) (const octave_idx_type&, F77_CONST_CHAR_ARG_DECL,
-			       F77_CONST_CHAR_ARG_DECL,
-			       const octave_idx_type&, const octave_idx_type&,
-			       const octave_idx_type&, const octave_idx_type&,
-			       octave_idx_type&
-			       F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
+                               F77_CONST_CHAR_ARG_DECL,
+                               const octave_idx_type&, const octave_idx_type&,
+                               const octave_idx_type&, const octave_idx_type&,
+                               octave_idx_type&
+                               F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgebal, ZGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&,
-			     octave_idx_type&, double*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&,
+                             octave_idx_type&, double*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgebak, DGEBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
-			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
+                             const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgemm, ZGEMM) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			   const Complex&, const Complex*, const octave_idx_type&,
-			   const Complex*, const octave_idx_type&, const Complex&,
-			   Complex*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+                           const Complex&, const Complex*, const octave_idx_type&,
+                           const Complex*, const octave_idx_type&, const Complex&,
+                           Complex*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgemv, ZGEMV) (F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, const octave_idx_type&, const Complex&,
                            const Complex*, const octave_idx_type&, const Complex*,
                            const octave_idx_type&, const Complex&, Complex*, const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xzdotu, XZDOTU) (const octave_idx_type&, const Complex*, const octave_idx_type&,
-			     const Complex*, const octave_idx_type&, Complex&);
+                             const Complex*, const octave_idx_type&, Complex&);
 
   F77_RET_T
   F77_FUNC (xzdotc, XZDOTC) (const octave_idx_type&, const Complex*, const octave_idx_type&,
-			     const Complex*, const octave_idx_type&, Complex&);
+                             const Complex*, const octave_idx_type&, Complex&);
 
   F77_RET_T
   F77_FUNC (zsyrk, ZSYRK) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, 
-			   const Complex&, const Complex*, const octave_idx_type&,
-			   const Complex&, Complex*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, const octave_idx_type&, 
+                           const Complex&, const Complex*, const octave_idx_type&,
+                           const Complex&, Complex*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zherk, ZHERK) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, 
-			   const double&, const Complex*, const octave_idx_type&,
-			   const double&, Complex*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, const octave_idx_type&, 
+                           const double&, const Complex*, const octave_idx_type&,
+                           const double&, Complex*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgetrf, ZGETRF) (const octave_idx_type&, const octave_idx_type&, Complex*, const octave_idx_type&,
-			     octave_idx_type*, octave_idx_type&);
+                             octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgetrs, ZGETRS) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, Complex*, const octave_idx_type&,
-			     const octave_idx_type*, Complex*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const octave_idx_type&, Complex*, const octave_idx_type&,
+                             const octave_idx_type*, Complex*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgetri, ZGETRI) (const octave_idx_type&, Complex*, const octave_idx_type&, const octave_idx_type*,
-			     Complex*, const octave_idx_type&, octave_idx_type&);
+                             Complex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgecon, ZGECON) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, Complex*, 
-			     const octave_idx_type&, const double&, double&, 
-			     Complex*, double*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, Complex*, 
+                             const octave_idx_type&, const double&, double&, 
+                             Complex*, double*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgelsy, ZGELSY) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     Complex*, const octave_idx_type&, Complex*,
-			     const octave_idx_type&, octave_idx_type*, double&, octave_idx_type&,
-			     Complex*, const octave_idx_type&, double*, octave_idx_type&);
+                             Complex*, const octave_idx_type&, Complex*,
+                             const octave_idx_type&, octave_idx_type*, double&, octave_idx_type&,
+                             Complex*, const octave_idx_type&, double*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgelsd, ZGELSD) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     Complex*, const octave_idx_type&, Complex*,
-			     const octave_idx_type&, double*, double&, octave_idx_type&,
-			     Complex*, const octave_idx_type&, double*, 
-			     octave_idx_type*, octave_idx_type&);
+                             Complex*, const octave_idx_type&, Complex*,
+                             const octave_idx_type&, double*, double&, octave_idx_type&,
+                             Complex*, const octave_idx_type&, double*, 
+                             octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zpotrf, ZPOTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     Complex*, const octave_idx_type&, 
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             Complex*, const octave_idx_type&, 
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zpocon, ZPOCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     Complex*, const octave_idx_type&, const double&,
-			     double&, Complex*, double*,
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             Complex*, const octave_idx_type&, const double&,
+                             double&, Complex*, double*,
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zpotrs, ZPOTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, const Complex*, 
-			     const octave_idx_type&, Complex*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const Complex*, 
+                             const octave_idx_type&, Complex*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ztrtri, ZTRTRI) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
-			     const octave_idx_type&, const Complex*, 
-			     const octave_idx_type&, octave_idx_type& 
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const Complex*, 
+                             const octave_idx_type&, octave_idx_type& 
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ztrcon, ZTRCON) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
-			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const Complex*, const octave_idx_type&, double&,
-			     Complex*, double*, octave_idx_type& 
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+                             const Complex*, const octave_idx_type&, double&,
+                             Complex*, double*, octave_idx_type& 
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ztrtrs, ZTRTRS) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
-			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, const Complex*, 
-			     const octave_idx_type&, Complex*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+                             const octave_idx_type&, const Complex*, 
+                             const octave_idx_type&, Complex*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zlartg, ZLARTG) (const Complex&, const Complex&,
-			     double&, Complex&, Complex&);
+                             double&, Complex&, Complex&);
 
   F77_RET_T
   F77_FUNC (ztrsyl, ZTRSYL) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     const Complex*, const octave_idx_type&,
-			     const Complex*, const octave_idx_type&,
-			     const Complex*, const octave_idx_type&, double&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+                             const Complex*, const octave_idx_type&,
+                             const Complex*, const octave_idx_type&,
+                             const Complex*, const octave_idx_type&, double&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xzlange, XZLANGE) (F77_CONST_CHAR_ARG_DECL,
-			       const octave_idx_type&, const octave_idx_type&, const Complex*,
-			       const octave_idx_type&, double*, double&
-			       F77_CHAR_ARG_LEN_DECL);
+                               const octave_idx_type&, const octave_idx_type&, const Complex*,
+                               const octave_idx_type&, double*, double&
+                               F77_CHAR_ARG_LEN_DECL);
 }
 
 static const Complex Complex_NaN_result (octave_NaN, octave_NaN);
 
 // Complex Matrix class
 
 ComplexMatrix::ComplexMatrix (const Matrix& a)
   : MArray2<Complex> (a.rows (), a.cols ())
@@ -327,19 +327,19 @@ bool
 ComplexMatrix::is_hermitian (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (is_square () && nr > 0)
     {
       for (octave_idx_type i = 0; i < nr; i++)
-	for (octave_idx_type j = i; j < nc; j++)
-	  if (elem (i, j) != conj (elem (j, i)))
-	    return false;
+        for (octave_idx_type j = i; j < nc; j++)
+          if (elem (i, j) != conj (elem (j, i)))
+            return false;
 
       return true;
     }
 
   return false;
 }
 
 // destructive insert/delete/reorder operations
@@ -356,18 +356,18 @@ ComplexMatrix::insert (const Matrix& a, 
       return *this;
     }
 
   if (a_nr >0 && a_nc > 0)
     {
       make_unique ();
 
       for (octave_idx_type j = 0; j < a_nc; j++)
-	for (octave_idx_type i = 0; i < a_nr; i++)
-	  xelem (r+i, c+j) = a.elem (i, j);
+        for (octave_idx_type i = 0; i < a_nr; i++)
+          xelem (r+i, c+j) = a.elem (i, j);
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const RowVector& a, octave_idx_type r, octave_idx_type c)
 {
@@ -379,17 +379,17 @@ ComplexMatrix::insert (const RowVector& 
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r, c+i) = a.elem (i);
+        xelem (r, c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ColumnVector& a, octave_idx_type r, octave_idx_type c)
 {
@@ -401,17 +401,17 @@ ComplexMatrix::insert (const ColumnVecto
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i, c) = a.elem (i);
+        xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const DiagMatrix& a, octave_idx_type r, octave_idx_type c)
 {
@@ -428,17 +428,17 @@ ComplexMatrix::insert (const DiagMatrix&
 
   octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i, c+i) = a.elem (i, i);
+        xelem (r+i, c+i) = a.elem (i, i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexMatrix& a, octave_idx_type r, octave_idx_type c)
 {
@@ -473,17 +473,17 @@ ComplexMatrix::insert (const ComplexColu
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i, c) = a.elem (i);
+        xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexDiagMatrix& a, octave_idx_type r, octave_idx_type c)
 {
@@ -500,53 +500,53 @@ ComplexMatrix::insert (const ComplexDiag
 
   octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i, c+i) = a.elem (i, i);
+        xelem (r+i, c+i) = a.elem (i, i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::fill (double val)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       make_unique ();
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  xelem (i, j) = val;
+        for (octave_idx_type i = 0; i < nr; i++)
+          xelem (i, j) = val;
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::fill (const Complex& val)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       make_unique ();
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  xelem (i, j) = val;
+        for (octave_idx_type i = 0; i < nr; i++)
+          xelem (i, j) = val;
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::fill (double val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
 {
@@ -563,18 +563,18 @@ ComplexMatrix::fill (double val, octave_
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (r2 >= r1 && c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type j = c1; j <= c2; j++)
-	for (octave_idx_type i = r1; i <= r2; i++)
-	  xelem (i, j) = val;
+        for (octave_idx_type i = r1; i <= r2; i++)
+          xelem (i, j) = val;
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::fill (const Complex& val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
 {
@@ -591,18 +591,18 @@ ComplexMatrix::fill (const Complex& val,
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (r2 >= r1 && c2 >=c1)
     {
       make_unique ();
 
       for (octave_idx_type j = c1; j <= c2; j++)
-	for (octave_idx_type i = r1; i <= r2; i++)
-	  xelem (i, j) = val;
+        for (octave_idx_type i = r1; i <= r2; i++)
+          xelem (i, j) = val;
     }
 
   return *this;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const Matrix& a) const
 {
@@ -750,17 +750,17 @@ ComplexMatrix::append (const ComplexDiag
 ComplexMatrix
 ComplexMatrix::stack (const Matrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -769,17 +769,17 @@ ComplexMatrix::stack (const Matrix& a) c
 ComplexMatrix
 ComplexMatrix::stack (const RowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -788,17 +788,17 @@ ComplexMatrix::stack (const RowVector& a
 ComplexMatrix
 ComplexMatrix::stack (const ColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.length (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -807,17 +807,17 @@ ComplexMatrix::stack (const ColumnVector
 ComplexMatrix
 ComplexMatrix::stack (const DiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -826,17 +826,17 @@ ComplexMatrix::stack (const DiagMatrix& 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -845,17 +845,17 @@ ComplexMatrix::stack (const ComplexMatri
 ComplexMatrix
 ComplexMatrix::stack (const ComplexRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -864,17 +864,17 @@ ComplexMatrix::stack (const ComplexRowVe
 ComplexMatrix
 ComplexMatrix::stack (const ComplexColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.length (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -883,17 +883,17 @@ ComplexMatrix::stack (const ComplexColum
 ComplexMatrix
 ComplexMatrix::stack (const ComplexDiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -966,17 +966,17 @@ ComplexMatrix::inverse (octave_idx_type&
 {
   double rcon;
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (octave_idx_type& info, double& rcon, int force,
-			int calc_cond) const
+                        int calc_cond) const
 {
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, force, calc_cond);
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (MatrixType &mattype) const
 {
@@ -989,17 +989,17 @@ ComplexMatrix
 ComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info) const
 {
   double rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::tinverse (MatrixType &mattype, octave_idx_type& info,
-			 double& rcon, int force, int calc_cond) const
+                         double& rcon, int force, int calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -1007,56 +1007,56 @@ ComplexMatrix::tinverse (MatrixType &mat
     {
       int typ = mattype.type ();
       char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
       char udiag = 'N';
       retval = *this;
       Complex *tmp_data = retval.fortran_vec ();
 
       F77_XFCN (ztrtri, ZTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
-				 F77_CONST_CHAR_ARG2 (&udiag, 1),
-				 nr, tmp_data, nr, info 
-				 F77_CHAR_ARG_LEN (1)
-				 F77_CHAR_ARG_LEN (1)));
+                                 F77_CONST_CHAR_ARG2 (&udiag, 1),
+                                 nr, tmp_data, nr, info 
+                                 F77_CHAR_ARG_LEN (1)
+                                 F77_CHAR_ARG_LEN (1)));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0) 
-	info = -1;
+        info = -1;
       else if (calc_cond) 
-	{
-	  octave_idx_type ztrcon_info = 0;
-	  char job = '1';
-
-	  OCTAVE_LOCAL_BUFFER (Complex, cwork, 2*nr);
-	  OCTAVE_LOCAL_BUFFER (double, rwork, nr);
-
-	  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     F77_CONST_CHAR_ARG2 (&uplo, 1),
-				     F77_CONST_CHAR_ARG2 (&udiag, 1),
-				     nr, tmp_data, nr, rcon, 
-				     cwork, rwork, ztrcon_info 
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (ztrcon_info != 0) 
-	    info = -1;
-	}
+        {
+          octave_idx_type ztrcon_info = 0;
+          char job = '1';
+
+          OCTAVE_LOCAL_BUFFER (Complex, cwork, 2*nr);
+          OCTAVE_LOCAL_BUFFER (double, rwork, nr);
+
+          F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&udiag, 1),
+                                     nr, tmp_data, nr, rcon, 
+                                     cwork, rwork, ztrcon_info 
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (ztrcon_info != 0) 
+            info = -1;
+        }
 
       if (info == -1 && ! force)
-	retval = *this; // Restore matrix contents.
+        retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
-			 double& rcon, int force, int calc_cond) const
+                         double& rcon, int force, int calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -1069,106 +1069,106 @@ ComplexMatrix::finverse (MatrixType &mat
       Complex *tmp_data = retval.fortran_vec ();
 
       Array<Complex> z(1);
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
       F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt, 
-				 z.fortran_vec (), lwork, info));
+                                 z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real(z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
       z.resize (lwork);
       Complex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm;
       if (calc_cond)
-	anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+        anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0) 
-	info = -1;
+        info = -1;
       else if (calc_cond) 
-	{
-	  // Now calculate the condition number for non-singular matrix.
-	  octave_idx_type zgecon_info = 0;
-	  char job = '1';
-	  Array<double> rz (2 * nc);
-	  double *prz = rz.fortran_vec ();
-	  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nc, tmp_data, nr, anorm, 
-				     rcon, pz, prz, zgecon_info
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (zgecon_info != 0) 
-	    info = -1;
-	}
+        {
+          // Now calculate the condition number for non-singular matrix.
+          octave_idx_type zgecon_info = 0;
+          char job = '1';
+          Array<double> rz (2 * nc);
+          double *prz = rz.fortran_vec ();
+          F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nc, tmp_data, nr, anorm, 
+                                     rcon, pz, prz, zgecon_info
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (zgecon_info != 0) 
+            info = -1;
+        }
 
       if (info == -1 && ! force)
-	retval = *this;  // Restore contents.
+        retval = *this;  // Restore contents.
       else
-	{
-	  octave_idx_type zgetri_info = 0;
-
-	  F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
-				     pz, lwork, zgetri_info));
-
-	  if (zgetri_info != 0) 
-	    info = -1;
-	}
+        {
+          octave_idx_type zgetri_info = 0;
+
+          F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
+                                     pz, lwork, zgetri_info));
+
+          if (zgetri_info != 0) 
+            info = -1;
+        }
 
       if (info != 0)
-	mattype.mark_as_rectangular();
+        mattype.mark_as_rectangular();
     }
   
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
-			double& rcon, int force, int calc_cond) const
+                        double& rcon, int force, int calc_cond) const
 {
   int typ = mattype.type (false);
   ComplexMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
     ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
-	{
-	  ComplexCHOL chol (*this, info, calc_cond);
-	  if (info == 0)
-	    {
-	      if (calc_cond)
-		rcon = chol.rcond();
-	      else
-		rcon = 1.0;
-	      ret = chol.inverse ();
-	    }
-	  else
-	    mattype.mark_as_unsymmetric ();
-	}
+        {
+          ComplexCHOL chol (*this, info, calc_cond);
+          if (info == 0)
+            {
+              if (calc_cond)
+                rcon = chol.rcond();
+              else
+                rcon = 1.0;
+              ret = chol.inverse ();
+            }
+          else
+            mattype.mark_as_unsymmetric ();
+        }
 
       if (!mattype.is_hermitian ())
-	ret = finverse(mattype, info, rcon, force, calc_cond);
+        ret = finverse(mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
-	ret = ComplexMatrix (rows (), columns (), Complex (octave_Inf, 0.));
+        ret = ComplexMatrix (rows (), columns (), Complex (octave_Inf, 0.));
     }
 
   return ret;
 }
 
 ComplexMatrix
 ComplexMatrix::pseudo_inverse (double tol) const
 {
@@ -1184,19 +1184,19 @@ ComplexMatrix::pseudo_inverse (double to
 
   octave_idx_type r = sigma.length () - 1;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
-	tol = nr * sigma.elem (0) * DBL_EPSILON;
+        tol = nr * sigma.elem (0) * DBL_EPSILON;
       else
-	tol = nc * sigma.elem (0) * DBL_EPSILON;
+        tol = nc * sigma.elem (0) * DBL_EPSILON;
     }
 
   while (r >= 0 && sigma.elem (r) < tol)
     r--;
 
   if (r < 0)
     retval = ComplexMatrix (nc, nr, 0.0);
   else
@@ -1452,22 +1452,22 @@ ComplexMatrix::fourier2d (void) const
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
-	prow[i] = tmp_data[i*nr + j];
+        prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
-	tmp_data[i*nr + j] = prow[i];
+        tmp_data[i*nr + j] = prow[i];
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier2d (void) const
 {
@@ -1521,22 +1521,22 @@ ComplexMatrix::ifourier2d (void) const
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
-	prow[i] = tmp_data[i*nr + j];
+        prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
-	tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
+        tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
     }
 
   return retval;
 }
 
 #endif
 
 ComplexDET
@@ -1559,17 +1559,17 @@ ComplexMatrix::determinant (octave_idx_t
 {
   MatrixType mattype (*this);
   return determinant (mattype, info, rcon, calc_cond);
 }
 
 ComplexDET
 ComplexMatrix::determinant (MatrixType& mattype,
                             octave_idx_type& info, double& rcon,
-			    int calc_cond) const
+                            int calc_cond) const
 {
   ComplexDET retval (1.0);
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
@@ -1714,367 +1714,367 @@ ComplexMatrix::rcond (MatrixType &mattyp
     (*current_liboctave_error_handler) ("matrix must be square");
   else if (nr == 0 || nc == 0)
     rcon = octave_Inf;
   else
     {
       int typ = mattype.type ();
 
       if (typ == MatrixType::Unknown)
-	typ = mattype.type (*this);
+        typ = mattype.type (*this);
 
       // Only calculate the condition number for LU/Cholesky
       if (typ == MatrixType::Upper)
-	{
-	  const Complex *tmp_data = fortran_vec ();
-	  octave_idx_type info = 0;
-	  char norm = '1';
-	  char uplo = 'U';
-	  char dia = 'N';
-
-	  Array<Complex> z (2 * nc);
-	  Complex *pz = z.fortran_vec ();
-	  Array<double> rz (nc);
-	  double *prz = rz.fortran_vec ();
-
-	  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-				     F77_CONST_CHAR_ARG2 (&dia, 1), 
-				     nr, tmp_data, nr, rcon,
-				     pz, prz, info
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (info != 0) 
-	    rcon = 0;
-	}
+        {
+          const Complex *tmp_data = fortran_vec ();
+          octave_idx_type info = 0;
+          char norm = '1';
+          char uplo = 'U';
+          char dia = 'N';
+
+          Array<Complex> z (2 * nc);
+          Complex *pz = z.fortran_vec ();
+          Array<double> rz (nc);
+          double *prz = rz.fortran_vec ();
+
+          F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                     nr, tmp_data, nr, rcon,
+                                     pz, prz, info
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (info != 0) 
+            rcon = 0;
+        }
       else if  (typ == MatrixType::Permuted_Upper)
-	(*current_liboctave_error_handler)
-	  ("permuted triangular matrix not implemented");
+        (*current_liboctave_error_handler)
+          ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
-	{
-	  const Complex *tmp_data = fortran_vec ();
-	  octave_idx_type info = 0;
-	  char norm = '1';
-	  char uplo = 'L';
-	  char dia = 'N';
-
-	  Array<Complex> z (2 * nc);
-	  Complex *pz = z.fortran_vec ();
-	  Array<double> rz (nc);
-	  double *prz = rz.fortran_vec ();
-
-	  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-				     F77_CONST_CHAR_ARG2 (&dia, 1), 
-				     nr, tmp_data, nr, rcon,
-				     pz, prz, info
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (info != 0) 
-	    rcon = 0.0;
-	}
+        {
+          const Complex *tmp_data = fortran_vec ();
+          octave_idx_type info = 0;
+          char norm = '1';
+          char uplo = 'L';
+          char dia = 'N';
+
+          Array<Complex> z (2 * nc);
+          Complex *pz = z.fortran_vec ();
+          Array<double> rz (nc);
+          double *prz = rz.fortran_vec ();
+
+          F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                     nr, tmp_data, nr, rcon,
+                                     pz, prz, info
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (info != 0) 
+            rcon = 0.0;
+        }
       else if (typ == MatrixType::Permuted_Lower)
-	(*current_liboctave_error_handler)
-	  ("permuted triangular matrix not implemented");
+        (*current_liboctave_error_handler)
+          ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
-	{
-	  double anorm = -1.0;
-	  ComplexMatrix atmp = *this;
-	  Complex *tmp_data = atmp.fortran_vec ();
-
-	  if (typ == MatrixType::Hermitian)
-	    {
-	      octave_idx_type info = 0;
-	      char job = 'L';
-	      anorm = atmp.abs().sum().
-		row(static_cast<octave_idx_type>(0)).max();
-
-	      F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
-					 tmp_data, nr, info
-					 F77_CHAR_ARG_LEN (1)));
-
-	      if (info != 0) 
-		{
-		  rcon = 0.0;
-
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Full;
-		}
-	      else 
-		{
-		  Array<Complex> z (2 * nc);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> rz (nc);
-		  double *prz = rz.fortran_vec ();
-
-		  F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, tmp_data, nr, anorm,
-					     rcon, pz, prz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    rcon = 0.0;
-		}
-	    }
-
-
-	  if (typ == MatrixType::Full)
-	    {
-	      octave_idx_type info = 0;
-
-	      Array<octave_idx_type> ipvt (nr);
-	      octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	      if(anorm < 0.)
-		anorm = atmp.abs().sum().
-		  row(static_cast<octave_idx_type>(0)).max();
-
-	      Array<Complex> z (2 * nc);
-	      Complex *pz = z.fortran_vec ();
-	      Array<double> rz (2 * nc);
-	      double *prz = rz.fortran_vec ();
-
-	      F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-	      if (info != 0) 
-		{ 
-		  rcon = 0.0;
-		  mattype.mark_as_rectangular ();
-		} 
-	      else 
-		{
-		  char job = '1';
-		  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nc, tmp_data, nr, anorm, 
-					     rcon, pz, prz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    rcon = 0.0;
-		}
-	    }
-	}
+        {
+          double anorm = -1.0;
+          ComplexMatrix atmp = *this;
+          Complex *tmp_data = atmp.fortran_vec ();
+
+          if (typ == MatrixType::Hermitian)
+            {
+              octave_idx_type info = 0;
+              char job = 'L';
+              anorm = atmp.abs().sum().
+                row(static_cast<octave_idx_type>(0)).max();
+
+              F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+                                         tmp_data, nr, info
+                                         F77_CHAR_ARG_LEN (1)));
+
+              if (info != 0) 
+                {
+                  rcon = 0.0;
+
+                  mattype.mark_as_unsymmetric ();
+                  typ = MatrixType::Full;
+                }
+              else 
+                {
+                  Array<Complex> z (2 * nc);
+                  Complex *pz = z.fortran_vec ();
+                  Array<double> rz (nc);
+                  double *prz = rz.fortran_vec ();
+
+                  F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, tmp_data, nr, anorm,
+                                             rcon, pz, prz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    rcon = 0.0;
+                }
+            }
+
+
+          if (typ == MatrixType::Full)
+            {
+              octave_idx_type info = 0;
+
+              Array<octave_idx_type> ipvt (nr);
+              octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+              if(anorm < 0.)
+                anorm = atmp.abs().sum().
+                  row(static_cast<octave_idx_type>(0)).max();
+
+              Array<Complex> z (2 * nc);
+              Complex *pz = z.fortran_vec ();
+              Array<double> rz (2 * nc);
+              double *prz = rz.fortran_vec ();
+
+              F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+              if (info != 0) 
+                { 
+                  rcon = 0.0;
+                  mattype.mark_as_rectangular ();
+                } 
+              else 
+                {
+                  char job = '1';
+                  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nc, tmp_data, nr, anorm, 
+                                             rcon, pz, prz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    rcon = 0.0;
+                }
+            }
+        }
       else
-	rcon = 0.0;
+        rcon = 0.0;
     }
 
   return rcon;
 }
 
 ComplexMatrix
 ComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b, 
-			octave_idx_type& info, double& rcon, 
-			solve_singularity_handler sing_handler,
-			bool calc_cond, blas_trans_type transt) const
+                        octave_idx_type& info, double& rcon, 
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond, blas_trans_type transt) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Upper)
-	{
-	  octave_idx_type b_nc = b.cols ();
-	  rcon = 1.;
-	  info = 0;
-
-	  if (typ == MatrixType::Permuted_Upper)
-	    {
-	      (*current_liboctave_error_handler)
-		("permuted triangular matrix not implemented");
-	    }
-	  else
-	    {
-	      const Complex *tmp_data = fortran_vec ();
-
-	      if (calc_cond)
-		{
-		  char norm = '1';
-		  char uplo = 'U';
-		  char dia = 'N';
-
-		  Array<Complex> z (2 * nc);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> rz (nc);
-		  double *prz = rz.fortran_vec ();
-
-		  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcon,
-					     pz, prz, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile double rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  Complex *result = retval.fortran_vec ();
-
-		  char uplo = 'U';
-		  char trans = get_blas_char (transt);
-		  char dia = 'N';
-
-		  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&trans, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, b_nc, tmp_data, nr,
-					     result, nr, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	    }
-	}
+          typ == MatrixType::Upper)
+        {
+          octave_idx_type b_nc = b.cols ();
+          rcon = 1.;
+          info = 0;
+
+          if (typ == MatrixType::Permuted_Upper)
+            {
+              (*current_liboctave_error_handler)
+                ("permuted triangular matrix not implemented");
+            }
+          else
+            {
+              const Complex *tmp_data = fortran_vec ();
+
+              if (calc_cond)
+                {
+                  char norm = '1';
+                  char uplo = 'U';
+                  char dia = 'N';
+
+                  Array<Complex> z (2 * nc);
+                  Complex *pz = z.fortran_vec ();
+                  Array<double> rz (nc);
+                  double *prz = rz.fortran_vec ();
+
+                  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, tmp_data, nr, rcon,
+                                             pz, prz, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile double rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  Complex *result = retval.fortran_vec ();
+
+                  char uplo = 'U';
+                  char trans = get_blas_char (transt);
+                  char dia = 'N';
+
+                  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, b_nc, tmp_data, nr,
+                                             result, nr, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b, 
-			octave_idx_type& info, double& rcon, 
-			solve_singularity_handler sing_handler,
-			bool calc_cond, blas_trans_type transt) const
+                        octave_idx_type& info, double& rcon, 
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond, blas_trans_type transt) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower ||
-	  typ == MatrixType::Lower)
-	{
-	  octave_idx_type b_nc = b.cols ();
-	  rcon = 1.;
-	  info = 0;
-
-	  if (typ == MatrixType::Permuted_Lower)
-	    {
-	      (*current_liboctave_error_handler)
-		("permuted triangular matrix not implemented");
-	    }
-	  else
-	    {
-	      const Complex *tmp_data = fortran_vec ();
-
-	      if (calc_cond)
-		{
-		  char norm = '1';
-		  char uplo = 'L';
-		  char dia = 'N';
-
-		  Array<Complex> z (2 * nc);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> rz (nc);
-		  double *prz = rz.fortran_vec ();
-
-		  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcon,
-					     pz, prz, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile double rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  Complex *result = retval.fortran_vec ();
-
-		  char uplo = 'L';
-		  char trans = get_blas_char (transt);
-		  char dia = 'N';
-
-		  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&trans, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, b_nc, tmp_data, nr,
-					     result, nr, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	    }
-	}
+          typ == MatrixType::Lower)
+        {
+          octave_idx_type b_nc = b.cols ();
+          rcon = 1.;
+          info = 0;
+
+          if (typ == MatrixType::Permuted_Lower)
+            {
+              (*current_liboctave_error_handler)
+                ("permuted triangular matrix not implemented");
+            }
+          else
+            {
+              const Complex *tmp_data = fortran_vec ();
+
+              if (calc_cond)
+                {
+                  char norm = '1';
+                  char uplo = 'L';
+                  char dia = 'N';
+
+                  Array<Complex> z (2 * nc);
+                  Complex *pz = z.fortran_vec ();
+                  Array<double> rz (nc);
+                  double *prz = rz.fortran_vec ();
+
+                  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, tmp_data, nr, rcon,
+                                             pz, prz, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile double rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  Complex *result = retval.fortran_vec ();
+
+                  char uplo = 'L';
+                  char trans = get_blas_char (transt);
+                  char dia = 'N';
+
+                  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, b_nc, tmp_data, nr,
+                                             result, nr, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b, 
-		       octave_idx_type& info, double& rcon,
-		       solve_singularity_handler sing_handler,
-		       bool calc_cond) const
+                       octave_idx_type& info, double& rcon,
+                       solve_singularity_handler sing_handler,
+                       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
 
   if (nr != nc || nr != b.rows ())
@@ -2085,235 +2085,235 @@ ComplexMatrix::fsolve (MatrixType &matty
   else
     {
       volatile int typ = mattype.type ();
  
      // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
-	{
-	  info = 0;
-	  char job = 'L';
-	  ComplexMatrix atmp = *this;
-	  Complex *tmp_data = atmp.fortran_vec ();
-	  anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
-
-	  F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
-				     tmp_data, nr, info
-				     F77_CHAR_ARG_LEN (1)));
-
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcon = 0.0;
-	  if (info != 0) 
-	    {
-	      info = -2;
-
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  Array<Complex> z (2 * nc);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> rz (nc);
-		  double *prz = rz.fortran_vec ();
-
-		  F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, tmp_data, nr, anorm,
-					     rcon, pz, prz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile double rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  Complex *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  F77_XFCN (zpotrs, ZPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, b_nc, tmp_data, nr,
-					     result, b.rows(), info
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	      else
-		{
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Full;
-		}
-	    }
-	}
+        {
+          info = 0;
+          char job = 'L';
+          ComplexMatrix atmp = *this;
+          Complex *tmp_data = atmp.fortran_vec ();
+          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+
+          F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+                                     tmp_data, nr, info
+                                     F77_CHAR_ARG_LEN (1)));
+
+          // Throw-away extra info LAPACK gives so as to not change output.
+          rcon = 0.0;
+          if (info != 0) 
+            {
+              info = -2;
+
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+          else 
+            {
+              if (calc_cond)
+                {
+                  Array<Complex> z (2 * nc);
+                  Complex *pz = z.fortran_vec ();
+                  Array<double> rz (nc);
+                  double *prz = rz.fortran_vec ();
+
+                  F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, tmp_data, nr, anorm,
+                                             rcon, pz, prz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile double rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  Complex *result = retval.fortran_vec ();
+
+                  octave_idx_type b_nc = b.cols ();
+
+                  F77_XFCN (zpotrs, ZPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, b_nc, tmp_data, nr,
+                                             result, b.rows(), info
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+              else
+                {
+                  mattype.mark_as_unsymmetric ();
+                  typ = MatrixType::Full;
+                }
+            }
+        }
 
       if (typ == MatrixType::Full)
-	{
-	  info = 0;
-
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  ComplexMatrix atmp = *this;
-	  Complex *tmp_data = atmp.fortran_vec ();
-
-	  Array<Complex> z (2 * nc);
-	  Complex *pz = z.fortran_vec ();
-	  Array<double> rz (2 * nc);
-	  double *prz = rz.fortran_vec ();
-
-	  // Calculate the norm of the matrix, for later use.
-	  if (anorm < 0.)
-	    anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
-
-	  F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcon = 0.0;
-	  if (info != 0) 
-	    { 
-	      info = -2;
-
-	      if (sing_handler)
-		sing_handler (rcon);
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	      mattype.mark_as_rectangular ();
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  // Now calculate the condition number for 
-		  // non-singular matrix.
-		  char job = '1';
-		  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nc, tmp_data, nr, anorm, 
-					     rcon, pz, prz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile double rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  Complex *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  char job = 'N';
-		  F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, b_nc, tmp_data, nr,
-					     pipvt, result, b.rows(), info
-					     F77_CHAR_ARG_LEN (1))); 
-		}
-	      else
-		mattype.mark_as_rectangular ();		    
-	    }
-	}
+        {
+          info = 0;
+
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          ComplexMatrix atmp = *this;
+          Complex *tmp_data = atmp.fortran_vec ();
+
+          Array<Complex> z (2 * nc);
+          Complex *pz = z.fortran_vec ();
+          Array<double> rz (2 * nc);
+          double *prz = rz.fortran_vec ();
+
+          // Calculate the norm of the matrix, for later use.
+          if (anorm < 0.)
+            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+
+          F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+          // Throw-away extra info LAPACK gives so as to not change output.
+          rcon = 0.0;
+          if (info != 0) 
+            { 
+              info = -2;
+
+              if (sing_handler)
+                sing_handler (rcon);
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+              mattype.mark_as_rectangular ();
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  // Now calculate the condition number for 
+                  // non-singular matrix.
+                  char job = '1';
+                  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nc, tmp_data, nr, anorm, 
+                                             rcon, pz, prz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile double rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  Complex *result = retval.fortran_vec ();
+
+                  octave_idx_type b_nc = b.cols ();
+
+                  char job = 'N';
+                  F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, b_nc, tmp_data, nr,
+                                             pipvt, result, b.rows(), info
+                                             F77_CHAR_ARG_LEN (1))); 
+                }
+              else
+                mattype.mark_as_rectangular ();             
+            }
+        }
     }
   
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const Matrix& b, 
-		      octave_idx_type& info) const
+                      octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		      double& rcon) const
+                      double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
-		      double& rcon, solve_singularity_handler sing_handler,
-		      bool singular_fallback, blas_trans_type transt) const
+                      double& rcon, solve_singularity_handler sing_handler,
+                      bool singular_fallback, blas_trans_type transt) const
 {
   ComplexMatrix tmp (b);
   return solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b, 
-		      octave_idx_type& info) const
+                      octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b, 
-		      octave_idx_type& info, double& rcon) const
+                      octave_idx_type& info, double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
-		      octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler,
-		      bool singular_fallback, blas_trans_type transt) const
+                      octave_idx_type& info, double& rcon,
+                      solve_singularity_handler sing_handler,
+                      bool singular_fallback, blas_trans_type transt) const
 {
   ComplexMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
@@ -2348,64 +2348,64 @@ ComplexMatrix::solve (MatrixType &typ, c
 {
   octave_idx_type info;
   double rcon;
   return solve (typ, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
-		      octave_idx_type& info) const
+                      octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
-		      octave_idx_type& info, double& rcon) const
+                      octave_idx_type& info, double& rcon) const
 {
   return solve (typ, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
-		      octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      octave_idx_type& info, double& rcon,
+                      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   return solve (typ, ComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
-		      octave_idx_type& info) const
+                      octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
-		      octave_idx_type& info, double& rcon) const
+                      octave_idx_type& info, double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
-		      octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      octave_idx_type& info, double& rcon,
+                      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
 
   ComplexMatrix tmp (b);
   return solve (typ, tmp, info, rcon, sing_handler, transt).column(static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b) const
@@ -2425,17 +2425,17 @@ ComplexMatrix::solve (const Matrix& b, o
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   ComplexMatrix tmp (b);
   return solve (tmp, info, rcon, sing_handler, transt);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b) const
 {
@@ -2454,17 +2454,17 @@ ComplexMatrix::solve (const ComplexMatri
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b) const
 {
@@ -2477,25 +2477,25 @@ ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
   double rcon;
   return solve (ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, 
-		      double& rcon) const
+                      double& rcon) const
 {
   return solve (ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, 
-		      double& rcon, 
-		      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      double& rcon, 
+                      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   return solve (ComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b) const
 {
   octave_idx_type info;
@@ -2507,25 +2507,25 @@ ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcon;
   return solve (b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
-		      double& rcon) const
+                      double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
-		      double& rcon,
-		      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      double& rcon,
+                      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const Matrix& b) const
 {
@@ -2540,25 +2540,25 @@ ComplexMatrix::lssolve (const Matrix& b,
 {
   octave_idx_type rank;
   double rcon;
   return lssolve (ComplexMatrix (b), info, rank, rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const Matrix& b, octave_idx_type& info,
-			octave_idx_type& rank) const
+                        octave_idx_type& rank) const
 {
   double rcon;
   return lssolve (ComplexMatrix (b), info, rank, rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const Matrix& b, octave_idx_type& info,
-			octave_idx_type& rank, double& rcon) const
+                        octave_idx_type& rank, double& rcon) const
 {
   return lssolve (ComplexMatrix (b), info, rank, rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b) const
 {
   octave_idx_type info;
@@ -2572,25 +2572,25 @@ ComplexMatrix::lssolve (const ComplexMat
 {
   octave_idx_type rank;
   double rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info,
-			octave_idx_type& rank) const
+                        octave_idx_type& rank) const
 {
   double rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, 
-			octave_idx_type& rank, double& rcon) const
+                        octave_idx_type& rank, double& rcon) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2601,130 +2601,130 @@ ComplexMatrix::lssolve (const ComplexMat
     retval = ComplexMatrix (n, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
-	{
-	  retval = ComplexMatrix (maxmn, nrhs);
-
-	  for (octave_idx_type j = 0; j < nrhs; j++)
-	    for (octave_idx_type i = 0; i < m; i++)
-	      retval.elem (i, j) = b.elem (i, j);
-	}
+        {
+          retval = ComplexMatrix (maxmn, nrhs);
+
+          for (octave_idx_type j = 0; j < nrhs; j++)
+            for (octave_idx_type i = 0; i < m; i++)
+              retval.elem (i, j) = b.elem (i, j);
+        }
       else
-	retval = b;
+        retval = b;
 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       Complex *pretval = retval.fortran_vec ();
       Array<double> s (minmn);
       double *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
       Array<Complex> work (1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("ZGELSD", 6),
-				   F77_CONST_CHAR_ARG2 (" ", 1),
-				   0, 0, 0, 0, smlsiz
-				   F77_CHAR_ARG_LEN (6)
-				   F77_CHAR_ARG_LEN (1));
+                                   F77_CONST_CHAR_ARG2 (" ", 1),
+                                   0, 0, 0, 0, smlsiz
+                                   F77_CHAR_ARG_LEN (6)
+                                   F77_CHAR_ARG_LEN (1));
 
       octave_idx_type mnthr;
       F77_FUNC (xilaenv, XILAENV) (6, F77_CONST_CHAR_ARG2 ("ZGELSD", 6),
-				   F77_CONST_CHAR_ARG2 (" ", 1),
-				   m, n, nrhs, -1, mnthr
-				   F77_CHAR_ARG_LEN (6)
-				   F77_CHAR_ARG_LEN (1));
+                                   F77_CONST_CHAR_ARG2 (" ", 1),
+                                   m, n, nrhs, -1, mnthr
+                                   F77_CHAR_ARG_LEN (6)
+                                   F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
 #if defined (HAVE_LOG2)
       double tmp = log2 (dminmn / dsmlsizp1);
 #else
       double tmp = log (dminmn / dsmlsizp1) / log (2.0);
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
-	nlvl = 0;
+        nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
-	+ 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
+        + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
-	lrwork = 1;
+        lrwork = 1;
       Array<double> rwork (lrwork);
       double *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
-	liwork = 1;
+        liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcon, rank, work.fortran_vec (),
-				 lwork, prwork, piwork, info));
+                                 ps, rcon, rank, work.fortran_vec (),
+                                 lwork, prwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for ZGELSD to operate
       // efficiently.
       if (n >= mnthr)
-	{
-	  octave_idx_type addend = m;
-
-	  if (2*m-4 > addend)
-	    addend = 2*m-4;
-
-	  if (nrhs > addend)
-	    addend = nrhs;
-
-	  if (n-3*m > addend)
-	    addend = n-3*m;
-
-	  const octave_idx_type lworkaround = 4*m + m*m + addend;
-
-	  if (std::real (work(0)) < lworkaround)
-	    work(0) = lworkaround;
-	}
+        {
+          octave_idx_type addend = m;
+
+          if (2*m-4 > addend)
+            addend = 2*m-4;
+
+          if (nrhs > addend)
+            addend = nrhs;
+
+          if (n-3*m > addend)
+            addend = n-3*m;
+
+          const octave_idx_type lworkaround = 4*m + m*m + addend;
+
+          if (std::real (work(0)) < lworkaround)
+            work(0) = lworkaround;
+        }
       else if (m >= n)
-	{
-	  octave_idx_type lworkaround = 2*m + m*nrhs;
-
-	  if (std::real (work(0)) < lworkaround)
-	    work(0) = lworkaround;
-	}
+        {
+          octave_idx_type lworkaround = 2*m + m*nrhs;
+
+          if (std::real (work(0)) < lworkaround)
+            work(0) = lworkaround;
+        }
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (lwork);
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcon, rank,
-				 work.fortran_vec (), lwork, 
-				 prwork, piwork, info));
+                                 maxmn, ps, rcon, rank,
+                                 work.fortran_vec (), lwork, 
+                                 prwork, piwork, info));
 
       if (rank < minmn)
-	(*current_liboctave_warning_handler) 
-	  ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
-	   m, n, rank, rcon);
+        (*current_liboctave_warning_handler) 
+          ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
+           m, n, rank, rcon);
 
       if (s.elem (0) == 0.0)
-	rcon = 0.0;
+        rcon = 0.0;
       else
-	rcon = s.elem (minmn - 1) / s.elem (0);
+        rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 ComplexColumnVector
@@ -2741,25 +2741,25 @@ ComplexMatrix::lssolve (const ColumnVect
 {
   octave_idx_type rank;
   double rcon;
   return lssolve (ComplexColumnVector (b), info, rank, rcon);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info, 
-			octave_idx_type& rank) const
+                        octave_idx_type& rank) const
 {
   double rcon;
   return lssolve (ComplexColumnVector (b), info, rank, rcon);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info, 
-			octave_idx_type& rank, double& rcon) const
+                        octave_idx_type& rank, double& rcon) const
 {
   return lssolve (ComplexColumnVector (b), info, rank, rcon);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b) const
 {
   octave_idx_type info;
@@ -2773,26 +2773,26 @@ ComplexMatrix::lssolve (const ComplexCol
 {
   octave_idx_type rank;
   double rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank) const
+                        octave_idx_type& rank) const
 {
   double rcon;
   return lssolve (b, info, rank, rcon);
 
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank, double& rcon) const
+                        octave_idx_type& rank, double& rcon) const
 {
   ComplexColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2803,99 +2803,99 @@ ComplexMatrix::lssolve (const ComplexCol
     retval = ComplexColumnVector (n, Complex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
-	{
-	  retval = ComplexColumnVector (maxmn);
-
-	  for (octave_idx_type i = 0; i < m; i++)
-	    retval.elem (i) = b.elem (i);
-	}
+        {
+          retval = ComplexColumnVector (maxmn);
+
+          for (octave_idx_type i = 0; i < m; i++)
+            retval.elem (i) = b.elem (i);
+        }
       else
-	retval = b;
+        retval = b;
 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       Complex *pretval = retval.fortran_vec ();
       Array<double> s (minmn);
       double *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
       Array<Complex> work (1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("ZGELSD", 6),
-				   F77_CONST_CHAR_ARG2 (" ", 1),
-				   0, 0, 0, 0, smlsiz
-				   F77_CHAR_ARG_LEN (6)
-				   F77_CHAR_ARG_LEN (1));
+                                   F77_CONST_CHAR_ARG2 (" ", 1),
+                                   0, 0, 0, 0, smlsiz
+                                   F77_CHAR_ARG_LEN (6)
+                                   F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
 #if defined (HAVE_LOG2)
       double tmp = log2 (dminmn / dsmlsizp1);
 #else
       double tmp = log (dminmn / dsmlsizp1) / log (2.0);
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
-	nlvl = 0;
+        nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
-	+ 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
+        + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
-	lrwork = 1;
+        lrwork = 1;
       Array<double> rwork (lrwork);
       double *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
-	liwork = 1;
+        liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcon, rank, work.fortran_vec (),
-				 lwork, prwork, piwork, info));
+                                 ps, rcon, rank, work.fortran_vec (),
+                                 lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (lwork);
       rwork.resize (static_cast<octave_idx_type> (rwork(0)));
       iwork.resize (iwork(0));
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcon, rank,
-				 work.fortran_vec (), lwork, 
-				 prwork, piwork, info));
+                                 maxmn, ps, rcon, rank,
+                                 work.fortran_vec (), lwork, 
+                                 prwork, piwork, info));
 
       if (rank < minmn)
-	{
-	  if (rank < minmn)
-	    (*current_liboctave_warning_handler) 
-	      ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
-	       m, n, rank, rcon);
-
-	  if (s.elem (0) == 0.0)
-	    rcon = 0.0;
-	  else
-	    rcon = s.elem (minmn - 1) / s.elem (0);
-
-	  retval.resize (n, nrhs);
-	}
+        {
+          if (rank < minmn)
+            (*current_liboctave_warning_handler) 
+              ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
+               m, n, rank, rcon);
+
+          if (s.elem (0) == 0.0)
+            rcon = 0.0;
+          else
+            rcon = s.elem (minmn - 1) / s.elem (0);
+
+          retval.resize (n, nrhs);
+        }
     }
 
   return retval;
 }
 
 // column vector by row vector -> matrix operations
 
 ComplexMatrix
@@ -2922,21 +2922,21 @@ operator * (const ComplexColumnVector& v
   if (len != 0)
     {
       octave_idx_type a_len = a.length ();
 
       retval = ComplexMatrix (len, a_len);
       Complex *c = retval.fortran_vec ();
 
       F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
-			       F77_CONST_CHAR_ARG2 ("N", 1),
-			       len, a_len, 1, 1.0, v.data (), len,
-			       a.data (), 1, 0.0, c, len
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 ("N", 1),
+                               len, a_len, 1, 1.0, v.data (), len,
+                               a.data (), 1, 0.0, c, len
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 // matrix by diagonal matrix -> matrix operations
 
 ComplexMatrix&
@@ -3087,36 +3087,36 @@ bool
 ComplexMatrix::any_element_is_nan (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	Complex val = elem (i, j);
-	if (xisnan (val))
-	  return true;
+        Complex val = elem (i, j);
+        if (xisnan (val))
+          return true;
       }
 
   return false;
 }
 
 bool
 ComplexMatrix::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	Complex val = elem (i, j);
-	if (xisinf (val) || xisnan (val))
-	  return true;
+        Complex val = elem (i, j);
+        if (xisinf (val) || xisnan (val))
+          return true;
       }
 
   return false;
 }
 
 // Return true if no elements have imaginary components.
 
 bool
@@ -3141,70 +3141,70 @@ ComplexMatrix::all_integers (double& max
 
       double r_val = std::real (val);
       double i_val = std::imag (val);
 
       max_val = r_val;
       min_val = r_val;
 
       if (i_val > max_val)
-	max_val = i_val;
+        max_val = i_val;
 
       if (i_val < max_val)
-	min_val = i_val;
+        min_val = i_val;
     }
   else
     return false;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	Complex val = elem (i, j);
-
-	double r_val = std::real (val);
-	double i_val = std::imag (val);
-
-	if (r_val > max_val)
-	  max_val = r_val;
-
-	if (i_val > max_val)
-	  max_val = i_val;
-
-	if (r_val < min_val)
-	  min_val = r_val;
-
-	if (i_val < min_val)
-	  min_val = i_val;
-
-	if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
-	  return false;
+        Complex val = elem (i, j);
+
+        double r_val = std::real (val);
+        double i_val = std::imag (val);
+
+        if (r_val > max_val)
+          max_val = r_val;
+
+        if (i_val > max_val)
+          max_val = i_val;
+
+        if (r_val < min_val)
+          min_val = r_val;
+
+        if (i_val < min_val)
+          min_val = i_val;
+
+        if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
+          return false;
       }
 
   return true;
 }
 
 bool
 ComplexMatrix::too_large_for_float (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	Complex val = elem (i, j);
-
-	double r_val = std::real (val);
-	double i_val = std::imag (val);
-
-	if ((! (xisnan (r_val) || xisinf (r_val))
-	     && fabs (r_val) > FLT_MAX)
-	    || (! (xisnan (i_val) || xisinf (i_val))
-		&& fabs (i_val) > FLT_MAX))
-	  return true;
+        Complex val = elem (i, j);
+
+        double r_val = std::real (val);
+        double i_val = std::imag (val);
+
+        if ((! (xisnan (r_val) || xisinf (r_val))
+             && fabs (r_val) > FLT_MAX)
+            || (! (xisnan (i_val) || xisinf (i_val))
+                && fabs (i_val) > FLT_MAX))
+          return true;
       }
 
   return false;
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
@@ -3267,42 +3267,42 @@ ComplexMatrix::row_is_real_only (octave_
 {
   bool retval = true;
 
   octave_idx_type nc = columns ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       if (std::imag (elem (i, j)) != 0.0)
-	{
-	  retval = false;
-	  break;
-	}
+        {
+          retval = false;
+          break;
+        }
     }
 
-  return retval;	      
+  return retval;              
 }
 
 bool
 ComplexMatrix::column_is_real_only (octave_idx_type j) const
 {
   bool retval = true;
 
   octave_idx_type nr = rows ();
 
   for (octave_idx_type i = 0; i < nr; i++)
     {
       if (std::imag (elem (i, j)) != 0.0)
-	{
-	  retval = false;
-	  break;
-	}
+        {
+          retval = false;
+          break;
+        }
     }
 
-  return retval;	      
+  return retval;              
 }
 
 ComplexColumnVector
 ComplexMatrix::row_min (void) const
 {
   Array<octave_idx_type> dummy_idx;
   return row_min (dummy_idx);
 }
@@ -3317,62 +3317,62 @@ ComplexMatrix::row_min (Array<octave_idx
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       idx_arg.resize (nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
-	  bool real_only = row_is_real_only (i);
-
-	  octave_idx_type idx_j;
-
-	  Complex tmp_min;
-
-	  double abs_min = octave_NaN;
-
-	  for (idx_j = 0; idx_j < nc; idx_j++)
-	    {
-	      tmp_min = elem (i, idx_j);
-
-	      if (! xisnan (tmp_min))
-		{
-		  abs_min = real_only ? std::real (tmp_min) : std::abs (tmp_min);
-		  break;
-		}
-	    }
-
-	  for (octave_idx_type j = idx_j+1; j < nc; j++)
-	    {
-	      Complex tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-
-	      double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
-
-	      if (abs_tmp < abs_min)
-		{
-		  idx_j = j;
-		  tmp_min = tmp;
-		  abs_min = abs_tmp;
-		}
-	    }
-
-	  if (xisnan (tmp_min))
-	    {
-	      result.elem (i) = Complex_NaN_result;
-	      idx_arg.elem (i) = 0;
-	    }
-	  else
-	    {
-	      result.elem (i) = tmp_min;
-	      idx_arg.elem (i) = idx_j;
-	    }
+          bool real_only = row_is_real_only (i);
+
+          octave_idx_type idx_j;
+
+          Complex tmp_min;
+
+          double abs_min = octave_NaN;
+
+          for (idx_j = 0; idx_j < nc; idx_j++)
+            {
+              tmp_min = elem (i, idx_j);
+
+              if (! xisnan (tmp_min))
+                {
+                  abs_min = real_only ? std::real (tmp_min) : std::abs (tmp_min);
+                  break;
+                }
+            }
+
+          for (octave_idx_type j = idx_j+1; j < nc; j++)
+            {
+              Complex tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+
+              double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+
+              if (abs_tmp < abs_min)
+                {
+                  idx_j = j;
+                  tmp_min = tmp;
+                  abs_min = abs_tmp;
+                }
+            }
+
+          if (xisnan (tmp_min))
+            {
+              result.elem (i) = Complex_NaN_result;
+              idx_arg.elem (i) = 0;
+            }
+          else
+            {
+              result.elem (i) = tmp_min;
+              idx_arg.elem (i) = idx_j;
+            }
         }
     }
 
   return result;
 }
 
 ComplexColumnVector
 ComplexMatrix::row_max (void) const
@@ -3391,62 +3391,62 @@ ComplexMatrix::row_max (Array<octave_idx
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       idx_arg.resize (nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
-	  bool real_only = row_is_real_only (i);
-
-	  octave_idx_type idx_j;
-
-	  Complex tmp_max;
-
-	  double abs_max = octave_NaN;
-
-	  for (idx_j = 0; idx_j < nc; idx_j++)
-	    {
-	      tmp_max = elem (i, idx_j);
-
-	      if (! xisnan (tmp_max))
-		{
-		  abs_max = real_only ? std::real (tmp_max) : std::abs (tmp_max);
-		  break;
-		}
-	    }
-
-	  for (octave_idx_type j = idx_j+1; j < nc; j++)
-	    {
-	      Complex tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-
-	      double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
-
-	      if (abs_tmp > abs_max)
-		{
-		  idx_j = j;
-		  tmp_max = tmp;
-		  abs_max = abs_tmp;
-		}
-	    }
-
-	  if (xisnan (tmp_max))
-	    {
-	      result.elem (i) = Complex_NaN_result;
-	      idx_arg.elem (i) = 0;
-	    }
-	  else
-	    {
-	      result.elem (i) = tmp_max;
-	      idx_arg.elem (i) = idx_j;
-	    }
+          bool real_only = row_is_real_only (i);
+
+          octave_idx_type idx_j;
+
+          Complex tmp_max;
+
+          double abs_max = octave_NaN;
+
+          for (idx_j = 0; idx_j < nc; idx_j++)
+            {
+              tmp_max = elem (i, idx_j);
+
+              if (! xisnan (tmp_max))
+                {
+                  abs_max = real_only ? std::real (tmp_max) : std::abs (tmp_max);
+                  break;
+                }
+            }
+
+          for (octave_idx_type j = idx_j+1; j < nc; j++)
+            {
+              Complex tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+
+              double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+
+              if (abs_tmp > abs_max)
+                {
+                  idx_j = j;
+                  tmp_max = tmp;
+                  abs_max = abs_tmp;
+                }
+            }
+
+          if (xisnan (tmp_max))
+            {
+              result.elem (i) = Complex_NaN_result;
+              idx_arg.elem (i) = 0;
+            }
+          else
+            {
+              result.elem (i) = tmp_max;
+              idx_arg.elem (i) = idx_j;
+            }
         }
     }
 
   return result;
 }
 
 ComplexRowVector
 ComplexMatrix::column_min (void) const
@@ -3465,62 +3465,62 @@ ComplexMatrix::column_min (Array<octave_
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       idx_arg.resize (nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-	  bool real_only = column_is_real_only (j);
-
-	  octave_idx_type idx_i;
-
-	  Complex tmp_min;
-
-	  double abs_min = octave_NaN;
-
-	  for (idx_i = 0; idx_i < nr; idx_i++)
-	    {
-	      tmp_min = elem (idx_i, j);
-
-	      if (! xisnan (tmp_min))
-		{
-		  abs_min = real_only ? std::real (tmp_min) : std::abs (tmp_min);
-		  break;
-		}
-	    }
-
-	  for (octave_idx_type i = idx_i+1; i < nr; i++)
-	    {
-	      Complex tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-
-	      double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
-
-	      if (abs_tmp < abs_min)
-		{
-		  idx_i = i;
-		  tmp_min = tmp;
-		  abs_min = abs_tmp;
-		}
-	    }
-
-	  if (xisnan (tmp_min))
-	    {
-	      result.elem (j) = Complex_NaN_result;
-	      idx_arg.elem (j) = 0;
-	    }
-	  else
-	    {
-	      result.elem (j) = tmp_min;
-	      idx_arg.elem (j) = idx_i;
-	    }
+          bool real_only = column_is_real_only (j);
+
+          octave_idx_type idx_i;
+
+          Complex tmp_min;
+
+          double abs_min = octave_NaN;
+
+          for (idx_i = 0; idx_i < nr; idx_i++)
+            {
+              tmp_min = elem (idx_i, j);
+
+              if (! xisnan (tmp_min))
+                {
+                  abs_min = real_only ? std::real (tmp_min) : std::abs (tmp_min);
+                  break;
+                }
+            }
+
+          for (octave_idx_type i = idx_i+1; i < nr; i++)
+            {
+              Complex tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+
+              double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+
+              if (abs_tmp < abs_min)
+                {
+                  idx_i = i;
+                  tmp_min = tmp;
+                  abs_min = abs_tmp;
+                }
+            }
+
+          if (xisnan (tmp_min))
+            {
+              result.elem (j) = Complex_NaN_result;
+              idx_arg.elem (j) = 0;
+            }
+          else
+            {
+              result.elem (j) = tmp_min;
+              idx_arg.elem (j) = idx_i;
+            }
         }
     }
 
   return result;
 }
 
 ComplexRowVector
 ComplexMatrix::column_max (void) const
@@ -3539,103 +3539,103 @@ ComplexMatrix::column_max (Array<octave_
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       idx_arg.resize (nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-	  bool real_only = column_is_real_only (j);
-
-	  octave_idx_type idx_i;
-
-	  Complex tmp_max;
-
-	  double abs_max = octave_NaN;
-
-	  for (idx_i = 0; idx_i < nr; idx_i++)
-	    {
-	      tmp_max = elem (idx_i, j);
-
-	      if (! xisnan (tmp_max))
-		{
-		  abs_max = real_only ? std::real (tmp_max) : std::abs (tmp_max);
-		  break;
-		}
-	    }
-
-	  for (octave_idx_type i = idx_i+1; i < nr; i++)
-	    {
-	      Complex tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-
-	      double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
-
-	      if (abs_tmp > abs_max)
-		{
-		  idx_i = i;
-		  tmp_max = tmp;
-		  abs_max = abs_tmp;
-		}
-	    }
-
-	  if (xisnan (tmp_max))
-	    {
-	      result.elem (j) = Complex_NaN_result;
-	      idx_arg.elem (j) = 0;
-	    }
-	  else
-	    {
-	      result.elem (j) = tmp_max;
-	      idx_arg.elem (j) = idx_i;
-	    }
+          bool real_only = column_is_real_only (j);
+
+          octave_idx_type idx_i;
+
+          Complex tmp_max;
+
+          double abs_max = octave_NaN;
+
+          for (idx_i = 0; idx_i < nr; idx_i++)
+            {
+              tmp_max = elem (idx_i, j);
+
+              if (! xisnan (tmp_max))
+                {
+                  abs_max = real_only ? std::real (tmp_max) : std::abs (tmp_max);
+                  break;
+                }
+            }
+
+          for (octave_idx_type i = idx_i+1; i < nr; i++)
+            {
+              Complex tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+
+              double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+
+              if (abs_tmp > abs_max)
+                {
+                  idx_i = i;
+                  tmp_max = tmp;
+                  abs_max = abs_tmp;
+                }
+            }
+
+          if (xisnan (tmp_max))
+            {
+              result.elem (j) = Complex_NaN_result;
+              idx_arg.elem (j) = 0;
+            }
+          else
+            {
+              result.elem (j) = tmp_max;
+              idx_arg.elem (j) = idx_i;
+            }
         }
     }
 
   return result;
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const ComplexMatrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
-	{
-	  os << " ";
-	  octave_write_complex (os, a.elem (i, j));
-	}
+        {
+          os << " ";
+          octave_write_complex (os, a.elem (i, j));
+        }
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr > 0 && nc > 0)
     {
       Complex tmp;
       for (octave_idx_type i = 0; i < nr; i++)
-	for (octave_idx_type j = 0; j < nc; j++)
-	  {
-	    tmp = octave_read_value<Complex> (is);
-	    if (is)
-	      a.elem (i, j) = tmp;
-	    else
-	      goto done;
-	  }
+        for (octave_idx_type j = 0; j < nc; j++)
+          {
+            tmp = octave_read_value<Complex> (is);
+            if (is)
+              a.elem (i, j) = tmp;
+            else
+              goto done;
+          }
     }
 
 done:
 
   return is;
 }
 
 ComplexMatrix
@@ -3653,17 +3653,17 @@ Givens (const Complex& x, const Complex&
   g.elem (0, 1) = cs;
   g.elem (1, 0) = -conj (cs);
 
   return g;
 }
 
 ComplexMatrix
 Sylvester (const ComplexMatrix& a, const ComplexMatrix& b,
-	   const ComplexMatrix& c)
+           const ComplexMatrix& c)
 {
   ComplexMatrix retval;
 
   // FIXME -- need to check that a, b, and c are all the same
   // size.
 
   // Compute Schur decompositions
 
@@ -3689,21 +3689,21 @@ Sylvester (const ComplexMatrix& a, const
   double scale;
   octave_idx_type info;
 
   Complex *pa = sch_a.fortran_vec ();
   Complex *pb = sch_b.fortran_vec ();
   Complex *px = cx.fortran_vec ();
   
   F77_XFCN (ztrsyl, ZTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
-			     F77_CONST_CHAR_ARG2 ("N", 1),
-			     1, a_nr, b_nr, pa, a_nr, pb,
-			     b_nr, px, a_nr, scale, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             1, a_nr, b_nr, pa, a_nr, pb,
+                             b_nr, px, a_nr, scale, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   // FIXME -- check info?
 
   retval = -ua * cx * ub.hermitian ();
 
   return retval;
 }
 
@@ -3770,23 +3770,23 @@ xgemm (const ComplexMatrix& a, const Com
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
     gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
   else
     {
       if (a_nr == 0 || a_nc == 0 || b_nc == 0)
-	retval = ComplexMatrix (a_nr, b_nc, 0.0);
+        retval = ComplexMatrix (a_nr, b_nc, 0.0);
       else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
         {
-	  octave_idx_type lda = a.rows ();
+          octave_idx_type lda = a.rows ();
 
           retval = ComplexMatrix (a_nr, b_nc);
-	  Complex *c = retval.fortran_vec ();
+          Complex *c = retval.fortran_vec ();
 
           const char *ctra = get_blas_trans_arg (tra, cja);
           if (cja || cjb)
             {
               F77_XFCN (zherk, ZHERK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                        F77_CONST_CHAR_ARG2 (ctra, 1),
                                        a_nr, a_nc, 1.0,
                                        a.data (), lda, 0.0, c, a_nr
@@ -3807,25 +3807,25 @@ xgemm (const ComplexMatrix& a, const Com
               for (octave_idx_type j = 0; j < a_nr; j++)
                 for (octave_idx_type i = 0; i < j; i++)
                   retval.xelem (j,i) = retval.xelem (i,j);
 
             }
 
         }
       else
-	{
-	  octave_idx_type lda = a.rows (), tda = a.cols ();
-	  octave_idx_type ldb = b.rows (), tdb = b.cols ();
-
-	  retval = ComplexMatrix (a_nr, b_nc);
-	  Complex *c = retval.fortran_vec ();
-
-	  if (b_nc == 1 && a_nr == 1)
-	    {
+        {
+          octave_idx_type lda = a.rows (), tda = a.cols ();
+          octave_idx_type ldb = b.rows (), tdb = b.cols ();
+
+          retval = ComplexMatrix (a_nr, b_nc);
+          Complex *c = retval.fortran_vec ();
+
+          if (b_nc == 1 && a_nr == 1)
+            {
               if (cja == cjb)
                 {
                   F77_FUNC (xzdotu, XZDOTU) (a_nc, a.data (), 1, b.data (), 1, *c);
                   if (cja) *c = std::conj (*c);
                 }
               else if (cja)
                   F77_FUNC (xzdotc, XZDOTC) (a_nc, a.data (), 1, b.data (), 1, *c);
               else
@@ -3842,28 +3842,28 @@ xgemm (const ComplexMatrix& a, const Com
           else if (a_nr == 1 && ! cja && ! cjb)
             {
               const char *crevtrb = get_blas_trans_arg (! trb, cjb);
               F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 (crevtrb, 1),
                                        ldb, tdb, 1.0,  b.data (), ldb,
                                        a.data (), 1, 0.0, c, 1
                                        F77_CHAR_ARG_LEN (1)));
             }
-	  else
-	    {
+          else
+            {
               const char *ctra = get_blas_trans_arg (tra, cja);
               const char *ctrb = get_blas_trans_arg (trb, cjb);
-	      F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 (ctra, 1),
-				       F77_CONST_CHAR_ARG2 (ctrb, 1),
-				       a_nr, b_nc, a_nc, 1.0, a.data (),
-				       lda, b.data (), ldb, 0.0, c, a_nr
-				       F77_CHAR_ARG_LEN (1)
-				       F77_CHAR_ARG_LEN (1)));
-	    }
-	}
+              F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 (ctra, 1),
+                                       F77_CONST_CHAR_ARG2 (ctrb, 1),
+                                       a_nr, b_nc, a_nc, 1.0, a.data (),
+                                       lda, b.data (), ldb, 0.0, c, a_nr
+                                       F77_CHAR_ARG_LEN (1)
+                                       F77_CHAR_ARG_LEN (1)));
+            }
+        }
     }
 
   return retval;
 }
 
 ComplexMatrix
 operator * (const ComplexMatrix& a, const ComplexMatrix& b)
 {
@@ -3885,18 +3885,18 @@ min (const Complex& c, const ComplexMatr
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmin (c, m (i, j));
+        octave_quit ();
+        result (i, j) = xmin (c, m (i, j));
       }
 
   return result;
 }
 
 ComplexMatrix
 min (const ComplexMatrix& m, const Complex& c)
 {
@@ -3905,66 +3905,66 @@ min (const ComplexMatrix& m, const Compl
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmin (m (i, j), c);
+        octave_quit ();
+        result (i, j) = xmin (m (i, j), c);
       }
 
   return result;
 }
 
 ComplexMatrix
 min (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-	("two-arg min expecting args of same size");
+        ("two-arg min expecting args of same size");
       return ComplexMatrix ();
     }
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  octave_quit ();
-	  if (std::imag (a (i, j)) != 0.0 || std::imag (b (i, j)) != 0.0)
-	    {
-	      columns_are_real_only = 0;
-	      break;
-	    }
-	}
+        {
+          octave_quit ();
+          if (std::imag (a (i, j)) != 0.0 || std::imag (b (i, j)) != 0.0)
+            {
+              columns_are_real_only = 0;
+              break;
+            }
+        }
 
       if (columns_are_real_only)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    result (i, j) = xmin (std::real (a (i, j)), std::real (b (i, j)));
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            result (i, j) = xmin (std::real (a (i, j)), std::real (b (i, j)));
+        }
       else
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      octave_quit ();
-	      result (i, j) = xmin (a (i, j), b (i, j));
-	    }
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              octave_quit ();
+              result (i, j) = xmin (a (i, j), b (i, j));
+            }
+        }
     }
 
   return result;
 }
 
 ComplexMatrix
 max (const Complex& c, const ComplexMatrix& m)
 {
@@ -3973,18 +3973,18 @@ max (const Complex& c, const ComplexMatr
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmax (c, m (i, j));
+        octave_quit ();
+        result (i, j) = xmax (c, m (i, j));
       }
 
   return result;
 }
 
 ComplexMatrix
 max (const ComplexMatrix& m, const Complex& c)
 {
@@ -3993,69 +3993,69 @@ max (const ComplexMatrix& m, const Compl
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmax (m (i, j), c);
+        octave_quit ();
+        result (i, j) = xmax (m (i, j), c);
       }
 
   return result;
 }
 
 ComplexMatrix
 max (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-	("two-arg max expecting args of same size");
+        ("two-arg max expecting args of same size");
       return ComplexMatrix ();
     }
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  octave_quit ();
-	  if (std::imag (a (i, j)) != 0.0 || std::imag (b (i, j)) != 0.0)
-	    {
-	      columns_are_real_only = 0;
-	      break;
-	    }
-	}
+        {
+          octave_quit ();
+          if (std::imag (a (i, j)) != 0.0 || std::imag (b (i, j)) != 0.0)
+            {
+              columns_are_real_only = 0;
+              break;
+            }
+        }
 
       if (columns_are_real_only)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      octave_quit ();
-	      result (i, j) = xmax (std::real (a (i, j)), std::real (b (i, j)));
-	    }
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              octave_quit ();
+              result (i, j) = xmax (std::real (a (i, j)), std::real (b (i, j)));
+            }
+        }
       else
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      octave_quit ();
-	      result (i, j) = xmax (a (i, j), b (i, j));
-	    }
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              octave_quit ();
+              result (i, j) = xmax (a (i, j), b (i, j));
+            }
+        }
     }
 
   return result;
 }
 
 ComplexMatrix linspace (const ComplexColumnVector& x1, 
                         const ComplexColumnVector& x2, 
                         octave_idx_type n)
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -76,17 +76,17 @@ ComplexNDArray::fourier (int dim) const
 
   const Complex *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::fft (in + k * stride * n, out + k * stride * n, 
-		      n, howmany, stride, dist);
+                      n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
@@ -107,17 +107,17 @@ ComplexNDArray::ifourier (int dim) const
 
   const Complex *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::ifft (in + k * stride * n, out + k * stride * n, 
-		      n, howmany, stride, dist);
+                      n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourier2d (void) const
 {
   dim_vector dv = dims();
@@ -232,27 +232,27 @@ ComplexNDArray::fourier (int dim) const
   octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
-	{
-	  octave_quit ();
+        {
+          octave_quit ();
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    tmp[i] = elem((i + k*npts)*stride + j*dist);
+          for (octave_idx_type i = 0; i < npts; i++)
+            tmp[i] = elem((i + k*npts)*stride + j*dist);
 
-	  F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
+          F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    retval ((i + k*npts)*stride + j*dist) = tmp[i];
-	}
+          for (octave_idx_type i = 0; i < npts; i++)
+            retval ((i + k*npts)*stride + j*dist) = tmp[i];
+        }
     }
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier (int dim) const
 {
@@ -279,28 +279,28 @@ ComplexNDArray::ifourier (int dim) const
   octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
-	{
-	  octave_quit ();
+        {
+          octave_quit ();
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    tmp[i] = elem((i + k*npts)*stride + j*dist);
+          for (octave_idx_type i = 0; i < npts; i++)
+            tmp[i] = elem((i + k*npts)*stride + j*dist);
 
-	  F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
+          F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    retval ((i + k*npts)*stride + j*dist) = tmp[i] /
-	      static_cast<double> (npts);
-	}
+          for (octave_idx_type i = 0; i < npts; i++)
+            retval ((i + k*npts)*stride + j*dist) = tmp[i] /
+              static_cast<double> (npts);
+        }
     }
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourier2d (void) const
 {
@@ -316,37 +316,37 @@ ComplexNDArray::fourier2d (void) const
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
+              F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l];
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l];
+            }
+        }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
 
 ComplexNDArray
@@ -364,38 +364,38 @@ ComplexNDArray::ifourier2d (void) const
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
+              F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l] /
-		  static_cast<double> (npts);
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                  static_cast<double> (npts);
+            }
+        }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
 
 ComplexNDArray
@@ -412,37 +412,37 @@ ComplexNDArray::fourierNd (void) const
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
+              F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l];
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l];
+            }
+        }
 
       stride *= dv(i);
     }
 
   return retval;
 }
 
 ComplexNDArray
@@ -459,38 +459,38 @@ ComplexNDArray::ifourierNd (void) const
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
+              F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l] /
-		  static_cast<double> (npts);
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                  static_cast<double> (npts);
+            }
+        }
 
       stride *= dv(i);
     }
 
   return retval;
 }
 
 #endif
@@ -509,31 +509,31 @@ bool
 ComplexNDArray::any_element_is_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = elem (i);
       if (xisnan (val))
-	return true;
+        return true;
     }
   return false;
 }
 
 bool
 ComplexNDArray::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = elem (i);
       if (xisinf (val) || xisnan (val))
-	return true;
+        return true;
     }
   return false;
 }
 
 // Return true if no elements have imaginary components.
 
 bool
 ComplexNDArray::all_elements_are_real (void) const
@@ -556,45 +556,45 @@ ComplexNDArray::all_integers (double& ma
 
       double r_val = std::real (val);
       double i_val = std::imag (val);
       
       max_val = r_val;
       min_val = r_val;
 
       if (i_val > max_val)
-	max_val = i_val;
+        max_val = i_val;
 
       if (i_val < max_val)
-	min_val = i_val;
+        min_val = i_val;
     }
   else
     return false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = elem (i);
 
       double r_val = std::real (val);
       double i_val = std::imag (val);
 
       if (r_val > max_val)
-	max_val = r_val;
+        max_val = r_val;
 
       if (i_val > max_val)
-	max_val = i_val;
+        max_val = i_val;
 
       if (r_val < min_val)
-	min_val = r_val;
+        min_val = r_val;
 
       if (i_val < min_val)
-	min_val = i_val;
+        min_val = i_val;
 
       if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
-	return false;
+        return false;
     }
 
   return true;
 }
 
 bool
 ComplexNDArray::too_large_for_float (void) const
 {
@@ -603,20 +603,20 @@ ComplexNDArray::too_large_for_float (voi
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = elem (i);
 
       double r_val = std::real (val);
       double i_val = std::imag (val);
 
       if ((! (xisnan (r_val) || xisinf (r_val))
-	   && fabs (r_val) > FLT_MAX)
-	  || (! (xisnan (i_val) || xisinf (i_val))
-	      && fabs (i_val) > FLT_MAX))
-	return true;
+           && fabs (r_val) > FLT_MAX)
+          || (! (xisnan (i_val) || xisinf (i_val))
+              && fabs (i_val) > FLT_MAX))
+        return true;
     }
 
   return false;
 }
 
 boolNDArray
 ComplexNDArray::all (int dim) const
 {
@@ -787,43 +787,43 @@ ComplexNDArray::insert (const NDArray& a
   if (n == dimensions.length ())
     {
       Array<octave_idx_type> a_ra_idx (a_dv.length (), 0);
       
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
       
       for (int i = 0; i < n; i++)
-	{
-	  if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
-	    {
-	      (*current_liboctave_error_handler)
-		("Array<T>::insert: range error for insert");
-	      return *this;
-	    }
-	}
+        {
+          if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
+            {
+              (*current_liboctave_error_handler)
+                ("Array<T>::insert: range error for insert");
+              return *this;
+            }
+        }
       
       a_ra_idx.elem (0) = 0;
       a_ra_idx.elem (1) = 0;
       
       octave_idx_type n_elt = a.numel ();
       
       // IS make_unique () NECCESSARY HERE??
 
       for (octave_idx_type i = 0; i < n_elt; i++)
-	{
-	  Array<octave_idx_type> ra_idx = a_ra_idx;
-	  
-	  ra_idx.elem (0) = a_ra_idx (0) + r;
-	  ra_idx.elem (1) = a_ra_idx (1) + c;
-	  
-	  elem (ra_idx) = a.elem (a_ra_idx);
+        {
+          Array<octave_idx_type> ra_idx = a_ra_idx;
+          
+          ra_idx.elem (0) = a_ra_idx (0) + r;
+          ra_idx.elem (1) = a_ra_idx (1) + c;
+          
+          elem (ra_idx) = a.elem (a_ra_idx);
 
-	  increment_index (a_ra_idx, a_dv);
-	}
+          increment_index (a_ra_idx, a_dv);
+        }
     }
   else
     (*current_liboctave_error_handler)
       ("Array<T>::insert: invalid indexing operation");
 
   return *this;
 }
 
@@ -852,25 +852,25 @@ ComplexNDArray::matrix_value (void) cons
     (*current_liboctave_error_handler)
       ("invalid conversion of ComplexNDArray to ComplexMatrix");
 
   return retval;
 }
 
 void
 ComplexNDArray::increment_index (Array<octave_idx_type>& ra_idx,
-				 const dim_vector& dimensions,
-				 int start_dimension)
+                                 const dim_vector& dimensions,
+                                 int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
 octave_idx_type 
 ComplexNDArray::compute_index (Array<octave_idx_type>& ra_idx,
-			       const dim_vector& dimensions)
+                               const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 ComplexNDArray
 ComplexNDArray::diag (octave_idx_type k) const
 {
   return MArrayN<Complex>::diag (k);
@@ -895,23 +895,23 @@ std::istream&
 operator >> (std::istream& is, ComplexNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       Complex tmp;
       for (octave_idx_type i = 0; i < nel; i++)
-	  {
-	    tmp = octave_read_value<Complex> (is);
-	    if (is)
-	      a.elem (i) = tmp;
-	    else
-	      goto done;
-	  }
+          {
+            tmp = octave_read_value<Complex> (is);
+            if (is)
+              a.elem (i) = tmp;
+            else
+              goto done;
+          }
     }
 
  done:
 
   return is;
 }
 
 ComplexNDArray
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -37,24 +37,24 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgemv, ZGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const Complex&,
-			   const Complex*, const octave_idx_type&, const Complex*,
-			   const octave_idx_type&, const Complex&, Complex*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, const octave_idx_type&, const Complex&,
+                           const Complex*, const octave_idx_type&, const Complex*,
+                           const octave_idx_type&, const Complex&, Complex*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xzdotu, XZDOTU) (const octave_idx_type&, const Complex*, const octave_idx_type&,
-			     const Complex*, const octave_idx_type&, Complex&);
+                             const Complex*, const octave_idx_type&, Complex&);
 }
 
 // Complex Row Vector class
 
 ComplexRowVector::ComplexRowVector (const RowVector& a)
   : MArray<Complex> (a.length ())
 {
   for (octave_idx_type i = 0; i < length (); i++)
@@ -89,17 +89,17 @@ ComplexRowVector::insert (const RowVecto
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (c+i) = a.elem (i);
+        xelem (c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::insert (const ComplexRowVector& a, octave_idx_type c)
 {
@@ -111,49 +111,49 @@ ComplexRowVector::insert (const ComplexR
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (c+i) = a.elem (i);
+        xelem (c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (double val)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (const Complex& val)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (double val, octave_idx_type c1, octave_idx_type c2)
 {
@@ -167,17 +167,17 @@ ComplexRowVector::fill (double val, octa
 
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type i = c1; i <= c2; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (const Complex& val, octave_idx_type c1, octave_idx_type c2)
 {
@@ -191,17 +191,17 @@ ComplexRowVector::fill (const Complex& v
 
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type i = c1; i <= c2; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexRowVector
 ComplexRowVector::append (const RowVector& a) const
 {
@@ -332,31 +332,31 @@ operator * (const ComplexRowVector& v, c
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
       if (len == 0)
-	retval.resize (a_nc, 0.0);
+        retval.resize (a_nc, 0.0);
       else
-	{
-	  // Transpose A to form A'*x == (x'*A)'
+        {
+          // Transpose A to form A'*x == (x'*A)'
 
-	  octave_idx_type ld = a_nr;
+          octave_idx_type ld = a_nr;
 
-	  retval.resize (a_nc);
-	  Complex *y = retval.fortran_vec ();
+          retval.resize (a_nc);
+          Complex *y = retval.fortran_vec ();
 
-	  F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
-				   a_nr, a_nc, 1.0, a.data (),
-				   ld, v.data (), 1, 0.0, y, 1
-				   F77_CHAR_ARG_LEN (1)));
-	}
+          F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
+                                   a_nr, a_nc, 1.0, a.data (),
+                                   ld, v.data (), 1, 0.0, y, 1
+                                   F77_CHAR_ARG_LEN (1)));
+        }
     }
 
   return retval;
 }
 
 ComplexRowVector
 operator * (const RowVector& v, const ComplexMatrix& a)
 {
@@ -374,18 +374,18 @@ ComplexRowVector::min (void) const
     return Complex (0.0);
 
   Complex res = elem (0);
   double absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) < absres)
       {
-	res = elem (i);
-	absres = std::abs (res);
+        res = elem (i);
+        absres = std::abs (res);
       }
 
   return res;
 }
 
 Complex
 ComplexRowVector::max (void) const
 {
@@ -394,18 +394,18 @@ ComplexRowVector::max (void) const
     return Complex (0.0);
 
   Complex res = elem (0);
   double absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) > absres)
       {
-	res = elem (i);
-	absres = std::abs (res);
+        res = elem (i);
+        absres = std::abs (res);
       }
 
   return res;
 }
 
 // i/o
 
 std::ostream&
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -62,67 +62,67 @@ along with Octave; see the file COPYING.
 #include "sparse-dmsolve.cc"
 #endif
 
 // Fortran functions we call.
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgbtrf, ZGBTRF) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
-			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type*, octave_idx_type&);
+                             const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgbtrs, ZGBTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
-			     const Complex*, const octave_idx_type&,
-			     const octave_idx_type*, Complex*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
+                             const Complex*, const octave_idx_type&,
+                             const octave_idx_type*, Complex*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgbcon, ZGBCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, const octave_idx_type&, Complex*, 
-			     const octave_idx_type&, const octave_idx_type*, const double&, 
-			     double&, Complex*, double*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const octave_idx_type&, Complex*, 
+                             const octave_idx_type&, const octave_idx_type*, const double&, 
+                             double&, Complex*, double*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zpbtrf, ZPBTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zpbtrs, ZPBTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, const octave_idx_type&, Complex*, const octave_idx_type&, 
-			     Complex*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const octave_idx_type&, Complex*, const octave_idx_type&, 
+                             Complex*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zpbcon, ZPBCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, Complex*, const octave_idx_type&, 
-			     const double&, double&, Complex*, double*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, Complex*, const octave_idx_type&, 
+                             const double&, double&, Complex*, double*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgttrf, ZGTTRF) (const octave_idx_type&, Complex*, Complex*, Complex*,
-			     Complex*, octave_idx_type*, octave_idx_type&);
+                             Complex*, octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgttrs, ZGTTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     const octave_idx_type&, const Complex*, const Complex*,
-			     const Complex*, const Complex*, const octave_idx_type*,
-			     Complex *, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const Complex*, const Complex*,
+                             const Complex*, const Complex*, const octave_idx_type*,
+                             Complex *, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zptsv, ZPTSV) (const octave_idx_type&, const octave_idx_type&, double*, Complex*,
-			   Complex*, const octave_idx_type&, octave_idx_type&);
+                           Complex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgtsv, ZGTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
-			   Complex*, Complex*, const octave_idx_type&, octave_idx_type&);
+                           Complex*, Complex*, const octave_idx_type&, octave_idx_type&);
 }
 
 SparseComplexMatrix::SparseComplexMatrix (const SparseMatrix& a)
   : MSparse<Complex> (a.rows (), a.cols (), a.nnz ())
 {
   octave_idx_type nc = cols ();
   octave_idx_type nz = a.nnz ();
 
@@ -179,17 +179,17 @@ SparseComplexMatrix::operator == (const 
   octave_idx_type nc_a = a.cols ();
   octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx(i) != a.cidx(i))
-	return false;
+        return false;
 
   for (octave_idx_type i = 0; i < nz; i++)
     if (data(i) != a.data(i) || ridx(i) != a.ridx(i))
       return false;
 
   return true;
 }
 
@@ -203,40 +203,40 @@ bool
 SparseComplexMatrix::is_hermitian (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == nc && nr > 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      octave_idx_type ri = ridx(i);
-
-	      if (ri != j)
-		{
-		  bool found = false;
-
-		  for (octave_idx_type k = cidx(ri); k < cidx(ri+1); k++)
-		    {
-		      if (ridx(k) == j)
-			{
-			  if (data(i) == conj(data(k)))
-			    found = true;
-			  break;
-			}
-		    }
-
-		  if (! found)
-		    return false;
-		}
-	    }
-	}
+        {
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              octave_idx_type ri = ridx(i);
+
+              if (ri != j)
+                {
+                  bool found = false;
+
+                  for (octave_idx_type k = cidx(ri); k < cidx(ri+1); k++)
+                    {
+                      if (ridx(k) == j)
+                        {
+                          if (data(i) == conj(data(k)))
+                            found = true;
+                          break;
+                        }
+                    }
+
+                  if (! found)
+                    return false;
+                }
+            }
+        }
 
       return true;
     }
 
   return false;
 }
 
 static const Complex Complex_NaN_result (octave_NaN, octave_NaN);
@@ -263,139 +263,139 @@ SparseComplexMatrix::max (Array<octave_i
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
       idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  Complex tmp_max;
-	  double abs_max = octave_NaN;
-	  octave_idx_type idx_j = 0;
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      if (ridx(i) != idx_j)
-		break;
-	      else
-		idx_j++;
-	    }
-
-	  if (idx_j != nr)
-	    {
-	      tmp_max = 0.;
-	      abs_max = 0.;
-	    }
-
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      Complex tmp = data (i);
-
-	      if (xisnan (tmp))
-		continue;
-
-	      double abs_tmp = std::abs (tmp);
-
-	      if (xisnan (abs_max) || abs_tmp > abs_max)
-		{
-		  idx_j = ridx (i);
-		  tmp_max = tmp;
-		  abs_max = abs_tmp;
-		}
-	    }
-
- 	  idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_j;
-	  if (abs_max != 0.)
-	    nel++;
-	}
+        {
+          Complex tmp_max;
+          double abs_max = octave_NaN;
+          octave_idx_type idx_j = 0;
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              if (ridx(i) != idx_j)
+                break;
+              else
+                idx_j++;
+            }
+
+          if (idx_j != nr)
+            {
+              tmp_max = 0.;
+              abs_max = 0.;
+            }
+
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              Complex tmp = data (i);
+
+              if (xisnan (tmp))
+                continue;
+
+              double abs_tmp = std::abs (tmp);
+
+              if (xisnan (abs_max) || abs_tmp > abs_max)
+                {
+                  idx_j = ridx (i);
+                  tmp_max = tmp;
+                  abs_max = abs_tmp;
+                }
+            }
+
+          idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_j;
+          if (abs_max != 0.)
+            nel++;
+        }
 
       result = SparseComplexMatrix (1, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  Complex tmp = elem (idx_arg(j), j);
-	  if (tmp != 0.)
-	    {
-	      result.xdata (ii) = tmp;
-	      result.xridx (ii++) = 0;
-	    }
-	  result.xcidx (j+1) = ii;
-	}
+        {
+          Complex tmp = elem (idx_arg(j), j);
+          if (tmp != 0.)
+            {
+              result.xdata (ii) = tmp;
+              result.xridx (ii++) = 0;
+            }
+          result.xcidx (j+1) = ii;
+        }
     }
   else
     {
       idx_arg.resize_fill (nr, 1, 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
-	idx_arg.elem(ridx(i)) = -1;
+        idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    if (idx_arg.elem(i) != -1)
-	      continue;
-	    bool found = false;
-	    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-	      if (ridx(k) == i)
-		{
-		  found = true;
-		  break;
-		}
-	    
-	    if (!found)
-	      idx_arg.elem(i) = j;
-
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            if (idx_arg.elem(i) != -1)
+              continue;
+            bool found = false;
+            for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
+              if (ridx(k) == i)
+                {
+                  found = true;
+                  break;
+                }
+            
+            if (!found)
+              idx_arg.elem(i) = j;
+
+          }
 
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      octave_idx_type ir = ridx (i);
-	      octave_idx_type ix = idx_arg.elem (ir);
-	      Complex tmp = data (i);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (ix == -1 || std::abs(tmp) > std::abs(elem (ir, ix)))
-		idx_arg.elem (ir) = j;
-	    }
-	}
+        {
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              octave_idx_type ir = ridx (i);
+              octave_idx_type ix = idx_arg.elem (ir);
+              Complex tmp = data (i);
+
+              if (xisnan (tmp))
+                continue;
+              else if (ix == -1 || std::abs(tmp) > std::abs(elem (ir, ix)))
+                idx_arg.elem (ir) = j;
+            }
+        }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
-	if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
-	  nel++;
+        if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
+          nel++;
 
       result = SparseComplexMatrix (nr, 1, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
-	{
-	  if (idx_arg(j) == -1)
-	    {
-	      idx_arg(j) = 0;
-	      result.xdata (ii) = Complex_NaN_result;
-	      result.xridx (ii++) = j;
-	    }
-	  else
-	    {
-	      Complex tmp = elem (j, idx_arg(j));
-	      if (tmp != 0.)
-		{
-		  result.xdata (ii) = tmp;
-		  result.xridx (ii++) = j;
-		}
-	    }
-	}
+        {
+          if (idx_arg(j) == -1)
+            {
+              idx_arg(j) = 0;
+              result.xdata (ii) = Complex_NaN_result;
+              result.xridx (ii++) = j;
+            }
+          else
+            {
+              Complex tmp = elem (j, idx_arg(j));
+              if (tmp != 0.)
+                {
+                  result.xdata (ii) = tmp;
+                  result.xridx (ii++) = j;
+                }
+            }
+        }
     }
 
   return result;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::min (int dim) const
 {
@@ -418,139 +418,139 @@ SparseComplexMatrix::min (Array<octave_i
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
       idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  Complex tmp_min;
-	  double abs_min = octave_NaN;
-	  octave_idx_type idx_j = 0;
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      if (ridx(i) != idx_j)
-		break;
-	      else
-		idx_j++;
-	    }
-
-	  if (idx_j != nr)
-	    {
-	      tmp_min = 0.;
-	      abs_min = 0.;
-	    }
-
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      Complex tmp = data (i);
-
-	      if (xisnan (tmp))
-		continue;
-
-	      double abs_tmp = std::abs (tmp);
-
-	      if (xisnan (abs_min) || abs_tmp < abs_min)
-		{
-		  idx_j = ridx (i);
-		  tmp_min = tmp;
-		  abs_min = abs_tmp;
-		}
-	    }
-
- 	  idx_arg.elem (j) = xisnan (tmp_min) ? 0 : idx_j;
-	  if (abs_min != 0.)
-	    nel++;
-	}
+        {
+          Complex tmp_min;
+          double abs_min = octave_NaN;
+          octave_idx_type idx_j = 0;
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              if (ridx(i) != idx_j)
+                break;
+              else
+                idx_j++;
+            }
+
+          if (idx_j != nr)
+            {
+              tmp_min = 0.;
+              abs_min = 0.;
+            }
+
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              Complex tmp = data (i);
+
+              if (xisnan (tmp))
+                continue;
+
+              double abs_tmp = std::abs (tmp);
+
+              if (xisnan (abs_min) || abs_tmp < abs_min)
+                {
+                  idx_j = ridx (i);
+                  tmp_min = tmp;
+                  abs_min = abs_tmp;
+                }
+            }
+
+          idx_arg.elem (j) = xisnan (tmp_min) ? 0 : idx_j;
+          if (abs_min != 0.)
+            nel++;
+        }
 
       result = SparseComplexMatrix (1, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  Complex tmp = elem (idx_arg(j), j);
-	  if (tmp != 0.)
-	    {
-	      result.xdata (ii) = tmp;
-	      result.xridx (ii++) = 0;
-	    }
-	  result.xcidx (j+1) = ii;
-	}
+        {
+          Complex tmp = elem (idx_arg(j), j);
+          if (tmp != 0.)
+            {
+              result.xdata (ii) = tmp;
+              result.xridx (ii++) = 0;
+            }
+          result.xcidx (j+1) = ii;
+        }
     }
   else
     {
       idx_arg.resize_fill (nr, 1, 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
-	idx_arg.elem(ridx(i)) = -1;
+        idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    if (idx_arg.elem(i) != -1)
-	      continue;
-	    bool found = false;
-	    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-	      if (ridx(k) == i)
-		{
-		  found = true;
-		  break;
-		}
-	    
-	    if (!found)
-	      idx_arg.elem(i) = j;
-
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            if (idx_arg.elem(i) != -1)
+              continue;
+            bool found = false;
+            for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
+              if (ridx(k) == i)
+                {
+                  found = true;
+                  break;
+                }
+            
+            if (!found)
+              idx_arg.elem(i) = j;
+
+          }
 
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      octave_idx_type ir = ridx (i);
-	      octave_idx_type ix = idx_arg.elem (ir);
-	      Complex tmp = data (i);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (ix == -1 || std::abs(tmp) < std::abs(elem (ir, ix)))
-		idx_arg.elem (ir) = j;
-	    }
-	}
+        {
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              octave_idx_type ir = ridx (i);
+              octave_idx_type ix = idx_arg.elem (ir);
+              Complex tmp = data (i);
+
+              if (xisnan (tmp))
+                continue;
+              else if (ix == -1 || std::abs(tmp) < std::abs(elem (ir, ix)))
+                idx_arg.elem (ir) = j;
+            }
+        }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
-	if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
-	  nel++;
+        if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
+          nel++;
 
       result = SparseComplexMatrix (nr, 1, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
-	{
-	  if (idx_arg(j) == -1)
-	    {
-	      idx_arg(j) = 0;
-	      result.xdata (ii) = Complex_NaN_result;
-	      result.xridx (ii++) = j;
-	    }
-	  else
-	    {
-	      Complex tmp = elem (j, idx_arg(j));
-	      if (tmp != 0.)
-		{
-		  result.xdata (ii) = tmp;
-		  result.xridx (ii++) = j;
-		}
-	    }
-	}
+        {
+          if (idx_arg(j) == -1)
+            {
+              idx_arg(j) = 0;
+              result.xdata (ii) = Complex_NaN_result;
+              result.xridx (ii++) = j;
+            }
+          else
+            {
+              Complex tmp = elem (j, idx_arg(j));
+              if (tmp != 0.)
+                {
+                  result.xdata (ii) = tmp;
+                  result.xridx (ii++) = j;
+                }
+            }
+        }
     }
 
   return result;
 }
 
 ComplexRowVector 
 SparseComplexMatrix::row (octave_idx_type i) const
 {
@@ -609,17 +609,17 @@ SparseComplexMatrix&
 SparseComplexMatrix::insert (const SparseComplexMatrix& a, const Array<octave_idx_type>& indx)
 {
   MSparse<Complex>::insert (a, indx);
   return *this;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::concat (const SparseComplexMatrix& rb, 
-			     const Array<octave_idx_type>& ra_idx)
+                             const Array<octave_idx_type>& ra_idx)
 {
   // Don't use numel to avoid all possiblity of an overflow
   if (rb.rows () > 0 && rb.cols () > 0)
     insert (rb, ra_idx(0), ra_idx(1));
   return *this;
 }
 
 SparseComplexMatrix
@@ -663,19 +663,19 @@ SparseComplexMatrix::hermitian (void) co
       retval.xcidx (i) = nz;
       nz += tmp;
     }
   // retval.xcidx[1:nr] holds row entry *start* offsets for rows 0:(nr-1)
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
       {
-	octave_idx_type q = retval.xcidx (ridx (k) + 1)++;
-	retval.xridx (q) = j;
-	retval.xdata (q) = conj (data (k));
+        octave_idx_type q = retval.xcidx (ridx (k) + 1)++;
+        retval.xridx (q) = j;
+        retval.xdata (q) = conj (data (k));
       }
   assert (nnz () == retval.xcidx (nr));
   // retval.xcidx[1:nr] holds row entry *end* offsets for rows 0:(nr-1)
   // and retval.xcidx[0:(nr-1)] holds their row entry *start* offsets
 
   return retval;
 }
 
@@ -720,349 +720,349 @@ SparseComplexMatrix
 SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   double rcond;
   return inverse (mattype, info, rcond, 0, 0);
 }
 
 SparseComplexMatrix 
 SparseComplexMatrix::dinverse (MatrixType &mattyp, octave_idx_type& info, 
-			double& rcond, const bool,
-			const bool calccond) const
+                        double& rcond, const bool,
+                        const bool calccond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
       if (typ == MatrixType::Diagonal ||
-	  typ == MatrixType::Permuted_Diagonal)
-	{
-	  if (typ == MatrixType::Permuted_Diagonal)
-	    retval = transpose();
-	  else
-	    retval = *this;
-	      
-	  // Force make_unique to be called
-	  Complex *v = retval.data();
-
-	  if (calccond)
-	    {
-	      double dmax = 0., dmin = octave_Inf; 
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  double tmp = std::abs(v[i]);
-		  if (tmp > dmax)
-		    dmax = tmp;
-		  if (tmp < dmin)
-		    dmin = tmp;
-		}
-	      rcond = dmin / dmax;
-	    }
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    v[i] = 1.0 / v[i];
-	}
+          typ == MatrixType::Permuted_Diagonal)
+        {
+          if (typ == MatrixType::Permuted_Diagonal)
+            retval = transpose();
+          else
+            retval = *this;
+              
+          // Force make_unique to be called
+          Complex *v = retval.data();
+
+          if (calccond)
+            {
+              double dmax = 0., dmin = octave_Inf; 
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  double tmp = std::abs(v[i]);
+                  if (tmp > dmax)
+                    dmax = tmp;
+                  if (tmp < dmin)
+                    dmin = tmp;
+                }
+              rcond = dmin / dmax;
+            }
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            v[i] = 1.0 / v[i];
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix 
 SparseComplexMatrix::tinverse (MatrixType &mattyp, octave_idx_type& info, 
-			       double& rcond, const bool,
-			       const bool calccond) const
+                               double& rcond, const bool,
+                               const bool calccond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
       if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-
-	  if (calccond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  if (typ == MatrixType::Upper || typ == MatrixType::Lower)
-	    {
-	      octave_idx_type nz = nnz ();
-	      octave_idx_type cx = 0;
-	      octave_idx_type nz2 = nz;
-	      retval = SparseComplexMatrix (nr, nc, nz2);
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  octave_quit ();
-		  // place the 1 in the identity position
-		  octave_idx_type cx_colstart = cx;
-	  
-		  if (cx == nz2)
-		    {
-		      nz2 *= 2;
-		      retval.change_capacity (nz2);
-		    }
-
-		  retval.xcidx(i) = cx;
-		  retval.xridx(cx) = i;
-		  retval.xdata(cx) = 1.0;
-		  cx++;
-
-		  // iterate accross columns of input matrix
-		  for (octave_idx_type j = i+1; j < nr; j++) 
-		    {
-		      Complex v = 0.;
-		      // iterate to calculate sum
-		      octave_idx_type colXp = retval.xcidx(i);
-		      octave_idx_type colUp = cidx(j);
-		      octave_idx_type rpX, rpU;
-
-		      if (cidx(j) == cidx(j+1))
-			{
-			  (*current_liboctave_error_handler) 
-			    ("division by zero");
-			  goto inverse_singular;
-			}
-
-		      do
-			{
-			  octave_quit ();
-			  rpX = retval.xridx(colXp);
-			  rpU = ridx(colUp);
-
-			  if (rpX < rpU) 
-			    colXp++;
-			  else if (rpX > rpU) 
-			    colUp++;
-			  else 
-			    {
-			      v -= retval.xdata(colXp) * data(colUp);
-			      colXp++;
-			      colUp++;
-			    }
-			} while ((rpX<j) && (rpU<j) && 
-				 (colXp<cx) && (colUp<nz));
-
-
-		      // get A(m,m)
-		      if (typ == MatrixType::Upper)
-			colUp = cidx(j+1) - 1;
-		      else
-			colUp = cidx(j);
-		      Complex pivot = data(colUp);
-		      if (pivot == 0. || ridx(colUp) != j) 
-			{
-			  (*current_liboctave_error_handler) 
-			    ("division by zero");
-			  goto inverse_singular;
-			}
-
-		      if (v != 0.)
-			{
-			  if (cx == nz2)
-			    {
-			      nz2 *= 2;
-			      retval.change_capacity (nz2);
-			    }
-
-			  retval.xridx(cx) = j;
-			  retval.xdata(cx) = v / pivot;
-			  cx++;
-			}
-		    }
-
-		  // get A(m,m)
-		  octave_idx_type colUp;
-		  if (typ == MatrixType::Upper)
-		    colUp = cidx(i+1) - 1;
-		  else
-		    colUp = cidx(i);
-		  Complex pivot = data(colUp);
-		  if (pivot == 0. || ridx(colUp) != i) 
-		    {
-		      (*current_liboctave_error_handler) ("division by zero");
-		      goto inverse_singular;
-		    }
-
-		  if (pivot != 1.0)
-		    for (octave_idx_type j = cx_colstart; j < cx; j++)
-		      retval.xdata(j) /= pivot;
-		}
-	      retval.xcidx(nr) = cx;
-	      retval.maybe_compress ();
-	    }
-	  else
-	    {
-	      octave_idx_type nz = nnz ();
-	      octave_idx_type cx = 0;
-	      octave_idx_type nz2 = nz;
-	      retval = SparseComplexMatrix (nr, nc, nz2);
-
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
-
-	      octave_idx_type *perm = mattyp.triangular_perm();
-	      if (typ == MatrixType::Permuted_Upper)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    rperm[perm[i]] = i;
-		}
-	      else
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    rperm[i] = perm[i];
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    perm[rperm[i]] = i;
-		}
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  octave_quit ();
-		  octave_idx_type iidx = rperm[i];
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    work[j] = 0.;
-
-		  // place the 1 in the identity position
-		  work[iidx] = 1.0;
-
-		  // iterate accross columns of input matrix
-		  for (octave_idx_type j = iidx+1; j < nr; j++) 
-		    {
-		      Complex v = 0.;
-		      octave_idx_type jidx = perm[j];
-		      // iterate to calculate sum
-		      for (octave_idx_type k = cidx(jidx); 
-			   k < cidx(jidx+1); k++)
-			{
-			  octave_quit ();
-			  v -= work[ridx(k)] * data(k);
-			}
-
-		      // get A(m,m)
-		      Complex pivot;
-		      if (typ == MatrixType::Permuted_Upper)
-			pivot = data(cidx(jidx+1) - 1);
-		      else
-			pivot = data(cidx(jidx));
-		      if (pivot == 0.) 
-			{
-			  (*current_liboctave_error_handler) 
-			    ("division by zero");
-			  goto inverse_singular;
-			}
-
-		      work[j] = v / pivot;
-		    }
-
-		  // get A(m,m)
-		  octave_idx_type colUp;
-		  if (typ == MatrixType::Permuted_Upper)
-		    colUp = cidx(perm[iidx]+1) - 1;
-		  else
-		    colUp = cidx(perm[iidx]);		  
-
-  		  Complex pivot = data(colUp);
-		  if (pivot == 0.)
-		    {
-		      (*current_liboctave_error_handler) 
-			("division by zero");
-		      goto inverse_singular;
-		    }
-
-		  octave_idx_type new_cx = cx;
-		  for (octave_idx_type j = iidx; j < nr; j++)
-		    if (work[j] != 0.0)
-		      {
-			new_cx++;
-			if (pivot != 1.0)
-			  work[j] /= pivot;
-		      }
-
-		  if (cx < new_cx)
-		    {
-		      nz2 = (2*nz2 < new_cx ? new_cx : 2*nz2);
-		      retval.change_capacity (nz2);
-		    }
-
-		  retval.xcidx(i) = cx;
-		  for (octave_idx_type j = iidx; j < nr; j++)
-		    if (work[j] != 0.)
-		      {
-			retval.xridx(cx) = j;
-			retval.xdata(cx++) = work[j];
-		      }
-		}
-
-	      retval.xcidx(nr) = cx;
-	      retval.maybe_compress ();
-	    }
-
-	  if (calccond)
-	    {
-	      // Calculate the 1-norm of inverse matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = retval.cidx(j); 
-		       i < retval.cidx(j+1); i++)
-		    atmp += std::abs(retval.data(i));
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-
-	      rcond = 1. / ainvnorm / anorm;     
-	    }
-	}
+          typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+
+          if (calccond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          if (typ == MatrixType::Upper || typ == MatrixType::Lower)
+            {
+              octave_idx_type nz = nnz ();
+              octave_idx_type cx = 0;
+              octave_idx_type nz2 = nz;
+              retval = SparseComplexMatrix (nr, nc, nz2);
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  octave_quit ();
+                  // place the 1 in the identity position
+                  octave_idx_type cx_colstart = cx;
+          
+                  if (cx == nz2)
+                    {
+                      nz2 *= 2;
+                      retval.change_capacity (nz2);
+                    }
+
+                  retval.xcidx(i) = cx;
+                  retval.xridx(cx) = i;
+                  retval.xdata(cx) = 1.0;
+                  cx++;
+
+                  // iterate accross columns of input matrix
+                  for (octave_idx_type j = i+1; j < nr; j++) 
+                    {
+                      Complex v = 0.;
+                      // iterate to calculate sum
+                      octave_idx_type colXp = retval.xcidx(i);
+                      octave_idx_type colUp = cidx(j);
+                      octave_idx_type rpX, rpU;
+
+                      if (cidx(j) == cidx(j+1))
+                        {
+                          (*current_liboctave_error_handler) 
+                            ("division by zero");
+                          goto inverse_singular;
+                        }
+
+                      do
+                        {
+                          octave_quit ();
+                          rpX = retval.xridx(colXp);
+                          rpU = ridx(colUp);
+
+                          if (rpX < rpU) 
+                            colXp++;
+                          else if (rpX > rpU) 
+                            colUp++;
+                          else 
+                            {
+                              v -= retval.xdata(colXp) * data(colUp);
+                              colXp++;
+                              colUp++;
+                            }
+                        } while ((rpX<j) && (rpU<j) && 
+                                 (colXp<cx) && (colUp<nz));
+
+
+                      // get A(m,m)
+                      if (typ == MatrixType::Upper)
+                        colUp = cidx(j+1) - 1;
+                      else
+                        colUp = cidx(j);
+                      Complex pivot = data(colUp);
+                      if (pivot == 0. || ridx(colUp) != j) 
+                        {
+                          (*current_liboctave_error_handler) 
+                            ("division by zero");
+                          goto inverse_singular;
+                        }
+
+                      if (v != 0.)
+                        {
+                          if (cx == nz2)
+                            {
+                              nz2 *= 2;
+                              retval.change_capacity (nz2);
+                            }
+
+                          retval.xridx(cx) = j;
+                          retval.xdata(cx) = v / pivot;
+                          cx++;
+                        }
+                    }
+
+                  // get A(m,m)
+                  octave_idx_type colUp;
+                  if (typ == MatrixType::Upper)
+                    colUp = cidx(i+1) - 1;
+                  else
+                    colUp = cidx(i);
+                  Complex pivot = data(colUp);
+                  if (pivot == 0. || ridx(colUp) != i) 
+                    {
+                      (*current_liboctave_error_handler) ("division by zero");
+                      goto inverse_singular;
+                    }
+
+                  if (pivot != 1.0)
+                    for (octave_idx_type j = cx_colstart; j < cx; j++)
+                      retval.xdata(j) /= pivot;
+                }
+              retval.xcidx(nr) = cx;
+              retval.maybe_compress ();
+            }
+          else
+            {
+              octave_idx_type nz = nnz ();
+              octave_idx_type cx = 0;
+              octave_idx_type nz2 = nz;
+              retval = SparseComplexMatrix (nr, nc, nz2);
+
+              OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+              OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
+
+              octave_idx_type *perm = mattyp.triangular_perm();
+              if (typ == MatrixType::Permuted_Upper)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    rperm[perm[i]] = i;
+                }
+              else
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    rperm[i] = perm[i];
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    perm[rperm[i]] = i;
+                }
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  octave_quit ();
+                  octave_idx_type iidx = rperm[i];
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    work[j] = 0.;
+
+                  // place the 1 in the identity position
+                  work[iidx] = 1.0;
+
+                  // iterate accross columns of input matrix
+                  for (octave_idx_type j = iidx+1; j < nr; j++) 
+                    {
+                      Complex v = 0.;
+                      octave_idx_type jidx = perm[j];
+                      // iterate to calculate sum
+                      for (octave_idx_type k = cidx(jidx); 
+                           k < cidx(jidx+1); k++)
+                        {
+                          octave_quit ();
+                          v -= work[ridx(k)] * data(k);
+                        }
+
+                      // get A(m,m)
+                      Complex pivot;
+                      if (typ == MatrixType::Permuted_Upper)
+                        pivot = data(cidx(jidx+1) - 1);
+                      else
+                        pivot = data(cidx(jidx));
+                      if (pivot == 0.) 
+                        {
+                          (*current_liboctave_error_handler) 
+                            ("division by zero");
+                          goto inverse_singular;
+                        }
+
+                      work[j] = v / pivot;
+                    }
+
+                  // get A(m,m)
+                  octave_idx_type colUp;
+                  if (typ == MatrixType::Permuted_Upper)
+                    colUp = cidx(perm[iidx]+1) - 1;
+                  else
+                    colUp = cidx(perm[iidx]);             
+
+                  Complex pivot = data(colUp);
+                  if (pivot == 0.)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("division by zero");
+                      goto inverse_singular;
+                    }
+
+                  octave_idx_type new_cx = cx;
+                  for (octave_idx_type j = iidx; j < nr; j++)
+                    if (work[j] != 0.0)
+                      {
+                        new_cx++;
+                        if (pivot != 1.0)
+                          work[j] /= pivot;
+                      }
+
+                  if (cx < new_cx)
+                    {
+                      nz2 = (2*nz2 < new_cx ? new_cx : 2*nz2);
+                      retval.change_capacity (nz2);
+                    }
+
+                  retval.xcidx(i) = cx;
+                  for (octave_idx_type j = iidx; j < nr; j++)
+                    if (work[j] != 0.)
+                      {
+                        retval.xridx(cx) = j;
+                        retval.xdata(cx++) = work[j];
+                      }
+                }
+
+              retval.xcidx(nr) = cx;
+              retval.maybe_compress ();
+            }
+
+          if (calccond)
+            {
+              // Calculate the 1-norm of inverse matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = retval.cidx(j); 
+                       i < retval.cidx(j+1); i++)
+                    atmp += std::abs(retval.data(i));
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
+                }
+
+              rcond = 1. / ainvnorm / anorm;     
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 
  inverse_singular:
   return SparseComplexMatrix();
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info, 
-			      double& rcond, int, int calc_cond) const
+                              double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
   SparseComplexMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
@@ -1072,53 +1072,53 @@ SparseComplexMatrix::inverse (MatrixType
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     { 
       MatrixType newtype = mattype.transpose();
       ret = transpose().tinverse (newtype, info, rcond, true, calc_cond);
     }
   else
     {
       if (mattype.is_hermitian())
-	{
-	  MatrixType tmp_typ (MatrixType::Upper);
-	  SparseComplexCHOL fact (*this, info, false);
-	  rcond = fact.rcond();
-	  if (info == 0)
-	    {
-	      double rcond2;
-	      SparseMatrix Q = fact.Q();
-	      SparseComplexMatrix InvL = fact.L().transpose().
-		tinverse(tmp_typ, info, rcond2, true, false);
-	      ret = Q * InvL.hermitian() * InvL * Q.transpose();
-	    }
-	  else
-	    {
-	      // Matrix is either singular or not positive definite
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	}
+        {
+          MatrixType tmp_typ (MatrixType::Upper);
+          SparseComplexCHOL fact (*this, info, false);
+          rcond = fact.rcond();
+          if (info == 0)
+            {
+              double rcond2;
+              SparseMatrix Q = fact.Q();
+              SparseComplexMatrix InvL = fact.L().transpose().
+                tinverse(tmp_typ, info, rcond2, true, false);
+              ret = Q * InvL.hermitian() * InvL * Q.transpose();
+            }
+          else
+            {
+              // Matrix is either singular or not positive definite
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+        }
 
       if (!mattype.is_hermitian())
-	{
-	  octave_idx_type n = rows();
-	  ColumnVector Qinit(n);
-	  for (octave_idx_type i = 0; i < n; i++)
-	    Qinit(i) = i;
-
-	  MatrixType tmp_typ (MatrixType::Upper);
-	  SparseComplexLU fact (*this, Qinit, Matrix (), false, false);
-	  rcond = fact.rcond();
-	  double rcond2;
-	  SparseComplexMatrix InvL = fact.L().transpose().
-	    tinverse(tmp_typ, info, rcond2, true, false);
-	  SparseComplexMatrix InvU = fact.U().
-	    tinverse(tmp_typ, info, rcond2, true, false).transpose();
-	  ret = fact.Pc().transpose() * InvU * InvL * fact.Pr();
-	}
+        {
+          octave_idx_type n = rows();
+          ColumnVector Qinit(n);
+          for (octave_idx_type i = 0; i < n; i++)
+            Qinit(i) = i;
+
+          MatrixType tmp_typ (MatrixType::Upper);
+          SparseComplexLU fact (*this, Qinit, Matrix (), false, false);
+          rcond = fact.rcond();
+          double rcond2;
+          SparseComplexMatrix InvL = fact.L().transpose().
+            tinverse(tmp_typ, info, rcond2, true, false);
+          SparseComplexMatrix InvU = fact.U().
+            tinverse(tmp_typ, info, rcond2, true, false).transpose();
+          ret = fact.Pc().transpose() * InvU * InvL * fact.Pr();
+        }
     }
 
   return ret;
 }
 
 ComplexDET
 SparseComplexMatrix::determinant (void) const
 {
@@ -1153,118 +1153,118 @@ SparseComplexMatrix::determinant (octave
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_ZNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
       if (!xisnan (tmp))
-	Control (UMFPACK_PRL) = tmp;
+        Control (UMFPACK_PRL) = tmp;
 
       tmp = octave_sparse_params::get_key ("piv_tol");
       if (!xisnan (tmp))
-	{
-	  Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
-	  Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
-	}
+        {
+          Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+          Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+        }
 
       // Set whether we are allowed to modify Q or not
       tmp = octave_sparse_params::get_key ("autoamd");
       if (!xisnan (tmp))
-	Control (UMFPACK_FIXQ) = tmp;
+        Control (UMFPACK_FIXQ) = tmp;
 
       // Turn-off UMFPACK scaling for LU 
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
       const octave_idx_type *Ai = ridx ();
       const Complex *Ax = data ();
 
       UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai, 
-				     reinterpret_cast<const double *> (Ax), 
-				     0, 1, control);
+                                     reinterpret_cast<const double *> (Ax), 
+                                     0, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status = UMFPACK_ZNAME (qsymbolic) 
-	(nr, nc, Ap, Ai, reinterpret_cast<const double *> (Ax), 0, 
-	 0, &Symbolic, control, info);
+        (nr, nc, Ap, Ai, reinterpret_cast<const double *> (Ax), 0, 
+         0, &Symbolic, control, info);
 
       if (status < 0)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("SparseComplexMatrix::determinant symbolic factorization failed");
-
-	  UMFPACK_ZNAME (report_status) (control, status);
-	  UMFPACK_ZNAME (report_info) (control, info);
-
-	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("SparseComplexMatrix::determinant symbolic factorization failed");
+
+          UMFPACK_ZNAME (report_status) (control, status);
+          UMFPACK_ZNAME (report_info) (control, info);
+
+          UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
+        }
       else
-	{
-	  UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
-
-	  void *Numeric;
-	  status
-	    = UMFPACK_ZNAME (numeric) (Ap, Ai,
-				       reinterpret_cast<const double *> (Ax),
-				       0, Symbolic, &Numeric, control, info) ;
-	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
-
-	  rcond = Info (UMFPACK_RCOND);
-
-	  if (status < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("SparseComplexMatrix::determinant numeric factorization failed");
-
-	      UMFPACK_ZNAME (report_status) (control, status);
-	      UMFPACK_ZNAME (report_info) (control, info);
-
-	      UMFPACK_ZNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    {
-	      UMFPACK_ZNAME (report_numeric) (Numeric, control);
-
-	      double c10[2], e10;
+        {
+          UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
+
+          void *Numeric;
+          status
+            = UMFPACK_ZNAME (numeric) (Ap, Ai,
+                                       reinterpret_cast<const double *> (Ax),
+                                       0, Symbolic, &Numeric, control, info) ;
+          UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
+
+          rcond = Info (UMFPACK_RCOND);
+
+          if (status < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("SparseComplexMatrix::determinant numeric factorization failed");
+
+              UMFPACK_ZNAME (report_status) (control, status);
+              UMFPACK_ZNAME (report_info) (control, info);
+
+              UMFPACK_ZNAME (free_numeric) (&Numeric);
+            }
+          else
+            {
+              UMFPACK_ZNAME (report_numeric) (Numeric, control);
+
+              double c10[2], e10;
 
               status = UMFPACK_ZNAME (get_determinant) (c10, 0, &e10,
                                                         Numeric, info);
 
-	      if (status < 0)
-		{
-		  (*current_liboctave_error_handler) 
-		    ("SparseComplexMatrix::determinant error calculating determinant");
-		  
-		  UMFPACK_ZNAME (report_status) (control, status);
-		  UMFPACK_ZNAME (report_info) (control, info);
-		}
-	      else
-		retval = ComplexDET (Complex (c10[0], c10[1]), e10, 10);
-		  
-	      UMFPACK_ZNAME (free_numeric) (&Numeric);
-	    }
-	}
+              if (status < 0)
+                {
+                  (*current_liboctave_error_handler) 
+                    ("SparseComplexMatrix::determinant error calculating determinant");
+                  
+                  UMFPACK_ZNAME (report_status) (control, status);
+                  UMFPACK_ZNAME (report_info) (control, info);
+                }
+              else
+                retval = ComplexDET (Complex (c10[0], c10[1]), e10, 10);
+                  
+              UMFPACK_ZNAME (free_numeric) (&Numeric);
+            }
+        }
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const Matrix& b,
-			     octave_idx_type& err, double& rcond, 
-			     solve_singularity_handler, bool calc_cond) const
+                             octave_idx_type& err, double& rcond, 
+                             solve_singularity_handler, bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1275,57 +1275,57 @@ SparseComplexMatrix::dsolve (MatrixType 
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
-	  typ == MatrixType::Permuted_Diagonal)
-	{
-	  retval.resize (nc, b.cols(), Complex(0.,0.));
-	  if (typ == MatrixType::Diagonal)
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-		for (octave_idx_type i = 0; i < nm; i++)
-		  retval(i,j) = b(i,j) / data (i);
-	  else
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type k = 0; k < nc; k++)
-		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-		  retval(k,j) = b(ridx(i),j) / data (i);
-	    
-	  if (calc_cond)
-	    {
-	      double dmax = 0., dmin = octave_Inf; 
-	      for (octave_idx_type i = 0; i < nm; i++)
-		{
-		  double tmp = std::abs(data(i));
-		  if (tmp > dmax)
-		    dmax = tmp;
-		  if (tmp < dmin)
-		    dmin = tmp;
-		}
-	      rcond = dmin / dmax;
-	    }
-	  else
-	    rcond = 1.0;
-	}
+          typ == MatrixType::Permuted_Diagonal)
+        {
+          retval.resize (nc, b.cols(), Complex(0.,0.));
+          if (typ == MatrixType::Diagonal)
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+                for (octave_idx_type i = 0; i < nm; i++)
+                  retval(i,j) = b(i,j) / data (i);
+          else
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+              for (octave_idx_type k = 0; k < nc; k++)
+                for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                  retval(k,j) = b(ridx(i),j) / data (i);
+            
+          if (calc_cond)
+            {
+              double dmax = 0., dmin = octave_Inf; 
+              for (octave_idx_type i = 0; i < nm; i++)
+                {
+                  double tmp = std::abs(data(i));
+                  if (tmp > dmax)
+                    dmax = tmp;
+                  if (tmp < dmin)
+                    dmin = tmp;
+                }
+              rcond = dmin / dmax;
+            }
+          else
+            rcond = 1.0;
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const SparseMatrix& b,
-			     octave_idx_type& err, double& rcond, 
-			     solve_singularity_handler,
-			     bool calc_cond) const
+                             octave_idx_type& err, double& rcond, 
+                             solve_singularity_handler,
+                             bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1336,87 +1336,87 @@ SparseComplexMatrix::dsolve (MatrixType 
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
-	  typ == MatrixType::Permuted_Diagonal)
-	{
-	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
-	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
-
-	  retval.xcidx(0) = 0;
-	  octave_idx_type ii = 0;
-	  if (typ == MatrixType::Diagonal)
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      {
-		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		  {
-		    if (b.ridx(i) >= nm)
-		      break;
-		    retval.xridx (ii) = b.ridx(i);
-		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
-		  }
-		retval.xcidx(j+1) = ii;
-	      }
-	  else
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      {
-		for (octave_idx_type l = 0; l < nc; l++)
-		  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
-		    {
-		      bool found = false;
-		      octave_idx_type k;
-		      for (k = b.cidx(j); k < b.cidx(j+1); k++)
-			if (ridx(i) == b.ridx(k))
-			  {
-			    found = true;
-			    break;
-			  }
-		      if (found)
-			{
-			  retval.xridx (ii) = l;
-			  retval.xdata (ii++) = b.data(k) / data (i);
-			}
-		    }
-		retval.xcidx(j+1) = ii;
-	      }
-	    
-	  if (calc_cond)
-	    {
-	      double dmax = 0., dmin = octave_Inf; 
-	      for (octave_idx_type i = 0; i < nm; i++)
-		{
-		  double tmp = std::abs(data(i));
-		  if (tmp > dmax)
-		    dmax = tmp;
-		  if (tmp < dmin)
-		    dmin = tmp;
-		}
-	      rcond = dmin / dmax;
-	    }
-	  else
-	    rcond = 1.0;
-	}
+          typ == MatrixType::Permuted_Diagonal)
+        {
+          octave_idx_type b_nc = b.cols ();
+          octave_idx_type b_nz = b.nnz ();
+          retval = SparseComplexMatrix (nc, b_nc, b_nz);
+
+          retval.xcidx(0) = 0;
+          octave_idx_type ii = 0;
+          if (typ == MatrixType::Diagonal)
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+              {
+                for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                  {
+                    if (b.ridx(i) >= nm)
+                      break;
+                    retval.xridx (ii) = b.ridx(i);
+                    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
+                  }
+                retval.xcidx(j+1) = ii;
+              }
+          else
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+              {
+                for (octave_idx_type l = 0; l < nc; l++)
+                  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+                    {
+                      bool found = false;
+                      octave_idx_type k;
+                      for (k = b.cidx(j); k < b.cidx(j+1); k++)
+                        if (ridx(i) == b.ridx(k))
+                          {
+                            found = true;
+                            break;
+                          }
+                      if (found)
+                        {
+                          retval.xridx (ii) = l;
+                          retval.xdata (ii++) = b.data(k) / data (i);
+                        }
+                    }
+                retval.xcidx(j+1) = ii;
+              }
+            
+          if (calc_cond)
+            {
+              double dmax = 0., dmin = octave_Inf; 
+              for (octave_idx_type i = 0; i < nm; i++)
+                {
+                  double tmp = std::abs(data(i));
+                  if (tmp > dmax)
+                    dmax = tmp;
+                  if (tmp < dmin)
+                    dmin = tmp;
+                }
+              rcond = dmin / dmax;
+            }
+          else
+            rcond = 1.0;
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const ComplexMatrix& b,
-			     octave_idx_type& err, double& rcond, 
-			     solve_singularity_handler,
-			     bool calc_cond) const
+                             octave_idx_type& err, double& rcond, 
+                             solve_singularity_handler,
+                             bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1427,57 +1427,57 @@ SparseComplexMatrix::dsolve (MatrixType 
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
-	  typ == MatrixType::Permuted_Diagonal)
-	{
-	  retval.resize (nc, b.cols(), Complex(0.,0.));
-	  if (typ == MatrixType::Diagonal)
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		retval(i,j) = b(i,j) / data (i);
-	  else
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type k = 0; k < nc; k++)
-		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-		  retval(k,j) = b(ridx(i),j) / data (i);
-	    
-	  if (calc_cond)
-	    {
-	      double dmax = 0., dmin = octave_Inf; 
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  double tmp = std::abs(data(i));
-		  if (tmp > dmax)
-		    dmax = tmp;
-		  if (tmp < dmin)
-		    dmin = tmp;
-		}
-	      rcond = dmin / dmax;
-	    }
-	  else
-	    rcond = 1.0;
-	}
+          typ == MatrixType::Permuted_Diagonal)
+        {
+          retval.resize (nc, b.cols(), Complex(0.,0.));
+          if (typ == MatrixType::Diagonal)
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+              for (octave_idx_type i = 0; i < nm; i++)
+                retval(i,j) = b(i,j) / data (i);
+          else
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+              for (octave_idx_type k = 0; k < nc; k++)
+                for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                  retval(k,j) = b(ridx(i),j) / data (i);
+            
+          if (calc_cond)
+            {
+              double dmax = 0., dmin = octave_Inf; 
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  double tmp = std::abs(data(i));
+                  if (tmp > dmax)
+                    dmax = tmp;
+                  if (tmp < dmin)
+                    dmin = tmp;
+                }
+              rcond = dmin / dmax;
+            }
+          else
+            rcond = 1.0;
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-			     octave_idx_type& err, double& rcond, 
-			     solve_singularity_handler,
-			     bool calc_cond) const
+                             octave_idx_type& err, double& rcond, 
+                             solve_singularity_handler,
+                             bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1488,87 +1488,87 @@ SparseComplexMatrix::dsolve (MatrixType 
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
-	  typ == MatrixType::Permuted_Diagonal)
-	{
-	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
-	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
-
-	  retval.xcidx(0) = 0;
-	  octave_idx_type ii = 0;
-	  if (typ == MatrixType::Diagonal)
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      {
-		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		  {
-		    if (b.ridx(i) >= nm)
-		      break;
-		    retval.xridx (ii) = b.ridx(i);
-		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
-		  }
-		retval.xcidx(j+1) = ii;
-	      }
-	  else
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      {
-		for (octave_idx_type l = 0; l < nc; l++)
-		  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
-		    {
-		      bool found = false;
-		      octave_idx_type k;
-		      for (k = b.cidx(j); k < b.cidx(j+1); k++)
-			if (ridx(i) == b.ridx(k))
-			  {
-			    found = true;
-			    break;
-			  }
-		      if (found)
-			{
-			  retval.xridx (ii) = l;
-			  retval.xdata (ii++) = b.data(k) / data (i);
-			}
-		    }
-		retval.xcidx(j+1) = ii;
-	      }
-	    
-	  if (calc_cond)
-	    {
-	      double dmax = 0., dmin = octave_Inf; 
-	      for (octave_idx_type i = 0; i < nm; i++)
-		{
-		  double tmp = std::abs(data(i));
-		  if (tmp > dmax)
-		    dmax = tmp;
-		  if (tmp < dmin)
-		    dmin = tmp;
-		}
-	      rcond = dmin / dmax;
-	    }
-	  else
-	    rcond = 1.0;
-	}
+          typ == MatrixType::Permuted_Diagonal)
+        {
+          octave_idx_type b_nc = b.cols ();
+          octave_idx_type b_nz = b.nnz ();
+          retval = SparseComplexMatrix (nc, b_nc, b_nz);
+
+          retval.xcidx(0) = 0;
+          octave_idx_type ii = 0;
+          if (typ == MatrixType::Diagonal)
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+              {
+                for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                  {
+                    if (b.ridx(i) >= nm)
+                      break;
+                    retval.xridx (ii) = b.ridx(i);
+                    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
+                  }
+                retval.xcidx(j+1) = ii;
+              }
+          else
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+              {
+                for (octave_idx_type l = 0; l < nc; l++)
+                  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+                    {
+                      bool found = false;
+                      octave_idx_type k;
+                      for (k = b.cidx(j); k < b.cidx(j+1); k++)
+                        if (ridx(i) == b.ridx(k))
+                          {
+                            found = true;
+                            break;
+                          }
+                      if (found)
+                        {
+                          retval.xridx (ii) = l;
+                          retval.xdata (ii++) = b.data(k) / data (i);
+                        }
+                    }
+                retval.xcidx(j+1) = ii;
+              }
+            
+          if (calc_cond)
+            {
+              double dmax = 0., dmin = octave_Inf; 
+              for (octave_idx_type i = 0; i < nm; i++)
+                {
+                  double tmp = std::abs(data(i));
+                  if (tmp > dmax)
+                    dmax = tmp;
+                  if (tmp < dmin)
+                    dmin = tmp;
+                }
+              rcond = dmin / dmax;
+            }
+          else
+            rcond = 1.0;
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const Matrix& b,
-			      octave_idx_type& err, double& rcond,
-			      solve_singularity_handler sing_handler,
-			      bool calc_cond) const
+                              octave_idx_type& err, double& rcond,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -1579,232 +1579,232 @@ SparseComplexMatrix::utsolve (MatrixType
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Upper)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  if (typ == MatrixType::Permuted_Upper)
-	    {
-	      retval.resize (nc, b_nc);
-	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
-		  for (octave_idx_type i = nr; i < nc; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      octave_idx_type kidx = perm[k];
-
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(kidx+1)-1) != k ||
-			      data(cidx(kidx+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(cidx(kidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(kidx); 
-			       i < cidx(kidx+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval (perm[i], j) = work[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  octave_idx_type iidx = perm[k];
-
-			  if (work[k] != 0.)
-			    {
-			      Complex tmp = work[k] / data(cidx(iidx+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(iidx); 
-				   i < cidx(iidx+1)-1; i++)
-				{
-				  octave_idx_type idx2 = ridx(i);
-				  work[idx2] = work[idx2] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-	      retval.resize (nc, b_nc);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
-		  for (octave_idx_type i = nr; i < nc; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(k+1)-1) != k ||
-			      data(cidx(k+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval.xelem (i, j) = work[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  if (work[k] != 0.)
-			    {
-			      Complex tmp = work[k] / data(cidx(k+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1)-1; i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Upper)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          octave_idx_type b_nc = b.cols ();
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          if (typ == MatrixType::Permuted_Upper)
+            {
+              retval.resize (nc, b_nc);
+              octave_idx_type *perm = mattype.triangular_perm ();
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[i] = b(i,j);
+                  for (octave_idx_type i = nr; i < nc; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      octave_idx_type kidx = perm[k];
+
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(kidx+1)-1) != k ||
+                              data(cidx(kidx+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(cidx(kidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(kidx); 
+                               i < cidx(kidx+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval (perm[i], j) = work[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          octave_idx_type iidx = perm[k];
+
+                          if (work[k] != 0.)
+                            {
+                              Complex tmp = work[k] / data(cidx(iidx+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(iidx); 
+                                   i < cidx(iidx+1)-1; i++)
+                                {
+                                  octave_idx_type idx2 = ridx(i);
+                                  work[idx2] = work[idx2] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+              retval.resize (nc, b_nc);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[i] = b(i,j);
+                  for (octave_idx_type i = nr; i < nc; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(k+1)-1) != k ||
+                              data(cidx(k+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(cidx(k+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval.xelem (i, j) = work[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              Complex tmp = work[k] / data(cidx(k+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1)-1; i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const SparseMatrix& b,
-			      octave_idx_type& err, double& rcond, 
-			      solve_singularity_handler sing_handler,
-			      bool calc_cond) const
+                              octave_idx_type& err, double& rcond, 
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -1815,283 +1815,283 @@ SparseComplexMatrix::utsolve (MatrixType
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Upper)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
-	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
-	  retval.xcidx(0) = 0;
-	  octave_idx_type ii = 0;
-	  octave_idx_type x_nz = b_nz;
-
-	  if (typ == MatrixType::Permuted_Upper)
-	    {
-	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
-	      for (octave_idx_type i = 0; i < nc; i++)
-		rperm[perm[i]] = i;
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      octave_idx_type kidx = perm[k];
-
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(kidx+1)-1) != k ||
-			      data(cidx(kidx+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(cidx(kidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(kidx); 
-			       i < cidx(kidx+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[rperm[i]] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[rperm[i]];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  octave_idx_type iidx = perm[k];
-
-			  if (work[k] != 0.)
-			    {
-			      Complex tmp = work[k] / data(cidx(iidx+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(iidx); 
-				   i < cidx(iidx+1)-1; i++)
-				{
-				  octave_idx_type idx2 = ridx(i);
-				  work[idx2] = work[idx2] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(k+1)-1) != k ||
-			      data(cidx(k+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  if (work[k] != 0.)
-			    {
-			      Complex tmp = work[k] / data(cidx(k+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1)-1; i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Upper)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          octave_idx_type b_nc = b.cols ();
+          octave_idx_type b_nz = b.nnz ();
+          retval = SparseComplexMatrix (nc, b_nc, b_nz);
+          retval.xcidx(0) = 0;
+          octave_idx_type ii = 0;
+          octave_idx_type x_nz = b_nz;
+
+          if (typ == MatrixType::Permuted_Upper)
+            {
+              octave_idx_type *perm = mattype.triangular_perm ();
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+              OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
+              for (octave_idx_type i = 0; i < nc; i++)
+                rperm[perm[i]] = i;
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[b.ridx(i)] = b.data(i);
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      octave_idx_type kidx = perm[k];
+
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(kidx+1)-1) != k ||
+                              data(cidx(kidx+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(cidx(kidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(kidx); 
+                               i < cidx(kidx+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[rperm[i]] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[rperm[i]];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          octave_idx_type iidx = perm[k];
+
+                          if (work[k] != 0.)
+                            {
+                              Complex tmp = work[k] / data(cidx(iidx+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(iidx); 
+                                   i < cidx(iidx+1)-1; i++)
+                                {
+                                  octave_idx_type idx2 = ridx(i);
+                                  work[idx2] = work[idx2] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[b.ridx(i)] = b.data(i);
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(k+1)-1) != k ||
+                              data(cidx(k+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(cidx(k+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              Complex tmp = work[k] / data(cidx(k+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1)-1; i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
-			      octave_idx_type& err, double& rcond, 
-			      solve_singularity_handler sing_handler,
-			      bool calc_cond) const
+                              octave_idx_type& err, double& rcond, 
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2102,232 +2102,232 @@ SparseComplexMatrix::utsolve (MatrixType
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Upper)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  if (typ == MatrixType::Permuted_Upper)
-	    {
-	      retval.resize (nc, b_nc);
-	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
-		  for (octave_idx_type i = nr; i < nc; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      octave_idx_type kidx = perm[k];
-
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(kidx+1)-1) != k ||
-			      data(cidx(kidx+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(cidx(kidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(kidx); 
-			       i < cidx(kidx+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval (perm[i], j) = work[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  octave_idx_type iidx = perm[k];
-
-			  if (work[k] != 0.)
-			    {
-			      Complex tmp = work[k] / data(cidx(iidx+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(iidx); 
-				   i < cidx(iidx+1)-1; i++)
-				{
-				  octave_idx_type idx2 = ridx(i);
-				  work[idx2] = work[idx2] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-	      retval.resize (nc, b_nc);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
-		  for (octave_idx_type i = nr; i < nc; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(k+1)-1) != k ||
-			      data(cidx(k+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval.xelem (i, j) = work[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  if (work[k] != 0.)
-			    {
-			      Complex tmp = work[k] / data(cidx(k+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1)-1; i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Upper)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          octave_idx_type b_nc = b.cols ();
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          if (typ == MatrixType::Permuted_Upper)
+            {
+              retval.resize (nc, b_nc);
+              octave_idx_type *perm = mattype.triangular_perm ();
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[i] = b(i,j);
+                  for (octave_idx_type i = nr; i < nc; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      octave_idx_type kidx = perm[k];
+
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(kidx+1)-1) != k ||
+                              data(cidx(kidx+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(cidx(kidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(kidx); 
+                               i < cidx(kidx+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval (perm[i], j) = work[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          octave_idx_type iidx = perm[k];
+
+                          if (work[k] != 0.)
+                            {
+                              Complex tmp = work[k] / data(cidx(iidx+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(iidx); 
+                                   i < cidx(iidx+1)-1; i++)
+                                {
+                                  octave_idx_type idx2 = ridx(i);
+                                  work[idx2] = work[idx2] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+              retval.resize (nc, b_nc);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[i] = b(i,j);
+                  for (octave_idx_type i = nr; i < nc; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(k+1)-1) != k ||
+                              data(cidx(k+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(cidx(k+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval.xelem (i, j) = work[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              Complex tmp = work[k] / data(cidx(k+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1)-1; i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-			      octave_idx_type& err, double& rcond, 
-			      solve_singularity_handler sing_handler,
-			      bool calc_cond) const
+                              octave_idx_type& err, double& rcond, 
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2338,284 +2338,284 @@ SparseComplexMatrix::utsolve (MatrixType
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Upper)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
-	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
-	  retval.xcidx(0) = 0;
-	  octave_idx_type ii = 0;
-	  octave_idx_type x_nz = b_nz;
-
-	  if (typ == MatrixType::Permuted_Upper)
-	    {
-	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
-	      for (octave_idx_type i = 0; i < nc; i++)
-		rperm[perm[i]] = i;
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      octave_idx_type kidx = perm[k];
-
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(kidx+1)-1) != k ||
-			      data(cidx(kidx+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(cidx(kidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(kidx); 
-			       i < cidx(kidx+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[rperm[i]] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[rperm[i]];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  octave_idx_type iidx = perm[k];
-
-			  if (work[k] != 0.)
-			    {
-			      Complex tmp = work[k] / data(cidx(iidx+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(iidx); 
-				   i < cidx(iidx+1)-1; i++)
-				{
-				  octave_idx_type idx2 = ridx(i);
-				  work[idx2] = work[idx2] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
-		    {
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(k+1)-1) != k ||
-			      data(cidx(k+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  if (work[k] != 0.)
-			    {
-			      Complex tmp = work[k] / data(cidx(k+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1)-1; i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Upper)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          octave_idx_type b_nc = b.cols ();
+          octave_idx_type b_nz = b.nnz ();
+          retval = SparseComplexMatrix (nc, b_nc, b_nz);
+          retval.xcidx(0) = 0;
+          octave_idx_type ii = 0;
+          octave_idx_type x_nz = b_nz;
+
+          if (typ == MatrixType::Permuted_Upper)
+            {
+              octave_idx_type *perm = mattype.triangular_perm ();
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+              OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
+              for (octave_idx_type i = 0; i < nc; i++)
+                rperm[perm[i]] = i;
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[b.ridx(i)] = b.data(i);
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      octave_idx_type kidx = perm[k];
+
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(kidx+1)-1) != k ||
+                              data(cidx(kidx+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(cidx(kidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(kidx); 
+                               i < cidx(kidx+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[rperm[i]] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[rperm[i]];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          octave_idx_type iidx = perm[k];
+
+                          if (work[k] != 0.)
+                            {
+                              Complex tmp = work[k] / data(cidx(iidx+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(iidx); 
+                                   i < cidx(iidx+1)-1; i++)
+                                {
+                                  octave_idx_type idx2 = ridx(i);
+                                  work[idx2] = work[idx2] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[b.ridx(i)] = b.data(i);
+
+                  for (octave_idx_type k = nr-1; k >= 0; k--)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(k+1)-1) != k ||
+                              data(cidx(k+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(cidx(k+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              Complex tmp = work[k] / data(cidx(k+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1)-1; i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const Matrix& b, 
-			      octave_idx_type& err, double& rcond, 
-			      solve_singularity_handler sing_handler,
-			      bool calc_cond) const
+                              octave_idx_type& err, double& rcond, 
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2626,252 +2626,252 @@ SparseComplexMatrix::ltsolve (MatrixType
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
-	  typ == MatrixType::Lower)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  if (typ == MatrixType::Permuted_Lower)
-	    {
-	      retval.resize (nc, b_nc);
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-	      octave_idx_type *perm = mattype.triangular_perm ();
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[perm[i]] = b(i,j);
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (work[k] != 0.)
-			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  if (minr != k || data (mini) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval (i, j) = work[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = 0; k < nc; k++)
-			{
-			  if (work[k] != 0.)
-			    {
-			      octave_idx_type minr = nr;
-			      octave_idx_type mini = 0;
-
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				if (perm[ridx(i)] < minr)
-				  {
-				    minr = perm[ridx(i)];
-				    mini = i;
-				  }
-
-			      Complex tmp = work[k] / data(mini);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				{
-				  if (i == mini)
-				    continue;
-
-				  octave_idx_type iidx = perm[ridx(i)];
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-	      retval.resize (nc, b_nc, 0.);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
-		  for (octave_idx_type i = nr; i < nc; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(k)) != k ||
-			      data(cidx(k)) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval.xelem (i, j) = work[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k < nc; k++)
-			{
-
-			  if (work[k] != 0.)
-			    {
-			      Complex tmp = work[k] / data(cidx(k));
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k)+1; 
-				   i < cidx(k+1); i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Lower)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          octave_idx_type b_nc = b.cols ();
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          if (typ == MatrixType::Permuted_Lower)
+            {
+              retval.resize (nc, b_nc);
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+              octave_idx_type *perm = mattype.triangular_perm ();
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[perm[i]] = b(i,j);
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          octave_idx_type minr = nr;
+                          octave_idx_type mini = 0;
+
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            if (perm[ridx(i)] < minr)
+                              {
+                                minr = perm[ridx(i)];
+                                mini = i;
+                              }
+
+                          if (minr != k || data (mini) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(mini);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            {
+                              if (i == mini)
+                                continue;
+
+                              octave_idx_type iidx = perm[ridx(i)];
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval (i, j) = work[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = 0; k < nc; k++)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              octave_idx_type minr = nr;
+                              octave_idx_type mini = 0;
+
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                if (perm[ridx(i)] < minr)
+                                  {
+                                    minr = perm[ridx(i)];
+                                    mini = i;
+                                  }
+
+                              Complex tmp = work[k] / data(mini);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                {
+                                  if (i == mini)
+                                    continue;
+
+                                  octave_idx_type iidx = perm[ridx(i)];
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+              retval.resize (nc, b_nc, 0.);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[i] = b(i,j);
+                  for (octave_idx_type i = nr; i < nc; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(k)) != k ||
+                              data(cidx(k)) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(cidx(k));
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval.xelem (i, j) = work[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k < nc; k++)
+                        {
+
+                          if (work[k] != 0.)
+                            {
+                              Complex tmp = work[k] / data(cidx(k));
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k)+1; 
+                                   i < cidx(k+1); i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b, 
-			      octave_idx_type& err, double& rcond, 
-			      solve_singularity_handler sing_handler,
-			      bool calc_cond) const
+                              octave_idx_type& err, double& rcond, 
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
 
   err = 0;
@@ -2883,303 +2883,303 @@ SparseComplexMatrix::ltsolve (MatrixType
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
-	  typ == MatrixType::Lower)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
-	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
-	  retval.xcidx(0) = 0;
-	  octave_idx_type ii = 0;
-	  octave_idx_type x_nz = b_nz;
-
-	  if (typ == MatrixType::Permuted_Lower)
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-	      octave_idx_type *perm = mattype.triangular_perm ();
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[perm[b.ridx(i)]] = b.data(i);
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (work[k] != 0.)
-			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  if (minr != k || data (mini) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = 0; k < nc; k++)
-			{
-			  if (work[k] != 0.)
-			    {
-			      octave_idx_type minr = nr;
-			      octave_idx_type mini = 0;
-
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				if (perm[ridx(i)] < minr)
-				  {
-				    minr = perm[ridx(i)];
-				    mini = i;
-				  }
-
-			      Complex tmp = work[k] / data(mini);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				{
-				  if (i == mini)
-				    continue;
-
-				  octave_idx_type iidx = perm[ridx(i)];
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(k)) != k ||
-			      data(cidx(k)) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k < nc; k++)
-			{
-
-			  if (work[k] != 0.)
-			    {
-			      Complex tmp = work[k] / data(cidx(k));
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k)+1; 
-				   i < cidx(k+1); i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Lower)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          octave_idx_type b_nc = b.cols ();
+          octave_idx_type b_nz = b.nnz ();
+          retval = SparseComplexMatrix (nc, b_nc, b_nz);
+          retval.xcidx(0) = 0;
+          octave_idx_type ii = 0;
+          octave_idx_type x_nz = b_nz;
+
+          if (typ == MatrixType::Permuted_Lower)
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+              octave_idx_type *perm = mattype.triangular_perm ();
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[perm[b.ridx(i)]] = b.data(i);
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          octave_idx_type minr = nr;
+                          octave_idx_type mini = 0;
+
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            if (perm[ridx(i)] < minr)
+                              {
+                                minr = perm[ridx(i)];
+                                mini = i;
+                              }
+
+                          if (minr != k || data (mini) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(mini);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            {
+                              if (i == mini)
+                                continue;
+
+                              octave_idx_type iidx = perm[ridx(i)];
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = 0; k < nc; k++)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              octave_idx_type minr = nr;
+                              octave_idx_type mini = 0;
+
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                if (perm[ridx(i)] < minr)
+                                  {
+                                    minr = perm[ridx(i)];
+                                    mini = i;
+                                  }
+
+                              Complex tmp = work[k] / data(mini);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                {
+                                  if (i == mini)
+                                    continue;
+
+                                  octave_idx_type iidx = perm[ridx(i)];
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[b.ridx(i)] = b.data(i);
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(k)) != k ||
+                              data(cidx(k)) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(cidx(k));
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k < nc; k++)
+                        {
+
+                          if (work[k] != 0.)
+                            {
+                              Complex tmp = work[k] / data(cidx(k));
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k)+1; 
+                                   i < cidx(k+1); i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
-			      octave_idx_type& err, double& rcond,
-			      solve_singularity_handler sing_handler,
-			      bool calc_cond) const
+                              octave_idx_type& err, double& rcond,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -3190,256 +3190,256 @@ SparseComplexMatrix::ltsolve (MatrixType
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
-	  typ == MatrixType::Lower)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  if (typ == MatrixType::Permuted_Lower)
-	    {
-	      retval.resize (nc, b_nc);
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-	      octave_idx_type *perm = mattype.triangular_perm ();
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[perm[i]] = b(i,j);
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (work[k] != 0.)
-			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  if (minr != k || data (mini) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval (i, j) = work[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = 0; k < nc; k++)
-			{
-			  if (work[k] != 0.)
-			    {
-			      octave_idx_type minr = nr;
-			      octave_idx_type mini = 0;
-
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				if (perm[ridx(i)] < minr)
-				  {
-				    minr = perm[ridx(i)];
-				    mini = i;
-				  }
-
-			      Complex tmp = work[k] / data(mini);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				{
-				  if (i == mini)
-				    continue;
-
-				  octave_idx_type iidx = perm[ridx(i)];
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-	      retval.resize (nc, b_nc, 0.);
-
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
-		  for (octave_idx_type i = nr; i < nc; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(k)) != k ||
-			      data(cidx(k)) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval.xelem (i, j) = work[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k < nc; k++)
-			{
-
-			  if (work[k] != 0.)
-			    {
-			      Complex tmp = work[k] / data(cidx(k));
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k)+1; 
-				   i < cidx(k+1); i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Lower)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          octave_idx_type b_nc = b.cols ();
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          if (typ == MatrixType::Permuted_Lower)
+            {
+              retval.resize (nc, b_nc);
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+              octave_idx_type *perm = mattype.triangular_perm ();
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[perm[i]] = b(i,j);
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          octave_idx_type minr = nr;
+                          octave_idx_type mini = 0;
+
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            if (perm[ridx(i)] < minr)
+                              {
+                                minr = perm[ridx(i)];
+                                mini = i;
+                              }
+
+                          if (minr != k || data (mini) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(mini);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            {
+                              if (i == mini)
+                                continue;
+
+                              octave_idx_type iidx = perm[ridx(i)];
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval (i, j) = work[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = 0; k < nc; k++)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              octave_idx_type minr = nr;
+                              octave_idx_type mini = 0;
+
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                if (perm[ridx(i)] < minr)
+                                  {
+                                    minr = perm[ridx(i)];
+                                    mini = i;
+                                  }
+
+                              Complex tmp = work[k] / data(mini);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                {
+                                  if (i == mini)
+                                    continue;
+
+                                  octave_idx_type iidx = perm[ridx(i)];
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+              retval.resize (nc, b_nc, 0.);
+
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[i] = b(i,j);
+                  for (octave_idx_type i = nr; i < nc; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(k)) != k ||
+                              data(cidx(k)) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(cidx(k));
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval.xelem (i, j) = work[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k < nc; k++)
+                        {
+
+                          if (work[k] != 0.)
+                            {
+                              Complex tmp = work[k] / data(cidx(k));
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k)+1; 
+                                   i < cidx(k+1); i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-			      octave_idx_type& err, double& rcond, 
-			      solve_singularity_handler sing_handler,
-			      bool calc_cond) const
+                              octave_idx_type& err, double& rcond, 
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -3450,303 +3450,303 @@ SparseComplexMatrix::ltsolve (MatrixType
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
-	  typ == MatrixType::Lower)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
-	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
-	  retval.xcidx(0) = 0;
-	  octave_idx_type ii = 0;
-	  octave_idx_type x_nz = b_nz;
-
-	  if (typ == MatrixType::Permuted_Lower)
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-	      octave_idx_type *perm = mattype.triangular_perm ();
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[perm[b.ridx(i)]] = b.data(i);
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (work[k] != 0.)
-			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  if (minr != k || data (mini) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = 0; k < nc; k++)
-			{
-			  if (work[k] != 0.)
-			    {
-			      octave_idx_type minr = nr;
-			      octave_idx_type mini = 0;
-
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				if (perm[ridx(i)] < minr)
-				  {
-				    minr = perm[ridx(i)];
-				    mini = i;
-				  }
-
-			      Complex tmp = work[k] / data(mini);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				{
-				  if (i == mini)
-				    continue;
-
-				  octave_idx_type iidx = perm[ridx(i)];
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(k)) != k ||
-			      data(cidx(k)) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k < nc; k++)
-			{
-
-			  if (work[k] != 0.)
-			    {
-			      Complex tmp = work[k] / data(cidx(k));
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k)+1; 
-				   i < cidx(k+1); i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += std::abs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Lower)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          octave_idx_type b_nc = b.cols ();
+          octave_idx_type b_nz = b.nnz ();
+          retval = SparseComplexMatrix (nc, b_nc, b_nz);
+          retval.xcidx(0) = 0;
+          octave_idx_type ii = 0;
+          octave_idx_type x_nz = b_nz;
+
+          if (typ == MatrixType::Permuted_Lower)
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+              octave_idx_type *perm = mattype.triangular_perm ();
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[perm[b.ridx(i)]] = b.data(i);
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          octave_idx_type minr = nr;
+                          octave_idx_type mini = 0;
+
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            if (perm[ridx(i)] < minr)
+                              {
+                                minr = perm[ridx(i)];
+                                mini = i;
+                              }
+
+                          if (minr != k || data (mini) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(mini);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            {
+                              if (i == mini)
+                                continue;
+
+                              octave_idx_type iidx = perm[ridx(i)];
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = 0; k < nc; k++)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              octave_idx_type minr = nr;
+                              octave_idx_type mini = 0;
+
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                if (perm[ridx(i)] < minr)
+                                  {
+                                    minr = perm[ridx(i)];
+                                    mini = i;
+                                  }
+
+                              Complex tmp = work[k] / data(mini);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                {
+                                  if (i == mini)
+                                    continue;
+
+                                  octave_idx_type iidx = perm[ridx(i)];
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[b.ridx(i)] = b.data(i);
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(k)) != k ||
+                              data(cidx(k)) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = work[k] / data(cidx(k));
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k < nc; k++)
+                        {
+
+                          if (work[k] != 0.)
+                            {
+                              Complex tmp = work[k] / data(cidx(k));
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k)+1; 
+                                   i < cidx(k+1); i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += std::abs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::trisolve (MatrixType &mattype, const Matrix& b,
-			       octave_idx_type& err, double& rcond,
-			       solve_singularity_handler sing_handler,
-			       bool calc_cond) const
+                               octave_idx_type& err, double& rcond,
+                               solve_singularity_handler sing_handler,
+                               bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -3759,145 +3759,145 @@ SparseComplexMatrix::trisolve (MatrixTyp
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Tridiagonal_Hermitian)
-	{
-	  OCTAVE_LOCAL_BUFFER (double, D, nr);
-	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-
-	  if (mattype.is_dense ())
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < nc-1; j++)
-		{
-		  D[j] = std::real(data(ii++));
-		  DL[j] = data(ii);
-		  ii += 2;
-		}
-	      D[nc-1] = std::real(data(ii));
-	    }
-	  else
-	    {
-	      D[0] = 0.;
-	      for (octave_idx_type i = 0; i < nr - 1; i++)
-		{
-		  D[i+1] = 0.;
-		  DL[i] = 0.;
-		}
-
-	      for (octave_idx_type j = 0; j < nc; j++)
-		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		  {
-		    if (ridx(i) == j)
-		      D[j] = std::real(data(i));
-		    else if (ridx(i) == j + 1)
-		      DL[j] = data(i);
-		  }
-	    }
-	      
-	  octave_idx_type b_nc = b.cols();
-	  retval = ComplexMatrix (b);
-	  Complex *result = retval.fortran_vec ();
-
-	  F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
-				   b.rows(), err));
-
-	  if (err != 0)
-	    {
-	      err = 0;
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Tridiagonal;
-	    }
-	  else 
-	    rcond = 1.;
-	}
+        {
+          OCTAVE_LOCAL_BUFFER (double, D, nr);
+          OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
+
+          if (mattype.is_dense ())
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < nc-1; j++)
+                {
+                  D[j] = std::real(data(ii++));
+                  DL[j] = data(ii);
+                  ii += 2;
+                }
+              D[nc-1] = std::real(data(ii));
+            }
+          else
+            {
+              D[0] = 0.;
+              for (octave_idx_type i = 0; i < nr - 1; i++)
+                {
+                  D[i+1] = 0.;
+                  DL[i] = 0.;
+                }
+
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  {
+                    if (ridx(i) == j)
+                      D[j] = std::real(data(i));
+                    else if (ridx(i) == j + 1)
+                      DL[j] = data(i);
+                  }
+            }
+              
+          octave_idx_type b_nc = b.cols();
+          retval = ComplexMatrix (b);
+          Complex *result = retval.fortran_vec ();
+
+          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
+                                   b.rows(), err));
+
+          if (err != 0)
+            {
+              err = 0;
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Tridiagonal;
+            }
+          else 
+            rcond = 1.;
+        }
 
       if (typ == MatrixType::Tridiagonal)
-	{
-	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
-	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
-	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-
-	  if (mattype.is_dense ())
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < nc-1; j++)
-		{
-		  D[j] = data(ii++);
-		  DL[j] = data(ii++);
-		  DU[j] = data(ii++);
-		}
-	      D[nc-1] = data(ii);
-	    }
-	  else
-	    {
-	      D[0] = 0.;
-	      for (octave_idx_type i = 0; i < nr - 1; i++)
-		{
-		  D[i+1] = 0.;
-		  DL[i] = 0.;
-		  DU[i] = 0.;
-		}
-
-	      for (octave_idx_type j = 0; j < nc; j++)
-		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		  {
-		    if (ridx(i) == j)
-		      D[j] = data(i);
-		    else if (ridx(i) == j + 1)
-		      DL[j] = data(i);
-		    else if (ridx(i) == j - 1)
-		      DU[j-1] = data(i);
-		  }
-	    }
-
-	  octave_idx_type b_nc = b.cols();
-	  retval = ComplexMatrix (b);
-	  Complex *result = retval.fortran_vec ();
-
-	  F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
-				   b.rows(), err));
-
-	  if (err != 0)
-	    {
-	      rcond = 0.;
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    } 
-	  else 
-	    rcond = 1.;
-	}
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
+          OCTAVE_LOCAL_BUFFER (Complex, D, nr);
+          OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
+
+          if (mattype.is_dense ())
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < nc-1; j++)
+                {
+                  D[j] = data(ii++);
+                  DL[j] = data(ii++);
+                  DU[j] = data(ii++);
+                }
+              D[nc-1] = data(ii);
+            }
+          else
+            {
+              D[0] = 0.;
+              for (octave_idx_type i = 0; i < nr - 1; i++)
+                {
+                  D[i+1] = 0.;
+                  DL[i] = 0.;
+                  DU[i] = 0.;
+                }
+
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  {
+                    if (ridx(i) == j)
+                      D[j] = data(i);
+                    else if (ridx(i) == j + 1)
+                      DL[j] = data(i);
+                    else if (ridx(i) == j - 1)
+                      DU[j-1] = data(i);
+                  }
+            }
+
+          octave_idx_type b_nc = b.cols();
+          retval = ComplexMatrix (b);
+          Complex *result = retval.fortran_vec ();
+
+          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
+                                   b.rows(), err));
+
+          if (err != 0)
+            {
+              rcond = 0.;
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+            } 
+          else 
+            rcond = 1.;
+        }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
-	       (*current_liboctave_error_handler) ("incorrect matrix type");
+               (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::trisolve (MatrixType &mattype, const SparseMatrix& b,
-			       octave_idx_type& err, double& rcond, 
-			       solve_singularity_handler sing_handler,
-			       bool calc_cond) const
+                               octave_idx_type& err, double& rcond, 
+                               solve_singularity_handler sing_handler,
+                               bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -3911,140 +3911,140 @@ SparseComplexMatrix::trisolve (MatrixTyp
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
-	  typ == MatrixType::Tridiagonal_Hermitian)
-	{
-	  OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
-	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
-	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
-	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  if (mattype.is_dense ())
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < nc-1; j++)
-		{
-		  D[j] = data(ii++);
-		  DL[j] = data(ii++);
-		  DU[j] = data(ii++);
-		}
-	      D[nc-1] = data(ii);
-	    }
-	  else
-	    {
-	      D[0] = 0.;
-	      for (octave_idx_type i = 0; i < nr - 1; i++)
-		{
-		  D[i+1] = 0.;
-		  DL[i] = 0.;
-		  DU[i] = 0.;
-		}
-
-	      for (octave_idx_type j = 0; j < nc; j++)
-		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		  {
-		    if (ridx(i) == j)
-		      D[j] = data(i);
-		    else if (ridx(i) == j + 1)
-		      DL[j] = data(i);
-		    else if (ridx(i) == j - 1)
-		      DU[j-1] = data(i);
-		  }
-	    }
-
-	  F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
-
-	  if (err != 0) 
-	    {
-	      err = -2;
-	      rcond = 0.0;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    } 
-	  else 
-	    {
-	      char job = 'N';
-	      volatile octave_idx_type x_nz = b.nnz ();
-	      octave_idx_type b_nc = b.cols ();
-	      retval = SparseComplexMatrix (nr, b_nc, x_nz);
-	      retval.xcidx(0) = 0;
-	      volatile octave_idx_type ii = 0;
-	      rcond = 1.0;
-
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-
-	      for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  F77_XFCN (zgttrs, ZGTTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, 1, DL, D, DU, DU2, pipvt, 
-			     work, b.rows (), err
-			     F77_CHAR_ARG_LEN (1)));
-
-		  // Count non-zeros in work vector and adjust 
-		  // space in retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-	    }
-	}
+          typ == MatrixType::Tridiagonal_Hermitian)
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
+          OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
+          OCTAVE_LOCAL_BUFFER (Complex, D, nr);
+          OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          if (mattype.is_dense ())
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < nc-1; j++)
+                {
+                  D[j] = data(ii++);
+                  DL[j] = data(ii++);
+                  DU[j] = data(ii++);
+                }
+              D[nc-1] = data(ii);
+            }
+          else
+            {
+              D[0] = 0.;
+              for (octave_idx_type i = 0; i < nr - 1; i++)
+                {
+                  D[i+1] = 0.;
+                  DL[i] = 0.;
+                  DU[i] = 0.;
+                }
+
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  {
+                    if (ridx(i) == j)
+                      D[j] = data(i);
+                    else if (ridx(i) == j + 1)
+                      DL[j] = data(i);
+                    else if (ridx(i) == j - 1)
+                      DU[j-1] = data(i);
+                  }
+            }
+
+          F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
+
+          if (err != 0) 
+            {
+              err = -2;
+              rcond = 0.0;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+            } 
+          else 
+            {
+              char job = 'N';
+              volatile octave_idx_type x_nz = b.nnz ();
+              octave_idx_type b_nc = b.cols ();
+              retval = SparseComplexMatrix (nr, b_nc, x_nz);
+              retval.xcidx(0) = 0;
+              volatile octave_idx_type ii = 0;
+              rcond = 1.0;
+
+              OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+
+              for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[b.ridx(i)] = b.data(i);
+
+                  F77_XFCN (zgttrs, ZGTTRS, 
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, 1, DL, D, DU, DU2, pipvt, 
+                             work, b.rows (), err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  // Count non-zeros in work vector and adjust 
+                  // space in retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    if (work[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+            }
+        }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::trisolve (MatrixType &mattype, const ComplexMatrix& b,
-			       octave_idx_type& err, double& rcond, 
-			       solve_singularity_handler sing_handler,
-			       bool calc_cond) const
+                               octave_idx_type& err, double& rcond, 
+                               solve_singularity_handler sing_handler,
+                               bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -4057,147 +4057,147 @@ SparseComplexMatrix::trisolve (MatrixTyp
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Tridiagonal_Hermitian)
-	{
-	  OCTAVE_LOCAL_BUFFER (double, D, nr);
-	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-
-	  if (mattype.is_dense ())
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < nc-1; j++)
-		{
-		  D[j] = std::real(data(ii++));
-		  DL[j] = data(ii);
-		  ii += 2;
-		}
-	      D[nc-1] = std::real(data(ii));
-	    }
-	  else
-	    {
-	      D[0] = 0.;
-	      for (octave_idx_type i = 0; i < nr - 1; i++)
-		{
-		  D[i+1] = 0.;
-		  DL[i] = 0.;
-		}
-
-	      for (octave_idx_type j = 0; j < nc; j++)
-		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		  {
-		    if (ridx(i) == j)
-		      D[j] = std::real (data(i));
-		    else if (ridx(i) == j + 1)
-		      DL[j] = data(i);
-		  }
-	    }
-
-	  octave_idx_type b_nr = b.rows ();
-	  octave_idx_type b_nc = b.cols();
-	  rcond = 1.;
-
-	  retval = ComplexMatrix (b);
-	  Complex *result = retval.fortran_vec ();
-		  
-	  F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
-				   b_nr, err));
-
-	  if (err != 0)
-	    {
-	      err = 0;
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Tridiagonal;
-	    }
-	}
+        {
+          OCTAVE_LOCAL_BUFFER (double, D, nr);
+          OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
+
+          if (mattype.is_dense ())
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < nc-1; j++)
+                {
+                  D[j] = std::real(data(ii++));
+                  DL[j] = data(ii);
+                  ii += 2;
+                }
+              D[nc-1] = std::real(data(ii));
+            }
+          else
+            {
+              D[0] = 0.;
+              for (octave_idx_type i = 0; i < nr - 1; i++)
+                {
+                  D[i+1] = 0.;
+                  DL[i] = 0.;
+                }
+
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  {
+                    if (ridx(i) == j)
+                      D[j] = std::real (data(i));
+                    else if (ridx(i) == j + 1)
+                      DL[j] = data(i);
+                  }
+            }
+
+          octave_idx_type b_nr = b.rows ();
+          octave_idx_type b_nc = b.cols();
+          rcond = 1.;
+
+          retval = ComplexMatrix (b);
+          Complex *result = retval.fortran_vec ();
+                  
+          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
+                                   b_nr, err));
+
+          if (err != 0)
+            {
+              err = 0;
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Tridiagonal;
+            }
+        }
 
       if (typ == MatrixType::Tridiagonal)
-	{
-	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
-	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
-	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-
-	  if (mattype.is_dense ())
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < nc-1; j++)
-		{
-		  D[j] = data(ii++);
-		  DL[j] = data(ii++);
-		  DU[j] = data(ii++);
-		}
-	      D[nc-1] = data(ii);
-	    }
-	  else
-	    {
-	      D[0] = 0.;
-	      for (octave_idx_type i = 0; i < nr - 1; i++)
-		{
-		  D[i+1] = 0.;
-		  DL[i] = 0.;
-		  DU[i] = 0.;
-		}
-
-	      for (octave_idx_type j = 0; j < nc; j++)
-		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		  {
-		    if (ridx(i) == j)
-		      D[j] = data(i);
-		    else if (ridx(i) == j + 1)
-		      DL[j] = data(i);
-		    else if (ridx(i) == j - 1)
-		      DU[j-1] = data(i);
-		  }
-	    }
-
-	  octave_idx_type b_nr = b.rows();
-	  octave_idx_type b_nc = b.cols();
-	  rcond = 1.;
-
-	  retval = ComplexMatrix (b);
-	  Complex *result = retval.fortran_vec ();
-	      
-	  F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
-				   b_nr, err));
-
-	  if (err != 0)
-	    {
-	      rcond = 0.;
-	      err = -2;
-		      
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-	    }
-	}
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
+          OCTAVE_LOCAL_BUFFER (Complex, D, nr);
+          OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
+
+          if (mattype.is_dense ())
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < nc-1; j++)
+                {
+                  D[j] = data(ii++);
+                  DL[j] = data(ii++);
+                  DU[j] = data(ii++);
+                }
+              D[nc-1] = data(ii);
+            }
+          else
+            {
+              D[0] = 0.;
+              for (octave_idx_type i = 0; i < nr - 1; i++)
+                {
+                  D[i+1] = 0.;
+                  DL[i] = 0.;
+                  DU[i] = 0.;
+                }
+
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  {
+                    if (ridx(i) == j)
+                      D[j] = data(i);
+                    else if (ridx(i) == j + 1)
+                      DL[j] = data(i);
+                    else if (ridx(i) == j - 1)
+                      DU[j-1] = data(i);
+                  }
+            }
+
+          octave_idx_type b_nr = b.rows();
+          octave_idx_type b_nc = b.cols();
+          rcond = 1.;
+
+          retval = ComplexMatrix (b);
+          Complex *result = retval.fortran_vec ();
+              
+          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
+                                   b_nr, err));
+
+          if (err != 0)
+            {
+              rcond = 0.;
+              err = -2;
+                      
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+            }
+        }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::trisolve (MatrixType &mattype, 
-			       const SparseComplexMatrix& b, 
-			       octave_idx_type& err, double& rcond, 
-			       solve_singularity_handler sing_handler,
-			       bool calc_cond) const
+                               const SparseComplexMatrix& b, 
+                               octave_idx_type& err, double& rcond, 
+                               solve_singularity_handler sing_handler,
+                               bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -4211,151 +4211,151 @@ SparseComplexMatrix::trisolve (MatrixTyp
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
-	  typ == MatrixType::Tridiagonal_Hermitian)
-	{
-	  OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
-	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
-	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
-	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  if (mattype.is_dense ())
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < nc-1; j++)
-		{
-		  D[j] = data(ii++);
-		  DL[j] = data(ii++);
-		  DU[j] = data(ii++);
-		}
-	      D[nc-1] = data(ii);
-	    }
-	  else
-	    {
-	      D[0] = 0.;
-	      for (octave_idx_type i = 0; i < nr - 1; i++)
-		{
-		  D[i+1] = 0.;
-		  DL[i] = 0.;
-		  DU[i] = 0.;
-		}
-
-	      for (octave_idx_type j = 0; j < nc; j++)
-		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		  {
-		    if (ridx(i) == j)
-		      D[j] = data(i);
-		    else if (ridx(i) == j + 1)
-		      DL[j] = data(i);
-		    else if (ridx(i) == j - 1)
-		      DU[j-1] = data(i);
-		  }
-	    }
-
-	  F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
-
-	  if (err != 0) 
-	    {
-	      rcond = 0.0;
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-	    } 
-	  else 
-	    {	
-	      rcond = 1.;
-	      char job = 'N';
-	      octave_idx_type b_nr = b.rows ();
-	      octave_idx_type b_nc = b.cols ();
-	      OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
-
-	      // Take a first guess that the number of non-zero terms
-	      // will be as many as in b
-	      volatile octave_idx_type x_nz = b.nnz ();
-	      volatile octave_idx_type ii = 0;
-	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-	      retval.xcidx(0) = 0;
-	      for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		{
-
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    Bx[i] = b (i,j);
-
-		  F77_XFCN (zgttrs, ZGTTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, 1, DL, D, DU, DU2, pipvt, 
-			     Bx, b_nr, err
-			     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0)
-		    {
-		      (*current_liboctave_error_handler)
-			("SparseComplexMatrix::solve solve failed");
-
-		      err = -1;
-		      break;
-		    }
-
-		  // Count non-zeros in work vector and adjust 
-		  // space in retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (Bx[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (Bx[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = Bx[i];
-		      }
-
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-	    }
-	}
+          typ == MatrixType::Tridiagonal_Hermitian)
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
+          OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
+          OCTAVE_LOCAL_BUFFER (Complex, D, nr);
+          OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          if (mattype.is_dense ())
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < nc-1; j++)
+                {
+                  D[j] = data(ii++);
+                  DL[j] = data(ii++);
+                  DU[j] = data(ii++);
+                }
+              D[nc-1] = data(ii);
+            }
+          else
+            {
+              D[0] = 0.;
+              for (octave_idx_type i = 0; i < nr - 1; i++)
+                {
+                  D[i+1] = 0.;
+                  DL[i] = 0.;
+                  DU[i] = 0.;
+                }
+
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  {
+                    if (ridx(i) == j)
+                      D[j] = data(i);
+                    else if (ridx(i) == j + 1)
+                      DL[j] = data(i);
+                    else if (ridx(i) == j - 1)
+                      DU[j-1] = data(i);
+                  }
+            }
+
+          F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
+
+          if (err != 0) 
+            {
+              rcond = 0.0;
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+            } 
+          else 
+            {   
+              rcond = 1.;
+              char job = 'N';
+              octave_idx_type b_nr = b.rows ();
+              octave_idx_type b_nc = b.cols ();
+              OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
+
+              // Take a first guess that the number of non-zero terms
+              // will be as many as in b
+              volatile octave_idx_type x_nz = b.nnz ();
+              volatile octave_idx_type ii = 0;
+              retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+              retval.xcidx(0) = 0;
+              for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                {
+
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    Bx[i] = b (i,j);
+
+                  F77_XFCN (zgttrs, ZGTTRS, 
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, 1, DL, D, DU, DU2, pipvt, 
+                             Bx, b_nr, err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
+                    {
+                      (*current_liboctave_error_handler)
+                        ("SparseComplexMatrix::solve solve failed");
+
+                      err = -1;
+                      break;
+                    }
+
+                  // Count non-zeros in work vector and adjust 
+                  // space in retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    if (Bx[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    if (Bx[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = Bx[i];
+                      }
+
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+            }
+        }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::bsolve (MatrixType &mattype, const Matrix& b,
-			     octave_idx_type& err, double& rcond,
-			     solve_singularity_handler sing_handler,
-			     bool calc_cond) const
+                             octave_idx_type& err, double& rcond,
+                             solve_singularity_handler sing_handler,
+                             bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -4365,245 +4365,245 @@ SparseComplexMatrix::bsolve (MatrixType 
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
-	{
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_lower + 1;
-	  ComplexMatrix m_band (ldm, nc);
-	  Complex *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      {
-		octave_idx_type ri = ridx (i);
-		if (ri >= j)
-		  m_band(ri - j, j) = data(i);
-	      }
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    anorm = m_band.abs().sum().row(0).max();
-
-	  char job = 'L';
-	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, tmp_data, ldm, err
-				     F77_CHAR_ARG_LEN (1)));
-	    
-	  if (err != 0) 
-	    {
-	      rcond = 0.0;
-	      // Matrix is not positive definite!! Fall through to
-	      // unsymmetric banded solver.
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Banded;
-	      err = 0;
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  Array<Complex> z (2 * nr);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> iz (nr);
-		  double *piz = iz.fortran_vec ();
-
-		  F77_XFCN (zpbcon, ZPBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nr, n_lower, tmp_data, ldm,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.0;
-
-	      if (err == 0)
-		{
-		  retval = ComplexMatrix (b);
-		  Complex *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  F77_XFCN (zpbtrs, ZPBTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, n_lower, b_nc, tmp_data,
-			     ldm, result, b.rows(), err
-			     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseMatrix::solve solve failed");
-		      err = -1;
-		    }
-		}
-	    }
-	}
+        {
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_lower + 1;
+          ComplexMatrix m_band (ldm, nc);
+          Complex *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              {
+                octave_idx_type ri = ridx (i);
+                if (ri >= j)
+                  m_band(ri - j, j) = data(i);
+              }
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            anorm = m_band.abs().sum().row(0).max();
+
+          char job = 'L';
+          F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nr, n_lower, tmp_data, ldm, err
+                                     F77_CHAR_ARG_LEN (1)));
+            
+          if (err != 0) 
+            {
+              rcond = 0.0;
+              // Matrix is not positive definite!! Fall through to
+              // unsymmetric banded solver.
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Banded;
+              err = 0;
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  Array<Complex> z (2 * nr);
+                  Complex *pz = z.fortran_vec ();
+                  Array<double> iz (nr);
+                  double *piz = iz.fortran_vec ();
+
+                  F77_XFCN (zpbcon, ZPBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nr, n_lower, tmp_data, ldm,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.0;
+
+              if (err == 0)
+                {
+                  retval = ComplexMatrix (b);
+                  Complex *result = retval.fortran_vec ();
+
+                  octave_idx_type b_nc = b.cols ();
+
+                  F77_XFCN (zpbtrs, ZPBTRS, 
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, b_nc, tmp_data,
+                             ldm, result, b.rows(), err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseMatrix::solve solve failed");
+                      err = -1;
+                    }
+                }
+            }
+        }
 
       if (typ == MatrixType::Banded)
-	{
-	  // Create the storage for the banded form of the sparse matrix
-	  octave_idx_type n_upper = mattype.nupper ();
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
-
-	  ComplexMatrix m_band (ldm, nc);
-	  Complex *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    {
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper, tmp_data, 
-				     ldm, pipvt, err));
-	    
-	  // Throw-away extra info LAPACK gives so as to not 
-	  // change output.
-	  if (err != 0) 
-	    {
-	      rcond = 0.0;
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  char job = '1';
-		  Array<Complex> z (2 * nr);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> iz (nr);
-		  double *piz = iz.fortran_vec ();
-
-		  F77_XFCN (zgbcon, ZGBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		   if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.;
-
-	      if (err == 0)
-		{
-		  retval = ComplexMatrix (b);
-		  Complex *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  char job = 'N';
-		  F77_XFCN (zgbtrs, ZGBTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, n_lower, n_upper, b_nc, tmp_data,
-			     ldm, pipvt, result, b.rows(), err
-			     F77_CHAR_ARG_LEN (1)));
-		}
-	    }
-	}
+        {
+          // Create the storage for the banded form of the sparse matrix
+          octave_idx_type n_upper = mattype.nupper ();
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+
+          ComplexMatrix m_band (ldm, nc);
+          Complex *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            {
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper, tmp_data, 
+                                     ldm, pipvt, err));
+            
+          // Throw-away extra info LAPACK gives so as to not 
+          // change output.
+          if (err != 0) 
+            {
+              rcond = 0.0;
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  char job = '1';
+                  Array<Complex> z (2 * nr);
+                  Complex *pz = z.fortran_vec ();
+                  Array<double> iz (nr);
+                  double *piz = iz.fortran_vec ();
+
+                  F77_XFCN (zgbcon, ZGBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                   if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.;
+
+              if (err == 0)
+                {
+                  retval = ComplexMatrix (b);
+                  Complex *result = retval.fortran_vec ();
+
+                  octave_idx_type b_nc = b.cols ();
+
+                  char job = 'N';
+                  F77_XFCN (zgbtrs, ZGBTRS, 
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, n_upper, b_nc, tmp_data,
+                             ldm, pipvt, result, b.rows(), err
+                             F77_CHAR_ARG_LEN (1)));
+                }
+            }
+        }
       else if (typ != MatrixType::Banded_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::bsolve (MatrixType &mattype, const SparseMatrix& b,
-			     octave_idx_type& err, double& rcond, 
-			     solve_singularity_handler sing_handler,
-			     bool calc_cond) const
+                             octave_idx_type& err, double& rcond, 
+                             solve_singularity_handler sing_handler,
+                             bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -4613,315 +4613,315 @@ SparseComplexMatrix::bsolve (MatrixType 
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
-	{
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_lower + 1;
-
-	  ComplexMatrix m_band (ldm, nc);
-	  Complex *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      {
-		octave_idx_type ri = ridx (i);
-		if (ri >= j)
-		  m_band(ri - j, j) = data(i);
-	      }
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    anorm = m_band.abs().sum().row(0).max();
-
-	  char job = 'L';
-	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, tmp_data, ldm, err
-				     F77_CHAR_ARG_LEN (1)));
-	    
-	  if (err != 0) 
-	    {
-	      rcond = 0.0;
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Banded;
-	      err = 0;
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  Array<Complex> z (2 * nr);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> iz (nr);
-		  double *piz = iz.fortran_vec ();
-
-		  F77_XFCN (zpbcon, ZPBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nr, n_lower, tmp_data, ldm,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.0;
-
-	      if (err == 0)
-		{
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
-
-		  // Take a first guess that the number of non-zero terms
-		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nnz ();
-		  volatile octave_idx_type ii = 0;
-		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-		  retval.xcidx(0) = 0;
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		    {
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			Bx[i] = b.elem (i, j);
-
-		      F77_XFCN (zpbtrs, ZPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bx, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseComplexMatrix::solve solve failed");
-			  err = -1;
-			  break;
-			}
-
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			{
-			  Complex tmp = Bx[i];
-			  if (tmp != 0.0)
-			    {
-			      if (ii == x_nz)
-				{
-				  // Resize the sparse matrix
-				  octave_idx_type sz = x_nz * 
-				    (b_nc - j) / b_nc;
-				  sz = (sz > 10 ? sz : 10) + x_nz;
-				  retval.change_capacity (sz);
-				  x_nz = sz;
-				}
-			      retval.xdata(ii) = tmp;
-			      retval.xridx(ii++) = i;
-			    }
-			}
-		      retval.xcidx(j+1) = ii;
-		    }
-
-		  retval.maybe_compress ();
-		}
-	    }
-	}
+        {
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_lower + 1;
+
+          ComplexMatrix m_band (ldm, nc);
+          Complex *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              {
+                octave_idx_type ri = ridx (i);
+                if (ri >= j)
+                  m_band(ri - j, j) = data(i);
+              }
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            anorm = m_band.abs().sum().row(0).max();
+
+          char job = 'L';
+          F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nr, n_lower, tmp_data, ldm, err
+                                     F77_CHAR_ARG_LEN (1)));
+            
+          if (err != 0) 
+            {
+              rcond = 0.0;
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Banded;
+              err = 0;
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  Array<Complex> z (2 * nr);
+                  Complex *pz = z.fortran_vec ();
+                  Array<double> iz (nr);
+                  double *piz = iz.fortran_vec ();
+
+                  F77_XFCN (zpbcon, ZPBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nr, n_lower, tmp_data, ldm,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.0;
+
+              if (err == 0)
+                {
+                  octave_idx_type b_nr = b.rows ();
+                  octave_idx_type b_nc = b.cols ();
+                  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
+
+                  // Take a first guess that the number of non-zero terms
+                  // will be as many as in b
+                  volatile octave_idx_type x_nz = b.nnz ();
+                  volatile octave_idx_type ii = 0;
+                  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+                  retval.xcidx(0) = 0;
+                  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                    {
+                      for (octave_idx_type i = 0; i < b_nr; i++)
+                        Bx[i] = b.elem (i, j);
+
+                      F77_XFCN (zpbtrs, ZPBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, 1, tmp_data,
+                                 ldm, Bx, b_nr, err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      if (err != 0)
+                        {
+                          (*current_liboctave_error_handler) 
+                            ("SparseComplexMatrix::solve solve failed");
+                          err = -1;
+                          break;
+                        }
+
+                      for (octave_idx_type i = 0; i < b_nr; i++)
+                        {
+                          Complex tmp = Bx[i];
+                          if (tmp != 0.0)
+                            {
+                              if (ii == x_nz)
+                                {
+                                  // Resize the sparse matrix
+                                  octave_idx_type sz = x_nz * 
+                                    (b_nc - j) / b_nc;
+                                  sz = (sz > 10 ? sz : 10) + x_nz;
+                                  retval.change_capacity (sz);
+                                  x_nz = sz;
+                                }
+                              retval.xdata(ii) = tmp;
+                              retval.xridx(ii++) = i;
+                            }
+                        }
+                      retval.xcidx(j+1) = ii;
+                    }
+
+                  retval.maybe_compress ();
+                }
+            }
+        }
 
       if (typ == MatrixType::Banded)
-	{
-	  // Create the storage for the banded form of the sparse matrix
-	  octave_idx_type n_upper = mattype.nupper ();
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
-
-	  ComplexMatrix m_band (ldm, nc);
-	  Complex *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    {
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
-				     ldm, pipvt, err));
-	    
-	  if (err != 0) 
-	    {
-	      rcond = 0.0;
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		sing_handler (rcond);
-		mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  char job = '1';
-		  Array<Complex> z (2 * nr);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> iz (nr);
-		  double *piz = iz.fortran_vec ();
-
-		  F77_XFCN (zgbcon, ZGBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		   if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.;
-
-	      if (err == 0)
-		{
-		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nnz ();
-		  octave_idx_type b_nc = b.cols ();
-		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
-		  retval.xcidx(0) = 0;
-		  volatile octave_idx_type ii = 0;
-
-		  OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
-			work[i] = 0.;
-		      for (octave_idx_type i = b.cidx(j); 
-			   i < b.cidx(j+1); i++)
-			work[b.ridx(i)] = b.data(i);
-
-		      F77_XFCN (zgbtrs, ZGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, work, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (work[i] != 0.)
-			  new_nnz++;
-
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (work[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = work[i];
-			  }
-		      retval.xcidx(j+1) = ii;
-		    }
-
-		  retval.maybe_compress ();
-		}
-	    }
-	}
+        {
+          // Create the storage for the banded form of the sparse matrix
+          octave_idx_type n_upper = mattype.nupper ();
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+
+          ComplexMatrix m_band (ldm, nc);
+          Complex *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            {
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+                                     ldm, pipvt, err));
+            
+          if (err != 0) 
+            {
+              rcond = 0.0;
+              err = -2;
+
+              if (sing_handler)
+                {
+                sing_handler (rcond);
+                mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  char job = '1';
+                  Array<Complex> z (2 * nr);
+                  Complex *pz = z.fortran_vec ();
+                  Array<double> iz (nr);
+                  double *piz = iz.fortran_vec ();
+
+                  F77_XFCN (zgbcon, ZGBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                   if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.;
+
+              if (err == 0)
+                {
+                  char job = 'N';
+                  volatile octave_idx_type x_nz = b.nnz ();
+                  octave_idx_type b_nc = b.cols ();
+                  retval = SparseComplexMatrix (nr, b_nc, x_nz);
+                  retval.xcidx(0) = 0;
+                  volatile octave_idx_type ii = 0;
+
+                  OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+
+                  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                    {
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        work[i] = 0.;
+                      for (octave_idx_type i = b.cidx(j); 
+                           i < b.cidx(j+1); i++)
+                        work[b.ridx(i)] = b.data(i);
+
+                      F77_XFCN (zgbtrs, ZGBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, n_upper, 1, tmp_data,
+                                 ldm, pipvt, work, b.rows (), err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      // Count non-zeros in work vector and adjust 
+                      // space in retval if needed
+                      octave_idx_type new_nnz = 0;
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        if (work[i] != 0.)
+                          new_nnz++;
+
+                      if (ii + new_nnz > x_nz)
+                        {
+                          // Resize the sparse matrix
+                          octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                          retval.change_capacity (sz);
+                          x_nz = sz;
+                        }
+
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        if (work[i] != 0.)
+                          {
+                            retval.xridx(ii) = i;
+                            retval.xdata(ii++) = work[i];
+                          }
+                      retval.xcidx(j+1) = ii;
+                    }
+
+                  retval.maybe_compress ();
+                }
+            }
+        }
       else if (typ != MatrixType::Banded_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::bsolve (MatrixType &mattype, const ComplexMatrix& b, 
-			     octave_idx_type& err, double& rcond, 
-			     solve_singularity_handler sing_handler,
-			     bool calc_cond) const
+                             octave_idx_type& err, double& rcond, 
+                             solve_singularity_handler sing_handler,
+                             bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -4931,243 +4931,243 @@ SparseComplexMatrix::bsolve (MatrixType 
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
-	{
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_lower + 1;
-
-	  ComplexMatrix m_band (ldm, nc);
-	  Complex *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      {
-		octave_idx_type ri = ridx (i);
-		if (ri >= j)
-		  m_band(ri - j, j) = data(i);
-	      }
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    anorm = m_band.abs().sum().row(0).max();
-
-	  char job = 'L';
-	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, tmp_data, ldm, err
-				     F77_CHAR_ARG_LEN (1)));
-	    
-	  if (err != 0) 
-	    {
-	      // Matrix is not positive definite!! Fall through to
-	      // unsymmetric banded solver.
-	      rcond = 0.0;
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Banded;
-	      err = 0;
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  Array<Complex> z (2 * nr);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> iz (nr);
-		  double *piz = iz.fortran_vec ();
-
-		  F77_XFCN (zpbcon, ZPBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nr, n_lower, tmp_data, ldm,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.0;
-
-	      if (err == 0)
-		{
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-		  retval = ComplexMatrix (b);
-		  Complex *result = retval.fortran_vec ();
-
-		  F77_XFCN (zpbtrs, ZPBTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, n_lower, b_nc, tmp_data,
-			     ldm, result, b_nr, err
-			     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseComplexMatrix::solve solve failed");
-		      err = -1;
-		    }
-		}
-	    }
-	}
+        {
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_lower + 1;
+
+          ComplexMatrix m_band (ldm, nc);
+          Complex *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              {
+                octave_idx_type ri = ridx (i);
+                if (ri >= j)
+                  m_band(ri - j, j) = data(i);
+              }
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            anorm = m_band.abs().sum().row(0).max();
+
+          char job = 'L';
+          F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nr, n_lower, tmp_data, ldm, err
+                                     F77_CHAR_ARG_LEN (1)));
+            
+          if (err != 0) 
+            {
+              // Matrix is not positive definite!! Fall through to
+              // unsymmetric banded solver.
+              rcond = 0.0;
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Banded;
+              err = 0;
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  Array<Complex> z (2 * nr);
+                  Complex *pz = z.fortran_vec ();
+                  Array<double> iz (nr);
+                  double *piz = iz.fortran_vec ();
+
+                  F77_XFCN (zpbcon, ZPBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nr, n_lower, tmp_data, ldm,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.0;
+
+              if (err == 0)
+                {
+                  octave_idx_type b_nr = b.rows ();
+                  octave_idx_type b_nc = b.cols ();
+                  retval = ComplexMatrix (b);
+                  Complex *result = retval.fortran_vec ();
+
+                  F77_XFCN (zpbtrs, ZPBTRS, 
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, b_nc, tmp_data,
+                             ldm, result, b_nr, err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseComplexMatrix::solve solve failed");
+                      err = -1;
+                    }
+                }
+            }
+        }
 
       if (typ == MatrixType::Banded)
-	{
-	  // Create the storage for the banded form of the sparse matrix
-	  octave_idx_type n_upper = mattype.nupper ();
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
-
-	  ComplexMatrix m_band (ldm, nc);
-	  Complex *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    {
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
-				     ldm, pipvt, err));
-	    
-	  if (err != 0) 
-	    {
-	      err = -2;
-	      rcond = 0.0;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  char job = '1';
-		  Array<Complex> z (2 * nr);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> iz (nr);
-		  double *piz = iz.fortran_vec ();
-
-		  F77_XFCN (zgbcon, ZGBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		   if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.;
-
-	      if (err == 0)
-		{
-		  char job = 'N';
-		  octave_idx_type b_nc = b.cols ();
-		  retval = ComplexMatrix (b);
-		  Complex *result = retval.fortran_vec ();
-
-		  F77_XFCN (zgbtrs, ZGBTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, n_lower, n_upper, b_nc, tmp_data,
-			     ldm, pipvt, result, b.rows (), err
-			     F77_CHAR_ARG_LEN (1)));
-		}
-	    }
-	}
+        {
+          // Create the storage for the banded form of the sparse matrix
+          octave_idx_type n_upper = mattype.nupper ();
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+
+          ComplexMatrix m_band (ldm, nc);
+          Complex *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            {
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+                                     ldm, pipvt, err));
+            
+          if (err != 0) 
+            {
+              err = -2;
+              rcond = 0.0;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  char job = '1';
+                  Array<Complex> z (2 * nr);
+                  Complex *pz = z.fortran_vec ();
+                  Array<double> iz (nr);
+                  double *piz = iz.fortran_vec ();
+
+                  F77_XFCN (zgbcon, ZGBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                   if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.;
+
+              if (err == 0)
+                {
+                  char job = 'N';
+                  octave_idx_type b_nc = b.cols ();
+                  retval = ComplexMatrix (b);
+                  Complex *result = retval.fortran_vec ();
+
+                  F77_XFCN (zgbtrs, ZGBTRS, 
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, n_upper, b_nc, tmp_data,
+                             ldm, pipvt, result, b.rows (), err
+                             F77_CHAR_ARG_LEN (1)));
+                }
+            }
+        }
       else if (typ != MatrixType::Banded_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::bsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-			     octave_idx_type& err, double& rcond, 
-			     solve_singularity_handler sing_handler,
-			     bool calc_cond) const
+                             octave_idx_type& err, double& rcond, 
+                             solve_singularity_handler sing_handler,
+                             bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -5177,324 +5177,324 @@ SparseComplexMatrix::bsolve (MatrixType 
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
-	{
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_lower + 1;
-
-	  ComplexMatrix m_band (ldm, nc);
-	  Complex *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      {
-		octave_idx_type ri = ridx (i);
-		if (ri >= j)
-		  m_band(ri - j, j) = data(i);
-	      }
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    anorm = m_band.abs().sum().row(0).max();
-
-	  char job = 'L';
-	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, tmp_data, ldm, err
-				     F77_CHAR_ARG_LEN (1)));
-	    
-	  if (err != 0) 
-	    {
-	      // Matrix is not positive definite!! Fall through to
-	      // unsymmetric banded solver.
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Banded;
-
-	      rcond = 0.0;
-	      err = 0;
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  Array<Complex> z (2 * nr);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> iz (nr);
-		  double *piz = iz.fortran_vec ();
-
-		  F77_XFCN (zpbcon, ZPBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nr, n_lower, tmp_data, ldm,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.0;
-
-	      if (err == 0)
-		{
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
-
-		  // Take a first guess that the number of non-zero terms
-		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nnz ();
-		  volatile octave_idx_type ii = 0;
-		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-		  retval.xcidx(0) = 0;
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		    {
-
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			Bx[i] = b (i,j);
-
-		      F77_XFCN (zpbtrs, ZPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bx, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseMatrix::solve solve failed");
-			  err = -1;
-			  break;
-			}
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0.)
-			  new_nnz++;
-
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = Bx[i];
-			  }
-
-		      retval.xcidx(j+1) = ii;
-		    }
-
-		  retval.maybe_compress ();
-		}
-	    }
-	}
+        {
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_lower + 1;
+
+          ComplexMatrix m_band (ldm, nc);
+          Complex *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              {
+                octave_idx_type ri = ridx (i);
+                if (ri >= j)
+                  m_band(ri - j, j) = data(i);
+              }
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            anorm = m_band.abs().sum().row(0).max();
+
+          char job = 'L';
+          F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nr, n_lower, tmp_data, ldm, err
+                                     F77_CHAR_ARG_LEN (1)));
+            
+          if (err != 0) 
+            {
+              // Matrix is not positive definite!! Fall through to
+              // unsymmetric banded solver.
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Banded;
+
+              rcond = 0.0;
+              err = 0;
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  Array<Complex> z (2 * nr);
+                  Complex *pz = z.fortran_vec ();
+                  Array<double> iz (nr);
+                  double *piz = iz.fortran_vec ();
+
+                  F77_XFCN (zpbcon, ZPBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nr, n_lower, tmp_data, ldm,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.0;
+
+              if (err == 0)
+                {
+                  octave_idx_type b_nr = b.rows ();
+                  octave_idx_type b_nc = b.cols ();
+                  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
+
+                  // Take a first guess that the number of non-zero terms
+                  // will be as many as in b
+                  volatile octave_idx_type x_nz = b.nnz ();
+                  volatile octave_idx_type ii = 0;
+                  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+                  retval.xcidx(0) = 0;
+                  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                    {
+
+                      for (octave_idx_type i = 0; i < b_nr; i++)
+                        Bx[i] = b (i,j);
+
+                      F77_XFCN (zpbtrs, ZPBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, 1, tmp_data,
+                                 ldm, Bx, b_nr, err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      if (err != 0)
+                        {
+                          (*current_liboctave_error_handler) 
+                            ("SparseMatrix::solve solve failed");
+                          err = -1;
+                          break;
+                        }
+
+                      // Count non-zeros in work vector and adjust 
+                      // space in retval if needed
+                      octave_idx_type new_nnz = 0;
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        if (Bx[i] != 0.)
+                          new_nnz++;
+
+                      if (ii + new_nnz > x_nz)
+                        {
+                          // Resize the sparse matrix
+                          octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                          retval.change_capacity (sz);
+                          x_nz = sz;
+                        }
+
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        if (Bx[i] != 0.)
+                          {
+                            retval.xridx(ii) = i;
+                            retval.xdata(ii++) = Bx[i];
+                          }
+
+                      retval.xcidx(j+1) = ii;
+                    }
+
+                  retval.maybe_compress ();
+                }
+            }
+        }
 
       if (typ == MatrixType::Banded)
-	{
-	  // Create the storage for the banded form of the sparse matrix
-	  octave_idx_type n_upper = mattype.nupper ();
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
-
-	  ComplexMatrix m_band (ldm, nc);
-	  Complex *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    {
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += std::abs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
-				     ldm, pipvt, err));
-	    
-	  if (err != 0) 
-	    {
-	      err = -2;
-	      rcond = 0.0;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    }
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  char job = '1';
-		  Array<Complex> z (2 * nr);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> iz (nr);
-		  double *piz = iz.fortran_vec ();
-
-		  F77_XFCN (zgbcon, ZGBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		   if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.;
-
-	      if (err == 0)
-		{
-		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nnz ();
-		  octave_idx_type b_nc = b.cols ();
-		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
-		  retval.xcidx(0) = 0;
-		  volatile octave_idx_type ii = 0;
-
-		  OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
-			Bx[i] = 0.;
-
-		      for (octave_idx_type i = b.cidx(j); 
-			   i < b.cidx(j+1); i++)
-			Bx[b.ridx(i)] = b.data(i);
-
-		      F77_XFCN (zgbtrs, ZGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, Bx, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0.)
-			  new_nnz++;
-
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = Bx[i]; 
-			  }
-		      retval.xcidx(j+1) = ii;
-		    }
-
-		  retval.maybe_compress ();
-		}
-	    }
-	}
+        {
+          // Create the storage for the banded form of the sparse matrix
+          octave_idx_type n_upper = mattype.nupper ();
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+
+          ComplexMatrix m_band (ldm, nc);
+          Complex *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            {
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += std::abs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+                                     ldm, pipvt, err));
+            
+          if (err != 0) 
+            {
+              err = -2;
+              rcond = 0.0;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+            }
+          else 
+            {
+              if (calc_cond)
+                {
+                  char job = '1';
+                  Array<Complex> z (2 * nr);
+                  Complex *pz = z.fortran_vec ();
+                  Array<double> iz (nr);
+                  double *piz = iz.fortran_vec ();
+
+                  F77_XFCN (zgbcon, ZGBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                   if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.;
+
+              if (err == 0)
+                {
+                  char job = 'N';
+                  volatile octave_idx_type x_nz = b.nnz ();
+                  octave_idx_type b_nc = b.cols ();
+                  retval = SparseComplexMatrix (nr, b_nc, x_nz);
+                  retval.xcidx(0) = 0;
+                  volatile octave_idx_type ii = 0;
+
+                  OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
+
+                  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                    {
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        Bx[i] = 0.;
+
+                      for (octave_idx_type i = b.cidx(j); 
+                           i < b.cidx(j+1); i++)
+                        Bx[b.ridx(i)] = b.data(i);
+
+                      F77_XFCN (zgbtrs, ZGBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, n_upper, 1, tmp_data,
+                                 ldm, pipvt, Bx, b.rows (), err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      // Count non-zeros in work vector and adjust 
+                      // space in retval if needed
+                      octave_idx_type new_nnz = 0;
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        if (Bx[i] != 0.)
+                          new_nnz++;
+
+                      if (ii + new_nnz > x_nz)
+                        {
+                          // Resize the sparse matrix
+                          octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                          retval.change_capacity (sz);
+                          x_nz = sz;
+                        }
+
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        if (Bx[i] != 0.)
+                          {
+                            retval.xridx(ii) = i;
+                            retval.xdata(ii++) = Bx[i]; 
+                          }
+                      retval.xcidx(j+1) = ii;
+                    }
+
+                  retval.maybe_compress ();
+                }
+            }
+        }
       else if (typ != MatrixType::Banded_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 void *
 SparseComplexMatrix::factorize (octave_idx_type& err, double &rcond,
-				Matrix &Control, Matrix &Info,
-				solve_singularity_handler sing_handler,
-				bool calc_cond) const
+                                Matrix &Control, Matrix &Info,
+                                solve_singularity_handler sing_handler,
+                                bool calc_cond) const
 {
   // The return values
   void *Numeric = 0;
   err = 0;
 
 #ifdef HAVE_UMFPACK
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
@@ -5520,97 +5520,97 @@ SparseComplexMatrix::factorize (octave_i
 
   const octave_idx_type *Ap = cidx ();
   const octave_idx_type *Ai = ridx ();
   const Complex *Ax = data ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
-				 reinterpret_cast<const double *> (Ax),
-				 0, 1, control);
+                                 reinterpret_cast<const double *> (Ax),
+                                 0, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
-				     reinterpret_cast<const double *> (Ax), 
-				     0, 0, &Symbolic, control, info);
+                                     reinterpret_cast<const double *> (Ax), 
+                                     0, 0, &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
-	("SparseComplexMatrix::solve symbolic factorization failed");
+        ("SparseComplexMatrix::solve symbolic factorization failed");
       err = -1;
 
       UMFPACK_ZNAME (report_status) (control, status);
       UMFPACK_ZNAME (report_info) (control, info);
 
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       status = UMFPACK_ZNAME (numeric) (Ap, Ai,
-				   reinterpret_cast<const double *> (Ax), 0, 
-				   Symbolic, &Numeric, control, info) ;
+                                   reinterpret_cast<const double *> (Ax), 0, 
+                                   Symbolic, &Numeric, control, info) ;
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
       if (calc_cond)
-	rcond = Info (UMFPACK_RCOND);
+        rcond = Info (UMFPACK_RCOND);
       else
-	rcond = 1.;
+        rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (status == UMFPACK_WARNING_singular_matrix || 
-	  rcond_plus_one == 1.0 || xisnan (rcond))
-	{
-	  UMFPACK_ZNAME (report_numeric) (Numeric, control);
-
-	  err = -2;
-
-	  if (sing_handler)
-	    sing_handler (rcond);
-	  else
-	    (*current_liboctave_error_handler)
-	      ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-	       rcond);
-
-	}
+          rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          UMFPACK_ZNAME (report_numeric) (Numeric, control);
+
+          err = -2;
+
+          if (sing_handler)
+            sing_handler (rcond);
+          else
+            (*current_liboctave_error_handler)
+              ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
+               rcond);
+
+        }
       else if (status < 0)
-	  {
-	    (*current_liboctave_error_handler) 
-	      ("SparseComplexMatrix::solve numeric factorization failed");
-
-	    UMFPACK_ZNAME (report_status) (control, status);
-	    UMFPACK_ZNAME (report_info) (control, info);
-	      
-	    err = -1;
-	  }
-	else
-	  {
-	    UMFPACK_ZNAME (report_numeric) (Numeric, control);
-	  }
+          {
+            (*current_liboctave_error_handler) 
+              ("SparseComplexMatrix::solve numeric factorization failed");
+
+            UMFPACK_ZNAME (report_status) (control, status);
+            UMFPACK_ZNAME (report_info) (control, info);
+              
+            err = -1;
+          }
+        else
+          {
+            UMFPACK_ZNAME (report_numeric) (Numeric, control);
+          }
     }
 
   if (err != 0)
     UMFPACK_ZNAME (free_numeric) (&Numeric);
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return Numeric;
 }
 
 ComplexMatrix
 SparseComplexMatrix::fsolve (MatrixType &mattype, const Matrix& b,
-			     octave_idx_type& err, double& rcond,
-			     solve_singularity_handler sing_handler,
-			     bool calc_cond) const
+                             octave_idx_type& err, double& rcond,
+                             solve_singularity_handler sing_handler,
+                             bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -5620,240 +5620,240 @@ SparseComplexMatrix::fsolve (MatrixType 
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
-	{
+        {
 #ifdef HAVE_CHOLMOD
-	  cholmod_common Common;
-	  cholmod_common *cm = &Common;
-
-	  // Setup initial parameters
-	  CHOLMOD_NAME(start) (cm);
-	  cm->prefer_zomplex = false;
-
-	  double spu = octave_sparse_params::get_key ("spumoni");
-	  if (spu == 0.)
-	    {
-	      cm->print = -1;
-	      cm->print_function = 0;
-	    }
-	  else
-	    {
-	      cm->print = static_cast<int> (spu) + 2;
-	      cm->print_function =&SparseCholPrint;
-	    }
-
-	  cm->error_handler = &SparseCholError;
-	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
-	  cm->hypotenuse = CHOLMOD_NAME(hypot);
-
-	  cm->final_ll = true;
-
-	  cholmod_sparse Astore;
-	  cholmod_sparse *A = &Astore;
-	  double dummy;
-	  A->nrow = nr;
-	  A->ncol = nc;
-
-	  A->p = cidx();
-	  A->i = ridx();
-	  A->nzmax = nnz();
-	  A->packed = true;
-	  A->sorted = true;
-	  A->nz = 0;
+          cholmod_common Common;
+          cholmod_common *cm = &Common;
+
+          // Setup initial parameters
+          CHOLMOD_NAME(start) (cm);
+          cm->prefer_zomplex = false;
+
+          double spu = octave_sparse_params::get_key ("spumoni");
+          if (spu == 0.)
+            {
+              cm->print = -1;
+              cm->print_function = 0;
+            }
+          else
+            {
+              cm->print = static_cast<int> (spu) + 2;
+              cm->print_function =&SparseCholPrint;
+            }
+
+          cm->error_handler = &SparseCholError;
+          cm->complex_divide = CHOLMOD_NAME(divcomplex);
+          cm->hypotenuse = CHOLMOD_NAME(hypot);
+
+          cm->final_ll = true;
+
+          cholmod_sparse Astore;
+          cholmod_sparse *A = &Astore;
+          double dummy;
+          A->nrow = nr;
+          A->ncol = nc;
+
+          A->p = cidx();
+          A->i = ridx();
+          A->nzmax = nnz();
+          A->packed = true;
+          A->sorted = true;
+          A->nz = 0;
 #ifdef IDX_TYPE_LONG
-	  A->itype = CHOLMOD_LONG;
+          A->itype = CHOLMOD_LONG;
 #else
-	  A->itype = CHOLMOD_INT;
+          A->itype = CHOLMOD_INT;
 #endif
-	  A->dtype = CHOLMOD_DOUBLE;
-	  A->stype = 1;
-	  A->xtype = CHOLMOD_COMPLEX;
-
-	  if (nr < 1)
-	    A->x = &dummy;
-	  else
-	    A->x = data();
-
-	  cholmod_dense Bstore;
-	  cholmod_dense *B = &Bstore;
-	  B->nrow = b.rows();
-	  B->ncol = b.cols();
-	  B->d = B->nrow;
-	  B->nzmax = B->nrow * B->ncol;
-	  B->dtype = CHOLMOD_DOUBLE;
-	  B->xtype = CHOLMOD_REAL;
-	  if (nc < 1 || b.cols() < 1)
-	    B->x = &dummy;
-	  else
-	    // We won't alter it, honest :-)
-	    B->x = const_cast<double *>(b.fortran_vec());
-
-	  cholmod_factor *L;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  L = CHOLMOD_NAME(analyze) (A, cm);
-	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  if (calc_cond)
-	    rcond = CHOLMOD_NAME(rcond)(L, cm);
-	  else
-	    rcond = 1.;
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	  if (rcond == 0.0)
-	    {
-	      // Either its indefinite or singular. Try UMFPACK
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	  else
-	    {
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  err = -2;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		       rcond);
-	      
-		  return retval;
-		}
-
-	      cholmod_dense *X;
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	      retval.resize (b.rows (), b.cols());
-	      for (octave_idx_type j = 0; j < b.cols(); j++)
-		{
-		  octave_idx_type jr = j * b.rows();
-		  for (octave_idx_type i = 0; i < b.rows(); i++)
-		    retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
-		}
-
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CHOLMOD_NAME(free_dense) (&X, cm);
-	      CHOLMOD_NAME(free_factor) (&L, cm);
-	      CHOLMOD_NAME(finish) (cm);
-	      static char tmp[] = " ";
-	      CHOLMOD_NAME(print_common) (tmp, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
+          A->dtype = CHOLMOD_DOUBLE;
+          A->stype = 1;
+          A->xtype = CHOLMOD_COMPLEX;
+
+          if (nr < 1)
+            A->x = &dummy;
+          else
+            A->x = data();
+
+          cholmod_dense Bstore;
+          cholmod_dense *B = &Bstore;
+          B->nrow = b.rows();
+          B->ncol = b.cols();
+          B->d = B->nrow;
+          B->nzmax = B->nrow * B->ncol;
+          B->dtype = CHOLMOD_DOUBLE;
+          B->xtype = CHOLMOD_REAL;
+          if (nc < 1 || b.cols() < 1)
+            B->x = &dummy;
+          else
+            // We won't alter it, honest :-)
+            B->x = const_cast<double *>(b.fortran_vec());
+
+          cholmod_factor *L;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          L = CHOLMOD_NAME(analyze) (A, cm);
+          CHOLMOD_NAME(factorize) (A, L, cm);
+          if (calc_cond)
+            rcond = CHOLMOD_NAME(rcond)(L, cm);
+          else
+            rcond = 1.;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+          if (rcond == 0.0)
+            {
+              // Either its indefinite or singular. Try UMFPACK
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+          else
+            {
+              volatile double rcond_plus_one = rcond + 1.0;
+
+              if (rcond_plus_one == 1.0 || xisnan (rcond))
+                {
+                  err = -2;
+
+                  if (sing_handler)
+                    {
+                      sing_handler (rcond);
+                      mattype.mark_as_rectangular ();
+                    }
+                  else
+                    (*current_liboctave_error_handler)
+                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                       rcond);
+              
+                  return retval;
+                }
+
+              cholmod_dense *X;
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+              retval.resize (b.rows (), b.cols());
+              for (octave_idx_type j = 0; j < b.cols(); j++)
+                {
+                  octave_idx_type jr = j * b.rows();
+                  for (octave_idx_type i = 0; i < b.rows(); i++)
+                    retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
+                }
+
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CHOLMOD_NAME(free_dense) (&X, cm);
+              CHOLMOD_NAME(free_factor) (&L, cm);
+              CHOLMOD_NAME(finish) (cm);
+              static char tmp[] = " ";
+              CHOLMOD_NAME(print_common) (tmp, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
 #else
-	  (*current_liboctave_warning_handler)
-	    ("CHOLMOD not installed");
-
-	  mattype.mark_as_unsymmetric ();
-	  typ = MatrixType::Full;
+          (*current_liboctave_warning_handler)
+            ("CHOLMOD not installed");
+
+          mattype.mark_as_unsymmetric ();
+          typ = MatrixType::Full;
 #endif
-	}
+        }
 
       if (typ == MatrixType::Full)
-	{
+        {
 #ifdef HAVE_UMFPACK
-	  Matrix Control, Info;
-	  void *Numeric = factorize (err, rcond, Control, Info, 
-				     sing_handler, calc_cond);
-
-	  if (err == 0)
-	    {
-	      octave_idx_type b_nr = b.rows ();
-	      octave_idx_type b_nc = b.cols ();
-	      int status = 0;
-	      double *control = Control.fortran_vec ();
-	      double *info = Info.fortran_vec ();
-	      const octave_idx_type *Ap = cidx ();
-	      const octave_idx_type *Ai = ridx ();
-	      const Complex *Ax = data ();
+          Matrix Control, Info;
+          void *Numeric = factorize (err, rcond, Control, Info, 
+                                     sing_handler, calc_cond);
+
+          if (err == 0)
+            {
+              octave_idx_type b_nr = b.rows ();
+              octave_idx_type b_nc = b.cols ();
+              int status = 0;
+              double *control = Control.fortran_vec ();
+              double *info = Info.fortran_vec ();
+              const octave_idx_type *Ap = cidx ();
+              const octave_idx_type *Ai = ridx ();
+              const Complex *Ax = data ();
 #ifdef UMFPACK_SEPARATE_SPLIT
-	      const double *Bx = b.fortran_vec ();
-	      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-	      for (octave_idx_type i = 0; i < b_nr; i++)
-		Bz[i] = 0.;
+              const double *Bx = b.fortran_vec ();
+              OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
+              for (octave_idx_type i = 0; i < b_nr; i++)
+                Bz[i] = 0.;
 #else
-	      OCTAVE_LOCAL_BUFFER (Complex, Bz, b_nr);
+              OCTAVE_LOCAL_BUFFER (Complex, Bz, b_nr);
 #endif
-	      retval.resize (b_nr, b_nc);
-	      Complex *Xx = retval.fortran_vec ();
-
-	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
-		{
+              retval.resize (b_nr, b_nc);
+              Complex *Xx = retval.fortran_vec ();
+
+              for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
+                {
 #ifdef UMFPACK_SEPARATE_SPLIT
-		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-					     Ai,
-					     reinterpret_cast<const double *> (Ax), 
-					     0,
-					     reinterpret_cast<double *> (&Xx[iidx]), 
-					     0,
-					     &Bx[iidx], Bz, Numeric, 
-					     control, info);
+                  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
+                                             Ai,
+                                             reinterpret_cast<const double *> (Ax), 
+                                             0,
+                                             reinterpret_cast<double *> (&Xx[iidx]), 
+                                             0,
+                                             &Bx[iidx], Bz, Numeric, 
+                                             control, info);
 #else
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    Bz[i] = b.elem (i, j);
-
-		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-					     Ai,
-					     reinterpret_cast<const double *> (Ax), 
-					     0,
-					     reinterpret_cast<double *> (&Xx[iidx]), 
-					     0,
-					     reinterpret_cast<const double *> (Bz),
-					     0, Numeric, 
-					     control, info);
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    Bz[i] = b.elem (i, j);
+
+                  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
+                                             Ai,
+                                             reinterpret_cast<const double *> (Ax), 
+                                             0,
+                                             reinterpret_cast<double *> (&Xx[iidx]), 
+                                             0,
+                                             reinterpret_cast<const double *> (Bz),
+                                             0, Numeric, 
+                                             control, info);
 #endif
 
-		  if (status < 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseComplexMatrix::solve solve failed");
-
-		      UMFPACK_ZNAME (report_status) (control, status);
-		      
-		      err = -1;
-
-		      break;
-		    }
-		}
-
-	      UMFPACK_ZNAME (report_info) (control, info);
-
-	      UMFPACK_ZNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    mattype.mark_as_rectangular ();
+                  if (status < 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseComplexMatrix::solve solve failed");
+
+                      UMFPACK_ZNAME (report_status) (control, status);
+                      
+                      err = -1;
+
+                      break;
+                    }
+                }
+
+              UMFPACK_ZNAME (report_info) (control, info);
+
+              UMFPACK_ZNAME (free_numeric) (&Numeric);
+            }
+          else
+            mattype.mark_as_rectangular ();
 
 #else
-	  (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
-	}
+        }
       else if (typ != MatrixType::Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::fsolve (MatrixType &mattype, const SparseMatrix& b, 
-			     octave_idx_type& err, double& rcond,
-			     solve_singularity_handler sing_handler,
-			     bool calc_cond) const
+                             octave_idx_type& err, double& rcond,
+                             solve_singularity_handler sing_handler,
+                             bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -5863,288 +5863,288 @@ SparseComplexMatrix::fsolve (MatrixType 
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
-	{
+        {
 #ifdef HAVE_CHOLMOD
-	  cholmod_common Common;
-	  cholmod_common *cm = &Common;
-
-	  // Setup initial parameters
-	  CHOLMOD_NAME(start) (cm);
-	  cm->prefer_zomplex = false;
-
-	  double spu = octave_sparse_params::get_key ("spumoni");
-	  if (spu == 0.)
-	    {
-	      cm->print = -1;
-	      cm->print_function = 0;
-	    }
-	  else
-	    {
-	      cm->print = static_cast<int> (spu) + 2;
-	      cm->print_function =&SparseCholPrint;
-	    }
-
-	  cm->error_handler = &SparseCholError;
-	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
-	  cm->hypotenuse = CHOLMOD_NAME(hypot);
-
-	  cm->final_ll = true;
-
-	  cholmod_sparse Astore;
-	  cholmod_sparse *A = &Astore;
-	  double dummy;
-	  A->nrow = nr;
-	  A->ncol = nc;
-
-	  A->p = cidx();
-	  A->i = ridx();
-	  A->nzmax = nnz();
-	  A->packed = true;
-	  A->sorted = true;
-	  A->nz = 0;
+          cholmod_common Common;
+          cholmod_common *cm = &Common;
+
+          // Setup initial parameters
+          CHOLMOD_NAME(start) (cm);
+          cm->prefer_zomplex = false;
+
+          double spu = octave_sparse_params::get_key ("spumoni");
+          if (spu == 0.)
+            {
+              cm->print = -1;
+              cm->print_function = 0;
+            }
+          else
+            {
+              cm->print = static_cast<int> (spu) + 2;
+              cm->print_function =&SparseCholPrint;
+            }
+
+          cm->error_handler = &SparseCholError;
+          cm->complex_divide = CHOLMOD_NAME(divcomplex);
+          cm->hypotenuse = CHOLMOD_NAME(hypot);
+
+          cm->final_ll = true;
+
+          cholmod_sparse Astore;
+          cholmod_sparse *A = &Astore;
+          double dummy;
+          A->nrow = nr;
+          A->ncol = nc;
+
+          A->p = cidx();
+          A->i = ridx();
+          A->nzmax = nnz();
+          A->packed = true;
+          A->sorted = true;
+          A->nz = 0;
 #ifdef IDX_TYPE_LONG
-	  A->itype = CHOLMOD_LONG;
+          A->itype = CHOLMOD_LONG;
 #else
-	  A->itype = CHOLMOD_INT;
+          A->itype = CHOLMOD_INT;
 #endif
-	  A->dtype = CHOLMOD_DOUBLE;
-	  A->stype = 1;
-	  A->xtype = CHOLMOD_COMPLEX;
-
-	  if (nr < 1)
-	    A->x = &dummy;
-	  else
-	    A->x = data();
-
-	  cholmod_sparse Bstore;
-	  cholmod_sparse *B = &Bstore;
-	  B->nrow = b.rows();
-	  B->ncol = b.cols();
-	  B->p = b.cidx();
-	  B->i = b.ridx();
-	  B->nzmax = b.nnz();
-	  B->packed = true;
-	  B->sorted = true;
-	  B->nz = 0;
+          A->dtype = CHOLMOD_DOUBLE;
+          A->stype = 1;
+          A->xtype = CHOLMOD_COMPLEX;
+
+          if (nr < 1)
+            A->x = &dummy;
+          else
+            A->x = data();
+
+          cholmod_sparse Bstore;
+          cholmod_sparse *B = &Bstore;
+          B->nrow = b.rows();
+          B->ncol = b.cols();
+          B->p = b.cidx();
+          B->i = b.ridx();
+          B->nzmax = b.nnz();
+          B->packed = true;
+          B->sorted = true;
+          B->nz = 0;
 #ifdef IDX_TYPE_LONG
-	  B->itype = CHOLMOD_LONG;
+          B->itype = CHOLMOD_LONG;
 #else
-	  B->itype = CHOLMOD_INT;
+          B->itype = CHOLMOD_INT;
 #endif
-	  B->dtype = CHOLMOD_DOUBLE;
-	  B->stype = 0;
-	  B->xtype = CHOLMOD_REAL;
-
-	  if (b.rows() < 1 || b.cols() < 1)
-	    B->x = &dummy;
-	  else
-	    B->x = b.data();
-
-	  cholmod_factor *L;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  L = CHOLMOD_NAME(analyze) (A, cm);
-	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  if (calc_cond)
-	    rcond = CHOLMOD_NAME(rcond)(L, cm);
-	  else
-	    rcond = 1.;
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	  if (rcond == 0.0)
-	    {
-	      // Either its indefinite or singular. Try UMFPACK
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	  else
-	    {
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  err = -2;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		       rcond);
-	      
-		  return retval;
-		}
-
-	      cholmod_sparse *X;
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	      retval = SparseComplexMatrix 
-		(static_cast<octave_idx_type>(X->nrow), 
-		 static_cast<octave_idx_type>(X->ncol),
-		 static_cast<octave_idx_type>(X->nzmax));
-	      for (octave_idx_type j = 0; 
-		   j <= static_cast<octave_idx_type>(X->ncol); j++)
-		retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
-	      for (octave_idx_type j = 0; 
-		   j < static_cast<octave_idx_type>(X->nzmax); j++)
-		{
-		  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
-		  retval.xdata(j) = static_cast<Complex *>(X->x)[j];
-		}
-
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CHOLMOD_NAME(free_sparse) (&X, cm);
-	      CHOLMOD_NAME(free_factor) (&L, cm);
-	      CHOLMOD_NAME(finish) (cm);
-	      static char tmp[] = " ";
-	      CHOLMOD_NAME(print_common) (tmp, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
+          B->dtype = CHOLMOD_DOUBLE;
+          B->stype = 0;
+          B->xtype = CHOLMOD_REAL;
+
+          if (b.rows() < 1 || b.cols() < 1)
+            B->x = &dummy;
+          else
+            B->x = b.data();
+
+          cholmod_factor *L;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          L = CHOLMOD_NAME(analyze) (A, cm);
+          CHOLMOD_NAME(factorize) (A, L, cm);
+          if (calc_cond)
+            rcond = CHOLMOD_NAME(rcond)(L, cm);
+          else
+            rcond = 1.;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+          if (rcond == 0.0)
+            {
+              // Either its indefinite or singular. Try UMFPACK
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+          else
+            {
+              volatile double rcond_plus_one = rcond + 1.0;
+
+              if (rcond_plus_one == 1.0 || xisnan (rcond))
+                {
+                  err = -2;
+
+                  if (sing_handler)
+                    {
+                      sing_handler (rcond);
+                      mattype.mark_as_rectangular ();
+                    }
+                  else
+                    (*current_liboctave_error_handler)
+                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                       rcond);
+              
+                  return retval;
+                }
+
+              cholmod_sparse *X;
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+              retval = SparseComplexMatrix 
+                (static_cast<octave_idx_type>(X->nrow), 
+                 static_cast<octave_idx_type>(X->ncol),
+                 static_cast<octave_idx_type>(X->nzmax));
+              for (octave_idx_type j = 0; 
+                   j <= static_cast<octave_idx_type>(X->ncol); j++)
+                retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
+              for (octave_idx_type j = 0; 
+                   j < static_cast<octave_idx_type>(X->nzmax); j++)
+                {
+                  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
+                  retval.xdata(j) = static_cast<Complex *>(X->x)[j];
+                }
+
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CHOLMOD_NAME(free_sparse) (&X, cm);
+              CHOLMOD_NAME(free_factor) (&L, cm);
+              CHOLMOD_NAME(finish) (cm);
+              static char tmp[] = " ";
+              CHOLMOD_NAME(print_common) (tmp, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
 #else
-	  (*current_liboctave_warning_handler)
-	    ("CHOLMOD not installed");
-
-	  mattype.mark_as_unsymmetric ();
-	  typ = MatrixType::Full;
+          (*current_liboctave_warning_handler)
+            ("CHOLMOD not installed");
+
+          mattype.mark_as_unsymmetric ();
+          typ = MatrixType::Full;
 #endif
-	}
+        }
 
       if (typ == MatrixType::Full)
-	{
+        {
 #ifdef HAVE_UMFPACK
-	  Matrix Control, Info;
-	  void *Numeric = factorize (err, rcond, Control, Info, 
-				     sing_handler, calc_cond);
-
-	  if (err == 0)
-	    {
-	      octave_idx_type b_nr = b.rows ();
-	      octave_idx_type b_nc = b.cols ();
-	      int status = 0;
-	      double *control = Control.fortran_vec ();
-	      double *info = Info.fortran_vec ();
-	      const octave_idx_type *Ap = cidx ();
-	      const octave_idx_type *Ai = ridx ();
-	      const Complex *Ax = data ();
+          Matrix Control, Info;
+          void *Numeric = factorize (err, rcond, Control, Info, 
+                                     sing_handler, calc_cond);
+
+          if (err == 0)
+            {
+              octave_idx_type b_nr = b.rows ();
+              octave_idx_type b_nc = b.cols ();
+              int status = 0;
+              double *control = Control.fortran_vec ();
+              double *info = Info.fortran_vec ();
+              const octave_idx_type *Ap = cidx ();
+              const octave_idx_type *Ai = ridx ();
+              const Complex *Ax = data ();
 
 #ifdef UMFPACK_SEPARATE_SPLIT
-	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-	      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-	      for (octave_idx_type i = 0; i < b_nr; i++)
-		Bz[i] = 0.;
+              OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+              OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
+              for (octave_idx_type i = 0; i < b_nr; i++)
+                Bz[i] = 0.;
 #else
-	      OCTAVE_LOCAL_BUFFER (Complex, Bz, b_nr);
+              OCTAVE_LOCAL_BUFFER (Complex, Bz, b_nr);
 #endif
 
-	      // Take a first guess that the number of non-zero terms
-	      // will be as many as in b
-	      octave_idx_type x_nz = b.nnz ();
-	      octave_idx_type ii = 0;
-	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-	      OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
-	      
-	      retval.xcidx(0) = 0;
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
+              // Take a first guess that the number of non-zero terms
+              // will be as many as in b
+              octave_idx_type x_nz = b.nnz ();
+              octave_idx_type ii = 0;
+              retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+              OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
+              
+              retval.xcidx(0) = 0;
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
 
 #ifdef UMFPACK_SEPARATE_SPLIT
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    Bx[i] = b.elem (i, j);
-
-		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-					     Ai,
-					     reinterpret_cast<const double *> (Ax),
-					     0,
-					     reinterpret_cast<double *> (Xx),
-					     0, 
-					     Bx, Bz, Numeric, control, 
-					     info);
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    Bx[i] = b.elem (i, j);
+
+                  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
+                                             Ai,
+                                             reinterpret_cast<const double *> (Ax),
+                                             0,
+                                             reinterpret_cast<double *> (Xx),
+                                             0, 
+                                             Bx, Bz, Numeric, control, 
+                                             info);
 #else
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    Bz[i] = b.elem (i, j);
-
-		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai, 
-					     reinterpret_cast<const double *> (Ax),
-					     0,
-					     reinterpret_cast<double *> (Xx),
-					     0,
-					     reinterpret_cast<double *> (Bz),
-					     0,
-					     Numeric, control, 
-					     info);
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    Bz[i] = b.elem (i, j);
+
+                  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai, 
+                                             reinterpret_cast<const double *> (Ax),
+                                             0,
+                                             reinterpret_cast<double *> (Xx),
+                                             0,
+                                             reinterpret_cast<double *> (Bz),
+                                             0,
+                                             Numeric, control, 
+                                             info);
 #endif
-		  if (status < 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseComplexMatrix::solve solve failed");
-
-		      UMFPACK_ZNAME (report_status) (control, status);
-		      
-		      err = -1;
-
-		      break;
-		    }
-
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    {
-		      Complex tmp = Xx[i];
-		      if (tmp != 0.0)
-			{
-			  if (ii == x_nz)
-			    {
-			      // Resize the sparse matrix
-			      octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
-			      sz = (sz > 10 ? sz : 10) + x_nz;
-			      retval.change_capacity (sz);
-			      x_nz = sz;
-			    }
-			  retval.xdata(ii) = tmp;
-			  retval.xridx(ii++) = i;
-			}
-		    }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      UMFPACK_ZNAME (report_info) (control, info);
-
-	      UMFPACK_ZNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    mattype.mark_as_rectangular ();
+                  if (status < 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseComplexMatrix::solve solve failed");
+
+                      UMFPACK_ZNAME (report_status) (control, status);
+                      
+                      err = -1;
+
+                      break;
+                    }
+
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    {
+                      Complex tmp = Xx[i];
+                      if (tmp != 0.0)
+                        {
+                          if (ii == x_nz)
+                            {
+                              // Resize the sparse matrix
+                              octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
+                              sz = (sz > 10 ? sz : 10) + x_nz;
+                              retval.change_capacity (sz);
+                              x_nz = sz;
+                            }
+                          retval.xdata(ii) = tmp;
+                          retval.xridx(ii++) = i;
+                        }
+                    }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              UMFPACK_ZNAME (report_info) (control, info);
+
+              UMFPACK_ZNAME (free_numeric) (&Numeric);
+            }
+          else
+            mattype.mark_as_rectangular ();
 
 #else
-	  (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
-	}
+        }
       else if (typ != MatrixType::Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b, 
-			     octave_idx_type& err, double& rcond,
-			     solve_singularity_handler sing_handler,
-			     bool calc_cond) const
+                             octave_idx_type& err, double& rcond,
+                             solve_singularity_handler sing_handler,
+                             bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -6154,219 +6154,219 @@ SparseComplexMatrix::fsolve (MatrixType 
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
-	{
+        {
 #ifdef HAVE_CHOLMOD
-	  cholmod_common Common;
-	  cholmod_common *cm = &Common;
-
-	  // Setup initial parameters
-	  CHOLMOD_NAME(start) (cm);
-	  cm->prefer_zomplex = false;
-
-	  double spu = octave_sparse_params::get_key ("spumoni");
-	  if (spu == 0.)
-	    {
-	      cm->print = -1;
-	      cm->print_function = 0;
-	    }
-	  else
-	    {
-	      cm->print = static_cast<int> (spu) + 2;
-	      cm->print_function =&SparseCholPrint;
-	    }
-
-	  cm->error_handler = &SparseCholError;
-	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
-	  cm->hypotenuse = CHOLMOD_NAME(hypot);
-
-	  cm->final_ll = true;
-
-	  cholmod_sparse Astore;
-	  cholmod_sparse *A = &Astore;
-	  double dummy;
-	  A->nrow = nr;
-	  A->ncol = nc;
-
-	  A->p = cidx();
-	  A->i = ridx();
-	  A->nzmax = nnz();
-	  A->packed = true;
-	  A->sorted = true;
-	  A->nz = 0;
+          cholmod_common Common;
+          cholmod_common *cm = &Common;
+
+          // Setup initial parameters
+          CHOLMOD_NAME(start) (cm);
+          cm->prefer_zomplex = false;
+
+          double spu = octave_sparse_params::get_key ("spumoni");
+          if (spu == 0.)
+            {
+              cm->print = -1;
+              cm->print_function = 0;
+            }
+          else
+            {
+              cm->print = static_cast<int> (spu) + 2;
+              cm->print_function =&SparseCholPrint;
+            }
+
+          cm->error_handler = &SparseCholError;
+          cm->complex_divide = CHOLMOD_NAME(divcomplex);
+          cm->hypotenuse = CHOLMOD_NAME(hypot);
+
+          cm->final_ll = true;
+
+          cholmod_sparse Astore;
+          cholmod_sparse *A = &Astore;
+          double dummy;
+          A->nrow = nr;
+          A->ncol = nc;
+
+          A->p = cidx();
+          A->i = ridx();
+          A->nzmax = nnz();
+          A->packed = true;
+          A->sorted = true;
+          A->nz = 0;
 #ifdef IDX_TYPE_LONG
-	  A->itype = CHOLMOD_LONG;
+          A->itype = CHOLMOD_LONG;
 #else
-	  A->itype = CHOLMOD_INT;
+          A->itype = CHOLMOD_INT;
 #endif
-	  A->dtype = CHOLMOD_DOUBLE;
-	  A->stype = 1;
-	  A->xtype = CHOLMOD_COMPLEX;
-
-	  if (nr < 1)
-	    A->x = &dummy;
-	  else
-	    A->x = data();
-
-	  cholmod_dense Bstore;
-	  cholmod_dense *B = &Bstore;
-	  B->nrow = b.rows();
-	  B->ncol = b.cols();
-	  B->d = B->nrow;
-	  B->nzmax = B->nrow * B->ncol;
-	  B->dtype = CHOLMOD_DOUBLE;
-	  B->xtype = CHOLMOD_COMPLEX;
-	  if (nc < 1 || b.cols() < 1)
-	    B->x = &dummy;
-	  else
-	    // We won't alter it, honest :-)
-	    B->x = const_cast<Complex *>(b.fortran_vec());
-
-	  cholmod_factor *L;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  L = CHOLMOD_NAME(analyze) (A, cm);
-	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  if (calc_cond)
-	    rcond = CHOLMOD_NAME(rcond)(L, cm);
-	  else
-	    rcond = 1.;
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	  if (rcond == 0.0)
-	    {
-	      // Either its indefinite or singular. Try UMFPACK
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	  else
-	    {
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  err = -2;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		       rcond);
-	      
-		  return retval;
-		}
-
-	      cholmod_dense *X;
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	      retval.resize (b.rows (), b.cols());
-	      for (octave_idx_type j = 0; j < b.cols(); j++)
-		{
-		  octave_idx_type jr = j * b.rows();
-		  for (octave_idx_type i = 0; i < b.rows(); i++)
-		    retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
-		}
-
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CHOLMOD_NAME(free_dense) (&X, cm);
-	      CHOLMOD_NAME(free_factor) (&L, cm);
-	      CHOLMOD_NAME(finish) (cm);
-	      static char tmp[] = " ";
-	      CHOLMOD_NAME(print_common) (tmp, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
+          A->dtype = CHOLMOD_DOUBLE;
+          A->stype = 1;
+          A->xtype = CHOLMOD_COMPLEX;
+
+          if (nr < 1)
+            A->x = &dummy;
+          else
+            A->x = data();
+
+          cholmod_dense Bstore;
+          cholmod_dense *B = &Bstore;
+          B->nrow = b.rows();
+          B->ncol = b.cols();
+          B->d = B->nrow;
+          B->nzmax = B->nrow * B->ncol;
+          B->dtype = CHOLMOD_DOUBLE;
+          B->xtype = CHOLMOD_COMPLEX;
+          if (nc < 1 || b.cols() < 1)
+            B->x = &dummy;
+          else
+            // We won't alter it, honest :-)
+            B->x = const_cast<Complex *>(b.fortran_vec());
+
+          cholmod_factor *L;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          L = CHOLMOD_NAME(analyze) (A, cm);
+          CHOLMOD_NAME(factorize) (A, L, cm);
+          if (calc_cond)
+            rcond = CHOLMOD_NAME(rcond)(L, cm);
+          else
+            rcond = 1.;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+          if (rcond == 0.0)
+            {
+              // Either its indefinite or singular. Try UMFPACK
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+          else
+            {
+              volatile double rcond_plus_one = rcond + 1.0;
+
+              if (rcond_plus_one == 1.0 || xisnan (rcond))
+                {
+                  err = -2;
+
+                  if (sing_handler)
+                    {
+                      sing_handler (rcond);
+                      mattype.mark_as_rectangular ();
+                    }
+                  else
+                    (*current_liboctave_error_handler)
+                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                       rcond);
+              
+                  return retval;
+                }
+
+              cholmod_dense *X;
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+              retval.resize (b.rows (), b.cols());
+              for (octave_idx_type j = 0; j < b.cols(); j++)
+                {
+                  octave_idx_type jr = j * b.rows();
+                  for (octave_idx_type i = 0; i < b.rows(); i++)
+                    retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
+                }
+
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CHOLMOD_NAME(free_dense) (&X, cm);
+              CHOLMOD_NAME(free_factor) (&L, cm);
+              CHOLMOD_NAME(finish) (cm);
+              static char tmp[] = " ";
+              CHOLMOD_NAME(print_common) (tmp, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
 #else
-	  (*current_liboctave_warning_handler)
-	    ("CHOLMOD not installed");
-
-	  mattype.mark_as_unsymmetric ();
-	  typ = MatrixType::Full;
+          (*current_liboctave_warning_handler)
+            ("CHOLMOD not installed");
+
+          mattype.mark_as_unsymmetric ();
+          typ = MatrixType::Full;
 #endif
-	}
+        }
 
       if (typ == MatrixType::Full)
-	{
+        {
 #ifdef HAVE_UMFPACK
-	  Matrix Control, Info;
-	  void *Numeric = factorize (err, rcond, Control, Info,
-				     sing_handler, calc_cond);
-
-	  if (err == 0)
-	    {
-	      octave_idx_type b_nr = b.rows ();
-	      octave_idx_type b_nc = b.cols ();
-	      int status = 0;
-	      double *control = Control.fortran_vec ();
-	      double *info = Info.fortran_vec ();
-	      const octave_idx_type *Ap = cidx ();
-	      const octave_idx_type *Ai = ridx ();
-	      const Complex *Ax = data ();
-	      const Complex *Bx = b.fortran_vec ();
-
-	      retval.resize (b_nr, b_nc);
-	      Complex *Xx = retval.fortran_vec ();
-	      
-	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
-		{
-		  status = 
-		    UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai, 
-				      reinterpret_cast<const double *> (Ax), 
-				      0,
-				      reinterpret_cast<double *> (&Xx[iidx]), 
-				      0,
-				      reinterpret_cast<const double *> (&Bx[iidx]), 
-				      0, Numeric, control, info);
-		  
-		  if (status < 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseComplexMatrix::solve solve failed");
-
-		      UMFPACK_ZNAME (report_status) (control, status);
-		      
-		      err = -1;
-
-		      break;
-		    }
-		}
-
-	      UMFPACK_ZNAME (report_info) (control, info);
-
-	      UMFPACK_ZNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    mattype.mark_as_rectangular ();
+          Matrix Control, Info;
+          void *Numeric = factorize (err, rcond, Control, Info,
+                                     sing_handler, calc_cond);
+
+          if (err == 0)
+            {
+              octave_idx_type b_nr = b.rows ();
+              octave_idx_type b_nc = b.cols ();
+              int status = 0;
+              double *control = Control.fortran_vec ();
+              double *info = Info.fortran_vec ();
+              const octave_idx_type *Ap = cidx ();
+              const octave_idx_type *Ai = ridx ();
+              const Complex *Ax = data ();
+              const Complex *Bx = b.fortran_vec ();
+
+              retval.resize (b_nr, b_nc);
+              Complex *Xx = retval.fortran_vec ();
+              
+              for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
+                {
+                  status = 
+                    UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai, 
+                                      reinterpret_cast<const double *> (Ax), 
+                                      0,
+                                      reinterpret_cast<double *> (&Xx[iidx]), 
+                                      0,
+                                      reinterpret_cast<const double *> (&Bx[iidx]), 
+                                      0, Numeric, control, info);
+                  
+                  if (status < 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseComplexMatrix::solve solve failed");
+
+                      UMFPACK_ZNAME (report_status) (control, status);
+                      
+                      err = -1;
+
+                      break;
+                    }
+                }
+
+              UMFPACK_ZNAME (report_info) (control, info);
+
+              UMFPACK_ZNAME (free_numeric) (&Numeric);
+            }
+          else
+            mattype.mark_as_rectangular ();
 
 #else
-	  (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
-	}
+        }
       else if (typ != MatrixType::Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::fsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-			     octave_idx_type& err, double& rcond,
-			     solve_singularity_handler sing_handler,
-			     bool calc_cond) const
+                             octave_idx_type& err, double& rcond,
+                             solve_singularity_handler sing_handler,
+                             bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -6376,610 +6376,610 @@ SparseComplexMatrix::fsolve (MatrixType 
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
-	{
+        {
 #ifdef HAVE_CHOLMOD
-	  cholmod_common Common;
-	  cholmod_common *cm = &Common;
-
-	  // Setup initial parameters
-	  CHOLMOD_NAME(start) (cm);
-	  cm->prefer_zomplex = false;
-
-	  double spu = octave_sparse_params::get_key ("spumoni");
-	  if (spu == 0.)
-	    {
-	      cm->print = -1;
-	      cm->print_function = 0;
-	    }
-	  else
-	    {
-	      cm->print = static_cast<int> (spu) + 2;
-	      cm->print_function =&SparseCholPrint;
-	    }
-
-	  cm->error_handler = &SparseCholError;
-	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
-	  cm->hypotenuse = CHOLMOD_NAME(hypot);
-
-	  cm->final_ll = true;
-
-	  cholmod_sparse Astore;
-	  cholmod_sparse *A = &Astore;
-	  double dummy;
-	  A->nrow = nr;
-	  A->ncol = nc;
-
-	  A->p = cidx();
-	  A->i = ridx();
-	  A->nzmax = nnz();
-	  A->packed = true;
-	  A->sorted = true;
-	  A->nz = 0;
+          cholmod_common Common;
+          cholmod_common *cm = &Common;
+
+          // Setup initial parameters
+          CHOLMOD_NAME(start) (cm);
+          cm->prefer_zomplex = false;
+
+          double spu = octave_sparse_params::get_key ("spumoni");
+          if (spu == 0.)
+            {
+              cm->print = -1;
+              cm->print_function = 0;
+            }
+          else
+            {
+              cm->print = static_cast<int> (spu) + 2;
+              cm->print_function =&SparseCholPrint;
+            }
+
+          cm->error_handler = &SparseCholError;
+          cm->complex_divide = CHOLMOD_NAME(divcomplex);
+          cm->hypotenuse = CHOLMOD_NAME(hypot);
+
+          cm->final_ll = true;
+
+          cholmod_sparse Astore;
+          cholmod_sparse *A = &Astore;
+          double dummy;
+          A->nrow = nr;
+          A->ncol = nc;
+
+          A->p = cidx();
+          A->i = ridx();
+          A->nzmax = nnz();
+          A->packed = true;
+          A->sorted = true;
+          A->nz = 0;
 #ifdef IDX_TYPE_LONG
-	  A->itype = CHOLMOD_LONG;
+          A->itype = CHOLMOD_LONG;
 #else
-	  A->itype = CHOLMOD_INT;
+          A->itype = CHOLMOD_INT;
 #endif
-	  A->dtype = CHOLMOD_DOUBLE;
-	  A->stype = 1;
-	  A->xtype = CHOLMOD_COMPLEX;
-
-	  if (nr < 1)
-	    A->x = &dummy;
-	  else
-	    A->x = data();
-
-	  cholmod_sparse Bstore;
-	  cholmod_sparse *B = &Bstore;
-	  B->nrow = b.rows();
-	  B->ncol = b.cols();
-	  B->p = b.cidx();
-	  B->i = b.ridx();
-	  B->nzmax = b.nnz();
-	  B->packed = true;
-	  B->sorted = true;
-	  B->nz = 0;
+          A->dtype = CHOLMOD_DOUBLE;
+          A->stype = 1;
+          A->xtype = CHOLMOD_COMPLEX;
+
+          if (nr < 1)
+            A->x = &dummy;
+          else
+            A->x = data();
+
+          cholmod_sparse Bstore;
+          cholmod_sparse *B = &Bstore;
+          B->nrow = b.rows();
+          B->ncol = b.cols();
+          B->p = b.cidx();
+          B->i = b.ridx();
+          B->nzmax = b.nnz();
+          B->packed = true;
+          B->sorted = true;
+          B->nz = 0;
 #ifdef IDX_TYPE_LONG
-	  B->itype = CHOLMOD_LONG;
+          B->itype = CHOLMOD_LONG;
 #else
-	  B->itype = CHOLMOD_INT;
+          B->itype = CHOLMOD_INT;
 #endif
-	  B->dtype = CHOLMOD_DOUBLE;
-	  B->stype = 0;
-	  B->xtype = CHOLMOD_COMPLEX;
-
-	  if (b.rows() < 1 || b.cols() < 1)
-	    B->x = &dummy;
-	  else
-	    B->x = b.data();
-
-	  cholmod_factor *L;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  L = CHOLMOD_NAME(analyze) (A, cm);
-	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  if (calc_cond)
-	    rcond = CHOLMOD_NAME(rcond)(L, cm);
-	  else
-	    rcond = 1.;
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	  if (rcond == 0.0)
-	    {
-	      // Either its indefinite or singular. Try UMFPACK
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	  else
-	    {
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  err = -2;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		       rcond);
-	      
-		  return retval;
-		}
-
-	      cholmod_sparse *X;
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	      retval = SparseComplexMatrix 
-		(static_cast<octave_idx_type>(X->nrow), 
-		 static_cast<octave_idx_type>(X->ncol),
-		 static_cast<octave_idx_type>(X->nzmax));
-	      for (octave_idx_type j = 0; 
-		   j <= static_cast<octave_idx_type>(X->ncol); j++)
-		retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
-	      for (octave_idx_type j = 0; 
-		   j < static_cast<octave_idx_type>(X->nzmax); j++)
-		{
-		  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
-		  retval.xdata(j) = static_cast<Complex *>(X->x)[j];
-		}
-
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CHOLMOD_NAME(free_sparse) (&X, cm);
-	      CHOLMOD_NAME(free_factor) (&L, cm);
-	      CHOLMOD_NAME(finish) (cm);
-	      static char tmp[] = " ";
-	      CHOLMOD_NAME(print_common) (tmp, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
+          B->dtype = CHOLMOD_DOUBLE;
+          B->stype = 0;
+          B->xtype = CHOLMOD_COMPLEX;
+
+          if (b.rows() < 1 || b.cols() < 1)
+            B->x = &dummy;
+          else
+            B->x = b.data();
+
+          cholmod_factor *L;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          L = CHOLMOD_NAME(analyze) (A, cm);
+          CHOLMOD_NAME(factorize) (A, L, cm);
+          if (calc_cond)
+            rcond = CHOLMOD_NAME(rcond)(L, cm);
+          else
+            rcond = 1.;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+          if (rcond == 0.0)
+            {
+              // Either its indefinite or singular. Try UMFPACK
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+          else
+            {
+              volatile double rcond_plus_one = rcond + 1.0;
+
+              if (rcond_plus_one == 1.0 || xisnan (rcond))
+                {
+                  err = -2;
+
+                  if (sing_handler)
+                    {
+                      sing_handler (rcond);
+                      mattype.mark_as_rectangular ();
+                    }
+                  else
+                    (*current_liboctave_error_handler)
+                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                       rcond);
+              
+                  return retval;
+                }
+
+              cholmod_sparse *X;
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+              retval = SparseComplexMatrix 
+                (static_cast<octave_idx_type>(X->nrow), 
+                 static_cast<octave_idx_type>(X->ncol),
+                 static_cast<octave_idx_type>(X->nzmax));
+              for (octave_idx_type j = 0; 
+                   j <= static_cast<octave_idx_type>(X->ncol); j++)
+                retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
+              for (octave_idx_type j = 0; 
+                   j < static_cast<octave_idx_type>(X->nzmax); j++)
+                {
+                  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
+                  retval.xdata(j) = static_cast<Complex *>(X->x)[j];
+                }
+
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CHOLMOD_NAME(free_sparse) (&X, cm);
+              CHOLMOD_NAME(free_factor) (&L, cm);
+              CHOLMOD_NAME(finish) (cm);
+              static char tmp[] = " ";
+              CHOLMOD_NAME(print_common) (tmp, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
 #else
-	  (*current_liboctave_warning_handler)
-	    ("CHOLMOD not installed");
-
-	  mattype.mark_as_unsymmetric ();
-	  typ = MatrixType::Full;
+          (*current_liboctave_warning_handler)
+            ("CHOLMOD not installed");
+
+          mattype.mark_as_unsymmetric ();
+          typ = MatrixType::Full;
 #endif
-	}
+        }
 
       if (typ == MatrixType::Full)
-	{
+        {
 #ifdef HAVE_UMFPACK
-	  Matrix Control, Info;
-	  void *Numeric = factorize (err, rcond, Control, Info,
-				     sing_handler, calc_cond);
-
-	  if (err == 0)
-	    {
-	      octave_idx_type b_nr = b.rows ();
-	      octave_idx_type b_nc = b.cols ();
-	      int status = 0;
-	      double *control = Control.fortran_vec ();
-	      double *info = Info.fortran_vec ();
-	      const octave_idx_type *Ap = cidx ();
-	      const octave_idx_type *Ai = ridx ();
-	      const Complex *Ax = data ();
-
-	      OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
-
-	      // Take a first guess that the number of non-zero terms
-	      // will be as many as in b
-	      octave_idx_type x_nz = b.nnz ();
-	      octave_idx_type ii = 0;
-	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-	      OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
-	      
-	      retval.xcidx(0) = 0;
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    Bx[i] = b (i,j);
-
-		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-					     Ai,
-					     reinterpret_cast<const double *> (Ax),
-					     0,
-					     reinterpret_cast<double *> (Xx),
-					     0,
-					     reinterpret_cast<double *> (Bx),
-					     0, Numeric, control, info);
-		  
-		  if (status < 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseComplexMatrix::solve solve failed");
-
-		      UMFPACK_ZNAME (report_status) (control, status);
-		  
-		      err = -1;
-
-		      break;
-		    }
-
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    {
-		      Complex tmp = Xx[i];
-		      if (tmp != 0.0)
-			{
-			  if (ii == x_nz)
-			    {
-			      // Resize the sparse matrix
-			      octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
-			      sz = (sz > 10 ? sz : 10) + x_nz;
-			      retval.change_capacity (sz);
-			      x_nz = sz;
-			    }
-			  retval.xdata(ii) = tmp;
-			  retval.xridx(ii++) = i;
-			}
-		    }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      rcond = Info (UMFPACK_RCOND);
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (status == UMFPACK_WARNING_singular_matrix || 
-		  rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  err = -2;
-
-		  if (sing_handler)
-		    sing_handler (rcond);
-		  else
-		    (*current_liboctave_error_handler)
-		      ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
-		       rcond);
-
-		}
-
-	      UMFPACK_ZNAME (report_info) (control, info);
-
-	      UMFPACK_ZNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    mattype.mark_as_rectangular ();
+          Matrix Control, Info;
+          void *Numeric = factorize (err, rcond, Control, Info,
+                                     sing_handler, calc_cond);
+
+          if (err == 0)
+            {
+              octave_idx_type b_nr = b.rows ();
+              octave_idx_type b_nc = b.cols ();
+              int status = 0;
+              double *control = Control.fortran_vec ();
+              double *info = Info.fortran_vec ();
+              const octave_idx_type *Ap = cidx ();
+              const octave_idx_type *Ai = ridx ();
+              const Complex *Ax = data ();
+
+              OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
+
+              // Take a first guess that the number of non-zero terms
+              // will be as many as in b
+              octave_idx_type x_nz = b.nnz ();
+              octave_idx_type ii = 0;
+              retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+              OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
+              
+              retval.xcidx(0) = 0;
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    Bx[i] = b (i,j);
+
+                  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
+                                             Ai,
+                                             reinterpret_cast<const double *> (Ax),
+                                             0,
+                                             reinterpret_cast<double *> (Xx),
+                                             0,
+                                             reinterpret_cast<double *> (Bx),
+                                             0, Numeric, control, info);
+                  
+                  if (status < 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseComplexMatrix::solve solve failed");
+
+                      UMFPACK_ZNAME (report_status) (control, status);
+                  
+                      err = -1;
+
+                      break;
+                    }
+
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    {
+                      Complex tmp = Xx[i];
+                      if (tmp != 0.0)
+                        {
+                          if (ii == x_nz)
+                            {
+                              // Resize the sparse matrix
+                              octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
+                              sz = (sz > 10 ? sz : 10) + x_nz;
+                              retval.change_capacity (sz);
+                              x_nz = sz;
+                            }
+                          retval.xdata(ii) = tmp;
+                          retval.xridx(ii++) = i;
+                        }
+                    }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              rcond = Info (UMFPACK_RCOND);
+              volatile double rcond_plus_one = rcond + 1.0;
+
+              if (status == UMFPACK_WARNING_singular_matrix || 
+                  rcond_plus_one == 1.0 || xisnan (rcond))
+                {
+                  err = -2;
+
+                  if (sing_handler)
+                    sing_handler (rcond);
+                  else
+                    (*current_liboctave_error_handler)
+                      ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
+                       rcond);
+
+                }
+
+              UMFPACK_ZNAME (report_info) (control, info);
+
+              UMFPACK_ZNAME (free_numeric) (&Numeric);
+            }
+          else
+            mattype.mark_as_rectangular ();
 
 #else
-	  (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
-	}
+        }
       else if (typ != MatrixType::Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b, 
-			    octave_idx_type& info) const
+                            octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b,
-			    octave_idx_type& info, double& rcond) const
+                            octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b,
-			    octave_idx_type& err, double& rcond, 
-			    solve_singularity_handler sing_handler,
-			    bool singular_fallback) const
+                            octave_idx_type& err, double& rcond, 
+                            solve_singularity_handler sing_handler,
+                            bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal || 
-	   typ == MatrixType::Tridiagonal_Hermitian)
+           typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
   if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseComplexMatrix,
-	Matrix> (*this, b, err);
+        Matrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b, 
-		     octave_idx_type& info) const
+                     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
-		     octave_idx_type& info, double& rcond) const
+                     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b, 
-			    octave_idx_type& err, double& rcond,
-			    solve_singularity_handler sing_handler,
-			    bool singular_fallback) const
+                            octave_idx_type& err, double& rcond,
+                            solve_singularity_handler sing_handler,
+                            bool singular_fallback) const
 {
   SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal || 
-	   typ == MatrixType::Tridiagonal_Hermitian)
+           typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
   if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
-	SparseMatrix> (*this, b, err);
+        SparseMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
-			    octave_idx_type& info) const
+                            octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
-			    octave_idx_type& info, double& rcond) const
+                            octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
-			    octave_idx_type& err, double& rcond, 
-			    solve_singularity_handler sing_handler,
-			    bool singular_fallback) const
+                            octave_idx_type& err, double& rcond, 
+                            solve_singularity_handler sing_handler,
+                            bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal || 
-	   typ == MatrixType::Tridiagonal_Hermitian)
+           typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
   if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseComplexMatrix,
-	ComplexMatrix> (*this, b, err);
+        ComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, 
-			    const SparseComplexMatrix& b) const
+                            const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b, 
-			    octave_idx_type& info) const
+                            octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
-			    octave_idx_type& info, double& rcond) const
+                            octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b, 
-			    octave_idx_type& err, double& rcond,
-			    solve_singularity_handler sing_handler,
-			    bool singular_fallback) const
+                            octave_idx_type& err, double& rcond,
+                            solve_singularity_handler sing_handler,
+                            bool singular_fallback) const
 {
   SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal || 
-	   typ == MatrixType::Tridiagonal_Hermitian)
+           typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
   if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
-	SparseComplexMatrix> (*this, b, err);
+        SparseComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b) const
 {
   octave_idx_type info; double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b, 
-			    octave_idx_type& info) const
+                            octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b, 
-			    octave_idx_type& info, double& rcond) const
+                            octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b, 
-			    octave_idx_type& info, double& rcond,
-			    solve_singularity_handler sing_handler) const
+                            octave_idx_type& info, double& rcond,
+                            solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
   return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, 
-			    const ComplexColumnVector& b) const
+                            const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
-			    octave_idx_type& info) const
+                            octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
-			    octave_idx_type& info, double& rcond) const
+                            octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
-			    octave_idx_type& info, double& rcond,
-			    solve_singularity_handler sing_handler) const
+                            octave_idx_type& info, double& rcond,
+                            solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b) const
 {
@@ -6992,113 +6992,113 @@ ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& info, 
-		     double& rcond) const
+                     double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& err, 
-			    double& rcond, 
-			    solve_singularity_handler sing_handler) const
+                            double& rcond, 
+                            solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b, 
-		     octave_idx_type& info) const
+                     octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b,
-		     octave_idx_type& info, double& rcond) const
+                     octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b, 
-		     octave_idx_type& err, double& rcond,
-		     solve_singularity_handler sing_handler) const
+                     octave_idx_type& err, double& rcond,
+                     solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b, 
-			    octave_idx_type& info) const
+                            octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b, 
-		     octave_idx_type& info, double& rcond) const
+                     octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b, 
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler) const
+                     octave_idx_type& err, double& rcond, 
+                     solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b, 
-		     octave_idx_type& info) const
+                     octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b,
-		     octave_idx_type& info, double& rcond) const
+                     octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b, 
-		     octave_idx_type& err, double& rcond,
-		     solve_singularity_handler sing_handler) const
+                     octave_idx_type& err, double& rcond,
+                     solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ColumnVector& b) const
 {
@@ -7110,24 +7110,24 @@ ComplexColumnVector
 SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, 
-			    double& rcond) const
+                            double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
-			    solve_singularity_handler sing_handler) const
+                            solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
   return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b) const
 {
@@ -7140,25 +7140,25 @@ ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, 
-		     double& rcond) const
+                     double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, 
-			    double& rcond,
-			    solve_singularity_handler sing_handler) const
+                            double& rcond,
+                            solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 // unary operations
 SparseBoolMatrix
 SparseComplexMatrix::operator ! (void) const
@@ -7171,25 +7171,25 @@ SparseComplexMatrix::operator ! (void) c
   SparseBoolMatrix r (nr, nc, nz2);
    
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = 0; j < nr; j++)
-	{
-	  if (jj < cidx(i+1) && ridx(jj) == j)
-	    jj++;
-	  else
-	    {
-	      r.data(ii) = true;
-	      r.ridx(ii++) = j;
-	    }
-	}
+        {
+          if (jj < cidx(i+1) && ridx(jj) == j)
+            jj++;
+          else
+            {
+              r.data(ii) = true;
+              r.ridx(ii++) = j;
+            }
+        }
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
 SparseComplexMatrix 
 SparseComplexMatrix::squeeze (void) const
@@ -7238,32 +7238,32 @@ bool
 SparseComplexMatrix::any_element_is_nan (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = data (i);
       if (xisnan (val))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 SparseComplexMatrix::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = data (i);
       if (xisinf (val) || xisnan (val))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 // Return true if no elements have imaginary components.
 
 bool
@@ -7284,57 +7284,57 @@ SparseComplexMatrix::all_integers (doubl
   if (nel == 0)
     return false;
 
   max_val = std::real(data (0));
   min_val = std::real(data (0));
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-	Complex val = data (i);
-
-	double r_val = std::real (val);
-	double i_val = std::imag (val);
-
-	if (r_val > max_val)
-	  max_val = r_val;
-
-	if (i_val > max_val)
-	  max_val = i_val;
-
-	if (r_val < min_val)
-	  min_val = r_val;
-
-	if (i_val < min_val)
-	  min_val = i_val;
-
-	if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
-	  return false;
+        Complex val = data (i);
+
+        double r_val = std::real (val);
+        double i_val = std::imag (val);
+
+        if (r_val > max_val)
+          max_val = r_val;
+
+        if (i_val > max_val)
+          max_val = i_val;
+
+        if (r_val < min_val)
+          min_val = r_val;
+
+        if (i_val < min_val)
+          min_val = i_val;
+
+        if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
+          return false;
     }
 
   return true;
 }
 
 bool
 SparseComplexMatrix::too_large_for_float (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-	Complex val = data (i);
-
-	double r_val = std::real (val);
-	double i_val = std::imag (val);
-
-	if (r_val > FLT_MAX
-	    || i_val > FLT_MAX
-	    || r_val < FLT_MIN
-	    || i_val < FLT_MIN)
-	  return true;
+        Complex val = data (i);
+
+        double r_val = std::real (val);
+        double i_val = std::imag (val);
+
+        if (r_val > FLT_MAX
+            || i_val > FLT_MAX
+            || r_val < FLT_MIN
+            || i_val < FLT_MIN)
+          return true;
     }
 
   return false;
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
@@ -7365,17 +7365,17 @@ SparseComplexMatrix::cumsum (int dim) co
 SparseComplexMatrix
 SparseComplexMatrix::prod (int dim) const
 {
   if ((rows() == 1 && dim == -1) || dim == 1)
     return transpose (). prod (0). transpose();
   else
     {
       SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, *=, 
-			   (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
+                           (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::sum (int dim) const
 {
   SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, +=, 0.0, 0.0);
 }
@@ -7387,17 +7387,17 @@ SparseComplexMatrix::sumsq (int dim) con
   Complex d = data (i); \
   tmp [ridx(i)] += d * conj (d)
 
 #define COL_EXPR \
   Complex d = data (i); \
   tmp [j] += d * conj (d)
 
   SPARSE_BASE_REDUCTION_OP (SparseComplexMatrix, Complex, ROW_EXPR, 
-			    COL_EXPR, 0.0, 0.0);
+                            COL_EXPR, 0.0, 0.0);
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
 SparseMatrix SparseComplexMatrix::abs (void) const
 {
   octave_idx_type nz = nnz ();
@@ -7428,19 +7428,19 @@ operator << (std::ostream& os, const Spa
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)  {
       octave_quit ();
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++) {
-	os << a.ridx(i) + 1 << " "  << j + 1 << " ";
-	octave_write_complex (os, a.data(i));
-	os << "\n";
+        os << a.ridx(i) + 1 << " "  << j + 1 << " ";
+        octave_write_complex (os, a.data(i));
+        os << "\n";
       }
    }
 
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseComplexMatrix& a)
@@ -7657,18 +7657,18 @@ min (const Complex& c, const SparseCompl
 
   if (abs(c) == 0.)
     return SparseComplexMatrix (nr, nc);
   else
     {
       result = SparseComplexMatrix (m);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-	  result.data(i) = xmin(c, m.data(i));
+        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+          result.data(i) = xmin(c, m.data(i));
     }
   
   return result;
 }
 
 SparseComplexMatrix
 min (const SparseComplexMatrix& m, const Complex& c)
 {
@@ -7684,85 +7684,85 @@ min (const SparseComplexMatrix& a, const
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr == 0 || b_nc == 0 || a.nnz () == 0 || b.nnz () == 0)
-	return SparseComplexMatrix (a_nr, a_nc);
+        return SparseComplexMatrix (a_nr, a_nc);
 
       if (a_nr != b_nr || a_nc != b_nc)
-	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
+        gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
-	{
-	  r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
+        {
+          r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
-	  octave_idx_type jx = 0;
-	  r.cidx (0) = 0;
-	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
-	    {
-	      octave_idx_type  ja = a.cidx(i);
-	      octave_idx_type  ja_max = a.cidx(i+1);
-	      bool ja_lt_max= ja < ja_max;
+          octave_idx_type jx = 0;
+          r.cidx (0) = 0;
+          for (octave_idx_type i = 0 ; i < a_nc ; i++)
+            {
+              octave_idx_type  ja = a.cidx(i);
+              octave_idx_type  ja_max = a.cidx(i+1);
+              bool ja_lt_max= ja < ja_max;
            
-	      octave_idx_type  jb = b.cidx(i);
-	      octave_idx_type  jb_max = b.cidx(i+1);
-	      bool jb_lt_max = jb < jb_max;
+              octave_idx_type  jb = b.cidx(i);
+              octave_idx_type  jb_max = b.cidx(i+1);
+              bool jb_lt_max = jb < jb_max;
            
-	      while (ja_lt_max || jb_lt_max )
-		{
-		  octave_quit ();
-		  if ((! jb_lt_max) ||
+              while (ja_lt_max || jb_lt_max )
+                {
+                  octave_quit ();
+                  if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
-		    {
-		      Complex tmp = xmin (a.data(ja), 0.);
-		      if (tmp != 0.)
-			{
-			  r.ridx(jx) = a.ridx(ja);
-			  r.data(jx) = tmp;
-			  jx++;
-			}
-		      ja++;
-		      ja_lt_max= ja < ja_max;
-		    }
-		  else if (( !ja_lt_max ) ||
-			   (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
-		    {
-		      Complex tmp = xmin (0., b.data(jb));
-		      if (tmp != 0.)
-			{
-			  r.ridx(jx) = b.ridx(jb);
-			  r.data(jx) = tmp;
-			  jx++;
-			}
-		      jb++;
-		      jb_lt_max= jb < jb_max;
-		    }
-		  else
-		    {
-		      Complex tmp = xmin (a.data(ja), b.data(jb));
-		      if (tmp != 0.)
-			{
+                    {
+                      Complex tmp = xmin (a.data(ja), 0.);
+                      if (tmp != 0.)
+                        {
+                          r.ridx(jx) = a.ridx(ja);
+                          r.data(jx) = tmp;
+                          jx++;
+                        }
+                      ja++;
+                      ja_lt_max= ja < ja_max;
+                    }
+                  else if (( !ja_lt_max ) ||
+                           (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                    {
+                      Complex tmp = xmin (0., b.data(jb));
+                      if (tmp != 0.)
+                        {
+                          r.ridx(jx) = b.ridx(jb);
+                          r.data(jx) = tmp;
+                          jx++;
+                        }
+                      jb++;
+                      jb_lt_max= jb < jb_max;
+                    }
+                  else
+                    {
+                      Complex tmp = xmin (a.data(ja), b.data(jb));
+                      if (tmp != 0.)
+                        {
                           r.data(jx) = tmp;
                           r.ridx(jx) = a.ridx(ja);
                           jx++;
-			}
-		      ja++;
-		      ja_lt_max= ja < ja_max;
-		      jb++;
-		      jb_lt_max= jb < jb_max;
-		    }
-		}
-	      r.cidx(i+1) = jx;
-	    }
-	  
-	  r.maybe_compress ();
-	}
+                        }
+                      ja++;
+                      ja_lt_max= ja < ja_max;
+                      jb++;
+                      jb_lt_max= jb < jb_max;
+                    }
+                }
+              r.cidx(i+1) = jx;
+            }
+          
+          r.maybe_compress ();
+        }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
 
 SparseComplexMatrix
@@ -7775,18 +7775,18 @@ max (const Complex& c, const SparseCompl
 
   EMPTY_RETURN_CHECK (SparseComplexMatrix);
 
   // Count the number of non-zero elements
   if (xmax(c, 0.) != 0.)
     {
       result = SparseComplexMatrix (nr, nc, c);
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-	  result.xdata(m.ridx(i) + j * nr) = xmax (c, m.data(i));
+        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+          result.xdata(m.ridx(i) + j * nr) = xmax (c, m.data(i));
     }
   else
     result = SparseComplexMatrix (m);
 
   return result;
 }
 
 SparseComplexMatrix
@@ -7804,99 +7804,99 @@ max (const SparseComplexMatrix& a, const
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr == 0 || b_nc == 0)
-	return SparseComplexMatrix (a_nr, a_nc);
+        return SparseComplexMatrix (a_nr, a_nc);
       if (a.nnz () == 0)
-	return SparseComplexMatrix (b);
+        return SparseComplexMatrix (b);
       if (b.nnz () == 0)
-	return SparseComplexMatrix (a);
+        return SparseComplexMatrix (a);
 
       if (a_nr != b_nr || a_nc != b_nc)
-	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
+        gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
-	{
-	  r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
+        {
+          r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
-	  octave_idx_type jx = 0;
-	  r.cidx (0) = 0;
-	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
-	    {
-	      octave_idx_type  ja = a.cidx(i);
-	      octave_idx_type  ja_max = a.cidx(i+1);
-	      bool ja_lt_max= ja < ja_max;
+          octave_idx_type jx = 0;
+          r.cidx (0) = 0;
+          for (octave_idx_type i = 0 ; i < a_nc ; i++)
+            {
+              octave_idx_type  ja = a.cidx(i);
+              octave_idx_type  ja_max = a.cidx(i+1);
+              bool ja_lt_max= ja < ja_max;
            
-	      octave_idx_type  jb = b.cidx(i);
-	      octave_idx_type  jb_max = b.cidx(i+1);
-	      bool jb_lt_max = jb < jb_max;
+              octave_idx_type  jb = b.cidx(i);
+              octave_idx_type  jb_max = b.cidx(i+1);
+              bool jb_lt_max = jb < jb_max;
            
-	      while (ja_lt_max || jb_lt_max )
-		{
-		  octave_quit ();
-		  if ((! jb_lt_max) ||
+              while (ja_lt_max || jb_lt_max )
+                {
+                  octave_quit ();
+                  if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
-		    {
-		      Complex tmp = xmax (a.data(ja), 0.);
-		      if (tmp != 0.)
-			{
-			  r.ridx(jx) = a.ridx(ja);
-			  r.data(jx) = tmp;
-			  jx++;
-			}
-		      ja++;
-		      ja_lt_max= ja < ja_max;
-		    }
-		  else if (( !ja_lt_max ) ||
-			   (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
-		    {
-		      Complex tmp = xmax (0., b.data(jb));
-		      if (tmp != 0.)
-			{
-			  r.ridx(jx) = b.ridx(jb);
-			  r.data(jx) = tmp;
-			  jx++;
-			}
-		      jb++;
-		      jb_lt_max= jb < jb_max;
-		    }
-		  else
-		    {
-		      Complex tmp = xmax (a.data(ja), b.data(jb));
-		      if (tmp != 0.)
-			{
+                    {
+                      Complex tmp = xmax (a.data(ja), 0.);
+                      if (tmp != 0.)
+                        {
+                          r.ridx(jx) = a.ridx(ja);
+                          r.data(jx) = tmp;
+                          jx++;
+                        }
+                      ja++;
+                      ja_lt_max= ja < ja_max;
+                    }
+                  else if (( !ja_lt_max ) ||
+                           (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                    {
+                      Complex tmp = xmax (0., b.data(jb));
+                      if (tmp != 0.)
+                        {
+                          r.ridx(jx) = b.ridx(jb);
+                          r.data(jx) = tmp;
+                          jx++;
+                        }
+                      jb++;
+                      jb_lt_max= jb < jb_max;
+                    }
+                  else
+                    {
+                      Complex tmp = xmax (a.data(ja), b.data(jb));
+                      if (tmp != 0.)
+                        {
                           r.data(jx) = tmp;
                           r.ridx(jx) = a.ridx(ja);
                           jx++;
-			}
-		      ja++;
-		      ja_lt_max= ja < ja_max;
-		      jb++;
-		      jb_lt_max= jb < jb_max;
-		    }
-		}
-	      r.cidx(i+1) = jx;
-	    }
-	  
-	  r.maybe_compress ();
-	}
+                        }
+                      ja++;
+                      ja_lt_max= ja < ja_max;
+                      jb++;
+                      jb_lt_max= jb < jb_max;
+                    }
+                }
+              r.cidx(i+1) = jx;
+            }
+          
+          r.maybe_compress ();
+        }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
 
 SPARSE_SMS_CMP_OPS (SparseComplexMatrix, 0.0, real, Complex, 
-		   0.0, real)
+                   0.0, real)
 SPARSE_SMS_BOOL_OPS (SparseComplexMatrix, Complex, 0.0)
 
 SPARSE_SSM_CMP_OPS (Complex, 0.0, real, SparseComplexMatrix, 
-		   0.0, real)
+                   0.0, real)
 SPARSE_SSM_BOOL_OPS (Complex, SparseComplexMatrix, 0.0)
 
 SPARSE_SMSM_CMP_OPS (SparseComplexMatrix, 0.0, real, SparseComplexMatrix, 
-		     0.0, real)
+                     0.0, real)
 SPARSE_SMSM_BOOL_OPS (SparseComplexMatrix, SparseComplexMatrix, 0.0)
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,41 @@
+2010-02-11  John W. Eaton  <jwe@octave.org>
+
+	* Array-C.cc, Array-fC.cc, Array-util.cc, Array.cc,
+	CColVector.cc, CDiagMatrix.cc, CMatrix.cc, CNDArray.cc,
+	CRowVector.cc, CSparse.cc, CmplxAEPBAL.cc, CmplxCHOL.cc,
+	CmplxGEPBAL.cc, CmplxHESS.cc, CmplxLU.cc, CmplxQR.cc,
+	CmplxQRP.cc, CmplxSCHUR.cc, CmplxSVD.cc, CollocWt.cc, DASPK.cc,
+	DASRT.cc, DASSL.cc, EIG.cc, LSODE.cc, MSparse.cc, MatrixType.cc,
+	ODES.cc, Quad.cc, Range.cc, Sparse-C.cc, Sparse.cc,
+	SparseCmplxCHOL.cc, SparseCmplxLU.cc, SparseCmplxQR.cc,
+	SparseQR.cc, SparsedbleCHOL.cc, SparsedbleLU.cc, boolNDArray.cc,
+	boolSparse.cc, chMatrix.cc, chNDArray.cc, cmd-edit.cc,
+	cmd-hist.cc, dColVector.cc, dDiagMatrix.cc, dMatrix.cc,
+	dNDArray.cc, dRowVector.cc, dSparse.cc, data-conv.cc,
+	dbleAEPBAL.cc, dbleCHOL.cc, dbleGEPBAL.cc, dbleHESS.cc,
+	dbleLU.cc, dbleQR.cc, dbleQRP.cc, dbleSCHUR.cc, dbleSVD.cc,
+	dir-ops.cc, eigs-base.cc, fCColVector.cc, fCDiagMatrix.cc,
+	fCMatrix.cc, fCNDArray.cc, fCRowVector.cc, fCmplxAEPBAL.cc,
+	fCmplxCHOL.cc, fCmplxGEPBAL.cc, fCmplxHESS.cc, fCmplxLU.cc,
+	fCmplxQR.cc, fCmplxQRP.cc, fCmplxSCHUR.cc, fCmplxSVD.cc,
+	fColVector.cc, fDiagMatrix.cc, fEIG.cc, fMatrix.cc, fNDArray.cc,
+	fRowVector.cc, file-stat.cc, floatAEPBAL.cc, floatCHOL.cc,
+	floatGEPBAL.cc, floatHESS.cc, floatLU.cc, floatQR.cc,
+	floatQRP.cc, floatSCHUR.cc, floatSVD.cc, idx-vector.cc,
+	intNDArray.cc, kpse.cc, lo-ieee.cc, lo-mappers.cc,
+	lo-specfun.cc, lo-sysdep.cc, lo-utils.cc, mach-info.cc,
+	mx-inlines.cc, oct-alloc.cc, oct-env.cc, oct-fftw.cc,
+	oct-glob.cc, oct-group.cc, oct-inttypes.cc, oct-md5.cc,
+	oct-rand.cc, oct-shlib.cc, oct-sort.cc, oct-spparms.cc,
+	oct-syscalls.cc, oct-time.cc, pathsearch.cc, regex-match.cc,
+	sparse-base-chol.cc, sparse-base-lu.cc, sparse-dmsolve.cc,
+	sparse-sort.cc, sparse-util.cc, str-vec.cc: Untabify.
+
 2010-02-11  John W. Eaton  <jwe@octave.org>
 
 	* Array-util.h, Array.h, Array2.h, Array3.h, CColVector.h,
 	CMatrix.h, CNDArray.h, CRowVector.h, CSparse.h, CmplxCHOL.h,
 	CmplxGEPBAL.h, CmplxHESS.h, CmplxLU.h, CmplxQRP.h, CmplxSCHUR.h,
 	CmplxSVD.h, CollocWt.h, DAE.h, DAEFunc.h, DAERT.h, DAERTFunc.h,
 	DASPK.h, DASRT.h, DASSL.h, DiagArray2.h, EIG.h, MArrayN.h,
 	MDiagArray2.h, MSparse-defs.h, MSparse.h, MatrixType.h, ODE.h,
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/CmplxAEPBAL.cc
--- a/liboctave/CmplxAEPBAL.cc
+++ b/liboctave/CmplxAEPBAL.cc
@@ -31,27 +31,27 @@ along with Octave; see the file COPYING.
 #include "CmplxAEPBAL.h"
 #include "dMatrix.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgebal, ZGEBAL) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     Complex*, const octave_idx_type&,
-			     octave_idx_type&, octave_idx_type&, double*,
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             Complex*, const octave_idx_type&,
+                             octave_idx_type&, octave_idx_type&, double*,
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
  
   F77_RET_T
   F77_FUNC (zgebak, ZGEBAK) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&,
-			     const octave_idx_type&, const double*,
-			     const octave_idx_type&, Complex*,
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL  F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const octave_idx_type&,
+                             const octave_idx_type&, const double*,
+                             const octave_idx_type&, Complex*,
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL  F77_CHAR_ARG_LEN_DECL);
 }
 
 ComplexAEPBALANCE::ComplexAEPBALANCE (const ComplexMatrix& a, 
                                       bool noperm, bool noscal)
   : base_aepbal<ComplexMatrix, ColumnVector> ()
 {
   octave_idx_type n = a.cols ();
 
@@ -67,19 +67,19 @@ ComplexAEPBALANCE::ComplexAEPBALANCE (co
   double *pscale = scale.fortran_vec ();
 
   balanced_mat = a;
   Complex *p_balanced_mat = balanced_mat.fortran_vec ();
 
   job = noperm ? (noscal ? 'N' : 'S') : (noscal ? 'P' : 'B');
 
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     n, p_balanced_mat, n, ilo, ihi,
-			     pscale, info
-			     F77_CHAR_ARG_LEN (1)));
+                             n, p_balanced_mat, n, ilo, ihi,
+                             pscale, info
+                             F77_CHAR_ARG_LEN (1)));
 }
 
 ComplexMatrix
 ComplexAEPBALANCE::balancing_matrix (void) const
 {
   octave_idx_type n = balanced_mat.rows ();
   ComplexMatrix balancing_mat (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
@@ -88,16 +88,16 @@ ComplexAEPBALANCE::balancing_matrix (voi
   Complex *p_balancing_mat = balancing_mat.fortran_vec ();
   const double *pscale = scale.fortran_vec ();
 
   octave_idx_type info;
 
   char side = 'R';
 
   F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 (&side, 1),
-			     n, ilo, ihi, pscale, n,
-			     p_balancing_mat, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&side, 1),
+                             n, ilo, ihi, pscale, n,
+                             p_balancing_mat, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   return balancing_mat;
 }
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -38,28 +38,28 @@ along with Octave; see the file COPYING.
 #ifndef HAVE_QRUPDATE
 #include "dbleQR.h"
 #endif
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zpotrf, ZPOTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     Complex*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             Complex*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (zpotri, ZPOTRI) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     Complex*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             Complex*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zpocon, ZPOCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     Complex*, const octave_idx_type&, const double&,
-			     double&, Complex*, double*, 
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             Complex*, const octave_idx_type&, const double&,
+                             double&, Complex*, double*, 
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
 #ifdef HAVE_QRUPDATE
 
   F77_RET_T
   F77_FUNC (zch1up, ZCH1UP) (const octave_idx_type&, Complex*, const octave_idx_type&,
                              Complex*, double*);
 
   F77_RET_T
   F77_FUNC (zch1dn, ZCH1DN) (const octave_idx_type&, Complex*, const octave_idx_type&,
@@ -85,17 +85,17 @@ octave_idx_type
 ComplexCHOL::init (const ComplexMatrix& a, bool calc_cond)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
-	("ComplexCHOL requires square matrix");
+        ("ComplexCHOL requires square matrix");
       return -1;
     }
 
   octave_idx_type n = a_nc;
   octave_idx_type info;
 
   chol_mat.clear (n, n);
   for (octave_idx_type j = 0; j < n; j++)
@@ -108,36 +108,36 @@ ComplexCHOL::init (const ComplexMatrix& 
   Complex *h = chol_mat.fortran_vec ();
 
   // Calculate the norm of the matrix, for later use.
   double anorm = 0;
   if (calc_cond) 
     anorm = xnorm (a, 1);
 
   F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CHAR_ARG_LEN (1)));
 
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond) 
     {
       octave_idx_type zpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
       Array<Complex> z (2*n);
       Complex *pz = z.fortran_vec ();
       Array<double> rz (n);
       double *prz = rz.fortran_vec ();
       F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
-				 n, anorm, xrcond, pz, prz, zpocon_info
-				 F77_CHAR_ARG_LEN (1)));
+                                 n, anorm, xrcond, pz, prz, zpocon_info
+                                 F77_CHAR_ARG_LEN (1)));
 
       if (zpocon_info != 0) 
-	info = -1;
+        info = -1;
     }
 
   return info;
 }
 
 static ComplexMatrix
 chol2inv_internal (const ComplexMatrix& r)
 {
@@ -149,26 +149,26 @@ chol2inv_internal (const ComplexMatrix& 
   if (r_nr == r_nc)
     {
       octave_idx_type n = r_nc;
       octave_idx_type info;
 
       ComplexMatrix tmp = r;
 
       F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-				 tmp.fortran_vec (), n, info
-				 F77_CHAR_ARG_LEN (1)));
+                                 tmp.fortran_vec (), n, info
+                                 F77_CHAR_ARG_LEN (1)));
 
       // If someone thinks of a more graceful way of doing this (or
       // faster for that matter :-)), please let me know!
 
       if (n > 1)
-	for (octave_idx_type j = 0; j < r_nc; j++)
-	  for (octave_idx_type i = j+1; i < r_nr; i++)
-	    tmp.xelem (i, j) = std::conj (tmp.xelem (j, i));
+        for (octave_idx_type j = 0; j < r_nc; j++)
+          for (octave_idx_type i = j+1; i < r_nr; i++)
+            tmp.xelem (i, j) = std::conj (tmp.xelem (j, i));
 
       retval = tmp;
     }
   else
     (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
   return retval;
 }
diff --git a/liboctave/CmplxGEPBAL.cc b/liboctave/CmplxGEPBAL.cc
--- a/liboctave/CmplxGEPBAL.cc
+++ b/liboctave/CmplxGEPBAL.cc
@@ -32,37 +32,37 @@ along with Octave; see the file COPYING.
 #include "Array-util.h"
 #include "f77-fcn.h"
 #include "oct-locbuf.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zggbal, ZGGBAL) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type& N,
-			     Complex* A, const octave_idx_type& LDA, Complex* B,
-			     const octave_idx_type& LDB, octave_idx_type& ILO, octave_idx_type& IHI,
-			     double* LSCALE, double* RSCALE,
-			     double* WORK, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL);
+                             Complex* A, const octave_idx_type& LDA, Complex* B,
+                             const octave_idx_type& LDB, octave_idx_type& ILO, octave_idx_type& IHI,
+                             double* LSCALE, double* RSCALE,
+                             double* WORK, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dggbak, DGGBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type& N, const octave_idx_type& ILO,
-			     const octave_idx_type& IHI, const double* LSCALE,
-			     const double* RSCALE, octave_idx_type& M, double* V,
-			     const octave_idx_type& LDV, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type& N, const octave_idx_type& ILO,
+                             const octave_idx_type& IHI, const double* LSCALE,
+                             const double* RSCALE, octave_idx_type& M, double* V,
+                             const octave_idx_type& LDV, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
 }
 
 octave_idx_type
 ComplexGEPBALANCE::init (const ComplexMatrix& a, const ComplexMatrix& b, 
-		  const std::string& balance_job)
+                  const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("ComplexGEPBALANCE requires square matrix");
       return -1;
     }
@@ -84,42 +84,42 @@ ComplexGEPBALANCE::init (const ComplexMa
   balanced_mat = a;
   Complex *p_balanced_mat = balanced_mat.fortran_vec ();
   balanced_mat2 = b;
   Complex *p_balanced_mat2 = balanced_mat2.fortran_vec ();
 
   char job = balance_job[0];
 
   F77_XFCN (zggbal, ZGGBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     n, p_balanced_mat, n, p_balanced_mat2,
-			     n, ilo, ihi, plscale, prscale, pwork, info
-			     F77_CHAR_ARG_LEN (1)));
+                             n, p_balanced_mat, n, p_balanced_mat2,
+                             n, ilo, ihi, plscale, prscale, pwork, info
+                             F77_CHAR_ARG_LEN (1)));
 
   balancing_mat = Matrix (n, n, 0.0);
   balancing_mat2 = Matrix (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
     {
       octave_quit ();
       balancing_mat.elem (i ,i) = 1.0;
       balancing_mat2.elem (i ,i) = 1.0;
     }
 
   double *p_balancing_mat = balancing_mat.fortran_vec ();
   double *p_balancing_mat2 = balancing_mat2.fortran_vec ();
 
   // first left
   F77_XFCN (dggbak, DGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 ("L", 1),
-			     n, ilo, ihi, plscale, prscale,
-			     n, p_balancing_mat, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 ("L", 1),
+                             n, ilo, ihi, plscale, prscale,
+                             n, p_balancing_mat, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
       
   // then right
   F77_XFCN (dggbak, DGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 ("R", 1),
-			     n, ilo, ihi, plscale, prscale,
-			     n, p_balancing_mat2, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 ("R", 1),
+                             n, ilo, ihi, plscale, prscale,
+                             n, p_balancing_mat2, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -28,49 +28,49 @@ along with Octave; see the file COPYING.
 #include "CmplxHESS.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgebal, ZGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, Complex*, const octave_idx_type&,
-			     octave_idx_type&, octave_idx_type&, double*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, Complex*, const octave_idx_type&,
+                             octave_idx_type&, octave_idx_type&, double*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
  
   F77_RET_T
   F77_FUNC (zgehrd, ZGEHRD) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     Complex*, const octave_idx_type&, Complex*,
-			     Complex*, const octave_idx_type&, octave_idx_type&);
+                             Complex*, const octave_idx_type&, Complex*,
+                             Complex*, const octave_idx_type&, octave_idx_type&);
  
   F77_RET_T
   F77_FUNC (zunghr, ZUNGHR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     Complex*, const octave_idx_type&, Complex*,
-			     Complex*, const octave_idx_type&, octave_idx_type&);
+                             Complex*, const octave_idx_type&, Complex*,
+                             Complex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgebak, ZGEBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
-			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
+                             const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 octave_idx_type
 ComplexHESS::init (const ComplexMatrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
-	("ComplexHESS requires square matrix");
+        ("ComplexHESS requires square matrix");
       return -1;
     }
 
   char job = 'N';
   char side = 'R';
 
   octave_idx_type n = a_nc;
   octave_idx_type lwork = 32 * n;
@@ -80,42 +80,42 @@ ComplexHESS::init (const ComplexMatrix& 
 
   hess_mat = a;
   Complex *h = hess_mat.fortran_vec ();
 
   Array<double> scale (n);
   double *pscale = scale.fortran_vec ();
 
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     n, h, n, ilo, ihi, pscale, info
-			     F77_CHAR_ARG_LEN (1)));
+                             n, h, n, ilo, ihi, pscale, info
+                             F77_CHAR_ARG_LEN (1)));
 
   Array<Complex> tau (n-1);
   Complex *ptau = tau.fortran_vec ();
 
   Array<Complex> work (lwork);
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zgehrd, ZGEHRD, (n, ilo, ihi, h, n, ptau, pwork, lwork, info));
 
   unitary_hess_mat = hess_mat;
   Complex *z = unitary_hess_mat.fortran_vec ();
 
   F77_XFCN (zunghr, ZUNGHR, (n, ilo, ihi, z, n, ptau, pwork,
-			     lwork, info));
+                             lwork, info));
 
   F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 (&side, 1),
-			     n, ilo, ihi, pscale, n, z, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&side, 1),
+                             n, ilo, ihi, pscale, n, z, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   // If someone thinks of a more graceful way of
   // doing this (or faster for that matter :-)),
   // please let me know!
 
   if (n > 2)
     for (octave_idx_type j = 0; j < a_nc; j++)
       for (octave_idx_type i = j+2; i < a_nr; i++)
-	hess_mat.elem (i, j) = 0;
+        hess_mat.elem (i, j) = 0;
 
   return info;
 }
diff --git a/liboctave/CmplxLU.cc b/liboctave/CmplxLU.cc
--- a/liboctave/CmplxLU.cc
+++ b/liboctave/CmplxLU.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 template class base_lu <ComplexMatrix>;
 
 // Define the constructor for this particular derivation.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgetrf, ZGETRF) (const octave_idx_type&, const octave_idx_type&, Complex*,
-			     const octave_idx_type&, octave_idx_type*, octave_idx_type&);
+                             const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 
 #ifdef HAVE_QRUPDATE_LUU
   F77_RET_T
   F77_FUNC (zlu1up, ZLU1UP) (const octave_idx_type&, const octave_idx_type&,
                              Complex *, const octave_idx_type&,
                              Complex *, const octave_idx_type&,
                              Complex *, Complex *);
 
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -37,23 +37,23 @@ along with Octave; see the file COPYING.
 #include "base-qr.cc"
 
 template class base_qr<ComplexMatrix>;
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgeqrf, ZGEQRF) (const octave_idx_type&, const octave_idx_type&, Complex*,
-			     const octave_idx_type&, Complex*, Complex*,
-			     const octave_idx_type&, octave_idx_type&); 
+                             const octave_idx_type&, Complex*, Complex*,
+                             const octave_idx_type&, octave_idx_type&); 
 
   F77_RET_T
   F77_FUNC (zungqr, ZUNGQR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     Complex*, const octave_idx_type&, Complex*,
-			     Complex*, const octave_idx_type&, octave_idx_type&);
+                             Complex*, const octave_idx_type&, Complex*,
+                             Complex*, const octave_idx_type&, octave_idx_type&);
 
 #ifdef HAVE_QRUPDATE
 
   F77_RET_T
   F77_FUNC (zqr1up, ZQR1UP) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
                              Complex*, const octave_idx_type&, Complex*, const octave_idx_type&,
                              Complex*, Complex*, Complex*, double*);
 
@@ -126,21 +126,21 @@ void ComplexQR::form (octave_idx_type n,
                       Complex *tau, qr_type_t qr_type)
 {
   octave_idx_type m = afact.rows (), min_mn = std::min (m, n);
   octave_idx_type info;
 
   if (qr_type == qr_type_raw)
     {
       for (octave_idx_type j = 0; j < min_mn; j++)
-	{
-	  octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
-	  for (octave_idx_type i = limit + 1; i < m; i++)
-	    afact.elem (i, j) *= tau[j];
-	}
+        {
+          octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
+          for (octave_idx_type i = limit + 1; i < m; i++)
+            afact.elem (i, j) *= tau[j];
+        }
 
       r = afact;
     }
   else
     {
       // Attempt to minimize copying.
       if (m >= n)
         {
@@ -177,17 +177,17 @@ void ComplexQR::form (octave_idx_type n,
           octave_idx_type k = q.columns ();
           // workspace query.
           Complex clwork;
           F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      &clwork, -1, info));
 
           // allocate buffer and do the job.
           octave_idx_type lwork = clwork.real ();
-	  lwork = std::max (lwork, static_cast<octave_idx_type> (1));
+          lwork = std::max (lwork, static_cast<octave_idx_type> (1));
           OCTAVE_LOCAL_BUFFER (Complex, work, lwork);
           F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      work, lwork, info));
         }
     }
 }
 
 #ifdef HAVE_QRUPDATE
@@ -295,17 +295,17 @@ ComplexQR::insert_col (const ComplexMatr
       else
         {
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (double, rw, kmax);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
-	  octave_idx_type ii = i;
+          octave_idx_type ii = i;
           ComplexColumnVector utmp = u.column (jsi(i));
           F77_XFCN (zqrinc, ZQRINC, (m, n + ii, std::min (kmax, k + ii), 
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1, 
                                      utmp.data (), rw));
         }
     }
 }
@@ -318,17 +318,17 @@ ComplexQR::delete_col (octave_idx_type j
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1) 
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrdec, ZQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
-				 r.fortran_vec (), r.rows (), j + 1, rw));
+                                 r.fortran_vec (), r.rows (), j + 1, rw));
 
       if (k < m)
         {
           q.resize (m, k-1);
           r.resize (k-1, n-1);
         }
       else
         {
@@ -355,17 +355,17 @@ ComplexQR::delete_col (const Array<octav
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
-	  octave_idx_type ii = i;
+          octave_idx_type ii = i;
           F77_XFCN (zqrdec, ZQRDEC, (m, n - ii, k == m ? k : k - ii, 
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1, rw));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
@@ -391,17 +391,17 @@ ComplexQR::insert_row (const ComplexRowV
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       ComplexRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrinr, ZQRINR, (m, n, q.fortran_vec (), q.rows (),
-				 r.fortran_vec (), r.rows (), 
+                                 r.fortran_vec (), r.rows (), 
                                  j + 1, utmp.fortran_vec (), rw));
 
     }
 }
 
 void
 ComplexQR::delete_row (octave_idx_type j)
 {
@@ -412,17 +412,17 @@ ComplexQR::delete_row (octave_idx_type j
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
   else if (j < 0 || j > m-1) 
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       OCTAVE_LOCAL_BUFFER (double, rw, m);
       F77_XFCN (zqrder, ZQRDER, (m, n, q.fortran_vec (), q.rows (),
-				 r.fortran_vec (), r.rows (), j + 1,
+                                 r.fortran_vec (), r.rows (), j + 1,
                                  w, rw));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 }
 
 void
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -31,18 +31,18 @@ along with Octave; see the file COPYING.
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgeqp3, ZGEQP3) (const octave_idx_type&, const octave_idx_type&, Complex*,
-			     const octave_idx_type&, octave_idx_type*, Complex*, Complex*,
-			     const octave_idx_type&, double*, octave_idx_type&);
+                             const octave_idx_type&, octave_idx_type*, Complex*, Complex*,
+                             const octave_idx_type&, double*, octave_idx_type&);
 }
 
 // It would be best to share some of this code with ComplexQR class...
 
 ComplexQRP::ComplexQRP (const ComplexMatrix& a, qr_type_t qr_type)
   : ComplexQR (), p ()
 {
   init (a, qr_type);
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -28,51 +28,51 @@ along with Octave; see the file COPYING.
 #include "CmplxSCHUR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgeesx, ZGEESX) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     ComplexSCHUR::select_function,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&,
-			     Complex*, Complex*, const octave_idx_type&, double&,
-			     double&, Complex*, const octave_idx_type&, double*, octave_idx_type*,
-			     octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             ComplexSCHUR::select_function,
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&,
+                             Complex*, Complex*, const octave_idx_type&, double&,
+                             double&, Complex*, const octave_idx_type&, double*, octave_idx_type*,
+                             octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 static octave_idx_type
 select_ana (const Complex& a)
 {
   return a.real () < 0.0;
 }
 
 static octave_idx_type
 select_dig (const Complex& a)
 {
   return (abs (a) < 1.0);
 }
 
 octave_idx_type
 ComplexSCHUR::init (const ComplexMatrix& a, const std::string& ord, 
-		    bool calc_unitary)
+                    bool calc_unitary)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
-	("ComplexSCHUR requires square matrix");
+        ("ComplexSCHUR requires square matrix");
       return -1;
     }
 
   // Workspace requirements may need to be fixed if any of the
   // following change.
 
   char jobvs;
   char sense = 'N';
@@ -118,19 +118,19 @@ ComplexSCHUR::init (const ComplexMatrix&
   Array<Complex> work (lwork);
   Complex *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for non-ordered Schur.
   Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
   F77_XFCN (zgeesx, ZGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
-			     F77_CONST_CHAR_ARG2 (&sort, 1),
-			     selector,
-			     F77_CONST_CHAR_ARG2 (&sense, 1),
-			     n, s, n, sdim, pw, q, n, rconde, rcondv,
-			     pwork, lwork, prwork, pbwork, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&sort, 1),
+                             selector,
+                             F77_CONST_CHAR_ARG2 (&sense, 1),
+                             n, s, n, sdim, pw, q, n, rconde, rcondv,
+                             pwork, lwork, prwork, pbwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
diff --git a/liboctave/CmplxSVD.cc b/liboctave/CmplxSVD.cc
--- a/liboctave/CmplxSVD.cc
+++ b/liboctave/CmplxSVD.cc
@@ -28,45 +28,45 @@ along with Octave; see the file COPYING.
 #include "CmplxSVD.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgesvd, ZGESVD) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, Complex*,
-			     const octave_idx_type&, double*, Complex*, const octave_idx_type&,
-			     Complex*, const octave_idx_type&, Complex*, const octave_idx_type&,
-			     double*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, Complex*,
+                             const octave_idx_type&, double*, Complex*, const octave_idx_type&,
+                             Complex*, const octave_idx_type&, Complex*, const octave_idx_type&,
+                             double*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 ComplexMatrix
 ComplexSVD::left_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
     {
       (*current_liboctave_error_handler)
-	("ComplexSVD: U not computed because type == SVD::sigma_only");
+        ("ComplexSVD: U not computed because type == SVD::sigma_only");
       return ComplexMatrix ();
     }
   else
     return left_sm;
 }
 
 ComplexMatrix
 ComplexSVD::right_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
     {
       (*current_liboctave_error_handler)
-	("ComplexSVD: V not computed because type == SVD::sigma_only");
+        ("ComplexSVD: V not computed because type == SVD::sigma_only");
       return ComplexMatrix ();
     }
   else
     return right_sm;
 }
 
 octave_idx_type
 ComplexSVD::init (const ComplexMatrix& a, SVD::type svd_type)
@@ -140,31 +140,31 @@ ComplexSVD::init (const ComplexMatrix& a
   octave_idx_type lwork = -1;
 
   Array<Complex> work (1);
 
   octave_idx_type one = 1;
   octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
 
   F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
-			     F77_CONST_CHAR_ARG2 (&jobv, 1),
-			     m, n, tmp_data, m1, s_vec, u, m1, vt,
-			     nrow_vt1, work.fortran_vec (), lwork,
-			     rwork.fortran_vec (), info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&jobv, 1),
+                             m, n, tmp_data, m1, s_vec, u, m1, vt,
+                             nrow_vt1, work.fortran_vec (), lwork,
+                             rwork.fortran_vec (), info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   lwork = static_cast<octave_idx_type> (work(0).real ());
   work.resize (lwork);
 
   F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
-			     F77_CONST_CHAR_ARG2 (&jobv, 1),
-			     m, n, tmp_data, m1, s_vec, u, m1, vt,
-			     nrow_vt1, work.fortran_vec (), lwork,
-			     rwork.fortran_vec (), info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&jobv, 1),
+                             m, n, tmp_data, m1, s_vec, u, m1, vt,
+                             nrow_vt1, work.fortran_vec (), lwork,
+                             rwork.fortran_vec (), info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm = right_sm.hermitian ();
 
   return info;
 }
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -30,23 +30,23 @@ along with Octave; see the file COPYING.
 #include "CollocWt.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (jcobi, JCOBI) (octave_idx_type&, octave_idx_type&, octave_idx_type&, octave_idx_type&, double&,
-			   double&, double*, double*, double*,
-			   double*);
+                           double&, double*, double*, double*,
+                           double*);
 
   F77_RET_T
   F77_FUNC (dfopr, DFOPR) (octave_idx_type&, octave_idx_type&, octave_idx_type&, octave_idx_type&, octave_idx_type&, octave_idx_type&,
-			   double*, double*, double*, double*,
-			   double*);
+                           double*, double*, double*, double*,
+                           double*);
 }
 
 // Error handling.
 
 void
 CollocWt::error (const char* msg)
 {
   (*current_liboctave_error_handler) ("fatal CollocWt error: %s", msg);
@@ -119,50 +119,50 @@ CollocWt::init (void)
   A.resize (nt, nt);
   B.resize (nt, nt);
 
   double *pr = r.fortran_vec ();
 
   // Compute roots.
 
   F77_FUNC (jcobi, JCOBI) (nt, n, inc_left, inc_right, Alpha, Beta,
-			  pdif1, pdif2, pdif3, pr);
+                          pdif1, pdif2, pdif3, pr);
 
   octave_idx_type id;
 
   // First derivative weights.
 
   id = 1;
   for (octave_idx_type i = 1; i <= nt; i++)
     {
       F77_FUNC (dfopr, DFOPR) (nt, n, inc_left, inc_right, i, id, pdif1,
-			      pdif2, pdif3, pr, pvect); 
+                              pdif2, pdif3, pr, pvect); 
 
       for (octave_idx_type j = 0; j < nt; j++)
-	A (i-1, j) = vect.elem (j);
+        A (i-1, j) = vect.elem (j);
     }
 
   // Second derivative weights.
 
   id = 2;
   for (octave_idx_type i = 1; i <= nt; i++)
     {
       F77_FUNC (dfopr, DFOPR) (nt, n, inc_left, inc_right, i, id, pdif1,
-			      pdif2, pdif3, pr, pvect); 
+                              pdif2, pdif3, pr, pvect); 
 
       for (octave_idx_type j = 0; j < nt; j++)
-	B (i-1, j) = vect.elem (j);
+        B (i-1, j) = vect.elem (j);
     }
 
   // Gaussian quadrature weights.
 
   id = 3;
   double *pq = q.fortran_vec ();
   F77_FUNC (dfopr, DFOPR) (nt, n, inc_left, inc_right, id, id, pdif1,
-			  pdif2, pdif3, pr, pq);
+                          pdif2, pdif3, pr, pq);
 
   initialized = 1;
 }
 
 std::ostream&
 operator << (std::ostream& os, const CollocWt& a)
 {
   if (a.left_included ())
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -31,48 +31,48 @@ along with Octave; see the file COPYING.
 
 #include "DASPK.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-math.h"
 #include "quit.h"
 
 typedef octave_idx_type (*daspk_fcn_ptr) (const double&, const double*,
-			      const double*, const double&,
-			      double*, octave_idx_type&, double*, octave_idx_type*);
+                              const double*, const double&,
+                              double*, octave_idx_type&, double*, octave_idx_type*);
 
 typedef octave_idx_type (*daspk_jac_ptr) (const double&, const double*,
-			      const double*, double*,
-			      const double&, double*, octave_idx_type*);
+                              const double*, double*,
+                              const double&, double*, octave_idx_type*);
 
 typedef octave_idx_type (*daspk_psol_ptr) (const octave_idx_type&, const double&,
-			       const double*, const double*,
-			       const double*, const double&,
-			       const double*, double*, octave_idx_type*,
-			       double*, const double&, octave_idx_type&,
-			       double*, octave_idx_type*);
+                               const double*, const double*,
+                               const double*, const double&,
+                               const double*, double*, octave_idx_type*,
+                               double*, const double&, octave_idx_type&,
+                               double*, octave_idx_type*);
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (ddaspk, DDASPK) (daspk_fcn_ptr, const octave_idx_type&, double&,
-			     double*, double*, double&, const octave_idx_type*,
-			     const double*, const double*, octave_idx_type&,
-			     double*, const octave_idx_type&, octave_idx_type*, const octave_idx_type&,
-			     const double*, const octave_idx_type*,
-			     daspk_jac_ptr, daspk_psol_ptr);
+                             double*, double*, double&, const octave_idx_type*,
+                             const double*, const double*, octave_idx_type&,
+                             double*, const octave_idx_type&, octave_idx_type*, const octave_idx_type&,
+                             const double*, const octave_idx_type*,
+                             daspk_jac_ptr, daspk_psol_ptr);
 }
 
 static DAEFunc::DAERHSFunc user_fun;
 static DAEFunc::DAEJacFunc user_jac;
 static octave_idx_type nn;
 
 static octave_idx_type
 ddaspk_f (const double& time, const double *state, const double *deriv,
-	  const double&, double *delta, octave_idx_type& ires, double *, octave_idx_type *)
+          const double&, double *delta, octave_idx_type& ires, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   ColumnVector tmp_deriv (nn);
   ColumnVector tmp_state (nn);
   ColumnVector tmp_delta (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
@@ -81,51 +81,51 @@ ddaspk_f (const double& time, const doub
       tmp_state.elem (i) = state [i];
     }
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, ires);
 
   if (ires >= 0)
     {
       if (tmp_delta.length () == 0)
-	ires = -2;
+        ires = -2;
       else
-	{
-	  for (octave_idx_type i = 0; i < nn; i++)
-	    delta [i] = tmp_delta.elem (i);
-	}
+        {
+          for (octave_idx_type i = 0; i < nn; i++)
+            delta [i] = tmp_delta.elem (i);
+        }
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 //NEQ, T, Y, YPRIME, SAVR, WK, CJ, WGHT,
 //C                          WP, IWP, B, EPLIN, IER, RPAR, IPAR)
 
 static octave_idx_type
 ddaspk_psol (const octave_idx_type&, const double&, const double *,
-	     const double *, const double *, const double&,
-	     const double *, double *, octave_idx_type *, double *,
-	     const double&, octave_idx_type&, double *, octave_idx_type*)
+             const double *, const double *, const double&,
+             const double *, double *, octave_idx_type *, double *,
+             const double&, octave_idx_type&, double *, octave_idx_type*)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   abort ();
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 
 static octave_idx_type
 ddaspk_j (const double& time, const double *state, const double *deriv,
-	  double *pd, const double& cj, double *, octave_idx_type *)
+          double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
@@ -158,367 +158,367 @@ DASPK::do_integrate (double tout)
     {
       integration_error = false;
 
       initialized = true;
 
       info.resize (20);
 
       for (octave_idx_type i = 0; i < 20; i++)
-	info(i) = 0;
+        info(i) = 0;
 
       pinfo = info.fortran_vec ();
 
       octave_idx_type n = size ();
 
       nn = n;
 
       info(0) = 0;
 
       if (stop_time_set)
-	{
-	  rwork(0) = stop_time;
-	  info(3) = 1;
-	}
+        {
+          rwork(0) = stop_time;
+          info(3) = 1;
+        }
       else
-	info(3) = 0;
+        info(3) = 0;
 
       px = x.fortran_vec ();
       pxdot = xdot.fortran_vec ();
 
       // DAEFunc
 
       user_fun = DAEFunc::function ();
       user_jac = DAEFunc::jacobian_function ();
 
       if (user_fun)
-	{
-	  octave_idx_type ires = 0;
+        {
+          octave_idx_type ires = 0;
 
-	  ColumnVector res = (*user_fun) (x, xdot, t, ires);
+          ColumnVector res = (*user_fun) (x, xdot, t, ires);
 
-	  if (res.length () != x.length ())
-	    {
-	      (*current_liboctave_error_handler)
-		("daspk: inconsistent sizes for state and residual vectors");
+          if (res.length () != x.length ())
+            {
+              (*current_liboctave_error_handler)
+                ("daspk: inconsistent sizes for state and residual vectors");
 
-	      integration_error = true;
-	      return retval;
-	    }
-	}
+              integration_error = true;
+              return retval;
+            }
+        }
       else
-	{
-	  (*current_liboctave_error_handler)
-	    ("daspk: no user supplied RHS subroutine!");
+        {
+          (*current_liboctave_error_handler)
+            ("daspk: no user supplied RHS subroutine!");
 
-	  integration_error = true;
-	  return retval;
-	}
+          integration_error = true;
+          return retval;
+        }
   
       info(4) = user_jac ? 1 : 0;
 
       DAEFunc::reset = false;
 
       octave_idx_type eiq = enforce_inequality_constraints ();
       octave_idx_type ccic = compute_consistent_initial_condition ();
       octave_idx_type eavfet = exclude_algebraic_variables_from_error_test ();
 
       liw = 40 + n;
       if (eiq == 1 || eiq == 3)
-	liw += n;
+        liw += n;
       if (ccic == 1 || eavfet == 1)
-	liw += n;
+        liw += n;
 
       lrw = 50 + 9*n + n*n;
       if (eavfet == 1)
-	lrw += n;
+        lrw += n;
 
       iwork.resize (liw);
       rwork.resize (lrw);
 
       piwork = iwork.fortran_vec ();
       prwork = rwork.fortran_vec ();
 
       // DASPK_options
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
       octave_idx_type abs_tol_len = abs_tol.length ();
       octave_idx_type rel_tol_len = rel_tol.length ();
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
-	{
-	  info(1) = 0;
-	}
+        {
+          info(1) = 0;
+        }
       else if (abs_tol_len == n && rel_tol_len == n)
-	{
-	  info(1) = 1;
-	}
+        {
+          info(1) = 1;
+        }
       else
-	{
-	  (*current_liboctave_error_handler)
-	    ("daspk: inconsistent sizes for tolerance arrays");
+        {
+          (*current_liboctave_error_handler)
+            ("daspk: inconsistent sizes for tolerance arrays");
 
-	  integration_error = true;
-	  return retval;
-	}
+          integration_error = true;
+          return retval;
+        }
 
       pabs_tol = abs_tol.fortran_vec ();
       prel_tol = rel_tol.fortran_vec ();
 
       double hmax = maximum_step_size ();
       if (hmax >= 0.0)
-	{
-	  rwork(1) = hmax;
-	  info(6) = 1;
-	}
+        {
+          rwork(1) = hmax;
+          info(6) = 1;
+        }
       else
-	info(6) = 0;
+        info(6) = 0;
 
       double h0 = initial_step_size ();
       if (h0 >= 0.0)
-	{
-	  rwork(2) = h0;
-	  info(7) = 1;
-	}
+        {
+          rwork(2) = h0;
+          info(7) = 1;
+        }
       else
-	info(7) = 0;
+        info(7) = 0;
 
       octave_idx_type maxord = maximum_order ();
       if (maxord >= 0)
-	{
-	  if (maxord > 0 && maxord < 6)
-	    {
-	      info(8) = 1;
-	      iwork(2) = maxord;
-	    }
-	  else
-	    {
-	      (*current_liboctave_error_handler)
-		("daspk: invalid value for maximum order");
-	      integration_error = true;
-	      return retval;
-	    }
-	}
+        {
+          if (maxord > 0 && maxord < 6)
+            {
+              info(8) = 1;
+              iwork(2) = maxord;
+            }
+          else
+            {
+              (*current_liboctave_error_handler)
+                ("daspk: invalid value for maximum order");
+              integration_error = true;
+              return retval;
+            }
+        }
 
       switch (eiq)
-	{
-	case 1:
-	case 3:
-	  {
-	    Array<octave_idx_type> ict = inequality_constraint_types ();
+        {
+        case 1:
+        case 3:
+          {
+            Array<octave_idx_type> ict = inequality_constraint_types ();
 
-	    if (ict.length () == n)
-	      {
-		for (octave_idx_type i = 0; i < n; i++)
-		  {
-		    octave_idx_type val = ict(i);
-		    if (val < -2 || val > 2)
-		      {
-			(*current_liboctave_error_handler)
-			  ("daspk: invalid value for inequality constraint type");
-			integration_error = true;
-			return retval;
-		      }
-		    iwork(40+i) = val;
-		  }
-	      }
-	    else
-	      {
-		(*current_liboctave_error_handler)
-		  ("daspk: inequality constraint types size mismatch");
-		integration_error = true;
-		return retval;
-	      }
-	  }
-	  // Fall through...
+            if (ict.length () == n)
+              {
+                for (octave_idx_type i = 0; i < n; i++)
+                  {
+                    octave_idx_type val = ict(i);
+                    if (val < -2 || val > 2)
+                      {
+                        (*current_liboctave_error_handler)
+                          ("daspk: invalid value for inequality constraint type");
+                        integration_error = true;
+                        return retval;
+                      }
+                    iwork(40+i) = val;
+                  }
+              }
+            else
+              {
+                (*current_liboctave_error_handler)
+                  ("daspk: inequality constraint types size mismatch");
+                integration_error = true;
+                return retval;
+              }
+          }
+          // Fall through...
 
-	case 0:
-	case 2:
-	  info(9) = eiq;
-	  break;
+        case 0:
+        case 2:
+          info(9) = eiq;
+          break;
 
-	default:
-	  (*current_liboctave_error_handler)
-	    ("daspk: invalid value for enforce inequality constraints option");
-	  integration_error = true;
-	  return retval;
-	}
+        default:
+          (*current_liboctave_error_handler)
+            ("daspk: invalid value for enforce inequality constraints option");
+          integration_error = true;
+          return retval;
+        }
 
       if (ccic)
-	{
-	  if (ccic == 1)
-	    {
-	      // FIXME -- this code is duplicated below.
+        {
+          if (ccic == 1)
+            {
+              // FIXME -- this code is duplicated below.
 
-	      Array<octave_idx_type> av = algebraic_variables ();
+              Array<octave_idx_type> av = algebraic_variables ();
 
-	      if (av.length () == n)
-		{
-		  octave_idx_type lid;
-		  if (eiq == 0 || eiq == 2)
-		    lid = 40;
-		  else if (eiq == 1 || eiq == 3)
-		    lid = 40 + n;
-		  else
-		    abort ();
+              if (av.length () == n)
+                {
+                  octave_idx_type lid;
+                  if (eiq == 0 || eiq == 2)
+                    lid = 40;
+                  else if (eiq == 1 || eiq == 3)
+                    lid = 40 + n;
+                  else
+                    abort ();
 
-		  for (octave_idx_type i = 0; i < n; i++)
-		    iwork(lid+i) = av(i) ? -1 : 1;
-		}
-	      else
-		{
-		  (*current_liboctave_error_handler)
-		    ("daspk: algebraic variables size mismatch");
-		  integration_error = true;
-		  return retval;
-		}
-	    }
-	  else if (ccic != 2)
-	    {
-	      (*current_liboctave_error_handler)
-		("daspk: invalid value for compute consistent initial condition option");
-	      integration_error = true;
-	      return retval;
-	    }
+                  for (octave_idx_type i = 0; i < n; i++)
+                    iwork(lid+i) = av(i) ? -1 : 1;
+                }
+              else
+                {
+                  (*current_liboctave_error_handler)
+                    ("daspk: algebraic variables size mismatch");
+                  integration_error = true;
+                  return retval;
+                }
+            }
+          else if (ccic != 2)
+            {
+              (*current_liboctave_error_handler)
+                ("daspk: invalid value for compute consistent initial condition option");
+              integration_error = true;
+              return retval;
+            }
 
-	  info(10) = ccic;
-	}
+          info(10) = ccic;
+        }
 
       if (eavfet)
-	{
-	  info(15) = 1;
+        {
+          info(15) = 1;
 
-	  // FIXME -- this code is duplicated above.
+          // FIXME -- this code is duplicated above.
 
-	  Array<octave_idx_type> av = algebraic_variables ();
+          Array<octave_idx_type> av = algebraic_variables ();
 
-	  if (av.length () == n)
-	    {
-	      octave_idx_type lid;
-	      if (eiq == 0 || eiq == 2)
-		lid = 40;
-	      else if (eiq == 1 || eiq == 3)
-		lid = 40 + n;
-	      else
-		abort ();
+          if (av.length () == n)
+            {
+              octave_idx_type lid;
+              if (eiq == 0 || eiq == 2)
+                lid = 40;
+              else if (eiq == 1 || eiq == 3)
+                lid = 40 + n;
+              else
+                abort ();
 
-	      for (octave_idx_type i = 0; i < n; i++)
-		iwork(lid+i) = av(i) ? -1 : 1;
-	    }
-	}
+              for (octave_idx_type i = 0; i < n; i++)
+                iwork(lid+i) = av(i) ? -1 : 1;
+            }
+        }
 
       if (use_initial_condition_heuristics ())
-	{
-	  Array<double> ich = initial_condition_heuristics ();
+        {
+          Array<double> ich = initial_condition_heuristics ();
 
-	  if (ich.length () == 6)
-	    {
-	      iwork(31) = NINTbig (ich(0));
-	      iwork(32) = NINTbig (ich(1));
-	      iwork(33) = NINTbig (ich(2));
-	      iwork(34) = NINTbig (ich(3));
+          if (ich.length () == 6)
+            {
+              iwork(31) = NINTbig (ich(0));
+              iwork(32) = NINTbig (ich(1));
+              iwork(33) = NINTbig (ich(2));
+              iwork(34) = NINTbig (ich(3));
 
-	      rwork(13) = ich(4);
-	      rwork(14) = ich(5);
-	    }
-	  else
-	    {
-	      (*current_liboctave_error_handler)
-		("daspk: invalid initial condition heuristics option");
-	      integration_error = true;
-	      return retval;
-	    }
+              rwork(13) = ich(4);
+              rwork(14) = ich(5);
+            }
+          else
+            {
+              (*current_liboctave_error_handler)
+                ("daspk: invalid initial condition heuristics option");
+              integration_error = true;
+              return retval;
+            }
 
-	  info(16) = 1;
-	}
+          info(16) = 1;
+        }
 
       octave_idx_type pici = print_initial_condition_info ();
       switch (pici)
-	{
-	case 0:
-	case 1:
-	case 2:
-	  info(17) = pici;
-	  break;
+        {
+        case 0:
+        case 1:
+        case 2:
+          info(17) = pici;
+          break;
 
-	default:
-	  (*current_liboctave_error_handler)
-	    ("daspk: invalid value for print initial condition info option");
-	  integration_error = true;
-	  return retval;
-	  break;
-	}
+        default:
+          (*current_liboctave_error_handler)
+            ("daspk: invalid value for print initial condition info option");
+          integration_error = true;
+          return retval;
+          break;
+        }
 
       DASPK_options::reset = false;
 
       restart = false;
     }
 
   static double *dummy = 0;
   static octave_idx_type *idummy = 0;
 
   F77_XFCN (ddaspk, DDASPK, (ddaspk_f, nn, t, px, pxdot, tout, pinfo,
-			     prel_tol, pabs_tol, istate, prwork, lrw,
-			     piwork, liw, dummy, idummy, ddaspk_j,
-			     ddaspk_psol));
+                             prel_tol, pabs_tol, istate, prwork, lrw,
+                             piwork, liw, dummy, idummy, ddaspk_j,
+                             ddaspk_psol));
 
   switch (istate)
     {
     case 1: // A step was successfully taken in intermediate-output
-	    // mode. The code has not yet reached TOUT.
+            // mode. The code has not yet reached TOUT.
     case 2: // The integration to TSTOP was successfully completed
-	    // (T=TSTOP) by stepping exactly to TSTOP.
+            // (T=TSTOP) by stepping exactly to TSTOP.
     case 3: // The integration to TOUT was successfully completed
-	    // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
-	    // interpolation.  YPRIME(*) is obtained by interpolation.
+            // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
+            // interpolation.  YPRIME(*) is obtained by interpolation.
     case 4: // The initial condition calculation, with
-	    // INFO(11) > 0, was successful, and INFO(14) = 1.
-	    // No integration steps were taken, and the solution
-	    // is not considered to have been started.
+            // INFO(11) > 0, was successful, and INFO(14) = 1.
+            // No integration steps were taken, and the solution
+            // is not considered to have been started.
       retval = x;
       t = tout;
       break;
 
     case -1: // A large amount of work has been expended.  (~500 steps).
     case -2: // The error tolerances are too stringent.
     case -3: // The local error test cannot be satisfied because you
-	     // specified a zero component in ATOL and the
-	     // corresponding computed solution component is zero.
-	     // Thus, a pure relative error test is impossible for
-	     // this component.
+             // specified a zero component in ATOL and the
+             // corresponding computed solution component is zero.
+             // Thus, a pure relative error test is impossible for
+             // this component.
     case -6: // DDASPK had repeated error test failures on the last
-	     // attempted step.
+             // attempted step.
     case -7: // The corrector could not converge.
     case -8: // The matrix of partial derivatives is singular.
     case -9: // The corrector could not converge.  There were repeated
-	     // error test failures in this step.
+             // error test failures in this step.
     case -10: // The corrector could not converge because IRES was
-	      // equal to minus one.
+              // equal to minus one.
     case -11: // IRES equal to -2 was encountered and control is being
-	      // returned to the calling program.
+              // returned to the calling program.
     case -12: // DDASPK failed to compute the initial YPRIME.
     case -13: // Unrecoverable error encountered inside user's
-	      // PSOL routine, and control is being returned to
-	      // the calling program.
+              // PSOL routine, and control is being returned to
+              // the calling program.
     case -14: // The Krylov linear system solver could not
-	      // achieve convergence.
+              // achieve convergence.
     case -33: // The code has encountered trouble from which it cannot
-	      // recover. A message is printed explaining the trouble
-	      // and control is returned to the calling program. For
-	      // example, this occurs when invalid input is detected.
+              // recover. A message is printed explaining the trouble
+              // and control is returned to the calling program. For
+              // example, this occurs when invalid input is detected.
       integration_error = true;
       break;
 
     default:
       integration_error = true;
       (*current_liboctave_error_handler)
-	("unrecognized value of istate (= %d) returned from ddaspk",
-	 istate);
+        ("unrecognized value of istate (= %d) returned from ddaspk",
+         istate);
       break;
     }
 
   return retval;
 }
 
 Matrix
 DASPK::do_integrate (const ColumnVector& tout)
@@ -536,145 +536,145 @@ DASPK::integrate (const ColumnVector& to
   octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  retval.elem (0, i) = x.elem (i);
-	  xdot_out.elem (0, i) = xdot.elem (i);
-	}
+        {
+          retval.elem (0, i) = x.elem (i);
+          xdot_out.elem (0, i) = xdot.elem (i);
+        }
 
       for (octave_idx_type j = 1; j < n_out; j++)
-	{
-	  ColumnVector x_next = do_integrate (tout.elem (j));
+        {
+          ColumnVector x_next = do_integrate (tout.elem (j));
 
-	  if (integration_error)
-	    return retval;
+          if (integration_error)
+            return retval;
 
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      retval.elem (j, i) = x_next.elem (i);
-	      xdot_out.elem (j, i) = xdot.elem (i);
-	    }
-	}
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              retval.elem (j, i) = x_next.elem (i);
+              xdot_out.elem (j, i) = xdot.elem (i);
+            }
+        }
     }
 
   return retval;
 }
 
 Matrix
 DASPK::do_integrate (const ColumnVector& tout, const ColumnVector& tcrit)
 {
   Matrix dummy;
   return integrate (tout, dummy, tcrit);
 }
 
 Matrix
 DASPK::integrate (const ColumnVector& tout, Matrix& xdot_out,
-		  const ColumnVector& tcrit) 
+                  const ColumnVector& tcrit) 
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.capacity ();
   octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  retval.elem (0, i) = x.elem (i);
-	  xdot_out.elem (0, i) = xdot.elem (i);
-	}
+        {
+          retval.elem (0, i) = x.elem (i);
+          xdot_out.elem (0, i) = xdot.elem (i);
+        }
 
       octave_idx_type n_crit = tcrit.capacity ();
 
       if (n_crit > 0)
-	{
-	  octave_idx_type i_crit = 0;
-	  octave_idx_type i_out = 1;
-	  double next_crit = tcrit.elem (0);
-	  double next_out;
-	  while (i_out < n_out)
-	    {
-	      bool do_restart = false;
+        {
+          octave_idx_type i_crit = 0;
+          octave_idx_type i_out = 1;
+          double next_crit = tcrit.elem (0);
+          double next_out;
+          while (i_out < n_out)
+            {
+              bool do_restart = false;
 
-	      next_out = tout.elem (i_out);
-	      if (i_crit < n_crit)
-		next_crit = tcrit.elem (i_crit);
+              next_out = tout.elem (i_out);
+              if (i_crit < n_crit)
+                next_crit = tcrit.elem (i_crit);
 
-	      bool save_output;
-	      double t_out;
+              bool save_output;
+              double t_out;
 
-	      if (next_crit == next_out)
-		{
-		  set_stop_time (next_crit);
-		  t_out = next_out;
-		  save_output = true;
-		  i_out++;
-		  i_crit++;
-		  do_restart = true;
-		}
-	      else if (next_crit < next_out)
-		{
-		  if (i_crit < n_crit)
-		    {
-		      set_stop_time (next_crit);
-		      t_out = next_crit;
-		      save_output = false;
-		      i_crit++;
-		      do_restart = true;
-		    }
-		  else
-		    {
-		      clear_stop_time ();
-		      t_out = next_out;
-		      save_output = true;
-		      i_out++;
-		    }
-		}
-	      else
-		{
-		  set_stop_time (next_crit);
-		  t_out = next_out;
-		  save_output = true;
-		  i_out++;
-		}
+              if (next_crit == next_out)
+                {
+                  set_stop_time (next_crit);
+                  t_out = next_out;
+                  save_output = true;
+                  i_out++;
+                  i_crit++;
+                  do_restart = true;
+                }
+              else if (next_crit < next_out)
+                {
+                  if (i_crit < n_crit)
+                    {
+                      set_stop_time (next_crit);
+                      t_out = next_crit;
+                      save_output = false;
+                      i_crit++;
+                      do_restart = true;
+                    }
+                  else
+                    {
+                      clear_stop_time ();
+                      t_out = next_out;
+                      save_output = true;
+                      i_out++;
+                    }
+                }
+              else
+                {
+                  set_stop_time (next_crit);
+                  t_out = next_out;
+                  save_output = true;
+                  i_out++;
+                }
 
-	      ColumnVector x_next = do_integrate (t_out);
+              ColumnVector x_next = do_integrate (t_out);
 
-	      if (integration_error)
-		return retval;
+              if (integration_error)
+                return retval;
 
-	      if (save_output)
-		{
-		  for (octave_idx_type i = 0; i < n; i++)
-		    {
-		      retval.elem (i_out-1, i) = x_next.elem (i);
-		      xdot_out.elem (i_out-1, i) = xdot.elem (i);
-		    }
-		}
+              if (save_output)
+                {
+                  for (octave_idx_type i = 0; i < n; i++)
+                    {
+                      retval.elem (i_out-1, i) = x_next.elem (i);
+                      xdot_out.elem (i_out-1, i) = xdot.elem (i);
+                    }
+                }
 
-	      if (do_restart)
-		force_restart ();
-	    }
-	}
+              if (do_restart)
+                force_restart ();
+            }
+        }
       else
-	{
-	  retval = integrate (tout, xdot_out);
+        {
+          retval = integrate (tout, xdot_out);
 
-	  if (integration_error)
-	    return retval;
-	}
+          if (integration_error)
+            return retval;
+        }
     }
 
   return retval;
 }
 
 std::string
 DASPK::error_message (void) const
 {
@@ -699,71 +699,71 @@ DASPK::error_message (void) const
       break;
 
     case 4:
       retval = "initial condition calculation completed successfully";
       break;
 
     case -1:
       retval = std::string ("a large amount of work has been expended (t =")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -2:
       retval = "the error tolerances are too stringent";
       break;
 
     case -3:
       retval = std::string ("error weight became zero during problem. (t = ")
-	+ t_curr
-	+ "; solution component i vanished, and atol or atol(i) == 0)";
+        + t_curr
+        + "; solution component i vanished, and atol or atol(i) == 0)";
       break;
 
     case -6:
       retval = std::string ("repeated error test failures on the last attempted step (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -7:
       retval = std::string ("the corrector could not converge (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -8:
       retval = std::string ("the matrix of partial derivatives is singular (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -9:
       retval = std::string ("the corrector could not converge (t = ")
-	+ t_curr + "; repeated test failures)";
+        + t_curr + "; repeated test failures)";
       break;
 
     case -10:
       retval = std::string ("corrector could not converge because IRES was -1 (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -11:
       retval = std::string ("return requested in user-supplied function (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -12:
       retval = "failed to compute consistent initial conditions";
       break;
 
     case -13:
       retval = std::string ("unrecoverable error encountered inside user's PSOL function (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -14:
       retval = std::string ("the Krylov linear system solver failed to converge (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -33:
       retval = "unrecoverable error (see printed message)";
       break;
 
     default:
       retval = "unknown error state";
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -30,44 +30,44 @@ along with Octave; see the file COPYING.
 
 #include "DASRT.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-math.h"
 #include "quit.h"
 
 typedef octave_idx_type (*dasrt_fcn_ptr) (const double&, const double*, const double*,
-			      double*, octave_idx_type&, double*, octave_idx_type*);
+                              double*, octave_idx_type&, double*, octave_idx_type*);
 
 typedef octave_idx_type (*dasrt_jac_ptr) (const double&, const double*, const double*,
-			      double*, const double&, double*, octave_idx_type*);
+                              double*, const double&, double*, octave_idx_type*);
 
 typedef octave_idx_type (*dasrt_constr_ptr) (const octave_idx_type&, const double&, const double*,
-				 const octave_idx_type&, double*, double*, octave_idx_type*);
+                                 const octave_idx_type&, double*, double*, octave_idx_type*);
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (ddasrt, DDASRT) (dasrt_fcn_ptr, const octave_idx_type&, double&,
-			     double*, double*, const double&, octave_idx_type*,
-			     const double*, const double*, octave_idx_type&, double*,
-			     const octave_idx_type&, octave_idx_type*, const octave_idx_type&, double*,
-			     octave_idx_type*, dasrt_jac_ptr, dasrt_constr_ptr,
-			     const octave_idx_type&, octave_idx_type*);
+                             double*, double*, const double&, octave_idx_type*,
+                             const double*, const double*, octave_idx_type&, double*,
+                             const octave_idx_type&, octave_idx_type*, const octave_idx_type&, double*,
+                             octave_idx_type*, dasrt_jac_ptr, dasrt_constr_ptr,
+                             const octave_idx_type&, octave_idx_type*);
 }
 
 static DAEFunc::DAERHSFunc user_fsub;
 static DAEFunc::DAEJacFunc user_jsub;
 static DAERTFunc::DAERTConstrFunc user_csub;
 
 static octave_idx_type nn;
 
 static octave_idx_type
 ddasrt_f (const double& t, const double *state, const double *deriv,
-	  double *delta, octave_idx_type& ires, double *, octave_idx_type *)
+          double *delta, octave_idx_type& ires, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
@@ -77,27 +77,27 @@ ddasrt_f (const double& t, const double 
 
   ColumnVector tmp_fval = (*user_fsub) (tmp_state, tmp_deriv, t, ires);
 
   if (tmp_fval.length () == 0)
     ires = -2;
   else
     {
       for (octave_idx_type i = 0; i < nn; i++)
-	delta[i] = tmp_fval(i);
+        delta[i] = tmp_fval(i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 octave_idx_type
 ddasrt_j (const double& time, const double *state, const double *deriv,
-	  double *pd, const double& cj, double *, octave_idx_type *)
+          double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
@@ -115,17 +115,17 @@ ddasrt_j (const double& time, const doub
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 static octave_idx_type
 ddasrt_g (const octave_idx_type& neq, const double& t, const double *state,
-	  const octave_idx_type& ng, double *gout, double *, octave_idx_type *) 
+          const octave_idx_type& ng, double *gout, double *, octave_idx_type *) 
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   octave_idx_type n = neq;
 
   ColumnVector tmp_state (n);
   for (octave_idx_type i = 0; i < n; i++)
     tmp_state(i) = state[i];
@@ -154,227 +154,227 @@ DASRT::integrate (double tout)
     {
       integration_error = false;
 
       initialized = true;
 
       info.resize (15);
 
       for (octave_idx_type i = 0; i < 15; i++)
-	info(i) = 0;
+        info(i) = 0;
 
       pinfo = info.fortran_vec ();
 
       octave_idx_type n = size ();
 
       nn = n;
 
       // DAERTFunc
 
       user_csub = DAERTFunc::constraint_function ();
 
       if (user_csub)
-	{
-	  ColumnVector tmp = (*user_csub) (x, t);
-	  ng = tmp.length ();
-	}
+        {
+          ColumnVector tmp = (*user_csub) (x, t);
+          ng = tmp.length ();
+        }
       else
-	ng = 0;
+        ng = 0;
 
       octave_idx_type maxord = maximum_order ();
       if (maxord >= 0)
-	{
-	  if (maxord > 0 && maxord < 6)
-	    {
-	      info(8) = 1;
-	      iwork(2) = maxord;
-	    }
-	  else
-	    {
-	      (*current_liboctave_error_handler)
-		("dassl: invalid value for maximum order");
-	      integration_error = true;
-	      return;
-	    }
-	}
+        {
+          if (maxord > 0 && maxord < 6)
+            {
+              info(8) = 1;
+              iwork(2) = maxord;
+            }
+          else
+            {
+              (*current_liboctave_error_handler)
+                ("dassl: invalid value for maximum order");
+              integration_error = true;
+              return;
+            }
+        }
 
       liw = 21 + n;
       lrw = 50 + 9*n + n*n + 3*ng;
 
       iwork.resize (liw);
       rwork.resize (lrw);
 
       info(0) = 0;
 
       if (stop_time_set)
-	{
-	  info(3) = 1;
-	  rwork(0) = stop_time;
-	}
+        {
+          info(3) = 1;
+          rwork(0) = stop_time;
+        }
       else
-	info(3) = 0;
+        info(3) = 0;
 
       px = x.fortran_vec ();
       pxdot = xdot.fortran_vec ();
 
       piwork = iwork.fortran_vec ();
       prwork = rwork.fortran_vec ();
 
       restart = false;
 
       // DAEFunc
 
       user_fsub = DAEFunc::function ();
       user_jsub = DAEFunc::jacobian_function ();
 
       if (user_fsub)
-	{
-	  octave_idx_type ires = 0;
+        {
+          octave_idx_type ires = 0;
 
-	  ColumnVector fval = (*user_fsub) (x, xdot, t, ires);
+          ColumnVector fval = (*user_fsub) (x, xdot, t, ires);
 
-	  if (fval.length () != x.length ())
-	    {
-	      (*current_liboctave_error_handler)
-		("dasrt: inconsistent sizes for state and residual vectors");
+          if (fval.length () != x.length ())
+            {
+              (*current_liboctave_error_handler)
+                ("dasrt: inconsistent sizes for state and residual vectors");
 
-	      integration_error = true;
-	      return;
-	    }
-	}
+              integration_error = true;
+              return;
+            }
+        }
       else
-	{
-	  (*current_liboctave_error_handler)
-	    ("dasrt: no user supplied RHS subroutine!");
+        {
+          (*current_liboctave_error_handler)
+            ("dasrt: no user supplied RHS subroutine!");
 
-	  integration_error = true;
-	  return;
-	}
+          integration_error = true;
+          return;
+        }
 
       info(4) = user_jsub ? 1 : 0;
 
       DAEFunc::reset = false;
 
       jroot.resize (ng, 1);
 
       pjroot = jroot.fortran_vec ();
 
       DAERTFunc::reset = false;
 
       // DASRT_options
 
       double mss = maximum_step_size ();
       if (mss >= 0.0)
-	{
-	  rwork(1) = mss;
-	  info(6) = 1;
-	}
+        {
+          rwork(1) = mss;
+          info(6) = 1;
+        }
       else
-	info(6) = 0;
+        info(6) = 0;
 
       double iss = initial_step_size ();
       if (iss >= 0.0)
-	{
-	  rwork(2) = iss;
-	  info(7) = 1;
-	}
+        {
+          rwork(2) = iss;
+          info(7) = 1;
+        }
       else
-	info(7) = 0;
+        info(7) = 0;
 
       if (step_limit () >= 0)
-	{
-	  info(11) = 1;
-	  iwork(20) = step_limit ();
-	}
+        {
+          info(11) = 1;
+          iwork(20) = step_limit ();
+        }
       else
-	info(11) = 0;
+        info(11) = 0;
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
       octave_idx_type abs_tol_len = abs_tol.length ();
       octave_idx_type rel_tol_len = rel_tol.length ();
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
-	{
-	  info.elem (1) = 0;
-	}
+        {
+          info.elem (1) = 0;
+        }
       else if (abs_tol_len == n && rel_tol_len == n)
-	{
-	  info.elem (1) = 1;
-	}
+        {
+          info.elem (1) = 1;
+        }
       else
-	{
-	  (*current_liboctave_error_handler)
-	    ("dasrt: inconsistent sizes for tolerance arrays");
+        {
+          (*current_liboctave_error_handler)
+            ("dasrt: inconsistent sizes for tolerance arrays");
 
-	  integration_error = true;
-	  return;
-	}
+          integration_error = true;
+          return;
+        }
 
       pabs_tol = abs_tol.fortran_vec ();
       prel_tol = rel_tol.fortran_vec ();
 
       DASRT_options::reset = false;
     }
 
   static double *dummy = 0;
   static octave_idx_type *idummy = 0;
 
   F77_XFCN (ddasrt, DDASRT, (ddasrt_f, nn, t, px, pxdot, tout, pinfo,
-			     prel_tol, pabs_tol, istate, prwork, lrw,
-			     piwork, liw, dummy, idummy, ddasrt_j,
-			     ddasrt_g, ng, pjroot));
+                             prel_tol, pabs_tol, istate, prwork, lrw,
+                             piwork, liw, dummy, idummy, ddasrt_j,
+                             ddasrt_g, ng, pjroot));
 
   switch (istate)
     {
     case 1: // A step was successfully taken in intermediate-output
-	    // mode. The code has not yet reached TOUT.
+            // mode. The code has not yet reached TOUT.
     case 2: // The integration to TOUT was successfully completed
-	    // (T=TOUT) by stepping exactly to TOUT.
+            // (T=TOUT) by stepping exactly to TOUT.
     case 3: // The integration to TOUT was successfully completed
-	    // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
-	    // interpolation.  YPRIME(*) is obtained by interpolation.
+            // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
+            // interpolation.  YPRIME(*) is obtained by interpolation.
       t = tout;
       break;
 
     case 4: //  The integration was successfully completed
-	    // by finding one or more roots of G at T.
+            // by finding one or more roots of G at T.
       break;
 
     case -1: // A large amount of work has been expended.
     case -2: // The error tolerances are too stringent.
     case -3: // The local error test cannot be satisfied because you
-	     // specified a zero component in ATOL and the
-	     // corresponding computed solution component is zero.
-	     // Thus, a pure relative error test is impossible for
-	     // this component.
+             // specified a zero component in ATOL and the
+             // corresponding computed solution component is zero.
+             // Thus, a pure relative error test is impossible for
+             // this component.
     case -6: // DDASRT had repeated error test failures on the last
-	     // attempted step.
+             // attempted step.
     case -7: // The corrector could not converge.
     case -8: // The matrix of partial derivatives is singular.
     case -9: // The corrector could not converge.  There were repeated
-	     // error test failures in this step.
+             // error test failures in this step.
     case -10: // The corrector could not converge because IRES was
-	      // equal to minus one.
+              // equal to minus one.
     case -11: // IRES equal to -2 was encountered and control is being
-	      // returned to the calling program.
+              // returned to the calling program.
     case -12: // DASSL failed to compute the initial YPRIME.
     case -33: // The code has encountered trouble from which it cannot
-	      // recover. A message is printed explaining the trouble
-	      // and control is returned to the calling program. For
-	      // example, this occurs when invalid input is detected.
+              // recover. A message is printed explaining the trouble
+              // and control is returned to the calling program. For
+              // example, this occurs when invalid input is detected.
       integration_error = true;
       break;
 
     default:
       integration_error = true;
       (*current_liboctave_error_handler)
-	("unrecognized value of istate (= %d) returned from ddasrt",
-	 istate);
+        ("unrecognized value of istate (= %d) returned from ddasrt",
+         istate);
       break;
     }
 }
 
 DASRT_result
 DASRT::integrate (const ColumnVector& tout)
 {
   DASRT_result retval;
@@ -387,50 +387,50 @@ DASRT::integrate (const ColumnVector& to
   octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       x_out.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  x_out(0,i) = x(i);
-	  xdot_out(0,i) = xdot(i);
-	}
+        {
+          x_out(0,i) = x(i);
+          xdot_out(0,i) = xdot(i);
+        }
 
       for (octave_idx_type j = 1; j < n_out; j++)
-	{
-	  integrate (tout(j));
+        {
+          integrate (tout(j));
 
-	  if (integration_error)
-	    {
-	      retval = DASRT_result (x_out, xdot_out, t_out);
-	      return retval;
-	    }
+          if (integration_error)
+            {
+              retval = DASRT_result (x_out, xdot_out, t_out);
+              return retval;
+            }
 
           if (istate == 4)
             t_out(j) = t;
           else
             t_out(j) = tout(j);
 
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      x_out(j,i) = x(i);
-	      xdot_out(j,i) = xdot(i);
-	    }
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              x_out(j,i) = x(i);
+              xdot_out(j,i) = xdot(i);
+            }
 
           if (istate == 4)
-	    {
-	      x_out.resize (j+1, n);
-	      xdot_out.resize (j+1, n);
-	      t_out.resize (j+1);
-	      break;
-	    }
-	}
+            {
+              x_out.resize (j+1, n);
+              xdot_out.resize (j+1, n);
+              t_out.resize (j+1);
+              break;
+            }
+        }
     }
 
   retval = DASRT_result (x_out, xdot_out, t_out);
 
   return retval;
 }
 
 DASRT_result
@@ -448,110 +448,110 @@ DASRT::integrate (const ColumnVector& to
   if (n_out > 0 && n > 0)
     {
       x_out.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       octave_idx_type n_crit = tcrit.capacity ();
 
       if (n_crit > 0)
-	{
-	  octave_idx_type i_crit = 0;
-	  octave_idx_type i_out = 1;
-	  double next_crit = tcrit(0);
-	  double next_out;
-	  while (i_out < n_out)
-	    {
-	      bool do_restart = false;
+        {
+          octave_idx_type i_crit = 0;
+          octave_idx_type i_out = 1;
+          double next_crit = tcrit(0);
+          double next_out;
+          while (i_out < n_out)
+            {
+              bool do_restart = false;
 
-	      next_out = tout(i_out);
-	      if (i_crit < n_crit)
-		next_crit = tcrit(i_crit);
+              next_out = tout(i_out);
+              if (i_crit < n_crit)
+                next_crit = tcrit(i_crit);
 
-	      octave_idx_type save_output;
-	      double t_out;
+              octave_idx_type save_output;
+              double t_out;
 
-	      if (next_crit == next_out)
-		{
-		  set_stop_time (next_crit);
-		  t_out = next_out;
-		  save_output = 1;
-		  i_out++;
-		  i_crit++;
-		  do_restart = true;
-		}
-	      else if (next_crit < next_out)
-		{
-		  if (i_crit < n_crit)
-		    {
-		      set_stop_time (next_crit);
-		      t_out = next_crit;
-		      save_output = 0;
-		      i_crit++;
-		      do_restart = true;
-		    }
-		  else
-		    {
-		      clear_stop_time ();
-		      t_out = next_out;
-		      save_output = 1;
-		      i_out++;
-		    }
-		}
-	      else
-		{
-		  set_stop_time (next_crit);
-		  t_out = next_out;
-		  save_output = 1;
-		  i_out++;
-		}
+              if (next_crit == next_out)
+                {
+                  set_stop_time (next_crit);
+                  t_out = next_out;
+                  save_output = 1;
+                  i_out++;
+                  i_crit++;
+                  do_restart = true;
+                }
+              else if (next_crit < next_out)
+                {
+                  if (i_crit < n_crit)
+                    {
+                      set_stop_time (next_crit);
+                      t_out = next_crit;
+                      save_output = 0;
+                      i_crit++;
+                      do_restart = true;
+                    }
+                  else
+                    {
+                      clear_stop_time ();
+                      t_out = next_out;
+                      save_output = 1;
+                      i_out++;
+                    }
+                }
+              else
+                {
+                  set_stop_time (next_crit);
+                  t_out = next_out;
+                  save_output = 1;
+                  i_out++;
+                }
 
-	      integrate (t_out);
+              integrate (t_out);
 
-	      if (integration_error)
-		{
-		  retval = DASRT_result (x_out, xdot_out, t_outs);
-		  return retval;
-		}
+              if (integration_error)
+                {
+                  retval = DASRT_result (x_out, xdot_out, t_outs);
+                  return retval;
+                }
 
               if (istate == 4)
                 t_out = t;
 
-	      if (save_output)
-		{
-		  for (octave_idx_type i = 0; i < n; i++)
-		    {
-		      x_out(i_out-1,i) = x(i);
-		      xdot_out(i_out-1,i) = xdot(i);
-		    }
+              if (save_output)
+                {
+                  for (octave_idx_type i = 0; i < n; i++)
+                    {
+                      x_out(i_out-1,i) = x(i);
+                      xdot_out(i_out-1,i) = xdot(i);
+                    }
 
                   t_outs(i_out-1) = t_out;
 
                   if (istate == 4)
                     {
                       x_out.resize (i_out, n);
                       xdot_out.resize (i_out, n);
                       t_outs.resize (i_out);
                       i_out = n_out;
                     }
-		}
+                }
 
-	      if (do_restart)
-		force_restart ();
-	    }
+              if (do_restart)
+                force_restart ();
+            }
 
-	  retval = DASRT_result (x_out, xdot_out, t_outs);
-	}
+          retval = DASRT_result (x_out, xdot_out, t_outs);
+        }
       else
-	{
-	  retval = integrate (tout);
+        {
+          retval = integrate (tout);
 
-	  if (integration_error)
-	    return retval;
-	}
+          if (integration_error)
+            return retval;
+        }
     }
 
   return retval;
 }
 
 std::string
 DASRT::error_message (void) const
 {
@@ -576,57 +576,57 @@ DASRT::error_message (void) const
       break;
 
     case 4:
       retval = "integration completed by finding one or more roots of G at T";
       break;
 
     case -1:
       retval = std::string ("a large amount of work has been expended (t =")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -2:
       retval = "the error tolerances are too stringent";
       break;
 
     case -3:
       retval = std::string ("error weight became zero during problem. (t = ")
-	+ t_curr
-	+ "; solution component i vanished, and atol or atol(i) == 0)";
+        + t_curr
+        + "; solution component i vanished, and atol or atol(i) == 0)";
       break;
 
     case -6:
       retval = std::string ("repeated error test failures on the last attempted step (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -7:
       retval = std::string ("the corrector could not converge (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -8:
       retval = std::string ("the matrix of partial derivatives is singular (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -9:
       retval = std::string ("the corrector could not converge (t = ")
-	+ t_curr + "; repeated test failures)";
+        + t_curr + "; repeated test failures)";
       break;
 
     case -10:
       retval = std::string ("corrector could not converge because IRES was -1 (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -11:
       retval = std::string ("return requested in user-supplied function (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -12:
       retval = "failed to compute consistent initial conditions";
       break;
 
     case -33:
       retval = "unrecoverable error (see printed message)";
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -31,40 +31,40 @@ along with Octave; see the file COPYING.
 
 #include "DASSL.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-math.h"
 #include "quit.h"
 
 typedef octave_idx_type (*dassl_fcn_ptr) (const double&, const double*, const double*,
-			      double*, octave_idx_type&, double*, octave_idx_type*);
+                              double*, octave_idx_type&, double*, octave_idx_type*);
 
 typedef octave_idx_type (*dassl_jac_ptr) (const double&, const double*, const double*,
-			      double*, const double&, double*, octave_idx_type*);
+                              double*, const double&, double*, octave_idx_type*);
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (ddassl, DDASSL) (dassl_fcn_ptr, const octave_idx_type&, double&,
-			     double*, double*, double&, const octave_idx_type*,
-			     const double*, const double*, octave_idx_type&,
-			     double*, const octave_idx_type&, octave_idx_type*, const octave_idx_type&,
-			     const double*, const octave_idx_type*,
-			     dassl_jac_ptr);
+                             double*, double*, double&, const octave_idx_type*,
+                             const double*, const double*, octave_idx_type&,
+                             double*, const octave_idx_type&, octave_idx_type*, const octave_idx_type&,
+                             const double*, const octave_idx_type*,
+                             dassl_jac_ptr);
 }
 
 static DAEFunc::DAERHSFunc user_fun;
 static DAEFunc::DAEJacFunc user_jac;
 
 static octave_idx_type nn;
 
 static octave_idx_type
 ddassl_f (const double& time, const double *state, const double *deriv,
-	  double *delta, octave_idx_type& ires, double *, octave_idx_type *)
+          double *delta, octave_idx_type& ires, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_deriv (nn);
   ColumnVector tmp_state (nn);
   ColumnVector tmp_delta (nn);
@@ -75,32 +75,32 @@ ddassl_f (const double& time, const doub
       tmp_state.elem (i) = state [i];
     }
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, ires);
 
   if (ires >= 0)
     {
       if (tmp_delta.length () == 0)
-	ires = -2;
+        ires = -2;
       else
-	{
-	  for (octave_idx_type i = 0; i < nn; i++)
-	    delta [i] = tmp_delta.elem (i);
-	}
+        {
+          for (octave_idx_type i = 0; i < nn; i++)
+            delta [i] = tmp_delta.elem (i);
+        }
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 static octave_idx_type
 ddassl_j (const double& time, const double *state, const double *deriv,
-	  double *pd, const double& cj, double *, octave_idx_type *)
+          double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
@@ -130,211 +130,211 @@ DASSL::do_integrate (double tout)
     {
       integration_error = false;
 
       initialized = true;
 
       info.resize (15);
 
       for (octave_idx_type i = 0; i < 15; i++)
-	info(i) = 0;
+        info(i) = 0;
 
       pinfo = info.fortran_vec ();
 
       octave_idx_type n = size ();
 
       liw = 21 + n;
       lrw = 40 + 9*n + n*n;
 
       nn = n;
 
       iwork.resize (liw);
       rwork.resize (lrw);
 
       info(0) = 0;
 
       if (stop_time_set)
-	{
-	  rwork(0) = stop_time;
-	  info(3) = 1;
-	}
+        {
+          rwork(0) = stop_time;
+          info(3) = 1;
+        }
       else
-	info(3) = 0;
+        info(3) = 0;
 
       px = x.fortran_vec ();
       pxdot = xdot.fortran_vec ();
 
       piwork = iwork.fortran_vec ();
       prwork = rwork.fortran_vec ();
 
       restart = false;
 
       // DAEFunc
 
       user_fun = DAEFunc::function ();
       user_jac = DAEFunc::jacobian_function ();
 
       if (user_fun)
-	{
-	  octave_idx_type ires = 0;
+        {
+          octave_idx_type ires = 0;
 
-	  ColumnVector res = (*user_fun) (x, xdot, t, ires);
+          ColumnVector res = (*user_fun) (x, xdot, t, ires);
 
-	  if (res.length () != x.length ())
-	    {
-	      (*current_liboctave_error_handler)
-		("dassl: inconsistent sizes for state and residual vectors");
+          if (res.length () != x.length ())
+            {
+              (*current_liboctave_error_handler)
+                ("dassl: inconsistent sizes for state and residual vectors");
 
-	      integration_error = true;
-	      return retval;
-	    }
-	}
+              integration_error = true;
+              return retval;
+            }
+        }
       else
-	{
-	  (*current_liboctave_error_handler)
-	    ("dassl: no user supplied RHS subroutine!");
+        {
+          (*current_liboctave_error_handler)
+            ("dassl: no user supplied RHS subroutine!");
 
-	  integration_error = true;
-	  return retval;
-	}
+          integration_error = true;
+          return retval;
+        }
 
       info(4) = user_jac ? 1 : 0;
   
       DAEFunc::reset = false;
 
       // DASSL_options
 
       double hmax = maximum_step_size ();
       if (hmax >= 0.0)
-	{
-	  rwork(1) = hmax;
-	  info(6) = 1;
-	}
+        {
+          rwork(1) = hmax;
+          info(6) = 1;
+        }
       else
-	info(6) = 0;
+        info(6) = 0;
 
       double h0 = initial_step_size ();
       if (h0 >= 0.0)
-	{
-	  rwork(2) = h0;
-	  info(7) = 1;
-	}
+        {
+          rwork(2) = h0;
+          info(7) = 1;
+        }
       else
-	info(7) = 0;
+        info(7) = 0;
 
       if (step_limit () >= 0)
-	{
-	  info(11) = 1;
-	  iwork(20) = step_limit ();
-	}
+        {
+          info(11) = 1;
+          iwork(20) = step_limit ();
+        }
       else
-	info(11) = 0;
+        info(11) = 0;
 
       octave_idx_type maxord = maximum_order ();
       if (maxord >= 0)
-	{
-	  if (maxord > 0 && maxord < 6)
-	    {
-	      info(8) = 1;
-	      iwork(2) = maxord;
-	    }
-	  else
-	    {
-	      (*current_liboctave_error_handler)
-		("dassl: invalid value for maximum order");
-	      integration_error = true;
-	      return retval;
-	    }
-	}
+        {
+          if (maxord > 0 && maxord < 6)
+            {
+              info(8) = 1;
+              iwork(2) = maxord;
+            }
+          else
+            {
+              (*current_liboctave_error_handler)
+                ("dassl: invalid value for maximum order");
+              integration_error = true;
+              return retval;
+            }
+        }
 
       octave_idx_type enc = enforce_nonnegativity_constraints ();
       info(9) = enc ? 1 : 0;
 
       octave_idx_type ccic = compute_consistent_initial_condition ();
       info(10) = ccic ? 1 : 0;
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
       octave_idx_type abs_tol_len = abs_tol.length ();
       octave_idx_type rel_tol_len = rel_tol.length ();
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
-	{
-	  info(1) = 0;
-	}
+        {
+          info(1) = 0;
+        }
       else if (abs_tol_len == n && rel_tol_len == n)
-	{
-	  info(1) = 1;
-	}
+        {
+          info(1) = 1;
+        }
       else
-	{
-	  (*current_liboctave_error_handler)
-	    ("dassl: inconsistent sizes for tolerance arrays");
+        {
+          (*current_liboctave_error_handler)
+            ("dassl: inconsistent sizes for tolerance arrays");
 
-	  integration_error = true;
-	  return retval;
-	}
+          integration_error = true;
+          return retval;
+        }
 
       pabs_tol = abs_tol.fortran_vec ();
       prel_tol = rel_tol.fortran_vec ();
 
       DASSL_options::reset = false;
     }
 
   static double *dummy = 0;
   static octave_idx_type *idummy = 0;
 
   F77_XFCN (ddassl, DDASSL, (ddassl_f, nn, t, px, pxdot, tout, pinfo,
-			     prel_tol, pabs_tol, istate, prwork, lrw,
-			     piwork, liw, dummy, idummy, ddassl_j));
+                             prel_tol, pabs_tol, istate, prwork, lrw,
+                             piwork, liw, dummy, idummy, ddassl_j));
 
   switch (istate)
     {
     case 1: // A step was successfully taken in intermediate-output
-	    // mode. The code has not yet reached TOUT.
+            // mode. The code has not yet reached TOUT.
     case 2: // The integration to TSTOP was successfully completed
-	    // (T=TSTOP) by stepping exactly to TSTOP.
+            // (T=TSTOP) by stepping exactly to TSTOP.
     case 3: // The integration to TOUT was successfully completed
-	    // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
-	    // interpolation.  YPRIME(*) is obtained by interpolation.
+            // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
+            // interpolation.  YPRIME(*) is obtained by interpolation.
       retval = x;
       t = tout;
       break;
 
     case -1: // A large amount of work has been expended.  (~500 steps).
     case -2: // The error tolerances are too stringent.
     case -3: // The local error test cannot be satisfied because you
-	     // specified a zero component in ATOL and the
-	     // corresponding computed solution component is zero.
-	     // Thus, a pure relative error test is impossible for
-	     // this component.
+             // specified a zero component in ATOL and the
+             // corresponding computed solution component is zero.
+             // Thus, a pure relative error test is impossible for
+             // this component.
     case -6: // DDASSL had repeated error test failures on the last
-	     // attempted step.
+             // attempted step.
     case -7: // The corrector could not converge.
     case -8: // The matrix of partial derivatives is singular.
     case -9: // The corrector could not converge.  There were repeated
-	     // error test failures in this step.
+             // error test failures in this step.
     case -10: // The corrector could not converge because IRES was
-	      // equal to minus one.
+              // equal to minus one.
     case -11: // IRES equal to -2 was encountered and control is being
-	      // returned to the calling program.
+              // returned to the calling program.
     case -12: // DDASSL failed to compute the initial YPRIME.
     case -33: // The code has encountered trouble from which it cannot
-	      // recover. A message is printed explaining the trouble
-	      // and control is returned to the calling program. For
-	      // example, this occurs when invalid input is detected.
+              // recover. A message is printed explaining the trouble
+              // and control is returned to the calling program. For
+              // example, this occurs when invalid input is detected.
       integration_error = true;
       break;
 
     default:
       integration_error = true;
       (*current_liboctave_error_handler)
-	("unrecognized value of istate (= %d) returned from ddassl",
-	 istate);
+        ("unrecognized value of istate (= %d) returned from ddassl",
+         istate);
       break;
     }
 
   return retval;
 }
 
 Matrix
 DASSL::do_integrate (const ColumnVector& tout)
@@ -352,145 +352,145 @@ DASSL::integrate (const ColumnVector& to
   octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  retval.elem (0, i) = x.elem (i);
-	  xdot_out.elem (0, i) = xdot.elem (i);
-	}
+        {
+          retval.elem (0, i) = x.elem (i);
+          xdot_out.elem (0, i) = xdot.elem (i);
+        }
 
       for (octave_idx_type j = 1; j < n_out; j++)
-	{
-	  ColumnVector x_next = do_integrate (tout.elem (j));
+        {
+          ColumnVector x_next = do_integrate (tout.elem (j));
 
-	  if (integration_error)
-	    return retval;
+          if (integration_error)
+            return retval;
 
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      retval.elem (j, i) = x_next.elem (i);
-	      xdot_out.elem (j, i) = xdot.elem (i);
-	    }
-	}
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              retval.elem (j, i) = x_next.elem (i);
+              xdot_out.elem (j, i) = xdot.elem (i);
+            }
+        }
     }
 
   return retval;
 }
 
 Matrix
 DASSL::do_integrate (const ColumnVector& tout, const ColumnVector& tcrit)
 {
   Matrix dummy;
   return integrate (tout, dummy, tcrit);
 }
 
 Matrix
 DASSL::integrate (const ColumnVector& tout, Matrix& xdot_out,
-		  const ColumnVector& tcrit) 
+                  const ColumnVector& tcrit) 
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.capacity ();
   octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  retval.elem (0, i) = x.elem (i);
-	  xdot_out.elem (0, i) = xdot.elem (i);
-	}
+        {
+          retval.elem (0, i) = x.elem (i);
+          xdot_out.elem (0, i) = xdot.elem (i);
+        }
 
       octave_idx_type n_crit = tcrit.capacity ();
 
       if (n_crit > 0)
-	{
-	  octave_idx_type i_crit = 0;
-	  octave_idx_type i_out = 1;
-	  double next_crit = tcrit.elem (0);
-	  double next_out;
-	  while (i_out < n_out)
-	    {
-	      bool do_restart = false;
+        {
+          octave_idx_type i_crit = 0;
+          octave_idx_type i_out = 1;
+          double next_crit = tcrit.elem (0);
+          double next_out;
+          while (i_out < n_out)
+            {
+              bool do_restart = false;
 
-	      next_out = tout.elem (i_out);
-	      if (i_crit < n_crit)
-		next_crit = tcrit.elem (i_crit);
+              next_out = tout.elem (i_out);
+              if (i_crit < n_crit)
+                next_crit = tcrit.elem (i_crit);
 
-	      bool save_output;
-	      double t_out;
+              bool save_output;
+              double t_out;
 
-	      if (next_crit == next_out)
-		{
-		  set_stop_time (next_crit);
-		  t_out = next_out;
-		  save_output = true;
-		  i_out++;
-		  i_crit++;
-		  do_restart = true;
-		}
-	      else if (next_crit < next_out)
-		{
-		  if (i_crit < n_crit)
-		    {
-		      set_stop_time (next_crit);
-		      t_out = next_crit;
-		      save_output = false;
-		      i_crit++;
-		      do_restart = true;
-		    }
-		  else
-		    {
-		      clear_stop_time ();
-		      t_out = next_out;
-		      save_output = true;
-		      i_out++;
-		    }
-		}
-	      else
-		{
-		  set_stop_time (next_crit);
-		  t_out = next_out;
-		  save_output = true;
-		  i_out++;
-		}
+              if (next_crit == next_out)
+                {
+                  set_stop_time (next_crit);
+                  t_out = next_out;
+                  save_output = true;
+                  i_out++;
+                  i_crit++;
+                  do_restart = true;
+                }
+              else if (next_crit < next_out)
+                {
+                  if (i_crit < n_crit)
+                    {
+                      set_stop_time (next_crit);
+                      t_out = next_crit;
+                      save_output = false;
+                      i_crit++;
+                      do_restart = true;
+                    }
+                  else
+                    {
+                      clear_stop_time ();
+                      t_out = next_out;
+                      save_output = true;
+                      i_out++;
+                    }
+                }
+              else
+                {
+                  set_stop_time (next_crit);
+                  t_out = next_out;
+                  save_output = true;
+                  i_out++;
+                }
 
-	      ColumnVector x_next = do_integrate (t_out);
+              ColumnVector x_next = do_integrate (t_out);
 
-	      if (integration_error)
-		return retval;
+              if (integration_error)
+                return retval;
 
-	      if (save_output)
-		{
-		  for (octave_idx_type i = 0; i < n; i++)
-		    {
-		      retval.elem (i_out-1, i) = x_next.elem (i);
-		      xdot_out.elem (i_out-1, i) = xdot.elem (i);
-		    }
-		}
+              if (save_output)
+                {
+                  for (octave_idx_type i = 0; i < n; i++)
+                    {
+                      retval.elem (i_out-1, i) = x_next.elem (i);
+                      xdot_out.elem (i_out-1, i) = xdot.elem (i);
+                    }
+                }
 
-	      if (do_restart)
-		force_restart ();
-	    }
-	}
+              if (do_restart)
+                force_restart ();
+            }
+        }
       else
-	{
-	  retval = integrate (tout, xdot_out);
+        {
+          retval = integrate (tout, xdot_out);
 
-	  if (integration_error)
-	    return retval;
-	}
+          if (integration_error)
+            return retval;
+        }
     }
 
   return retval;
 }
 
 std::string
 DASSL::error_message (void) const
 {
@@ -511,57 +511,57 @@ DASSL::error_message (void) const
       break;
 
     case 3:
       retval = "integration to tout completed by stepping past TOUT";
       break;
 
     case -1:
       retval = std::string ("a large amount of work has been expended (t =")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -2:
       retval = "the error tolerances are too stringent";
       break;
 
     case -3:
       retval = std::string ("error weight became zero during problem. (t = ")
-	+ t_curr
-	+ "; solution component i vanished, and atol or atol(i) == 0)";
+        + t_curr
+        + "; solution component i vanished, and atol or atol(i) == 0)";
       break;
 
     case -6:
       retval = std::string ("repeated error test failures on the last attempted step (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -7:
       retval = std::string ("the corrector could not converge (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -8:
       retval = std::string ("the matrix of partial derivatives is singular (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -9:
       retval = std::string ("the corrector could not converge (t = ")
-	+ t_curr + "; repeated test failures)";
+        + t_curr + "; repeated test failures)";
       break;
 
     case -10:
       retval = std::string ("corrector could not converge because IRES was -1 (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -11:
       retval = std::string ("return requested in user-supplied function (t = ")
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     case -12:
       retval = "failed to compute consistent initial conditions";
       break;
 
     case -33:
       retval = "unrecoverable error (see printed message)";
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -29,118 +29,118 @@ along with Octave; see the file COPYING.
 #include "dColVector.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgeev, DGEEV) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, double*, const octave_idx_type&, double*,
-			   double*, double*, const octave_idx_type&, double*,
-			   const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, double*, const octave_idx_type&, double*,
+                           double*, double*, const octave_idx_type&, double*,
+                           const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgeev, ZGEEV) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, Complex*, const octave_idx_type&, Complex*,
-			   Complex*, const octave_idx_type&, Complex*, const octave_idx_type&,
-			   Complex*, const octave_idx_type&, double*, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, Complex*, const octave_idx_type&, Complex*,
+                           Complex*, const octave_idx_type&, Complex*, const octave_idx_type&,
+                           Complex*, const octave_idx_type&, double*, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dsyev, DSYEV) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, double*, const octave_idx_type&, double*,
-			   double*, const octave_idx_type&, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, double*, const octave_idx_type&, double*,
+                           double*, const octave_idx_type&, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zheev, ZHEEV) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, Complex*, const octave_idx_type&, double*,
-			   Complex*, const octave_idx_type&, double*, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, Complex*, const octave_idx_type&, double*,
+                           Complex*, const octave_idx_type&, double*, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dpotrf, DPOTRF) (F77_CONST_CHAR_ARG_DECL, 
-			   const octave_idx_type&, 
-			   double*, const octave_idx_type&,
-			   octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, 
+                           double*, const octave_idx_type&,
+                           octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zpotrf, ZPOTRF) (F77_CONST_CHAR_ARG_DECL, 
-			   const octave_idx_type&, 
-			   Complex*, const octave_idx_type&,
-			   octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, 
+                           Complex*, const octave_idx_type&,
+                           octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dggev, DGGEV) (F77_CONST_CHAR_ARG_DECL, 
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, 
-			   double*, const octave_idx_type&,
-			   double*, const octave_idx_type&,
-			   double*, double*, double *,
-			   double*, const octave_idx_type&, double*, const octave_idx_type&,
-			   double*, const octave_idx_type&, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, 
+                           double*, const octave_idx_type&,
+                           double*, const octave_idx_type&,
+                           double*, double*, double *,
+                           double*, const octave_idx_type&, double*, const octave_idx_type&,
+                           double*, const octave_idx_type&, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dsygv, DSYGV) (const octave_idx_type&,
-			   F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, 
-			   double*, const octave_idx_type&,
-			   double*, const octave_idx_type&,
-			   double*, double*, const octave_idx_type&, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, 
+                           double*, const octave_idx_type&,
+                           double*, const octave_idx_type&,
+                           double*, double*, const octave_idx_type&, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zggev, ZGGEV) (F77_CONST_CHAR_ARG_DECL, 
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, 
-			   Complex*, const octave_idx_type&,
-			   Complex*, const octave_idx_type&,
-			   Complex*, Complex*,
-			   Complex*, const octave_idx_type&, Complex*, const octave_idx_type&,
-			   Complex*, const octave_idx_type&, double*, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, 
+                           Complex*, const octave_idx_type&,
+                           Complex*, const octave_idx_type&,
+                           Complex*, Complex*,
+                           Complex*, const octave_idx_type&, Complex*, const octave_idx_type&,
+                           Complex*, const octave_idx_type&, double*, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zhegv, ZHEGV) (const octave_idx_type&,
-			   F77_CONST_CHAR_ARG_DECL, 
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, 
-			   Complex*, const octave_idx_type&,
-			   Complex*, const octave_idx_type&,
-			   double*, Complex*, const octave_idx_type&, double*, 
-			   octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL, 
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, 
+                           Complex*, const octave_idx_type&,
+                           Complex*, const octave_idx_type&,
+                           double*, Complex*, const octave_idx_type&, double*, 
+                           octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 }
 
 octave_idx_type
 EIG::init (const Matrix& a, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan ())
     {
       (*current_liboctave_error_handler)
-	("EIG: matrix contains Inf or NaN values");
+        ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
   if (a.is_symmetric ())
     return symmetric_init (a, calc_ev);
 
   octave_idx_type n = a.rows ();
 
@@ -167,80 +167,80 @@ EIG::init (const Matrix& a, bool calc_ev
 
   octave_idx_type lwork = -1;
   double dummy_work;
 
   double *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			   F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   n, tmp_data, n, pwr, pwi, dummy,
-			   idummy, pvr, n, &dummy_work, lwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, tmp_data, n, pwr, pwi, dummy,
+                           idummy, pvr, n, &dummy_work, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<double> work (lwork);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			       F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       n, tmp_data, n, pwr, pwi, dummy,
-			       idummy, pvr, n, pwork, lwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                               n, tmp_data, n, pwr, pwi, dummy,
+                               idummy, pvr, n, pwork, lwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in dgeev");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in dgeev");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("dgeev failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("dgeev failed to converge");
+          return info;
+        }
 
       lambda.resize (n);
       octave_idx_type nvr = calc_ev ? n : 0;
       v.resize (nvr, nvr);
 
       for (octave_idx_type j = 0; j < n; j++)
-	{
-	  if (wi.elem (j) == 0.0)
-	    {
-	      lambda.elem (j) = Complex (wr.elem (j));
-	      for (octave_idx_type i = 0; i < nvr; i++)
-		v.elem (i, j) = vr.elem (i, j);
-	    }
-	  else
-	    {
-	      if (j+1 >= n)
-		{
-		  (*current_liboctave_error_handler) ("EIG: internal error");
-		  return -1;
-		}
+        {
+          if (wi.elem (j) == 0.0)
+            {
+              lambda.elem (j) = Complex (wr.elem (j));
+              for (octave_idx_type i = 0; i < nvr; i++)
+                v.elem (i, j) = vr.elem (i, j);
+            }
+          else
+            {
+              if (j+1 >= n)
+                {
+                  (*current_liboctave_error_handler) ("EIG: internal error");
+                  return -1;
+                }
 
-	      lambda.elem(j) = Complex (wr.elem(j), wi.elem(j));
-	      lambda.elem(j+1) = Complex (wr.elem(j+1), wi.elem(j+1));
+              lambda.elem(j) = Complex (wr.elem(j), wi.elem(j));
+              lambda.elem(j+1) = Complex (wr.elem(j+1), wi.elem(j+1));
 
-	      for (octave_idx_type i = 0; i < nvr; i++)
-		{
-		  double real_part = vr.elem (i, j);
-		  double imag_part = vr.elem (i, j+1);
-		  v.elem (i, j) = Complex (real_part, imag_part);
-		  v.elem (i, j+1) = Complex (real_part, -imag_part);
-		}
-	      j++;
-	    }
-	}
+              for (octave_idx_type i = 0; i < nvr; i++)
+                {
+                  double real_part = vr.elem (i, j);
+                  double imag_part = vr.elem (i, j+1);
+                  v.elem (i, j) = Complex (real_part, imag_part);
+                  v.elem (i, j+1) = Complex (real_part, -imag_part);
+                }
+              j++;
+            }
+        }
     }
   else
     (*current_liboctave_error_handler) ("dgeev workspace query failed");
 
   return info;
 }
 
 octave_idx_type 
@@ -261,61 +261,61 @@ EIG::symmetric_init (const Matrix& a, bo
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   double dummy_work;
 
   F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   F77_CONST_CHAR_ARG2 ("U", 1),
-			   n, tmp_data, n, pwr, &dummy_work, lwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, tmp_data, n, pwr, &dummy_work, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<double> work (lwork);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       F77_CONST_CHAR_ARG2 ("U", 1),
-			       n, tmp_data, n, pwr, pwork, lwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 ("U", 1),
+                               n, tmp_data, n, pwr, pwork, lwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in dsyev");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in dsyev");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("dsyev failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("dsyev failed to converge");
+          return info;
+        }
 
       lambda = ComplexColumnVector (wr);
       v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
     }
   else
     (*current_liboctave_error_handler) ("dsyev workspace query failed");
 
   return info;
 }
 
 octave_idx_type
 EIG::init (const ComplexMatrix& a, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan ())
     {
       (*current_liboctave_error_handler)
-	("EIG: matrix contains Inf or NaN values");
+        ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
   if (a.is_hermitian ())
     return hermitian_init (a, calc_ev);
 
   octave_idx_type n = a.rows ();
 
@@ -343,46 +343,46 @@ EIG::init (const ComplexMatrix& a, bool 
   octave_idx_type lrwork = 2*n;
   Array<double> rwork (lrwork);
   double *prwork = rwork.fortran_vec ();
 
   Complex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			   F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   n, tmp_data, n, pw, dummy, idummy,
-			   pv, n, &dummy_work, lwork, prwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, tmp_data, n, pw, dummy, idummy,
+                           pv, n, &dummy_work, lwork, prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<Complex> work (lwork);
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			       F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       n, tmp_data, n, pw, dummy, idummy,
-			       pv, n, pwork, lwork, prwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                               n, tmp_data, n, pw, dummy, idummy,
+                               pv, n, pwork, lwork, prwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in zgeev");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in zgeev");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("zgeev failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("zgeev failed to converge");
+          return info;
+        }
 
       lambda = w;
       v = vtmp;
     }
   else
     (*current_liboctave_error_handler) ("zgeev workspace query failed");
 
   return info;
@@ -410,62 +410,62 @@ EIG::hermitian_init (const ComplexMatrix
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<double> rwork (lrwork);
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   F77_CONST_CHAR_ARG2 ("U", 1),
-			   n, tmp_data, n, pwr, &dummy_work, lwork,
-			   prwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, tmp_data, n, pwr, &dummy_work, lwork,
+                           prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<Complex> work (lwork);
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       F77_CONST_CHAR_ARG2 ("U", 1),
-			       n, tmp_data, n, pwr, pwork, lwork, prwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 ("U", 1),
+                               n, tmp_data, n, pwr, pwork, lwork, prwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in zheev");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in zheev");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("zheev failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("zheev failed to converge");
+          return info;
+        }
 
       lambda = ComplexColumnVector (wr);
       v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
     }
   else
     (*current_liboctave_error_handler) ("zheev workspace query failed");
 
   return info;
 }
 
 octave_idx_type
 EIG::init (const Matrix& a, const Matrix& b, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     {
       (*current_liboctave_error_handler)
-	("EIG: matrix contains Inf or NaN values");
+        ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
     {
@@ -480,20 +480,20 @@ EIG::init (const Matrix& a, const Matrix
     }
 
   octave_idx_type info = 0;
 
   Matrix tmp = b;
   double *tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-			     n, tmp_data, n, 
-			     info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             n, tmp_data, n, 
+                             info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (a.is_symmetric () && b.is_symmetric () && info == 0)
     return symmetric_init (a, b, calc_ev);
 
   Matrix atmp = a;
   double *atmp_data = atmp.fortran_vec ();
 
   Matrix btmp = b;
@@ -514,86 +514,86 @@ EIG::init (const Matrix& a, const Matrix
 
   octave_idx_type lwork = -1;
   double dummy_work;
 
   double *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			   F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   n, atmp_data, n, btmp_data, n, 
-			   par, pai, pbeta,
-			   dummy, idummy, pvr, n,
-			   &dummy_work, lwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, atmp_data, n, btmp_data, n, 
+                           par, pai, pbeta,
+                           dummy, idummy, pvr, n,
+                           &dummy_work, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<double> work (lwork);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			       F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       n, atmp_data, n, btmp_data, n, 
-			       par, pai, pbeta,
-			       dummy, idummy, pvr, n,
-			       pwork, lwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                               n, atmp_data, n, btmp_data, n, 
+                               par, pai, pbeta,
+                               dummy, idummy, pvr, n,
+                               pwork, lwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in dggev");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in dggev");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("dggev failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("dggev failed to converge");
+          return info;
+        }
 
       lambda.resize (n);
       octave_idx_type nvr = calc_ev ? n : 0;
       v.resize (nvr, nvr);
 
       for (octave_idx_type j = 0; j < n; j++)
-	{
-	  if (ai.elem (j) == 0.0)
-	    {
-	      lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j));
-	      for (octave_idx_type i = 0; i < nvr; i++)
-		v.elem (i, j) = vr.elem (i, j);
-	    }
-	  else
-	    {
-	      if (j+1 >= n)
-		{
-		  (*current_liboctave_error_handler) ("EIG: internal error");
-		  return -1;
-		}
+        {
+          if (ai.elem (j) == 0.0)
+            {
+              lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j));
+              for (octave_idx_type i = 0; i < nvr; i++)
+                v.elem (i, j) = vr.elem (i, j);
+            }
+          else
+            {
+              if (j+1 >= n)
+                {
+                  (*current_liboctave_error_handler) ("EIG: internal error");
+                  return -1;
+                }
 
-	      lambda.elem(j) = Complex (ar.elem(j) / beta.elem (j), 
-	                                ai.elem(j) / beta.elem (j));
-	      lambda.elem(j+1) = Complex (ar.elem(j+1) / beta.elem (j+1), 
-	                                  ai.elem(j+1) / beta.elem (j+1));
+              lambda.elem(j) = Complex (ar.elem(j) / beta.elem (j), 
+                                        ai.elem(j) / beta.elem (j));
+              lambda.elem(j+1) = Complex (ar.elem(j+1) / beta.elem (j+1), 
+                                          ai.elem(j+1) / beta.elem (j+1));
 
-	      for (octave_idx_type i = 0; i < nvr; i++)
-		{
-		  double real_part = vr.elem (i, j);
-		  double imag_part = vr.elem (i, j+1);
-		  v.elem (i, j) = Complex (real_part, imag_part);
-		  v.elem (i, j+1) = Complex (real_part, -imag_part);
-		}
-	      j++;
-	    }
-	}
+              for (octave_idx_type i = 0; i < nvr; i++)
+                {
+                  double real_part = vr.elem (i, j);
+                  double imag_part = vr.elem (i, j+1);
+                  v.elem (i, j) = Complex (real_part, imag_part);
+                  v.elem (i, j+1) = Complex (real_part, -imag_part);
+                }
+              j++;
+            }
+        }
     }
   else
     (*current_liboctave_error_handler) ("dggev workspace query failed");
 
   return info;
 }
 
 octave_idx_type 
@@ -624,65 +624,65 @@ EIG::symmetric_init (const Matrix& a, co
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   double dummy_work;
 
   F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   F77_CONST_CHAR_ARG2 ("U", 1),
-			   n, atmp_data, n, 
-			   btmp_data, n, 
-			   pwr, &dummy_work, lwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, atmp_data, n, 
+                           btmp_data, n, 
+                           pwr, &dummy_work, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<double> work (lwork);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       F77_CONST_CHAR_ARG2 ("U", 1),
-			       n, atmp_data, n, 
-			       btmp_data, n, 
-			       pwr, pwork, lwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 ("U", 1),
+                               n, atmp_data, n, 
+                               btmp_data, n, 
+                               pwr, pwork, lwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in dsygv");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in dsygv");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("dsygv failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("dsygv failed to converge");
+          return info;
+        }
 
       lambda = ComplexColumnVector (wr);
       v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
     }
   else
     (*current_liboctave_error_handler) ("dsygv workspace query failed");
 
   return info;
 }
 
 octave_idx_type
 EIG::init (const ComplexMatrix& a, const ComplexMatrix& b, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     {
       (*current_liboctave_error_handler)
-	("EIG: matrix contains Inf or NaN values");
+        ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols())
     {
@@ -697,20 +697,20 @@ EIG::init (const ComplexMatrix& a, const
     }
 
   octave_idx_type info = 0;
 
   ComplexMatrix tmp = b;
   Complex*tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-			     n, tmp_data, n, 
-			     info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             n, tmp_data, n, 
+                             info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (a.is_hermitian () && b.is_hermitian () && info == 0)
     return hermitian_init (a, calc_ev);
 
   ComplexMatrix atmp = a;
   Complex *atmp_data = atmp.fortran_vec ();
 
   ComplexMatrix btmp = b;
@@ -732,48 +732,48 @@ EIG::init (const ComplexMatrix& a, const
   octave_idx_type lrwork = 8*n;
   Array<double> rwork (lrwork);
   double *prwork = rwork.fortran_vec ();
 
   Complex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			   F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   n, atmp_data, n, btmp_data, n, 
-			   palpha, pbeta, dummy, idummy,
-			   pv, n, &dummy_work, lwork, prwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, atmp_data, n, btmp_data, n, 
+                           palpha, pbeta, dummy, idummy,
+                           pv, n, &dummy_work, lwork, prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<Complex> work (lwork);
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			       F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       n, atmp_data, n, btmp_data, n, 
-			       palpha, pbeta, dummy, idummy,
-			       pv, n, pwork, lwork, prwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                               n, atmp_data, n, btmp_data, n, 
+                               palpha, pbeta, dummy, idummy,
+                               pv, n, pwork, lwork, prwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
       
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in zggev");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in zggev");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("zggev failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("zggev failed to converge");
+          return info;
+        }
 
       lambda.resize (n);
 
       for (octave_idx_type j = 0; j < n; j++)
         lambda.elem (j) = alpha.elem (j) / beta.elem(j);
 
       v = vtmp;
     }
@@ -815,49 +815,49 @@ EIG::hermitian_init (const ComplexMatrix
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<double> rwork (lrwork);
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   F77_CONST_CHAR_ARG2 ("U", 1),
-			   n, atmp_data, n, 
-			   btmp_data, n,
-			   pwr, &dummy_work, lwork,
-			   prwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, atmp_data, n, 
+                           btmp_data, n,
+                           pwr, &dummy_work, lwork,
+                           prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<Complex> work (lwork);
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       F77_CONST_CHAR_ARG2 ("U", 1),
-			       n, atmp_data, n, 
-			       btmp_data, n, 
-			       pwr, pwork, lwork, prwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 ("U", 1),
+                               n, atmp_data, n, 
+                               btmp_data, n, 
+                               pwr, pwork, lwork, prwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("zhegv failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("zhegv failed to converge");
+          return info;
+        }
 
       lambda = ComplexColumnVector (wr);
       v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
     }
   else
     (*current_liboctave_error_handler) ("zhegv workspace query failed");
 
   return info;
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -31,65 +31,65 @@ along with Octave; see the file COPYING.
 
 #include "LSODE.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-math.h"
 #include "quit.h"
 
 typedef octave_idx_type (*lsode_fcn_ptr) (const octave_idx_type&, const double&, double*,
-			      double*, octave_idx_type&);
+                              double*, octave_idx_type&);
 
 typedef octave_idx_type (*lsode_jac_ptr) (const octave_idx_type&, const double&, double*,
-			      const octave_idx_type&, const octave_idx_type&, double*, const
-			      octave_idx_type&);
+                              const octave_idx_type&, const octave_idx_type&, double*, const
+                              octave_idx_type&);
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dlsode, DLSODE) (lsode_fcn_ptr, octave_idx_type&, double*, double&,
-			     double&, octave_idx_type&, double&, const double*, octave_idx_type&,
-			     octave_idx_type&, octave_idx_type&, double*, octave_idx_type&, octave_idx_type*, octave_idx_type&,
-			     lsode_jac_ptr, octave_idx_type&);
+                             double&, octave_idx_type&, double&, const double*, octave_idx_type&,
+                             octave_idx_type&, octave_idx_type&, double*, octave_idx_type&, octave_idx_type*, octave_idx_type&,
+                             lsode_jac_ptr, octave_idx_type&);
 }
 
 static ODEFunc::ODERHSFunc user_fun;
 static ODEFunc::ODEJacFunc user_jac;
 static ColumnVector *tmp_x;
 
 static octave_idx_type
 lsode_f (const octave_idx_type& neq, const double& time, double *,
-	 double *deriv, octave_idx_type& ierr) 
+         double *deriv, octave_idx_type& ierr) 
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   ColumnVector tmp_deriv;
 
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
 
   tmp_deriv = (*user_fun) (*tmp_x, time);
 
   if (tmp_deriv.length () == 0)
     ierr = -1;
   else
     {
       for (octave_idx_type i = 0; i < neq; i++)
-	deriv [i] = tmp_deriv.elem (i);
+        deriv [i] = tmp_deriv.elem (i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 static octave_idx_type
 lsode_j (const octave_idx_type& neq, const double& time, double *,
-	 const octave_idx_type&, const octave_idx_type&, double *pd, const octave_idx_type& nrowpd)
+         const octave_idx_type&, const octave_idx_type&, double *pd, const octave_idx_type& nrowpd)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   Matrix tmp_jac (neq, neq);
 
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
@@ -122,75 +122,75 @@ LSODE::do_integrate (double tout)
 
       octave_idx_type n = size ();
 
       nn = n;
 
       octave_idx_type max_maxord = 0;
 
       if (integration_method () == "stiff")
-	{
-	  max_maxord = 5;
+        {
+          max_maxord = 5;
 
-	  if (jac)
-	    method_flag = 21;
-	  else
-	    method_flag = 22;
+          if (jac)
+            method_flag = 21;
+          else
+            method_flag = 22;
 
-	  liw = 20 + n;
-	  lrw = 22 + n * (9 + n);
-	}
+          liw = 20 + n;
+          lrw = 22 + n * (9 + n);
+        }
       else
-	{
-	  max_maxord = 12;
+        {
+          max_maxord = 12;
 
-	  method_flag = 10;
+          method_flag = 10;
 
-	  liw = 20;
-	  lrw = 22 + 16 * n;
-	}
+          liw = 20;
+          lrw = 22 + 16 * n;
+        }
 
       maxord = maximum_order ();
 
       iwork.resize (liw);
 
       for (octave_idx_type i = 4; i < 9; i++)
-	iwork(i) = 0;
+        iwork(i) = 0;
 
       rwork.resize (lrw);
 
       for (octave_idx_type i = 4; i < 9; i++)
-	rwork(i) = 0;
+        rwork(i) = 0;
 
       if (maxord >= 0)
-	{
-	  if (maxord > 0 && maxord <= max_maxord)
-	    {
-	      iwork(4) = maxord;
-	      iopt = 1;
-	    }	  
-	  else
-	    {
-	      (*current_liboctave_error_handler)
-		("lsode: invalid value for maximum order");
-	      integration_error = true;
-	      return retval;
-	    }
-	}
+        {
+          if (maxord > 0 && maxord <= max_maxord)
+            {
+              iwork(4) = maxord;
+              iopt = 1;
+            }     
+          else
+            {
+              (*current_liboctave_error_handler)
+                ("lsode: invalid value for maximum order");
+              integration_error = true;
+              return retval;
+            }
+        }
 
       if (stop_time_set)
-	{
-	  itask = 4;
-	  rwork(0) = stop_time;
-	  iopt = 1;
-	}
+        {
+          itask = 4;
+          rwork(0) = stop_time;
+          iopt = 1;
+        }
       else
-	{
-	  itask = 1;
-	}
+        {
+          itask = 1;
+        }
 
       px = x.fortran_vec ();
 
       piwork = iwork.fortran_vec ();
       prwork = rwork.fortran_vec ();
 
       restart = false;
 
@@ -203,108 +203,108 @@ LSODE::do_integrate (double tout)
       tmp_x = &x;
 
       user_fun = function ();
       user_jac = jacobian_function ();
 
       ColumnVector xdot = (*user_fun) (x, t);
 
       if (x.length () != xdot.length ())
-	{
-	  (*current_liboctave_error_handler)
-	    ("lsode: inconsistent sizes for state and derivative vectors");
+        {
+          (*current_liboctave_error_handler)
+            ("lsode: inconsistent sizes for state and derivative vectors");
 
-	  integration_error = true;
-	  return retval;
-	}
+          integration_error = true;
+          return retval;
+        }
 
       ODEFunc::reset = false;
 
       // LSODE_options
 
       rel_tol = relative_tolerance ();
       abs_tol = absolute_tolerance ();
 
       octave_idx_type abs_tol_len = abs_tol.length ();
 
       if (abs_tol_len == 1)
-	itol = 1;
+        itol = 1;
       else if (abs_tol_len == n)
-	itol = 2;
+        itol = 2;
       else
-	{
-	  (*current_liboctave_error_handler)
-	    ("lsode: inconsistent sizes for state and absolute tolerance vectors");
+        {
+          (*current_liboctave_error_handler)
+            ("lsode: inconsistent sizes for state and absolute tolerance vectors");
 
-	  integration_error = true;
-	  return retval;
-	}
+          integration_error = true;
+          return retval;
+        }
 
       double iss = initial_step_size ();
       if (iss >= 0.0)
-	{
-	  rwork(4) = iss;
-	  iopt = 1;
-	}
+        {
+          rwork(4) = iss;
+          iopt = 1;
+        }
 
       double maxss = maximum_step_size ();
       if (maxss >= 0.0)
-	{
-	  rwork(5) = maxss;
-	  iopt = 1;
-	}
+        {
+          rwork(5) = maxss;
+          iopt = 1;
+        }
 
       double minss = minimum_step_size ();
       if (minss >= 0.0)
-	{
-	  rwork(6) = minss;
-	  iopt = 1;
-	}
+        {
+          rwork(6) = minss;
+          iopt = 1;
+        }
 
       octave_idx_type sl = step_limit ();
       if (sl > 0)
-	{
-	  iwork(5) = sl;
-	  iopt = 1;
-	}
+        {
+          iwork(5) = sl;
+          iopt = 1;
+        }
 
       pabs_tol = abs_tol.fortran_vec ();
 
       LSODE_options::reset = false;
     }
 
   F77_XFCN (dlsode, DLSODE, (lsode_f, nn, px, t, tout, itol, rel_tol,
-			     pabs_tol, itask, istate, iopt, prwork, lrw,
-			     piwork, liw, lsode_j, method_flag));
+                             pabs_tol, itask, istate, iopt, prwork, lrw,
+                             piwork, liw, lsode_j, method_flag));
 
   switch (istate)
     {
     case 1:  // prior to initial integration step.
     case 2:  // lsode was successful.
       retval = x;
       t = tout;
       break;
 
     case -1:  // excess work done on this call (perhaps wrong mf).
     case -2:  // excess accuracy requested (tolerances too small).
     case -3:  // invalid input detected (see printed message).
     case -4:  // repeated error test failures (check all inputs).
     case -5:  // repeated convergence failures (perhaps bad jacobian
-	      // supplied or wrong choice of mf or tolerances).
+              // supplied or wrong choice of mf or tolerances).
     case -6:  // error weight became zero during problem. (solution
-	      // component i vanished, and atol or atol(i) = 0.)
+              // component i vanished, and atol or atol(i) = 0.)
     case -13: // return requested in user-supplied function.
       integration_error = true;
       break;
 
     default:
       integration_error = true;
       (*current_liboctave_error_handler)
-	("unrecognized value of istate (= %d) returned from lsode",
-	 istate);
+        ("unrecognized value of istate (= %d) returned from lsode",
+         istate);
       break;
     }
 
   return retval;
 }
 
 std::string
 LSODE::error_message (void) const
@@ -319,54 +319,54 @@ LSODE::error_message (void) const
     {
     case 1:
       retval = "prior to initial integration step";
       break;
 
     case 2:
       retval = "successful exit";
       break;
-	  
+          
     case 3:
       retval = "prior to continuation call with modified parameters";
       break;
-	  
+          
     case -1:
       retval = std::string ("excess work on this call (t = ")
-	+ t_curr + "; perhaps wrong integration method)";
+        + t_curr + "; perhaps wrong integration method)";
       break;
 
     case -2:
       retval = "excess accuracy requested (tolerances too small)";
       break;
 
     case -3:
       retval = "invalid input detected (see printed message)";
       break;
 
     case -4:
       retval = std::string ("repeated error test failures (t = ")
-	+ t_curr + "check all inputs)";
+        + t_curr + "check all inputs)";
       break;
 
     case -5:
       retval = std::string ("repeated convergence failures (t = ")
-	+ t_curr
-	+ "perhaps bad jacobian supplied or wrong choice of integration method or tolerances)";
+        + t_curr
+        + "perhaps bad jacobian supplied or wrong choice of integration method or tolerances)";
       break;
 
     case -6:
       retval = std::string ("error weight became zero during problem. (t = ")
-	+ t_curr
-	+ "; solution component i vanished, and atol or atol(i) == 0)";
+        + t_curr
+        + "; solution component i vanished, and atol or atol(i) == 0)";
       break;
 
     case -13:
       retval = "return requested in user-supplied function (t = "
-	+ t_curr + ")";
+        + t_curr + ")";
       break;
 
     default:
       retval = "unknown error state";
       break;
     }
 
   return retval;
@@ -380,28 +380,28 @@ LSODE::do_integrate (const ColumnVector&
   octave_idx_type n_out = tout.capacity ();
   octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
 
       for (octave_idx_type i = 0; i < n; i++)
-	retval.elem (0, i) = x.elem (i);
+        retval.elem (0, i) = x.elem (i);
 
       for (octave_idx_type j = 1; j < n_out; j++)
-	{
-	  ColumnVector x_next = do_integrate (tout.elem (j));
+        {
+          ColumnVector x_next = do_integrate (tout.elem (j));
 
-	  if (integration_error)
-	    return retval;
+          if (integration_error)
+            return retval;
 
-	  for (octave_idx_type i = 0; i < n; i++)
-	    retval.elem (j, i) = x_next.elem (i);
-	}
+          for (octave_idx_type i = 0; i < n; i++)
+            retval.elem (j, i) = x_next.elem (i);
+        }
     }
 
   return retval;
 }
 
 Matrix
 LSODE::do_integrate (const ColumnVector& tout, const ColumnVector& tcrit)
 {
@@ -410,90 +410,90 @@ LSODE::do_integrate (const ColumnVector&
   octave_idx_type n_out = tout.capacity ();
   octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
 
       for (octave_idx_type i = 0; i < n; i++)
-	retval.elem (0, i) = x.elem (i);
+        retval.elem (0, i) = x.elem (i);
 
       octave_idx_type n_crit = tcrit.capacity ();
 
       if (n_crit > 0)
-	{
-	  octave_idx_type i_crit = 0;
-	  octave_idx_type i_out = 1;
-	  double next_crit = tcrit.elem (0);
-	  double next_out;
-	  while (i_out < n_out)
-	    {
-	      bool do_restart = false;
+        {
+          octave_idx_type i_crit = 0;
+          octave_idx_type i_out = 1;
+          double next_crit = tcrit.elem (0);
+          double next_out;
+          while (i_out < n_out)
+            {
+              bool do_restart = false;
 
-	      next_out = tout.elem (i_out);
-	      if (i_crit < n_crit)
-		next_crit = tcrit.elem (i_crit);
+              next_out = tout.elem (i_out);
+              if (i_crit < n_crit)
+                next_crit = tcrit.elem (i_crit);
 
-	      octave_idx_type save_output;
-	      double t_out;
+              octave_idx_type save_output;
+              double t_out;
 
-	      if (next_crit == next_out)
-		{
-		  set_stop_time (next_crit);
-		  t_out = next_out;
-		  save_output = 1;
-		  i_out++;
-		  i_crit++;
-		  do_restart = true;
-		}
-	      else if (next_crit < next_out)
-		{
-		  if (i_crit < n_crit)
-		    {
-		      set_stop_time (next_crit);
-		      t_out = next_crit;
-		      save_output = 0;
-		      i_crit++;
-		      do_restart = true;
-		    }
-		  else
-		    {
-		      clear_stop_time ();
-		      t_out = next_out;
-		      save_output = 1;
-		      i_out++;
-		    }
-		}
-	      else
-		{
-		  set_stop_time (next_crit);
-		  t_out = next_out;
-		  save_output = 1;
-		  i_out++;
-		}
+              if (next_crit == next_out)
+                {
+                  set_stop_time (next_crit);
+                  t_out = next_out;
+                  save_output = 1;
+                  i_out++;
+                  i_crit++;
+                  do_restart = true;
+                }
+              else if (next_crit < next_out)
+                {
+                  if (i_crit < n_crit)
+                    {
+                      set_stop_time (next_crit);
+                      t_out = next_crit;
+                      save_output = 0;
+                      i_crit++;
+                      do_restart = true;
+                    }
+                  else
+                    {
+                      clear_stop_time ();
+                      t_out = next_out;
+                      save_output = 1;
+                      i_out++;
+                    }
+                }
+              else
+                {
+                  set_stop_time (next_crit);
+                  t_out = next_out;
+                  save_output = 1;
+                  i_out++;
+                }
 
-	      ColumnVector x_next = do_integrate (t_out);
+              ColumnVector x_next = do_integrate (t_out);
 
-	      if (integration_error)
-		return retval;
+              if (integration_error)
+                return retval;
 
-	      if (save_output)
-		{
-		  for (octave_idx_type i = 0; i < n; i++)
-		    retval.elem (i_out-1, i) = x_next.elem (i);
-		}
+              if (save_output)
+                {
+                  for (octave_idx_type i = 0; i < n; i++)
+                    retval.elem (i_out-1, i) = x_next.elem (i);
+                }
 
-	      if (do_restart)
-		force_restart ();
-	    }
-	}
+              if (do_restart)
+                force_restart ();
+            }
+        }
       else
-	{
-	  retval = do_integrate (tout);
+        {
+          retval = do_integrate (tout);
 
-	  if (integration_error)
-	    return retval;
-	}
+          if (integration_error)
+            return retval;
+        }
     }
 
   return retval;
 }
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -76,40 +76,40 @@ operator += (MSparse<T>& a, const MSpars
                     r.data(jx) = a.data(ja) + 0.;
                     jx++;
                     ja++;
                     ja_lt_max= ja < ja_max;
                   }
                 else if (( !ja_lt_max ) ||
                      (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
                   {
-		    r.ridx(jx) = b.ridx(jb);
-		    r.data(jx) = 0. + b.data(jb);
-		    jx++;
+                    r.ridx(jx) = b.ridx(jb);
+                    r.data(jx) = 0. + b.data(jb);
+                    jx++;
                     jb++;
                     jb_lt_max= jb < jb_max;
                   }
                 else
                   {
-		     if ((a.data(ja) + b.data(jb)) != 0.)
-	               {
+                     if ((a.data(ja) + b.data(jb)) != 0.)
+                       {
                           r.data(jx) = a.data(ja) + b.data(jb);
                           r.ridx(jx) = a.ridx(ja);
                           jx++;
                        }
                      ja++;
                      ja_lt_max= ja < ja_max;
                      jb++;
                      jb_lt_max= jb < jb_max;
                   }
               }
             r.cidx(i+1) = jx;
           }
        
-	a = r.maybe_compress ();
+        a = r.maybe_compress ();
       }
 
     return a;
 }
 
 template <class T>
 MSparse<T>&
 operator -= (MSparse<T>& a, const MSparse<T>& b)
@@ -149,78 +149,78 @@ operator -= (MSparse<T>& a, const MSpars
                     r.data(jx) = a.data(ja) - 0.;
                     jx++;
                     ja++;
                     ja_lt_max= ja < ja_max;
                   }
                 else if (( !ja_lt_max ) ||
                      (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
                   {
-		    r.ridx(jx) = b.ridx(jb);
-		    r.data(jx) = 0. - b.data(jb);
-		    jx++;
+                    r.ridx(jx) = b.ridx(jb);
+                    r.data(jx) = 0. - b.data(jb);
+                    jx++;
                     jb++;
                     jb_lt_max= jb < jb_max;
                   }
                 else
                   {
-		     if ((a.data(ja) - b.data(jb)) != 0.)
-	               {
+                     if ((a.data(ja) - b.data(jb)) != 0.)
+                       {
                           r.data(jx) = a.data(ja) - b.data(jb);
                           r.ridx(jx) = a.ridx(ja);
                           jx++;
                        }
                      ja++;
                      ja_lt_max= ja < ja_max;
                      jb++;
                      jb_lt_max= jb < jb_max;
                   }
               }
             r.cidx(i+1) = jx;
           }
        
-	a = r.maybe_compress ();
+        a = r.maybe_compress ();
       }
 
     return a;
 }
 
 // Element by element MSparse by scalar ops.
 
 #define SPARSE_A2S_OP_1(OP) \
   template <class T> \
   MArray2<T> \
   operator OP (const MSparse<T>& a, const T& s) \
   { \
     octave_idx_type nr = a.rows (); \
     octave_idx_type nc = a.cols (); \
  \
-    MArray2<T> r (nr, nc, (0.0 OP s));	\
+    MArray2<T> r (nr, nc, (0.0 OP s));  \
  \
     for (octave_idx_type j = 0; j < nc; j++) \
-      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)	\
-        r.elem (a.ridx (i), j) = a.data (i) OP s;	\
+      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++) \
+        r.elem (a.ridx (i), j) = a.data (i) OP s;       \
     return r; \
   }
 
 #define SPARSE_A2S_OP_2(OP) \
   template <class T> \
   MSparse<T> \
   operator OP (const MSparse<T>& a, const T& s) \
   { \
     octave_idx_type nr = a.rows (); \
     octave_idx_type nc = a.cols (); \
     octave_idx_type nz = a.nnz (); \
  \
     MSparse<T> r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
-	r.data(i) = a.data(i) OP s; \
-	r.ridx(i) = a.ridx(i); \
+        r.data(i) = a.data(i) OP s; \
+        r.ridx(i) = a.ridx(i); \
       } \
     for (octave_idx_type i = 0; i < nc + 1; i++) \
       r.cidx(i) = a.cidx(i); \
     r.maybe_compress (true); \
     return r; \
   }
 
 
@@ -234,39 +234,39 @@ SPARSE_A2S_OP_2 (/)
 #define SPARSE_SA2_OP_1(OP) \
   template <class T> \
   MArray2<T> \
   operator OP (const T& s, const MSparse<T>& a) \
   { \
     octave_idx_type nr = a.rows (); \
     octave_idx_type nc = a.cols (); \
  \
-    MArray2<T> r (nr, nc, (s OP 0.0));	\
+    MArray2<T> r (nr, nc, (s OP 0.0));  \
  \
     for (octave_idx_type j = 0; j < nc; j++) \
-      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)	\
-        r.elem (a.ridx (i), j) = s OP a.data (i);	\
+      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++) \
+        r.elem (a.ridx (i), j) = s OP a.data (i);       \
     return r; \
   }
 
 #define SPARSE_SA2_OP_2(OP) \
   template <class T> \
   MSparse<T> \
   operator OP (const T& s, const MSparse<T>& a) \
   { \
     octave_idx_type nr = a.rows (); \
     octave_idx_type nc = a.cols (); \
     octave_idx_type nz = a.nnz (); \
  \
     MSparse<T> r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
-	r.data(i) = s OP a.data(i); \
-	r.ridx(i) = a.ridx(i); \
+        r.data(i) = s OP a.data(i); \
+        r.ridx(i) = a.ridx(i); \
       } \
     for (octave_idx_type i = 0; i < nc + 1; i++) \
       r.cidx(i) = a.cidx(i); \
     r.maybe_compress (true); \
     return r; \
   }
 
 SPARSE_SA2_OP_1 (+)
@@ -290,60 +290,60 @@ SPARSE_SA2_OP_2 (/)
     octave_idx_type b_nc = b.cols (); \
  \
     if (a_nr == 1 && a_nc == 1) \
       { \
         if (a.elem(0,0) == 0.) \
           r =  OP MSparse<T> (b); \
         else \
           { \
-	    r = MSparse<T> (b_nr, b_nc, a.data(0) OP 0.); \
+            r = MSparse<T> (b_nr, b_nc, a.data(0) OP 0.); \
             \
             for (octave_idx_type j = 0 ; j < b_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * b_nr; \
                 for (octave_idx_type i = b.cidx(j) ; i < b.cidx(j+1) ; i++) \
                   { \
                    octave_quit (); \
                    r.data(idxj + b.ridx(i)) = a.data(0) OP b.data(i); \
-		  } \
+                  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (b_nr == 1 && b_nc == 1) \
       { \
         if (b.elem(0,0) == 0.) \
           r = MSparse<T> (a); \
         else \
           { \
-	    r = MSparse<T> (a_nr, a_nc, 0. OP b.data(0)); \
+            r = MSparse<T> (a_nr, a_nc, 0. OP b.data(0)); \
             \
             for (octave_idx_type j = 0 ; j < a_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * a_nr; \
                 for (octave_idx_type i = a.cidx(j) ; i < a.cidx(j+1) ; i++) \
                   { \
                     octave_quit (); \
                     r.data(idxj + a.ridx(i)) = a.data(i) OP b.data(0); \
-		  } \
+                  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant ("operator " # OP, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
         r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ())); \
         \
         octave_idx_type jx = 0; \
-	r.cidx (0) = 0; \
+        r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < a_nc ; i++) \
           { \
             octave_idx_type  ja = a.cidx(i); \
             octave_idx_type  ja_max = a.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
             octave_idx_type  jb = b.cidx(i); \
             octave_idx_type  jb_max = b.cidx(i+1); \
@@ -359,46 +359,46 @@ SPARSE_SA2_OP_2 (/)
                     r.data(jx) = a.data(ja) OP 0.; \
                     jx++; \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
                      (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) ) \
                   { \
-		    r.ridx(jx) = b.ridx(jb); \
-		    r.data(jx) = 0. OP b.data(jb); \
-		    jx++; \
+                    r.ridx(jx) = b.ridx(jb); \
+                    r.data(jx) = 0. OP b.data(jb); \
+                    jx++; \
                     jb++; \
                     jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
-		     if ((a.data(ja) OP b.data(jb)) != 0.) \
-	               { \
+                     if ((a.data(ja) OP b.data(jb)) != 0.) \
+                       { \
                           r.data(jx) = a.data(ja) OP b.data(jb); \
                           r.ridx(jx) = a.ridx(ja); \
                           jx++; \
                        } \
                      ja++; \
                      ja_lt_max= ja < ja_max; \
                      jb++; \
                      jb_lt_max= jb < jb_max; \
                   } \
               } \
             r.cidx(i+1) = jx; \
           } \
         \
-	r.maybe_compress (); \
+        r.maybe_compress (); \
       } \
  \
     return r; \
   }
 
-#define SPARSE_A2A2_FCN_1(FCN, OP)	\
+#define SPARSE_A2A2_FCN_1(FCN, OP)      \
   template <class T> \
   MSparse<T> \
   FCN (const MSparse<T>& a, const MSparse<T>& b) \
   { \
     MSparse<T> r; \
  \
     octave_idx_type a_nr = a.rows (); \
     octave_idx_type a_nc = a.cols (); \
@@ -407,34 +407,34 @@ SPARSE_SA2_OP_2 (/)
     octave_idx_type b_nc = b.cols (); \
  \
     if (a_nr == 1 && a_nc == 1) \
       { \
         if (a.elem(0,0) == 0.) \
           r = MSparse<T> (b_nr, b_nc); \
         else \
           { \
-	    r = MSparse<T> (b); \
+            r = MSparse<T> (b); \
             octave_idx_type b_nnz = b.nnz(); \
             \
             for (octave_idx_type i = 0 ; i < b_nnz ; i++) \
               { \
                 octave_quit (); \
                 r.data (i) = a.data(0) OP r.data(i); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (b_nr == 1 && b_nc == 1) \
       { \
         if (b.elem(0,0) == 0.) \
           r = MSparse<T> (a_nr, a_nc); \
         else \
           { \
-	    r = MSparse<T> (a); \
+            r = MSparse<T> (a); \
             octave_idx_type a_nnz = a.nnz(); \
             \
             for (octave_idx_type i = 0 ; i < a_nnz ; i++) \
               { \
                 octave_quit (); \
                 r.data (i) = r.data(i) OP b.data(0); \
               } \
             r.maybe_compress (); \
@@ -442,17 +442,17 @@ SPARSE_SA2_OP_2 (/)
       } \
     else if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
         r = MSparse<T> (a_nr, a_nc, (a.nnz () > b.nnz () ? a.nnz () : b.nnz ())); \
         \
         octave_idx_type jx = 0; \
-	r.cidx (0) = 0; \
+        r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < a_nc ; i++) \
           { \
             octave_idx_type  ja = a.cidx(i); \
             octave_idx_type  ja_max = a.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
             octave_idx_type  jb = b.cidx(i); \
             octave_idx_type  jb_max = b.cidx(i+1); \
@@ -468,36 +468,36 @@ SPARSE_SA2_OP_2 (/)
                   } \
                 else if (( !ja_lt_max ) || \
                      (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) ) \
                   { \
                      jb++; jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
-		     if ((a.data(ja) OP b.data(jb)) != 0.) \
-	               { \
+                     if ((a.data(ja) OP b.data(jb)) != 0.) \
+                       { \
                           r.data(jx) = a.data(ja) OP b.data(jb); \
                           r.ridx(jx) = a.ridx(ja); \
                           jx++; \
                        } \
                      ja++; ja_lt_max= ja < ja_max; \
                      jb++; jb_lt_max= jb < jb_max; \
                   } \
               } \
             r.cidx(i+1) = jx; \
           } \
         \
-	r.maybe_compress (); \
+        r.maybe_compress (); \
       } \
  \
     return r; \
   }
 
-#define SPARSE_A2A2_FCN_2(FCN, OP)	\
+#define SPARSE_A2A2_FCN_2(FCN, OP)      \
   template <class T> \
   MSparse<T> \
   FCN (const MSparse<T>& a, const MSparse<T>& b) \
   { \
     MSparse<T> r; \
     T Zero = T (); \
  \
     octave_idx_type a_nr = a.rows (); \
@@ -524,17 +524,17 @@ SPARSE_SA2_OP_2 (/)
             for (octave_idx_type j = 0 ; j < b_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * b_nr; \
                 for (octave_idx_type i = b.cidx(j) ; i < b.cidx(j+1) ; i++) \
                   { \
                     octave_quit (); \
                     r.data(idxj + b.ridx(i)) = val OP b.data(i); \
-		  } \
+                  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (b_nr == 1 && b_nc == 1) \
       { \
         T val = b.elem (0,0); \
         T fill = T() OP val; \
@@ -552,17 +552,17 @@ SPARSE_SA2_OP_2 (/)
             for (octave_idx_type j = 0 ; j < a_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * a_nr; \
                 for (octave_idx_type i = a.cidx(j) ; i < a.cidx(j+1) ; i++) \
                   { \
                     octave_quit (); \
                     r.data(idxj + a.ridx(i)) = a.data(i) OP val; \
-		  } \
+                  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
@@ -579,35 +579,35 @@ SPARSE_SA2_OP_2 (/)
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb)))) \
                   { \
-		     r.elem (a.ridx(ja),i) = a.data(ja) OP Zero; \
+                     r.elem (a.ridx(ja),i) = a.data(ja) OP Zero; \
                      ja++; ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
                      (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) ) \
                   { \
-		     r.elem (b.ridx(jb),i) = Zero OP b.data(jb);	\
+                     r.elem (b.ridx(jb),i) = Zero OP b.data(jb);        \
                      jb++; jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
                      r.elem (a.ridx(ja),i) = a.data(ja) OP b.data(jb); \
                      ja++; ja_lt_max= ja < ja_max; \
                      jb++; jb_lt_max= jb < jb_max; \
                   } \
               } \
           } \
         \
-	r.maybe_compress (true); \
+        r.maybe_compress (true); \
       } \
  \
     return r; \
   }
 
 SPARSE_A2A2_OP (+)
 SPARSE_A2A2_OP (-)
 SPARSE_A2A2_FCN_1 (product,    *)
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
--- a/liboctave/MatrixType.cc
+++ b/liboctave/MatrixType.cc
@@ -47,17 +47,17 @@ MatrixType::MatrixType (const MatrixType
   : typ (a.typ), sp_bandden (a.sp_bandden), bandden (a.bandden), 
     upper_band (a.upper_band), lower_band (a.lower_band), 
     dense (a.dense), full (a.full), nperm (a.nperm)
 { 
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
-	perm[i] = a.perm[i];
+        perm[i] = a.perm[i];
     }
 }
 
 template<class T> 
 MatrixType::matrix_type 
 matrix_real_probe (const MArray2<T>& a)
 {
   MatrixType::matrix_type typ;
@@ -72,45 +72,45 @@ matrix_real_probe (const MArray2<T>& a)
       bool lower = true;
       bool hermitian = true;
 
       // do the checks for lower/upper/hermitian all in one pass.
       ColumnVector diag(ncols);
 
       for (octave_idx_type j = 0; 
            j < ncols && upper; j++)
-	{
+        {
           T d = a.elem (j,j);
           upper = upper && (d != zero);
           lower = lower && (d != zero);
           hermitian = hermitian && (d > zero);
           diag(j) = d;
         }
 
       for (octave_idx_type j = 0; 
            j < ncols && (upper || lower || hermitian); j++)
-	{
+        {
           for (octave_idx_type i = 0; i < j; i++)
             {
               double aij = a.elem (i,j), aji = a.elem (j,i);
               lower = lower && (aij == zero);
               upper = upper && (aji == zero);
               hermitian = hermitian && (aij == aji 
                                         && aij*aij < diag(i)*diag(j));
             }
-	}
+        }
 
       if (upper)
-	typ = MatrixType::Upper;
+        typ = MatrixType::Upper;
       else if (lower)
-	typ = MatrixType::Lower;
+        typ = MatrixType::Lower;
       else if (hermitian)
-	typ = MatrixType::Hermitian;
+        typ = MatrixType::Hermitian;
       else 
-	typ = MatrixType::Full;
+        typ = MatrixType::Full;
     }
   else
     typ = MatrixType::Rectangular;
 
   return typ;
 }
 
 template<class T> 
@@ -129,46 +129,46 @@ matrix_complex_probe (const MArray2<T>& 
       bool lower = true;
       bool hermitian = true;
 
       // do the checks for lower/upper/hermitian all in one pass.
       ColumnVector diag(ncols);
 
       for (octave_idx_type j = 0; 
            j < ncols && upper; j++)
-	{
+        {
           T d = a.elem (j,j);
           upper = upper && (d != zero);
           lower = lower && (d != zero);
           hermitian = hermitian && (d.real() > zero && d.imag() == zero);
           diag (j) = d.real();
         }
 
       for (octave_idx_type j = 0; 
            j < ncols && (upper || lower || hermitian); j++)
-	{
+        {
           for (octave_idx_type i = 0; i < j; i++)
             {
               T aij = a.elem (i,j), aji = a.elem (j,i);
               lower = lower && (aij == zero);
               upper = upper && (aji == zero);
               hermitian = hermitian && (aij == std::conj (aji)
                                         && std::norm (aij) < diag(i)*diag(j));
             }
-	}
+        }
 
 
       if (upper)
-	typ = MatrixType::Upper;
+        typ = MatrixType::Upper;
       else if (lower)
-	typ = MatrixType::Lower;
+        typ = MatrixType::Lower;
       else if (hermitian)
-	typ = MatrixType::Hermitian;
+        typ = MatrixType::Hermitian;
       else if (ncols == nrows)
-	typ = MatrixType::Full;
+        typ = MatrixType::Full;
     }
   else
     typ = MatrixType::Rectangular;
 
   return typ;
 }
 
 MatrixType::MatrixType (const Matrix &a)
@@ -223,262 +223,262 @@ MatrixType::MatrixType (const SparseMatr
   typ = MatrixType::Full;
 
   if (nnz == nm)
     {
       matrix_type tmp_typ = MatrixType::Diagonal;
       octave_idx_type i;
       // Maybe the matrix is diagonal
       for (i = 0; i < nm; i++)
-	{
-	  if (a.cidx(i+1) != a.cidx(i) + 1)
-	    {
-	      tmp_typ = MatrixType::Full;
-	      break;
-	    }
-	  if (a.ridx(i) != i)
-	    {
-	      tmp_typ = MatrixType::Permuted_Diagonal;
-	      break;
-	    }
-	}
-	  
+        {
+          if (a.cidx(i+1) != a.cidx(i) + 1)
+            {
+              tmp_typ = MatrixType::Full;
+              break;
+            }
+          if (a.ridx(i) != i)
+            {
+              tmp_typ = MatrixType::Permuted_Diagonal;
+              break;
+            }
+        }
+          
       if (tmp_typ == MatrixType::Permuted_Diagonal)
-	{
-	  std::vector<bool> found (nrows);
+        {
+          std::vector<bool> found (nrows);
 
-	  for (octave_idx_type j = 0; j < i; j++)
-	    found [j] = true;
-	  for (octave_idx_type j = i; j < nrows; j++)
-	    found [j] = false;
-	      
-	  for (octave_idx_type j = i; j < nm; j++)
-	    {
-	      if ((a.cidx(j+1) > a.cidx(j) + 1)  || 
-		  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
-		{
-		  tmp_typ = MatrixType::Full;
-		  break;
-		}
-	      found [a.ridx(j)] = true;
-	    }
-	}
+          for (octave_idx_type j = 0; j < i; j++)
+            found [j] = true;
+          for (octave_idx_type j = i; j < nrows; j++)
+            found [j] = false;
+              
+          for (octave_idx_type j = i; j < nm; j++)
+            {
+              if ((a.cidx(j+1) > a.cidx(j) + 1)  || 
+                  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
+                {
+                  tmp_typ = MatrixType::Full;
+                  break;
+                }
+              found [a.ridx(j)] = true;
+            }
+        }
       typ = tmp_typ;
     }
 
   if (typ == MatrixType::Full)
     {
       // Search for banded, upper and lower triangular matrices
       bool singular = false;
       upper_band = 0;
       lower_band = 0;
       for (octave_idx_type j = 0; j < ncols; j++)
-	{
-	  bool zero_on_diagonal = false;
-	  if (j < nrows)
-	    {
-	      zero_on_diagonal = true;
-	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		if (a.ridx(i) == j)
-		  {
-		    zero_on_diagonal = false;
-		    break;
-		  }
-	    }
+        {
+          bool zero_on_diagonal = false;
+          if (j < nrows)
+            {
+              zero_on_diagonal = true;
+              for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+                if (a.ridx(i) == j)
+                  {
+                    zero_on_diagonal = false;
+                    break;
+                  }
+            }
 
-	  if (zero_on_diagonal)
-	    {
-	      singular = true;
-	      break;
-	    }
+          if (zero_on_diagonal)
+            {
+              singular = true;
+              break;
+            }
 
-	  if (a.cidx(j+1) != a.cidx(j))
-	    {
-	      octave_idx_type ru = a.ridx(a.cidx(j));
-	      octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
+          if (a.cidx(j+1) != a.cidx(j))
+            {
+              octave_idx_type ru = a.ridx(a.cidx(j));
+              octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
 
-	      if (j - ru > upper_band)
-		upper_band = j - ru;
-		  
-	      if (rl - j > lower_band)
-		lower_band = rl - j;
-	    }
-	}
+              if (j - ru > upper_band)
+                upper_band = j - ru;
+                  
+              if (rl - j > lower_band)
+                lower_band = rl - j;
+            }
+        }
 
       if (!singular)
-	{
-	  bandden = double (nnz) /
-	    (double (ncols) * (double (lower_band) +
-			       double (upper_band)) -
-	     0.5 * double (upper_band + 1) * double (upper_band) -
-	     0.5 * double (lower_band + 1) * double (lower_band));
+        {
+          bandden = double (nnz) /
+            (double (ncols) * (double (lower_band) +
+                               double (upper_band)) -
+             0.5 * double (upper_band + 1) * double (upper_band) -
+             0.5 * double (lower_band + 1) * double (lower_band));
 
-	  if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
-	    {
-	      if (upper_band == 1 && lower_band == 1)
-		typ = MatrixType::Tridiagonal;
-	      else
-		typ = MatrixType::Banded;
+          if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
+            {
+              if (upper_band == 1 && lower_band == 1)
+                typ = MatrixType::Tridiagonal;
+              else
+                typ = MatrixType::Banded;
 
-	      octave_idx_type nnz_in_band = 
-		(upper_band + lower_band + 1) * nrows -
-		(1 + upper_band) * upper_band / 2 -
-		(1 + lower_band) * lower_band / 2;
-	      if (nnz_in_band == nnz)
-		dense = true;
-	      else 
-		dense = false;
-	    }
-	  else if (upper_band == 0)
-	    typ = MatrixType::Lower;
-	  else if (lower_band == 0)
-	    typ = MatrixType::Upper;
+              octave_idx_type nnz_in_band = 
+                (upper_band + lower_band + 1) * nrows -
+                (1 + upper_band) * upper_band / 2 -
+                (1 + lower_band) * lower_band / 2;
+              if (nnz_in_band == nnz)
+                dense = true;
+              else 
+                dense = false;
+            }
+          else if (upper_band == 0)
+            typ = MatrixType::Lower;
+          else if (lower_band == 0)
+            typ = MatrixType::Upper;
 
-	  if (upper_band == lower_band && nrows == ncols)
-	    maybe_hermitian = true;
-	}
+          if (upper_band == lower_band && nrows == ncols)
+            maybe_hermitian = true;
+        }
 
       if (typ == MatrixType::Full)
-	{
-	  // Search for a permuted triangular matrix, and test if
-	  // permutation is singular
+        {
+          // Search for a permuted triangular matrix, and test if
+          // permutation is singular
 
-	  // FIXME
-	  // Perhaps this should be based on a dmperm algorithm
-	  bool found = false;
+          // FIXME
+          // Perhaps this should be based on a dmperm algorithm
+          bool found = false;
 
-	  nperm = ncols;
-	  perm = new octave_idx_type [ncols];
+          nperm = ncols;
+          perm = new octave_idx_type [ncols];
 
-	  for (octave_idx_type i = 0; i < ncols; i++)
-	    perm [i] = -1;
+          for (octave_idx_type i = 0; i < ncols; i++)
+            perm [i] = -1;
 
-	  for (octave_idx_type i = 0; i < nm; i++)
-	    {
-	      found = false;
+          for (octave_idx_type i = 0; i < nm; i++)
+            {
+              found = false;
 
-	      for (octave_idx_type j = 0; j < ncols; j++)
-		{
-		  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
-		      (a.ridx(a.cidx(j+1)-1) == i))
-		    {
-		      perm [i] = j;
-		      found = true;
-		      break;
-		    }
-		}
+              for (octave_idx_type j = 0; j < ncols; j++)
+                {
+                  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
+                      (a.ridx(a.cidx(j+1)-1) == i))
+                    {
+                      perm [i] = j;
+                      found = true;
+                      break;
+                    }
+                }
 
-	      if (!found)
-		break;
-	    }
+              if (!found)
+                break;
+            }
 
-	  if (found)
-	    {
-	      typ = MatrixType::Permuted_Upper;
-	      if (ncols > nrows)
-		{
-		  octave_idx_type k = nrows;
-		  for (octave_idx_type i = 0; i < ncols; i++)
-		    if (perm [i] == -1)
-		      perm[i] = k++;
-		}
-	    }
-	  else if (a.cidx(nm) == a.cidx(ncols))
-	    {
-	      nperm = nrows;
-	      delete [] perm;
-	      perm = new octave_idx_type [nrows];
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
+          if (found)
+            {
+              typ = MatrixType::Permuted_Upper;
+              if (ncols > nrows)
+                {
+                  octave_idx_type k = nrows;
+                  for (octave_idx_type i = 0; i < ncols; i++)
+                    if (perm [i] == -1)
+                      perm[i] = k++;
+                }
+            }
+          else if (a.cidx(nm) == a.cidx(ncols))
+            {
+              nperm = nrows;
+              delete [] perm;
+              perm = new octave_idx_type [nrows];
+              OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
 
-	      for (octave_idx_type i = 0; i < nrows; i++)
-		{
-		  perm [i] = -1;
-		  tmp [i] = -1;
-		}
+              for (octave_idx_type i = 0; i < nrows; i++)
+                {
+                  perm [i] = -1;
+                  tmp [i] = -1;
+                }
 
-	      for (octave_idx_type j = 0; j < ncols; j++)
-		for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		    perm [a.ridx(i)] = j;
+              for (octave_idx_type j = 0; j < ncols; j++)
+                for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+                    perm [a.ridx(i)] = j;
 
-	      found = true;
-	      for (octave_idx_type i = 0; i < nm; i++)
-		if (perm[i] == -1)
-		  {
-		    found = false;
-		    break;
-		  }
-		else
-		  {
-		    tmp[perm[i]] = 1;
-		  }
+              found = true;
+              for (octave_idx_type i = 0; i < nm; i++)
+                if (perm[i] == -1)
+                  {
+                    found = false;
+                    break;
+                  }
+                else
+                  {
+                    tmp[perm[i]] = 1;
+                  }
 
-	      if (found)
-		{
-		  octave_idx_type k = ncols;
-		  for (octave_idx_type i = 0; i < nrows; i++)
-		    {
-		      if (tmp[i] == -1)
-			{
-			  if (k < nrows)
-			    {
-			      perm[k++] = i;
-			    }
-			  else
-			    {
-			      found = false;
-			      break;
-			    }
-			}
-		    }
-		}
+              if (found)
+                {
+                  octave_idx_type k = ncols;
+                  for (octave_idx_type i = 0; i < nrows; i++)
+                    {
+                      if (tmp[i] == -1)
+                        {
+                          if (k < nrows)
+                            {
+                              perm[k++] = i;
+                            }
+                          else
+                            {
+                              found = false;
+                              break;
+                            }
+                        }
+                    }
+                }
 
-	      if (found)
-		typ = MatrixType::Permuted_Lower;
-	      else
-		{
-		  delete [] perm;
-		  nperm = 0;
-		}
-	    }
-	  else
-	    {
-	      delete [] perm;
-	      nperm = 0;
-	    }
-	}
+              if (found)
+                typ = MatrixType::Permuted_Lower;
+              else
+                {
+                  delete [] perm;
+                  nperm = 0;
+                }
+            }
+          else
+            {
+              delete [] perm;
+              nperm = 0;
+            }
+        }
 
       // FIXME
       // Disable lower under-determined and upper over-determined problems
       // as being detected, and force to treat as singular. As this seems
       // to cause issues
       if (((typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-	   && nrows > ncols) ||
-	  ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-	   && nrows < ncols))
-	{
-	  typ = MatrixType::Rectangular;
-	  if (typ == MatrixType::Permuted_Upper ||
-	      typ == MatrixType::Permuted_Lower)
-	    delete [] perm;
-	  nperm = 0;
-	}
+           && nrows > ncols) ||
+          ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
+           && nrows < ncols))
+        {
+          typ = MatrixType::Rectangular;
+          if (typ == MatrixType::Permuted_Upper ||
+              typ == MatrixType::Permuted_Lower)
+            delete [] perm;
+          nperm = 0;
+        }
 
       if (typ == MatrixType::Full && ncols != nrows)
-	typ = MatrixType::Rectangular;
+        typ = MatrixType::Rectangular;
 
       if (maybe_hermitian && (typ == MatrixType::Full || 
-			      typ == MatrixType::Tridiagonal || 
-			      typ == MatrixType::Banded))
-	{
-	  bool is_herm = true;
+                              typ == MatrixType::Tridiagonal || 
+                              typ == MatrixType::Banded))
+        {
+          bool is_herm = true;
 
           // first, check whether the diagonal is positive & extract it
           ColumnVector diag (ncols);
 
-	  for (octave_idx_type j = 0; is_herm && j < ncols; j++)
+          for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             {
               is_herm = false;
               for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
                 {
                   if (a.ridx(i) == j)
                     {
                       double d = a.data(i);
                       is_herm = d > 0.;
@@ -507,26 +507,26 @@ MatrixType::MatrixType (const SparseMatr
                           {
                             is_herm = a.data(l) == d;
                             break;
                           }
                       }
                   }
               }
 
-	  if (is_herm)
-	    {
-	      if (typ == MatrixType::Full)
-		typ = MatrixType::Hermitian;
-	      else if (typ == MatrixType::Banded)
-		typ = MatrixType::Banded_Hermitian;
-	      else
-		typ = MatrixType::Tridiagonal_Hermitian;
-	    }
-	}
+          if (is_herm)
+            {
+              if (typ == MatrixType::Full)
+                typ = MatrixType::Hermitian;
+              else if (typ == MatrixType::Banded)
+                typ = MatrixType::Banded_Hermitian;
+              else
+                typ = MatrixType::Tridiagonal_Hermitian;
+            }
+        }
     }
 }
 
 MatrixType::MatrixType (const SparseComplexMatrix &a)
   : typ (MatrixType::Unknown),
     sp_bandden (0), bandden (0), upper_band (0), lower_band (0),
     dense (false), full (false), nperm (0), perm (0)
 {
@@ -544,262 +544,262 @@ MatrixType::MatrixType (const SparseComp
   typ = MatrixType::Full;
 
   if (nnz == nm)
     {
       matrix_type tmp_typ = MatrixType::Diagonal;
       octave_idx_type i;
       // Maybe the matrix is diagonal
       for (i = 0; i < nm; i++)
-	{
-	  if (a.cidx(i+1) != a.cidx(i) + 1)
-	    {
-	      tmp_typ = MatrixType::Full;
-	      break;
-	    }
-	  if (a.ridx(i) != i)
-	    {
-	      tmp_typ = MatrixType::Permuted_Diagonal;
-	      break;
-	    }
-	}
-	  
+        {
+          if (a.cidx(i+1) != a.cidx(i) + 1)
+            {
+              tmp_typ = MatrixType::Full;
+              break;
+            }
+          if (a.ridx(i) != i)
+            {
+              tmp_typ = MatrixType::Permuted_Diagonal;
+              break;
+            }
+        }
+          
       if (tmp_typ == MatrixType::Permuted_Diagonal)
-	{
-	  std::vector<bool> found (nrows);
+        {
+          std::vector<bool> found (nrows);
 
-	  for (octave_idx_type j = 0; j < i; j++)
-	    found [j] = true;
-	  for (octave_idx_type j = i; j < nrows; j++)
-	    found [j] = false;
-	      
-	  for (octave_idx_type j = i; j < nm; j++)
-	    {
-	      if ((a.cidx(j+1) > a.cidx(j) + 1)  || 
-		  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
-		{
-		  tmp_typ = MatrixType::Full;
-		  break;
-		}
-	      found [a.ridx(j)] = true;
-	    }
-	}
+          for (octave_idx_type j = 0; j < i; j++)
+            found [j] = true;
+          for (octave_idx_type j = i; j < nrows; j++)
+            found [j] = false;
+              
+          for (octave_idx_type j = i; j < nm; j++)
+            {
+              if ((a.cidx(j+1) > a.cidx(j) + 1)  || 
+                  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
+                {
+                  tmp_typ = MatrixType::Full;
+                  break;
+                }
+              found [a.ridx(j)] = true;
+            }
+        }
       typ = tmp_typ;
     }
 
   if (typ == MatrixType::Full)
     {
       // Search for banded, upper and lower triangular matrices
       bool singular = false;
       upper_band = 0;
       lower_band = 0;
       for (octave_idx_type j = 0; j < ncols; j++)
-	{
-	  bool zero_on_diagonal = false;
-	  if (j < nrows)
-	    {
-	      zero_on_diagonal = true;
-	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		if (a.ridx(i) == j)
-		  {
-		    zero_on_diagonal = false;
-		    break;
-		  }
-	    }
+        {
+          bool zero_on_diagonal = false;
+          if (j < nrows)
+            {
+              zero_on_diagonal = true;
+              for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+                if (a.ridx(i) == j)
+                  {
+                    zero_on_diagonal = false;
+                    break;
+                  }
+            }
 
-	  if (zero_on_diagonal)
-	    {
-	      singular = true;
-	      break;
-	    }
+          if (zero_on_diagonal)
+            {
+              singular = true;
+              break;
+            }
 
-	  if (a.cidx(j+1) != a.cidx(j))
-	    {
-	      octave_idx_type ru = a.ridx(a.cidx(j));
-	      octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
+          if (a.cidx(j+1) != a.cidx(j))
+            {
+              octave_idx_type ru = a.ridx(a.cidx(j));
+              octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
 
-	      if (j - ru > upper_band)
-		upper_band = j - ru;
-		  
-	      if (rl - j > lower_band)
-		lower_band = rl - j;
-	    }
-	}
+              if (j - ru > upper_band)
+                upper_band = j - ru;
+                  
+              if (rl - j > lower_band)
+                lower_band = rl - j;
+            }
+        }
 
       if (!singular)
-	{
-	  bandden = double (nnz) /
-	    (double (ncols) * (double (lower_band) +
-			       double (upper_band)) -
-	     0.5 * double (upper_band + 1) * double (upper_band) -
-	     0.5 * double (lower_band + 1) * double (lower_band));
+        {
+          bandden = double (nnz) /
+            (double (ncols) * (double (lower_band) +
+                               double (upper_band)) -
+             0.5 * double (upper_band + 1) * double (upper_band) -
+             0.5 * double (lower_band + 1) * double (lower_band));
 
-	  if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
-	    {
-	      if (upper_band == 1 && lower_band == 1)
-		typ = MatrixType::Tridiagonal;
-	      else
-		typ = MatrixType::Banded;
+          if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
+            {
+              if (upper_band == 1 && lower_band == 1)
+                typ = MatrixType::Tridiagonal;
+              else
+                typ = MatrixType::Banded;
 
-	      octave_idx_type nnz_in_band = 
-		(upper_band + lower_band + 1) * nrows -
-		(1 + upper_band) * upper_band / 2 -
-		(1 + lower_band) * lower_band / 2;
-	      if (nnz_in_band == nnz)
-		dense = true;
-	      else 
-		dense = false;
-	    }
-	  else if (upper_band == 0)
-	    typ = MatrixType::Lower;
-	  else if (lower_band == 0)
-	    typ = MatrixType::Upper;
+              octave_idx_type nnz_in_band = 
+                (upper_band + lower_band + 1) * nrows -
+                (1 + upper_band) * upper_band / 2 -
+                (1 + lower_band) * lower_band / 2;
+              if (nnz_in_band == nnz)
+                dense = true;
+              else 
+                dense = false;
+            }
+          else if (upper_band == 0)
+            typ = MatrixType::Lower;
+          else if (lower_band == 0)
+            typ = MatrixType::Upper;
 
-	  if (upper_band == lower_band && nrows == ncols)
-	    maybe_hermitian = true;
-	}
+          if (upper_band == lower_band && nrows == ncols)
+            maybe_hermitian = true;
+        }
 
       if (typ == MatrixType::Full)
-	{
-	  // Search for a permuted triangular matrix, and test if
-	  // permutation is singular
+        {
+          // Search for a permuted triangular matrix, and test if
+          // permutation is singular
 
-	  // FIXME
-	  // Perhaps this should be based on a dmperm algorithm
-	  bool found = false;
+          // FIXME
+          // Perhaps this should be based on a dmperm algorithm
+          bool found = false;
 
-	  nperm = ncols;
-	  perm = new octave_idx_type [ncols];
+          nperm = ncols;
+          perm = new octave_idx_type [ncols];
 
-	  for (octave_idx_type i = 0; i < ncols; i++)
-	    perm [i] = -1;
+          for (octave_idx_type i = 0; i < ncols; i++)
+            perm [i] = -1;
 
-	  for (octave_idx_type i = 0; i < nm; i++)
-	    {
-	      found = false;
+          for (octave_idx_type i = 0; i < nm; i++)
+            {
+              found = false;
 
-	      for (octave_idx_type j = 0; j < ncols; j++)
-		{
-		  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
-		      (a.ridx(a.cidx(j+1)-1) == i))
-		    {
-		      perm [i] = j;
-		      found = true;
-		      break;
-		    }
-		}
+              for (octave_idx_type j = 0; j < ncols; j++)
+                {
+                  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
+                      (a.ridx(a.cidx(j+1)-1) == i))
+                    {
+                      perm [i] = j;
+                      found = true;
+                      break;
+                    }
+                }
 
-	      if (!found)
-		break;
-	    }
+              if (!found)
+                break;
+            }
 
-	  if (found)
-	    {
-	      typ = MatrixType::Permuted_Upper;
-	      if (ncols > nrows)
-		{
-		  octave_idx_type k = nrows;
-		  for (octave_idx_type i = 0; i < ncols; i++)
-		    if (perm [i] == -1)
-		      perm[i] = k++;
-		}
-	    }
-	  else if (a.cidx(nm) == a.cidx(ncols))
-	    {
-	      nperm = nrows;
-	      delete [] perm;
-	      perm = new octave_idx_type [nrows];
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
+          if (found)
+            {
+              typ = MatrixType::Permuted_Upper;
+              if (ncols > nrows)
+                {
+                  octave_idx_type k = nrows;
+                  for (octave_idx_type i = 0; i < ncols; i++)
+                    if (perm [i] == -1)
+                      perm[i] = k++;
+                }
+            }
+          else if (a.cidx(nm) == a.cidx(ncols))
+            {
+              nperm = nrows;
+              delete [] perm;
+              perm = new octave_idx_type [nrows];
+              OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
 
-	      for (octave_idx_type i = 0; i < nrows; i++)
-		{
-		  perm [i] = -1;
-		  tmp [i] = -1;
-		}
+              for (octave_idx_type i = 0; i < nrows; i++)
+                {
+                  perm [i] = -1;
+                  tmp [i] = -1;
+                }
 
-	      for (octave_idx_type j = 0; j < ncols; j++)
-		for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		    perm [a.ridx(i)] = j;
+              for (octave_idx_type j = 0; j < ncols; j++)
+                for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+                    perm [a.ridx(i)] = j;
 
-	      found = true;
-	      for (octave_idx_type i = 0; i < nm; i++)
-		if (perm[i] == -1)
-		  {
-		    found = false;
-		    break;
-		  }
-		else
-		  {
-		    tmp[perm[i]] = 1;
-		  }
+              found = true;
+              for (octave_idx_type i = 0; i < nm; i++)
+                if (perm[i] == -1)
+                  {
+                    found = false;
+                    break;
+                  }
+                else
+                  {
+                    tmp[perm[i]] = 1;
+                  }
 
-	      if (found)
-		{
-		  octave_idx_type k = ncols;
-		  for (octave_idx_type i = 0; i < nrows; i++)
-		    {
-		      if (tmp[i] == -1)
-			{
-			  if (k < nrows)
-			    {
-			      perm[k++] = i;
-			    }
-			  else
-			    {
-			      found = false;
-			      break;
-			    }
-			}
-		    }
-		}
+              if (found)
+                {
+                  octave_idx_type k = ncols;
+                  for (octave_idx_type i = 0; i < nrows; i++)
+                    {
+                      if (tmp[i] == -1)
+                        {
+                          if (k < nrows)
+                            {
+                              perm[k++] = i;
+                            }
+                          else
+                            {
+                              found = false;
+                              break;
+                            }
+                        }
+                    }
+                }
 
-	      if (found)
-		typ = MatrixType::Permuted_Lower;
-	      else
-		{
-		  delete [] perm;
-		  nperm = 0;
-		}
-	    }
-	  else
-	    {
-	      delete [] perm;
-	      nperm = 0;
-	    }
-	}
+              if (found)
+                typ = MatrixType::Permuted_Lower;
+              else
+                {
+                  delete [] perm;
+                  nperm = 0;
+                }
+            }
+          else
+            {
+              delete [] perm;
+              nperm = 0;
+            }
+        }
 
       // FIXME
       // Disable lower under-determined and upper over-determined problems
       // as being detected, and force to treat as singular. As this seems
       // to cause issues
       if (((typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-	   && nrows > ncols) ||
-	  ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-	   && nrows < ncols))
-	{
-	  typ = MatrixType::Rectangular;
-	  if (typ == MatrixType::Permuted_Upper ||
-	      typ == MatrixType::Permuted_Lower)
-	    delete [] perm;
-	  nperm = 0;
-	}
+           && nrows > ncols) ||
+          ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
+           && nrows < ncols))
+        {
+          typ = MatrixType::Rectangular;
+          if (typ == MatrixType::Permuted_Upper ||
+              typ == MatrixType::Permuted_Lower)
+            delete [] perm;
+          nperm = 0;
+        }
 
       if (typ == MatrixType::Full && ncols != nrows)
-	typ = MatrixType::Rectangular;
+        typ = MatrixType::Rectangular;
 
       if (maybe_hermitian && (typ == MatrixType::Full || 
-			      typ == MatrixType::Tridiagonal || 
-			      typ == MatrixType::Banded))
-	{
-	  bool is_herm = true;
+                              typ == MatrixType::Tridiagonal || 
+                              typ == MatrixType::Banded))
+        {
+          bool is_herm = true;
 
           // first, check whether the diagonal is positive & extract it
           ColumnVector diag (ncols);
 
-	  for (octave_idx_type j = 0; is_herm && j < ncols; j++)
+          for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             {
               is_herm = false;
               for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
                 {
                   if (a.ridx(i) == j)
                     {
                       Complex d = a.data(i);
                       is_herm = d.real() > 0. && d.imag() == 0.;
@@ -829,26 +829,26 @@ MatrixType::MatrixType (const SparseComp
                             is_herm = a.data(l) == d;
                             break;
                           }
                       }
                   }
               }
 
 
-	  if (is_herm)
-	    {
-	      if (typ == MatrixType::Full)
-		typ = MatrixType::Hermitian;
-	      else if (typ == MatrixType::Banded)
-		typ = MatrixType::Banded_Hermitian;
-	      else
-		typ = MatrixType::Tridiagonal_Hermitian;
-	    }
-	}
+          if (is_herm)
+            {
+              if (typ == MatrixType::Full)
+                typ = MatrixType::Hermitian;
+              else if (typ == MatrixType::Banded)
+                typ = MatrixType::Banded_Hermitian;
+              else
+                typ = MatrixType::Tridiagonal_Hermitian;
+            }
+        }
     }
 }
 MatrixType::MatrixType (const matrix_type t, bool _full)
   : typ (MatrixType::Unknown),
     sp_bandden (octave_sparse_params::get_bandden()),
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
@@ -858,37 +858,37 @@ MatrixType::MatrixType (const matrix_typ
       || t == MatrixType::Tridiagonal || t == MatrixType::Tridiagonal_Hermitian
       || t == MatrixType::Rectangular)
     typ = t;
   else
     (*current_liboctave_warning_handler) ("Invalid matrix type");
 }
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type np,
-			const octave_idx_type *p, bool _full)
+                        const octave_idx_type *p, bool _full)
   : typ (MatrixType::Unknown),
     sp_bandden (octave_sparse_params::get_bandden()),
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
   if ((t == MatrixType::Permuted_Upper || t == MatrixType::Permuted_Lower) &&
       np > 0 && p != 0)
     {
       typ = t;
       nperm = np;
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
-	perm[i] = p[i];
+        perm[i] = p[i];
     }
   else
     (*current_liboctave_warning_handler) ("Invalid matrix type");
 }
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type ku,
-			const octave_idx_type kl, bool _full)
+                        const octave_idx_type kl, bool _full)
   : typ (MatrixType::Unknown),
     sp_bandden (octave_sparse_params::get_bandden()),
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
   if (t == MatrixType::Banded || t == MatrixType::Banded_Hermitian)
     {
       typ = t;
@@ -917,36 +917,36 @@ MatrixType::operator = (const MatrixType
       bandden = a.bandden;
       upper_band = a.upper_band;
       lower_band = a.lower_band;
       dense = a.dense;
       full = a.full;
       nperm = a.nperm;
 
       if (nperm != 0)
-	{
-	  perm = new octave_idx_type [nperm];
-	  for (octave_idx_type i = 0; i < nperm; i++)
-	    perm[i] = a.perm[i];
-	}
+        {
+          perm = new octave_idx_type [nperm];
+          for (octave_idx_type i = 0; i < nperm; i++)
+            perm[i] = a.perm[i];
+        }
     }
 
   return *this;
 }
 
 int
 MatrixType::type (bool quiet)
 {
   if (typ != MatrixType::Unknown && (full ||
       sp_bandden == octave_sparse_params::get_bandden()))
     {
       if (!quiet &&
-	  octave_sparse_params::get_key ("spumoni") != 0.)
-  	(*current_liboctave_warning_handler) 
-  	  ("Using Cached Matrix Type");
+          octave_sparse_params::get_key ("spumoni") != 0.)
+        (*current_liboctave_warning_handler) 
+          ("Using Cached Matrix Type");
       
       return typ;
     }
 
   if (typ != MatrixType::Unknown && 
       octave_sparse_params::get_key ("spumoni") != 0.)
     (*current_liboctave_warning_handler) 
       ("Invalidating Matrix Type");
@@ -958,18 +958,18 @@ MatrixType::type (bool quiet)
 
 int
 MatrixType::type (const SparseMatrix &a)
 {
   if (typ != MatrixType::Unknown && (full ||
       sp_bandden == octave_sparse_params::get_bandden()))
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
-  	(*current_liboctave_warning_handler) 
-  	  ("Using Cached Matrix Type");
+        (*current_liboctave_warning_handler) 
+          ("Using Cached Matrix Type");
       
       return typ;
     }
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   sp_bandden = tmp_typ.sp_bandden;
   bandden = tmp_typ.bandden;
@@ -978,31 +978,31 @@ MatrixType::type (const SparseMatrix &a)
   dense = tmp_typ.dense;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
-	perm[i] = tmp_typ.perm[i];
+        perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
 MatrixType::type (const SparseComplexMatrix &a)
 {
   if (typ != MatrixType::Unknown && (full || 
       sp_bandden == octave_sparse_params::get_bandden()))
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
-  	(*current_liboctave_warning_handler) 
-  	  ("Using Cached Matrix Type");
+        (*current_liboctave_warning_handler) 
+          ("Using Cached Matrix Type");
       
       return typ;
     }
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   sp_bandden = tmp_typ.sp_bandden;
   bandden = tmp_typ.bandden;
@@ -1011,210 +1011,210 @@ MatrixType::type (const SparseComplexMat
   dense = tmp_typ.dense;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
-	perm[i] = tmp_typ.perm[i];
+        perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
 MatrixType::type (const Matrix &a)
 {
   if (typ != MatrixType::Unknown)
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
-  	(*current_liboctave_warning_handler) 
-  	  ("Using Cached Matrix Type");
+        (*current_liboctave_warning_handler) 
+          ("Using Cached Matrix Type");
       
       return typ;
     }
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
-	perm[i] = tmp_typ.perm[i];
+        perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
 MatrixType::type (const ComplexMatrix &a)
 {
   if (typ != MatrixType::Unknown)
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
-  	(*current_liboctave_warning_handler) 
-  	  ("Using Cached Matrix Type");
+        (*current_liboctave_warning_handler) 
+          ("Using Cached Matrix Type");
       
       return typ;
     }
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full; 
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
-	perm[i] = tmp_typ.perm[i];
+        perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
 MatrixType::type (const FloatMatrix &a)
 {
   if (typ != MatrixType::Unknown)
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
-  	(*current_liboctave_warning_handler) 
-  	  ("Using Cached Matrix Type");
+        (*current_liboctave_warning_handler) 
+          ("Using Cached Matrix Type");
       
       return typ;
     }
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
-	perm[i] = tmp_typ.perm[i];
+        perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
 MatrixType::type (const FloatComplexMatrix &a)
 {
   if (typ != MatrixType::Unknown)
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
-  	(*current_liboctave_warning_handler) 
-  	  ("Using Cached Matrix Type");
+        (*current_liboctave_warning_handler) 
+          ("Using Cached Matrix Type");
       
       return typ;
     }
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full; 
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
-	perm[i] = tmp_typ.perm[i];
+        perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 void
 MatrixType::info () const
 {
   if (octave_sparse_params::get_key ("spumoni") != 0.)
     {
       if (typ == MatrixType::Unknown)
-	(*current_liboctave_warning_handler) 
-	  ("Unknown Matrix Type");
+        (*current_liboctave_warning_handler) 
+          ("Unknown Matrix Type");
       else if (typ == MatrixType::Diagonal)
-	(*current_liboctave_warning_handler) 
-	  ("Diagonal Sparse Matrix");
+        (*current_liboctave_warning_handler) 
+          ("Diagonal Sparse Matrix");
       else if (typ == MatrixType::Permuted_Diagonal)
-	(*current_liboctave_warning_handler) 
-	  ("Permuted Diagonal Sparse Matrix");
+        (*current_liboctave_warning_handler) 
+          ("Permuted Diagonal Sparse Matrix");
       else if (typ == MatrixType::Upper)
-	(*current_liboctave_warning_handler) 
-	  ("Upper Triangular Matrix");
+        (*current_liboctave_warning_handler) 
+          ("Upper Triangular Matrix");
       else if (typ == MatrixType::Lower)
-	(*current_liboctave_warning_handler) 
-	  ("Lower Triangular Matrix");
+        (*current_liboctave_warning_handler) 
+          ("Lower Triangular Matrix");
       else if (typ == MatrixType::Permuted_Upper)
-	(*current_liboctave_warning_handler) 
-	  ("Permuted Upper Triangular Matrix");
+        (*current_liboctave_warning_handler) 
+          ("Permuted Upper Triangular Matrix");
       else if (typ == MatrixType::Permuted_Lower)
-	(*current_liboctave_warning_handler) 
-	  ("Permuted Lower Triangular Matrix");
+        (*current_liboctave_warning_handler) 
+          ("Permuted Lower Triangular Matrix");
       else if (typ == MatrixType::Banded)
-	(*current_liboctave_warning_handler) 
-	  ("Banded Sparse Matrix %d-1-%d (Density %f)", lower_band, 
-	   upper_band, bandden);
+        (*current_liboctave_warning_handler) 
+          ("Banded Sparse Matrix %d-1-%d (Density %f)", lower_band, 
+           upper_band, bandden);
       else if (typ == MatrixType::Banded_Hermitian)
-	(*current_liboctave_warning_handler) 
-	  ("Banded Hermitian/Symmetric Sparse Matrix %d-1-%d (Density %f)", 
-	   lower_band, upper_band, bandden);
+        (*current_liboctave_warning_handler) 
+          ("Banded Hermitian/Symmetric Sparse Matrix %d-1-%d (Density %f)", 
+           lower_band, upper_band, bandden);
       else if (typ == MatrixType::Hermitian)
-	(*current_liboctave_warning_handler) 
-	  ("Hermitian/Symmetric Matrix");
+        (*current_liboctave_warning_handler) 
+          ("Hermitian/Symmetric Matrix");
       else if (typ == MatrixType::Tridiagonal)
-	(*current_liboctave_warning_handler) 
-	  ("Tridiagonal Sparse Matrix");
+        (*current_liboctave_warning_handler) 
+          ("Tridiagonal Sparse Matrix");
       else if (typ == MatrixType::Tridiagonal_Hermitian)
-	(*current_liboctave_warning_handler) 
-	  ("Hermitian/Symmetric Tridiagonal Sparse Matrix");
+        (*current_liboctave_warning_handler) 
+          ("Hermitian/Symmetric Tridiagonal Sparse Matrix");
       else if (typ == MatrixType::Rectangular)
-	(*current_liboctave_warning_handler) 
-	  ("Rectangular/Singular Matrix");
+        (*current_liboctave_warning_handler) 
+          ("Rectangular/Singular Matrix");
       else if (typ == MatrixType::Full)
-	(*current_liboctave_warning_handler) 
-	  ("Full Matrix");
+        (*current_liboctave_warning_handler) 
+          ("Full Matrix");
     }
 }
 
 void
 MatrixType::mark_as_symmetric (void)
 {
   if (typ == MatrixType::Tridiagonal || 
       typ == MatrixType::Tridiagonal_Hermitian)
     typ = MatrixType::Tridiagonal_Hermitian;
   else if (typ == MatrixType::Banded ||
-	   typ == MatrixType::Banded_Hermitian)
+           typ == MatrixType::Banded_Hermitian)
     typ = MatrixType::Banded_Hermitian;
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian || 
-	   typ == MatrixType::Unknown)
+           typ == MatrixType::Unknown)
     typ = MatrixType::Hermitian;
   else
     (*current_liboctave_error_handler) 
       ("Can not mark current matrix type as symmetric");
 }
 
 void
 MatrixType::mark_as_unsymmetric (void)
 {
   if (typ == MatrixType::Tridiagonal || 
       typ == MatrixType::Tridiagonal_Hermitian)
     typ = MatrixType::Tridiagonal;
   else if (typ == MatrixType::Banded ||
-	   typ == MatrixType::Banded_Hermitian)
+           typ == MatrixType::Banded_Hermitian)
     typ = MatrixType::Banded;
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian || 
-	   typ == MatrixType::Unknown)
+           typ == MatrixType::Unknown)
     typ = MatrixType::Full;
 }
 
 void
 MatrixType::mark_as_permuted (const octave_idx_type np, const octave_idx_type *p)
 {
   nperm = np;
   perm = new octave_idx_type [nperm];
diff --git a/liboctave/ODES.cc b/liboctave/ODES.cc
--- a/liboctave/ODES.cc
+++ b/liboctave/ODES.cc
@@ -31,14 +31,14 @@ void
 ODES::initialize (const ColumnVector& xx, double tt)
 {
   base_diff_eqn::initialize (xx, tt);
   xdot = ColumnVector (xx.length (), 0.0);
 }
 
 void
 ODES::initialize (const ColumnVector& xx, double tt,
-		  const ColumnVector& xtheta)
+                  const ColumnVector& xtheta)
 {
   base_diff_eqn::initialize (xx, tt);
   xdot = ColumnVector (xx.length (), 0.0);
   theta = xtheta;
 }
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -37,44 +37,44 @@ static float_integrand_fcn float_user_fc
 // FIXME -- would be nice to not have to have this global
 // variable.
 // Nonzero means an error occurred in the calculation of the integrand
 // function, and the user wants us to quit.
 int quad_integration_error = 0;
 
 typedef octave_idx_type (*quad_fcn_ptr) (double*, int&, double*);
 typedef octave_idx_type (*quad_float_fcn_ptr) (float*, int&, float*);
-			      
+                              
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dqagp, DQAGP) (quad_fcn_ptr, const double&, const double&,
-			   const octave_idx_type&, const double*, const double&,
-			   const double&, double&, double&, octave_idx_type&,
-			   octave_idx_type&, const octave_idx_type&, const octave_idx_type&, octave_idx_type&, octave_idx_type*,
-			   double*);
+                           const octave_idx_type&, const double*, const double&,
+                           const double&, double&, double&, octave_idx_type&,
+                           octave_idx_type&, const octave_idx_type&, const octave_idx_type&, octave_idx_type&, octave_idx_type*,
+                           double*);
 
   F77_RET_T
   F77_FUNC (dqagi, DQAGI) (quad_fcn_ptr, const double&, const octave_idx_type&,
-			   const double&, const double&, double&,
-			   double&, octave_idx_type&, octave_idx_type&, const octave_idx_type&,
-			   const octave_idx_type&, octave_idx_type&, octave_idx_type*, double*); 
+                           const double&, const double&, double&,
+                           double&, octave_idx_type&, octave_idx_type&, const octave_idx_type&,
+                           const octave_idx_type&, octave_idx_type&, octave_idx_type*, double*); 
 
   F77_RET_T
   F77_FUNC (qagp, QAGP) (quad_float_fcn_ptr, const float&, const float&,
-			 const octave_idx_type&, const float*, const float&,
-			 const float&, float&, float&, octave_idx_type&,
-			 octave_idx_type&, const octave_idx_type&, const octave_idx_type&, octave_idx_type&, octave_idx_type*,
-			 float*);
+                         const octave_idx_type&, const float*, const float&,
+                         const float&, float&, float&, octave_idx_type&,
+                         octave_idx_type&, const octave_idx_type&, const octave_idx_type&, octave_idx_type&, octave_idx_type*,
+                         float*);
 
   F77_RET_T
   F77_FUNC (qagi, QAGI) (quad_float_fcn_ptr, const float&, const octave_idx_type&,
-			 const float&, const float&, float&,
-			 float&, octave_idx_type&, octave_idx_type&, const octave_idx_type&,
-			 const octave_idx_type&, octave_idx_type&, octave_idx_type*, float*); 
+                         const float&, const float&, float&,
+                         float&, octave_idx_type&, octave_idx_type&, const octave_idx_type&,
+                         const octave_idx_type&, octave_idx_type&, octave_idx_type*, float*); 
 }
 
 static octave_idx_type
 user_function (double *x, int& ierr, double *result)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
 #if defined (__sparc) && defined (__GNUC__)
@@ -135,19 +135,19 @@ DefQuad::do_integrate (octave_idx_type& 
 
   user_fcn = f;
   octave_idx_type last;
 
   double abs_tol = absolute_tolerance ();
   double rel_tol = relative_tolerance ();
 
   F77_XFCN (dqagp, DQAGP, (user_function, lower_limit, upper_limit,
-			   npts, points, abs_tol, rel_tol, result,
-			   abserr, neval, ier, leniw, lenw, last,
-			   piwork, pwork));
+                           npts, points, abs_tol, rel_tol, result,
+                           abserr, neval, ier, leniw, lenw, last,
+                           piwork, pwork));
 
   return result;
 }
 
 float
 DefQuad::do_integrate (octave_idx_type&, octave_idx_type&, float&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
@@ -189,18 +189,18 @@ IndefQuad::do_integrate (octave_idx_type
       assert (0);
       break;
     }
 
   double abs_tol = absolute_tolerance ();
   double rel_tol = relative_tolerance ();
 
   F77_XFCN (dqagi, DQAGI, (user_function, bound, inf, abs_tol, rel_tol,
-			   result, abserr, neval, ier, leniw, lenw,
-			   last, piwork, pwork));
+                           result, abserr, neval, ier, leniw, lenw,
+                           last, piwork, pwork));
 
   return result;
 }
 
 float
 IndefQuad::do_integrate (octave_idx_type&, octave_idx_type&, float&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
@@ -231,19 +231,19 @@ FloatDefQuad::do_integrate (octave_idx_t
 
   float_user_fcn = ff;
   octave_idx_type last;
 
   float abs_tol = single_precision_absolute_tolerance ();
   float rel_tol = single_precision_relative_tolerance ();
 
   F77_XFCN (qagp, QAGP, (float_user_function, lower_limit, upper_limit,
-			 npts, points, abs_tol, rel_tol, result,
-			 abserr, neval, ier, leniw, lenw, last,
-			 piwork, pwork));
+                         npts, points, abs_tol, rel_tol, result,
+                         abserr, neval, ier, leniw, lenw, last,
+                         piwork, pwork));
 
   return result;
 }
 
 double
 FloatIndefQuad::do_integrate (octave_idx_type&, octave_idx_type&, double&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
@@ -285,13 +285,13 @@ FloatIndefQuad::do_integrate (octave_idx
       assert (0);
       break;
     }
 
   float abs_tol = single_precision_absolute_tolerance ();
   float rel_tol = single_precision_relative_tolerance ();
 
   F77_XFCN (qagi, QAGI, (float_user_function, bound, inf, abs_tol, rel_tol,
-			 result, abserr, neval, ier, leniw, lenw,
-			 last, piwork, pwork));
+                         result, abserr, neval, ier, leniw, lenw,
+                         last, piwork, pwork));
 
   return result;
 }
diff --git a/liboctave/Range.cc b/liboctave/Range.cc
--- a/liboctave/Range.cc
+++ b/liboctave/Range.cc
@@ -47,40 +47,40 @@ Range::Range (double b, double i, octave
 bool
 Range::all_elements_are_ints (void) const
 {
   // If the base and increment are ints, the final value in the range
   // will also be an integer, even if the limit is not. If there is one
   // or fewer elements only the base needs to be an integer
 
   return (! (xisnan (rng_base) || xisnan (rng_inc))
-	  && (NINTbig (rng_base) == rng_base || rng_nelem < 1)
-	  && (NINTbig (rng_inc) == rng_inc || rng_nelem <= 1));
+          && (NINTbig (rng_base) == rng_base || rng_nelem < 1)
+          && (NINTbig (rng_inc) == rng_inc || rng_nelem <= 1));
 }
 
 Matrix
 Range::matrix_value (void) const
 {
   if (rng_nelem > 0 && cache.nelem () == 0)
     {
       cache.resize (1, rng_nelem);
       double b = rng_base;
       double increment = rng_inc;
       for (octave_idx_type i = 0; i < rng_nelem; i++)
-	cache(i) = b + i * increment;
+        cache(i) = b + i * increment;
 
       // On some machines (x86 with extended precision floating point
       // arithmetic, for example) it is possible that we can overshoot
       // the limit by approximately the machine precision even though
       // we were very careful in our calculation of the number of
       // elements.
 
       if ((rng_inc > 0 && cache(rng_nelem-1) > rng_limit)
-	  || (rng_inc < 0 && cache(rng_nelem-1) < rng_limit))
-	cache(rng_nelem-1) = rng_limit;
+          || (rng_inc < 0 && cache(rng_nelem-1) < rng_limit))
+        cache(rng_nelem-1) = rng_limit;
     }
 
   return cache;
 }
 
 double
 Range::checkelem (octave_idx_type i) const
 {
@@ -137,48 +137,48 @@ Range::index (const idx_vector& i) const
 
 double
 Range::min (void) const
 {
   double retval = 0.0;
   if (rng_nelem > 0)
     {
       if (rng_inc > 0)
-	retval = rng_base;
+        retval = rng_base;
       else
-	{
-	  retval = rng_base + (rng_nelem - 1) * rng_inc;
+        {
+          retval = rng_base + (rng_nelem - 1) * rng_inc;
 
-	  // See the note in the matrix_value method above.
+          // See the note in the matrix_value method above.
 
-	  if (retval < rng_limit)
-	    retval = rng_limit;
-	}
+          if (retval < rng_limit)
+            retval = rng_limit;
+        }
 
     }
   return retval;
 }
 
 double
 Range::max (void) const
 {
   double retval = 0.0;
   if (rng_nelem > 0)
     {
       if (rng_inc > 0)
-	{
-	  retval = rng_base + (rng_nelem - 1) * rng_inc;
+        {
+          retval = rng_base + (rng_nelem - 1) * rng_inc;
 
-	  // See the note in the matrix_value method above.
+          // See the note in the matrix_value method above.
 
-	  if (retval > rng_limit)
-	    retval = rng_limit;
-	}
+          if (retval > rng_limit)
+            retval = rng_limit;
+        }
       else
-	retval = rng_base;
+        retval = rng_base;
     }
   return retval;
 }
 
 void
 Range::sort_internal (bool ascending)
 {
   if (ascending && rng_base > rng_limit && rng_inc < 0.0)
@@ -246,38 +246,38 @@ Range::diag (octave_idx_type k) const
 Range
 Range::sort (octave_idx_type dim, sortmode mode) const
 {
   Range retval = *this;
 
   if (dim == 1)
     {
       if (mode == ASCENDING)
-	retval.sort_internal (true);
+        retval.sort_internal (true);
       else if (mode == DESCENDING)
-	retval.sort_internal (false);
+        retval.sort_internal (false);
     }
   else if (dim != 0)
     (*current_liboctave_error_handler) ("Range::sort: invalid dimension");
 
   return retval;
 }
 
 Range
 Range::sort (Array<octave_idx_type>& sidx, octave_idx_type dim,
-	     sortmode mode) const
+             sortmode mode) const
 {
   Range retval = *this;
 
   if (dim == 1)
     {
       if (mode == ASCENDING)
-	  retval.sort_internal (sidx, true);
+          retval.sort_internal (sidx, true);
       else if (mode == DESCENDING)
-	retval.sort_internal (sidx, false);
+        retval.sort_internal (sidx, false);
     }
   else if (dim != 0)
     (*current_liboctave_error_handler) ("Range::sort: invalid dimension");
 
   return retval;
 }
 
 sortmode
@@ -314,20 +314,20 @@ operator << (std::ostream& os, const Ran
 std::istream&
 operator >> (std::istream& is, Range& a)
 {
   is >> a.rng_base;
   if (is)
     {
       is >> a.rng_limit;
       if (is)
-	{
-	  is >> a.rng_inc;
-	  a.rng_nelem = a.nelem_internal ();
-	}
+        {
+          is >> a.rng_inc;
+          a.rng_nelem = a.nelem_internal ();
+        }
     }
 
   return is;
 }
 
 Range
 operator - (const Range& r)
 {
@@ -492,20 +492,20 @@ Range::nelem_internal (void) const
       // element.
       //
       // I'm not sure this is very good, but it seems to work better than
       // just using tfloor as above.  For example, without it, the
       // expression 1.8:0.05:1.9 fails to produce the expected result of
       // [1.8, 1.85, 1.9].
 
       if (! teq (rng_base + (n_elt - 1) * rng_inc, rng_limit))
-	{
-	  if (teq (rng_base + (n_elt - 2) * rng_inc, rng_limit))
-	    n_elt--;
-	  else if (teq (rng_base + n_elt * rng_inc, rng_limit))
-	    n_elt++;
-	}
+        {
+          if (teq (rng_base + (n_elt - 2) * rng_inc, rng_limit))
+            n_elt--;
+          else if (teq (rng_base + n_elt * rng_inc, rng_limit))
+            n_elt++;
+        }
 
       retval = (n_elt >= std::numeric_limits<octave_idx_type>::max () - 1) ? -1 : n_elt;
     }
 
   return retval;
 }
diff --git a/liboctave/Sparse-C.cc b/liboctave/Sparse-C.cc
--- a/liboctave/Sparse-C.cc
+++ b/liboctave/Sparse-C.cc
@@ -41,25 +41,25 @@ xabs (const Complex& x)
 }
 
 
 template <>
 bool
 sparse_ascending_compare<Complex> (const Complex& a, const Complex& b)
 {
   return (xisnan (b) || (xabs (a) < xabs (b))
-	  || ((xabs (a) == xabs (b)) && (arg (a) < arg (b))));
+          || ((xabs (a) == xabs (b)) && (arg (a) < arg (b))));
 }
 
 template <>
 bool
 sparse_descending_compare<Complex> (const Complex& a, const Complex& b)
 {
   return (xisnan (a) || (xabs (a) > xabs (b))
-	  || ((xabs (a) == xabs (b)) && (arg (a) > arg (b))));
+          || ((xabs (a) == xabs (b)) && (arg (a) > arg (b))));
 }
 
 INSTANTIATE_SPARSE_AND_ASSIGN (Complex, OCTAVE_API);
 
 INSTANTIATE_SPARSE_ASSIGN (Complex, double, OCTAVE_API);
 
 #if 0
 template std::ostream& operator << (std::ostream&, const Sparse<Complex>&);
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -50,118 +50,118 @@ template <class T>
 T&
 Sparse<T>::SparseRep::elem (octave_idx_type _r, octave_idx_type _c)
 {
   octave_idx_type i;
 
   if (nzmx > 0)
     {
       for (i = c[_c]; i < c[_c + 1]; i++)
-	if (r[i] == _r)
-	  return d[i];
-	else if (r[i] > _r)
-	  break;
+        if (r[i] == _r)
+          return d[i];
+        else if (r[i] > _r)
+          break;
 
       // Ok, If we've gotten here, we're in trouble.. Have to create a 
       // new element in the sparse array. This' gonna be slow!!!
       if (c[ncols] == nzmx)
-	{
-	  (*current_liboctave_error_handler)
-	    ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
-	  return *d;
-	}
+        {
+          (*current_liboctave_error_handler)
+            ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
+          return *d;
+        }
 
       octave_idx_type to_move = c[ncols] - i;
       if (to_move != 0)
-	{
-	  for (octave_idx_type j = c[ncols]; j > i; j--)
-	    {
-	      d[j] = d[j-1];
-	      r[j] = r[j-1];
-	    }
-	}
+        {
+          for (octave_idx_type j = c[ncols]; j > i; j--)
+            {
+              d[j] = d[j-1];
+              r[j] = r[j-1];
+            }
+        }
 
       for (octave_idx_type j = _c + 1; j < ncols + 1; j++)
-	c[j] = c[j] + 1;
+        c[j] = c[j] + 1;
       
       d[i] = 0.;
       r[i] = _r;
 
       return d[i];
     }
   else
     {
       (*current_liboctave_error_handler)
-	("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
+        ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
       return *d;
     }
 }
 
 template <class T>
 T
 Sparse<T>::SparseRep::celem (octave_idx_type _r, octave_idx_type _c) const
 {
   if (nzmx > 0)
     for (octave_idx_type i = c[_c]; i < c[_c + 1]; i++)
       if (r[i] == _r)
-	return d[i];
+        return d[i];
   return T ();
 }
 
 template <class T>
 void
 Sparse<T>::SparseRep::maybe_compress (bool remove_zeros)
 {
   octave_idx_type ndel = nzmx - c[ncols];
   octave_idx_type nzero = 0;
 
   if (remove_zeros)
     for (octave_idx_type i = 0; i < nzmx - ndel; i++)
       if (d[i] == T ())
-	nzero++;
+        nzero++;
 
   if (!ndel && !nzero)
     return;
 
   if (!nzero)
     {
       octave_idx_type new_nzmx = nzmx - ndel;
 
       T *new_data = new T [new_nzmx];
       for (octave_idx_type i = 0; i < new_nzmx; i++)
-	new_data[i] = d[i];
+        new_data[i] = d[i];
       delete [] d;
       d = new_data;
 
       octave_idx_type *new_ridx = new octave_idx_type [new_nzmx];
       for (octave_idx_type i = 0; i < new_nzmx; i++)
-	new_ridx[i] = r[i];
+        new_ridx[i] = r[i];
       delete [] r;
       r = new_ridx;
     }
   else
     {
       octave_idx_type new_nzmx = nzmx - ndel - nzero;
 
       T *new_data = new T [new_nzmx];
       octave_idx_type *new_ridx = new octave_idx_type [new_nzmx];
 
       octave_idx_type ii = 0;
       octave_idx_type ic = 0;
       for (octave_idx_type j = 0; j < ncols; j++)
-	{
-	  for (octave_idx_type k = ic; k < c[j+1]; k++)
-	    if (d[k] != T ())
-	      {
-		new_data [ii] = d[k];
-		new_ridx [ii++] = r[k];
-	      }
-	  ic = c[j+1];
-	  c[j+1] = ii;
-	}
+        {
+          for (octave_idx_type k = ic; k < c[j+1]; k++)
+            if (d[k] != T ())
+              {
+                new_data [ii] = d[k];
+                new_ridx [ii++] = r[k];
+              }
+          ic = c[j+1];
+          c[j+1] = ii;
+        }
 
       delete [] d;
       d = new_data;
 
       delete [] r;
       r = new_ridx;
     }
 
@@ -173,32 +173,32 @@ void
 Sparse<T>::SparseRep::change_length (octave_idx_type nz)
 {
   if (nz != nzmx)
     {
       octave_idx_type min_nzmx = (nz < nzmx ? nz : nzmx);
 
       octave_idx_type * new_ridx = new octave_idx_type [nz];
       for (octave_idx_type i = 0; i < min_nzmx; i++)
-	new_ridx[i] = r[i];
+        new_ridx[i] = r[i];
 
       delete [] r;
       r = new_ridx;
 
       T * new_data = new T [nz];
       for (octave_idx_type i = 0; i < min_nzmx; i++)
-	new_data[i] = d[i];
+        new_data[i] = d[i];
 
       delete [] d;
       d = new_data;
 
       if (nz < nzmx)
-	for (octave_idx_type i = 0; i <= ncols; i++)
-	  if (c[i] > nz)
-	    c[i] = nz;
+        for (octave_idx_type i = 0; i <= ncols; i++)
+          if (c[i] > nz)
+            c[i] = nz;
 
       nzmx = nz;
     }
 }
 
 template <class T>
 bool
 Sparse<T>::SparseRep::indices_ok (void) const
@@ -215,50 +215,50 @@ Sparse<T>::Sparse (const Sparse<U>& a)
     rep = new typename Sparse<T>::SparseRep (rows (), cols());
   else
     {
       rep = new typename Sparse<T>::SparseRep (rows (), cols (), a.nnz ());
       
       octave_idx_type nz = a.nnz ();
       octave_idx_type nc = cols ();
       for (octave_idx_type i = 0; i < nz; i++)
-	{
-	  xdata (i) = T (a.data (i));
-	  xridx (i) = a.ridx (i);
-	}
+        {
+          xdata (i) = T (a.data (i));
+          xridx (i) = a.ridx (i);
+        }
       for (octave_idx_type i = 0; i < nc + 1; i++)
-	xcidx (i) = a.cidx (i);
+        xcidx (i) = a.cidx (i);
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (octave_idx_type nr, octave_idx_type nc, T val)
   : dimensions (dim_vector (nr, nc)), idx (0), idx_count (0)
 { 
   if (val != T ())
     {
       rep = new typename Sparse<T>::SparseRep (nr, nc, nr*nc);
 
       octave_idx_type ii = 0;
       xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      xdata (ii) = val;
-	      xridx (ii++) = i;
-	    } 
-	  xcidx (j+1) = ii;
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              xdata (ii) = val;
+              xridx (ii++) = i;
+            } 
+          xcidx (j+1) = ii;
+        }
     }
   else
     {
       rep = new typename Sparse<T>::SparseRep (nr, nc, 0);
       for (octave_idx_type j = 0; j < nc+1; j++)
-	xcidx(j) = 0;
+        xcidx(j) = 0;
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const dim_vector& dv)
   : dimensions (dv), idx (0), idx_count (0)
 { 
   if (dv.length() != 2)
@@ -291,265 +291,265 @@ Sparse<T>::Sparse (const Sparse<T>& a, c
       octave_idx_type old_nr = old_dims (0);
       octave_idx_type old_nc = old_dims (1);
 
       rep = new typename Sparse<T>::SparseRep (new_nr, new_nc, new_nzmx);
 
       octave_idx_type kk = 0;
       xcidx(0) = 0;
       for (octave_idx_type i = 0; i < old_nc; i++)
-	for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++)
-	  {
-	    octave_idx_type tmp = i * old_nr + a.ridx(j);
-	    octave_idx_type ii = tmp % new_nr;
-	    octave_idx_type jj = (tmp - ii) / new_nr; 
-	    for (octave_idx_type k = kk; k < jj; k++)
-	      xcidx(k+1) = j;
-	    kk = jj;
-	    xdata(j) = a.data(j);
-	    xridx(j) = ii;
-	  }
+        for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++)
+          {
+            octave_idx_type tmp = i * old_nr + a.ridx(j);
+            octave_idx_type ii = tmp % new_nr;
+            octave_idx_type jj = (tmp - ii) / new_nr; 
+            for (octave_idx_type k = kk; k < jj; k++)
+              xcidx(k+1) = j;
+            kk = jj;
+            xdata(j) = a.data(j);
+            xridx(j) = ii;
+          }
       for (octave_idx_type k = kk; k < new_nc; k++)
-	xcidx(k+1) = new_nzmx;
+        xcidx(k+1) = new_nzmx;
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const Array<T>& a, const Array<octave_idx_type>& r, 
-		   const Array<octave_idx_type>& c, octave_idx_type nr,
-		   octave_idx_type nc, bool sum_terms)
+                   const Array<octave_idx_type>& c, octave_idx_type nr,
+                   octave_idx_type nc, bool sum_terms)
   : dimensions (dim_vector (nr, nc)), idx (0), idx_count (0)
 {
   octave_idx_type a_len = a.length ();
   octave_idx_type r_len = r.length ();
   octave_idx_type c_len = c.length ();
   bool ri_scalar = (r_len == 1); 
   bool ci_scalar = (c_len == 1);
   bool cf_scalar = (a_len == 1);
   
   if ((a_len != r_len && !cf_scalar && !ri_scalar) ||
       (a_len != c_len && !cf_scalar && !ci_scalar) ||
       (r_len != c_len && !ri_scalar && !ci_scalar) || nr < 0 || nc < 0)
     {
       (*current_liboctave_error_handler)
-	("Sparse::Sparse (const Array<T>&, const Array<octave_idx_type>&, ...): dimension mismatch");
+        ("Sparse::Sparse (const Array<T>&, const Array<octave_idx_type>&, ...): dimension mismatch");
       rep = nil_rep ();
       dimensions = dim_vector (0, 0);
     }
   else
     {
       octave_idx_type max_nzmx = (r_len > c_len ? r_len : c_len);
 
       OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl *, sidx, max_nzmx);
       OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl, sidxX, max_nzmx);
 
       for (octave_idx_type i = 0; i < max_nzmx; i++)
-	sidx[i] = &sidxX[i];
+        sidx[i] = &sidxX[i];
 
       octave_idx_type actual_nzmx = 0;
       octave_quit ();
       for (octave_idx_type i = 0; i < max_nzmx; i++) 
-	{
-	  octave_idx_type rowidx =  (ri_scalar ? r(0) : r(i));
-	  octave_idx_type colidx = (ci_scalar ? c(0) : c(i));
-	  if (rowidx < nr && rowidx >= 0 &&
-	      colidx < nc && colidx >= 0 ) 
-	    {
-	      if ( a (cf_scalar ? 0 : i ) != T ()) 
-		{
-		  sidx[actual_nzmx]->r = rowidx;
-		  sidx[actual_nzmx]->c = colidx;
-		  sidx[actual_nzmx]->idx = i;
-		  actual_nzmx++;	
-		}
-	    }
-	  else 
-	    {
-	      (*current_liboctave_error_handler)
-		("Sparse::Sparse : index (%d,%d) out of range", 
-		 rowidx + 1, colidx + 1);
-	      rep = nil_rep ();
-	      dimensions = dim_vector (0, 0);
-	      return;
-	    }
-	}
+        {
+          octave_idx_type rowidx =  (ri_scalar ? r(0) : r(i));
+          octave_idx_type colidx = (ci_scalar ? c(0) : c(i));
+          if (rowidx < nr && rowidx >= 0 &&
+              colidx < nc && colidx >= 0 ) 
+            {
+              if ( a (cf_scalar ? 0 : i ) != T ()) 
+                {
+                  sidx[actual_nzmx]->r = rowidx;
+                  sidx[actual_nzmx]->c = colidx;
+                  sidx[actual_nzmx]->idx = i;
+                  actual_nzmx++;        
+                }
+            }
+          else 
+            {
+              (*current_liboctave_error_handler)
+                ("Sparse::Sparse : index (%d,%d) out of range", 
+                 rowidx + 1, colidx + 1);
+              rep = nil_rep ();
+              dimensions = dim_vector (0, 0);
+              return;
+            }
+        }
   
       if (actual_nzmx == 0)
-	rep = new typename Sparse<T>::SparseRep (nr, nc);
+        rep = new typename Sparse<T>::SparseRep (nr, nc);
       else
-	{
-	  octave_quit ();
-	  octave_sort<octave_sparse_sort_idxl *> 
-	    lsort (octave_sparse_sidxl_comp);
-
-	  lsort.sort (sidx, actual_nzmx);
-	  octave_quit ();
-
-	  // Now count the unique non-zero values
-	  octave_idx_type real_nzmx = 1;
-	  for (octave_idx_type i = 1; i < actual_nzmx; i++) 
-	    if (sidx[i-1]->r != sidx[i]->r || sidx[i-1]->c != sidx[i]->c) 
-	      real_nzmx++;
-
-	  rep = new typename Sparse<T>::SparseRep (nr, nc, real_nzmx);
-
-	  octave_idx_type cx = 0;
-	  octave_idx_type prev_rval = -1;
-	  octave_idx_type prev_cval = -1;
-	  octave_idx_type ii = -1;
-	  xcidx (0) = 0;
-	  for (octave_idx_type i = 0; i < actual_nzmx; i++) 
-	    {
-	      octave_quit ();
-	      octave_idx_type iidx = sidx[i]->idx;
-	      octave_idx_type rval = sidx[i]->r;
-	      octave_idx_type cval = sidx[i]->c;
-
-	      if (prev_cval < cval || (prev_rval < rval && prev_cval == cval)) 
-		{
-		  octave_idx_type ci = static_cast<octave_idx_type> (c (ci_scalar ? 0 : iidx));
-		  ii++;
-		  while (cx < ci) 
-		    xcidx (++cx) = ii;
-		  xdata(ii) = a (cf_scalar ? 0 : iidx);
-		  xridx(ii) = static_cast<octave_idx_type> (r (ri_scalar ? 0 : iidx));
-		} 
-	      else 
-		{
-		  if (sum_terms)
-		    xdata(ii) += a (cf_scalar ? 0 : iidx);
-		  else
-		    xdata(ii) =  a (cf_scalar ? 0 : iidx);
-		}
-	      prev_rval = rval;
-	      prev_cval = cval;
-	    } 
-
-	  while (cx < nc) 
-	    xcidx (++cx) = ii + 1;
-	}
+        {
+          octave_quit ();
+          octave_sort<octave_sparse_sort_idxl *> 
+            lsort (octave_sparse_sidxl_comp);
+
+          lsort.sort (sidx, actual_nzmx);
+          octave_quit ();
+
+          // Now count the unique non-zero values
+          octave_idx_type real_nzmx = 1;
+          for (octave_idx_type i = 1; i < actual_nzmx; i++) 
+            if (sidx[i-1]->r != sidx[i]->r || sidx[i-1]->c != sidx[i]->c) 
+              real_nzmx++;
+
+          rep = new typename Sparse<T>::SparseRep (nr, nc, real_nzmx);
+
+          octave_idx_type cx = 0;
+          octave_idx_type prev_rval = -1;
+          octave_idx_type prev_cval = -1;
+          octave_idx_type ii = -1;
+          xcidx (0) = 0;
+          for (octave_idx_type i = 0; i < actual_nzmx; i++) 
+            {
+              octave_quit ();
+              octave_idx_type iidx = sidx[i]->idx;
+              octave_idx_type rval = sidx[i]->r;
+              octave_idx_type cval = sidx[i]->c;
+
+              if (prev_cval < cval || (prev_rval < rval && prev_cval == cval)) 
+                {
+                  octave_idx_type ci = static_cast<octave_idx_type> (c (ci_scalar ? 0 : iidx));
+                  ii++;
+                  while (cx < ci) 
+                    xcidx (++cx) = ii;
+                  xdata(ii) = a (cf_scalar ? 0 : iidx);
+                  xridx(ii) = static_cast<octave_idx_type> (r (ri_scalar ? 0 : iidx));
+                } 
+              else 
+                {
+                  if (sum_terms)
+                    xdata(ii) += a (cf_scalar ? 0 : iidx);
+                  else
+                    xdata(ii) =  a (cf_scalar ? 0 : iidx);
+                }
+              prev_rval = rval;
+              prev_cval = cval;
+            } 
+
+          while (cx < nc) 
+            xcidx (++cx) = ii + 1;
+        }
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const Array<T>& a, const Array<double>& r, 
-		   const Array<double>& c, octave_idx_type nr,
-		   octave_idx_type nc, bool sum_terms)
+                   const Array<double>& c, octave_idx_type nr,
+                   octave_idx_type nc, bool sum_terms)
   : dimensions (dim_vector (nr, nc)), idx (0), idx_count (0)
 {
   octave_idx_type a_len = a.length ();
   octave_idx_type r_len = r.length ();
   octave_idx_type c_len = c.length ();
   bool ri_scalar = (r_len == 1); 
   bool ci_scalar = (c_len == 1);
   bool cf_scalar = (a_len == 1);
 
   if ((a_len != r_len && !cf_scalar && !ri_scalar) ||
       (a_len != c_len && !cf_scalar && !ci_scalar) ||
       (r_len != c_len && !ri_scalar && !ci_scalar) || nr < 0 || nc < 0)
     {
       (*current_liboctave_error_handler)
-	("Sparse::Sparse (const Array<T>&, const Array<double>&, ...): dimension mismatch");
+        ("Sparse::Sparse (const Array<T>&, const Array<double>&, ...): dimension mismatch");
       rep = nil_rep ();
       dimensions = dim_vector (0, 0);
     }
   else
     {
       octave_idx_type max_nzmx = (r_len > c_len ? r_len : c_len);
   
       OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl *, sidx, max_nzmx);
       OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl, sidxX, max_nzmx);
 
       for (octave_idx_type i = 0; i < max_nzmx; i++)
-	sidx[i] = &sidxX[i];
+        sidx[i] = &sidxX[i];
 
       octave_idx_type actual_nzmx = 0;
       octave_quit ();
 
       for (octave_idx_type i = 0; i < max_nzmx; i++) 
-	{
-	  octave_idx_type rowidx = static_cast<octave_idx_type> (ri_scalar ? r(0) : r(i));
-	  octave_idx_type colidx = static_cast<octave_idx_type> (ci_scalar ? c(0) : c(i));
-	  if (rowidx < nr && rowidx >= 0 &&
-	      colidx < nc && colidx >= 0 ) 
-	    {
-	      if ( a (cf_scalar ? 0 : i ) != T ()) 
-		{
-		  sidx[actual_nzmx]->r = rowidx;
-		  sidx[actual_nzmx]->c = colidx;
-		  sidx[actual_nzmx]->idx = i;
-		  actual_nzmx++;	
-		}
-	    }
-	  else 
-	    {
-	      (*current_liboctave_error_handler)
-		("Sparse::Sparse : index (%d,%d) out of range", 
-		 rowidx + 1, colidx + 1);
-	      rep = nil_rep ();
-	      dimensions = dim_vector (0, 0);
-	      return;
-	    }
-	}
+        {
+          octave_idx_type rowidx = static_cast<octave_idx_type> (ri_scalar ? r(0) : r(i));
+          octave_idx_type colidx = static_cast<octave_idx_type> (ci_scalar ? c(0) : c(i));
+          if (rowidx < nr && rowidx >= 0 &&
+              colidx < nc && colidx >= 0 ) 
+            {
+              if ( a (cf_scalar ? 0 : i ) != T ()) 
+                {
+                  sidx[actual_nzmx]->r = rowidx;
+                  sidx[actual_nzmx]->c = colidx;
+                  sidx[actual_nzmx]->idx = i;
+                  actual_nzmx++;        
+                }
+            }
+          else 
+            {
+              (*current_liboctave_error_handler)
+                ("Sparse::Sparse : index (%d,%d) out of range", 
+                 rowidx + 1, colidx + 1);
+              rep = nil_rep ();
+              dimensions = dim_vector (0, 0);
+              return;
+            }
+        }
 
       if (actual_nzmx == 0)
-	rep = new typename Sparse<T>::SparseRep (nr, nc);
+        rep = new typename Sparse<T>::SparseRep (nr, nc);
       else
-	{
-	  octave_quit ();
-	  octave_sort<octave_sparse_sort_idxl *> 
-	    lsort (octave_sparse_sidxl_comp);
-
-	  lsort.sort (sidx, actual_nzmx);
-	  octave_quit ();
-
-	  // Now count the unique non-zero values
-	  octave_idx_type real_nzmx = 1;
-	  for (octave_idx_type i = 1; i < actual_nzmx; i++) 
-	    if (sidx[i-1]->r != sidx[i]->r || sidx[i-1]->c != sidx[i]->c) 
-	      real_nzmx++;
-
-	  rep = new typename Sparse<T>::SparseRep (nr, nc, real_nzmx);
-
-	  octave_idx_type cx = 0;
-	  octave_idx_type prev_rval = -1;
-	  octave_idx_type prev_cval = -1;
-	  octave_idx_type ii = -1;
-	  xcidx (0) = 0;
-	  for (octave_idx_type i = 0; i < actual_nzmx; i++) 
-	    {
-	      octave_quit ();
-	      octave_idx_type iidx = sidx[i]->idx;
-	      octave_idx_type rval = sidx[i]->r;
-	      octave_idx_type cval = sidx[i]->c;
-
-	      if (prev_cval < cval || (prev_rval < rval && prev_cval == cval)) 
-		{
-		  octave_idx_type ci = static_cast<octave_idx_type> (c (ci_scalar ? 0 : iidx));
-		  ii++;
-
-		  while (cx < ci) 
-		    xcidx (++cx) = ii;
-		  xdata(ii) = a (cf_scalar ? 0 : iidx);
-		  xridx(ii) = static_cast<octave_idx_type> (r (ri_scalar ? 0 : iidx));
-		} 
-	      else 
-		{
-		  if (sum_terms)
-		    xdata(ii) += a (cf_scalar ? 0 : iidx);
-		  else
-		    xdata(ii) =  a (cf_scalar ? 0 : iidx);
-		}
-	      prev_rval = rval;
-	      prev_cval = cval;
-	    } 
-
-	  while (cx < nc) 
-	    xcidx (++cx) = ii + 1;
-	}
+        {
+          octave_quit ();
+          octave_sort<octave_sparse_sort_idxl *> 
+            lsort (octave_sparse_sidxl_comp);
+
+          lsort.sort (sidx, actual_nzmx);
+          octave_quit ();
+
+          // Now count the unique non-zero values
+          octave_idx_type real_nzmx = 1;
+          for (octave_idx_type i = 1; i < actual_nzmx; i++) 
+            if (sidx[i-1]->r != sidx[i]->r || sidx[i-1]->c != sidx[i]->c) 
+              real_nzmx++;
+
+          rep = new typename Sparse<T>::SparseRep (nr, nc, real_nzmx);
+
+          octave_idx_type cx = 0;
+          octave_idx_type prev_rval = -1;
+          octave_idx_type prev_cval = -1;
+          octave_idx_type ii = -1;
+          xcidx (0) = 0;
+          for (octave_idx_type i = 0; i < actual_nzmx; i++) 
+            {
+              octave_quit ();
+              octave_idx_type iidx = sidx[i]->idx;
+              octave_idx_type rval = sidx[i]->r;
+              octave_idx_type cval = sidx[i]->c;
+
+              if (prev_cval < cval || (prev_rval < rval && prev_cval == cval)) 
+                {
+                  octave_idx_type ci = static_cast<octave_idx_type> (c (ci_scalar ? 0 : iidx));
+                  ii++;
+
+                  while (cx < ci) 
+                    xcidx (++cx) = ii;
+                  xdata(ii) = a (cf_scalar ? 0 : iidx);
+                  xridx(ii) = static_cast<octave_idx_type> (r (ri_scalar ? 0 : iidx));
+                } 
+              else 
+                {
+                  if (sum_terms)
+                    xdata(ii) += a (cf_scalar ? 0 : iidx);
+                  else
+                    xdata(ii) =  a (cf_scalar ? 0 : iidx);
+                }
+              prev_rval = rval;
+              prev_cval = cval;
+            } 
+
+          while (cx < nc) 
+            xcidx (++cx) = ii + 1;
+        }
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const Array2<T>& a)
   : dimensions (a.dims ()), idx (0), idx_count (0)
 {
   octave_idx_type nr = rows ();
@@ -564,21 +564,21 @@ Sparse<T>::Sparse (const Array2<T>& a)
 
   rep = new typename Sparse<T>::SparseRep (nr, nc, new_nzmx);
 
   octave_idx_type ii = 0;
   xcidx(0) = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = 0; i < nr; i++)
-	if (a.elem (i,j) != T ())
-	  {
-	    xdata(ii) = a.elem (i,j);
-	    xridx(ii++) = i;
-	  }
+        if (a.elem (i,j) != T ())
+          {
+            xdata(ii) = a.elem (i,j);
+            xridx(ii++) = i;
+          }
       xcidx(j+1) = ii;
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const Array<T>& a)
   : dimensions (a.dims ()), idx (0), idx_count (0)
 {
@@ -589,33 +589,33 @@ Sparse<T>::Sparse (const Array<T>& a)
     {
       octave_idx_type nr = rows ();
       octave_idx_type nc = cols ();
       octave_idx_type len = a.length ();
       octave_idx_type new_nzmx = 0;
 
       // First count the number of non-zero terms
       for (octave_idx_type i = 0; i < len; i++)
-	if (a(i) != T ())
-	  new_nzmx++;
+        if (a(i) != T ())
+          new_nzmx++;
 
       rep = new typename Sparse<T>::SparseRep (nr, nc, new_nzmx);
 
       octave_idx_type ii = 0;
       xcidx(0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    if (a.elem (i,j) != T ())
-	      {
-		xdata(ii) = a.elem (i,j);
-		xridx(ii++) = i;
-	      }
-	  xcidx(j+1) = ii;
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            if (a.elem (i,j) != T ())
+              {
+                xdata(ii) = a.elem (i,j);
+                xridx(ii++) = i;
+              }
+          xcidx(j+1) = ii;
+        }
     }
 }
 
 template <class T>
 Sparse<T>::~Sparse (void)
 {
   if (--rep->count <= 0)
     delete rep;
@@ -625,17 +625,17 @@ Sparse<T>::~Sparse (void)
 
 template <class T>
 Sparse<T>&
 Sparse<T>::operator = (const Sparse<T>& a)
 {
   if (this != &a)
     {
       if (--rep->count <= 0)
-	delete rep;
+        delete rep;
 
       rep = a.rep;
       rep->count++;
 
       dimensions = a.dimensions;
 
       delete [] idx;
       idx_count = 0;
@@ -653,20 +653,20 @@ Sparse<T>::compute_index (const Array<oc
 
   octave_idx_type n = dimensions.length ();
 
   if (n > 0 && n == ra_idx.length ())
     {
       retval = ra_idx(--n);
 
       while (--n >= 0)
-	{
-	  retval *= dimensions(n);
-	  retval += ra_idx(n);
-	}
+        {
+          retval *= dimensions(n);
+          retval += ra_idx(n);
+        }
     }
   else
     (*current_liboctave_error_handler)
       ("Sparse<T>::compute_index: invalid ra_idxing operation");
 
   return retval;
 }
 
@@ -762,61 +762,61 @@ Sparse<T>
 Sparse<T>::reshape (const dim_vector& new_dims) const
 {
   Sparse<T> retval;
   dim_vector dims2 = new_dims;
 
   if (dims2.length () > 2)
     {
       (*current_liboctave_warning_handler)
-	("reshape: sparse reshape to N-d array smashes dims");
+        ("reshape: sparse reshape to N-d array smashes dims");
 
       for (octave_idx_type i = 2; i < dims2.length(); i++)
-	dims2(1) *= dims2(i);
+        dims2(1) *= dims2(i);
 
       dims2.resize (2);
     }
 
   if (dimensions != dims2)
     {
       if (dimensions.numel () == dims2.numel ())
-	{
-	  octave_idx_type new_nnz = nnz ();
-	  octave_idx_type new_nr = dims2 (0);
-	  octave_idx_type new_nc = dims2 (1);
-	  octave_idx_type old_nr = rows ();
-	  octave_idx_type old_nc = cols ();
-	  retval = Sparse<T> (new_nr, new_nc, new_nnz);
-
-	  octave_idx_type kk = 0;
-	  retval.xcidx(0) = 0;
-	  for (octave_idx_type i = 0; i < old_nc; i++)
-	    for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
-	      {
-		octave_idx_type tmp = i * old_nr + ridx(j);
-		octave_idx_type ii = tmp % new_nr;
-		octave_idx_type jj = (tmp - ii) / new_nr; 
-		for (octave_idx_type k = kk; k < jj; k++)
-		  retval.xcidx(k+1) = j;
-		kk = jj;
-		retval.xdata(j) = data(j);
-		retval.xridx(j) = ii;
-	      }
-	  for (octave_idx_type k = kk; k < new_nc; k++)
-	    retval.xcidx(k+1) = new_nnz;
-	}
+        {
+          octave_idx_type new_nnz = nnz ();
+          octave_idx_type new_nr = dims2 (0);
+          octave_idx_type new_nc = dims2 (1);
+          octave_idx_type old_nr = rows ();
+          octave_idx_type old_nc = cols ();
+          retval = Sparse<T> (new_nr, new_nc, new_nnz);
+
+          octave_idx_type kk = 0;
+          retval.xcidx(0) = 0;
+          for (octave_idx_type i = 0; i < old_nc; i++)
+            for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
+              {
+                octave_idx_type tmp = i * old_nr + ridx(j);
+                octave_idx_type ii = tmp % new_nr;
+                octave_idx_type jj = (tmp - ii) / new_nr; 
+                for (octave_idx_type k = kk; k < jj; k++)
+                  retval.xcidx(k+1) = j;
+                kk = jj;
+                retval.xdata(j) = data(j);
+                retval.xridx(j) = ii;
+              }
+          for (octave_idx_type k = kk; k < new_nc; k++)
+            retval.xcidx(k+1) = new_nnz;
+        }
       else
-	{
-	  std::string dimensions_str = dimensions.str ();
-	  std::string new_dims_str = new_dims.str ();
-
-	  (*current_liboctave_error_handler)
-	    ("reshape: can't reshape %s array to %s array",
-	     dimensions_str.c_str (), new_dims_str.c_str ());
-	}
+        {
+          std::string dimensions_str = dimensions.str ();
+          std::string new_dims_str = new_dims.str ();
+
+          (*current_liboctave_error_handler)
+            ("reshape: can't reshape %s array to %s array",
+             dimensions_str.c_str (), new_dims_str.c_str ());
+        }
     }
   else
     retval = *this;
 
   return retval;
 }
 
 template <class T>
@@ -826,21 +826,21 @@ Sparse<T>::permute (const Array<octave_i
   // The only valid permutations of a sparse array are [1, 2] and [2, 1].
 
   bool fail = false;
   bool trans = false;
 
   if (perm_vec.length () == 2)
     {
       if (perm_vec(0) == 0 && perm_vec(1) == 1)
-	/* do nothing */;
+        /* do nothing */;
       else if (perm_vec(0) == 1 && perm_vec(1) == 0)
-	trans = true;
+        trans = true;
       else
-	fail = true;
+        fail = true;
     }
   else
     fail = true;
 
   if (fail)
     (*current_liboctave_error_handler)
       ("permutation vector contains an invalid element");
 
@@ -864,17 +864,17 @@ Sparse<T>::resize_no_fill (const dim_vec
 
 template <class T>
 void
 Sparse<T>::resize_no_fill (octave_idx_type r, octave_idx_type c)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler)
-	("can't resize to negative dimension");
+        ("can't resize to negative dimension");
       return;
     }
 
   if (ndims () == 0)
     dimensions = dim_vector (0, 0);
 
   if (r == dim1 () && c == dim2 ())
     return;
@@ -888,73 +888,73 @@ Sparse<T>::resize_no_fill (octave_idx_ty
     // Special case of redimensioning to/from a sparse matrix with 
     // no elements
     rep = new typename Sparse<T>::SparseRep (r, c);
   else
     {
       octave_idx_type n = 0;
       Sparse<T> tmpval;
       if (r >= nr)
-	{
-	  if (c > nc)
-	    n = xcidx(nc);
-	  else
-	    n = xcidx(c);
-
-	  tmpval = Sparse<T> (r, c, n);
-
-	  if (c > nc)
-	    {
-	      for (octave_idx_type i = 0; i < nc + 1; i++)
-		tmpval.cidx(i) = xcidx(i);
-	      for (octave_idx_type i = nc + 1; i < c + 1; i++)
-		tmpval.cidx(i) = tmpval.cidx(i-1);
-	    }
-	  else if (c <= nc)
-	    for (octave_idx_type i = 0; i < c + 1; i++)
-	      tmpval.cidx(i) = xcidx(i);
-	  
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      tmpval.data(i) = xdata(i);
-	      tmpval.ridx(i) = xridx(i);
-	    }
-	}
+        {
+          if (c > nc)
+            n = xcidx(nc);
+          else
+            n = xcidx(c);
+
+          tmpval = Sparse<T> (r, c, n);
+
+          if (c > nc)
+            {
+              for (octave_idx_type i = 0; i < nc + 1; i++)
+                tmpval.cidx(i) = xcidx(i);
+              for (octave_idx_type i = nc + 1; i < c + 1; i++)
+                tmpval.cidx(i) = tmpval.cidx(i-1);
+            }
+          else if (c <= nc)
+            for (octave_idx_type i = 0; i < c + 1; i++)
+              tmpval.cidx(i) = xcidx(i);
+          
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              tmpval.data(i) = xdata(i);
+              tmpval.ridx(i) = xridx(i);
+            }
+        }
       else
-	{
-	  // Count how many non zero terms before we do anything
-	  octave_idx_type min_nc = (c < nc ? c : nc);
-	  for (octave_idx_type i = 0; i < min_nc; i++)
-	    for (octave_idx_type j = xcidx(i); j < xcidx(i+1); j++)
-	      if (xridx(j) < r)
-		n++;
-
-	  if (n)
-	    {
-	      // Now that we know the size we can do something
-	      tmpval = Sparse<T> (r, c, n);
-
-	      tmpval.cidx(0);
-	      for (octave_idx_type i = 0, ii = 0; i < min_nc; i++)
-		{
-		  for (octave_idx_type j = xcidx(i); j < xcidx(i+1); j++)
-		    if (xridx(j) < r)
-		      {
-			tmpval.data(ii) = xdata(j);
-			tmpval.ridx(ii++) = xridx(j);
-		      }
-		  tmpval.cidx(i+1) = ii;
-		}
-	      if (c > min_nc)
-		for (octave_idx_type i = nc; i < c; i++)
-		  tmpval.cidx(i+1) = tmpval.cidx(i);
-	    }
-	  else
-	    tmpval = Sparse<T> (r, c);
-	}
+        {
+          // Count how many non zero terms before we do anything
+          octave_idx_type min_nc = (c < nc ? c : nc);
+          for (octave_idx_type i = 0; i < min_nc; i++)
+            for (octave_idx_type j = xcidx(i); j < xcidx(i+1); j++)
+              if (xridx(j) < r)
+                n++;
+
+          if (n)
+            {
+              // Now that we know the size we can do something
+              tmpval = Sparse<T> (r, c, n);
+
+              tmpval.cidx(0);
+              for (octave_idx_type i = 0, ii = 0; i < min_nc; i++)
+                {
+                  for (octave_idx_type j = xcidx(i); j < xcidx(i+1); j++)
+                    if (xridx(j) < r)
+                      {
+                        tmpval.data(ii) = xdata(j);
+                        tmpval.ridx(ii++) = xridx(j);
+                      }
+                  tmpval.cidx(i+1) = ii;
+                }
+              if (c > min_nc)
+                for (octave_idx_type i = nc; i < c; i++)
+                  tmpval.cidx(i+1) = tmpval.cidx(i);
+            }
+          else
+            tmpval = Sparse<T> (r, c);
+        }
 
       rep = tmpval.rep;
       rep->count++;
     }
 
   dimensions = dim_vector (r, c);
 
   if (--old_rep->count <= 0)
@@ -980,17 +980,17 @@ Sparse<T>::insert (const Sparse<T>& a, o
   octave_idx_type nel = cidx(c) + a.nnz ();
 
   if (c + a_cols < nc)
     nel += cidx(nc) - cidx(c + a_cols);
 
   for (octave_idx_type i = c; i < c + a_cols; i++)
     for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
       if (ridx(j) < r || ridx(j) >= r + a_rows)
-	nel++;
+        nel++;
 
   Sparse<T> tmp (*this);
   --rep->count;
   rep = new typename Sparse<T>::SparseRep (nr, nc, nel);
 
   for (octave_idx_type i = 0; i < tmp.cidx(c); i++)
     {
       data(i) = tmp.data(i);
@@ -1001,49 +1001,49 @@ Sparse<T>::insert (const Sparse<T>& a, o
 
   octave_idx_type ii = cidx(c);
 
   for (octave_idx_type i = c; i < c + a_cols; i++)
     {
       octave_quit ();
 
       for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
-	if (tmp.ridx(j) < r)
-	  {
-	    data(ii) = tmp.data(j);
-	    ridx(ii++) = tmp.ridx(j);
-	  }
+        if (tmp.ridx(j) < r)
+          {
+            data(ii) = tmp.data(j);
+            ridx(ii++) = tmp.ridx(j);
+          }
 
       octave_quit ();
 
       for (octave_idx_type j = a.cidx(i-c); j < a.cidx(i-c+1); j++)
-	{
-	  data(ii) = a.data(j);
-	  ridx(ii++) = r + a.ridx(j);
-	}
+        {
+          data(ii) = a.data(j);
+          ridx(ii++) = r + a.ridx(j);
+        }
 
       octave_quit ();
 
       for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
-	if (tmp.ridx(j) >= r + a_rows)
-	  {
-	    data(ii) = tmp.data(j);
-	    ridx(ii++) = tmp.ridx(j);
-	  }
+        if (tmp.ridx(j) >= r + a_rows)
+          {
+            data(ii) = tmp.data(j);
+            ridx(ii++) = tmp.ridx(j);
+          }
 
       cidx(i+1) = ii;
     }
 
   for (octave_idx_type i = c + a_cols; i < nc; i++)
     {
       for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
-	{
-	  data(ii) = tmp.data(j);
-	  ridx(ii++) = tmp.ridx(j);
-	}
+        {
+          data(ii) = tmp.data(j);
+          ridx(ii++) = tmp.ridx(j);
+        }
       cidx(i+1) = ii;
     }
 
   return *this;
 }
 
 template <class T>
 Sparse<T>&
@@ -1080,19 +1080,19 @@ Sparse<T>::transpose (void) const
       retval.xcidx (i) = nz;
       nz += tmp;
     }
   // retval.xcidx[1:nr] holds row entry *start* offsets for rows 0:(nr-1)
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
       {
-	octave_idx_type q = retval.xcidx (ridx (k) + 1)++;
-	retval.xridx (q) = j;
-	retval.xdata (q) = data (k);
+        octave_idx_type q = retval.xcidx (ridx (k) + 1)++;
+        retval.xridx (q) = j;
+        retval.xdata (q) = data (k);
       }
   assert (nnz () == retval.xcidx (nr));
   // retval.xcidx[1:nr] holds row entry *end* offsets for rows 0:(nr-1)
   // and retval.xcidx[0:(nr-1)] holds their row entry *start* offsets
 
   return retval;
 }
 
@@ -1118,17 +1118,17 @@ Sparse<T>::set_index (const idx_vector& 
     {
       idx[idx_count++] = idx_arg;
     }
   else
     {
       idx_vector *new_idx = new idx_vector [idx_count+1];
 
       for (octave_idx_type i = 0; i < idx_count; i++)
-	new_idx[i] = idx[i];
+        new_idx[i] = idx[i];
 
       new_idx[idx_count++] = idx_arg;
 
       delete [] idx;
 
       idx = new_idx;
     }
 }
@@ -1177,90 +1177,90 @@ Sparse<T>::maybe_delete_elements (idx_ve
       octave_idx_type new_n = n;
       octave_idx_type new_nnz = nnz ();
 
       octave_idx_type iidx = 0;
 
       const Sparse<T> tmp (*this);
 
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  octave_quit ();
-
-	  if (i == idx_arg.elem (iidx))
-	    {
-	      iidx++;
-	      new_n--;
-
-	      if (tmp.elem (i) != T ())
-		new_nnz--;
-
-	      if (iidx == num_to_delete)
-		break;
-	    }
-	}
+        {
+          octave_quit ();
+
+          if (i == idx_arg.elem (iidx))
+            {
+              iidx++;
+              new_n--;
+
+              if (tmp.elem (i) != T ())
+                new_nnz--;
+
+              if (iidx == num_to_delete)
+                break;
+            }
+        }
 
       if (new_n > 0)
-	{
-	  rep->count--;
-
-	  if (nr == 1)
-	    rep = new typename Sparse<T>::SparseRep (1, new_n, new_nnz);
-	  else
-	    rep = new typename Sparse<T>::SparseRep (new_n, 1, new_nnz);
-
-	  octave_idx_type ii = 0;
-	  octave_idx_type jj = 0;
-	  iidx = 0;
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      octave_quit ();
-
-	      if (iidx < num_to_delete && i == idx_arg.elem (iidx))
-		iidx++;
-	      else
-		{
-		  T el = tmp.elem (i);
-		  if (el != T ())
-		    {
-		      data(ii) = el;
-		      ridx(ii++) = jj;
-		    }
-		  jj++;
-		}
-	    }
-
-	  dimensions.resize (2);
-
-	  if (nr == 1)
-	    {
-	      ii = 0;
-	      cidx(0) = 0;
-	      for (octave_idx_type i = 0; i < new_n; i++)
-		{
-		  octave_quit ();
-		  if (ridx(ii) == i)
-		    ridx(ii++) = 0;
-		  cidx(i+1) = ii;
-		}
-
-	      dimensions(0) = 1;
-	      dimensions(1) = new_n;
-	    }
-	  else
-	    {
-	      cidx(0) = 0;
-	      cidx(1) = new_nnz;
-	      dimensions(0) = new_n;
-	      dimensions(1) = 1;
-	    }
-	}
+        {
+          rep->count--;
+
+          if (nr == 1)
+            rep = new typename Sparse<T>::SparseRep (1, new_n, new_nnz);
+          else
+            rep = new typename Sparse<T>::SparseRep (new_n, 1, new_nnz);
+
+          octave_idx_type ii = 0;
+          octave_idx_type jj = 0;
+          iidx = 0;
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              octave_quit ();
+
+              if (iidx < num_to_delete && i == idx_arg.elem (iidx))
+                iidx++;
+              else
+                {
+                  T el = tmp.elem (i);
+                  if (el != T ())
+                    {
+                      data(ii) = el;
+                      ridx(ii++) = jj;
+                    }
+                  jj++;
+                }
+            }
+
+          dimensions.resize (2);
+
+          if (nr == 1)
+            {
+              ii = 0;
+              cidx(0) = 0;
+              for (octave_idx_type i = 0; i < new_n; i++)
+                {
+                  octave_quit ();
+                  if (ridx(ii) == i)
+                    ridx(ii++) = 0;
+                  cidx(i+1) = ii;
+                }
+
+              dimensions(0) = 1;
+              dimensions(1) = new_n;
+            }
+          else
+            {
+              cidx(0) = 0;
+              cidx(1) = new_nnz;
+              dimensions(0) = new_n;
+              dimensions(1) = 1;
+            }
+        }
       else
-	(*current_liboctave_error_handler)
-	  ("A(idx) = []: index out of range");
+        (*current_liboctave_error_handler)
+          ("A(idx) = []: index out of range");
     }
 }
 
 template <class T>
 void
 Sparse<T>::maybe_delete_elements (idx_vector& idx_i, idx_vector& idx_j)
 {
   assert (ndims () == 2);
@@ -1269,202 +1269,202 @@ Sparse<T>::maybe_delete_elements (idx_ve
   octave_idx_type nc = dim2 ();
 
   if (nr == 0 && nc == 0)
     return;
 
   if (idx_i.is_colon ())
     {
       if (idx_j.is_colon ())
-	{
-	  // A(:,:) -- We are deleting columns and rows, so the result
-	  // is [](0x0).
-
-	  resize_no_fill (0, 0);
-	  return;
-	}
+        {
+          // A(:,:) -- We are deleting columns and rows, so the result
+          // is [](0x0).
+
+          resize_no_fill (0, 0);
+          return;
+        }
 
       if (idx_j.is_colon_equiv (nc, 1))
-	{
-	  // A(:,j) -- We are deleting columns by enumerating them,
-	  // If we enumerate all of them, we should have zero columns
-	  // with the same number of rows that we started with.
-
-	  resize_no_fill (nr, 0);
-	  return;
-	}
+        {
+          // A(:,j) -- We are deleting columns by enumerating them,
+          // If we enumerate all of them, we should have zero columns
+          // with the same number of rows that we started with.
+
+          resize_no_fill (nr, 0);
+          return;
+        }
     }
 
   if (idx_j.is_colon () && idx_i.is_colon_equiv (nr, 1))
     {
       // A(i,:) -- We are deleting rows by enumerating them.  If we
       // enumerate all of them, we should have zero rows with the
       // same number of columns that we started with.
 
       resize_no_fill (0, nc);
       return;
     }
 
   if (idx_i.is_colon_equiv (nr, 1))
     {
       if (idx_j.is_colon_equiv (nc, 1))
-	resize_no_fill (0, 0);
+        resize_no_fill (0, 0);
       else
-	{
-	  idx_j.sort (true);
-
-	  octave_idx_type num_to_delete = idx_j.length (nc);
-
-	  if (num_to_delete != 0)
-	    {
-	      if (nr == 1 && num_to_delete == nc)
-		resize_no_fill (0, 0);
-	      else
-		{
-		  octave_idx_type new_nc = nc;
-		  octave_idx_type new_nnz = nnz ();
-
-		  octave_idx_type iidx = 0;
-
-		  for (octave_idx_type j = 0; j < nc; j++)
-		    {
-		      octave_quit ();
-
-		      if (j == idx_j.elem (iidx))
-			{
-			  iidx++;
-			  new_nc--;
-			  
-			  new_nnz -= cidx(j+1) - cidx(j);
-
-			  if (iidx == num_to_delete)
-			    break;
-			}
-		    }
-
-		  if (new_nc > 0)
-		    {
-		      const Sparse<T> tmp (*this);
-		      --rep->count;
-		      rep = new typename Sparse<T>::SparseRep (nr, new_nc, 
-							       new_nnz);
-		      octave_idx_type ii = 0;
-		      octave_idx_type jj = 0;
-		      iidx = 0;
-		      cidx(0) = 0;
-		      for (octave_idx_type j = 0; j < nc; j++)
-			{
-			  octave_quit ();
-
-			  if (iidx < num_to_delete && j == idx_j.elem (iidx))
-			    iidx++;
-			  else
-			    {
-			      for (octave_idx_type i = tmp.cidx(j); 
-				   i < tmp.cidx(j+1); i++)
-				{
-				  data(jj) = tmp.data(i);
-				  ridx(jj++) = tmp.ridx(i);
-				}
-			      cidx(++ii) = jj;
-			    }
-			}
-
-		      dimensions.resize (2);
-		      dimensions(1) = new_nc;
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("A(idx) = []: index out of range");
-		}
-	    }
-	}
+        {
+          idx_j.sort (true);
+
+          octave_idx_type num_to_delete = idx_j.length (nc);
+
+          if (num_to_delete != 0)
+            {
+              if (nr == 1 && num_to_delete == nc)
+                resize_no_fill (0, 0);
+              else
+                {
+                  octave_idx_type new_nc = nc;
+                  octave_idx_type new_nnz = nnz ();
+
+                  octave_idx_type iidx = 0;
+
+                  for (octave_idx_type j = 0; j < nc; j++)
+                    {
+                      octave_quit ();
+
+                      if (j == idx_j.elem (iidx))
+                        {
+                          iidx++;
+                          new_nc--;
+                          
+                          new_nnz -= cidx(j+1) - cidx(j);
+
+                          if (iidx == num_to_delete)
+                            break;
+                        }
+                    }
+
+                  if (new_nc > 0)
+                    {
+                      const Sparse<T> tmp (*this);
+                      --rep->count;
+                      rep = new typename Sparse<T>::SparseRep (nr, new_nc, 
+                                                               new_nnz);
+                      octave_idx_type ii = 0;
+                      octave_idx_type jj = 0;
+                      iidx = 0;
+                      cidx(0) = 0;
+                      for (octave_idx_type j = 0; j < nc; j++)
+                        {
+                          octave_quit ();
+
+                          if (iidx < num_to_delete && j == idx_j.elem (iidx))
+                            iidx++;
+                          else
+                            {
+                              for (octave_idx_type i = tmp.cidx(j); 
+                                   i < tmp.cidx(j+1); i++)
+                                {
+                                  data(jj) = tmp.data(i);
+                                  ridx(jj++) = tmp.ridx(i);
+                                }
+                              cidx(++ii) = jj;
+                            }
+                        }
+
+                      dimensions.resize (2);
+                      dimensions(1) = new_nc;
+                    }
+                  else
+                    (*current_liboctave_error_handler)
+                      ("A(idx) = []: index out of range");
+                }
+            }
+        }
     }
   else if (idx_j.is_colon_equiv (nc, 1))
     {
       if (idx_i.is_colon_equiv (nr, 1))
-	resize_no_fill (0, 0);
+        resize_no_fill (0, 0);
       else
-	{
-	  idx_i.sort (true);
-
-	  octave_idx_type num_to_delete = idx_i.length (nr);
-
-	  if (num_to_delete != 0)
-	    {
-	      if (nc == 1 && num_to_delete == nr)
-		resize_no_fill (0, 0);
-	      else
-		{
-		  octave_idx_type new_nr = nr;
-		  octave_idx_type new_nnz = nnz ();
-
-		  octave_idx_type iidx = 0;
-
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    {
-		      octave_quit ();
-
-		      if (i == idx_i.elem (iidx))
-			{
-			  iidx++;
-			  new_nr--;
-			  
-			  for (octave_idx_type j = 0; j < nnz (); j++)
-			    if (ridx(j) == i)
-			      new_nnz--;
-
-			  if (iidx == num_to_delete)
-			    break;
-			}
-		    }
-
-		  if (new_nr > 0)
-		    {
-		      const Sparse<T> tmp (*this);
-		      --rep->count;
-		      rep = new typename Sparse<T>::SparseRep (new_nr, nc, 
-							       new_nnz);
-
-		      octave_idx_type jj = 0;
-		      cidx(0) = 0;
-		      for (octave_idx_type i = 0; i < nc; i++)
-			{
-			  iidx = 0;
-			  for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
-			    {
-			      octave_quit ();
-
-			      octave_idx_type ri = tmp.ridx(j);
-
-			      while (iidx < num_to_delete && 
-				     ri > idx_i.elem (iidx))
-				{
-				  iidx++;
-				}
-
-			      if (iidx == num_to_delete ||
-				  ri != idx_i.elem(iidx))
-				{
-				  data(jj) = tmp.data(j);
-				  ridx(jj++) = ri - iidx;
-				}
-			    }
-			  cidx(i+1) = jj;
-			}
-
-		      dimensions.resize (2);
-		      dimensions(0) = new_nr;
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("A(idx) = []: index out of range");
-		}
-	    }
-	}
+        {
+          idx_i.sort (true);
+
+          octave_idx_type num_to_delete = idx_i.length (nr);
+
+          if (num_to_delete != 0)
+            {
+              if (nc == 1 && num_to_delete == nr)
+                resize_no_fill (0, 0);
+              else
+                {
+                  octave_idx_type new_nr = nr;
+                  octave_idx_type new_nnz = nnz ();
+
+                  octave_idx_type iidx = 0;
+
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    {
+                      octave_quit ();
+
+                      if (i == idx_i.elem (iidx))
+                        {
+                          iidx++;
+                          new_nr--;
+                          
+                          for (octave_idx_type j = 0; j < nnz (); j++)
+                            if (ridx(j) == i)
+                              new_nnz--;
+
+                          if (iidx == num_to_delete)
+                            break;
+                        }
+                    }
+
+                  if (new_nr > 0)
+                    {
+                      const Sparse<T> tmp (*this);
+                      --rep->count;
+                      rep = new typename Sparse<T>::SparseRep (new_nr, nc, 
+                                                               new_nnz);
+
+                      octave_idx_type jj = 0;
+                      cidx(0) = 0;
+                      for (octave_idx_type i = 0; i < nc; i++)
+                        {
+                          iidx = 0;
+                          for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
+                            {
+                              octave_quit ();
+
+                              octave_idx_type ri = tmp.ridx(j);
+
+                              while (iidx < num_to_delete && 
+                                     ri > idx_i.elem (iidx))
+                                {
+                                  iidx++;
+                                }
+
+                              if (iidx == num_to_delete ||
+                                  ri != idx_i.elem(iidx))
+                                {
+                                  data(jj) = tmp.data(j);
+                                  ridx(jj++) = ri - iidx;
+                                }
+                            }
+                          cidx(i+1) = jj;
+                        }
+
+                      dimensions.resize (2);
+                      dimensions(0) = new_nr;
+                    }
+                  else
+                    (*current_liboctave_error_handler)
+                      ("A(idx) = []: index out of range");
+                }
+            }
+        }
     }
 }
 
 template <class T>
 void
 Sparse<T>::maybe_delete_elements (Array<idx_vector>& ra_idx)
 {
   if (ra_idx.length () == 1)
@@ -1529,325 +1529,325 @@ Sparse<T>::index (idx_vector& idx_arg, i
     (*current_liboctave_error_handler)
       ("Sparse<T>::index: Can not index Sparse<T> with an N-D Array");
   else if (idx_arg.is_colon ())
     {
       // Fast magic colon processing.
       retval = Sparse<T> (nr * nc, 1, nz);
 
       for (octave_idx_type i = 0; i < nc; i++)
-	for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
-	  {
-	    octave_quit ();
-	    retval.xdata(j) = data(j); 
-	    retval.xridx(j) = ridx(j) + i * nr;
-	  }
+        for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
+          {
+            octave_quit ();
+            retval.xdata(j) = data(j); 
+            retval.xridx(j) = ridx(j) + i * nr;
+          }
       retval.xcidx(0) = 0;
       retval.xcidx(1) = nz;
     }
   else if (nr == 1 && nc == 1)
     {
       // You have to be pretty sick to get to this bit of code,
       // since you have a scalar stored as a sparse matrix, and
       // then want to make a dense matrix with sparse 
       // representation. Ok, we'll do it, but you deserve what 
       // you get!!
       octave_idx_type n = idx_arg.freeze (length (), "sparse vector", resize_ok);
       if (n == 0)
 
-	  retval = Sparse<T> (idx_orig_dims);
+          retval = Sparse<T> (idx_orig_dims);
       else if (nz < 1)
-	if (n >= idx_orig_dims.numel ())
-	  retval = Sparse<T> (idx_orig_dims);
-	else
-	  retval = Sparse<T> (dim_vector (n, 1));
+        if (n >= idx_orig_dims.numel ())
+          retval = Sparse<T> (idx_orig_dims);
+        else
+          retval = Sparse<T> (dim_vector (n, 1));
       else if (n >= idx_orig_dims.numel ())
-	{
-	  T el = elem (0);
-	  octave_idx_type new_nr = idx_orig_rows;
-	  octave_idx_type new_nc = idx_orig_columns;
-	  for (octave_idx_type i = 2; i < idx_orig_dims.length (); i++)
-	    new_nc *= idx_orig_dims (i);
-		
-	  retval = Sparse<T> (new_nr, new_nc, idx_arg.ones_count ());
-
-	  octave_idx_type ic = 0;
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      if (i % new_nr == 0)
-		retval.xcidx(i / new_nr) = ic;
-
-	      octave_idx_type ii = idx_arg.elem (i);
-	      if (ii == 0)
-		{
-		  octave_quit ();
-		  retval.xdata(ic) = el;
-		  retval.xridx(ic++) = i % new_nr;
-		}
-	    }
-	  retval.xcidx (new_nc) = ic;
-	}
+        {
+          T el = elem (0);
+          octave_idx_type new_nr = idx_orig_rows;
+          octave_idx_type new_nc = idx_orig_columns;
+          for (octave_idx_type i = 2; i < idx_orig_dims.length (); i++)
+            new_nc *= idx_orig_dims (i);
+                
+          retval = Sparse<T> (new_nr, new_nc, idx_arg.ones_count ());
+
+          octave_idx_type ic = 0;
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              if (i % new_nr == 0)
+                retval.xcidx(i / new_nr) = ic;
+
+              octave_idx_type ii = idx_arg.elem (i);
+              if (ii == 0)
+                {
+                  octave_quit ();
+                  retval.xdata(ic) = el;
+                  retval.xridx(ic++) = i % new_nr;
+                }
+            }
+          retval.xcidx (new_nc) = ic;
+        }
       else
-	{
-	  T el = elem (0);
-	  retval = Sparse<T> (n, 1, nz);
-  	 
-	  for (octave_idx_type i = 0; i < nz; i++) 
-	    {
-	      octave_quit ();
-	      retval.xdata(i) = el;
-	      retval.xridx(i) = i;
-	    }
-	  retval.xcidx(0) = 0; 	 
-	  retval.xcidx(1) = n; 	 
-	}
+        {
+          T el = elem (0);
+          retval = Sparse<T> (n, 1, nz);
+         
+          for (octave_idx_type i = 0; i < nz; i++) 
+            {
+              octave_quit ();
+              retval.xdata(i) = el;
+              retval.xridx(i) = i;
+            }
+          retval.xcidx(0) = 0;   
+          retval.xcidx(1) = n;   
+        }
     }
   else if (nr == 1 || nc == 1)
     {
       // If indexing a vector with a matrix, return value has same
       // shape as the index.  Otherwise, it has same orientation as
       // indexed object.
       octave_idx_type len = length ();
       octave_idx_type n = idx_arg.freeze (len, "sparse vector", resize_ok);
 
       if (n == 0)
-	if (nr == 1)
-	  retval = Sparse<T> (dim_vector (1, 0));
-	else
-	  retval = Sparse<T> (dim_vector (0, 1));
+        if (nr == 1)
+          retval = Sparse<T> (dim_vector (1, 0));
+        else
+          retval = Sparse<T> (dim_vector (0, 1));
       else if (nz < 1)
-	if (idx_orig_rows == 1 || idx_orig_columns == 1)
-	  retval = Sparse<T> ((nr == 1 ? 1 : n), (nr == 1 ? n : 1));
-	else
-	  retval = Sparse<T> (idx_orig_dims);
+        if (idx_orig_rows == 1 || idx_orig_columns == 1)
+          retval = Sparse<T> ((nr == 1 ? 1 : n), (nr == 1 ? n : 1));
+        else
+          retval = Sparse<T> (idx_orig_dims);
       else
-	{
-
-	  octave_idx_type new_nzmx = 0;
-	  if (nr == 1)
-	    for (octave_idx_type i = 0; i < n; i++)
-	      {
-		octave_quit ();
-
-		octave_idx_type ii = idx_arg.elem (i);
-		if (ii < len)
-		  if (cidx(ii) != cidx(ii+1))
-		    new_nzmx++;
-	      }
-	  else
-	    for (octave_idx_type i = 0; i < n; i++)
-	      {
-		octave_idx_type ii = idx_arg.elem (i);
-		if (ii < len)
-		  for (octave_idx_type j = 0; j < nz; j++)
-		    {
-		      octave_quit ();
-
-		      if (ridx(j) == ii)
-			new_nzmx++;
-		      if (ridx(j) >= ii)
-			break;
-		    }
-	      }
-
-	  if (idx_orig_rows == 1 || idx_orig_columns == 1)
-	    {
-	      if (nr == 1)
-		{
-		  retval = Sparse<T> (1, n, new_nzmx);
-		  octave_idx_type jj = 0;
-		  retval.xcidx(0) = 0;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    {
-		      octave_quit ();
-
-		      octave_idx_type ii = idx_arg.elem (i);
-		      if (ii < len)
-			if (cidx(ii) != cidx(ii+1))
-			  {
-			    retval.xdata(jj) = data(cidx(ii));
-			    retval.xridx(jj++) = 0;
-			  }
-		      retval.xcidx(i+1) = jj;
-		    }
-		}
-	      else
-		{
-		  retval = Sparse<T> (n, 1, new_nzmx);
-		  retval.xcidx(0) = 0;
-		  retval.xcidx(1) = new_nzmx;
-		  octave_idx_type jj = 0;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    {
-		      octave_idx_type ii = idx_arg.elem (i);
-		      if (ii < len)
-			for (octave_idx_type j = 0; j < nz; j++)
-			  {
-			    octave_quit ();
-
-			    if (ridx(j) == ii)
-			      {
-				retval.xdata(jj) = data(j);
-				retval.xridx(jj++) = i;
-			      }
-			    if (ridx(j) >= ii)
-			      break;
-			  }
-		    }
-		}
-	    }
-	  else 
-	    {
-	      octave_idx_type new_nr;
-	      octave_idx_type new_nc;
-	      if (n >= idx_orig_dims.numel ())
-		{
-		  new_nr = idx_orig_rows;
-		  new_nc = idx_orig_columns;
-		}
-	      else
-		{
-		  new_nr = n;
-		  new_nc = 1;
-		}
-
-	      retval = Sparse<T> (new_nr, new_nc, new_nzmx);
-
-	      if (nr == 1)
-		{
-		  octave_idx_type jj = 0;
-		  retval.xcidx(0) = 0;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    {
-		      octave_quit ();
-
-		      octave_idx_type ii = idx_arg.elem (i);
-		      if (ii < len)
-			if (cidx(ii) != cidx(ii+1))
-			  {
-			    retval.xdata(jj) = data(cidx(ii));
-			    retval.xridx(jj++) = 0;
-			  }
-		      retval.xcidx(i/new_nr+1) = jj;
-		    }
-		}
-	      else
-		{
-		  octave_idx_type jj = 0;
-		  retval.xcidx(0) = 0;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    {
-		      octave_idx_type ii = idx_arg.elem (i);
-		      if (ii < len)
-			for (octave_idx_type j = 0; j < nz; j++)
-			  {
-			    octave_quit ();
-
-			    if (ridx(j) == ii)
-			      {
-				retval.xdata(jj) = data(j);
-				retval.xridx(jj++) = i;
-			      }
-			    if (ridx(j) >= ii)
-			      break;
-			  }
-		      retval.xcidx(i/new_nr+1) = jj;
-		    }
-		}
-	    }
-	}
+        {
+
+          octave_idx_type new_nzmx = 0;
+          if (nr == 1)
+            for (octave_idx_type i = 0; i < n; i++)
+              {
+                octave_quit ();
+
+                octave_idx_type ii = idx_arg.elem (i);
+                if (ii < len)
+                  if (cidx(ii) != cidx(ii+1))
+                    new_nzmx++;
+              }
+          else
+            for (octave_idx_type i = 0; i < n; i++)
+              {
+                octave_idx_type ii = idx_arg.elem (i);
+                if (ii < len)
+                  for (octave_idx_type j = 0; j < nz; j++)
+                    {
+                      octave_quit ();
+
+                      if (ridx(j) == ii)
+                        new_nzmx++;
+                      if (ridx(j) >= ii)
+                        break;
+                    }
+              }
+
+          if (idx_orig_rows == 1 || idx_orig_columns == 1)
+            {
+              if (nr == 1)
+                {
+                  retval = Sparse<T> (1, n, new_nzmx);
+                  octave_idx_type jj = 0;
+                  retval.xcidx(0) = 0;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    {
+                      octave_quit ();
+
+                      octave_idx_type ii = idx_arg.elem (i);
+                      if (ii < len)
+                        if (cidx(ii) != cidx(ii+1))
+                          {
+                            retval.xdata(jj) = data(cidx(ii));
+                            retval.xridx(jj++) = 0;
+                          }
+                      retval.xcidx(i+1) = jj;
+                    }
+                }
+              else
+                {
+                  retval = Sparse<T> (n, 1, new_nzmx);
+                  retval.xcidx(0) = 0;
+                  retval.xcidx(1) = new_nzmx;
+                  octave_idx_type jj = 0;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    {
+                      octave_idx_type ii = idx_arg.elem (i);
+                      if (ii < len)
+                        for (octave_idx_type j = 0; j < nz; j++)
+                          {
+                            octave_quit ();
+
+                            if (ridx(j) == ii)
+                              {
+                                retval.xdata(jj) = data(j);
+                                retval.xridx(jj++) = i;
+                              }
+                            if (ridx(j) >= ii)
+                              break;
+                          }
+                    }
+                }
+            }
+          else 
+            {
+              octave_idx_type new_nr;
+              octave_idx_type new_nc;
+              if (n >= idx_orig_dims.numel ())
+                {
+                  new_nr = idx_orig_rows;
+                  new_nc = idx_orig_columns;
+                }
+              else
+                {
+                  new_nr = n;
+                  new_nc = 1;
+                }
+
+              retval = Sparse<T> (new_nr, new_nc, new_nzmx);
+
+              if (nr == 1)
+                {
+                  octave_idx_type jj = 0;
+                  retval.xcidx(0) = 0;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    {
+                      octave_quit ();
+
+                      octave_idx_type ii = idx_arg.elem (i);
+                      if (ii < len)
+                        if (cidx(ii) != cidx(ii+1))
+                          {
+                            retval.xdata(jj) = data(cidx(ii));
+                            retval.xridx(jj++) = 0;
+                          }
+                      retval.xcidx(i/new_nr+1) = jj;
+                    }
+                }
+              else
+                {
+                  octave_idx_type jj = 0;
+                  retval.xcidx(0) = 0;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    {
+                      octave_idx_type ii = idx_arg.elem (i);
+                      if (ii < len)
+                        for (octave_idx_type j = 0; j < nz; j++)
+                          {
+                            octave_quit ();
+
+                            if (ridx(j) == ii)
+                              {
+                                retval.xdata(jj) = data(j);
+                                retval.xridx(jj++) = i;
+                              }
+                            if (ridx(j) >= ii)
+                              break;
+                          }
+                      retval.xcidx(i/new_nr+1) = jj;
+                    }
+                }
+            }
+        }
     }
   else
     {
       (*current_liboctave_warning_with_id_handler) 
-	("Octave:fortran-indexing", "single index used for sparse matrix");
+        ("Octave:fortran-indexing", "single index used for sparse matrix");
 
       // This code is only for indexing matrices.  The vector
       // cases are handled above.
 
       idx_arg.freeze (nr * nc, "matrix", resize_ok);
 
       if (idx_arg)
-	{
-	  octave_idx_type result_nr = idx_orig_rows;
-	  octave_idx_type result_nc = idx_orig_columns;
-
-	  if (nz < 1)
-	    retval = Sparse<T> (result_nr, result_nc);
-	  else
-	    {
-	      // Count number of non-zero elements
-	      octave_idx_type new_nzmx = 0;
-	      octave_idx_type kk = 0;
-	      for (octave_idx_type j = 0; j < result_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < result_nr; i++)
-		    {
-		      octave_quit ();
-		      
-		      octave_idx_type ii = idx_arg.elem (kk++);
-		      if (ii < orig_len)
-			{
-			  octave_idx_type fr = ii % nr;
-			  octave_idx_type fc = (ii - fr) / nr;
-			  for (octave_idx_type k = cidx(fc); k < cidx(fc+1); k++)
-			    {
-			      if (ridx(k) == fr)
-				new_nzmx++;
-			      if (ridx(k) >= fr)
-				break;
-			    }
-			}
-		    }
-		}
-	      
-	      retval = Sparse<T> (result_nr, result_nc, new_nzmx);
-
-	      kk = 0;
-	      octave_idx_type jj = 0;
-	      retval.xcidx(0) = 0;
-	      for (octave_idx_type j = 0; j < result_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < result_nr; i++)
-		    {
-		      octave_quit ();
-
-		      octave_idx_type ii = idx_arg.elem (kk++);
-		      if (ii < orig_len)
-			{
-			  octave_idx_type fr = ii % nr;
-			  octave_idx_type fc = (ii - fr) / nr;
-			  for (octave_idx_type k = cidx(fc); k < cidx(fc+1); k++)
-			    {
-			      if (ridx(k) == fr)
-				{
-				  retval.xdata(jj) = data(k);
-				  retval.xridx(jj++) = i;
-				}
-			      if (ridx(k) >= fr)
-				break;
-			    }
-			}
-		    }
-		  retval.xcidx(j+1) = jj;
-		}
-	    }
-	  // idx_vector::freeze() printed an error message for us.
-	}
+        {
+          octave_idx_type result_nr = idx_orig_rows;
+          octave_idx_type result_nc = idx_orig_columns;
+
+          if (nz < 1)
+            retval = Sparse<T> (result_nr, result_nc);
+          else
+            {
+              // Count number of non-zero elements
+              octave_idx_type new_nzmx = 0;
+              octave_idx_type kk = 0;
+              for (octave_idx_type j = 0; j < result_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < result_nr; i++)
+                    {
+                      octave_quit ();
+                      
+                      octave_idx_type ii = idx_arg.elem (kk++);
+                      if (ii < orig_len)
+                        {
+                          octave_idx_type fr = ii % nr;
+                          octave_idx_type fc = (ii - fr) / nr;
+                          for (octave_idx_type k = cidx(fc); k < cidx(fc+1); k++)
+                            {
+                              if (ridx(k) == fr)
+                                new_nzmx++;
+                              if (ridx(k) >= fr)
+                                break;
+                            }
+                        }
+                    }
+                }
+              
+              retval = Sparse<T> (result_nr, result_nc, new_nzmx);
+
+              kk = 0;
+              octave_idx_type jj = 0;
+              retval.xcidx(0) = 0;
+              for (octave_idx_type j = 0; j < result_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < result_nr; i++)
+                    {
+                      octave_quit ();
+
+                      octave_idx_type ii = idx_arg.elem (kk++);
+                      if (ii < orig_len)
+                        {
+                          octave_idx_type fr = ii % nr;
+                          octave_idx_type fc = (ii - fr) / nr;
+                          for (octave_idx_type k = cidx(fc); k < cidx(fc+1); k++)
+                            {
+                              if (ridx(k) == fr)
+                                {
+                                  retval.xdata(jj) = data(k);
+                                  retval.xridx(jj++) = i;
+                                }
+                              if (ridx(k) >= fr)
+                                break;
+                            }
+                        }
+                    }
+                  retval.xcidx(j+1) = jj;
+                }
+            }
+          // idx_vector::freeze() printed an error message for us.
+        }
     }
 
   return retval;
 }
 
 struct 
 idx_node 
 {
   octave_idx_type i;
   struct idx_node *next;
-};		    
+};                  
 
 template <class T>
 Sparse<T>
 Sparse<T>::index (idx_vector& idx_i, idx_vector& idx_j, int resize_ok) const
 {
   Sparse<T> retval;
 
   assert (ndims () == 2);
@@ -1856,213 +1856,213 @@ Sparse<T>::index (idx_vector& idx_i, idx
   octave_idx_type nc = dim2 ();
 
   octave_idx_type n = idx_i.freeze (nr, "row", resize_ok);
   octave_idx_type m = idx_j.freeze (nc, "column", resize_ok);
 
   if (idx_i && idx_j)
     {
       if (idx_i.orig_empty () || idx_j.orig_empty () || n == 0 || m == 0)
-	{
-	  retval.resize_no_fill (n, m);
-	}
+        {
+          retval.resize_no_fill (n, m);
+        }
       else 
-	{
-	  int idx_i_colon = idx_i.is_colon_equiv (nr);
-	  int idx_j_colon = idx_j.is_colon_equiv (nc);
-
-	  if (idx_i_colon && idx_j_colon)
-	    {
-	      retval = *this;
-	    }
-	  else
-	    {
-	      // Identify if the indices have any repeated values
-	      bool permutation = true;
-
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, itmp, 
-				   (nr > nc ? nr : nc));
-	      octave_sort<octave_idx_type> lsort;
-
-	      if (n > nr || m > nc)
-		permutation = false;
-
-	      if (permutation && ! idx_i_colon)
-		{
-		  // Can't use something like
-		  //   idx_vector tmp_idx = idx_i;
-		  //   tmp_idx.sort (true);
-		  //   if (tmp_idx.length(nr) != n)
-		  //       permutation = false;
-		  // here as there is no make_unique function 
-		  // for idx_vector type.
-		  for (octave_idx_type i = 0; i < n; i++)
-		    itmp [i] = idx_i.elem (i);
-		  lsort.sort (itmp, n);
-		  for (octave_idx_type i = 1; i < n; i++)
-		    if (itmp[i-1] == itmp[i])
-		      {
-			permutation = false;
-			break;
-		      }
-		}
-	      if (permutation && ! idx_j_colon)
-		{
-		  for (octave_idx_type i = 0; i < m; i++)
-		    itmp [i] = idx_j.elem (i);
-		  lsort.sort (itmp, m);
-		  for (octave_idx_type i = 1; i < m; i++)
-		    if (itmp[i-1] == itmp[i])
-		      {
-			permutation = false;
-			break;
-		      }
-		}
-
-	      if (permutation)
-		{
-		  // Special case permutation like indexing for speed
-		  retval = Sparse<T> (n, m, nnz ());
-		  octave_idx_type *ri = retval.xridx ();
-	      
-		  std::vector<T> X (n);
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    itmp [i] = -1;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    itmp[idx_i.elem(i)] = i;
-
-		  octave_idx_type kk = 0;
-		  retval.xcidx(0) = 0;
-		  for (octave_idx_type j = 0; j < m; j++)
-		    {
-		      octave_idx_type jj = idx_j.elem (j);
-		      for (octave_idx_type i = cidx(jj); i < cidx(jj+1); i++)
-			{
-			  octave_quit ();
-
-			  octave_idx_type ii = itmp [ridx(i)];
-			  if (ii >= 0)
-			    {
-			      X [ii] = data (i);
-			      retval.xridx (kk++) = ii;
-			    }
-			}
-		      lsort.sort (ri + retval.xcidx (j), kk - retval.xcidx (j));
-		      for (octave_idx_type p = retval.xcidx (j); p < kk; p++)
-			retval.xdata (p) = X [retval.xridx (p)]; 
-		      retval.xcidx(j+1) = kk;
-		    }
-		  retval.maybe_compress ();
-		}
-	      else
-		{
-		  OCTAVE_LOCAL_BUFFER (struct idx_node, nodes, n); 
-		  OCTAVE_LOCAL_BUFFER (octave_idx_type, start_nodes, nr); 
-
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    start_nodes[i] = -1;
-
-		  for (octave_idx_type i = 0; i < n; i++)
-		    {
-		      octave_idx_type ii = idx_i.elem (i);
-		      nodes[i].i = i;
-		      nodes[i].next = 0;
-
-		      octave_idx_type node = start_nodes[ii];
-		      if (node == -1)
-			start_nodes[ii] = i;
-		      else
-			{
-			  while (nodes[node].next)
-			    node = nodes[node].next->i;
-			  nodes[node].next = nodes + i;
-			}
-		    }
-
-		  // First count the number of non-zero elements
-		  octave_idx_type new_nzmx = 0;
-		  for (octave_idx_type j = 0; j < m; j++)
-		    {
-		      octave_idx_type jj = idx_j.elem (j);
-
-		      if (jj < nc)
-			{
-			  for (octave_idx_type i = cidx(jj); 
-			       i < cidx(jj+1); i++)
-			    {
-			      octave_quit ();
-
-			      octave_idx_type ii = start_nodes [ridx(i)];
-
-			      if (ii >= 0)
-				{
-				  struct idx_node inode = nodes[ii];
-			      
-				  while (true)
-				    {
-				      if (idx_i.elem (inode.i) < nr)
-					new_nzmx ++;
-				      if (inode.next == 0)
-					break;
-				      else
-					inode = *inode.next;
-				    }
-				}
-			    }
-			}
-		    }
-
-		  std::vector<T> X (n);
-		  retval = Sparse<T> (n, m, new_nzmx);
-		  octave_idx_type *ri = retval.xridx ();
-
-		  octave_idx_type kk = 0;
-		  retval.xcidx(0) = 0;
-		  for (octave_idx_type j = 0; j < m; j++)
-		    {
-		      octave_idx_type jj = idx_j.elem (j);
-		      if (jj < nc)
-			{
-			  for (octave_idx_type i = cidx(jj); 
-			       i < cidx(jj+1); i++)
-			    {
-			      octave_quit ();
-
-			      octave_idx_type ii = start_nodes [ridx(i)];
-
-			      if (ii >= 0)
-				{
-				  struct idx_node inode = nodes[ii];
-			      
-				  while (true)
-				    {
-				      if (idx_i.elem (inode.i) < nr)
-					{
-					  X [inode.i] = data (i);
-					  retval.xridx (kk++) = inode.i;
-					}
-
-				      if (inode.next == 0)
-					break;
-				      else
-					inode = *inode.next;
-				    }
-				}
-			    }
-			  lsort.sort (ri + retval.xcidx (j), 
-				     kk - retval.xcidx (j));
-			  for (octave_idx_type p = retval.xcidx (j); 
-			       p < kk; p++)
-			    retval.xdata (p) = X [retval.xridx (p)]; 
-			  retval.xcidx(j+1) = kk;
-			}
-		    }
-		}
-	    }
-	}
+        {
+          int idx_i_colon = idx_i.is_colon_equiv (nr);
+          int idx_j_colon = idx_j.is_colon_equiv (nc);
+
+          if (idx_i_colon && idx_j_colon)
+            {
+              retval = *this;
+            }
+          else
+            {
+              // Identify if the indices have any repeated values
+              bool permutation = true;
+
+              OCTAVE_LOCAL_BUFFER (octave_idx_type, itmp, 
+                                   (nr > nc ? nr : nc));
+              octave_sort<octave_idx_type> lsort;
+
+              if (n > nr || m > nc)
+                permutation = false;
+
+              if (permutation && ! idx_i_colon)
+                {
+                  // Can't use something like
+                  //   idx_vector tmp_idx = idx_i;
+                  //   tmp_idx.sort (true);
+                  //   if (tmp_idx.length(nr) != n)
+                  //       permutation = false;
+                  // here as there is no make_unique function 
+                  // for idx_vector type.
+                  for (octave_idx_type i = 0; i < n; i++)
+                    itmp [i] = idx_i.elem (i);
+                  lsort.sort (itmp, n);
+                  for (octave_idx_type i = 1; i < n; i++)
+                    if (itmp[i-1] == itmp[i])
+                      {
+                        permutation = false;
+                        break;
+                      }
+                }
+              if (permutation && ! idx_j_colon)
+                {
+                  for (octave_idx_type i = 0; i < m; i++)
+                    itmp [i] = idx_j.elem (i);
+                  lsort.sort (itmp, m);
+                  for (octave_idx_type i = 1; i < m; i++)
+                    if (itmp[i-1] == itmp[i])
+                      {
+                        permutation = false;
+                        break;
+                      }
+                }
+
+              if (permutation)
+                {
+                  // Special case permutation like indexing for speed
+                  retval = Sparse<T> (n, m, nnz ());
+                  octave_idx_type *ri = retval.xridx ();
+              
+                  std::vector<T> X (n);
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    itmp [i] = -1;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    itmp[idx_i.elem(i)] = i;
+
+                  octave_idx_type kk = 0;
+                  retval.xcidx(0) = 0;
+                  for (octave_idx_type j = 0; j < m; j++)
+                    {
+                      octave_idx_type jj = idx_j.elem (j);
+                      for (octave_idx_type i = cidx(jj); i < cidx(jj+1); i++)
+                        {
+                          octave_quit ();
+
+                          octave_idx_type ii = itmp [ridx(i)];
+                          if (ii >= 0)
+                            {
+                              X [ii] = data (i);
+                              retval.xridx (kk++) = ii;
+                            }
+                        }
+                      lsort.sort (ri + retval.xcidx (j), kk - retval.xcidx (j));
+                      for (octave_idx_type p = retval.xcidx (j); p < kk; p++)
+                        retval.xdata (p) = X [retval.xridx (p)]; 
+                      retval.xcidx(j+1) = kk;
+                    }
+                  retval.maybe_compress ();
+                }
+              else
+                {
+                  OCTAVE_LOCAL_BUFFER (struct idx_node, nodes, n); 
+                  OCTAVE_LOCAL_BUFFER (octave_idx_type, start_nodes, nr); 
+
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    start_nodes[i] = -1;
+
+                  for (octave_idx_type i = 0; i < n; i++)
+                    {
+                      octave_idx_type ii = idx_i.elem (i);
+                      nodes[i].i = i;
+                      nodes[i].next = 0;
+
+                      octave_idx_type node = start_nodes[ii];
+                      if (node == -1)
+                        start_nodes[ii] = i;
+                      else
+                        {
+                          while (nodes[node].next)
+                            node = nodes[node].next->i;
+                          nodes[node].next = nodes + i;
+                        }
+                    }
+
+                  // First count the number of non-zero elements
+                  octave_idx_type new_nzmx = 0;
+                  for (octave_idx_type j = 0; j < m; j++)
+                    {
+                      octave_idx_type jj = idx_j.elem (j);
+
+                      if (jj < nc)
+                        {
+                          for (octave_idx_type i = cidx(jj); 
+                               i < cidx(jj+1); i++)
+                            {
+                              octave_quit ();
+
+                              octave_idx_type ii = start_nodes [ridx(i)];
+
+                              if (ii >= 0)
+                                {
+                                  struct idx_node inode = nodes[ii];
+                              
+                                  while (true)
+                                    {
+                                      if (idx_i.elem (inode.i) < nr)
+                                        new_nzmx ++;
+                                      if (inode.next == 0)
+                                        break;
+                                      else
+                                        inode = *inode.next;
+                                    }
+                                }
+                            }
+                        }
+                    }
+
+                  std::vector<T> X (n);
+                  retval = Sparse<T> (n, m, new_nzmx);
+                  octave_idx_type *ri = retval.xridx ();
+
+                  octave_idx_type kk = 0;
+                  retval.xcidx(0) = 0;
+                  for (octave_idx_type j = 0; j < m; j++)
+                    {
+                      octave_idx_type jj = idx_j.elem (j);
+                      if (jj < nc)
+                        {
+                          for (octave_idx_type i = cidx(jj); 
+                               i < cidx(jj+1); i++)
+                            {
+                              octave_quit ();
+
+                              octave_idx_type ii = start_nodes [ridx(i)];
+
+                              if (ii >= 0)
+                                {
+                                  struct idx_node inode = nodes[ii];
+                              
+                                  while (true)
+                                    {
+                                      if (idx_i.elem (inode.i) < nr)
+                                        {
+                                          X [inode.i] = data (i);
+                                          retval.xridx (kk++) = inode.i;
+                                        }
+
+                                      if (inode.next == 0)
+                                        break;
+                                      else
+                                        inode = *inode.next;
+                                    }
+                                }
+                            }
+                          lsort.sort (ri + retval.xcidx (j), 
+                                     kk - retval.xcidx (j));
+                          for (octave_idx_type p = retval.xcidx (j); 
+                               p < kk; p++)
+                            retval.xdata (p) = X [retval.xridx (p)]; 
+                          retval.xcidx(j+1) = kk;
+                        }
+                    }
+                }
+            }
+        }
     }
   // idx_vector::freeze() printed an error message for us.
 
   return retval;
 }
 
 template <class T>
 Sparse<T>
@@ -2130,46 +2130,46 @@ Sparse<T>::sort (octave_idx_type dim, so
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_idx_type ns = mcidx [j + 1] - mcidx [j];
       lsort.sort (v, ns);
 
       octave_idx_type i;
       if (mode == ASCENDING) 
-	{
-	  for (i = 0; i < ns; i++)
-	    if (sparse_ascending_compare<T> (static_cast<T> (0), v [i]))
-	      break;
-	}
+        {
+          for (i = 0; i < ns; i++)
+            if (sparse_ascending_compare<T> (static_cast<T> (0), v [i]))
+              break;
+        }
       else
-	{
-	  for (i = 0; i < ns; i++)
-	    if (sparse_descending_compare<T> (static_cast<T> (0), v [i]))
-	      break;
-	}
+        {
+          for (i = 0; i < ns; i++)
+            if (sparse_descending_compare<T> (static_cast<T> (0), v [i]))
+              break;
+        }
       for (octave_idx_type k = 0; k < i; k++)
-	mridx [k] = k;
+        mridx [k] = k;
       for (octave_idx_type k = i; k < ns; k++)
-	mridx [k] = k - ns + nr; 
+        mridx [k] = k - ns + nr; 
 
       v += ns;
       mridx += ns;
     }
 
   if (dim > 0)
       m = m.transpose ();
 
   return m;
 }
 
 template <class T>
 Sparse<T>
 Sparse<T>::sort (Array<octave_idx_type> &sidx, octave_idx_type dim, 
-		 sortmode mode) const
+                 sortmode mode) const
 {
   Sparse<T> m = *this;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   if (m.length () < 1)
     {
@@ -2201,66 +2201,66 @@ Sparse<T>::sort (Array<octave_idx_type> 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, vi, nr);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_idx_type ns = mcidx [j + 1] - mcidx [j];
       octave_idx_type offset = j * nr;
 
       if (ns == 0)
-	{
-	  for (octave_idx_type k = 0; k < nr; k++)
-	    sidx (offset + k) = k;
-	}
+        {
+          for (octave_idx_type k = 0; k < nr; k++)
+            sidx (offset + k) = k;
+        }
       else
-	{
-	  for (octave_idx_type i = 0; i < ns; i++)
+        {
+          for (octave_idx_type i = 0; i < ns; i++)
             vi[i] = mridx[i];
 
-	  indexed_sort.sort (v, vi, ns);
-
-	  octave_idx_type i;
-	  if (mode == ASCENDING) 
-	    {
-	      for (i = 0; i < ns; i++)
-		if (sparse_ascending_compare<T> (static_cast<T> (0), v[i]))
-		  break;
-	    }
-	  else
-	    {
-	      for (i = 0; i < ns; i++)
-		if (sparse_descending_compare<T> (static_cast<T> (0), v[i]))
-		  break;
-	    }
-
-	  octave_idx_type ii = 0;
-	  octave_idx_type jj = i;
-	  for (octave_idx_type k = 0; k < nr; k++)
-	    {
-	      if (ii < ns && mridx[ii] == k)
-		ii++;
-	      else
-		sidx (offset + jj++) = k;
-	    }
-
-	  for (octave_idx_type k = 0; k < i; k++)
-	    {
-	      sidx (k + offset) = vi [k];
-	      mridx [k] = k;
-	    }
-
-	  for (octave_idx_type k = i; k < ns; k++)
-	    {
-	      sidx (k - ns + nr + offset) = vi [k];
-	      mridx [k] = k - ns + nr; 
-	    }
-
-	  v += ns;
-	  mridx += ns;
-	}
+          indexed_sort.sort (v, vi, ns);
+
+          octave_idx_type i;
+          if (mode == ASCENDING) 
+            {
+              for (i = 0; i < ns; i++)
+                if (sparse_ascending_compare<T> (static_cast<T> (0), v[i]))
+                  break;
+            }
+          else
+            {
+              for (i = 0; i < ns; i++)
+                if (sparse_descending_compare<T> (static_cast<T> (0), v[i]))
+                  break;
+            }
+
+          octave_idx_type ii = 0;
+          octave_idx_type jj = i;
+          for (octave_idx_type k = 0; k < nr; k++)
+            {
+              if (ii < ns && mridx[ii] == k)
+                ii++;
+              else
+                sidx (offset + jj++) = k;
+            }
+
+          for (octave_idx_type k = 0; k < i; k++)
+            {
+              sidx (k + offset) = vi [k];
+              mridx [k] = k;
+            }
+
+          for (octave_idx_type k = i; k < ns; k++)
+            {
+              sidx (k - ns + nr + offset) = vi [k];
+              mridx [k] = k - ns + nr; 
+            }
+
+          v += ns;
+          mridx += ns;
+        }
     }
 
   if (dim > 0)
     {
       m = m.transpose ();
       sidx = sidx.transpose ();
     }
 
@@ -2275,148 +2275,148 @@ Sparse<T>::diag (octave_idx_type k) cons
   octave_idx_type nnc = cols ();
   Sparse<T> d;
 
   if (nnr == 0 || nnc == 0)
     ; // do nothing
   else if (nnr != 1 && nnc != 1)
     {
       if (k > 0)
-	nnc -= k;
+        nnc -= k;
       else if (k < 0)
-	nnr += k;
+        nnr += k;
 
       if (nnr > 0 && nnc > 0)
-	{
-	  octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
-
-	  // Count the number of non-zero elements
-	  octave_idx_type nel = 0;
-	  if (k > 0)
-	    {
-	      for (octave_idx_type i = 0; i < ndiag; i++)
-		if (elem (i, i+k) != 0.)
-		  nel++;
-	    }
-	  else if ( k < 0)
-	    {
-	      for (octave_idx_type i = 0; i < ndiag; i++)
-		if (elem (i-k, i) != 0.)
-		  nel++;
-	    }
-	  else
-	    {
-	      for (octave_idx_type i = 0; i < ndiag; i++)
-		if (elem (i, i) != 0.)
-		  nel++;
-	    }
+        {
+          octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
+
+          // Count the number of non-zero elements
+          octave_idx_type nel = 0;
+          if (k > 0)
+            {
+              for (octave_idx_type i = 0; i < ndiag; i++)
+                if (elem (i, i+k) != 0.)
+                  nel++;
+            }
+          else if ( k < 0)
+            {
+              for (octave_idx_type i = 0; i < ndiag; i++)
+                if (elem (i-k, i) != 0.)
+                  nel++;
+            }
+          else
+            {
+              for (octave_idx_type i = 0; i < ndiag; i++)
+                if (elem (i, i) != 0.)
+                  nel++;
+            }
       
-	  d = Sparse<T> (ndiag, 1, nel);
-	  d.xcidx (0) = 0;
-	  d.xcidx (1) = nel;
-
-	  octave_idx_type ii = 0;
-	  if (k > 0)
-	    {
-	      for (octave_idx_type i = 0; i < ndiag; i++)
-		{
-		  T tmp = elem (i, i+k);
-		  if (tmp != 0.)
-		    {
-		      d.xdata (ii) = tmp;
-		      d.xridx (ii++) = i;
-		    }
-		}
-	    }
-	  else if ( k < 0)
-	    {
-	      for (octave_idx_type i = 0; i < ndiag; i++)
-		{
-		  T tmp = elem (i-k, i);
-		  if (tmp != 0.)
-		    {
-		      d.xdata (ii) = tmp;
-		      d.xridx (ii++) = i;
-		    }
-		}
-	    }
-	  else
-	    {
-	      for (octave_idx_type i = 0; i < ndiag; i++)
-		{
-		  T tmp = elem (i, i);
-		  if (tmp != 0.)
-		    {
-		      d.xdata (ii) = tmp;
-		      d.xridx (ii++) = i;
-		    }
-		}
-	    }
-	}
+          d = Sparse<T> (ndiag, 1, nel);
+          d.xcidx (0) = 0;
+          d.xcidx (1) = nel;
+
+          octave_idx_type ii = 0;
+          if (k > 0)
+            {
+              for (octave_idx_type i = 0; i < ndiag; i++)
+                {
+                  T tmp = elem (i, i+k);
+                  if (tmp != 0.)
+                    {
+                      d.xdata (ii) = tmp;
+                      d.xridx (ii++) = i;
+                    }
+                }
+            }
+          else if ( k < 0)
+            {
+              for (octave_idx_type i = 0; i < ndiag; i++)
+                {
+                  T tmp = elem (i-k, i);
+                  if (tmp != 0.)
+                    {
+                      d.xdata (ii) = tmp;
+                      d.xridx (ii++) = i;
+                    }
+                }
+            }
+          else
+            {
+              for (octave_idx_type i = 0; i < ndiag; i++)
+                {
+                  T tmp = elem (i, i);
+                  if (tmp != 0.)
+                    {
+                      d.xdata (ii) = tmp;
+                      d.xridx (ii++) = i;
+                    }
+                }
+            }
+        }
       else
-	(*current_liboctave_error_handler) 
-	  ("diag: requested diagonal out of range");
+        (*current_liboctave_error_handler) 
+          ("diag: requested diagonal out of range");
     }
   else if (nnr != 0 && nnc != 0)
     {
       octave_idx_type roff = 0;
       octave_idx_type coff = 0;
       if (k > 0) 
-	{
-	  roff = 0;
-	  coff = k;
-	} 
+        {
+          roff = 0;
+          coff = k;
+        } 
       else if (k < 0) 
-	{
-	  roff = -k;
-	  coff = 0;
-	}
+        {
+          roff = -k;
+          coff = 0;
+        }
 
       if (nnr == 1) 
-	{
-	  octave_idx_type n = nnc + std::abs (k);
-	  octave_idx_type nz = nzmax ();
-	  d = Sparse<T> (n, n, nz);
-	  for (octave_idx_type i = 0; i < coff+1; i++)
-	    d.xcidx (i) = 0;
-	  for (octave_idx_type j = 0; j < nnc; j++)
-	    {
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		{
-		  d.xdata (i) = data (i);
-		  d.xridx (i) = j + roff;
-		}
-	      d.xcidx (j + coff + 1) = cidx(j+1);
-	    }
-	  for (octave_idx_type i = nnc + coff + 1; i < n + 1; i++)
-	    d.xcidx (i) = nz;
-	} 
+        {
+          octave_idx_type n = nnc + std::abs (k);
+          octave_idx_type nz = nzmax ();
+          d = Sparse<T> (n, n, nz);
+          for (octave_idx_type i = 0; i < coff+1; i++)
+            d.xcidx (i) = 0;
+          for (octave_idx_type j = 0; j < nnc; j++)
+            {
+              for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                {
+                  d.xdata (i) = data (i);
+                  d.xridx (i) = j + roff;
+                }
+              d.xcidx (j + coff + 1) = cidx(j+1);
+            }
+          for (octave_idx_type i = nnc + coff + 1; i < n + 1; i++)
+            d.xcidx (i) = nz;
+        } 
       else 
-	{
-	  octave_idx_type n = nnr + std::abs (k);
-	  octave_idx_type nz = nzmax ();
-	  octave_idx_type ii = 0;
-	  octave_idx_type ir = ridx(0);
-	  d = Sparse<T> (n, n, nz);
-	  for (octave_idx_type i = 0; i < coff+1; i++)
-	    d.xcidx (i) = 0;
-	  for (octave_idx_type i = 0; i < nnr; i++)
-	    {
-	      if (ir == i)
-		{
-		  d.xdata (ii) = data (ii);
-		  d.xridx (ii++) = ir + roff;
-		  if (ii != nz)
-		    ir = ridx (ii);
-		}
-	      d.xcidx (i + coff + 1) = ii;
-	    }
-	  for (octave_idx_type i = nnr + coff + 1; i < n+1; i++)
-	    d.xcidx (i) = nz;
-	}
+        {
+          octave_idx_type n = nnr + std::abs (k);
+          octave_idx_type nz = nzmax ();
+          octave_idx_type ii = 0;
+          octave_idx_type ir = ridx(0);
+          d = Sparse<T> (n, n, nz);
+          for (octave_idx_type i = 0; i < coff+1; i++)
+            d.xcidx (i) = 0;
+          for (octave_idx_type i = 0; i < nnr; i++)
+            {
+              if (ir == i)
+                {
+                  d.xdata (ii) = data (ii);
+                  d.xridx (ii++) = ir + roff;
+                  if (ii != nz)
+                    ir = ridx (ii);
+                }
+              d.xcidx (i + coff + 1) = ii;
+            }
+          for (octave_idx_type i = nnr + coff + 1; i < n+1; i++)
+            d.xcidx (i) = nz;
+        }
     }
 
   return d;
 }
 
 // FIXME
 // Unfortunately numel can overflow for very large but very sparse matrices.
 // For now just flag an error when this happens.
@@ -2440,19 +2440,19 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
   uint64_t long_rhs_len = 
     static_cast<uint64_t> (rhs.rows ()) *
     static_cast<uint64_t> (rhs.cols ());
 
   if (long_rhs_len != static_cast<uint64_t>(rhs_len) ||
       long_lhs_len != static_cast<uint64_t>(lhs_len))
     {
       (*current_liboctave_error_handler)
-	("A(I) = X: Matrix dimensions too large to ensure correct\n",
-	 "operation. This is an limitation that should be removed\n",
-	 "in the future.");
+        ("A(I) = X: Matrix dimensions too large to ensure correct\n",
+         "operation. This is an limitation that should be removed\n",
+         "in the future.");
 
       lhs.clear_index ();
       return 0;
     }
 
   octave_idx_type nr = lhs.rows ();
   octave_idx_type nc = lhs.cols ();
   octave_idx_type nz = lhs.nnz ();
@@ -2464,341 +2464,341 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
       octave_idx_type max_idx = lhs_idx.max () + 1;
       max_idx = max_idx < lhs_len ? lhs_len : max_idx;
 
       // Take a constant copy of lhs. This means that elem won't 
       // create missing elements.
       const Sparse<LT> c_lhs (lhs);
 
       if (rhs_len == n)
-	{
-	  octave_idx_type new_nzmx = lhs.nnz ();
-
-	  OCTAVE_LOCAL_BUFFER (octave_idx_type, rhs_idx, n);
-	  if (! lhs_idx.is_colon ())
-	    {
-	      // Ok here we have to be careful with the indexing,
-	      // to treat cases like "a([3,2,1]) = b", and still 
-	      // handle the need for strict sorting of the sparse 
-	      // elements.
-	      OCTAVE_LOCAL_BUFFER (octave_idx_vector_sort *, sidx, n);
-	      OCTAVE_LOCAL_BUFFER (octave_idx_vector_sort, sidxX, n);
-
-	      for (octave_idx_type i = 0; i < n; i++)
-		{
-		  sidx[i] = &sidxX[i];
-		  sidx[i]->i = lhs_idx.elem(i);
-		  sidx[i]->idx = i;
-		}
-			  
-	      octave_quit ();
-	      octave_sort<octave_idx_vector_sort *> 
-		sort (octave_idx_vector_comp);
-
-	      sort.sort (sidx, n);
-
-	      intNDArray<octave_idx_type> new_idx (dim_vector (n,1));
-
-	      for (octave_idx_type i = 0; i < n; i++)
-		{
-		  new_idx.xelem(i) = sidx[i]->i;
-		  rhs_idx[i] = sidx[i]->idx;
-		}
-
-	      lhs_idx = idx_vector (new_idx);
-	    }
-	  else
-	    for (octave_idx_type i = 0; i < n; i++)
-	      rhs_idx[i] = i;
-
-	  // First count the number of non-zero elements
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      octave_quit ();
-
-	      octave_idx_type ii = lhs_idx.elem (i);
-	      if (i < n - 1 && lhs_idx.elem (i + 1) == ii)
-		continue;
-	      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
-		new_nzmx--;
-	      if (rhs.elem(rhs_idx[i]) != RT ())
-		new_nzmx++;
-	    }
-
-	  if (nr > 1)
-	    {
-	      Sparse<LT> tmp ((max_idx > nr ? max_idx : nr), 1, new_nzmx);
-	      tmp.cidx(0) = 0;
-	      tmp.cidx(1) = new_nzmx;
-
-	      octave_idx_type i = 0;
-	      octave_idx_type ii = 0;
-	      if (i < nz)
-		ii = c_lhs.ridx(i);
-
-	      octave_idx_type j = 0;
-	      octave_idx_type jj = lhs_idx.elem(j);
-
-	      octave_idx_type kk = 0;
-
-	      while (j < n || i < nz)
-		{
-		  if (j < n - 1 && lhs_idx.elem (j + 1) == jj)
-		    {
-		      j++;
-		      jj = lhs_idx.elem (j);
-		      continue;
-		    }
-		  if (j == n || (i < nz && ii < jj))
-		    {
-		      tmp.xdata (kk) = c_lhs.data (i);
-		      tmp.xridx (kk++) = ii;
-		      if (++i < nz)
-			ii = c_lhs.ridx(i);
-		    }
-		  else
-		    {
-		      RT rtmp = rhs.elem (rhs_idx[j]);
-		      if (rtmp != RT ())
-			{
-			  tmp.xdata (kk) = rtmp;
-			  tmp.xridx (kk++) = jj;
-			}
-
-		      if (ii == jj && i < nz)
-			if (++i < nz)
-			  ii = c_lhs.ridx(i);
-		      if (++j < n)
-			jj = lhs_idx.elem(j);
-		    }
-		}
-
-	      lhs = tmp;
-	    }
-	  else
-	    {
-	      Sparse<LT> tmp (1, (max_idx > nc ? max_idx : nc), new_nzmx);
-
-	      octave_idx_type i = 0;
-	      octave_idx_type ii = 0;
-	      while (ii < nc && c_lhs.cidx(ii+1) <= i)
-		ii++;
-
-	      octave_idx_type j = 0;
-	      octave_idx_type jj = lhs_idx.elem(j);
-
-	      octave_idx_type kk = 0;
-	      octave_idx_type ic = 0;
-
-	      while (j < n || i < nz)
-		{
-		  if (j < n - 1 && lhs_idx.elem (j + 1) == jj)
-		    {
-		      j++;
-		      jj = lhs_idx.elem (j);
-		      continue;
-		    }
-		  if (j == n || (i < nz && ii < jj))
-		    {
-		      while (ic <= ii)
-			tmp.xcidx (ic++) = kk;
-		      tmp.xdata (kk) = c_lhs.data (i);
-		      tmp.xridx (kk++) = 0;
-		      i++;
-		      while (ii < nc && c_lhs.cidx(ii+1) <= i)
-			ii++;
-		    }
-		  else
-		    {
-		      while (ic <= jj)
-			tmp.xcidx (ic++) = kk;
-
-		      RT rtmp = rhs.elem (rhs_idx[j]);
-		      if (rtmp != RT ())
-			{
-			  tmp.xdata (kk) = rtmp;
-			  tmp.xridx (kk++) = 0;
-			}
-		      if (ii == jj)
-			{
-			  i++;
-			  while (ii < nc && c_lhs.cidx(ii+1) <= i)
-			    ii++;
-			}
-		      j++;
-		      if (j < n)
-			jj = lhs_idx.elem(j);
-		    }
-		}
-
-	      for (octave_idx_type iidx = ic; iidx < max_idx+1; iidx++)
-		tmp.xcidx(iidx) = kk;
-
-	      lhs = tmp;
-	    }
-	}
+        {
+          octave_idx_type new_nzmx = lhs.nnz ();
+
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, rhs_idx, n);
+          if (! lhs_idx.is_colon ())
+            {
+              // Ok here we have to be careful with the indexing,
+              // to treat cases like "a([3,2,1]) = b", and still 
+              // handle the need for strict sorting of the sparse 
+              // elements.
+              OCTAVE_LOCAL_BUFFER (octave_idx_vector_sort *, sidx, n);
+              OCTAVE_LOCAL_BUFFER (octave_idx_vector_sort, sidxX, n);
+
+              for (octave_idx_type i = 0; i < n; i++)
+                {
+                  sidx[i] = &sidxX[i];
+                  sidx[i]->i = lhs_idx.elem(i);
+                  sidx[i]->idx = i;
+                }
+                          
+              octave_quit ();
+              octave_sort<octave_idx_vector_sort *> 
+                sort (octave_idx_vector_comp);
+
+              sort.sort (sidx, n);
+
+              intNDArray<octave_idx_type> new_idx (dim_vector (n,1));
+
+              for (octave_idx_type i = 0; i < n; i++)
+                {
+                  new_idx.xelem(i) = sidx[i]->i;
+                  rhs_idx[i] = sidx[i]->idx;
+                }
+
+              lhs_idx = idx_vector (new_idx);
+            }
+          else
+            for (octave_idx_type i = 0; i < n; i++)
+              rhs_idx[i] = i;
+
+          // First count the number of non-zero elements
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              octave_quit ();
+
+              octave_idx_type ii = lhs_idx.elem (i);
+              if (i < n - 1 && lhs_idx.elem (i + 1) == ii)
+                continue;
+              if (ii < lhs_len && c_lhs.elem(ii) != LT ())
+                new_nzmx--;
+              if (rhs.elem(rhs_idx[i]) != RT ())
+                new_nzmx++;
+            }
+
+          if (nr > 1)
+            {
+              Sparse<LT> tmp ((max_idx > nr ? max_idx : nr), 1, new_nzmx);
+              tmp.cidx(0) = 0;
+              tmp.cidx(1) = new_nzmx;
+
+              octave_idx_type i = 0;
+              octave_idx_type ii = 0;
+              if (i < nz)
+                ii = c_lhs.ridx(i);
+
+              octave_idx_type j = 0;
+              octave_idx_type jj = lhs_idx.elem(j);
+
+              octave_idx_type kk = 0;
+
+              while (j < n || i < nz)
+                {
+                  if (j < n - 1 && lhs_idx.elem (j + 1) == jj)
+                    {
+                      j++;
+                      jj = lhs_idx.elem (j);
+                      continue;
+                    }
+                  if (j == n || (i < nz && ii < jj))
+                    {
+                      tmp.xdata (kk) = c_lhs.data (i);
+                      tmp.xridx (kk++) = ii;
+                      if (++i < nz)
+                        ii = c_lhs.ridx(i);
+                    }
+                  else
+                    {
+                      RT rtmp = rhs.elem (rhs_idx[j]);
+                      if (rtmp != RT ())
+                        {
+                          tmp.xdata (kk) = rtmp;
+                          tmp.xridx (kk++) = jj;
+                        }
+
+                      if (ii == jj && i < nz)
+                        if (++i < nz)
+                          ii = c_lhs.ridx(i);
+                      if (++j < n)
+                        jj = lhs_idx.elem(j);
+                    }
+                }
+
+              lhs = tmp;
+            }
+          else
+            {
+              Sparse<LT> tmp (1, (max_idx > nc ? max_idx : nc), new_nzmx);
+
+              octave_idx_type i = 0;
+              octave_idx_type ii = 0;
+              while (ii < nc && c_lhs.cidx(ii+1) <= i)
+                ii++;
+
+              octave_idx_type j = 0;
+              octave_idx_type jj = lhs_idx.elem(j);
+
+              octave_idx_type kk = 0;
+              octave_idx_type ic = 0;
+
+              while (j < n || i < nz)
+                {
+                  if (j < n - 1 && lhs_idx.elem (j + 1) == jj)
+                    {
+                      j++;
+                      jj = lhs_idx.elem (j);
+                      continue;
+                    }
+                  if (j == n || (i < nz && ii < jj))
+                    {
+                      while (ic <= ii)
+                        tmp.xcidx (ic++) = kk;
+                      tmp.xdata (kk) = c_lhs.data (i);
+                      tmp.xridx (kk++) = 0;
+                      i++;
+                      while (ii < nc && c_lhs.cidx(ii+1) <= i)
+                        ii++;
+                    }
+                  else
+                    {
+                      while (ic <= jj)
+                        tmp.xcidx (ic++) = kk;
+
+                      RT rtmp = rhs.elem (rhs_idx[j]);
+                      if (rtmp != RT ())
+                        {
+                          tmp.xdata (kk) = rtmp;
+                          tmp.xridx (kk++) = 0;
+                        }
+                      if (ii == jj)
+                        {
+                          i++;
+                          while (ii < nc && c_lhs.cidx(ii+1) <= i)
+                            ii++;
+                        }
+                      j++;
+                      if (j < n)
+                        jj = lhs_idx.elem(j);
+                    }
+                }
+
+              for (octave_idx_type iidx = ic; iidx < max_idx+1; iidx++)
+                tmp.xcidx(iidx) = kk;
+
+              lhs = tmp;
+            }
+        }
       else if (rhs_len == 1)
-	{
-	  octave_idx_type new_nzmx = lhs.nnz ();
-	  RT scalar = rhs.elem (0);
-	  bool scalar_non_zero = (scalar != RT ());
-	  lhs_idx.sort (true);
-	  n = lhs_idx.length (n);
-
-	  // First count the number of non-zero elements
-	  if (scalar != RT ())
-	    new_nzmx += n;
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      octave_quit ();
-
-	      octave_idx_type ii = lhs_idx.elem (i);
-	      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
-		new_nzmx--;
-	    }
-
-	  if (nr > 1)
-	    {
-	      Sparse<LT> tmp ((max_idx > nr ? max_idx : nr), 1, new_nzmx);
-	      tmp.cidx(0) = 0;
-	      tmp.cidx(1) = new_nzmx;
-
-	      octave_idx_type i = 0;
-	      octave_idx_type ii = 0;
-	      if (i < nz)
-		ii = c_lhs.ridx(i);
-
-	      octave_idx_type j = 0;
-	      octave_idx_type jj = lhs_idx.elem(j);
-
-	      octave_idx_type kk = 0;
-
-	      while (j < n || i < nz)
-		{
-		  if (j == n || (i < nz && ii < jj))
-		    {
-		      tmp.xdata (kk) = c_lhs.data (i);
-		      tmp.xridx (kk++) = ii;
-		      if (++i < nz)
-			ii = c_lhs.ridx(i);
-		    }
-		  else
-		    {
-		      if (scalar_non_zero)
-			{
-			  tmp.xdata (kk) = scalar;
-			  tmp.xridx (kk++) = jj;
-			}
-
-		      if (ii == jj && i < nz)
-			if (++i < nz)
-			  ii = c_lhs.ridx(i);
-		      if (++j < n)
-			jj = lhs_idx.elem(j);
-		    }
-		}
-
-	      lhs = tmp;
-	    }
-	  else
-	    {
-	      Sparse<LT> tmp (1, (max_idx > nc ? max_idx : nc), new_nzmx);
-
-	      octave_idx_type i = 0;
-	      octave_idx_type ii = 0;
-	      while (ii < nc && c_lhs.cidx(ii+1) <= i)
-		ii++;
-
-	      octave_idx_type j = 0;
-	      octave_idx_type jj = lhs_idx.elem(j);
-
-	      octave_idx_type kk = 0;
-	      octave_idx_type ic = 0;
-
-	      while (j < n || i < nz)
-		{
-		  if (j == n || (i < nz && ii < jj))
-		    {
-		      while (ic <= ii)
-			tmp.xcidx (ic++) = kk;
-		      tmp.xdata (kk) = c_lhs.data (i);
-		      i++;
-		      while (ii < nc && c_lhs.cidx(ii+1) <= i)
-			ii++;
+        {
+          octave_idx_type new_nzmx = lhs.nnz ();
+          RT scalar = rhs.elem (0);
+          bool scalar_non_zero = (scalar != RT ());
+          lhs_idx.sort (true);
+          n = lhs_idx.length (n);
+
+          // First count the number of non-zero elements
+          if (scalar != RT ())
+            new_nzmx += n;
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              octave_quit ();
+
+              octave_idx_type ii = lhs_idx.elem (i);
+              if (ii < lhs_len && c_lhs.elem(ii) != LT ())
+                new_nzmx--;
+            }
+
+          if (nr > 1)
+            {
+              Sparse<LT> tmp ((max_idx > nr ? max_idx : nr), 1, new_nzmx);
+              tmp.cidx(0) = 0;
+              tmp.cidx(1) = new_nzmx;
+
+              octave_idx_type i = 0;
+              octave_idx_type ii = 0;
+              if (i < nz)
+                ii = c_lhs.ridx(i);
+
+              octave_idx_type j = 0;
+              octave_idx_type jj = lhs_idx.elem(j);
+
+              octave_idx_type kk = 0;
+
+              while (j < n || i < nz)
+                {
+                  if (j == n || (i < nz && ii < jj))
+                    {
+                      tmp.xdata (kk) = c_lhs.data (i);
+                      tmp.xridx (kk++) = ii;
+                      if (++i < nz)
+                        ii = c_lhs.ridx(i);
+                    }
+                  else
+                    {
+                      if (scalar_non_zero)
+                        {
+                          tmp.xdata (kk) = scalar;
+                          tmp.xridx (kk++) = jj;
+                        }
+
+                      if (ii == jj && i < nz)
+                        if (++i < nz)
+                          ii = c_lhs.ridx(i);
+                      if (++j < n)
+                        jj = lhs_idx.elem(j);
+                    }
+                }
+
+              lhs = tmp;
+            }
+          else
+            {
+              Sparse<LT> tmp (1, (max_idx > nc ? max_idx : nc), new_nzmx);
+
+              octave_idx_type i = 0;
+              octave_idx_type ii = 0;
+              while (ii < nc && c_lhs.cidx(ii+1) <= i)
+                ii++;
+
+              octave_idx_type j = 0;
+              octave_idx_type jj = lhs_idx.elem(j);
+
+              octave_idx_type kk = 0;
+              octave_idx_type ic = 0;
+
+              while (j < n || i < nz)
+                {
+                  if (j == n || (i < nz && ii < jj))
+                    {
+                      while (ic <= ii)
+                        tmp.xcidx (ic++) = kk;
+                      tmp.xdata (kk) = c_lhs.data (i);
+                      i++;
+                      while (ii < nc && c_lhs.cidx(ii+1) <= i)
+                        ii++;
                       tmp.xridx (kk++) = 0;
-		    }
-		  else
-		    {
-		      while (ic <= jj)
-			tmp.xcidx (ic++) = kk;
-		      if (scalar_non_zero)
+                    }
+                  else
+                    {
+                      while (ic <= jj)
+                        tmp.xcidx (ic++) = kk;
+                      if (scalar_non_zero)
                         {
                           tmp.xdata (kk) = scalar;
                           tmp.xridx (kk++) = 0;
                         }
-		      if (ii == jj)
-			{
-			  i++;
-			  while (ii < nc && c_lhs.cidx(ii+1) <= i)
-			    ii++;
-			}
-		      j++;
-		      if (j < n)
-			jj = lhs_idx.elem(j);
-		    }
-		}
-
-	      for (octave_idx_type iidx = ic; iidx < max_idx+1; iidx++)
-		tmp.xcidx(iidx) = kk;
-
-	      lhs = tmp;
-	    }
-	}
+                      if (ii == jj)
+                        {
+                          i++;
+                          while (ii < nc && c_lhs.cidx(ii+1) <= i)
+                            ii++;
+                        }
+                      j++;
+                      if (j < n)
+                        jj = lhs_idx.elem(j);
+                    }
+                }
+
+              for (octave_idx_type iidx = ic; iidx < max_idx+1; iidx++)
+                tmp.xcidx(iidx) = kk;
+
+              lhs = tmp;
+            }
+        }
       else
-	{
-	  (*current_liboctave_error_handler)
-	    ("A(I) = X: X must be a scalar or a vector with same length as I");
-
-	  retval = 0;
-	}
+        {
+          (*current_liboctave_error_handler)
+            ("A(I) = X: X must be a scalar or a vector with same length as I");
+
+          retval = 0;
+        }
     }
   else if (lhs_idx.is_colon ())
     {
       if (lhs_len == 0)
-	{
-
-	  octave_idx_type new_nzmx = rhs.nnz ();
-	  Sparse<LT> tmp (1, rhs_len, new_nzmx);
-
-	  octave_idx_type ii = 0;
-	  octave_idx_type jj = 0;
-	  for (octave_idx_type i = 0; i < rhs.cols(); i++)
-	    for (octave_idx_type j = rhs.cidx(i); j < rhs.cidx(i+1); j++)
-	      {
-		octave_quit ();
-		for (octave_idx_type k = jj; k <= i * rhs.rows() + rhs.ridx(j); k++)
-		  tmp.cidx(jj++) = ii;
-
-		tmp.data(ii) = rhs.data(j);
-		tmp.ridx(ii++) = 0;
-	      }
-
-	  for (octave_idx_type i = jj; i < rhs_len + 1; i++)
-	    tmp.cidx(i) = ii;
-
-	  lhs = tmp;
-	}
+        {
+
+          octave_idx_type new_nzmx = rhs.nnz ();
+          Sparse<LT> tmp (1, rhs_len, new_nzmx);
+
+          octave_idx_type ii = 0;
+          octave_idx_type jj = 0;
+          for (octave_idx_type i = 0; i < rhs.cols(); i++)
+            for (octave_idx_type j = rhs.cidx(i); j < rhs.cidx(i+1); j++)
+              {
+                octave_quit ();
+                for (octave_idx_type k = jj; k <= i * rhs.rows() + rhs.ridx(j); k++)
+                  tmp.cidx(jj++) = ii;
+
+                tmp.data(ii) = rhs.data(j);
+                tmp.ridx(ii++) = 0;
+              }
+
+          for (octave_idx_type i = jj; i < rhs_len + 1; i++)
+            tmp.cidx(i) = ii;
+
+          lhs = tmp;
+        }
       else
-	(*current_liboctave_error_handler)
-	  ("A(:) = X: A must be the same size as X");
+        (*current_liboctave_error_handler)
+          ("A(:) = X: A must be the same size as X");
     }
   else if (! (rhs_len == 1 || rhs_len == 0))
     {
       (*current_liboctave_error_handler)
-	("A([]) = X: X must also be an empty matrix or a scalar");
+        ("A([]) = X: X must also be an empty matrix or a scalar");
 
       retval = 0;
     }
 
   lhs.clear_index ();
 
   return retval;
 }
@@ -2846,23 +2846,23 @@ assign (Sparse<LT>& lhs, const Sparse<RT
     {
       octave_idx_type n = idx_i.freeze (lhs_nr, "row", true);
       octave_idx_type m = idx_j.freeze (lhs_nc, "column", true);
 
       int idx_i_is_colon = idx_i.is_colon ();
       int idx_j_is_colon = idx_j.is_colon ();
 
       if (lhs_nr == 0 && lhs_nc == 0)
-	{
-	  if (idx_i_is_colon)
-	    n = rhs_nr;
-
-	  if (idx_j_is_colon)
-	    m = rhs_nc;
-	}
+        {
+          if (idx_i_is_colon)
+            n = rhs_nr;
+
+          if (idx_j_is_colon)
+            m = rhs_nc;
+        }
 
       if (idx_i && idx_j)
         {
           if (rhs_nr == 1 && rhs_nc == 1 && n >= 0 && m >= 0)
             {
               if (n > 0 && m > 0)
                 {
                   idx_i.sort (true);
@@ -2935,17 +2935,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
                               if (iii < n && ii <= pp)
                                 {
                                   if (scalar != RT ())
                                     {
                                       stmp.data(kk) = scalar;
                                       stmp.ridx(kk++) = ii;
                                     }
                                   if (ii == pp)
-                                    pp = (++ppp < ppi ? c_lhs.ridx(c_lhs.cidx(j)+ppp) : new_nr);					
+                                    pp = (++ppp < ppi ? c_lhs.ridx(c_lhs.cidx(j)+ppp) : new_nr);                                        
                                   if (++iii < n)
                                     ii = idx_i.elem(iii);
                                 }
                               else
                                 {
                                   stmp.data(kk) = 
                                     c_lhs.data(c_lhs.cidx(j)+ppp);
                                   stmp.ridx(kk++) = pp;
@@ -3142,17 +3142,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
                                   RT rtmp = rhs.elem (rhs_idx_i[iii], 
                                                       rhs_idx_j[jji]);
                                   if (rtmp != RT ())
                                     {
                                       stmp.data(kk) = rtmp;
                                       stmp.ridx(kk++) = ii;
                                     }
                                   if (ii == pp)
-                                    pp = (++ppp < ppi ? c_lhs.ridx(c_lhs.cidx(j)+ppp) : new_nr);					
+                                    pp = (++ppp < ppi ? c_lhs.ridx(c_lhs.cidx(j)+ppp) : new_nr);                                        
                                   if (++iii < n)
                                     ii = idx_i.elem(iii);
                                 }
                               else
                                 {
                                   stmp.data(kk) = 
                                     c_lhs.data(c_lhs.cidx(j)+ppp);
                                   stmp.ridx(kk++) = pp;
@@ -3203,23 +3203,23 @@ assign (Sparse<LT>& lhs, const Sparse<RT
         }
       // idx_vector::freeze() printed an error message for us.
     }
   else if (n_idx == 1)
     {
       int lhs_is_empty = lhs_nr == 0 || lhs_nc == 0;
 
       if (lhs_is_empty || (lhs_nr == 1 && lhs_nc == 1))
-	{
-	  octave_idx_type lhs_len = lhs.length ();
-
-	  // Called for side-effects on idx_i.
-	  idx_i.freeze (lhs_len, 0, true);
-
-	  if (idx_i)
+        {
+          octave_idx_type lhs_len = lhs.length ();
+
+          // Called for side-effects on idx_i.
+          idx_i.freeze (lhs_len, 0, true);
+
+          if (idx_i)
             {
               if (lhs_is_empty
                   && idx_i.is_colon ()
                   && ! (rhs_nr == 1 || rhs_nc == 1))
                 {
                   (*current_liboctave_warning_with_id_handler)
                     ("Octave:fortran-indexing",
                      "A(:) = X: X is not a vector or scalar");
@@ -3233,291 +3233,291 @@ assign (Sparse<LT>& lhs, const Sparse<RT
                     (*current_liboctave_warning_with_id_handler)
                       ("Octave:fortran-indexing",
                        "A(I) = X: X does not have same shape as I");
                 }
 
               if (! assign1 (lhs, rhs))
                 retval = 0;
             }
-	  // idx_vector::freeze() printed an error message for us.
-	}
+          // idx_vector::freeze() printed an error message for us.
+        }
       else if (lhs_nr == 1)
-	{
-	  idx_i.freeze (lhs_nc, "vector", true);
-
-	  if (idx_i)
+        {
+          idx_i.freeze (lhs_nc, "vector", true);
+
+          if (idx_i)
+            {
+              if (! assign1 (lhs, rhs))
+                retval = 0;
+            }
+          // idx_vector::freeze() printed an error message for us.
+        }
+      else if (lhs_nc == 1)
+        {
+          idx_i.freeze (lhs_nr, "vector", true);
+
+          if (idx_i)
             {
               if (! assign1 (lhs, rhs))
                 retval = 0;
             }
-	  // idx_vector::freeze() printed an error message for us.
-	}
-      else if (lhs_nc == 1)
-	{
-	  idx_i.freeze (lhs_nr, "vector", true);
-
-	  if (idx_i)
-	    {
-	      if (! assign1 (lhs, rhs))
-		retval = 0;
-	    }
-	  // idx_vector::freeze() printed an error message for us.
-	}
+          // idx_vector::freeze() printed an error message for us.
+        }
       else
-	{
-	  if (! idx_i.is_colon ())
-	    (*current_liboctave_warning_with_id_handler)
-	      ("Octave:fortran-indexing", "single index used for matrix");
-
-	  octave_idx_type lhs_len = lhs.length ();
-
-	  octave_idx_type len = idx_i.freeze (lhs_nr * lhs_nc, "matrix");
-
-	  if (idx_i)
-	    {
-	      if (len == 0)
-		{
-		  if (! ((rhs_nr == 1 && rhs_nc == 1)
-			 || (rhs_nr == 0 || rhs_nc == 0)))
-		    (*current_liboctave_error_handler)
-		      ("A([]) = X: X must be an empty matrix or scalar");
-		}
-	      else if (len == rhs_nr * rhs_nc)
-		{
-		  octave_idx_type new_nzmx = lhs_nz;
-		  OCTAVE_LOCAL_BUFFER (octave_idx_type, rhs_idx, len);
-		  
-		  if (! idx_i.is_colon ())
-		    {
-		      // Ok here we have to be careful with the indexing, to
-		      // treat cases like "a([3,2,1]) = b", and still handle
-		      // the need for strict sorting of the sparse elements.
-
-		      OCTAVE_LOCAL_BUFFER (octave_idx_vector_sort *, sidx, 
-					   len);
-		      OCTAVE_LOCAL_BUFFER (octave_idx_vector_sort, sidxX, 
-					   len);
-
-		      for (octave_idx_type i = 0; i < len; i++)
-			{
-			  sidx[i] = &sidxX[i];
-			  sidx[i]->i = idx_i.elem(i);
-			  sidx[i]->idx = i;
-			}
-
-		      octave_quit ();
-		      octave_sort<octave_idx_vector_sort *> 
-			sort (octave_idx_vector_comp);
-
-		      sort.sort (sidx, len);
-
-		      intNDArray<octave_idx_type> new_idx (dim_vector (len,1));
-
-		      for (octave_idx_type i = 0; i < len; i++)
-			{
-			  new_idx.xelem(i) = sidx[i]->i;
-			  rhs_idx[i] = sidx[i]->idx;
-			}
-
-		      idx_i = idx_vector (new_idx);
-		    }
-		  else
-		    for (octave_idx_type i = 0; i < len; i++)
-		      rhs_idx[i] = i;
-
-		  // First count the number of non-zero elements
-		  for (octave_idx_type i = 0; i < len; i++)
-		    {
-		      octave_quit ();
-		      
-		      octave_idx_type ii = idx_i.elem (i);
-		      if (i < len - 1 && idx_i.elem (i + 1) == ii)
-			continue;
-		      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
-			new_nzmx--;
-		      if (rhs.elem(rhs_idx[i]) != RT ())
-			new_nzmx++;
-		    }
-
-		  Sparse<LT> stmp (lhs_nr, lhs_nc, new_nzmx);
-
-		  octave_idx_type i = 0;
-		  octave_idx_type ii = 0;
-		  octave_idx_type ic = 0;
-		  if (i < lhs_nz)
-		    {
-		      while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
-			ic++;
-		      ii = ic * lhs_nr + c_lhs.ridx(i);
-		    }
-
-		  octave_idx_type j = 0;
-		  octave_idx_type jj = idx_i.elem (j);
-		  octave_idx_type jr = jj % lhs_nr;
-		  octave_idx_type jc = (jj - jr) / lhs_nr;
-
-		  octave_idx_type kk = 0;
-		  octave_idx_type kc = 0;
-
-		  while (j < len || i < lhs_nz)
-		    {
-		      if (j < len - 1 && idx_i.elem (j + 1) == jj)
-			{
-			  j++;
-			  jj = idx_i.elem (j);
-			  jr = jj % lhs_nr;
-			  jc = (jj - jr) / lhs_nr;
-			  continue;
-			}
-
-		      if (j == len || (i < lhs_nz && ii < jj))
-			{
-			  while (kc <= ic)
-			    stmp.xcidx (kc++) = kk;
-			  stmp.xdata (kk) = c_lhs.data (i);
-			  stmp.xridx (kk++) = c_lhs.ridx (i);
-			  i++;
-			  while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
-			    ic++;
-			  if (i < lhs_nz)
-			    ii = ic * lhs_nr + c_lhs.ridx(i);
-			}
-		      else
-			{
-			  while (kc <= jc)
-			    stmp.xcidx (kc++) = kk;
-			  RT rtmp = rhs.elem (rhs_idx[j]);
-			  if (rtmp != RT ())
-			    {
-			      stmp.xdata (kk) = rtmp;
-			      stmp.xridx (kk++) = jr;
-			    }
-			  if (ii == jj)
-			    {
-			      i++;
-			      while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
-				ic++;
-			      if (i < lhs_nz)
-				ii = ic * lhs_nr + c_lhs.ridx(i);
-			    }
-			  j++;
-			  if (j < len)
-			    {
-			      jj = idx_i.elem (j);
-			      jr = jj % lhs_nr;
-			      jc = (jj - jr) / lhs_nr;
-			    }
-			}
-		    }
-
-		  for (octave_idx_type iidx = kc; iidx < lhs_nc+1; iidx++)
-		    stmp.xcidx(iidx) = kk; 
-
-		  lhs = stmp;
-		}
-	      else if (rhs_nr == 1 && rhs_nc == 1)
-		{
-		  RT scalar = rhs.elem (0, 0);
-		  octave_idx_type new_nzmx = lhs_nz;
-		  idx_i.sort (true);
-		  len = idx_i.length (len);
-
-		  // First count the number of non-zero elements
-		  if (scalar != RT ())
-		    new_nzmx += len;
-		  for (octave_idx_type i = 0; i < len; i++)
-		    {
-		      octave_quit ();
-		      octave_idx_type ii = idx_i.elem (i);
-		      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
-			new_nzmx--;
-		    }
-
-		  Sparse<LT> stmp (lhs_nr, lhs_nc, new_nzmx);
-
-		  octave_idx_type i = 0;
-		  octave_idx_type ii = 0;
-		  octave_idx_type ic = 0;
-		  if (i < lhs_nz)
-		    {
-		      while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
-			ic++;
-		      ii = ic * lhs_nr + c_lhs.ridx(i);
-		    }
-
-		  octave_idx_type j = 0;
-		  octave_idx_type jj = idx_i.elem (j);
-		  octave_idx_type jr = jj % lhs_nr;
-		  octave_idx_type jc = (jj - jr) / lhs_nr;
-
-		  octave_idx_type kk = 0;
-		  octave_idx_type kc = 0;
-
-		  while (j < len || i < lhs_nz)
-		    {
-		      if (j == len || (i < lhs_nz && ii < jj))
-			{
-			  while (kc <= ic)
-			    stmp.xcidx (kc++) = kk;
-			  stmp.xdata (kk) = c_lhs.data (i);
-			  stmp.xridx (kk++) = c_lhs.ridx (i);
-			  i++;
-			  while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
-			    ic++;
-			  if (i < lhs_nz)
-			    ii = ic * lhs_nr + c_lhs.ridx(i);
-			}
-		      else
-			{
-			  while (kc <= jc)
-			    stmp.xcidx (kc++) = kk;
-			  if (scalar != RT ())
-			    {
-			      stmp.xdata (kk) = scalar;
-			      stmp.xridx (kk++) = jr;
-			    }
-			  if (ii == jj)
-			    {
-			      i++;
-			      while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
-				ic++;
-			      if (i < lhs_nz)
-				ii = ic * lhs_nr + c_lhs.ridx(i);
-			    }
-			  j++;
-			  if (j < len)
-			    {
-			      jj = idx_i.elem (j);
-			      jr = jj % lhs_nr;
-			      jc = (jj - jr) / lhs_nr;
-			    }
-			}
-		    }
-
-		  for (octave_idx_type iidx = kc; iidx < lhs_nc+1; iidx++)
-		    stmp.xcidx(iidx) = kk;
-		  
-		  lhs = stmp;
-		}
-	      else
-		{
-		  (*current_liboctave_error_handler)
+        {
+          if (! idx_i.is_colon ())
+            (*current_liboctave_warning_with_id_handler)
+              ("Octave:fortran-indexing", "single index used for matrix");
+
+          octave_idx_type lhs_len = lhs.length ();
+
+          octave_idx_type len = idx_i.freeze (lhs_nr * lhs_nc, "matrix");
+
+          if (idx_i)
+            {
+              if (len == 0)
+                {
+                  if (! ((rhs_nr == 1 && rhs_nc == 1)
+                         || (rhs_nr == 0 || rhs_nc == 0)))
+                    (*current_liboctave_error_handler)
+                      ("A([]) = X: X must be an empty matrix or scalar");
+                }
+              else if (len == rhs_nr * rhs_nc)
+                {
+                  octave_idx_type new_nzmx = lhs_nz;
+                  OCTAVE_LOCAL_BUFFER (octave_idx_type, rhs_idx, len);
+                  
+                  if (! idx_i.is_colon ())
+                    {
+                      // Ok here we have to be careful with the indexing, to
+                      // treat cases like "a([3,2,1]) = b", and still handle
+                      // the need for strict sorting of the sparse elements.
+
+                      OCTAVE_LOCAL_BUFFER (octave_idx_vector_sort *, sidx, 
+                                           len);
+                      OCTAVE_LOCAL_BUFFER (octave_idx_vector_sort, sidxX, 
+                                           len);
+
+                      for (octave_idx_type i = 0; i < len; i++)
+                        {
+                          sidx[i] = &sidxX[i];
+                          sidx[i]->i = idx_i.elem(i);
+                          sidx[i]->idx = i;
+                        }
+
+                      octave_quit ();
+                      octave_sort<octave_idx_vector_sort *> 
+                        sort (octave_idx_vector_comp);
+
+                      sort.sort (sidx, len);
+
+                      intNDArray<octave_idx_type> new_idx (dim_vector (len,1));
+
+                      for (octave_idx_type i = 0; i < len; i++)
+                        {
+                          new_idx.xelem(i) = sidx[i]->i;
+                          rhs_idx[i] = sidx[i]->idx;
+                        }
+
+                      idx_i = idx_vector (new_idx);
+                    }
+                  else
+                    for (octave_idx_type i = 0; i < len; i++)
+                      rhs_idx[i] = i;
+
+                  // First count the number of non-zero elements
+                  for (octave_idx_type i = 0; i < len; i++)
+                    {
+                      octave_quit ();
+                      
+                      octave_idx_type ii = idx_i.elem (i);
+                      if (i < len - 1 && idx_i.elem (i + 1) == ii)
+                        continue;
+                      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
+                        new_nzmx--;
+                      if (rhs.elem(rhs_idx[i]) != RT ())
+                        new_nzmx++;
+                    }
+
+                  Sparse<LT> stmp (lhs_nr, lhs_nc, new_nzmx);
+
+                  octave_idx_type i = 0;
+                  octave_idx_type ii = 0;
+                  octave_idx_type ic = 0;
+                  if (i < lhs_nz)
+                    {
+                      while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
+                        ic++;
+                      ii = ic * lhs_nr + c_lhs.ridx(i);
+                    }
+
+                  octave_idx_type j = 0;
+                  octave_idx_type jj = idx_i.elem (j);
+                  octave_idx_type jr = jj % lhs_nr;
+                  octave_idx_type jc = (jj - jr) / lhs_nr;
+
+                  octave_idx_type kk = 0;
+                  octave_idx_type kc = 0;
+
+                  while (j < len || i < lhs_nz)
+                    {
+                      if (j < len - 1 && idx_i.elem (j + 1) == jj)
+                        {
+                          j++;
+                          jj = idx_i.elem (j);
+                          jr = jj % lhs_nr;
+                          jc = (jj - jr) / lhs_nr;
+                          continue;
+                        }
+
+                      if (j == len || (i < lhs_nz && ii < jj))
+                        {
+                          while (kc <= ic)
+                            stmp.xcidx (kc++) = kk;
+                          stmp.xdata (kk) = c_lhs.data (i);
+                          stmp.xridx (kk++) = c_lhs.ridx (i);
+                          i++;
+                          while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
+                            ic++;
+                          if (i < lhs_nz)
+                            ii = ic * lhs_nr + c_lhs.ridx(i);
+                        }
+                      else
+                        {
+                          while (kc <= jc)
+                            stmp.xcidx (kc++) = kk;
+                          RT rtmp = rhs.elem (rhs_idx[j]);
+                          if (rtmp != RT ())
+                            {
+                              stmp.xdata (kk) = rtmp;
+                              stmp.xridx (kk++) = jr;
+                            }
+                          if (ii == jj)
+                            {
+                              i++;
+                              while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
+                                ic++;
+                              if (i < lhs_nz)
+                                ii = ic * lhs_nr + c_lhs.ridx(i);
+                            }
+                          j++;
+                          if (j < len)
+                            {
+                              jj = idx_i.elem (j);
+                              jr = jj % lhs_nr;
+                              jc = (jj - jr) / lhs_nr;
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type iidx = kc; iidx < lhs_nc+1; iidx++)
+                    stmp.xcidx(iidx) = kk; 
+
+                  lhs = stmp;
+                }
+              else if (rhs_nr == 1 && rhs_nc == 1)
+                {
+                  RT scalar = rhs.elem (0, 0);
+                  octave_idx_type new_nzmx = lhs_nz;
+                  idx_i.sort (true);
+                  len = idx_i.length (len);
+
+                  // First count the number of non-zero elements
+                  if (scalar != RT ())
+                    new_nzmx += len;
+                  for (octave_idx_type i = 0; i < len; i++)
+                    {
+                      octave_quit ();
+                      octave_idx_type ii = idx_i.elem (i);
+                      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
+                        new_nzmx--;
+                    }
+
+                  Sparse<LT> stmp (lhs_nr, lhs_nc, new_nzmx);
+
+                  octave_idx_type i = 0;
+                  octave_idx_type ii = 0;
+                  octave_idx_type ic = 0;
+                  if (i < lhs_nz)
+                    {
+                      while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
+                        ic++;
+                      ii = ic * lhs_nr + c_lhs.ridx(i);
+                    }
+
+                  octave_idx_type j = 0;
+                  octave_idx_type jj = idx_i.elem (j);
+                  octave_idx_type jr = jj % lhs_nr;
+                  octave_idx_type jc = (jj - jr) / lhs_nr;
+
+                  octave_idx_type kk = 0;
+                  octave_idx_type kc = 0;
+
+                  while (j < len || i < lhs_nz)
+                    {
+                      if (j == len || (i < lhs_nz && ii < jj))
+                        {
+                          while (kc <= ic)
+                            stmp.xcidx (kc++) = kk;
+                          stmp.xdata (kk) = c_lhs.data (i);
+                          stmp.xridx (kk++) = c_lhs.ridx (i);
+                          i++;
+                          while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
+                            ic++;
+                          if (i < lhs_nz)
+                            ii = ic * lhs_nr + c_lhs.ridx(i);
+                        }
+                      else
+                        {
+                          while (kc <= jc)
+                            stmp.xcidx (kc++) = kk;
+                          if (scalar != RT ())
+                            {
+                              stmp.xdata (kk) = scalar;
+                              stmp.xridx (kk++) = jr;
+                            }
+                          if (ii == jj)
+                            {
+                              i++;
+                              while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
+                                ic++;
+                              if (i < lhs_nz)
+                                ii = ic * lhs_nr + c_lhs.ridx(i);
+                            }
+                          j++;
+                          if (j < len)
+                            {
+                              jj = idx_i.elem (j);
+                              jr = jj % lhs_nr;
+                              jc = (jj - jr) / lhs_nr;
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type iidx = kc; iidx < lhs_nc+1; iidx++)
+                    stmp.xcidx(iidx) = kk;
+                  
+                  lhs = stmp;
+                }
+              else
+                {
+                  (*current_liboctave_error_handler)
       ("A(I) = X: X must be a scalar or a matrix with the same size as I");
 
-		  retval = 0;
-		}
-	    }
-	  // idx_vector::freeze() printed an error message for us.
-	}
+                  retval = 0;
+                }
+            }
+          // idx_vector::freeze() printed an error message for us.
+        }
     }
   else
     {
       (*current_liboctave_error_handler)
-	("invalid number of indices for matrix expression");
+        ("invalid number of indices for matrix expression");
 
       retval = 0;
     }
 
   lhs.clear_index ();
 
   return retval;
 }
diff --git a/liboctave/SparseCmplxCHOL.cc b/liboctave/SparseCmplxCHOL.cc
--- a/liboctave/SparseCmplxCHOL.cc
+++ b/liboctave/SparseCmplxCHOL.cc
@@ -45,26 +45,26 @@ chol2inv (const SparseComplexMatrix& r)
     {
       MatrixType mattype (r);
       int typ = mattype.type (false);
       double rcond;
       octave_idx_type info;
       SparseComplexMatrix rinv;
 
       if (typ == MatrixType::Upper)
-	{
-	  rinv = r.inverse(mattype, info, rcond, true, false);
-	  retval = rinv.transpose() * rinv;
-	}
+        {
+          rinv = r.inverse(mattype, info, rcond, true, false);
+          retval = rinv.transpose() * rinv;
+        }
       else if (typ == MatrixType::Lower)
-	{
-	  rinv = r.transpose().inverse(mattype, info, rcond, true, false);
-	  retval = rinv.transpose() * rinv;
-	}
+        {
+          rinv = r.transpose().inverse(mattype, info, rcond, true, false);
+          retval = rinv.transpose() * rinv;
+        }
       else
-	(*current_liboctave_error_handler) 
-	  ("spchol2inv requires triangular matrix");
+        (*current_liboctave_error_handler) 
+          ("spchol2inv requires triangular matrix");
     }
   else
     (*current_liboctave_error_handler) ("spchol2inv requires square matrix");
 
   return retval;
 }
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 #include "sparse-base-lu.h"
 #include "sparse-base-lu.cc"
 
 template class sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double>;
 
 #include "oct-sparse.h"
 
 SparseComplexLU::SparseComplexLU (const SparseComplexMatrix& a, 
-				  const Matrix& piv_thres, bool scale)
+                                  const Matrix& piv_thres, bool scale)
 {
 #ifdef HAVE_UMFPACK
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
@@ -56,30 +56,30 @@ SparseComplexLU::SparseComplexLU (const 
 
   double tmp = octave_sparse_params::get_key ("spumoni");
   if (!xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
   if (piv_thres.nelem() == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
       if (!xisnan (tmp))
-	Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+        Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
       if (!xisnan (tmp))
-	Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+        Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
   else
     {
       tmp = octave_sparse_params::get_key ("piv_tol");
       if (!xisnan (tmp))
-	Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+        Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
       tmp = octave_sparse_params::get_key ("sym_tol");
       if (!xisnan (tmp))
-	  Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+          Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = octave_sparse_params::get_key ("autoamd");
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   // Turn-off UMFPACK scaling for LU 
@@ -90,169 +90,169 @@ SparseComplexLU::SparseComplexLU (const 
 
   UMFPACK_ZNAME (report_control) (control);
 
   const octave_idx_type *Ap = a.cidx ();
   const octave_idx_type *Ai = a.ridx ();
   const Complex *Ax = a.data ();
 
   UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
-				 reinterpret_cast<const double *> (Ax),
-				 0, 1, control);
+                                 reinterpret_cast<const double *> (Ax),
+                                 0, 1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
-					  reinterpret_cast<const double *> (Ax),
-					  0, 0,
-					  &Symbolic, control, info);
+                                          reinterpret_cast<const double *> (Ax),
+                                          0, 0,
+                                          &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
-	    ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
+            ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
 
       UMFPACK_ZNAME (report_status) (control, status);
       UMFPACK_ZNAME (report_info) (control, info);
 
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       void *Numeric;
       status = UMFPACK_ZNAME (numeric) (Ap, Ai,
-					reinterpret_cast<const double *> (Ax),
-					0, Symbolic, &Numeric, control,
-					info);
+                                        reinterpret_cast<const double *> (Ax),
+                                        0, Symbolic, &Numeric, control,
+                                        info);
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
       cond = Info (UMFPACK_RCOND);
 
       if (status < 0)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("SparseComplexLU::SparseComplexLU numeric factorization failed");
+        {
+          (*current_liboctave_error_handler) 
+            ("SparseComplexLU::SparseComplexLU numeric factorization failed");
 
-	  UMFPACK_ZNAME (report_status) (control, status);
-	  UMFPACK_ZNAME (report_info) (control, info);
+          UMFPACK_ZNAME (report_status) (control, status);
+          UMFPACK_ZNAME (report_info) (control, info);
 
-	  UMFPACK_ZNAME (free_numeric) (&Numeric);
-	}
+          UMFPACK_ZNAME (free_numeric) (&Numeric);
+        }
       else
-	{
-	  UMFPACK_ZNAME (report_numeric) (Numeric, control);
+        {
+          UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
-	  octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
-	  status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz, &ignore1,
-					&ignore2, &ignore3, Numeric) ;
-	  
-	  if (status < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("SparseComplexLU::SparseComplexLU extracting LU factors failed");
+          octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
+          status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz, &ignore1,
+                                        &ignore2, &ignore3, Numeric) ;
+          
+          if (status < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
-	      UMFPACK_ZNAME (report_status) (control, status);
-	      UMFPACK_ZNAME (report_info) (control, info);
+              UMFPACK_ZNAME (report_status) (control, status);
+              UMFPACK_ZNAME (report_info) (control, info);
 
-	      UMFPACK_ZNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    {
-	      octave_idx_type n_inner = (nr < nc ? nr : nc);
+              UMFPACK_ZNAME (free_numeric) (&Numeric);
+            }
+          else
+            {
+              octave_idx_type n_inner = (nr < nc ? nr : nc);
 
-	      if (lnz < 1)
-		Lfact = SparseComplexMatrix (n_inner, nr,
-					     static_cast<octave_idx_type> (1));
-	      else
-		Lfact = SparseComplexMatrix (n_inner, nr, lnz);
+              if (lnz < 1)
+                Lfact = SparseComplexMatrix (n_inner, nr,
+                                             static_cast<octave_idx_type> (1));
+              else
+                Lfact = SparseComplexMatrix (n_inner, nr, lnz);
 
-	      octave_idx_type *Ltp = Lfact.cidx ();
-	      octave_idx_type *Ltj = Lfact.ridx ();
-	      Complex *Ltx = Lfact.data ();
+              octave_idx_type *Ltp = Lfact.cidx ();
+              octave_idx_type *Ltj = Lfact.ridx ();
+              Complex *Ltx = Lfact.data ();
 
-	      if (unz < 1)
-		Ufact = SparseComplexMatrix (n_inner, nc,
-					     static_cast<octave_idx_type> (1));
-	      else
-		Ufact = SparseComplexMatrix (n_inner, nc, unz);
+              if (unz < 1)
+                Ufact = SparseComplexMatrix (n_inner, nc,
+                                             static_cast<octave_idx_type> (1));
+              else
+                Ufact = SparseComplexMatrix (n_inner, nc, unz);
 
-	      octave_idx_type *Up = Ufact.cidx ();
-	      octave_idx_type *Uj = Ufact.ridx ();
-	      Complex *Ux = Ufact.data ();
-	      
-	      Rfact = SparseMatrix (nr, nr, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  Rfact.xridx (i) = i;
-		  Rfact.xcidx (i) = i;
-		}
-	      Rfact.xcidx (nr) = nr;
-	      double *Rx = Rfact.data ();
+              octave_idx_type *Up = Ufact.cidx ();
+              octave_idx_type *Uj = Ufact.ridx ();
+              Complex *Ux = Ufact.data ();
+              
+              Rfact = SparseMatrix (nr, nr, nr);
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  Rfact.xridx (i) = i;
+                  Rfact.xcidx (i) = i;
+                }
+              Rfact.xcidx (nr) = nr;
+              double *Rx = Rfact.data ();
 
-	      P.resize (nr);
-	      octave_idx_type *p = P.fortran_vec ();
+              P.resize (nr);
+              octave_idx_type *p = P.fortran_vec ();
 
-	      Q.resize (nc);
-	      octave_idx_type *q = Q.fortran_vec ();
+              Q.resize (nc);
+              octave_idx_type *q = Q.fortran_vec ();
 
-	      octave_idx_type do_recip;
-	      status = UMFPACK_ZNAME (get_numeric) (Ltp, Ltj,
-						    reinterpret_cast<double *> (Ltx),
-						    0, Up, Uj,
-						    reinterpret_cast <double *> (Ux),
-						    0, p, q, 0, 0,
-						    &do_recip, Rx, Numeric);
+              octave_idx_type do_recip;
+              status = UMFPACK_ZNAME (get_numeric) (Ltp, Ltj,
+                                                    reinterpret_cast<double *> (Ltx),
+                                                    0, Up, Uj,
+                                                    reinterpret_cast <double *> (Ux),
+                                                    0, p, q, 0, 0,
+                                                    &do_recip, Rx, Numeric);
 
-	      UMFPACK_ZNAME (free_numeric) (&Numeric) ;
+              UMFPACK_ZNAME (free_numeric) (&Numeric) ;
 
-	      if (status < 0)
-		{
-		  (*current_liboctave_error_handler) 
-		    ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
+              if (status < 0)
+                {
+                  (*current_liboctave_error_handler) 
+                    ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
-		  UMFPACK_ZNAME (report_status) (control, status);
-		}
-	      else
-		{
-		  Lfact = Lfact.transpose ();
+                  UMFPACK_ZNAME (report_status) (control, status);
+                }
+              else
+                {
+                  Lfact = Lfact.transpose ();
 
-		  if (do_recip)
-		    for (octave_idx_type i = 0; i < nr; i++)
-		      Rx[i] = 1.0 / Rx[i];
+                  if (do_recip)
+                    for (octave_idx_type i = 0; i < nr; i++)
+                      Rx[i] = 1.0 / Rx[i];
 
-		  UMFPACK_ZNAME (report_matrix) (nr, n_inner,
-					    Lfact.cidx (), Lfact.ridx (), 
-					    reinterpret_cast<double *> (Lfact.data()), 
-					    0, 1, control);
+                  UMFPACK_ZNAME (report_matrix) (nr, n_inner,
+                                            Lfact.cidx (), Lfact.ridx (), 
+                                            reinterpret_cast<double *> (Lfact.data()), 
+                                            0, 1, control);
 
-		  UMFPACK_ZNAME (report_matrix) (n_inner, nc,
-					    Ufact.cidx (), Ufact.ridx (), 
-					    reinterpret_cast<double *> (Ufact.data()), 
-					    0, 1, control);
-		  UMFPACK_ZNAME (report_perm) (nr, p, control);
-		  UMFPACK_ZNAME (report_perm) (nc, q, control);
-		}
+                  UMFPACK_ZNAME (report_matrix) (n_inner, nc,
+                                            Ufact.cidx (), Ufact.ridx (), 
+                                            reinterpret_cast<double *> (Ufact.data()), 
+                                            0, 1, control);
+                  UMFPACK_ZNAME (report_perm) (nr, p, control);
+                  UMFPACK_ZNAME (report_perm) (nc, q, control);
+                }
 
-	      UMFPACK_ZNAME (report_info) (control, info);
-	    }
-	}
+              UMFPACK_ZNAME (report_info) (control, info);
+            }
+        }
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 }
 
 SparseComplexLU::SparseComplexLU (const SparseComplexMatrix& a, 
-				  const ColumnVector& Qinit, 
-				  const Matrix& piv_thres, bool scale,
-				  bool FixedQ, double droptol, 
-				  bool milu, bool udiag)
+                                  const ColumnVector& Qinit, 
+                                  const Matrix& piv_thres, bool scale,
+                                  bool FixedQ, double droptol, 
+                                  bool milu, bool udiag)
 {
 #ifdef HAVE_UMFPACK
   if (milu)
     (*current_liboctave_error_handler) 
       ("Modified incomplete LU not implemented");   
   else
     {
       octave_idx_type nr = a.rows ();
@@ -260,220 +260,220 @@ SparseComplexLU::SparseComplexLU (const 
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_ZNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
       if (!xisnan (tmp))
-	Control (UMFPACK_PRL) = tmp;
+        Control (UMFPACK_PRL) = tmp;
       if (piv_thres.nelem() == 2)
-	{
-	  tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
-	  if (!xisnan (tmp))
-	    Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
-	  tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
-	  if (!xisnan (tmp))
-	    Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
-	}
+        {
+          tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
+          if (!xisnan (tmp))
+            Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+          tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
+          if (!xisnan (tmp))
+            Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+        }
       else
-	{
-	  tmp = octave_sparse_params::get_key ("piv_tol");
-	  if (!xisnan (tmp))
-	    Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+        {
+          tmp = octave_sparse_params::get_key ("piv_tol");
+          if (!xisnan (tmp))
+            Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
-	  tmp = octave_sparse_params::get_key ("sym_tol");
-	  if (!xisnan (tmp))
-	    Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
-	}
+          tmp = octave_sparse_params::get_key ("sym_tol");
+          if (!xisnan (tmp))
+            Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+        }
 
       if (droptol >= 0.)
-	Control (UMFPACK_DROPTOL) = droptol;
+        Control (UMFPACK_DROPTOL) = droptol;
 
       // Set whether we are allowed to modify Q or not
       if (FixedQ)
-	Control (UMFPACK_FIXQ) = 1.0;
+        Control (UMFPACK_FIXQ) = 1.0;
       else
-	{
-	  tmp = octave_sparse_params::get_key ("autoamd");
-	  if (!xisnan (tmp))
-	    Control (UMFPACK_FIXQ) = tmp;
-	}
+        {
+          tmp = octave_sparse_params::get_key ("autoamd");
+          if (!xisnan (tmp))
+            Control (UMFPACK_FIXQ) = tmp;
+        }
 
       // Turn-off UMFPACK scaling for LU 
       if (scale)
-	Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
+        Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
       else
-	Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
+        Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = a.cidx ();
       const octave_idx_type *Ai = a.ridx ();
       const Complex *Ax = a.data ();
 
       UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai, 
-				reinterpret_cast<const double *> (Ax), 0,
-				1, control);
+                                reinterpret_cast<const double *> (Ax), 0,
+                                1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not
       // needed
       do {
-	OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
+        OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
-	for (octave_idx_type i = 0; i < nc; i++)
-	  qinit [i] = static_cast<octave_idx_type> (Qinit (i));
+        for (octave_idx_type i = 0; i < nc; i++)
+          qinit [i] = static_cast<octave_idx_type> (Qinit (i));
 
-	status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
-				       reinterpret_cast<const double *> (Ax),
-				       0, qinit, &Symbolic, control, 
-				       info);
+        status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
+                                       reinterpret_cast<const double *> (Ax),
+                                       0, qinit, &Symbolic, control, 
+                                       info);
       } while (0);
 
       if (status < 0)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
+        {
+          (*current_liboctave_error_handler) 
+            ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
 
-	  UMFPACK_ZNAME (report_status) (control, status);
-	  UMFPACK_ZNAME (report_info) (control, info);
+          UMFPACK_ZNAME (report_status) (control, status);
+          UMFPACK_ZNAME (report_info) (control, info);
 
-	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
-	}
+          UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
+        }
       else
-	{
-	  UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
+        {
+          UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
-	  void *Numeric;
-	  status = UMFPACK_ZNAME (numeric) (Ap, Ai, 
-				       reinterpret_cast<const double *> (Ax), 0,
-				       Symbolic, &Numeric, control, info) ;
-	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
+          void *Numeric;
+          status = UMFPACK_ZNAME (numeric) (Ap, Ai, 
+                                       reinterpret_cast<const double *> (Ax), 0,
+                                       Symbolic, &Numeric, control, info) ;
+          UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
-	  cond = Info (UMFPACK_RCOND);
+          cond = Info (UMFPACK_RCOND);
 
-	  if (status < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("SparseComplexLU::SparseComplexLU numeric factorization failed");
+          if (status < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("SparseComplexLU::SparseComplexLU numeric factorization failed");
 
-	      UMFPACK_ZNAME (report_status) (control, status);
-	      UMFPACK_ZNAME (report_info) (control, info);
+              UMFPACK_ZNAME (report_status) (control, status);
+              UMFPACK_ZNAME (report_info) (control, info);
 
-	      UMFPACK_ZNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    {
-	      UMFPACK_ZNAME (report_numeric) (Numeric, control);
+              UMFPACK_ZNAME (free_numeric) (&Numeric);
+            }
+          else
+            {
+              UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
-	      octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
-	      status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz,
-					    &ignore1, &ignore2, &ignore3, Numeric);
-	  
-	      if (status < 0)
-		{
-		  (*current_liboctave_error_handler) 
-		    ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
+              octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
+              status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz,
+                                            &ignore1, &ignore2, &ignore3, Numeric);
+          
+              if (status < 0)
+                {
+                  (*current_liboctave_error_handler) 
+                    ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
-		  UMFPACK_ZNAME (report_status) (control, status);
-		  UMFPACK_ZNAME (report_info) (control, info);
+                  UMFPACK_ZNAME (report_status) (control, status);
+                  UMFPACK_ZNAME (report_info) (control, info);
 
-		  UMFPACK_ZNAME (free_numeric) (&Numeric);
-		}
-	      else
-		{
-		  octave_idx_type n_inner = (nr < nc ? nr : nc);
+                  UMFPACK_ZNAME (free_numeric) (&Numeric);
+                }
+              else
+                {
+                  octave_idx_type n_inner = (nr < nc ? nr : nc);
 
-		  if (lnz < 1)
-		    Lfact = SparseComplexMatrix (n_inner, nr,
-		       static_cast<octave_idx_type> (1));
-		  else
-		    Lfact = SparseComplexMatrix (n_inner, nr, lnz);
+                  if (lnz < 1)
+                    Lfact = SparseComplexMatrix (n_inner, nr,
+                       static_cast<octave_idx_type> (1));
+                  else
+                    Lfact = SparseComplexMatrix (n_inner, nr, lnz);
 
-		  octave_idx_type *Ltp = Lfact.cidx ();
-		  octave_idx_type *Ltj = Lfact.ridx ();
-		  Complex *Ltx = Lfact.data ();
+                  octave_idx_type *Ltp = Lfact.cidx ();
+                  octave_idx_type *Ltj = Lfact.ridx ();
+                  Complex *Ltx = Lfact.data ();
 
-		  if (unz < 1)
-		    Ufact = SparseComplexMatrix (n_inner, nc,
-		       static_cast<octave_idx_type> (1));
-		  else
-		    Ufact = SparseComplexMatrix  (n_inner, nc, unz);
+                  if (unz < 1)
+                    Ufact = SparseComplexMatrix (n_inner, nc,
+                       static_cast<octave_idx_type> (1));
+                  else
+                    Ufact = SparseComplexMatrix  (n_inner, nc, unz);
 
-		  octave_idx_type *Up = Ufact.cidx ();
-		  octave_idx_type *Uj = Ufact.ridx ();
-		  Complex *Ux = Ufact.data ();
-	      
-		  Rfact = SparseMatrix (nr, nr, nr);
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    {
-		      Rfact.xridx (i) = i;
-		      Rfact.xcidx (i) = i;
-		    }
-		  Rfact.xcidx (nr) = nr;
-		  double *Rx = Rfact.data ();
+                  octave_idx_type *Up = Ufact.cidx ();
+                  octave_idx_type *Uj = Ufact.ridx ();
+                  Complex *Ux = Ufact.data ();
+              
+                  Rfact = SparseMatrix (nr, nr, nr);
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    {
+                      Rfact.xridx (i) = i;
+                      Rfact.xcidx (i) = i;
+                    }
+                  Rfact.xcidx (nr) = nr;
+                  double *Rx = Rfact.data ();
 
-		  P.resize (nr);
-		  octave_idx_type *p = P.fortran_vec ();
+                  P.resize (nr);
+                  octave_idx_type *p = P.fortran_vec ();
 
-		  Q.resize (nc);
-		  octave_idx_type *q = Q.fortran_vec ();
+                  Q.resize (nc);
+                  octave_idx_type *q = Q.fortran_vec ();
 
-		  octave_idx_type do_recip;
-		  status = 
-		    UMFPACK_ZNAME (get_numeric) (Ltp, Ltj, 
-					    reinterpret_cast<double *> (Ltx),
-					    0, Up, Uj,
-					    reinterpret_cast<double *> (Ux), 
-					    0, p, q, 0, 0, 
-					    &do_recip, Rx, Numeric) ;
+                  octave_idx_type do_recip;
+                  status = 
+                    UMFPACK_ZNAME (get_numeric) (Ltp, Ltj, 
+                                            reinterpret_cast<double *> (Ltx),
+                                            0, Up, Uj,
+                                            reinterpret_cast<double *> (Ux), 
+                                            0, p, q, 0, 0, 
+                                            &do_recip, Rx, Numeric) ;
 
-		  UMFPACK_ZNAME (free_numeric) (&Numeric) ;
+                  UMFPACK_ZNAME (free_numeric) (&Numeric) ;
 
-		  if (status < 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseComplexLU::SparseComplexLU extracting LU factors failed");
+                  if (status < 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
-		      UMFPACK_ZNAME (report_status) (control, status);
-		    }
-		  else
-		    {
-		      Lfact = Lfact.transpose ();
+                      UMFPACK_ZNAME (report_status) (control, status);
+                    }
+                  else
+                    {
+                      Lfact = Lfact.transpose ();
 
-		      if (do_recip)
-			for (octave_idx_type i = 0; i < nr; i++)
-			  Rx[i] = 1.0 / Rx[i];
+                      if (do_recip)
+                        for (octave_idx_type i = 0; i < nr; i++)
+                          Rx[i] = 1.0 / Rx[i];
 
-		      UMFPACK_ZNAME (report_matrix) (nr, n_inner, 
-						Lfact.cidx (), 
-						Lfact.ridx (), 
-						reinterpret_cast<double *> (Lfact.data()), 
-						0, 1, control);
+                      UMFPACK_ZNAME (report_matrix) (nr, n_inner, 
+                                                Lfact.cidx (), 
+                                                Lfact.ridx (), 
+                                                reinterpret_cast<double *> (Lfact.data()), 
+                                                0, 1, control);
 
-		      UMFPACK_ZNAME (report_matrix) (n_inner, nc, 
-						Ufact.cidx (), 
-						Ufact.ridx (), 
-						reinterpret_cast<double *> (Ufact.data()), 
-						0, 1, control);
-		      UMFPACK_ZNAME (report_perm) (nr, p, control);
-		      UMFPACK_ZNAME (report_perm) (nc, q, control);
-		    }
+                      UMFPACK_ZNAME (report_matrix) (n_inner, nc, 
+                                                Ufact.cidx (), 
+                                                Ufact.ridx (), 
+                                                reinterpret_cast<double *> (Ufact.data()), 
+                                                0, 1, control);
+                      UMFPACK_ZNAME (report_perm) (nr, p, control);
+                      UMFPACK_ZNAME (report_perm) (nc, q, control);
+                    }
 
-		  UMFPACK_ZNAME (report_info) (control, info);
-		}
-	    }
-	}
+                  UMFPACK_ZNAME (report_info) (control, info);
+                }
+            }
+        }
 
       if (udiag)
-	(*current_liboctave_error_handler) 
-	  ("Option udiag of incomplete LU not implemented");   
+        (*current_liboctave_error_handler) 
+          ("Option udiag of incomplete LU not implemented");   
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 }
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -57,17 +57,17 @@ SparseComplexQR::SparseComplexQR_rep::Sp
   A.m = a.rows ();
   A.n = a.cols ();
   nrows = A.m;
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
   A.x = const_cast<cs_complex_t *>(reinterpret_cast<const cs_complex_t *> 
-				      (a.data ()));
+                                      (a.data ()));
   A.nz = -1;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
   S = CXSPARSE_ZNAME (_sqr) (order, &A, 1);
 #else
   S = CXSPARSE_ZNAME (_sqr) (&A, order - 1, 1);
 #endif
   N = CXSPARSE_ZNAME (_qr) (&A, S);
@@ -199,39 +199,39 @@ SparseComplexQR::SparseComplexQR_rep::C 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     ret = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
-	{
-	  octave_quit ();
-	  volatile octave_idx_type nm = (nr < nc ? nr : nc);
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          volatile octave_idx_type nm = (nr < nc ? nr : nc);
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (S->pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf), b_nr);
+          CXSPARSE_ZNAME (_ipvec) 
+            (S->pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf), b_nr);
 #else
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (b_nr, S->Pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf));
+          CXSPARSE_ZNAME (_ipvec) 
+            (b_nr, S->Pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf));
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type i = 0; i < nm; i++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (_happly) 
-		(N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  for (octave_idx_type i = 0; i < b_nr; i++)
-	    vec[i+idx] = buf[i];
-	}
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type i = 0; i < nm; i++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_ZNAME (_happly) 
+                (N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          for (octave_idx_type i = 0; i < b_nr; i++)
+            vec[i+idx] = buf[i];
+        }
     }
   return ret;
 #else
   return ComplexMatrix ();
 #endif
 }
 
 ComplexMatrix
@@ -245,44 +245,44 @@ SparseComplexQR::SparseComplexQR_rep::Q 
   if (nr < 0 || nc < 0)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0)
     ret = ComplexMatrix (nc, nr, Complex (0.0, 0.0));
   else
     {
       OCTAVE_C99_COMPLEX (bvec, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-	bvec[i] = OCTAVE_C99_ZERO;
+        bvec[i] = OCTAVE_C99_ZERO;
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
-	{
-	  octave_quit ();
-	  bvec[j] = OCTAVE_C99_ONE;
-	  volatile octave_idx_type nm = (nr < nc ? nr : nc);
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          bvec[j] = OCTAVE_C99_ONE;
+          volatile octave_idx_type nm = (nr < nc ? nr : nc);
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (S->pinv, bvec, reinterpret_cast<cs_complex_t *>(buf), nr);
+          CXSPARSE_ZNAME (_ipvec) 
+            (S->pinv, bvec, reinterpret_cast<cs_complex_t *>(buf), nr);
 #else
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (nr, S->Pinv, bvec, reinterpret_cast<cs_complex_t *>(buf));
+          CXSPARSE_ZNAME (_ipvec) 
+            (nr, S->Pinv, bvec, reinterpret_cast<cs_complex_t *>(buf));
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type i = 0; i < nm; i++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (_happly) 
-		(N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    vec[i+idx] = buf[i];
-	  bvec[j] = OCTAVE_C99_ZERO;
-	}
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type i = 0; i < nm; i++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_ZNAME (_happly) 
+                (N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          for (octave_idx_type i = 0; i < nr; i++)
+            vec[i+idx] = buf[i];
+          bvec[j] = OCTAVE_C99_ZERO;
+        }
     }
   return ret.hermitian ();
 #else
   return ComplexMatrix ();
 #endif
 }
 
 ComplexMatrix
@@ -300,115 +300,115 @@ qrsolve(const SparseComplexMatrix&a, con
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
-	return ComplexMatrix();
+        return ComplexMatrix();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-	(x.fortran_vec());
+        (x.fortran_vec());
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = 0; j < b_nr; j++)
-	    Xx[j] = b.xelem(j,i);
-	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
-	    buf[j] = OCTAVE_C99_ZERO;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type j = 0; j < b_nr; j++)
+            Xx[j] = b.xelem(j,i);
+          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+            buf[j] = OCTAVE_C99_ZERO;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+          CXSPARSE_ZNAME (_ipvec) 
+            (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
+          CXSPARSE_ZNAME (_ipvec) 
+            (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
+          CXSPARSE_ZNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
 #else
-	  CXSPARSE_ZNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
+          CXSPARSE_ZNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	}
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
-	return ComplexMatrix();
+        return ComplexMatrix();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-	(x.fortran_vec());
+        (x.fortran_vec());
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_C99_COMPLEX (buf, nbuf);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-	B[i] = q.N()->B [i];
+        B[i] = q.N()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = 0; j < b_nr; j++)
-	    Xx[j] = b.xelem(j,i);
-	  for (octave_idx_type j = nr; j < nbuf; j++)
-	    buf[j] = OCTAVE_C99_ZERO;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type j = 0; j < b_nr; j++)
+            Xx[j] = b.xelem(j,i);
+          for (octave_idx_type j = nr; j < nbuf; j++)
+            buf[j] = OCTAVE_C99_ZERO;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_pvec)
-	    (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+          CXSPARSE_ZNAME (_pvec)
+            (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
-	  CXSPARSE_ZNAME (_pvec)
-	    (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
+          CXSPARSE_ZNAME (_pvec)
+            (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
-	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = nr-1; j >= 0; j--)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
-	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
 #else
-	      CXSPARSE_ZNAME (_happly) 
-		(q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
+              CXSPARSE_ZNAME (_happly) 
+                (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
+          CXSPARSE_ZNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
 #else
-	  CXSPARSE_ZNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
+          CXSPARSE_ZNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	}
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        }
       info = 0;
     }
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
 }
@@ -429,159 +429,159 @@ qrsolve(const SparseComplexMatrix&a, con
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
-	return SparseComplexMatrix();
+        return SparseComplexMatrix();
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = 0; j < b_nr; j++)
-	    Xx[j] = b.xelem(j,i);
-	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
-	    buf[j] = OCTAVE_C99_ZERO;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type j = 0; j < b_nr; j++)
+            Xx[j] = b.xelem(j,i);
+          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+            buf[j] = OCTAVE_C99_ZERO;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+          CXSPARSE_ZNAME (_ipvec) 
+            (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
+          CXSPARSE_ZNAME (_ipvec) 
+            (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (q.S()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+          CXSPARSE_ZNAME (_ipvec) 
+            (q.S()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (nc, q.S()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
+          CXSPARSE_ZNAME (_ipvec) 
+            (nc, q.S()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      Complex tmp = Xx[j];
-	      if (tmp != 0.0)
-		{
-		  if (ii == x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
-		      sz = (sz > 10 ? sz : 10) + x_nz;
-		      x.change_capacity (sz);
-		      x_nz = sz;
-		    }
-		  x.xdata(ii) = tmp;
-		  x.xridx(ii++) = j;
-		}
-	    }
-	  x.xcidx(i+1) = ii;
-	}
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              Complex tmp = Xx[j];
+              if (tmp != 0.0)
+                {
+                  if (ii == x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
+                      sz = (sz > 10 ? sz : 10) + x_nz;
+                      x.change_capacity (sz);
+                      x_nz = sz;
+                    }
+                  x.xdata(ii) = tmp;
+                  x.xridx(ii++) = j;
+                }
+            }
+          x.xcidx(i+1) = ii;
+        }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
-	return SparseComplexMatrix();
+        return SparseComplexMatrix();
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, nbuf);
 
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-	B[i] = q.N()->B [i];
+        B[i] = q.N()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = 0; j < b_nr; j++)
-	    Xx[j] = b.xelem(j,i);
-	  for (octave_idx_type j = nr; j < nbuf; j++)
-	    buf[j] = OCTAVE_C99_ZERO;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type j = 0; j < b_nr; j++)
+            Xx[j] = b.xelem(j,i);
+          for (octave_idx_type j = nr; j < nbuf; j++)
+            buf[j] = OCTAVE_C99_ZERO;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_pvec)
-	    (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+          CXSPARSE_ZNAME (_pvec)
+            (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
-	  CXSPARSE_ZNAME (_pvec)
-	    (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
+          CXSPARSE_ZNAME (_pvec)
+            (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
-	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = nr-1; j >= 0; j--)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
-	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
 #else
-	      CXSPARSE_ZNAME (_happly) 
-		(q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
+              CXSPARSE_ZNAME (_happly) 
+                (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_pvec) 
-	    (q.S()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+          CXSPARSE_ZNAME (_pvec) 
+            (q.S()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
-	  CXSPARSE_ZNAME (_pvec) 
-	    (nc, q.S()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
+          CXSPARSE_ZNAME (_pvec) 
+            (nc, q.S()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      Complex tmp = Xx[j];
-	      if (tmp != 0.0)
-		{
-		  if (ii == x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
-		      sz = (sz > 10 ? sz : 10) + x_nz;
-		      x.change_capacity (sz);
-		      x_nz = sz;
-		    }
-		  x.xdata(ii) = tmp;
-		  x.xridx(ii++) = j;
-		}
-	    }
-	  x.xcidx(i+1) = ii;
-	}
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              Complex tmp = Xx[j];
+              if (tmp != 0.0)
+                {
+                  if (ii == x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
+                      sz = (sz > 10 ? sz : 10) + x_nz;
+                      x.change_capacity (sz);
+                      x_nz = sz;
+                    }
+                  x.xdata(ii) = tmp;
+                  x.xridx(ii++) = j;
+                }
+            }
+          x.xcidx(i+1) = ii;
+        }
       info = 0;
     }
 
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
 #endif
@@ -604,106 +604,106 @@ qrsolve(const SparseComplexMatrix&a, con
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
-	return ComplexMatrix();
+        return ComplexMatrix();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-	(x.fortran_vec());
+        (x.fortran_vec());
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
-	   i++, idx+=nc, bidx+=b_nr)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
-	    buf[j] = OCTAVE_C99_ZERO;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+           i++, idx+=nc, bidx+=b_nr)
+        {
+          octave_quit ();
+          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+            buf[j] = OCTAVE_C99_ZERO;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_ipvec) (q.S()->pinv, bvec + bidx, buf, nr);
+          CXSPARSE_ZNAME (_ipvec) (q.S()->pinv, bvec + bidx, buf, nr);
 #else
-	  CXSPARSE_ZNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
+          CXSPARSE_ZNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
+          CXSPARSE_ZNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
 #else
-	  CXSPARSE_ZNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
+          CXSPARSE_ZNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	}
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
-	return ComplexMatrix();
+        return ComplexMatrix();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-	(x.fortran_vec());
+        (x.fortran_vec());
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_C99_COMPLEX (buf, nbuf);
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-	B[i] = q.N()->B [i];
+        B[i] = q.N()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
-	   i++, idx+=nc, bidx+=b_nr)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = nr; j < nbuf; j++)
-	    buf[j] = OCTAVE_C99_ZERO;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+           i++, idx+=nc, bidx+=b_nr)
+        {
+          octave_quit ();
+          for (octave_idx_type j = nr; j < nbuf; j++)
+            buf[j] = OCTAVE_C99_ZERO;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_pvec) (q.S()->q, bvec + bidx, buf, nr);
+          CXSPARSE_ZNAME (_pvec) (q.S()->q, bvec + bidx, buf, nr);
 #else
-	  CXSPARSE_ZNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
+          CXSPARSE_ZNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
 #endif
-	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = nr-1; j >= 0; j--)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
-	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
 #else
-	      CXSPARSE_ZNAME (_happly) 
-		(q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
+              CXSPARSE_ZNAME (_happly) 
+                (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
+          CXSPARSE_ZNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
 #else
-	  CXSPARSE_ZNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
+          CXSPARSE_ZNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	}
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        }
       info = 0;
     }
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
 }
@@ -724,173 +724,173 @@ qrsolve(const SparseComplexMatrix&a, con
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
-	return SparseComplexMatrix();
+        return SparseComplexMatrix();
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = 0; j < b_nr; j++)
-	    Xx[j] = b.xelem(j,i);
-	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
-	    buf[j] = OCTAVE_C99_ZERO;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type j = 0; j < b_nr; j++)
+            Xx[j] = b.xelem(j,i);
+          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+            buf[j] = OCTAVE_C99_ZERO;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+          CXSPARSE_ZNAME (_ipvec) 
+            (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
+          CXSPARSE_ZNAME (_ipvec) 
+            (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (q.S()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+          CXSPARSE_ZNAME (_ipvec) 
+            (q.S()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
-	  CXSPARSE_ZNAME (_ipvec) 
-	    (nc, q.S()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
+          CXSPARSE_ZNAME (_ipvec) 
+            (nc, q.S()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      Complex tmp = Xx[j];
-	      if (tmp != 0.0)
-		{
-		  if (ii == x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
-		      sz = (sz > 10 ? sz : 10) + x_nz;
-		      x.change_capacity (sz);
-		      x_nz = sz;
-		    }
-		  x.xdata(ii) = tmp;
-		  x.xridx(ii++) = j;
-		}
-	    }
-	  x.xcidx(i+1) = ii;
-	}
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              Complex tmp = Xx[j];
+              if (tmp != 0.0)
+                {
+                  if (ii == x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
+                      sz = (sz > 10 ? sz : 10) + x_nz;
+                      x.change_capacity (sz);
+                      x_nz = sz;
+                    }
+                  x.xdata(ii) = tmp;
+                  x.xridx(ii++) = j;
+                }
+            }
+          x.xcidx(i+1) = ii;
+        }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
-	return SparseComplexMatrix();
+        return SparseComplexMatrix();
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, nbuf);
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-	B[i] = q.N()->B [i];
+        B[i] = q.N()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = 0; j < b_nr; j++)
-	    Xx[j] = b.xelem(j,i);
-	  for (octave_idx_type j = nr; j < nbuf; j++)
-	    buf[j] = OCTAVE_C99_ZERO;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type j = 0; j < b_nr; j++)
+            Xx[j] = b.xelem(j,i);
+          for (octave_idx_type j = nr; j < nbuf; j++)
+            buf[j] = OCTAVE_C99_ZERO;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_pvec)
-	    (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+          CXSPARSE_ZNAME (_pvec)
+            (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
-	  CXSPARSE_ZNAME (_pvec)
-	    (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
+          CXSPARSE_ZNAME (_pvec)
+            (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
-	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = nr-1; j >= 0; j--)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
-	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
 #else
-	      CXSPARSE_ZNAME (_happly) 
-		(q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
+              CXSPARSE_ZNAME (_happly) 
+                (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_ZNAME (_pvec) 
-	    (q.S()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+          CXSPARSE_ZNAME (_pvec) 
+            (q.S()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
-	  CXSPARSE_ZNAME (_pvec) 
-	    (nc, q.S()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
+          CXSPARSE_ZNAME (_pvec) 
+            (nc, q.S()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      Complex tmp = Xx[j];
-	      if (tmp != 0.0)
-		{
-		  if (ii == x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
-		      sz = (sz > 10 ? sz : 10) + x_nz;
-		      x.change_capacity (sz);
-		      x_nz = sz;
-		    }
-		  x.xdata(ii) = tmp;
-		  x.xridx(ii++) = j;
-		}
-	    }
-	  x.xcidx(i+1) = ii;
-	}
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              Complex tmp = Xx[j];
+              if (tmp != 0.0)
+                {
+                  if (ii == x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
+                      sz = (sz > 10 ? sz : 10) + x_nz;
+                      x.change_capacity (sz);
+                      x_nz = sz;
+                    }
+                  x.xdata(ii) = tmp;
+                  x.xridx(ii++) = j;
+                }
+            }
+          x.xcidx(i+1) = ii;
+        }
       info = 0;
     }
 
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
 #endif
 }
 
 ComplexMatrix 
 qrsolve (const SparseComplexMatrix &a, const MArray2<double> &b, 
-	 octave_idx_type &info)
+         octave_idx_type &info)
 {
   return qrsolve (a, Matrix (b), info);
 }
 
 ComplexMatrix 
 qrsolve (const SparseComplexMatrix &a, const MArray2<Complex> &b, 
-	 octave_idx_type &info)
+         octave_idx_type &info)
 {
   return qrsolve (a, ComplexMatrix (b), info);
 }
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -180,39 +180,39 @@ SparseQR::SparseQR_rep::C (const Matrix 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     ret = Matrix (nc, b_nc, 0.0);
   else
     {
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
-	{
-	  octave_quit ();
-	  for (octave_idx_type i = nr; i < S->m2; i++)
-	    buf[i] = 0.;
-	  volatile octave_idx_type nm = (nr < nc ? nr : nc);
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type i = nr; i < S->m2; i++)
+            buf[i] = 0.;
+          volatile octave_idx_type nm = (nr < nc ? nr : nc);
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (S->pinv, bvec + idx, buf, b_nr);
+          CXSPARSE_DNAME (_ipvec) (S->pinv, bvec + idx, buf, b_nr);
 #else
-	  CXSPARSE_DNAME (_ipvec) (b_nr, S->Pinv, bvec + idx, buf);
+          CXSPARSE_DNAME (_ipvec) (b_nr, S->Pinv, bvec + idx, buf);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-	  for (volatile octave_idx_type i = 0; i < nm; i++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (N->L, i, N->B[i], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  for (octave_idx_type i = 0; i < b_nr; i++)
-	    vec[i+idx] = buf[i];
-	}
+          for (volatile octave_idx_type i = 0; i < nm; i++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (N->L, i, N->B[i], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          for (octave_idx_type i = 0; i < b_nr; i++)
+            vec[i+idx] = buf[i];
+        }
     }
   return ret;
 #else
   return Matrix ();
 #endif
 }
 
 Matrix
@@ -226,44 +226,44 @@ SparseQR::SparseQR_rep::Q (void) const
   if (nr < 0 || nc < 0)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0)
     ret = Matrix (nc, nr, 0.0);
   else
     {
       OCTAVE_LOCAL_BUFFER (double, bvec, nr + 1);
       for (octave_idx_type i = 0; i < nr; i++)
-	bvec[i] = 0.;
+        bvec[i] = 0.;
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
-	{
-	  octave_quit ();
-	  bvec[j] = 1.0;
-	  for (octave_idx_type i = nr; i < S->m2; i++)
-	    buf[i] = 0.;
-	  volatile octave_idx_type nm = (nr < nc ? nr : nc);
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          bvec[j] = 1.0;
+          for (octave_idx_type i = nr; i < S->m2; i++)
+            buf[i] = 0.;
+          volatile octave_idx_type nm = (nr < nc ? nr : nc);
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (S->pinv, bvec, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (S->pinv, bvec, buf, nr);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nr, S->Pinv, bvec, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, S->Pinv, bvec, buf);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-	  for (volatile octave_idx_type i = 0; i < nm; i++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (N->L, i, N->B[i], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    vec[i+idx] = buf[i];
-	  bvec[j] = 0.0;
-	}
+          for (volatile octave_idx_type i = 0; i < nm; i++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (N->L, i, N->B[i], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          for (octave_idx_type i = 0; i < nr; i++)
+            vec[i+idx] = buf[i];
+          bvec[j] = 0.0;
+        }
     }
   return ret.transpose ();
 #else
   return Matrix ();
 #endif
 }
 
 Matrix
@@ -282,90 +282,90 @@ qrsolve(const SparseMatrix&a, const Matr
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = Matrix (nc, b_nc, 0.0);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ()) 
-	return Matrix();
+        return Matrix();
       x.resize(nc, b_nc);
       double *vec = x.fortran_vec();
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
-	   i++, idx+=nc, bidx+=b_nr)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
-	    buf[j] = 0.;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+           i++, idx+=nc, bidx+=b_nr)
+        {
+          octave_quit ();
+          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+            buf[j] = 0.;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (q.S()->pinv, bvec + bidx, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, bvec + bidx, buf, nr);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	}
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian();
       SparseQR q (at, 3);
       if (! q.ok ())
-	return Matrix();
+        return Matrix();
       x.resize(nc, b_nc);
       double *vec = x.fortran_vec();
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
-	   i++, idx+=nc, bidx+=b_nr)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = nr; j < nbuf; j++)
-	    buf[j] = 0.;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+           i++, idx+=nc, bidx+=b_nr)
+        {
+          octave_quit ();
+          for (octave_idx_type j = nr; j < nbuf; j++)
+            buf[j] = 0.;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_pvec) (q.S()->q, bvec + bidx, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S()->q, bvec + bidx, buf, nr);
 #else
-	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
 #endif
-	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = nr-1; j >= 0; j--)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
+          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
 #else
-	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
+          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	}
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        }
       info = 0;
     }
 
   return x;
 #else
   return Matrix ();
 #endif
 }
@@ -386,136 +386,136 @@ qrsolve(const SparseMatrix&a, const Spar
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ()) 
-	return SparseMatrix();
+        return SparseMatrix();
       x = SparseMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = 0; j < b_nr; j++)
-	    Xx[j] = b.xelem(j,i);
-	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
-	    buf[j] = 0.;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type j = 0; j < b_nr; j++)
+            Xx[j] = b.xelem(j,i);
+          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+            buf[j] = 0.;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double tmp = Xx[j];
-	      if (tmp != 0.0)
-		{
-		  if (ii == x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
-		      sz = (sz > 10 ? sz : 10) + x_nz;
-		      x.change_capacity (sz);
-		      x_nz = sz;
-		    }
-		  x.xdata(ii) = tmp;
-		  x.xridx(ii++) = j;
-		}
-	    }
-	  x.xcidx(i+1) = ii;
-	}
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double tmp = Xx[j];
+              if (tmp != 0.0)
+                {
+                  if (ii == x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
+                      sz = (sz > 10 ? sz : 10) + x_nz;
+                      x.change_capacity (sz);
+                      x_nz = sz;
+                    }
+                  x.xdata(ii) = tmp;
+                  x.xridx(ii++) = j;
+                }
+            }
+          x.xcidx(i+1) = ii;
+        }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian();
       SparseQR q (at, 3);
       if (! q.ok ())
-	return SparseMatrix();
+        return SparseMatrix();
       x = SparseMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = 0; j < b_nr; j++)
-	    Xx[j] = b.xelem(j,i);
-	  for (octave_idx_type j = nr; j < nbuf; j++)
-	    buf[j] = 0.;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type j = 0; j < b_nr; j++)
+            Xx[j] = b.xelem(j,i);
+          for (octave_idx_type j = nr; j < nbuf; j++)
+            buf[j] = 0.;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
 #else
-	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
 #endif
-	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = nr-1; j >= 0; j--)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
+          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
 #else
-	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double tmp = Xx[j];
-	      if (tmp != 0.0)
-		{
-		  if (ii == x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
-		      sz = (sz > 10 ? sz : 10) + x_nz;
-		      x.change_capacity (sz);
-		      x_nz = sz;
-		    }
-		  x.xdata(ii) = tmp;
-		  x.xridx(ii++) = j;
-		}
-	    }
-	  x.xcidx(i+1) = ii;
-	}
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double tmp = Xx[j];
+              if (tmp != 0.0)
+                {
+                  if (ii == x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
+                      sz = (sz > 10 ? sz : 10) + x_nz;
+                      x.change_capacity (sz);
+                      x_nz = sz;
+                    }
+                  x.xdata(ii) = tmp;
+                  x.xridx(ii++) = j;
+                }
+            }
+          x.xcidx(i+1) = ii;
+        }
       info = 0;
     }
 
   x.maybe_compress ();
   return x;
 #else
   return SparseMatrix ();
 #endif
@@ -536,154 +536,154 @@ qrsolve(const SparseMatrix&a, const Comp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
-	return ComplexMatrix();
+        return ComplexMatrix();
       x.resize(nc, b_nc);
       Complex *vec = x.fortran_vec();
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = 0; j < b_nr; j++)
-	    {
-	      Complex c = b.xelem (j,i);
-	      Xx[j] = std::real (c);
-	      Xz[j] = std::imag (c);
-	    }
-	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
-	    buf[j] = 0.;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type j = 0; j < b_nr; j++)
+            {
+              Complex c = b.xelem (j,i);
+              Xx[j] = std::real (c);
+              Xz[j] = std::imag (c);
+            }
+          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+            buf[j] = 0.;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
 #endif
-	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
-	    buf[j] = 0.;
+          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+            buf[j] = 0.;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xz, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xz, buf, nr);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xz, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xz, nc);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xz);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xz);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    vec[j+idx] = Complex (Xx[j], Xz[j]);
-	}
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (octave_idx_type j = 0; j < nc; j++)
+            vec[j+idx] = Complex (Xx[j], Xz[j]);
+        }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian();
       SparseQR q (at, 3);
       if (! q.ok ())
-	return ComplexMatrix();
+        return ComplexMatrix();
       x.resize(nc, b_nc);
       Complex *vec = x.fortran_vec();
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = 0; j < b_nr; j++)
-	    {
-	      Complex c = b.xelem (j,i);
-	      Xx[j] = std::real (c);
-	      Xz[j] = std::imag (c);
-	    }
-	  for (octave_idx_type j = nr; j < nbuf; j++)
-	    buf[j] = 0.;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type j = 0; j < b_nr; j++)
+            {
+              Complex c = b.xelem (j,i);
+              Xx[j] = std::real (c);
+              Xz[j] = std::imag (c);
+            }
+          for (octave_idx_type j = nr; j < nbuf; j++)
+            buf[j] = 0.;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
 #else
-	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
 #endif
-	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = nr-1; j >= 0; j--)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
+          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
 #else
-	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (octave_idx_type j = nr; j < nbuf; j++)
-	    buf[j] = 0.;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (octave_idx_type j = nr; j < nbuf; j++)
+            buf[j] = 0.;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_pvec) (q.S()->q, Xz, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S()->q, Xz, buf, nr);
 #else
-	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
 #endif
-	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = nr-1; j >= 0; j--)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xz, nc);
+          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xz, nc);
 #else
-	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xz);
+          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xz);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    vec[j+idx] = Complex (Xx[j], Xz[j]);
-	}
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (octave_idx_type j = 0; j < nc; j++)
+            vec[j+idx] = Complex (Xx[j], Xz[j]);
+        }
       info = 0;
     }
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
 }
@@ -704,209 +704,209 @@ qrsolve(const SparseMatrix&a, const Spar
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ()) 
-	return SparseComplexMatrix();
+        return SparseComplexMatrix();
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = 0; j < b_nr; j++)
-	    {
-	      Complex c = b.xelem (j,i);
-	      Xx[j] = std::real (c);
-	      Xz[j] = std::imag (c);
-	    }
-	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
-	    buf[j] = 0.;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type j = 0; j < b_nr; j++)
+            {
+              Complex c = b.xelem (j,i);
+              Xx[j] = std::real (c);
+              Xz[j] = std::imag (c);
+            }
+          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+            buf[j] = 0.;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
-	    buf[j] = 0.;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+            buf[j] = 0.;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xz, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xz, buf, nr);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xz, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xz, nc);
 #else
-	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xz);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xz);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      Complex tmp = Complex (Xx[j], Xz[j]);
-	      if (tmp != 0.0)
-		{
-		  if (ii == x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
-		      sz = (sz > 10 ? sz : 10) + x_nz;
-		      x.change_capacity (sz);
-		      x_nz = sz;
-		    }
-		  x.xdata(ii) = tmp;
-		  x.xridx(ii++) = j;
-		}
-	    }
-	  x.xcidx(i+1) = ii;
-	}
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              Complex tmp = Complex (Xx[j], Xz[j]);
+              if (tmp != 0.0)
+                {
+                  if (ii == x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
+                      sz = (sz > 10 ? sz : 10) + x_nz;
+                      x.change_capacity (sz);
+                      x_nz = sz;
+                    }
+                  x.xdata(ii) = tmp;
+                  x.xridx(ii++) = j;
+                }
+            }
+          x.xcidx(i+1) = ii;
+        }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian();
       SparseQR q (at, 3);
       if (! q.ok ())
-	return SparseComplexMatrix();
+        return SparseComplexMatrix();
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
-	{
-	  octave_quit ();
-	  for (octave_idx_type j = 0; j < b_nr; j++)
-	    {
-	      Complex c = b.xelem (j,i);
-	      Xx[j] = std::real (c);
-	      Xz[j] = std::imag (c);
-	    }
-	  for (octave_idx_type j = nr; j < nbuf; j++)
-	    buf[j] = 0.;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+        {
+          octave_quit ();
+          for (octave_idx_type j = 0; j < b_nr; j++)
+            {
+              Complex c = b.xelem (j,i);
+              Xx[j] = std::real (c);
+              Xz[j] = std::imag (c);
+            }
+          for (octave_idx_type j = nr; j < nbuf; j++)
+            buf[j] = 0.;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
 #else
-	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
 #endif
-	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = nr-1; j >= 0; j--)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
+          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
 #else
-	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (octave_idx_type j = nr; j < nbuf; j++)
-	    buf[j] = 0.;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (octave_idx_type j = nr; j < nbuf; j++)
+            buf[j] = 0.;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_pvec) (q.S()->q, Xz, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S()->q, Xz, buf, nr);
 #else
-	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
 #endif
-	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
-	    {
-	      octave_quit ();
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          for (volatile octave_idx_type j = nr-1; j >= 0; j--)
+            {
+              octave_quit ();
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-	  CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xz, nc);
+          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xz, nc);
 #else
-	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xz);
+          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xz);
 #endif
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      Complex tmp = Complex (Xx[j], Xz[j]);
-	      if (tmp != 0.0)
-		{
-		  if (ii == x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
-		      sz = (sz > 10 ? sz : 10) + x_nz;
-		      x.change_capacity (sz);
-		      x_nz = sz;
-		    }
-		  x.xdata(ii) = tmp;
-		  x.xridx(ii++) = j;
-		}
-	    }
-	  x.xcidx(i+1) = ii;
-	}
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              Complex tmp = Complex (Xx[j], Xz[j]);
+              if (tmp != 0.0)
+                {
+                  if (ii == x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
+                      sz = (sz > 10 ? sz : 10) + x_nz;
+                      x.change_capacity (sz);
+                      x_nz = sz;
+                    }
+                  x.xdata(ii) = tmp;
+                  x.xridx(ii++) = j;
+                }
+            }
+          x.xcidx(i+1) = ii;
+        }
       info = 0;
     }
 
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
 #endif
 }
 
 Matrix 
 qrsolve(const SparseMatrix &a, const MArray2<double> &b, 
-	octave_idx_type &info)
+        octave_idx_type &info)
 { 
   return qrsolve (a, Matrix (b), info); 
 }
 
 ComplexMatrix 
 qrsolve(const SparseMatrix &a, const MArray2<Complex> &b, 
-	octave_idx_type &info)
+        octave_idx_type &info)
 { 
   return qrsolve (a, ComplexMatrix (b), info);
 }
diff --git a/liboctave/SparsedbleCHOL.cc b/liboctave/SparsedbleCHOL.cc
--- a/liboctave/SparsedbleCHOL.cc
+++ b/liboctave/SparsedbleCHOL.cc
@@ -45,26 +45,26 @@ chol2inv (const SparseMatrix& r)
     {
       MatrixType mattype (r);
       int typ = mattype.type (false);
       double rcond;
       octave_idx_type info;
       SparseMatrix rinv;
 
       if (typ == MatrixType::Upper)
-	{
-	  rinv = r.inverse(mattype, info, rcond, true, false);
-	  retval = rinv.transpose() * rinv;
-	}
+        {
+          rinv = r.inverse(mattype, info, rcond, true, false);
+          retval = rinv.transpose() * rinv;
+        }
       else if (typ == MatrixType::Lower)
-	{
-	  rinv = r.transpose().inverse(mattype, info, rcond, true, false);
-	  retval = rinv.transpose() * rinv;
-	}
+        {
+          rinv = r.transpose().inverse(mattype, info, rcond, true, false);
+          retval = rinv.transpose() * rinv;
+        }
       else
-	(*current_liboctave_error_handler) 
-	  ("spchol2inv requires triangular matrix");
+        (*current_liboctave_error_handler) 
+          ("spchol2inv requires triangular matrix");
     }
   else
     (*current_liboctave_error_handler) ("spchol2inv requires square matrix");
 
   return retval;
 }
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -56,30 +56,30 @@ SparseLU::SparseLU (const SparseMatrix& 
   double tmp = octave_sparse_params::get_key ("spumoni");
   if (!xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
 
   if (piv_thres.nelem() == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
       if (!xisnan (tmp))
-	Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+        Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
       if (!xisnan (tmp))
-	Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+        Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
   else
     {
       tmp = octave_sparse_params::get_key ("piv_tol");
       if (!xisnan (tmp))
-	Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+        Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
       tmp = octave_sparse_params::get_key ("sym_tol");
       if (!xisnan (tmp))
-	  Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+          Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = octave_sparse_params::get_key ("autoamd");
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   if (scale)
@@ -94,151 +94,151 @@ SparseLU::SparseLU (const SparseMatrix& 
   const double *Ax = a.data ();
 
   UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 0,
-				     &Symbolic, control, info);
+                                     &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
-	    ("SparseLU::SparseLU symbolic factorization failed");
+            ("SparseLU::SparseLU symbolic factorization failed");
 
       UMFPACK_DNAME (report_status) (control, status);
       UMFPACK_DNAME (report_info) (control, info);
 
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
       UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
       void *Numeric;
       status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic, 
-				   &Numeric, control, info) ;
+                                   &Numeric, control, info) ;
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
       cond = Info (UMFPACK_RCOND);
 
       if (status < 0)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("SparseLU::SparseLU numeric factorization failed");
+        {
+          (*current_liboctave_error_handler) 
+            ("SparseLU::SparseLU numeric factorization failed");
 
-	  UMFPACK_DNAME (report_status) (control, status);
-	  UMFPACK_DNAME (report_info) (control, info);
+          UMFPACK_DNAME (report_status) (control, status);
+          UMFPACK_DNAME (report_info) (control, info);
 
-	  UMFPACK_DNAME (free_numeric) (&Numeric);
-	}
+          UMFPACK_DNAME (free_numeric) (&Numeric);
+        }
       else
-	{
-	  UMFPACK_DNAME (report_numeric) (Numeric, control);
+        {
+          UMFPACK_DNAME (report_numeric) (Numeric, control);
 
-	  octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
-	  status = UMFPACK_DNAME (get_lunz) (&lnz, &unz, &ignore1,
-					&ignore2, &ignore3, Numeric) ;
-	  
-	  if (status < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("SparseLU::SparseLU extracting LU factors failed");
+          octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
+          status = UMFPACK_DNAME (get_lunz) (&lnz, &unz, &ignore1,
+                                        &ignore2, &ignore3, Numeric) ;
+          
+          if (status < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("SparseLU::SparseLU extracting LU factors failed");
 
-	      UMFPACK_DNAME (report_status) (control, status);
-	      UMFPACK_DNAME (report_info) (control, info);
+              UMFPACK_DNAME (report_status) (control, status);
+              UMFPACK_DNAME (report_info) (control, info);
 
-	      UMFPACK_DNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    {
-	      octave_idx_type n_inner = (nr < nc ? nr : nc);
+              UMFPACK_DNAME (free_numeric) (&Numeric);
+            }
+          else
+            {
+              octave_idx_type n_inner = (nr < nc ? nr : nc);
 
-	      if (lnz < 1)
-		Lfact = SparseMatrix (n_inner, nr,
-				      static_cast<octave_idx_type> (1));
-	      else
-		Lfact = SparseMatrix (n_inner, nr, lnz);
+              if (lnz < 1)
+                Lfact = SparseMatrix (n_inner, nr,
+                                      static_cast<octave_idx_type> (1));
+              else
+                Lfact = SparseMatrix (n_inner, nr, lnz);
 
-	      octave_idx_type *Ltp = Lfact.cidx ();
-	      octave_idx_type *Ltj = Lfact.ridx ();
-	      double *Ltx = Lfact.data ();
+              octave_idx_type *Ltp = Lfact.cidx ();
+              octave_idx_type *Ltj = Lfact.ridx ();
+              double *Ltx = Lfact.data ();
 
-	      if (unz < 1)
-		Ufact = SparseMatrix (n_inner, nc,
-				      static_cast<octave_idx_type> (1));
-	      else
-		Ufact = SparseMatrix (n_inner, nc, unz);
+              if (unz < 1)
+                Ufact = SparseMatrix (n_inner, nc,
+                                      static_cast<octave_idx_type> (1));
+              else
+                Ufact = SparseMatrix (n_inner, nc, unz);
 
-	      octave_idx_type *Up = Ufact.cidx ();
-	      octave_idx_type *Uj = Ufact.ridx ();
-	      double *Ux = Ufact.data ();
+              octave_idx_type *Up = Ufact.cidx ();
+              octave_idx_type *Uj = Ufact.ridx ();
+              double *Ux = Ufact.data ();
 
-	      Rfact = SparseMatrix (nr, nr, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  Rfact.xridx (i) = i;
-		  Rfact.xcidx (i) = i;
-		}
-	      Rfact.xcidx (nr) = nr;
-	      double *Rx = Rfact.data ();
+              Rfact = SparseMatrix (nr, nr, nr);
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  Rfact.xridx (i) = i;
+                  Rfact.xcidx (i) = i;
+                }
+              Rfact.xcidx (nr) = nr;
+              double *Rx = Rfact.data ();
 
-	      P.resize (nr);
-	      octave_idx_type *p = P.fortran_vec ();
+              P.resize (nr);
+              octave_idx_type *p = P.fortran_vec ();
 
-	      Q.resize (nc);
-	      octave_idx_type *q = Q.fortran_vec ();
+              Q.resize (nc);
+              octave_idx_type *q = Q.fortran_vec ();
 
-	      octave_idx_type do_recip;
-	      status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj, Ltx,
-					       Up, Uj, Ux, p, q, 0,
-					       &do_recip, Rx, 
-					       Numeric) ;
+              octave_idx_type do_recip;
+              status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj, Ltx,
+                                               Up, Uj, Ux, p, q, 0,
+                                               &do_recip, Rx, 
+                                               Numeric) ;
 
-	      UMFPACK_DNAME (free_numeric) (&Numeric) ;
+              UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
-	      if (status < 0)
-		{
-		  (*current_liboctave_error_handler) 
-		    ("SparseLU::SparseLU extracting LU factors failed");
+              if (status < 0)
+                {
+                  (*current_liboctave_error_handler) 
+                    ("SparseLU::SparseLU extracting LU factors failed");
 
-		  UMFPACK_DNAME (report_status) (control, status);
-		}
-	      else
-		{
-		  Lfact = Lfact.transpose ();
+                  UMFPACK_DNAME (report_status) (control, status);
+                }
+              else
+                {
+                  Lfact = Lfact.transpose ();
 
-		  if (do_recip)
-		    for (octave_idx_type i = 0; i < nr; i++)
-		      Rx[i] = 1.0 / Rx[i];
+                  if (do_recip)
+                    for (octave_idx_type i = 0; i < nr; i++)
+                      Rx[i] = 1.0 / Rx[i];
 
-		  UMFPACK_DNAME (report_matrix) (nr, n_inner, 
-					    Lfact.cidx (), Lfact.ridx (),
-					    Lfact.data (), 1, control);
-		  UMFPACK_DNAME (report_matrix) (n_inner, nc, 
-					    Ufact.cidx (), Ufact.ridx (),
-					    Ufact.data (), 1, control);
-		  UMFPACK_DNAME (report_perm) (nr, p, control);
-		  UMFPACK_DNAME (report_perm) (nc, q, control);
-		}
+                  UMFPACK_DNAME (report_matrix) (nr, n_inner, 
+                                            Lfact.cidx (), Lfact.ridx (),
+                                            Lfact.data (), 1, control);
+                  UMFPACK_DNAME (report_matrix) (n_inner, nc, 
+                                            Ufact.cidx (), Ufact.ridx (),
+                                            Ufact.data (), 1, control);
+                  UMFPACK_DNAME (report_perm) (nr, p, control);
+                  UMFPACK_DNAME (report_perm) (nc, q, control);
+                }
 
-	      UMFPACK_DNAME (report_info) (control, info);
-	    }
-	}
+              UMFPACK_DNAME (report_info) (control, info);
+            }
+        }
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 }
 
 SparseLU::SparseLU (const SparseMatrix& a, const ColumnVector& Qinit,
-		    const Matrix& piv_thres, bool scale, bool FixedQ,
-		    double droptol, bool milu, bool udiag)
+                    const Matrix& piv_thres, bool scale, bool FixedQ,
+                    double droptol, bool milu, bool udiag)
 {
 #ifdef HAVE_UMFPACK
   if (milu)
     (*current_liboctave_error_handler) 
       ("Modified incomplete LU not implemented");   
   else
     {
       octave_idx_type nr = a.rows ();
@@ -246,212 +246,212 @@ SparseLU::SparseLU (const SparseMatrix& 
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_DNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
       if (!xisnan (tmp))
-	Control (UMFPACK_PRL) = tmp;
+        Control (UMFPACK_PRL) = tmp;
 
       if (piv_thres.nelem() == 2)
-	{
-	  tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
-	  if (!xisnan (tmp))
-	    Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
-	  tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
-	  if (!xisnan (tmp))
-	    Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
-	}
+        {
+          tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
+          if (!xisnan (tmp))
+            Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+          tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
+          if (!xisnan (tmp))
+            Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+        }
       else
-	{
-	  tmp = octave_sparse_params::get_key ("piv_tol");
-	  if (!xisnan (tmp))
-	    Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+        {
+          tmp = octave_sparse_params::get_key ("piv_tol");
+          if (!xisnan (tmp))
+            Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
-	  tmp = octave_sparse_params::get_key ("sym_tol");
-	  if (!xisnan (tmp))
-	    Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
-	}
+          tmp = octave_sparse_params::get_key ("sym_tol");
+          if (!xisnan (tmp))
+            Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+        }
 
       if (droptol >= 0.)
-	Control (UMFPACK_DROPTOL) = droptol;
+        Control (UMFPACK_DROPTOL) = droptol;
 
 
       // Set whether we are allowed to modify Q or not
       if (FixedQ)
-	Control (UMFPACK_FIXQ) = 1.0;
+        Control (UMFPACK_FIXQ) = 1.0;
       else
-	{
-	  tmp = octave_sparse_params::get_key ("autoamd");
-	  if (!xisnan (tmp))
-	    Control (UMFPACK_FIXQ) = tmp;
-	}
+        {
+          tmp = octave_sparse_params::get_key ("autoamd");
+          if (!xisnan (tmp))
+            Control (UMFPACK_FIXQ) = tmp;
+        }
 
       if (scale)
-	Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
+        Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
       else
-	Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
+        Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_DNAME (report_control) (control);
 
       const octave_idx_type *Ap = a.cidx ();
       const octave_idx_type *Ai = a.ridx ();
       const double *Ax = a.data ();
 
       UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, 
-						     control);
+                                                     control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not needed
       do {
-	OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
+        OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
-	for (octave_idx_type i = 0; i < nc; i++)
-	  qinit [i] = static_cast<octave_idx_type> (Qinit (i));
+        for (octave_idx_type i = 0; i < nc; i++)
+          qinit [i] = static_cast<octave_idx_type> (Qinit (i));
 
-	status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 
-				       qinit, &Symbolic, control, info);
+        status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 
+                                       qinit, &Symbolic, control, info);
       } while (0);
 
       if (status < 0)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("SparseLU::SparseLU symbolic factorization failed");
+        {
+          (*current_liboctave_error_handler) 
+            ("SparseLU::SparseLU symbolic factorization failed");
 
-	  UMFPACK_DNAME (report_status) (control, status);
-	  UMFPACK_DNAME (report_info) (control, info);
+          UMFPACK_DNAME (report_status) (control, status);
+          UMFPACK_DNAME (report_info) (control, info);
 
-	  UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
-	}
+          UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
+        }
       else
-	{
-	  UMFPACK_DNAME (report_symbolic) (Symbolic, control);
+        {
+          UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
-	  void *Numeric;
-	  status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
-				       &Numeric, control, info) ;
-	  UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
+          void *Numeric;
+          status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
+                                       &Numeric, control, info) ;
+          UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
-	  cond = Info (UMFPACK_RCOND);
+          cond = Info (UMFPACK_RCOND);
 
-	  if (status < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("SparseLU::SparseLU numeric factorization failed");
+          if (status < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("SparseLU::SparseLU numeric factorization failed");
 
-	      UMFPACK_DNAME (report_status) (control, status);
-	      UMFPACK_DNAME (report_info) (control, info);
+              UMFPACK_DNAME (report_status) (control, status);
+              UMFPACK_DNAME (report_info) (control, info);
 
-	      UMFPACK_DNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    {
-	      UMFPACK_DNAME (report_numeric) (Numeric, control);
+              UMFPACK_DNAME (free_numeric) (&Numeric);
+            }
+          else
+            {
+              UMFPACK_DNAME (report_numeric) (Numeric, control);
 
-	      octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
-	      status = UMFPACK_DNAME (get_lunz) (&lnz, &unz, &ignore1, &ignore2,
-						 &ignore3, Numeric) ;
-	  
-	      if (status < 0)
-		{
-		  (*current_liboctave_error_handler) 
-		    ("SparseLU::SparseLU extracting LU factors failed");
+              octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
+              status = UMFPACK_DNAME (get_lunz) (&lnz, &unz, &ignore1, &ignore2,
+                                                 &ignore3, Numeric) ;
+          
+              if (status < 0)
+                {
+                  (*current_liboctave_error_handler) 
+                    ("SparseLU::SparseLU extracting LU factors failed");
 
-		  UMFPACK_DNAME (report_status) (control, status);
-		  UMFPACK_DNAME (report_info) (control, info);
+                  UMFPACK_DNAME (report_status) (control, status);
+                  UMFPACK_DNAME (report_info) (control, info);
 
-		  UMFPACK_DNAME (free_numeric) (&Numeric);
-		}
-	      else
-		{
-		  octave_idx_type n_inner = (nr < nc ? nr : nc);
+                  UMFPACK_DNAME (free_numeric) (&Numeric);
+                }
+              else
+                {
+                  octave_idx_type n_inner = (nr < nc ? nr : nc);
 
-		  if (lnz < 1)
-		    Lfact = SparseMatrix (n_inner, nr,
-					  static_cast<octave_idx_type> (1));
-		  else
-		    Lfact = SparseMatrix (n_inner, nr, lnz);
+                  if (lnz < 1)
+                    Lfact = SparseMatrix (n_inner, nr,
+                                          static_cast<octave_idx_type> (1));
+                  else
+                    Lfact = SparseMatrix (n_inner, nr, lnz);
 
-		  octave_idx_type *Ltp = Lfact.cidx ();
-		  octave_idx_type *Ltj = Lfact.ridx ();
-		  double *Ltx = Lfact.data ();
+                  octave_idx_type *Ltp = Lfact.cidx ();
+                  octave_idx_type *Ltj = Lfact.ridx ();
+                  double *Ltx = Lfact.data ();
 
-		  if (unz < 1)
-		    Ufact = SparseMatrix (n_inner, nc,
-					  static_cast<octave_idx_type> (1));
-		  else
-		    Ufact = SparseMatrix (n_inner, nc, unz);
+                  if (unz < 1)
+                    Ufact = SparseMatrix (n_inner, nc,
+                                          static_cast<octave_idx_type> (1));
+                  else
+                    Ufact = SparseMatrix (n_inner, nc, unz);
 
-		  octave_idx_type *Up = Ufact.cidx ();
-		  octave_idx_type *Uj = Ufact.ridx ();
-		  double *Ux = Ufact.data ();
+                  octave_idx_type *Up = Ufact.cidx ();
+                  octave_idx_type *Uj = Ufact.ridx ();
+                  double *Ux = Ufact.data ();
 
-		  Rfact = SparseMatrix (nr, nr, nr);
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    {
-		      Rfact.xridx (i) = i;
-		      Rfact.xcidx (i) = i;
-		    }
-		  Rfact.xcidx (nr) = nr;
-		  double *Rx = Rfact.data ();
+                  Rfact = SparseMatrix (nr, nr, nr);
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    {
+                      Rfact.xridx (i) = i;
+                      Rfact.xcidx (i) = i;
+                    }
+                  Rfact.xcidx (nr) = nr;
+                  double *Rx = Rfact.data ();
 
-		  P.resize (nr);
-		  octave_idx_type *p = P.fortran_vec ();
+                  P.resize (nr);
+                  octave_idx_type *p = P.fortran_vec ();
 
-		  Q.resize (nc);
-		  octave_idx_type *q = Q.fortran_vec ();
+                  Q.resize (nc);
+                  octave_idx_type *q = Q.fortran_vec ();
 
-		  octave_idx_type do_recip;
-		  status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj,
-						   Ltx, Up, Uj, Ux, p, q, 
-						   0, &do_recip, 
-						   Rx, Numeric) ;
+                  octave_idx_type do_recip;
+                  status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj,
+                                                   Ltx, Up, Uj, Ux, p, q, 
+                                                   0, &do_recip, 
+                                                   Rx, Numeric) ;
 
-		  UMFPACK_DNAME (free_numeric) (&Numeric) ;
+                  UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
-		  if (status < 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseLU::SparseLU extracting LU factors failed");
+                  if (status < 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseLU::SparseLU extracting LU factors failed");
 
-		      UMFPACK_DNAME (report_status) (control, status);
-		    }
-		  else
-		    {
-		      Lfact = Lfact.transpose ();
+                      UMFPACK_DNAME (report_status) (control, status);
+                    }
+                  else
+                    {
+                      Lfact = Lfact.transpose ();
 
-		      if (do_recip)
-			for (octave_idx_type i = 0; i < nr; i++)
-			  Rx[i] = 1.0 / Rx[i];
+                      if (do_recip)
+                        for (octave_idx_type i = 0; i < nr; i++)
+                          Rx[i] = 1.0 / Rx[i];
 
-		      UMFPACK_DNAME (report_matrix) (nr, n_inner, 
-						Lfact.cidx (), 
-						Lfact.ridx (), 
-						Lfact.data (),
-						1, control);
-		      UMFPACK_DNAME (report_matrix) (n_inner, nc, 
-						Ufact.cidx (), 
-						Ufact.ridx (), 
-						Ufact.data (),
-						1, control);
-		      UMFPACK_DNAME (report_perm) (nr, p, control);
-		      UMFPACK_DNAME (report_perm) (nc, q, control);
-		    }
+                      UMFPACK_DNAME (report_matrix) (nr, n_inner, 
+                                                Lfact.cidx (), 
+                                                Lfact.ridx (), 
+                                                Lfact.data (),
+                                                1, control);
+                      UMFPACK_DNAME (report_matrix) (n_inner, nc, 
+                                                Ufact.cidx (), 
+                                                Ufact.ridx (), 
+                                                Ufact.data (),
+                                                1, control);
+                      UMFPACK_DNAME (report_perm) (nr, p, control);
+                      UMFPACK_DNAME (report_perm) (nc, q, control);
+                    }
 
-		  UMFPACK_DNAME (report_info) (control, info);
-		}
-	    }
-	}
+                  UMFPACK_DNAME (report_info) (control, info);
+                }
+            }
+        }
 
       if (udiag)
-	(*current_liboctave_error_handler) 
-	  ("Option udiag of incomplete LU not implemented");   
+        (*current_liboctave_error_handler) 
+          ("Option udiag of incomplete LU not implemented");   
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 }
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -118,39 +118,39 @@ boolNDArray::matrix_value (void) const
   switch (nd)
     {
     case 1:
       retval = boolMatrix (Array2<bool> (*this, dimensions(0), 1));
       break;
 
     case 2:
       retval = boolMatrix (Array2<bool> (*this, dimensions(0),
-					 dimensions(1)));
+                                         dimensions(1)));
       break;
 
     default:
       (*current_liboctave_error_handler)
-	("invalid conversion of boolNDArray to boolMatrix");
+        ("invalid conversion of boolNDArray to boolMatrix");
       break;
     }
 
   return retval;
 }
 
 void
 boolNDArray::increment_index (Array<octave_idx_type>& ra_idx,
-			      const dim_vector& dimensions,
-			      int start_dimension)
+                              const dim_vector& dimensions,
+                              int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
 octave_idx_type
 boolNDArray::compute_index (Array<octave_idx_type>& ra_idx,
-			    const dim_vector& dimensions)
+                            const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 boolNDArray
 boolNDArray::diag (octave_idx_type k) const
 {
   return Array<bool>::diag (k);
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -47,17 +47,17 @@ SparseBoolMatrix::operator == (const Spa
   octave_idx_type nc_a = a.cols ();
   octave_idx_type nz_a = a.nzmax ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx(i) != a.cidx(i))
-	return false;
+        return false;
 
   for (octave_idx_type i = 0; i < nz; i++)
     if (data(i) != a.data(i) || ridx(i) != a.ridx(i))
       return false;
 
   return true;
 }
 
@@ -103,25 +103,25 @@ SparseBoolMatrix::operator ! (void) cons
   SparseBoolMatrix r (nr, nc, nz2);
    
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = 0; j < nr; j++)
-	{
-	  if (jj < cidx(i+1) && ridx(jj) == j)
-	    jj++;
-	  else
-	    {
-	      r.data(ii) = true;
-	      r.ridx(ii++) = j;
-	    }
-	}
+        {
+          if (jj < cidx(i+1) && ridx(jj) == j)
+            jj++;
+          else
+            {
+              r.data(ii) = true;
+              r.ridx(ii++) = j;
+            }
+        }
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
 // other operations
 
@@ -166,17 +166,17 @@ operator << (std::ostream& os, const Spa
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)  
      {
        octave_quit ();
        for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-	 os << a.ridx(i) + 1 << " "  << j + 1 << " " << a.data(i) << "\n";
+         os << a.ridx(i) + 1 << " "  << j + 1 << " " << a.data(i) << "\n";
      }
    
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseBoolMatrix& a)
 {
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -79,17 +79,17 @@ charMatrix::charMatrix (const string_vec
 {
   octave_idx_type nr = rows ();
 
   for (octave_idx_type i = 0; i < nr; i++)
     {
       const std::string si = s(i);
       octave_idx_type nc = si.length ();
       for (octave_idx_type j = 0; j < nc; j++)
-	elem (i, j) = si[j];
+        elem (i, j) = si[j];
     }
 }
 
 bool
 charMatrix::operator == (const charMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return 0;
@@ -106,23 +106,23 @@ charMatrix::operator != (const charMatri
 charMatrix&
 charMatrix::insert (const char *s, octave_idx_type r, octave_idx_type c)
 {
   if (s)
     {
       octave_idx_type s_len = strlen (s);
 
       if (r < 0 || r >= rows () || c < 0 || c + s_len - 1 > cols ())
-	{
-	  (*current_liboctave_error_handler) ("range error for insert");
-	  return *this;
-	}
+        {
+          (*current_liboctave_error_handler) ("range error for insert");
+          return *this;
+        }
 
       for (octave_idx_type i = 0; i < s_len; i++)
-	elem (r, c+i) = s[i];
+        elem (r, c+i) = s[i];
     }
   return *this;
 }
 
 charMatrix&
 charMatrix::insert (const charMatrix& a, octave_idx_type r, octave_idx_type c)
 {
   Array2<char>::insert (a, r, c);
@@ -149,30 +149,30 @@ charMatrix::row_as_string (octave_idx_ty
   retval.resize (nc, '\0');
 
   for (octave_idx_type i = 0; i < nc; i++)
     retval[i] = elem (r, i);
 
   if (! raw)
     {
       if (strip_ws)
-	{
-	  while (--nc >= 0)
-	    {
-	      char c = retval[nc];
-	      if (c && c != ' ')
-		break;
-	    }
-	}
+        {
+          while (--nc >= 0)
+            {
+              char c = retval[nc];
+              if (c && c != ' ')
+                break;
+            }
+        }
       else
-	{
-	  while (--nc >= 0)
-	    if (retval[nc])
-	      break;
-	}
+        {
+          while (--nc >= 0)
+            if (retval[nc])
+              break;
+        }
 
       retval.resize (nc+1);
     }
 
   return retval;
 }
 
 charMatrix
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -65,32 +65,32 @@ charNDArray::concat (const NDArray& rb, 
   if (rb.numel () == 0)
     return *this;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double d = rb.elem (i);
 
       if (xisnan (d))
-	{
-	  (*current_liboctave_error_handler)
-	    ("invalid conversion from NaN to character");
-	  return *this;
-	}
+        {
+          (*current_liboctave_error_handler)
+            ("invalid conversion from NaN to character");
+          return *this;
+        }
       else
-	{
-	  octave_idx_type ival = NINTbig (d);
+        {
+          octave_idx_type ival = NINTbig (d);
 
-	  if (ival < 0 || ival > UCHAR_MAX)
-	    // FIXME -- is there something
-	    // better we could do? Should we warn the user?
-	    ival = 0;
+          if (ival < 0 || ival > UCHAR_MAX)
+            // FIXME -- is there something
+            // better we could do? Should we warn the user?
+            ival = 0;
 
-	  tmp.elem (i) = static_cast<char>(ival);
-	}
+          tmp.elem (i) = static_cast<char>(ival);
+        }
     }
 
   insert (tmp, ra_idx);
   return *this;
 }
 
 charNDArray&
 charNDArray::insert (const charNDArray& a, octave_idx_type r, octave_idx_type c)
@@ -116,39 +116,39 @@ charNDArray::matrix_value (void) const
   switch (nd)
     {
     case 1:
       retval = charMatrix (Array2<char> (*this, dimensions(0), 1));
       break;
 
     case 2:
       retval = charMatrix (Array2<char> (*this, dimensions(0),
-					       dimensions(1)));
+                                               dimensions(1)));
       break;
 
     default:
       (*current_liboctave_error_handler)
-	("invalid conversion of charNDArray to charMatrix");
+        ("invalid conversion of charNDArray to charMatrix");
       break;
     }
 
   return retval;
 }
 
 void
 charNDArray::increment_index (Array<octave_idx_type>& ra_idx,
-			      const dim_vector& dimensions,
-			      int start_dimension)
+                              const dim_vector& dimensions,
+                              int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
 octave_idx_type 
 charNDArray::compute_index (Array<octave_idx_type>& ra_idx,
-			    const dim_vector& dimensions)
+                            const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 charNDArray
 charNDArray::diag (octave_idx_type k) const
 {
   return Array<char>::diag (k);
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -212,28 +212,28 @@ gnu_readline::gnu_readline ()
 
   octave_rl_initialize ();
 
   do_blink_matching_paren (true);
 
   // Bind operate-and-get-next.
 
   octave_rl_add_defun ("operate-and-get-next",
-		       gnu_readline::operate_and_get_next,
-		       octave_rl_ctrl ('O'));
+                       gnu_readline::operate_and_get_next,
+                       octave_rl_ctrl ('O'));
 
   // And the history search functions.
 
   octave_rl_add_defun ("history-search-backward",
-		       gnu_readline::history_search_backward,
-		       octave_rl_meta ('P'));
+                       gnu_readline::history_search_backward,
+                       octave_rl_meta ('P'));
 
   octave_rl_add_defun ("history-search-forward",
-		       gnu_readline::history_search_forward,
-		       octave_rl_meta ('N'));
+                       gnu_readline::history_search_forward,
+                       octave_rl_meta ('N'));
 }
 
 void
 gnu_readline::do_set_name (const std::string& nm)
 {
   ::octave_rl_set_name (nm.c_str ());
 }
 
@@ -424,20 +424,20 @@ gnu_readline::do_set_char_is_quoted_func
 
 void
 gnu_readline::do_set_user_accept_line_function (user_accept_line_fcn f)
 {
   user_accept_line_function = f;
 
   if (f)
     octave_rl_add_defun ("accept-line", gnu_readline::command_accept_line, 
-			 ::octave_rl_ctrl ('M'));
+                         ::octave_rl_ctrl ('M'));
   else
     octave_rl_add_defun ("accept-line", ::octave_rl_newline,
-			 ::octave_rl_ctrl ('M'));
+                         ::octave_rl_ctrl ('M'));
 }
 
 gnu_readline::completion_fcn
 gnu_readline::do_get_completion_function (void) const
 {
   return completion_function;
 }
 
@@ -475,33 +475,33 @@ gnu_readline::do_generate_filename_compl
 
   char *fn = 0;
 
   while (1)
     {
       fn = ::octave_rl_filename_completion_function (text.c_str (), count);
 
       if (fn)
-	{
-	  if (count == n)
-	    {
-	      // Famous last words:  Most large directories will not
-	      // have more than a few hundred files, so we should not
-	      // resize too many times even if the growth is linear...
+        {
+          if (count == n)
+            {
+              // Famous last words:  Most large directories will not
+              // have more than a few hundred files, so we should not
+              // resize too many times even if the growth is linear...
 
-	      n += 100;
-	      retval.resize (n);
-	    }
+              n += 100;
+              retval.resize (n);
+            }
 
-	  retval[count++] = fn;
+          retval[count++] = fn;
 
-	  free (fn);
-	}
+          free (fn);
+        }
       else
-	break;
+        break;
     }
 
   retval.resize (count);
 
   return retval;
 }
 
 std::string
@@ -826,17 +826,17 @@ command_editor::instance_ok (void)
   bool retval = true;
 
   if (! instance)
     make_command_editor ();
 
   if (! instance)
     {
       current_liboctave_error_handler
-	("unable to create command history object!");
+        ("unable to create command history object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 void
@@ -860,17 +860,17 @@ int
 command_editor::startup_handler (void)
 {
   for (startup_hook_set_iterator p = startup_hook_set.begin ();
        p != startup_hook_set.end (); p++)
     {
       startup_hook_fcn f = *p;
 
       if (f)
-	f ();
+        f ();
     }
 
   return 0;
 }
 
 int
 command_editor::event_handler (void)
 {
@@ -881,17 +881,17 @@ command_editor::event_handler (void)
   event_hook_lock.unlock ();
 
   for (event_hook_set_iterator p = hook_set.begin ();
        p != hook_set.end (); p++)
     {
       event_hook_fcn f = *p;
 
       if (f)
-	f ();
+        f ();
     }
 
   return 0;
 }
 
 void
 command_editor::set_name (const std::string& n)
 {
@@ -1179,20 +1179,20 @@ command_editor::add_startup_hook (startu
 void
 command_editor::remove_startup_hook (startup_hook_fcn f)
 {
   if (instance_ok ())
     {
       startup_hook_set_iterator p = startup_hook_set.find (f);
 
       if (p != startup_hook_set.end ())
-	startup_hook_set.erase (p);
+        startup_hook_set.erase (p);
 
       if (startup_hook_set.empty ())
-	instance->restore_startup_hook ();
+        instance->restore_startup_hook ();
     }
 }
 
 void
 command_editor::add_event_hook (event_hook_fcn f)
 {
   octave_autolock guard (event_hook_lock);
 
@@ -1209,20 +1209,20 @@ command_editor::remove_event_hook (event
 {
   octave_autolock guard (event_hook_lock);
 
   if (instance_ok ())
     {
       event_hook_set_iterator p = event_hook_set.find (f);
 
       if (p != event_hook_set.end ())
-	event_hook_set.erase (p);
+        event_hook_set.erase (p);
 
       if (event_hook_set.empty ())
-	instance->restore_event_hook ();
+        instance->restore_event_hook ();
     }
 }
 
 void
 command_editor::read_init_file (const std::string& file_arg)
 {
   if (instance_ok ())
     {
@@ -1251,38 +1251,38 @@ command_editor::filename_quoting_desired
 {
   return (instance_ok ())
     ? instance->do_filename_quoting_desired (arg) : false;
 }
 
 // Return a string which will be printed as a prompt.  The string may
 // contain special characters which are decoded as follows: 
 //   
-//	\a	bell (ascii 07)
-//	\d	the date
-//	\e	escape (ascii 033)
-//	\h	the hostname up to the first `.'
-//	\H	the hostname
-//	\n	CRLF
-//	\r	CR
-//	\s	the name of the shell (program)
-//	\t	the time
-//	\T	the time in 12-hour hh:mm:ss format
-//	\@	the time in 12-hour hh:mm am/pm format
-//	\A	the time in 24-hour hh:mm format
-//	\u	your username
-//	\w	the current working directory
-//	\W	the last element of PWD
-//	\!	the history number of this command
-//	\#	the command number of this command
-//	\$	a $ or a # if you are root
-//	\nnn    character code nnn in octal
-//	\\	a backslash
-//	\[	begin a sequence of non-printing chars
-//	\]	end a sequence of non-printing chars
+//      \a      bell (ascii 07)
+//      \d      the date
+//      \e      escape (ascii 033)
+//      \h      the hostname up to the first `.'
+//      \H      the hostname
+//      \n      CRLF
+//      \r      CR
+//      \s      the name of the shell (program)
+//      \t      the time
+//      \T      the time in 12-hour hh:mm:ss format
+//      \@      the time in 12-hour hh:mm am/pm format
+//      \A      the time in 24-hour hh:mm format
+//      \u      your username
+//      \w      the current working directory
+//      \W      the last element of PWD
+//      \!      the history number of this command
+//      \#      the command number of this command
+//      \$      a $ or a # if you are root
+//      \nnn    character code nnn in octal
+//      \\      a backslash
+//      \[      begin a sequence of non-printing chars
+//      \]      end a sequence of non-printing chars
 
 std::string
 command_editor::do_decode_prompt_string (const std::string& s)
 {
   std::string result;
   std::string temp;
   size_t i = 0;
   size_t slen = s.length ();
@@ -1290,228 +1290,228 @@ command_editor::do_decode_prompt_string 
 
   while (i < slen)
     {
       c = s[i];
 
       i++;
 
       if (c == '\\')
-	{
-	  c = s[i];
+        {
+          c = s[i];
 
-	  switch (c)
-	    {
-	    case '0':
-	    case '1':
-	    case '2':
-	    case '3':
-	    case '4':
-	    case '5':
-	    case '6':
-	    case '7':
-	      // Maybe convert an octal number.
-	      {
-		int n = read_octal (s.substr (i, 3));
+          switch (c)
+            {
+            case '0':
+            case '1':
+            case '2':
+            case '3':
+            case '4':
+            case '5':
+            case '6':
+            case '7':
+              // Maybe convert an octal number.
+              {
+                int n = read_octal (s.substr (i, 3));
 
-		temp = "\\";
+                temp = "\\";
 
-		if (n != -1)
-		  {
-		    i += 3;
-		    temp[0] = n;
-		  }
+                if (n != -1)
+                  {
+                    i += 3;
+                    temp[0] = n;
+                  }
 
-		c = 0;
-		goto add_string;
-	      }
+                c = 0;
+                goto add_string;
+              }
 
-	    case 'a':
-	      {
-		temp = '\a';
+            case 'a':
+              {
+                temp = '\a';
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    case 'e':
-	      {
-		temp = '\033';
+            case 'e':
+              {
+                temp = '\033';
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    case 'r':
-	      {
-		temp = '\r';
+            case 'r':
+              {
+                temp = '\r';
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    case 'd':
-	    case 't':
-	    case 'T':
-	    case '@':
-	    case 'A':
-	      // Make the current time/date into a string.
-	      {
-		octave_localtime now;
+            case 'd':
+            case 't':
+            case 'T':
+            case '@':
+            case 'A':
+              // Make the current time/date into a string.
+              {
+                octave_localtime now;
 
-		if (c == 'd')
-		  temp = now.strftime ("%a %b %d");
-		else if (c == 't')
-		  temp = now.strftime ("%H:%M:%S");
-		else if (c == 'T')
-		  temp = now.strftime ("%I:%M:%S");
-		else if (c == '@')
-		  temp = now.strftime ("%I:%M %p");
-		else if (c == 'A')
-		  temp = now.strftime ("%H:%M");
+                if (c == 'd')
+                  temp = now.strftime ("%a %b %d");
+                else if (c == 't')
+                  temp = now.strftime ("%H:%M:%S");
+                else if (c == 'T')
+                  temp = now.strftime ("%I:%M:%S");
+                else if (c == '@')
+                  temp = now.strftime ("%I:%M %p");
+                else if (c == 'A')
+                  temp = now.strftime ("%H:%M");
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    case 'n':
-	      {
-		temp = newline_chars ();
+            case 'n':
+              {
+                temp = newline_chars ();
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    case 's':
-	      {
-		temp = octave_env::get_program_name ();
-		temp = octave_env::base_pathname (temp);
+            case 's':
+              {
+                temp = octave_env::get_program_name ();
+                temp = octave_env::base_pathname (temp);
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    case 'w':
-	    case 'W':
-	      {
-		temp = octave_env::get_current_directory ();
+            case 'w':
+            case 'W':
+              {
+                temp = octave_env::get_current_directory ();
 
-		std::string home_dir = octave_env::get_home_directory ();
+                std::string home_dir = octave_env::get_home_directory ();
 
-		if (c == 'W' && (home_dir.empty () || temp != home_dir))
-		  {
-		    if (temp != "/" && temp != "//")
-		      {
-			size_t pos = temp.rfind ('/');
+                if (c == 'W' && (home_dir.empty () || temp != home_dir))
+                  {
+                    if (temp != "/" && temp != "//")
+                      {
+                        size_t pos = temp.rfind ('/');
 
-			if (pos != std::string::npos && pos != 0)
-			  temp = temp.substr (pos + 1);
-		      }
-		  }
-		else
-		  temp = octave_env::polite_directory_format (temp);
+                        if (pos != std::string::npos && pos != 0)
+                          temp = temp.substr (pos + 1);
+                      }
+                  }
+                else
+                  temp = octave_env::polite_directory_format (temp);
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    case 'u':
-	      {
-		temp = octave_env::get_user_name ();
+            case 'u':
+              {
+                temp = octave_env::get_user_name ();
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    case 'H':
-	      {
-		temp = octave_env::get_host_name ();
+            case 'H':
+              {
+                temp = octave_env::get_host_name ();
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    case 'h':
-	      {
-		temp = octave_env::get_host_name ();
+            case 'h':
+              {
+                temp = octave_env::get_host_name ();
 
-		size_t pos = temp.find ('.');
+                size_t pos = temp.find ('.');
 
-		if (pos != std::string::npos)
-		  temp.resize (pos);
-		
-		goto add_string;
-	      }
+                if (pos != std::string::npos)
+                  temp.resize (pos);
+                
+                goto add_string;
+              }
 
-	    case '#':
-	      {
-		char number_buffer[128];
-		sprintf (number_buffer, "%d", command_number);
-		temp = number_buffer;
+            case '#':
+              {
+                char number_buffer[128];
+                sprintf (number_buffer, "%d", command_number);
+                temp = number_buffer;
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    case '!':
-	      {
-		char number_buffer[128];
-		int num = command_history::current_number ();
-		if (num > 0)
+            case '!':
+              {
+                char number_buffer[128];
+                int num = command_history::current_number ();
+                if (num > 0)
                   sprintf (number_buffer, "%d", num);
-		else
-		  strcpy (number_buffer, "!");
-		temp = number_buffer;
+                else
+                  strcpy (number_buffer, "!");
+                temp = number_buffer;
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    case '$':
-	      {
+            case '$':
+              {
 #if defined (HAVE_GETEUID)
-		temp = (::geteuid () == 0 ? "#" : "$");
+                temp = (::geteuid () == 0 ? "#" : "$");
 #else
-		temp = "$";
+                temp = "$";
 #endif
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
 #if defined (USE_READLINE)
-	    case '[':
-	    case ']':
-	      {
-		temp.resize (1);
+            case '[':
+            case ']':
+              {
+                temp.resize (1);
 
-		temp[0] = ((c == '[')
-			   ? ::octave_rl_prompt_start_ignore ()
-			   : ::octave_rl_prompt_end_ignore ());
+                temp[0] = ((c == '[')
+                           ? ::octave_rl_prompt_start_ignore ()
+                           : ::octave_rl_prompt_end_ignore ());
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 #endif
 
-	    case '\\':
-	      {
-		temp = "\\";
+            case '\\':
+              {
+                temp = "\\";
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    default:
-	      {
-		temp = "\\ ";
-		temp[1] = c;
+            default:
+              {
+                temp = "\\ ";
+                temp[1] = c;
 
-		goto add_string;
-	      }
+                goto add_string;
+              }
 
-	    add_string:
-	      {
-		if (c)
-		  i++;
+            add_string:
+              {
+                if (c)
+                  i++;
 
-		result.append (temp);
+                result.append (temp);
 
-		break;
-	      }
-	    }
-	}
+                break;
+              }
+            }
+        }
       else
-	result += c;
+        result += c;
     }
 
   return result;
 }
 
 // Return the octal number parsed from STRING, or -1 to indicate that
 // the string contained a bad number.
 
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -109,18 +109,18 @@ private:
 };
 
 void
 gnu_history::do_add (const std::string& s)
 {
   if (! do_ignoring_entries ())
     {
       if (s.empty ()
-	  || (s.length () == 1 && (s[0] == '\r' || s[0] == '\n')))
-	return;
+          || (s.length () == 1 && (s[0] == '\r' || s[0] == '\n')))
+        return;
 
       ::octave_add_history (s.c_str ());
 
       lines_this_session++;
     }
 }
 
 void
@@ -186,21 +186,21 @@ gnu_history::do_set_mark (int n)
 int
 gnu_history::do_goto_mark (void)
 {
   if (mark)
     {
       char *line = ::octave_history_goto_mark (mark);
 
       if (line)
-	{
-	  command_editor::insert_text (line);
+        {
+          command_editor::insert_text (line);
 
-	  command_editor::clear_undo_list ();
-	}
+          command_editor::clear_undo_list ();
+        }
     }
 
   mark = 0;
 
   // FIXME -- for operate_and_get_next.
   command_editor::remove_startup_hook (command_history::goto_mark);
 
   return 0;
@@ -209,47 +209,47 @@ gnu_history::do_goto_mark (void)
 void
 gnu_history::do_read (const std::string& f, bool must_exist)
 {
   if (! f.empty ())
     {
       int status = ::octave_read_history (f.c_str ());
 
       if (status != 0 && must_exist)
-	error (status);
+        error (status);
       else
-	{
-	  lines_in_file = do_where ();
+        {
+          lines_in_file = do_where ();
 
-	  ::octave_using_history ();
-	}
+          ::octave_using_history ();
+        }
     }
   else
     error ("gnu_history::read: missing file name");
 }
 
 void
 gnu_history::do_read_range (const std::string& f, int from, int to,
-			    bool must_exist)
+                            bool must_exist)
 {
   if (from < 0)
     from = lines_in_file;
 
   if (! f.empty ())
     {
       int status = ::octave_read_history_range (f.c_str (), from, to);
 
       if (status != 0 && must_exist)
-	error (status);
+        error (status);
       else
-	{
-	  lines_in_file = do_where ();
+        {
+          lines_in_file = do_where ();
 
-	  ::octave_using_history ();
-	}
+          ::octave_using_history ();
+        }
     }
   else
     error ("gnu_history::read_range: missing file name");
 }
 
 void
 gnu_history::do_write (const std::string& f_arg)
 {
@@ -258,61 +258,61 @@ gnu_history::do_write (const std::string
   if (f.empty ())
     f = xfile;
 
   if (! f.empty ())
     {
       int status = ::octave_write_history (f.c_str ());
 
       if (status != 0)
-	error (status);
+        error (status);
     }
   else
     error ("gnu_history::write: missing file name");
 }
 
 void
 gnu_history::do_append (const std::string& f_arg)
 {
   if (lines_this_session)
     {
       if (lines_this_session < do_where ())
-	{
-	  // Create file if it doesn't already exist.
+        {
+          // Create file if it doesn't already exist.
 
-	  std::string f = f_arg;
+          std::string f = f_arg;
 
-	  if (f.empty ())
-	    f = xfile;
+          if (f.empty ())
+            f = xfile;
 
-	  if (! f.empty ())
-	    {
-	      file_stat fs (f);
+          if (! f.empty ())
+            {
+              file_stat fs (f);
 
-	      if (! fs)
-		{
-		  int tem;
+              if (! fs)
+                {
+                  int tem;
 
-		  tem = open (f.c_str (), O_CREAT, 0666);
-		  close (tem);
-		}
+                  tem = open (f.c_str (), O_CREAT, 0666);
+                  close (tem);
+                }
 
-	      int status
-		= ::octave_append_history (lines_this_session, f.c_str ());
+              int status
+                = ::octave_append_history (lines_this_session, f.c_str ());
 
-	      if (status != 0)
-		error (status);
-	      else
-		lines_in_file += lines_this_session;
+              if (status != 0)
+                error (status);
+              else
+                lines_in_file += lines_this_session;
 
-	      lines_this_session = 0;
-	    }
-	  else
-	    error ("gnu_history::append: missing file name");
-	}
+              lines_this_session = 0;
+            }
+          else
+            error ("gnu_history::append: missing file name");
+        }
     }
 }
 
 void
 gnu_history::do_truncate_file (const std::string& f_arg, int n)
 {
   std::string f = f_arg;
 
@@ -361,17 +361,17 @@ gnu_history::do_clean_up_and_save (const
   std::string f = f_arg;
 
   if (f.empty ())
     f = xfile;
 
   if (! f.empty ())
     {
       if (n < 0)
-	n = xsize;
+        n = xsize;
 
       stifle (n);
 
       do_write (f.c_str ());
     }
   else
     error ("gnu_history::clean_up_and_save: missing file name");
 }
@@ -384,17 +384,17 @@ command_history::instance_ok (void)
   bool retval = true;
 
   if (! instance)
     make_command_history ();
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
-	("unable to create command history object!");
+        ("unable to create command history object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 void
@@ -553,17 +553,17 @@ command_history::read (const std::string
 void
 command_history::read_range (int from, int to, bool must_exist)
 {
   read_range (file (), from, to, must_exist);
 }
 
 void
 command_history::read_range (const std::string& f, int from, int to,
-			     bool must_exist) 
+                             bool must_exist) 
 {
   if (instance_ok ())
     instance->do_read_range (f, from, to, must_exist);
 }
 
 void
 command_history::write (const std::string& f)
 {
@@ -744,27 +744,27 @@ command_history::do_write (const std::st
 }
 
 void
 command_history::do_append (const std::string& f_arg)
 {
   if (lines_this_session)
     {
       if (lines_this_session < do_where ())
-	{
-	  // Create file if it doesn't already exist.
+        {
+          // Create file if it doesn't already exist.
 
-	  std::string f = f_arg;
+          std::string f = f_arg;
 
-	  if (f.empty ())
-	    f = xfile;
+          if (f.empty ())
+            f = xfile;
 
-	  if (f.empty ())
-	    error ("command_history::append: missing file name");
-	}
+          if (f.empty ())
+            error ("command_history::append: missing file name");
+        }
     }
 }
 
 void
 command_history::do_truncate_file (const std::string& f_arg, int)
 {
   std::string f = f_arg;
 
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -37,21 +37,21 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgemv, DGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const double&,
-			   const double*, const octave_idx_type&, const double*,
-			   const octave_idx_type&, const double&, double*,
-			   const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, const octave_idx_type&, const double&,
+                           const double*, const octave_idx_type&, const double*,
+                           const octave_idx_type&, const double&, double*,
+                           const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL);
 }
 
 // Column Vector class.
 
 bool
 ColumnVector::operator == (const ColumnVector& a) const
 {
   octave_idx_type len = length ();
@@ -77,33 +77,33 @@ ColumnVector::insert (const ColumnVector
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i) = a.elem (i);
+        xelem (r+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ColumnVector&
 ColumnVector::fill (double val)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 ColumnVector&
 ColumnVector::fill (double val, octave_idx_type r1, octave_idx_type r2)
 {
@@ -117,17 +117,17 @@ ColumnVector::fill (double val, octave_i
 
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
 
   if (r2 >= r1)
     {
       make_unique ();
 
       for (octave_idx_type i = r1; i <= r2; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 ColumnVector
 ColumnVector::stack (const ColumnVector& a) const
 {
@@ -237,27 +237,27 @@ operator * (const DiagMatrix& m, const C
 
   octave_idx_type a_len = a.length ();
 
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       if (nr == 0 || nc == 0)
-	retval.resize (nr, 0.0);
+        retval.resize (nr, 0.0);
       else
-	{
-	  retval.resize (nr);
+        {
+          retval.resize (nr);
 
-	  for (octave_idx_type i = 0; i < a_len; i++)
-	    retval.elem (i) = a.elem (i) * m.elem (i, i);
+          for (octave_idx_type i = 0; i < a_len; i++)
+            retval.elem (i) = a.elem (i) * m.elem (i, i);
 
-	  for (octave_idx_type i = a_len; i < nr; i++)
-	    retval.elem (i) = 0.0;
-	}
+          for (octave_idx_type i = a_len; i < nr; i++)
+            retval.elem (i) = 0.0;
+        }
     }
 
   return retval;
 }
 
 // other operations
 
 double
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -150,28 +150,28 @@ DiagMatrix::abs (void) const
 
 DiagMatrix
 real (const ComplexDiagMatrix& a)
 {
   DiagMatrix retval;
   octave_idx_type a_len = a.length ();
   if (a_len > 0)
     retval = DiagMatrix (mx_inline_real_dup (a.data (), a_len), a.rows (),
-			 a.cols ());
+                         a.cols ());
   return retval;
 }
 
 DiagMatrix
 imag (const ComplexDiagMatrix& a)
 {
   DiagMatrix retval;
   octave_idx_type a_len = a.length ();
   if (a_len > 0)
     retval = DiagMatrix (mx_inline_imag_dup (a.data (), a_len), a.rows (),
-			 a.cols ());
+                         a.cols ());
   return retval;
 }
 
 Matrix
 DiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
@@ -288,22 +288,22 @@ DiagMatrix::inverse (octave_idx_type &in
     }
 
   DiagMatrix retval (r, c);
 
   info = 0;
   for (octave_idx_type i = 0; i < len; i++)
     {
       if (elem (i, i) == 0.0)
-	{
-	  info = -1;
-	  return *this;
-	}
+        {
+          info = -1;
+          return *this;
+        }
       else
-	retval.elem (i, i) = 1.0 / elem (i, i);
+        retval.elem (i, i) = 1.0 / elem (i, i);
     }
 
   return retval;
 }
 
 DiagMatrix
 DiagMatrix::pseudo_inverse (void) const
 {
@@ -384,18 +384,18 @@ DiagMatrix::rcond (void) const
 std::ostream&
 operator << (std::ostream& os, const DiagMatrix& a)
 {
 //  int field_width = os.precision () + 7;
 
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
-	{
-	  if (i == j)
-	    os << " " /* setw (field_width) */ << a.elem (i, i);
-	  else
-	    os << " " /* setw (field_width) */ << 0.0;
-	}
+        {
+          if (i == j)
+            os << " " /* setw (field_width) */ << a.elem (i, i);
+          else
+            os << " " /* setw (field_width) */ << 0.0;
+        }
       os << "\n";
     }
   return os;
 }
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -59,161 +59,161 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (xilaenv, XILAENV) (const octave_idx_type&, F77_CONST_CHAR_ARG_DECL,
-			       F77_CONST_CHAR_ARG_DECL,
-			       const octave_idx_type&, const octave_idx_type&,
-			       const octave_idx_type&, const octave_idx_type&,
-			       octave_idx_type&
-			       F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
+                               F77_CONST_CHAR_ARG_DECL,
+                               const octave_idx_type&, const octave_idx_type&,
+                               const octave_idx_type&, const octave_idx_type&,
+                               octave_idx_type&
+                               F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgebal, DGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&,
-			     octave_idx_type&, double*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&,
+                             octave_idx_type&, double*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgebak, DGEBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
-			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
+                             const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
 
   F77_RET_T
   F77_FUNC (dgemm, DGEMM) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			   const double&, const double*, const octave_idx_type&,
-			   const double*, const octave_idx_type&, const double&,
-			   double*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+                           const double&, const double*, const octave_idx_type&,
+                           const double*, const octave_idx_type&, const double&,
+                           double*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgemv, DGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const double&,
-			   const double*, const octave_idx_type&, const double*,
-			   const octave_idx_type&, const double&, double*,
-			   const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, const octave_idx_type&, const double&,
+                           const double*, const octave_idx_type&, const double*,
+                           const octave_idx_type&, const double&, double*,
+                           const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xddot, XDDOT) (const octave_idx_type&, const double*, const octave_idx_type&,
-			   const double*, const octave_idx_type&, double&);
+                           const double*, const octave_idx_type&, double&);
 
   F77_RET_T
   F77_FUNC (dsyrk, DSYRK) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, 
-			   const double&, const double*, const octave_idx_type&,
-			   const double&, double*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, const octave_idx_type&, 
+                           const double&, const double*, const octave_idx_type&,
+                           const double&, double*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgetrf, DGETRF) (const octave_idx_type&, const octave_idx_type&, double*, const octave_idx_type&,
-		      octave_idx_type*, octave_idx_type&);
+                      octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dgetrs, DGETRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, const octave_idx_type&, 
-			     const double*, const octave_idx_type&,
-			     const octave_idx_type*, double*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const double*, const octave_idx_type&,
+                             const octave_idx_type*, double*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgetri, DGETRI) (const octave_idx_type&, double*, const octave_idx_type&, const octave_idx_type*,
-			     double*, const octave_idx_type&, octave_idx_type&);
+                             double*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dgecon, DGECON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, double*, 
-			     const octave_idx_type&, const double&, double&, 
-			     double*, octave_idx_type*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const double&, double&, 
+                             double*, octave_idx_type*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgelsy, DGELSY) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     double*, const octave_idx_type&, double*,
-			     const octave_idx_type&, octave_idx_type*, double&, octave_idx_type&,
-			     double*, const octave_idx_type&, octave_idx_type&);
+                             double*, const octave_idx_type&, double*,
+                             const octave_idx_type&, octave_idx_type*, double&, octave_idx_type&,
+                             double*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dgelsd, DGELSD) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     double*, const octave_idx_type&, double*,
-			     const octave_idx_type&, double*, double&, octave_idx_type&,
-			     double*, const octave_idx_type&, octave_idx_type*,
-			     octave_idx_type&);
+                             double*, const octave_idx_type&, double*,
+                             const octave_idx_type&, double*, double&, octave_idx_type&,
+                             double*, const octave_idx_type&, octave_idx_type*,
+                             octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dpotrf, DPOTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     double *, const octave_idx_type&, 
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             double *, const octave_idx_type&, 
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dpocon, DPOCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     double*, const octave_idx_type&, const double&,
-			     double&, double*, octave_idx_type*,
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             double*, const octave_idx_type&, const double&,
+                             double&, double*, octave_idx_type*,
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (dpotrs, DPOTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, const double*, 
-			     const octave_idx_type&, double*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const double*, 
+                             const octave_idx_type&, double*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dtrtri, DTRTRI) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
-			     const octave_idx_type&, const double*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const double*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (dtrcon, DTRCON) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
-			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const double*, const octave_idx_type&, double&,
-			     double*, octave_idx_type*, octave_idx_type& 
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+                             const double*, const octave_idx_type&, double&,
+                             double*, octave_idx_type*, octave_idx_type& 
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (dtrtrs, DTRTRS) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
-			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, const double*, 
-			     const octave_idx_type&, double*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+                             const octave_idx_type&, const double*, 
+                             const octave_idx_type&, double*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dlartg, DLARTG) (const double&, const double&, double&,
-			     double&, double&);
+                             double&, double&);
 
   F77_RET_T
   F77_FUNC (dtrsyl, DTRSYL) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     const double*, const octave_idx_type&, const double*,
-			     const octave_idx_type&, const double*, const octave_idx_type&,
-			     double&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+                             const double*, const octave_idx_type&, const double*,
+                             const octave_idx_type&, const double*, const octave_idx_type&,
+                             double&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xdlange, XDLANGE) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			       const octave_idx_type&, const double*,
-			       const octave_idx_type&, double*, double&
-			       F77_CHAR_ARG_LEN_DECL); 
+                               const octave_idx_type&, const double*,
+                               const octave_idx_type&, double*, double&
+                               F77_CHAR_ARG_LEN_DECL); 
 }
 
 // Matrix class.
 
 Matrix::Matrix (const RowVector& rv)
   : MArray2<double> (Array2<double> (rv, 1, rv.length ()))
 {
 }
@@ -278,19 +278,19 @@ Matrix::operator != (const Matrix& a) co
 }
 
 bool
 Matrix::is_symmetric (void) const
 {
   if (is_square () && rows () > 0)
     {
       for (octave_idx_type i = 0; i < rows (); i++)
-	for (octave_idx_type j = i+1; j < cols (); j++)
-	  if (elem (i, j) != elem (j, i))
-	    return false;
+        for (octave_idx_type j = i+1; j < cols (); j++)
+          if (elem (i, j) != elem (j, i))
+            return false;
 
       return true;
     }
 
   return false;
 }
 
 Matrix&
@@ -311,17 +311,17 @@ Matrix::insert (const RowVector& a, octa
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r, c+i) = a.elem (i);
+        xelem (r, c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 Matrix&
 Matrix::insert (const ColumnVector& a, octave_idx_type r, octave_idx_type c)
 {
@@ -333,17 +333,17 @@ Matrix::insert (const ColumnVector& a, o
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i, c) = a.elem (i);
+        xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 Matrix&
 Matrix::insert (const DiagMatrix& a, octave_idx_type r, octave_idx_type c)
 {
@@ -360,35 +360,35 @@ Matrix::insert (const DiagMatrix& a, oct
 
   octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i, c+i) = a.elem (i, i);
+        xelem (r+i, c+i) = a.elem (i, i);
     }
 
   return *this;
 }
 
 Matrix&
 Matrix::fill (double val)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       make_unique ();
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  xelem (i, j) = val;
+        for (octave_idx_type i = 0; i < nr; i++)
+          xelem (i, j) = val;
     }
 
   return *this;
 }
 
 Matrix&
 Matrix::fill (double val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
 {
@@ -405,18 +405,18 @@ Matrix::fill (double val, octave_idx_typ
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (r2 >= r1 && c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type j = c1; j <= c2; j++)
-	for (octave_idx_type i = r1; i <= r2; i++)
-	  xelem (i, j) = val;
+        for (octave_idx_type i = r1; i <= r2; i++)
+          xelem (i, j) = val;
     }
 
   return *this;
 }
 
 Matrix
 Matrix::append (const Matrix& a) const
 {
@@ -492,17 +492,17 @@ Matrix::append (const DiagMatrix& a) con
 Matrix
 Matrix::stack (const Matrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return Matrix ();
     }
 
   octave_idx_type nr_insert = nr;
   Matrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -511,17 +511,17 @@ Matrix::stack (const Matrix& a) const
 Matrix
 Matrix::stack (const RowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return Matrix ();
     }
 
   octave_idx_type nr_insert = nr;
   Matrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -530,17 +530,17 @@ Matrix::stack (const RowVector& a) const
 Matrix
 Matrix::stack (const ColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return Matrix ();
     }
 
   octave_idx_type nr_insert = nr;
   Matrix retval (nr + a.length (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -549,17 +549,17 @@ Matrix::stack (const ColumnVector& a) co
 Matrix
 Matrix::stack (const DiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return Matrix ();
     }
 
   octave_idx_type nr_insert = nr;
   Matrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -637,17 +637,17 @@ Matrix::inverse (octave_idx_type& info) 
 {
   double rcon;
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 Matrix
 Matrix::inverse (octave_idx_type& info, double& rcon, int force,
-		 int calc_cond) const
+                 int calc_cond) const
 {
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, force, calc_cond);
 }
 
 Matrix
 Matrix::inverse (MatrixType& mattype) const
 {
@@ -660,17 +660,17 @@ Matrix
 Matrix::inverse (MatrixType &mattype, octave_idx_type& info) const
 {
   double rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 Matrix
 Matrix::tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
-		  int force, int calc_cond) const
+                  int force, int calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -678,57 +678,57 @@ Matrix::tinverse (MatrixType &mattype, o
     {
       int typ = mattype.type ();
       char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
       char udiag = 'N';
       retval = *this;
       double *tmp_data = retval.fortran_vec ();
 
       F77_XFCN (dtrtri, DTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
-				 F77_CONST_CHAR_ARG2 (&udiag, 1),
-				 nr, tmp_data, nr, info 
-				 F77_CHAR_ARG_LEN (1)
-				 F77_CHAR_ARG_LEN (1)));
+                                 F77_CONST_CHAR_ARG2 (&udiag, 1),
+                                 nr, tmp_data, nr, info 
+                                 F77_CHAR_ARG_LEN (1)
+                                 F77_CHAR_ARG_LEN (1)));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0) 
-	info = -1;
+        info = -1;
       else if (calc_cond) 
-	{
-	  octave_idx_type dtrcon_info = 0;
-	  char job = '1';
-
-	  OCTAVE_LOCAL_BUFFER (double, work, 3 * nr);
-	  OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
-
-	  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     F77_CONST_CHAR_ARG2 (&uplo, 1),
-				     F77_CONST_CHAR_ARG2 (&udiag, 1),
-				     nr, tmp_data, nr, rcon, 
-				     work, iwork, dtrcon_info 
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (dtrcon_info != 0) 
-	    info = -1;
-	}
+        {
+          octave_idx_type dtrcon_info = 0;
+          char job = '1';
+
+          OCTAVE_LOCAL_BUFFER (double, work, 3 * nr);
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
+
+          F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&udiag, 1),
+                                     nr, tmp_data, nr, rcon, 
+                                     work, iwork, dtrcon_info 
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (dtrcon_info != 0) 
+            info = -1;
+        }
 
       if (info == -1 && ! force)
-	retval = *this; // Restore matrix contents.
+        retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
 
 
 Matrix
 Matrix::finverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
-		  int force, int calc_cond) const
+                  int force, int calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -740,107 +740,107 @@ Matrix::finverse (MatrixType &mattype, o
       retval = *this;
       double *tmp_data = retval.fortran_vec ();
 
       Array<double> z(1);
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
       F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt, 
-				 z.fortran_vec (), lwork, info));
+                                 z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (z(0));
       lwork = (lwork < 2 *nc ? 2*nc : lwork);
       z.resize (lwork);
       double *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) 
-	anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+        anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0) 
-	info = -1;
+        info = -1;
       else if (calc_cond) 
-	{
-	  octave_idx_type dgecon_info = 0;
-
-	  // Now calculate the condition number for non-singular matrix.
-	  char job = '1';
-	  Array<octave_idx_type> iz (nc);
-	  octave_idx_type *piz = iz.fortran_vec ();
-	  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nc, tmp_data, nr, anorm, 
-				     rcon, pz, piz, dgecon_info
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (dgecon_info != 0) 
-	    info = -1;
-	}
+        {
+          octave_idx_type dgecon_info = 0;
+
+          // Now calculate the condition number for non-singular matrix.
+          char job = '1';
+          Array<octave_idx_type> iz (nc);
+          octave_idx_type *piz = iz.fortran_vec ();
+          F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nc, tmp_data, nr, anorm, 
+                                     rcon, pz, piz, dgecon_info
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (dgecon_info != 0) 
+            info = -1;
+        }
 
       if (info == -1 && ! force)
-	retval = *this; // Restore matrix contents.
+        retval = *this; // Restore matrix contents.
       else
-	{
-	  octave_idx_type dgetri_info = 0;
-
-	  F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
-				     pz, lwork, dgetri_info));
-
-	  if (dgetri_info != 0) 
-	    info = -1;
-	}
+        {
+          octave_idx_type dgetri_info = 0;
+
+          F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
+                                     pz, lwork, dgetri_info));
+
+          if (dgetri_info != 0) 
+            info = -1;
+        }
 
       if (info != 0)
-	mattype.mark_as_rectangular();
+        mattype.mark_as_rectangular();
     }
 
   return retval;
 }
 
 Matrix
 Matrix::inverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
-		 int force, int calc_cond) const
+                 int force, int calc_cond) const
 {
   int typ = mattype.type (false);
   Matrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
     ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
-	{
-	  CHOL chol (*this, info, calc_cond);
-	  if (info == 0)
-	    {
-	      if (calc_cond)
-		rcon = chol.rcond ();
-	      else
-		rcon = 1.0;
-	      ret = chol.inverse ();
-	    }
-	  else
-	    mattype.mark_as_unsymmetric ();
-	}
+        {
+          CHOL chol (*this, info, calc_cond);
+          if (info == 0)
+            {
+              if (calc_cond)
+                rcon = chol.rcond ();
+              else
+                rcon = 1.0;
+              ret = chol.inverse ();
+            }
+          else
+            mattype.mark_as_unsymmetric ();
+        }
 
       if (!mattype.is_hermitian ())
-	ret = finverse(mattype, info, rcon, force, calc_cond);
+        ret = finverse(mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
-	ret = Matrix (rows (), columns (), octave_Inf);
+        ret = Matrix (rows (), columns (), octave_Inf);
     }
 
   return ret;
 }
 
 Matrix
 Matrix::pseudo_inverse (double tol) const
 {
@@ -854,19 +854,19 @@ Matrix::pseudo_inverse (double tol) cons
 
   octave_idx_type r = sigma.length () - 1;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
-	tol = nr * sigma.elem (0) * DBL_EPSILON;
+        tol = nr * sigma.elem (0) * DBL_EPSILON;
       else
-	tol = nc * sigma.elem (0) * DBL_EPSILON;
+        tol = nc * sigma.elem (0) * DBL_EPSILON;
     }
 
   while (r >= 0 && sigma.elem (r) < tol)
     r--;
 
   if (r < 0)
     return Matrix (nc, nr, 0.0);
   else
@@ -1118,22 +1118,22 @@ Matrix::fourier2d (void) const
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
-	prow[i] = tmp_data[i*nr + j];
+        prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
-	tmp_data[i*nr + j] = prow[i];
+        tmp_data[i*nr + j] = prow[i];
     }
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::ifourier2d (void) const
 {
@@ -1187,22 +1187,22 @@ Matrix::ifourier2d (void) const
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
-	prow[i] = tmp_data[i*nr + j];
+        prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
-	tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
+        tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
     }
 
   return retval;
 }
 
 #endif
 
 DET
@@ -1379,362 +1379,362 @@ Matrix::rcond (MatrixType &mattype) cons
     (*current_liboctave_error_handler) ("matrix must be square");
   else if (nr == 0 || nc == 0)
     rcon = octave_Inf;
   else
     {
       int typ = mattype.type ();
 
       if (typ == MatrixType::Unknown)
-	typ = mattype.type (*this);
+        typ = mattype.type (*this);
 
       // Only calculate the condition number for LU/Cholesky
       if (typ == MatrixType::Upper)
-	{
-	  const double *tmp_data = fortran_vec ();
-	  octave_idx_type info = 0;
-	  char norm = '1';
-	  char uplo = 'U';
-	  char dia = 'N';
-
-	  Array<double> z (3 * nc);
-	  double *pz = z.fortran_vec ();
-	  Array<octave_idx_type> iz (nc);
-	  octave_idx_type *piz = iz.fortran_vec ();
-
-	  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-				     F77_CONST_CHAR_ARG2 (&dia, 1), 
-				     nr, tmp_data, nr, rcon,
-				     pz, piz, info
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (info != 0) 
-	    rcon = 0.0;
-	}
+        {
+          const double *tmp_data = fortran_vec ();
+          octave_idx_type info = 0;
+          char norm = '1';
+          char uplo = 'U';
+          char dia = 'N';
+
+          Array<double> z (3 * nc);
+          double *pz = z.fortran_vec ();
+          Array<octave_idx_type> iz (nc);
+          octave_idx_type *piz = iz.fortran_vec ();
+
+          F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                     nr, tmp_data, nr, rcon,
+                                     pz, piz, info
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (info != 0) 
+            rcon = 0.0;
+        }
       else if  (typ == MatrixType::Permuted_Upper)
-	(*current_liboctave_error_handler)
-	  ("permuted triangular matrix not implemented");
+        (*current_liboctave_error_handler)
+          ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
-	{
-	  const double *tmp_data = fortran_vec ();
-	  octave_idx_type info = 0;
-	  char norm = '1';
-	  char uplo = 'L';
-	  char dia = 'N';
-
-	  Array<double> z (3 * nc);
-	  double *pz = z.fortran_vec ();
-	  Array<octave_idx_type> iz (nc);
-	  octave_idx_type *piz = iz.fortran_vec ();
-
-	  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-				     F77_CONST_CHAR_ARG2 (&dia, 1), 
-				     nr, tmp_data, nr, rcon,
-				     pz, piz, info
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (info != 0) 
-	    rcon = 0.0;
-	}
+        {
+          const double *tmp_data = fortran_vec ();
+          octave_idx_type info = 0;
+          char norm = '1';
+          char uplo = 'L';
+          char dia = 'N';
+
+          Array<double> z (3 * nc);
+          double *pz = z.fortran_vec ();
+          Array<octave_idx_type> iz (nc);
+          octave_idx_type *piz = iz.fortran_vec ();
+
+          F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                     nr, tmp_data, nr, rcon,
+                                     pz, piz, info
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (info != 0) 
+            rcon = 0.0;
+        }
       else if (typ == MatrixType::Permuted_Lower)
-	(*current_liboctave_error_handler)
-	  ("permuted triangular matrix not implemented");
+        (*current_liboctave_error_handler)
+          ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
-	{
-	  double anorm = -1.0;
-	  Matrix atmp = *this;
-	  double *tmp_data = atmp.fortran_vec ();
-
-	  if (typ == MatrixType::Hermitian)
-	    {
-	      octave_idx_type info = 0;
-	      char job = 'L';
-	      anorm = atmp.abs().sum().
-		row(static_cast<octave_idx_type>(0)).max();
-
-	      F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
-					 tmp_data, nr, info
-					 F77_CHAR_ARG_LEN (1)));
-
-	      if (info != 0) 
-		{
-		  rcon = 0.0;
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Full;
-		}
-	      else 
-		{
-		  Array<double> z (3 * nc);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nc);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, tmp_data, nr, anorm,
-					     rcon, pz, piz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    rcon = 0.0;
-		}
-	    }
-
-	  if (typ == MatrixType::Full)
-	    {
-	      octave_idx_type info = 0;
-
-	      Array<octave_idx_type> ipvt (nr);
-	      octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	      if(anorm < 0.)
-		anorm = atmp.abs().sum().
-		  row(static_cast<octave_idx_type>(0)).max();
-
-	      Array<double> z (4 * nc);
-	      double *pz = z.fortran_vec ();
-	      Array<octave_idx_type> iz (nc);
-	      octave_idx_type *piz = iz.fortran_vec ();
-
-	      F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-	      if (info != 0) 
-		{
-		  rcon = 0.0;
-		  mattype.mark_as_rectangular ();
-		}
-	      else 
-		{
-		  char job = '1';
-		  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nc, tmp_data, nr, anorm, 
-					     rcon, pz, piz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    rcon = 0.0;
-		}
-	    }
-	}
+        {
+          double anorm = -1.0;
+          Matrix atmp = *this;
+          double *tmp_data = atmp.fortran_vec ();
+
+          if (typ == MatrixType::Hermitian)
+            {
+              octave_idx_type info = 0;
+              char job = 'L';
+              anorm = atmp.abs().sum().
+                row(static_cast<octave_idx_type>(0)).max();
+
+              F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+                                         tmp_data, nr, info
+                                         F77_CHAR_ARG_LEN (1)));
+
+              if (info != 0) 
+                {
+                  rcon = 0.0;
+                  mattype.mark_as_unsymmetric ();
+                  typ = MatrixType::Full;
+                }
+              else 
+                {
+                  Array<double> z (3 * nc);
+                  double *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nc);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, tmp_data, nr, anorm,
+                                             rcon, pz, piz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    rcon = 0.0;
+                }
+            }
+
+          if (typ == MatrixType::Full)
+            {
+              octave_idx_type info = 0;
+
+              Array<octave_idx_type> ipvt (nr);
+              octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+              if(anorm < 0.)
+                anorm = atmp.abs().sum().
+                  row(static_cast<octave_idx_type>(0)).max();
+
+              Array<double> z (4 * nc);
+              double *pz = z.fortran_vec ();
+              Array<octave_idx_type> iz (nc);
+              octave_idx_type *piz = iz.fortran_vec ();
+
+              F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+              if (info != 0) 
+                {
+                  rcon = 0.0;
+                  mattype.mark_as_rectangular ();
+                }
+              else 
+                {
+                  char job = '1';
+                  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nc, tmp_data, nr, anorm, 
+                                             rcon, pz, piz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    rcon = 0.0;
+                }
+            }
+        }
       else
-	rcon = 0.0;
+        rcon = 0.0;
     }
 
   return rcon;
 }
 
 Matrix
 Matrix::utsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
-		double& rcon, solve_singularity_handler sing_handler,
-		bool calc_cond, blas_trans_type transt) const
+                double& rcon, solve_singularity_handler sing_handler,
+                bool calc_cond, blas_trans_type transt) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Upper)
-	{
-	  octave_idx_type b_nc = b.cols ();
-	  rcon = 1.;
-	  info = 0;
-
-	  if (typ == MatrixType::Permuted_Upper)
-	    {
-	      (*current_liboctave_error_handler)
-		("permuted triangular matrix not implemented");
-	    }
-	  else
-	    {
-	      const double *tmp_data = fortran_vec ();
-
-	      if (calc_cond)
-		{
-		  char norm = '1';
-		  char uplo = 'U';
-		  char dia = 'N';
-
-		  Array<double> z (3 * nc);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nc);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcon,
-					     pz, piz, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile double rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  double *result = retval.fortran_vec ();
-
-		  char uplo = 'U';
-		  char trans = get_blas_char (transt);
-		  char dia = 'N';
-
-		  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&trans, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, b_nc, tmp_data, nr,
-					     result, nr, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	    }
-	}
+          typ == MatrixType::Upper)
+        {
+          octave_idx_type b_nc = b.cols ();
+          rcon = 1.;
+          info = 0;
+
+          if (typ == MatrixType::Permuted_Upper)
+            {
+              (*current_liboctave_error_handler)
+                ("permuted triangular matrix not implemented");
+            }
+          else
+            {
+              const double *tmp_data = fortran_vec ();
+
+              if (calc_cond)
+                {
+                  char norm = '1';
+                  char uplo = 'U';
+                  char dia = 'N';
+
+                  Array<double> z (3 * nc);
+                  double *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nc);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, tmp_data, nr, rcon,
+                                             pz, piz, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile double rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  double *result = retval.fortran_vec ();
+
+                  char uplo = 'U';
+                  char trans = get_blas_char (transt);
+                  char dia = 'N';
+
+                  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, b_nc, tmp_data, nr,
+                                             result, nr, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 Matrix::ltsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
-		double& rcon, solve_singularity_handler sing_handler,
-		bool calc_cond, blas_trans_type transt) const
+                double& rcon, solve_singularity_handler sing_handler,
+                bool calc_cond, blas_trans_type transt) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower ||
-	  typ == MatrixType::Lower)
-	{
-	  octave_idx_type b_nc = b.cols ();
-	  rcon = 1.;
-	  info = 0;
-
-	  if (typ == MatrixType::Permuted_Lower)
-	    {
-	      (*current_liboctave_error_handler)
-		("permuted triangular matrix not implemented");
-	    }
-	  else
-	    {
-	      const double *tmp_data = fortran_vec ();
-
-	      if (calc_cond)
-		{
-		  char norm = '1';
-		  char uplo = 'L';
-		  char dia = 'N';
-
-		  Array<double> z (3 * nc);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nc);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcon,
-					     pz, piz, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile double rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  double *result = retval.fortran_vec ();
-
-		  char uplo = 'L';
-		  char trans = get_blas_char (transt);
-		  char dia = 'N';
-
-		  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&trans, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, b_nc, tmp_data, nr,
-					     result, nr, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	    }
-	}
+          typ == MatrixType::Lower)
+        {
+          octave_idx_type b_nc = b.cols ();
+          rcon = 1.;
+          info = 0;
+
+          if (typ == MatrixType::Permuted_Lower)
+            {
+              (*current_liboctave_error_handler)
+                ("permuted triangular matrix not implemented");
+            }
+          else
+            {
+              const double *tmp_data = fortran_vec ();
+
+              if (calc_cond)
+                {
+                  char norm = '1';
+                  char uplo = 'L';
+                  char dia = 'N';
+
+                  Array<double> z (3 * nc);
+                  double *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nc);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, tmp_data, nr, rcon,
+                                             pz, piz, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile double rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  double *result = retval.fortran_vec ();
+
+                  char uplo = 'L';
+                  char trans = get_blas_char (transt);
+                  char dia = 'N';
+
+                  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, b_nc, tmp_data, nr,
+                                             result, nr, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 Matrix::fsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
-		double& rcon, solve_singularity_handler sing_handler,
-		bool calc_cond) const
+                double& rcon, solve_singularity_handler sing_handler,
+                bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1744,170 +1744,170 @@ Matrix::fsolve (MatrixType &mattype, con
   else
     {
       volatile int typ = mattype.type ();
  
      // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
-	{
-	  info = 0;
-	  char job = 'L';
-	  Matrix atmp = *this;
-	  double *tmp_data = atmp.fortran_vec ();
-	  anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
-
-	  F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
-				     tmp_data, nr, info
-				     F77_CHAR_ARG_LEN (1)));
-
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcon = 0.0;
-	  if (info != 0) 
-	    {
-	      info = -2;
-
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  Array<double> z (3 * nc);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nc);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, tmp_data, nr, anorm,
-					     rcon, pz, piz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile double rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  double *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  F77_XFCN (dpotrs, DPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, b_nc, tmp_data, nr,
-					     result, b.rows(), info
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	      else
-		{
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Full;
-		}		    
-	    }
-	}
+        {
+          info = 0;
+          char job = 'L';
+          Matrix atmp = *this;
+          double *tmp_data = atmp.fortran_vec ();
+          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+
+          F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+                                     tmp_data, nr, info
+                                     F77_CHAR_ARG_LEN (1)));
+
+          // Throw-away extra info LAPACK gives so as to not change output.
+          rcon = 0.0;
+          if (info != 0) 
+            {
+              info = -2;
+
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+          else 
+            {
+              if (calc_cond)
+                {
+                  Array<double> z (3 * nc);
+                  double *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nc);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, tmp_data, nr, anorm,
+                                             rcon, pz, piz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile double rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  double *result = retval.fortran_vec ();
+
+                  octave_idx_type b_nc = b.cols ();
+
+                  F77_XFCN (dpotrs, DPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, b_nc, tmp_data, nr,
+                                             result, b.rows(), info
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+              else
+                {
+                  mattype.mark_as_unsymmetric ();
+                  typ = MatrixType::Full;
+                }                   
+            }
+        }
 
       if (typ == MatrixType::Full)
-	{
-	  info = 0;
-
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  Matrix atmp = *this;
-	  double *tmp_data = atmp.fortran_vec ();
-	  if(anorm < 0.)
-	    anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
-
-	  Array<double> z (4 * nc);
-	  double *pz = z.fortran_vec ();
-	  Array<octave_idx_type> iz (nc);
-	  octave_idx_type *piz = iz.fortran_vec ();
-
-	  F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcon = 0.0;
-	  if (info != 0) 
-	    {
-	      info = -2;
-
-	      if (sing_handler)
-		sing_handler (rcon);
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	      mattype.mark_as_rectangular ();
-	    }
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  // Now calculate the condition number for 
-		  // non-singular matrix.
-		  char job = '1';
-		  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nc, tmp_data, nr, anorm, 
-					     rcon, pz, piz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile double rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  double *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  char job = 'N';
-		  F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, b_nc, tmp_data, nr,
-					     pipvt, result, b.rows(), info
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	      else
-		mattype.mark_as_rectangular ();
-	    }
-	}
+        {
+          info = 0;
+
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          Matrix atmp = *this;
+          double *tmp_data = atmp.fortran_vec ();
+          if(anorm < 0.)
+            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+
+          Array<double> z (4 * nc);
+          double *pz = z.fortran_vec ();
+          Array<octave_idx_type> iz (nc);
+          octave_idx_type *piz = iz.fortran_vec ();
+
+          F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+          // Throw-away extra info LAPACK gives so as to not change output.
+          rcon = 0.0;
+          if (info != 0) 
+            {
+              info = -2;
+
+              if (sing_handler)
+                sing_handler (rcon);
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+              mattype.mark_as_rectangular ();
+            }
+          else 
+            {
+              if (calc_cond)
+                {
+                  // Now calculate the condition number for 
+                  // non-singular matrix.
+                  char job = '1';
+                  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nc, tmp_data, nr, anorm, 
+                                             rcon, pz, piz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile double rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  double *result = retval.fortran_vec ();
+
+                  octave_idx_type b_nc = b.cols ();
+
+                  char job = 'N';
+                  F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, b_nc, tmp_data, nr,
+                                             pipvt, result, b.rows(), info
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+              else
+                mattype.mark_as_rectangular ();
+            }
+        }
       else if (typ != MatrixType::Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 Matrix::solve (MatrixType &typ, const Matrix& b) const
 {
@@ -1920,25 +1920,25 @@ Matrix
 Matrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 Matrix
 Matrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
-	       double& rcon) const
+               double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 Matrix
 Matrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
-	       double& rcon, solve_singularity_handler sing_handler,
-	       bool singular_fallback, blas_trans_type transt) const
+               double& rcon, solve_singularity_handler sing_handler,
+               bool singular_fallback, blas_trans_type transt) const
 {
   Matrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
@@ -1979,17 +1979,17 @@ Matrix::solve (MatrixType &typ, const Co
   octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 Matrix::solve (MatrixType &typ, const ComplexMatrix& b, octave_idx_type& info,
-	       double& rcon) const
+               double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 static Matrix
 stack_complex_matrix (const ComplexMatrix& cm)
 {
   octave_idx_type m = cm.rows (), n = cm.cols (), nel = m*n;
@@ -2013,81 +2013,81 @@ unstack_complex_matrix (const Matrix& sm
   Complex *rd = retval.fortran_vec ();
   for (octave_idx_type i = 0; i < nel; i++)
     rd[i] = Complex (smd[i], smd[nel+i]);
   return retval;
 }
 
 ComplexMatrix
 Matrix::solve (MatrixType &typ, const ComplexMatrix& b, octave_idx_type& info,
-	       double& rcon, solve_singularity_handler sing_handler,
-	       bool singular_fallback, blas_trans_type transt) const
+               double& rcon, solve_singularity_handler sing_handler,
+               bool singular_fallback, blas_trans_type transt) const
 {
   Matrix tmp = stack_complex_matrix (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
   return unstack_complex_matrix (tmp);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b) const
 {
   octave_idx_type info; double rcon;
   return solve (typ, b, info, rcon);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, 
-	       octave_idx_type& info) const
+               octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
-	       double& rcon) const
+               double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
-	       double& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
+               double& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   Matrix tmp (b);
   return solve (typ, tmp, info, rcon, sing_handler, transt).column(static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
-	       octave_idx_type& info) const
+               octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info);
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
-	       octave_idx_type& info, double& rcon) const
+               octave_idx_type& info, double& rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info, rcon);
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
-	       octave_idx_type& info, double& rcon,
-	       solve_singularity_handler sing_handler, blas_trans_type transt) const
+               octave_idx_type& info, double& rcon,
+               solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve(typ, b, info, rcon, sing_handler, transt);
 }
 
 Matrix
 Matrix::solve (const Matrix& b) const
 {
@@ -2106,17 +2106,17 @@ Matrix::solve (const Matrix& b, octave_i
 Matrix
 Matrix::solve (const Matrix& b, octave_idx_type& info, double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 Matrix
 Matrix::solve (const Matrix& b, octave_idx_type& info,
-	       double& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
+               double& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 ComplexMatrix
 Matrix::solve (const ComplexMatrix& b) const
 {
@@ -2135,17 +2135,17 @@ ComplexMatrix
 Matrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon);
 }
 
 ComplexMatrix
 Matrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
-	       solve_singularity_handler sing_handler, blas_trans_type transt) const
+               solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon, sing_handler, transt);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b) const
 {
@@ -2163,17 +2163,17 @@ Matrix::solve (const ColumnVector& b, oc
 ColumnVector
 Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
-	       solve_singularity_handler sing_handler, blas_trans_type transt) const
+               solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 ComplexColumnVector
 Matrix::solve (const ComplexColumnVector& b) const
 {
@@ -2192,17 +2192,17 @@ ComplexColumnVector
 Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon);
 }
 
 ComplexColumnVector
 Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcon,
-	       solve_singularity_handler sing_handler, blas_trans_type transt) const
+               solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon, sing_handler, transt);
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b) const
 {
@@ -2217,25 +2217,25 @@ Matrix::lssolve (const Matrix& b, octave
 {
   octave_idx_type rank;
   double rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b, octave_idx_type& info,
-		 octave_idx_type& rank) const
+                 octave_idx_type& rank) const
 {
   double rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b, octave_idx_type& info,
-		 octave_idx_type& rank, double &rcon) const
+                 octave_idx_type& rank, double &rcon) const
 {
   Matrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2245,127 +2245,127 @@ Matrix::lssolve (const Matrix& b, octave
   else if (m == 0 || n == 0 || b.cols () == 0)
     retval = Matrix (n, b.cols (), 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
       if (m != n)
-	{
-	  retval = Matrix (maxmn, nrhs, 0.0);
-
-	  for (octave_idx_type j = 0; j < nrhs; j++)
-	    for (octave_idx_type i = 0; i < m; i++)
-	      retval.elem (i, j) = b.elem (i, j);
-	}
+        {
+          retval = Matrix (maxmn, nrhs, 0.0);
+
+          for (octave_idx_type j = 0; j < nrhs; j++)
+            for (octave_idx_type i = 0; i < m; i++)
+              retval.elem (i, j) = b.elem (i, j);
+        }
       else
-	retval = b;
+        retval = b;
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       double *pretval = retval.fortran_vec ();
       Array<double> s (minmn);
       double *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
       Array<double> work (1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("DGELSD", 6),
-				   F77_CONST_CHAR_ARG2 (" ", 1),
-				   0, 0, 0, 0, smlsiz
-				   F77_CHAR_ARG_LEN (6)
-				   F77_CHAR_ARG_LEN (1));
+                                   F77_CONST_CHAR_ARG2 (" ", 1),
+                                   0, 0, 0, 0, smlsiz
+                                   F77_CHAR_ARG_LEN (6)
+                                   F77_CHAR_ARG_LEN (1));
 
       octave_idx_type mnthr;
       F77_FUNC (xilaenv, XILAENV) (6, F77_CONST_CHAR_ARG2 ("DGELSD", 6),
-				   F77_CONST_CHAR_ARG2 (" ", 1),
-				   m, n, nrhs, -1, mnthr
-				   F77_CHAR_ARG_LEN (6)
-				   F77_CHAR_ARG_LEN (1));
+                                   F77_CONST_CHAR_ARG2 (" ", 1),
+                                   m, n, nrhs, -1, mnthr
+                                   F77_CHAR_ARG_LEN (6)
+                                   F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
 #if defined (HAVE_LOG2)
       double tmp = log2 (dminmn / dsmlsizp1);
 #else
       double tmp = log (dminmn / dsmlsizp1) / log (2.0);
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
-	nlvl = 0;
+        nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
-	liwork = 1;
+        liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcon, rank, work.fortran_vec (),
-				 lwork, piwork, info));
+                                 ps, rcon, rank, work.fortran_vec (),
+                                 lwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for DGELSD to operate
       // efficiently.
       if (n >= mnthr)
-	{
-	  const octave_idx_type wlalsd
-	    = 9*m + 2*m*smlsiz + 8*m*nlvl + m*nrhs + (smlsiz+1)*(smlsiz+1);
-
-	  octave_idx_type addend = m;
-
-	  if (2*m-4 > addend)
-	    addend = 2*m-4;
-
-	  if (nrhs > addend)
-	    addend = nrhs;
-
-	  if (n-3*m > addend)
-	    addend = n-3*m;
-
-	  if (wlalsd > addend)
-	    addend = wlalsd;
-
-	  const octave_idx_type lworkaround = 4*m + m*m + addend;
-
-	  if (work(0) < lworkaround)
-	    work(0) = lworkaround;
-	}
+        {
+          const octave_idx_type wlalsd
+            = 9*m + 2*m*smlsiz + 8*m*nlvl + m*nrhs + (smlsiz+1)*(smlsiz+1);
+
+          octave_idx_type addend = m;
+
+          if (2*m-4 > addend)
+            addend = 2*m-4;
+
+          if (nrhs > addend)
+            addend = nrhs;
+
+          if (n-3*m > addend)
+            addend = n-3*m;
+
+          if (wlalsd > addend)
+            addend = wlalsd;
+
+          const octave_idx_type lworkaround = 4*m + m*m + addend;
+
+          if (work(0) < lworkaround)
+            work(0) = lworkaround;
+        }
       else if (m >= n)
-	{
-	  octave_idx_type lworkaround
-	    = 12*n + 2*n*smlsiz + 8*n*nlvl + n*nrhs + (smlsiz+1)*(smlsiz+1);
-
-	  if (work(0) < lworkaround)
-	    work(0) = lworkaround;
-	}
+        {
+          octave_idx_type lworkaround
+            = 12*n + 2*n*smlsiz + 8*n*nlvl + n*nrhs + (smlsiz+1)*(smlsiz+1);
+
+          if (work(0) < lworkaround)
+            work(0) = lworkaround;
+        }
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (lwork);
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcon, rank,
-				 work.fortran_vec (), lwork, 
-				 piwork, info));
+                                 maxmn, ps, rcon, rank,
+                                 work.fortran_vec (), lwork, 
+                                 piwork, info));
 
       if (rank < minmn)
-	(*current_liboctave_warning_handler) 
-	  ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
+        (*current_liboctave_warning_handler) 
+          ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
       if (s.elem (0) == 0.0)
-	rcon = 0.0;
+        rcon = 0.0;
       else
-	rcon = s.elem (minmn - 1) / s.elem (0);
+        rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 ComplexMatrix
@@ -2384,26 +2384,26 @@ Matrix::lssolve (const ComplexMatrix& b,
   ComplexMatrix tmp (*this);
   octave_idx_type rank;
   double rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
 Matrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, 
-		 octave_idx_type& rank) const
+                 octave_idx_type& rank) const
 {
   ComplexMatrix tmp (*this);
   double rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
 Matrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, 
-		 octave_idx_type& rank, double& rcon) const
+                 octave_idx_type& rank, double& rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b) const
 {
@@ -2418,25 +2418,25 @@ Matrix::lssolve (const ColumnVector& b, 
 {
   octave_idx_type rank;
   double rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b, octave_idx_type& info,
-		 octave_idx_type& rank) const
+                 octave_idx_type& rank) const
 {
   double rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b, octave_idx_type& info,
-		 octave_idx_type& rank, double &rcon) const
+                 octave_idx_type& rank, double &rcon) const
 {
   ColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2447,85 +2447,85 @@ Matrix::lssolve (const ColumnVector& b, 
     retval = ColumnVector (n, 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
  
       if (m != n)
-	{
-	  retval = ColumnVector (maxmn, 0.0);
-
-	  for (octave_idx_type i = 0; i < m; i++)
-	    retval.elem (i) = b.elem (i);
-	}
+        {
+          retval = ColumnVector (maxmn, 0.0);
+
+          for (octave_idx_type i = 0; i < m; i++)
+            retval.elem (i) = b.elem (i);
+        }
       else
-	retval = b;
+        retval = b;
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       double *pretval = retval.fortran_vec ();
       Array<double> s (minmn);
       double *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
       Array<double> work (1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("DGELSD", 6),
-				   F77_CONST_CHAR_ARG2 (" ", 1),
-				   0, 0, 0, 0, smlsiz
-				   F77_CHAR_ARG_LEN (6)
-				   F77_CHAR_ARG_LEN (1));
+                                   F77_CONST_CHAR_ARG2 (" ", 1),
+                                   0, 0, 0, 0, smlsiz
+                                   F77_CHAR_ARG_LEN (6)
+                                   F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
 #if defined (HAVE_LOG2)
       double tmp = log2 (dminmn / dsmlsizp1);
 #else
       double tmp = log (dminmn / dsmlsizp1) / log (2.0);
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
-	nlvl = 0;
+        nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
-	liwork = 1;
+        liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcon, rank, work.fortran_vec (),
-				 lwork, piwork, info));
+                                 ps, rcon, rank, work.fortran_vec (),
+                                 lwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (lwork);
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcon, rank,
-				 work.fortran_vec (), lwork, 
-				 piwork, info));
+                                 maxmn, ps, rcon, rank,
+                                 work.fortran_vec (), lwork, 
+                                 piwork, info));
 
       if (rank < minmn)
-	{
-	  if (rank < minmn)
-	    (*current_liboctave_warning_handler) 
-	      ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
-	  if (s.elem (0) == 0.0)
-	    rcon = 0.0;
-	  else
-	    rcon = s.elem (minmn - 1) / s.elem (0);
-	}
+        {
+          if (rank < minmn)
+            (*current_liboctave_warning_handler) 
+              ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
+          if (s.elem (0) == 0.0)
+            rcon = 0.0;
+          else
+            rcon = s.elem (minmn - 1) / s.elem (0);
+        }
 
       retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 ComplexColumnVector
@@ -2544,26 +2544,26 @@ Matrix::lssolve (const ComplexColumnVect
   ComplexMatrix tmp (*this);
   octave_idx_type rank;
   double rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
 Matrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info, 
-		 octave_idx_type& rank) const
+                 octave_idx_type& rank) const
 {
   ComplexMatrix tmp (*this);
   double rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
 Matrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info, 
-		 octave_idx_type& rank, double &rcon) const
+                 octave_idx_type& rank, double &rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 Matrix&
 Matrix::operator += (const DiagMatrix& a)
 {
@@ -2624,108 +2624,108 @@ operator * (const ColumnVector& v, const
   octave_idx_type len = v.length ();
 
   if (len != 0)
     {
       octave_idx_type a_len = a.length ();
 
       retval = Matrix (len, a_len);
       double *c = retval.fortran_vec ();
-	  
+          
       F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
-			       F77_CONST_CHAR_ARG2 ("N", 1),
-			       len, a_len, 1, 1.0, v.data (), len,
-			       a.data (), 1, 0.0, c, len
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 ("N", 1),
+                               len, a_len, 1, 1.0, v.data (), len,
+                               a.data (), 1, 0.0, c, len
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 // other operations.
 
 bool
 Matrix::any_element_is_negative (bool neg_zero) const
 {
   octave_idx_type nel = nelem ();
 
   if (neg_zero)
     {
       for (octave_idx_type i = 0; i < nel; i++)
-	if (lo_ieee_signbit (elem (i)))
-	  return true;
+        if (lo_ieee_signbit (elem (i)))
+          return true;
     }
   else
     {
       for (octave_idx_type i = 0; i < nel; i++)
-	if (elem (i) < 0)
-	  return true;
+        if (elem (i) < 0)
+          return true;
     }
 
   return false;
 }
 
 bool
 Matrix::any_element_is_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
       if (xisnan (val))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 Matrix::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
       if (xisinf (val) || xisnan (val))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 Matrix::any_element_not_one_or_zero (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
       if (val != 0 && val != 1)
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 Matrix::all_elements_are_int_or_inf_or_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
       if (xisnan (val) || D_NINT (val) == val)
-	continue;
+        continue;
       else
-	return false;
+        return false;
     }
 
   return true;
 }
 
 // Return nonzero if any element of M is not an integer.  Also extract
 // the largest and smallest values and return them in MAX_VAL and MIN_VAL.
 
@@ -2742,40 +2742,40 @@ Matrix::all_integers (double& max_val, d
   else
     return false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
 
       if (val > max_val)
-	max_val = val;
+        max_val = val;
 
       if (val < min_val)
-	min_val = val;
+        min_val = val;
 
       if (D_NINT (val) != val)
-	return false;
+        return false;
     }
 
   return true;
 }
 
 bool
 Matrix::too_large_for_float (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
 
       if (! (xisnan (val) || xisinf (val))
-	  && fabs (val) > FLT_MAX)
-	return true;
+          && fabs (val) > FLT_MAX)
+        return true;
     }
 
   return false;
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
@@ -2851,43 +2851,43 @@ Matrix::row_min (Array<octave_idx_type>&
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       idx_arg.resize (nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
-	  octave_idx_type idx_j;
-
-	  double tmp_min = octave_NaN;
-
-	  for (idx_j = 0; idx_j < nc; idx_j++)
-	    {
-	      tmp_min = elem (i, idx_j);
-
-	      if (! xisnan (tmp_min))
-		break;
-	    }
-
-	  for (octave_idx_type j = idx_j+1; j < nc; j++)
-	    {
-	      double tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (tmp < tmp_min)
-		{
-		  idx_j = j;
-		  tmp_min = tmp;
-		}
-	    }
-
-	  result.elem (i) = tmp_min;
-	  idx_arg.elem (i) = xisnan (tmp_min) ? 0 : idx_j;
+          octave_idx_type idx_j;
+
+          double tmp_min = octave_NaN;
+
+          for (idx_j = 0; idx_j < nc; idx_j++)
+            {
+              tmp_min = elem (i, idx_j);
+
+              if (! xisnan (tmp_min))
+                break;
+            }
+
+          for (octave_idx_type j = idx_j+1; j < nc; j++)
+            {
+              double tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+              else if (tmp < tmp_min)
+                {
+                  idx_j = j;
+                  tmp_min = tmp;
+                }
+            }
+
+          result.elem (i) = tmp_min;
+          idx_arg.elem (i) = xisnan (tmp_min) ? 0 : idx_j;
         }
     }
 
   return result;
 }
 
 ColumnVector
 Matrix::row_max (void) const
@@ -2906,43 +2906,43 @@ Matrix::row_max (Array<octave_idx_type>&
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       idx_arg.resize (nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
-	  octave_idx_type idx_j;
-
-	  double tmp_max = octave_NaN;
-
-	  for (idx_j = 0; idx_j < nc; idx_j++)
-	    {
-	      tmp_max = elem (i, idx_j);
-
-	      if (! xisnan (tmp_max))
-		break;
-	    }
-
-	  for (octave_idx_type j = idx_j+1; j < nc; j++)
-	    {
-	      double tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (tmp > tmp_max)
-		{
-		  idx_j = j;
-		  tmp_max = tmp;
-		}
-	    }
-
-	  result.elem (i) = tmp_max;
-	  idx_arg.elem (i) = xisnan (tmp_max) ? 0 : idx_j;
+          octave_idx_type idx_j;
+
+          double tmp_max = octave_NaN;
+
+          for (idx_j = 0; idx_j < nc; idx_j++)
+            {
+              tmp_max = elem (i, idx_j);
+
+              if (! xisnan (tmp_max))
+                break;
+            }
+
+          for (octave_idx_type j = idx_j+1; j < nc; j++)
+            {
+              double tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+              else if (tmp > tmp_max)
+                {
+                  idx_j = j;
+                  tmp_max = tmp;
+                }
+            }
+
+          result.elem (i) = tmp_max;
+          idx_arg.elem (i) = xisnan (tmp_max) ? 0 : idx_j;
         }
     }
 
   return result;
 }
 
 RowVector
 Matrix::column_min (void) const
@@ -2961,43 +2961,43 @@ Matrix::column_min (Array<octave_idx_typ
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       idx_arg.resize (nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-	  octave_idx_type idx_i;
-
-	  double tmp_min = octave_NaN;
-
-	  for (idx_i = 0; idx_i < nr; idx_i++)
-	    {
-	      tmp_min = elem (idx_i, j);
-
-	      if (! xisnan (tmp_min))
-		break;
-	    }
-
-	  for (octave_idx_type i = idx_i+1; i < nr; i++)
-	    {
-	      double tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (tmp < tmp_min)
-		{
-		  idx_i = i;
-		  tmp_min = tmp;
-		}
-	    }
-
-	  result.elem (j) = tmp_min;
-	  idx_arg.elem (j) = xisnan (tmp_min) ? 0 : idx_i;
+          octave_idx_type idx_i;
+
+          double tmp_min = octave_NaN;
+
+          for (idx_i = 0; idx_i < nr; idx_i++)
+            {
+              tmp_min = elem (idx_i, j);
+
+              if (! xisnan (tmp_min))
+                break;
+            }
+
+          for (octave_idx_type i = idx_i+1; i < nr; i++)
+            {
+              double tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+              else if (tmp < tmp_min)
+                {
+                  idx_i = i;
+                  tmp_min = tmp;
+                }
+            }
+
+          result.elem (j) = tmp_min;
+          idx_arg.elem (j) = xisnan (tmp_min) ? 0 : idx_i;
         }
     }
 
   return result;
 }
 
 RowVector
 Matrix::column_max (void) const
@@ -3016,82 +3016,82 @@ Matrix::column_max (Array<octave_idx_typ
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       idx_arg.resize (nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-	  octave_idx_type idx_i;
-
-	  double tmp_max = octave_NaN;
-
-	  for (idx_i = 0; idx_i < nr; idx_i++)
-	    {
-	      tmp_max = elem (idx_i, j);
-
-	      if (! xisnan (tmp_max))
-		break;
-	    }
-
-	  for (octave_idx_type i = idx_i+1; i < nr; i++)
-	    {
-	      double tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (tmp > tmp_max)
-		{
-		  idx_i = i;
-		  tmp_max = tmp;
-		}
-	    }
-
-	  result.elem (j) = tmp_max;
-	  idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_i;
+          octave_idx_type idx_i;
+
+          double tmp_max = octave_NaN;
+
+          for (idx_i = 0; idx_i < nr; idx_i++)
+            {
+              tmp_max = elem (idx_i, j);
+
+              if (! xisnan (tmp_max))
+                break;
+            }
+
+          for (octave_idx_type i = idx_i+1; i < nr; i++)
+            {
+              double tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+              else if (tmp > tmp_max)
+                {
+                  idx_i = i;
+                  tmp_max = tmp;
+                }
+            }
+
+          result.elem (j) = tmp_max;
+          idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_i;
         }
     }
 
   return result;
 }
 
 std::ostream&
 operator << (std::ostream& os, const Matrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
-	{
-	  os << " ";
-	  octave_write_double (os, a.elem (i, j));
-	}
+        {
+          os << " ";
+          octave_write_double (os, a.elem (i, j));
+        }
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, Matrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr > 0 && nc > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < nr; i++)
-	for (octave_idx_type j = 0; j < nc; j++)
-	  {
-	    tmp = octave_read_value<double> (is);
-	    if (is)
-	      a.elem (i, j) = tmp;
-	    else
-	      goto done;
-	  }
+        for (octave_idx_type j = 0; j < nc; j++)
+          {
+            tmp = octave_read_value<double> (is);
+            if (is)
+              a.elem (i, j) = tmp;
+            else
+              goto done;
+          }
     }
 
  done:
 
   return is;
 }
 
 Matrix
@@ -3143,21 +3143,21 @@ Sylvester (const Matrix& a, const Matrix
   double scale;
   octave_idx_type info;
 
   double *pa = sch_a.fortran_vec ();
   double *pb = sch_b.fortran_vec ();
   double *px = cx.fortran_vec ();
 
   F77_XFCN (dtrsyl, DTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
-			     F77_CONST_CHAR_ARG2 ("N", 1),
-			     1, a_nr, b_nr, pa, a_nr, pb,
-			     b_nr, px, a_nr, scale, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             1, a_nr, b_nr, pa, a_nr, pb,
+                             b_nr, px, a_nr, scale, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
 
   // FIXME -- check info?
   
   retval = -ua*cx*ub.transpose ();
 
   return retval;
 }
@@ -3205,77 +3205,77 @@ xgemm (const Matrix& a, const Matrix& b,
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
     gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
   else
     {
       if (a_nr == 0 || a_nc == 0 || b_nc == 0)
-	retval = Matrix (a_nr, b_nc, 0.0);
+        retval = Matrix (a_nr, b_nc, 0.0);
       else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
         {
-	  octave_idx_type lda = a.rows ();
+          octave_idx_type lda = a.rows ();
 
           retval = Matrix (a_nr, b_nc);
-	  double *c = retval.fortran_vec ();
+          double *c = retval.fortran_vec ();
 
           const char *ctra = get_blas_trans_arg (tra);
           F77_XFCN (dsyrk, DSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (ctra, 1),
                                    a_nr, a_nc, 1.0,
                                    a.data (), lda, 0.0, c, a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
           for (int j = 0; j < a_nr; j++)
             for (int i = 0; i < j; i++)
               retval.xelem (j,i) = retval.xelem (i,j);
 
         }
       else
-	{
-	  octave_idx_type lda = a.rows (), tda = a.cols ();
-	  octave_idx_type ldb = b.rows (), tdb = b.cols ();
-
-	  retval = Matrix (a_nr, b_nc);
-	  double *c = retval.fortran_vec ();
-
-	  if (b_nc == 1)
-	    {
-	      if (a_nr == 1)
-		F77_FUNC (xddot, XDDOT) (a_nc, a.data (), 1, b.data (), 1, *c);
-	      else
-		{
+        {
+          octave_idx_type lda = a.rows (), tda = a.cols ();
+          octave_idx_type ldb = b.rows (), tdb = b.cols ();
+
+          retval = Matrix (a_nr, b_nc);
+          double *c = retval.fortran_vec ();
+
+          if (b_nc == 1)
+            {
+              if (a_nr == 1)
+                F77_FUNC (xddot, XDDOT) (a_nc, a.data (), 1, b.data (), 1, *c);
+              else
+                {
                   const char *ctra = get_blas_trans_arg (tra);
-		  F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 (ctra, 1),
-					   lda, tda, 1.0,  a.data (), lda,
-					   b.data (), 1, 0.0, c, 1
-					   F77_CHAR_ARG_LEN (1)));
-		}
+                  F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 (ctra, 1),
+                                           lda, tda, 1.0,  a.data (), lda,
+                                           b.data (), 1, 0.0, c, 1
+                                           F77_CHAR_ARG_LEN (1)));
+                }
             }
           else if (a_nr == 1)
             {
               const char *crevtrb = get_blas_trans_arg (! trb);
               F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 (crevtrb, 1),
                                        ldb, tdb, 1.0,  b.data (), ldb,
                                        a.data (), 1, 0.0, c, 1
                                        F77_CHAR_ARG_LEN (1)));
             }
-	  else
-	    {
+          else
+            {
               const char *ctra = get_blas_trans_arg (tra);
               const char *ctrb = get_blas_trans_arg (trb);
-	      F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 (ctra, 1),
-				       F77_CONST_CHAR_ARG2 (ctrb, 1),
-				       a_nr, b_nc, a_nc, 1.0, a.data (),
-				       lda, b.data (), ldb, 0.0, c, a_nr
-				       F77_CHAR_ARG_LEN (1)
-				       F77_CHAR_ARG_LEN (1)));
-	    }
-	}
+              F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 (ctra, 1),
+                                       F77_CONST_CHAR_ARG2 (ctrb, 1),
+                                       a_nr, b_nc, a_nc, 1.0, a.data (),
+                                       lda, b.data (), ldb, 0.0, c, a_nr
+                                       F77_CHAR_ARG_LEN (1)
+                                       F77_CHAR_ARG_LEN (1)));
+            }
+        }
     }
 
   return retval;
 }
 
 Matrix
 operator * (const Matrix& a, const Matrix& b)
 {
@@ -3297,18 +3297,18 @@ min (double d, const Matrix& m)
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmin (d, m (i, j));
+        octave_quit ();
+        result (i, j) = xmin (d, m (i, j));
       }
 
   return result;
 }
 
 Matrix
 min (const Matrix& m, double d)
 {
@@ -3317,45 +3317,45 @@ min (const Matrix& m, double d)
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmin (m (i, j), d);
+        octave_quit ();
+        result (i, j) = xmin (m (i, j), d);
       }
 
   return result;
 }
 
 Matrix
 min (const Matrix& a, const Matrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-	("two-arg min expecting args of same size");
+        ("two-arg min expecting args of same size");
       return Matrix ();
     }
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmin (a (i, j), b (i, j));
+        octave_quit ();
+        result (i, j) = xmin (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 Matrix
 max (double d, const Matrix& m)
 {
@@ -3364,18 +3364,18 @@ max (double d, const Matrix& m)
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmax (d, m (i, j));
+        octave_quit ();
+        result (i, j) = xmax (d, m (i, j));
       }
 
   return result;
 }
 
 Matrix
 max (const Matrix& m, double d)
 {
@@ -3384,45 +3384,45 @@ max (const Matrix& m, double d)
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmax (m (i, j), d);
+        octave_quit ();
+        result (i, j) = xmax (m (i, j), d);
       }
 
   return result;
 }
 
 Matrix
 max (const Matrix& a, const Matrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-	("two-arg max expecting args of same size");
+        ("two-arg max expecting args of same size");
       return Matrix ();
     }
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmax (a (i, j), b (i, j));
+        octave_quit ();
+        result (i, j) = xmax (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 Matrix linspace (const ColumnVector& x1, 
                  const ColumnVector& x2, 
                  octave_idx_type n)
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -41,54 +41,54 @@ along with Octave; see the file COPYING.
 #include "mx-base.h"
 #include "mx-op-defs.h"
 #include "oct-fftw.h"
 #include "oct-locbuf.h"
 
 #include "bsxfun-defs.cc"
 
 NDArray::NDArray (const Array<octave_idx_type>& a, bool zero_based,
-		  bool negative_to_nan)
+                  bool negative_to_nan)
 {
   const octave_idx_type *pa = a.fortran_vec ();
   resize (a.dims ());
   double *ptmp = fortran_vec ();
   if (negative_to_nan)
     {
       double nan_val = lo_ieee_nan_value ();
 
       if (zero_based)
-	for (octave_idx_type i = 0; i < a.numel (); i++)
-	  {
-	    double val = static_cast<double> 
-	      (pa[i] + static_cast<octave_idx_type> (1));
-	    if (val <= 0)
-	      ptmp[i] = nan_val;
-	    else
-	      ptmp[i] = val;
-	  }
+        for (octave_idx_type i = 0; i < a.numel (); i++)
+          {
+            double val = static_cast<double> 
+              (pa[i] + static_cast<octave_idx_type> (1));
+            if (val <= 0)
+              ptmp[i] = nan_val;
+            else
+              ptmp[i] = val;
+          }
       else
-	for (octave_idx_type i = 0; i < a.numel (); i++)
-	  {
-	    double val = static_cast<double> (pa[i]);
-	    if (val <= 0)
-	      ptmp[i] = nan_val;
-	    else
-	      ptmp[i] = val;
-	  }
+        for (octave_idx_type i = 0; i < a.numel (); i++)
+          {
+            double val = static_cast<double> (pa[i]);
+            if (val <= 0)
+              ptmp[i] = nan_val;
+            else
+              ptmp[i] = val;
+          }
     }
   else
     {
       if (zero_based)
-	for (octave_idx_type i = 0; i < a.numel (); i++)
-	  ptmp[i] = static_cast<double> 
-	    (pa[i] + static_cast<octave_idx_type> (1));
+        for (octave_idx_type i = 0; i < a.numel (); i++)
+          ptmp[i] = static_cast<double> 
+            (pa[i] + static_cast<octave_idx_type> (1));
       else
-	for (octave_idx_type i = 0; i < a.numel (); i++)
-	  ptmp[i] = static_cast<double> (pa[i]);
+        for (octave_idx_type i = 0; i < a.numel (); i++)
+          ptmp[i] = static_cast<double> (pa[i]);
     }
 }
 
 NDArray::NDArray (const charNDArray& a)
   : MArrayN<double> (a.dims ())
 {
   octave_idx_type n = a.numel ();
   for (octave_idx_type i = 0; i < n; i++)
@@ -118,17 +118,17 @@ NDArray::fourier (int dim) const
 
   const double *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::fft (in + k * stride * n, out + k * stride * n, 
-		      n, howmany, stride, dist);
+                      n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
@@ -148,17 +148,17 @@ NDArray::ifourier (int dim) const
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   ComplexNDArray retval (*this);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::ifft (out + k * stride * n, out + k * stride * n, 
-		      n, howmany, stride, dist);
+                      n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
 {
   dim_vector dv = dims();
@@ -273,27 +273,27 @@ NDArray::fourier (int dim) const
   octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
-	{
-	  octave_quit ();
+        {
+          octave_quit ();
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    tmp[i] = elem((i + k*npts)*stride + j*dist);
+          for (octave_idx_type i = 0; i < npts; i++)
+            tmp[i] = elem((i + k*npts)*stride + j*dist);
 
-	  F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
+          F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    retval ((i + k*npts)*stride + j*dist) = tmp[i];
-	}
+          for (octave_idx_type i = 0; i < npts; i++)
+            retval ((i + k*npts)*stride + j*dist) = tmp[i];
+        }
     }
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier (int dim) const
 {
@@ -320,28 +320,28 @@ NDArray::ifourier (int dim) const
   octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
-	{
-	  octave_quit ();
+        {
+          octave_quit ();
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    tmp[i] = elem((i + k*npts)*stride + j*dist);
+          for (octave_idx_type i = 0; i < npts; i++)
+            tmp[i] = elem((i + k*npts)*stride + j*dist);
 
-	  F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
+          F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    retval ((i + k*npts)*stride + j*dist) = tmp[i] / 
-	      static_cast<double> (npts);
-	}
+          for (octave_idx_type i = 0; i < npts; i++)
+            retval ((i + k*npts)*stride + j*dist) = tmp[i] / 
+              static_cast<double> (npts);
+        }
     }
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
 {
@@ -357,37 +357,37 @@ NDArray::fourier2d (void) const
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
+              F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l];
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l];
+            }
+        }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
 
 ComplexNDArray
@@ -405,38 +405,38 @@ NDArray::ifourier2d (void) const
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
+              F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l] / 
-		  static_cast<double> (npts);
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l] / 
+                  static_cast<double> (npts);
+            }
+        }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
 
 ComplexNDArray
@@ -453,37 +453,37 @@ NDArray::fourierNd (void) const
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
+              F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l];
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l];
+            }
+        }
 
       stride *= dv(i);
     }
 
   return retval;
 }
 
 ComplexNDArray
@@ -500,38 +500,38 @@ NDArray::ifourierNd (void) const
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
+              F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l] /
-		  static_cast<double> (npts);
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                  static_cast<double> (npts);
+            }
+        }
 
       stride *= dv(i);
     }
 
   return retval;
 }
 
 #endif
@@ -547,65 +547,65 @@ NDArray::operator ! (void) const
 bool
 NDArray::any_element_is_negative (bool neg_zero) const
 {
   octave_idx_type nel = nelem ();
 
   if (neg_zero)
     {
       for (octave_idx_type i = 0; i < nel; i++)
-	if (lo_ieee_signbit (elem (i)))
-	  return true;
+        if (lo_ieee_signbit (elem (i)))
+          return true;
     }
   else
     return mx_inline_any_negative (numel (), data ());
 
   return false;
 }
 
 bool
 NDArray::any_element_is_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
       if (xisnan (val))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 NDArray::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
       if (xisinf (val) || xisnan (val))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 NDArray::any_element_not_one_or_zero (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
       if (val != 0 && val != 1)
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 NDArray::all_elements_are_zero (void) const
 {
@@ -622,19 +622,19 @@ bool
 NDArray::all_elements_are_int_or_inf_or_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
       if (xisnan (val) || D_NINT (val) == val)
-	continue;
+        continue;
       else
-	return false;
+        return false;
     }
 
   return true;
 }
 
 // Return nonzero if any element of M is not an integer.  Also extract
 // the largest and smallest values and return them in MAX_VAL and MIN_VAL.
 
@@ -651,56 +651,56 @@ NDArray::all_integers (double& max_val, 
   else
     return false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
 
       if (val > max_val)
-	max_val = val;
+        max_val = val;
 
       if (val < min_val)
-	min_val = val;
+        min_val = val;
 
       if (D_NINT (val) != val)
-	return false;
+        return false;
     }
 
   return true;
 }
 
 bool
 NDArray::all_integers (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
 
       if (D_NINT (val) != val)
-	return false;
+        return false;
     }
 
   return true;
 }
 
 bool
 NDArray::too_large_for_float (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
 
       if (! (xisnan (val) || xisinf (val))
-	  && fabs (val) > FLT_MAX)
-	return true;
+          && fabs (val) > FLT_MAX)
+        return true;
     }
 
   return false;
 }
 
 // FIXME -- this is not quite the right thing.
 
 boolNDArray
@@ -828,32 +828,32 @@ NDArray::concat (const charNDArray& rb, 
   charNDArray retval (dims ());
   octave_idx_type nel = numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double d = elem (i);
 
       if (xisnan (d))
-	{
-	  (*current_liboctave_error_handler)
-	    ("invalid conversion from NaN to character");
-	  return retval;
-	}
+        {
+          (*current_liboctave_error_handler)
+            ("invalid conversion from NaN to character");
+          return retval;
+        }
       else
-	{
-	  octave_idx_type ival = NINTbig (d);
+        {
+          octave_idx_type ival = NINTbig (d);
 
-	  if (ival < 0 || ival > UCHAR_MAX)
-	    // FIXME -- is there something
-	    // better we could do? Should we warn the user?
-	    ival = 0;
+          if (ival < 0 || ival > UCHAR_MAX)
+            // FIXME -- is there something
+            // better we could do? Should we warn the user?
+            ival = 0;
 
-	  retval.elem (i) = static_cast<char>(ival);
-	}
+          retval.elem (i) = static_cast<char>(ival);
+        }
     }
 
   if (rb.numel () == 0)
     return retval;
 
   retval.insert (rb, ra_idx);
   return retval;
 }
@@ -919,25 +919,25 @@ NDArray::matrix_value (void) const
     (*current_liboctave_error_handler)
       ("invalid conversion of NDArray to Matrix");
 
   return retval;
 }
 
 void
 NDArray::increment_index (Array<octave_idx_type>& ra_idx,
-			  const dim_vector& dimensions,
-			  int start_dimension)
+                          const dim_vector& dimensions,
+                          int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
 octave_idx_type
 NDArray::compute_index (Array<octave_idx_type>& ra_idx,
-			const dim_vector& dimensions)
+                        const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 NDArray
 NDArray::diag (octave_idx_type k) const
 {
   return MArrayN<double>::diag (k);
@@ -962,23 +962,23 @@ std::istream&
 operator >> (std::istream& is, NDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < nel; i++)
-	  {
-	    tmp = octave_read_value<double> (is);
-	    if (is)
-	      a.elem (i) = tmp;
-	    else
-	      goto done;
-	  }
+          {
+            tmp = octave_read_value<double> (is);
+            if (is)
+              a.elem (i) = tmp;
+            else
+              goto done;
+          }
     }
 
  done:
 
   return is;
 }
 
 NDArray
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -37,23 +37,23 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgemv, DGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const double&,
-			   const double*, const octave_idx_type&, const double*,
-			   const octave_idx_type&, const double&, double*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, const octave_idx_type&, const double&,
+                           const double*, const octave_idx_type&, const double*,
+                           const octave_idx_type&, const double&, double*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (xddot, XDDOT) (const octave_idx_type&, const double*, const octave_idx_type&,
-			   const double*, const octave_idx_type&, double&);
+                           const double*, const octave_idx_type&, double&);
 }
 
 // Row Vector class.
 
 bool
 RowVector::operator == (const RowVector& a) const
 {
   octave_idx_type len = length ();
@@ -79,33 +79,33 @@ RowVector::insert (const RowVector& a, o
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (c+i) = a.elem (i);
+        xelem (c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 RowVector&
 RowVector::fill (double val)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 RowVector&
 RowVector::fill (double val, octave_idx_type c1, octave_idx_type c2)
 {
@@ -119,17 +119,17 @@ RowVector::fill (double val, octave_idx_
 
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type i = c1; i <= c2; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 RowVector
 RowVector::append (const RowVector& a) const
 {
@@ -205,31 +205,31 @@ operator * (const RowVector& v, const Ma
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
       if (len == 0)
-	retval.resize (a_nc, 0.0);
+        retval.resize (a_nc, 0.0);
       else
-	{
-	  // Transpose A to form A'*x == (x'*A)'
+        {
+          // Transpose A to form A'*x == (x'*A)'
 
-	  octave_idx_type ld = a_nr;
+          octave_idx_type ld = a_nr;
 
-	  retval.resize (a_nc);
-	  double *y = retval.fortran_vec ();
+          retval.resize (a_nc);
+          double *y = retval.fortran_vec ();
 
-	  F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
-				   a_nr, a_nc, 1.0, a.data (),
-				   ld, v.data (), 1, 0.0, y, 1
-				   F77_CHAR_ARG_LEN (1)));
-	}
+          F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
+                                   a_nr, a_nc, 1.0, a.data (),
+                                   ld, v.data (), 1, 0.0, y, 1
+                                   F77_CHAR_ARG_LEN (1)));
+        }
     }
 
   return retval;
 }
 
 // other operations
 
 double
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -62,76 +62,76 @@ along with Octave; see the file COPYING.
 #include "sparse-dmsolve.cc"
 #endif
 
 // Fortran functions we call.
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgbtrf, DGBTRF) (const octave_idx_type&, const octave_idx_type&,
-			     const octave_idx_type&, const octave_idx_type&,
-			     double*, const octave_idx_type&,
-			     octave_idx_type*, octave_idx_type&);
+                             const octave_idx_type&, const octave_idx_type&,
+                             double*, const octave_idx_type&,
+                             octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dgbtrs, DGBTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
-			     const double*, const octave_idx_type&,
-			     const octave_idx_type*, double*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
+                             const double*, const octave_idx_type&,
+                             const octave_idx_type*, double*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgbcon, DGBCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, const octave_idx_type&, double*, 
-			     const octave_idx_type&, const octave_idx_type*, const double&, 
-			     double&, double*, octave_idx_type*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const octave_idx_type&, double*, 
+                             const octave_idx_type&, const octave_idx_type*, const double&, 
+                             double&, double*, octave_idx_type*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dpbtrf, DPBTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dpbtrs, DPBTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, const octave_idx_type&, double*, const octave_idx_type&, 
-			     double*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const octave_idx_type&, double*, const octave_idx_type&, 
+                             double*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dpbcon, DPBCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, double*, const octave_idx_type&, 
-			     const double&, double&, double*, octave_idx_type*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, double*, const octave_idx_type&, 
+                             const double&, double&, double*, octave_idx_type*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (dptsv, DPTSV) (const octave_idx_type&, const octave_idx_type&, double*, double*,
-			   double*, const octave_idx_type&, octave_idx_type&);
+                           double*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dgtsv, DGTSV) (const octave_idx_type&, const octave_idx_type&, double*, double*,
-			   double*, double*, const octave_idx_type&, octave_idx_type&);
+                           double*, double*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dgttrf, DGTTRF) (const octave_idx_type&, double*, double*, double*, double*,
-			     octave_idx_type*, octave_idx_type&);
+                             octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dgttrs, DGTTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     const octave_idx_type&, const double*, const double*,
-			     const double*, const double*, const octave_idx_type*,
-			     double *, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const double*, const double*,
+                             const double*, const double*, const octave_idx_type*,
+                             double *, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zptsv, ZPTSV) (const octave_idx_type&, const octave_idx_type&, double*, Complex*,
-			   Complex*, const octave_idx_type&, octave_idx_type&);
+                           Complex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgtsv, ZGTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
-			   Complex*, Complex*, const octave_idx_type&, octave_idx_type&);
+                           Complex*, Complex*, const octave_idx_type&, octave_idx_type&);
 
 }
 
 SparseMatrix::SparseMatrix (const SparseBoolMatrix &a)
   : MSparse<double> (a.rows (), a.cols (), a.nnz ())
 {
   octave_idx_type nc = cols ();
   octave_idx_type nz = a.nnz ();
@@ -197,17 +197,17 @@ SparseMatrix::operator == (const SparseM
   octave_idx_type nc_a = a.cols ();
   octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx(i) != a.cidx(i))
-	return false;
+        return false;
 
   for (octave_idx_type i = 0; i < nz; i++)
     if (data(i) != a.data(i) || ridx(i) != a.ridx(i))
       return false;
 
   return true;
 }
 
@@ -221,40 +221,40 @@ bool
 SparseMatrix::is_symmetric (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == nc && nr > 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      octave_idx_type ri = ridx(i);
-
-	      if (ri != j)
-		{
-		  bool found = false;
-
-		  for (octave_idx_type k = cidx(ri); k < cidx(ri+1); k++)
-		    {
-		      if (ridx(k) == j)
-			{
-			  if (data(i) == data(k))
-			    found = true;
-			  break;
-			}
-		    }
-
-		  if (! found)
-		    return false;
-		}
-	    }
-	}
+        {
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              octave_idx_type ri = ridx(i);
+
+              if (ri != j)
+                {
+                  bool found = false;
+
+                  for (octave_idx_type k = cidx(ri); k < cidx(ri+1); k++)
+                    {
+                      if (ridx(k) == j)
+                        {
+                          if (data(i) == data(k))
+                            found = true;
+                          break;
+                        }
+                    }
+
+                  if (! found)
+                    return false;
+                }
+            }
+        }
 
       return true;
     }
 
   return false;
 }
 
 SparseMatrix&
@@ -293,133 +293,133 @@ SparseMatrix::max (Array<octave_idx_type
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
       idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  double tmp_max = octave_NaN;
-	  octave_idx_type idx_j = 0;
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      if (ridx(i) != idx_j)
-		break;
-	      else
-		idx_j++;
-	    }
-
-	  if (idx_j != nr)
-	    tmp_max = 0.;
-
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      double tmp = data (i);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (xisnan (tmp_max) || tmp > tmp_max)
-		{
-		  idx_j = ridx (i);
-		  tmp_max = tmp;
-		}
-
-	    }
-
- 	  idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_j;
-	  if (tmp_max != 0.)
-	    nel++;
-	}
+        {
+          double tmp_max = octave_NaN;
+          octave_idx_type idx_j = 0;
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              if (ridx(i) != idx_j)
+                break;
+              else
+                idx_j++;
+            }
+
+          if (idx_j != nr)
+            tmp_max = 0.;
+
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              double tmp = data (i);
+
+              if (xisnan (tmp))
+                continue;
+              else if (xisnan (tmp_max) || tmp > tmp_max)
+                {
+                  idx_j = ridx (i);
+                  tmp_max = tmp;
+                }
+
+            }
+
+          idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_j;
+          if (tmp_max != 0.)
+            nel++;
+        }
 
       result = SparseMatrix (1, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  double tmp = elem (idx_arg(j), j);
-	  if (tmp != 0.)
-	    {
-	      result.xdata (ii) = tmp;
-	      result.xridx (ii++) = 0;
-	    }
-	  result.xcidx (j+1) = ii;
-
-	}
+        {
+          double tmp = elem (idx_arg(j), j);
+          if (tmp != 0.)
+            {
+              result.xdata (ii) = tmp;
+              result.xridx (ii++) = 0;
+            }
+          result.xcidx (j+1) = ii;
+
+        }
     }
   else
     {
       idx_arg.resize_fill (nr, 1, 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
-	idx_arg.elem(ridx(i)) = -1;
+        idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    if (idx_arg.elem(i) != -1)
-	      continue;
-	    bool found = false;
-	    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-	      if (ridx(k) == i)
-		{
-		  found = true;
-		  break;
-		}
-	    
-	    if (!found)
-	      idx_arg.elem(i) = j;
-
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            if (idx_arg.elem(i) != -1)
+              continue;
+            bool found = false;
+            for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
+              if (ridx(k) == i)
+                {
+                  found = true;
+                  break;
+                }
+            
+            if (!found)
+              idx_arg.elem(i) = j;
+
+          }
 
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      octave_idx_type ir = ridx (i);
-	      octave_idx_type ix = idx_arg.elem (ir);
-	      double tmp = data (i);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (ix == -1 || tmp > elem (ir, ix))
-		idx_arg.elem (ir) = j;
-	    }
-	}
+        {
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              octave_idx_type ir = ridx (i);
+              octave_idx_type ix = idx_arg.elem (ir);
+              double tmp = data (i);
+
+              if (xisnan (tmp))
+                continue;
+              else if (ix == -1 || tmp > elem (ir, ix))
+                idx_arg.elem (ir) = j;
+            }
+        }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
-	if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
-	  nel++;
+        if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
+          nel++;
 
       result = SparseMatrix (nr, 1, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
-	{
-	  if (idx_arg(j) == -1)
-	    {
-	      idx_arg(j) = 0;
-	      result.xdata (ii) = octave_NaN;
-	      result.xridx (ii++) = j;
-	    }
-	  else
-	    {
-	      double tmp = elem (j, idx_arg(j));
-	      if (tmp != 0.)
-		{
-		  result.xdata (ii) = tmp;
-		  result.xridx (ii++) = j;
-		}
-	    }
-	}
+        {
+          if (idx_arg(j) == -1)
+            {
+              idx_arg(j) = 0;
+              result.xdata (ii) = octave_NaN;
+              result.xridx (ii++) = j;
+            }
+          else
+            {
+              double tmp = elem (j, idx_arg(j));
+              if (tmp != 0.)
+                {
+                  result.xdata (ii) = tmp;
+                  result.xridx (ii++) = j;
+                }
+            }
+        }
     }
 
   return result;
 }
 
 SparseMatrix
 SparseMatrix::min (int dim) const
 {
@@ -442,133 +442,133 @@ SparseMatrix::min (Array<octave_idx_type
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
       idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  double tmp_min = octave_NaN;
-	  octave_idx_type idx_j = 0;
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      if (ridx(i) != idx_j)
-		break;
-	      else
-		idx_j++;
-	    }
-
-	  if (idx_j != nr)
-	    tmp_min = 0.;
-
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      double tmp = data (i);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (xisnan (tmp_min) || tmp < tmp_min)
-		{
-		  idx_j = ridx (i);
-		  tmp_min = tmp;
-		}
-
-	    }
-
- 	  idx_arg.elem (j) = xisnan (tmp_min) ? 0 : idx_j;
-	  if (tmp_min != 0.)
-	    nel++;
-	}
+        {
+          double tmp_min = octave_NaN;
+          octave_idx_type idx_j = 0;
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              if (ridx(i) != idx_j)
+                break;
+              else
+                idx_j++;
+            }
+
+          if (idx_j != nr)
+            tmp_min = 0.;
+
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              double tmp = data (i);
+
+              if (xisnan (tmp))
+                continue;
+              else if (xisnan (tmp_min) || tmp < tmp_min)
+                {
+                  idx_j = ridx (i);
+                  tmp_min = tmp;
+                }
+
+            }
+
+          idx_arg.elem (j) = xisnan (tmp_min) ? 0 : idx_j;
+          if (tmp_min != 0.)
+            nel++;
+        }
 
       result = SparseMatrix (1, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  double tmp = elem (idx_arg(j), j);
-	  if (tmp != 0.)
-	    {
-	      result.xdata (ii) = tmp;
-	      result.xridx (ii++) = 0;
-	    }
-	  result.xcidx (j+1) = ii;
-
-	}
+        {
+          double tmp = elem (idx_arg(j), j);
+          if (tmp != 0.)
+            {
+              result.xdata (ii) = tmp;
+              result.xridx (ii++) = 0;
+            }
+          result.xcidx (j+1) = ii;
+
+        }
     }
   else
     {
       idx_arg.resize_fill (nr, 1, 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
-	idx_arg.elem(ridx(i)) = -1;
+        idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    if (idx_arg.elem(i) != -1)
-	      continue;
-	    bool found = false;
-	    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-	      if (ridx(k) == i)
-		{
-		  found = true;
-		  break;
-		}
-	    
-	    if (!found)
-	      idx_arg.elem(i) = j;
-
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            if (idx_arg.elem(i) != -1)
+              continue;
+            bool found = false;
+            for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
+              if (ridx(k) == i)
+                {
+                  found = true;
+                  break;
+                }
+            
+            if (!found)
+              idx_arg.elem(i) = j;
+
+          }
 
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      octave_idx_type ir = ridx (i);
-	      octave_idx_type ix = idx_arg.elem (ir);
-	      double tmp = data (i);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (ix == -1 || tmp < elem (ir, ix))
-		idx_arg.elem (ir) = j;
-	    }
-	}
+        {
+          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            {
+              octave_idx_type ir = ridx (i);
+              octave_idx_type ix = idx_arg.elem (ir);
+              double tmp = data (i);
+
+              if (xisnan (tmp))
+                continue;
+              else if (ix == -1 || tmp < elem (ir, ix))
+                idx_arg.elem (ir) = j;
+            }
+        }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
-	if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
-	  nel++;
+        if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
+          nel++;
 
       result = SparseMatrix (nr, 1, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
-	{
-	  if (idx_arg(j) == -1)
-	    {
-	      idx_arg(j) = 0;
-	      result.xdata (ii) = octave_NaN;
-	      result.xridx (ii++) = j;
-	    }
-	  else
-	    {
-	      double tmp = elem (j, idx_arg(j));
-	      if (tmp != 0.)
-		{
-		  result.xdata (ii) = tmp;
-		  result.xridx (ii++) = j;
-		}
-	    }
-	}
+        {
+          if (idx_arg(j) == -1)
+            {
+              idx_arg(j) = 0;
+              result.xdata (ii) = octave_NaN;
+              result.xridx (ii++) = j;
+            }
+          else
+            {
+              double tmp = elem (j, idx_arg(j));
+              if (tmp != 0.)
+                {
+                  result.xdata (ii) = tmp;
+                  result.xridx (ii++) = j;
+                }
+            }
+        }
     }
 
   return result;
 }
 
 RowVector 
 SparseMatrix::row (octave_idx_type i) const
 {
@@ -668,18 +668,18 @@ atan2 (const double& x, const SparseMatr
     return SparseMatrix (nr, nc);
   else
     {
       // Its going to be basically full, so this is probably the
       // best way to handle it.
       Matrix tmp (nr, nc, atan2 (x, 0.));
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = y.cidx (j); i < y.cidx (j+1); i++)
-	  tmp.elem (y.ridx(i), j) = atan2 (x, y.data(i));
+        for (octave_idx_type i = y.cidx (j); i < y.cidx (j+1); i++)
+          tmp.elem (y.ridx(i), j) = atan2 (x, y.data(i));
 
       return SparseMatrix (tmp);
     }
 }
 
 SparseMatrix 
 atan2 (const SparseMatrix& x, const double& y)
 {
@@ -689,37 +689,37 @@ atan2 (const SparseMatrix& x, const doub
 
   SparseMatrix retval (nr, nc, nz);
 
   octave_idx_type ii = 0;
   retval.xcidx(0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = x.cidx(i); j < x.cidx(i+1); j++)
-	{
-	  double tmp = atan2 (x.data(j), y);
-	  if (tmp != 0.)
-	    {
-	      retval.xdata (ii) = tmp;
-	      retval.xridx (ii++) = x.ridx (j);
-	    }
-	}
+        {
+          double tmp = atan2 (x.data(j), y);
+          if (tmp != 0.)
+            {
+              retval.xdata (ii) = tmp;
+              retval.xridx (ii++) = x.ridx (j);
+            }
+        }
       retval.xcidx (i+1) = ii;
     }
 
   if (ii != nz)
     {
       SparseMatrix retval2 (nr, nc, ii);
       for (octave_idx_type i = 0; i < nc+1; i++)
-	retval2.xcidx (i) = retval.cidx (i);
+        retval2.xcidx (i) = retval.cidx (i);
       for (octave_idx_type i = 0; i < ii; i++)
-	{
-	  retval2.xdata (i) = retval.data (i);
-	  retval2.xridx (i) = retval.ridx (i);
-	}
+        {
+          retval2.xdata (i) = retval.data (i);
+          retval2.xridx (i) = retval.ridx (i);
+        }
       return retval2;
     }
   else
     return retval;
 }
 
 SparseMatrix 
 atan2 (const SparseMatrix& x, const SparseMatrix& y)
@@ -730,71 +730,71 @@ atan2 (const SparseMatrix& x, const Spar
     {
       octave_idx_type x_nr = x.rows ();
       octave_idx_type x_nc = x.cols ();
 
       octave_idx_type y_nr = y.rows ();
       octave_idx_type y_nc = y.cols ();
 
       if (x_nr != y_nr || x_nc != y_nc)
-	gripe_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
+        gripe_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
       else
-	{
-	  r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
+        {
+          r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
        
-	  octave_idx_type jx = 0;
-	  r.cidx (0) = 0;
-	  for (octave_idx_type i = 0 ; i < x_nc ; i++)
-	    {
-	      octave_idx_type  ja = x.cidx(i);
-	      octave_idx_type  ja_max = x.cidx(i+1);
-	      bool ja_lt_max= ja < ja_max;
+          octave_idx_type jx = 0;
+          r.cidx (0) = 0;
+          for (octave_idx_type i = 0 ; i < x_nc ; i++)
+            {
+              octave_idx_type  ja = x.cidx(i);
+              octave_idx_type  ja_max = x.cidx(i+1);
+              bool ja_lt_max= ja < ja_max;
            
-	      octave_idx_type  jb = y.cidx(i);
-	      octave_idx_type  jb_max = y.cidx(i+1);
-	      bool jb_lt_max = jb < jb_max;
+              octave_idx_type  jb = y.cidx(i);
+              octave_idx_type  jb_max = y.cidx(i+1);
+              bool jb_lt_max = jb < jb_max;
            
-	      while (ja_lt_max || jb_lt_max )
-		{
-		  octave_quit ();
-		  if ((! jb_lt_max) ||
+              while (ja_lt_max || jb_lt_max )
+                {
+                  octave_quit ();
+                  if ((! jb_lt_max) ||
                       (ja_lt_max && (x.ridx(ja) < y.ridx(jb))))
-		    {
-		      r.ridx(jx) = x.ridx(ja);
-		      r.data(jx) = atan2 (x.data(ja), 0.);
-		      jx++;
-		      ja++;
-		      ja_lt_max= ja < ja_max;
-		    }
-		  else if (( !ja_lt_max ) ||
-			   (jb_lt_max && (y.ridx(jb) < x.ridx(ja)) ) )
-		    {
-		      jb++;
-		      jb_lt_max= jb < jb_max;
-		    }
-		  else
-		    {
-		      double tmp = atan2 (x.data(ja), y.data(jb));
-		      if (tmp != 0.)
-			{
+                    {
+                      r.ridx(jx) = x.ridx(ja);
+                      r.data(jx) = atan2 (x.data(ja), 0.);
+                      jx++;
+                      ja++;
+                      ja_lt_max= ja < ja_max;
+                    }
+                  else if (( !ja_lt_max ) ||
+                           (jb_lt_max && (y.ridx(jb) < x.ridx(ja)) ) )
+                    {
+                      jb++;
+                      jb_lt_max= jb < jb_max;
+                    }
+                  else
+                    {
+                      double tmp = atan2 (x.data(ja), y.data(jb));
+                      if (tmp != 0.)
+                        {
                           r.data(jx) = tmp;
                           r.ridx(jx) = x.ridx(ja);
                           jx++;
-			}
-		      ja++;
-		      ja_lt_max= ja < ja_max;
-		      jb++;
-		      jb_lt_max= jb < jb_max;
-		    }
-		}
-	      r.cidx(i+1) = jx;
-	    }
-	  
-	  r.maybe_compress ();
-	}
+                        }
+                      ja++;
+                      ja_lt_max= ja < ja_max;
+                      jb++;
+                      jb_lt_max= jb < jb_max;
+                    }
+                }
+              r.cidx(i+1) = jx;
+            }
+          
+          r.maybe_compress ();
+        }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
 
 SparseMatrix
@@ -818,348 +818,348 @@ SparseMatrix
 SparseMatrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   double rcond;
   return inverse (mattype, info, rcond, 0, 0);
 }
 
 SparseMatrix 
 SparseMatrix::dinverse (MatrixType &mattyp, octave_idx_type& info, 
-			double& rcond, const bool, 
-			const bool calccond) const
+                        double& rcond, const bool, 
+                        const bool calccond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
       if (typ == MatrixType::Diagonal ||
-	  typ == MatrixType::Permuted_Diagonal)
-	{
-	  if (typ == MatrixType::Permuted_Diagonal)
-	    retval = transpose();
-	  else
-	    retval = *this;
-	      
-	  // Force make_unique to be called
-	  double *v = retval.data();
-
-	  if (calccond)
-	    {
-	      double dmax = 0., dmin = octave_Inf; 
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  double tmp = fabs(v[i]);
-		  if (tmp > dmax)
-		    dmax = tmp;
-		  if (tmp < dmin)
-		    dmin = tmp;
-		}
-	      rcond = dmin / dmax;
-	    }
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    v[i] = 1.0 / v[i];
-	}
+          typ == MatrixType::Permuted_Diagonal)
+        {
+          if (typ == MatrixType::Permuted_Diagonal)
+            retval = transpose();
+          else
+            retval = *this;
+              
+          // Force make_unique to be called
+          double *v = retval.data();
+
+          if (calccond)
+            {
+              double dmax = 0., dmin = octave_Inf; 
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  double tmp = fabs(v[i]);
+                  if (tmp > dmax)
+                    dmax = tmp;
+                  if (tmp < dmin)
+                    dmin = tmp;
+                }
+              rcond = dmin / dmax;
+            }
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            v[i] = 1.0 / v[i];
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix 
 SparseMatrix::tinverse (MatrixType &mattyp, octave_idx_type& info, 
-			double& rcond, const bool, 
-			const bool calccond) const
+                        double& rcond, const bool, 
+                        const bool calccond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
       if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper || 
-	  typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-
-	  if (calccond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  if (typ == MatrixType::Upper || typ == MatrixType::Lower)
-	    {
-	      octave_idx_type nz = nnz ();
-	      octave_idx_type cx = 0;
-	      octave_idx_type nz2 = nz;
-	      retval = SparseMatrix (nr, nc, nz2);
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  octave_quit ();
-		  // place the 1 in the identity position
-		  octave_idx_type cx_colstart = cx;
-	  
-		  if (cx == nz2)
-		    {
-		      nz2 *= 2;
-		      retval.change_capacity (nz2);
-		    }
-
-		  retval.xcidx(i) = cx;
-		  retval.xridx(cx) = i;
-		  retval.xdata(cx) = 1.0;
-		  cx++;
-
-		  // iterate accross columns of input matrix
-		  for (octave_idx_type j = i+1; j < nr; j++) 
-		    {
-		      double v = 0.;
-		      // iterate to calculate sum
-		      octave_idx_type colXp = retval.xcidx(i);
-		      octave_idx_type colUp = cidx(j);
-		      octave_idx_type rpX, rpU;
-
-		      if (cidx(j) == cidx(j+1))
-			{
-			  (*current_liboctave_error_handler) 
-			    ("division by zero");
-			  goto inverse_singular;
-			}
-
-		      do
-			{
-			  octave_quit ();
-			  rpX = retval.xridx(colXp);
-			  rpU = ridx(colUp);
-
-			  if (rpX < rpU) 
-			    colXp++;
-			  else if (rpX > rpU) 
-			    colUp++;
-			  else 
-			    {
-			      v -= retval.xdata(colXp) * data(colUp);
-			      colXp++;
-			      colUp++;
-			    }
-			} while ((rpX<j) && (rpU<j) && 
-				 (colXp<cx) && (colUp<nz));
-
-		      // get A(m,m)
-		      if (typ == MatrixType::Upper)
-			colUp = cidx(j+1) - 1;
-		      else
-			colUp = cidx(j);
-		      double pivot = data(colUp);
-		      if (pivot == 0. || ridx(colUp) != j) 
-			{
-			  (*current_liboctave_error_handler) 
-			    ("division by zero");
-			  goto inverse_singular;
-			}
-
-		      if (v != 0.)
-			{
-			  if (cx == nz2)
-			    {
-			      nz2 *= 2;
-			      retval.change_capacity (nz2);
-			    }
-
-			  retval.xridx(cx) = j;
-			  retval.xdata(cx) = v / pivot;
-			  cx++;
-			}
-		    }
-
-		  // get A(m,m)
-		  octave_idx_type colUp;
-		  if (typ == MatrixType::Upper)
-		    colUp = cidx(i+1) - 1;
-		  else
-		    colUp = cidx(i);
-		  double pivot = data(colUp);
-		  if (pivot == 0. || ridx(colUp) != i) 
-		    {
-		      (*current_liboctave_error_handler) ("division by zero");
-		      goto inverse_singular;
-		    }
-
-		  if (pivot != 1.0)
-		    for (octave_idx_type j = cx_colstart; j < cx; j++)
-		      retval.xdata(j) /= pivot;
-		}
-	      retval.xcidx(nr) = cx;
-	      retval.maybe_compress ();
-	    }
-	  else
-	    {
-	      octave_idx_type nz = nnz ();
-	      octave_idx_type cx = 0;
-	      octave_idx_type nz2 = nz;
-	      retval = SparseMatrix (nr, nc, nz2);
-
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
-
-	      octave_idx_type *perm = mattyp.triangular_perm();
-	      if (typ == MatrixType::Permuted_Upper)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    rperm[perm[i]] = i;
-		}
-	      else
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    rperm[i] = perm[i];
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    perm[rperm[i]] = i;
-		}
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  octave_quit ();
-		  octave_idx_type iidx = rperm[i];
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    work[j] = 0.;
-
-		  // place the 1 in the identity position
-		  work[iidx] = 1.0;
-
-		  // iterate accross columns of input matrix
-		  for (octave_idx_type j = iidx+1; j < nr; j++) 
-		    {
-		      double v = 0.;
-		      octave_idx_type jidx = perm[j];
-		      // iterate to calculate sum
-		      for (octave_idx_type k = cidx(jidx); 
-			   k < cidx(jidx+1); k++)
-			{
-			  octave_quit ();
-			  v -= work[ridx(k)] * data(k);
-			}
-
-		      // get A(m,m)
-		      double pivot;
-		      if (typ == MatrixType::Permuted_Upper)
-			pivot = data(cidx(jidx+1) - 1);
-		      else
-			pivot = data(cidx(jidx));
-		      if (pivot == 0.) 
-			{
-			  (*current_liboctave_error_handler) 
-			    ("division by zero");
-			  goto inverse_singular;
-			}
-
-		      work[j] = v / pivot;
-		    }
-
-		  // get A(m,m)
-		  octave_idx_type colUp;
-		  if (typ == MatrixType::Permuted_Upper)
-		    colUp = cidx(perm[iidx]+1) - 1;
-		  else
-		    colUp = cidx(perm[iidx]);
-
-		  double pivot = data(colUp);
-		  if (pivot == 0.)
-		    {
-		      (*current_liboctave_error_handler) 
-			("division by zero");
-		      goto inverse_singular;
-		    }
-
-		  octave_idx_type new_cx = cx;
-		  for (octave_idx_type j = iidx; j < nr; j++)
-		    if (work[j] != 0.0)
-		      {
-			new_cx++;
-			if (pivot != 1.0)
-			  work[j] /= pivot;
-		      }
-
-		  if (cx < new_cx)
-		    {
-		      nz2 = (2*nz2 < new_cx ? new_cx : 2*nz2);
-		      retval.change_capacity (nz2);
-		    }
-
-		  retval.xcidx(i) = cx;
-		  for (octave_idx_type j = iidx; j < nr; j++)
-		    if (work[j] != 0.)
-		      {
-			retval.xridx(cx) = j;
-			retval.xdata(cx++) = work[j];
-		      }
-		}
-
-	      retval.xcidx(nr) = cx;
-	      retval.maybe_compress ();
-	    }
-
-	  if (calccond)
-	    {
-	      // Calculate the 1-norm of inverse matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = retval.cidx(j); 
-		       i < retval.cidx(j+1); i++)
-		    atmp += fabs(retval.data(i));
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-
-	      rcond = 1. / ainvnorm / anorm;     
-	    }
-	}
+          typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+
+          if (calccond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          if (typ == MatrixType::Upper || typ == MatrixType::Lower)
+            {
+              octave_idx_type nz = nnz ();
+              octave_idx_type cx = 0;
+              octave_idx_type nz2 = nz;
+              retval = SparseMatrix (nr, nc, nz2);
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  octave_quit ();
+                  // place the 1 in the identity position
+                  octave_idx_type cx_colstart = cx;
+          
+                  if (cx == nz2)
+                    {
+                      nz2 *= 2;
+                      retval.change_capacity (nz2);
+                    }
+
+                  retval.xcidx(i) = cx;
+                  retval.xridx(cx) = i;
+                  retval.xdata(cx) = 1.0;
+                  cx++;
+
+                  // iterate accross columns of input matrix
+                  for (octave_idx_type j = i+1; j < nr; j++) 
+                    {
+                      double v = 0.;
+                      // iterate to calculate sum
+                      octave_idx_type colXp = retval.xcidx(i);
+                      octave_idx_type colUp = cidx(j);
+                      octave_idx_type rpX, rpU;
+
+                      if (cidx(j) == cidx(j+1))
+                        {
+                          (*current_liboctave_error_handler) 
+                            ("division by zero");
+                          goto inverse_singular;
+                        }
+
+                      do
+                        {
+                          octave_quit ();
+                          rpX = retval.xridx(colXp);
+                          rpU = ridx(colUp);
+
+                          if (rpX < rpU) 
+                            colXp++;
+                          else if (rpX > rpU) 
+                            colUp++;
+                          else 
+                            {
+                              v -= retval.xdata(colXp) * data(colUp);
+                              colXp++;
+                              colUp++;
+                            }
+                        } while ((rpX<j) && (rpU<j) && 
+                                 (colXp<cx) && (colUp<nz));
+
+                      // get A(m,m)
+                      if (typ == MatrixType::Upper)
+                        colUp = cidx(j+1) - 1;
+                      else
+                        colUp = cidx(j);
+                      double pivot = data(colUp);
+                      if (pivot == 0. || ridx(colUp) != j) 
+                        {
+                          (*current_liboctave_error_handler) 
+                            ("division by zero");
+                          goto inverse_singular;
+                        }
+
+                      if (v != 0.)
+                        {
+                          if (cx == nz2)
+                            {
+                              nz2 *= 2;
+                              retval.change_capacity (nz2);
+                            }
+
+                          retval.xridx(cx) = j;
+                          retval.xdata(cx) = v / pivot;
+                          cx++;
+                        }
+                    }
+
+                  // get A(m,m)
+                  octave_idx_type colUp;
+                  if (typ == MatrixType::Upper)
+                    colUp = cidx(i+1) - 1;
+                  else
+                    colUp = cidx(i);
+                  double pivot = data(colUp);
+                  if (pivot == 0. || ridx(colUp) != i) 
+                    {
+                      (*current_liboctave_error_handler) ("division by zero");
+                      goto inverse_singular;
+                    }
+
+                  if (pivot != 1.0)
+                    for (octave_idx_type j = cx_colstart; j < cx; j++)
+                      retval.xdata(j) /= pivot;
+                }
+              retval.xcidx(nr) = cx;
+              retval.maybe_compress ();
+            }
+          else
+            {
+              octave_idx_type nz = nnz ();
+              octave_idx_type cx = 0;
+              octave_idx_type nz2 = nz;
+              retval = SparseMatrix (nr, nc, nz2);
+
+              OCTAVE_LOCAL_BUFFER (double, work, nr);
+              OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
+
+              octave_idx_type *perm = mattyp.triangular_perm();
+              if (typ == MatrixType::Permuted_Upper)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    rperm[perm[i]] = i;
+                }
+              else
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    rperm[i] = perm[i];
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    perm[rperm[i]] = i;
+                }
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  octave_quit ();
+                  octave_idx_type iidx = rperm[i];
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    work[j] = 0.;
+
+                  // place the 1 in the identity position
+                  work[iidx] = 1.0;
+
+                  // iterate accross columns of input matrix
+                  for (octave_idx_type j = iidx+1; j < nr; j++) 
+                    {
+                      double v = 0.;
+                      octave_idx_type jidx = perm[j];
+                      // iterate to calculate sum
+                      for (octave_idx_type k = cidx(jidx); 
+                           k < cidx(jidx+1); k++)
+                        {
+                          octave_quit ();
+                          v -= work[ridx(k)] * data(k);
+                        }
+
+                      // get A(m,m)
+                      double pivot;
+                      if (typ == MatrixType::Permuted_Upper)
+                        pivot = data(cidx(jidx+1) - 1);
+                      else
+                        pivot = data(cidx(jidx));
+                      if (pivot == 0.) 
+                        {
+                          (*current_liboctave_error_handler) 
+                            ("division by zero");
+                          goto inverse_singular;
+                        }
+
+                      work[j] = v / pivot;
+                    }
+
+                  // get A(m,m)
+                  octave_idx_type colUp;
+                  if (typ == MatrixType::Permuted_Upper)
+                    colUp = cidx(perm[iidx]+1) - 1;
+                  else
+                    colUp = cidx(perm[iidx]);
+
+                  double pivot = data(colUp);
+                  if (pivot == 0.)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("division by zero");
+                      goto inverse_singular;
+                    }
+
+                  octave_idx_type new_cx = cx;
+                  for (octave_idx_type j = iidx; j < nr; j++)
+                    if (work[j] != 0.0)
+                      {
+                        new_cx++;
+                        if (pivot != 1.0)
+                          work[j] /= pivot;
+                      }
+
+                  if (cx < new_cx)
+                    {
+                      nz2 = (2*nz2 < new_cx ? new_cx : 2*nz2);
+                      retval.change_capacity (nz2);
+                    }
+
+                  retval.xcidx(i) = cx;
+                  for (octave_idx_type j = iidx; j < nr; j++)
+                    if (work[j] != 0.)
+                      {
+                        retval.xridx(cx) = j;
+                        retval.xdata(cx++) = work[j];
+                      }
+                }
+
+              retval.xcidx(nr) = cx;
+              retval.maybe_compress ();
+            }
+
+          if (calccond)
+            {
+              // Calculate the 1-norm of inverse matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = retval.cidx(j); 
+                       i < retval.cidx(j+1); i++)
+                    atmp += fabs(retval.data(i));
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
+                }
+
+              rcond = 1. / ainvnorm / anorm;     
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 
  inverse_singular:
   return SparseMatrix();
 }
 
 SparseMatrix
 SparseMatrix::inverse (MatrixType &mattype, octave_idx_type& info, 
-		       double& rcond, int, int calc_cond) const
+                       double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
   SparseMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
@@ -1169,53 +1169,53 @@ SparseMatrix::inverse (MatrixType &matty
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     {
       MatrixType newtype = mattype.transpose();
       ret = transpose().tinverse (newtype, info, rcond, true, calc_cond);
     }
   else
     {
       if (mattype.is_hermitian())
-	{
-	  MatrixType tmp_typ (MatrixType::Upper);
-	  SparseCHOL fact (*this, info, false);
-	  rcond = fact.rcond();
-	  if (info == 0)
-	    {
-	      double rcond2;
-	      SparseMatrix Q = fact.Q();
-	      SparseMatrix InvL = fact.L().transpose().tinverse(tmp_typ,
-					   info, rcond2, true, false);
-	      ret = Q * InvL.transpose() * InvL * Q.transpose();
-	    }
-	  else
-	    {
-	      // Matrix is either singular or not positive definite
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	}
+        {
+          MatrixType tmp_typ (MatrixType::Upper);
+          SparseCHOL fact (*this, info, false);
+          rcond = fact.rcond();
+          if (info == 0)
+            {
+              double rcond2;
+              SparseMatrix Q = fact.Q();
+              SparseMatrix InvL = fact.L().transpose().tinverse(tmp_typ,
+                                           info, rcond2, true, false);
+              ret = Q * InvL.transpose() * InvL * Q.transpose();
+            }
+          else
+            {
+              // Matrix is either singular or not positive definite
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+        }
 
       if (!mattype.is_hermitian())
-	{
-	  octave_idx_type n = rows();
-	  ColumnVector Qinit(n);
-	  for (octave_idx_type i = 0; i < n; i++)
-	    Qinit(i) = i;
-
-	  MatrixType tmp_typ (MatrixType::Upper);
-	  SparseLU fact (*this, Qinit, Matrix(), false, false);
-	  rcond = fact.rcond();
-	  double rcond2;
-	  SparseMatrix InvL = fact.L().transpose().tinverse(tmp_typ, 
-					   info, rcond2, true, false);
-	  SparseMatrix InvU = fact.U().tinverse(tmp_typ, info, rcond2,
-					   true, false).transpose();
-	  ret = fact.Pc().transpose() * InvU * InvL * fact.Pr();
-	}
+        {
+          octave_idx_type n = rows();
+          ColumnVector Qinit(n);
+          for (octave_idx_type i = 0; i < n; i++)
+            Qinit(i) = i;
+
+          MatrixType tmp_typ (MatrixType::Upper);
+          SparseLU fact (*this, Qinit, Matrix(), false, false);
+          rcond = fact.rcond();
+          double rcond2;
+          SparseMatrix InvL = fact.L().transpose().tinverse(tmp_typ, 
+                                           info, rcond2, true, false);
+          SparseMatrix InvU = fact.U().tinverse(tmp_typ, info, rcond2,
+                                           true, false).transpose();
+          ret = fact.Pc().transpose() * InvU * InvL * fact.Pr();
+        }
     }
 
   return ret;
 }
 
 DET
 SparseMatrix::determinant (void) const
 {
@@ -1250,112 +1250,112 @@ SparseMatrix::determinant (octave_idx_ty
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_DNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
       if (!xisnan (tmp))
-	Control (UMFPACK_PRL) = tmp;
+        Control (UMFPACK_PRL) = tmp;
 
       tmp = octave_sparse_params::get_key ("piv_tol");
       if (!xisnan (tmp))
-	{
-	  Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
-	  Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
-	}
+        {
+          Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+          Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+        }
 
       // Set whether we are allowed to modify Q or not
       tmp = octave_sparse_params::get_key ("autoamd");
       if (!xisnan (tmp))
-	Control (UMFPACK_FIXQ) = tmp;
+        Control (UMFPACK_FIXQ) = tmp;
 
       // Turn-off UMFPACK scaling for LU 
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_DNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
       const octave_idx_type *Ai = ridx ();
       const double *Ax = data ();
 
       UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, 
-					 Ax, 0, &Symbolic, control, info);
+                                         Ax, 0, &Symbolic, control, info);
 
       if (status < 0)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("SparseMatrix::determinant symbolic factorization failed");
-
-	  UMFPACK_DNAME (report_status) (control, status);
-	  UMFPACK_DNAME (report_info) (control, info);
-
-	  UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("SparseMatrix::determinant symbolic factorization failed");
+
+          UMFPACK_DNAME (report_status) (control, status);
+          UMFPACK_DNAME (report_info) (control, info);
+
+          UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
+        }
       else
-	{
-	  UMFPACK_DNAME (report_symbolic) (Symbolic, control);
-
-	  void *Numeric;
-	  status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic, 
-				       &Numeric, control, info) ;
-	  UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
-
-	  rcond = Info (UMFPACK_RCOND);
-
-	  if (status < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("SparseMatrix::determinant numeric factorization failed");
-
-	      UMFPACK_DNAME (report_status) (control, status);
-	      UMFPACK_DNAME (report_info) (control, info);
-
-	      UMFPACK_DNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    {
-	      UMFPACK_DNAME (report_numeric) (Numeric, control);
-
-	      double c10, e10;
-
-	      status = UMFPACK_DNAME (get_determinant) (&c10, &e10, Numeric, info);
-
-	      if (status < 0)
-		{
-		  (*current_liboctave_error_handler) 
-		    ("SparseMatrix::determinant error calculating determinant");
-		  
-		  UMFPACK_DNAME (report_status) (control, status);
-		  UMFPACK_DNAME (report_info) (control, info);
-		}
-	      else
-		retval = DET (c10, e10, 10);
-
-	      UMFPACK_DNAME (free_numeric) (&Numeric);
-	    }
-	}
+        {
+          UMFPACK_DNAME (report_symbolic) (Symbolic, control);
+
+          void *Numeric;
+          status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic, 
+                                       &Numeric, control, info) ;
+          UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
+
+          rcond = Info (UMFPACK_RCOND);
+
+          if (status < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("SparseMatrix::determinant numeric factorization failed");
+
+              UMFPACK_DNAME (report_status) (control, status);
+              UMFPACK_DNAME (report_info) (control, info);
+
+              UMFPACK_DNAME (free_numeric) (&Numeric);
+            }
+          else
+            {
+              UMFPACK_DNAME (report_numeric) (Numeric, control);
+
+              double c10, e10;
+
+              status = UMFPACK_DNAME (get_determinant) (&c10, &e10, Numeric, info);
+
+              if (status < 0)
+                {
+                  (*current_liboctave_error_handler) 
+                    ("SparseMatrix::determinant error calculating determinant");
+                  
+                  UMFPACK_DNAME (report_status) (control, status);
+                  UMFPACK_DNAME (report_info) (control, info);
+                }
+              else
+                retval = DET (c10, e10, 10);
+
+              UMFPACK_DNAME (free_numeric) (&Numeric);
+            }
+        }
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return retval;
 }
 
 Matrix
 SparseMatrix::dsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& err,
-		      double& rcond, solve_singularity_handler, 
-		      bool calc_cond) const
+                      double& rcond, solve_singularity_handler, 
+                      bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1366,56 +1366,56 @@ SparseMatrix::dsolve (MatrixType &mattyp
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
-	  typ == MatrixType::Permuted_Diagonal)
-	{
-	  retval.resize (nc, b.cols(), 0.);
-	  if (typ == MatrixType::Diagonal)
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		retval(i,j) = b(i,j) / data (i);
-	  else
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type k = 0; k < nc; k++)
-		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-		  retval(k,j) = b(ridx(i),j) / data (i);
-
-	  if (calc_cond)
-	    {
-	      double dmax = 0., dmin = octave_Inf; 
-	      for (octave_idx_type i = 0; i < nm; i++)
-		{
-		  double tmp = fabs(data(i));
-		  if (tmp > dmax)
-		    dmax = tmp;
-		  if (tmp < dmin)
-		    dmin = tmp;
-		}
-	      rcond = dmin / dmax;
-	    }
-	  else
-	    rcond = 1.;
-	}
+          typ == MatrixType::Permuted_Diagonal)
+        {
+          retval.resize (nc, b.cols(), 0.);
+          if (typ == MatrixType::Diagonal)
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+              for (octave_idx_type i = 0; i < nm; i++)
+                retval(i,j) = b(i,j) / data (i);
+          else
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+              for (octave_idx_type k = 0; k < nc; k++)
+                for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                  retval(k,j) = b(ridx(i),j) / data (i);
+
+          if (calc_cond)
+            {
+              double dmax = 0., dmin = octave_Inf; 
+              for (octave_idx_type i = 0; i < nm; i++)
+                {
+                  double tmp = fabs(data(i));
+                  if (tmp > dmax)
+                    dmax = tmp;
+                  if (tmp < dmin)
+                    dmin = tmp;
+                }
+              rcond = dmin / dmax;
+            }
+          else
+            rcond = 1.;
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::dsolve (MatrixType &mattype, const SparseMatrix& b, 
-		      octave_idx_type& err, double& rcond, 
-		      solve_singularity_handler, bool calc_cond) const
+                      octave_idx_type& err, double& rcond, 
+                      solve_singularity_handler, bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1426,86 +1426,86 @@ SparseMatrix::dsolve (MatrixType &mattyp
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
-	  typ == MatrixType::Permuted_Diagonal)
-	{
-	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
-	  retval = SparseMatrix (nc, b_nc, b_nz);
-
-	  retval.xcidx(0) = 0;
-	  octave_idx_type ii = 0;
-	  if (typ == MatrixType::Diagonal)
-	    for (octave_idx_type j = 0; j < b_nc; j++)
-	      {
-		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		  {
-		    if (b.ridx(i) >= nm)
-		      break;
-		    retval.xridx (ii) = b.ridx(i);
-		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
-		  }
-		retval.xcidx(j+1) = ii;
-	      }
-	  else
-	    for (octave_idx_type j = 0; j < b_nc; j++)
-	      {
-		for (octave_idx_type l = 0; l < nc; l++)
-		  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
-		    {
-		      bool found = false;
-		      octave_idx_type k;
-		      for (k = b.cidx(j); k < b.cidx(j+1); k++)
-			if (ridx(i) == b.ridx(k))
-			  {
-			    found = true;
-			    break;
-			  }
-		      if (found)
-			{
-			  retval.xridx (ii) = l;
-			  retval.xdata (ii++) = b.data(k) / data (i);
-			}
-		    }
-		retval.xcidx(j+1) = ii;
-	      }
-
-	  if (calc_cond)
-	    {
-	      double dmax = 0., dmin = octave_Inf; 
-	      for (octave_idx_type i = 0; i < nm; i++)
-		{
-		  double tmp = fabs(data(i));
-		  if (tmp > dmax)
-		    dmax = tmp;
-		  if (tmp < dmin)
-		    dmin = tmp;
-		}
-	      rcond = dmin / dmax;
-	    }
-	  else
-	    rcond = 1.;
-	}
+          typ == MatrixType::Permuted_Diagonal)
+        {
+          octave_idx_type b_nc = b.cols ();
+          octave_idx_type b_nz = b.nnz ();
+          retval = SparseMatrix (nc, b_nc, b_nz);
+
+          retval.xcidx(0) = 0;
+          octave_idx_type ii = 0;
+          if (typ == MatrixType::Diagonal)
+            for (octave_idx_type j = 0; j < b_nc; j++)
+              {
+                for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                  {
+                    if (b.ridx(i) >= nm)
+                      break;
+                    retval.xridx (ii) = b.ridx(i);
+                    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
+                  }
+                retval.xcidx(j+1) = ii;
+              }
+          else
+            for (octave_idx_type j = 0; j < b_nc; j++)
+              {
+                for (octave_idx_type l = 0; l < nc; l++)
+                  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+                    {
+                      bool found = false;
+                      octave_idx_type k;
+                      for (k = b.cidx(j); k < b.cidx(j+1); k++)
+                        if (ridx(i) == b.ridx(k))
+                          {
+                            found = true;
+                            break;
+                          }
+                      if (found)
+                        {
+                          retval.xridx (ii) = l;
+                          retval.xdata (ii++) = b.data(k) / data (i);
+                        }
+                    }
+                retval.xcidx(j+1) = ii;
+              }
+
+          if (calc_cond)
+            {
+              double dmax = 0., dmin = octave_Inf; 
+              for (octave_idx_type i = 0; i < nm; i++)
+                {
+                  double tmp = fabs(data(i));
+                  if (tmp > dmax)
+                    dmax = tmp;
+                  if (tmp < dmin)
+                    dmin = tmp;
+                }
+              rcond = dmin / dmax;
+            }
+          else
+            rcond = 1.;
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::dsolve (MatrixType &mattype, const ComplexMatrix& b,
-		      octave_idx_type& err, double& rcond,
-		      solve_singularity_handler, bool calc_cond) const
+                      octave_idx_type& err, double& rcond,
+                      solve_singularity_handler, bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1516,56 +1516,56 @@ SparseMatrix::dsolve (MatrixType &mattyp
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
-	  typ == MatrixType::Permuted_Diagonal)
-	{
-	  retval.resize (nc, b.cols(), 0);
-	  if (typ == MatrixType::Diagonal)
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-		for (octave_idx_type i = 0; i < nm; i++)
-		  retval(i,j) = b(i,j) / data (i);
-	  else
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type k = 0; k < nc; k++)
-		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-		  retval(k,j) = b(ridx(i),j) / data (i);
-	    
-	  if (calc_cond)
-	    {
-	      double dmax = 0., dmin = octave_Inf; 
-	      for (octave_idx_type i = 0; i < nm; i++)
-		{
-		  double tmp = fabs(data(i));
-		  if (tmp > dmax)
-		    dmax = tmp;
-		  if (tmp < dmin)
-		    dmin = tmp;
-		}
-	      rcond = dmin / dmax;
-	    }
-	  else
-	    rcond = 1.;
-	}
+          typ == MatrixType::Permuted_Diagonal)
+        {
+          retval.resize (nc, b.cols(), 0);
+          if (typ == MatrixType::Diagonal)
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+                for (octave_idx_type i = 0; i < nm; i++)
+                  retval(i,j) = b(i,j) / data (i);
+          else
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+              for (octave_idx_type k = 0; k < nc; k++)
+                for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                  retval(k,j) = b(ridx(i),j) / data (i);
+            
+          if (calc_cond)
+            {
+              double dmax = 0., dmin = octave_Inf; 
+              for (octave_idx_type i = 0; i < nm; i++)
+                {
+                  double tmp = fabs(data(i));
+                  if (tmp > dmax)
+                    dmax = tmp;
+                  if (tmp < dmin)
+                    dmin = tmp;
+                }
+              rcond = dmin / dmax;
+            }
+          else
+            rcond = 1.;
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::dsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler, bool calc_cond) const
+                     octave_idx_type& err, double& rcond, 
+                     solve_singularity_handler, bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1576,87 +1576,87 @@ SparseMatrix::dsolve (MatrixType &mattyp
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
-	  typ == MatrixType::Permuted_Diagonal)
-	{
-	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
-	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
-
-	  retval.xcidx(0) = 0;
-	  octave_idx_type ii = 0;
-	  if (typ == MatrixType::Diagonal)
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      {
-		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		  {
-		    if (b.ridx(i) >= nm)
-		      break;
-		    retval.xridx (ii) = b.ridx(i);
-		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
-		  }
-		retval.xcidx(j+1) = ii;
-	      }
-	  else
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      {
-		for (octave_idx_type l = 0; l < nc; l++)
-		  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
-		    {
-		      bool found = false;
-		      octave_idx_type k;
-		      for (k = b.cidx(j); k < b.cidx(j+1); k++)
-			if (ridx(i) == b.ridx(k))
-			  {
-			    found = true;
-			    break;
-			  }
-		      if (found)
-			{
-			  retval.xridx (ii) = l;
-			  retval.xdata (ii++) = b.data(k) / data (i);
-			}
-		    }
-		retval.xcidx(j+1) = ii;
-	      }
-	    
-	  if (calc_cond)
-	    {
-	      double dmax = 0., dmin = octave_Inf; 
-	      for (octave_idx_type i = 0; i < nm; i++)
-		{
-		  double tmp = fabs(data(i));
-		  if (tmp > dmax)
-		    dmax = tmp;
-		  if (tmp < dmin)
-		    dmin = tmp;
-		}
-	      rcond = dmin / dmax;
-	    }
-	  else
-	    rcond = 1.;
-	}
+          typ == MatrixType::Permuted_Diagonal)
+        {
+          octave_idx_type b_nc = b.cols ();
+          octave_idx_type b_nz = b.nnz ();
+          retval = SparseComplexMatrix (nc, b_nc, b_nz);
+
+          retval.xcidx(0) = 0;
+          octave_idx_type ii = 0;
+          if (typ == MatrixType::Diagonal)
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+              {
+                for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                  {
+                    if (b.ridx(i) >= nm)
+                      break;
+                    retval.xridx (ii) = b.ridx(i);
+                    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
+                  }
+                retval.xcidx(j+1) = ii;
+              }
+          else
+            for (octave_idx_type j = 0; j < b.cols(); j++)
+              {
+                for (octave_idx_type l = 0; l < nc; l++)
+                  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+                    {
+                      bool found = false;
+                      octave_idx_type k;
+                      for (k = b.cidx(j); k < b.cidx(j+1); k++)
+                        if (ridx(i) == b.ridx(k))
+                          {
+                            found = true;
+                            break;
+                          }
+                      if (found)
+                        {
+                          retval.xridx (ii) = l;
+                          retval.xdata (ii++) = b.data(k) / data (i);
+                        }
+                    }
+                retval.xcidx(j+1) = ii;
+              }
+            
+          if (calc_cond)
+            {
+              double dmax = 0., dmin = octave_Inf; 
+              for (octave_idx_type i = 0; i < nm; i++)
+                {
+                  double tmp = fabs(data(i));
+                  if (tmp > dmax)
+                    dmax = tmp;
+                  if (tmp < dmin)
+                    dmin = tmp;
+                }
+              rcond = dmin / dmax;
+            }
+          else
+            rcond = 1.;
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 SparseMatrix::utsolve (MatrixType &mattype, const Matrix& b,
-		       octave_idx_type& err, double& rcond,
-		       solve_singularity_handler sing_handler, 
-		       bool calc_cond) const
+                       octave_idx_type& err, double& rcond,
+                       solve_singularity_handler sing_handler, 
+                       bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -1667,231 +1667,231 @@ SparseMatrix::utsolve (MatrixType &matty
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Upper)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  if (typ == MatrixType::Permuted_Upper)
-	    {
-	      retval.resize (nc, b_nc);
-	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
-		  for (octave_idx_type i = nr; i < nc; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      octave_idx_type kidx = perm[k];
-
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(kidx+1)-1) != k ||
-			      data(cidx(kidx+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  double tmp = work[k] / data(cidx(kidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(kidx); 
-			       i < cidx(kidx+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval.xelem (perm[i], j) = work[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  octave_idx_type iidx = perm[k];
-
-			  if (work[k] != 0.)
-			    {
-			      double tmp = work[k] / data(cidx(iidx+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(iidx); 
-				   i < cidx(iidx+1)-1; i++)
-				{
-				  octave_idx_type idx2 = ridx(i);
-				  work[idx2] = work[idx2] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-	      retval.resize (nc, b_nc);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
-		  for (octave_idx_type i = nr; i < nc; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(k+1)-1) != k ||
-			      data(cidx(k+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  double tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval.xelem (i, j) = work[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  if (work[k] != 0.)
-			    {
-			      double tmp = work[k] / data(cidx(k+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Upper)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          octave_idx_type b_nc = b.cols ();
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          if (typ == MatrixType::Permuted_Upper)
+            {
+              retval.resize (nc, b_nc);
+              octave_idx_type *perm = mattype.triangular_perm ();
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[i] = b(i,j);
+                  for (octave_idx_type i = nr; i < nc; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      octave_idx_type kidx = perm[k];
+
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(kidx+1)-1) != k ||
+                              data(cidx(kidx+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          double tmp = work[k] / data(cidx(kidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(kidx); 
+                               i < cidx(kidx+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval.xelem (perm[i], j) = work[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          octave_idx_type iidx = perm[k];
+
+                          if (work[k] != 0.)
+                            {
+                              double tmp = work[k] / data(cidx(iidx+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(iidx); 
+                                   i < cidx(iidx+1)-1; i++)
+                                {
+                                  octave_idx_type idx2 = ridx(i);
+                                  work[idx2] = work[idx2] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+              retval.resize (nc, b_nc);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[i] = b(i,j);
+                  for (octave_idx_type i = nr; i < nc; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(k+1)-1) != k ||
+                              data(cidx(k+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          double tmp = work[k] / data(cidx(k+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval.xelem (i, j) = work[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              double tmp = work[k] / data(cidx(k+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::utsolve (MatrixType &mattype, const SparseMatrix& b,
-		       octave_idx_type& err, double& rcond, 
-		       solve_singularity_handler sing_handler,
-		       bool calc_cond) const
+                       octave_idx_type& err, double& rcond, 
+                       solve_singularity_handler sing_handler,
+                       bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -1902,283 +1902,283 @@ SparseMatrix::utsolve (MatrixType &matty
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Upper)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
-	  retval = SparseMatrix (nc, b_nc, b_nz);
-	  retval.xcidx(0) = 0;
-	  octave_idx_type ii = 0;
-	  octave_idx_type x_nz = b_nz;
-
-	  if (typ == MatrixType::Permuted_Upper)
-	    {
-	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
-	      for (octave_idx_type i = 0; i < nc; i++)
-		rperm[perm[i]] = i;
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      octave_idx_type kidx = perm[k];
-
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(kidx+1)-1) != k ||
-			      data(cidx(kidx+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  double tmp = work[k] / data(cidx(kidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(kidx); 
-			       i < cidx(kidx+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[rperm[i]] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[rperm[i]];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  octave_idx_type iidx = perm[k];
-
-			  if (work[k] != 0.)
-			    {
-			      double tmp = work[k] / data(cidx(iidx+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(iidx); 
-				   i < cidx(iidx+1)-1; i++)
-				{
-				  octave_idx_type idx2 = ridx(i);
-				  work[idx2] = work[idx2] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(k+1)-1) != k ||
-			      data(cidx(k+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  double tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  if (work[k] != 0.)
-			    {
-			      double tmp = work[k] / data(cidx(k+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1)-1; i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Upper)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          octave_idx_type b_nc = b.cols ();
+          octave_idx_type b_nz = b.nnz ();
+          retval = SparseMatrix (nc, b_nc, b_nz);
+          retval.xcidx(0) = 0;
+          octave_idx_type ii = 0;
+          octave_idx_type x_nz = b_nz;
+
+          if (typ == MatrixType::Permuted_Upper)
+            {
+              octave_idx_type *perm = mattype.triangular_perm ();
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+
+              OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
+              for (octave_idx_type i = 0; i < nc; i++)
+                rperm[perm[i]] = i;
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[b.ridx(i)] = b.data(i);
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      octave_idx_type kidx = perm[k];
+
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(kidx+1)-1) != k ||
+                              data(cidx(kidx+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          double tmp = work[k] / data(cidx(kidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(kidx); 
+                               i < cidx(kidx+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[rperm[i]] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[rperm[i]];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          octave_idx_type iidx = perm[k];
+
+                          if (work[k] != 0.)
+                            {
+                              double tmp = work[k] / data(cidx(iidx+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(iidx); 
+                                   i < cidx(iidx+1)-1; i++)
+                                {
+                                  octave_idx_type idx2 = ridx(i);
+                                  work[idx2] = work[idx2] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[b.ridx(i)] = b.data(i);
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(k+1)-1) != k ||
+                              data(cidx(k+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          double tmp = work[k] / data(cidx(k+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              double tmp = work[k] / data(cidx(k+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1)-1; i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b, 
-		       octave_idx_type& err, double& rcond, 
-		       solve_singularity_handler sing_handler,
-		       bool calc_cond) const
+                       octave_idx_type& err, double& rcond, 
+                       solve_singularity_handler sing_handler,
+                       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2189,234 +2189,234 @@ SparseMatrix::utsolve (MatrixType &matty
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Upper)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  if (typ == MatrixType::Permuted_Upper)
-	    {
-	      retval.resize (nc, b_nc);
-	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    cwork[i] = b(i,j);
-		  for (octave_idx_type i = nr; i < nc; i++)
-		    cwork[i] = 0.;
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      octave_idx_type kidx = perm[k];
-
-		      if (cwork[k] != 0.)
-			{
-			  if (ridx(cidx(kidx+1)-1) != k ||
-			      data(cidx(kidx+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
-			  cwork[k] = tmp;
-			  for (octave_idx_type i = cidx(kidx); 
-			       i < cidx(kidx+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      cwork[iidx] = cwork[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval.xelem (perm[i], j) = cwork[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  OCTAVE_LOCAL_BUFFER (double, work, nm);
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  octave_idx_type iidx = perm[k];
-
-			  if (work[k] != 0.)
-			    {
-			      double tmp = work[k] / data(cidx(iidx+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(iidx); 
-				   i < cidx(iidx+1)-1; i++)
-				{
-				  octave_idx_type idx2 = ridx(i);
-				  work[idx2] = work[idx2] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-	      retval.resize (nc, b_nc);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    cwork[i] = b(i,j);
-		  for (octave_idx_type i = nr; i < nc; i++)
-		    cwork[i] = 0.;
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      if (cwork[k] != 0.)
-			{
-			  if (ridx(cidx(k+1)-1) != k ||
-			      data(cidx(k+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = cwork[k] / data(cidx(k+1)-1);
-			  cwork[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      cwork[iidx] = cwork[iidx] - tmp  * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval.xelem (i, j) = cwork[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  OCTAVE_LOCAL_BUFFER (double, work, nm);
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  if (work[k] != 0.)
-			    {
-			      double tmp = work[k] / data(cidx(k+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1)-1; i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Upper)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          octave_idx_type b_nc = b.cols ();
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          if (typ == MatrixType::Permuted_Upper)
+            {
+              retval.resize (nc, b_nc);
+              octave_idx_type *perm = mattype.triangular_perm ();
+              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    cwork[i] = b(i,j);
+                  for (octave_idx_type i = nr; i < nc; i++)
+                    cwork[i] = 0.;
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      octave_idx_type kidx = perm[k];
+
+                      if (cwork[k] != 0.)
+                        {
+                          if (ridx(cidx(kidx+1)-1) != k ||
+                              data(cidx(kidx+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
+                          cwork[k] = tmp;
+                          for (octave_idx_type i = cidx(kidx); 
+                               i < cidx(kidx+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval.xelem (perm[i], j) = cwork[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  OCTAVE_LOCAL_BUFFER (double, work, nm);
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          octave_idx_type iidx = perm[k];
+
+                          if (work[k] != 0.)
+                            {
+                              double tmp = work[k] / data(cidx(iidx+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(iidx); 
+                                   i < cidx(iidx+1)-1; i++)
+                                {
+                                  octave_idx_type idx2 = ridx(i);
+                                  work[idx2] = work[idx2] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+              retval.resize (nc, b_nc);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    cwork[i] = b(i,j);
+                  for (octave_idx_type i = nr; i < nc; i++)
+                    cwork[i] = 0.;
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      if (cwork[k] != 0.)
+                        {
+                          if (ridx(cidx(k+1)-1) != k ||
+                              data(cidx(k+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = cwork[k] / data(cidx(k+1)-1);
+                          cwork[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              cwork[iidx] = cwork[iidx] - tmp  * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval.xelem (i, j) = cwork[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  OCTAVE_LOCAL_BUFFER (double, work, nm);
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              double tmp = work[k] / data(cidx(k+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1)-1; i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::utsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-		       octave_idx_type& err, double& rcond, 
-		       solve_singularity_handler sing_handler,
-		       bool calc_cond) const
+                       octave_idx_type& err, double& rcond, 
+                       solve_singularity_handler sing_handler,
+                       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2427,286 +2427,286 @@ SparseMatrix::utsolve (MatrixType &matty
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Upper)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
-	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
-	  retval.xcidx(0) = 0;
-	  octave_idx_type ii = 0;
-	  octave_idx_type x_nz = b_nz;
-
-	  if (typ == MatrixType::Permuted_Upper)
-	    {
-	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
-	      for (octave_idx_type i = 0; i < nc; i++)
-		rperm[perm[i]] = i;
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    cwork[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    cwork[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      octave_idx_type kidx = perm[k];
-
-		      if (cwork[k] != 0.)
-			{
-			  if (ridx(cidx(kidx+1)-1) != k ||
-			      data(cidx(kidx+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
-			  cwork[k] = tmp;
-			  for (octave_idx_type i = cidx(kidx); 
-			       i < cidx(kidx+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      cwork[iidx] = cwork[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (cwork[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (cwork[rperm[i]] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = cwork[rperm[i]];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  OCTAVE_LOCAL_BUFFER (double, work, nm);
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  octave_idx_type iidx = perm[k];
-
-			  if (work[k] != 0.)
-			    {
-			      double tmp = work[k] / data(cidx(iidx+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(iidx); 
-				   i < cidx(iidx+1)-1; i++)
-				{
-				  octave_idx_type idx2 = ridx(i);
-				  work[idx2] = work[idx2] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    cwork[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    cwork[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = nc-1; k >= 0; k--)
-		    {
-		      if (cwork[k] != 0.)
-			{
-			  if (ridx(cidx(k+1)-1) != k ||
-			      data(cidx(k+1)-1) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = cwork[k] / data(cidx(k+1)-1);
-			  cwork[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      cwork[iidx] = cwork[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (cwork[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (cwork[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = cwork[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  OCTAVE_LOCAL_BUFFER (double, work, nm);
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k >= 0; k--)
-			{
-			  if (work[k] != 0.)
-			    {
-			      double tmp = work[k] / data(cidx(k+1)-1);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1)-1; i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = 0; i < j+1; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Upper)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          octave_idx_type b_nc = b.cols ();
+          octave_idx_type b_nz = b.nnz ();
+          retval = SparseComplexMatrix (nc, b_nc, b_nz);
+          retval.xcidx(0) = 0;
+          octave_idx_type ii = 0;
+          octave_idx_type x_nz = b_nz;
+
+          if (typ == MatrixType::Permuted_Upper)
+            {
+              octave_idx_type *perm = mattype.triangular_perm ();
+              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+
+              OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
+              for (octave_idx_type i = 0; i < nc; i++)
+                rperm[perm[i]] = i;
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    cwork[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    cwork[b.ridx(i)] = b.data(i);
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      octave_idx_type kidx = perm[k];
+
+                      if (cwork[k] != 0.)
+                        {
+                          if (ridx(cidx(kidx+1)-1) != k ||
+                              data(cidx(kidx+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
+                          cwork[k] = tmp;
+                          for (octave_idx_type i = cidx(kidx); 
+                               i < cidx(kidx+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (cwork[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (cwork[rperm[i]] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = cwork[rperm[i]];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  OCTAVE_LOCAL_BUFFER (double, work, nm);
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          octave_idx_type iidx = perm[k];
+
+                          if (work[k] != 0.)
+                            {
+                              double tmp = work[k] / data(cidx(iidx+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(iidx); 
+                                   i < cidx(iidx+1)-1; i++)
+                                {
+                                  octave_idx_type idx2 = ridx(i);
+                                  work[idx2] = work[idx2] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    cwork[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    cwork[b.ridx(i)] = b.data(i);
+
+                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                    {
+                      if (cwork[k] != 0.)
+                        {
+                          if (ridx(cidx(k+1)-1) != k ||
+                              data(cidx(k+1)-1) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = cwork[k] / data(cidx(k+1)-1);
+                          cwork[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (cwork[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (cwork[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = cwork[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  OCTAVE_LOCAL_BUFFER (double, work, nm);
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k >= 0; k--)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              double tmp = work[k] / data(cidx(k+1)-1);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1)-1; i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = 0; i < j+1; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 SparseMatrix::ltsolve (MatrixType &mattype, const Matrix& b,
-		       octave_idx_type& err, double& rcond,
-		       solve_singularity_handler sing_handler,
-		       bool calc_cond) const
+                       octave_idx_type& err, double& rcond,
+                       solve_singularity_handler sing_handler,
+                       bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2717,256 +2717,256 @@ SparseMatrix::ltsolve (MatrixType &matty
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
-	  typ == MatrixType::Lower)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  if (typ == MatrixType::Permuted_Lower)
-	    {
-	      retval.resize (nc, b_nc);
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-	      octave_idx_type *perm = mattype.triangular_perm ();
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  if (nc > nr)
-		    for (octave_idx_type i = 0; i < nm; i++)
-		      work[i] = 0.;
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[perm[i]] = b(i,j);
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (work[k] != 0.)
-			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  if (minr != k || data(mini) == 0)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  double tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval (i, j) = work[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = 0; k < nc; k++)
-			{
-			  if (work[k] != 0.)
-			    {
-			      octave_idx_type minr = nr;
-			      octave_idx_type mini = 0;
-
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				if (perm[ridx(i)] < minr)
-				  {
-				    minr = perm[ridx(i)];
-				    mini = i;
-				  }
-
-			      double tmp = work[k] / data(mini);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				{
-				  if (i == mini)
-				    continue;
-
-				  octave_idx_type iidx = perm[ridx(i)];
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-	      retval.resize (nc, b_nc, 0.);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
-		  for (octave_idx_type i = nr; i < nc; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(k)) != k ||
-			      data(cidx(k)) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  double tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; 
-			       i < cidx(k+1); i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval.xelem (i, j) = work[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k < nc; k++)
-			{
-
-			  if (work[k] != 0.)
-			    {
-			      double tmp = work[k] / data(cidx(k));
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k)+1; 
-				   i < cidx(k+1); i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Lower)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          octave_idx_type b_nc = b.cols ();
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          if (typ == MatrixType::Permuted_Lower)
+            {
+              retval.resize (nc, b_nc);
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+              octave_idx_type *perm = mattype.triangular_perm ();
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  if (nc > nr)
+                    for (octave_idx_type i = 0; i < nm; i++)
+                      work[i] = 0.;
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[perm[i]] = b(i,j);
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          octave_idx_type minr = nr;
+                          octave_idx_type mini = 0;
+
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            if (perm[ridx(i)] < minr)
+                              {
+                                minr = perm[ridx(i)];
+                                mini = i;
+                              }
+
+                          if (minr != k || data(mini) == 0)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          double tmp = work[k] / data(mini);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            {
+                              if (i == mini)
+                                continue;
+
+                              octave_idx_type iidx = perm[ridx(i)];
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval (i, j) = work[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = 0; k < nc; k++)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              octave_idx_type minr = nr;
+                              octave_idx_type mini = 0;
+
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                if (perm[ridx(i)] < minr)
+                                  {
+                                    minr = perm[ridx(i)];
+                                    mini = i;
+                                  }
+
+                              double tmp = work[k] / data(mini);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                {
+                                  if (i == mini)
+                                    continue;
+
+                                  octave_idx_type iidx = perm[ridx(i)];
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+              retval.resize (nc, b_nc, 0.);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[i] = b(i,j);
+                  for (octave_idx_type i = nr; i < nc; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(k)) != k ||
+                              data(cidx(k)) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          double tmp = work[k] / data(cidx(k));
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k)+1; 
+                               i < cidx(k+1); i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval.xelem (i, j) = work[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k < nc; k++)
+                        {
+
+                          if (work[k] != 0.)
+                            {
+                              double tmp = work[k] / data(cidx(k));
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k)+1; 
+                                   i < cidx(k+1); i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b, 
-		       octave_idx_type& err, double& rcond, 
-		       solve_singularity_handler sing_handler,
-		       bool calc_cond) const
+                       octave_idx_type& err, double& rcond, 
+                       solve_singularity_handler sing_handler,
+                       bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2977,303 +2977,303 @@ SparseMatrix::ltsolve (MatrixType &matty
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
-	  typ == MatrixType::Lower)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
-	  retval = SparseMatrix (nc, b_nc, b_nz);
-	  retval.xcidx(0) = 0;
-	  octave_idx_type ii = 0;
-	  octave_idx_type x_nz = b_nz;
-
-	  if (typ == MatrixType::Permuted_Lower)
-	    {
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-	      octave_idx_type *perm = mattype.triangular_perm ();
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[perm[b.ridx(i)]] = b.data(i);
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (work[k] != 0.)
-			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  if (minr != k || data(mini) == 0)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  double tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = 0; k < nc; k++)
-			{
-			  if (work[k] != 0.)
-			    {
-			      octave_idx_type minr = nr;
-			      octave_idx_type mini = 0;
-
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				if (perm[ridx(i)] < minr)
-				  {
-				    minr = perm[ridx(i)];
-				    mini = i;
-				  }
-
-			      double tmp = work[k] / data(mini);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				{
-				  if (i == mini)
-				    continue;
-
-				  octave_idx_type iidx = perm[ridx(i)];
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nr; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (work[k] != 0.)
-			{
-			  if (ridx(cidx(k)) != k ||
-			      data(cidx(k)) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  double tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (work[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k < nc; k++)
-			{
-
-			  if (work[k] != 0.)
-			    {
-			      double tmp = work[k] / data(cidx(k));
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k)+1; 
-				   i < cidx(k+1); i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Lower)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          octave_idx_type b_nc = b.cols ();
+          octave_idx_type b_nz = b.nnz ();
+          retval = SparseMatrix (nc, b_nc, b_nz);
+          retval.xcidx(0) = 0;
+          octave_idx_type ii = 0;
+          octave_idx_type x_nz = b_nz;
+
+          if (typ == MatrixType::Permuted_Lower)
+            {
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+              octave_idx_type *perm = mattype.triangular_perm ();
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[perm[b.ridx(i)]] = b.data(i);
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          octave_idx_type minr = nr;
+                          octave_idx_type mini = 0;
+
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            if (perm[ridx(i)] < minr)
+                              {
+                                minr = perm[ridx(i)];
+                                mini = i;
+                              }
+
+                          if (minr != k || data(mini) == 0)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          double tmp = work[k] / data(mini);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            {
+                              if (i == mini)
+                                continue;
+
+                              octave_idx_type iidx = perm[ridx(i)];
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = 0; k < nc; k++)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              octave_idx_type minr = nr;
+                              octave_idx_type mini = 0;
+
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                if (perm[ridx(i)] < minr)
+                                  {
+                                    minr = perm[ridx(i)];
+                                    mini = i;
+                                  }
+
+                              double tmp = work[k] / data(mini);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                {
+                                  if (i == mini)
+                                    continue;
+
+                                  octave_idx_type iidx = perm[ridx(i)];
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nr; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[b.ridx(i)] = b.data(i);
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          if (ridx(cidx(k)) != k ||
+                              data(cidx(k)) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          double tmp = work[k] / data(cidx(k));
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              work[iidx] = work[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (work[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k < nc; k++)
+                        {
+
+                          if (work[k] != 0.)
+                            {
+                              double tmp = work[k] / data(cidx(k));
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k)+1; 
+                                   i < cidx(k+1); i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b, 
-		       octave_idx_type& err, double& rcond, 
-		       solve_singularity_handler sing_handler,
-		       bool calc_cond) const
+                       octave_idx_type& err, double& rcond, 
+                       solve_singularity_handler sing_handler,
+                       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -3284,257 +3284,257 @@ SparseMatrix::ltsolve (MatrixType &matty
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
-	  typ == MatrixType::Lower)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  if (typ == MatrixType::Permuted_Lower)
-	    {
-	      retval.resize (nc, b_nc);
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-	      octave_idx_type *perm = mattype.triangular_perm ();
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    cwork[i] = 0.;
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    cwork[perm[i]] = b(i,j);
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (cwork[k] != 0.)
-			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  if (minr != k || data(mini) == 0)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = cwork[k] / data(mini);
-			  cwork[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      cwork[iidx] = cwork[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval (i, j) = cwork[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  OCTAVE_LOCAL_BUFFER (double, work, nm);
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = 0; k < nc; k++)
-			{
-			  if (work[k] != 0.)
-			    {
-			      octave_idx_type minr = nr;
-			      octave_idx_type mini = 0;
-
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				if (perm[ridx(i)] < minr)
-				  {
-				    minr = perm[ridx(i)];
-				    mini = i;
-				  }
-
-			      double tmp = work[k] / data(mini);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				{
-				  if (i == mini)
-				    continue;
-
-				  octave_idx_type iidx = perm[ridx(i)];
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-	      retval.resize (nc, b_nc, 0.);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    cwork[i] = b(i,j);
-		  for (octave_idx_type i = nr; i < nc; i++)
-		    cwork[i] = 0.;
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (cwork[k] != 0.)
-			{
-			  if (ridx(cidx(k)) != k ||
-			      data(cidx(k)) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = cwork[k] / data(cidx(k));
-			  cwork[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      cwork[iidx] = cwork[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    retval.xelem (i, j) = cwork[i];
-		}
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  OCTAVE_LOCAL_BUFFER (double, work, nm);
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k < nc; k++)
-			{
-
-			  if (work[k] != 0.)
-			    {
-			      double tmp = work[k] / data(cidx(k));
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k)+1; 
-				   i < cidx(k+1); i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Lower)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          octave_idx_type b_nc = b.cols ();
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          if (typ == MatrixType::Permuted_Lower)
+            {
+              retval.resize (nc, b_nc);
+              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+              octave_idx_type *perm = mattype.triangular_perm ();
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    cwork[i] = 0.;
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    cwork[perm[i]] = b(i,j);
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (cwork[k] != 0.)
+                        {
+                          octave_idx_type minr = nr;
+                          octave_idx_type mini = 0;
+
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            if (perm[ridx(i)] < minr)
+                              {
+                                minr = perm[ridx(i)];
+                                mini = i;
+                              }
+
+                          if (minr != k || data(mini) == 0)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = cwork[k] / data(mini);
+                          cwork[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            {
+                              if (i == mini)
+                                continue;
+
+                              octave_idx_type iidx = perm[ridx(i)];
+                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval (i, j) = cwork[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  OCTAVE_LOCAL_BUFFER (double, work, nm);
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = 0; k < nc; k++)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              octave_idx_type minr = nr;
+                              octave_idx_type mini = 0;
+
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                if (perm[ridx(i)] < minr)
+                                  {
+                                    minr = perm[ridx(i)];
+                                    mini = i;
+                                  }
+
+                              double tmp = work[k] / data(mini);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                {
+                                  if (i == mini)
+                                    continue;
+
+                                  octave_idx_type iidx = perm[ridx(i)];
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+              retval.resize (nc, b_nc, 0.);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    cwork[i] = b(i,j);
+                  for (octave_idx_type i = nr; i < nc; i++)
+                    cwork[i] = 0.;
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (cwork[k] != 0.)
+                        {
+                          if (ridx(cidx(k)) != k ||
+                              data(cidx(k)) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = cwork[k] / data(cidx(k));
+                          cwork[k] = tmp;
+                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    retval.xelem (i, j) = cwork[i];
+                }
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  OCTAVE_LOCAL_BUFFER (double, work, nm);
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k < nc; k++)
+                        {
+
+                          if (work[k] != 0.)
+                            {
+                              double tmp = work[k] / data(cidx(k));
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k)+1; 
+                                   i < cidx(k+1); i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::ltsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-		       octave_idx_type& err, double& rcond, 
-		       solve_singularity_handler sing_handler,
-		       bool calc_cond) const
+                       octave_idx_type& err, double& rcond, 
+                       solve_singularity_handler sing_handler,
+                       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -3545,305 +3545,305 @@ SparseMatrix::ltsolve (MatrixType &matty
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Permuted_Lower ||
-	  typ == MatrixType::Lower)
-	{
-	  double anorm = 0.;
-	  double ainvnorm = 0.;
-	  rcond = 1.;
-
-	  if (calc_cond)
-	    {
-	      // Calculate the 1-norm of matrix for rcond calculation
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
-	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
-	  retval.xcidx(0) = 0;
-	  octave_idx_type ii = 0;
-	  octave_idx_type x_nz = b_nz;
-
-	  if (typ == MatrixType::Permuted_Lower)
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-	      octave_idx_type *perm = mattype.triangular_perm ();
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    cwork[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    cwork[perm[b.ridx(i)]] = b.data(i);
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (cwork[k] != 0.)
-			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  if (minr != k || data(mini) == 0)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = cwork[k] / data(mini);
-			  cwork[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      cwork[iidx] = cwork[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (cwork[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (cwork[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = cwork[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  OCTAVE_LOCAL_BUFFER (double, work, nm);
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = 0; k < nc; k++)
-			{
-			  if (work[k] != 0.)
-			    {
-			      octave_idx_type minr = nr;
-			      octave_idx_type mini = 0;
-
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				if (perm[ridx(i)] < minr)
-				  {
-				    minr = perm[ridx(i)];
-				    mini = i;
-				  }
-
-			      double tmp = work[k] / data(mini);
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k); 
-				   i < cidx(k+1); i++)
-				{
-				  if (i == mini)
-				    continue;
-
-				  octave_idx_type iidx = perm[ridx(i)];
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    cwork[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    cwork[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = 0; k < nc; k++)
-		    {
-		      if (cwork[k] != 0.)
-			{
-			  if (ridx(cidx(k)) != k ||
-			      data(cidx(k)) == 0.)
-			    {
-			      err = -2;
-			      goto triangular_error;
-			    }			    
-
-			  Complex tmp = cwork[k] / data(cidx(k));
-			  cwork[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
-			    {
-			      octave_idx_type iidx = ridx(i);
-			      cwork[iidx] = cwork[iidx] - tmp * data(i);
-			    }
-			}
-		    }
-
-		  // Count non-zeros in work vector and adjust space in
-		  // retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (cwork[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nc; i++)
-		    if (cwork[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = cwork[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      if (calc_cond)
-		{
-		  // Calculation of 1-norm of inv(*this)
-		  OCTAVE_LOCAL_BUFFER (double, work, nm);
-		  for (octave_idx_type i = 0; i < nm; i++)
-		    work[i] = 0.;
-
-		  for (octave_idx_type j = 0; j < nr; j++)
-		    {
-		      work[j] = 1.;
-
-		      for (octave_idx_type k = j; k < nc; k++)
-			{
-
-			  if (work[k] != 0.)
-			    {
-			      double tmp = work[k] / data(cidx(k));
-			      work[k] = tmp;
-			      for (octave_idx_type i = cidx(k)+1; 
-				   i < cidx(k+1); i++)
-				{
-				  octave_idx_type iidx = ridx(i);
-				  work[iidx] = work[iidx] - tmp * data(i);
-				}
-			    }
-			}
-		      double atmp = 0;
-		      for (octave_idx_type i = j; i < nc; i++)
-			{
-			  atmp += fabs(work[i]);
-			  work[i] = 0.;
-			}
-		      if (atmp > ainvnorm)
-			ainvnorm = atmp;
-		    }
-		  rcond = 1. / ainvnorm / anorm;
-		}
-	    }
-
-	triangular_error:
-	  if (err != 0)
-	    {
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-
-	  volatile double rcond_plus_one = rcond + 1.0;
-
-	  if (rcond_plus_one == 1.0 || xisnan (rcond))
-	    {
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    }
-	}
+          typ == MatrixType::Lower)
+        {
+          double anorm = 0.;
+          double ainvnorm = 0.;
+          rcond = 1.;
+
+          if (calc_cond)
+            {
+              // Calculate the 1-norm of matrix for rcond calculation
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          octave_idx_type b_nc = b.cols ();
+          octave_idx_type b_nz = b.nnz ();
+          retval = SparseComplexMatrix (nc, b_nc, b_nz);
+          retval.xcidx(0) = 0;
+          octave_idx_type ii = 0;
+          octave_idx_type x_nz = b_nz;
+
+          if (typ == MatrixType::Permuted_Lower)
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+              octave_idx_type *perm = mattype.triangular_perm ();
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    cwork[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    cwork[perm[b.ridx(i)]] = b.data(i);
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (cwork[k] != 0.)
+                        {
+                          octave_idx_type minr = nr;
+                          octave_idx_type mini = 0;
+
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            if (perm[ridx(i)] < minr)
+                              {
+                                minr = perm[ridx(i)];
+                                mini = i;
+                              }
+
+                          if (minr != k || data(mini) == 0)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = cwork[k] / data(mini);
+                          cwork[k] = tmp;
+                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                            {
+                              if (i == mini)
+                                continue;
+
+                              octave_idx_type iidx = perm[ridx(i)];
+                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (cwork[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (cwork[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = cwork[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  OCTAVE_LOCAL_BUFFER (double, work, nm);
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = 0; k < nc; k++)
+                        {
+                          if (work[k] != 0.)
+                            {
+                              octave_idx_type minr = nr;
+                              octave_idx_type mini = 0;
+
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                if (perm[ridx(i)] < minr)
+                                  {
+                                    minr = perm[ridx(i)];
+                                    mini = i;
+                                  }
+
+                              double tmp = work[k] / data(mini);
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k); 
+                                   i < cidx(k+1); i++)
+                                {
+                                  if (i == mini)
+                                    continue;
+
+                                  octave_idx_type iidx = perm[ridx(i)];
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    cwork[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    cwork[b.ridx(i)] = b.data(i);
+
+                  for (octave_idx_type k = 0; k < nc; k++)
+                    {
+                      if (cwork[k] != 0.)
+                        {
+                          if (ridx(cidx(k)) != k ||
+                              data(cidx(k)) == 0.)
+                            {
+                              err = -2;
+                              goto triangular_error;
+                            }                       
+
+                          Complex tmp = cwork[k] / data(cidx(k));
+                          cwork[k] = tmp;
+                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                            {
+                              octave_idx_type iidx = ridx(i);
+                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                            }
+                        }
+                    }
+
+                  // Count non-zeros in work vector and adjust space in
+                  // retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (cwork[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nc; i++)
+                    if (cwork[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = cwork[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              if (calc_cond)
+                {
+                  // Calculation of 1-norm of inv(*this)
+                  OCTAVE_LOCAL_BUFFER (double, work, nm);
+                  for (octave_idx_type i = 0; i < nm; i++)
+                    work[i] = 0.;
+
+                  for (octave_idx_type j = 0; j < nr; j++)
+                    {
+                      work[j] = 1.;
+
+                      for (octave_idx_type k = j; k < nc; k++)
+                        {
+
+                          if (work[k] != 0.)
+                            {
+                              double tmp = work[k] / data(cidx(k));
+                              work[k] = tmp;
+                              for (octave_idx_type i = cidx(k)+1; 
+                                   i < cidx(k+1); i++)
+                                {
+                                  octave_idx_type iidx = ridx(i);
+                                  work[iidx] = work[iidx] - tmp * data(i);
+                                }
+                            }
+                        }
+                      double atmp = 0;
+                      for (octave_idx_type i = j; i < nc; i++)
+                        {
+                          atmp += fabs(work[i]);
+                          work[i] = 0.;
+                        }
+                      if (atmp > ainvnorm)
+                        ainvnorm = atmp;
+                    }
+                  rcond = 1. / ainvnorm / anorm;
+                }
+            }
+
+        triangular_error:
+          if (err != 0)
+            {
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+
+          volatile double rcond_plus_one = rcond + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcond))
+            {
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision, rcond = %g",
+                   rcond);
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 SparseMatrix::trisolve (MatrixType &mattype, const Matrix& b,
-			octave_idx_type& err, double& rcond,
-			solve_singularity_handler sing_handler,
-			bool calc_cond) const
+                        octave_idx_type& err, double& rcond,
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -3856,145 +3856,145 @@ SparseMatrix::trisolve (MatrixType &matt
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Tridiagonal_Hermitian)
-	{
-	  OCTAVE_LOCAL_BUFFER (double, D, nr);
-	  OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
-
-	  if (mattype.is_dense ())
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < nc-1; j++)
-		{
-		  D[j] = data(ii++);
-		  DL[j] = data(ii);
-		  ii += 2;
-		}
-	      D[nc-1] = data(ii);
-	    }
-	  else
-	    {
-	      D[0] = 0.;
-	      for (octave_idx_type i = 0; i < nr - 1; i++)
-		{
-		  D[i+1] = 0.;
-		  DL[i] = 0.;
-		}
-
-	      for (octave_idx_type j = 0; j < nc; j++)
-		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		  {
-		    if (ridx(i) == j)
-		      D[j] = data(i);
-		    else if (ridx(i) == j + 1)
-		      DL[j] = data(i);
-		  }
-	    }
-	      
-	  octave_idx_type b_nc = b.cols();
-	  retval = b;
-	  double *result = retval.fortran_vec ();
-
-	  F77_XFCN (dptsv, DPTSV, (nr, b_nc, D, DL, result, 
-				   b.rows(), err));
-
-	  if (err != 0)
-	    {
-	      err = 0;
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Tridiagonal;
-	    }
-	  else 
-	    rcond = 1.;
-	}
+        {
+          OCTAVE_LOCAL_BUFFER (double, D, nr);
+          OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
+
+          if (mattype.is_dense ())
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < nc-1; j++)
+                {
+                  D[j] = data(ii++);
+                  DL[j] = data(ii);
+                  ii += 2;
+                }
+              D[nc-1] = data(ii);
+            }
+          else
+            {
+              D[0] = 0.;
+              for (octave_idx_type i = 0; i < nr - 1; i++)
+                {
+                  D[i+1] = 0.;
+                  DL[i] = 0.;
+                }
+
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  {
+                    if (ridx(i) == j)
+                      D[j] = data(i);
+                    else if (ridx(i) == j + 1)
+                      DL[j] = data(i);
+                  }
+            }
+              
+          octave_idx_type b_nc = b.cols();
+          retval = b;
+          double *result = retval.fortran_vec ();
+
+          F77_XFCN (dptsv, DPTSV, (nr, b_nc, D, DL, result, 
+                                   b.rows(), err));
+
+          if (err != 0)
+            {
+              err = 0;
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Tridiagonal;
+            }
+          else 
+            rcond = 1.;
+        }
 
       if (typ == MatrixType::Tridiagonal)
-	{
-	  OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
-	  OCTAVE_LOCAL_BUFFER (double, D, nr);
-	  OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
-
-	  if (mattype.is_dense ())
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < nc-1; j++)
-		{
-		  D[j] = data(ii++);
-		  DL[j] = data(ii++);
-		  DU[j] = data(ii++);
-		}
-	      D[nc-1] = data(ii);
-	    }
-	  else
-	    {
-	      D[0] = 0.;
-	      for (octave_idx_type i = 0; i < nr - 1; i++)
-		{
-		  D[i+1] = 0.;
-		  DL[i] = 0.;
-		  DU[i] = 0.;
-		}
-
-	      for (octave_idx_type j = 0; j < nc; j++)
-		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		  {
-		    if (ridx(i) == j)
-		      D[j] = data(i);
-		    else if (ridx(i) == j + 1)
-		      DL[j] = data(i);
-		    else if (ridx(i) == j - 1)
-		      DU[j-1] = data(i);
-		  }
-	    }
-
-	  octave_idx_type b_nc = b.cols();
-	  retval = b;
-	  double *result = retval.fortran_vec ();
-
-	  F77_XFCN (dgtsv, DGTSV, (nr, b_nc, DL, D, DU, result, 
-				   b.rows(), err));
-
-	  if (err != 0)
-	    {
-	      rcond = 0.;
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    } 
-	  else 
-	    rcond = 1.;
-	}
+        {
+          OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
+          OCTAVE_LOCAL_BUFFER (double, D, nr);
+          OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
+
+          if (mattype.is_dense ())
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < nc-1; j++)
+                {
+                  D[j] = data(ii++);
+                  DL[j] = data(ii++);
+                  DU[j] = data(ii++);
+                }
+              D[nc-1] = data(ii);
+            }
+          else
+            {
+              D[0] = 0.;
+              for (octave_idx_type i = 0; i < nr - 1; i++)
+                {
+                  D[i+1] = 0.;
+                  DL[i] = 0.;
+                  DU[i] = 0.;
+                }
+
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  {
+                    if (ridx(i) == j)
+                      D[j] = data(i);
+                    else if (ridx(i) == j + 1)
+                      DL[j] = data(i);
+                    else if (ridx(i) == j - 1)
+                      DU[j-1] = data(i);
+                  }
+            }
+
+          octave_idx_type b_nc = b.cols();
+          retval = b;
+          double *result = retval.fortran_vec ();
+
+          F77_XFCN (dgtsv, DGTSV, (nr, b_nc, DL, D, DU, result, 
+                                   b.rows(), err));
+
+          if (err != 0)
+            {
+              rcond = 0.;
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+            } 
+          else 
+            rcond = 1.;
+        }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
-	       (*current_liboctave_error_handler) ("incorrect matrix type");
+               (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::trisolve (MatrixType &mattype, const SparseMatrix& b, 
-			octave_idx_type& err, double& rcond, 
-			solve_singularity_handler sing_handler,
-			bool calc_cond) const
+                        octave_idx_type& err, double& rcond, 
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -4008,140 +4008,140 @@ SparseMatrix::trisolve (MatrixType &matt
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
-	  typ == MatrixType::Tridiagonal_Hermitian)
-	{
-	  OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
-	  OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
-	  OCTAVE_LOCAL_BUFFER (double, D, nr);
-	  OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  if (mattype.is_dense ())
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < nc-1; j++)
-		{
-		  D[j] = data(ii++);
-		  DL[j] = data(ii++);
-		  DU[j] = data(ii++);
-		}
-	      D[nc-1] = data(ii);
-	    }
-	  else
-	    {
-	      D[0] = 0.;
-	      for (octave_idx_type i = 0; i < nr - 1; i++)
-		{
-		  D[i+1] = 0.;
-		  DL[i] = 0.;
-		  DU[i] = 0.;
-		}
-
-	      for (octave_idx_type j = 0; j < nc; j++)
-		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		  {
-		    if (ridx(i) == j)
-		      D[j] = data(i);
-		    else if (ridx(i) == j + 1)
-		      DL[j] = data(i);
-		    else if (ridx(i) == j - 1)
-		      DU[j-1] = data(i);
-		  }
-	    }
-
-	  F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
-
-	  if (err != 0) 
-	    {
-	      rcond = 0.0;
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    } 
-	  else 
-	    {
-	      rcond = 1.0;
-	      char job = 'N';
-	      volatile octave_idx_type x_nz = b.nnz ();
-	      octave_idx_type b_nc = b.cols ();
-	      retval = SparseMatrix (nr, b_nc, x_nz);
-	      retval.xcidx(0) = 0;
-	      volatile octave_idx_type ii = 0;
-
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-
-	      for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = 0.;
-		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  F77_XFCN (dgttrs, DGTTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, 1, DL, D, DU, DU2, pipvt, 
-			     work, b.rows (), err
-			     F77_CHAR_ARG_LEN (1)));
-
-		  // Count non-zeros in work vector and adjust 
-		  // space in retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
-		      }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-	    }
-	}
+          typ == MatrixType::Tridiagonal_Hermitian)
+        {
+          OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
+          OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
+          OCTAVE_LOCAL_BUFFER (double, D, nr);
+          OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          if (mattype.is_dense ())
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < nc-1; j++)
+                {
+                  D[j] = data(ii++);
+                  DL[j] = data(ii++);
+                  DU[j] = data(ii++);
+                }
+              D[nc-1] = data(ii);
+            }
+          else
+            {
+              D[0] = 0.;
+              for (octave_idx_type i = 0; i < nr - 1; i++)
+                {
+                  D[i+1] = 0.;
+                  DL[i] = 0.;
+                  DU[i] = 0.;
+                }
+
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  {
+                    if (ridx(i) == j)
+                      D[j] = data(i);
+                    else if (ridx(i) == j + 1)
+                      DL[j] = data(i);
+                    else if (ridx(i) == j - 1)
+                      DU[j-1] = data(i);
+                  }
+            }
+
+          F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
+
+          if (err != 0) 
+            {
+              rcond = 0.0;
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+            } 
+          else 
+            {
+              rcond = 1.0;
+              char job = 'N';
+              volatile octave_idx_type x_nz = b.nnz ();
+              octave_idx_type b_nc = b.cols ();
+              retval = SparseMatrix (nr, b_nc, x_nz);
+              retval.xcidx(0) = 0;
+              volatile octave_idx_type ii = 0;
+
+              OCTAVE_LOCAL_BUFFER (double, work, nr);
+
+              for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    work[i] = 0.;
+                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                    work[b.ridx(i)] = b.data(i);
+
+                  F77_XFCN (dgttrs, DGTTRS, 
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, 1, DL, D, DU, DU2, pipvt, 
+                             work, b.rows (), err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  // Count non-zeros in work vector and adjust 
+                  // space in retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    if (work[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    if (work[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = work[i];
+                      }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+            }
+        }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::trisolve (MatrixType &mattype, const ComplexMatrix& b, 
-			octave_idx_type& err, double& rcond, 
-			solve_singularity_handler sing_handler,
-			bool calc_cond) const
+                        octave_idx_type& err, double& rcond, 
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -4154,146 +4154,146 @@ SparseMatrix::trisolve (MatrixType &matt
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
       if (typ == MatrixType::Tridiagonal_Hermitian)
-	{
-	  OCTAVE_LOCAL_BUFFER (double, D, nr);
-	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-
-	  if (mattype.is_dense ())
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < nc-1; j++)
-		{
-		  D[j] = data(ii++);
-		  DL[j] = data(ii);
-		  ii += 2;
-		}
-	      D[nc-1] = data(ii);
-	    }
-	  else
-	    {
-	      D[0] = 0.;
-	      for (octave_idx_type i = 0; i < nr - 1; i++)
-		{
-		  D[i+1] = 0.;
-		  DL[i] = 0.;
-		}
-
-	      for (octave_idx_type j = 0; j < nc; j++)
-		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		  {
-		    if (ridx(i) == j)
-		      D[j] = data(i);
-		    else if (ridx(i) == j + 1)
-		      DL[j] = data(i);
-		  }
-	    }
-
-	  octave_idx_type b_nr = b.rows ();
-	  octave_idx_type b_nc = b.cols();
-	  rcond = 1.;
-
-	  retval = b;
-	  Complex *result = retval.fortran_vec ();
-		  
-	  F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
-				   b_nr, err));
-
-	  if (err != 0)
-	    {
-	      err = 0;
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Tridiagonal;
-	    }
-	}
+        {
+          OCTAVE_LOCAL_BUFFER (double, D, nr);
+          OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
+
+          if (mattype.is_dense ())
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < nc-1; j++)
+                {
+                  D[j] = data(ii++);
+                  DL[j] = data(ii);
+                  ii += 2;
+                }
+              D[nc-1] = data(ii);
+            }
+          else
+            {
+              D[0] = 0.;
+              for (octave_idx_type i = 0; i < nr - 1; i++)
+                {
+                  D[i+1] = 0.;
+                  DL[i] = 0.;
+                }
+
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  {
+                    if (ridx(i) == j)
+                      D[j] = data(i);
+                    else if (ridx(i) == j + 1)
+                      DL[j] = data(i);
+                  }
+            }
+
+          octave_idx_type b_nr = b.rows ();
+          octave_idx_type b_nc = b.cols();
+          rcond = 1.;
+
+          retval = b;
+          Complex *result = retval.fortran_vec ();
+                  
+          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
+                                   b_nr, err));
+
+          if (err != 0)
+            {
+              err = 0;
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Tridiagonal;
+            }
+        }
 
       if (typ == MatrixType::Tridiagonal)
-	{
-	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
-	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
-	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-
-	  if (mattype.is_dense ())
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < nc-1; j++)
-		{
-		  D[j] = data(ii++);
-		  DL[j] = data(ii++);
-		  DU[j] = data(ii++);
-		}
-	      D[nc-1] = data(ii);
-	    }
-	  else
-	    {
-	      D[0] = 0.;
-	      for (octave_idx_type i = 0; i < nr - 1; i++)
-		{
-		  D[i+1] = 0.;
-		  DL[i] = 0.;
-		  DU[i] = 0.;
-		}
-
-	      for (octave_idx_type j = 0; j < nc; j++)
-		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		  {
-		    if (ridx(i) == j)
-		      D[j] = data(i);
-		    else if (ridx(i) == j + 1)
-		      DL[j] = data(i);
-		    else if (ridx(i) == j - 1)
-		      DU[j-1] = data(i);
-		  }
-	    }
-
-	  octave_idx_type b_nr = b.rows();
-	  octave_idx_type b_nc = b.cols();
-	  rcond = 1.;
-
-	  retval = b;
-	  Complex *result = retval.fortran_vec ();
-	      
-	  F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
-				   b_nr, err));
-
-	  if (err != 0)
-	    {
-	      rcond = 0.;
-	      err = -2;
-		      
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-	    }
-	}
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
+          OCTAVE_LOCAL_BUFFER (Complex, D, nr);
+          OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
+
+          if (mattype.is_dense ())
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < nc-1; j++)
+                {
+                  D[j] = data(ii++);
+                  DL[j] = data(ii++);
+                  DU[j] = data(ii++);
+                }
+              D[nc-1] = data(ii);
+            }
+          else
+            {
+              D[0] = 0.;
+              for (octave_idx_type i = 0; i < nr - 1; i++)
+                {
+                  D[i+1] = 0.;
+                  DL[i] = 0.;
+                  DU[i] = 0.;
+                }
+
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  {
+                    if (ridx(i) == j)
+                      D[j] = data(i);
+                    else if (ridx(i) == j + 1)
+                      DL[j] = data(i);
+                    else if (ridx(i) == j - 1)
+                      DU[j-1] = data(i);
+                  }
+            }
+
+          octave_idx_type b_nr = b.rows();
+          octave_idx_type b_nc = b.cols();
+          rcond = 1.;
+
+          retval = b;
+          Complex *result = retval.fortran_vec ();
+              
+          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
+                                   b_nr, err));
+
+          if (err != 0)
+            {
+              rcond = 0.;
+              err = -2;
+                      
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+            }
+        }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::trisolve (MatrixType &mattype, const SparseComplexMatrix& b,
-			octave_idx_type& err, double& rcond, 
-			solve_singularity_handler sing_handler,
-			bool calc_cond) const
+                        octave_idx_type& err, double& rcond, 
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -4307,172 +4307,172 @@ SparseMatrix::trisolve (MatrixType &matt
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
-	  typ == MatrixType::Tridiagonal_Hermitian)
-	{
-	  OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
-	  OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
-	  OCTAVE_LOCAL_BUFFER (double, D, nr);
-	  OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  if (mattype.is_dense ())
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < nc-1; j++)
-		{
-		  D[j] = data(ii++);
-		  DL[j] = data(ii++);
-		  DU[j] = data(ii++);
-		}
-	      D[nc-1] = data(ii);
-	    }
-	  else
-	    {
-	      D[0] = 0.;
-	      for (octave_idx_type i = 0; i < nr - 1; i++)
-		{
-		  D[i+1] = 0.;
-		  DL[i] = 0.;
-		  DU[i] = 0.;
-		}
-
-	      for (octave_idx_type j = 0; j < nc; j++)
-		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		  {
-		    if (ridx(i) == j)
-		      D[j] = data(i);
-		    else if (ridx(i) == j + 1)
-		      DL[j] = data(i);
-		    else if (ridx(i) == j - 1)
-		      DU[j-1] = data(i);
-		  }
-	    }
-
-	  F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
-
-	  if (err != 0) 
-	    {
-	      rcond = 0.0;
-	      err = -2;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-	    } 
-	  else 
-	    {	
-	      rcond = 1.;
-	      char job = 'N';
-	      octave_idx_type b_nr = b.rows ();
-	      octave_idx_type b_nc = b.cols ();
-	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-	      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-
-	      // Take a first guess that the number of non-zero terms
-	      // will be as many as in b
-	      volatile octave_idx_type x_nz = b.nnz ();
-	      volatile octave_idx_type ii = 0;
-	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-	      retval.xcidx(0) = 0;
-	      for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		{
-
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    {
-		      Complex c = b (i,j);
-		      Bx[i] = std::real (c);
-		      Bz[i] = std::imag (c);
-		    }
-
-		  F77_XFCN (dgttrs, DGTTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, 1, DL, D, DU, DU2, pipvt, 
-			     Bx, b_nr, err
-			     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0)
-		    {
-		      (*current_liboctave_error_handler)
-			("SparseMatrix::solve solve failed");
-
-		      err = -1;
-		      break;
-		    }
-
-		  F77_XFCN (dgttrs, DGTTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, 1, DL, D, DU, DU2, pipvt, 
-			     Bz, b_nr, err
-			     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0)
-		    {
-		      (*current_liboctave_error_handler)
-			("SparseMatrix::solve solve failed");
-
-		      err = -1;
-		      break;
-		    }
-
-		  // Count non-zeros in work vector and adjust 
-		  // space in retval if needed
-		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (Bx[i] != 0. || Bz[i] != 0.)
-		      new_nnz++;
-
-		  if (ii + new_nnz > x_nz)
-		    {
-		      // Resize the sparse matrix
-		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-		      retval.change_capacity (sz);
-		      x_nz = sz;
-		    }
-
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (Bx[i] != 0. || Bz[i] != 0.)
-		      {
-			retval.xridx(ii) = i;
-			retval.xdata(ii++) = 
-			  Complex (Bx[i], Bz[i]);
-		      }
-
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-	    }
-	}
+          typ == MatrixType::Tridiagonal_Hermitian)
+        {
+          OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
+          OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
+          OCTAVE_LOCAL_BUFFER (double, D, nr);
+          OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          if (mattype.is_dense ())
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < nc-1; j++)
+                {
+                  D[j] = data(ii++);
+                  DL[j] = data(ii++);
+                  DU[j] = data(ii++);
+                }
+              D[nc-1] = data(ii);
+            }
+          else
+            {
+              D[0] = 0.;
+              for (octave_idx_type i = 0; i < nr - 1; i++)
+                {
+                  D[i+1] = 0.;
+                  DL[i] = 0.;
+                  DU[i] = 0.;
+                }
+
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  {
+                    if (ridx(i) == j)
+                      D[j] = data(i);
+                    else if (ridx(i) == j + 1)
+                      DL[j] = data(i);
+                    else if (ridx(i) == j - 1)
+                      DU[j-1] = data(i);
+                  }
+            }
+
+          F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
+
+          if (err != 0) 
+            {
+              rcond = 0.0;
+              err = -2;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+            } 
+          else 
+            {   
+              rcond = 1.;
+              char job = 'N';
+              octave_idx_type b_nr = b.rows ();
+              octave_idx_type b_nc = b.cols ();
+              OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+              OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
+
+              // Take a first guess that the number of non-zero terms
+              // will be as many as in b
+              volatile octave_idx_type x_nz = b.nnz ();
+              volatile octave_idx_type ii = 0;
+              retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+              retval.xcidx(0) = 0;
+              for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                {
+
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    {
+                      Complex c = b (i,j);
+                      Bx[i] = std::real (c);
+                      Bz[i] = std::imag (c);
+                    }
+
+                  F77_XFCN (dgttrs, DGTTRS, 
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, 1, DL, D, DU, DU2, pipvt, 
+                             Bx, b_nr, err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
+                    {
+                      (*current_liboctave_error_handler)
+                        ("SparseMatrix::solve solve failed");
+
+                      err = -1;
+                      break;
+                    }
+
+                  F77_XFCN (dgttrs, DGTTRS, 
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, 1, DL, D, DU, DU2, pipvt, 
+                             Bz, b_nr, err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
+                    {
+                      (*current_liboctave_error_handler)
+                        ("SparseMatrix::solve solve failed");
+
+                      err = -1;
+                      break;
+                    }
+
+                  // Count non-zeros in work vector and adjust 
+                  // space in retval if needed
+                  octave_idx_type new_nnz = 0;
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    if (Bx[i] != 0. || Bz[i] != 0.)
+                      new_nnz++;
+
+                  if (ii + new_nnz > x_nz)
+                    {
+                      // Resize the sparse matrix
+                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                      retval.change_capacity (sz);
+                      x_nz = sz;
+                    }
+
+                  for (octave_idx_type i = 0; i < nr; i++)
+                    if (Bx[i] != 0. || Bz[i] != 0.)
+                      {
+                        retval.xridx(ii) = i;
+                        retval.xdata(ii++) = 
+                          Complex (Bx[i], Bz[i]);
+                      }
+
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+            }
+        }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 SparseMatrix::bsolve (MatrixType &mattype, const Matrix& b,
-		      octave_idx_type& err, double& rcond,
-		      solve_singularity_handler sing_handler,
-		      bool calc_cond) const
+                      octave_idx_type& err, double& rcond,
+                      solve_singularity_handler sing_handler,
+                      bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -4482,246 +4482,246 @@ SparseMatrix::bsolve (MatrixType &mattyp
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
-	{
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_lower + 1;
-	  Matrix m_band (ldm, nc);
-	  double *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      {
-		octave_idx_type ri = ridx (i);
-		if (ri >= j)
-		  m_band(ri - j, j) = data(i);
-	      }
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    anorm = m_band.abs().sum().row(0).max();
-
-	  char job = 'L';
-	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, tmp_data, ldm, err
-				     F77_CHAR_ARG_LEN (1)));
-	    
-	  if (err != 0) 
-	    {
-	      // Matrix is not positive definite!! Fall through to
-	      // unsymmetric banded solver.
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Banded;
-	      rcond = 0.0;
-	      err = 0;
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  Array<double> z (3 * nr);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nr);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dpbcon, DPBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nr, n_lower, tmp_data, ldm,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.;
-
-	      if (err == 0)
-		{
-		  retval = b;
-		  double *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  F77_XFCN (dpbtrs, DPBTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, n_lower, b_nc, tmp_data,
-			     ldm, result, b.rows(), err
-			     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseMatrix::solve solve failed");
-		      err = -1;
-		    }
-		}
-	    }
-	}
+        {
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_lower + 1;
+          Matrix m_band (ldm, nc);
+          double *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              {
+                octave_idx_type ri = ridx (i);
+                if (ri >= j)
+                  m_band(ri - j, j) = data(i);
+              }
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            anorm = m_band.abs().sum().row(0).max();
+
+          char job = 'L';
+          F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nr, n_lower, tmp_data, ldm, err
+                                     F77_CHAR_ARG_LEN (1)));
+            
+          if (err != 0) 
+            {
+              // Matrix is not positive definite!! Fall through to
+              // unsymmetric banded solver.
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Banded;
+              rcond = 0.0;
+              err = 0;
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  Array<double> z (3 * nr);
+                  double *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nr);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (dpbcon, DPBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nr, n_lower, tmp_data, ldm,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.;
+
+              if (err == 0)
+                {
+                  retval = b;
+                  double *result = retval.fortran_vec ();
+
+                  octave_idx_type b_nc = b.cols ();
+
+                  F77_XFCN (dpbtrs, DPBTRS, 
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, b_nc, tmp_data,
+                             ldm, result, b.rows(), err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseMatrix::solve solve failed");
+                      err = -1;
+                    }
+                }
+            }
+        }
 
       if (typ == MatrixType::Banded)
-	{
-	  // Create the storage for the banded form of the sparse matrix
-	  octave_idx_type n_upper = mattype.nupper ();
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
-
-	  Matrix m_band (ldm, nc);
-	  double *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    {
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
-				     ldm, pipvt, err));
-	    
-	  // Throw-away extra info LAPACK gives so as to not 
-	  // change output.
-	  if (err != 0) 
-	    {
-	      err = -2;
-	      rcond = 0.0;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  char job = '1';
-		  Array<double> z (3 * nr);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nr);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dgbcon, DGBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		   if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.;
-
-	      if (err == 0)
-		{
-		  retval = b;
-		  double *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  char job = 'N';
-		  F77_XFCN (dgbtrs, DGBTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, n_lower, n_upper, b_nc, tmp_data,
-			     ldm, pipvt, result, b.rows(), err
-			     F77_CHAR_ARG_LEN (1)));
-		}
-	    }
-	}
+        {
+          // Create the storage for the banded form of the sparse matrix
+          octave_idx_type n_upper = mattype.nupper ();
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+
+          Matrix m_band (ldm, nc);
+          double *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            {
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+                                     ldm, pipvt, err));
+            
+          // Throw-away extra info LAPACK gives so as to not 
+          // change output.
+          if (err != 0) 
+            {
+              err = -2;
+              rcond = 0.0;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  char job = '1';
+                  Array<double> z (3 * nr);
+                  double *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nr);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (dgbcon, DGBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                   if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.;
+
+              if (err == 0)
+                {
+                  retval = b;
+                  double *result = retval.fortran_vec ();
+
+                  octave_idx_type b_nc = b.cols ();
+
+                  char job = 'N';
+                  F77_XFCN (dgbtrs, DGBTRS, 
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, n_upper, b_nc, tmp_data,
+                             ldm, pipvt, result, b.rows(), err
+                             F77_CHAR_ARG_LEN (1)));
+                }
+            }
+        }
       else if (typ != MatrixType::Banded_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::bsolve (MatrixType &mattype, const SparseMatrix& b,
-		      octave_idx_type& err, double& rcond, 
-		      solve_singularity_handler sing_handler,
-		      bool calc_cond) const
+                      octave_idx_type& err, double& rcond, 
+                      solve_singularity_handler sing_handler,
+                      bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -4731,315 +4731,315 @@ SparseMatrix::bsolve (MatrixType &mattyp
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
-	{
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_lower + 1;
-
-	  Matrix m_band (ldm, nc);
-	  double *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      {
-		octave_idx_type ri = ridx (i);
-		if (ri >= j)
-		  m_band(ri - j, j) = data(i);
-	      }
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    anorm = m_band.abs().sum().row(0).max();
-
-	  char job = 'L';
-	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, tmp_data, ldm, err
-				     F77_CHAR_ARG_LEN (1)));
-	    
-	  if (err != 0) 
-	    {
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Banded;
-	      rcond = 0.0;
-	      err = 0;
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  Array<double> z (3 * nr);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nr);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dpbcon, DPBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nr, n_lower, tmp_data, ldm,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.;
-
-	      if (err == 0)
-		{
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-
-		  // Take a first guess that the number of non-zero terms
-		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nnz ();
-		  volatile octave_idx_type ii = 0;
-		  retval = SparseMatrix (b_nr, b_nc, x_nz);
-
-		  retval.xcidx(0) = 0;
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		    {
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			Bx[i] = b.elem (i, j);
-
-		      F77_XFCN (dpbtrs, DPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bx, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseMatrix::solve solve failed");
-			  err = -1;
-			  break;
-			}
-
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			{
-			  double tmp = Bx[i];
-			  if (tmp != 0.0)
-			    {
-			      if (ii == x_nz)
-				{
-				  // Resize the sparse matrix
-				  octave_idx_type sz = x_nz * 
-				    (b_nc - j) / b_nc;
-				  sz = (sz > 10 ? sz : 10) + x_nz;
-				  retval.change_capacity (sz);
-				  x_nz = sz;
-				}
-			      retval.xdata(ii) = tmp;
-			      retval.xridx(ii++) = i;
-			    }
-			}
-		      retval.xcidx(j+1) = ii;
-		    }
-
-		  retval.maybe_compress ();
-		}
-	    }
-	}
+        {
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_lower + 1;
+
+          Matrix m_band (ldm, nc);
+          double *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              {
+                octave_idx_type ri = ridx (i);
+                if (ri >= j)
+                  m_band(ri - j, j) = data(i);
+              }
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            anorm = m_band.abs().sum().row(0).max();
+
+          char job = 'L';
+          F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nr, n_lower, tmp_data, ldm, err
+                                     F77_CHAR_ARG_LEN (1)));
+            
+          if (err != 0) 
+            {
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Banded;
+              rcond = 0.0;
+              err = 0;
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  Array<double> z (3 * nr);
+                  double *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nr);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (dpbcon, DPBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nr, n_lower, tmp_data, ldm,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.;
+
+              if (err == 0)
+                {
+                  octave_idx_type b_nr = b.rows ();
+                  octave_idx_type b_nc = b.cols ();
+                  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+
+                  // Take a first guess that the number of non-zero terms
+                  // will be as many as in b
+                  volatile octave_idx_type x_nz = b.nnz ();
+                  volatile octave_idx_type ii = 0;
+                  retval = SparseMatrix (b_nr, b_nc, x_nz);
+
+                  retval.xcidx(0) = 0;
+                  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                    {
+                      for (octave_idx_type i = 0; i < b_nr; i++)
+                        Bx[i] = b.elem (i, j);
+
+                      F77_XFCN (dpbtrs, DPBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, 1, tmp_data,
+                                 ldm, Bx, b_nr, err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      if (err != 0)
+                        {
+                          (*current_liboctave_error_handler) 
+                            ("SparseMatrix::solve solve failed");
+                          err = -1;
+                          break;
+                        }
+
+                      for (octave_idx_type i = 0; i < b_nr; i++)
+                        {
+                          double tmp = Bx[i];
+                          if (tmp != 0.0)
+                            {
+                              if (ii == x_nz)
+                                {
+                                  // Resize the sparse matrix
+                                  octave_idx_type sz = x_nz * 
+                                    (b_nc - j) / b_nc;
+                                  sz = (sz > 10 ? sz : 10) + x_nz;
+                                  retval.change_capacity (sz);
+                                  x_nz = sz;
+                                }
+                              retval.xdata(ii) = tmp;
+                              retval.xridx(ii++) = i;
+                            }
+                        }
+                      retval.xcidx(j+1) = ii;
+                    }
+
+                  retval.maybe_compress ();
+                }
+            }
+        }
 
       if (typ == MatrixType::Banded)
-	{
-	  // Create the storage for the banded form of the sparse matrix
-	  octave_idx_type n_upper = mattype.nupper ();
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
-
-	  Matrix m_band (ldm, nc);
-	  double *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    {
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
-				     ldm, pipvt, err));
-	    
-	  if (err != 0) 
-	    {
-	      err = -2;
-	      rcond = 0.0;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  char job = '1';
-		  Array<double> z (3 * nr);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nr);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dgbcon, DGBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		   if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.;
-
-	      if (err == 0)
-		{
-		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nnz ();
-		  octave_idx_type b_nc = b.cols ();
-		  retval = SparseMatrix (nr, b_nc, x_nz);
-		  retval.xcidx(0) = 0;
-		  volatile octave_idx_type ii = 0;
-
-		  OCTAVE_LOCAL_BUFFER (double, work, nr);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
-			work[i] = 0.;
-		      for (octave_idx_type i = b.cidx(j); 
-			   i < b.cidx(j+1); i++)
-			work[b.ridx(i)] = b.data(i);
-
-		      F77_XFCN (dgbtrs, DGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, work, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (work[i] != 0.)
-			  new_nnz++;
-
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (work[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = work[i];
-			  }
-		      retval.xcidx(j+1) = ii;
-		    }
-
-		  retval.maybe_compress ();
-		}
-	    }
-	}
+        {
+          // Create the storage for the banded form of the sparse matrix
+          octave_idx_type n_upper = mattype.nupper ();
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+
+          Matrix m_band (ldm, nc);
+          double *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            {
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+                                     ldm, pipvt, err));
+            
+          if (err != 0) 
+            {
+              err = -2;
+              rcond = 0.0;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  char job = '1';
+                  Array<double> z (3 * nr);
+                  double *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nr);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (dgbcon, DGBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                   if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.;
+
+              if (err == 0)
+                {
+                  char job = 'N';
+                  volatile octave_idx_type x_nz = b.nnz ();
+                  octave_idx_type b_nc = b.cols ();
+                  retval = SparseMatrix (nr, b_nc, x_nz);
+                  retval.xcidx(0) = 0;
+                  volatile octave_idx_type ii = 0;
+
+                  OCTAVE_LOCAL_BUFFER (double, work, nr);
+
+                  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                    {
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        work[i] = 0.;
+                      for (octave_idx_type i = b.cidx(j); 
+                           i < b.cidx(j+1); i++)
+                        work[b.ridx(i)] = b.data(i);
+
+                      F77_XFCN (dgbtrs, DGBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, n_upper, 1, tmp_data,
+                                 ldm, pipvt, work, b.rows (), err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      // Count non-zeros in work vector and adjust 
+                      // space in retval if needed
+                      octave_idx_type new_nnz = 0;
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        if (work[i] != 0.)
+                          new_nnz++;
+
+                      if (ii + new_nnz > x_nz)
+                        {
+                          // Resize the sparse matrix
+                          octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                          retval.change_capacity (sz);
+                          x_nz = sz;
+                        }
+
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        if (work[i] != 0.)
+                          {
+                            retval.xridx(ii) = i;
+                            retval.xdata(ii++) = work[i];
+                          }
+                      retval.xcidx(j+1) = ii;
+                    }
+
+                  retval.maybe_compress ();
+                }
+            }
+        }
       else if (typ != MatrixType::Banded_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::bsolve (MatrixType &mattype, const ComplexMatrix& b, 
-		      octave_idx_type& err, double& rcond, 
-		      solve_singularity_handler sing_handler,
-		      bool calc_cond) const
+                      octave_idx_type& err, double& rcond, 
+                      solve_singularity_handler sing_handler,
+                      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -5049,296 +5049,296 @@ SparseMatrix::bsolve (MatrixType &mattyp
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
-	{
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_lower + 1;
-
-	  Matrix m_band (ldm, nc);
-	  double *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      {
-		octave_idx_type ri = ridx (i);
-		if (ri >= j)
-		  m_band(ri - j, j) = data(i);
-	      }
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    anorm = m_band.abs().sum().row(0).max();
-
-	  char job = 'L';
-	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, tmp_data, ldm, err
-				     F77_CHAR_ARG_LEN (1)));
-	    
-	  if (err != 0) 
-	    {
-	      // Matrix is not positive definite!! Fall through to
-	      // unsymmetric banded solver.
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Banded;
-	      rcond = 0.0;
-	      err = 0;
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  Array<double> z (3 * nr);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nr);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dpbcon, DPBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nr, n_lower, tmp_data, ldm,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.;
-
-	      if (err == 0)
-		{
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-
-		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-
-		  retval.resize (b_nr, b_nc);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		    {
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			{
-			  Complex c = b (i,j);
-			  Bx[i] = std::real (c);
-			  Bz[i] = std::imag (c);
-			}
-
-		      F77_XFCN (dpbtrs, DPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bx, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseMatrix::solve solve failed");
-			  err = -1;
-			  break;
-			}
-
-		      F77_XFCN (dpbtrs, DPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bz, b.rows(), err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseMatrix::solve solve failed");
-			  err = -1;
-			  break;
-			}
-
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			retval (i, j) = Complex (Bx[i], Bz[i]);
-		    }
-		}
-	    }
-	}
+        {
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_lower + 1;
+
+          Matrix m_band (ldm, nc);
+          double *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              {
+                octave_idx_type ri = ridx (i);
+                if (ri >= j)
+                  m_band(ri - j, j) = data(i);
+              }
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            anorm = m_band.abs().sum().row(0).max();
+
+          char job = 'L';
+          F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nr, n_lower, tmp_data, ldm, err
+                                     F77_CHAR_ARG_LEN (1)));
+            
+          if (err != 0) 
+            {
+              // Matrix is not positive definite!! Fall through to
+              // unsymmetric banded solver.
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Banded;
+              rcond = 0.0;
+              err = 0;
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  Array<double> z (3 * nr);
+                  double *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nr);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (dpbcon, DPBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nr, n_lower, tmp_data, ldm,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.;
+
+              if (err == 0)
+                {
+                  octave_idx_type b_nr = b.rows ();
+                  octave_idx_type b_nc = b.cols ();
+
+                  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+                  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
+
+                  retval.resize (b_nr, b_nc);
+
+                  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                    {
+                      for (octave_idx_type i = 0; i < b_nr; i++)
+                        {
+                          Complex c = b (i,j);
+                          Bx[i] = std::real (c);
+                          Bz[i] = std::imag (c);
+                        }
+
+                      F77_XFCN (dpbtrs, DPBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, 1, tmp_data,
+                                 ldm, Bx, b_nr, err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      if (err != 0)
+                        {
+                          (*current_liboctave_error_handler) 
+                            ("SparseMatrix::solve solve failed");
+                          err = -1;
+                          break;
+                        }
+
+                      F77_XFCN (dpbtrs, DPBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, 1, tmp_data,
+                                 ldm, Bz, b.rows(), err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      if (err != 0)
+                        {
+                          (*current_liboctave_error_handler) 
+                            ("SparseMatrix::solve solve failed");
+                          err = -1;
+                          break;
+                        }
+
+                      for (octave_idx_type i = 0; i < b_nr; i++)
+                        retval (i, j) = Complex (Bx[i], Bz[i]);
+                    }
+                }
+            }
+        }
 
       if (typ == MatrixType::Banded)
-	{
-	  // Create the storage for the banded form of the sparse matrix
-	  octave_idx_type n_upper = mattype.nupper ();
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
-
-	  Matrix m_band (ldm, nc);
-	  double *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    {
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
-				     ldm, pipvt, err));
-	    
-	  if (err != 0) 
-	    {
-	      err = -2;
-	      rcond = 0.0;
-
-	      if (sing_handler)
-		{
-		sing_handler (rcond);
-		mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  char job = '1';
-		  Array<double> z (3 * nr);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nr);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dpbcon, DPBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nr, n_lower, tmp_data, ldm,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			sing_handler (rcond);
-			mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.;
-
-	      if (err == 0)
-		{
-		  char job = 'N';
-		  octave_idx_type b_nc = b.cols ();
-		  retval.resize (nr,b_nc);
-
-		  OCTAVE_LOCAL_BUFFER (double, Bz, nr);
-		  OCTAVE_LOCAL_BUFFER (double, Bx, nr);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
-			{
-			  Complex c = b (i, j);
-			  Bx[i] = std::real (c);
-			  Bz[i] = std::imag  (c);
-			}
-
-		      F77_XFCN (dgbtrs, DGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, Bx, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      F77_XFCN (dgbtrs, DGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, Bz, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			retval (i, j) = Complex (Bx[i], Bz[i]);
-		    }
-		}
-	    }
-	}
+        {
+          // Create the storage for the banded form of the sparse matrix
+          octave_idx_type n_upper = mattype.nupper ();
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+
+          Matrix m_band (ldm, nc);
+          double *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            {
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+                                     ldm, pipvt, err));
+            
+          if (err != 0) 
+            {
+              err = -2;
+              rcond = 0.0;
+
+              if (sing_handler)
+                {
+                sing_handler (rcond);
+                mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  char job = '1';
+                  Array<double> z (3 * nr);
+                  double *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nr);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (dpbcon, DPBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nr, n_lower, tmp_data, ldm,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                        sing_handler (rcond);
+                        mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.;
+
+              if (err == 0)
+                {
+                  char job = 'N';
+                  octave_idx_type b_nc = b.cols ();
+                  retval.resize (nr,b_nc);
+
+                  OCTAVE_LOCAL_BUFFER (double, Bz, nr);
+                  OCTAVE_LOCAL_BUFFER (double, Bx, nr);
+
+                  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                    {
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        {
+                          Complex c = b (i, j);
+                          Bx[i] = std::real (c);
+                          Bz[i] = std::imag  (c);
+                        }
+
+                      F77_XFCN (dgbtrs, DGBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, n_upper, 1, tmp_data,
+                                 ldm, pipvt, Bx, b.rows (), err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      F77_XFCN (dgbtrs, DGBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, n_upper, 1, tmp_data,
+                                 ldm, pipvt, Bz, b.rows (), err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        retval (i, j) = Complex (Bx[i], Bz[i]);
+                    }
+                }
+            }
+        }
       else if (typ != MatrixType::Banded_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::bsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-		      octave_idx_type& err, double& rcond, 
-		      solve_singularity_handler sing_handler,
-		      bool calc_cond) const
+                      octave_idx_type& err, double& rcond, 
+                      solve_singularity_handler sing_handler,
+                      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -5348,358 +5348,358 @@ SparseMatrix::bsolve (MatrixType &mattyp
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
-	{
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_lower + 1;
-
-	  Matrix m_band (ldm, nc);
-	  double *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      {
-		octave_idx_type ri = ridx (i);
-		if (ri >= j)
-		  m_band(ri - j, j) = data(i);
-	      }
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    anorm = m_band.abs().sum().row(0).max();
-
-	  char job = 'L';
-	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, tmp_data, ldm, err
-				     F77_CHAR_ARG_LEN (1)));
-	    
-	  if (err != 0) 
-	    {
-	      // Matrix is not positive definite!! Fall through to
-	      // unsymmetric banded solver.
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Banded;
-
-	      rcond = 0.0;
-	      err = 0;
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  Array<double> z (3 * nr);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nr);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dpbcon, DPBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nr, n_lower, tmp_data, ldm,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		  if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.;
-
-	      if (err == 0)
-		{
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-
-		  // Take a first guess that the number of non-zero terms
-		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nnz ();
-		  volatile octave_idx_type ii = 0;
-		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-		  retval.xcidx(0) = 0;
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		    {
-
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			{
-			  Complex c = b (i,j);
-			  Bx[i] = std::real (c);
-			  Bz[i] = std::imag (c);
-			}
-
-		      F77_XFCN (dpbtrs, DPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bx, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseMatrix::solve solve failed");
-			  err = -1;
-			  break;
-			}
-
-		      F77_XFCN (dpbtrs, DPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bz, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler)
-			    ("SparseMatrix::solve solve failed");
-
-			  err = -1;
-			  break;
-			}
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0. || Bz[i] != 0.)
-			  new_nnz++;
-
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0. || Bz[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = 
-			      Complex (Bx[i], Bz[i]);
-			  }
-
-		      retval.xcidx(j+1) = ii;
-		    }
-
-		  retval.maybe_compress ();
-		}
-	    }
-	}
+        {
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_lower + 1;
+
+          Matrix m_band (ldm, nc);
+          double *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              {
+                octave_idx_type ri = ridx (i);
+                if (ri >= j)
+                  m_band(ri - j, j) = data(i);
+              }
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            anorm = m_band.abs().sum().row(0).max();
+
+          char job = 'L';
+          F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nr, n_lower, tmp_data, ldm, err
+                                     F77_CHAR_ARG_LEN (1)));
+            
+          if (err != 0) 
+            {
+              // Matrix is not positive definite!! Fall through to
+              // unsymmetric banded solver.
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Banded;
+
+              rcond = 0.0;
+              err = 0;
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  Array<double> z (3 * nr);
+                  double *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nr);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (dpbcon, DPBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nr, n_lower, tmp_data, ldm,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.;
+
+              if (err == 0)
+                {
+                  octave_idx_type b_nr = b.rows ();
+                  octave_idx_type b_nc = b.cols ();
+                  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+                  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
+
+                  // Take a first guess that the number of non-zero terms
+                  // will be as many as in b
+                  volatile octave_idx_type x_nz = b.nnz ();
+                  volatile octave_idx_type ii = 0;
+                  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+                  retval.xcidx(0) = 0;
+                  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                    {
+
+                      for (octave_idx_type i = 0; i < b_nr; i++)
+                        {
+                          Complex c = b (i,j);
+                          Bx[i] = std::real (c);
+                          Bz[i] = std::imag (c);
+                        }
+
+                      F77_XFCN (dpbtrs, DPBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, 1, tmp_data,
+                                 ldm, Bx, b_nr, err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      if (err != 0)
+                        {
+                          (*current_liboctave_error_handler) 
+                            ("SparseMatrix::solve solve failed");
+                          err = -1;
+                          break;
+                        }
+
+                      F77_XFCN (dpbtrs, DPBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, 1, tmp_data,
+                                 ldm, Bz, b_nr, err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      if (err != 0)
+                        {
+                          (*current_liboctave_error_handler)
+                            ("SparseMatrix::solve solve failed");
+
+                          err = -1;
+                          break;
+                        }
+
+                      // Count non-zeros in work vector and adjust 
+                      // space in retval if needed
+                      octave_idx_type new_nnz = 0;
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        if (Bx[i] != 0. || Bz[i] != 0.)
+                          new_nnz++;
+
+                      if (ii + new_nnz > x_nz)
+                        {
+                          // Resize the sparse matrix
+                          octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                          retval.change_capacity (sz);
+                          x_nz = sz;
+                        }
+
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        if (Bx[i] != 0. || Bz[i] != 0.)
+                          {
+                            retval.xridx(ii) = i;
+                            retval.xdata(ii++) = 
+                              Complex (Bx[i], Bz[i]);
+                          }
+
+                      retval.xcidx(j+1) = ii;
+                    }
+
+                  retval.maybe_compress ();
+                }
+            }
+        }
 
       if (typ == MatrixType::Banded)
-	{
-	  // Create the storage for the banded form of the sparse matrix
-	  octave_idx_type n_upper = mattype.nupper ();
-	  octave_idx_type n_lower = mattype.nlower ();
-	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
-
-	  Matrix m_band (ldm, nc);
-	  double *tmp_data = m_band.fortran_vec ();
-	      
-	  if (! mattype.is_dense ()) 
-	    {
-	      octave_idx_type ii = 0;
-
-	      for (octave_idx_type j = 0; j < ldm; j++)
-		for (octave_idx_type i = 0; i < nc; i++)
-		  tmp_data[ii++] = 0.;
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
-
-	  // Calculate the norm of the matrix, for later use.
-	  double anorm;
-	  if (calc_cond)
-	    {
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  double atmp = 0.;
-		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		    atmp += fabs(data(i));
-		  if (atmp > anorm)
-		    anorm = atmp;
-		}
-	    }
-
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
-				     ldm, pipvt, err));
-	    
-	  if (err != 0) 
-	    {
-	      err = -2;
-	      rcond = 0.0;
-
-	      if (sing_handler)
-		{
-		  sing_handler (rcond);
-		  mattype.mark_as_rectangular ();
-		}
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  char job = '1';
-		  Array<double> z (3 * nr);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nr);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dgbcon, DGBCON, 
-		    (F77_CONST_CHAR_ARG2 (&job, 1),
-		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		     anorm, rcond, pz, piz, err
-		     F77_CHAR_ARG_LEN (1)));
-
-		   if (err != 0) 
-		    err = -2;
-
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
-		    {
-		      err = -2;
-
-		      if (sing_handler)
-			{
-			  sing_handler (rcond);
-			  mattype.mark_as_rectangular ();
-			}
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
-		    }
-		}
-	      else
-		rcond = 1.;
-
-	      if (err == 0)
-		{
-		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nnz ();
-		  octave_idx_type b_nc = b.cols ();
-		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
-		  retval.xcidx(0) = 0;
-		  volatile octave_idx_type ii = 0;
-
-		  OCTAVE_LOCAL_BUFFER (double, Bx, nr);
-		  OCTAVE_LOCAL_BUFFER (double, Bz, nr);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
-			{
-			  Bx[i] = 0.;
-			  Bz[i] = 0.;
-			}
-		      for (octave_idx_type i = b.cidx(j); 
-			   i < b.cidx(j+1); i++)
-			{
-			  Complex c = b.data(i);
-			  Bx[b.ridx(i)] = std::real (c);
-			  Bz[b.ridx(i)] = std::imag (c);
-			}
-
-		      F77_XFCN (dgbtrs, DGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, Bx, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      F77_XFCN (dgbtrs, DGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, Bz, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0. || Bz[i] != 0.)
-			  new_nnz++;
-
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0. || Bz[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = 
-			      Complex (Bx[i], Bz[i]);
-			  }
-		      retval.xcidx(j+1) = ii;
-		    }
-
-		  retval.maybe_compress ();
-		}
-	    }
-	}
+        {
+          // Create the storage for the banded form of the sparse matrix
+          octave_idx_type n_upper = mattype.nupper ();
+          octave_idx_type n_lower = mattype.nlower ();
+          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+
+          Matrix m_band (ldm, nc);
+          double *tmp_data = m_band.fortran_vec ();
+              
+          if (! mattype.is_dense ()) 
+            {
+              octave_idx_type ii = 0;
+
+              for (octave_idx_type j = 0; j < ldm; j++)
+                for (octave_idx_type i = 0; i < nc; i++)
+                  tmp_data[ii++] = 0.;
+            }
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+
+          // Calculate the norm of the matrix, for later use.
+          double anorm;
+          if (calc_cond)
+            {
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  double atmp = 0.;
+                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                    atmp += fabs(data(i));
+                  if (atmp > anorm)
+                    anorm = atmp;
+                }
+            }
+
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+                                     ldm, pipvt, err));
+            
+          if (err != 0) 
+            {
+              err = -2;
+              rcond = 0.0;
+
+              if (sing_handler)
+                {
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
+                }
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  char job = '1';
+                  Array<double> z (3 * nr);
+                  double *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nr);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (dgbcon, DGBCON, 
+                    (F77_CONST_CHAR_ARG2 (&job, 1),
+                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                     anorm, rcond, pz, piz, err
+                     F77_CHAR_ARG_LEN (1)));
+
+                   if (err != 0) 
+                    err = -2;
+
+                  volatile double rcond_plus_one = rcond + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                    {
+                      err = -2;
+
+                      if (sing_handler)
+                        {
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
+                        }
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcond);
+                    }
+                }
+              else
+                rcond = 1.;
+
+              if (err == 0)
+                {
+                  char job = 'N';
+                  volatile octave_idx_type x_nz = b.nnz ();
+                  octave_idx_type b_nc = b.cols ();
+                  retval = SparseComplexMatrix (nr, b_nc, x_nz);
+                  retval.xcidx(0) = 0;
+                  volatile octave_idx_type ii = 0;
+
+                  OCTAVE_LOCAL_BUFFER (double, Bx, nr);
+                  OCTAVE_LOCAL_BUFFER (double, Bz, nr);
+
+                  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+                    {
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        {
+                          Bx[i] = 0.;
+                          Bz[i] = 0.;
+                        }
+                      for (octave_idx_type i = b.cidx(j); 
+                           i < b.cidx(j+1); i++)
+                        {
+                          Complex c = b.data(i);
+                          Bx[b.ridx(i)] = std::real (c);
+                          Bz[b.ridx(i)] = std::imag (c);
+                        }
+
+                      F77_XFCN (dgbtrs, DGBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, n_upper, 1, tmp_data,
+                                 ldm, pipvt, Bx, b.rows (), err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      F77_XFCN (dgbtrs, DGBTRS, 
+                                (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nr, n_lower, n_upper, 1, tmp_data,
+                                 ldm, pipvt, Bz, b.rows (), err
+                                 F77_CHAR_ARG_LEN (1)));
+
+                      // Count non-zeros in work vector and adjust 
+                      // space in retval if needed
+                      octave_idx_type new_nnz = 0;
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        if (Bx[i] != 0. || Bz[i] != 0.)
+                          new_nnz++;
+
+                      if (ii + new_nnz > x_nz)
+                        {
+                          // Resize the sparse matrix
+                          octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                          retval.change_capacity (sz);
+                          x_nz = sz;
+                        }
+
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        if (Bx[i] != 0. || Bz[i] != 0.)
+                          {
+                            retval.xridx(ii) = i;
+                            retval.xdata(ii++) = 
+                              Complex (Bx[i], Bz[i]);
+                          }
+                      retval.xcidx(j+1) = ii;
+                    }
+
+                  retval.maybe_compress ();
+                }
+            }
+        }
       else if (typ != MatrixType::Banded_Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 void *
 SparseMatrix::factorize (octave_idx_type& err, double &rcond, Matrix &Control,
-			 Matrix &Info, solve_singularity_handler sing_handler,
-			 bool calc_cond) const
+                         Matrix &Info, solve_singularity_handler sing_handler,
+                         bool calc_cond) const
 {
   // The return values
   void *Numeric = 0;
   err = 0;
 
 #ifdef HAVE_UMFPACK
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
@@ -5730,89 +5730,89 @@ SparseMatrix::factorize (octave_idx_type
   octave_idx_type nc = cols ();
 
   UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 0,
-				     &Symbolic, control, info);
+                                     &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
-	("SparseMatrix::solve symbolic factorization failed");
+        ("SparseMatrix::solve symbolic factorization failed");
       err = -1;
 
       UMFPACK_DNAME (report_status) (control, status);
       UMFPACK_DNAME (report_info) (control, info);
 
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
       UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
       status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
-				   &Numeric, control, info) ;
+                                   &Numeric, control, info) ;
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
       if (calc_cond)
-	rcond = Info (UMFPACK_RCOND);
+        rcond = Info (UMFPACK_RCOND);
       else
-	rcond = 1.;
+        rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (status == UMFPACK_WARNING_singular_matrix || 
-	  rcond_plus_one == 1.0 || xisnan (rcond))
-	{
-	  UMFPACK_DNAME (report_numeric) (Numeric, control);
-
-	  err = -2;
-
-	  if (sing_handler)
-	    sing_handler (rcond);
-	  else
-	    (*current_liboctave_error_handler)
-	      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-	       rcond);
-
-	}
+          rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          UMFPACK_DNAME (report_numeric) (Numeric, control);
+
+          err = -2;
+
+          if (sing_handler)
+            sing_handler (rcond);
+          else
+            (*current_liboctave_error_handler)
+              ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+               rcond);
+
+        }
       else if (status < 0)
-	  {
-	    (*current_liboctave_error_handler) 
-	      ("SparseMatrix::solve numeric factorization failed");
-
-	    UMFPACK_DNAME (report_status) (control, status);
-	    UMFPACK_DNAME (report_info) (control, info);
-	      
-	    err = -1;
-	  }
-	else
-	  {
-	    UMFPACK_DNAME (report_numeric) (Numeric, control);
-	  }
+          {
+            (*current_liboctave_error_handler) 
+              ("SparseMatrix::solve numeric factorization failed");
+
+            UMFPACK_DNAME (report_status) (control, status);
+            UMFPACK_DNAME (report_info) (control, info);
+              
+            err = -1;
+          }
+        else
+          {
+            UMFPACK_DNAME (report_numeric) (Numeric, control);
+          }
     }
 
   if (err != 0)
     UMFPACK_DNAME (free_numeric) (&Numeric);
 
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return Numeric;
 }
 
 Matrix
 SparseMatrix::fsolve (MatrixType &mattype, const Matrix& b,
-		      octave_idx_type& err, double& rcond, 
-		      solve_singularity_handler sing_handler,
-		      bool calc_cond) const
+                      octave_idx_type& err, double& rcond, 
+                      solve_singularity_handler sing_handler,
+                      bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -5822,213 +5822,213 @@ SparseMatrix::fsolve (MatrixType &mattyp
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
-	{
+        {
 #ifdef HAVE_CHOLMOD
-	  cholmod_common Common;
-	  cholmod_common *cm = &Common;
-
-	  // Setup initial parameters
-	  CHOLMOD_NAME(start) (cm);
-	  cm->prefer_zomplex = false;
-
-	  double spu = octave_sparse_params::get_key ("spumoni");
-	  if (spu == 0.)
-	    {
-	      cm->print = -1;
-	      cm->print_function = 0;
-	    }
-	  else
-	    {
-	      cm->print = static_cast<int> (spu) + 2;
-	      cm->print_function =&SparseCholPrint;
-	    }
-
-	  cm->error_handler = &SparseCholError;
-	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
-	  cm->hypotenuse = CHOLMOD_NAME(hypot);
-
-	  cm->final_ll = true;
-
-	  cholmod_sparse Astore;
-	  cholmod_sparse *A = &Astore;
-	  double dummy;
-	  A->nrow = nr;
-	  A->ncol = nc;
-
-	  A->p = cidx();
-	  A->i = ridx();
-	  A->nzmax = nnz();
-	  A->packed = true;
-	  A->sorted = true;
-	  A->nz = 0;
+          cholmod_common Common;
+          cholmod_common *cm = &Common;
+
+          // Setup initial parameters
+          CHOLMOD_NAME(start) (cm);
+          cm->prefer_zomplex = false;
+
+          double spu = octave_sparse_params::get_key ("spumoni");
+          if (spu == 0.)
+            {
+              cm->print = -1;
+              cm->print_function = 0;
+            }
+          else
+            {
+              cm->print = static_cast<int> (spu) + 2;
+              cm->print_function =&SparseCholPrint;
+            }
+
+          cm->error_handler = &SparseCholError;
+          cm->complex_divide = CHOLMOD_NAME(divcomplex);
+          cm->hypotenuse = CHOLMOD_NAME(hypot);
+
+          cm->final_ll = true;
+
+          cholmod_sparse Astore;
+          cholmod_sparse *A = &Astore;
+          double dummy;
+          A->nrow = nr;
+          A->ncol = nc;
+
+          A->p = cidx();
+          A->i = ridx();
+          A->nzmax = nnz();
+          A->packed = true;
+          A->sorted = true;
+          A->nz = 0;
 #ifdef IDX_TYPE_LONG
-	  A->itype = CHOLMOD_LONG;
+          A->itype = CHOLMOD_LONG;
 #else
-	  A->itype = CHOLMOD_INT;
+          A->itype = CHOLMOD_INT;
 #endif
-	  A->dtype = CHOLMOD_DOUBLE;
-	  A->stype = 1;
-	  A->xtype = CHOLMOD_REAL;
-
-	  if (nr < 1)
-	    A->x = &dummy;
-	  else
-	    A->x = data();
-
-	  cholmod_dense Bstore;
-	  cholmod_dense *B = &Bstore;
-	  B->nrow = b.rows();
-	  B->ncol = b.cols();
-	  B->d = B->nrow;
-	  B->nzmax = B->nrow * B->ncol;
-	  B->dtype = CHOLMOD_DOUBLE;
-	  B->xtype = CHOLMOD_REAL;
-	  if (nc < 1 || b.cols() < 1)
-	    B->x = &dummy;
-	  else
-	    // We won't alter it, honest :-)
-	    B->x = const_cast<double *>(b.fortran_vec());
-
-	  cholmod_factor *L;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  L = CHOLMOD_NAME(analyze) (A, cm);
-	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  if (calc_cond)
-	    rcond = CHOLMOD_NAME(rcond)(L, cm);
-	  else
-	    rcond = 1.0;
-
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	  if (rcond == 0.0)
-	    {
-	      // Either its indefinite or singular. Try UMFPACK
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	  else
-	    {
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  err = -2;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		       rcond);
-	      
-		  return retval;
-		}
-
-	      cholmod_dense *X;
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	      retval.resize (b.rows (), b.cols());
-	      for (octave_idx_type j = 0; j < b.cols(); j++)
-		{
-		  octave_idx_type jr = j * b.rows();
-		  for (octave_idx_type i = 0; i < b.rows(); i++)
-		    retval.xelem(i,j) = static_cast<double *>(X->x)[jr + i];
-		}
-
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CHOLMOD_NAME(free_dense) (&X, cm);
-	      CHOLMOD_NAME(free_factor) (&L, cm);
-	      CHOLMOD_NAME(finish) (cm);
-	      static char tmp[] = " ";
-	      CHOLMOD_NAME(print_common) (tmp, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
+          A->dtype = CHOLMOD_DOUBLE;
+          A->stype = 1;
+          A->xtype = CHOLMOD_REAL;
+
+          if (nr < 1)
+            A->x = &dummy;
+          else
+            A->x = data();
+
+          cholmod_dense Bstore;
+          cholmod_dense *B = &Bstore;
+          B->nrow = b.rows();
+          B->ncol = b.cols();
+          B->d = B->nrow;
+          B->nzmax = B->nrow * B->ncol;
+          B->dtype = CHOLMOD_DOUBLE;
+          B->xtype = CHOLMOD_REAL;
+          if (nc < 1 || b.cols() < 1)
+            B->x = &dummy;
+          else
+            // We won't alter it, honest :-)
+            B->x = const_cast<double *>(b.fortran_vec());
+
+          cholmod_factor *L;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          L = CHOLMOD_NAME(analyze) (A, cm);
+          CHOLMOD_NAME(factorize) (A, L, cm);
+          if (calc_cond)
+            rcond = CHOLMOD_NAME(rcond)(L, cm);
+          else
+            rcond = 1.0;
+
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+          if (rcond == 0.0)
+            {
+              // Either its indefinite or singular. Try UMFPACK
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+          else
+            {
+              volatile double rcond_plus_one = rcond + 1.0;
+
+              if (rcond_plus_one == 1.0 || xisnan (rcond))
+                {
+                  err = -2;
+
+                  if (sing_handler)
+                    {
+                      sing_handler (rcond);
+                      mattype.mark_as_rectangular ();
+                    }
+                  else
+                    (*current_liboctave_error_handler)
+                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                       rcond);
+              
+                  return retval;
+                }
+
+              cholmod_dense *X;
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+              retval.resize (b.rows (), b.cols());
+              for (octave_idx_type j = 0; j < b.cols(); j++)
+                {
+                  octave_idx_type jr = j * b.rows();
+                  for (octave_idx_type i = 0; i < b.rows(); i++)
+                    retval.xelem(i,j) = static_cast<double *>(X->x)[jr + i];
+                }
+
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CHOLMOD_NAME(free_dense) (&X, cm);
+              CHOLMOD_NAME(free_factor) (&L, cm);
+              CHOLMOD_NAME(finish) (cm);
+              static char tmp[] = " ";
+              CHOLMOD_NAME(print_common) (tmp, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
 #else
-	  (*current_liboctave_warning_handler)
-	    ("CHOLMOD not installed");
-
-	  mattype.mark_as_unsymmetric ();
-	  typ = MatrixType::Full;
+          (*current_liboctave_warning_handler)
+            ("CHOLMOD not installed");
+
+          mattype.mark_as_unsymmetric ();
+          typ = MatrixType::Full;
 #endif
-	}
+        }
 
       if (typ == MatrixType::Full)
-	{
+        {
 #ifdef HAVE_UMFPACK
-	  Matrix Control, Info;
-	  void *Numeric = 
-	    factorize (err, rcond, Control, Info, sing_handler, calc_cond);
-
-	  if (err == 0)
-	    {
-	      const double *Bx = b.fortran_vec ();
-	      retval.resize (b.rows (), b.cols());
-	      double *result = retval.fortran_vec ();
-	      octave_idx_type b_nr = b.rows ();
-	      octave_idx_type b_nc = b.cols ();
-	      int status = 0;
-	      double *control = Control.fortran_vec ();
-	      double *info = Info.fortran_vec ();
-	      const octave_idx_type *Ap = cidx ();
-	      const octave_idx_type *Ai = ridx ();
-	      const double *Ax = data ();
-
-	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
-		{
-		  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap, 
-					     Ai, Ax, &result[iidx], &Bx[iidx],
-					     Numeric, control, info);
-		  if (status < 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseMatrix::solve solve failed");
-
-		      UMFPACK_DNAME (report_status) (control, status);
-		      
-		      err = -1;
-		  
-		      break;
-		    }
-		}
-
-	      UMFPACK_DNAME (report_info) (control, info);
-		
-	      UMFPACK_DNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    mattype.mark_as_rectangular ();
+          Matrix Control, Info;
+          void *Numeric = 
+            factorize (err, rcond, Control, Info, sing_handler, calc_cond);
+
+          if (err == 0)
+            {
+              const double *Bx = b.fortran_vec ();
+              retval.resize (b.rows (), b.cols());
+              double *result = retval.fortran_vec ();
+              octave_idx_type b_nr = b.rows ();
+              octave_idx_type b_nc = b.cols ();
+              int status = 0;
+              double *control = Control.fortran_vec ();
+              double *info = Info.fortran_vec ();
+              const octave_idx_type *Ap = cidx ();
+              const octave_idx_type *Ai = ridx ();
+              const double *Ax = data ();
+
+              for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
+                {
+                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap, 
+                                             Ai, Ax, &result[iidx], &Bx[iidx],
+                                             Numeric, control, info);
+                  if (status < 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseMatrix::solve solve failed");
+
+                      UMFPACK_DNAME (report_status) (control, status);
+                      
+                      err = -1;
+                  
+                      break;
+                    }
+                }
+
+              UMFPACK_DNAME (report_info) (control, info);
+                
+              UMFPACK_DNAME (free_numeric) (&Numeric);
+            }
+          else
+            mattype.mark_as_rectangular ();
 
 #else
-	  (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
-	}
+        }
       else if (typ != MatrixType::Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::fsolve (MatrixType &mattype, const SparseMatrix& b,
-		      octave_idx_type& err, double& rcond,
-		      solve_singularity_handler sing_handler,
-		      bool calc_cond) const
+                      octave_idx_type& err, double& rcond,
+                      solve_singularity_handler sing_handler,
+                      bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -6038,259 +6038,259 @@ SparseMatrix::fsolve (MatrixType &mattyp
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
-	{
+        {
 #ifdef HAVE_CHOLMOD
-	  cholmod_common Common;
-	  cholmod_common *cm = &Common;
-
-	  // Setup initial parameters
-	  CHOLMOD_NAME(start) (cm);
-	  cm->prefer_zomplex = false;
-
-	  double spu = octave_sparse_params::get_key ("spumoni");
-	  if (spu == 0.)
-	    {
-	      cm->print = -1;
-	      cm->print_function = 0;
-	    }
-	  else
-	    {
-	      cm->print = static_cast<int> (spu) + 2;
-	      cm->print_function =&SparseCholPrint;
-	    }
-
-	  cm->error_handler = &SparseCholError;
-	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
-	  cm->hypotenuse = CHOLMOD_NAME(hypot);
-
-	  cm->final_ll = true;
-
-	  cholmod_sparse Astore;
-	  cholmod_sparse *A = &Astore;
-	  double dummy;
-	  A->nrow = nr;
-	  A->ncol = nc;
-
-	  A->p = cidx();
-	  A->i = ridx();
-	  A->nzmax = nnz();
-	  A->packed = true;
-	  A->sorted = true;
-	  A->nz = 0;
+          cholmod_common Common;
+          cholmod_common *cm = &Common;
+
+          // Setup initial parameters
+          CHOLMOD_NAME(start) (cm);
+          cm->prefer_zomplex = false;
+
+          double spu = octave_sparse_params::get_key ("spumoni");
+          if (spu == 0.)
+            {
+              cm->print = -1;
+              cm->print_function = 0;
+            }
+          else
+            {
+              cm->print = static_cast<int> (spu) + 2;
+              cm->print_function =&SparseCholPrint;
+            }
+
+          cm->error_handler = &SparseCholError;
+          cm->complex_divide = CHOLMOD_NAME(divcomplex);
+          cm->hypotenuse = CHOLMOD_NAME(hypot);
+
+          cm->final_ll = true;
+
+          cholmod_sparse Astore;
+          cholmod_sparse *A = &Astore;
+          double dummy;
+          A->nrow = nr;
+          A->ncol = nc;
+
+          A->p = cidx();
+          A->i = ridx();
+          A->nzmax = nnz();
+          A->packed = true;
+          A->sorted = true;
+          A->nz = 0;
 #ifdef IDX_TYPE_LONG
-	  A->itype = CHOLMOD_LONG;
+          A->itype = CHOLMOD_LONG;
 #else
-	  A->itype = CHOLMOD_INT;
+          A->itype = CHOLMOD_INT;
 #endif
-	  A->dtype = CHOLMOD_DOUBLE;
-	  A->stype = 1;
-	  A->xtype = CHOLMOD_REAL;
-
-	  if (nr < 1)
-	    A->x = &dummy;
-	  else
-	    A->x = data();
-
-	  cholmod_sparse Bstore;
-	  cholmod_sparse *B = &Bstore;
-	  B->nrow = b.rows();
-	  B->ncol = b.cols();
-	  B->p = b.cidx();
-	  B->i = b.ridx();
-	  B->nzmax = b.nnz();
-	  B->packed = true;
-	  B->sorted = true;
-	  B->nz = 0;
+          A->dtype = CHOLMOD_DOUBLE;
+          A->stype = 1;
+          A->xtype = CHOLMOD_REAL;
+
+          if (nr < 1)
+            A->x = &dummy;
+          else
+            A->x = data();
+
+          cholmod_sparse Bstore;
+          cholmod_sparse *B = &Bstore;
+          B->nrow = b.rows();
+          B->ncol = b.cols();
+          B->p = b.cidx();
+          B->i = b.ridx();
+          B->nzmax = b.nnz();
+          B->packed = true;
+          B->sorted = true;
+          B->nz = 0;
 #ifdef IDX_TYPE_LONG
-	  B->itype = CHOLMOD_LONG;
+          B->itype = CHOLMOD_LONG;
 #else
-	  B->itype = CHOLMOD_INT;
+          B->itype = CHOLMOD_INT;
 #endif
-	  B->dtype = CHOLMOD_DOUBLE;
-	  B->stype = 0;
-	  B->xtype = CHOLMOD_REAL;
-
-	  if (b.rows() < 1 || b.cols() < 1)
-	    B->x = &dummy;
-	  else
-	    B->x = b.data();
-
-	  cholmod_factor *L;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  L = CHOLMOD_NAME(analyze) (A, cm);
-	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  if (calc_cond)
-	    rcond = CHOLMOD_NAME(rcond)(L, cm);
-	  else
-	    rcond = 1.;
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	  if (rcond == 0.0)
-	    {
-	      // Either its indefinite or singular. Try UMFPACK
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	  else
-	    {
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  err = -2;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		       rcond);
-	      
-		  return retval;
-		}
-
-	      cholmod_sparse *X;
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	      retval = SparseMatrix (static_cast<octave_idx_type>(X->nrow), 
-				     static_cast<octave_idx_type>(X->ncol),
-				     static_cast<octave_idx_type>(X->nzmax));
-	      for (octave_idx_type j = 0; 
-		   j <= static_cast<octave_idx_type>(X->ncol); j++)
-		retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
-	      for (octave_idx_type j = 0; 
-		   j < static_cast<octave_idx_type>(X->nzmax); j++)
-		{
-		  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
-		  retval.xdata(j) = static_cast<double *>(X->x)[j];
-		}
-
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CHOLMOD_NAME(free_sparse) (&X, cm);
-	      CHOLMOD_NAME(free_factor) (&L, cm);
-	      CHOLMOD_NAME(finish) (cm);
-	      static char tmp[] = " ";
-	      CHOLMOD_NAME(print_common) (tmp, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
+          B->dtype = CHOLMOD_DOUBLE;
+          B->stype = 0;
+          B->xtype = CHOLMOD_REAL;
+
+          if (b.rows() < 1 || b.cols() < 1)
+            B->x = &dummy;
+          else
+            B->x = b.data();
+
+          cholmod_factor *L;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          L = CHOLMOD_NAME(analyze) (A, cm);
+          CHOLMOD_NAME(factorize) (A, L, cm);
+          if (calc_cond)
+            rcond = CHOLMOD_NAME(rcond)(L, cm);
+          else
+            rcond = 1.;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+          if (rcond == 0.0)
+            {
+              // Either its indefinite or singular. Try UMFPACK
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+          else
+            {
+              volatile double rcond_plus_one = rcond + 1.0;
+
+              if (rcond_plus_one == 1.0 || xisnan (rcond))
+                {
+                  err = -2;
+
+                  if (sing_handler)
+                    {
+                      sing_handler (rcond);
+                      mattype.mark_as_rectangular ();
+                    }
+                  else
+                    (*current_liboctave_error_handler)
+                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                       rcond);
+              
+                  return retval;
+                }
+
+              cholmod_sparse *X;
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+              retval = SparseMatrix (static_cast<octave_idx_type>(X->nrow), 
+                                     static_cast<octave_idx_type>(X->ncol),
+                                     static_cast<octave_idx_type>(X->nzmax));
+              for (octave_idx_type j = 0; 
+                   j <= static_cast<octave_idx_type>(X->ncol); j++)
+                retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
+              for (octave_idx_type j = 0; 
+                   j < static_cast<octave_idx_type>(X->nzmax); j++)
+                {
+                  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
+                  retval.xdata(j) = static_cast<double *>(X->x)[j];
+                }
+
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CHOLMOD_NAME(free_sparse) (&X, cm);
+              CHOLMOD_NAME(free_factor) (&L, cm);
+              CHOLMOD_NAME(finish) (cm);
+              static char tmp[] = " ";
+              CHOLMOD_NAME(print_common) (tmp, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
 #else
-	  (*current_liboctave_warning_handler)
-	    ("CHOLMOD not installed");
-
-	  mattype.mark_as_unsymmetric ();
-	  typ = MatrixType::Full;
+          (*current_liboctave_warning_handler)
+            ("CHOLMOD not installed");
+
+          mattype.mark_as_unsymmetric ();
+          typ = MatrixType::Full;
 #endif
-	}
+        }
 
       if (typ == MatrixType::Full)
-	{
+        {
 #ifdef HAVE_UMFPACK
-	  Matrix Control, Info;
-	  void *Numeric = factorize (err, rcond, Control, Info, 
-				     sing_handler, calc_cond);
-
-	  if (err == 0)
-	    {
-	      octave_idx_type b_nr = b.rows ();
-	      octave_idx_type b_nc = b.cols ();
-	      int status = 0;
-	      double *control = Control.fortran_vec ();
-	      double *info = Info.fortran_vec ();
-	      const octave_idx_type *Ap = cidx ();
-	      const octave_idx_type *Ai = ridx ();
-	      const double *Ax = data ();
-
-	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-	      OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
-
-	      // Take a first guess that the number of non-zero terms
-	      // will be as many as in b
-	      octave_idx_type x_nz = b.nnz ();
-	      octave_idx_type ii = 0;
-	      retval = SparseMatrix (b_nr, b_nc, x_nz);
-
-	      retval.xcidx(0) = 0;
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    Bx[i] = b.elem (i, j);
-
-		  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap, 
-					     Ai, Ax, Xx, Bx, Numeric, control, 
-					     info);
-		  if (status < 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseMatrix::solve solve failed");
-
-		      UMFPACK_DNAME (report_status) (control, status);
-		  
-		      err = -1;
-
-		      break;
-		    }
-	      
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    {
-		      double tmp = Xx[i];
-		      if (tmp != 0.0)
-			{
-			  if (ii == x_nz)
-			    {
-			      // Resize the sparse matrix
-			      octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
-			      sz = (sz > 10 ? sz : 10) + x_nz;
-			      retval.change_capacity (sz);
-			      x_nz = sz;
-			    }
-			  retval.xdata(ii) = tmp;
-			  retval.xridx(ii++) = i;
-			}
-		    }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      UMFPACK_DNAME (report_info) (control, info);
-
-	      UMFPACK_DNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    mattype.mark_as_rectangular ();
+          Matrix Control, Info;
+          void *Numeric = factorize (err, rcond, Control, Info, 
+                                     sing_handler, calc_cond);
+
+          if (err == 0)
+            {
+              octave_idx_type b_nr = b.rows ();
+              octave_idx_type b_nc = b.cols ();
+              int status = 0;
+              double *control = Control.fortran_vec ();
+              double *info = Info.fortran_vec ();
+              const octave_idx_type *Ap = cidx ();
+              const octave_idx_type *Ai = ridx ();
+              const double *Ax = data ();
+
+              OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+              OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
+
+              // Take a first guess that the number of non-zero terms
+              // will be as many as in b
+              octave_idx_type x_nz = b.nnz ();
+              octave_idx_type ii = 0;
+              retval = SparseMatrix (b_nr, b_nc, x_nz);
+
+              retval.xcidx(0) = 0;
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    Bx[i] = b.elem (i, j);
+
+                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap, 
+                                             Ai, Ax, Xx, Bx, Numeric, control, 
+                                             info);
+                  if (status < 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseMatrix::solve solve failed");
+
+                      UMFPACK_DNAME (report_status) (control, status);
+                  
+                      err = -1;
+
+                      break;
+                    }
+              
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    {
+                      double tmp = Xx[i];
+                      if (tmp != 0.0)
+                        {
+                          if (ii == x_nz)
+                            {
+                              // Resize the sparse matrix
+                              octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
+                              sz = (sz > 10 ? sz : 10) + x_nz;
+                              retval.change_capacity (sz);
+                              x_nz = sz;
+                            }
+                          retval.xdata(ii) = tmp;
+                          retval.xridx(ii++) = i;
+                        }
+                    }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              UMFPACK_DNAME (report_info) (control, info);
+
+              UMFPACK_DNAME (free_numeric) (&Numeric);
+            }
+          else
+            mattype.mark_as_rectangular ();
 
 #else
-	  (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
-	}
+        }
       else if (typ != MatrixType::Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b, 
-		      octave_idx_type& err, double& rcond,
-		      solve_singularity_handler sing_handler,
-		      bool calc_cond) const
+                      octave_idx_type& err, double& rcond,
+                      solve_singularity_handler sing_handler,
+                      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -6300,231 +6300,231 @@ SparseMatrix::fsolve (MatrixType &mattyp
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
-	{
+        {
 #ifdef HAVE_CHOLMOD
-	  cholmod_common Common;
-	  cholmod_common *cm = &Common;
-
-	  // Setup initial parameters
-	  CHOLMOD_NAME(start) (cm);
-	  cm->prefer_zomplex = false;
-
-	  double spu = octave_sparse_params::get_key ("spumoni");
-	  if (spu == 0.)
-	    {
-	      cm->print = -1;
-	      cm->print_function = 0;
-	    }
-	  else
-	    {
-	      cm->print = static_cast<int> (spu) + 2;
-	      cm->print_function =&SparseCholPrint;
-	    }
-
-	  cm->error_handler = &SparseCholError;
-	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
-	  cm->hypotenuse = CHOLMOD_NAME(hypot);
-
-	  cm->final_ll = true;
-
-	  cholmod_sparse Astore;
-	  cholmod_sparse *A = &Astore;
-	  double dummy;
-	  A->nrow = nr;
-	  A->ncol = nc;
-
-	  A->p = cidx();
-	  A->i = ridx();
-	  A->nzmax = nnz();
-	  A->packed = true;
-	  A->sorted = true;
-	  A->nz = 0;
+          cholmod_common Common;
+          cholmod_common *cm = &Common;
+
+          // Setup initial parameters
+          CHOLMOD_NAME(start) (cm);
+          cm->prefer_zomplex = false;
+
+          double spu = octave_sparse_params::get_key ("spumoni");
+          if (spu == 0.)
+            {
+              cm->print = -1;
+              cm->print_function = 0;
+            }
+          else
+            {
+              cm->print = static_cast<int> (spu) + 2;
+              cm->print_function =&SparseCholPrint;
+            }
+
+          cm->error_handler = &SparseCholError;
+          cm->complex_divide = CHOLMOD_NAME(divcomplex);
+          cm->hypotenuse = CHOLMOD_NAME(hypot);
+
+          cm->final_ll = true;
+
+          cholmod_sparse Astore;
+          cholmod_sparse *A = &Astore;
+          double dummy;
+          A->nrow = nr;
+          A->ncol = nc;
+
+          A->p = cidx();
+          A->i = ridx();
+          A->nzmax = nnz();
+          A->packed = true;
+          A->sorted = true;
+          A->nz = 0;
 #ifdef IDX_TYPE_LONG
-	  A->itype = CHOLMOD_LONG;
+          A->itype = CHOLMOD_LONG;
 #else
-	  A->itype = CHOLMOD_INT;
+          A->itype = CHOLMOD_INT;
 #endif
-	  A->dtype = CHOLMOD_DOUBLE;
-	  A->stype = 1;
-	  A->xtype = CHOLMOD_REAL;
-
-	  if (nr < 1)
-	    A->x = &dummy;
-	  else
-	    A->x = data();
-
-	  cholmod_dense Bstore;
-	  cholmod_dense *B = &Bstore;
-	  B->nrow = b.rows();
-	  B->ncol = b.cols();
-	  B->d = B->nrow;
-	  B->nzmax = B->nrow * B->ncol;
-	  B->dtype = CHOLMOD_DOUBLE;
-	  B->xtype = CHOLMOD_COMPLEX;
-	  if (nc < 1 || b.cols() < 1)
-	    B->x = &dummy;
-	  else
-	    // We won't alter it, honest :-)
-	    B->x = const_cast<Complex *>(b.fortran_vec());
-
-	  cholmod_factor *L;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  L = CHOLMOD_NAME(analyze) (A, cm);
-	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  if (calc_cond)
-	    rcond = CHOLMOD_NAME(rcond)(L, cm);
-	  else
-	    rcond = 1.0;
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	  if (rcond == 0.0)
-	    {
-	      // Either its indefinite or singular. Try UMFPACK
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	  else
-	    {
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  err = -2;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		       rcond);
-	      
-		  return retval;
-		}
-
-	      cholmod_dense *X;
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	      retval.resize (b.rows (), b.cols());
-	      for (octave_idx_type j = 0; j < b.cols(); j++)
-		{
-		  octave_idx_type jr = j * b.rows();
-		  for (octave_idx_type i = 0; i < b.rows(); i++)
-		    retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
-		}
-
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CHOLMOD_NAME(free_dense) (&X, cm);
-	      CHOLMOD_NAME(free_factor) (&L, cm);
-	      CHOLMOD_NAME(finish) (cm);
-	      static char tmp[] = " ";
-	      CHOLMOD_NAME(print_common) (tmp, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
+          A->dtype = CHOLMOD_DOUBLE;
+          A->stype = 1;
+          A->xtype = CHOLMOD_REAL;
+
+          if (nr < 1)
+            A->x = &dummy;
+          else
+            A->x = data();
+
+          cholmod_dense Bstore;
+          cholmod_dense *B = &Bstore;
+          B->nrow = b.rows();
+          B->ncol = b.cols();
+          B->d = B->nrow;
+          B->nzmax = B->nrow * B->ncol;
+          B->dtype = CHOLMOD_DOUBLE;
+          B->xtype = CHOLMOD_COMPLEX;
+          if (nc < 1 || b.cols() < 1)
+            B->x = &dummy;
+          else
+            // We won't alter it, honest :-)
+            B->x = const_cast<Complex *>(b.fortran_vec());
+
+          cholmod_factor *L;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          L = CHOLMOD_NAME(analyze) (A, cm);
+          CHOLMOD_NAME(factorize) (A, L, cm);
+          if (calc_cond)
+            rcond = CHOLMOD_NAME(rcond)(L, cm);
+          else
+            rcond = 1.0;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+          if (rcond == 0.0)
+            {
+              // Either its indefinite or singular. Try UMFPACK
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+          else
+            {
+              volatile double rcond_plus_one = rcond + 1.0;
+
+              if (rcond_plus_one == 1.0 || xisnan (rcond))
+                {
+                  err = -2;
+
+                  if (sing_handler)
+                    {
+                      sing_handler (rcond);
+                      mattype.mark_as_rectangular ();
+                    }
+                  else
+                    (*current_liboctave_error_handler)
+                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                       rcond);
+              
+                  return retval;
+                }
+
+              cholmod_dense *X;
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+              retval.resize (b.rows (), b.cols());
+              for (octave_idx_type j = 0; j < b.cols(); j++)
+                {
+                  octave_idx_type jr = j * b.rows();
+                  for (octave_idx_type i = 0; i < b.rows(); i++)
+                    retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
+                }
+
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CHOLMOD_NAME(free_dense) (&X, cm);
+              CHOLMOD_NAME(free_factor) (&L, cm);
+              CHOLMOD_NAME(finish) (cm);
+              static char tmp[] = " ";
+              CHOLMOD_NAME(print_common) (tmp, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
 #else
-	  (*current_liboctave_warning_handler)
-	    ("CHOLMOD not installed");
-
-	  mattype.mark_as_unsymmetric ();
-	  typ = MatrixType::Full;
+          (*current_liboctave_warning_handler)
+            ("CHOLMOD not installed");
+
+          mattype.mark_as_unsymmetric ();
+          typ = MatrixType::Full;
 #endif
-	}
+        }
 
       if (typ == MatrixType::Full)
-	{
+        {
 #ifdef HAVE_UMFPACK
-	  Matrix Control, Info;
-	  void *Numeric = factorize (err, rcond, Control, Info, 
-				     sing_handler, calc_cond);
-
-	  if (err == 0)
-	    {
-	      octave_idx_type b_nr = b.rows ();
-	      octave_idx_type b_nc = b.cols ();
-	      int status = 0;
-	      double *control = Control.fortran_vec ();
-	      double *info = Info.fortran_vec ();
-	      const octave_idx_type *Ap = cidx ();
-	      const octave_idx_type *Ai = ridx ();
-	      const double *Ax = data ();
-
-	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-	      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-
-	      retval.resize (b_nr, b_nc);
-
-	      OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
-	      OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
-	      
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    {
-		      Complex c = b (i,j);
-		      Bx[i] = std::real (c);
-		      Bz[i] = std::imag (c);
-		    }
-
-		  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap, 
-					     Ai, Ax, Xx, Bx, Numeric, control, 
-					     info);
-		  int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
-						  Ap, Ai, Ax, Xz, Bz, Numeric, 
-						  control, info) ;
-
-		  if (status < 0 || status2 < 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseMatrix::solve solve failed");
-
-		      UMFPACK_DNAME (report_status) (control, status);
-		      
-		      err = -1;
-
-		      break;
-		    }
-
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    retval (i, j) = Complex (Xx[i], Xz[i]);
-		}
-
-	      UMFPACK_DNAME (report_info) (control, info);
-
-	      UMFPACK_DNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    mattype.mark_as_rectangular ();
+          Matrix Control, Info;
+          void *Numeric = factorize (err, rcond, Control, Info, 
+                                     sing_handler, calc_cond);
+
+          if (err == 0)
+            {
+              octave_idx_type b_nr = b.rows ();
+              octave_idx_type b_nc = b.cols ();
+              int status = 0;
+              double *control = Control.fortran_vec ();
+              double *info = Info.fortran_vec ();
+              const octave_idx_type *Ap = cidx ();
+              const octave_idx_type *Ai = ridx ();
+              const double *Ax = data ();
+
+              OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+              OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
+
+              retval.resize (b_nr, b_nc);
+
+              OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
+              OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
+              
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    {
+                      Complex c = b (i,j);
+                      Bx[i] = std::real (c);
+                      Bz[i] = std::imag (c);
+                    }
+
+                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap, 
+                                             Ai, Ax, Xx, Bx, Numeric, control, 
+                                             info);
+                  int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
+                                                  Ap, Ai, Ax, Xz, Bz, Numeric, 
+                                                  control, info) ;
+
+                  if (status < 0 || status2 < 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseMatrix::solve solve failed");
+
+                      UMFPACK_DNAME (report_status) (control, status);
+                      
+                      err = -1;
+
+                      break;
+                    }
+
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    retval (i, j) = Complex (Xx[i], Xz[i]);
+                }
+
+              UMFPACK_DNAME (report_info) (control, info);
+
+              UMFPACK_DNAME (free_numeric) (&Numeric);
+            }
+          else
+            mattype.mark_as_rectangular ();
 
 #else
-	  (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
-	}
+        }
       else if (typ != MatrixType::Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::fsolve (MatrixType &mattype, const SparseComplexMatrix& b, 
-		      octave_idx_type& err, double& rcond,
-		      solve_singularity_handler sing_handler,
-		      bool calc_cond) const
+                      octave_idx_type& err, double& rcond,
+                      solve_singularity_handler sing_handler,
+                      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
@@ -6534,291 +6534,291 @@ SparseMatrix::fsolve (MatrixType &mattyp
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
-	{
+        {
 #ifdef HAVE_CHOLMOD
-	  cholmod_common Common;
-	  cholmod_common *cm = &Common;
-
-	  // Setup initial parameters
-	  CHOLMOD_NAME(start) (cm);
-	  cm->prefer_zomplex = false;
-
-	  double spu = octave_sparse_params::get_key ("spumoni");
-	  if (spu == 0.)
-	    {
-	      cm->print = -1;
-	      cm->print_function = 0;
-	    }
-	  else
-	    {
-	      cm->print = static_cast<int> (spu) + 2;
-	      cm->print_function =&SparseCholPrint;
-	    }
-
-	  cm->error_handler = &SparseCholError;
-	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
-	  cm->hypotenuse = CHOLMOD_NAME(hypot);
-
-	  cm->final_ll = true;
-
-	  cholmod_sparse Astore;
-	  cholmod_sparse *A = &Astore;
-	  double dummy;
-	  A->nrow = nr;
-	  A->ncol = nc;
-
-	  A->p = cidx();
-	  A->i = ridx();
-	  A->nzmax = nnz();
-	  A->packed = true;
-	  A->sorted = true;
-	  A->nz = 0;
+          cholmod_common Common;
+          cholmod_common *cm = &Common;
+
+          // Setup initial parameters
+          CHOLMOD_NAME(start) (cm);
+          cm->prefer_zomplex = false;
+
+          double spu = octave_sparse_params::get_key ("spumoni");
+          if (spu == 0.)
+            {
+              cm->print = -1;
+              cm->print_function = 0;
+            }
+          else
+            {
+              cm->print = static_cast<int> (spu) + 2;
+              cm->print_function =&SparseCholPrint;
+            }
+
+          cm->error_handler = &SparseCholError;
+          cm->complex_divide = CHOLMOD_NAME(divcomplex);
+          cm->hypotenuse = CHOLMOD_NAME(hypot);
+
+          cm->final_ll = true;
+
+          cholmod_sparse Astore;
+          cholmod_sparse *A = &Astore;
+          double dummy;
+          A->nrow = nr;
+          A->ncol = nc;
+
+          A->p = cidx();
+          A->i = ridx();
+          A->nzmax = nnz();
+          A->packed = true;
+          A->sorted = true;
+          A->nz = 0;
 #ifdef IDX_TYPE_LONG
-	  A->itype = CHOLMOD_LONG;
+          A->itype = CHOLMOD_LONG;
 #else
-	  A->itype = CHOLMOD_INT;
+          A->itype = CHOLMOD_INT;
 #endif
-	  A->dtype = CHOLMOD_DOUBLE;
-	  A->stype = 1;
-	  A->xtype = CHOLMOD_REAL;
-
-	  if (nr < 1)
-	    A->x = &dummy;
-	  else
-	    A->x = data();
-
-	  cholmod_sparse Bstore;
-	  cholmod_sparse *B = &Bstore;
-	  B->nrow = b.rows();
-	  B->ncol = b.cols();
-	  B->p = b.cidx();
-	  B->i = b.ridx();
-	  B->nzmax = b.nnz();
-	  B->packed = true;
-	  B->sorted = true;
-	  B->nz = 0;
+          A->dtype = CHOLMOD_DOUBLE;
+          A->stype = 1;
+          A->xtype = CHOLMOD_REAL;
+
+          if (nr < 1)
+            A->x = &dummy;
+          else
+            A->x = data();
+
+          cholmod_sparse Bstore;
+          cholmod_sparse *B = &Bstore;
+          B->nrow = b.rows();
+          B->ncol = b.cols();
+          B->p = b.cidx();
+          B->i = b.ridx();
+          B->nzmax = b.nnz();
+          B->packed = true;
+          B->sorted = true;
+          B->nz = 0;
 #ifdef IDX_TYPE_LONG
-	  B->itype = CHOLMOD_LONG;
+          B->itype = CHOLMOD_LONG;
 #else
-	  B->itype = CHOLMOD_INT;
+          B->itype = CHOLMOD_INT;
 #endif
-	  B->dtype = CHOLMOD_DOUBLE;
-	  B->stype = 0;
-	  B->xtype = CHOLMOD_COMPLEX;
-
-	  if (b.rows() < 1 || b.cols() < 1)
-	    B->x = &dummy;
-	  else
-	    B->x = b.data();
-
-	  cholmod_factor *L;
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  L = CHOLMOD_NAME(analyze) (A, cm);
-	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  if (calc_cond)
-	    rcond = CHOLMOD_NAME(rcond)(L, cm);
-	  else
-	    rcond = 1.0;
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	  if (rcond == 0.0)
-	    {
-	      // Either its indefinite or singular. Try UMFPACK
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	  else
-	    {
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  err = -2;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
-		       rcond);
-	      
-		  return retval;
-		}
-
-	      cholmod_sparse *X;
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-	      retval = SparseComplexMatrix 
-		(static_cast<octave_idx_type>(X->nrow), 
-		 static_cast<octave_idx_type>(X->ncol),
-		 static_cast<octave_idx_type>(X->nzmax));
-	      for (octave_idx_type j = 0; 
-		   j <= static_cast<octave_idx_type>(X->ncol); j++)
-		retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
-	      for (octave_idx_type j = 0; 
-		   j < static_cast<octave_idx_type>(X->nzmax); j++)
-		{
-		  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
-		  retval.xdata(j) = static_cast<Complex *>(X->x)[j];
-		}
-
-	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CHOLMOD_NAME(free_sparse) (&X, cm);
-	      CHOLMOD_NAME(free_factor) (&L, cm);
-	      CHOLMOD_NAME(finish) (cm);
-	      static char tmp[] = " ";
-	      CHOLMOD_NAME(print_common) (tmp, cm);
-	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	    }
+          B->dtype = CHOLMOD_DOUBLE;
+          B->stype = 0;
+          B->xtype = CHOLMOD_COMPLEX;
+
+          if (b.rows() < 1 || b.cols() < 1)
+            B->x = &dummy;
+          else
+            B->x = b.data();
+
+          cholmod_factor *L;
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          L = CHOLMOD_NAME(analyze) (A, cm);
+          CHOLMOD_NAME(factorize) (A, L, cm);
+          if (calc_cond)
+            rcond = CHOLMOD_NAME(rcond)(L, cm);
+          else
+            rcond = 1.0;
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+          if (rcond == 0.0)
+            {
+              // Either its indefinite or singular. Try UMFPACK
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+          else
+            {
+              volatile double rcond_plus_one = rcond + 1.0;
+
+              if (rcond_plus_one == 1.0 || xisnan (rcond))
+                {
+                  err = -2;
+
+                  if (sing_handler)
+                    {
+                      sing_handler (rcond);
+                      mattype.mark_as_rectangular ();
+                    }
+                  else
+                    (*current_liboctave_error_handler)
+                      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
+                       rcond);
+              
+                  return retval;
+                }
+
+              cholmod_sparse *X;
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+              retval = SparseComplexMatrix 
+                (static_cast<octave_idx_type>(X->nrow), 
+                 static_cast<octave_idx_type>(X->ncol),
+                 static_cast<octave_idx_type>(X->nzmax));
+              for (octave_idx_type j = 0; 
+                   j <= static_cast<octave_idx_type>(X->ncol); j++)
+                retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
+              for (octave_idx_type j = 0; 
+                   j < static_cast<octave_idx_type>(X->nzmax); j++)
+                {
+                  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
+                  retval.xdata(j) = static_cast<Complex *>(X->x)[j];
+                }
+
+              BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+              CHOLMOD_NAME(free_sparse) (&X, cm);
+              CHOLMOD_NAME(free_factor) (&L, cm);
+              CHOLMOD_NAME(finish) (cm);
+              static char tmp[] = " ";
+              CHOLMOD_NAME(print_common) (tmp, cm);
+              END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+            }
 #else
-	  (*current_liboctave_warning_handler)
-	    ("CHOLMOD not installed");
-
-	  mattype.mark_as_unsymmetric ();
-	  typ = MatrixType::Full;
+          (*current_liboctave_warning_handler)
+            ("CHOLMOD not installed");
+
+          mattype.mark_as_unsymmetric ();
+          typ = MatrixType::Full;
 #endif
-	}
+        }
 
       if (typ == MatrixType::Full)
-	{
+        {
 #ifdef HAVE_UMFPACK
-	  Matrix Control, Info;
-	  void *Numeric = factorize (err, rcond, Control, Info, 
-				     sing_handler, calc_cond);
-
-	  if (err == 0)
-	    {
-	      octave_idx_type b_nr = b.rows ();
-	      octave_idx_type b_nc = b.cols ();
-	      int status = 0;
-	      double *control = Control.fortran_vec ();
-	      double *info = Info.fortran_vec ();
-	      const octave_idx_type *Ap = cidx ();
-	      const octave_idx_type *Ai = ridx ();
-	      const double *Ax = data ();
-
-	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-	      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-
-	      // Take a first guess that the number of non-zero terms
-	      // will be as many as in b
-	      octave_idx_type x_nz = b.nnz ();
-	      octave_idx_type ii = 0;
-	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-	      OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
-	      OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
-	      
-	      retval.xcidx(0) = 0;
-	      for (octave_idx_type j = 0; j < b_nc; j++)
-		{
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    {
-		      Complex c = b (i,j);
-		      Bx[i] = std::real (c);
-		      Bz[i] = std::imag (c);
-		    }
-
-		  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
-					     Ai, Ax, Xx, Bx, Numeric, control, 
-					     info);
-		  int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
-						  Ap, Ai, Ax, Xz, Bz, Numeric, 
-						  control, info) ;
-
-		  if (status < 0 || status2 < 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseMatrix::solve solve failed");
-
-		      UMFPACK_DNAME (report_status) (control, status);
-		      
-		      err = -1;
-
-		      break;
-		    }
-
-		  for (octave_idx_type i = 0; i < b_nr; i++)
-		    {
-		      Complex tmp = Complex (Xx[i], Xz[i]);
-		      if (tmp != 0.0)
-			{
-			  if (ii == x_nz)
-			    {
-			      // Resize the sparse matrix
-			      octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
-			      sz = (sz > 10 ? sz : 10) + x_nz;
-			      retval.change_capacity (sz);
-			      x_nz = sz;
-			    }
-			  retval.xdata(ii) = tmp;
-			  retval.xridx(ii++) = i;
-			}
-		    }
-		  retval.xcidx(j+1) = ii;
-		}
-
-	      retval.maybe_compress ();
-
-	      UMFPACK_DNAME (report_info) (control, info);
-
-	      UMFPACK_DNAME (free_numeric) (&Numeric);
-	    }
-	  else
-	    mattype.mark_as_rectangular ();
+          Matrix Control, Info;
+          void *Numeric = factorize (err, rcond, Control, Info, 
+                                     sing_handler, calc_cond);
+
+          if (err == 0)
+            {
+              octave_idx_type b_nr = b.rows ();
+              octave_idx_type b_nc = b.cols ();
+              int status = 0;
+              double *control = Control.fortran_vec ();
+              double *info = Info.fortran_vec ();
+              const octave_idx_type *Ap = cidx ();
+              const octave_idx_type *Ai = ridx ();
+              const double *Ax = data ();
+
+              OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+              OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
+
+              // Take a first guess that the number of non-zero terms
+              // will be as many as in b
+              octave_idx_type x_nz = b.nnz ();
+              octave_idx_type ii = 0;
+              retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+              OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
+              OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
+              
+              retval.xcidx(0) = 0;
+              for (octave_idx_type j = 0; j < b_nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    {
+                      Complex c = b (i,j);
+                      Bx[i] = std::real (c);
+                      Bz[i] = std::imag (c);
+                    }
+
+                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
+                                             Ai, Ax, Xx, Bx, Numeric, control, 
+                                             info);
+                  int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
+                                                  Ap, Ai, Ax, Xz, Bz, Numeric, 
+                                                  control, info) ;
+
+                  if (status < 0 || status2 < 0)
+                    {
+                      (*current_liboctave_error_handler) 
+                        ("SparseMatrix::solve solve failed");
+
+                      UMFPACK_DNAME (report_status) (control, status);
+                      
+                      err = -1;
+
+                      break;
+                    }
+
+                  for (octave_idx_type i = 0; i < b_nr; i++)
+                    {
+                      Complex tmp = Complex (Xx[i], Xz[i]);
+                      if (tmp != 0.0)
+                        {
+                          if (ii == x_nz)
+                            {
+                              // Resize the sparse matrix
+                              octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
+                              sz = (sz > 10 ? sz : 10) + x_nz;
+                              retval.change_capacity (sz);
+                              x_nz = sz;
+                            }
+                          retval.xdata(ii) = tmp;
+                          retval.xridx(ii++) = i;
+                        }
+                    }
+                  retval.xcidx(j+1) = ii;
+                }
+
+              retval.maybe_compress ();
+
+              UMFPACK_DNAME (report_info) (control, info);
+
+              UMFPACK_DNAME (free_numeric) (&Numeric);
+            }
+          else
+            mattype.mark_as_rectangular ();
 #else
-	  (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
-	}
+        }
       else if (typ != MatrixType::Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 Matrix
 SparseMatrix::solve (MatrixType &mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
 SparseMatrix::solve (MatrixType &mattype, const Matrix& b, 
-		     octave_idx_type& info) const
+                     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
 SparseMatrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& info, 
-		     double& rcond) const
+                     double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
 SparseMatrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& err, 
-		     double& rcond, solve_singularity_handler sing_handler,
-		     bool singular_fallback) const
+                     double& rcond, solve_singularity_handler sing_handler,
+                     bool singular_fallback) const
 {
   Matrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for CHOLMOD/UMFPACK
@@ -6826,17 +6826,17 @@ SparseMatrix::solve (MatrixType &mattype
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal || 
-	   typ == MatrixType::Tridiagonal_Hermitian)
+           typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return Matrix ();
     }
@@ -6860,204 +6860,204 @@ SparseMatrix::solve (MatrixType &mattype
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b, 
-		     octave_idx_type& info) const
+                     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
-		     octave_idx_type& info, double& rcond) const
+                     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b, 
-		     octave_idx_type& err, double& rcond,
-		     solve_singularity_handler sing_handler,
-		     bool singular_fallback) const
+                     octave_idx_type& err, double& rcond,
+                     solve_singularity_handler sing_handler,
+                     bool singular_fallback) const
 {
   SparseMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal || 
-	   typ == MatrixType::Tridiagonal_Hermitian)
+           typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseMatrix ();
     }
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseMatrix, SparseMatrix, 
-	SparseMatrix> (*this, b, err);
+        SparseMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
-			    octave_idx_type& info) const
+                            octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
-		     octave_idx_type& info, double& rcond) const
+                     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler,
-		     bool singular_fallback) const
+                     octave_idx_type& err, double& rcond, 
+                     solve_singularity_handler sing_handler,
+                     bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal || 
-	   typ == MatrixType::Tridiagonal_Hermitian)
+           typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
   if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseMatrix, 
-	ComplexMatrix> (*this, b, err);
+        ComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b, 
-		     octave_idx_type& info) const
+                     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
-		     octave_idx_type& info, double& rcond) const
+                     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b, 
-		     octave_idx_type& err, double& rcond,
-		     solve_singularity_handler sing_handler,
-		     bool singular_fallback) const
+                     octave_idx_type& err, double& rcond,
+                     solve_singularity_handler sing_handler,
+                     bool singular_fallback) const
 {
   SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal || 
-	   typ == MatrixType::Tridiagonal_Hermitian)
+           typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
   if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseMatrix, 
-	SparseComplexMatrix> (*this, b, err);
+        SparseComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ColumnVector
 SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b) const
@@ -7076,17 +7076,17 @@ SparseMatrix::solve (MatrixType &mattype
 ColumnVector
 SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b, octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ColumnVector
 SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b, octave_idx_type& info, double& rcond,
-	       solve_singularity_handler sing_handler) const
+               solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
   return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b) const
 {
@@ -7099,24 +7099,24 @@ ComplexColumnVector
 SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info, 
-		     double& rcond) const
+                     double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
-	       solve_singularity_handler sing_handler) const
+               solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 Matrix
 SparseMatrix::solve (const Matrix& b) const
 {
@@ -7129,113 +7129,113 @@ Matrix
 SparseMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 Matrix
 SparseMatrix::solve (const Matrix& b, octave_idx_type& info, 
-		     double& rcond) const
+                     double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 Matrix
 SparseMatrix::solve (const Matrix& b, octave_idx_type& err, 
-		     double& rcond, 
-		     solve_singularity_handler sing_handler) const
+                     double& rcond, 
+                     solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b, 
-		     octave_idx_type& info) const
+                     octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b,
-		     octave_idx_type& info, double& rcond) const
+                     octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b, 
-		     octave_idx_type& err, double& rcond,
-		     solve_singularity_handler sing_handler) const
+                     octave_idx_type& err, double& rcond,
+                     solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexMatrix
 SparseMatrix::solve (const ComplexMatrix& b, 
-			    octave_idx_type& info) const
+                            octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (const ComplexMatrix& b, 
-		     octave_idx_type& info, double& rcond) const
+                     octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (const ComplexMatrix& b, 
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler) const
+                     octave_idx_type& err, double& rcond, 
+                     solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b, 
-		     octave_idx_type& info) const
+                     octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b,
-		     octave_idx_type& info, double& rcond) const
+                     octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b, 
-		     octave_idx_type& err, double& rcond,
-		     solve_singularity_handler sing_handler) const
+                     octave_idx_type& err, double& rcond,
+                     solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ColumnVector
 SparseMatrix::solve (const ColumnVector& b) const
 {
@@ -7253,17 +7253,17 @@ SparseMatrix::solve (const ColumnVector&
 ColumnVector
 SparseMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ColumnVector
 SparseMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
-	       solve_singularity_handler sing_handler) const
+               solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
   return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b) const
 {
@@ -7276,92 +7276,92 @@ ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, 
-		     double& rcond) const
+                     double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
-	       solve_singularity_handler sing_handler) const
+               solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 // other operations.
 
 bool
 SparseMatrix::any_element_is_negative (bool neg_zero) const
 {
   octave_idx_type nel = nnz ();
 
   if (neg_zero)
     {
       for (octave_idx_type i = 0; i < nel; i++)
-	if (lo_ieee_signbit (data (i)))
-	  return true;
+        if (lo_ieee_signbit (data (i)))
+          return true;
     }
   else
     {
       for (octave_idx_type i = 0; i < nel; i++)
-	if (data (i) < 0)
-	  return true;
+        if (data (i) < 0)
+          return true;
     }
 
   return false;
 }
 
 bool
 SparseMatrix::any_element_is_nan (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
       if (xisnan (val))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 SparseMatrix::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
       if (xisinf (val) || xisnan (val))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 SparseMatrix::any_element_not_one_or_zero (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
       if (val != 0.0 && val != 1.0)
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 SparseMatrix::all_elements_are_zero (void) const
 {
@@ -7378,19 +7378,19 @@ bool
 SparseMatrix::all_elements_are_int_or_inf_or_nan (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
       if (xisnan (val) || D_NINT (val) == val)
-	continue;
+        continue;
       else
-	return false;
+        return false;
     }
 
   return true;
 }
 
 // Return nonzero if any element of M is not an integer.  Also extract
 // the largest and smallest values and return them in MAX_VAL and MIN_VAL.
 
@@ -7405,39 +7405,39 @@ SparseMatrix::all_integers (double& max_
   max_val = data (0);
   min_val = data (0);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
 
       if (val > max_val)
-	max_val = val;
+        max_val = val;
 
       if (val < min_val)
-	min_val = val;
+        min_val = val;
 
       if (D_NINT (val) != val)
-	return false;
+        return false;
     }
 
   return true;
 }
 
 bool
 SparseMatrix::too_large_for_float (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
 
       if (val > FLT_MAX || val < FLT_MIN)
-	return true;
+        return true;
     }
 
   return false;
 }
 
 SparseBoolMatrix 
 SparseMatrix::operator ! (void) const 
 { 
@@ -7449,25 +7449,25 @@ SparseMatrix::operator ! (void) const
   SparseBoolMatrix r (nr, nc, nz2);
    
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = 0; j < nr; j++)
-	{
-	  if (jj < cidx(i+1) && ridx(jj) == j)
-	    jj++;
-	  else
-	    {
-	      r.data(ii) = true;
-	      r.ridx(ii++) = j;
-	    }
-	}
+        {
+          if (jj < cidx(i+1) && ridx(jj) == j)
+            jj++;
+          else
+            {
+              r.data(ii) = true;
+              r.ridx(ii++) = j;
+            }
+        }
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
@@ -7499,17 +7499,17 @@ SparseMatrix::cumsum (int dim) const
 SparseMatrix
 SparseMatrix::prod (int dim) const
 {
   if ((rows() == 1 && dim == -1) || dim == 1)
     return transpose (). prod (0). transpose();
   else
     {
       SPARSE_REDUCTION_OP (SparseMatrix, double, *=, 
-			   (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
+                           (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseMatrix
 SparseMatrix::sum (int dim) const
 {
   SPARSE_REDUCTION_OP (SparseMatrix, double, +=, 0.0, 0.0);
 }
@@ -7521,17 +7521,17 @@ SparseMatrix::sumsq (int dim) const
   double d = data (i); \
   tmp[ridx(i)] += d * d
 
 #define COL_EXPR \
   double d = data (i); \
   tmp[j] += d * d
 
   SPARSE_BASE_REDUCTION_OP (SparseMatrix, double, ROW_EXPR, COL_EXPR, 
-			    0.0, 0.0);
+                            0.0, 0.0);
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
 SparseMatrix
 SparseMatrix::abs (void) const
 {
@@ -7570,19 +7570,19 @@ operator << (std::ostream& os, const Spa
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)  {
       octave_quit ();
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++) {
-	os << a.ridx(i) + 1 << " "  << j + 1 << " ";
-	octave_write_double (os, a.data(i));
-	os << "\n";
+        os << a.ridx(i) + 1 << " "  << j + 1 << " ";
+        octave_write_double (os, a.data(i));
+        os << "\n";
       }
    }
 
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseMatrix& a)
@@ -7735,53 +7735,53 @@ min (double d, const SparseMatrix& m)
 
   EMPTY_RETURN_CHECK (SparseMatrix);
 
   // Count the number of non-zero elements
   if (d < 0.)
     {
       result = SparseMatrix (nr, nc, d);
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-	  {
-	    double tmp = xmin (d, m.data (i));
-	    if (tmp != 0.)
-	      {
-		octave_idx_type idx = m.ridx(i) + j * nr;
-		result.xdata(idx) = tmp;
-		result.xridx(idx) = m.ridx(i);
-	      }
-	  }
+        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+          {
+            double tmp = xmin (d, m.data (i));
+            if (tmp != 0.)
+              {
+                octave_idx_type idx = m.ridx(i) + j * nr;
+                result.xdata(idx) = tmp;
+                result.xridx(idx) = m.ridx(i);
+              }
+          }
     }
   else
     {
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-	  if (xmin (d, m.data (i)) != 0.)
-	    nel++;
+        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+          if (xmin (d, m.data (i)) != 0.)
+            nel++;
 
       result = SparseMatrix (nr, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx(0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-	    {
-	      double tmp = xmin (d, m.data (i));
-
-	      if (tmp != 0.)
-		{
-		  result.xdata(ii) = tmp;
-		  result.xridx(ii++) = m.ridx(i);
-		}
-	    }
-	  result.xcidx(j+1) = ii;
-	}
+        {
+          for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+            {
+              double tmp = xmin (d, m.data (i));
+
+              if (tmp != 0.)
+                {
+                  result.xdata(ii) = tmp;
+                  result.xridx(ii++) = m.ridx(i);
+                }
+            }
+          result.xcidx(j+1) = ii;
+        }
     }
 
   return result;
 }
 
 SparseMatrix
 min (const SparseMatrix& m, double d)
 {
@@ -7797,82 +7797,82 @@ min (const SparseMatrix& a, const Sparse
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
-	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
+        gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
-	{
-	  r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
+        {
+          r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
-	  octave_idx_type jx = 0;
-	  r.cidx (0) = 0;
-	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
-	    {
-	      octave_idx_type  ja = a.cidx(i);
-	      octave_idx_type  ja_max = a.cidx(i+1);
-	      bool ja_lt_max= ja < ja_max;
+          octave_idx_type jx = 0;
+          r.cidx (0) = 0;
+          for (octave_idx_type i = 0 ; i < a_nc ; i++)
+            {
+              octave_idx_type  ja = a.cidx(i);
+              octave_idx_type  ja_max = a.cidx(i+1);
+              bool ja_lt_max= ja < ja_max;
            
-	      octave_idx_type  jb = b.cidx(i);
-	      octave_idx_type  jb_max = b.cidx(i+1);
-	      bool jb_lt_max = jb < jb_max;
+              octave_idx_type  jb = b.cidx(i);
+              octave_idx_type  jb_max = b.cidx(i+1);
+              bool jb_lt_max = jb < jb_max;
            
-	      while (ja_lt_max || jb_lt_max )
-		{
-		  octave_quit ();
-		  if ((! jb_lt_max) ||
+              while (ja_lt_max || jb_lt_max )
+                {
+                  octave_quit ();
+                  if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
-		    {
-		      double tmp = xmin (a.data(ja), 0.);
-		      if (tmp != 0.)
-			{
-			  r.ridx(jx) = a.ridx(ja);
-			  r.data(jx) = tmp;
-			  jx++;
-			}
-		      ja++;
-		      ja_lt_max= ja < ja_max;
-		    }
-		  else if (( !ja_lt_max ) ||
-			   (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
-		    {
-		      double tmp = xmin (0., b.data(jb));
-		      if (tmp != 0.)
-			{
-			  r.ridx(jx) = b.ridx(jb);
-			  r.data(jx) = tmp;
-			  jx++;
-			}
-		      jb++;
-		      jb_lt_max= jb < jb_max;
-		    }
-		  else
-		    {
-		      double tmp = xmin (a.data(ja), b.data(jb));
-		      if (tmp != 0.)
-			{
+                    {
+                      double tmp = xmin (a.data(ja), 0.);
+                      if (tmp != 0.)
+                        {
+                          r.ridx(jx) = a.ridx(ja);
+                          r.data(jx) = tmp;
+                          jx++;
+                        }
+                      ja++;
+                      ja_lt_max= ja < ja_max;
+                    }
+                  else if (( !ja_lt_max ) ||
+                           (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                    {
+                      double tmp = xmin (0., b.data(jb));
+                      if (tmp != 0.)
+                        {
+                          r.ridx(jx) = b.ridx(jb);
+                          r.data(jx) = tmp;
+                          jx++;
+                        }
+                      jb++;
+                      jb_lt_max= jb < jb_max;
+                    }
+                  else
+                    {
+                      double tmp = xmin (a.data(ja), b.data(jb));
+                      if (tmp != 0.)
+                        {
                           r.data(jx) = tmp;
                           r.ridx(jx) = a.ridx(ja);
                           jx++;
-			}
-		      ja++;
-		      ja_lt_max= ja < ja_max;
-		      jb++;
-		      jb_lt_max= jb < jb_max;
-		    }
-		}
-	      r.cidx(i+1) = jx;
-	    }
-	  
-	  r.maybe_compress ();
-	}
+                        }
+                      ja++;
+                      ja_lt_max= ja < ja_max;
+                      jb++;
+                      jb_lt_max= jb < jb_max;
+                    }
+                }
+              r.cidx(i+1) = jx;
+            }
+          
+          r.maybe_compress ();
+        }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
 
 SparseMatrix
@@ -7885,53 +7885,53 @@ max (double d, const SparseMatrix& m)
 
   EMPTY_RETURN_CHECK (SparseMatrix);
 
   // Count the number of non-zero elements
   if (d > 0.)
     {
       result = SparseMatrix (nr, nc, d);
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-	  {
-	    double tmp = xmax (d, m.data (i));
-
-	    if (tmp != 0.)
-	      {
-		octave_idx_type idx = m.ridx(i) + j * nr;
-		result.xdata(idx) = tmp;
-		result.xridx(idx) = m.ridx(i);
-	      }
-	  }
+        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+          {
+            double tmp = xmax (d, m.data (i));
+
+            if (tmp != 0.)
+              {
+                octave_idx_type idx = m.ridx(i) + j * nr;
+                result.xdata(idx) = tmp;
+                result.xridx(idx) = m.ridx(i);
+              }
+          }
     }
   else
     {
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-	  if (xmax (d, m.data (i)) != 0.)
-	    nel++;
+        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+          if (xmax (d, m.data (i)) != 0.)
+            nel++;
 
       result = SparseMatrix (nr, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx(0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-	    {
-	      double tmp = xmax (d, m.data (i));
-	      if (tmp != 0.)
-		{
-		  result.xdata(ii) = tmp;
-		  result.xridx(ii++) = m.ridx(i);
-		}
-	    }
-	  result.xcidx(j+1) = ii;
-	}
+        {
+          for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+            {
+              double tmp = xmax (d, m.data (i));
+              if (tmp != 0.)
+                {
+                  result.xdata(ii) = tmp;
+                  result.xridx(ii++) = m.ridx(i);
+                }
+            }
+          result.xcidx(j+1) = ii;
+        }
     }
 
   return result;
 }
 
 SparseMatrix
 max (const SparseMatrix& m, double d)
 {
@@ -7947,82 +7947,82 @@ max (const SparseMatrix& a, const Sparse
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
-	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
+        gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
-	{
-	  r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
+        {
+          r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
-	  octave_idx_type jx = 0;
-	  r.cidx (0) = 0;
-	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
-	    {
-	      octave_idx_type  ja = a.cidx(i);
-	      octave_idx_type  ja_max = a.cidx(i+1);
-	      bool ja_lt_max= ja < ja_max;
+          octave_idx_type jx = 0;
+          r.cidx (0) = 0;
+          for (octave_idx_type i = 0 ; i < a_nc ; i++)
+            {
+              octave_idx_type  ja = a.cidx(i);
+              octave_idx_type  ja_max = a.cidx(i+1);
+              bool ja_lt_max= ja < ja_max;
            
-	      octave_idx_type  jb = b.cidx(i);
-	      octave_idx_type  jb_max = b.cidx(i+1);
-	      bool jb_lt_max = jb < jb_max;
+              octave_idx_type  jb = b.cidx(i);
+              octave_idx_type  jb_max = b.cidx(i+1);
+              bool jb_lt_max = jb < jb_max;
            
-	      while (ja_lt_max || jb_lt_max )
-		{
-		  octave_quit ();
-		  if ((! jb_lt_max) ||
+              while (ja_lt_max || jb_lt_max )
+                {
+                  octave_quit ();
+                  if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
-		    {
-		      double tmp = xmax (a.data(ja), 0.);
-		      if (tmp != 0.)
-			{
-			  r.ridx(jx) = a.ridx(ja);
-			  r.data(jx) = tmp;
-			  jx++;
-			}
-		      ja++;
-		      ja_lt_max= ja < ja_max;
-		    }
-		  else if (( !ja_lt_max ) ||
-			   (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
-		    {
-		      double tmp = xmax (0., b.data(jb));
-		      if (tmp != 0.)
-			{
-			  r.ridx(jx) = b.ridx(jb);
-			  r.data(jx) = tmp;
-			  jx++;
-			}
-		      jb++;
-		      jb_lt_max= jb < jb_max;
-		    }
-		  else
-		    {
-		      double tmp = xmax (a.data(ja), b.data(jb));
-		      if (tmp != 0.)
-			{
+                    {
+                      double tmp = xmax (a.data(ja), 0.);
+                      if (tmp != 0.)
+                        {
+                          r.ridx(jx) = a.ridx(ja);
+                          r.data(jx) = tmp;
+                          jx++;
+                        }
+                      ja++;
+                      ja_lt_max= ja < ja_max;
+                    }
+                  else if (( !ja_lt_max ) ||
+                           (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                    {
+                      double tmp = xmax (0., b.data(jb));
+                      if (tmp != 0.)
+                        {
+                          r.ridx(jx) = b.ridx(jb);
+                          r.data(jx) = tmp;
+                          jx++;
+                        }
+                      jb++;
+                      jb_lt_max= jb < jb_max;
+                    }
+                  else
+                    {
+                      double tmp = xmax (a.data(ja), b.data(jb));
+                      if (tmp != 0.)
+                        {
                           r.data(jx) = tmp;
                           r.ridx(jx) = a.ridx(ja);
                           jx++;
-			}
-		      ja++;
-		      ja_lt_max= ja < ja_max;
-		      jb++;
-		      jb_lt_max= jb < jb_max;
-		    }
-		}
-	      r.cidx(i+1) = jx;
-	    }
-	  
-	  r.maybe_compress ();
-	}
+                        }
+                      ja++;
+                      ja_lt_max= ja < ja_max;
+                      jb++;
+                      jb_lt_max= jb < jb_max;
+                    }
+                }
+              r.cidx(i+1) = jx;
+            }
+          
+          r.maybe_compress ();
+        }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
 
 SPARSE_SMS_CMP_OPS (SparseMatrix, 0.0, , double, 0.0, )
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -42,56 +42,56 @@ template void swap_bytes<4> (volatile vo
 template void swap_bytes<8> (volatile void *, int);
 
 #if defined HAVE_LONG_LONG_INT
 #define FIND_SIZED_INT_TYPE(VAL, BITS, TQ, Q) \
   do \
     { \
       int sz = BITS / CHAR_BIT; \
       if (sizeof (TQ char) == sz) \
-	VAL = oct_data_conv::dt_ ## Q ## char; \
+        VAL = oct_data_conv::dt_ ## Q ## char; \
       else if (sizeof (TQ short) == sz) \
-	VAL = oct_data_conv::dt_ ## Q ## short; \
+        VAL = oct_data_conv::dt_ ## Q ## short; \
       else if (sizeof (TQ int) == sz) \
-	VAL = oct_data_conv::dt_ ## Q ## int; \
+        VAL = oct_data_conv::dt_ ## Q ## int; \
       else if (sizeof (TQ long) == sz) \
-	VAL = oct_data_conv::dt_ ## Q ## long; \
+        VAL = oct_data_conv::dt_ ## Q ## long; \
       else if (sizeof (TQ long long) == sz) \
-	VAL = oct_data_conv::dt_ ## Q ## longlong; \
+        VAL = oct_data_conv::dt_ ## Q ## longlong; \
       else \
         VAL = oct_data_conv::dt_unknown; \
     } \
   while (0)
 #else
 #define FIND_SIZED_INT_TYPE(VAL, BITS, TQ, Q) \
   do \
     { \
       int sz = BITS / CHAR_BIT; \
       if (sizeof (TQ char) == sz) \
-	VAL = oct_data_conv::dt_ ## Q ## char; \
+        VAL = oct_data_conv::dt_ ## Q ## char; \
       else if (sizeof (TQ short) == sz) \
-	VAL = oct_data_conv::dt_ ## Q ## short; \
+        VAL = oct_data_conv::dt_ ## Q ## short; \
       else if (sizeof (TQ int) == sz) \
-	VAL = oct_data_conv::dt_ ## Q ## int; \
+        VAL = oct_data_conv::dt_ ## Q ## int; \
       else if (sizeof (TQ long) == sz) \
-	VAL = oct_data_conv::dt_ ## Q ## long; \
+        VAL = oct_data_conv::dt_ ## Q ## long; \
       else \
         VAL = oct_data_conv::dt_unknown; \
     } \
   while (0)
 #endif
 
 #define FIND_SIZED_FLOAT_TYPE(VAL, BITS) \
   do \
     { \
       int sz = BITS / CHAR_BIT; \
       if (sizeof (float) == sz) \
-	VAL = oct_data_conv::dt_float; \
+        VAL = oct_data_conv::dt_float; \
       else if (sizeof (double) == sz) \
-	VAL = oct_data_conv::dt_double; \
+        VAL = oct_data_conv::dt_double; \
       else \
         VAL = oct_data_conv::dt_unknown; \
     } \
   while (0)
 
 // I'm not sure it is worth the trouble, but let's use a lookup table
 // for the types that are supposed to be a specific number of bits
 // wide.  Given the macros above, this should work as long as CHAR_BIT
@@ -148,37 +148,37 @@ strip_spaces (const std::string& str)
 
   return s;
 }
 
 #define GET_SIZED_INT_TYPE(T, U) \
   do \
     { \
       switch (sizeof (T)) \
-	{ \
-	case 1: \
-	  retval = dt_ ## U ## int8; \
-	  break; \
+        { \
+        case 1: \
+          retval = dt_ ## U ## int8; \
+          break; \
  \
-	case 2: \
-	  retval = dt_ ## U ## int16; \
-	  break; \
+        case 2: \
+          retval = dt_ ## U ## int16; \
+          break; \
  \
-	case 4: \
-	  retval = dt_ ## U ## int32; \
-	  break; \
+        case 4: \
+          retval = dt_ ## U ## int32; \
+          break; \
  \
-	case 8: \
-	  retval = dt_ ## U ## int64; \
-	  break; \
+        case 8: \
+          retval = dt_ ## U ## int64; \
+          break; \
  \
-	default: \
-	  retval = dt_unknown; \
-	  break; \
-	} \
+        default: \
+          retval = dt_unknown; \
+          break; \
+        } \
     } \
   while (0)
 
 oct_data_conv::data_type
 oct_data_conv::string_to_data_type (const std::string& str)
 {
   data_type retval = dt_unknown;
 
@@ -235,19 +235,19 @@ oct_data_conv::string_to_data_type (cons
     GET_SIZED_INT_TYPE (unsigned long, u);
   else if (s == "longlong")
     GET_SIZED_INT_TYPE (long long, );
   else if (s == "ulonglong" || s == "unsignedlonglong")
     GET_SIZED_INT_TYPE (unsigned long long, u);
   else if (s == "float")
     {
       if (sizeof (float) == sizeof (double))
-	retval = dt_double;
+        retval = dt_double;
       else
-	retval = dt_single;
+        retval = dt_single;
     }
   else if (s == "logical")
     retval = dt_logical;
   else
     (*current_liboctave_error_handler) ("invalid data type specified");
 
   if (retval == dt_unknown)
     (*current_liboctave_error_handler)
@@ -274,71 +274,71 @@ oct_data_conv::string_to_data_type
 
   if (s[0] == '*')
     input_is_output = true;
   else
     {
       size_t len = s.length ();
 
       while (pos < len && isdigit (s[pos]))
-	pos++;
+        pos++;
 
       if (pos > 0)
-	{
-	  if (s[pos] == '*')
-	    {
-	      block_size = atoi (s.c_str ());
-	      s = s.substr (pos+1);
-	    }
-	  else
-	    {
-	      (*current_liboctave_error_handler)
-		("invalid repeat count in `%s'", str.c_str ());
+        {
+          if (s[pos] == '*')
+            {
+              block_size = atoi (s.c_str ());
+              s = s.substr (pos+1);
+            }
+          else
+            {
+              (*current_liboctave_error_handler)
+                ("invalid repeat count in `%s'", str.c_str ());
 
-	      return;
-	    }
-	}
+              return;
+            }
+        }
     }
 
   pos = s.find ('=');
 
   if (pos != std::string::npos)
     {
       if (s[pos+1] == '>')
-	{
-	  std::string s1;
+        {
+          std::string s1;
 
-	  if (input_is_output)
-	    {
-	      input_is_output = false;
+          if (input_is_output)
+            {
+              input_is_output = false;
 
-	      s1 = s.substr (1, pos-1);
+              s1 = s.substr (1, pos-1);
 
-	      (*current_liboctave_warning_handler)
-		("warning: ignoring leading * in fread precision");
-	    }
-	  else
-	    s1 = s.substr (0, pos);
+              (*current_liboctave_warning_handler)
+                ("warning: ignoring leading * in fread precision");
+            }
+          else
+            s1 = s.substr (0, pos);
 
-	  input_type = string_to_data_type (s1);
-	  output_type = string_to_data_type (s.substr (pos+2));
-	}
+          input_type = string_to_data_type (s1);
+          output_type = string_to_data_type (s.substr (pos+2));
+        }
       else
-	(*current_liboctave_error_handler)
-	  ("fread: invalid precision specified");
+        (*current_liboctave_error_handler)
+          ("fread: invalid precision specified");
     }
   else
     {
       if (input_is_output)
-	s = s.substr (1);
+        s = s.substr (1);
 
       input_type = string_to_data_type (s);
 
       if (input_is_output)
-	output_type = input_type;
+        output_type = input_type;
     }
 }
 
 void
 oct_data_conv::string_to_data_type
   (const std::string& str, int& block_size,
    oct_data_conv::data_type& output_type)
 {
@@ -352,27 +352,27 @@ oct_data_conv::string_to_data_type
   size_t len = s.length ();
 
   while (pos < len && isdigit (s[pos]))
     pos++;
 
   if (pos > 0)
     {
       if (s[pos] == '*')
-	{
-	  block_size = atoi (s.c_str ());
-	  s = s.substr (pos+1);
-	}
+        {
+          block_size = atoi (s.c_str ());
+          s = s.substr (pos+1);
+        }
       else
-	{
-	  (*current_liboctave_error_handler)
-	    ("invalid repeat count in `%s'", str.c_str ());
+        {
+          (*current_liboctave_error_handler)
+            ("invalid repeat count in `%s'", str.c_str ());
 
-	  return;
-	}
+          return;
+        }
     }
 
   output_type = string_to_data_type (s);
 }
 
 std::string
 oct_data_conv::data_type_as_string (oct_data_conv::data_type dt)
 {
@@ -480,42 +480,42 @@ oct_data_conv::data_type_as_string (oct_
 
   return retval;
 }
 
 #define LS_DO_READ(TYPE, swap, data, size, len, stream) \
   do \
     { \
       if (len > 0) \
-	{ \
-	  OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
-	  stream.read (reinterpret_cast<char *>  (ptr), size * len); \
-	  if (swap) \
-	    swap_bytes< size > (ptr, len); \
-	  for (int i = 0; i < len; i++) \
-	    data[i] = ptr[i]; \
-	} \
+        { \
+          OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
+          stream.read (reinterpret_cast<char *>  (ptr), size * len); \
+          if (swap) \
+            swap_bytes< size > (ptr, len); \
+          for (int i = 0; i < len; i++) \
+            data[i] = ptr[i]; \
+        } \
     } \
   while (0)
 
 // Have to use copy here to avoid writing over data accessed via
 // Matrix::data().
 
 #define LS_DO_WRITE(TYPE, data, size, len, stream) \
   do \
     { \
       if (len > 0) \
-	{ \
-	  char tmp_type = type; \
-	  stream.write (&tmp_type, 1); \
-	  OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
-	  for (int i = 0; i < len; i++) \
-	    ptr[i] = static_cast <TYPE> (data[i]);	   \
-	  stream.write (reinterpret_cast<char *> (ptr), size * len); \
-	} \
+        { \
+          char tmp_type = type; \
+          stream.write (&tmp_type, 1); \
+          OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
+          for (int i = 0; i < len; i++) \
+            ptr[i] = static_cast <TYPE> (data[i]);         \
+          stream.write (reinterpret_cast<char *> (ptr), size * len); \
+        } \
     } \
   while (0)
 
 // Loading variables from files.
 
 static void
 gripe_unrecognized_float_fmt (void)
 {
@@ -728,295 +728,295 @@ VAX_D_float_to_VAX_G_float (void * /* d 
 static void
 Cray_to_VAX_G_float (void * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX G float", "VAX G");
 }
 
 void
 do_double_format_conversion (void *data, int len,
-			     oct_mach_info::float_format from_fmt,
-			     oct_mach_info::float_format to_fmt)
+                             oct_mach_info::float_format from_fmt,
+                             oct_mach_info::float_format to_fmt)
 {
   switch (to_fmt)
     {
     case oct_mach_info::flt_fmt_ieee_little_endian:
       switch (from_fmt)
-	{
-	case oct_mach_info::flt_fmt_ieee_little_endian:
-	  break;
+        {
+        case oct_mach_info::flt_fmt_ieee_little_endian:
+          break;
 
-	case oct_mach_info::flt_fmt_ieee_big_endian:
-	  IEEE_big_double_to_IEEE_little_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_ieee_big_endian:
+          IEEE_big_double_to_IEEE_little_double (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_vax_d:
-	  VAX_D_double_to_IEEE_little_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_vax_d:
+          VAX_D_double_to_IEEE_little_double (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_vax_g:
-	  VAX_G_double_to_IEEE_little_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_vax_g:
+          VAX_G_double_to_IEEE_little_double (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_cray:
-	  Cray_to_IEEE_little_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_cray:
+          Cray_to_IEEE_little_double (data, len);
+          break;
 
-	default:
-	  gripe_unrecognized_float_fmt ();
-	  break;
-	}
+        default:
+          gripe_unrecognized_float_fmt ();
+          break;
+        }
       break;
 
     case oct_mach_info::flt_fmt_ieee_big_endian:
       switch (from_fmt)
-	{
-	case oct_mach_info::flt_fmt_ieee_little_endian:
-	  IEEE_little_double_to_IEEE_big_double (data, len);
-	  break;
+        {
+        case oct_mach_info::flt_fmt_ieee_little_endian:
+          IEEE_little_double_to_IEEE_big_double (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_ieee_big_endian:
-	  break;
+        case oct_mach_info::flt_fmt_ieee_big_endian:
+          break;
 
-	case oct_mach_info::flt_fmt_vax_d:
-	  VAX_D_double_to_IEEE_big_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_vax_d:
+          VAX_D_double_to_IEEE_big_double (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_vax_g:
-	  VAX_G_double_to_IEEE_big_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_vax_g:
+          VAX_G_double_to_IEEE_big_double (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_cray:
-	  Cray_to_IEEE_big_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_cray:
+          Cray_to_IEEE_big_double (data, len);
+          break;
 
-	default:
-	  gripe_unrecognized_float_fmt ();
-	  break;
-	}
+        default:
+          gripe_unrecognized_float_fmt ();
+          break;
+        }
       break;
 
     case oct_mach_info::flt_fmt_vax_d:
       switch (from_fmt)
-	{
-	case oct_mach_info::flt_fmt_ieee_little_endian:
-	  IEEE_little_double_to_VAX_D_double (data, len);
-	  break;
+        {
+        case oct_mach_info::flt_fmt_ieee_little_endian:
+          IEEE_little_double_to_VAX_D_double (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_ieee_big_endian:
-	  IEEE_big_double_to_VAX_D_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_ieee_big_endian:
+          IEEE_big_double_to_VAX_D_double (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_vax_d:
-	  break;
+        case oct_mach_info::flt_fmt_vax_d:
+          break;
 
-	case oct_mach_info::flt_fmt_vax_g:
-	  VAX_G_double_to_VAX_D_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_vax_g:
+          VAX_G_double_to_VAX_D_double (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_cray:
-	  Cray_to_VAX_D_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_cray:
+          Cray_to_VAX_D_double (data, len);
+          break;
 
-	default:
-	  gripe_unrecognized_float_fmt ();
-	  break;
-	}
+        default:
+          gripe_unrecognized_float_fmt ();
+          break;
+        }
       break;
 
     case oct_mach_info::flt_fmt_vax_g:
       switch (from_fmt)
-	{
-	case oct_mach_info::flt_fmt_ieee_little_endian:
-	  IEEE_little_double_to_VAX_G_double (data, len);
-	  break;
+        {
+        case oct_mach_info::flt_fmt_ieee_little_endian:
+          IEEE_little_double_to_VAX_G_double (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_ieee_big_endian:
-	  IEEE_big_double_to_VAX_G_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_ieee_big_endian:
+          IEEE_big_double_to_VAX_G_double (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_vax_d:
-	  VAX_D_double_to_VAX_G_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_vax_d:
+          VAX_D_double_to_VAX_G_double (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_vax_g:
-	  break;
+        case oct_mach_info::flt_fmt_vax_g:
+          break;
 
-	case oct_mach_info::flt_fmt_cray:
-	  Cray_to_VAX_G_double (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_cray:
+          Cray_to_VAX_G_double (data, len);
+          break;
 
-	default:
-	  gripe_unrecognized_float_fmt ();
-	  break;
-	}
+        default:
+          gripe_unrecognized_float_fmt ();
+          break;
+        }
       break;
 
     default:
       (*current_liboctave_error_handler)
-	("impossible state reached in file `%s' at line %d",
-	 __FILE__, __LINE__);
+        ("impossible state reached in file `%s' at line %d",
+         __FILE__, __LINE__);
       break;
     }
 }
 
 void
 do_float_format_conversion (void *data, int len,
-			    oct_mach_info::float_format from_fmt,
-			    oct_mach_info::float_format to_fmt)
+                            oct_mach_info::float_format from_fmt,
+                            oct_mach_info::float_format to_fmt)
 {
   switch (to_fmt)
     {
     case oct_mach_info::flt_fmt_ieee_little_endian:
       switch (from_fmt)
-	{
-	case oct_mach_info::flt_fmt_ieee_little_endian:
-	  break;
+        {
+        case oct_mach_info::flt_fmt_ieee_little_endian:
+          break;
 
-	case oct_mach_info::flt_fmt_ieee_big_endian:
-	  IEEE_big_float_to_IEEE_little_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_ieee_big_endian:
+          IEEE_big_float_to_IEEE_little_float (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_vax_d:
-	  VAX_D_float_to_IEEE_little_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_vax_d:
+          VAX_D_float_to_IEEE_little_float (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_vax_g:
-	  VAX_G_float_to_IEEE_little_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_vax_g:
+          VAX_G_float_to_IEEE_little_float (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_cray:
-	  Cray_to_IEEE_little_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_cray:
+          Cray_to_IEEE_little_float (data, len);
+          break;
 
-	default:
-	  gripe_unrecognized_float_fmt ();
-	  break;
-	}
+        default:
+          gripe_unrecognized_float_fmt ();
+          break;
+        }
       break;
 
     case oct_mach_info::flt_fmt_ieee_big_endian:
       switch (from_fmt)
-	{
-	case oct_mach_info::flt_fmt_ieee_little_endian:
-	  IEEE_little_float_to_IEEE_big_float (data, len);
-	  break;
+        {
+        case oct_mach_info::flt_fmt_ieee_little_endian:
+          IEEE_little_float_to_IEEE_big_float (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_ieee_big_endian:
-	  break;
+        case oct_mach_info::flt_fmt_ieee_big_endian:
+          break;
 
-	case oct_mach_info::flt_fmt_vax_d:
-	  VAX_D_float_to_IEEE_big_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_vax_d:
+          VAX_D_float_to_IEEE_big_float (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_vax_g:
-	  VAX_G_float_to_IEEE_big_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_vax_g:
+          VAX_G_float_to_IEEE_big_float (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_cray:
-	  Cray_to_IEEE_big_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_cray:
+          Cray_to_IEEE_big_float (data, len);
+          break;
 
-	default:
-	  gripe_unrecognized_float_fmt ();
-	  break;
-	}
+        default:
+          gripe_unrecognized_float_fmt ();
+          break;
+        }
       break;
 
     case oct_mach_info::flt_fmt_vax_d:
       switch (from_fmt)
-	{
-	case oct_mach_info::flt_fmt_ieee_little_endian:
-	  IEEE_little_float_to_VAX_D_float (data, len);
-	  break;
+        {
+        case oct_mach_info::flt_fmt_ieee_little_endian:
+          IEEE_little_float_to_VAX_D_float (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_ieee_big_endian:
-	  IEEE_big_float_to_VAX_D_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_ieee_big_endian:
+          IEEE_big_float_to_VAX_D_float (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_vax_d:
-	  break;
+        case oct_mach_info::flt_fmt_vax_d:
+          break;
 
-	case oct_mach_info::flt_fmt_vax_g:
-	  VAX_G_float_to_VAX_D_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_vax_g:
+          VAX_G_float_to_VAX_D_float (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_cray:
-	  Cray_to_VAX_D_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_cray:
+          Cray_to_VAX_D_float (data, len);
+          break;
 
-	default:
-	  gripe_unrecognized_float_fmt ();
-	  break;
-	}
+        default:
+          gripe_unrecognized_float_fmt ();
+          break;
+        }
       break;
 
     case oct_mach_info::flt_fmt_vax_g:
       switch (from_fmt)
-	{
-	case oct_mach_info::flt_fmt_ieee_little_endian:
-	  IEEE_little_float_to_VAX_G_float (data, len);
-	  break;
+        {
+        case oct_mach_info::flt_fmt_ieee_little_endian:
+          IEEE_little_float_to_VAX_G_float (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_ieee_big_endian:
-	  IEEE_big_float_to_VAX_G_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_ieee_big_endian:
+          IEEE_big_float_to_VAX_G_float (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_vax_d:
-	  VAX_D_float_to_VAX_G_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_vax_d:
+          VAX_D_float_to_VAX_G_float (data, len);
+          break;
 
-	case oct_mach_info::flt_fmt_vax_g:
-	  break;
+        case oct_mach_info::flt_fmt_vax_g:
+          break;
 
-	case oct_mach_info::flt_fmt_cray:
-	  Cray_to_VAX_G_float (data, len);
-	  break;
+        case oct_mach_info::flt_fmt_cray:
+          Cray_to_VAX_G_float (data, len);
+          break;
 
-	default:
-	  gripe_unrecognized_float_fmt ();
-	  break;
-	}
+        default:
+          gripe_unrecognized_float_fmt ();
+          break;
+        }
       break;
 
     default:
       (*current_liboctave_error_handler)
-	("impossible state reached in file `%s' at line %d",
-	 __FILE__, __LINE__);
+        ("impossible state reached in file `%s' at line %d",
+         __FILE__, __LINE__);
       break;
     }
 }
 
 void
 do_float_format_conversion (void *data, size_t sz, int len,
-			    oct_mach_info::float_format from_fmt,
-			    oct_mach_info::float_format to_fmt)
+                            oct_mach_info::float_format from_fmt,
+                            oct_mach_info::float_format to_fmt)
 {
   switch (sz)
     {
     case sizeof (float):
       do_float_format_conversion (data, len, from_fmt, to_fmt);
       break;
 
     case sizeof (double):
       do_double_format_conversion (data, len, from_fmt, to_fmt);
       break;
 
     default:
       (*current_liboctave_error_handler)
-	("impossible state reached in file `%s' at line %d",
-	 __FILE__, __LINE__);
+        ("impossible state reached in file `%s' at line %d",
+         __FILE__, __LINE__);
       break;
     }
 }
 
 
 void
 read_doubles (std::istream& is, double *data, save_type type, int len,
-	      bool swap, oct_mach_info::float_format fmt)
+              bool swap, oct_mach_info::float_format fmt)
 {
   switch (type)
     {
     case LS_U_CHAR:
       LS_DO_READ (uint8_t, swap, data, 1, len, is);
       break;
 
     case LS_U_SHORT:
@@ -1036,43 +1036,43 @@ read_doubles (std::istream& is, double *
       break;
 
     case LS_INT:
       LS_DO_READ (int32_t, swap, data, 4, len, is);
       break;
 
     case LS_FLOAT:
       {
-	OCTAVE_LOCAL_BUFFER (float, ptr, len);
-	is.read (reinterpret_cast<char *> (ptr), 4 * len);
-	do_float_format_conversion (ptr, len, fmt);
-	for (int i = 0; i < len; i++)
-	  data[i] = ptr[i];
+        OCTAVE_LOCAL_BUFFER (float, ptr, len);
+        is.read (reinterpret_cast<char *> (ptr), 4 * len);
+        do_float_format_conversion (ptr, len, fmt);
+        for (int i = 0; i < len; i++)
+          data[i] = ptr[i];
       }
       break;
 
     case LS_DOUBLE: // No conversion necessary.
       {
-	is.read (reinterpret_cast<char *> (data), 8 * len);
-	do_double_format_conversion (data, len, fmt);
+        is.read (reinterpret_cast<char *> (data), 8 * len);
+        do_double_format_conversion (data, len, fmt);
 
-	for (int i = 0; i < len; i++)
-	  data[i] = __lo_ieee_replace_old_NA (data[i]);
+        for (int i = 0; i < len; i++)
+          data[i] = __lo_ieee_replace_old_NA (data[i]);
       }
       break;
 
     default:
       is.clear (std::ios::failbit|is.rdstate ());
       break;
     }
 }
 
 void
 read_floats (std::istream& is, float *data, save_type type, int len,
-	      bool swap, oct_mach_info::float_format fmt)
+              bool swap, oct_mach_info::float_format fmt)
 {
   switch (type)
     {
     case LS_U_CHAR:
       LS_DO_READ (uint8_t, swap, data, 1, len, is);
       break;
 
     case LS_U_SHORT:
@@ -1097,21 +1097,21 @@ read_floats (std::istream& is, float *da
 
     case LS_FLOAT: // No conversion necessary.
       is.read (reinterpret_cast<char *> (data), 4 * len);
       do_float_format_conversion (data, len, fmt);
       break;
 
     case LS_DOUBLE:
       {
-	OCTAVE_LOCAL_BUFFER (double, ptr, len);
-	is.read (reinterpret_cast<char *> (ptr), 8 * len);
-	do_double_format_conversion (ptr, len, fmt);
-	for (int i = 0; i < len; i++)
-	  data[i] = ptr[i];
+        OCTAVE_LOCAL_BUFFER (double, ptr, len);
+        is.read (reinterpret_cast<char *> (ptr), 8 * len);
+        do_double_format_conversion (ptr, len, fmt);
+        for (int i = 0; i < len; i++)
+          data[i] = ptr[i];
       }
       break;
 
     default:
       is.clear (std::ios::failbit|is.rdstate ());
       break;
     }
 }
@@ -1146,25 +1146,25 @@ write_doubles (std::ostream& os, const d
       break;
 
     case LS_FLOAT:
       LS_DO_WRITE (float, data, 4, len, os);
       break;
 
     case LS_DOUBLE: // No conversion necessary.
       {
-	char tmp_type = static_cast<char> (type);
-	os.write (&tmp_type, 1);
-	os.write (reinterpret_cast <const char *> (data), 8 * len);
+        char tmp_type = static_cast<char> (type);
+        os.write (&tmp_type, 1);
+        os.write (reinterpret_cast <const char *> (data), 8 * len);
       }
       break;
 
     default:
       (*current_liboctave_error_handler)
-	("unrecognized data format requested");
+        ("unrecognized data format requested");
       break;
     }
 }
 
 void
 write_floats (std::ostream& os, const float *data, save_type type, int len)
 {
   switch (type)
@@ -1190,24 +1190,24 @@ write_floats (std::ostream& os, const fl
       break;
 
     case LS_INT:
       LS_DO_WRITE (int32_t, data, 4, len, os);
       break;
 
     case LS_FLOAT: // No conversion necessary.
       {
-	char tmp_type = static_cast<char> (type);
-	os.write (&tmp_type, 1);
-	os.write (reinterpret_cast <const char *> (data), 4 * len);
+        char tmp_type = static_cast<char> (type);
+        os.write (&tmp_type, 1);
+        os.write (reinterpret_cast <const char *> (data), 4 * len);
       }
       break;
 
     case LS_DOUBLE:
       LS_DO_WRITE (double, data, 8, len, os);
       break;
 
     default:
       (*current_liboctave_error_handler)
-	("unrecognized data format requested");
+        ("unrecognized data format requested");
       break;
     }
 }
diff --git a/liboctave/dbleAEPBAL.cc b/liboctave/dbleAEPBAL.cc
--- a/liboctave/dbleAEPBAL.cc
+++ b/liboctave/dbleAEPBAL.cc
@@ -30,28 +30,28 @@ along with Octave; see the file COPYING.
 
 #include "dbleAEPBAL.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgebal, DGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&,
-			     octave_idx_type&, double*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&,
+                             octave_idx_type&, double*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgebak, DGEBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
                              const double*, const octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 AEPBALANCE::AEPBALANCE (const Matrix& a, bool noperm, bool noscal)
   : base_aepbal<Matrix, ColumnVector> ()
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
@@ -66,18 +66,18 @@ AEPBALANCE::AEPBALANCE (const Matrix& a,
   double *pscale = scale.fortran_vec ();
 
   balanced_mat = a;
   double *p_balanced_mat = balanced_mat.fortran_vec ();
 
   job = noperm ? (noscal ? 'N' : 'S') : (noscal ? 'P' : 'B');
 
   F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     n, p_balanced_mat, n, ilo, ihi, pscale, info
-			     F77_CHAR_ARG_LEN (1)));
+                             n, p_balanced_mat, n, ilo, ihi, pscale, info
+                             F77_CHAR_ARG_LEN (1)));
 }
 
 Matrix
 AEPBALANCE::balancing_matrix (void) const
 {
   octave_idx_type n = balanced_mat.rows ();
   Matrix balancing_mat (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
@@ -86,16 +86,16 @@ AEPBALANCE::balancing_matrix (void) cons
   double *p_balancing_mat = balancing_mat.fortran_vec ();
   const double *pscale = scale.fortran_vec ();
 
   octave_idx_type info;
 
   char side = 'R';
 
   F77_XFCN (dgebak, DGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 (&side, 1),
-			     n, ilo, ihi, pscale, n,
-			     p_balancing_mat, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&side, 1),
+                             n, ilo, ihi, pscale, n,
+                             p_balancing_mat, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   return balancing_mat;
 }
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -37,29 +37,29 @@ along with Octave; see the file COPYING.
 #ifndef HAVE_QRUPDATE
 #include "dbleQR.h"
 #endif
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dpotrf, DPOTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     double*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             double*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dpotri, DPOTRI) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     double*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             double*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dpocon, DPOCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     double*, const octave_idx_type&, const double&,
-			     double&, double*, octave_idx_type*, 
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             double*, const octave_idx_type&, const double&,
+                             double&, double*, octave_idx_type*, 
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
 #ifdef HAVE_QRUPDATE
 
   F77_RET_T
   F77_FUNC (dch1up, DCH1UP) (const octave_idx_type&, double*, const octave_idx_type&,
                              double*, double*);
 
   F77_RET_T
   F77_FUNC (dch1dn, DCH1DN) (const octave_idx_type&, double*, const octave_idx_type&,
@@ -107,37 +107,37 @@ CHOL::init (const Matrix& a, bool calc_c
   double *h = chol_mat.fortran_vec ();
 
   // Calculate the norm of the matrix, for later use.
   double anorm = 0;
   if (calc_cond) 
     anorm = xnorm (a, 1);
 
   F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1),
-			     n, h, n, info
-			     F77_CHAR_ARG_LEN (1)));
+                             n, h, n, info
+                             F77_CHAR_ARG_LEN (1)));
 
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond) 
     {
       octave_idx_type dpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
       Array<double> z (3*n);
       double *pz = z.fortran_vec ();
       Array<octave_idx_type> iz (n);
       octave_idx_type *piz = iz.fortran_vec ();
       F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
-				 n, anorm, xrcond, pz, piz, dpocon_info
-				 F77_CHAR_ARG_LEN (1)));
+                                 n, anorm, xrcond, pz, piz, dpocon_info
+                                 F77_CHAR_ARG_LEN (1)));
 
       if (dpocon_info != 0) 
-	info = -1;
+        info = -1;
     }
 
   return info;
 }
 
 static Matrix
 chol2inv_internal (const Matrix& r)
 {
@@ -150,31 +150,31 @@ chol2inv_internal (const Matrix& r)
     {
       octave_idx_type n = r_nc;
       octave_idx_type info = 0;
 
       Matrix tmp = r;
       double *v = tmp.fortran_vec();
 
       if (info == 0)
-	{
-	  F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-				     v, n, info
-				     F77_CHAR_ARG_LEN (1)));
+        {
+          F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
+                                     v, n, info
+                                     F77_CHAR_ARG_LEN (1)));
 
-	  // If someone thinks of a more graceful way of doing this (or
-	  // faster for that matter :-)), please let me know!
+          // If someone thinks of a more graceful way of doing this (or
+          // faster for that matter :-)), please let me know!
 
-	  if (n > 1)
-	    for (octave_idx_type j = 0; j < r_nc; j++)
-	      for (octave_idx_type i = j+1; i < r_nr; i++)
-		tmp.xelem (i, j) = tmp.xelem (j, i);
+          if (n > 1)
+            for (octave_idx_type j = 0; j < r_nc; j++)
+              for (octave_idx_type i = j+1; i < r_nr; i++)
+                tmp.xelem (i, j) = tmp.xelem (j, i);
 
-	  retval = tmp;
-	}
+          retval = tmp;
+        }
     }
   else
     (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
   return retval;
 }
 
 // Compute the inverse of a matrix using the Cholesky factorization.
diff --git a/liboctave/dbleGEPBAL.cc b/liboctave/dbleGEPBAL.cc
--- a/liboctave/dbleGEPBAL.cc
+++ b/liboctave/dbleGEPBAL.cc
@@ -32,37 +32,37 @@ along with Octave; see the file COPYING.
 #include "Array-util.h"
 #include "f77-fcn.h"
 #include "oct-locbuf.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dggbal, DGGBAL) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type& N,
-			     double* A, const octave_idx_type& LDA, double* B,
-			     const octave_idx_type& LDB, octave_idx_type& ILO, octave_idx_type& IHI,
-			     double* LSCALE, double* RSCALE,
-			     double* WORK, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL);
+                             double* A, const octave_idx_type& LDA, double* B,
+                             const octave_idx_type& LDB, octave_idx_type& ILO, octave_idx_type& IHI,
+                             double* LSCALE, double* RSCALE,
+                             double* WORK, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dggbak, DGGBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type& N, const octave_idx_type& ILO,
-			     const octave_idx_type& IHI, const double* LSCALE,
-			     const double* RSCALE, octave_idx_type& M, double* V,
-			     const octave_idx_type& LDV, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type& N, const octave_idx_type& ILO,
+                             const octave_idx_type& IHI, const double* LSCALE,
+                             const double* RSCALE, octave_idx_type& M, double* V,
+                             const octave_idx_type& LDV, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
 }
 
 octave_idx_type
 GEPBALANCE::init (const Matrix& a, const Matrix& b, 
-		  const std::string& balance_job)
+                  const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("GEPBALANCE requires square matrix");
       return -1;
     }
@@ -84,42 +84,42 @@ GEPBALANCE::init (const Matrix& a, const
   balanced_mat = a;
   double *p_balanced_mat = balanced_mat.fortran_vec ();
   balanced_mat2 = b;
   double *p_balanced_mat2 = balanced_mat2.fortran_vec ();
 
   char job = balance_job[0];
 
   F77_XFCN (dggbal, DGGBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     n, p_balanced_mat, n, p_balanced_mat2,
-			     n, ilo, ihi, plscale, prscale, pwork, info
-			     F77_CHAR_ARG_LEN  (1)));
+                             n, p_balanced_mat, n, p_balanced_mat2,
+                             n, ilo, ihi, plscale, prscale, pwork, info
+                             F77_CHAR_ARG_LEN  (1)));
 
   balancing_mat = Matrix (n, n, 0.0);
   balancing_mat2 = Matrix (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
     {
       octave_quit ();
       balancing_mat.elem (i ,i) = 1.0;
       balancing_mat2.elem (i ,i) = 1.0;
     }
 
   double *p_balancing_mat = balancing_mat.fortran_vec ();
   double *p_balancing_mat2 = balancing_mat2.fortran_vec ();
 
   // first left
   F77_XFCN (dggbak, DGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 ("L", 1),
-			     n, ilo, ihi, plscale, prscale,
-			     n, p_balancing_mat, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 ("L", 1),
+                             n, ilo, ihi, plscale, prscale,
+                             n, p_balancing_mat, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
       
   // then right
   F77_XFCN (dggbak, DGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 ("R", 1),
-			     n, ilo, ihi, plscale, prscale,
-			     n, p_balancing_mat2, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 ("R", 1),
+                             n, ilo, ihi, plscale, prscale,
+                             n, p_balancing_mat2, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
diff --git a/liboctave/dbleHESS.cc b/liboctave/dbleHESS.cc
--- a/liboctave/dbleHESS.cc
+++ b/liboctave/dbleHESS.cc
@@ -28,37 +28,37 @@ along with Octave; see the file COPYING.
 #include "dbleHESS.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgebal, DGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&,
-			     octave_idx_type&, double*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&,
+                             octave_idx_type&, double*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgehrd, DGEHRD) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     double*, const octave_idx_type&, double*, double*,
-			     const octave_idx_type&, octave_idx_type&);
+                             double*, const octave_idx_type&, double*, double*,
+                             const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dorghr, DORGHR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     double*, const octave_idx_type&, double*, double*,
-			     const octave_idx_type&, octave_idx_type&);
+                             double*, const octave_idx_type&, double*, double*,
+                             const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dgebak, DGEBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
-			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
+                             const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 octave_idx_type
 HESS::init (const Matrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
@@ -79,44 +79,44 @@ HESS::init (const Matrix& a)
 
   hess_mat = a;
   double *h = hess_mat.fortran_vec ();
 
   Array<double> scale (n);
   double *pscale = scale.fortran_vec ();
 
   F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     n, h, n, ilo, ihi, pscale, info
-			     F77_CHAR_ARG_LEN (1)));
+                             n, h, n, ilo, ihi, pscale, info
+                             F77_CHAR_ARG_LEN (1)));
 
   Array<double> tau (n-1);
   double *ptau = tau.fortran_vec ();
 
   Array<double> work (lwork);
   double *pwork = work.fortran_vec ();
 
   F77_XFCN (dgehrd, DGEHRD, (n, ilo, ihi, h, n, ptau, pwork,
-			     lwork, info));
+                             lwork, info));
 
   unitary_hess_mat = hess_mat;
   double *z = unitary_hess_mat.fortran_vec ();
 
   F77_XFCN (dorghr, DORGHR, (n, ilo, ihi, z, n, ptau, pwork,
-			     lwork, info));
+                             lwork, info));
 
   F77_XFCN (dgebak, DGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 (&side, 1),
-			     n, ilo, ihi, pscale, n, z,
-			     n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&side, 1),
+                             n, ilo, ihi, pscale, n, z,
+                             n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   // If someone thinks of a more graceful way of doing
   // this (or faster for that matter :-)), please let
   // me know!
 
   if (n > 2)
     for (octave_idx_type j = 0; j < a_nc; j++)
       for (octave_idx_type i = j+2; i < a_nr; i++)
-	hess_mat.elem (i, j) = 0;
+        hess_mat.elem (i, j) = 0;
 
   return info;
 }
diff --git a/liboctave/dbleLU.cc b/liboctave/dbleLU.cc
--- a/liboctave/dbleLU.cc
+++ b/liboctave/dbleLU.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 template class base_lu <Matrix>;
 
 // Define the constructor for this particular derivation.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgetrf, DGETRF) (const octave_idx_type&, const octave_idx_type&, double*,
-			     const octave_idx_type&, octave_idx_type*, octave_idx_type&);
+                             const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 
 #ifdef HAVE_QRUPDATE_LUU
   F77_RET_T
   F77_FUNC (dlu1up, DLU1UP) (const octave_idx_type&, const octave_idx_type&,
                              double *, const octave_idx_type&,
                              double *, const octave_idx_type&,
                              double *, double *);
 
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -37,21 +37,21 @@ along with Octave; see the file COPYING.
 #include "base-qr.cc"
 
 template class base_qr<Matrix>;
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgeqrf, DGEQRF) (const octave_idx_type&, const octave_idx_type&, double*, const octave_idx_type&,
-			     double*, double*, const octave_idx_type&, octave_idx_type&); 
+                             double*, double*, const octave_idx_type&, octave_idx_type&); 
 
   F77_RET_T
   F77_FUNC (dorgqr, DORGQR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
-			     const octave_idx_type&, double*, double*, const octave_idx_type&, octave_idx_type&);
+                             const octave_idx_type&, double*, double*, const octave_idx_type&, octave_idx_type&);
 
 #ifdef HAVE_QRUPDATE
 
   F77_RET_T
   F77_FUNC (dqr1up, DQR1UP) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
                              double*, const octave_idx_type&, double*, const octave_idx_type&,
                              double*, double*, double*);
 
@@ -126,21 +126,21 @@ void QR::form (octave_idx_type n, Matrix
                double *tau, qr_type_t qr_type)
 {
   octave_idx_type m = afact.rows (), min_mn = std::min (m, n);
   octave_idx_type info;
 
   if (qr_type == qr_type_raw)
     {
       for (octave_idx_type j = 0; j < min_mn; j++)
-	{
-	  octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
-	  for (octave_idx_type i = limit + 1; i < m; i++)
-	    afact.elem (i, j) *= tau[j];
-	}
+        {
+          octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
+          for (octave_idx_type i = limit + 1; i < m; i++)
+            afact.elem (i, j) *= tau[j];
+        }
 
       r = afact;
     }
   else
     {
       // Attempt to minimize copying.
       if (m >= n)
         {
@@ -177,17 +177,17 @@ void QR::form (octave_idx_type n, Matrix
           octave_idx_type k = q.columns ();
           // workspace query.
           double rlwork;
           F77_XFCN (dorgqr, DORGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      &rlwork, -1, info));
 
           // allocate buffer and do the job.
           octave_idx_type lwork = rlwork;
-	  lwork = std::max (lwork, static_cast<octave_idx_type> (1));
+          lwork = std::max (lwork, static_cast<octave_idx_type> (1));
           OCTAVE_LOCAL_BUFFER (double, work, lwork);
           F77_XFCN (dorgqr, DORGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      work, lwork, info));
         }
     }
 }
 
 #ifdef HAVE_QRUPDATE
@@ -293,17 +293,17 @@ QR::insert_col (const Matrix& u, const A
       else
         {
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (double, w, kmax);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
-	  octave_idx_type ii = i;
+          octave_idx_type ii = i;
           ColumnVector utmp = u.column (jsi(i));
           F77_XFCN (dqrinc, DQRINC, (m, n + ii, std::min (kmax, k + ii), 
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1, 
                                      utmp.data (), w));
         }
     }
 }
@@ -316,17 +316,17 @@ QR::delete_col (octave_idx_type j)
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1) 
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (double, w, k);
       F77_XFCN (dqrdec, DQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
-				 r.fortran_vec (), r.rows (), j + 1, w));
+                                 r.fortran_vec (), r.rows (), j + 1, w));
 
       if (k < m)
         {
           q.resize (m, k-1);
           r.resize (k-1, n-1);
         }
       else
         {
@@ -353,17 +353,17 @@ QR::delete_col (const Array<octave_idx_t
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, w, k);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
-	  octave_idx_type ii = i;
+          octave_idx_type ii = i;
           F77_XFCN (dqrdec, DQRDEC, (m, n - ii, k == m ? k : k - ii, 
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1, w));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
@@ -389,17 +389,17 @@ QR::insert_row (const RowVector& u, octa
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       RowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, w, k);
       F77_XFCN (dqrinr, DQRINR, (m, n, q.fortran_vec (), q.rows (),
-				 r.fortran_vec (), r.rows (), 
+                                 r.fortran_vec (), r.rows (), 
                                  j + 1, utmp.fortran_vec (), w));
 
     }
 }
 
 void
 QR::delete_row (octave_idx_type j)
 {
@@ -409,17 +409,17 @@ QR::delete_row (octave_idx_type j)
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
   else if (j < 0 || j > m-1) 
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (double, w, 2*m);
       F77_XFCN (dqrder, DQRDER, (m, n, q.fortran_vec (), q.rows (),
-				 r.fortran_vec (), r.rows (), j + 1,
+                                 r.fortran_vec (), r.rows (), j + 1,
                                  w));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 }
 
 void
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgeqp3, DGEQP3) (const octave_idx_type&, const octave_idx_type&, double*,
-			     const octave_idx_type&, octave_idx_type*, double*, double*,
+                             const octave_idx_type&, octave_idx_type*, double*, double*,
                              const octave_idx_type&, octave_idx_type&);
 }
 
 // It would be best to share some of this code with QR class...
 
 QRP::QRP (const Matrix& a, qr_type_t qr_type)
   : QR (), p ()
 {
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -30,26 +30,26 @@ along with Octave; see the file COPYING.
 #include "dbleSCHUR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgeesx, DGEESX) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     SCHUR::select_function,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&,
-			     double*, double*, double*, const octave_idx_type&,
-			     double&, double&, double*, const octave_idx_type&,
-			     octave_idx_type*, const octave_idx_type&, octave_idx_type*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             SCHUR::select_function,
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&,
+                             double*, double*, double*, const octave_idx_type&,
+                             double&, double&, double*, const octave_idx_type&,
+                             octave_idx_type*, const octave_idx_type&, octave_idx_type*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 static octave_idx_type
 select_ana (const double& a, const double&)
 {
    return (a < 0.0);
 }
 
@@ -123,24 +123,24 @@ SCHUR::init (const Matrix& a, const std:
   // BWORK is not referenced for the non-ordered Schur routine.
   Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
   Array<octave_idx_type> iwork (liwork);
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   F77_XFCN (dgeesx, DGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
-			     F77_CONST_CHAR_ARG2 (&sort, 1),
-			     selector,
-			     F77_CONST_CHAR_ARG2 (&sense, 1),
-			     n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
-			     pwork, lwork, piwork, liwork, pbwork, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&sort, 1),
+                             selector,
+                             F77_CONST_CHAR_ARG2 (&sense, 1),
+                             n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
+                             pwork, lwork, piwork, liwork, pbwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
 
 std::ostream&
 operator << (std::ostream& os, const SCHUR& a)
 {
   os << a.schur_matrix () << "\n";
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -29,45 +29,45 @@ along with Octave; see the file COPYING.
 
 #include "dbleSVD.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgesvd, DGESVD) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, double*,
-			     const octave_idx_type&, double*, double*,
-			     const octave_idx_type&, double*, const octave_idx_type&,
-			     double*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, double*,
+                             const octave_idx_type&, double*, double*,
+                             const octave_idx_type&, double*, const octave_idx_type&,
+                             double*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 Matrix
 SVD::left_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
     {
       (*current_liboctave_error_handler)
-	("SVD: U not computed because type == SVD::sigma_only");
+        ("SVD: U not computed because type == SVD::sigma_only");
       return Matrix ();
     }
   else
     return left_sm;
 }
 
 Matrix
 SVD::right_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
     {
       (*current_liboctave_error_handler)
-	("SVD: V not computed because type == SVD::sigma_only");
+        ("SVD: V not computed because type == SVD::sigma_only");
       return Matrix ();
     }
   else
     return right_sm;
 }
 
 octave_idx_type
 SVD::init (const Matrix& a, SVD::type svd_type)
@@ -136,31 +136,31 @@ SVD::init (const Matrix& a, SVD::type sv
   octave_idx_type lwork = -1;
 
   Array<double> work (1);
 
   octave_idx_type one = 1;
   octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
 
   F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
-			     F77_CONST_CHAR_ARG2 (&jobv, 1),
-			     m, n, tmp_data, m1, s_vec, u, m1, vt,
-			     nrow_vt1, work.fortran_vec (), lwork, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&jobv, 1),
+                             m, n, tmp_data, m1, s_vec, u, m1, vt,
+                             nrow_vt1, work.fortran_vec (), lwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   lwork = static_cast<octave_idx_type> (work(0));
   work.resize (lwork);
 
   F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
-			     F77_CONST_CHAR_ARG2 (&jobv, 1),
-			     m, n, tmp_data, m1, s_vec, u, m1, vt,
-			     nrow_vt1, work.fortran_vec (), lwork, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&jobv, 1),
+                             m, n, tmp_data, m1, s_vec, u, m1, vt,
+                             nrow_vt1, work.fortran_vec (), lwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm = right_sm.transpose ();
 
   return info;
 }
 
 std::ostream&
diff --git a/liboctave/dir-ops.cc b/liboctave/dir-ops.cc
--- a/liboctave/dir-ops.cc
+++ b/liboctave/dir-ops.cc
@@ -51,22 +51,22 @@ dir_entry::open (const std::string& n)
     {
       close ();
       
       std::string fullname = file_ops::tilde_expand (name);
 
       dir = static_cast<void *> (opendir (fullname.c_str ()));
 
       if (dir)
-	fail = false;
+        fail = false;
       else
-	{
-	  using namespace std;
-	  errmsg = strerror (errno);
-	}
+        {
+          using namespace std;
+          errmsg = strerror (errno);
+        }
     }
   else
     errmsg = "dir_entry::open: empty file name";
 
   return ! fail;
 }
 
 string_vector
@@ -76,22 +76,22 @@ dir_entry::read (void)
 
   if (ok ())
     {
       std::list<std::string> dirlist;
 
       struct dirent *dir_ent;
 
       while ((dir_ent = readdir (static_cast<DIR *> (dir))))
-	{
-	  if (dir_ent)
-	    dirlist.push_back (dir_ent->d_name);
-	  else
-	    break;
-	}
+        {
+          if (dir_ent)
+            dirlist.push_back (dir_ent->d_name);
+          else
+            break;
+        }
 
       retval = string_vector (dirlist);
     }
 
   return retval;
 }
 
 void
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -49,92 +49,92 @@ typedef ColumnVector (*EigsFunc) (const 
 typedef ComplexColumnVector (*EigsComplexFunc) 
   (const ComplexColumnVector &x, int &eigs_error);
 
 // Arpack and blas fortran functions we call.
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dsaupd, DSAUPD) (octave_idx_type&, F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, F77_CONST_CHAR_ARG_DECL, 
-			     const octave_idx_type&, const double&,
-			     double*, const octave_idx_type&, double*,
-			     const octave_idx_type&, octave_idx_type*,
-			     octave_idx_type*, double*, double*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, F77_CONST_CHAR_ARG_DECL, 
+                             const octave_idx_type&, const double&,
+                             double*, const octave_idx_type&, double*,
+                             const octave_idx_type&, octave_idx_type*,
+                             octave_idx_type*, double*, double*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dseupd, DSEUPD) (const int&, F77_CONST_CHAR_ARG_DECL,
-			     octave_idx_type*, double*, double*,
-			     const octave_idx_type&, const double&,
-			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const double&, double*, const octave_idx_type&, 
-			     double*, const octave_idx_type&, octave_idx_type*,
-			     octave_idx_type*, double*, double*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             octave_idx_type*, double*, double*,
+                             const octave_idx_type&, const double&,
+                             F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+                             F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+                             const double&, double*, const octave_idx_type&, 
+                             double*, const octave_idx_type&, octave_idx_type*,
+                             octave_idx_type*, double*, double*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dnaupd, DNAUPD) (octave_idx_type&, F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, F77_CONST_CHAR_ARG_DECL, 
-			     octave_idx_type&, const double&,
-			     double*, const octave_idx_type&, double*,
-			     const octave_idx_type&, octave_idx_type*,
-			     octave_idx_type*, double*, double*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, F77_CONST_CHAR_ARG_DECL, 
+                             octave_idx_type&, const double&,
+                             double*, const octave_idx_type&, double*,
+                             const octave_idx_type&, octave_idx_type*,
+                             octave_idx_type*, double*, double*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dneupd, DNEUPD) (const int&, F77_CONST_CHAR_ARG_DECL,
-			     octave_idx_type*, double*, double*,
-			     double*, const octave_idx_type&, const double&,
-			     const double&, double*, F77_CONST_CHAR_ARG_DECL, 
-			     const octave_idx_type&, F77_CONST_CHAR_ARG_DECL, 
-			     octave_idx_type&, const double&, double*, 
-			     const octave_idx_type&, double*, 
-			     const octave_idx_type&, octave_idx_type*, 
-			     octave_idx_type*, double*, double*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             octave_idx_type*, double*, double*,
+                             double*, const octave_idx_type&, const double&,
+                             const double&, double*, F77_CONST_CHAR_ARG_DECL, 
+                             const octave_idx_type&, F77_CONST_CHAR_ARG_DECL, 
+                             octave_idx_type&, const double&, double*, 
+                             const octave_idx_type&, double*, 
+                             const octave_idx_type&, octave_idx_type*, 
+                             octave_idx_type*, double*, double*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (znaupd, ZNAUPD) (octave_idx_type&, F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, F77_CONST_CHAR_ARG_DECL, 
-			     const octave_idx_type&, const double&,
-			     Complex*, const octave_idx_type&, Complex*,
-			     const octave_idx_type&, octave_idx_type*,
-			     octave_idx_type*, Complex*, Complex*, 
-			     const octave_idx_type&, double *, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, F77_CONST_CHAR_ARG_DECL, 
+                             const octave_idx_type&, const double&,
+                             Complex*, const octave_idx_type&, Complex*,
+                             const octave_idx_type&, octave_idx_type*,
+                             octave_idx_type*, Complex*, Complex*, 
+                             const octave_idx_type&, double *, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zneupd, ZNEUPD) (const int&, F77_CONST_CHAR_ARG_DECL,
-			     octave_idx_type*, Complex*, Complex*, 
-			     const octave_idx_type&, const Complex&,
-			     Complex*, F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, F77_CONST_CHAR_ARG_DECL, 
-			     const octave_idx_type&, const double&,
-			     Complex*, const octave_idx_type&, Complex*,
-			     const octave_idx_type&, octave_idx_type*,
-			     octave_idx_type*, Complex*, Complex*, 
-			     const octave_idx_type&, double *, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             octave_idx_type*, Complex*, Complex*, 
+                             const octave_idx_type&, const Complex&,
+                             Complex*, F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, F77_CONST_CHAR_ARG_DECL, 
+                             const octave_idx_type&, const double&,
+                             Complex*, const octave_idx_type&, Complex*,
+                             const octave_idx_type&, octave_idx_type*,
+                             octave_idx_type*, Complex*, Complex*, 
+                             const octave_idx_type&, double *, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgemv, DGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const double&,
-			   const double*, const octave_idx_type&, const double*,
-			   const octave_idx_type&, const double&, double*,
-			   const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, const octave_idx_type&, const double&,
+                           const double*, const octave_idx_type&, const double*,
+                           const octave_idx_type&, const double&, double*,
+                           const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL);
 
 
   F77_RET_T
   F77_FUNC (zgemv, ZGEMV) (F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, const octave_idx_type&, const Complex&,
                            const Complex*, const octave_idx_type&, const Complex*,
                            const octave_idx_type&, const Complex&, Complex*, const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL);
@@ -143,27 +143,27 @@ extern "C"
 
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static octave_idx_type
 lusolve (const SparseMatrix&, const SparseMatrix&, Matrix&);
 
 static octave_idx_type
 lusolve (const SparseComplexMatrix&, const SparseComplexMatrix&, 
-	 ComplexMatrix&);
+         ComplexMatrix&);
 
 static octave_idx_type
 lusolve (const Matrix&, const Matrix&, Matrix&);
 
 static octave_idx_type
 lusolve (const ComplexMatrix&, const ComplexMatrix&, ComplexMatrix&);
 
 static ComplexMatrix
 ltsolve (const SparseComplexMatrix&, const ColumnVector&, 
-		const ComplexMatrix&);
+                const ComplexMatrix&);
 
 static Matrix
 ltsolve (const SparseMatrix&, const ColumnVector&, const Matrix&,);
 
 static ComplexMatrix
 ltsolve (const ComplexMatrix&, const ColumnVector&, const ComplexMatrix&);
 
 static Matrix
@@ -213,21 +213,21 @@ ltsolve (const SM& L, const ColumnVector
   M tmp = L.solve (ltyp, m, err, rcond, 0);
   M retval;
   const double* qv = Q.fortran_vec();
 
   if (!err)
     {
       retval.resize (n, b_nc);
       for (octave_idx_type j = 0; j < b_nc; j++)
-	{
-	  for (octave_idx_type i = 0; i < n; i++)
-	    retval.elem(static_cast<octave_idx_type>(qv[i]), j)  = 
-	      tmp.elem(i,j);
-	}
+        {
+          for (octave_idx_type i = 0; i < n; i++)
+            retval.elem(static_cast<octave_idx_type>(qv[i]), j)  = 
+              tmp.elem(i,j);
+        }
     }
 
   return retval;
 }
 
 template <class SM, class M>
 static M
 utsolve (const SM& U, const ColumnVector& Q, const M& m)
@@ -238,17 +238,17 @@ utsolve (const SM& U, const ColumnVector
   double rcond;
   MatrixType utyp (MatrixType::Upper);
 
   M retval (n, b_nc);
   const double* qv = Q.fortran_vec();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = 0; i < n; i++)
-	retval.elem(i,j) = m.elem(static_cast<octave_idx_type>(qv[i]), j);
+        retval.elem(i,j) = m.elem(static_cast<octave_idx_type>(qv[i]), j);
     }
   return U.solve (utyp, retval, err, rcond, 0);
 }
 
 static bool
 vector_product (const SparseMatrix& m, const double* x, double* y)
 {
   octave_idx_type nc = m.cols ();
@@ -265,33 +265,33 @@ vector_product (const SparseMatrix& m, c
 
 static bool
 vector_product (const Matrix& m, const double *x, double *y)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			   nr, nc, 1.0,  m.data (), nr,
-			   x, 1, 0.0, y, 1
-			   F77_CHAR_ARG_LEN (1)));
+                           nr, nc, 1.0,  m.data (), nr,
+                           x, 1, 0.0, y, 1
+                           F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler) 
-	("eigs: unrecoverable error in dgemv");
+        ("eigs: unrecoverable error in dgemv");
       return false;
     }
   else
     return true;
 }
 
 static bool
 vector_product (const SparseComplexMatrix& m, const Complex* x, 
-			Complex* y)
+                        Complex* y)
 {
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     y[j] = 0.;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
@@ -302,24 +302,24 @@ vector_product (const SparseComplexMatri
 
 static bool
 vector_product (const ComplexMatrix& m, const Complex *x, Complex *y)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			   nr, nc, 1.0,  m.data (), nr,
-			   x, 1, 0.0, y, 1
-			   F77_CHAR_ARG_LEN (1)));
+                           nr, nc, 1.0,  m.data (), nr,
+                           x, 1, 0.0, y, 1
+                           F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler) 
-	("eigs: unrecoverable error in zgemv");
+        ("eigs: unrecoverable error in zgemv");
       return false;
     }
   else
     return true;
 }
 
 static bool
 make_cholb (Matrix& b, Matrix& bt, ColumnVector& permB)
@@ -331,17 +331,17 @@ make_cholb (Matrix& b, Matrix& bt, Colum
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
       b =  bt.transpose();
       permB = ColumnVector(n);
       for (octave_idx_type i = 0; i < n; i++)
-	permB(i) = i;
+        permB(i) = i;
       return true;
     }
 }
 
 static bool
 make_cholb (SparseMatrix& b, SparseMatrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
@@ -368,24 +368,24 @@ make_cholb (ComplexMatrix& b, ComplexMat
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
       b =  bt.hermitian();
       permB = ColumnVector(n);
       for (octave_idx_type i = 0; i < n; i++)
-	permB(i) = i;
+        permB(i) = i;
       return true;
     }
 }
 
 static bool
 make_cholb (SparseComplexMatrix& b, SparseComplexMatrix& bt, 
-	    ColumnVector& permB)
+            ColumnVector& permB)
 {
   octave_idx_type info;
   SparseComplexCHOL fact (b, info, false);
 
   if (fact.P() != 0)
     return false;
   else
     {
@@ -393,67 +393,67 @@ make_cholb (SparseComplexMatrix& b, Spar
       bt = b.hermitian();
       permB = fact.perm() - 1.0;
       return true;
     }
 }
 
 static bool
 LuAminusSigmaB (const SparseMatrix &m, const SparseMatrix &b, 
-		bool cholB, const ColumnVector& permB, double sigma,
-		SparseMatrix &L, SparseMatrix &U, octave_idx_type *P, 
-		octave_idx_type *Q)
+                bool cholB, const ColumnVector& permB, double sigma,
+                SparseMatrix &L, SparseMatrix &U, octave_idx_type *P, 
+                octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
   octave_idx_type n = m.rows();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
-	{
-	  if (permB.length())
-	    {
-	      SparseMatrix tmp(n,n,n);
-	      for (octave_idx_type i = 0; i < n; i++)
-		{
-		  tmp.xcidx(i) = i;
-		  tmp.xridx(i) = 
-		    static_cast<octave_idx_type>(permB(i));
-		  tmp.xdata(i) = 1;
-		}
-	      tmp.xcidx(n) = n;
-
-	      AminusSigmaB = AminusSigmaB - sigma * tmp *
-		b.transpose() * b * tmp.transpose();
-	    }
-	  else
-	    AminusSigmaB = AminusSigmaB - sigma *
-	      b.transpose() * b;
-	}
+        {
+          if (permB.length())
+            {
+              SparseMatrix tmp(n,n,n);
+              for (octave_idx_type i = 0; i < n; i++)
+                {
+                  tmp.xcidx(i) = i;
+                  tmp.xridx(i) = 
+                    static_cast<octave_idx_type>(permB(i));
+                  tmp.xdata(i) = 1;
+                }
+              tmp.xcidx(n) = n;
+
+              AminusSigmaB = AminusSigmaB - sigma * tmp *
+                b.transpose() * b * tmp.transpose();
+            }
+          else
+            AminusSigmaB = AminusSigmaB - sigma *
+              b.transpose() * b;
+        }
       else
-	AminusSigmaB = AminusSigmaB - sigma * b;
+        AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       SparseMatrix sigmat (n, n, n);
 
-	  // Create sigma * speye(n,n)
-	  sigmat.xcidx (0) = 0;
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      sigmat.xdata(i) = sigma;
-	      sigmat.xridx(i) = i;
-	      sigmat.xcidx(i+1) = i + 1;
-	    }
-
-	  AminusSigmaB = AminusSigmaB - sigmat;
-	}
+          // Create sigma * speye(n,n)
+          sigmat.xcidx (0) = 0;
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              sigmat.xdata(i) = sigma;
+              sigmat.xridx(i) = i;
+              sigmat.xcidx(i+1) = i + 1;
+            }
+
+          AminusSigmaB = AminusSigmaB - sigmat;
+        }
 
   SparseLU fact (AminusSigmaB);
 
   L = fact.L ();
   U = fact.U ();
   const octave_idx_type *P2 = fact.row_perm ();
   const octave_idx_type *Q2 = fact.col_perm ();
 
@@ -465,166 +465,166 @@ LuAminusSigmaB (const SparseMatrix &m, c
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = 0.;
       if (U.xcidx(j+1) > U.xcidx(j) &&
-	  U.xridx (U.xcidx(j+1)-1) == j)
-	d = std::abs (U.xdata (U.xcidx(j+1)-1));
+          U.xridx (U.xcidx(j+1)-1) == j)
+        d = std::abs (U.xdata (U.xcidx(j+1)-1));
 
       if (xisnan (minU) || d < minU)
-	minU = d;
+        minU = d;
 
       if (xisnan (maxU) || d > maxU)
-	maxU = d;
+        maxU = d;
     }
 
   double rcond = (minU / maxU);
   volatile double rcond_plus_one = rcond + 1.0;
 
   if (rcond_plus_one == 1.0 || xisnan (rcond))
     {
       (*current_liboctave_warning_handler)
-	("eigs: 'A - sigma*B' is singular, indicating sigma is exactly");
+        ("eigs: 'A - sigma*B' is singular, indicating sigma is exactly");
       (*current_liboctave_warning_handler)
-	("       an eigenvalue. Convergence is not guaranteed");
+        ("       an eigenvalue. Convergence is not guaranteed");
     }
 
   return true;
 }
 
 static bool
 LuAminusSigmaB (const Matrix &m, const Matrix &b, 
-		bool cholB, const ColumnVector& permB, double sigma,
-		Matrix &L, Matrix &U, octave_idx_type *P, 
-		octave_idx_type *Q)
+                bool cholB, const ColumnVector& permB, double sigma,
+                Matrix &L, Matrix &U, octave_idx_type *P, 
+                octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
   octave_idx_type n = m.cols();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   Matrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
-	{
-	  Matrix tmp = sigma * b.transpose() * b;
-	  const double *pB = permB.fortran_vec();
-	  double *p = AminusSigmaB.fortran_vec();
-
-	  if (permB.length())
-	    {
-	      for (octave_idx_type j = 0; 
-		   j < b.cols(); j++)
-		for (octave_idx_type i = 0; 
-		     i < b.rows(); i++)
-		  *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
-				      static_cast<octave_idx_type>(pB[j]));
-	    }
-	  else
-	    AminusSigmaB = AminusSigmaB - tmp;
-	}
+        {
+          Matrix tmp = sigma * b.transpose() * b;
+          const double *pB = permB.fortran_vec();
+          double *p = AminusSigmaB.fortran_vec();
+
+          if (permB.length())
+            {
+              for (octave_idx_type j = 0; 
+                   j < b.cols(); j++)
+                for (octave_idx_type i = 0; 
+                     i < b.rows(); i++)
+                  *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
+                                      static_cast<octave_idx_type>(pB[j]));
+            }
+          else
+            AminusSigmaB = AminusSigmaB - tmp;
+        }
       else
-	AminusSigmaB = AminusSigmaB - sigma * b;
+        AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       double *p = AminusSigmaB.fortran_vec();
 
       for (octave_idx_type i = 0; i < n; i++)
-	p[i*(n+1)] -= sigma;
+        p[i*(n+1)] -= sigma;
     }
 
   LU fact (AminusSigmaB);
 
   L = fact.P().transpose() * fact.L ();
   U = fact.U ();
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;  
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = std::abs (U.xelem(j,j));
       if (xisnan (minU) || d < minU)
-	minU = d;
+        minU = d;
 
       if (xisnan (maxU) || d > maxU)
-	maxU = d;
+        maxU = d;
     }
 
   double rcond = (minU / maxU);
   volatile double rcond_plus_one = rcond + 1.0;
 
   if (rcond_plus_one == 1.0 || xisnan (rcond))
     {
       (*current_liboctave_warning_handler) 
-	("eigs: 'A - sigma*B' is singular, indicating sigma is exactly");
+        ("eigs: 'A - sigma*B' is singular, indicating sigma is exactly");
       (*current_liboctave_warning_handler) 
-	("       an eigenvalue. Convergence is not guaranteed");
+        ("       an eigenvalue. Convergence is not guaranteed");
     }
 
   return true;
 }
 
 static bool
 LuAminusSigmaB (const SparseComplexMatrix &m, const SparseComplexMatrix &b, 
-		bool cholB, const ColumnVector& permB, Complex sigma,
-		SparseComplexMatrix &L, SparseComplexMatrix &U,
-		octave_idx_type *P, octave_idx_type *Q)
+                bool cholB, const ColumnVector& permB, Complex sigma,
+                SparseComplexMatrix &L, SparseComplexMatrix &U,
+                octave_idx_type *P, octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
   octave_idx_type n = m.rows();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseComplexMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
-	{
-	  if (permB.length())
-	    {
-	      SparseMatrix tmp(n,n,n);
-	      for (octave_idx_type i = 0; i < n; i++)
-		{
-		  tmp.xcidx(i) = i;
-		  tmp.xridx(i) = 
-		    static_cast<octave_idx_type>(permB(i));
-		  tmp.xdata(i) = 1;
-		}
-	      tmp.xcidx(n) = n;
-
-	      AminusSigmaB = AminusSigmaB - tmp * b.hermitian() * b * 
-		tmp.transpose() * sigma;
-	    }
-	  else
-	    AminusSigmaB = AminusSigmaB - sigma * b.hermitian() * b;
-	}
+        {
+          if (permB.length())
+            {
+              SparseMatrix tmp(n,n,n);
+              for (octave_idx_type i = 0; i < n; i++)
+                {
+                  tmp.xcidx(i) = i;
+                  tmp.xridx(i) = 
+                    static_cast<octave_idx_type>(permB(i));
+                  tmp.xdata(i) = 1;
+                }
+              tmp.xcidx(n) = n;
+
+              AminusSigmaB = AminusSigmaB - tmp * b.hermitian() * b * 
+                tmp.transpose() * sigma;
+            }
+          else
+            AminusSigmaB = AminusSigmaB - sigma * b.hermitian() * b;
+        }
       else
-	AminusSigmaB = AminusSigmaB - sigma * b;
+        AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       SparseComplexMatrix sigmat (n, n, n);
 
       // Create sigma * speye(n,n)
       sigmat.xcidx (0) = 0;
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  sigmat.xdata(i) = sigma;
-	  sigmat.xridx(i) = i;
-	  sigmat.xcidx(i+1) = i + 1;
-	}
+        {
+          sigmat.xdata(i) = sigma;
+          sigmat.xridx(i) = i;
+          sigmat.xcidx(i+1) = i + 1;
+        }
 
       AminusSigmaB = AminusSigmaB - sigmat;
     }
 
   SparseComplexLU fact (AminusSigmaB);
 
   L = fact.L ();
   U = fact.U ();
@@ -639,126 +639,126 @@ LuAminusSigmaB (const SparseComplexMatri
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = 0.;
       if (U.xcidx(j+1) > U.xcidx(j) &&
-	  U.xridx (U.xcidx(j+1)-1) == j)
-	d = std::abs (U.xdata (U.xcidx(j+1)-1));
+          U.xridx (U.xcidx(j+1)-1) == j)
+        d = std::abs (U.xdata (U.xcidx(j+1)-1));
 
       if (xisnan (minU) || d < minU)
-	minU = d;
+        minU = d;
 
       if (xisnan (maxU) || d > maxU)
-	maxU = d;
+        maxU = d;
     }
 
   double rcond = (minU / maxU);
   volatile double rcond_plus_one = rcond + 1.0;
 
   if (rcond_plus_one == 1.0 || xisnan (rcond))
     {
       (*current_liboctave_warning_handler)
-	("eigs: 'A - sigma*B' is singular, indicating sigma is exactly");
+        ("eigs: 'A - sigma*B' is singular, indicating sigma is exactly");
       (*current_liboctave_warning_handler)
-	("       an eigenvalue. Convergence is not guaranteed");
+        ("       an eigenvalue. Convergence is not guaranteed");
     }
 
   return true;
 }
 
 static bool
 LuAminusSigmaB (const ComplexMatrix &m, const ComplexMatrix &b, 
-		bool cholB, const ColumnVector& permB, Complex sigma,
-		ComplexMatrix &L, ComplexMatrix &U, octave_idx_type *P, 
-		octave_idx_type *Q)
+                bool cholB, const ColumnVector& permB, Complex sigma,
+                ComplexMatrix &L, ComplexMatrix &U, octave_idx_type *P, 
+                octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
   octave_idx_type n = m.cols();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   ComplexMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
-	{
-	  ComplexMatrix tmp = sigma * b.hermitian() * b;
-	  const double *pB = permB.fortran_vec();
-	  Complex *p = AminusSigmaB.fortran_vec();
-
-	  if (permB.length())
-	    {
-	      for (octave_idx_type j = 0; 
-		   j < b.cols(); j++)
-		for (octave_idx_type i = 0; 
-		     i < b.rows(); i++)
-		  *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
-				      static_cast<octave_idx_type>(pB[j]));
-	    }
-	  else
-	    AminusSigmaB = AminusSigmaB - tmp;
-	}
+        {
+          ComplexMatrix tmp = sigma * b.hermitian() * b;
+          const double *pB = permB.fortran_vec();
+          Complex *p = AminusSigmaB.fortran_vec();
+
+          if (permB.length())
+            {
+              for (octave_idx_type j = 0; 
+                   j < b.cols(); j++)
+                for (octave_idx_type i = 0; 
+                     i < b.rows(); i++)
+                  *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
+                                      static_cast<octave_idx_type>(pB[j]));
+            }
+          else
+            AminusSigmaB = AminusSigmaB - tmp;
+        }
       else
-	AminusSigmaB = AminusSigmaB - sigma * b;
+        AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       Complex *p = AminusSigmaB.fortran_vec();
 
       for (octave_idx_type i = 0; i < n; i++)
-	p[i*(n+1)] -= sigma;
+        p[i*(n+1)] -= sigma;
     }
 
   ComplexLU fact (AminusSigmaB);
 
   L = fact.P().transpose() * fact.L ();
   U = fact.U ();
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;  
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = std::abs (U.xelem(j,j));
       if (xisnan (minU) || d < minU)
-	minU = d;
+        minU = d;
 
       if (xisnan (maxU) || d > maxU)
-	maxU = d;
+        maxU = d;
     }
 
   double rcond = (minU / maxU);
   volatile double rcond_plus_one = rcond + 1.0;
 
   if (rcond_plus_one == 1.0 || xisnan (rcond))
     {
       (*current_liboctave_warning_handler) 
-	("eigs: 'A - sigma*B' is singular, indicating sigma is exactly");
+        ("eigs: 'A - sigma*B' is singular, indicating sigma is exactly");
       (*current_liboctave_warning_handler) 
-	("       an eigenvalue. Convergence is not guaranteed");
+        ("       an eigenvalue. Convergence is not guaranteed");
     }
 
   return true;
 }
 
 template <class M>
 octave_idx_type
 EigsRealSymmetricMatrix (const M& m, const std::string typ, 
-			 octave_idx_type k, octave_idx_type p,
-			 octave_idx_type &info, Matrix &eig_vec,
-			 ColumnVector &eig_val, const M& _b,
-			 ColumnVector &permB, ColumnVector &resid, 
-			 std::ostream& os, double tol, int rvec, 
-			 bool cholB, int disp, int maxit)
+                         octave_idx_type k, octave_idx_type p,
+                         octave_idx_type &info, Matrix &eig_vec,
+                         ColumnVector &eig_val, const M& _b,
+                         ColumnVector &permB, ColumnVector &resid, 
+                         std::ostream& os, double tol, int rvec, 
+                         bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 1;
   bool have_b = ! b.is_empty();
   bool note3 = false;
   char bmat = 'I';
   double sigma = 0.;
@@ -767,128 +767,128 @@ EigsRealSymmetricMatrix (const M& m, con
   if (m.rows() != m.cols())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
   if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
     {
       (*current_liboctave_error_handler) 
-	("eigs: B must be square and the same size as A");
+        ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   if (resid.is_empty())
     {
       std::string rand_dist = octave_rand::distribution();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
-	("eigs: n must be at least 3");
+        ("eigs: n must be at least 3");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
-	p = 20;
+        p = 20;
       
       if (p > n - 1)
-	p = n - 1 ;
+        p = n - 1 ;
     }
   
   if (k < 1 || k > n - 2)
     {
       (*current_liboctave_error_handler) 
-	("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
-	 "      Use 'eig(full(A))' instead");
+        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
+         "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler) 
-	("eigs: opts.p must be greater than k and less than n");
+        ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
   if (have_b && cholB && permB.length() != 0) 
     {
       // Check the we really have a permutation vector
       if (permB.length() != n)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: permB vector invalid");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: permB vector invalid");
+          return -1;
+        }
       else
-	{
-	  Array<bool> checked(n,false);
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      octave_idx_type bidx = 
-		static_cast<octave_idx_type> (permB(i));
-	      if (checked(bidx) || bidx < 0 ||
-		  bidx >= n || D_NINT (bidx) != bidx)
-		{
-		  (*current_liboctave_error_handler) 
-		    ("eigs: permB vector invalid");
-		  return -1;
-		}
-	    }
-	}
+        {
+          Array<bool> checked(n,false);
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              octave_idx_type bidx = 
+                static_cast<octave_idx_type> (permB(i));
+              if (checked(bidx) || bidx < 0 ||
+                  bidx >= n || D_NINT (bidx) != bidx)
+                {
+                  (*current_liboctave_error_handler) 
+                    ("eigs: permB vector invalid");
+                  return -1;
+                }
+            }
+        }
     }
 
   if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" && 
       typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
       typ != "SI")
     {
       (*current_liboctave_error_handler) 
-	("eigs: unrecognized sigma value");
+        ("eigs: unrecognized sigma value");
       return -1;
     }
   
   if (typ == "LI" || typ == "SI" || typ == "LR" || typ == "SR")
     {
       (*current_liboctave_error_handler) 
-	("eigs: invalid sigma value for real symmetric problem");
+        ("eigs: invalid sigma value for real symmetric problem");
       return -1;
     }
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
-	{
-	  bt = b;
-	  b = b.transpose();
-	  if (permB.length() == 0)
-	    {
-	      permB = ColumnVector(n);
-	      for (octave_idx_type i = 0; i < n; i++)
-		permB(i) = i;
-	    }
-	}
+        {
+          bt = b;
+          b = b.transpose();
+          if (permB.length() == 0)
+            {
+              permB = ColumnVector(n);
+              for (octave_idx_type i = 0; i < n; i++)
+                permB(i) = i;
+            }
+        }
       else
-	{
-	  if (! make_cholb(b, bt, permB))
-	    {
-	      (*current_liboctave_error_handler) 
-		("eigs: The matrix B is not positive definite");
-	      return -1;
-	    }
-	}
+        {
+          if (! make_cholb(b, bt, permB))
+            {
+              (*current_liboctave_error_handler) 
+                ("eigs: The matrix B is not positive definite");
+              return -1;
+            }
+        }
     }
 
   Array<octave_idx_type> ip (11);
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
@@ -912,76 +912,76 @@ EigsRealSymmetricMatrix (const M& m, con
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do 
     {
       F77_FUNC (dsaupd, DSAUPD) 
-	(ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-	 F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
-	 k, tol, presid, p, v, n, iparam,
-	 ipntr, workd, workl, lwork, info
-	 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+        (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
+         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         k, tol, presid, p, v, n, iparam,
+         ipntr, workd, workl, lwork, info
+         F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: unrecoverable exception encountered in dsaupd");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: unrecoverable exception encountered in dsaupd");
+          return -1;
+        }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
-	{
-	  if (iter++)
-	    {
-	      os << "Iteration " << iter - 1 << 
-		": a few Ritz values of the " << p << "-by-" <<
-		p << " matrix\n";
-	      for (int i = 0 ; i < k; i++)
-		os << "    " << workl[iptr(5)+i-1] << "\n";
-	    }
-
-	  // This is a kludge, as ARPACK doesn't give its
-	  // iteration pointer. But as workl[iptr(5)-1] is
-	  // an output value updated at each iteration, setting
-	  // a value in this array to NaN and testing for it
-	  // is a way of obtaining the iteration counter.
-	  if (ido != 99)
-	    workl[iptr(5)-1] = octave_NaN; 
-	}
+        {
+          if (iter++)
+            {
+              os << "Iteration " << iter - 1 << 
+                ": a few Ritz values of the " << p << "-by-" <<
+                p << " matrix\n";
+              for (int i = 0 ; i < k; i++)
+                os << "    " << workl[iptr(5)+i-1] << "\n";
+            }
+
+          // This is a kludge, as ARPACK doesn't give its
+          // iteration pointer. But as workl[iptr(5)-1] is
+          // an output value updated at each iteration, setting
+          // a value in this array to NaN and testing for it
+          // is a way of obtaining the iteration counter.
+          if (ido != 99)
+            workl[iptr(5)-1] = octave_NaN; 
+        }
 
       if (ido == -1 || ido == 1 || ido == 2)
-	{
-	  if (have_b)
-	    {
-	      Matrix mtmp (n,1);
-	      for (octave_idx_type i = 0; i < n; i++)
-		mtmp(i,0) = workd[i + iptr(0) - 1];
-	      
-	      mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
-
-	      for (octave_idx_type i = 0; i < n; i++)
-		workd[i+iptr(1)-1] = mtmp(i,0);
-	    }
-	  else if (!vector_product (m, workd + iptr(0) - 1, 
-				    workd + iptr(1) - 1))
-	    break;
-	}
+        {
+          if (have_b)
+            {
+              Matrix mtmp (n,1);
+              for (octave_idx_type i = 0; i < n; i++)
+                mtmp(i,0) = workd[i + iptr(0) - 1];
+              
+              mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
+
+              for (octave_idx_type i = 0; i < n; i++)
+                workd[i+iptr(1)-1] = mtmp(i,0);
+            }
+          else if (!vector_product (m, workd + iptr(0) - 1, 
+                                    workd + iptr(1) - 1))
+            break;
+        }
       else
-	{
-	  if (info < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("eigs: error %d in dsaupd", info);
-	      return -1;
-	    }
-	  break;
-	}
+        {
+          if (info < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("eigs: error %d in dsaupd", info);
+              return -1;
+            }
+          break;
+        }
     } 
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
@@ -1003,173 +1003,173 @@ EigsRealSymmetricMatrix (const M& m, con
      F77_CONST_CHAR_ARG2 (&bmat, 1), n, 
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
      ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) 
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler)
-	("eigs: unrecoverable exception encountered in dseupd");
+        ("eigs: unrecoverable exception encountered in dseupd");
       return -1;
     }
   else
     {
       if (info2 == 0)
-	{
-	  octave_idx_type k2 = k / 2;
-	  if (typ != "SM" && typ != "BE")
-	    {
-	      for (octave_idx_type i = 0; i < k2; i++)
-		{
-		  double dtmp = d[i];
-		  d[i] = d[k - i - 1];
-		  d[k - i - 1] = dtmp;
-		}
-	    }
-
-	  if (rvec)
-	    {
-	      if (typ != "SM" && typ != "BE")
-		{
-		  OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-		  for (octave_idx_type i = 0; i < k2; i++)
-		    {
-		      octave_idx_type off1 = i * n;
-		      octave_idx_type off2 = (k - i - 1) * n;
-
-		      if (off1 == off2)
-			continue;
-
-		      for (octave_idx_type j = 0; j < n; j++)
-			dtmp[j] = z[off1 + j];
-
-		      for (octave_idx_type j = 0; j < n; j++)
-			z[off1 + j] = z[off2 + j];
-
-		      for (octave_idx_type j = 0; j < n; j++)
-			z[off2 + j] = dtmp[j];
-		    }
-		}
-
-	      if (note3)
-		eig_vec = ltsolve(b, permB, eig_vec);
-	    }
-	}
+        {
+          octave_idx_type k2 = k / 2;
+          if (typ != "SM" && typ != "BE")
+            {
+              for (octave_idx_type i = 0; i < k2; i++)
+                {
+                  double dtmp = d[i];
+                  d[i] = d[k - i - 1];
+                  d[k - i - 1] = dtmp;
+                }
+            }
+
+          if (rvec)
+            {
+              if (typ != "SM" && typ != "BE")
+                {
+                  OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
+                  for (octave_idx_type i = 0; i < k2; i++)
+                    {
+                      octave_idx_type off1 = i * n;
+                      octave_idx_type off2 = (k - i - 1) * n;
+
+                      if (off1 == off2)
+                        continue;
+
+                      for (octave_idx_type j = 0; j < n; j++)
+                        dtmp[j] = z[off1 + j];
+
+                      for (octave_idx_type j = 0; j < n; j++)
+                        z[off1 + j] = z[off2 + j];
+
+                      for (octave_idx_type j = 0; j < n; j++)
+                        z[off2 + j] = dtmp[j];
+                    }
+                }
+
+              if (note3)
+                eig_vec = ltsolve(b, permB, eig_vec);
+            }
+        }
       else
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: error %d in dseupd", info2);
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: error %d in dseupd", info2);
+          return -1;
+        }
     }
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsRealSymmetricMatrixShift (const M& m, double sigma,
-			      octave_idx_type k, octave_idx_type p, 
-			      octave_idx_type &info, Matrix &eig_vec, 
-			      ColumnVector &eig_val, const M& _b,
-			      ColumnVector &permB, ColumnVector &resid, 
-			      std::ostream& os, double tol, int rvec, 
-			      bool cholB, int disp, int maxit)
+                              octave_idx_type k, octave_idx_type p, 
+                              octave_idx_type &info, Matrix &eig_vec, 
+                              ColumnVector &eig_val, const M& _b,
+                              ColumnVector &permB, ColumnVector &resid, 
+                              std::ostream& os, double tol, int rvec, 
+                              bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
   bool have_b = ! b.is_empty();
   std::string typ = "LM";
 
   if (m.rows() != m.cols())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
   if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
     {
       (*current_liboctave_error_handler) 
-	("eigs: B must be square and the same size as A");
+        ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsRealSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
-  //				    _b, permB, resid, os, tol, rvec, cholB,
-  //				    disp, maxit);
+  //                                _b, permB, resid, os, tol, rvec, cholB,
+  //                                disp, maxit);
 
   if (resid.is_empty())
     {
       std::string rand_dist = octave_rand::distribution();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
-	("eigs: n must be at least 3");
+        ("eigs: n must be at least 3");
       return -1;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler) 
-	("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
-	     "      Use 'eig(full(A))' instead");
+        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
+             "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
-	p = 20;
+        p = 20;
       
       if (p > n - 1)
-	p = n - 1 ;
+        p = n - 1 ;
     }
   
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler) 
-	("eigs: opts.p must be greater than k and less than n");
+        ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
   if (have_b && cholB && permB.length() != 0) 
     {
       // Check the we really have a permutation vector
       if (permB.length() != n)
-	{
-	  (*current_liboctave_error_handler) ("eigs: permB vector invalid");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+          return -1;
+        }
       else
-	{
-	  Array<bool> checked(n,false);
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      octave_idx_type bidx = 
-		static_cast<octave_idx_type> (permB(i));
-	      if (checked(bidx) || bidx < 0 ||
-		  bidx >= n || D_NINT (bidx) != bidx)
-		{
-		  (*current_liboctave_error_handler) 
-		    ("eigs: permB vector invalid");
-		  return -1;
-		}
-	    }
-	}
+        {
+          Array<bool> checked(n,false);
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              octave_idx_type bidx = 
+                static_cast<octave_idx_type> (permB(i));
+              if (checked(bidx) || bidx < 0 ||
+                  bidx >= n || D_NINT (bidx) != bidx)
+                {
+                  (*current_liboctave_error_handler) 
+                    ("eigs: permB vector invalid");
+                  return -1;
+                }
+            }
+        }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
   Array<octave_idx_type> ip (11);
   octave_idx_type *iparam = ip.fortran_vec ();
@@ -1205,208 +1205,208 @@ EigsRealSymmetricMatrixShift (const M& m
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do 
     {
       F77_FUNC (dsaupd, DSAUPD) 
-	(ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-	 F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
-	 k, tol, presid, p, v, n, iparam,
-	 ipntr, workd, workl, lwork, info
-	 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+        (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
+         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         k, tol, presid, p, v, n, iparam,
+         ipntr, workd, workl, lwork, info
+         F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: unrecoverable exception encountered in dsaupd");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: unrecoverable exception encountered in dsaupd");
+          return -1;
+        }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
-	{
-	  if (iter++)
-	    {
-	      os << "Iteration " << iter - 1 << 
-		": a few Ritz values of the " << p << "-by-" <<
-		p << " matrix\n";
-	      for (int i = 0 ; i < k; i++)
-		os << "    " << workl[iptr(5)+i-1] << "\n";
-	    }
-
-	  // This is a kludge, as ARPACK doesn't give its
-	  // iteration pointer. But as workl[iptr(5)-1] is
-	  // an output value updated at each iteration, setting
-	  // a value in this array to NaN and testing for it
-	  // is a way of obtaining the iteration counter.
-	  if (ido != 99)
-	    workl[iptr(5)-1] = octave_NaN; 
-	}
+        {
+          if (iter++)
+            {
+              os << "Iteration " << iter - 1 << 
+                ": a few Ritz values of the " << p << "-by-" <<
+                p << " matrix\n";
+              for (int i = 0 ; i < k; i++)
+                os << "    " << workl[iptr(5)+i-1] << "\n";
+            }
+
+          // This is a kludge, as ARPACK doesn't give its
+          // iteration pointer. But as workl[iptr(5)-1] is
+          // an output value updated at each iteration, setting
+          // a value in this array to NaN and testing for it
+          // is a way of obtaining the iteration counter.
+          if (ido != 99)
+            workl[iptr(5)-1] = octave_NaN; 
+        }
 
       if (ido == -1 || ido == 1 || ido == 2)
-	{
-	  if (have_b)
-	    {
-	      if (ido == -1)
-		{
-		  OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-		  vector_product (m, workd+iptr(0)-1, dtmp);
-
-		  Matrix tmp(n, 1);
-
-		  for (octave_idx_type i = 0; i < n; i++)
-		    tmp(i,0) = dtmp[P[i]];
-				  
-		  lusolve (L, U, tmp);
-
-		  double *ip2 = workd+iptr(1)-1;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    ip2[Q[i]] = tmp(i,0);
-		}
-	      else if (ido == 2)
-		vector_product (b, workd+iptr(0)-1, workd+iptr(1)-1);
-	      else
-		{
-		  double *ip2 = workd+iptr(2)-1;
-		  Matrix tmp(n, 1);
-
-		  for (octave_idx_type i = 0; i < n; i++)
-		    tmp(i,0) = ip2[P[i]];
-				  
-		  lusolve (L, U, tmp);
-
-		  ip2 = workd+iptr(1)-1;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    ip2[Q[i]] = tmp(i,0);
-		}
-	    }
-	  else
-	    {
-	      if (ido == 2)
-		{
-		  for (octave_idx_type i = 0; i < n; i++)
-		    workd[iptr(0) + i - 1] = workd[iptr(1) + i - 1];
-		}
-	      else
-		{
-		  double *ip2 = workd+iptr(0)-1;
-		  Matrix tmp(n, 1);
-
-		  for (octave_idx_type i = 0; i < n; i++)
-		    tmp(i,0) = ip2[P[i]];
-				  
-		  lusolve (L, U, tmp);
-
-		  ip2 = workd+iptr(1)-1;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    ip2[Q[i]] = tmp(i,0);
-		}
-	    }
-	}
+        {
+          if (have_b)
+            {
+              if (ido == -1)
+                {
+                  OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
+                  vector_product (m, workd+iptr(0)-1, dtmp);
+
+                  Matrix tmp(n, 1);
+
+                  for (octave_idx_type i = 0; i < n; i++)
+                    tmp(i,0) = dtmp[P[i]];
+                                  
+                  lusolve (L, U, tmp);
+
+                  double *ip2 = workd+iptr(1)-1;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    ip2[Q[i]] = tmp(i,0);
+                }
+              else if (ido == 2)
+                vector_product (b, workd+iptr(0)-1, workd+iptr(1)-1);
+              else
+                {
+                  double *ip2 = workd+iptr(2)-1;
+                  Matrix tmp(n, 1);
+
+                  for (octave_idx_type i = 0; i < n; i++)
+                    tmp(i,0) = ip2[P[i]];
+                                  
+                  lusolve (L, U, tmp);
+
+                  ip2 = workd+iptr(1)-1;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    ip2[Q[i]] = tmp(i,0);
+                }
+            }
+          else
+            {
+              if (ido == 2)
+                {
+                  for (octave_idx_type i = 0; i < n; i++)
+                    workd[iptr(0) + i - 1] = workd[iptr(1) + i - 1];
+                }
+              else
+                {
+                  double *ip2 = workd+iptr(0)-1;
+                  Matrix tmp(n, 1);
+
+                  for (octave_idx_type i = 0; i < n; i++)
+                    tmp(i,0) = ip2[P[i]];
+                                  
+                  lusolve (L, U, tmp);
+
+                  ip2 = workd+iptr(1)-1;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    ip2[Q[i]] = tmp(i,0);
+                }
+            }
+        }
       else
-	{
-	  if (info < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("eigs: error %d in dsaupd", info);
-	      return -1;
-	    }
-	  break;
-	}
+        {
+          if (info < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("eigs: error %d in dsaupd", info);
+              return -1;
+            }
+          break;
+        }
     } 
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
   Array<octave_idx_type> s (p);
   octave_idx_type *sel = s.fortran_vec ();
-			
+                        
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
   F77_FUNC (dseupd, DSEUPD) 
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, 
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler)
-	("eigs: unrecoverable exception encountered in dseupd");
+        ("eigs: unrecoverable exception encountered in dseupd");
       return -1;
     }
   else
     {
       if (info2 == 0)
-	{
-	  octave_idx_type k2 = k / 2;
-	  for (octave_idx_type i = 0; i < k2; i++)
-	    {
-	      double dtmp = d[i];
-	      d[i] = d[k - i - 1];
-	      d[k - i - 1] = dtmp;
-	    }
-
-	  if (rvec)
-	    {
-	      OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-	      for (octave_idx_type i = 0; i < k2; i++)
-		{
-		  octave_idx_type off1 = i * n;
-		  octave_idx_type off2 = (k - i - 1) * n;
-
-		  if (off1 == off2)
-		    continue;
-
-		  for (octave_idx_type j = 0; j < n; j++)
-		    dtmp[j] = z[off1 + j];
-
-		  for (octave_idx_type j = 0; j < n; j++)
-		    z[off1 + j] = z[off2 + j];
-
-		  for (octave_idx_type j = 0; j < n; j++)
-		    z[off2 + j] = dtmp[j];
-		}
-	    }
-	}
+        {
+          octave_idx_type k2 = k / 2;
+          for (octave_idx_type i = 0; i < k2; i++)
+            {
+              double dtmp = d[i];
+              d[i] = d[k - i - 1];
+              d[k - i - 1] = dtmp;
+            }
+
+          if (rvec)
+            {
+              OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
+              for (octave_idx_type i = 0; i < k2; i++)
+                {
+                  octave_idx_type off1 = i * n;
+                  octave_idx_type off2 = (k - i - 1) * n;
+
+                  if (off1 == off2)
+                    continue;
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    dtmp[j] = z[off1 + j];
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    z[off1 + j] = z[off2 + j];
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    z[off2 + j] = dtmp[j];
+                }
+            }
+        }
       else
-	{
-	  (*current_liboctave_error_handler)
-	    ("eigs: error %d in dseupd", info2);
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler)
+            ("eigs: error %d in dseupd", info2);
+          return -1;
+        }
     }
 
   return ip(4);
 }
 
 octave_idx_type
 EigsRealSymmetricFunc (EigsFunc fun, octave_idx_type n,
-		       const std::string &_typ, double sigma,
-		       octave_idx_type k, octave_idx_type p, 
-		       octave_idx_type &info, Matrix &eig_vec, 
-		       ColumnVector &eig_val, ColumnVector &resid, 
-		       std::ostream& os, double tol, int rvec,
-		       bool /* cholB */, int disp, int maxit)
+                       const std::string &_typ, double sigma,
+                       octave_idx_type k, octave_idx_type p, 
+                       octave_idx_type &info, Matrix &eig_vec, 
+                       ColumnVector &eig_val, ColumnVector &resid, 
+                       std::ostream& os, double tol, int rvec,
+                       bool /* cholB */, int disp, int maxit)
 {
   std::string typ (_typ);
   bool have_sigma = (sigma ? true : false);
   char bmat = 'I';
   octave_idx_type mode = 1;
   int err = 0;
 
   if (resid.is_empty())
@@ -1415,67 +1415,67 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
-	("eigs: n must be at least 3");
+        ("eigs: n must be at least 3");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
-	p = 20;
+        p = 20;
       
       if (p > n - 1)
-	p = n - 1 ;
+        p = n - 1 ;
     }
   
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
-	("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-	     "      Use 'eig(full(A))' instead");
+        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+             "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
-	("eigs: opts.p must be greater than k and less than n");
+        ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
   if (! have_sigma)
     {
       if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" && 
-	  typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
-	  typ != "SI")
-	(*current_liboctave_error_handler) 
-	  ("eigs: unrecognized sigma value");
+          typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
+          typ != "SI")
+        (*current_liboctave_error_handler) 
+          ("eigs: unrecognized sigma value");
 
       if (typ == "LI" || typ == "SI" || typ == "LR" || typ == "SR")
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: invalid sigma value for real symmetric problem");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: invalid sigma value for real symmetric problem");
+          return -1;
+        }
 
       if (typ == "SM")
-	{
-	  typ = "LM";
-	  sigma = 0.;
-	  mode = 3;
-	}
+        {
+          typ = "LM";
+          sigma = 0.;
+          mode = 3;
+        }
     }
   else if (! std::abs (sigma))
     typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
     }
@@ -1506,172 +1506,172 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do 
     {
       F77_FUNC (dsaupd, DSAUPD) 
-	(ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-	 F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
-	 k, tol, presid, p, v, n, iparam,
-	 ipntr, workd, workl, lwork, info
-	 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+        (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
+         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         k, tol, presid, p, v, n, iparam,
+         ipntr, workd, workl, lwork, info
+         F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: unrecoverable exception encountered in dsaupd");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: unrecoverable exception encountered in dsaupd");
+          return -1;
+        }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
-	{
-	  if (iter++)
-	    {
-	      os << "Iteration " << iter - 1 << 
-		": a few Ritz values of the " << p << "-by-" <<
-		p << " matrix\n";
-	      for (int i = 0 ; i < k; i++)
-		os << "    " << workl[iptr(5)+i-1] << "\n";
-	    }
-
-	  // This is a kludge, as ARPACK doesn't give its
-	  // iteration pointer. But as workl[iptr(5)-1] is
-	  // an output value updated at each iteration, setting
-	  // a value in this array to NaN and testing for it
-	  // is a way of obtaining the iteration counter.
-	  if (ido != 99)
-	    workl[iptr(5)-1] = octave_NaN; 
-	}
+        {
+          if (iter++)
+            {
+              os << "Iteration " << iter - 1 << 
+                ": a few Ritz values of the " << p << "-by-" <<
+                p << " matrix\n";
+              for (int i = 0 ; i < k; i++)
+                os << "    " << workl[iptr(5)+i-1] << "\n";
+            }
+
+          // This is a kludge, as ARPACK doesn't give its
+          // iteration pointer. But as workl[iptr(5)-1] is
+          // an output value updated at each iteration, setting
+          // a value in this array to NaN and testing for it
+          // is a way of obtaining the iteration counter.
+          if (ido != 99)
+            workl[iptr(5)-1] = octave_NaN; 
+        }
 
 
       if (ido == -1 || ido == 1 || ido == 2)
-	{
-	  double *ip2 = workd + iptr(0) - 1;
-	  ColumnVector x(n);
-
-	  for (octave_idx_type i = 0; i < n; i++)
-	    x(i) = *ip2++;
-
-	  ColumnVector y = fun (x, err);
-
-	  if (err)
-	    return false;
-
-	  ip2 = workd + iptr(1) - 1;
-	  for (octave_idx_type i = 0; i < n; i++)
-	    *ip2++ = y(i);
-	}
+        {
+          double *ip2 = workd + iptr(0) - 1;
+          ColumnVector x(n);
+
+          for (octave_idx_type i = 0; i < n; i++)
+            x(i) = *ip2++;
+
+          ColumnVector y = fun (x, err);
+
+          if (err)
+            return false;
+
+          ip2 = workd + iptr(1) - 1;
+          for (octave_idx_type i = 0; i < n; i++)
+            *ip2++ = y(i);
+        }
       else
-	{
-	  if (info < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("eigs: error %d in dsaupd", info);
-	      return -1;
-	    }
-	  break;
-	}
+        {
+          if (info < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("eigs: error %d in dsaupd", info);
+              return -1;
+            }
+          break;
+        }
     } 
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
   Array<octave_idx_type> s (p);
   octave_idx_type *sel = s.fortran_vec ();
-			
+                        
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
   F77_FUNC (dseupd, DSEUPD) 
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, 
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler)
-	("eigs: unrecoverable exception encountered in dseupd");
+        ("eigs: unrecoverable exception encountered in dseupd");
       return -1;
     }
   else
     {
       if (info2 == 0)
-	{
-	  octave_idx_type k2 = k / 2;
-	  if (typ != "SM" && typ != "BE")
-	    {
-	      for (octave_idx_type i = 0; i < k2; i++)
-		{
-		  double dtmp = d[i];
-		  d[i] = d[k - i - 1];
-		  d[k - i - 1] = dtmp;
-		}
-	    }
-
-	  if (rvec)
-	    {
-	      if (typ != "SM" && typ != "BE")
-		{
-		  OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-		  for (octave_idx_type i = 0; i < k2; i++)
-		    {
-		      octave_idx_type off1 = i * n;
-		      octave_idx_type off2 = (k - i - 1) * n;
-
-		      if (off1 == off2)
-			continue;
-
-		      for (octave_idx_type j = 0; j < n; j++)
-			dtmp[j] = z[off1 + j];
-
-		      for (octave_idx_type j = 0; j < n; j++)
-			z[off1 + j] = z[off2 + j];
-
-		      for (octave_idx_type j = 0; j < n; j++)
-			z[off2 + j] = dtmp[j];
-		    }
-		}
-	    }
-	}
+        {
+          octave_idx_type k2 = k / 2;
+          if (typ != "SM" && typ != "BE")
+            {
+              for (octave_idx_type i = 0; i < k2; i++)
+                {
+                  double dtmp = d[i];
+                  d[i] = d[k - i - 1];
+                  d[k - i - 1] = dtmp;
+                }
+            }
+
+          if (rvec)
+            {
+              if (typ != "SM" && typ != "BE")
+                {
+                  OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
+                  for (octave_idx_type i = 0; i < k2; i++)
+                    {
+                      octave_idx_type off1 = i * n;
+                      octave_idx_type off2 = (k - i - 1) * n;
+
+                      if (off1 == off2)
+                        continue;
+
+                      for (octave_idx_type j = 0; j < n; j++)
+                        dtmp[j] = z[off1 + j];
+
+                      for (octave_idx_type j = 0; j < n; j++)
+                        z[off1 + j] = z[off2 + j];
+
+                      for (octave_idx_type j = 0; j < n; j++)
+                        z[off2 + j] = dtmp[j];
+                    }
+                }
+            }
+        }
       else
-	{
-	  (*current_liboctave_error_handler)
-	    ("eigs: error %d in dseupd", info2);
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler)
+            ("eigs: error %d in dseupd", info2);
+          return -1;
+        }
     }
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsRealNonSymmetricMatrix (const M& m, const std::string typ, 
-			    octave_idx_type k, octave_idx_type p,
-			    octave_idx_type &info, ComplexMatrix &eig_vec,
-			    ComplexColumnVector &eig_val, const M& _b,
-			    ColumnVector &permB, ColumnVector &resid, 
-			    std::ostream& os, double tol, int rvec, 
-			    bool cholB, int disp, int maxit)
+                            octave_idx_type k, octave_idx_type p,
+                            octave_idx_type &info, ComplexMatrix &eig_vec,
+                            ComplexColumnVector &eig_val, const M& _b,
+                            ColumnVector &permB, ColumnVector &resid, 
+                            std::ostream& os, double tol, int rvec, 
+                            bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 1;
   bool have_b = ! b.is_empty();
   bool note3 = false;
   char bmat = 'I';
   double sigmar = 0.;
@@ -1681,128 +1681,128 @@ EigsRealNonSymmetricMatrix (const M& m, 
   if (m.rows() != m.cols())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
   if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
     {
       (*current_liboctave_error_handler) 
-	("eigs: B must be square and the same size as A");
+        ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   if (resid.is_empty())
     {
       std::string rand_dist = octave_rand::distribution();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
-	("eigs: n must be at least 3");
+        ("eigs: n must be at least 3");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
-	p = 20;
+        p = 20;
       
       if (p > n - 1)
-	p = n - 1 ;
+        p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler) 
-	("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-	 "      Use 'eig(full(A))' instead");
+        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+         "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler) 
-	("eigs: opts.p must be greater than k and less than n");
+        ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
   if (have_b && cholB && permB.length() != 0) 
     {
       // Check the we really have a permutation vector
       if (permB.length() != n)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: permB vector invalid");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: permB vector invalid");
+          return -1;
+        }
       else
-	{
-	  Array<bool> checked(n,false);
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      octave_idx_type bidx = 
-		static_cast<octave_idx_type> (permB(i));
-	      if (checked(bidx) || bidx < 0 ||
-		  bidx >= n || D_NINT (bidx) != bidx)
-		{
-		  (*current_liboctave_error_handler) 
-		    ("eigs: permB vector invalid");
-		  return -1;
-		}
-	    }
-	}
+        {
+          Array<bool> checked(n,false);
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              octave_idx_type bidx = 
+                static_cast<octave_idx_type> (permB(i));
+              if (checked(bidx) || bidx < 0 ||
+                  bidx >= n || D_NINT (bidx) != bidx)
+                {
+                  (*current_liboctave_error_handler) 
+                    ("eigs: permB vector invalid");
+                  return -1;
+                }
+            }
+        }
     }
 
   if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" && 
       typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
       typ != "SI")
     {
       (*current_liboctave_error_handler) 
-	("eigs: unrecognized sigma value");
+        ("eigs: unrecognized sigma value");
       return -1;
     }
   
   if (typ == "LA" || typ == "SA" || typ == "BE")
     {
       (*current_liboctave_error_handler) 
-	("eigs: invalid sigma value for unsymmetric problem");
+        ("eigs: invalid sigma value for unsymmetric problem");
       return -1;
     }
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
-	{
-	  bt = b;
-	  b = b.transpose();
-	  if (permB.length() == 0)
-	    {
-	      permB = ColumnVector(n);
-	      for (octave_idx_type i = 0; i < n; i++)
-		permB(i) = i;
-	    }
-	}
+        {
+          bt = b;
+          b = b.transpose();
+          if (permB.length() == 0)
+            {
+              permB = ColumnVector(n);
+              for (octave_idx_type i = 0; i < n; i++)
+                permB(i) = i;
+            }
+        }
       else
-	{
-	  if (! make_cholb(b, bt, permB))
-	    {
-	      (*current_liboctave_error_handler) 
-		("eigs: The matrix B is not positive definite");
-	      return -1;
-	    }
-	}
+        {
+          if (! make_cholb(b, bt, permB))
+            {
+              (*current_liboctave_error_handler) 
+                ("eigs: The matrix B is not positive definite");
+              return -1;
+            }
+        }
     }
 
   Array<octave_idx_type> ip (11);
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
@@ -1826,76 +1826,76 @@ EigsRealNonSymmetricMatrix (const M& m, 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do 
     {
       F77_FUNC (dnaupd, DNAUPD) 
-	(ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-	 F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
-	 k, tol, presid, p, v, n, iparam,
-	 ipntr, workd, workl, lwork, info
-	 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+        (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
+         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         k, tol, presid, p, v, n, iparam,
+         ipntr, workd, workl, lwork, info
+         F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: unrecoverable exception encountered in dnaupd");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: unrecoverable exception encountered in dnaupd");
+          return -1;
+        }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
-	{
-	  if (iter++)
-	    {
-	      os << "Iteration " << iter - 1 << 
-		": a few Ritz values of the " << p << "-by-" <<
-		p << " matrix\n";
-	      for (int i = 0 ; i < k; i++)
-		os << "    " << workl[iptr(5)+i-1] << "\n";
-	    }
-
-	  // This is a kludge, as ARPACK doesn't give its
-	  // iteration pointer. But as workl[iptr(5)-1] is
-	  // an output value updated at each iteration, setting
-	  // a value in this array to NaN and testing for it
-	  // is a way of obtaining the iteration counter.
-	  if (ido != 99)
-	    workl[iptr(5)-1] = octave_NaN; 
-	}
+        {
+          if (iter++)
+            {
+              os << "Iteration " << iter - 1 << 
+                ": a few Ritz values of the " << p << "-by-" <<
+                p << " matrix\n";
+              for (int i = 0 ; i < k; i++)
+                os << "    " << workl[iptr(5)+i-1] << "\n";
+            }
+
+          // This is a kludge, as ARPACK doesn't give its
+          // iteration pointer. But as workl[iptr(5)-1] is
+          // an output value updated at each iteration, setting
+          // a value in this array to NaN and testing for it
+          // is a way of obtaining the iteration counter.
+          if (ido != 99)
+            workl[iptr(5)-1] = octave_NaN; 
+        }
 
       if (ido == -1 || ido == 1 || ido == 2)
-	{
-	  if (have_b)
-	    {
-	      Matrix mtmp (n,1);
-	      for (octave_idx_type i = 0; i < n; i++)
-		mtmp(i,0) = workd[i + iptr(0) - 1];
-	      
-	      mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
-
-	      for (octave_idx_type i = 0; i < n; i++)
-		workd[i+iptr(1)-1] = mtmp(i,0);
-	    }
-	  else if (!vector_product (m, workd + iptr(0) - 1, 
-				    workd + iptr(1) - 1))
-	    break;
-	}
+        {
+          if (have_b)
+            {
+              Matrix mtmp (n,1);
+              for (octave_idx_type i = 0; i < n; i++)
+                mtmp(i,0) = workd[i + iptr(0) - 1];
+              
+              mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
+
+              for (octave_idx_type i = 0; i < n; i++)
+                workd[i+iptr(1)-1] = mtmp(i,0);
+            }
+          else if (!vector_product (m, workd + iptr(0) - 1, 
+                                    workd + iptr(1) - 1))
+            break;
+        }
       else
-	{
-	  if (info < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("eigs: error %d in dnaupd", info);
-	      return -1;
-	    }
-	  break;
-	}
+        {
+          if (info < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("eigs: error %d in dnaupd", info);
+              return -1;
+            }
+          break;
+        }
     } 
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
@@ -1920,212 +1920,212 @@ EigsRealNonSymmetricMatrix (const M& m, 
      sigmai, workev,  F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
      ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) 
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler)
-	("eigs: unrecoverable exception encountered in dneupd");
+        ("eigs: unrecoverable exception encountered in dneupd");
       return -1;
     }
   else
     {
       eig_val.resize (k+1);
       Complex *d = eig_val.fortran_vec ();
 
       if (info2 == 0)
-	{
-	  octave_idx_type jj = 0;
-	  for (octave_idx_type i = 0; i < k+1; i++)
-	    {
-	      if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
-		jj++;
-	      else
-		d [i-jj] = Complex (dr[i], di[i]);
-	    }
-	  if (jj == 0 && !rvec)
-	    for (octave_idx_type i = 0; i < k; i++)
-	      d[i] = d[i+1];
-
-	  octave_idx_type k2 = k / 2;
-	  for (octave_idx_type i = 0; i < k2; i++)
-	    {
-	      Complex dtmp = d[i];
-	      d[i] = d[k - i - 1];
-	      d[k - i - 1] = dtmp;
-	    }
-	  eig_val.resize(k);
-
-	  if (rvec)
-	    {
-	      OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-	      for (octave_idx_type i = 0; i < k2; i++)
-		{
-		  octave_idx_type off1 = i * n;
-		  octave_idx_type off2 = (k - i - 1) * n;
-
-		  if (off1 == off2)
-		    continue;
-
-		  for (octave_idx_type j = 0; j < n; j++)
-		    dtmp[j] = z[off1 + j];
-
-		  for (octave_idx_type j = 0; j < n; j++)
-		    z[off1 + j] = z[off2 + j];
-
-		  for (octave_idx_type j = 0; j < n; j++)
-		    z[off2 + j] = dtmp[j];
-		}
-
-	      eig_vec.resize (n, k);
-	      octave_idx_type i = 0;
-	      while (i < k)
-		{
-		  octave_idx_type off1 = i * n;
-		  octave_idx_type off2 = (i+1) * n;
-		  if (std::imag(eig_val(i)) == 0)
-		    {
-		      for (octave_idx_type j = 0; j < n; j++)
-			eig_vec(j,i) = 
-			  Complex(z[j+off1],0.);
-		      i++;
-		    }
-		  else
-		    {
-		      for (octave_idx_type j = 0; j < n; j++)
-			{
-			  eig_vec(j,i) = 
-			    Complex(z[j+off1],z[j+off2]);
-			  if (i < k - 1)
-			    eig_vec(j,i+1) = 
-			      Complex(z[j+off1],-z[j+off2]);
-			}
-		      i+=2;
-		    }
-		}
-
-	      if (note3)
-		eig_vec = ltsolve(M (b), permB, eig_vec);
-	    }
-	}
+        {
+          octave_idx_type jj = 0;
+          for (octave_idx_type i = 0; i < k+1; i++)
+            {
+              if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
+                jj++;
+              else
+                d [i-jj] = Complex (dr[i], di[i]);
+            }
+          if (jj == 0 && !rvec)
+            for (octave_idx_type i = 0; i < k; i++)
+              d[i] = d[i+1];
+
+          octave_idx_type k2 = k / 2;
+          for (octave_idx_type i = 0; i < k2; i++)
+            {
+              Complex dtmp = d[i];
+              d[i] = d[k - i - 1];
+              d[k - i - 1] = dtmp;
+            }
+          eig_val.resize(k);
+
+          if (rvec)
+            {
+              OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
+              for (octave_idx_type i = 0; i < k2; i++)
+                {
+                  octave_idx_type off1 = i * n;
+                  octave_idx_type off2 = (k - i - 1) * n;
+
+                  if (off1 == off2)
+                    continue;
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    dtmp[j] = z[off1 + j];
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    z[off1 + j] = z[off2 + j];
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    z[off2 + j] = dtmp[j];
+                }
+
+              eig_vec.resize (n, k);
+              octave_idx_type i = 0;
+              while (i < k)
+                {
+                  octave_idx_type off1 = i * n;
+                  octave_idx_type off2 = (i+1) * n;
+                  if (std::imag(eig_val(i)) == 0)
+                    {
+                      for (octave_idx_type j = 0; j < n; j++)
+                        eig_vec(j,i) = 
+                          Complex(z[j+off1],0.);
+                      i++;
+                    }
+                  else
+                    {
+                      for (octave_idx_type j = 0; j < n; j++)
+                        {
+                          eig_vec(j,i) = 
+                            Complex(z[j+off1],z[j+off2]);
+                          if (i < k - 1)
+                            eig_vec(j,i+1) = 
+                              Complex(z[j+off1],-z[j+off2]);
+                        }
+                      i+=2;
+                    }
+                }
+
+              if (note3)
+                eig_vec = ltsolve(M (b), permB, eig_vec);
+            }
+        }
       else
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: error %d in dneupd", info2);
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: error %d in dneupd", info2);
+          return -1;
+        }
     }
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsRealNonSymmetricMatrixShift (const M& m, double sigmar,
-				 octave_idx_type k, octave_idx_type p, 
-				 octave_idx_type &info, 
-				 ComplexMatrix &eig_vec, 
-				 ComplexColumnVector &eig_val, const M& _b,
-				 ColumnVector &permB, ColumnVector &resid, 
-				 std::ostream& os, double tol, int rvec, 
-				 bool cholB, int disp, int maxit)
+                                 octave_idx_type k, octave_idx_type p, 
+                                 octave_idx_type &info, 
+                                 ComplexMatrix &eig_vec, 
+                                 ComplexColumnVector &eig_val, const M& _b,
+                                 ColumnVector &permB, ColumnVector &resid, 
+                                 std::ostream& os, double tol, int rvec, 
+                                 bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
   bool have_b = ! b.is_empty();
   std::string typ = "LM";
   double sigmai = 0.;
 
   if (m.rows() != m.cols())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
   if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
     {
       (*current_liboctave_error_handler) 
-	("eigs: B must be square and the same size as A");
+        ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigmar))
   //  return EigsRealNonSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
-  //				       _b, permB, resid, os, tol, rvec, cholB,
-  //				       disp, maxit);
+  //                                   _b, permB, resid, os, tol, rvec, cholB,
+  //                                   disp, maxit);
 
   if (resid.is_empty())
     {
       std::string rand_dist = octave_rand::distribution();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
-	("eigs: n must be at least 3");
+        ("eigs: n must be at least 3");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
-	p = 20;
+        p = 20;
       
       if (p > n - 1)
-	p = n - 1 ;
+        p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler) 
-	("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-	     "      Use 'eig(full(A))' instead");
+        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+             "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler) 
-	("eigs: opts.p must be greater than k and less than n");
+        ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
   if (have_b && cholB && permB.length() != 0) 
     {
       // Check that we really have a permutation vector
       if (permB.length() != n)
-	{
-	  (*current_liboctave_error_handler) ("eigs: permB vector invalid");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+          return -1;
+        }
       else
-	{
-	  Array<bool> checked(n,false);
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      octave_idx_type bidx = 
-		static_cast<octave_idx_type> (permB(i));
-	      if (checked(bidx) || bidx < 0 ||
-		  bidx >= n || D_NINT (bidx) != bidx)
-		{
-		  (*current_liboctave_error_handler) 
-		    ("eigs: permB vector invalid");
-		  return -1;
-		}
-	    }
-	}
+        {
+          Array<bool> checked(n,false);
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              octave_idx_type bidx = 
+                static_cast<octave_idx_type> (permB(i));
+              if (checked(bidx) || bidx < 0 ||
+                  bidx >= n || D_NINT (bidx) != bidx)
+                {
+                  (*current_liboctave_error_handler) 
+                    ("eigs: permB vector invalid");
+                  return -1;
+                }
+            }
+        }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
   Array<octave_idx_type> ip (11);
   octave_idx_type *iparam = ip.fortran_vec ();
@@ -2161,135 +2161,135 @@ EigsRealNonSymmetricMatrixShift (const M
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do 
     {
       F77_FUNC (dnaupd, DNAUPD) 
-	(ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-	 F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
-	 k, tol, presid, p, v, n, iparam,
-	 ipntr, workd, workl, lwork, info
-	 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+        (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
+         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         k, tol, presid, p, v, n, iparam,
+         ipntr, workd, workl, lwork, info
+         F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: unrecoverable exception encountered in dsaupd");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: unrecoverable exception encountered in dsaupd");
+          return -1;
+        }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
-	{
-	  if (iter++)
-	    {
-	      os << "Iteration " << iter - 1 << 
-		": a few Ritz values of the " << p << "-by-" <<
-		p << " matrix\n";
-	      for (int i = 0 ; i < k; i++)
-		os << "    " << workl[iptr(5)+i-1] << "\n";
-	    }
-
-	  // This is a kludge, as ARPACK doesn't give its
-	  // iteration pointer. But as workl[iptr(5)-1] is
-	  // an output value updated at each iteration, setting
-	  // a value in this array to NaN and testing for it
-	  // is a way of obtaining the iteration counter.
-	  if (ido != 99)
-	    workl[iptr(5)-1] = octave_NaN; 
-	}
+        {
+          if (iter++)
+            {
+              os << "Iteration " << iter - 1 << 
+                ": a few Ritz values of the " << p << "-by-" <<
+                p << " matrix\n";
+              for (int i = 0 ; i < k; i++)
+                os << "    " << workl[iptr(5)+i-1] << "\n";
+            }
+
+          // This is a kludge, as ARPACK doesn't give its
+          // iteration pointer. But as workl[iptr(5)-1] is
+          // an output value updated at each iteration, setting
+          // a value in this array to NaN and testing for it
+          // is a way of obtaining the iteration counter.
+          if (ido != 99)
+            workl[iptr(5)-1] = octave_NaN; 
+        }
 
       if (ido == -1 || ido == 1 || ido == 2)
-	{
-	  if (have_b)
-	    {
-	      if (ido == -1)
-		{
-		  OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-		  vector_product (m, workd+iptr(0)-1, dtmp);
-
-		  Matrix tmp(n, 1);
-
-		  for (octave_idx_type i = 0; i < n; i++)
-		    tmp(i,0) = dtmp[P[i]];
-				  
-		  lusolve (L, U, tmp);
-
-		  double *ip2 = workd+iptr(1)-1;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    ip2[Q[i]] = tmp(i,0);
-		}
-	      else if (ido == 2)
-		vector_product (b, workd+iptr(0)-1, workd+iptr(1)-1);
-	      else
-		{
-		  double *ip2 = workd+iptr(2)-1;
-		  Matrix tmp(n, 1);
-
-		  for (octave_idx_type i = 0; i < n; i++)
-		    tmp(i,0) = ip2[P[i]];
-				  
-		  lusolve (L, U, tmp);
-
-		  ip2 = workd+iptr(1)-1;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    ip2[Q[i]] = tmp(i,0);
-		}
-	    }
-	  else
-	    {
-	      if (ido == 2)
-		{
-		  for (octave_idx_type i = 0; i < n; i++)
-		    workd[iptr(0) + i - 1] = workd[iptr(1) + i - 1];
-		}
-	      else
-		{
-		  double *ip2 = workd+iptr(0)-1;
-		  Matrix tmp(n, 1);
-
-		  for (octave_idx_type i = 0; i < n; i++)
-		    tmp(i,0) = ip2[P[i]];
-				  
-		  lusolve (L, U, tmp);
-
-		  ip2 = workd+iptr(1)-1;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    ip2[Q[i]] = tmp(i,0);
-		}
-	    }
-	}
+        {
+          if (have_b)
+            {
+              if (ido == -1)
+                {
+                  OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
+                  vector_product (m, workd+iptr(0)-1, dtmp);
+
+                  Matrix tmp(n, 1);
+
+                  for (octave_idx_type i = 0; i < n; i++)
+                    tmp(i,0) = dtmp[P[i]];
+                                  
+                  lusolve (L, U, tmp);
+
+                  double *ip2 = workd+iptr(1)-1;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    ip2[Q[i]] = tmp(i,0);
+                }
+              else if (ido == 2)
+                vector_product (b, workd+iptr(0)-1, workd+iptr(1)-1);
+              else
+                {
+                  double *ip2 = workd+iptr(2)-1;
+                  Matrix tmp(n, 1);
+
+                  for (octave_idx_type i = 0; i < n; i++)
+                    tmp(i,0) = ip2[P[i]];
+                                  
+                  lusolve (L, U, tmp);
+
+                  ip2 = workd+iptr(1)-1;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    ip2[Q[i]] = tmp(i,0);
+                }
+            }
+          else
+            {
+              if (ido == 2)
+                {
+                  for (octave_idx_type i = 0; i < n; i++)
+                    workd[iptr(0) + i - 1] = workd[iptr(1) + i - 1];
+                }
+              else
+                {
+                  double *ip2 = workd+iptr(0)-1;
+                  Matrix tmp(n, 1);
+
+                  for (octave_idx_type i = 0; i < n; i++)
+                    tmp(i,0) = ip2[P[i]];
+                                  
+                  lusolve (L, U, tmp);
+
+                  ip2 = workd+iptr(1)-1;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    ip2[Q[i]] = tmp(i,0);
+                }
+            }
+        }
       else
-	{
-	  if (info < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("eigs: error %d in dsaupd", info);
-	      return -1;
-	    }
-	  break;
-	}
+        {
+          if (info < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("eigs: error %d in dsaupd", info);
+              return -1;
+            }
+          break;
+        }
     } 
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
   Array<octave_idx_type> s (p);
   octave_idx_type *sel = s.fortran_vec ();
-			
+                        
   Matrix eig_vec2 (n, k + 1);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
   for (octave_idx_type i = 0; i < k+1; i++)
     dr[i] = di[i] = 0.;
@@ -2299,116 +2299,116 @@ EigsRealNonSymmetricMatrixShift (const M
      sigmai, workev,  F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
      ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) 
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler)
-	("eigs: unrecoverable exception encountered in dneupd");
+        ("eigs: unrecoverable exception encountered in dneupd");
       return -1;
     }
   else
     {
       eig_val.resize (k+1);
       Complex *d = eig_val.fortran_vec ();
 
       if (info2 == 0)
-	{
-	  octave_idx_type jj = 0;
-	  for (octave_idx_type i = 0; i < k+1; i++)
-	    {
-	      if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
-		jj++;
-	      else
-		d [i-jj] = Complex (dr[i], di[i]);
-	    }
-	  if (jj == 0 && !rvec)
-	    for (octave_idx_type i = 0; i < k; i++)
-	      d[i] = d[i+1];
-
-	  octave_idx_type k2 = k / 2;
-	  for (octave_idx_type i = 0; i < k2; i++)
-	    {
-	      Complex dtmp = d[i];
-	      d[i] = d[k - i - 1];
-	      d[k - i - 1] = dtmp;
-	    }
-	  eig_val.resize(k);
-
-	  if (rvec)
-	    {
-	      OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-	      for (octave_idx_type i = 0; i < k2; i++)
-		{
-		  octave_idx_type off1 = i * n;
-		  octave_idx_type off2 = (k - i - 1) * n;
-
-		  if (off1 == off2)
-		    continue;
-
-		  for (octave_idx_type j = 0; j < n; j++)
-		    dtmp[j] = z[off1 + j];
-
-		  for (octave_idx_type j = 0; j < n; j++)
-		    z[off1 + j] = z[off2 + j];
-
-		  for (octave_idx_type j = 0; j < n; j++)
-		    z[off2 + j] = dtmp[j];
-		}
-
-	      eig_vec.resize (n, k);
-	      octave_idx_type i = 0;
-	      while (i < k)
-		{
-		  octave_idx_type off1 = i * n;
-		  octave_idx_type off2 = (i+1) * n;
-		  if (std::imag(eig_val(i)) == 0)
-		    {
-		      for (octave_idx_type j = 0; j < n; j++)
-			eig_vec(j,i) = 
-			  Complex(z[j+off1],0.);
-		      i++;
-		    }
-		  else
-		    {
-		      for (octave_idx_type j = 0; j < n; j++)
-			{
-			  eig_vec(j,i) = 
-			    Complex(z[j+off1],z[j+off2]);
-			  if (i < k - 1)
-			    eig_vec(j,i+1) = 
-			      Complex(z[j+off1],-z[j+off2]);
-			}
-		      i+=2;
-		    }
-		}
-	    }
-	}
+        {
+          octave_idx_type jj = 0;
+          for (octave_idx_type i = 0; i < k+1; i++)
+            {
+              if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
+                jj++;
+              else
+                d [i-jj] = Complex (dr[i], di[i]);
+            }
+          if (jj == 0 && !rvec)
+            for (octave_idx_type i = 0; i < k; i++)
+              d[i] = d[i+1];
+
+          octave_idx_type k2 = k / 2;
+          for (octave_idx_type i = 0; i < k2; i++)
+            {
+              Complex dtmp = d[i];
+              d[i] = d[k - i - 1];
+              d[k - i - 1] = dtmp;
+            }
+          eig_val.resize(k);
+
+          if (rvec)
+            {
+              OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
+              for (octave_idx_type i = 0; i < k2; i++)
+                {
+                  octave_idx_type off1 = i * n;
+                  octave_idx_type off2 = (k - i - 1) * n;
+
+                  if (off1 == off2)
+                    continue;
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    dtmp[j] = z[off1 + j];
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    z[off1 + j] = z[off2 + j];
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    z[off2 + j] = dtmp[j];
+                }
+
+              eig_vec.resize (n, k);
+              octave_idx_type i = 0;
+              while (i < k)
+                {
+                  octave_idx_type off1 = i * n;
+                  octave_idx_type off2 = (i+1) * n;
+                  if (std::imag(eig_val(i)) == 0)
+                    {
+                      for (octave_idx_type j = 0; j < n; j++)
+                        eig_vec(j,i) = 
+                          Complex(z[j+off1],0.);
+                      i++;
+                    }
+                  else
+                    {
+                      for (octave_idx_type j = 0; j < n; j++)
+                        {
+                          eig_vec(j,i) = 
+                            Complex(z[j+off1],z[j+off2]);
+                          if (i < k - 1)
+                            eig_vec(j,i+1) = 
+                              Complex(z[j+off1],-z[j+off2]);
+                        }
+                      i+=2;
+                    }
+                }
+            }
+        }
       else
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: error %d in dneupd", info2);
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: error %d in dneupd", info2);
+          return -1;
+        }
     }
 
   return ip(4);
 }
 
 octave_idx_type
 EigsRealNonSymmetricFunc (EigsFunc fun, octave_idx_type n,
-			  const std::string &_typ, double sigmar,
-			  octave_idx_type k, octave_idx_type p, 
-			  octave_idx_type &info, ComplexMatrix &eig_vec, 
-			  ComplexColumnVector &eig_val, ColumnVector &resid, 
-			  std::ostream& os, double tol, int rvec,
-			  bool /* cholB */, int disp, int maxit)
+                          const std::string &_typ, double sigmar,
+                          octave_idx_type k, octave_idx_type p, 
+                          octave_idx_type &info, ComplexMatrix &eig_vec, 
+                          ComplexColumnVector &eig_val, ColumnVector &resid, 
+                          std::ostream& os, double tol, int rvec,
+                          bool /* cholB */, int disp, int maxit)
 {
   std::string typ (_typ);
   bool have_sigma = (sigmar ? true : false);
   char bmat = 'I';
   double sigmai = 0.;
   octave_idx_type mode = 1;
   int err = 0;
 
@@ -2418,68 +2418,68 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
-	("eigs: n must be at least 3");
+        ("eigs: n must be at least 3");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
-	p = 20;
+        p = 20;
       
       if (p > n - 1)
-	p = n - 1 ;
+        p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
-	("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-	     "      Use 'eig(full(A))' instead");
+        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+             "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
-	("eigs: opts.p must be greater than k and less than n");
+        ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
 
   if (! have_sigma)
     {
       if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" && 
-	  typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
-	  typ != "SI")
-	(*current_liboctave_error_handler) 
-	  ("eigs: unrecognized sigma value");
+          typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
+          typ != "SI")
+        (*current_liboctave_error_handler) 
+          ("eigs: unrecognized sigma value");
 
       if (typ == "LA" || typ == "SA" || typ == "BE")
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: invalid sigma value for unsymmetric problem");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: invalid sigma value for unsymmetric problem");
+          return -1;
+        }
 
       if (typ == "SM")
-	{
-	  typ = "LM";
-	  sigmar = 0.;
-	  mode = 3;
-	}
+        {
+          typ = "LM";
+          sigmar = 0.;
+          mode = 3;
+        }
     }
   else if (! std::abs (sigmar))
     typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
     }
@@ -2510,76 +2510,76 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do 
     {
       F77_FUNC (dnaupd, DNAUPD) 
-	(ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-	 F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
-	 k, tol, presid, p, v, n, iparam,
-	 ipntr, workd, workl, lwork, info
-	 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+        (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
+         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         k, tol, presid, p, v, n, iparam,
+         ipntr, workd, workl, lwork, info
+         F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: unrecoverable exception encountered in dnaupd");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: unrecoverable exception encountered in dnaupd");
+          return -1;
+        }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
-	{
-	  if (iter++)
-	    {
-	      os << "Iteration " << iter - 1 << 
-		": a few Ritz values of the " << p << "-by-" <<
-		p << " matrix\n";
-	      for (int i = 0 ; i < k; i++)
-		os << "    " << workl[iptr(5)+i-1] << "\n";
-	    }
-
-	  // This is a kludge, as ARPACK doesn't give its
-	  // iteration pointer. But as workl[iptr(5)-1] is
-	  // an output value updated at each iteration, setting
-	  // a value in this array to NaN and testing for it
-	  // is a way of obtaining the iteration counter.
-	  if (ido != 99)
-	    workl[iptr(5)-1] = octave_NaN; 
-	}
+        {
+          if (iter++)
+            {
+              os << "Iteration " << iter - 1 << 
+                ": a few Ritz values of the " << p << "-by-" <<
+                p << " matrix\n";
+              for (int i = 0 ; i < k; i++)
+                os << "    " << workl[iptr(5)+i-1] << "\n";
+            }
+
+          // This is a kludge, as ARPACK doesn't give its
+          // iteration pointer. But as workl[iptr(5)-1] is
+          // an output value updated at each iteration, setting
+          // a value in this array to NaN and testing for it
+          // is a way of obtaining the iteration counter.
+          if (ido != 99)
+            workl[iptr(5)-1] = octave_NaN; 
+        }
 
       if (ido == -1 || ido == 1 || ido == 2)
-	{
-	  double *ip2 = workd + iptr(0) - 1;
-	  ColumnVector x(n);
-
-	  for (octave_idx_type i = 0; i < n; i++)
-	    x(i) = *ip2++;
-
-	  ColumnVector y = fun (x, err);
-
-	  if (err)
-	    return false;
-
-	  ip2 = workd + iptr(1) - 1;
-	  for (octave_idx_type i = 0; i < n; i++)
-	    *ip2++ = y(i);
-	}
+        {
+          double *ip2 = workd + iptr(0) - 1;
+          ColumnVector x(n);
+
+          for (octave_idx_type i = 0; i < n; i++)
+            x(i) = *ip2++;
+
+          ColumnVector y = fun (x, err);
+
+          if (err)
+            return false;
+
+          ip2 = workd + iptr(1) - 1;
+          for (octave_idx_type i = 0; i < n; i++)
+            *ip2++ = y(i);
+        }
       else
-	{
-	  if (info < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("eigs: error %d in dsaupd", info);
-	      return -1;
-	    }
-	  break;
-	}
+        {
+          if (info < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("eigs: error %d in dsaupd", info);
+              return -1;
+            }
+          break;
+        }
     } 
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
@@ -2604,118 +2604,118 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
      sigmai, workev,  F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
      ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) 
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler)
-	("eigs: unrecoverable exception encountered in dneupd");
+        ("eigs: unrecoverable exception encountered in dneupd");
       return -1;
     }
   else
     {
       eig_val.resize (k+1);
       Complex *d = eig_val.fortran_vec ();
 
       if (info2 == 0)
-	{
-	  octave_idx_type jj = 0;
-	  for (octave_idx_type i = 0; i < k+1; i++)
-	    {
-	      if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
-		jj++;
-	      else
-		d [i-jj] = Complex (dr[i], di[i]);
-	    }
-	  if (jj == 0 && !rvec)
-	    for (octave_idx_type i = 0; i < k; i++)
-	      d[i] = d[i+1];
-
-	  octave_idx_type k2 = k / 2;
-	  for (octave_idx_type i = 0; i < k2; i++)
-	    {
-	      Complex dtmp = d[i];
-	      d[i] = d[k - i - 1];
-	      d[k - i - 1] = dtmp;
-	    }
-	  eig_val.resize(k);
-
-	  if (rvec)
-	    {
-	      OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-	      for (octave_idx_type i = 0; i < k2; i++)
-		{
-		  octave_idx_type off1 = i * n;
-		  octave_idx_type off2 = (k - i - 1) * n;
-
-		  if (off1 == off2)
-		    continue;
-
-		  for (octave_idx_type j = 0; j < n; j++)
-		    dtmp[j] = z[off1 + j];
-
-		  for (octave_idx_type j = 0; j < n; j++)
-		    z[off1 + j] = z[off2 + j];
-
-		  for (octave_idx_type j = 0; j < n; j++)
-		    z[off2 + j] = dtmp[j];
-		}
-
-	      eig_vec.resize (n, k);
-	      octave_idx_type i = 0;
-	      while (i < k)
-		{
-		  octave_idx_type off1 = i * n;
-		  octave_idx_type off2 = (i+1) * n;
-		  if (std::imag(eig_val(i)) == 0)
-		    {
-		      for (octave_idx_type j = 0; j < n; j++)
-			eig_vec(j,i) = 
-			  Complex(z[j+off1],0.);
-		      i++;
-		    }
-		  else
-		    {
-		      for (octave_idx_type j = 0; j < n; j++)
-			{
-			  eig_vec(j,i) = 
-			    Complex(z[j+off1],z[j+off2]);
-			  if (i < k - 1)
-			    eig_vec(j,i+1) = 
-			      Complex(z[j+off1],-z[j+off2]);
-			}
-		      i+=2;
-		    }
-		}
-	    }
-	}
+        {
+          octave_idx_type jj = 0;
+          for (octave_idx_type i = 0; i < k+1; i++)
+            {
+              if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
+                jj++;
+              else
+                d [i-jj] = Complex (dr[i], di[i]);
+            }
+          if (jj == 0 && !rvec)
+            for (octave_idx_type i = 0; i < k; i++)
+              d[i] = d[i+1];
+
+          octave_idx_type k2 = k / 2;
+          for (octave_idx_type i = 0; i < k2; i++)
+            {
+              Complex dtmp = d[i];
+              d[i] = d[k - i - 1];
+              d[k - i - 1] = dtmp;
+            }
+          eig_val.resize(k);
+
+          if (rvec)
+            {
+              OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
+              for (octave_idx_type i = 0; i < k2; i++)
+                {
+                  octave_idx_type off1 = i * n;
+                  octave_idx_type off2 = (k - i - 1) * n;
+
+                  if (off1 == off2)
+                    continue;
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    dtmp[j] = z[off1 + j];
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    z[off1 + j] = z[off2 + j];
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    z[off2 + j] = dtmp[j];
+                }
+
+              eig_vec.resize (n, k);
+              octave_idx_type i = 0;
+              while (i < k)
+                {
+                  octave_idx_type off1 = i * n;
+                  octave_idx_type off2 = (i+1) * n;
+                  if (std::imag(eig_val(i)) == 0)
+                    {
+                      for (octave_idx_type j = 0; j < n; j++)
+                        eig_vec(j,i) = 
+                          Complex(z[j+off1],0.);
+                      i++;
+                    }
+                  else
+                    {
+                      for (octave_idx_type j = 0; j < n; j++)
+                        {
+                          eig_vec(j,i) = 
+                            Complex(z[j+off1],z[j+off2]);
+                          if (i < k - 1)
+                            eig_vec(j,i+1) = 
+                              Complex(z[j+off1],-z[j+off2]);
+                        }
+                      i+=2;
+                    }
+                }
+            }
+        }
       else
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: error %d in dneupd", info2);
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: error %d in dneupd", info2);
+          return -1;
+        }
     }
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsComplexNonSymmetricMatrix (const M& m, const std::string typ, 
-			       octave_idx_type k, octave_idx_type p,
-			       octave_idx_type &info, ComplexMatrix &eig_vec,
-			       ComplexColumnVector &eig_val, const M& _b,
-			       ColumnVector &permB, 
-			       ComplexColumnVector &cresid, 
-			       std::ostream& os, double tol, int rvec, 
-			       bool cholB, int disp, int maxit)
+                               octave_idx_type k, octave_idx_type p,
+                               octave_idx_type &info, ComplexMatrix &eig_vec,
+                               ComplexColumnVector &eig_val, const M& _b,
+                               ColumnVector &permB, 
+                               ComplexColumnVector &cresid, 
+                               std::ostream& os, double tol, int rvec, 
+                               bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 1;
   bool have_b = ! b.is_empty();
   bool note3 = false;
   char bmat = 'I';
   Complex sigma = 0.;
@@ -2724,132 +2724,132 @@ EigsComplexNonSymmetricMatrix (const M& 
   if (m.rows() != m.cols())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
   if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
     {
       (*current_liboctave_error_handler) 
-	("eigs: B must be square and the same size as A");
+        ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   if (cresid.is_empty())
     {
       std::string rand_dist = octave_rand::distribution();
       octave_rand::distribution("uniform");
       Array<double> rr (octave_rand::vector(n));
       Array<double> ri (octave_rand::vector(n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
-	cresid(i) = Complex(rr(i),ri(i));
+        cresid(i) = Complex(rr(i),ri(i));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
-	("eigs: n must be at least 3");
+        ("eigs: n must be at least 3");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
-	p = 20;
+        p = 20;
       
       if (p > n - 1)
-	p = n - 1 ;
+        p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler) 
-	("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-	 "      Use 'eig(full(A))' instead");
+        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+         "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler) 
-	("eigs: opts.p must be greater than k and less than n");
+        ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
   if (have_b && cholB && permB.length() != 0) 
     {
       // Check the we really have a permutation vector
       if (permB.length() != n)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: permB vector invalid");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: permB vector invalid");
+          return -1;
+        }
       else
-	{
-	  Array<bool> checked(n,false);
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      octave_idx_type bidx = 
-		static_cast<octave_idx_type> (permB(i));
-	      if (checked(bidx) || bidx < 0 ||
-		  bidx >= n || D_NINT (bidx) != bidx)
-		{
-		  (*current_liboctave_error_handler) 
-		    ("eigs: permB vector invalid");
-		  return -1;
-		}
-	    }
-	}
+        {
+          Array<bool> checked(n,false);
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              octave_idx_type bidx = 
+                static_cast<octave_idx_type> (permB(i));
+              if (checked(bidx) || bidx < 0 ||
+                  bidx >= n || D_NINT (bidx) != bidx)
+                {
+                  (*current_liboctave_error_handler) 
+                    ("eigs: permB vector invalid");
+                  return -1;
+                }
+            }
+        }
     }
 
   if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" && 
       typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
       typ != "SI")
     {
       (*current_liboctave_error_handler) 
-	("eigs: unrecognized sigma value");
+        ("eigs: unrecognized sigma value");
       return -1;
     }
   
   if (typ == "LA" || typ == "SA" || typ == "BE")
     {
       (*current_liboctave_error_handler) 
-	("eigs: invalid sigma value for complex problem");
+        ("eigs: invalid sigma value for complex problem");
       return -1;
     }
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
-	{
-	  bt = b;
-	  b = b.hermitian();
-	  if (permB.length() == 0)
-	    {
-	      permB = ColumnVector(n);
-	      for (octave_idx_type i = 0; i < n; i++)
-		permB(i) = i;
-	    }
-	}
+        {
+          bt = b;
+          b = b.hermitian();
+          if (permB.length() == 0)
+            {
+              permB = ColumnVector(n);
+              for (octave_idx_type i = 0; i < n; i++)
+                permB(i) = i;
+            }
+        }
       else
-	{
-	  if (! make_cholb(b, bt, permB))
-	    {
-	      (*current_liboctave_error_handler) 
-		("eigs: The matrix B is not positive definite");
-	      return -1;
-	    }
-	}
+        {
+          if (! make_cholb(b, bt, permB))
+            {
+              (*current_liboctave_error_handler) 
+                ("eigs: The matrix B is not positive definite");
+              return -1;
+            }
+        }
     }
 
   Array<octave_idx_type> ip (11);
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
@@ -2864,85 +2864,85 @@ EigsComplexNonSymmetricMatrix (const M& 
   // ip(7) to ip(10) return values
  
   Array<octave_idx_type> iptr (14);
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (3 * p + 5);
-	      
+              
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do 
     {
       F77_FUNC (znaupd, ZNAUPD) 
-	(ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-	 F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
-	 k, tol, presid, p, v, n, iparam,
-	 ipntr, workd, workl, lwork, rwork, info
-	 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+        (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
+         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         k, tol, presid, p, v, n, iparam,
+         ipntr, workd, workl, lwork, rwork, info
+         F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: unrecoverable exception encountered in znaupd");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: unrecoverable exception encountered in znaupd");
+          return -1;
+        }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
-	{
-	  if (iter++)
-	    {
-	      os << "Iteration " << iter - 1 << 
-		": a few Ritz values of the " << p << "-by-" <<
-		p << " matrix\n";
-	      for (int i = 0 ; i < k; i++)
-		os << "    " << workl[iptr(5)+i-1] << "\n";
-	    }
-			  
-	  // This is a kludge, as ARPACK doesn't give its
-	  // iteration pointer. But as workl[iptr(5)-1] is
-	  // an output value updated at each iteration, setting
-	  // a value in this array to NaN and testing for it
-	  // is a way of obtaining the iteration counter.
-	  if (ido != 99)
-	    workl[iptr(5)-1] = octave_NaN; 
-	}
+        {
+          if (iter++)
+            {
+              os << "Iteration " << iter - 1 << 
+                ": a few Ritz values of the " << p << "-by-" <<
+                p << " matrix\n";
+              for (int i = 0 ; i < k; i++)
+                os << "    " << workl[iptr(5)+i-1] << "\n";
+            }
+                          
+          // This is a kludge, as ARPACK doesn't give its
+          // iteration pointer. But as workl[iptr(5)-1] is
+          // an output value updated at each iteration, setting
+          // a value in this array to NaN and testing for it
+          // is a way of obtaining the iteration counter.
+          if (ido != 99)
+            workl[iptr(5)-1] = octave_NaN; 
+        }
 
       if (ido == -1 || ido == 1 || ido == 2)
-	{
-	  if (have_b)
-	    {
-	      ComplexMatrix mtmp (n,1);
-	      for (octave_idx_type i = 0; i < n; i++)
-		mtmp(i,0) = workd[i + iptr(0) - 1];
-	      mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
-	      for (octave_idx_type i = 0; i < n; i++)
-		workd[i+iptr(1)-1] = mtmp(i,0);
-
-	    }
-	  else if (!vector_product (m, workd + iptr(0) - 1, 
-				    workd + iptr(1) - 1))
-	    break;
-	}
+        {
+          if (have_b)
+            {
+              ComplexMatrix mtmp (n,1);
+              for (octave_idx_type i = 0; i < n; i++)
+                mtmp(i,0) = workd[i + iptr(0) - 1];
+              mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
+              for (octave_idx_type i = 0; i < n; i++)
+                workd[i+iptr(1)-1] = mtmp(i,0);
+
+            }
+          else if (!vector_product (m, workd + iptr(0) - 1, 
+                                    workd + iptr(1) - 1))
+            break;
+        }
       else
-	{
-	  if (info < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("eigs: error %d in znaupd", info);
-	      return -1;
-	    }
-	  break;
-	}
+        {
+          if (info < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("eigs: error %d in znaupd", info);
+              return -1;
+            }
+          break;
+        }
     } 
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
@@ -2966,172 +2966,172 @@ EigsComplexNonSymmetricMatrix (const M& 
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, rwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler) 
-	("eigs: unrecoverable exception encountered in zneupd");
+        ("eigs: unrecoverable exception encountered in zneupd");
       return -1;
     }
 
   if (info2 == 0)
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
-	{
-	  Complex ctmp = d[i];
-	  d[i] = d[k - i - 1];
-	  d[k - i - 1] = ctmp;
-	}
+        {
+          Complex ctmp = d[i];
+          d[i] = d[k - i - 1];
+          d[k - i - 1] = ctmp;
+        }
       eig_val.resize(k);
 
       if (rvec)
-	{
-	  OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
-
-	  for (octave_idx_type i = 0; i < k2; i++)
-	    {
-	      octave_idx_type off1 = i * n;
-	      octave_idx_type off2 = (k - i - 1) * n;
-
-	      if (off1 == off2)
-		continue;
-
-	      for (octave_idx_type j = 0; j < n; j++)
-		ctmp[j] = z[off1 + j];
-
-	      for (octave_idx_type j = 0; j < n; j++)
-		z[off1 + j] = z[off2 + j];
-
-	      for (octave_idx_type j = 0; j < n; j++)
-		z[off2 + j] = ctmp[j];
-	    }
-
-	  if (note3)
-	    eig_vec = ltsolve(b, permB, eig_vec);
-	}
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
+
+          for (octave_idx_type i = 0; i < k2; i++)
+            {
+              octave_idx_type off1 = i * n;
+              octave_idx_type off2 = (k - i - 1) * n;
+
+              if (off1 == off2)
+                continue;
+
+              for (octave_idx_type j = 0; j < n; j++)
+                ctmp[j] = z[off1 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off1 + j] = z[off2 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off2 + j] = ctmp[j];
+            }
+
+          if (note3)
+            eig_vec = ltsolve(b, permB, eig_vec);
+        }
     }
   else
     {
       (*current_liboctave_error_handler) 
-	("eigs: error %d in zneupd", info2);
+        ("eigs: error %d in zneupd", info2);
       return -1;
     }
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsComplexNonSymmetricMatrixShift (const M& m, Complex sigma,
-				    octave_idx_type k, octave_idx_type p, 
-				    octave_idx_type &info, 
-				    ComplexMatrix &eig_vec, 
-				    ComplexColumnVector &eig_val, const M& _b,
-				    ColumnVector &permB, 
-				    ComplexColumnVector &cresid, 
-				    std::ostream& os, double tol, int rvec, 
-				    bool cholB, int disp, int maxit)
+                                    octave_idx_type k, octave_idx_type p, 
+                                    octave_idx_type &info, 
+                                    ComplexMatrix &eig_vec, 
+                                    ComplexColumnVector &eig_val, const M& _b,
+                                    ColumnVector &permB, 
+                                    ComplexColumnVector &cresid, 
+                                    std::ostream& os, double tol, int rvec, 
+                                    bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
   bool have_b = ! b.is_empty();
   std::string typ = "LM";
 
   if (m.rows() != m.cols())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
   if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
     {
       (*current_liboctave_error_handler) 
-	("eigs: B must be square and the same size as A");
+        ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsComplexNonSymmetricMatrix (m, "SM", k, p, info, eig_vec,
-  //					  eig_val, _b, permB, cresid, os, tol,
-  //					  rvec, cholB, disp, maxit);
+  //                                      eig_val, _b, permB, cresid, os, tol,
+  //                                      rvec, cholB, disp, maxit);
 
   if (cresid.is_empty())
     {
       std::string rand_dist = octave_rand::distribution();
       octave_rand::distribution("uniform");
       Array<double> rr (octave_rand::vector(n));
       Array<double> ri (octave_rand::vector(n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
-	cresid(i) = Complex(rr(i),ri(i));
+        cresid(i) = Complex(rr(i),ri(i));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
-	("eigs: n must be at least 3");
+        ("eigs: n must be at least 3");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
-	p = 20;
+        p = 20;
       
       if (p > n - 1)
-	p = n - 1 ;
+        p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler) 
-	("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-	     "      Use 'eig(full(A))' instead");
+        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+             "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler) 
-	("eigs: opts.p must be greater than k and less than n");
+        ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
   if (have_b && cholB && permB.length() != 0) 
     {
       // Check that we really have a permutation vector
       if (permB.length() != n)
-	{
-	  (*current_liboctave_error_handler) ("eigs: permB vector invalid");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+          return -1;
+        }
       else
-	{
-	  Array<bool> checked(n,false);
-	  for (octave_idx_type i = 0; i < n; i++)
-	    {
-	      octave_idx_type bidx = 
-		static_cast<octave_idx_type> (permB(i));
-	      if (checked(bidx) || bidx < 0 ||
-		  bidx >= n || D_NINT (bidx) != bidx)
-		{
-		  (*current_liboctave_error_handler) 
-		    ("eigs: permB vector invalid");
-		  return -1;
-		}
-	    }
-	}
+        {
+          Array<bool> checked(n,false);
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              octave_idx_type bidx = 
+                static_cast<octave_idx_type> (permB(i));
+              if (checked(bidx) || bidx < 0 ||
+                  bidx >= n || D_NINT (bidx) != bidx)
+                {
+                  (*current_liboctave_error_handler) 
+                    ("eigs: permB vector invalid");
+                  return -1;
+                }
+            }
+        }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
   Array<octave_idx_type> ip (11);
   octave_idx_type *iparam = ip.fortran_vec ();
@@ -3158,131 +3158,131 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
 
   if (! LuAminusSigmaB(m, b, cholB, permB, sigma, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = p * (3 * p + 5);
-	      
+              
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do 
     {
       F77_FUNC (znaupd, ZNAUPD) 
-	(ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-	 F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
-	 k, tol, presid, p, v, n, iparam,
-	 ipntr, workd, workl, lwork, rwork, info
-	 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+        (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
+         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         k, tol, presid, p, v, n, iparam,
+         ipntr, workd, workl, lwork, rwork, info
+         F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: unrecoverable exception encountered in znaupd");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: unrecoverable exception encountered in znaupd");
+          return -1;
+        }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
-	{
-	  if (iter++)
-	    {
-	      os << "Iteration " << iter - 1 << 
-		": a few Ritz values of the " << p << "-by-" <<
-		p << " matrix\n";
-	      for (int i = 0 ; i < k; i++)
-		os << "    " << workl[iptr(5)+i-1] << "\n";
-	    }
-			  
-	  // This is a kludge, as ARPACK doesn't give its
-	  // iteration pointer. But as workl[iptr(5)-1] is
-	  // an output value updated at each iteration, setting
-	  // a value in this array to NaN and testing for it
-	  // is a way of obtaining the iteration counter.
-	  if (ido != 99)
-	    workl[iptr(5)-1] = octave_NaN; 
-	}
+        {
+          if (iter++)
+            {
+              os << "Iteration " << iter - 1 << 
+                ": a few Ritz values of the " << p << "-by-" <<
+                p << " matrix\n";
+              for (int i = 0 ; i < k; i++)
+                os << "    " << workl[iptr(5)+i-1] << "\n";
+            }
+                          
+          // This is a kludge, as ARPACK doesn't give its
+          // iteration pointer. But as workl[iptr(5)-1] is
+          // an output value updated at each iteration, setting
+          // a value in this array to NaN and testing for it
+          // is a way of obtaining the iteration counter.
+          if (ido != 99)
+            workl[iptr(5)-1] = octave_NaN; 
+        }
 
       if (ido == -1 || ido == 1 || ido == 2)
-	{
-	  if (have_b)
-	    {
-	      if (ido == -1)
-		{
-		  OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
-
-		  vector_product (m, workd+iptr(0)-1, ctmp);
-
-		  ComplexMatrix tmp(n, 1);
-
-		  for (octave_idx_type i = 0; i < n; i++)
-		    tmp(i,0) = ctmp[P[i]];
-				  
-		  lusolve (L, U, tmp);
-
-		  Complex *ip2 = workd+iptr(1)-1;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    ip2[Q[i]] = tmp(i,0);
-		}
-	      else if (ido == 2)
-		vector_product (b, workd + iptr(0) - 1, workd + iptr(1) - 1);
-	      else
-		{
-		  Complex *ip2 = workd+iptr(2)-1;
-		  ComplexMatrix tmp(n, 1);
-
-		  for (octave_idx_type i = 0; i < n; i++)
-		    tmp(i,0) = ip2[P[i]];
-				  
-		  lusolve (L, U, tmp);
-
-		  ip2 = workd+iptr(1)-1;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    ip2[Q[i]] = tmp(i,0);
-		}
-	    }
-	  else
-	    {
-	      if (ido == 2)
-		{
-		  for (octave_idx_type i = 0; i < n; i++)
-		    workd[iptr(0) + i - 1] =
-		      workd[iptr(1) + i - 1];
-		}
-	      else
-		{
-		  Complex *ip2 = workd+iptr(0)-1;
-		  ComplexMatrix tmp(n, 1);
-
-		  for (octave_idx_type i = 0; i < n; i++)
-		    tmp(i,0) = ip2[P[i]];
-				  
-		  lusolve (L, U, tmp);
-
-		  ip2 = workd+iptr(1)-1;
-		  for (octave_idx_type i = 0; i < n; i++)
-		    ip2[Q[i]] = tmp(i,0);
-		}
-	    }
-	}
+        {
+          if (have_b)
+            {
+              if (ido == -1)
+                {
+                  OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
+
+                  vector_product (m, workd+iptr(0)-1, ctmp);
+
+                  ComplexMatrix tmp(n, 1);
+
+                  for (octave_idx_type i = 0; i < n; i++)
+                    tmp(i,0) = ctmp[P[i]];
+                                  
+                  lusolve (L, U, tmp);
+
+                  Complex *ip2 = workd+iptr(1)-1;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    ip2[Q[i]] = tmp(i,0);
+                }
+              else if (ido == 2)
+                vector_product (b, workd + iptr(0) - 1, workd + iptr(1) - 1);
+              else
+                {
+                  Complex *ip2 = workd+iptr(2)-1;
+                  ComplexMatrix tmp(n, 1);
+
+                  for (octave_idx_type i = 0; i < n; i++)
+                    tmp(i,0) = ip2[P[i]];
+                                  
+                  lusolve (L, U, tmp);
+
+                  ip2 = workd+iptr(1)-1;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    ip2[Q[i]] = tmp(i,0);
+                }
+            }
+          else
+            {
+              if (ido == 2)
+                {
+                  for (octave_idx_type i = 0; i < n; i++)
+                    workd[iptr(0) + i - 1] =
+                      workd[iptr(1) + i - 1];
+                }
+              else
+                {
+                  Complex *ip2 = workd+iptr(0)-1;
+                  ComplexMatrix tmp(n, 1);
+
+                  for (octave_idx_type i = 0; i < n; i++)
+                    tmp(i,0) = ip2[P[i]];
+                                  
+                  lusolve (L, U, tmp);
+
+                  ip2 = workd+iptr(1)-1;
+                  for (octave_idx_type i = 0; i < n; i++)
+                    ip2[Q[i]] = tmp(i,0);
+                }
+            }
+        }
       else
-	{
-	  if (info < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("eigs: error %d in dsaupd", info);
-	      return -1;
-	    }
-	  break;
-	}
+        {
+          if (info < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("eigs: error %d in dsaupd", info);
+              return -1;
+            }
+          break;
+        }
     } 
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
@@ -3306,146 +3306,146 @@ EigsComplexNonSymmetricMatrixShift (cons
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, rwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler) 
-	("eigs: unrecoverable exception encountered in zneupd");
+        ("eigs: unrecoverable exception encountered in zneupd");
       return -1;
     }
 
   if (info2 == 0)
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
-	{
-	  Complex ctmp = d[i];
-	  d[i] = d[k - i - 1];
-	  d[k - i - 1] = ctmp;
-	}
+        {
+          Complex ctmp = d[i];
+          d[i] = d[k - i - 1];
+          d[k - i - 1] = ctmp;
+        }
       eig_val.resize(k);
 
       if (rvec)
-	{
-	  OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
-
-	  for (octave_idx_type i = 0; i < k2; i++)
-	    {
-	      octave_idx_type off1 = i * n;
-	      octave_idx_type off2 = (k - i - 1) * n;
-
-	      if (off1 == off2)
-		continue;
-
-	      for (octave_idx_type j = 0; j < n; j++)
-		ctmp[j] = z[off1 + j];
-
-	      for (octave_idx_type j = 0; j < n; j++)
-		z[off1 + j] = z[off2 + j];
-
-	      for (octave_idx_type j = 0; j < n; j++)
-		z[off2 + j] = ctmp[j];
-	    }
-	}
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
+
+          for (octave_idx_type i = 0; i < k2; i++)
+            {
+              octave_idx_type off1 = i * n;
+              octave_idx_type off2 = (k - i - 1) * n;
+
+              if (off1 == off2)
+                continue;
+
+              for (octave_idx_type j = 0; j < n; j++)
+                ctmp[j] = z[off1 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off1 + j] = z[off2 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off2 + j] = ctmp[j];
+            }
+        }
     }
   else
     {
       (*current_liboctave_error_handler) 
-	("eigs: error %d in zneupd", info2);
+        ("eigs: error %d in zneupd", info2);
       return -1;
     }
 
   return ip(4);
 }
 
 octave_idx_type
 EigsComplexNonSymmetricFunc (EigsComplexFunc fun, octave_idx_type n,
-			     const std::string &_typ, Complex sigma,
-			     octave_idx_type k, octave_idx_type p, 
-			     octave_idx_type &info, ComplexMatrix &eig_vec, 
-			     ComplexColumnVector &eig_val, 
-			     ComplexColumnVector &cresid, std::ostream& os, 
-			     double tol, int rvec, bool /* cholB */,
-			     int disp, int maxit)
+                             const std::string &_typ, Complex sigma,
+                             octave_idx_type k, octave_idx_type p, 
+                             octave_idx_type &info, ComplexMatrix &eig_vec, 
+                             ComplexColumnVector &eig_val, 
+                             ComplexColumnVector &cresid, std::ostream& os, 
+                             double tol, int rvec, bool /* cholB */,
+                             int disp, int maxit)
 {
   std::string typ (_typ);
   bool have_sigma = (std::abs(sigma) ? true : false);
   char bmat = 'I';
   octave_idx_type mode = 1;
   int err = 0;
 
   if (cresid.is_empty())
     {
       std::string rand_dist = octave_rand::distribution();
       octave_rand::distribution("uniform");
       Array<double> rr (octave_rand::vector(n));
       Array<double> ri (octave_rand::vector(n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
-	cresid(i) = Complex(rr(i),ri(i));
+        cresid(i) = Complex(rr(i),ri(i));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
-	("eigs: n must be at least 3");
+        ("eigs: n must be at least 3");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
-	p = 20;
+        p = 20;
       
       if (p > n - 1)
-	p = n - 1 ;
+        p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
-	("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-	     "      Use 'eig(full(A))' instead");
+        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+             "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
-	("eigs: opts.p must be greater than k and less than n");
+        ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
   if (! have_sigma)
     {
       if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" && 
-	  typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
-	  typ != "SI")
-	(*current_liboctave_error_handler) 
-	  ("eigs: unrecognized sigma value");
+          typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
+          typ != "SI")
+        (*current_liboctave_error_handler) 
+          ("eigs: unrecognized sigma value");
 
       if (typ == "LA" || typ == "SA" || typ == "BE")
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: invalid sigma value for complex problem");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: invalid sigma value for complex problem");
+          return -1;
+        }
 
       if (typ == "SM")
-	{
-	  typ = "LM";
-	  sigma = 0.;
-	  mode = 3;
-	}
+        {
+          typ = "LM";
+          sigma = 0.;
+          mode = 3;
+        }
     }
   else if (! std::abs (sigma))
     typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
     }
@@ -3467,86 +3467,86 @@ EigsComplexNonSymmetricFunc (EigsComplex
   // ip(7) to ip(10) return values
  
   Array<octave_idx_type> iptr (14);
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (3 * p + 5);
-	      
+              
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do 
     {
       F77_FUNC (znaupd, ZNAUPD) 
-	(ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-	 F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
-	 k, tol, presid, p, v, n, iparam,
-	 ipntr, workd, workl, lwork, rwork, info
-	 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+        (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
+         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         k, tol, presid, p, v, n, iparam,
+         ipntr, workd, workl, lwork, rwork, info
+         F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-	{
-	  (*current_liboctave_error_handler) 
-	    ("eigs: unrecoverable exception encountered in znaupd");
-	  return -1;
-	}
+        {
+          (*current_liboctave_error_handler) 
+            ("eigs: unrecoverable exception encountered in znaupd");
+          return -1;
+        }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
-	{
-	  if (iter++)
-	    {
-	      os << "Iteration " << iter - 1 << 
-		": a few Ritz values of the " << p << "-by-" <<
-		p << " matrix\n";
-	      for (int i = 0 ; i < k; i++)
-		os << "    " << workl[iptr(5)+i-1] << "\n";
-	    }
-			  
-	  // This is a kludge, as ARPACK doesn't give its
-	  // iteration pointer. But as workl[iptr(5)-1] is
-	  // an output value updated at each iteration, setting
-	  // a value in this array to NaN and testing for it
-	  // is a way of obtaining the iteration counter.
-	  if (ido != 99)
-	    workl[iptr(5)-1] = octave_NaN; 
-	}
+        {
+          if (iter++)
+            {
+              os << "Iteration " << iter - 1 << 
+                ": a few Ritz values of the " << p << "-by-" <<
+                p << " matrix\n";
+              for (int i = 0 ; i < k; i++)
+                os << "    " << workl[iptr(5)+i-1] << "\n";
+            }
+                          
+          // This is a kludge, as ARPACK doesn't give its
+          // iteration pointer. But as workl[iptr(5)-1] is
+          // an output value updated at each iteration, setting
+          // a value in this array to NaN and testing for it
+          // is a way of obtaining the iteration counter.
+          if (ido != 99)
+            workl[iptr(5)-1] = octave_NaN; 
+        }
 
       if (ido == -1 || ido == 1 || ido == 2)
-	{
-	  Complex *ip2 = workd + iptr(0) - 1;
-	  ComplexColumnVector x(n);
-
-	  for (octave_idx_type i = 0; i < n; i++)
-	    x(i) = *ip2++;
-
-	  ComplexColumnVector y = fun (x, err);
-
-	  if (err)
-	    return false;
-
-	  ip2 = workd + iptr(1) - 1;
-	  for (octave_idx_type i = 0; i < n; i++)
-	    *ip2++ = y(i);
-	}
+        {
+          Complex *ip2 = workd + iptr(0) - 1;
+          ComplexColumnVector x(n);
+
+          for (octave_idx_type i = 0; i < n; i++)
+            x(i) = *ip2++;
+
+          ComplexColumnVector y = fun (x, err);
+
+          if (err)
+            return false;
+
+          ip2 = workd + iptr(1) - 1;
+          for (octave_idx_type i = 0; i < n; i++)
+            *ip2++ = y(i);
+        }
       else
-	{
-	  if (info < 0)
-	    {
-	      (*current_liboctave_error_handler) 
-		("eigs: error %d in dsaupd", info);
-	      return -1;
-	    }
-	  break;
-	}
+        {
+          if (info < 0)
+            {
+              (*current_liboctave_error_handler) 
+                ("eigs: error %d in dsaupd", info);
+              return -1;
+            }
+          break;
+        }
     } 
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
@@ -3570,261 +3570,261 @@ EigsComplexNonSymmetricFunc (EigsComplex
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, rwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler) 
-	("eigs: unrecoverable exception encountered in zneupd");
+        ("eigs: unrecoverable exception encountered in zneupd");
       return -1;
     }
 
   if (info2 == 0)
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
-	{
-	  Complex ctmp = d[i];
-	  d[i] = d[k - i - 1];
-	  d[k - i - 1] = ctmp;
-	}
+        {
+          Complex ctmp = d[i];
+          d[i] = d[k - i - 1];
+          d[k - i - 1] = ctmp;
+        }
       eig_val.resize(k);
 
       if (rvec)
-	{
-	  OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
-
-	  for (octave_idx_type i = 0; i < k2; i++)
-	    {
-	      octave_idx_type off1 = i * n;
-	      octave_idx_type off2 = (k - i - 1) * n;
-
-	      if (off1 == off2)
-		continue;
-
-	      for (octave_idx_type j = 0; j < n; j++)
-		ctmp[j] = z[off1 + j];
-
-	      for (octave_idx_type j = 0; j < n; j++)
-		z[off1 + j] = z[off2 + j];
-
-	      for (octave_idx_type j = 0; j < n; j++)
-		z[off2 + j] = ctmp[j];
-	    }
-	}
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
+
+          for (octave_idx_type i = 0; i < k2; i++)
+            {
+              octave_idx_type off1 = i * n;
+              octave_idx_type off2 = (k - i - 1) * n;
+
+              if (off1 == off2)
+                continue;
+
+              for (octave_idx_type j = 0; j < n; j++)
+                ctmp[j] = z[off1 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off1 + j] = z[off2 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off2 + j] = ctmp[j];
+            }
+        }
     }
   else
     {
       (*current_liboctave_error_handler) 
-	("eigs: error %d in zneupd", info2);
+        ("eigs: error %d in zneupd", info2);
       return -1;
     }
 
   return ip(4);
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern octave_idx_type
 EigsRealSymmetricMatrix (const Matrix& m, const std::string typ, 
-			 octave_idx_type k, octave_idx_type p,
-			 octave_idx_type &info, Matrix &eig_vec,
-			 ColumnVector &eig_val, const Matrix& b,
-			 ColumnVector &permB, ColumnVector &resid, 
-			 std::ostream &os, double tol = DBL_EPSILON,
-			 int rvec = 0, bool cholB = 0, int disp = 0,
-			 int maxit = 300);
+                         octave_idx_type k, octave_idx_type p,
+                         octave_idx_type &info, Matrix &eig_vec,
+                         ColumnVector &eig_val, const Matrix& b,
+                         ColumnVector &permB, ColumnVector &resid, 
+                         std::ostream &os, double tol = DBL_EPSILON,
+                         int rvec = 0, bool cholB = 0, int disp = 0,
+                         int maxit = 300);
 
 extern octave_idx_type
 EigsRealSymmetricMatrix (const SparseMatrix& m, const std::string typ, 
-			 octave_idx_type k, octave_idx_type p,
-			 octave_idx_type &info, Matrix &eig_vec,
-			 ColumnVector &eig_val, const SparseMatrix& b,
-			 ColumnVector &permB, ColumnVector &resid, 
-			 std::ostream& os, double tol = DBL_EPSILON,
-			 int rvec = 0, bool cholB = 0, int disp = 0, 
-			 int maxit = 300);
+                         octave_idx_type k, octave_idx_type p,
+                         octave_idx_type &info, Matrix &eig_vec,
+                         ColumnVector &eig_val, const SparseMatrix& b,
+                         ColumnVector &permB, ColumnVector &resid, 
+                         std::ostream& os, double tol = DBL_EPSILON,
+                         int rvec = 0, bool cholB = 0, int disp = 0, 
+                         int maxit = 300);
 
 extern octave_idx_type
 EigsRealSymmetricMatrixShift (const Matrix& m, double sigma,
-			      octave_idx_type k, octave_idx_type p, 
-			      octave_idx_type &info, Matrix &eig_vec, 
-			      ColumnVector &eig_val, const Matrix& b,
-			      ColumnVector &permB, ColumnVector &resid, 
-			      std::ostream &os, double tol = DBL_EPSILON,
-			      int rvec = 0, bool cholB = 0, int disp = 0, 
-			      int maxit = 300);
+                              octave_idx_type k, octave_idx_type p, 
+                              octave_idx_type &info, Matrix &eig_vec, 
+                              ColumnVector &eig_val, const Matrix& b,
+                              ColumnVector &permB, ColumnVector &resid, 
+                              std::ostream &os, double tol = DBL_EPSILON,
+                              int rvec = 0, bool cholB = 0, int disp = 0, 
+                              int maxit = 300);
 
 extern octave_idx_type
 EigsRealSymmetricMatrixShift (const SparseMatrix& m, double sigma,
-			      octave_idx_type k, octave_idx_type p, 
-			      octave_idx_type &info, Matrix &eig_vec, 
-			      ColumnVector &eig_val, const SparseMatrix& b,
-			      ColumnVector &permB, ColumnVector &resid, 
-			      std::ostream &os, double tol = DBL_EPSILON,
-			      int rvec = 0, bool cholB = 0, int disp = 0, 
-			      int maxit = 300);
+                              octave_idx_type k, octave_idx_type p, 
+                              octave_idx_type &info, Matrix &eig_vec, 
+                              ColumnVector &eig_val, const SparseMatrix& b,
+                              ColumnVector &permB, ColumnVector &resid, 
+                              std::ostream &os, double tol = DBL_EPSILON,
+                              int rvec = 0, bool cholB = 0, int disp = 0, 
+                              int maxit = 300);
 
 extern octave_idx_type
 EigsRealSymmetricFunc (EigsFunc fun, octave_idx_type n,
-		       const std::string &typ, double sigma,
-		       octave_idx_type k, octave_idx_type p, 
-		       octave_idx_type &info,
-		       Matrix &eig_vec, ColumnVector &eig_val, 
-		       ColumnVector &resid, std::ostream &os,
-		       double tol = DBL_EPSILON, int rvec = 0,
-		       bool cholB = 0, int disp = 0, int maxit = 300);
+                       const std::string &typ, double sigma,
+                       octave_idx_type k, octave_idx_type p, 
+                       octave_idx_type &info,
+                       Matrix &eig_vec, ColumnVector &eig_val, 
+                       ColumnVector &resid, std::ostream &os,
+                       double tol = DBL_EPSILON, int rvec = 0,
+                       bool cholB = 0, int disp = 0, int maxit = 300);
 
 extern octave_idx_type
 EigsRealNonSymmetricMatrix (const Matrix& m, const std::string typ, 
-			    octave_idx_type k, octave_idx_type p,
-			    octave_idx_type &info, ComplexMatrix &eig_vec,
-			    ComplexColumnVector &eig_val, const Matrix& b,
-			    ColumnVector &permB, ColumnVector &resid, 
-			    std::ostream &os, double tol = DBL_EPSILON,
-			    int rvec = 0, bool cholB = 0, int disp = 0,
-			    int maxit = 300);
+                            octave_idx_type k, octave_idx_type p,
+                            octave_idx_type &info, ComplexMatrix &eig_vec,
+                            ComplexColumnVector &eig_val, const Matrix& b,
+                            ColumnVector &permB, ColumnVector &resid, 
+                            std::ostream &os, double tol = DBL_EPSILON,
+                            int rvec = 0, bool cholB = 0, int disp = 0,
+                            int maxit = 300);
 
 extern octave_idx_type
 EigsRealNonSymmetricMatrix (const SparseMatrix& m, const std::string typ, 
-			    octave_idx_type k, octave_idx_type p,
-			    octave_idx_type &info, ComplexMatrix &eig_vec,
-			    ComplexColumnVector &eig_val, 
-			    const SparseMatrix& b,
-			    ColumnVector &permB, ColumnVector &resid, 
-			    std::ostream &os, double tol = DBL_EPSILON,
-			    int rvec = 0, bool cholB = 0, int disp = 0,
-			    int maxit = 300);
+                            octave_idx_type k, octave_idx_type p,
+                            octave_idx_type &info, ComplexMatrix &eig_vec,
+                            ComplexColumnVector &eig_val, 
+                            const SparseMatrix& b,
+                            ColumnVector &permB, ColumnVector &resid, 
+                            std::ostream &os, double tol = DBL_EPSILON,
+                            int rvec = 0, bool cholB = 0, int disp = 0,
+                            int maxit = 300);
 
 extern octave_idx_type
 EigsRealNonSymmetricMatrixShift (const Matrix& m, double sigma,
-				 octave_idx_type k, octave_idx_type p, 
-				 octave_idx_type &info,
-				 ComplexMatrix &eig_vec, 
-				 ComplexColumnVector &eig_val, const Matrix& b,
-				 ColumnVector &permB, ColumnVector &resid, 
-				 std::ostream &os, double tol = DBL_EPSILON,
-				 int rvec = 0, bool cholB = 0, int disp = 0, 
-				 int maxit = 300);
+                                 octave_idx_type k, octave_idx_type p, 
+                                 octave_idx_type &info,
+                                 ComplexMatrix &eig_vec, 
+                                 ComplexColumnVector &eig_val, const Matrix& b,
+                                 ColumnVector &permB, ColumnVector &resid, 
+                                 std::ostream &os, double tol = DBL_EPSILON,
+                                 int rvec = 0, bool cholB = 0, int disp = 0, 
+                                 int maxit = 300);
 
 extern octave_idx_type
 EigsRealNonSymmetricMatrixShift (const SparseMatrix& m, double sigma,
-				 octave_idx_type k, octave_idx_type p, 
-				 octave_idx_type &info,
-				 ComplexMatrix &eig_vec, 
-				 ComplexColumnVector &eig_val, 
-				 const SparseMatrix& b,
-				 ColumnVector &permB, ColumnVector &resid, 
-				 std::ostream &os, double tol = DBL_EPSILON,
-				 int rvec = 0, bool cholB = 0, int disp = 0, 
-				 int maxit = 300);
+                                 octave_idx_type k, octave_idx_type p, 
+                                 octave_idx_type &info,
+                                 ComplexMatrix &eig_vec, 
+                                 ComplexColumnVector &eig_val, 
+                                 const SparseMatrix& b,
+                                 ColumnVector &permB, ColumnVector &resid, 
+                                 std::ostream &os, double tol = DBL_EPSILON,
+                                 int rvec = 0, bool cholB = 0, int disp = 0, 
+                                 int maxit = 300);
 
 extern octave_idx_type
 EigsRealNonSymmetricFunc (EigsFunc fun, octave_idx_type n,
-			  const std::string &_typ, double sigma,
-			  octave_idx_type k, octave_idx_type p, 
-			  octave_idx_type &info, ComplexMatrix &eig_vec, 
-			  ComplexColumnVector &eig_val, 
-			  ColumnVector &resid, std::ostream& os, 
-			  double tol = DBL_EPSILON, int rvec = 0,
-			  bool cholB = 0, int disp = 0, int maxit = 300);
+                          const std::string &_typ, double sigma,
+                          octave_idx_type k, octave_idx_type p, 
+                          octave_idx_type &info, ComplexMatrix &eig_vec, 
+                          ComplexColumnVector &eig_val, 
+                          ColumnVector &resid, std::ostream& os, 
+                          double tol = DBL_EPSILON, int rvec = 0,
+                          bool cholB = 0, int disp = 0, int maxit = 300);
 
 extern octave_idx_type
 EigsComplexNonSymmetricMatrix (const ComplexMatrix& m, const std::string typ, 
-			       octave_idx_type k, octave_idx_type p,
-			       octave_idx_type &info, ComplexMatrix &eig_vec,
-			       ComplexColumnVector &eig_val, 
-			       const ComplexMatrix& b, ColumnVector &permB, 
-			       ComplexColumnVector &resid, 
-			       std::ostream &os, double tol = DBL_EPSILON,
-			       int rvec = 0, bool cholB = 0, int disp = 0, 
-			       int maxit = 300);
+                               octave_idx_type k, octave_idx_type p,
+                               octave_idx_type &info, ComplexMatrix &eig_vec,
+                               ComplexColumnVector &eig_val, 
+                               const ComplexMatrix& b, ColumnVector &permB, 
+                               ComplexColumnVector &resid, 
+                               std::ostream &os, double tol = DBL_EPSILON,
+                               int rvec = 0, bool cholB = 0, int disp = 0, 
+                               int maxit = 300);
 
 extern octave_idx_type
 EigsComplexNonSymmetricMatrix (const SparseComplexMatrix& m, 
-			       const std::string typ, octave_idx_type k, 
-			       octave_idx_type p, octave_idx_type &info, 
-			       ComplexMatrix &eig_vec,
-			       ComplexColumnVector &eig_val, 
-			       const SparseComplexMatrix& b,
-			       ColumnVector &permB,
-			       ComplexColumnVector &resid, 
-			       std::ostream &os, double tol = DBL_EPSILON,
-			       int rvec = 0, bool cholB = 0, int disp = 0, 
-			       int maxit = 300);
+                               const std::string typ, octave_idx_type k, 
+                               octave_idx_type p, octave_idx_type &info, 
+                               ComplexMatrix &eig_vec,
+                               ComplexColumnVector &eig_val, 
+                               const SparseComplexMatrix& b,
+                               ColumnVector &permB,
+                               ComplexColumnVector &resid, 
+                               std::ostream &os, double tol = DBL_EPSILON,
+                               int rvec = 0, bool cholB = 0, int disp = 0, 
+                               int maxit = 300);
 
 extern octave_idx_type
 EigsComplexNonSymmetricMatrixShift (const ComplexMatrix& m, Complex sigma,
-				    octave_idx_type k, octave_idx_type p, 
-				    octave_idx_type &info, 
-				    ComplexMatrix &eig_vec, 
-				    ComplexColumnVector &eig_val,
-				    const ComplexMatrix& b,
-				    ColumnVector &permB,
-				    ComplexColumnVector &resid, 
-				    std::ostream &os, double tol = DBL_EPSILON,
-				    int rvec = 0, bool cholB = 0,
-				    int disp = 0, int maxit = 300);
+                                    octave_idx_type k, octave_idx_type p, 
+                                    octave_idx_type &info, 
+                                    ComplexMatrix &eig_vec, 
+                                    ComplexColumnVector &eig_val,
+                                    const ComplexMatrix& b,
+                                    ColumnVector &permB,
+                                    ComplexColumnVector &resid, 
+                                    std::ostream &os, double tol = DBL_EPSILON,
+                                    int rvec = 0, bool cholB = 0,
+                                    int disp = 0, int maxit = 300);
 
 extern octave_idx_type
 EigsComplexNonSymmetricMatrixShift (const SparseComplexMatrix& m,
-				    Complex sigma,
-				    octave_idx_type k, octave_idx_type p, 
-				    octave_idx_type &info, 
-				    ComplexMatrix &eig_vec, 
-				    ComplexColumnVector &eig_val, 
-				    const SparseComplexMatrix& b,
-				    ColumnVector &permB,
-				    ComplexColumnVector &resid, 
-				    std::ostream &os, double tol = DBL_EPSILON,
-				    int rvec = 0, bool cholB = 0,
-				    int disp = 0, int maxit = 300);
+                                    Complex sigma,
+                                    octave_idx_type k, octave_idx_type p, 
+                                    octave_idx_type &info, 
+                                    ComplexMatrix &eig_vec, 
+                                    ComplexColumnVector &eig_val, 
+                                    const SparseComplexMatrix& b,
+                                    ColumnVector &permB,
+                                    ComplexColumnVector &resid, 
+                                    std::ostream &os, double tol = DBL_EPSILON,
+                                    int rvec = 0, bool cholB = 0,
+                                    int disp = 0, int maxit = 300);
 
 extern octave_idx_type
 EigsComplexNonSymmetricFunc (EigsComplexFunc fun, octave_idx_type n,
-			     const std::string &_typ, Complex sigma,
-			     octave_idx_type k, octave_idx_type p, 
-			     octave_idx_type &info, ComplexMatrix &eig_vec, 
-			     ComplexColumnVector &eig_val, 
-			     ComplexColumnVector &resid, std::ostream& os, 
-			     double tol = DBL_EPSILON, int rvec = 0,
-			     bool cholB = 0, int disp = 0, int maxit = 300);
+                             const std::string &_typ, Complex sigma,
+                             octave_idx_type k, octave_idx_type p, 
+                             octave_idx_type &info, ComplexMatrix &eig_vec, 
+                             ComplexColumnVector &eig_val, 
+                             ComplexColumnVector &resid, std::ostream& os, 
+                             double tol = DBL_EPSILON, int rvec = 0,
+                             bool cholB = 0, int disp = 0, int maxit = 300);
 #endif
 
 #ifndef _MSC_VER
 template static octave_idx_type
 lusolve (const SparseMatrix&, const SparseMatrix&, Matrix&);
 
 template static octave_idx_type
 lusolve (const SparseComplexMatrix&, const SparseComplexMatrix&, 
-	 ComplexMatrix&);
+         ComplexMatrix&);
 
 template static octave_idx_type
 lusolve (const Matrix&, const Matrix&, Matrix&);
 
 template static octave_idx_type
 lusolve (const ComplexMatrix&, const ComplexMatrix&, ComplexMatrix&);
 
 template static ComplexMatrix
 ltsolve (const SparseComplexMatrix&, const ColumnVector&, 
-	 const ComplexMatrix&);
+         const ComplexMatrix&);
 
 template static Matrix
 ltsolve (const SparseMatrix&, const ColumnVector&, const Matrix&);
 
 template static ComplexMatrix
 ltsolve (const ComplexMatrix&, const ColumnVector&, const ComplexMatrix&);
 
 template static Matrix
 ltsolve (const Matrix&, const ColumnVector&, const Matrix&);
 
 template static ComplexMatrix
 utsolve (const SparseComplexMatrix&, const ColumnVector&,
-	 const ComplexMatrix&);
+         const ComplexMatrix&);
 
 template static Matrix
 utsolve (const SparseMatrix&, const ColumnVector&, const Matrix&);
 
 template static ComplexMatrix
 utsolve (const ComplexMatrix&, const ColumnVector&, const ComplexMatrix&);
 
 template static Matrix
diff --git a/liboctave/fCColVector.cc b/liboctave/fCColVector.cc
--- a/liboctave/fCColVector.cc
+++ b/liboctave/fCColVector.cc
@@ -37,20 +37,20 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgemv, CGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const FloatComplex&,
-			   const FloatComplex*, const octave_idx_type&, const FloatComplex*,
-			   const octave_idx_type&, const FloatComplex&, FloatComplex*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, const octave_idx_type&, const FloatComplex&,
+                           const FloatComplex*, const octave_idx_type&, const FloatComplex*,
+                           const octave_idx_type&, const FloatComplex&, FloatComplex*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL);
 }
 
 // FloatComplex Column Vector class
 
 FloatComplexColumnVector::FloatComplexColumnVector (const FloatColumnVector& a)
    : MArray<FloatComplex> (a.length ())
 {
   for (octave_idx_type i = 0; i < length (); i++)
@@ -85,17 +85,17 @@ FloatComplexColumnVector::insert (const 
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i) = a.elem (i);
+        xelem (r+i) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::insert (const FloatComplexColumnVector& a, octave_idx_type r)
 {
@@ -107,49 +107,49 @@ FloatComplexColumnVector::insert (const 
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i) = a.elem (i);
+        xelem (r+i) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::fill (float val)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::fill (const FloatComplex& val)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
 
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::fill (float val, octave_idx_type r1, octave_idx_type r2)
@@ -164,17 +164,17 @@ FloatComplexColumnVector::fill (float va
 
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
 
   if (r2 >= r1)
     {
       make_unique ();
 
       for (octave_idx_type i = r1; i <= r2; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::fill (const FloatComplex& val, octave_idx_type r1, octave_idx_type r2)
 {
@@ -188,17 +188,17 @@ FloatComplexColumnVector::fill (const Fl
 
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
 
   if (r2 >= r1)
     {
       make_unique ();
 
       for (octave_idx_type i = r1; i <= r2; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatComplexColumnVector
 FloatComplexColumnVector::stack (const FloatColumnVector& a) const
 {
@@ -461,18 +461,18 @@ FloatComplexColumnVector::min (void) con
     return 0.0;
 
   FloatComplex res = elem (0);
   float absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) < absres)
       {
-	res = elem (i);
-	absres = std::abs (res);
+        res = elem (i);
+        absres = std::abs (res);
       }
 
   return res;
 }
 
 FloatComplex
 FloatComplexColumnVector::max (void) const
 {
@@ -481,18 +481,18 @@ FloatComplexColumnVector::max (void) con
     return 0.0;
 
   FloatComplex res = elem (0);
   float absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) > absres)
       {
-	res = elem (i);
-	absres = std::abs (res);
+        res = elem (i);
+        absres = std::abs (res);
       }
 
   return res;
 }
 
 // i/o
 
 std::ostream&
diff --git a/liboctave/fCDiagMatrix.cc b/liboctave/fCDiagMatrix.cc
--- a/liboctave/fCDiagMatrix.cc
+++ b/liboctave/fCDiagMatrix.cc
@@ -245,17 +245,17 @@ FloatComplexDiagMatrix::abs (void) const
 
 FloatComplexDiagMatrix
 conj (const FloatComplexDiagMatrix& a)
 {
   FloatComplexDiagMatrix retval;
   octave_idx_type a_len = a.length ();
   if (a_len > 0)
     retval = FloatComplexDiagMatrix (mx_inline_conj_dup (a.data (), a_len),
-				a.rows (), a.cols ());
+                                a.rows (), a.cols ());
   return retval;
 }
 
 // resize is the destructive analog for this one
 
 FloatComplexMatrix
 FloatComplexDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
@@ -373,22 +373,22 @@ FloatComplexDiagMatrix::inverse (octave_
     }
 
   FloatComplexDiagMatrix retval (r, c);
 
   info = 0;
   for (octave_idx_type i = 0; i < length (); i++)
     {
       if (elem (i, i) == static_cast<float> (0.0))
-	{
-	  info = -1;
-	  return *this;
-	}
+        {
+          info = -1;
+          return *this;
+        }
       else
-	retval.elem (i, i) = static_cast<float> (1.0) / elem (i, i);
+        retval.elem (i, i) = static_cast<float> (1.0) / elem (i, i);
     }
 
   return retval;
 }
 
 FloatComplexDiagMatrix
 FloatComplexDiagMatrix::pseudo_inverse (void) const
 {
@@ -565,18 +565,18 @@ FloatComplexDiagMatrix::rcond (void) con
 std::ostream&
 operator << (std::ostream& os, const FloatComplexDiagMatrix& a)
 {
   FloatComplex ZERO (0.0);
 //  int field_width = os.precision () + 7;
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
-	{
-	  if (i == j)
-	    os << " " /* setw (field_width) */ << a.elem (i, i);
-	  else
-	    os << " " /* setw (field_width) */ << ZERO;
-	}
+        {
+          if (i == j)
+            os << " " /* setw (field_width) */ << a.elem (i, i);
+          else
+            os << " " /* setw (field_width) */ << ZERO;
+        }
       os << "\n";
     }
   return os;
 }
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -60,176 +60,176 @@ along with Octave; see the file COPYING.
 #include "oct-norm.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (xilaenv, XILAENV) (const octave_idx_type&, F77_CONST_CHAR_ARG_DECL,
-			       F77_CONST_CHAR_ARG_DECL,
-			       const octave_idx_type&, const octave_idx_type&,
-			       const octave_idx_type&, const octave_idx_type&,
-			       octave_idx_type&
-			       F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
+                               F77_CONST_CHAR_ARG_DECL,
+                               const octave_idx_type&, const octave_idx_type&,
+                               const octave_idx_type&, const octave_idx_type&,
+                               octave_idx_type&
+                               F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cgebal, CGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, FloatComplex*, const octave_idx_type&, octave_idx_type&,
-			     octave_idx_type&, float*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, FloatComplex*, const octave_idx_type&, octave_idx_type&,
+                             octave_idx_type&, float*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgebak, SGEBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, float*,
-			     const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, float*,
+                             const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cgemm, CGEMM) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			   const FloatComplex&, const FloatComplex*, const octave_idx_type&,
-			   const FloatComplex*, const octave_idx_type&, const FloatComplex&,
-			   FloatComplex*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+                           const FloatComplex&, const FloatComplex*, const octave_idx_type&,
+                           const FloatComplex*, const octave_idx_type&, const FloatComplex&,
+                           FloatComplex*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cgemv, CGEMV) (F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, const octave_idx_type&, const FloatComplex&,
                            const FloatComplex*, const octave_idx_type&, const FloatComplex*,
                            const octave_idx_type&, const FloatComplex&, FloatComplex*, const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xcdotu, XCDOTU) (const octave_idx_type&, const FloatComplex*, const octave_idx_type&,
-			     const FloatComplex*, const octave_idx_type&, FloatComplex&);
+                             const FloatComplex*, const octave_idx_type&, FloatComplex&);
 
   F77_RET_T
   F77_FUNC (xcdotc, XCDOTC) (const octave_idx_type&, const FloatComplex*, const octave_idx_type&,
-			     const FloatComplex*, const octave_idx_type&, FloatComplex&);
+                             const FloatComplex*, const octave_idx_type&, FloatComplex&);
 
   F77_RET_T
   F77_FUNC (csyrk, CSYRK) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, 
-			   const FloatComplex&, const FloatComplex*, const octave_idx_type&,
-			   const FloatComplex&, FloatComplex*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, const octave_idx_type&, 
+                           const FloatComplex&, const FloatComplex*, const octave_idx_type&,
+                           const FloatComplex&, FloatComplex*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cherk, CHERK) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, 
-			   const float&, const FloatComplex*, const octave_idx_type&,
-			   const float&, FloatComplex*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, const octave_idx_type&, 
+                           const float&, const FloatComplex*, const octave_idx_type&,
+                           const float&, FloatComplex*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cgetrf, CGETRF) (const octave_idx_type&, const octave_idx_type&, FloatComplex*, const octave_idx_type&,
-			     octave_idx_type*, octave_idx_type&);
+                             octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cgetrs, CGETRS) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, FloatComplex*, const octave_idx_type&,
-			     const octave_idx_type*, FloatComplex*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const octave_idx_type&, FloatComplex*, const octave_idx_type&,
+                             const octave_idx_type*, FloatComplex*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cgetri, CGETRI) (const octave_idx_type&, FloatComplex*, const octave_idx_type&, const octave_idx_type*,
-			     FloatComplex*, const octave_idx_type&, octave_idx_type&);
+                             FloatComplex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cgecon, CGECON) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, FloatComplex*, 
-			     const octave_idx_type&, const float&, float&, 
-			     FloatComplex*, float*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, FloatComplex*, 
+                             const octave_idx_type&, const float&, float&, 
+                             FloatComplex*, float*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cgelsy, CGELSY) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     FloatComplex*, const octave_idx_type&, FloatComplex*,
-			     const octave_idx_type&, octave_idx_type*, float&, octave_idx_type&,
-			     FloatComplex*, const octave_idx_type&, float*, octave_idx_type&);
+                             FloatComplex*, const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, octave_idx_type*, float&, octave_idx_type&,
+                             FloatComplex*, const octave_idx_type&, float*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cgelsd, CGELSD) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     FloatComplex*, const octave_idx_type&, FloatComplex*,
-			     const octave_idx_type&, float*, float&, octave_idx_type&,
-			     FloatComplex*, const octave_idx_type&, float*, 
-			     octave_idx_type*, octave_idx_type&);
+                             FloatComplex*, const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, float*, float&, octave_idx_type&,
+                             FloatComplex*, const octave_idx_type&, float*, 
+                             octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cpotrf, CPOTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     FloatComplex*, const octave_idx_type&, 
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             FloatComplex*, const octave_idx_type&, 
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cpocon, CPOCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     FloatComplex*, const octave_idx_type&, const float&,
-			     float&, FloatComplex*, float*,
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             FloatComplex*, const octave_idx_type&, const float&,
+                             float&, FloatComplex*, float*,
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cpotrs, CPOTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, const FloatComplex*, 
-			     const octave_idx_type&, FloatComplex*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const FloatComplex*, 
+                             const octave_idx_type&, FloatComplex*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ctrtri, CTRTRI) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
-			     const octave_idx_type&, const FloatComplex*, 
-			     const octave_idx_type&, octave_idx_type& 
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const FloatComplex*, 
+                             const octave_idx_type&, octave_idx_type& 
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ctrcon, CTRCON) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
-			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const FloatComplex*, const octave_idx_type&, float&,
-			     FloatComplex*, float*, octave_idx_type& 
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+                             const FloatComplex*, const octave_idx_type&, float&,
+                             FloatComplex*, float*, octave_idx_type& 
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ctrtrs, CTRTRS) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
-			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, const FloatComplex*, 
-			     const octave_idx_type&, FloatComplex*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+                             const octave_idx_type&, const FloatComplex*, 
+                             const octave_idx_type&, FloatComplex*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (clartg, CLARTG) (const FloatComplex&, const FloatComplex&,
-			     float&, FloatComplex&, FloatComplex&);
+                             float&, FloatComplex&, FloatComplex&);
 
   F77_RET_T
   F77_FUNC (ctrsyl, CTRSYL) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     const FloatComplex*, const octave_idx_type&,
-			     const FloatComplex*, const octave_idx_type&,
-			     const FloatComplex*, const octave_idx_type&, float&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+                             const FloatComplex*, const octave_idx_type&,
+                             const FloatComplex*, const octave_idx_type&,
+                             const FloatComplex*, const octave_idx_type&, float&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xclange, XCLANGE) (F77_CONST_CHAR_ARG_DECL,
-			       const octave_idx_type&, const octave_idx_type&, const FloatComplex*,
-			       const octave_idx_type&, float*, float&
-			       F77_CHAR_ARG_LEN_DECL);
+                               const octave_idx_type&, const octave_idx_type&, const FloatComplex*,
+                               const octave_idx_type&, float*, float&
+                               F77_CHAR_ARG_LEN_DECL);
 }
 
 static const FloatComplex FloatComplex_NaN_result (octave_Float_NaN, octave_Float_NaN);
 
 // FloatComplex Matrix class
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatMatrix& a)
   : MArray2<FloatComplex> (a.rows (), a.cols ())
@@ -326,19 +326,19 @@ bool
 FloatComplexMatrix::is_hermitian (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (is_square () && nr > 0)
     {
       for (octave_idx_type i = 0; i < nr; i++)
-	for (octave_idx_type j = i; j < nc; j++)
-	  if (elem (i, j) != conj (elem (j, i)))
-	    return false;
+        for (octave_idx_type j = i; j < nc; j++)
+          if (elem (i, j) != conj (elem (j, i)))
+            return false;
 
       return true;
     }
 
   return false;
 }
 
 // destructive insert/delete/reorder operations
@@ -355,18 +355,18 @@ FloatComplexMatrix::insert (const FloatM
       return *this;
     }
 
   if (a_nr >0 && a_nc > 0)
     {
       make_unique ();
 
       for (octave_idx_type j = 0; j < a_nc; j++)
-	for (octave_idx_type i = 0; i < a_nr; i++)
-	  xelem (r+i, c+j) = a.elem (i, j);
+        for (octave_idx_type i = 0; i < a_nr; i++)
+          xelem (r+i, c+j) = a.elem (i, j);
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatRowVector& a, octave_idx_type r, octave_idx_type c)
 {
@@ -378,17 +378,17 @@ FloatComplexMatrix::insert (const FloatR
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r, c+i) = a.elem (i);
+        xelem (r, c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatColumnVector& a, octave_idx_type r, octave_idx_type c)
 {
@@ -400,17 +400,17 @@ FloatComplexMatrix::insert (const FloatC
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i, c) = a.elem (i);
+        xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatDiagMatrix& a, octave_idx_type r, octave_idx_type c)
 {
@@ -427,17 +427,17 @@ FloatComplexMatrix::insert (const FloatD
 
   octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i, c+i) = a.elem (i, i);
+        xelem (r+i, c+i) = a.elem (i, i);
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatComplexMatrix& a, octave_idx_type r, octave_idx_type c)
 {
@@ -472,17 +472,17 @@ FloatComplexMatrix::insert (const FloatC
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i, c) = a.elem (i);
+        xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatComplexDiagMatrix& a, octave_idx_type r, octave_idx_type c)
 {
@@ -499,53 +499,53 @@ FloatComplexMatrix::insert (const FloatC
 
   octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i, c+i) = a.elem (i, i);
+        xelem (r+i, c+i) = a.elem (i, i);
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::fill (float val)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       make_unique ();
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  xelem (i, j) = val;
+        for (octave_idx_type i = 0; i < nr; i++)
+          xelem (i, j) = val;
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::fill (const FloatComplex& val)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       make_unique ();
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  xelem (i, j) = val;
+        for (octave_idx_type i = 0; i < nr; i++)
+          xelem (i, j) = val;
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::fill (float val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
 {
@@ -562,18 +562,18 @@ FloatComplexMatrix::fill (float val, oct
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (r2 >= r1 && c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type j = c1; j <= c2; j++)
-	for (octave_idx_type i = r1; i <= r2; i++)
-	  xelem (i, j) = val;
+        for (octave_idx_type i = r1; i <= r2; i++)
+          xelem (i, j) = val;
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::fill (const FloatComplex& val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
 {
@@ -590,18 +590,18 @@ FloatComplexMatrix::fill (const FloatCom
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (r2 >= r1 && c2 >=c1)
     {
       make_unique ();
 
       for (octave_idx_type j = c1; j <= c2; j++)
-	for (octave_idx_type i = r1; i <= r2; i++)
-	  xelem (i, j) = val;
+        for (octave_idx_type i = r1; i <= r2; i++)
+          xelem (i, j) = val;
     }
 
   return *this;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::append (const FloatMatrix& a) const
 {
@@ -749,17 +749,17 @@ FloatComplexMatrix::append (const FloatC
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -768,17 +768,17 @@ FloatComplexMatrix::stack (const FloatMa
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -787,17 +787,17 @@ FloatComplexMatrix::stack (const FloatRo
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + a.length (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -806,17 +806,17 @@ FloatComplexMatrix::stack (const FloatCo
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatDiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -825,17 +825,17 @@ FloatComplexMatrix::stack (const FloatDi
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatComplexMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -844,17 +844,17 @@ FloatComplexMatrix::stack (const FloatCo
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatComplexRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -863,17 +863,17 @@ FloatComplexMatrix::stack (const FloatCo
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatComplexColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + a.length (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -882,17 +882,17 @@ FloatComplexMatrix::stack (const FloatCo
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatComplexDiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return *this;
     }
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -965,17 +965,17 @@ FloatComplexMatrix::inverse (octave_idx_
 {
   float rcon;
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (octave_idx_type& info, float& rcon, int force,
-			int calc_cond) const
+                        int calc_cond) const
 {
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, force, calc_cond);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype) const
 {
@@ -988,17 +988,17 @@ FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info) const
 {
   float rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::tinverse (MatrixType &mattype, octave_idx_type& info,
-			 float& rcon, int force, int calc_cond) const
+                         float& rcon, int force, int calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -1006,56 +1006,56 @@ FloatComplexMatrix::tinverse (MatrixType
     {
       int typ = mattype.type ();
       char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
       char udiag = 'N';
       retval = *this;
       FloatComplex *tmp_data = retval.fortran_vec ();
 
       F77_XFCN (ctrtri, CTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
-				 F77_CONST_CHAR_ARG2 (&udiag, 1),
-				 nr, tmp_data, nr, info 
-				 F77_CHAR_ARG_LEN (1)
-				 F77_CHAR_ARG_LEN (1)));
+                                 F77_CONST_CHAR_ARG2 (&udiag, 1),
+                                 nr, tmp_data, nr, info 
+                                 F77_CHAR_ARG_LEN (1)
+                                 F77_CHAR_ARG_LEN (1)));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0) 
-	info = -1;
+        info = -1;
       else if (calc_cond) 
-	{
-	  octave_idx_type ztrcon_info = 0;
-	  char job = '1';
-
-	  OCTAVE_LOCAL_BUFFER (FloatComplex, cwork, 2*nr);
-	  OCTAVE_LOCAL_BUFFER (float, rwork, nr);
-
-	  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     F77_CONST_CHAR_ARG2 (&uplo, 1),
-				     F77_CONST_CHAR_ARG2 (&udiag, 1),
-				     nr, tmp_data, nr, rcon, 
-				     cwork, rwork, ztrcon_info 
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (ztrcon_info != 0) 
-	    info = -1;
-	}
+        {
+          octave_idx_type ztrcon_info = 0;
+          char job = '1';
+
+          OCTAVE_LOCAL_BUFFER (FloatComplex, cwork, 2*nr);
+          OCTAVE_LOCAL_BUFFER (float, rwork, nr);
+
+          F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&udiag, 1),
+                                     nr, tmp_data, nr, rcon, 
+                                     cwork, rwork, ztrcon_info 
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (ztrcon_info != 0) 
+            info = -1;
+        }
 
       if (info == -1 && ! force)
-	retval = *this; // Restore matrix contents.
+        retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
-			 float& rcon, int force, int calc_cond) const
+                         float& rcon, int force, int calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -1068,106 +1068,106 @@ FloatComplexMatrix::finverse (MatrixType
       FloatComplex *tmp_data = retval.fortran_vec ();
 
       Array<FloatComplex> z(1);
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
       F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt, 
-				 z.fortran_vec (), lwork, info));
+                                 z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real(z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
       z.resize (lwork);
       FloatComplex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm;
       if (calc_cond)
-	anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+        anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (cgetrf, CGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0) 
-	info = -1;
+        info = -1;
       else if (calc_cond) 
-	{
-	  // Now calculate the condition number for non-singular matrix.
-	  octave_idx_type zgecon_info = 0;
-	  char job = '1';
-	  Array<float> rz (2 * nc);
-	  float *prz = rz.fortran_vec ();
-	  F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nc, tmp_data, nr, anorm, 
-				     rcon, pz, prz, zgecon_info
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (zgecon_info != 0) 
-	    info = -1;
-	}
+        {
+          // Now calculate the condition number for non-singular matrix.
+          octave_idx_type zgecon_info = 0;
+          char job = '1';
+          Array<float> rz (2 * nc);
+          float *prz = rz.fortran_vec ();
+          F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nc, tmp_data, nr, anorm, 
+                                     rcon, pz, prz, zgecon_info
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (zgecon_info != 0) 
+            info = -1;
+        }
 
       if (info == -1 && ! force)
-	retval = *this;  // Restore contents.
+        retval = *this;  // Restore contents.
       else
-	{
-	  octave_idx_type zgetri_info = 0;
-
-	  F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
-				     pz, lwork, zgetri_info));
-
-	  if (zgetri_info != 0) 
-	    info = -1;
-	}
+        {
+          octave_idx_type zgetri_info = 0;
+
+          F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
+                                     pz, lwork, zgetri_info));
+
+          if (zgetri_info != 0) 
+            info = -1;
+        }
 
       if (info != 0)
-	mattype.mark_as_rectangular();
+        mattype.mark_as_rectangular();
     }
   
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
-			float& rcon, int force, int calc_cond) const
+                        float& rcon, int force, int calc_cond) const
 {
   int typ = mattype.type (false);
   FloatComplexMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
     ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
-	{
-	  FloatComplexCHOL chol (*this, info, calc_cond);
-	  if (info == 0)
-	    {
-	      if (calc_cond)
-		rcon = chol.rcond();
-	      else
-		rcon = 1.0;
-	      ret = chol.inverse ();
-	    }
-	  else
-	    mattype.mark_as_unsymmetric ();
-	}
+        {
+          FloatComplexCHOL chol (*this, info, calc_cond);
+          if (info == 0)
+            {
+              if (calc_cond)
+                rcon = chol.rcond();
+              else
+                rcon = 1.0;
+              ret = chol.inverse ();
+            }
+          else
+            mattype.mark_as_unsymmetric ();
+        }
 
       if (!mattype.is_hermitian ())
-	ret = finverse(mattype, info, rcon, force, calc_cond);
+        ret = finverse(mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
-	ret = FloatComplexMatrix (rows (), columns (), FloatComplex (octave_Float_Inf, 0.));
+        ret = FloatComplexMatrix (rows (), columns (), FloatComplex (octave_Float_Inf, 0.));
     }
 
   return ret;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::pseudo_inverse (float tol) const
 {
@@ -1183,19 +1183,19 @@ FloatComplexMatrix::pseudo_inverse (floa
 
   octave_idx_type r = sigma.length () - 1;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
-	tol = nr * sigma.elem (0) * DBL_EPSILON;
+        tol = nr * sigma.elem (0) * DBL_EPSILON;
       else
-	tol = nc * sigma.elem (0) * DBL_EPSILON;
+        tol = nc * sigma.elem (0) * DBL_EPSILON;
     }
 
   while (r >= 0 && sigma.elem (r) < tol)
     r--;
 
   if (r < 0)
     retval = FloatComplexMatrix (nc, nr, 0.0);
   else
@@ -1446,22 +1446,22 @@ FloatComplexMatrix::fourier2d (void) con
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
-	prow[i] = tmp_data[i*nr + j];
+        prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
-	tmp_data[i*nr + j] = prow[i];
+        tmp_data[i*nr + j] = prow[i];
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::ifourier2d (void) const
 {
@@ -1515,22 +1515,22 @@ FloatComplexMatrix::ifourier2d (void) co
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
-	prow[i] = tmp_data[i*nr + j];
+        prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
-	tmp_data[i*nr + j] = prow[i] / static_cast<float> (npts);
+        tmp_data[i*nr + j] = prow[i] / static_cast<float> (npts);
     }
 
   return retval;
 }
 
 #endif
 
 FloatComplexDET
@@ -1707,367 +1707,367 @@ FloatComplexMatrix::rcond (MatrixType &m
     (*current_liboctave_error_handler) ("matrix must be square");
   else if (nr == 0 || nc == 0)
     rcon = octave_Inf;
   else
     {
       int typ = mattype.type ();
 
       if (typ == MatrixType::Unknown)
-	typ = mattype.type (*this);
+        typ = mattype.type (*this);
 
       // Only calculate the condition number for LU/Cholesky
       if (typ == MatrixType::Upper)
-	{
-	  const FloatComplex *tmp_data = fortran_vec ();
-	  octave_idx_type info = 0;
-	  char norm = '1';
-	  char uplo = 'U';
-	  char dia = 'N';
-
-	  Array<FloatComplex> z (2 * nc);
-	  FloatComplex *pz = z.fortran_vec ();
-	  Array<float> rz (nc);
-	  float *prz = rz.fortran_vec ();
-
-	  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-				     F77_CONST_CHAR_ARG2 (&dia, 1), 
-				     nr, tmp_data, nr, rcon,
-				     pz, prz, info
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (info != 0) 
-	    rcon = 0;
-	}
+        {
+          const FloatComplex *tmp_data = fortran_vec ();
+          octave_idx_type info = 0;
+          char norm = '1';
+          char uplo = 'U';
+          char dia = 'N';
+
+          Array<FloatComplex> z (2 * nc);
+          FloatComplex *pz = z.fortran_vec ();
+          Array<float> rz (nc);
+          float *prz = rz.fortran_vec ();
+
+          F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                     nr, tmp_data, nr, rcon,
+                                     pz, prz, info
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (info != 0) 
+            rcon = 0;
+        }
       else if  (typ == MatrixType::Permuted_Upper)
-	(*current_liboctave_error_handler)
-	  ("permuted triangular matrix not implemented");
+        (*current_liboctave_error_handler)
+          ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
-	{
-	  const FloatComplex *tmp_data = fortran_vec ();
-	  octave_idx_type info = 0;
-	  char norm = '1';
-	  char uplo = 'L';
-	  char dia = 'N';
-
-	  Array<FloatComplex> z (2 * nc);
-	  FloatComplex *pz = z.fortran_vec ();
-	  Array<float> rz (nc);
-	  float *prz = rz.fortran_vec ();
-
-	  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-				     F77_CONST_CHAR_ARG2 (&dia, 1), 
-				     nr, tmp_data, nr, rcon,
-				     pz, prz, info
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (info != 0) 
-	    rcon = 0.0;
-	}
+        {
+          const FloatComplex *tmp_data = fortran_vec ();
+          octave_idx_type info = 0;
+          char norm = '1';
+          char uplo = 'L';
+          char dia = 'N';
+
+          Array<FloatComplex> z (2 * nc);
+          FloatComplex *pz = z.fortran_vec ();
+          Array<float> rz (nc);
+          float *prz = rz.fortran_vec ();
+
+          F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                     nr, tmp_data, nr, rcon,
+                                     pz, prz, info
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (info != 0) 
+            rcon = 0.0;
+        }
       else if (typ == MatrixType::Permuted_Lower)
-	(*current_liboctave_error_handler)
-	  ("permuted triangular matrix not implemented");
+        (*current_liboctave_error_handler)
+          ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
-	{
-	  float anorm = -1.0;
-	  FloatComplexMatrix atmp = *this;
-	  FloatComplex *tmp_data = atmp.fortran_vec ();
-
-	  if (typ == MatrixType::Hermitian)
-	    {
-	      octave_idx_type info = 0;
-	      char job = 'L';
-	      anorm = atmp.abs().sum().
-		row(static_cast<octave_idx_type>(0)).max();
-
-	      F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
-					 tmp_data, nr, info
-					 F77_CHAR_ARG_LEN (1)));
-
-	      if (info != 0) 
-		{
-		  rcon = 0.0;
-
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Full;
-		}
-	      else 
-		{
-		  Array<FloatComplex> z (2 * nc);
-		  FloatComplex *pz = z.fortran_vec ();
-		  Array<float> rz (nc);
-		  float *prz = rz.fortran_vec ();
-
-		  F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, tmp_data, nr, anorm,
-					     rcon, pz, prz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    rcon = 0.0;
-		}
-	    }
-
-
-	  if (typ == MatrixType::Full)
-	    {
-	      octave_idx_type info = 0;
-
-	      Array<octave_idx_type> ipvt (nr);
-	      octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	      if(anorm < 0.)
-		anorm = atmp.abs().sum().
-		  row(static_cast<octave_idx_type>(0)).max();
-
-	      Array<FloatComplex> z (2 * nc);
-	      FloatComplex *pz = z.fortran_vec ();
-	      Array<float> rz (2 * nc);
-	      float *prz = rz.fortran_vec ();
-
-	      F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-	      if (info != 0) 
-		{ 
-		  rcon = 0.0;
-		  mattype.mark_as_rectangular ();
-		} 
-	      else 
-		{
-		  char job = '1';
-		  F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nc, tmp_data, nr, anorm, 
-					     rcon, pz, prz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    rcon = 0.0;
-		}
-	    }
-	}
+        {
+          float anorm = -1.0;
+          FloatComplexMatrix atmp = *this;
+          FloatComplex *tmp_data = atmp.fortran_vec ();
+
+          if (typ == MatrixType::Hermitian)
+            {
+              octave_idx_type info = 0;
+              char job = 'L';
+              anorm = atmp.abs().sum().
+                row(static_cast<octave_idx_type>(0)).max();
+
+              F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+                                         tmp_data, nr, info
+                                         F77_CHAR_ARG_LEN (1)));
+
+              if (info != 0) 
+                {
+                  rcon = 0.0;
+
+                  mattype.mark_as_unsymmetric ();
+                  typ = MatrixType::Full;
+                }
+              else 
+                {
+                  Array<FloatComplex> z (2 * nc);
+                  FloatComplex *pz = z.fortran_vec ();
+                  Array<float> rz (nc);
+                  float *prz = rz.fortran_vec ();
+
+                  F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, tmp_data, nr, anorm,
+                                             rcon, pz, prz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    rcon = 0.0;
+                }
+            }
+
+
+          if (typ == MatrixType::Full)
+            {
+              octave_idx_type info = 0;
+
+              Array<octave_idx_type> ipvt (nr);
+              octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+              if(anorm < 0.)
+                anorm = atmp.abs().sum().
+                  row(static_cast<octave_idx_type>(0)).max();
+
+              Array<FloatComplex> z (2 * nc);
+              FloatComplex *pz = z.fortran_vec ();
+              Array<float> rz (2 * nc);
+              float *prz = rz.fortran_vec ();
+
+              F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+              if (info != 0) 
+                { 
+                  rcon = 0.0;
+                  mattype.mark_as_rectangular ();
+                } 
+              else 
+                {
+                  char job = '1';
+                  F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nc, tmp_data, nr, anorm, 
+                                             rcon, pz, prz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    rcon = 0.0;
+                }
+            }
+        }
       else
-	rcon = 0.0;
+        rcon = 0.0;
     }
 
   return rcon;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::utsolve (MatrixType &mattype, const FloatComplexMatrix& b, 
-			octave_idx_type& info, float& rcon, 
-			solve_singularity_handler sing_handler,
-			bool calc_cond, blas_trans_type transt) const
+                        octave_idx_type& info, float& rcon, 
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Upper)
-	{
-	  octave_idx_type b_nc = b.cols ();
-	  rcon = 1.;
-	  info = 0;
-
-	  if (typ == MatrixType::Permuted_Upper)
-	    {
-	      (*current_liboctave_error_handler)
-		("permuted triangular matrix not implemented");
-	    }
-	  else
-	    {
-	      const FloatComplex *tmp_data = fortran_vec ();
-
-	      if (calc_cond)
-		{
-		  char norm = '1';
-		  char uplo = 'U';
-		  char dia = 'N';
-
-		  Array<FloatComplex> z (2 * nc);
-		  FloatComplex *pz = z.fortran_vec ();
-		  Array<float> rz (nc);
-		  float *prz = rz.fortran_vec ();
-
-		  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcon,
-					     pz, prz, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile float rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  FloatComplex *result = retval.fortran_vec ();
-
-		  char uplo = 'U';
-		  char trans = get_blas_char (transt);
-		  char dia = 'N';
-
-		  F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&trans, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, b_nc, tmp_data, nr,
-					     result, nr, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	    }
-	}
+          typ == MatrixType::Upper)
+        {
+          octave_idx_type b_nc = b.cols ();
+          rcon = 1.;
+          info = 0;
+
+          if (typ == MatrixType::Permuted_Upper)
+            {
+              (*current_liboctave_error_handler)
+                ("permuted triangular matrix not implemented");
+            }
+          else
+            {
+              const FloatComplex *tmp_data = fortran_vec ();
+
+              if (calc_cond)
+                {
+                  char norm = '1';
+                  char uplo = 'U';
+                  char dia = 'N';
+
+                  Array<FloatComplex> z (2 * nc);
+                  FloatComplex *pz = z.fortran_vec ();
+                  Array<float> rz (nc);
+                  float *prz = rz.fortran_vec ();
+
+                  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, tmp_data, nr, rcon,
+                                             pz, prz, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile float rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  FloatComplex *result = retval.fortran_vec ();
+
+                  char uplo = 'U';
+                  char trans = get_blas_char (transt);
+                  char dia = 'N';
+
+                  F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, b_nc, tmp_data, nr,
+                                             result, nr, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::ltsolve (MatrixType &mattype, const FloatComplexMatrix& b, 
-			octave_idx_type& info, float& rcon, 
-			solve_singularity_handler sing_handler,
-			bool calc_cond, blas_trans_type transt) const
+                        octave_idx_type& info, float& rcon, 
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower ||
-	  typ == MatrixType::Lower)
-	{
-	  octave_idx_type b_nc = b.cols ();
-	  rcon = 1.;
-	  info = 0;
-
-	  if (typ == MatrixType::Permuted_Lower)
-	    {
-	      (*current_liboctave_error_handler)
-		("permuted triangular matrix not implemented");
-	    }
-	  else
-	    {
-	      const FloatComplex *tmp_data = fortran_vec ();
-
-	      if (calc_cond)
-		{
-		  char norm = '1';
-		  char uplo = 'L';
-		  char dia = 'N';
-
-		  Array<FloatComplex> z (2 * nc);
-		  FloatComplex *pz = z.fortran_vec ();
-		  Array<float> rz (nc);
-		  float *prz = rz.fortran_vec ();
-
-		  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcon,
-					     pz, prz, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile float rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  FloatComplex *result = retval.fortran_vec ();
-
-		  char uplo = 'L';
-		  char trans = get_blas_char (transt);
-		  char dia = 'N';
-
-		  F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&trans, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, b_nc, tmp_data, nr,
-					     result, nr, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	    }
-	}
+          typ == MatrixType::Lower)
+        {
+          octave_idx_type b_nc = b.cols ();
+          rcon = 1.;
+          info = 0;
+
+          if (typ == MatrixType::Permuted_Lower)
+            {
+              (*current_liboctave_error_handler)
+                ("permuted triangular matrix not implemented");
+            }
+          else
+            {
+              const FloatComplex *tmp_data = fortran_vec ();
+
+              if (calc_cond)
+                {
+                  char norm = '1';
+                  char uplo = 'L';
+                  char dia = 'N';
+
+                  Array<FloatComplex> z (2 * nc);
+                  FloatComplex *pz = z.fortran_vec ();
+                  Array<float> rz (nc);
+                  float *prz = rz.fortran_vec ();
+
+                  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, tmp_data, nr, rcon,
+                                             pz, prz, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile float rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  FloatComplex *result = retval.fortran_vec ();
+
+                  char uplo = 'L';
+                  char trans = get_blas_char (transt);
+                  char dia = 'N';
+
+                  F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, b_nc, tmp_data, nr,
+                                             result, nr, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::fsolve (MatrixType &mattype, const FloatComplexMatrix& b, 
-		       octave_idx_type& info, float& rcon,
-		       solve_singularity_handler sing_handler,
-		       bool calc_cond) const
+                       octave_idx_type& info, float& rcon,
+                       solve_singularity_handler sing_handler,
+                       bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
 
   if (nr != nc || nr != b.rows ())
@@ -2078,235 +2078,235 @@ FloatComplexMatrix::fsolve (MatrixType &
   else
     {
       volatile int typ = mattype.type ();
  
      // Calculate the norm of the matrix, for later use.
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
-	{
-	  info = 0;
-	  char job = 'L';
-	  FloatComplexMatrix atmp = *this;
-	  FloatComplex *tmp_data = atmp.fortran_vec ();
-	  anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
-
-	  F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
-				     tmp_data, nr, info
-				     F77_CHAR_ARG_LEN (1)));
-
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcon = 0.0;
-	  if (info != 0) 
-	    {
-	      info = -2;
-
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  Array<FloatComplex> z (2 * nc);
-		  FloatComplex *pz = z.fortran_vec ();
-		  Array<float> rz (nc);
-		  float *prz = rz.fortran_vec ();
-
-		  F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, tmp_data, nr, anorm,
-					     rcon, pz, prz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile float rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  FloatComplex *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  F77_XFCN (cpotrs, CPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, b_nc, tmp_data, nr,
-					     result, b.rows(), info
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	      else
-		{
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Full;
-		}
-	    }
-	}
+        {
+          info = 0;
+          char job = 'L';
+          FloatComplexMatrix atmp = *this;
+          FloatComplex *tmp_data = atmp.fortran_vec ();
+          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+
+          F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+                                     tmp_data, nr, info
+                                     F77_CHAR_ARG_LEN (1)));
+
+          // Throw-away extra info LAPACK gives so as to not change output.
+          rcon = 0.0;
+          if (info != 0) 
+            {
+              info = -2;
+
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+          else 
+            {
+              if (calc_cond)
+                {
+                  Array<FloatComplex> z (2 * nc);
+                  FloatComplex *pz = z.fortran_vec ();
+                  Array<float> rz (nc);
+                  float *prz = rz.fortran_vec ();
+
+                  F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, tmp_data, nr, anorm,
+                                             rcon, pz, prz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile float rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  FloatComplex *result = retval.fortran_vec ();
+
+                  octave_idx_type b_nc = b.cols ();
+
+                  F77_XFCN (cpotrs, CPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, b_nc, tmp_data, nr,
+                                             result, b.rows(), info
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+              else
+                {
+                  mattype.mark_as_unsymmetric ();
+                  typ = MatrixType::Full;
+                }
+            }
+        }
 
       if (typ == MatrixType::Full)
-	{
-	  info = 0;
-
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  FloatComplexMatrix atmp = *this;
-	  FloatComplex *tmp_data = atmp.fortran_vec ();
-
-	  Array<FloatComplex> z (2 * nc);
-	  FloatComplex *pz = z.fortran_vec ();
-	  Array<float> rz (2 * nc);
-	  float *prz = rz.fortran_vec ();
-
-	  // Calculate the norm of the matrix, for later use.
-	  if (anorm < 0.)
-	    anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
-
-	  F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcon = 0.0;
-	  if (info != 0) 
-	    { 
-	      info = -2;
-
-	      if (sing_handler)
-		sing_handler (rcon);
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	      mattype.mark_as_rectangular ();
-	    } 
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  // Now calculate the condition number for 
-		  // non-singular matrix.
-		  char job = '1';
-		  F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nc, tmp_data, nr, anorm, 
-					     rcon, pz, prz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile float rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  FloatComplex *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  char job = 'N';
-		  F77_XFCN (cgetrs, CGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, b_nc, tmp_data, nr,
-					     pipvt, result, b.rows(), info
-					     F77_CHAR_ARG_LEN (1))); 
-		}
-	      else
-		mattype.mark_as_rectangular ();		    
-	    }
-	}
+        {
+          info = 0;
+
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          FloatComplexMatrix atmp = *this;
+          FloatComplex *tmp_data = atmp.fortran_vec ();
+
+          Array<FloatComplex> z (2 * nc);
+          FloatComplex *pz = z.fortran_vec ();
+          Array<float> rz (2 * nc);
+          float *prz = rz.fortran_vec ();
+
+          // Calculate the norm of the matrix, for later use.
+          if (anorm < 0.)
+            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+
+          F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+          // Throw-away extra info LAPACK gives so as to not change output.
+          rcon = 0.0;
+          if (info != 0) 
+            { 
+              info = -2;
+
+              if (sing_handler)
+                sing_handler (rcon);
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+              mattype.mark_as_rectangular ();
+            } 
+          else 
+            {
+              if (calc_cond)
+                {
+                  // Now calculate the condition number for 
+                  // non-singular matrix.
+                  char job = '1';
+                  F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nc, tmp_data, nr, anorm, 
+                                             rcon, pz, prz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile float rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  FloatComplex *result = retval.fortran_vec ();
+
+                  octave_idx_type b_nc = b.cols ();
+
+                  char job = 'N';
+                  F77_XFCN (cgetrs, CGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, b_nc, tmp_data, nr,
+                                             pipvt, result, b.rows(), info
+                                             F77_CHAR_ARG_LEN (1))); 
+                }
+              else
+                mattype.mark_as_rectangular ();             
+            }
+        }
     }
   
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, 
-		      octave_idx_type& info) const
+                      octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-		      float& rcon) const
+                      float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info, 
-		      float& rcon, solve_singularity_handler sing_handler,
-		      bool singular_fallback, blas_trans_type transt) const
+                      float& rcon, solve_singularity_handler sing_handler,
+                      bool singular_fallback, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (b);
   return solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		      octave_idx_type& info) const
+                      octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		      octave_idx_type& info, float& rcon) const
+                      octave_idx_type& info, float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &mattype, const FloatComplexMatrix& b, 
-		      octave_idx_type& info, float& rcon,
-		      solve_singularity_handler sing_handler,
-		      bool singular_fallback, blas_trans_type transt) const
+                      octave_idx_type& info, float& rcon,
+                      solve_singularity_handler sing_handler,
+                      bool singular_fallback, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
@@ -2341,64 +2341,64 @@ FloatComplexMatrix::solve (MatrixType &t
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
-		      octave_idx_type& info) const
+                      octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
-		      octave_idx_type& info, float& rcon) const
+                      octave_idx_type& info, float& rcon) const
 {
   return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
-		      octave_idx_type& info, float& rcon,
-		      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      octave_idx_type& info, float& rcon,
+                      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   return solve (typ, FloatComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-		      octave_idx_type& info) const
+                      octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
-		      octave_idx_type& info, float& rcon) const
+                      octave_idx_type& info, float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
-		      octave_idx_type& info, float& rcon,
-		      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      octave_idx_type& info, float& rcon,
+                      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
 
   FloatComplexMatrix tmp (b);
   return solve (typ, tmp, info, rcon, sing_handler, transt).column(static_cast<octave_idx_type> (0));
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b) const
@@ -2418,17 +2418,17 @@ FloatComplexMatrix::solve (const FloatMa
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
-		      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (b);
   return solve (tmp, info, rcon, sing_handler, transt);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b) const
 {
@@ -2447,17 +2447,17 @@ FloatComplexMatrix::solve (const FloatCo
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
-		      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b) const
 {
@@ -2470,25 +2470,25 @@ FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info) const
 {
   float rcon;
   return solve (FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, 
-		      float& rcon) const
+                      float& rcon) const
 {
   return solve (FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, 
-		      float& rcon, 
-		      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      float& rcon, 
+                      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   return solve (FloatComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
@@ -2500,25 +2500,25 @@ FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info) const
 {
   float rcon;
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-		      float& rcon) const
+                      float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-		      float& rcon,
-		      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      float& rcon,
+                      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatMatrix& b) const
 {
@@ -2533,25 +2533,25 @@ FloatComplexMatrix::lssolve (const Float
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (FloatComplexMatrix (b), info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
-			octave_idx_type& rank) const
+                        octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (FloatComplexMatrix (b), info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
-			octave_idx_type& rank, float& rcon) const
+                        octave_idx_type& rank, float& rcon) const
 {
   return lssolve (FloatComplexMatrix (b), info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
@@ -2565,25 +2565,25 @@ FloatComplexMatrix::lssolve (const Float
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-			octave_idx_type& rank) const
+                        octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info, 
-			octave_idx_type& rank, float& rcon) const
+                        octave_idx_type& rank, float& rcon) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2594,130 +2594,130 @@ FloatComplexMatrix::lssolve (const Float
     retval = FloatComplexMatrix (n, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
-	{
-	  retval = FloatComplexMatrix (maxmn, nrhs);
-
-	  for (octave_idx_type j = 0; j < nrhs; j++)
-	    for (octave_idx_type i = 0; i < m; i++)
-	      retval.elem (i, j) = b.elem (i, j);
-	}
+        {
+          retval = FloatComplexMatrix (maxmn, nrhs);
+
+          for (octave_idx_type j = 0; j < nrhs; j++)
+            for (octave_idx_type i = 0; i < m; i++)
+              retval.elem (i, j) = b.elem (i, j);
+        }
       else
-	retval = b;
+        retval = b;
 
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
       FloatComplex *pretval = retval.fortran_vec ();
       Array<float> s (minmn);
       float *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
       Array<FloatComplex> work (1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("CGELSD", 6),
-				   F77_CONST_CHAR_ARG2 (" ", 1),
-				   0, 0, 0, 0, smlsiz
-				   F77_CHAR_ARG_LEN (6)
-				   F77_CHAR_ARG_LEN (1));
+                                   F77_CONST_CHAR_ARG2 (" ", 1),
+                                   0, 0, 0, 0, smlsiz
+                                   F77_CHAR_ARG_LEN (6)
+                                   F77_CHAR_ARG_LEN (1));
 
       octave_idx_type mnthr;
       F77_FUNC (xilaenv, XILAENV) (6, F77_CONST_CHAR_ARG2 ("CGELSD", 6),
-				   F77_CONST_CHAR_ARG2 (" ", 1),
-				   m, n, nrhs, -1, mnthr
-				   F77_CHAR_ARG_LEN (6)
-				   F77_CHAR_ARG_LEN (1));
+                                   F77_CONST_CHAR_ARG2 (" ", 1),
+                                   m, n, nrhs, -1, mnthr
+                                   F77_CHAR_ARG_LEN (6)
+                                   F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
 #if defined (HAVE_LOG2)
       float tmp = log2 (dminmn / dsmlsizp1);
 #else
       float tmp = log (dminmn / dsmlsizp1) / log (2.0);
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
-	nlvl = 0;
+        nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
-	+ 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
+        + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
-	lrwork = 1;
+        lrwork = 1;
       Array<float> rwork (lrwork);
       float *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
-	liwork = 1;
+        liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcon, rank, work.fortran_vec (),
-				 lwork, prwork, piwork, info));
+                                 ps, rcon, rank, work.fortran_vec (),
+                                 lwork, prwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for ZGELSD to operate
       // efficiently.
       if (n >= mnthr)
-	{
-	  octave_idx_type addend = m;
-
-	  if (2*m-4 > addend)
-	    addend = 2*m-4;
-
-	  if (nrhs > addend)
-	    addend = nrhs;
-
-	  if (n-3*m > addend)
-	    addend = n-3*m;
-
-	  const octave_idx_type lworkaround = 4*m + m*m + addend;
-
-	  if (std::real (work(0)) < lworkaround)
-	    work(0) = lworkaround;
-	}
+        {
+          octave_idx_type addend = m;
+
+          if (2*m-4 > addend)
+            addend = 2*m-4;
+
+          if (nrhs > addend)
+            addend = nrhs;
+
+          if (n-3*m > addend)
+            addend = n-3*m;
+
+          const octave_idx_type lworkaround = 4*m + m*m + addend;
+
+          if (std::real (work(0)) < lworkaround)
+            work(0) = lworkaround;
+        }
       else if (m >= n)
-	{
-	  octave_idx_type lworkaround = 2*m + m*nrhs;
-
-	  if (std::real (work(0)) < lworkaround)
-	    work(0) = lworkaround;
-	}
+        {
+          octave_idx_type lworkaround = 2*m + m*nrhs;
+
+          if (std::real (work(0)) < lworkaround)
+            work(0) = lworkaround;
+        }
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (lwork);
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcon, rank,
-				 work.fortran_vec (), lwork, 
-				 prwork, piwork, info));
+                                 maxmn, ps, rcon, rank,
+                                 work.fortran_vec (), lwork, 
+                                 prwork, piwork, info));
 
       if (rank < minmn)
-	(*current_liboctave_warning_handler) 
-	  ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
-	   m, n, rank, rcon);
+        (*current_liboctave_warning_handler) 
+          ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
+           m, n, rank, rcon);
 
       if (s.elem (0) == 0.0)
-	rcon = 0.0;
+        rcon = 0.0;
       else
-	rcon = s.elem (minmn - 1) / s.elem (0);
+        rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 FloatComplexColumnVector
@@ -2734,25 +2734,25 @@ FloatComplexMatrix::lssolve (const Float
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info, 
-			octave_idx_type& rank) const
+                        octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info, 
-			octave_idx_type& rank, float& rcon) const
+                        octave_idx_type& rank, float& rcon) const
 {
   return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
@@ -2766,26 +2766,26 @@ FloatComplexMatrix::lssolve (const Float
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank) const
+                        octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (b, info, rank, rcon);
 
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank, float& rcon) const
+                        octave_idx_type& rank, float& rcon) const
 {
   FloatComplexColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2796,99 +2796,99 @@ FloatComplexMatrix::lssolve (const Float
     retval = FloatComplexColumnVector (n, FloatComplex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
-	{
-	  retval = FloatComplexColumnVector (maxmn);
-
-	  for (octave_idx_type i = 0; i < m; i++)
-	    retval.elem (i) = b.elem (i);
-	}
+        {
+          retval = FloatComplexColumnVector (maxmn);
+
+          for (octave_idx_type i = 0; i < m; i++)
+            retval.elem (i) = b.elem (i);
+        }
       else
-	retval = b;
+        retval = b;
 
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
       FloatComplex *pretval = retval.fortran_vec ();
       Array<float> s (minmn);
       float *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
       Array<FloatComplex> work (1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("CGELSD", 6),
-				   F77_CONST_CHAR_ARG2 (" ", 1),
-				   0, 0, 0, 0, smlsiz
-				   F77_CHAR_ARG_LEN (6)
-				   F77_CHAR_ARG_LEN (1));
+                                   F77_CONST_CHAR_ARG2 (" ", 1),
+                                   0, 0, 0, 0, smlsiz
+                                   F77_CHAR_ARG_LEN (6)
+                                   F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
 #if defined (HAVE_LOG2)
       float tmp = log2 (dminmn / dsmlsizp1);
 #else
       float tmp = log (dminmn / dsmlsizp1) / log (2.0);
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
-	nlvl = 0;
+        nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
-	+ 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
+        + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
-	lrwork = 1;
+        lrwork = 1;
       Array<float> rwork (lrwork);
       float *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
-	liwork = 1;
+        liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcon, rank, work.fortran_vec (),
-				 lwork, prwork, piwork, info));
+                                 ps, rcon, rank, work.fortran_vec (),
+                                 lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (lwork);
       rwork.resize (static_cast<octave_idx_type> (rwork(0)));
       iwork.resize (iwork(0));
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcon, rank,
-				 work.fortran_vec (), lwork, 
-				 prwork, piwork, info));
+                                 maxmn, ps, rcon, rank,
+                                 work.fortran_vec (), lwork, 
+                                 prwork, piwork, info));
 
       if (rank < minmn)
-	{
-	  if (rank < minmn)
-	    (*current_liboctave_warning_handler) 
-	      ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
-	       m, n, rank, rcon);
-
-	  if (s.elem (0) == 0.0)
-	    rcon = 0.0;
-	  else
-	    rcon = s.elem (minmn - 1) / s.elem (0);
-
-	  retval.resize (n, nrhs);
-	}
+        {
+          if (rank < minmn)
+            (*current_liboctave_warning_handler) 
+              ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
+               m, n, rank, rcon);
+
+          if (s.elem (0) == 0.0)
+            rcon = 0.0;
+          else
+            rcon = s.elem (minmn - 1) / s.elem (0);
+
+          retval.resize (n, nrhs);
+        }
     }
 
   return retval;
 }
 
 // column vector by row vector -> matrix operations
 
 FloatComplexMatrix
@@ -2915,21 +2915,21 @@ operator * (const FloatComplexColumnVect
   if (len != 0)
     {
       octave_idx_type a_len = a.length ();
 
       retval = FloatComplexMatrix (len, a_len);
       FloatComplex *c = retval.fortran_vec ();
 
       F77_XFCN (cgemm, CGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
-			       F77_CONST_CHAR_ARG2 ("N", 1),
-			       len, a_len, 1, 1.0, v.data (), len,
-			       a.data (), 1, 0.0, c, len
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 ("N", 1),
+                               len, a_len, 1, 1.0, v.data (), len,
+                               a.data (), 1, 0.0, c, len
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 // matrix by diagonal matrix -> matrix operations
 
 FloatComplexMatrix&
@@ -3080,36 +3080,36 @@ bool
 FloatComplexMatrix::any_element_is_nan (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	FloatComplex val = elem (i, j);
-	if (xisnan (val))
-	  return true;
+        FloatComplex val = elem (i, j);
+        if (xisnan (val))
+          return true;
       }
 
   return false;
 }
 
 bool
 FloatComplexMatrix::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	FloatComplex val = elem (i, j);
-	if (xisinf (val) || xisnan (val))
-	  return true;
+        FloatComplex val = elem (i, j);
+        if (xisinf (val) || xisnan (val))
+          return true;
       }
 
   return false;
 }
 
 // Return true if no elements have imaginary components.
 
 bool
@@ -3134,70 +3134,70 @@ FloatComplexMatrix::all_integers (float&
 
       float r_val = std::real (val);
       float i_val = std::imag (val);
 
       max_val = r_val;
       min_val = r_val;
 
       if (i_val > max_val)
-	max_val = i_val;
+        max_val = i_val;
 
       if (i_val < max_val)
-	min_val = i_val;
+        min_val = i_val;
     }
   else
     return false;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	FloatComplex val = elem (i, j);
-
-	float r_val = std::real (val);
-	float i_val = std::imag (val);
-
-	if (r_val > max_val)
-	  max_val = r_val;
-
-	if (i_val > max_val)
-	  max_val = i_val;
-
-	if (r_val < min_val)
-	  min_val = r_val;
-
-	if (i_val < min_val)
-	  min_val = i_val;
-
-	if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
-	  return false;
+        FloatComplex val = elem (i, j);
+
+        float r_val = std::real (val);
+        float i_val = std::imag (val);
+
+        if (r_val > max_val)
+          max_val = r_val;
+
+        if (i_val > max_val)
+          max_val = i_val;
+
+        if (r_val < min_val)
+          min_val = r_val;
+
+        if (i_val < min_val)
+          min_val = i_val;
+
+        if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
+          return false;
       }
 
   return true;
 }
 
 bool
 FloatComplexMatrix::too_large_for_float (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	FloatComplex val = elem (i, j);
-
-	float r_val = std::real (val);
-	float i_val = std::imag (val);
-
-	if ((! (xisnan (r_val) || xisinf (r_val))
-	     && fabs (r_val) > FLT_MAX)
-	    || (! (xisnan (i_val) || xisinf (i_val))
-		&& fabs (i_val) > FLT_MAX))
-	  return true;
+        FloatComplex val = elem (i, j);
+
+        float r_val = std::real (val);
+        float i_val = std::imag (val);
+
+        if ((! (xisnan (r_val) || xisinf (r_val))
+             && fabs (r_val) > FLT_MAX)
+            || (! (xisnan (i_val) || xisinf (i_val))
+                && fabs (i_val) > FLT_MAX))
+          return true;
       }
 
   return false;
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
@@ -3260,42 +3260,42 @@ FloatComplexMatrix::row_is_real_only (oc
 {
   bool retval = true;
 
   octave_idx_type nc = columns ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       if (std::imag (elem (i, j)) != 0.0)
-	{
-	  retval = false;
-	  break;
-	}
+        {
+          retval = false;
+          break;
+        }
     }
 
-  return retval;	      
+  return retval;              
 }
 
 bool
 FloatComplexMatrix::column_is_real_only (octave_idx_type j) const
 {
   bool retval = true;
 
   octave_idx_type nr = rows ();
 
   for (octave_idx_type i = 0; i < nr; i++)
     {
       if (std::imag (elem (i, j)) != 0.0)
-	{
-	  retval = false;
-	  break;
-	}
+        {
+          retval = false;
+          break;
+        }
     }
 
-  return retval;	      
+  return retval;              
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::row_min (void) const
 {
   Array<octave_idx_type> dummy_idx;
   return row_min (dummy_idx);
 }
@@ -3310,62 +3310,62 @@ FloatComplexMatrix::row_min (Array<octav
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       idx_arg.resize (nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
-	  bool real_only = row_is_real_only (i);
-
-	  octave_idx_type idx_j;
-
-	  FloatComplex tmp_min;
-
-	  float abs_min = octave_Float_NaN;
-
-	  for (idx_j = 0; idx_j < nc; idx_j++)
-	    {
-	      tmp_min = elem (i, idx_j);
-
-	      if (! xisnan (tmp_min))
-		{
-		  abs_min = real_only ? std::real (tmp_min) : std::abs (tmp_min);
-		  break;
-		}
-	    }
-
-	  for (octave_idx_type j = idx_j+1; j < nc; j++)
-	    {
-	      FloatComplex tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-
-	      float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
-
-	      if (abs_tmp < abs_min)
-		{
-		  idx_j = j;
-		  tmp_min = tmp;
-		  abs_min = abs_tmp;
-		}
-	    }
-
-	  if (xisnan (tmp_min))
-	    {
-	      result.elem (i) = FloatComplex_NaN_result;
-	      idx_arg.elem (i) = 0;
-	    }
-	  else
-	    {
-	      result.elem (i) = tmp_min;
-	      idx_arg.elem (i) = idx_j;
-	    }
+          bool real_only = row_is_real_only (i);
+
+          octave_idx_type idx_j;
+
+          FloatComplex tmp_min;
+
+          float abs_min = octave_Float_NaN;
+
+          for (idx_j = 0; idx_j < nc; idx_j++)
+            {
+              tmp_min = elem (i, idx_j);
+
+              if (! xisnan (tmp_min))
+                {
+                  abs_min = real_only ? std::real (tmp_min) : std::abs (tmp_min);
+                  break;
+                }
+            }
+
+          for (octave_idx_type j = idx_j+1; j < nc; j++)
+            {
+              FloatComplex tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+
+              float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+
+              if (abs_tmp < abs_min)
+                {
+                  idx_j = j;
+                  tmp_min = tmp;
+                  abs_min = abs_tmp;
+                }
+            }
+
+          if (xisnan (tmp_min))
+            {
+              result.elem (i) = FloatComplex_NaN_result;
+              idx_arg.elem (i) = 0;
+            }
+          else
+            {
+              result.elem (i) = tmp_min;
+              idx_arg.elem (i) = idx_j;
+            }
         }
     }
 
   return result;
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::row_max (void) const
@@ -3384,62 +3384,62 @@ FloatComplexMatrix::row_max (Array<octav
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       idx_arg.resize (nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
-	  bool real_only = row_is_real_only (i);
-
-	  octave_idx_type idx_j;
-
-	  FloatComplex tmp_max;
-
-	  float abs_max = octave_Float_NaN;
-
-	  for (idx_j = 0; idx_j < nc; idx_j++)
-	    {
-	      tmp_max = elem (i, idx_j);
-
-	      if (! xisnan (tmp_max))
-		{
-		  abs_max = real_only ? std::real (tmp_max) : std::abs (tmp_max);
-		  break;
-		}
-	    }
-
-	  for (octave_idx_type j = idx_j+1; j < nc; j++)
-	    {
-	      FloatComplex tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-
-	      float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
-
-	      if (abs_tmp > abs_max)
-		{
-		  idx_j = j;
-		  tmp_max = tmp;
-		  abs_max = abs_tmp;
-		}
-	    }
-
-	  if (xisnan (tmp_max))
-	    {
-	      result.elem (i) = FloatComplex_NaN_result;
-	      idx_arg.elem (i) = 0;
-	    }
-	  else
-	    {
-	      result.elem (i) = tmp_max;
-	      idx_arg.elem (i) = idx_j;
-	    }
+          bool real_only = row_is_real_only (i);
+
+          octave_idx_type idx_j;
+
+          FloatComplex tmp_max;
+
+          float abs_max = octave_Float_NaN;
+
+          for (idx_j = 0; idx_j < nc; idx_j++)
+            {
+              tmp_max = elem (i, idx_j);
+
+              if (! xisnan (tmp_max))
+                {
+                  abs_max = real_only ? std::real (tmp_max) : std::abs (tmp_max);
+                  break;
+                }
+            }
+
+          for (octave_idx_type j = idx_j+1; j < nc; j++)
+            {
+              FloatComplex tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+
+              float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+
+              if (abs_tmp > abs_max)
+                {
+                  idx_j = j;
+                  tmp_max = tmp;
+                  abs_max = abs_tmp;
+                }
+            }
+
+          if (xisnan (tmp_max))
+            {
+              result.elem (i) = FloatComplex_NaN_result;
+              idx_arg.elem (i) = 0;
+            }
+          else
+            {
+              result.elem (i) = tmp_max;
+              idx_arg.elem (i) = idx_j;
+            }
         }
     }
 
   return result;
 }
 
 FloatComplexRowVector
 FloatComplexMatrix::column_min (void) const
@@ -3458,62 +3458,62 @@ FloatComplexMatrix::column_min (Array<oc
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       idx_arg.resize (nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-	  bool real_only = column_is_real_only (j);
-
-	  octave_idx_type idx_i;
-
-	  FloatComplex tmp_min;
-
-	  float abs_min = octave_Float_NaN;
-
-	  for (idx_i = 0; idx_i < nr; idx_i++)
-	    {
-	      tmp_min = elem (idx_i, j);
-
-	      if (! xisnan (tmp_min))
-		{
-		  abs_min = real_only ? std::real (tmp_min) : std::abs (tmp_min);
-		  break;
-		}
-	    }
-
-	  for (octave_idx_type i = idx_i+1; i < nr; i++)
-	    {
-	      FloatComplex tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-
-	      float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
-
-	      if (abs_tmp < abs_min)
-		{
-		  idx_i = i;
-		  tmp_min = tmp;
-		  abs_min = abs_tmp;
-		}
-	    }
-
-	  if (xisnan (tmp_min))
-	    {
-	      result.elem (j) = FloatComplex_NaN_result;
-	      idx_arg.elem (j) = 0;
-	    }
-	  else
-	    {
-	      result.elem (j) = tmp_min;
-	      idx_arg.elem (j) = idx_i;
-	    }
+          bool real_only = column_is_real_only (j);
+
+          octave_idx_type idx_i;
+
+          FloatComplex tmp_min;
+
+          float abs_min = octave_Float_NaN;
+
+          for (idx_i = 0; idx_i < nr; idx_i++)
+            {
+              tmp_min = elem (idx_i, j);
+
+              if (! xisnan (tmp_min))
+                {
+                  abs_min = real_only ? std::real (tmp_min) : std::abs (tmp_min);
+                  break;
+                }
+            }
+
+          for (octave_idx_type i = idx_i+1; i < nr; i++)
+            {
+              FloatComplex tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+
+              float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+
+              if (abs_tmp < abs_min)
+                {
+                  idx_i = i;
+                  tmp_min = tmp;
+                  abs_min = abs_tmp;
+                }
+            }
+
+          if (xisnan (tmp_min))
+            {
+              result.elem (j) = FloatComplex_NaN_result;
+              idx_arg.elem (j) = 0;
+            }
+          else
+            {
+              result.elem (j) = tmp_min;
+              idx_arg.elem (j) = idx_i;
+            }
         }
     }
 
   return result;
 }
 
 FloatComplexRowVector
 FloatComplexMatrix::column_max (void) const
@@ -3532,103 +3532,103 @@ FloatComplexMatrix::column_max (Array<oc
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       idx_arg.resize (nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-	  bool real_only = column_is_real_only (j);
-
-	  octave_idx_type idx_i;
-
-	  FloatComplex tmp_max;
-
-	  float abs_max = octave_Float_NaN;
-
-	  for (idx_i = 0; idx_i < nr; idx_i++)
-	    {
-	      tmp_max = elem (idx_i, j);
-
-	      if (! xisnan (tmp_max))
-		{
-		  abs_max = real_only ? std::real (tmp_max) : std::abs (tmp_max);
-		  break;
-		}
-	    }
-
-	  for (octave_idx_type i = idx_i+1; i < nr; i++)
-	    {
-	      FloatComplex tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-
-	      float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
-
-	      if (abs_tmp > abs_max)
-		{
-		  idx_i = i;
-		  tmp_max = tmp;
-		  abs_max = abs_tmp;
-		}
-	    }
-
-	  if (xisnan (tmp_max))
-	    {
-	      result.elem (j) = FloatComplex_NaN_result;
-	      idx_arg.elem (j) = 0;
-	    }
-	  else
-	    {
-	      result.elem (j) = tmp_max;
-	      idx_arg.elem (j) = idx_i;
-	    }
+          bool real_only = column_is_real_only (j);
+
+          octave_idx_type idx_i;
+
+          FloatComplex tmp_max;
+
+          float abs_max = octave_Float_NaN;
+
+          for (idx_i = 0; idx_i < nr; idx_i++)
+            {
+              tmp_max = elem (idx_i, j);
+
+              if (! xisnan (tmp_max))
+                {
+                  abs_max = real_only ? std::real (tmp_max) : std::abs (tmp_max);
+                  break;
+                }
+            }
+
+          for (octave_idx_type i = idx_i+1; i < nr; i++)
+            {
+              FloatComplex tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+
+              float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+
+              if (abs_tmp > abs_max)
+                {
+                  idx_i = i;
+                  tmp_max = tmp;
+                  abs_max = abs_tmp;
+                }
+            }
+
+          if (xisnan (tmp_max))
+            {
+              result.elem (j) = FloatComplex_NaN_result;
+              idx_arg.elem (j) = 0;
+            }
+          else
+            {
+              result.elem (j) = tmp_max;
+              idx_arg.elem (j) = idx_i;
+            }
         }
     }
 
   return result;
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const FloatComplexMatrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
-	{
-	  os << " ";
-	  octave_write_complex (os, a.elem (i, j));
-	}
+        {
+          os << " ";
+          octave_write_complex (os, a.elem (i, j));
+        }
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr > 0 && nc > 0)
     {
       FloatComplex tmp;
       for (octave_idx_type i = 0; i < nr; i++)
-	for (octave_idx_type j = 0; j < nc; j++)
-	  {
-	    tmp = octave_read_value<FloatComplex> (is);
-	    if (is)
-	      a.elem (i, j) = tmp;
-	    else
-	      goto done;
-	  }
+        for (octave_idx_type j = 0; j < nc; j++)
+          {
+            tmp = octave_read_value<FloatComplex> (is);
+            if (is)
+              a.elem (i, j) = tmp;
+            else
+              goto done;
+          }
     }
 
 done:
 
   return is;
 }
 
 FloatComplexMatrix
@@ -3646,17 +3646,17 @@ Givens (const FloatComplex& x, const Flo
   g.elem (0, 1) = cs;
   g.elem (1, 0) = -conj (cs);
 
   return g;
 }
 
 FloatComplexMatrix
 Sylvester (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
-	   const FloatComplexMatrix& c)
+           const FloatComplexMatrix& c)
 {
   FloatComplexMatrix retval;
 
   // FIXME -- need to check that a, b, and c are all the same
   // size.
 
   // Compute Schur decompositions
 
@@ -3682,21 +3682,21 @@ Sylvester (const FloatComplexMatrix& a, 
   float scale;
   octave_idx_type info;
 
   FloatComplex *pa = sch_a.fortran_vec ();
   FloatComplex *pb = sch_b.fortran_vec ();
   FloatComplex *px = cx.fortran_vec ();
   
   F77_XFCN (ctrsyl, CTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
-			     F77_CONST_CHAR_ARG2 ("N", 1),
-			     1, a_nr, b_nr, pa, a_nr, pb,
-			     b_nr, px, a_nr, scale, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             1, a_nr, b_nr, pa, a_nr, pb,
+                             b_nr, px, a_nr, scale, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   // FIXME -- check info?
 
   retval = -ua * cx * ub.hermitian ();
 
   return retval;
 }
 
@@ -3763,23 +3763,23 @@ xgemm (const FloatComplexMatrix& a, cons
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
     gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
   else
     {
       if (a_nr == 0 || a_nc == 0 || b_nc == 0)
-	retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
+        retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
       else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
         {
-	  octave_idx_type lda = a.rows ();
+          octave_idx_type lda = a.rows ();
 
           retval = FloatComplexMatrix (a_nr, b_nc);
-	  FloatComplex *c = retval.fortran_vec ();
+          FloatComplex *c = retval.fortran_vec ();
 
           const char *ctra = get_blas_trans_arg (tra, cja);
           if (cja || cjb)
             {
               F77_XFCN (cherk, CHERK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                        F77_CONST_CHAR_ARG2 (ctra, 1),
                                        a_nr, a_nc, 1.0,
                                        a.data (), lda, 0.0, c, a_nr
@@ -3800,25 +3800,25 @@ xgemm (const FloatComplexMatrix& a, cons
               for (octave_idx_type j = 0; j < a_nr; j++)
                 for (octave_idx_type i = 0; i < j; i++)
                   retval.xelem (j,i) = retval.xelem (i,j);
 
             }
 
         }
       else
-	{
-	  octave_idx_type lda = a.rows (), tda = a.cols ();
-	  octave_idx_type ldb = b.rows (), tdb = b.cols ();
-
-	  retval = FloatComplexMatrix (a_nr, b_nc);
-	  FloatComplex *c = retval.fortran_vec ();
-
-	  if (b_nc == 1 && a_nr == 1)
-	    {
+        {
+          octave_idx_type lda = a.rows (), tda = a.cols ();
+          octave_idx_type ldb = b.rows (), tdb = b.cols ();
+
+          retval = FloatComplexMatrix (a_nr, b_nc);
+          FloatComplex *c = retval.fortran_vec ();
+
+          if (b_nc == 1 && a_nr == 1)
+            {
               if (cja == cjb)
                 {
                   F77_FUNC (xcdotu, XCDOTU) (a_nc, a.data (), 1, b.data (), 1, *c);
                   if (cja) *c = std::conj (*c);
                 }
               else if (cja)
                   F77_FUNC (xcdotc, XCDOTC) (a_nc, a.data (), 1, b.data (), 1, *c);
               else
@@ -3835,28 +3835,28 @@ xgemm (const FloatComplexMatrix& a, cons
           else if (a_nr == 1 && ! cja && ! cjb)
             {
               const char *crevtrb = get_blas_trans_arg (! trb, cjb);
               F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 (crevtrb, 1),
                                        ldb, tdb, 1.0,  b.data (), ldb,
                                        a.data (), 1, 0.0, c, 1
                                        F77_CHAR_ARG_LEN (1)));
             }
-	  else
-	    {
+          else
+            {
               const char *ctra = get_blas_trans_arg (tra, cja);
               const char *ctrb = get_blas_trans_arg (trb, cjb);
-	      F77_XFCN (cgemm, CGEMM, (F77_CONST_CHAR_ARG2 (ctra, 1),
-				       F77_CONST_CHAR_ARG2 (ctrb, 1),
-				       a_nr, b_nc, a_nc, 1.0, a.data (),
-				       lda, b.data (), ldb, 0.0, c, a_nr
-				       F77_CHAR_ARG_LEN (1)
-				       F77_CHAR_ARG_LEN (1)));
-	    }
-	}
+              F77_XFCN (cgemm, CGEMM, (F77_CONST_CHAR_ARG2 (ctra, 1),
+                                       F77_CONST_CHAR_ARG2 (ctrb, 1),
+                                       a_nr, b_nc, a_nc, 1.0, a.data (),
+                                       lda, b.data (), ldb, 0.0, c, a_nr
+                                       F77_CHAR_ARG_LEN (1)
+                                       F77_CHAR_ARG_LEN (1)));
+            }
+        }
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 operator * (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
 {
@@ -3878,18 +3878,18 @@ min (const FloatComplex& c, const FloatC
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmin (c, m (i, j));
+        octave_quit ();
+        result (i, j) = xmin (c, m (i, j));
       }
 
   return result;
 }
 
 FloatComplexMatrix
 min (const FloatComplexMatrix& m, const FloatComplex& c)
 {
@@ -3898,66 +3898,66 @@ min (const FloatComplexMatrix& m, const 
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmin (m (i, j), c);
+        octave_quit ();
+        result (i, j) = xmin (m (i, j), c);
       }
 
   return result;
 }
 
 FloatComplexMatrix
 min (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-	("two-arg min expecting args of same size");
+        ("two-arg min expecting args of same size");
       return FloatComplexMatrix ();
     }
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  octave_quit ();
-	  if (std::imag (a (i, j)) != 0.0 || std::imag (b (i, j)) != 0.0)
-	    {
-	      columns_are_real_only = 0;
-	      break;
-	    }
-	}
+        {
+          octave_quit ();
+          if (std::imag (a (i, j)) != 0.0 || std::imag (b (i, j)) != 0.0)
+            {
+              columns_are_real_only = 0;
+              break;
+            }
+        }
 
       if (columns_are_real_only)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    result (i, j) = xmin (std::real (a (i, j)), std::real (b (i, j)));
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            result (i, j) = xmin (std::real (a (i, j)), std::real (b (i, j)));
+        }
       else
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      octave_quit ();
-	      result (i, j) = xmin (a (i, j), b (i, j));
-	    }
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              octave_quit ();
+              result (i, j) = xmin (a (i, j), b (i, j));
+            }
+        }
     }
 
   return result;
 }
 
 FloatComplexMatrix
 max (const FloatComplex& c, const FloatComplexMatrix& m)
 {
@@ -3966,18 +3966,18 @@ max (const FloatComplex& c, const FloatC
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmax (c, m (i, j));
+        octave_quit ();
+        result (i, j) = xmax (c, m (i, j));
       }
 
   return result;
 }
 
 FloatComplexMatrix
 max (const FloatComplexMatrix& m, const FloatComplex& c)
 {
@@ -3986,69 +3986,69 @@ max (const FloatComplexMatrix& m, const 
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmax (m (i, j), c);
+        octave_quit ();
+        result (i, j) = xmax (m (i, j), c);
       }
 
   return result;
 }
 
 FloatComplexMatrix
 max (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-	("two-arg max expecting args of same size");
+        ("two-arg max expecting args of same size");
       return FloatComplexMatrix ();
     }
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  octave_quit ();
-	  if (std::imag (a (i, j)) != 0.0 || std::imag (b (i, j)) != 0.0)
-	    {
-	      columns_are_real_only = 0;
-	      break;
-	    }
-	}
+        {
+          octave_quit ();
+          if (std::imag (a (i, j)) != 0.0 || std::imag (b (i, j)) != 0.0)
+            {
+              columns_are_real_only = 0;
+              break;
+            }
+        }
 
       if (columns_are_real_only)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      octave_quit ();
-	      result (i, j) = xmax (std::real (a (i, j)), std::real (b (i, j)));
-	    }
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              octave_quit ();
+              result (i, j) = xmax (std::real (a (i, j)), std::real (b (i, j)));
+            }
+        }
       else
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      octave_quit ();
-	      result (i, j) = xmax (a (i, j), b (i, j));
-	    }
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              octave_quit ();
+              result (i, j) = xmax (a (i, j), b (i, j));
+            }
+        }
     }
 
   return result;
 }
 
 FloatComplexMatrix linspace (const FloatComplexColumnVector& x1, 
                              const FloatComplexColumnVector& x2, 
                              octave_idx_type n)
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -76,17 +76,17 @@ FloatComplexNDArray::fourier (int dim) c
 
   const FloatComplex *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::fft (in + k * stride * n, out + k * stride * n, 
-		      n, howmany, stride, dist);
+                      n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
@@ -107,17 +107,17 @@ FloatComplexNDArray::ifourier (int dim) 
 
   const FloatComplex *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::ifft (in + k * stride * n, out + k * stride * n, 
-		      n, howmany, stride, dist);
+                      n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourier2d (void) const
 {
   dim_vector dv = dims();
@@ -227,27 +227,27 @@ FloatComplexNDArray::fourier (int dim) c
   octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
-	{
-	  octave_quit ();
+        {
+          octave_quit ();
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    tmp[i] = elem((i + k*npts)*stride + j*dist);
+          for (octave_idx_type i = 0; i < npts; i++)
+            tmp[i] = elem((i + k*npts)*stride + j*dist);
 
-	  F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
+          F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    retval ((i + k*npts)*stride + j*dist) = tmp[i];
-	}
+          for (octave_idx_type i = 0; i < npts; i++)
+            retval ((i + k*npts)*stride + j*dist) = tmp[i];
+        }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier (int dim) const
 {
@@ -274,28 +274,28 @@ FloatComplexNDArray::ifourier (int dim) 
   octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
-	{
-	  octave_quit ();
+        {
+          octave_quit ();
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    tmp[i] = elem((i + k*npts)*stride + j*dist);
+          for (octave_idx_type i = 0; i < npts; i++)
+            tmp[i] = elem((i + k*npts)*stride + j*dist);
 
-	  F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
+          F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    retval ((i + k*npts)*stride + j*dist) = tmp[i] /
-	      static_cast<float> (npts);
-	}
+          for (octave_idx_type i = 0; i < npts; i++)
+            retval ((i + k*npts)*stride + j*dist) = tmp[i] /
+              static_cast<float> (npts);
+        }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourier2d (void) const
 {
@@ -311,37 +311,37 @@ FloatComplexNDArray::fourier2d (void) co
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
+              F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l];
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l];
+            }
+        }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
 
 FloatComplexNDArray
@@ -359,38 +359,38 @@ FloatComplexNDArray::ifourier2d (void) c
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
+              F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l] /
-		  static_cast<float> (npts);
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                  static_cast<float> (npts);
+            }
+        }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
 
 FloatComplexNDArray
@@ -407,37 +407,37 @@ FloatComplexNDArray::fourierNd (void) co
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
+              F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l];
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l];
+            }
+        }
 
       stride *= dv(i);
     }
 
   return retval;
 }
 
 FloatComplexNDArray
@@ -454,38 +454,38 @@ FloatComplexNDArray::ifourierNd (void) c
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
+              F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l] /
-		  static_cast<float> (npts);
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                  static_cast<float> (npts);
+            }
+        }
 
       stride *= dv(i);
     }
 
   return retval;
 }
 
 #endif
@@ -504,31 +504,31 @@ bool
 FloatComplexNDArray::any_element_is_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       FloatComplex val = elem (i);
       if (xisnan (val))
-	return true;
+        return true;
     }
   return false;
 }
 
 bool
 FloatComplexNDArray::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       FloatComplex val = elem (i);
       if (xisinf (val) || xisnan (val))
-	return true;
+        return true;
     }
   return false;
 }
 
 // Return true if no elements have imaginary components.
 
 bool
 FloatComplexNDArray::all_elements_are_real (void) const
@@ -551,45 +551,45 @@ FloatComplexNDArray::all_integers (float
 
       float r_val = std::real (val);
       float i_val = std::imag (val);
       
       max_val = r_val;
       min_val = r_val;
 
       if (i_val > max_val)
-	max_val = i_val;
+        max_val = i_val;
 
       if (i_val < max_val)
-	min_val = i_val;
+        min_val = i_val;
     }
   else
     return false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       FloatComplex val = elem (i);
 
       float r_val = std::real (val);
       float i_val = std::imag (val);
 
       if (r_val > max_val)
-	max_val = r_val;
+        max_val = r_val;
 
       if (i_val > max_val)
-	max_val = i_val;
+        max_val = i_val;
 
       if (r_val < min_val)
-	min_val = r_val;
+        min_val = r_val;
 
       if (i_val < min_val)
-	min_val = i_val;
+        min_val = i_val;
 
       if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
-	return false;
+        return false;
     }
 
   return true;
 }
 
 bool
 FloatComplexNDArray::too_large_for_float (void) const
 {
@@ -598,20 +598,20 @@ FloatComplexNDArray::too_large_for_float
   for (octave_idx_type i = 0; i < nel; i++)
     {
       FloatComplex val = elem (i);
 
       float r_val = std::real (val);
       float i_val = std::imag (val);
 
       if ((! (xisnan (r_val) || xisinf (r_val))
-	   && fabs (r_val) > FLT_MAX)
-	  || (! (xisnan (i_val) || xisinf (i_val))
-	      && fabs (i_val) > FLT_MAX))
-	return true;
+           && fabs (r_val) > FLT_MAX)
+          || (! (xisnan (i_val) || xisinf (i_val))
+              && fabs (i_val) > FLT_MAX))
+        return true;
     }
 
   return false;
 }
 
 boolNDArray
 FloatComplexNDArray::all (int dim) const
 {
@@ -782,43 +782,43 @@ FloatComplexNDArray::insert (const NDArr
   if (n == dimensions.length ())
     {
       Array<octave_idx_type> a_ra_idx (a_dv.length (), 0);
       
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
       
       for (int i = 0; i < n; i++)
-	{
-	  if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
-	    {
-	      (*current_liboctave_error_handler)
-		("Array<T>::insert: range error for insert");
-	      return *this;
-	    }
-	}
+        {
+          if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
+            {
+              (*current_liboctave_error_handler)
+                ("Array<T>::insert: range error for insert");
+              return *this;
+            }
+        }
       
       a_ra_idx.elem (0) = 0;
       a_ra_idx.elem (1) = 0;
       
       octave_idx_type n_elt = a.numel ();
       
       // IS make_unique () NECCESSARY HERE??
 
       for (octave_idx_type i = 0; i < n_elt; i++)
-	{
-	  Array<octave_idx_type> ra_idx = a_ra_idx;
-	  
-	  ra_idx.elem (0) = a_ra_idx (0) + r;
-	  ra_idx.elem (1) = a_ra_idx (1) + c;
-	  
-	  elem (ra_idx) = a.elem (a_ra_idx);
+        {
+          Array<octave_idx_type> ra_idx = a_ra_idx;
+          
+          ra_idx.elem (0) = a_ra_idx (0) + r;
+          ra_idx.elem (1) = a_ra_idx (1) + c;
+          
+          elem (ra_idx) = a.elem (a_ra_idx);
 
-	  increment_index (a_ra_idx, a_dv);
-	}
+          increment_index (a_ra_idx, a_dv);
+        }
     }
   else
     (*current_liboctave_error_handler)
       ("Array<T>::insert: invalid indexing operation");
 
   return *this;
 }
 
@@ -847,25 +847,25 @@ FloatComplexNDArray::matrix_value (void)
     (*current_liboctave_error_handler)
       ("invalid conversion of FloatComplexNDArray to FloatComplexMatrix");
 
   return retval;
 }
 
 void
 FloatComplexNDArray::increment_index (Array<octave_idx_type>& ra_idx,
-				 const dim_vector& dimensions,
-				 int start_dimension)
+                                 const dim_vector& dimensions,
+                                 int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
 octave_idx_type 
 FloatComplexNDArray::compute_index (Array<octave_idx_type>& ra_idx,
-			       const dim_vector& dimensions)
+                               const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::diag (octave_idx_type k) const
 {
   return MArrayN<FloatComplex>::diag (k);
@@ -890,23 +890,23 @@ std::istream&
 operator >> (std::istream& is, FloatComplexNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       FloatComplex tmp;
       for (octave_idx_type i = 0; i < nel; i++)
-	  {
-	    tmp = octave_read_value<FloatComplex> (is);
-	    if (is)
-	      a.elem (i) = tmp;
-	    else
-	      goto done;
-	  }
+          {
+            tmp = octave_read_value<FloatComplex> (is);
+            if (is)
+              a.elem (i) = tmp;
+            else
+              goto done;
+          }
     }
 
  done:
 
   return is;
 }
 
 FloatComplexNDArray
diff --git a/liboctave/fCRowVector.cc b/liboctave/fCRowVector.cc
--- a/liboctave/fCRowVector.cc
+++ b/liboctave/fCRowVector.cc
@@ -37,24 +37,24 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgemv, CGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const FloatComplex&,
-			   const FloatComplex*, const octave_idx_type&, const FloatComplex*,
-			   const octave_idx_type&, const FloatComplex&, FloatComplex*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, const octave_idx_type&, const FloatComplex&,
+                           const FloatComplex*, const octave_idx_type&, const FloatComplex*,
+                           const octave_idx_type&, const FloatComplex&, FloatComplex*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xcdotu, XCDOTU) (const octave_idx_type&, const FloatComplex*, const octave_idx_type&,
-			     const FloatComplex*, const octave_idx_type&, FloatComplex&);
+                             const FloatComplex*, const octave_idx_type&, FloatComplex&);
 }
 
 // FloatComplex Row Vector class
 
 FloatComplexRowVector::FloatComplexRowVector (const FloatRowVector& a)
   : MArray<FloatComplex> (a.length ())
 {
   for (octave_idx_type i = 0; i < length (); i++)
@@ -89,17 +89,17 @@ FloatComplexRowVector::insert (const Flo
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (c+i) = a.elem (i);
+        xelem (c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::insert (const FloatComplexRowVector& a, octave_idx_type c)
 {
@@ -111,49 +111,49 @@ FloatComplexRowVector::insert (const Flo
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (c+i) = a.elem (i);
+        xelem (c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::fill (float val)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::fill (const FloatComplex& val)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::fill (float val, octave_idx_type c1, octave_idx_type c2)
 {
@@ -167,17 +167,17 @@ FloatComplexRowVector::fill (float val, 
 
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type i = c1; i <= c2; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::fill (const FloatComplex& val, octave_idx_type c1, octave_idx_type c2)
 {
@@ -191,17 +191,17 @@ FloatComplexRowVector::fill (const Float
 
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type i = c1; i <= c2; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatComplexRowVector
 FloatComplexRowVector::append (const FloatRowVector& a) const
 {
@@ -332,31 +332,31 @@ operator * (const FloatComplexRowVector&
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
       if (len == 0)
-	retval.resize (a_nc, 0.0);
+        retval.resize (a_nc, 0.0);
       else
-	{
-	  // Transpose A to form A'*x == (x'*A)'
+        {
+          // Transpose A to form A'*x == (x'*A)'
 
-	  octave_idx_type ld = a_nr;
+          octave_idx_type ld = a_nr;
 
-	  retval.resize (a_nc);
-	  FloatComplex *y = retval.fortran_vec ();
+          retval.resize (a_nc);
+          FloatComplex *y = retval.fortran_vec ();
 
-	  F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
-				   a_nr, a_nc, 1.0, a.data (),
-				   ld, v.data (), 1, 0.0, y, 1
-				   F77_CHAR_ARG_LEN (1)));
-	}
+          F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
+                                   a_nr, a_nc, 1.0, a.data (),
+                                   ld, v.data (), 1, 0.0, y, 1
+                                   F77_CHAR_ARG_LEN (1)));
+        }
     }
 
   return retval;
 }
 
 FloatComplexRowVector
 operator * (const FloatRowVector& v, const FloatComplexMatrix& a)
 {
@@ -374,18 +374,18 @@ FloatComplexRowVector::min (void) const
     return FloatComplex (0.0);
 
   FloatComplex res = elem (0);
   float absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) < absres)
       {
-	res = elem (i);
-	absres = std::abs (res);
+        res = elem (i);
+        absres = std::abs (res);
       }
 
   return res;
 }
 
 FloatComplex
 FloatComplexRowVector::max (void) const
 {
@@ -394,18 +394,18 @@ FloatComplexRowVector::max (void) const
     return FloatComplex (0.0);
 
   FloatComplex res = elem (0);
   float absres = std::abs (res);
 
   for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) > absres)
       {
-	res = elem (i);
-	absres = std::abs (res);
+        res = elem (i);
+        absres = std::abs (res);
       }
 
   return res;
 }
 
 // i/o
 
 std::ostream&
diff --git a/liboctave/fCmplxAEPBAL.cc b/liboctave/fCmplxAEPBAL.cc
--- a/liboctave/fCmplxAEPBAL.cc
+++ b/liboctave/fCmplxAEPBAL.cc
@@ -31,27 +31,27 @@ along with Octave; see the file COPYING.
 #include "fCmplxAEPBAL.h"
 #include "fMatrix.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgebal, CGEBAL) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     FloatComplex*, const octave_idx_type&,
-			     octave_idx_type&, octave_idx_type&, float*,
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             FloatComplex*, const octave_idx_type&,
+                             octave_idx_type&, octave_idx_type&, float*,
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
  
   F77_RET_T
   F77_FUNC (cgebak, CGEBAK) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&,
-			     const octave_idx_type&, const float*,
-			     const octave_idx_type&, FloatComplex*,
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL  F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const octave_idx_type&,
+                             const octave_idx_type&, const float*,
+                             const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL  F77_CHAR_ARG_LEN_DECL);
 }
 
 FloatComplexAEPBALANCE::FloatComplexAEPBALANCE (const FloatComplexMatrix& a, 
                                                 bool noperm, bool noscal)
  : base_aepbal<FloatComplexMatrix, FloatColumnVector> ()
 {
   octave_idx_type n = a.cols ();
 
@@ -67,19 +67,19 @@ FloatComplexAEPBALANCE::FloatComplexAEPB
   float *pscale = scale.fortran_vec ();
 
   balanced_mat = a;
   FloatComplex *p_balanced_mat = balanced_mat.fortran_vec ();
 
   job = noperm ? (noscal ? 'N' : 'S') : (noscal ? 'P' : 'B');
 
   F77_XFCN (cgebal, CGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     n, p_balanced_mat, n, ilo, ihi,
-			     pscale, info
-			     F77_CHAR_ARG_LEN (1)));
+                             n, p_balanced_mat, n, ilo, ihi,
+                             pscale, info
+                             F77_CHAR_ARG_LEN (1)));
 }
 
 FloatComplexMatrix
 FloatComplexAEPBALANCE::balancing_matrix (void) const
 {
   octave_idx_type n = balanced_mat.rows ();
   FloatComplexMatrix balancing_mat (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
@@ -88,16 +88,16 @@ FloatComplexAEPBALANCE::balancing_matrix
   FloatComplex *p_balancing_mat = balancing_mat.fortran_vec ();
   const float *pscale = scale.fortran_vec ();
 
   octave_idx_type info;
 
   char side = 'R';
 
   F77_XFCN (cgebak, CGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 (&side, 1),
-			     n, ilo, ihi, pscale, n,
-			     p_balancing_mat, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&side, 1),
+                             n, ilo, ihi, pscale, n,
+                             p_balancing_mat, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   return balancing_mat;
 }
diff --git a/liboctave/fCmplxCHOL.cc b/liboctave/fCmplxCHOL.cc
--- a/liboctave/fCmplxCHOL.cc
+++ b/liboctave/fCmplxCHOL.cc
@@ -38,28 +38,28 @@ along with Octave; see the file COPYING.
 #ifndef HAVE_QRUPDATE
 #include "dbleQR.h"
 #endif
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cpotrf, CPOTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     FloatComplex*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             FloatComplex*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (cpotri, CPOTRI) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     FloatComplex*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             FloatComplex*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cpocon, CPOCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     FloatComplex*, const octave_idx_type&, const float&,
-			     float&, FloatComplex*, float*, 
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             FloatComplex*, const octave_idx_type&, const float&,
+                             float&, FloatComplex*, float*, 
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
 #ifdef HAVE_QRUPDATE
 
   F77_RET_T
   F77_FUNC (cch1up, CCH1UP) (const octave_idx_type&, FloatComplex*, const octave_idx_type&,
                              FloatComplex*, float*);
 
   F77_RET_T
   F77_FUNC (cch1dn, CCH1DN) (const octave_idx_type&, FloatComplex*, const octave_idx_type&,
@@ -85,17 +85,17 @@ octave_idx_type
 FloatComplexCHOL::init (const FloatComplexMatrix& a, bool calc_cond)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
-	("FloatComplexCHOL requires square matrix");
+        ("FloatComplexCHOL requires square matrix");
       return -1;
     }
 
   octave_idx_type n = a_nc;
   octave_idx_type info;
 
   chol_mat.clear (n, n);
   for (octave_idx_type j = 0; j < n; j++)
@@ -108,36 +108,36 @@ FloatComplexCHOL::init (const FloatCompl
   FloatComplex *h = chol_mat.fortran_vec ();
 
   // Calculate the norm of the matrix, for later use.
   float anorm = 0;
   if (calc_cond) 
     anorm = xnorm (a, 1);
 
   F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CHAR_ARG_LEN (1)));
 
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond) 
     {
       octave_idx_type cpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
       Array<FloatComplex> z (2*n);
       FloatComplex *pz = z.fortran_vec ();
       Array<float> rz (n);
       float *prz = rz.fortran_vec ();
       F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
-				 n, anorm, xrcond, pz, prz, cpocon_info
-				 F77_CHAR_ARG_LEN (1)));
+                                 n, anorm, xrcond, pz, prz, cpocon_info
+                                 F77_CHAR_ARG_LEN (1)));
 
       if (cpocon_info != 0) 
-	info = -1;
+        info = -1;
     }
 
   return info;
 }
 
 static FloatComplexMatrix
 chol2inv_internal (const FloatComplexMatrix& r)
 {
@@ -149,26 +149,26 @@ chol2inv_internal (const FloatComplexMat
   if (r_nr == r_nc)
     {
       octave_idx_type n = r_nc;
       octave_idx_type info;
 
       FloatComplexMatrix tmp = r;
 
       F77_XFCN (cpotri, CPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-				 tmp.fortran_vec (), n, info
-				 F77_CHAR_ARG_LEN (1)));
+                                 tmp.fortran_vec (), n, info
+                                 F77_CHAR_ARG_LEN (1)));
 
       // If someone thinks of a more graceful way of doing this (or
       // faster for that matter :-)), please let me know!
 
       if (n > 1)
-	for (octave_idx_type j = 0; j < r_nc; j++)
-	  for (octave_idx_type i = j+1; i < r_nr; i++)
-	    tmp.xelem (i, j) = std::conj (tmp.xelem (j, i));
+        for (octave_idx_type j = 0; j < r_nc; j++)
+          for (octave_idx_type i = j+1; i < r_nr; i++)
+            tmp.xelem (i, j) = std::conj (tmp.xelem (j, i));
 
       retval = tmp;
     }
   else
     (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
   return retval;
 }
diff --git a/liboctave/fCmplxGEPBAL.cc b/liboctave/fCmplxGEPBAL.cc
--- a/liboctave/fCmplxGEPBAL.cc
+++ b/liboctave/fCmplxGEPBAL.cc
@@ -32,37 +32,37 @@ along with Octave; see the file COPYING.
 #include "Array-util.h"
 #include "f77-fcn.h"
 #include "oct-locbuf.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cggbal, CGGBAL) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type& N,
-			     FloatComplex* A, const octave_idx_type& LDA, FloatComplex* B,
-			     const octave_idx_type& LDB, octave_idx_type& ILO, octave_idx_type& IHI,
-			     float* LSCALE, float* RSCALE,
-			     float* WORK, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL);
+                             FloatComplex* A, const octave_idx_type& LDA, FloatComplex* B,
+                             const octave_idx_type& LDB, octave_idx_type& ILO, octave_idx_type& IHI,
+                             float* LSCALE, float* RSCALE,
+                             float* WORK, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sggbak, SGGBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type& N, const octave_idx_type& ILO,
-			     const octave_idx_type& IHI, const float* LSCALE,
-			     const float* RSCALE, octave_idx_type& M, float* V,
-			     const octave_idx_type& LDV, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type& N, const octave_idx_type& ILO,
+                             const octave_idx_type& IHI, const float* LSCALE,
+                             const float* RSCALE, octave_idx_type& M, float* V,
+                             const octave_idx_type& LDV, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
 }
 
 octave_idx_type
 FloatComplexGEPBALANCE::init (const FloatComplexMatrix& a, const FloatComplexMatrix& b, 
-		  const std::string& balance_job)
+                  const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("FloatComplexGEPBALANCE requires square matrix");
       return -1;
     }
@@ -84,42 +84,42 @@ FloatComplexGEPBALANCE::init (const Floa
   balanced_mat = a;
   FloatComplex *p_balanced_mat = balanced_mat.fortran_vec ();
   balanced_mat2 = b;
   FloatComplex *p_balanced_mat2 = balanced_mat2.fortran_vec ();
 
   char job = balance_job[0];
 
   F77_XFCN (cggbal, CGGBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     n, p_balanced_mat, n, p_balanced_mat2,
-			     n, ilo, ihi, plscale,prscale, pwork, info
-			     F77_CHAR_ARG_LEN (1)));
+                             n, p_balanced_mat, n, p_balanced_mat2,
+                             n, ilo, ihi, plscale,prscale, pwork, info
+                             F77_CHAR_ARG_LEN (1)));
 
   balancing_mat = FloatMatrix (n, n, 0.0);
   balancing_mat2 = FloatMatrix (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
     {
       octave_quit ();
       balancing_mat.elem (i ,i) = 1.0;
       balancing_mat2.elem (i ,i) = 1.0;
     }
 
   float *p_balancing_mat = balancing_mat.fortran_vec ();
   float *p_balancing_mat2 = balancing_mat2.fortran_vec ();
 
   // first left
   F77_XFCN (sggbak, SGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 ("L", 1),
-			     n, ilo, ihi, plscale, prscale,
-			     n, p_balancing_mat, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 ("L", 1),
+                             n, ilo, ihi, plscale, prscale,
+                             n, p_balancing_mat, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
       
   // then right
   F77_XFCN (sggbak, SGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 ("R", 1),
-			     n, ilo, ihi, plscale, prscale,
-			     n, p_balancing_mat2, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 ("R", 1),
+                             n, ilo, ihi, plscale, prscale,
+                             n, p_balancing_mat2, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
diff --git a/liboctave/fCmplxHESS.cc b/liboctave/fCmplxHESS.cc
--- a/liboctave/fCmplxHESS.cc
+++ b/liboctave/fCmplxHESS.cc
@@ -28,49 +28,49 @@ along with Octave; see the file COPYING.
 #include "fCmplxHESS.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgebal, CGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, FloatComplex*, const octave_idx_type&,
-			     octave_idx_type&, octave_idx_type&, float*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, FloatComplex*, const octave_idx_type&,
+                             octave_idx_type&, octave_idx_type&, float*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
  
   F77_RET_T
   F77_FUNC (cgehrd, CGEHRD) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     FloatComplex*, const octave_idx_type&, FloatComplex*,
-			     FloatComplex*, const octave_idx_type&, octave_idx_type&);
+                             FloatComplex*, const octave_idx_type&, FloatComplex*,
+                             FloatComplex*, const octave_idx_type&, octave_idx_type&);
  
   F77_RET_T
   F77_FUNC (cunghr, CUNGHR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     FloatComplex*, const octave_idx_type&, FloatComplex*,
-			     FloatComplex*, const octave_idx_type&, octave_idx_type&);
+                             FloatComplex*, const octave_idx_type&, FloatComplex*,
+                             FloatComplex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cgebak, CGEBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, float*,
-			     const octave_idx_type&, FloatComplex*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, float*,
+                             const octave_idx_type&, FloatComplex*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 octave_idx_type
 FloatComplexHESS::init (const FloatComplexMatrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
-	("FloatComplexHESS requires square matrix");
+        ("FloatComplexHESS requires square matrix");
       return -1;
     }
 
   char job = 'N';
   char side = 'R';
 
   octave_idx_type n = a_nc;
   octave_idx_type lwork = 32 * n;
@@ -80,42 +80,42 @@ FloatComplexHESS::init (const FloatCompl
 
   hess_mat = a;
   FloatComplex *h = hess_mat.fortran_vec ();
 
   Array<float> scale (n);
   float *pscale = scale.fortran_vec ();
 
   F77_XFCN (cgebal, CGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     n, h, n, ilo, ihi, pscale, info
-			     F77_CHAR_ARG_LEN (1)));
+                             n, h, n, ilo, ihi, pscale, info
+                             F77_CHAR_ARG_LEN (1)));
 
   Array<FloatComplex> tau (n-1);
   FloatComplex *ptau = tau.fortran_vec ();
 
   Array<FloatComplex> work (lwork);
   FloatComplex *pwork = work.fortran_vec ();
 
   F77_XFCN (cgehrd, CGEHRD, (n, ilo, ihi, h, n, ptau, pwork, lwork, info));
 
   unitary_hess_mat = hess_mat;
   FloatComplex *z = unitary_hess_mat.fortran_vec ();
 
   F77_XFCN (cunghr, CUNGHR, (n, ilo, ihi, z, n, ptau, pwork,
-			     lwork, info));
+                             lwork, info));
 
   F77_XFCN (cgebak, CGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 (&side, 1),
-			     n, ilo, ihi, pscale, n, z, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&side, 1),
+                             n, ilo, ihi, pscale, n, z, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   // If someone thinks of a more graceful way of
   // doing this (or faster for that matter :-)),
   // please let me know!
 
   if (n > 2)
     for (octave_idx_type j = 0; j < a_nc; j++)
       for (octave_idx_type i = j+2; i < a_nr; i++)
-	hess_mat.elem (i, j) = 0;
+        hess_mat.elem (i, j) = 0;
 
   return info;
 }
diff --git a/liboctave/fCmplxLU.cc b/liboctave/fCmplxLU.cc
--- a/liboctave/fCmplxLU.cc
+++ b/liboctave/fCmplxLU.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 template class base_lu <FloatComplexMatrix>;
 
 // Define the constructor for this particular derivation.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgetrf, CGETRF) (const octave_idx_type&, const octave_idx_type&, FloatComplex*,
-			     const octave_idx_type&, octave_idx_type*, octave_idx_type&);
+                             const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 
 #ifdef HAVE_QRUPDATE_LUU
   F77_RET_T
   F77_FUNC (clu1up, CLU1UP) (const octave_idx_type&, const octave_idx_type&,
                              FloatComplex *, const octave_idx_type&,
                              FloatComplex *, const octave_idx_type&,
                              FloatComplex *, FloatComplex *);
 
diff --git a/liboctave/fCmplxQR.cc b/liboctave/fCmplxQR.cc
--- a/liboctave/fCmplxQR.cc
+++ b/liboctave/fCmplxQR.cc
@@ -37,23 +37,23 @@ along with Octave; see the file COPYING.
 #include "base-qr.cc"
 
 template class base_qr<FloatComplexMatrix>;
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgeqrf, CGEQRF) (const octave_idx_type&, const octave_idx_type&, FloatComplex*,
-			     const octave_idx_type&, FloatComplex*, FloatComplex*,
-			     const octave_idx_type&, octave_idx_type&); 
+                             const octave_idx_type&, FloatComplex*, FloatComplex*,
+                             const octave_idx_type&, octave_idx_type&); 
 
   F77_RET_T
   F77_FUNC (cungqr, CUNGQR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     FloatComplex*, const octave_idx_type&, FloatComplex*,
-			     FloatComplex*, const octave_idx_type&, octave_idx_type&);
+                             FloatComplex*, const octave_idx_type&, FloatComplex*,
+                             FloatComplex*, const octave_idx_type&, octave_idx_type&);
 
 #ifdef HAVE_QRUPDATE
 
   F77_RET_T
   F77_FUNC (cqr1up, CQR1UP) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
                              FloatComplex*, const octave_idx_type&, FloatComplex*, const octave_idx_type&,
                              FloatComplex*, FloatComplex*, FloatComplex*, float*);
 
@@ -126,21 +126,21 @@ void FloatComplexQR::form (octave_idx_ty
                            FloatComplex *tau, qr_type_t qr_type)
 {
   octave_idx_type m = afact.rows (), min_mn = std::min (m, n);
   octave_idx_type info;
 
   if (qr_type == qr_type_raw)
     {
       for (octave_idx_type j = 0; j < min_mn; j++)
-	{
-	  octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
-	  for (octave_idx_type i = limit + 1; i < m; i++)
-	    afact.elem (i, j) *= tau[j];
-	}
+        {
+          octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
+          for (octave_idx_type i = limit + 1; i < m; i++)
+            afact.elem (i, j) *= tau[j];
+        }
 
       r = afact;
     }
   else
     {
       // Attempt to minimize copying.
       if (m >= n)
         {
@@ -177,17 +177,17 @@ void FloatComplexQR::form (octave_idx_ty
           octave_idx_type k = q.columns ();
           // workspace query.
           FloatComplex clwork;
           F77_XFCN (cungqr, CUNGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      &clwork, -1, info));
 
           // allocate buffer and do the job.
           octave_idx_type lwork = clwork.real ();
-	  lwork = std::max (lwork, static_cast<octave_idx_type> (1));
+          lwork = std::max (lwork, static_cast<octave_idx_type> (1));
           OCTAVE_LOCAL_BUFFER (FloatComplex, work, lwork);
           F77_XFCN (cungqr, CUNGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      work, lwork, info));
         }
     }
 }
 
 #ifdef HAVE_QRUPDATE
@@ -295,17 +295,17 @@ FloatComplexQR::insert_col (const FloatC
       else
         {
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (float, rw, kmax);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
-	  octave_idx_type ii = i;
+          octave_idx_type ii = i;
           F77_XFCN (cqrinc, CQRINC, (m, n + ii, std::min (kmax, k + ii), 
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1, 
                                      u.column (jsi(i)).data (), rw));
         }
     }
 }
 
@@ -317,17 +317,17 @@ FloatComplexQR::delete_col (octave_idx_t
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1) 
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrdec, CQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
-				 r.fortran_vec (), r.rows (), j + 1, rw));
+                                 r.fortran_vec (), r.rows (), j + 1, rw));
 
       if (k < m)
         {
           q.resize (m, k-1);
           r.resize (k-1, n-1);
         }
       else
         {
@@ -354,17 +354,17 @@ FloatComplexQR::delete_col (const Array<
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
-	  octave_idx_type ii = i;
+          octave_idx_type ii = i;
           F77_XFCN (cqrdec, CQRDEC, (m, n - ii, k == m ? k : k - ii, 
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1, rw));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
@@ -390,17 +390,17 @@ FloatComplexQR::insert_row (const FloatC
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       FloatComplexRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrinr, CQRINR, (m, n, q.fortran_vec (), q.rows (),
-				 r.fortran_vec (), r.rows (), 
+                                 r.fortran_vec (), r.rows (), 
                                  j + 1, utmp.fortran_vec (), rw));
 
     }
 }
 
 void
 FloatComplexQR::delete_row (octave_idx_type j)
 {
@@ -411,17 +411,17 @@ FloatComplexQR::delete_row (octave_idx_t
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
   else if (j < 0 || j > m-1) 
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       OCTAVE_LOCAL_BUFFER (float, rw, m);
       F77_XFCN (cqrder, CQRDER, (m, n, q.fortran_vec (), q.rows (),
-				 r.fortran_vec (), r.rows (), j + 1,
+                                 r.fortran_vec (), r.rows (), j + 1,
                                  w, rw));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 }
 
 void
diff --git a/liboctave/fCmplxQRP.cc b/liboctave/fCmplxQRP.cc
--- a/liboctave/fCmplxQRP.cc
+++ b/liboctave/fCmplxQRP.cc
@@ -31,18 +31,18 @@ along with Octave; see the file COPYING.
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgeqp3, CGEQP3) (const octave_idx_type&, const octave_idx_type&, FloatComplex*,
-			     const octave_idx_type&, octave_idx_type*, FloatComplex*, FloatComplex*,
-			     const octave_idx_type&, float*, octave_idx_type&);
+                             const octave_idx_type&, octave_idx_type*, FloatComplex*, FloatComplex*,
+                             const octave_idx_type&, float*, octave_idx_type&);
 }
 
 // It would be best to share some of this code with FloatComplexQR class...
 
 FloatComplexQRP::FloatComplexQRP (const FloatComplexMatrix& a, qr_type_t qr_type)
   : FloatComplexQR (), p ()
 {
   init (a, qr_type);
diff --git a/liboctave/fCmplxSCHUR.cc b/liboctave/fCmplxSCHUR.cc
--- a/liboctave/fCmplxSCHUR.cc
+++ b/liboctave/fCmplxSCHUR.cc
@@ -28,51 +28,51 @@ along with Octave; see the file COPYING.
 #include "fCmplxSCHUR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgeesx, CGEESX) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     FloatComplexSCHUR::select_function,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, FloatComplex*, const octave_idx_type&, octave_idx_type&,
-			     FloatComplex*, FloatComplex*, const octave_idx_type&, float&,
-			     float&, FloatComplex*, const octave_idx_type&, float*, octave_idx_type*,
-			     octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             FloatComplexSCHUR::select_function,
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, FloatComplex*, const octave_idx_type&, octave_idx_type&,
+                             FloatComplex*, FloatComplex*, const octave_idx_type&, float&,
+                             float&, FloatComplex*, const octave_idx_type&, float*, octave_idx_type*,
+                             octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 static octave_idx_type
 select_ana (const FloatComplex& a)
 {
   return a.real () < 0.0;
 }
 
 static octave_idx_type
 select_dig (const FloatComplex& a)
 {
   return (abs (a) < 1.0);
 }
 
 octave_idx_type
 FloatComplexSCHUR::init (const FloatComplexMatrix& a, const std::string& ord, 
-		    bool calc_unitary)
+                    bool calc_unitary)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
-	("FloatComplexSCHUR requires square matrix");
+        ("FloatComplexSCHUR requires square matrix");
       return -1;
     }
 
   // Workspace requirements may need to be fixed if any of the
   // following change.
 
   char jobvs;
   char sense = 'N';
@@ -118,19 +118,19 @@ FloatComplexSCHUR::init (const FloatComp
   Array<FloatComplex> work (lwork);
   FloatComplex *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for non-ordered Schur.
   Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
   F77_XFCN (cgeesx, CGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
-			     F77_CONST_CHAR_ARG2 (&sort, 1),
-			     selector,
-			     F77_CONST_CHAR_ARG2 (&sense, 1),
-			     n, s, n, sdim, pw, q, n, rconde, rcondv,
-			     pwork, lwork, prwork, pbwork, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&sort, 1),
+                             selector,
+                             F77_CONST_CHAR_ARG2 (&sense, 1),
+                             n, s, n, sdim, pw, q, n, rconde, rcondv,
+                             pwork, lwork, prwork, pbwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
diff --git a/liboctave/fCmplxSVD.cc b/liboctave/fCmplxSVD.cc
--- a/liboctave/fCmplxSVD.cc
+++ b/liboctave/fCmplxSVD.cc
@@ -28,45 +28,45 @@ along with Octave; see the file COPYING.
 #include "fCmplxSVD.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgesvd, CGESVD) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, FloatComplex*,
-			     const octave_idx_type&, float*, FloatComplex*, const octave_idx_type&,
-			     FloatComplex*, const octave_idx_type&, FloatComplex*, const octave_idx_type&,
-			     float*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, float*, FloatComplex*, const octave_idx_type&,
+                             FloatComplex*, const octave_idx_type&, FloatComplex*, const octave_idx_type&,
+                             float*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 FloatComplexMatrix
 FloatComplexSVD::left_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
     {
       (*current_liboctave_error_handler)
-	("FloatComplexSVD: U not computed because type == SVD::sigma_only");
+        ("FloatComplexSVD: U not computed because type == SVD::sigma_only");
       return FloatComplexMatrix ();
     }
   else
     return left_sm;
 }
 
 FloatComplexMatrix
 FloatComplexSVD::right_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
     {
       (*current_liboctave_error_handler)
-	("FloatComplexSVD: V not computed because type == SVD::sigma_only");
+        ("FloatComplexSVD: V not computed because type == SVD::sigma_only");
       return FloatComplexMatrix ();
     }
   else
     return right_sm;
 }
 
 octave_idx_type
 FloatComplexSVD::init (const FloatComplexMatrix& a, SVD::type svd_type)
@@ -140,31 +140,31 @@ FloatComplexSVD::init (const FloatComple
   octave_idx_type lwork = -1;
 
   Array<FloatComplex> work (1);
 
   octave_idx_type one = 1;
   octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
 
   F77_XFCN (cgesvd, CGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
-			     F77_CONST_CHAR_ARG2 (&jobv, 1),
-			     m, n, tmp_data, m1, s_vec, u, m1, vt,
-			     nrow_vt1, work.fortran_vec (), lwork,
-			     rwork.fortran_vec (), info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&jobv, 1),
+                             m, n, tmp_data, m1, s_vec, u, m1, vt,
+                             nrow_vt1, work.fortran_vec (), lwork,
+                             rwork.fortran_vec (), info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   lwork = static_cast<octave_idx_type> (work(0).real ());
   work.resize (lwork);
 
   F77_XFCN (cgesvd, CGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
-			     F77_CONST_CHAR_ARG2 (&jobv, 1),
-			     m, n, tmp_data, m1, s_vec, u, m1, vt,
-			     nrow_vt1, work.fortran_vec (), lwork,
-			     rwork.fortran_vec (), info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&jobv, 1),
+                             m, n, tmp_data, m1, s_vec, u, m1, vt,
+                             nrow_vt1, work.fortran_vec (), lwork,
+                             rwork.fortran_vec (), info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm = right_sm.hermitian ();
 
   return info;
 }
diff --git a/liboctave/fColVector.cc b/liboctave/fColVector.cc
--- a/liboctave/fColVector.cc
+++ b/liboctave/fColVector.cc
@@ -37,21 +37,21 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sgemv, SGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const float&,
-			   const float*, const octave_idx_type&, const float*,
-			   const octave_idx_type&, const float&, float*,
-			   const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, const octave_idx_type&, const float&,
+                           const float*, const octave_idx_type&, const float*,
+                           const octave_idx_type&, const float&, float*,
+                           const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL);
 }
 
 // Column Vector class.
 
 bool
 FloatColumnVector::operator == (const FloatColumnVector& a) const
 {
   octave_idx_type len = length ();
@@ -77,33 +77,33 @@ FloatColumnVector::insert (const FloatCo
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i) = a.elem (i);
+        xelem (r+i) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatColumnVector&
 FloatColumnVector::fill (float val)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatColumnVector&
 FloatColumnVector::fill (float val, octave_idx_type r1, octave_idx_type r2)
 {
@@ -117,17 +117,17 @@ FloatColumnVector::fill (float val, octa
 
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
 
   if (r2 >= r1)
     {
       make_unique ();
 
       for (octave_idx_type i = r1; i <= r2; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatColumnVector
 FloatColumnVector::stack (const FloatColumnVector& a) const
 {
@@ -237,27 +237,27 @@ operator * (const FloatDiagMatrix& m, co
 
   octave_idx_type a_len = a.length ();
 
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       if (nr == 0 || nc == 0)
-	retval.resize (nr, 0.0);
+        retval.resize (nr, 0.0);
       else
-	{
-	  retval.resize (nr);
+        {
+          retval.resize (nr);
 
-	  for (octave_idx_type i = 0; i < a_len; i++)
-	    retval.elem (i) = a.elem (i) * m.elem (i, i);
+          for (octave_idx_type i = 0; i < a_len; i++)
+            retval.elem (i) = a.elem (i) * m.elem (i, i);
 
-	  for (octave_idx_type i = a_len; i < nr; i++)
-	    retval.elem (i) = 0.0;
-	}
+          for (octave_idx_type i = a_len; i < nr; i++)
+            retval.elem (i) = 0.0;
+        }
     }
 
   return retval;
 }
 
 // other operations
 
 float
diff --git a/liboctave/fDiagMatrix.cc b/liboctave/fDiagMatrix.cc
--- a/liboctave/fDiagMatrix.cc
+++ b/liboctave/fDiagMatrix.cc
@@ -150,28 +150,28 @@ FloatDiagMatrix::abs (void) const
 
 FloatDiagMatrix
 real (const FloatComplexDiagMatrix& a)
 {
   FloatDiagMatrix retval;
   octave_idx_type a_len = a.length ();
   if (a_len > 0)
     retval = FloatDiagMatrix (mx_inline_real_dup (a.data (), a_len), a.rows (),
-			 a.cols ());
+                         a.cols ());
   return retval;
 }
 
 FloatDiagMatrix
 imag (const FloatComplexDiagMatrix& a)
 {
   FloatDiagMatrix retval;
   octave_idx_type a_len = a.length ();
   if (a_len > 0)
     retval = FloatDiagMatrix (mx_inline_imag_dup (a.data (), a_len), a.rows (),
-			 a.cols ());
+                         a.cols ());
   return retval;
 }
 
 FloatMatrix
 FloatDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
@@ -288,22 +288,22 @@ FloatDiagMatrix::inverse (octave_idx_typ
     }
 
   FloatDiagMatrix retval (r, c);
 
   info = 0;
   for (octave_idx_type i = 0; i < len; i++)
     {
       if (elem (i, i) == 0.0)
-	{
-	  info = -1;
-	  return *this;
-	}
+        {
+          info = -1;
+          return *this;
+        }
       else
-	retval.elem (i, i) = 1.0 / elem (i, i);
+        retval.elem (i, i) = 1.0 / elem (i, i);
     }
 
   return retval;
 }
 
 FloatDiagMatrix
 FloatDiagMatrix::pseudo_inverse (void) const
 {
@@ -384,18 +384,18 @@ FloatDiagMatrix::rcond (void) const
 std::ostream&
 operator << (std::ostream& os, const FloatDiagMatrix& a)
 {
 //  int field_width = os.precision () + 7;
 
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
-	{
-	  if (i == j)
-	    os << " " /* setw (field_width) */ << a.elem (i, i);
-	  else
-	    os << " " /* setw (field_width) */ << 0.0;
-	}
+        {
+          if (i == j)
+            os << " " /* setw (field_width) */ << a.elem (i, i);
+          else
+            os << " " /* setw (field_width) */ << 0.0;
+        }
       os << "\n";
     }
   return os;
 }
diff --git a/liboctave/fEIG.cc b/liboctave/fEIG.cc
--- a/liboctave/fEIG.cc
+++ b/liboctave/fEIG.cc
@@ -29,118 +29,118 @@ along with Octave; see the file COPYING.
 #include "fColVector.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sgeev, SGEEV) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, float*, const octave_idx_type&, float*,
-			   float*, float*, const octave_idx_type&, float*,
-			   const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, float*, const octave_idx_type&, float*,
+                           float*, float*, const octave_idx_type&, float*,
+                           const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cgeev, CGEEV) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, FloatComplex*, const octave_idx_type&, FloatComplex*,
-			   FloatComplex*, const octave_idx_type&, FloatComplex*, const octave_idx_type&,
-			   FloatComplex*, const octave_idx_type&, float*, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, FloatComplex*, const octave_idx_type&, FloatComplex*,
+                           FloatComplex*, const octave_idx_type&, FloatComplex*, const octave_idx_type&,
+                           FloatComplex*, const octave_idx_type&, float*, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ssyev, SSYEV) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, float*, const octave_idx_type&, float*,
-			   float*, const octave_idx_type&, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, float*, const octave_idx_type&, float*,
+                           float*, const octave_idx_type&, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cheev, CHEEV) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, FloatComplex*, const octave_idx_type&, float*,
-			   FloatComplex*, const octave_idx_type&, float*, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, FloatComplex*, const octave_idx_type&, float*,
+                           FloatComplex*, const octave_idx_type&, float*, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (spotrf, SPOTRF) (F77_CONST_CHAR_ARG_DECL, 
-			   const octave_idx_type&, 
-			   float*, const octave_idx_type&,
-			   octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, 
+                           float*, const octave_idx_type&,
+                           octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cpotrf, CPOTRF) (F77_CONST_CHAR_ARG_DECL, 
-			   const octave_idx_type&, 
-			   FloatComplex*, const octave_idx_type&,
-			   octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, 
+                           FloatComplex*, const octave_idx_type&,
+                           octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sggev, SGGEV) (F77_CONST_CHAR_ARG_DECL, 
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, 
-			   float*, const octave_idx_type&,
-			   float*, const octave_idx_type&,
-			   float*, float*, float*,
-			   float*, const octave_idx_type&, float*, const octave_idx_type&,
-			   float*, const octave_idx_type&, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, 
+                           float*, const octave_idx_type&,
+                           float*, const octave_idx_type&,
+                           float*, float*, float*,
+                           float*, const octave_idx_type&, float*, const octave_idx_type&,
+                           float*, const octave_idx_type&, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ssygv, SSYGV) (const octave_idx_type&,
-			   F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, 
-			   float*, const octave_idx_type&,
-			   float*, const octave_idx_type&,
-			   float*, float*, const octave_idx_type&, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, 
+                           float*, const octave_idx_type&,
+                           float*, const octave_idx_type&,
+                           float*, float*, const octave_idx_type&, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cggev, CGGEV) (F77_CONST_CHAR_ARG_DECL, 
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, 
-			   FloatComplex*, const octave_idx_type&,
-			   FloatComplex*, const octave_idx_type&,
-			   FloatComplex*, FloatComplex*,
-			   FloatComplex*, const octave_idx_type&, FloatComplex*, const octave_idx_type&,
-			   FloatComplex*, const octave_idx_type&, float*, octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, 
+                           FloatComplex*, const octave_idx_type&,
+                           FloatComplex*, const octave_idx_type&,
+                           FloatComplex*, FloatComplex*,
+                           FloatComplex*, const octave_idx_type&, FloatComplex*, const octave_idx_type&,
+                           FloatComplex*, const octave_idx_type&, float*, octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (chegv, CHEGV) (const octave_idx_type&,
-			   F77_CONST_CHAR_ARG_DECL, 
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, 
-			   FloatComplex*, const octave_idx_type&,
-			   FloatComplex*, const octave_idx_type&,
-			   float*, FloatComplex*, const octave_idx_type&, float*, 
-			   octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL, 
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, 
+                           FloatComplex*, const octave_idx_type&,
+                           FloatComplex*, const octave_idx_type&,
+                           float*, FloatComplex*, const octave_idx_type&, float*, 
+                           octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 }
 
 octave_idx_type
 FloatEIG::init (const FloatMatrix& a, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan ())
     {
       (*current_liboctave_error_handler)
-	("EIG: matrix contains Inf or NaN values");
+        ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
   if (a.is_symmetric ())
     return symmetric_init (a, calc_ev);
 
   octave_idx_type n = a.rows ();
 
@@ -167,79 +167,79 @@ FloatEIG::init (const FloatMatrix& a, bo
 
   octave_idx_type lwork = -1;
   float dummy_work;
 
   float *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (sgeev, SGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			   F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   n, tmp_data, n, pwr, pwi, dummy,
-			   idummy, pvr, n, &dummy_work, lwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, tmp_data, n, pwr, pwi, dummy,
+                           idummy, pvr, n, &dummy_work, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<float> work (lwork);
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (sgeev, SGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			       F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       n, tmp_data, n, pwr, pwi, dummy,
-			       idummy, pvr, n, pwork, lwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                               n, tmp_data, n, pwr, pwi, dummy,
+                               idummy, pvr, n, pwork, lwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in sgeev");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in sgeev");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("sgeev failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("sgeev failed to converge");
+          return info;
+        }
 
       lambda.resize (n);
       v.resize (nvr, nvr);
 
       for (octave_idx_type j = 0; j < n; j++)
-	{
-	  if (wi.elem (j) == 0.0)
-	    {
-	      lambda.elem (j) = FloatComplex (wr.elem (j));
-	      for (octave_idx_type i = 0; i < nvr; i++)
-		v.elem (i, j) = vr.elem (i, j);
-	    }
-	  else
-	    {
-	      if (j+1 >= n)
-		{
-		  (*current_liboctave_error_handler) ("EIG: internal error");
-		  return -1;
-		}
+        {
+          if (wi.elem (j) == 0.0)
+            {
+              lambda.elem (j) = FloatComplex (wr.elem (j));
+              for (octave_idx_type i = 0; i < nvr; i++)
+                v.elem (i, j) = vr.elem (i, j);
+            }
+          else
+            {
+              if (j+1 >= n)
+                {
+                  (*current_liboctave_error_handler) ("EIG: internal error");
+                  return -1;
+                }
 
-	      lambda.elem(j) = FloatComplex (wr.elem(j), wi.elem(j));
-	      lambda.elem(j+1) = FloatComplex (wr.elem(j+1), wi.elem(j+1));
+              lambda.elem(j) = FloatComplex (wr.elem(j), wi.elem(j));
+              lambda.elem(j+1) = FloatComplex (wr.elem(j+1), wi.elem(j+1));
 
-	      for (octave_idx_type i = 0; i < nvr; i++)
-		{
-		  float real_part = vr.elem (i, j);
-		  float imag_part = vr.elem (i, j+1);
-		  v.elem (i, j) = FloatComplex (real_part, imag_part);
-		  v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
-		}
-	      j++;
-	    }
-	}
+              for (octave_idx_type i = 0; i < nvr; i++)
+                {
+                  float real_part = vr.elem (i, j);
+                  float imag_part = vr.elem (i, j+1);
+                  v.elem (i, j) = FloatComplex (real_part, imag_part);
+                  v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
+                }
+              j++;
+            }
+        }
     }
   else
     (*current_liboctave_error_handler) ("sgeev workspace query failed");
 
   return info;
 }
 
 octave_idx_type 
@@ -260,61 +260,61 @@ FloatEIG::symmetric_init (const FloatMat
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   float dummy_work;
 
   F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   F77_CONST_CHAR_ARG2 ("U", 1),
-			   n, tmp_data, n, pwr, &dummy_work, lwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, tmp_data, n, pwr, &dummy_work, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<float> work (lwork);
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       F77_CONST_CHAR_ARG2 ("U", 1),
-			       n, tmp_data, n, pwr, pwork, lwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 ("U", 1),
+                               n, tmp_data, n, pwr, pwork, lwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in ssyev");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in ssyev");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("ssyev failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("ssyev failed to converge");
+          return info;
+        }
 
       lambda = FloatComplexColumnVector (wr);
       v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
     }
   else
     (*current_liboctave_error_handler) ("ssyev workspace query failed");
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::init (const FloatComplexMatrix& a, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan ())
     {
       (*current_liboctave_error_handler)
-	("EIG: matrix contains Inf or NaN values");
+        ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
   if (a.is_hermitian ())
     return hermitian_init (a, calc_ev);
 
   octave_idx_type n = a.rows ();
 
@@ -342,46 +342,46 @@ FloatEIG::init (const FloatComplexMatrix
   octave_idx_type lrwork = 2*n;
   Array<float> rwork (lrwork);
   float *prwork = rwork.fortran_vec ();
 
   FloatComplex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			   F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   n, tmp_data, n, pw, dummy, idummy,
-			   pv, n, &dummy_work, lwork, prwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, tmp_data, n, pw, dummy, idummy,
+                           pv, n, &dummy_work, lwork, prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<FloatComplex> work (lwork);
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			       F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       n, tmp_data, n, pw, dummy, idummy,
-			       pv, n, pwork, lwork, prwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                               n, tmp_data, n, pw, dummy, idummy,
+                               pv, n, pwork, lwork, prwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in cgeev");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in cgeev");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("cgeev failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("cgeev failed to converge");
+          return info;
+        }
 
       lambda = w;
       v = vtmp;
     }
   else
     (*current_liboctave_error_handler) ("cgeev workspace query failed");
 
   return info;
@@ -409,62 +409,62 @@ FloatEIG::hermitian_init (const FloatCom
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<float> rwork (lrwork);
   float *prwork = rwork.fortran_vec ();
 
   F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   F77_CONST_CHAR_ARG2 ("U", 1),
-			   n, tmp_data, n, pwr, &dummy_work, lwork,
-			   prwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, tmp_data, n, pwr, &dummy_work, lwork,
+                           prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<FloatComplex> work (lwork);
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       F77_CONST_CHAR_ARG2 ("U", 1),
-			       n, tmp_data, n, pwr, pwork, lwork, prwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 ("U", 1),
+                               n, tmp_data, n, pwr, pwork, lwork, prwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in cheev");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in cheev");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("cheev failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("cheev failed to converge");
+          return info;
+        }
 
       lambda = FloatComplexColumnVector (wr);
       v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
     }
   else
     (*current_liboctave_error_handler) ("cheev workspace query failed");
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::init (const FloatMatrix& a, const FloatMatrix& b, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     {
       (*current_liboctave_error_handler)
-	("EIG: matrix contains Inf or NaN values");
+        ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
     {
@@ -479,20 +479,20 @@ FloatEIG::init (const FloatMatrix& a, co
     }
 
   octave_idx_type info = 0;
 
   FloatMatrix tmp = b;
   float *tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-			     n, tmp_data, n, 
-			     info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             n, tmp_data, n, 
+                             info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (a.is_symmetric () && b.is_symmetric () && info == 0)
     return symmetric_init (a, b, calc_ev);
 
   FloatMatrix atmp = a;
   float *atmp_data = atmp.fortran_vec ();
 
   FloatMatrix btmp = b;
@@ -513,85 +513,85 @@ FloatEIG::init (const FloatMatrix& a, co
 
   octave_idx_type lwork = -1;
   float dummy_work;
 
   float *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			   F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   n, atmp_data, n, btmp_data, n, 
-			   par, pai, pbeta,
-			   dummy, idummy, pvr, n,
-			   &dummy_work, lwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, atmp_data, n, btmp_data, n, 
+                           par, pai, pbeta,
+                           dummy, idummy, pvr, n,
+                           &dummy_work, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<float> work (lwork);
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			       F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       n, atmp_data, n, btmp_data, n, 
-			       par, pai, pbeta,
-			       dummy, idummy, pvr, n,
-			       pwork, lwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                               n, atmp_data, n, btmp_data, n, 
+                               par, pai, pbeta,
+                               dummy, idummy, pvr, n,
+                               pwork, lwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in sggev");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in sggev");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("sggev failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("sggev failed to converge");
+          return info;
+        }
 
       lambda.resize (n);
       v.resize (nvr, nvr);
 
       for (octave_idx_type j = 0; j < n; j++)
-	{
-	  if (ai.elem (j) == 0.0)
-	    {
-	      lambda.elem (j) = FloatComplex (ar.elem (j) / beta.elem (j));
-	      for (octave_idx_type i = 0; i < nvr; i++)
-		v.elem (i, j) = vr.elem (i, j);
-	    }
-	  else
-	    {
-	      if (j+1 >= n)
-		{
-		  (*current_liboctave_error_handler) ("EIG: internal error");
-		  return -1;
-		}
+        {
+          if (ai.elem (j) == 0.0)
+            {
+              lambda.elem (j) = FloatComplex (ar.elem (j) / beta.elem (j));
+              for (octave_idx_type i = 0; i < nvr; i++)
+                v.elem (i, j) = vr.elem (i, j);
+            }
+          else
+            {
+              if (j+1 >= n)
+                {
+                  (*current_liboctave_error_handler) ("EIG: internal error");
+                  return -1;
+                }
 
-	      lambda.elem(j) = FloatComplex (ar.elem(j) / beta.elem (j), 
-	                                     ai.elem(j) / beta.elem (j));
-	      lambda.elem(j+1) = FloatComplex (ar.elem(j+1) / beta.elem (j+1), 
-	                                       ai.elem(j+1) / beta.elem (j+1));
+              lambda.elem(j) = FloatComplex (ar.elem(j) / beta.elem (j), 
+                                             ai.elem(j) / beta.elem (j));
+              lambda.elem(j+1) = FloatComplex (ar.elem(j+1) / beta.elem (j+1), 
+                                               ai.elem(j+1) / beta.elem (j+1));
 
-	      for (octave_idx_type i = 0; i < nvr; i++)
-		{
-		  float real_part = vr.elem (i, j);
-		  float imag_part = vr.elem (i, j+1);
-		  v.elem (i, j) = FloatComplex (real_part, imag_part);
-		  v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
-		}
-	      j++;
-	    }
-	}
+              for (octave_idx_type i = 0; i < nvr; i++)
+                {
+                  float real_part = vr.elem (i, j);
+                  float imag_part = vr.elem (i, j+1);
+                  v.elem (i, j) = FloatComplex (real_part, imag_part);
+                  v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
+                }
+              j++;
+            }
+        }
     }
   else
     (*current_liboctave_error_handler) ("sggev workspace query failed");
 
   return info;
 }
 
 octave_idx_type 
@@ -622,65 +622,65 @@ FloatEIG::symmetric_init (const FloatMat
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   float dummy_work;
 
   F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   F77_CONST_CHAR_ARG2 ("U", 1),
-			   n, atmp_data, n, 
-			   btmp_data, n, 
-			   pwr, &dummy_work, lwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, atmp_data, n, 
+                           btmp_data, n, 
+                           pwr, &dummy_work, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<float> work (lwork);
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       F77_CONST_CHAR_ARG2 ("U", 1),
-			       n, atmp_data, n, 
-			       btmp_data, n, 
-			       pwr, pwork, lwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 ("U", 1),
+                               n, atmp_data, n, 
+                               btmp_data, n, 
+                               pwr, pwork, lwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in ssygv");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in ssygv");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("ssygv failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("ssygv failed to converge");
+          return info;
+        }
 
       lambda = FloatComplexColumnVector (wr);
       v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
     }
   else
     (*current_liboctave_error_handler) ("ssygv workspace query failed");
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::init (const FloatComplexMatrix& a, const FloatComplexMatrix& b, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     {
       (*current_liboctave_error_handler)
-	("EIG: matrix contains Inf or NaN values");
+        ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols())
     {
@@ -695,20 +695,20 @@ FloatEIG::init (const FloatComplexMatrix
     }
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix tmp = b;
   FloatComplex *tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-			     n, tmp_data, n, 
-			     info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             n, tmp_data, n, 
+                             info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (a.is_hermitian () && b.is_hermitian () && info == 0)
     return hermitian_init (a, calc_ev);
 
   FloatComplexMatrix atmp = a;
   FloatComplex *atmp_data = atmp.fortran_vec ();
 
   FloatComplexMatrix btmp = b;
@@ -730,48 +730,48 @@ FloatEIG::init (const FloatComplexMatrix
   octave_idx_type lrwork = 8*n;
   Array<float> rwork (lrwork);
   float *prwork = rwork.fortran_vec ();
 
   FloatComplex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			   F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   n, atmp_data, n, btmp_data, n, 
-			   palpha, pbeta, dummy, idummy,
-			   pv, n, &dummy_work, lwork, prwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, atmp_data, n, btmp_data, n, 
+                           palpha, pbeta, dummy, idummy,
+                           pv, n, &dummy_work, lwork, prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<FloatComplex> work (lwork);
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-			       F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       n, atmp_data, n, btmp_data, n, 
-			       palpha, pbeta, dummy, idummy,
-			       pv, n, pwork, lwork, prwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                               n, atmp_data, n, btmp_data, n, 
+                               palpha, pbeta, dummy, idummy,
+                               pv, n, pwork, lwork, prwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
       
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in cggev");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in cggev");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("cggev failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("cggev failed to converge");
+          return info;
+        }
 
       lambda.resize (n);
 
       for (octave_idx_type j = 0; j < n; j++)
         lambda.elem (j) = alpha.elem (j) / beta.elem(j);
 
       v = vtmp;
     }
@@ -813,49 +813,49 @@ FloatEIG::hermitian_init (const FloatCom
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<float> rwork (lrwork);
   float *prwork = rwork.fortran_vec ();
 
   F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			   F77_CONST_CHAR_ARG2 ("U", 1),
-			   n, atmp_data, n, 
-			   btmp_data, n,
-			   pwr, &dummy_work, lwork,
-			   prwork, info
-			   F77_CHAR_ARG_LEN (1)
-			   F77_CHAR_ARG_LEN (1)));
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, atmp_data, n, 
+                           btmp_data, n,
+                           pwr, &dummy_work, lwork,
+                           prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<FloatComplex> work (lwork);
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-			       F77_CONST_CHAR_ARG2 ("U", 1),
-			       n, atmp_data, n, 
-			       btmp_data, n, 
-			       pwr, pwork, lwork, prwork, info
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 ("U", 1),
+                               n, atmp_data, n, 
+                               btmp_data, n, 
+                               pwr, pwork, lwork, prwork, info
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
-	{
-	  (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
+          return info;
+        }
 
       if (info > 0)
-	{
-	  (*current_liboctave_error_handler) ("zhegv failed to converge");
-	  return info;
-	}
+        {
+          (*current_liboctave_error_handler) ("zhegv failed to converge");
+          return info;
+        }
 
       lambda = FloatComplexColumnVector (wr);
       v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
     }
   else
     (*current_liboctave_error_handler) ("zhegv workspace query failed");
 
   return info;
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -58,161 +58,161 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (xilaenv, XILAENV) (const octave_idx_type&, F77_CONST_CHAR_ARG_DECL,
-			       F77_CONST_CHAR_ARG_DECL,
-			       const octave_idx_type&, const octave_idx_type&,
-			       const octave_idx_type&, const octave_idx_type&,
-			       octave_idx_type&
-			       F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
+                               F77_CONST_CHAR_ARG_DECL,
+                               const octave_idx_type&, const octave_idx_type&,
+                               const octave_idx_type&, const octave_idx_type&,
+                               octave_idx_type&
+                               F77_CHAR_ARG_LEN_DECL F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgebal, SGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&,
-			     octave_idx_type&, float*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&,
+                             octave_idx_type&, float*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgebak, SGEBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, float*,
-			     const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, float*,
+                             const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
 
   F77_RET_T
   F77_FUNC (sgemm, SGEMM) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			   const float&, const float*, const octave_idx_type&,
-			   const float*, const octave_idx_type&, const float&,
-			   float*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+                           const float&, const float*, const octave_idx_type&,
+                           const float*, const octave_idx_type&, const float&,
+                           float*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgemv, SGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const float&,
-			   const float*, const octave_idx_type&, const float*,
-			   const octave_idx_type&, const float&, float*,
-			   const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, const octave_idx_type&, const float&,
+                           const float*, const octave_idx_type&, const float*,
+                           const octave_idx_type&, const float&, float*,
+                           const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xsdot, XSDOT) (const octave_idx_type&, const float*, const octave_idx_type&,
-			   const float*, const octave_idx_type&, float&);
+                           const float*, const octave_idx_type&, float&);
 
   F77_RET_T
   F77_FUNC (ssyrk, SSYRK) (F77_CONST_CHAR_ARG_DECL,
-			   F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, 
-			   const float&, const float*, const octave_idx_type&,
-			   const float&, float*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CONST_CHAR_ARG_DECL,
+                           const octave_idx_type&, const octave_idx_type&, 
+                           const float&, const float*, const octave_idx_type&,
+                           const float&, float*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL
+                           F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgetrf, SGETRF) (const octave_idx_type&, const octave_idx_type&, float*, const octave_idx_type&,
-		      octave_idx_type*, octave_idx_type&);
+                      octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (sgetrs, SGETRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, const octave_idx_type&, 
-			     const float*, const octave_idx_type&,
-			     const octave_idx_type*, float*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const float*, const octave_idx_type&,
+                             const octave_idx_type*, float*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgetri, SGETRI) (const octave_idx_type&, float*, const octave_idx_type&, const octave_idx_type*,
-			     float*, const octave_idx_type&, octave_idx_type&);
+                             float*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (sgecon, SGECON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, float*, 
-			     const octave_idx_type&, const float&, float&, 
-			     float*, octave_idx_type*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const float&, float&, 
+                             float*, octave_idx_type*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgelsy, SGELSY) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     float*, const octave_idx_type&, float*,
-			     const octave_idx_type&, octave_idx_type*, float&, octave_idx_type&,
-			     float*, const octave_idx_type&, octave_idx_type&);
+                             float*, const octave_idx_type&, float*,
+                             const octave_idx_type&, octave_idx_type*, float&, octave_idx_type&,
+                             float*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (sgelsd, SGELSD) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     float*, const octave_idx_type&, float*,
-			     const octave_idx_type&, float*, float&, octave_idx_type&,
-			     float*, const octave_idx_type&, octave_idx_type*,
-			     octave_idx_type&);
+                             float*, const octave_idx_type&, float*,
+                             const octave_idx_type&, float*, float&, octave_idx_type&,
+                             float*, const octave_idx_type&, octave_idx_type*,
+                             octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (spotrf, SPOTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     float *, const octave_idx_type&, 
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             float *, const octave_idx_type&, 
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (spocon, SPOCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     float*, const octave_idx_type&, const float&,
-			     float&, float*, octave_idx_type*,
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             float*, const octave_idx_type&, const float&,
+                             float&, float*, octave_idx_type*,
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (spotrs, SPOTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, const float*, 
-			     const octave_idx_type&, float*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const float*, 
+                             const octave_idx_type&, float*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (strtri, STRTRI) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
-			     const octave_idx_type&, const float*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, const float*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (strcon, STRCON) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
-			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const float*, const octave_idx_type&, float&,
-			     float*, octave_idx_type*, octave_idx_type& 
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+                             const float*, const octave_idx_type&, float&,
+                             float*, octave_idx_type*, octave_idx_type& 
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (strtrs, STRTRS) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
-			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
-			     const octave_idx_type&, const float*, 
-			     const octave_idx_type&, float*, 
-			     const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+                             const octave_idx_type&, const float*, 
+                             const octave_idx_type&, float*, 
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (slartg, SLARTG) (const float&, const float&, float&,
-			     float&, float&);
+                             float&, float&);
 
   F77_RET_T
   F77_FUNC (strsyl, STRSYL) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     const float*, const octave_idx_type&, const float*,
-			     const octave_idx_type&, const float*, const octave_idx_type&,
-			     float&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+                             const float*, const octave_idx_type&, const float*,
+                             const octave_idx_type&, const float*, const octave_idx_type&,
+                             float&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xslange, XSLANGE) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			       const octave_idx_type&, const float*,
-			       const octave_idx_type&, float*, float&
-			       F77_CHAR_ARG_LEN_DECL); 
+                               const octave_idx_type&, const float*,
+                               const octave_idx_type&, float*, float&
+                               F77_CHAR_ARG_LEN_DECL); 
 }
 
 // Matrix class.
 
 FloatMatrix::FloatMatrix (const FloatRowVector& rv)
   : MArray2<float> (Array2<float> (rv, 1, rv.length ()))
 {
 }
@@ -277,19 +277,19 @@ FloatMatrix::operator != (const FloatMat
 }
 
 bool
 FloatMatrix::is_symmetric (void) const
 {
   if (is_square () && rows () > 0)
     {
       for (octave_idx_type i = 0; i < rows (); i++)
-	for (octave_idx_type j = i+1; j < cols (); j++)
-	  if (elem (i, j) != elem (j, i))
-	    return false;
+        for (octave_idx_type j = i+1; j < cols (); j++)
+          if (elem (i, j) != elem (j, i))
+            return false;
 
       return true;
     }
 
   return false;
 }
 
 FloatMatrix&
@@ -310,17 +310,17 @@ FloatMatrix::insert (const FloatRowVecto
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r, c+i) = a.elem (i);
+        xelem (r, c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatMatrix&
 FloatMatrix::insert (const FloatColumnVector& a, octave_idx_type r, octave_idx_type c)
 {
@@ -332,17 +332,17 @@ FloatMatrix::insert (const FloatColumnVe
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i, c) = a.elem (i);
+        xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatMatrix&
 FloatMatrix::insert (const FloatDiagMatrix& a, octave_idx_type r, octave_idx_type c)
 {
@@ -359,35 +359,35 @@ FloatMatrix::insert (const FloatDiagMatr
 
   octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (r+i, c+i) = a.elem (i, i);
+        xelem (r+i, c+i) = a.elem (i, i);
     }
 
   return *this;
 }
 
 FloatMatrix&
 FloatMatrix::fill (float val)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       make_unique ();
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  xelem (i, j) = val;
+        for (octave_idx_type i = 0; i < nr; i++)
+          xelem (i, j) = val;
     }
 
   return *this;
 }
 
 FloatMatrix&
 FloatMatrix::fill (float val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
 {
@@ -404,18 +404,18 @@ FloatMatrix::fill (float val, octave_idx
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (r2 >= r1 && c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type j = c1; j <= c2; j++)
-	for (octave_idx_type i = r1; i <= r2; i++)
-	  xelem (i, j) = val;
+        for (octave_idx_type i = r1; i <= r2; i++)
+          xelem (i, j) = val;
     }
 
   return *this;
 }
 
 FloatMatrix
 FloatMatrix::append (const FloatMatrix& a) const
 {
@@ -491,17 +491,17 @@ FloatMatrix::append (const FloatDiagMatr
 FloatMatrix
 FloatMatrix::stack (const FloatMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return FloatMatrix ();
     }
 
   octave_idx_type nr_insert = nr;
   FloatMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -510,17 +510,17 @@ FloatMatrix::stack (const FloatMatrix& a
 FloatMatrix
 FloatMatrix::stack (const FloatRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return FloatMatrix ();
     }
 
   octave_idx_type nr_insert = nr;
   FloatMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -529,17 +529,17 @@ FloatMatrix::stack (const FloatRowVector
 FloatMatrix
 FloatMatrix::stack (const FloatColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return FloatMatrix ();
     }
 
   octave_idx_type nr_insert = nr;
   FloatMatrix retval (nr + a.length (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -548,17 +548,17 @@ FloatMatrix::stack (const FloatColumnVec
 FloatMatrix
 FloatMatrix::stack (const FloatDiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("column dimension mismatch for stack");
+        ("column dimension mismatch for stack");
       return FloatMatrix ();
     }
 
   octave_idx_type nr_insert = nr;
   FloatMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
@@ -636,17 +636,17 @@ FloatMatrix::inverse (octave_idx_type& i
 {
   float rcon;
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatMatrix
 FloatMatrix::inverse (octave_idx_type& info, float& rcon, int force,
-		 int calc_cond) const
+                 int calc_cond) const
 {
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, force, calc_cond);
 }
 
 FloatMatrix
 FloatMatrix::inverse (MatrixType& mattype) const
 {
@@ -659,17 +659,17 @@ FloatMatrix
 FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info) const
 {
   float rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatMatrix
 FloatMatrix::tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
-		  int force, int calc_cond) const
+                  int force, int calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -677,57 +677,57 @@ FloatMatrix::tinverse (MatrixType &matty
     {
       int typ = mattype.type ();
       char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
       char udiag = 'N';
       retval = *this;
       float *tmp_data = retval.fortran_vec ();
 
       F77_XFCN (strtri, STRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
-				 F77_CONST_CHAR_ARG2 (&udiag, 1),
-				 nr, tmp_data, nr, info 
-				 F77_CHAR_ARG_LEN (1)
-				 F77_CHAR_ARG_LEN (1)));
+                                 F77_CONST_CHAR_ARG2 (&udiag, 1),
+                                 nr, tmp_data, nr, info 
+                                 F77_CHAR_ARG_LEN (1)
+                                 F77_CHAR_ARG_LEN (1)));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0) 
-	info = -1;
+        info = -1;
       else if (calc_cond) 
-	{
-	  octave_idx_type dtrcon_info = 0;
-	  char job = '1';
-
-	  OCTAVE_LOCAL_BUFFER (float, work, 3 * nr);
-	  OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
-
-	  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     F77_CONST_CHAR_ARG2 (&uplo, 1),
-				     F77_CONST_CHAR_ARG2 (&udiag, 1),
-				     nr, tmp_data, nr, rcon, 
-				     work, iwork, dtrcon_info 
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (dtrcon_info != 0) 
-	    info = -1;
-	}
+        {
+          octave_idx_type dtrcon_info = 0;
+          char job = '1';
+
+          OCTAVE_LOCAL_BUFFER (float, work, 3 * nr);
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
+
+          F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&udiag, 1),
+                                     nr, tmp_data, nr, rcon, 
+                                     work, iwork, dtrcon_info 
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (dtrcon_info != 0) 
+            info = -1;
+        }
 
       if (info == -1 && ! force)
-	retval = *this; // Restore matrix contents.
+        retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
 
 
 FloatMatrix
 FloatMatrix::finverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
-		  int force, int calc_cond) const
+                  int force, int calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -739,107 +739,107 @@ FloatMatrix::finverse (MatrixType &matty
       retval = *this;
       float *tmp_data = retval.fortran_vec ();
 
       Array<float> z(1);
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
       F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt, 
-				 z.fortran_vec (), lwork, info));
+                                 z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (z(0));
       lwork = (lwork < 2 *nc ? 2*nc : lwork);
       z.resize (lwork);
       float *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond) 
-	anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+        anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0) 
-	info = -1;
+        info = -1;
       else if (calc_cond) 
-	{
-	  octave_idx_type dgecon_info = 0;
-
-	  // Now calculate the condition number for non-singular matrix.
-	  char job = '1';
-	  Array<octave_idx_type> iz (nc);
-	  octave_idx_type *piz = iz.fortran_vec ();
-	  F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nc, tmp_data, nr, anorm, 
-				     rcon, pz, piz, dgecon_info
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (dgecon_info != 0) 
-	    info = -1;
-	}
+        {
+          octave_idx_type dgecon_info = 0;
+
+          // Now calculate the condition number for non-singular matrix.
+          char job = '1';
+          Array<octave_idx_type> iz (nc);
+          octave_idx_type *piz = iz.fortran_vec ();
+          F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nc, tmp_data, nr, anorm, 
+                                     rcon, pz, piz, dgecon_info
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (dgecon_info != 0) 
+            info = -1;
+        }
 
       if (info == -1 && ! force)
-	retval = *this; // Restore matrix contents.
+        retval = *this; // Restore matrix contents.
       else
-	{
-	  octave_idx_type dgetri_info = 0;
-
-	  F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt,
-				     pz, lwork, dgetri_info));
-
-	  if (dgetri_info != 0) 
-	    info = -1;
-	}
+        {
+          octave_idx_type dgetri_info = 0;
+
+          F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt,
+                                     pz, lwork, dgetri_info));
+
+          if (dgetri_info != 0) 
+            info = -1;
+        }
 
       if (info != 0)
-	mattype.mark_as_rectangular();
+        mattype.mark_as_rectangular();
     }
 
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
-		 int force, int calc_cond) const
+                 int force, int calc_cond) const
 {
   int typ = mattype.type (false);
   FloatMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
     ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
-	{
-	  FloatCHOL chol (*this, info, calc_cond);
-	  if (info == 0)
-	    {
-	      if (calc_cond)
-		rcon = chol.rcond ();
-	      else
-		rcon = 1.0;
-	      ret = chol.inverse ();
-	    }
-	  else
-	    mattype.mark_as_unsymmetric ();
-	}
+        {
+          FloatCHOL chol (*this, info, calc_cond);
+          if (info == 0)
+            {
+              if (calc_cond)
+                rcon = chol.rcond ();
+              else
+                rcon = 1.0;
+              ret = chol.inverse ();
+            }
+          else
+            mattype.mark_as_unsymmetric ();
+        }
 
       if (!mattype.is_hermitian ())
-	ret = finverse(mattype, info, rcon, force, calc_cond);
+        ret = finverse(mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
-	ret = FloatMatrix (rows (), columns (), octave_Float_Inf);
+        ret = FloatMatrix (rows (), columns (), octave_Float_Inf);
     }
 
   return ret;
 }
 
 FloatMatrix
 FloatMatrix::pseudo_inverse (float tol) const
 {
@@ -853,19 +853,19 @@ FloatMatrix::pseudo_inverse (float tol) 
 
   octave_idx_type r = sigma.length () - 1;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
-	tol = nr * sigma.elem (0) * DBL_EPSILON;
+        tol = nr * sigma.elem (0) * DBL_EPSILON;
       else
-	tol = nc * sigma.elem (0) * DBL_EPSILON;
+        tol = nc * sigma.elem (0) * DBL_EPSILON;
     }
 
   while (r >= 0 && sigma.elem (r) < tol)
     r--;
 
   if (r < 0)
     return FloatMatrix (nc, nr, 0.0);
   else
@@ -1117,22 +1117,22 @@ FloatMatrix::fourier2d (void) const
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
-	prow[i] = tmp_data[i*nr + j];
+        prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
-	tmp_data[i*nr + j] = prow[i];
+        tmp_data[i*nr + j] = prow[i];
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::ifourier2d (void) const
 {
@@ -1186,22 +1186,22 @@ FloatMatrix::ifourier2d (void) const
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
-	prow[i] = tmp_data[i*nr + j];
+        prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
       for (octave_idx_type i = 0; i < npts; i++)
-	tmp_data[i*nr + j] = prow[i] / static_cast<float> (npts);
+        tmp_data[i*nr + j] = prow[i] / static_cast<float> (npts);
     }
 
   return retval;
 }
 
 #endif
 
 FloatDET
@@ -1378,362 +1378,362 @@ FloatMatrix::rcond (MatrixType &mattype)
     (*current_liboctave_error_handler) ("matrix must be square");
   else if (nr == 0 || nc == 0)
     rcon = octave_Inf;
   else
     {
       int typ = mattype.type ();
 
       if (typ == MatrixType::Unknown)
-	typ = mattype.type (*this);
+        typ = mattype.type (*this);
 
       // Only calculate the condition number for LU/Cholesky
       if (typ == MatrixType::Upper)
-	{
-	  const float *tmp_data = fortran_vec ();
-	  octave_idx_type info = 0;
-	  char norm = '1';
-	  char uplo = 'U';
-	  char dia = 'N';
-
-	  Array<float> z (3 * nc);
-	  float *pz = z.fortran_vec ();
-	  Array<octave_idx_type> iz (nc);
-	  octave_idx_type *piz = iz.fortran_vec ();
-
-	  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-				     F77_CONST_CHAR_ARG2 (&dia, 1), 
-				     nr, tmp_data, nr, rcon,
-				     pz, piz, info
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (info != 0) 
-	    rcon = 0.0;
-	}
+        {
+          const float *tmp_data = fortran_vec ();
+          octave_idx_type info = 0;
+          char norm = '1';
+          char uplo = 'U';
+          char dia = 'N';
+
+          Array<float> z (3 * nc);
+          float *pz = z.fortran_vec ();
+          Array<octave_idx_type> iz (nc);
+          octave_idx_type *piz = iz.fortran_vec ();
+
+          F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                     nr, tmp_data, nr, rcon,
+                                     pz, piz, info
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (info != 0) 
+            rcon = 0.0;
+        }
       else if  (typ == MatrixType::Permuted_Upper)
-	(*current_liboctave_error_handler)
-	  ("permuted triangular matrix not implemented");
+        (*current_liboctave_error_handler)
+          ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
-	{
-	  const float *tmp_data = fortran_vec ();
-	  octave_idx_type info = 0;
-	  char norm = '1';
-	  char uplo = 'L';
-	  char dia = 'N';
-
-	  Array<float> z (3 * nc);
-	  float *pz = z.fortran_vec ();
-	  Array<octave_idx_type> iz (nc);
-	  octave_idx_type *piz = iz.fortran_vec ();
-
-	  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-				     F77_CONST_CHAR_ARG2 (&dia, 1), 
-				     nr, tmp_data, nr, rcon,
-				     pz, piz, info
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)
-				     F77_CHAR_ARG_LEN (1)));
-
-	  if (info != 0) 
-	    rcon = 0.0;
-	}
+        {
+          const float *tmp_data = fortran_vec ();
+          octave_idx_type info = 0;
+          char norm = '1';
+          char uplo = 'L';
+          char dia = 'N';
+
+          Array<float> z (3 * nc);
+          float *pz = z.fortran_vec ();
+          Array<octave_idx_type> iz (nc);
+          octave_idx_type *piz = iz.fortran_vec ();
+
+          F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                     nr, tmp_data, nr, rcon,
+                                     pz, piz, info
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (info != 0) 
+            rcon = 0.0;
+        }
       else if (typ == MatrixType::Permuted_Lower)
-	(*current_liboctave_error_handler)
-	  ("permuted triangular matrix not implemented");
+        (*current_liboctave_error_handler)
+          ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
-	{
-	  float anorm = -1.0;
-	  FloatMatrix atmp = *this;
-	  float *tmp_data = atmp.fortran_vec ();
-
-	  if (typ == MatrixType::Hermitian)
-	    {
-	      octave_idx_type info = 0;
-	      char job = 'L';
-	      anorm = atmp.abs().sum().
-		row(static_cast<octave_idx_type>(0)).max();
-
-	      F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
-					 tmp_data, nr, info
-					 F77_CHAR_ARG_LEN (1)));
-
-	      if (info != 0) 
-		{
-		  rcon = 0.0;
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Full;
-		}
-	      else 
-		{
-		  Array<float> z (3 * nc);
-		  float *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nc);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, tmp_data, nr, anorm,
-					     rcon, pz, piz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    rcon = 0.0;
-		}
-	    }
-
-	  if (typ == MatrixType::Full)
-	    {
-	      octave_idx_type info = 0;
-
-	      Array<octave_idx_type> ipvt (nr);
-	      octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	      if(anorm < 0.)
-		anorm = atmp.abs().sum().
-		  row(static_cast<octave_idx_type>(0)).max();
-
-	      Array<float> z (4 * nc);
-	      float *pz = z.fortran_vec ();
-	      Array<octave_idx_type> iz (nc);
-	      octave_idx_type *piz = iz.fortran_vec ();
-
-	      F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-	      if (info != 0) 
-		{
-		  rcon = 0.0;
-		  mattype.mark_as_rectangular ();
-		}
-	      else 
-		{
-		  char job = '1';
-		  F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nc, tmp_data, nr, anorm, 
-					     rcon, pz, piz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    rcon = 0.0;
-		}
-	    }
-	}
+        {
+          float anorm = -1.0;
+          FloatMatrix atmp = *this;
+          float *tmp_data = atmp.fortran_vec ();
+
+          if (typ == MatrixType::Hermitian)
+            {
+              octave_idx_type info = 0;
+              char job = 'L';
+              anorm = atmp.abs().sum().
+                row(static_cast<octave_idx_type>(0)).max();
+
+              F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+                                         tmp_data, nr, info
+                                         F77_CHAR_ARG_LEN (1)));
+
+              if (info != 0) 
+                {
+                  rcon = 0.0;
+                  mattype.mark_as_unsymmetric ();
+                  typ = MatrixType::Full;
+                }
+              else 
+                {
+                  Array<float> z (3 * nc);
+                  float *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nc);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, tmp_data, nr, anorm,
+                                             rcon, pz, piz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    rcon = 0.0;
+                }
+            }
+
+          if (typ == MatrixType::Full)
+            {
+              octave_idx_type info = 0;
+
+              Array<octave_idx_type> ipvt (nr);
+              octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+              if(anorm < 0.)
+                anorm = atmp.abs().sum().
+                  row(static_cast<octave_idx_type>(0)).max();
+
+              Array<float> z (4 * nc);
+              float *pz = z.fortran_vec ();
+              Array<octave_idx_type> iz (nc);
+              octave_idx_type *piz = iz.fortran_vec ();
+
+              F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+              if (info != 0) 
+                {
+                  rcon = 0.0;
+                  mattype.mark_as_rectangular ();
+                }
+              else 
+                {
+                  char job = '1';
+                  F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nc, tmp_data, nr, anorm, 
+                                             rcon, pz, piz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    rcon = 0.0;
+                }
+            }
+        }
       else
-	rcon = 0.0;
+        rcon = 0.0;
     }
 
   return rcon;
 }
 
 FloatMatrix
 FloatMatrix::utsolve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
-		float& rcon, solve_singularity_handler sing_handler,
-		bool calc_cond, blas_trans_type transt) const
+                float& rcon, solve_singularity_handler sing_handler,
+                bool calc_cond, blas_trans_type transt) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = FloatMatrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper ||
-	  typ == MatrixType::Upper)
-	{
-	  octave_idx_type b_nc = b.cols ();
-	  rcon = 1.;
-	  info = 0;
-
-	  if (typ == MatrixType::Permuted_Upper)
-	    {
-	      (*current_liboctave_error_handler)
-		("permuted triangular matrix not implemented");
-	    }
-	  else
-	    {
-	      const float *tmp_data = fortran_vec ();
-
-	      if (calc_cond)
-		{
-		  char norm = '1';
-		  char uplo = 'U';
-		  char dia = 'N';
-
-		  Array<float> z (3 * nc);
-		  float *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nc);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcon,
-					     pz, piz, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile float rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  float *result = retval.fortran_vec ();
-
-		  char uplo = 'U';
-		  char trans = get_blas_char (transt);
-		  char dia = 'N';
-
-		  F77_XFCN (strtrs, STRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&trans, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, b_nc, tmp_data, nr,
-					     result, nr, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	    }
-	}
+          typ == MatrixType::Upper)
+        {
+          octave_idx_type b_nc = b.cols ();
+          rcon = 1.;
+          info = 0;
+
+          if (typ == MatrixType::Permuted_Upper)
+            {
+              (*current_liboctave_error_handler)
+                ("permuted triangular matrix not implemented");
+            }
+          else
+            {
+              const float *tmp_data = fortran_vec ();
+
+              if (calc_cond)
+                {
+                  char norm = '1';
+                  char uplo = 'U';
+                  char dia = 'N';
+
+                  Array<float> z (3 * nc);
+                  float *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nc);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, tmp_data, nr, rcon,
+                                             pz, piz, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile float rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  float *result = retval.fortran_vec ();
+
+                  char uplo = 'U';
+                  char trans = get_blas_char (transt);
+                  char dia = 'N';
+
+                  F77_XFCN (strtrs, STRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, b_nc, tmp_data, nr,
+                                             result, nr, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::ltsolve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
-		float& rcon, solve_singularity_handler sing_handler,
-		bool calc_cond, blas_trans_type transt) const
+                float& rcon, solve_singularity_handler sing_handler,
+                bool calc_cond, blas_trans_type transt) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = FloatMatrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower ||
-	  typ == MatrixType::Lower)
-	{
-	  octave_idx_type b_nc = b.cols ();
-	  rcon = 1.;
-	  info = 0;
-
-	  if (typ == MatrixType::Permuted_Lower)
-	    {
-	      (*current_liboctave_error_handler)
-		("permuted triangular matrix not implemented");
-	    }
-	  else
-	    {
-	      const float *tmp_data = fortran_vec ();
-
-	      if (calc_cond)
-		{
-		  char norm = '1';
-		  char uplo = 'L';
-		  char dia = 'N';
-
-		  Array<float> z (3 * nc);
-		  float *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nc);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcon,
-					     pz, piz, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile float rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  float *result = retval.fortran_vec ();
-
-		  char uplo = 'L';
-		  char trans = get_blas_char (transt);
-		  char dia = 'N';
-
-		  F77_XFCN (strtrs, STRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-					     F77_CONST_CHAR_ARG2 (&trans, 1), 
-					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, b_nc, tmp_data, nr,
-					     result, nr, info
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	    }
-	}
+          typ == MatrixType::Lower)
+        {
+          octave_idx_type b_nc = b.cols ();
+          rcon = 1.;
+          info = 0;
+
+          if (typ == MatrixType::Permuted_Lower)
+            {
+              (*current_liboctave_error_handler)
+                ("permuted triangular matrix not implemented");
+            }
+          else
+            {
+              const float *tmp_data = fortran_vec ();
+
+              if (calc_cond)
+                {
+                  char norm = '1';
+                  char uplo = 'L';
+                  char dia = 'N';
+
+                  Array<float> z (3 * nc);
+                  float *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nc);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, tmp_data, nr, rcon,
+                                             pz, piz, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile float rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  float *result = retval.fortran_vec ();
+
+                  char uplo = 'L';
+                  char trans = get_blas_char (transt);
+                  char dia = 'N';
+
+                  F77_XFCN (strtrs, STRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
+                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
+                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                                             nr, b_nc, tmp_data, nr,
+                                             result, nr, info
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+            }
+        }
       else
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::fsolve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
-		float& rcon, solve_singularity_handler sing_handler,
-		bool calc_cond) const
+                float& rcon, solve_singularity_handler sing_handler,
+                bool calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1743,170 +1743,170 @@ FloatMatrix::fsolve (MatrixType &mattype
   else
     {
       volatile int typ = mattype.type ();
  
      // Calculate the norm of the matrix, for later use.
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
-	{
-	  info = 0;
-	  char job = 'L';
-	  FloatMatrix atmp = *this;
-	  float *tmp_data = atmp.fortran_vec ();
-	  anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
-
-	  F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
-				     tmp_data, nr, info
-				     F77_CHAR_ARG_LEN (1)));
-
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcon = 0.0;
-	  if (info != 0) 
-	    {
-	      info = -2;
-
-	      mattype.mark_as_unsymmetric ();
-	      typ = MatrixType::Full;
-	    }
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  Array<float> z (3 * nc);
-		  float *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nc);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, tmp_data, nr, anorm,
-					     rcon, pz, piz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile float rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  float *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  F77_XFCN (spotrs, SPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, b_nc, tmp_data, nr,
-					     result, b.rows(), info
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	      else
-		{
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Full;
-		}		    
-	    }
-	}
+        {
+          info = 0;
+          char job = 'L';
+          FloatMatrix atmp = *this;
+          float *tmp_data = atmp.fortran_vec ();
+          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+
+          F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+                                     tmp_data, nr, info
+                                     F77_CHAR_ARG_LEN (1)));
+
+          // Throw-away extra info LAPACK gives so as to not change output.
+          rcon = 0.0;
+          if (info != 0) 
+            {
+              info = -2;
+
+              mattype.mark_as_unsymmetric ();
+              typ = MatrixType::Full;
+            }
+          else 
+            {
+              if (calc_cond)
+                {
+                  Array<float> z (3 * nc);
+                  float *pz = z.fortran_vec ();
+                  Array<octave_idx_type> iz (nc);
+                  octave_idx_type *piz = iz.fortran_vec ();
+
+                  F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, tmp_data, nr, anorm,
+                                             rcon, pz, piz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile float rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  float *result = retval.fortran_vec ();
+
+                  octave_idx_type b_nc = b.cols ();
+
+                  F77_XFCN (spotrs, SPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, b_nc, tmp_data, nr,
+                                             result, b.rows(), info
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+              else
+                {
+                  mattype.mark_as_unsymmetric ();
+                  typ = MatrixType::Full;
+                }                   
+            }
+        }
 
       if (typ == MatrixType::Full)
-	{
-	  info = 0;
-
-	  Array<octave_idx_type> ipvt (nr);
-	  octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-	  FloatMatrix atmp = *this;
-	  float *tmp_data = atmp.fortran_vec ();
-	  if(anorm < 0.)
-	    anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
-
-	  Array<float> z (4 * nc);
-	  float *pz = z.fortran_vec ();
-	  Array<octave_idx_type> iz (nc);
-	  octave_idx_type *piz = iz.fortran_vec ();
-
-	  F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcon = 0.0;
-	  if (info != 0) 
-	    {
-	      info = -2;
-
-	      if (sing_handler)
-		sing_handler (rcon);
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	      mattype.mark_as_rectangular ();
-	    }
-	  else 
-	    {
-	      if (calc_cond)
-		{
-		  // Now calculate the condition number for 
-		  // non-singular matrix.
-		  char job = '1';
-		  F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nc, tmp_data, nr, anorm, 
-					     rcon, pz, piz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (info != 0) 
-		    info = -2;
-
-		  volatile float rcond_plus_one = rcon + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcon))
-		    {
-		      info = -2;
-
-		      if (sing_handler)
-			sing_handler (rcon);
-		      else
-			(*current_liboctave_error_handler)
-			  ("matrix singular to machine precision, rcond = %g",
-			   rcon);
-		    }
-		}
-
-	      if (info == 0)
-		{
-		  retval = b;
-		  float *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  char job = 'N';
-		  F77_XFCN (sgetrs, SGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, b_nc, tmp_data, nr,
-					     pipvt, result, b.rows(), info
-					     F77_CHAR_ARG_LEN (1)));
-		}
-	      else
-		mattype.mark_as_rectangular ();
-	    }
-	}
+        {
+          info = 0;
+
+          Array<octave_idx_type> ipvt (nr);
+          octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+          FloatMatrix atmp = *this;
+          float *tmp_data = atmp.fortran_vec ();
+          if(anorm < 0.)
+            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+
+          Array<float> z (4 * nc);
+          float *pz = z.fortran_vec ();
+          Array<octave_idx_type> iz (nc);
+          octave_idx_type *piz = iz.fortran_vec ();
+
+          F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+          // Throw-away extra info LAPACK gives so as to not change output.
+          rcon = 0.0;
+          if (info != 0) 
+            {
+              info = -2;
+
+              if (sing_handler)
+                sing_handler (rcon);
+              else
+                (*current_liboctave_error_handler)
+                  ("matrix singular to machine precision");
+
+              mattype.mark_as_rectangular ();
+            }
+          else 
+            {
+              if (calc_cond)
+                {
+                  // Now calculate the condition number for 
+                  // non-singular matrix.
+                  char job = '1';
+                  F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nc, tmp_data, nr, anorm, 
+                                             rcon, pz, piz, info
+                                             F77_CHAR_ARG_LEN (1)));
+
+                  if (info != 0) 
+                    info = -2;
+
+                  volatile float rcond_plus_one = rcon + 1.0;
+
+                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                    {
+                      info = -2;
+
+                      if (sing_handler)
+                        sing_handler (rcon);
+                      else
+                        (*current_liboctave_error_handler)
+                          ("matrix singular to machine precision, rcond = %g",
+                           rcon);
+                    }
+                }
+
+              if (info == 0)
+                {
+                  retval = b;
+                  float *result = retval.fortran_vec ();
+
+                  octave_idx_type b_nc = b.cols ();
+
+                  char job = 'N';
+                  F77_XFCN (sgetrs, SGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                             nr, b_nc, tmp_data, nr,
+                                             pipvt, result, b.rows(), info
+                                             F77_CHAR_ARG_LEN (1)));
+                }
+              else
+                mattype.mark_as_rectangular ();
+            }
+        }
       else if (typ != MatrixType::Hermitian)
-	(*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b) const
 {
@@ -1919,25 +1919,25 @@ FloatMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info, 
-	       float& rcon) const
+               float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatMatrix
 FloatMatrix::solve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
-	       float& rcon, solve_singularity_handler sing_handler,
-	       bool singular_fallback, blas_trans_type transt) const
+               float& rcon, solve_singularity_handler sing_handler,
+               bool singular_fallback, blas_trans_type transt) const
 {
   FloatMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
@@ -1978,17 +1978,17 @@ FloatMatrix::solve (MatrixType &typ, con
   octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, octave_idx_type& info,
-	       float& rcon) const
+               float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 static FloatMatrix
 stack_complex_matrix (const FloatComplexMatrix& cm)
 {
   octave_idx_type m = cm.rows (), n = cm.cols (), nel = m*n;
@@ -2012,81 +2012,81 @@ unstack_complex_matrix (const FloatMatri
   FloatComplex *rd = retval.fortran_vec ();
   for (octave_idx_type i = 0; i < nel; i++)
     rd[i] = FloatComplex (smd[i], smd[nel+i]);
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, octave_idx_type& info,
-	       float& rcon, solve_singularity_handler sing_handler,
-	       bool singular_fallback, blas_trans_type transt) const
+               float& rcon, solve_singularity_handler sing_handler,
+               bool singular_fallback, blas_trans_type transt) const
 {
   FloatMatrix tmp = stack_complex_matrix (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
   return unstack_complex_matrix (tmp);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b) const
 {
   octave_idx_type info; float rcon;
   return solve (typ, b, info, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
-	       octave_idx_type& info) const
+               octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, octave_idx_type& info,
-	       float& rcon) const
+               float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, octave_idx_type& info,
-	       float& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
+               float& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatMatrix tmp (b);
   return solve (typ, tmp, info, rcon, sing_handler, transt).column(static_cast<octave_idx_type> (0));
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-	       octave_idx_type& info) const
+               octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-	       octave_idx_type& info, float& rcon) const
+               octave_idx_type& info, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-	       octave_idx_type& info, float& rcon,
-	       solve_singularity_handler sing_handler, blas_trans_type transt) const
+               octave_idx_type& info, float& rcon,
+               solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve(typ, b, info, rcon, sing_handler, transt);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b) const
 {
@@ -2105,17 +2105,17 @@ FloatMatrix::solve (const FloatMatrix& b
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info,
-	       float& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
+               float& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (const FloatComplexMatrix& b) const
 {
@@ -2134,17 +2134,17 @@ FloatComplexMatrix
 FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
-	       solve_singularity_handler sing_handler, blas_trans_type transt) const
+               solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon, sing_handler, transt);
 }
 
 FloatColumnVector
 FloatMatrix::solve (const FloatColumnVector& b) const
 {
@@ -2162,17 +2162,17 @@ FloatMatrix::solve (const FloatColumnVec
 FloatColumnVector
 FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatColumnVector
 FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
-	       solve_singularity_handler sing_handler, blas_trans_type transt) const
+               solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (const FloatComplexColumnVector& b) const
 {
@@ -2191,17 +2191,17 @@ FloatComplexColumnVector
 FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info, float& rcon,
-	       solve_singularity_handler sing_handler, blas_trans_type transt) const
+               solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon, sing_handler, transt);
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b) const
 {
@@ -2216,25 +2216,25 @@ FloatMatrix::lssolve (const FloatMatrix&
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
-		 octave_idx_type& rank) const
+                 octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
-		 octave_idx_type& rank, float &rcon) const
+                 octave_idx_type& rank, float &rcon) const
 {
   FloatMatrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2244,127 +2244,127 @@ FloatMatrix::lssolve (const FloatMatrix&
   else if (m == 0 || n == 0 || b.cols () == 0)
     retval = FloatMatrix (n, b.cols (), 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
       if (m != n)
-	{
-	  retval = FloatMatrix (maxmn, nrhs, 0.0);
-
-	  for (octave_idx_type j = 0; j < nrhs; j++)
-	    for (octave_idx_type i = 0; i < m; i++)
-	      retval.elem (i, j) = b.elem (i, j);
-	}
+        {
+          retval = FloatMatrix (maxmn, nrhs, 0.0);
+
+          for (octave_idx_type j = 0; j < nrhs; j++)
+            for (octave_idx_type i = 0; i < m; i++)
+              retval.elem (i, j) = b.elem (i, j);
+        }
       else
-	retval = b;
+        retval = b;
 
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
       float *pretval = retval.fortran_vec ();
       Array<float> s (minmn);
       float *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
       Array<float> work (1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("SGELSD", 6),
-				   F77_CONST_CHAR_ARG2 (" ", 1),
-				   0, 0, 0, 0, smlsiz
-				   F77_CHAR_ARG_LEN (6)
-				   F77_CHAR_ARG_LEN (1));
+                                   F77_CONST_CHAR_ARG2 (" ", 1),
+                                   0, 0, 0, 0, smlsiz
+                                   F77_CHAR_ARG_LEN (6)
+                                   F77_CHAR_ARG_LEN (1));
 
       octave_idx_type mnthr;
       F77_FUNC (xilaenv, XILAENV) (6, F77_CONST_CHAR_ARG2 ("SGELSD", 6),
-				   F77_CONST_CHAR_ARG2 (" ", 1),
-				   m, n, nrhs, -1, mnthr
-				   F77_CHAR_ARG_LEN (6)
-				   F77_CHAR_ARG_LEN (1));
+                                   F77_CONST_CHAR_ARG2 (" ", 1),
+                                   m, n, nrhs, -1, mnthr
+                                   F77_CHAR_ARG_LEN (6)
+                                   F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
 #if defined (HAVE_LOG2)
       float tmp = log2 (dminmn / dsmlsizp1);
 #else
       float tmp = log (dminmn / dsmlsizp1) / log (2.0);
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
-	nlvl = 0;
+        nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
-	liwork = 1;
+        liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcon, rank, work.fortran_vec (),
-				 lwork, piwork, info));
+                                 ps, rcon, rank, work.fortran_vec (),
+                                 lwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for DGELSD to operate
       // efficiently.
       if (n >= mnthr)
-	{
-	  const octave_idx_type wlalsd
-	    = 9*m + 2*m*smlsiz + 8*m*nlvl + m*nrhs + (smlsiz+1)*(smlsiz+1);
-
-	  octave_idx_type addend = m;
-
-	  if (2*m-4 > addend)
-	    addend = 2*m-4;
-
-	  if (nrhs > addend)
-	    addend = nrhs;
-
-	  if (n-3*m > addend)
-	    addend = n-3*m;
-
-	  if (wlalsd > addend)
-	    addend = wlalsd;
-
-	  const octave_idx_type lworkaround = 4*m + m*m + addend;
-
-	  if (work(0) < lworkaround)
-	    work(0) = lworkaround;
-	}
+        {
+          const octave_idx_type wlalsd
+            = 9*m + 2*m*smlsiz + 8*m*nlvl + m*nrhs + (smlsiz+1)*(smlsiz+1);
+
+          octave_idx_type addend = m;
+
+          if (2*m-4 > addend)
+            addend = 2*m-4;
+
+          if (nrhs > addend)
+            addend = nrhs;
+
+          if (n-3*m > addend)
+            addend = n-3*m;
+
+          if (wlalsd > addend)
+            addend = wlalsd;
+
+          const octave_idx_type lworkaround = 4*m + m*m + addend;
+
+          if (work(0) < lworkaround)
+            work(0) = lworkaround;
+        }
       else if (m >= n)
-	{
-	  octave_idx_type lworkaround
-	    = 12*n + 2*n*smlsiz + 8*n*nlvl + n*nrhs + (smlsiz+1)*(smlsiz+1);
-
-	  if (work(0) < lworkaround)
-	    work(0) = lworkaround;
-	}
+        {
+          octave_idx_type lworkaround
+            = 12*n + 2*n*smlsiz + 8*n*nlvl + n*nrhs + (smlsiz+1)*(smlsiz+1);
+
+          if (work(0) < lworkaround)
+            work(0) = lworkaround;
+        }
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (lwork);
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcon, rank,
-				 work.fortran_vec (), lwork, 
-				 piwork, info));
+                                 maxmn, ps, rcon, rank,
+                                 work.fortran_vec (), lwork, 
+                                 piwork, info));
 
       if (rank < minmn)
-	(*current_liboctave_warning_handler) 
-	  ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
+        (*current_liboctave_warning_handler) 
+          ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
       if (s.elem (0) == 0.0)
-	rcon = 0.0;
+        rcon = 0.0;
       else
-	rcon = s.elem (minmn - 1) / s.elem (0);
+        rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 FloatComplexMatrix
@@ -2383,26 +2383,26 @@ FloatMatrix::lssolve (const FloatComplex
   FloatComplexMatrix tmp (*this);
   octave_idx_type rank;
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info, 
-		 octave_idx_type& rank) const
+                 octave_idx_type& rank) const
 {
   FloatComplexMatrix tmp (*this);
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info, 
-		 octave_idx_type& rank, float& rcon) const
+                 octave_idx_type& rank, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b) const
 {
@@ -2417,25 +2417,25 @@ FloatMatrix::lssolve (const FloatColumnV
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
-		 octave_idx_type& rank) const
+                 octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
-		 octave_idx_type& rank, float &rcon) const
+                 octave_idx_type& rank, float &rcon) const
 {
   FloatColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2446,85 +2446,85 @@ FloatMatrix::lssolve (const FloatColumnV
     retval = FloatColumnVector (n, 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
  
       if (m != n)
-	{
-	  retval = FloatColumnVector (maxmn, 0.0);
-
-	  for (octave_idx_type i = 0; i < m; i++)
-	    retval.elem (i) = b.elem (i);
-	}
+        {
+          retval = FloatColumnVector (maxmn, 0.0);
+
+          for (octave_idx_type i = 0; i < m; i++)
+            retval.elem (i) = b.elem (i);
+        }
       else
-	retval = b;
+        retval = b;
 
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
       float *pretval = retval.fortran_vec ();
       Array<float> s (minmn);
       float *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
       Array<float> work (1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("SGELSD", 6),
-				   F77_CONST_CHAR_ARG2 (" ", 1),
-				   0, 0, 0, 0, smlsiz
-				   F77_CHAR_ARG_LEN (6)
-				   F77_CHAR_ARG_LEN (1));
+                                   F77_CONST_CHAR_ARG2 (" ", 1),
+                                   0, 0, 0, 0, smlsiz
+                                   F77_CHAR_ARG_LEN (6)
+                                   F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
 #if defined (HAVE_LOG2)
       float tmp = log2 (dminmn / dsmlsizp1);
 #else
       float tmp = log (dminmn / dsmlsizp1) / log (2.0);
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
-	nlvl = 0;
+        nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
-	liwork = 1;
+        liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcon, rank, work.fortran_vec (),
-				 lwork, piwork, info));
+                                 ps, rcon, rank, work.fortran_vec (),
+                                 lwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (lwork);
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcon, rank,
-				 work.fortran_vec (), lwork, 
-				 piwork, info));
+                                 maxmn, ps, rcon, rank,
+                                 work.fortran_vec (), lwork, 
+                                 piwork, info));
 
       if (rank < minmn)
-	{
-	  if (rank < minmn)
-	    (*current_liboctave_warning_handler) 
-	      ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
-	  if (s.elem (0) == 0.0)
-	    rcon = 0.0;
-	  else
-	    rcon = s.elem (minmn - 1) / s.elem (0);
-	}
+        {
+          if (rank < minmn)
+            (*current_liboctave_warning_handler) 
+              ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
+          if (s.elem (0) == 0.0)
+            rcon = 0.0;
+          else
+            rcon = s.elem (minmn - 1) / s.elem (0);
+        }
 
       retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 FloatComplexColumnVector
@@ -2543,26 +2543,26 @@ FloatMatrix::lssolve (const FloatComplex
   FloatComplexMatrix tmp (*this);
   octave_idx_type rank;
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info, 
-		 octave_idx_type& rank) const
+                 octave_idx_type& rank) const
 {
   FloatComplexMatrix tmp (*this);
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info, 
-		 octave_idx_type& rank, float &rcon) const
+                 octave_idx_type& rank, float &rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatMatrix&
 FloatMatrix::operator += (const FloatDiagMatrix& a)
 {
@@ -2623,108 +2623,108 @@ operator * (const FloatColumnVector& v, 
   octave_idx_type len = v.length ();
 
   if (len != 0)
     {
       octave_idx_type a_len = a.length ();
 
       retval = FloatMatrix (len, a_len);
       float *c = retval.fortran_vec ();
-	  
+          
       F77_XFCN (sgemm, SGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
-			       F77_CONST_CHAR_ARG2 ("N", 1),
-			       len, a_len, 1, 1.0, v.data (), len,
-			       a.data (), 1, 0.0, c, len
-			       F77_CHAR_ARG_LEN (1)
-			       F77_CHAR_ARG_LEN (1)));
+                               F77_CONST_CHAR_ARG2 ("N", 1),
+                               len, a_len, 1, 1.0, v.data (), len,
+                               a.data (), 1, 0.0, c, len
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 // other operations.
 
 bool
 FloatMatrix::any_element_is_negative (bool neg_zero) const
 {
   octave_idx_type nel = nelem ();
 
   if (neg_zero)
     {
       for (octave_idx_type i = 0; i < nel; i++)
-	if (lo_ieee_signbit (elem (i)))
-	  return true;
+        if (lo_ieee_signbit (elem (i)))
+          return true;
     }
   else
     {
       for (octave_idx_type i = 0; i < nel; i++)
-	if (elem (i) < 0)
-	  return true;
+        if (elem (i) < 0)
+          return true;
     }
 
   return false;
 }
 
 bool
 FloatMatrix::any_element_is_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float val = elem (i);
       if (xisnan (val))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 FloatMatrix::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float val = elem (i);
       if (xisinf (val) || xisnan (val))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 FloatMatrix::any_element_not_one_or_zero (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float val = elem (i);
       if (val != 0 && val != 1)
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 FloatMatrix::all_elements_are_int_or_inf_or_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float val = elem (i);
       if (xisnan (val) || D_NINT (val) == val)
-	continue;
+        continue;
       else
-	return false;
+        return false;
     }
 
   return true;
 }
 
 // Return nonzero if any element of M is not an integer.  Also extract
 // the largest and smallest values and return them in MAX_VAL and MIN_VAL.
 
@@ -2741,40 +2741,40 @@ FloatMatrix::all_integers (float& max_va
   else
     return false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float val = elem (i);
 
       if (val > max_val)
-	max_val = val;
+        max_val = val;
 
       if (val < min_val)
-	min_val = val;
+        min_val = val;
 
       if (D_NINT (val) != val)
-	return false;
+        return false;
     }
 
   return true;
 }
 
 bool
 FloatMatrix::too_large_for_float (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float val = elem (i);
 
       if (! (xisnan (val) || xisinf (val))
-	  && fabs (val) > FLT_MAX)
-	return true;
+          && fabs (val) > FLT_MAX)
+        return true;
     }
 
   return false;
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
@@ -2850,43 +2850,43 @@ FloatMatrix::row_min (Array<octave_idx_t
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       idx_arg.resize (nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
-	  octave_idx_type idx_j;
-
-	  float tmp_min = octave_Float_NaN;
-
-	  for (idx_j = 0; idx_j < nc; idx_j++)
-	    {
-	      tmp_min = elem (i, idx_j);
-
-	      if (! xisnan (tmp_min))
-		break;
-	    }
-
-	  for (octave_idx_type j = idx_j+1; j < nc; j++)
-	    {
-	      float tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (tmp < tmp_min)
-		{
-		  idx_j = j;
-		  tmp_min = tmp;
-		}
-	    }
-
-	  result.elem (i) = tmp_min;
-	  idx_arg.elem (i) = xisnan (tmp_min) ? 0 : idx_j;
+          octave_idx_type idx_j;
+
+          float tmp_min = octave_Float_NaN;
+
+          for (idx_j = 0; idx_j < nc; idx_j++)
+            {
+              tmp_min = elem (i, idx_j);
+
+              if (! xisnan (tmp_min))
+                break;
+            }
+
+          for (octave_idx_type j = idx_j+1; j < nc; j++)
+            {
+              float tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+              else if (tmp < tmp_min)
+                {
+                  idx_j = j;
+                  tmp_min = tmp;
+                }
+            }
+
+          result.elem (i) = tmp_min;
+          idx_arg.elem (i) = xisnan (tmp_min) ? 0 : idx_j;
         }
     }
 
   return result;
 }
 
 FloatColumnVector
 FloatMatrix::row_max (void) const
@@ -2905,43 +2905,43 @@ FloatMatrix::row_max (Array<octave_idx_t
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       idx_arg.resize (nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
-	  octave_idx_type idx_j;
-
-	  float tmp_max = octave_Float_NaN;
-
-	  for (idx_j = 0; idx_j < nc; idx_j++)
-	    {
-	      tmp_max = elem (i, idx_j);
-
-	      if (! xisnan (tmp_max))
-		break;
-	    }
-
-	  for (octave_idx_type j = idx_j+1; j < nc; j++)
-	    {
-	      float tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (tmp > tmp_max)
-		{
-		  idx_j = j;
-		  tmp_max = tmp;
-		}
-	    }
-
-	  result.elem (i) = tmp_max;
-	  idx_arg.elem (i) = xisnan (tmp_max) ? 0 : idx_j;
+          octave_idx_type idx_j;
+
+          float tmp_max = octave_Float_NaN;
+
+          for (idx_j = 0; idx_j < nc; idx_j++)
+            {
+              tmp_max = elem (i, idx_j);
+
+              if (! xisnan (tmp_max))
+                break;
+            }
+
+          for (octave_idx_type j = idx_j+1; j < nc; j++)
+            {
+              float tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+              else if (tmp > tmp_max)
+                {
+                  idx_j = j;
+                  tmp_max = tmp;
+                }
+            }
+
+          result.elem (i) = tmp_max;
+          idx_arg.elem (i) = xisnan (tmp_max) ? 0 : idx_j;
         }
     }
 
   return result;
 }
 
 FloatRowVector
 FloatMatrix::column_min (void) const
@@ -2960,43 +2960,43 @@ FloatMatrix::column_min (Array<octave_id
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       idx_arg.resize (nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-	  octave_idx_type idx_i;
-
-	  float tmp_min = octave_Float_NaN;
-
-	  for (idx_i = 0; idx_i < nr; idx_i++)
-	    {
-	      tmp_min = elem (idx_i, j);
-
-	      if (! xisnan (tmp_min))
-		break;
-	    }
-
-	  for (octave_idx_type i = idx_i+1; i < nr; i++)
-	    {
-	      float tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (tmp < tmp_min)
-		{
-		  idx_i = i;
-		  tmp_min = tmp;
-		}
-	    }
-
-	  result.elem (j) = tmp_min;
-	  idx_arg.elem (j) = xisnan (tmp_min) ? 0 : idx_i;
+          octave_idx_type idx_i;
+
+          float tmp_min = octave_Float_NaN;
+
+          for (idx_i = 0; idx_i < nr; idx_i++)
+            {
+              tmp_min = elem (idx_i, j);
+
+              if (! xisnan (tmp_min))
+                break;
+            }
+
+          for (octave_idx_type i = idx_i+1; i < nr; i++)
+            {
+              float tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+              else if (tmp < tmp_min)
+                {
+                  idx_i = i;
+                  tmp_min = tmp;
+                }
+            }
+
+          result.elem (j) = tmp_min;
+          idx_arg.elem (j) = xisnan (tmp_min) ? 0 : idx_i;
         }
     }
 
   return result;
 }
 
 FloatRowVector
 FloatMatrix::column_max (void) const
@@ -3015,82 +3015,82 @@ FloatMatrix::column_max (Array<octave_id
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       idx_arg.resize (nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-	  octave_idx_type idx_i;
-
-	  float tmp_max = octave_Float_NaN;
-
-	  for (idx_i = 0; idx_i < nr; idx_i++)
-	    {
-	      tmp_max = elem (idx_i, j);
-
-	      if (! xisnan (tmp_max))
-		break;
-	    }
-
-	  for (octave_idx_type i = idx_i+1; i < nr; i++)
-	    {
-	      float tmp = elem (i, j);
-
-	      if (xisnan (tmp))
-		continue;
-	      else if (tmp > tmp_max)
-		{
-		  idx_i = i;
-		  tmp_max = tmp;
-		}
-	    }
-
-	  result.elem (j) = tmp_max;
-	  idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_i;
+          octave_idx_type idx_i;
+
+          float tmp_max = octave_Float_NaN;
+
+          for (idx_i = 0; idx_i < nr; idx_i++)
+            {
+              tmp_max = elem (idx_i, j);
+
+              if (! xisnan (tmp_max))
+                break;
+            }
+
+          for (octave_idx_type i = idx_i+1; i < nr; i++)
+            {
+              float tmp = elem (i, j);
+
+              if (xisnan (tmp))
+                continue;
+              else if (tmp > tmp_max)
+                {
+                  idx_i = i;
+                  tmp_max = tmp;
+                }
+            }
+
+          result.elem (j) = tmp_max;
+          idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_i;
         }
     }
 
   return result;
 }
 
 std::ostream&
 operator << (std::ostream& os, const FloatMatrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
-	{
-	  os << " ";
-	  octave_write_float (os, a.elem (i, j));
-	}
+        {
+          os << " ";
+          octave_write_float (os, a.elem (i, j));
+        }
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr > 0 && nc > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < nr; i++)
-	for (octave_idx_type j = 0; j < nc; j++)
-	  {
-	    tmp = octave_read_value<float> (is);
-	    if (is)
-	      a.elem (i, j) = tmp;
-	    else
-	      goto done;
-	  }
+        for (octave_idx_type j = 0; j < nc; j++)
+          {
+            tmp = octave_read_value<float> (is);
+            if (is)
+              a.elem (i, j) = tmp;
+            else
+              goto done;
+          }
     }
 
  done:
 
   return is;
 }
 
 FloatMatrix
@@ -3142,21 +3142,21 @@ Sylvester (const FloatMatrix& a, const F
   float scale;
   octave_idx_type info;
 
   float *pa = sch_a.fortran_vec ();
   float *pb = sch_b.fortran_vec ();
   float *px = cx.fortran_vec ();
 
   F77_XFCN (strsyl, STRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
-			     F77_CONST_CHAR_ARG2 ("N", 1),
-			     1, a_nr, b_nr, pa, a_nr, pb,
-			     b_nr, px, a_nr, scale, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             1, a_nr, b_nr, pa, a_nr, pb,
+                             b_nr, px, a_nr, scale, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
 
   // FIXME -- check info?
   
   retval = -ua*cx*ub.transpose ();
 
   return retval;
 }
@@ -3204,77 +3204,77 @@ xgemm (const FloatMatrix& a, const Float
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
     gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
   else
     {
       if (a_nr == 0 || a_nc == 0 || b_nc == 0)
-	retval = FloatMatrix (a_nr, b_nc, 0.0);
+        retval = FloatMatrix (a_nr, b_nc, 0.0);
       else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
         {
-	  octave_idx_type lda = a.rows ();
+          octave_idx_type lda = a.rows ();
 
           retval = FloatMatrix (a_nr, b_nc);
-	  float *c = retval.fortran_vec ();
+          float *c = retval.fortran_vec ();
 
           const char *ctra = get_blas_trans_arg (tra);
           F77_XFCN (ssyrk, SSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (ctra, 1),
                                    a_nr, a_nc, 1.0,
                                    a.data (), lda, 0.0, c, a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
           for (int j = 0; j < a_nr; j++)
             for (int i = 0; i < j; i++)
               retval.xelem (j,i) = retval.xelem (i,j);
 
         }
       else
-	{
-	  octave_idx_type lda = a.rows (), tda = a.cols ();
-	  octave_idx_type ldb = b.rows (), tdb = b.cols ();
-
-	  retval = FloatMatrix (a_nr, b_nc);
-	  float *c = retval.fortran_vec ();
-
-	  if (b_nc == 1)
-	    {
-	      if (a_nr == 1)
-		F77_FUNC (xsdot, XSDOT) (a_nc, a.data (), 1, b.data (), 1, *c);
-	      else
-		{
+        {
+          octave_idx_type lda = a.rows (), tda = a.cols ();
+          octave_idx_type ldb = b.rows (), tdb = b.cols ();
+
+          retval = FloatMatrix (a_nr, b_nc);
+          float *c = retval.fortran_vec ();
+
+          if (b_nc == 1)
+            {
+              if (a_nr == 1)
+                F77_FUNC (xsdot, XSDOT) (a_nc, a.data (), 1, b.data (), 1, *c);
+              else
+                {
                   const char *ctra = get_blas_trans_arg (tra);
-		  F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 (ctra, 1),
-					   lda, tda, 1.0,  a.data (), lda,
-					   b.data (), 1, 0.0, c, 1
-					   F77_CHAR_ARG_LEN (1)));
-		}
+                  F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 (ctra, 1),
+                                           lda, tda, 1.0,  a.data (), lda,
+                                           b.data (), 1, 0.0, c, 1
+                                           F77_CHAR_ARG_LEN (1)));
+                }
             }
           else if (a_nr == 1)
             {
               const char *crevtrb = get_blas_trans_arg (! trb);
               F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 (crevtrb, 1),
                                        ldb, tdb, 1.0,  b.data (), ldb,
                                        a.data (), 1, 0.0, c, 1
                                        F77_CHAR_ARG_LEN (1)));
             }
-	  else
-	    {
+          else
+            {
               const char *ctra = get_blas_trans_arg (tra);
               const char *ctrb = get_blas_trans_arg (trb);
-	      F77_XFCN (sgemm, SGEMM, (F77_CONST_CHAR_ARG2 (ctra, 1),
-				       F77_CONST_CHAR_ARG2 (ctrb, 1),
-				       a_nr, b_nc, a_nc, 1.0, a.data (),
-				       lda, b.data (), ldb, 0.0, c, a_nr
-				       F77_CHAR_ARG_LEN (1)
-				       F77_CHAR_ARG_LEN (1)));
-	    }
-	}
+              F77_XFCN (sgemm, SGEMM, (F77_CONST_CHAR_ARG2 (ctra, 1),
+                                       F77_CONST_CHAR_ARG2 (ctrb, 1),
+                                       a_nr, b_nc, a_nc, 1.0, a.data (),
+                                       lda, b.data (), ldb, 0.0, c, a_nr
+                                       F77_CHAR_ARG_LEN (1)
+                                       F77_CHAR_ARG_LEN (1)));
+            }
+        }
     }
 
   return retval;
 }
 
 FloatMatrix
 operator * (const FloatMatrix& a, const FloatMatrix& b)
 {
@@ -3296,18 +3296,18 @@ min (float d, const FloatMatrix& m)
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmin (d, m (i, j));
+        octave_quit ();
+        result (i, j) = xmin (d, m (i, j));
       }
 
   return result;
 }
 
 FloatMatrix
 min (const FloatMatrix& m, float d)
 {
@@ -3316,45 +3316,45 @@ min (const FloatMatrix& m, float d)
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmin (m (i, j), d);
+        octave_quit ();
+        result (i, j) = xmin (m (i, j), d);
       }
 
   return result;
 }
 
 FloatMatrix
 min (const FloatMatrix& a, const FloatMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-	("two-arg min expecting args of same size");
+        ("two-arg min expecting args of same size");
       return FloatMatrix ();
     }
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmin (a (i, j), b (i, j));
+        octave_quit ();
+        result (i, j) = xmin (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 FloatMatrix
 max (float d, const FloatMatrix& m)
 {
@@ -3363,18 +3363,18 @@ max (float d, const FloatMatrix& m)
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmax (d, m (i, j));
+        octave_quit ();
+        result (i, j) = xmax (d, m (i, j));
       }
 
   return result;
 }
 
 FloatMatrix
 max (const FloatMatrix& m, float d)
 {
@@ -3383,45 +3383,45 @@ max (const FloatMatrix& m, float d)
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmax (m (i, j), d);
+        octave_quit ();
+        result (i, j) = xmax (m (i, j), d);
       }
 
   return result;
 }
 
 FloatMatrix
 max (const FloatMatrix& a, const FloatMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-	("two-arg max expecting args of same size");
+        ("two-arg max expecting args of same size");
       return FloatMatrix ();
     }
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = xmax (a (i, j), b (i, j));
+        octave_quit ();
+        result (i, j) = xmax (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 FloatMatrix linspace (const FloatColumnVector& x1, 
                       const FloatColumnVector& x2, 
                       octave_idx_type n)
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -76,17 +76,17 @@ FloatNDArray::fourier (int dim) const
 
   const float *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::fft (in + k * stride * n, out + k * stride * n, 
-		      n, howmany, stride, dist);
+                      n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
@@ -106,17 +106,17 @@ FloatNDArray::ifourier (int dim) const
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   FloatComplexNDArray retval (*this);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::ifft (out + k * stride * n, out + k * stride * n, 
-		      n, howmany, stride, dist);
+                      n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::fourier2d (void) const
 {
   dim_vector dv = dims();
@@ -231,27 +231,27 @@ FloatNDArray::fourier (int dim) const
   octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
-	{
-	  octave_quit ();
+        {
+          octave_quit ();
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    tmp[i] = elem((i + k*npts)*stride + j*dist);
+          for (octave_idx_type i = 0; i < npts; i++)
+            tmp[i] = elem((i + k*npts)*stride + j*dist);
 
-	  F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
+          F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    retval ((i + k*npts)*stride + j*dist) = tmp[i];
-	}
+          for (octave_idx_type i = 0; i < npts; i++)
+            retval ((i + k*npts)*stride + j*dist) = tmp[i];
+        }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier (int dim) const
 {
@@ -278,28 +278,28 @@ FloatNDArray::ifourier (int dim) const
   octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
   octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
-	{
-	  octave_quit ();
+        {
+          octave_quit ();
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    tmp[i] = elem((i + k*npts)*stride + j*dist);
+          for (octave_idx_type i = 0; i < npts; i++)
+            tmp[i] = elem((i + k*npts)*stride + j*dist);
 
-	  F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
+          F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
-	  for (octave_idx_type i = 0; i < npts; i++)
-	    retval ((i + k*npts)*stride + j*dist) = tmp[i] / 
-	      static_cast<float> (npts);
-	}
+          for (octave_idx_type i = 0; i < npts; i++)
+            retval ((i + k*npts)*stride + j*dist) = tmp[i] / 
+              static_cast<float> (npts);
+        }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::fourier2d (void) const
 {
@@ -315,37 +315,37 @@ FloatNDArray::fourier2d (void) const
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
+              F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l];
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l];
+            }
+        }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
 
 FloatComplexNDArray
@@ -363,38 +363,38 @@ FloatNDArray::ifourier2d (void) const
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
+              F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l] / 
-		  static_cast<float> (npts);
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l] / 
+                  static_cast<float> (npts);
+            }
+        }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
 
 FloatComplexNDArray
@@ -411,37 +411,37 @@ FloatNDArray::fourierNd (void) const
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
+              F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l];
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l];
+            }
+        }
 
       stride *= dv(i);
     }
 
   return retval;
 }
 
 FloatComplexNDArray
@@ -458,38 +458,38 @@ FloatNDArray::ifourierNd (void) const
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
-		 (howmany > stride ? stride : howmany));
+                 (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
-	{
-	  for (octave_idx_type j = 0; j < howmany; j++)
-	    {
-	      octave_quit ();
+        {
+          for (octave_idx_type j = 0; j < howmany; j++)
+            {
+              octave_quit ();
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		prow[l] = retval ((l + k*npts)*stride + j*dist);
+              for (octave_idx_type l = 0; l < npts; l++)
+                prow[l] = retval ((l + k*npts)*stride + j*dist);
 
-	      F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
+              F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
-	      for (octave_idx_type l = 0; l < npts; l++)
-		retval ((l + k*npts)*stride + j*dist) = prow[l] /
-		  static_cast<float> (npts);
-	    }
-	}
+              for (octave_idx_type l = 0; l < npts; l++)
+                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                  static_cast<float> (npts);
+            }
+        }
 
       stride *= dv(i);
     }
 
   return retval;
 }
 
 #endif
@@ -505,65 +505,65 @@ FloatNDArray::operator ! (void) const
 bool
 FloatNDArray::any_element_is_negative (bool neg_zero) const
 {
   octave_idx_type nel = nelem ();
 
   if (neg_zero)
     {
       for (octave_idx_type i = 0; i < nel; i++)
-	if (lo_ieee_signbit (elem (i)))
-	  return true;
+        if (lo_ieee_signbit (elem (i)))
+          return true;
     }
   else
     return mx_inline_any_negative (numel (), data ());
 
   return false;
 }
 
 bool
 FloatNDArray::any_element_is_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float val = elem (i);
       if (xisnan (val))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 FloatNDArray::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float val = elem (i);
       if (xisinf (val) || xisnan (val))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 FloatNDArray::any_element_not_one_or_zero (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float val = elem (i);
       if (val != 0 && val != 1)
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 FloatNDArray::all_elements_are_zero (void) const
 {
@@ -580,19 +580,19 @@ bool
 FloatNDArray::all_elements_are_int_or_inf_or_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float val = elem (i);
       if (xisnan (val) || D_NINT (val) == val)
-	continue;
+        continue;
       else
-	return false;
+        return false;
     }
 
   return true;
 }
 
 // Return nonzero if any element of M is not an integer.  Also extract
 // the largest and smallest values and return them in MAX_VAL and MIN_VAL.
 
@@ -609,56 +609,56 @@ FloatNDArray::all_integers (float& max_v
   else
     return false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float val = elem (i);
 
       if (val > max_val)
-	max_val = val;
+        max_val = val;
 
       if (val < min_val)
-	min_val = val;
+        min_val = val;
 
       if (D_NINT (val) != val)
-	return false;
+        return false;
     }
 
   return true;
 }
 
 bool
 FloatNDArray::all_integers (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
 
       if (D_NINT (val) != val)
-	return false;
+        return false;
     }
 
   return true;
 }
 
 bool
 FloatNDArray::too_large_for_float (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float val = elem (i);
 
       if (! (xisnan (val) || xisinf (val))
-	  && fabs (val) > FLT_MAX)
-	return true;
+          && fabs (val) > FLT_MAX)
+        return true;
     }
 
   return false;
 }
 
 // FIXME -- this is not quite the right thing.
 
 boolNDArray
@@ -786,32 +786,32 @@ FloatNDArray::concat (const charNDArray&
   charNDArray retval (dims ());
   octave_idx_type nel = numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float d = elem (i);
 
       if (xisnan (d))
-	{
-	  (*current_liboctave_error_handler)
-	    ("invalid conversion from NaN to character");
-	  return retval;
-	}
+        {
+          (*current_liboctave_error_handler)
+            ("invalid conversion from NaN to character");
+          return retval;
+        }
       else
-	{
-	  octave_idx_type ival = NINTbig (d);
+        {
+          octave_idx_type ival = NINTbig (d);
 
-	  if (ival < 0 || ival > UCHAR_MAX)
-	    // FIXME -- is there something
-	    // better we could do? Should we warn the user?
-	    ival = 0;
+          if (ival < 0 || ival > UCHAR_MAX)
+            // FIXME -- is there something
+            // better we could do? Should we warn the user?
+            ival = 0;
 
-	  retval.elem (i) = static_cast<char>(ival);
-	}
+          retval.elem (i) = static_cast<char>(ival);
+        }
     }
 
   if (rb.numel () == 0)
     return retval;
 
   retval.insert (rb, ra_idx);
   return retval;
 }
@@ -877,25 +877,25 @@ FloatNDArray::matrix_value (void) const
     (*current_liboctave_error_handler)
       ("invalid conversion of FloatNDArray to FloatMatrix");
 
   return retval;
 }
 
 void
 FloatNDArray::increment_index (Array<octave_idx_type>& ra_idx,
-			  const dim_vector& dimensions,
-			  int start_dimension)
+                          const dim_vector& dimensions,
+                          int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
 octave_idx_type
 FloatNDArray::compute_index (Array<octave_idx_type>& ra_idx,
-			const dim_vector& dimensions)
+                        const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 FloatNDArray
 FloatNDArray::diag (octave_idx_type k) const
 {
   return MArrayN<float>::diag (k);
@@ -920,23 +920,23 @@ std::istream&
 operator >> (std::istream& is, FloatNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < nel; i++)
-	  {
-	    tmp = octave_read_value<float> (is);
-	    if (is)
-	      a.elem (i) = tmp;
-	    else
-	      goto done;
-	  }
+          {
+            tmp = octave_read_value<float> (is);
+            if (is)
+              a.elem (i) = tmp;
+            else
+              goto done;
+          }
     }
 
  done:
 
   return is;
 }
 
 FloatNDArray
diff --git a/liboctave/fRowVector.cc b/liboctave/fRowVector.cc
--- a/liboctave/fRowVector.cc
+++ b/liboctave/fRowVector.cc
@@ -37,23 +37,23 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sgemv, SGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const octave_idx_type&, const octave_idx_type&, const float&,
-			   const float*, const octave_idx_type&, const float*,
-			   const octave_idx_type&, const float&, float*, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL);
+                           const octave_idx_type&, const octave_idx_type&, const float&,
+                           const float*, const octave_idx_type&, const float*,
+                           const octave_idx_type&, const float&, float*, const octave_idx_type&
+                           F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (xsdot, XSDOT) (const octave_idx_type&, const float*, const octave_idx_type&,
-			   const float*, const octave_idx_type&, float&);
+                           const float*, const octave_idx_type&, float&);
 }
 
 // Row Vector class.
 
 bool
 FloatRowVector::operator == (const FloatRowVector& a) const
 {
   octave_idx_type len = length ();
@@ -79,33 +79,33 @@ FloatRowVector::insert (const FloatRowVe
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
-	xelem (c+i) = a.elem (i);
+        xelem (c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatRowVector&
 FloatRowVector::fill (float val)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatRowVector&
 FloatRowVector::fill (float val, octave_idx_type c1, octave_idx_type c2)
 {
@@ -119,17 +119,17 @@ FloatRowVector::fill (float val, octave_
 
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type i = c1; i <= c2; i++)
-	xelem (i) = val;
+        xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatRowVector
 FloatRowVector::append (const FloatRowVector& a) const
 {
@@ -205,31 +205,31 @@ operator * (const FloatRowVector& v, con
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
       if (len == 0)
-	retval.resize (a_nc, 0.0);
+        retval.resize (a_nc, 0.0);
       else
-	{
-	  // Transpose A to form A'*x == (x'*A)'
+        {
+          // Transpose A to form A'*x == (x'*A)'
 
-	  octave_idx_type ld = a_nr;
+          octave_idx_type ld = a_nr;
 
-	  retval.resize (a_nc);
-	  float *y = retval.fortran_vec ();
+          retval.resize (a_nc);
+          float *y = retval.fortran_vec ();
 
-	  F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
-				   a_nr, a_nc, 1.0, a.data (),
-				   ld, v.data (), 1, 0.0, y, 1
-				   F77_CHAR_ARG_LEN (1)));
-	}
+          F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
+                                   a_nr, a_nc, 1.0, a.data (),
+                                   ld, v.data (), 1, 0.0, y, 1
+                                   F77_CHAR_ARG_LEN (1)));
+        }
     }
 
   return retval;
 }
 
 // other operations
 
 float
diff --git a/liboctave/file-stat.cc b/liboctave/file-stat.cc
--- a/liboctave/file-stat.cc
+++ b/liboctave/file-stat.cc
@@ -186,59 +186,59 @@ file_stat::update_internal (bool force)
       initialized = false;
       fail = false;
       
       std::string full_file_name = file_ops::tilde_expand (file_name);
 
 #if defined (__WIN32__)
       // Remove trailing slash.
       if (file_ops::is_dir_sep (full_file_name[full_file_name.length () - 1])
-	  && full_file_name.length () != 1
+          && full_file_name.length () != 1
           && ! (full_file_name.length() == 3 && full_file_name[1] == ':'))
         full_file_name.resize (full_file_name.length () - 1);
 #endif
 
       const char *cname = full_file_name.c_str ();
 
       struct stat buf;
 
       int status = follow_links ? stat (cname, &buf) : lstat (cname, &buf);
 
       if (status < 0)
-	{
-	  using namespace std;
+        {
+          using namespace std;
 
-	  fail = true;
-	  errmsg = strerror (errno);
-	}
+          fail = true;
+          errmsg = strerror (errno);
+        }
       else
-	{
-	  fs_mode = buf.st_mode;
-	  fs_ino = buf.st_ino;
-	  fs_dev = buf.st_dev;
-	  fs_nlink = buf.st_nlink;
-	  fs_uid = buf.st_uid;
-	  fs_gid = buf.st_gid;
-	  fs_size = buf.st_size;
-	  fs_atime = buf.st_atime;
-	  fs_mtime = buf.st_mtime;
-	  fs_ctime = buf.st_ctime;
+        {
+          fs_mode = buf.st_mode;
+          fs_ino = buf.st_ino;
+          fs_dev = buf.st_dev;
+          fs_nlink = buf.st_nlink;
+          fs_uid = buf.st_uid;
+          fs_gid = buf.st_gid;
+          fs_size = buf.st_size;
+          fs_atime = buf.st_atime;
+          fs_mtime = buf.st_mtime;
+          fs_ctime = buf.st_ctime;
 
 #if defined (HAVE_STRUCT_STAT_ST_RDEV)
-	  fs_rdev = buf.st_rdev;
+          fs_rdev = buf.st_rdev;
 #endif
 
 #if defined (HAVE_STRUCT_STAT_ST_BLKSIZE)
-	  fs_blksize = buf.st_blksize;
+          fs_blksize = buf.st_blksize;
 #endif
 
 #if defined (HAVE_STRUCT_STAT_ST_BLOCKS)
-	  fs_blocks = buf.st_blocks;
+          fs_blocks = buf.st_blocks;
 #endif
-	}
+        }
 
       initialized = true;
     }
 }
 
 void
 file_fstat::update_internal (bool force)
 {
@@ -247,43 +247,43 @@ file_fstat::update_internal (bool force)
       initialized = false;
       fail = false;
 
       struct stat buf;
 
       int status = fstat (fid, &buf);
 
       if (status < 0)
-	{
-	  using namespace std;
+        {
+          using namespace std;
 
-	  fail = true;
-	  errmsg = strerror (errno);
-	}
+          fail = true;
+          errmsg = strerror (errno);
+        }
       else
-	{
-	  fs_mode = buf.st_mode;
-	  fs_ino = buf.st_ino;
-	  fs_dev = buf.st_dev;
-	  fs_nlink = buf.st_nlink;
-	  fs_uid = buf.st_uid;
-	  fs_gid = buf.st_gid;
-	  fs_size = buf.st_size;
-	  fs_atime = buf.st_atime;
-	  fs_mtime = buf.st_mtime;
-	  fs_ctime = buf.st_ctime;
+        {
+          fs_mode = buf.st_mode;
+          fs_ino = buf.st_ino;
+          fs_dev = buf.st_dev;
+          fs_nlink = buf.st_nlink;
+          fs_uid = buf.st_uid;
+          fs_gid = buf.st_gid;
+          fs_size = buf.st_size;
+          fs_atime = buf.st_atime;
+          fs_mtime = buf.st_mtime;
+          fs_ctime = buf.st_ctime;
 
 #if defined (HAVE_STRUCT_STAT_ST_RDEV)
-	  fs_rdev = buf.st_rdev;
+          fs_rdev = buf.st_rdev;
 #endif
 
 #if defined (HAVE_STRUCT_STAT_ST_BLKSIZE)
-	  fs_blksize = buf.st_blksize;
+          fs_blksize = buf.st_blksize;
 #endif
 
 #if defined (HAVE_STRUCT_STAT_ST_BLOCKS)
-	  fs_blocks = buf.st_blocks;
+          fs_blocks = buf.st_blocks;
 #endif
-	}
+        }
 
       initialized = true;
     }
 }
diff --git a/liboctave/floatAEPBAL.cc b/liboctave/floatAEPBAL.cc
--- a/liboctave/floatAEPBAL.cc
+++ b/liboctave/floatAEPBAL.cc
@@ -30,28 +30,28 @@ along with Octave; see the file COPYING.
 
 #include "floatAEPBAL.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sgebal, SGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&,
-			     octave_idx_type&, float*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&,
+                             octave_idx_type&, float*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgebak, SGEBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
                              const float*, const octave_idx_type&, float*,
                              const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 FloatAEPBALANCE::FloatAEPBALANCE (const FloatMatrix& a, 
                                   bool noperm, bool noscal)
   : base_aepbal<FloatMatrix, FloatColumnVector> ()
 {
   octave_idx_type n = a.cols ();
 
@@ -67,18 +67,18 @@ FloatAEPBALANCE::FloatAEPBALANCE (const 
   float *pscale = scale.fortran_vec ();
 
   balanced_mat = a;
   float *p_balanced_mat = balanced_mat.fortran_vec ();
 
   job = noperm ? (noscal ? 'N' : 'S') : (noscal ? 'P' : 'B');
 
   F77_XFCN (sgebal, SGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     n, p_balanced_mat, n, ilo, ihi, pscale, info
-			     F77_CHAR_ARG_LEN (1)));
+                             n, p_balanced_mat, n, ilo, ihi, pscale, info
+                             F77_CHAR_ARG_LEN (1)));
 }
 
 FloatMatrix
 FloatAEPBALANCE::balancing_matrix (void) const
 {
   octave_idx_type n = balanced_mat.rows ();
   FloatMatrix balancing_mat (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
@@ -87,16 +87,16 @@ FloatAEPBALANCE::balancing_matrix (void)
   float *p_balancing_mat = balancing_mat.fortran_vec ();
   const float *pscale = scale.fortran_vec ();
 
   octave_idx_type info;
 
   char side = 'R';
 
   F77_XFCN (sgebak, SGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 (&side, 1),
-			     n, ilo, ihi, pscale, n,
-			     p_balancing_mat, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&side, 1),
+                             n, ilo, ihi, pscale, n,
+                             p_balancing_mat, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   return balancing_mat;
 }
diff --git a/liboctave/floatCHOL.cc b/liboctave/floatCHOL.cc
--- a/liboctave/floatCHOL.cc
+++ b/liboctave/floatCHOL.cc
@@ -37,29 +37,29 @@ along with Octave; see the file COPYING.
 #ifndef HAVE_QRUPDATE
 #include "dbleQR.h"
 #endif
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (spotrf, SPOTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     float*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             float*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (spotri, SPOTRI) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     float*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             float*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (spocon, SPOCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
-			     float*, const octave_idx_type&, const float&,
-			     float&, float*, octave_idx_type*, 
-			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+                             float*, const octave_idx_type&, const float&,
+                             float&, float*, octave_idx_type*, 
+                             octave_idx_type& F77_CHAR_ARG_LEN_DECL);
 #ifdef HAVE_QRUPDATE
 
   F77_RET_T
   F77_FUNC (sch1up, SCH1UP) (const octave_idx_type&, float*, const octave_idx_type&,
                              float*, float*);
 
   F77_RET_T
   F77_FUNC (sch1dn, SCH1DN) (const octave_idx_type&, float*, const octave_idx_type&,
@@ -107,37 +107,37 @@ FloatCHOL::init (const FloatMatrix& a, b
   float *h = chol_mat.fortran_vec ();
 
   // Calculate the norm of the matrix, for later use.
   float anorm = 0;
   if (calc_cond) 
     anorm = xnorm (a, 1);
 
   F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1),
-			     n, h, n, info
-			     F77_CHAR_ARG_LEN (1)));
+                             n, h, n, info
+                             F77_CHAR_ARG_LEN (1)));
 
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond) 
     {
       octave_idx_type spocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
       Array<float> z (3*n);
       float *pz = z.fortran_vec ();
       Array<octave_idx_type> iz (n);
       octave_idx_type *piz = iz.fortran_vec ();
       F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
-				 n, anorm, xrcond, pz, piz, spocon_info
-				 F77_CHAR_ARG_LEN (1)));
+                                 n, anorm, xrcond, pz, piz, spocon_info
+                                 F77_CHAR_ARG_LEN (1)));
 
       if (spocon_info != 0) 
-	info = -1;
+        info = -1;
     }
 
   return info;
 }
 
 static FloatMatrix
 chol2inv_internal (const FloatMatrix& r)
 {
@@ -150,31 +150,31 @@ chol2inv_internal (const FloatMatrix& r)
     {
       octave_idx_type n = r_nc;
       octave_idx_type info = 0;
 
       FloatMatrix tmp = r;
       float *v = tmp.fortran_vec();
 
       if (info == 0)
-	{
-	  F77_XFCN (spotri, SPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-				     v, n, info
-				     F77_CHAR_ARG_LEN (1)));
+        {
+          F77_XFCN (spotri, SPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
+                                     v, n, info
+                                     F77_CHAR_ARG_LEN (1)));
 
-	  // If someone thinks of a more graceful way of doing this (or
-	  // faster for that matter :-)), please let me know!
+          // If someone thinks of a more graceful way of doing this (or
+          // faster for that matter :-)), please let me know!
 
-	  if (n > 1)
-	    for (octave_idx_type j = 0; j < r_nc; j++)
-	      for (octave_idx_type i = j+1; i < r_nr; i++)
-		tmp.xelem (i, j) = tmp.xelem (j, i);
+          if (n > 1)
+            for (octave_idx_type j = 0; j < r_nc; j++)
+              for (octave_idx_type i = j+1; i < r_nr; i++)
+                tmp.xelem (i, j) = tmp.xelem (j, i);
 
-	  retval = tmp;
-	}
+          retval = tmp;
+        }
     }
   else
     (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
   return retval;
 }
 
 // Compute the inverse of a matrix using the Cholesky factorization.
diff --git a/liboctave/floatGEPBAL.cc b/liboctave/floatGEPBAL.cc
--- a/liboctave/floatGEPBAL.cc
+++ b/liboctave/floatGEPBAL.cc
@@ -32,37 +32,37 @@ along with Octave; see the file COPYING.
 #include "Array-util.h"
 #include "f77-fcn.h"
 #include "oct-locbuf.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sggbal, SGGBAL) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type& N,
-			     float* A, const octave_idx_type& LDA, float* B,
-			     const octave_idx_type& LDB, octave_idx_type& ILO, octave_idx_type& IHI,
-			     float* LSCALE, float* RSCALE,
-			     float* WORK, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL);
+                             float* A, const octave_idx_type& LDA, float* B,
+                             const octave_idx_type& LDB, octave_idx_type& ILO, octave_idx_type& IHI,
+                             float* LSCALE, float* RSCALE,
+                             float* WORK, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sggbak, SGGBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type& N, const octave_idx_type& ILO,
-			     const octave_idx_type& IHI, const float* LSCALE,
-			     const float* RSCALE, octave_idx_type& M, float* V,
-			     const octave_idx_type& LDV, octave_idx_type& INFO
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type& N, const octave_idx_type& ILO,
+                             const octave_idx_type& IHI, const float* LSCALE,
+                             const float* RSCALE, octave_idx_type& M, float* V,
+                             const octave_idx_type& LDV, octave_idx_type& INFO
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
 }
 
 octave_idx_type
 FloatGEPBALANCE::init (const FloatMatrix& a, const FloatMatrix& b, 
-		  const std::string& balance_job)
+                  const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("FloatGEPBALANCE requires square matrix");
       return -1;
     }
@@ -84,42 +84,42 @@ FloatGEPBALANCE::init (const FloatMatrix
   balanced_mat = a;
   float *p_balanced_mat = balanced_mat.fortran_vec ();
   balanced_mat2 = b;
   float *p_balanced_mat2 = balanced_mat2.fortran_vec ();
 
   char job = balance_job[0];
 
   F77_XFCN (sggbal, SGGBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     n, p_balanced_mat, n, p_balanced_mat2,
-			     n, ilo, ihi, plscale, prscale, pwork, info
-			     F77_CHAR_ARG_LEN  (1)));
+                             n, p_balanced_mat, n, p_balanced_mat2,
+                             n, ilo, ihi, plscale, prscale, pwork, info
+                             F77_CHAR_ARG_LEN  (1)));
 
   balancing_mat = FloatMatrix (n, n, 0.0);
   balancing_mat2 = FloatMatrix (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
     {
       octave_quit ();
       balancing_mat.elem (i ,i) = 1.0;
       balancing_mat2.elem (i ,i) = 1.0;
     }
 
   float *p_balancing_mat = balancing_mat.fortran_vec ();
   float *p_balancing_mat2 = balancing_mat2.fortran_vec ();
 
   // first left
   F77_XFCN (sggbak, SGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 ("L", 1),
-			     n, ilo, ihi, plscale, prscale,
-			     n, p_balancing_mat, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 ("L", 1),
+                             n, ilo, ihi, plscale, prscale,
+                             n, p_balancing_mat, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
       
   // then right
   F77_XFCN (sggbak, SGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 ("R", 1),
-			     n, ilo, ihi, plscale, prscale,
-			     n, p_balancing_mat2, n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 ("R", 1),
+                             n, ilo, ihi, plscale, prscale,
+                             n, p_balancing_mat2, n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
diff --git a/liboctave/floatHESS.cc b/liboctave/floatHESS.cc
--- a/liboctave/floatHESS.cc
+++ b/liboctave/floatHESS.cc
@@ -28,37 +28,37 @@ along with Octave; see the file COPYING.
 #include "floatHESS.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sgebal, SGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&,
-			     octave_idx_type&, float*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL);
+                             const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&,
+                             octave_idx_type&, float*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgehrd, SGEHRD) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     float*, const octave_idx_type&, float*, float*,
-			     const octave_idx_type&, octave_idx_type&);
+                             float*, const octave_idx_type&, float*, float*,
+                             const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (sorghr, SORGHR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
-			     float*, const octave_idx_type&, float*, float*,
-			     const octave_idx_type&, octave_idx_type&);
+                             float*, const octave_idx_type&, float*, float*,
+                             const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (sgebak, SGEBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, float*,
-			     const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, float*,
+                             const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 octave_idx_type
 FloatHESS::init (const FloatMatrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
@@ -79,44 +79,44 @@ FloatHESS::init (const FloatMatrix& a)
 
   hess_mat = a;
   float *h = hess_mat.fortran_vec ();
 
   Array<float> scale (n);
   float *pscale = scale.fortran_vec ();
 
   F77_XFCN (sgebal, SGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     n, h, n, ilo, ihi, pscale, info
-			     F77_CHAR_ARG_LEN (1)));
+                             n, h, n, ilo, ihi, pscale, info
+                             F77_CHAR_ARG_LEN (1)));
 
   Array<float> tau (n-1);
   float *ptau = tau.fortran_vec ();
 
   Array<float> work (lwork);
   float *pwork = work.fortran_vec ();
 
   F77_XFCN (sgehrd, SGEHRD, (n, ilo, ihi, h, n, ptau, pwork,
-			     lwork, info));
+                             lwork, info));
 
   unitary_hess_mat = hess_mat;
   float *z = unitary_hess_mat.fortran_vec ();
 
   F77_XFCN (sorghr, SORGHR, (n, ilo, ihi, z, n, ptau, pwork,
-			     lwork, info));
+                             lwork, info));
 
   F77_XFCN (sgebak, SGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-			     F77_CONST_CHAR_ARG2 (&side, 1),
-			     n, ilo, ihi, pscale, n, z,
-			     n, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&side, 1),
+                             n, ilo, ihi, pscale, n, z,
+                             n, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   // If someone thinks of a more graceful way of doing
   // this (or faster for that matter :-)), please let
   // me know!
 
   if (n > 2)
     for (octave_idx_type j = 0; j < a_nc; j++)
       for (octave_idx_type i = j+2; i < a_nr; i++)
-	hess_mat.elem (i, j) = 0;
+        hess_mat.elem (i, j) = 0;
 
   return info;
 }
diff --git a/liboctave/floatLU.cc b/liboctave/floatLU.cc
--- a/liboctave/floatLU.cc
+++ b/liboctave/floatLU.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 template class base_lu <FloatMatrix>;
 
 // Define the constructor for this particular derivation.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sgetrf, SGETRF) (const octave_idx_type&, const octave_idx_type&, float*,
-			     const octave_idx_type&, octave_idx_type*, octave_idx_type&);
+                             const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 
 #ifdef HAVE_QRUPDATE_LUU
   F77_RET_T
   F77_FUNC (slu1up, SLU1UP) (const octave_idx_type&, const octave_idx_type&,
                              float *, const octave_idx_type&,
                              float *, const octave_idx_type&,
                              float *, float *);
 
diff --git a/liboctave/floatQR.cc b/liboctave/floatQR.cc
--- a/liboctave/floatQR.cc
+++ b/liboctave/floatQR.cc
@@ -37,21 +37,21 @@ along with Octave; see the file COPYING.
 #include "base-qr.cc"
 
 template class base_qr<FloatMatrix>;
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sgeqrf, SGEQRF) (const octave_idx_type&, const octave_idx_type&, float*, const octave_idx_type&,
-			     float*, float*, const octave_idx_type&, octave_idx_type&); 
+                             float*, float*, const octave_idx_type&, octave_idx_type&); 
 
   F77_RET_T
   F77_FUNC (sorgqr, SORGQR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, float*,
-			     const octave_idx_type&, float*, float*, const octave_idx_type&, octave_idx_type&);
+                             const octave_idx_type&, float*, float*, const octave_idx_type&, octave_idx_type&);
 
 #ifdef HAVE_QRUPDATE
 
   F77_RET_T
   F77_FUNC (sqr1up, SQR1UP) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
                              float*, const octave_idx_type&, float*, const octave_idx_type&,
                              float*, float*, float*);
 
@@ -124,21 +124,21 @@ void FloatQR::form (octave_idx_type n, F
                     float *tau, qr_type_t qr_type)
 {
   octave_idx_type m = afact.rows (), min_mn = std::min (m, n);
   octave_idx_type info;
 
   if (qr_type == qr_type_raw)
     {
       for (octave_idx_type j = 0; j < min_mn; j++)
-	{
-	  octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
-	  for (octave_idx_type i = limit + 1; i < m; i++)
-	    afact.elem (i, j) *= tau[j];
-	}
+        {
+          octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
+          for (octave_idx_type i = limit + 1; i < m; i++)
+            afact.elem (i, j) *= tau[j];
+        }
 
       r = afact;
     }
   else
     {
       // Attempt to minimize copying.
       if (m >= n)
         {
@@ -175,17 +175,17 @@ void FloatQR::form (octave_idx_type n, F
           octave_idx_type k = q.columns ();
           // workspace query.
           float rlwork;
           F77_XFCN (sorgqr, SORGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      &rlwork, -1, info));
 
           // allocate buffer and do the job.
           octave_idx_type lwork = rlwork;
-	  lwork = std::max (lwork, static_cast<octave_idx_type> (1));
+          lwork = std::max (lwork, static_cast<octave_idx_type> (1));
           OCTAVE_LOCAL_BUFFER (float, work, lwork);
           F77_XFCN (sorgqr, SORGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      work, lwork, info));
         }
     }
 }
 
 #ifdef HAVE_QRUPDATE
@@ -291,17 +291,17 @@ FloatQR::insert_col (const FloatMatrix& 
       else
         {
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (float, w, kmax);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
-	  octave_idx_type ii = i;
+          octave_idx_type ii = i;
           FloatColumnVector utmp = u.column (jsi(i));
           F77_XFCN (sqrinc, SQRINC, (m, n + ii, std::min (kmax, k + ii), 
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1, 
                                      utmp.data (), w));
         }
     }
 }
@@ -314,17 +314,17 @@ FloatQR::delete_col (octave_idx_type j)
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1) 
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (float, w, k);
       F77_XFCN (sqrdec, SQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
-				 r.fortran_vec (), r.rows (), j + 1, w));
+                                 r.fortran_vec (), r.rows (), j + 1, w));
 
       if (k < m)
         {
           q.resize (m, k-1);
           r.resize (k-1, n-1);
         }
       else
         {
@@ -351,17 +351,17 @@ FloatQR::delete_col (const Array<octave_
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, w, k);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
-	  octave_idx_type ii = i;
+          octave_idx_type ii = i;
           F77_XFCN (sqrdec, SQRDEC, (m, n - ii, k == m ? k : k - ii, 
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1, w));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
@@ -387,17 +387,17 @@ FloatQR::insert_row (const FloatRowVecto
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       FloatRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, w, k);
       F77_XFCN (sqrinr, SQRINR, (m, n, q.fortran_vec (), q.rows (),
-				 r.fortran_vec (), r.rows (), 
+                                 r.fortran_vec (), r.rows (), 
                                  j + 1, utmp.fortran_vec (), w));
 
     }
 }
 
 void
 FloatQR::delete_row (octave_idx_type j)
 {
@@ -407,17 +407,17 @@ FloatQR::delete_row (octave_idx_type j)
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
   else if (j < 0 || j > m-1) 
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (float, w, 2*m);
       F77_XFCN (sqrder, SQRDER, (m, n, q.fortran_vec (), q.rows (),
-				 r.fortran_vec (), r.rows (), j + 1,
+                                 r.fortran_vec (), r.rows (), j + 1,
                                  w));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 }
 
 void
diff --git a/liboctave/floatQRP.cc b/liboctave/floatQRP.cc
--- a/liboctave/floatQRP.cc
+++ b/liboctave/floatQRP.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sgeqp3, SGEQP3) (const octave_idx_type&, const octave_idx_type&, float*,
-			     const octave_idx_type&, octave_idx_type*, float*, float*,
+                             const octave_idx_type&, octave_idx_type*, float*, float*,
                              const octave_idx_type&, octave_idx_type&);
 }
 
 // It would be best to share some of this code with QR class...
 
 FloatQRP::FloatQRP (const FloatMatrix& a, qr_type_t qr_type)
   : FloatQR (), p ()
 {
diff --git a/liboctave/floatSCHUR.cc b/liboctave/floatSCHUR.cc
--- a/liboctave/floatSCHUR.cc
+++ b/liboctave/floatSCHUR.cc
@@ -30,26 +30,26 @@ along with Octave; see the file COPYING.
 #include "floatSCHUR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sgeesx, SGEESX) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     FloatSCHUR::select_function,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&,
-			     float*, float*, float*, const octave_idx_type&,
-			     float&, float&, float*, const octave_idx_type&,
-			     octave_idx_type*, const octave_idx_type&, octave_idx_type*, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             FloatSCHUR::select_function,
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, float*, const octave_idx_type&, octave_idx_type&,
+                             float*, float*, float*, const octave_idx_type&,
+                             float&, float&, float*, const octave_idx_type&,
+                             octave_idx_type*, const octave_idx_type&, octave_idx_type*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 static octave_idx_type
 select_ana (const float& a, const float&)
 {
    return (a < 0.0);
 }
 
@@ -123,24 +123,24 @@ FloatSCHUR::init (const FloatMatrix& a, 
   // BWORK is not referenced for the non-ordered Schur routine.
   Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
   Array<octave_idx_type> iwork (liwork);
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   F77_XFCN (sgeesx, SGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
-			     F77_CONST_CHAR_ARG2 (&sort, 1),
-			     selector,
-			     F77_CONST_CHAR_ARG2 (&sense, 1),
-			     n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
-			     pwork, lwork, piwork, liwork, pbwork, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&sort, 1),
+                             selector,
+                             F77_CONST_CHAR_ARG2 (&sense, 1),
+                             n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
+                             pwork, lwork, piwork, liwork, pbwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
 
 std::ostream&
 operator << (std::ostream& os, const FloatSCHUR& a)
 {
   os << a.schur_matrix () << "\n";
diff --git a/liboctave/floatSVD.cc b/liboctave/floatSVD.cc
--- a/liboctave/floatSVD.cc
+++ b/liboctave/floatSVD.cc
@@ -29,45 +29,45 @@ along with Octave; see the file COPYING.
 
 #include "floatSVD.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sgesvd, SGESVD) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const octave_idx_type&, const octave_idx_type&, float*,
-			     const octave_idx_type&, float*, float*,
-			     const octave_idx_type&, float*, const octave_idx_type&,
-			     float*, const octave_idx_type&, octave_idx_type&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const octave_idx_type&, float*,
+                             const octave_idx_type&, float*, float*,
+                             const octave_idx_type&, float*, const octave_idx_type&,
+                             float*, const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 }
 
 FloatMatrix
 FloatSVD::left_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
     {
       (*current_liboctave_error_handler)
-	("FloatSVD: U not computed because type == SVD::sigma_only");
+        ("FloatSVD: U not computed because type == SVD::sigma_only");
       return FloatMatrix ();
     }
   else
     return left_sm;
 }
 
 FloatMatrix
 FloatSVD::right_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
     {
       (*current_liboctave_error_handler)
-	("FloatSVD: V not computed because type == SVD::sigma_only");
+        ("FloatSVD: V not computed because type == SVD::sigma_only");
       return FloatMatrix ();
     }
   else
     return right_sm;
 }
 
 octave_idx_type
 FloatSVD::init (const FloatMatrix& a, SVD::type svd_type)
@@ -136,31 +136,31 @@ FloatSVD::init (const FloatMatrix& a, SV
   octave_idx_type lwork = -1;
 
   Array<float> work (1);
 
   octave_idx_type one = 1;
   octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
 
   F77_XFCN (sgesvd, SGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
-			     F77_CONST_CHAR_ARG2 (&jobv, 1),
-			     m, n, tmp_data, m1, s_vec, u, m1, vt,
-			     nrow_vt1, work.fortran_vec (), lwork, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&jobv, 1),
+                             m, n, tmp_data, m1, s_vec, u, m1, vt,
+                             nrow_vt1, work.fortran_vec (), lwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   lwork = static_cast<octave_idx_type> (work(0));
   work.resize (lwork);
 
   F77_XFCN (sgesvd, SGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
-			     F77_CONST_CHAR_ARG2 (&jobv, 1),
-			     m, n, tmp_data, m1, s_vec, u, m1, vt,
-			     nrow_vt1, work.fortran_vec (), lwork, info
-			     F77_CHAR_ARG_LEN (1)
-			     F77_CHAR_ARG_LEN (1)));
+                             F77_CONST_CHAR_ARG2 (&jobv, 1),
+                             m, n, tmp_data, m1, s_vec, u, m1, vt,
+                             nrow_vt1, work.fortran_vec (), lwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm = right_sm.transpose ();
 
   return info;
 }
 
 std::ostream&
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -375,34 +375,34 @@ idx_vector::idx_vector_rep::idx_vector_r
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type [len];
 
       octave_idx_type ntot = bnda.length ();
 
       octave_idx_type k = 0;
       for (octave_idx_type i = 0; i < ntot; i++)
-	if (bnda.xelem (i)) d[k++] = i;
+        if (bnda.xelem (i)) d[k++] = i;
 
       data = d;
 
       ext = d[k-1] + 1;
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Sparse<bool>& bnda)
   : data (0), len (0), ext (0), aowner (0), orig_dims ()
 {
   for (octave_idx_type i = 0, l = bnda.nnz (); i < l; i++)
     if (bnda.data (i)) len++;
 
   dim_vector dv = bnda.dims ();
 
   orig_dims = ((dv.length () == 2 && dv(0) == 1)
-	       ? dim_vector (1, len) : orig_dims = dim_vector (len, 1));
+               ? dim_vector (1, len) : orig_dims = dim_vector (len, 1));
 
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type [len];
 
       octave_idx_type nnz = bnda.nnz ();
 
       octave_idx_type k = 0;
@@ -865,17 +865,17 @@ bool idx_vector::maybe_reduce (octave_id
       break;
     }
 
   return reduced;
 }
 
 bool
 idx_vector::is_cont_range (octave_idx_type n,
-			   octave_idx_type& l, octave_idx_type& u) const
+                           octave_idx_type& l, octave_idx_type& u) const
 {
   bool res = false;
   switch (rep->idx_class ())
     {
     case class_colon:
       l = 0; u = n;
       res = true;
       break;
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -51,17 +51,17 @@ intNDArray<T>::any_element_not_one_or_ze
 {
   octave_idx_type nel = this->nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       T val = this->elem (i);
 
       if (val != 0.0 && val != 1.0)
-	return true;
+        return true;
     }
 
   return false;
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::diag (octave_idx_type k) const
@@ -83,26 +83,26 @@ boolNDArray
 intNDArray<T>::any (int dim) const
 {
   return do_mx_red_op<boolNDArray, T > (*this, dim, mx_inline_any);
 }
 
 template <class T>
 void
 intNDArray<T>::increment_index (Array<octave_idx_type>& ra_idx,
-			       const dim_vector& dimensions,
-			       int start_dimension)
+                               const dim_vector& dimensions,
+                               int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
 template <class T>
 octave_idx_type 
 intNDArray<T>::compute_index (Array<octave_idx_type>& ra_idx,
-			      const dim_vector& dimensions)
+                              const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::concat (const intNDArray<T>& rb, const Array<octave_idx_type>& ra_idx)
 {
@@ -147,24 +147,24 @@ operator >> (std::istream& is, intNDArra
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       T tmp;
 
       for (octave_idx_type i = 0; i < nel; i++)
-	{
-	  is >> tmp;
+        {
+          is >> tmp;
 
-	  if (is)
-	    a.elem (i) = tmp;
-	  else
-	    goto done;
-	}
+          if (is)
+            a.elem (i) = tmp;
+          else
+            goto done;
+        }
     }
 
  done:
 
   return is;
 }
 
 // FIXME -- should abs and signum just be mapper functions?
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -35,35 +35,35 @@ 02110-1301, USA.  */
    myself; if you do, I'd be grateful for any changes. --kb@mail.tug.org */
 
 /* If we have either DOS or OS2, we are DOSISH.  */
 #if defined (DOS) || defined (OS2) || defined (WIN32) || defined(__MSDOS__)
 #define DOSISH
 #endif
 
 #if defined (DOSISH)
-#define MONOCASE_FILENAMES	/* case-insensitive filename comparisons */
+#define MONOCASE_FILENAMES      /* case-insensitive filename comparisons */
 #endif
 
 extern "C" {
 #if defined(__MINGW32__)
 #include <windows.h>
 #include <fcntl.h>
 #include <dirent.h>
 #elif defined(WIN32)
 #define __STDC__ 1
 #ifndef _MSC_VER
 #include "win32lib.h"
 #endif
 #endif /* not WIN32 */
 
 #ifdef __DJGPP__
-#include <fcntl.h>	/* for long filenames' stuff */
-#include <dir.h>	/* for `getdisk' */
-#include <io.h>		/* for `setmode' */
+#include <fcntl.h>      /* for long filenames' stuff */
+#include <dir.h>        /* for `getdisk' */
+#include <io.h>         /* for `setmode' */
 #endif
 }
 
 /* Some drivers have partially integrated kpathsea changes.  */
 #ifndef KPATHSEA
 #define KPATHSEA 32
 #endif
  
@@ -168,38 +168,38 @@ extern "C" {
 #ifndef NO_DEBUG
 
 /* OK, we'll have tracing support.  */
 #define KPSE_DEBUG
 
 /* Test if a bit is on.  */
 #define KPSE_DEBUG_P(bit) (kpathsea_debug & (1 << (bit)))
 
-#define KPSE_DEBUG_STAT 0		/* stat calls */
-#define KPSE_DEBUG_HASH 1		/* hash lookups */
-#define KPSE_DEBUG_FOPEN 2		/* fopen/fclose calls */
-#define KPSE_DEBUG_PATHS 3		/* search path initializations */
-#define KPSE_DEBUG_EXPAND 4		/* path element expansion */
-#define KPSE_DEBUG_SEARCH 5		/* searches */
-#define KPSE_DEBUG_VARS 6		/* variable values */
+#define KPSE_DEBUG_STAT 0               /* stat calls */
+#define KPSE_DEBUG_HASH 1               /* hash lookups */
+#define KPSE_DEBUG_FOPEN 2              /* fopen/fclose calls */
+#define KPSE_DEBUG_PATHS 3              /* search path initializations */
+#define KPSE_DEBUG_EXPAND 4             /* path element expansion */
+#define KPSE_DEBUG_SEARCH 5             /* searches */
+#define KPSE_DEBUG_VARS 6               /* variable values */
 #define KPSE_LAST_DEBUG KPSE_DEBUG_VARS
 
 /* A printf for the debugging.  */
 #define DEBUGF_START() do { fputs ("kdebug:", stderr)
 #define DEBUGF_END()        fflush (stderr); } while (0)
 
-#define DEBUGF(str)							\
+#define DEBUGF(str)                                                     \
   DEBUGF_START (); fputs (str, stderr); DEBUGF_END ()
-#define DEBUGF1(str, e1)						\
+#define DEBUGF1(str, e1)                                                \
   DEBUGF_START (); fprintf (stderr, str, e1); DEBUGF_END ()
-#define DEBUGF2(str, e1, e2)						\
+#define DEBUGF2(str, e1, e2)                                            \
   DEBUGF_START (); fprintf (stderr, str, e1, e2); DEBUGF_END ()
-#define DEBUGF3(str, e1, e2, e3)					\
+#define DEBUGF3(str, e1, e2, e3)                                        \
   DEBUGF_START (); fprintf (stderr, str, e1, e2, e3); DEBUGF_END ()
-#define DEBUGF4(str, e1, e2, e3, e4)					\
+#define DEBUGF4(str, e1, e2, e3, e4)                                    \
   DEBUGF_START (); fprintf (stderr, str, e1, e2, e3, e4); DEBUGF_END ()
 
 #undef fopen
 #define fopen kpse_fopen_trace
 static FILE *fopen (const char *filename, const char *mode);
 
 #endif /* not NO_DEBUG */
 
@@ -302,20 +302,20 @@ static void str_llist_float (str_llist_t
 
 static std::string kpse_var_expand (const std::string& src);
 
 static str_llist_type *kpse_element_dirs (const std::string& elt);
 
 static std::string kpse_expand (const std::string& s);
 
 static std::string kpse_expand_default (const std::string& path,
-					const std::string& dflt);
+                                        const std::string& dflt);
 
 static string_vector kpse_db_search (const std::string& name,
-				     const std::string& path_elt, bool all);
+                                     const std::string& path_elt, bool all);
 
 #include <ctime> /* for `time' */
 
 static bool
 kpse_is_env_sep (char c)
 {
   return IS_ENV_SEP (c);
 }
@@ -387,21 +387,21 @@ hash_lookup (hash_table_type table, cons
 #ifdef KPSE_DEBUG
   if (KPSE_DEBUG_P (KPSE_DEBUG_HASH))
     {
       DEBUGF1 ("hash_lookup (%s) =>", key.c_str ());
       if (ret.empty ())
         fputs (" (nil)\n", stderr);
       else
         {
-	  int len = ret.length ();
-	  for (int i = 0; i < len; i++)
+          int len = ret.length ();
+          for (int i = 0; i < len; i++)
             {
               putc (' ', stderr);
-	      fputs (ret[i].c_str (), stderr);
+              fputs (ret[i].c_str (), stderr);
             }
           putc ('\n', stderr);
         }
       fflush (stderr);
     }
 #endif
 
   return ret;
@@ -438,42 +438,42 @@ private:
   size_t e;
   size_t len;
 
   void set_end (void)
     {
       e = b + 1;
 
       if (e == len)
-	; /* OK, we have found the last element.  */
+        ; /* OK, we have found the last element.  */
       else if (e > len)
-	b = e = std::string::npos;
+        b = e = std::string::npos;
       else
-	{
-	  /* Find the next colon not enclosed by braces (or the end of
-	     the path).  */
-
-	  int brace_level = 0;
-	  while (e < len && ! (brace_level == 0 && kpse_is_env_sep (path[e])))
-	    e++;
-	}
+        {
+          /* Find the next colon not enclosed by braces (or the end of
+             the path).  */
+
+          int brace_level = 0;
+          while (e < len && ! (brace_level == 0 && kpse_is_env_sep (path[e])))
+            e++;
+        }
     }
 
   void next (void)
     {
       b = e + 1;
 
       /* Skip any consecutive colons.  */
       while (b < len && kpse_is_env_sep (path[b]))
-	b++;
+        b++;
 
       if (b >= len)
-	b = e = std::string::npos;
+        b = e = std::string::npos;
       else
-	set_end ();
+        set_end ();
     }
 
   // No assignment.
   kpse_path_iterator& operator = (const kpse_path_iterator&);
 };
 
 /* Here's the simple one, when a program just wants a value.  */
 
@@ -485,17 +485,17 @@ kpse_var_value (const std::string& var)
   std::string tmp = octave_env::getenv (var);
 
   if (! tmp.empty ())
     ret = kpse_var_expand (tmp);
 
 #ifdef KPSE_DEBUG
   if (KPSE_DEBUG_P (KPSE_DEBUG_VARS))
     DEBUGF2 ("variable: %s = %s\n", var.c_str (),
-	     tmp.empty () ? "(nil)" :  tmp.c_str ());
+             tmp.empty () ? "(nil)" :  tmp.c_str ());
 #endif
 
   return ret;
 }
 
 /* Truncate any too-long components in NAME, returning the result.  It's
    too bad this is necessary.  See comments in readable.c for why.  */
 
@@ -508,22 +508,22 @@ kpse_truncate_filename (const std::strin
   std::string ret = name;
 
   size_t len = name.length ();
 
   for (size_t i = 0; i < len; i++)
     {
       if (IS_DIR_SEP (name[i]) || IS_DEVICE_SEP (name[i]))
         {
-	  /* At a directory delimiter, reset component length.  */
+          /* At a directory delimiter, reset component length.  */
           c_len = 0;
         }
       else if (c_len > NAME_MAX)
         {
-	  /* If past the max for a component, ignore this character.  */
+          /* If past the max for a component, ignore this character.  */
           continue;
         }
 
       /* Copy this character.  */
       ret[ret_len++] = name[i];
       c_len++;
     }
 
@@ -538,25 +538,25 @@ kpse_truncate_filename (const std::strin
    kinds of devices.  */
 
 #ifdef WIN32
 static inline bool
 READABLE (const std::string& fn, struct stat&)
 {
   const char *t = fn.c_str ();
   return (GetFileAttributes (t) != 0xFFFFFFFF
-	  && ! (GetFileAttributes (t) & FILE_ATTRIBUTE_DIRECTORY));
+          && ! (GetFileAttributes (t) & FILE_ATTRIBUTE_DIRECTORY));
 }
 #else
 static inline bool
 READABLE (const std::string& fn, struct stat& st)
 {
   const char *t = fn.c_str ();
   return (access (t, R_OK) == 0
-	  && stat (t, &(st)) == 0 && ! S_ISDIR (st.st_mode));
+          && stat (t, &(st)) == 0 && ! S_ISDIR (st.st_mode));
 }
 #endif
 
 /* POSIX invented the brain-damage of not necessarily truncating
    filename components; the system's behavior is defined by the value of
    the symbol _POSIX_NO_TRUNC, but you can't change it dynamically!
 
    Generic const return warning.  See extend-fname.c.  */
@@ -573,34 +573,34 @@ kpse_readable_file (const std::string& n
 
 #ifdef ENAMETOOLONG
     }
   else if (errno == ENAMETOOLONG)
     {
       ret = kpse_truncate_filename (name);
 
       /* Perhaps some other error will occur with the truncated name,
-	 so let's call access again.  */
+         so let's call access again.  */
 
       if (! READABLE (ret, st))
-	{
-	  /* Failed.  */
-	  ret = std::string ();
-	}
+        {
+          /* Failed.  */
+          ret = std::string ();
+        }
 #endif /* ENAMETOOLONG */
 
     }
   else
     {
       /* Some other error.  */
       if (errno == EACCES)
-	{
-	  /* Maybe warn them if permissions are bad.  */
-	  perror (name.c_str ());
-	}
+        {
+          /* Maybe warn them if permissions are bad.  */
+          perror (name.c_str ());
+        }
 
       ret = std::string ();
     }
 
   return ret;
 }
 
 /* Sorry this is such a system-dependent mess, but I can't see any way
@@ -620,19 +620,19 @@ kpse_absolute_p (const std::string& file
                      /* UNC names */
     || (len > 1 && filename[0] == '\\' && filename[1] == '\\')
 #endif
     ;
 
   int explicit_relative
     = relative_ok
       && (len > 1
-	  && filename[0] == '.'
-	  && (IS_DIR_SEP (filename[1])
-	      || (len > 2 && filename[1] == '.' && IS_DIR_SEP (filename[2]))));
+          && filename[0] == '.'
+          && (IS_DIR_SEP (filename[1])
+              || (len > 2 && filename[1] == '.' && IS_DIR_SEP (filename[2]))));
 
   return absolute || explicit_relative;
 }
 
 /* The very first search is for texmf.cnf, called when someone tries to
    initialize the TFM path or whatever.  init_path calls kpse_cnf_get
    which calls kpse_all_path_search to find all the texmf.cnf's.  We
    need to do various special things in this case, since we obviously
@@ -653,59 +653,59 @@ log_search (const string_vector& filenam
   if (first_time)
     {
       first_time = false;
 
       /* Get name from either envvar or config file.  */
       std::string log_name = kpse_var_value ("TEXMFLOG");
 
       if (! log_name.empty ())
-	{
-	  log_file = xfopen (log_name.c_str (), "a");
-
-	  if (! log_file)
-	    perror (log_name.c_str ());
-	}
+        {
+          log_file = xfopen (log_name.c_str (), "a");
+
+          if (! log_file)
+            perror (log_name.c_str ());
+        }
     }
 
   if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH) || log_file)
     {
       /* FILENAMES should never be null, but safety doesn't hurt.  */
       for (int e = 0; e < filenames.length () && ! filenames[e].empty (); e++)
-	{
-	  std::string filename = filenames[e];
-
-	  /* Only record absolute filenames, for privacy.  */
-	  if (log_file && kpse_absolute_p (filename.c_str (), false))
-	    fprintf (log_file, "%lu %s\n",
-		     static_cast<unsigned long> (time (0)),
-		     filename.c_str ());
-
-	  /* And show them online, if debugging.  We've already started
-	     the debugging line in `search', where this is called, so
-	     just print the filename here, don't use DEBUGF.  */
-	  if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
-	    fputs (filename.c_str (), stderr);
-	}
+        {
+          std::string filename = filenames[e];
+
+          /* Only record absolute filenames, for privacy.  */
+          if (log_file && kpse_absolute_p (filename.c_str (), false))
+            fprintf (log_file, "%lu %s\n",
+                     static_cast<unsigned long> (time (0)),
+                     filename.c_str ());
+
+          /* And show them online, if debugging.  We've already started
+             the debugging line in `search', where this is called, so
+             just print the filename here, don't use DEBUGF.  */
+          if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
+            fputs (filename.c_str (), stderr);
+        }
     }
 }
 
 /* Concatenate each element in DIRS with NAME (assume each ends with a
    /, to save time).  If SEARCH_ALL is false, return the first readable
    regular file.  Else continue to search for more.  In any case, if
    none, return a list containing just NULL.
 
    We keep a single buffer for the potential filenames and reallocate
    only when necessary.  I'm not sure it's noticeably faster, but it
    does seem cleaner.  (We do waste a bit of space in the return
    value, though, since we don't shrink it to the final size returned.)  */
 
 static string_vector
 dir_list_search (str_llist_type *dirs, const std::string& name,
-		 bool search_all)
+                 bool search_all)
 {
   str_llist_elt_type *elt;
   string_vector ret;
 
   for (elt = *dirs; elt; elt = STR_LLIST_NEXT (*elt))
     {
       const std::string dir = STR_LLIST (*elt);
 
@@ -744,104 +744,104 @@ absolute_search (const std::string& name
   return ret_list;
 }
 
 /* This is the hard case -- look for NAME in PATH.  If ALL is false,
    return the first file found.  Otherwise, search all elements of PATH.  */
 
 static string_vector
 path_search (const std::string& path, const std::string& name,
-	     bool /* must_exist */, bool all)
+             bool /* must_exist */, bool all)
 {
   string_vector ret_list;
   bool done = false;
 
   for (kpse_path_iterator pi (path); ! done && pi != std::string::npos; pi++)
     {
       std::string elt = *pi;
 
       string_vector found;
       bool allow_disk_search = true;
 
       if (elt.length () > 1 && elt[0] == '!' && elt[1] == '!')
-	{
-	  /* Those magic leading chars in a path element means don't
-	     search the disk for this elt.  And move past the magic to
-	     get to the name.  */
-	  allow_disk_search = false;
-	  elt = elt.substr (2);
-	}
+        {
+          /* Those magic leading chars in a path element means don't
+             search the disk for this elt.  And move past the magic to
+             get to the name.  */
+          allow_disk_search = false;
+          elt = elt.substr (2);
+        }
 
       /* Do not touch the device if present */
       if (NAME_BEGINS_WITH_DEVICE (elt))
-	{
-	  while (elt.length () > 3
-		 && IS_DIR_SEP (elt[2]) && IS_DIR_SEP (elt[3]))
-	    {
-	      elt[2] = elt[1];
-	      elt[1] = elt[0];
-	      elt = elt.substr (1);
-	    }
-	}
+        {
+          while (elt.length () > 3
+                 && IS_DIR_SEP (elt[2]) && IS_DIR_SEP (elt[3]))
+            {
+              elt[2] = elt[1];
+              elt[1] = elt[0];
+              elt = elt.substr (1);
+            }
+        }
       else
-	{
-	  /* We never want to search the whole disk.  */
-	  while (elt.length () > 1
-		 && IS_DIR_SEP (elt[0]) && IS_DIR_SEP (elt[1]))
-	    elt = elt.substr (1);
-	}
+        {
+          /* We never want to search the whole disk.  */
+          while (elt.length () > 1
+                 && IS_DIR_SEP (elt[0]) && IS_DIR_SEP (elt[1]))
+            elt = elt.substr (1);
+        }
 
       /* Try ls-R, unless we're searching for texmf.cnf.  Our caller
-	 (search), also tests first_search, and does the resetting.  */
+         (search), also tests first_search, and does the resetting.  */
       found = first_search
-	? string_vector () : kpse_db_search (name, elt, all);
+        ? string_vector () : kpse_db_search (name, elt, all);
 
       /* Search the filesystem if (1) the path spec allows it, and either
          (2a) we are searching for texmf.cnf ; or
          (2b) no db exists; or
          (2c) no db's are relevant to this elt; or
          (3) MUST_EXIST && NAME was not in the db.
-	 In (2*), `found' will be NULL.
-	 In (3),  `found' will be an empty list. */
+         In (2*), `found' will be NULL.
+         In (3),  `found' will be an empty list. */
 
       if (allow_disk_search && found.empty ())
-	{
-	  str_llist_type *dirs = kpse_element_dirs (elt);
-
-	  if (dirs && *dirs)
-	    found = dir_list_search (dirs, name, all);
-	}
+        {
+          str_llist_type *dirs = kpse_element_dirs (elt);
+
+          if (dirs && *dirs)
+            found = dir_list_search (dirs, name, all);
+        }
 
       /* Did we find anything anywhere?  */
       if (! found.empty ())
-	{
-	  if (all)
-	    ret_list.append (found);
-	  else
-	    {
-	      ret_list.append (found[0]);
-	      done = true;
-	    }
-	}
+        {
+          if (all)
+            ret_list.append (found);
+          else
+            {
+              ret_list.append (found[0]);
+              done = true;
+            }
+        }
     }
 
   return ret_list;
 }
 
 /* Search PATH for ORIGINAL_NAME.  If ALL is false, or ORIGINAL_NAME is
    absolute_p, check ORIGINAL_NAME itself.  Otherwise, look at each
    element of PATH for the first readable ORIGINAL_NAME.
 
    Always return a list; if no files are found, the list will
    contain just NULL.  If ALL is true, the list will be
    terminated with NULL.  */
 
 static string_vector
 search (const std::string& path, const std::string& original_name,
-	bool must_exist, bool all)
+        bool must_exist, bool all)
 {
   string_vector ret_list;
   bool absolute_p;
 
   /* Make a leading ~ count as an absolute filename, and expand $FOO's.  */
   std::string name = kpse_expand (original_name);
 
   /* If the first name is absolute or explicitly relative, no need to
@@ -860,25 +860,25 @@ search (const std::string& path, const s
      we want to allow setting TEXMFLOG in texmf.cnf.  */
   if (first_search)
     {
       first_search = false;
     }
   else
     {
       /* Record the filenames we found, if desired.  And wrap them in a
-	 debugging line if we're doing that.  */
+         debugging line if we're doing that.  */
 
       if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
-	DEBUGF1 ("search (%s) =>", original_name.c_str ());
+        DEBUGF1 ("search (%s) =>", original_name.c_str ());
 
       log_search (ret_list);
 
       if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
-	putc ('\n', stderr);
+        putc ('\n', stderr);
     }
 
   return ret_list;
 }
 
 /* Search PATH for the first NAME.  */
 
 /* Call `kpse_expand' on NAME.  If the result is an absolute or
@@ -896,17 +896,17 @@ search (const std::string& path, const s
    
    The caller must expand PATH. This is because it makes more sense to
    do this once, in advance, instead of for every search using it.
    
    In any case, return the complete filename if found, otherwise NULL.  */
 
 static std::string
 kpse_path_search (const std::string& path, const std::string& name,
-		  bool must_exist)
+                  bool must_exist)
 {
   string_vector ret_list = search (path, name, must_exist, false);
 
   return ret_list.empty () ? std::string () : ret_list[0];
 }
 
 /* Search all elements of PATH for files named NAME.  Not sure if it's
    right to assert `must_exist' here, but it suffices now.  */
@@ -921,227 +921,227 @@ kpse_all_path_search (const std::string&
 }
 
 /* This is the hard case -- look in each element of PATH for each
    element of NAMES.  If ALL is false, return the first file found.
    Otherwise, search all elements of PATH.  */
 
 static string_vector
 path_find_first_of (const std::string& path, const string_vector& names,
-		    bool /* must_exist */, bool all)
+                    bool /* must_exist */, bool all)
 {
   string_vector ret_list;
   bool done = false;
 
   for (kpse_path_iterator pi (path); ! done && pi != std::string::npos; pi++)
     {
       std::string elt = *pi;
 
       str_llist_type *dirs;
       str_llist_elt_type *dirs_elt;
       string_vector found;
       bool allow_disk_search = true;
 
       if (elt.length () > 1 && elt[0] == '!' && elt[1] == '!')
-	{
-	  /* Those magic leading chars in a path element means don't
-	     search the disk for this elt.  And move past the magic to
-	     get to the name.  */
-
-	  allow_disk_search = false;
-	  elt = elt.substr (2);
-	}
+        {
+          /* Those magic leading chars in a path element means don't
+             search the disk for this elt.  And move past the magic to
+             get to the name.  */
+
+          allow_disk_search = false;
+          elt = elt.substr (2);
+        }
 
       /* Do not touch the device if present */
 
       if (NAME_BEGINS_WITH_DEVICE (elt))
-	{
-	  while (elt.length () > 3
-		 && IS_DIR_SEP (elt[2]) && IS_DIR_SEP (elt[3]))
-	    {
-	      elt[2] = elt[1];
-	      elt[1] = elt[0];
-	      elt = elt.substr (1);
-	    }
-	}
+        {
+          while (elt.length () > 3
+                 && IS_DIR_SEP (elt[2]) && IS_DIR_SEP (elt[3]))
+            {
+              elt[2] = elt[1];
+              elt[1] = elt[0];
+              elt = elt.substr (1);
+            }
+        }
       else
-	{
-	  /* We never want to search the whole disk.  */
-	  while (elt.length () > 1
-		 && IS_DIR_SEP (elt[0]) && IS_DIR_SEP (elt[1]))
-	    elt = elt.substr (1);
-	}
+        {
+          /* We never want to search the whole disk.  */
+          while (elt.length () > 1
+                 && IS_DIR_SEP (elt[0]) && IS_DIR_SEP (elt[1]))
+            elt = elt.substr (1);
+        }
 
       /* We have to search one directory at a time.  */
       dirs = kpse_element_dirs (elt);
       for (dirs_elt = *dirs; dirs_elt; dirs_elt = STR_LLIST_NEXT (*dirs_elt))
-	{
-	  const std::string dir = STR_LLIST (*dirs_elt);
-
-	  int len = names.length ();
-	  for (int i = 0; i < len && !done; i++)
-	    {
-	      std::string name = names[i];
-
-	      /* Try ls-R, unless we're searching for texmf.cnf.  Our caller
-		 (find_first_of), also tests first_search, and does the
-		 resetting.  */
-	      found = first_search
-		? string_vector () : kpse_db_search (name, dir.c_str (), all);
-
-	      /* Search the filesystem if (1) the path spec allows it,
-		 and either
-
-		   (2a) we are searching for texmf.cnf ; or
-		   (2b) no db exists; or
-		   (2c) no db's are relevant to this elt; or
-		   (3) MUST_EXIST && NAME was not in the db.
-
-		 In (2*), `found' will be NULL.
-		 In (3),  `found' will be an empty list. */
-
-	      if (allow_disk_search && found.empty ())
-		{
-		  static str_llist_type *tmp = 0;
-
-		  if (! tmp)
-		    {
-		      tmp = new str_llist_type;
-		      *tmp = 0;
-		      str_llist_add (tmp, "");
-		    }
-
-		  STR_LLIST (*(*tmp)) = dir;
-
-		  found = dir_list_search (tmp, name, all);
-		}
-
-	      /* Did we find anything anywhere?  */
-	      if (! found.empty ())
-		{
-		  if (all)
-		    ret_list.append (found);
-		  else
-		    {
-		      ret_list.append (found[0]);
-		      done = true;
-		    }
-		}
-	    }
-	}
+        {
+          const std::string dir = STR_LLIST (*dirs_elt);
+
+          int len = names.length ();
+          for (int i = 0; i < len && !done; i++)
+            {
+              std::string name = names[i];
+
+              /* Try ls-R, unless we're searching for texmf.cnf.  Our caller
+                 (find_first_of), also tests first_search, and does the
+                 resetting.  */
+              found = first_search
+                ? string_vector () : kpse_db_search (name, dir.c_str (), all);
+
+              /* Search the filesystem if (1) the path spec allows it,
+                 and either
+
+                   (2a) we are searching for texmf.cnf ; or
+                   (2b) no db exists; or
+                   (2c) no db's are relevant to this elt; or
+                   (3) MUST_EXIST && NAME was not in the db.
+
+                 In (2*), `found' will be NULL.
+                 In (3),  `found' will be an empty list. */
+
+              if (allow_disk_search && found.empty ())
+                {
+                  static str_llist_type *tmp = 0;
+
+                  if (! tmp)
+                    {
+                      tmp = new str_llist_type;
+                      *tmp = 0;
+                      str_llist_add (tmp, "");
+                    }
+
+                  STR_LLIST (*(*tmp)) = dir;
+
+                  found = dir_list_search (tmp, name, all);
+                }
+
+              /* Did we find anything anywhere?  */
+              if (! found.empty ())
+                {
+                  if (all)
+                    ret_list.append (found);
+                  else
+                    {
+                      ret_list.append (found[0]);
+                      done = true;
+                    }
+                }
+            }
+        }
     }
 
   return ret_list;
 }
 
 static string_vector
 find_first_of (const std::string& path, const string_vector& names,
-	       bool must_exist, bool all)
+               bool must_exist, bool all)
 {
   string_vector ret_list;
 
   if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
     {
       fputs ("start find_first_of ((", stderr);
 
       int len = names.length ();
 
       for (int i = 0; i < len; i++)
-	{
-	  if (i == 0)
-	    fputs (names[i].c_str (), stderr);
-	  else
-	    fprintf (stderr, ", %s", names[i].c_str ());
-	}
+        {
+          if (i == 0)
+            fputs (names[i].c_str (), stderr);
+          else
+            fprintf (stderr, ", %s", names[i].c_str ());
+        }
 
       fprintf (stderr, "), path=%s, must_exist=%d).\n",
-	       path.c_str (), must_exist);
+               path.c_str (), must_exist);
     }
 
   for (int i = 0; i < names.length (); i++)
     {
       std::string name = names[i];
 
       if (kpse_absolute_p (name, true))
-	{
-	  /* If the name is absolute or explicitly relative, no need
-	     to consider PATH at all.  If we find something, then we
-	     are done.  */
-
-	  ret_list = absolute_search (name);
-
-	  if (! ret_list.empty ())
-	    return ret_list;
-	}
+        {
+          /* If the name is absolute or explicitly relative, no need
+             to consider PATH at all.  If we find something, then we
+             are done.  */
+
+          ret_list = absolute_search (name);
+
+          if (! ret_list.empty ())
+            return ret_list;
+        }
     }
 
   /* Find the file. */
   ret_list = path_find_first_of (path, names, must_exist, all);
 
   /* The very first search is for texmf.cnf.  We can't log that, since
      we want to allow setting TEXMFLOG in texmf.cnf.  */
   if (first_search)
     {
       first_search = false;
     }
   else
     {
       /* Record the filenames we found, if desired.  And wrap them in a
-	 debugging line if we're doing that.  */
+         debugging line if we're doing that.  */
 
       if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
-	{
-	  fputs ("find_first_of (", stderr);
-
-	  int len = names.length ();
-
-	  for (int i = 0; i < len; i++)
-	    {
-	      if (i == 0)
-		fputs (names[i].c_str (), stderr);
-	      else
-		fprintf (stderr, ", %s", names[i].c_str ());
-	    }
-	  fputs (") =>", stderr);
-	}
+        {
+          fputs ("find_first_of (", stderr);
+
+          int len = names.length ();
+
+          for (int i = 0; i < len; i++)
+            {
+              if (i == 0)
+                fputs (names[i].c_str (), stderr);
+              else
+                fprintf (stderr, ", %s", names[i].c_str ());
+            }
+          fputs (") =>", stderr);
+        }
 
       log_search (ret_list);
 
       if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
-	putc ('\n', stderr);
+        putc ('\n', stderr);
     }
 
   return ret_list;
 }
 
 /* Search each element of PATH for each element of NAMES.  Return the
    first one found.  */
 
 /* Search each element of PATH for each element in the list of NAMES.
    Return the first one found.  */
 
 static std::string
 kpse_path_find_first_of (const std::string& path, const string_vector& names,
-			 bool must_exist)
+                         bool must_exist)
 {
   string_vector ret_list = find_first_of (path, names, must_exist, false);
 
   return ret_list.empty () ? std::string () : ret_list[0];
 }
 
 /* Search each element of PATH for each element of NAMES and return a
    list containing everything found, in the order found.  */
 
 /* Like `kpse_path_find_first_of' with MUST_EXIST true, but return a
    list of all the filenames (or NULL if none), instead of taking the
    first.  */
 
 static string_vector
 kpse_all_path_find_first_of (const std::string& path,
-			     const string_vector& names)
+                             const string_vector& names)
 {
   return find_first_of (path, names, true, true);
 }
 
 /* General expansion.  Some of this file (the brace-expansion
    code from bash) is covered by the GPL; this is the only GPL-covered
    code in kpathsea.  The part of the file that I wrote (the first
    couple of functions) is covered by the LGPL.  */
@@ -1156,51 +1156,51 @@ kpse_tilde_expand (const std::string& na
   std::string expansion;
 
   /* If no leading tilde, do nothing.  */
   if (name.empty () || name[0] != '~')
     {
       expansion = name;
 
       /* If a bare tilde, return the home directory or `.'.  (Very
-	 unlikely that the directory name will do anyone any good, but
-	 ...  */
+         unlikely that the directory name will do anyone any good, but
+         ...  */
     }
   else if (name.length () == 1)
     {
       expansion = octave_env::getenv ("HOME");
 
       if (expansion.empty ())
-	expansion = ".";
+        expansion = ".";
 
       /* If `~/', remove any trailing / or replace leading // in $HOME.
-	 Should really check for doubled intermediate slashes, too.  */
+         Should really check for doubled intermediate slashes, too.  */
     }
   else if (IS_DIR_SEP (name[1]))
     {
       unsigned c = 1;
       std::string home = octave_env::getenv ("HOME");
 
       if (home.empty ())
-	home = ".";
+        home = ".";
 
       size_t home_len = home.length ();
 
       /* handle leading // */
       if (home_len > 1 && IS_DIR_SEP (home[0]) && IS_DIR_SEP (home[1]))
-	home = home.substr (1);
+        home = home.substr (1);
 
       /* omit / after ~ */
       if (IS_DIR_SEP (home[home_len - 1]))
-	c++;
+        c++;
 
       expansion = home + name.substr (c);
 
       /* If `~user' or `~user/', look up user in the passwd database (but
-	 OS/2 doesn't have this concept.  */
+         OS/2 doesn't have this concept.  */
     }
   else
 #ifdef HAVE_PWD_H
     {
       unsigned c = 2;
 
       /* find user name */
       while (name.length () > c && ! IS_DIR_SEP (name[c]))
@@ -1211,17 +1211,17 @@ kpse_tilde_expand (const std::string& na
       /* We only need the cast here for (deficient) systems
          which do not declare `getpwnam' in <pwd.h>.  */
       octave_passwd p = octave_passwd::getpwnam (user);
 
       /* If no such user, just use `.'.  */
       std::string home = p ? p.dir () : std::string (".");
 
       if (home.empty ())
-	home = ".";
+        home = ".";
 
       /* handle leading // */
       if (home.length () > 1 && IS_DIR_SEP (home[0]) && IS_DIR_SEP (home[1]))
         home = home.substr (1);
 
       /* If HOME ends in /, omit the / after ~user. */
       if (name.length () > c && IS_DIR_SEP (home[home.length () - 1]))
         c++;
@@ -1263,29 +1263,29 @@ kpse_expand_kpse_dot (const std::string&
   if (kpse_dot.empty ())
     return path;
 
   for (kpse_path_iterator pi (path); pi != std::string::npos; pi++)
     {
       std::string elt = *pi;
 
       /* We assume that the !! magic is only used on absolute components.
-	 Single "." get special treatment, as does "./" or its  equivalent.  */
+         Single "." get special treatment, as does "./" or its  equivalent.  */
 
       size_t elt_len = elt.length ();
 
       if (kpse_absolute_p (elt, false)
-	  || (elt_len > 1 && elt[0] == '!' && elt[1] == '!'))
-	ret += elt + ENV_SEP_STRING;
+          || (elt_len > 1 && elt[0] == '!' && elt[1] == '!'))
+        ret += elt + ENV_SEP_STRING;
       else if (elt_len == 1 && elt[0] == '.')
-	ret += kpse_dot + ENV_SEP_STRING;
+        ret += kpse_dot + ENV_SEP_STRING;
       else if (elt_len > 1 && elt[0] == '.' && IS_DIR_SEP (elt[1]))
-	ret += kpse_dot + elt.substr (1) + ENV_SEP_STRING;
+        ret += kpse_dot + elt.substr (1) + ENV_SEP_STRING;
       else
-	ret += kpse_dot + DIR_SEP_STRING + elt + ENV_SEP_STRING;
+        ret += kpse_dot + DIR_SEP_STRING + elt + ENV_SEP_STRING;
     }
 
   int len = ret.length ();
   if (len > 0)
     ret.resize (len-1);
 
   return ret;
 }
@@ -1303,23 +1303,23 @@ kpse_brace_expand_element (const std::st
   string_vector expansions = brace_expand (elt);
 
   for (int i = 0; i < expansions.length (); i++)
     {
       /* Do $ and ~ expansion on each element.  */
       std::string x = kpse_expand (expansions[i]);
 
       if (x != expansions[i])
-	{
-	  /* If we did any expansions, do brace expansion again.  Since
-	     recursive variable definitions are not allowed, this recursion
-	     must terminate.  (In practice, it's unlikely there will ever be
-	     more than one level of recursion.)  */
-	  x = kpse_brace_expand_element (x);
-	}
+        {
+          /* If we did any expansions, do brace expansion again.  Since
+             recursive variable definitions are not allowed, this recursion
+             must terminate.  (In practice, it's unlikely there will ever be
+             more than one level of recursion.)  */
+          x = kpse_brace_expand_element (x);
+        }
 
       ret += x + ENV_SEP_STRING;
     }
 
   ret.resize (ret.length () - 1);
 
   return ret;
 }
@@ -1382,65 +1382,65 @@ kpse_path_expand (const std::string& pat
   for (kpse_path_iterator pi (tmp); pi != std::string::npos; pi++)
     {
       std::string elt = *pi;
 
       str_llist_type *dirs;
 
       /* Skip and ignore magic leading chars.  */
       if (elt.length () > 1 && elt[0] == '!' && elt[1] == '!')
-	elt = elt.substr (2);
+        elt = elt.substr (2);
 
       /* Do not touch the device if present */
       if (NAME_BEGINS_WITH_DEVICE (elt))
-	{
-	  while (elt.length () > 3
-		 && IS_DIR_SEP (elt[2]) && IS_DIR_SEP (elt[3]))
-	    {
-	      elt[2] = elt[1];
-	      elt[1] = elt[0];
-	      elt = elt.substr (1);
-	    }
-	}
+        {
+          while (elt.length () > 3
+                 && IS_DIR_SEP (elt[2]) && IS_DIR_SEP (elt[3]))
+            {
+              elt[2] = elt[1];
+              elt[1] = elt[0];
+              elt = elt.substr (1);
+            }
+        }
       else
-	{
-	  /* We never want to search the whole disk.  */
-	  while (elt.length () > 1
-		 && IS_DIR_SEP (elt[0]) && IS_DIR_SEP (elt[1]))
-	    elt = elt.substr (1);
-	}
+        {
+          /* We never want to search the whole disk.  */
+          while (elt.length () > 1
+                 && IS_DIR_SEP (elt[0]) && IS_DIR_SEP (elt[1]))
+            elt = elt.substr (1);
+        }
 
       /* Search the disk for all dirs in the component specified.
-	 Be faster to check the database, but this is more reliable.  */
+         Be faster to check the database, but this is more reliable.  */
       dirs = kpse_element_dirs (elt);
 
       if (dirs && *dirs)
-	{
-	  str_llist_elt_type *dir;
-
-	  for (dir = *dirs; dir; dir = STR_LLIST_NEXT (*dir))
-	    {
-	      const std::string thedir = STR_LLIST (*dir);
-	      unsigned dirlen = thedir.length ();
-
-	      ret += thedir;
-	      len += dirlen;
-
-	      /* Retain trailing slash if that's the root directory.  */
-	      if (dirlen == 1
-		  || (dirlen == 3 && NAME_BEGINS_WITH_DEVICE (thedir)
-		      && IS_DIR_SEP (thedir[2])))
-		{
-		  ret += ENV_SEP_STRING;
-		  len++;
-		}
-
-	      ret[len-1] = ENV_SEP;
-	    }
-	}
+        {
+          str_llist_elt_type *dir;
+
+          for (dir = *dirs; dir; dir = STR_LLIST_NEXT (*dir))
+            {
+              const std::string thedir = STR_LLIST (*dir);
+              unsigned dirlen = thedir.length ();
+
+              ret += thedir;
+              len += dirlen;
+
+              /* Retain trailing slash if that's the root directory.  */
+              if (dirlen == 1
+                  || (dirlen == 3 && NAME_BEGINS_WITH_DEVICE (thedir)
+                      && IS_DIR_SEP (thedir[2])))
+                {
+                  ret += ENV_SEP_STRING;
+                  len++;
+                }
+
+              ret[len-1] = ENV_SEP;
+            }
+        }
     }
 
   if (len > 0)
     ret.resize (len-1);
 
   return ret;
 }
 
@@ -1493,18 +1493,18 @@ array_concat (const string_vector& arr1,
     {
       int len1 = arr1.length ();
       int len2 = arr2.length ();
 
       result = string_vector (len1 * len2);
 
       int k = 0;
       for (int i = 0; i < len2; i++)
-	for (int j = 0; j < len1; j++)
-	  result[k++] = arr1[j] + arr2[i];
+        for (int j = 0; j < len1; j++)
+          result[k++] = arr1[j] + arr2[i];
     }
 
   return result;
 }
 
 static int brace_gobbler (const std::string&, int&, int);
 static string_vector expand_amble (const std::string&);
 
@@ -1523,30 +1523,30 @@ brace_expand (const std::string& text)
   if (c == '{')
     {
       /* Find the amble.  This is the stuff inside this set of braces. */
       int start = ++i;
       c = brace_gobbler (text, i, '}');
 
       /* What if there isn't a matching close brace? */
       if (! c)
-	{
-	  (*current_liboctave_warning_handler)
-	    ("%s: Unmatched {", text.c_str ());
-
-	  result = string_vector (text);
-	}
+        {
+          (*current_liboctave_warning_handler)
+            ("%s: Unmatched {", text.c_str ());
+
+          result = string_vector (text);
+        }
       else
-	{
-	  std::string amble = text.substr (start, i-start);
-	  result = array_concat (result, expand_amble (amble));
-
-	  std::string postamble = text.substr (i+1);
-	  result = array_concat (result, brace_expand (postamble));
-	}
+        {
+          std::string amble = text.substr (start, i-start);
+          result = array_concat (result, expand_amble (amble));
+
+          std::string postamble = text.substr (i+1);
+          result = array_concat (result, brace_expand (postamble));
+        }
     }
 
   return result;
 }
 
 /* The character which is used to separate arguments. */
 static int brace_arg_separator = ',';
 
@@ -1572,19 +1572,19 @@ expand_amble (const std::string& text)
       c = c0 | c1;
       i = (i0 < i1 ? i0 : i1);
 
       std::string tem = text.substr (start, i-start);
 
       string_vector partial = brace_expand (tem);
 
       if (result.empty ())
-	result = partial;
+        result = partial;
       else
-	result.append (partial);
+        result.append (partial);
     }
 
   return result;
 }
 
 /* Start at INDEX, and skip characters in TEXT. Set INDEX to the
    index of the character matching SATISFY.  This understands about
    quoting.  Return the character that caused us to stop searching;
@@ -1598,102 +1598,102 @@ brace_gobbler (const std::string& text, 
 
   size_t i = indx;
 
   for (; i < text_len; i++)
     {
       c = text[i];
 
       if (pass_next)
-	{
-	  pass_next = 0;
-	  continue;
-	}
+        {
+          pass_next = 0;
+          continue;
+        }
 
       /* A backslash escapes the next character.  This allows backslash to
-	 escape the quote character in a double-quoted string. */
+         escape the quote character in a double-quoted string. */
       if (c == '\\' && (quoted == 0 || quoted == '"' || quoted == '`'))
         {
           pass_next = 1;
           continue;
         }
 
       if (quoted)
-	{
-	  if (c == quoted)
-	    quoted = 0;
-	  continue;
-	}
+        {
+          if (c == quoted)
+            quoted = 0;
+          continue;
+        }
 
       if (c == '"' || c == '\'' || c == '`')
-	{
-	  quoted = c;
-	  continue;
-	}
+        {
+          quoted = c;
+          continue;
+        }
 
       if (c == satisfy && !level && !quoted)
-	{
-	  /* We ignore an open brace surrounded by whitespace, and also
-	     an open brace followed immediately by a close brace, that
-	     was preceded with whitespace.  */
-	  if (c == '{' &&
-	      ((i == 0 || brace_whitespace (text[i-1])) &&
-	       (i+1 < text_len &&
-		(brace_whitespace (text[i+1]) || text[i+1] == '}'))))
-	    continue;
-	  /* If this is being compiled as part of bash, ignore the `{'
-	     in a `${}' construct */
-	  if ((c != '{') || i == 0 || (text[i-1] != '$'))
-	    break;
-	}
+        {
+          /* We ignore an open brace surrounded by whitespace, and also
+             an open brace followed immediately by a close brace, that
+             was preceded with whitespace.  */
+          if (c == '{' &&
+              ((i == 0 || brace_whitespace (text[i-1])) &&
+               (i+1 < text_len &&
+                (brace_whitespace (text[i+1]) || text[i+1] == '}'))))
+            continue;
+          /* If this is being compiled as part of bash, ignore the `{'
+             in a `${}' construct */
+          if ((c != '{') || i == 0 || (text[i-1] != '$'))
+            break;
+        }
 
       if (c == '{')
-	level++;
+        level++;
       else if (c == '}' && level)
-	level--;
+        level--;
     }
 
   indx = i;
   return c;
 }
 
 /* For each file format, we record the following information.  The main
    thing that is not part of this structure is the environment variable
    lists. They are used directly in tex-file.c. We could incorporate
    them here, but it would complicate the code a bit. We could also do
    it via variable expansion, but not now, maybe not ever:
    ${PKFONTS-${TEXFONTS-/usr/local/lib/texmf/fonts//}}.  */
 
 struct kpse_format_info_type
 {
-  std::string type;	     /* Human-readable description.  */
-  std::string path;	     /* The search path to use.  */
-  std::string raw_path;	     /* Pre-$~ (but post-default) expansion.  */
+  std::string type;          /* Human-readable description.  */
+  std::string path;          /* The search path to use.  */
+  std::string raw_path;      /* Pre-$~ (but post-default) expansion.  */
   std::string path_source;   /* Where the path started from.  */
   std::string override_path; /* From client environment variable.  */
   std::string client_path;   /* E.g., from dvips's config.ps.  */
-  std::string cnf_path;	     /* From texmf.cnf.  */
+  std::string cnf_path;      /* From texmf.cnf.  */
   std::string default_path;  /* If all else fails.  */
-  string_vector suffix;	     /* For kpse_find_file to check for/append.  */
+  string_vector suffix;      /* For kpse_find_file to check for/append.  */
 };
 
 /* The sole variable of that type, indexed by `kpse_file_format_type'.
    Initialized by calls to `kpse_find_file' for `kpse_init_format'.  */
 static kpse_format_info_type kpse_format_info;
 
 /* And EXPAND_DEFAULT calls kpse_expand_default on try_path and the
    present info->path.  */
 #define EXPAND_DEFAULT(try_path, source_string) \
   do \
     { \
       if (! try_path.empty ()) \
         { \
-          info.raw_path = try_path;	\
+          info.raw_path = try_path;     \
           info.path = kpse_expand_default (try_path, info.path); \
-          info.path_source = source_string;	\
+          info.path_source = source_string;     \
         } \
     } \
   while (0)
 
 static hash_table_type db; /* The hash table for all the ls-R's.  */
 
 static hash_table_type alias_db;
 
@@ -1710,68 +1710,68 @@ match (const std::string& filename_arg, 
   const char *path_elt = path_elt_arg.c_str ();
 
   const char *original_filename = filename;
   bool matched = false;
 
   for (; *filename && *path_elt; filename++, path_elt++)
     {
       if (*filename == *path_elt) /* normal character match */
-	;
+        ;
 
       else if (IS_DIR_SEP (*path_elt)  /* at // */
-	       && original_filename < filename && IS_DIR_SEP (path_elt[-1]))
-	{
-	  while (IS_DIR_SEP (*path_elt))
-	    path_elt++; /* get past second and any subsequent /'s */
-
-	  if (*path_elt == 0)
-	    {
-	      /* Trailing //, matches anything. We could make this
-		 part of the other case, but it seems pointless to do
-		 the extra work.  */
-	      matched = true;
-	      break;
-	    }
-	  else
-	    {
-	      /* Intermediate //, have to match rest of PATH_ELT.  */
-	      for (; !matched && *filename; filename++)
-		{
-		  /* Try matching at each possible character.  */
-		  if (IS_DIR_SEP (filename[-1]) && *filename == *path_elt)
-		    matched = match (filename, path_elt);
-		}
-
-	      /* Prevent filename++ when *filename='\0'. */
-	      break;
-	    }
-	}
+               && original_filename < filename && IS_DIR_SEP (path_elt[-1]))
+        {
+          while (IS_DIR_SEP (*path_elt))
+            path_elt++; /* get past second and any subsequent /'s */
+
+          if (*path_elt == 0)
+            {
+              /* Trailing //, matches anything. We could make this
+                 part of the other case, but it seems pointless to do
+                 the extra work.  */
+              matched = true;
+              break;
+            }
+          else
+            {
+              /* Intermediate //, have to match rest of PATH_ELT.  */
+              for (; !matched && *filename; filename++)
+                {
+                  /* Try matching at each possible character.  */
+                  if (IS_DIR_SEP (filename[-1]) && *filename == *path_elt)
+                    matched = match (filename, path_elt);
+                }
+
+              /* Prevent filename++ when *filename='\0'. */
+              break;
+            }
+        }
       else
-	/* normal character nonmatch, quit */
-	break;
+        /* normal character nonmatch, quit */
+        break;
     }
 
   /* If we've reached the end of PATH_ELT, check that we're at the last
      component of FILENAME, we've matched.  */
   if (! matched && *path_elt == 0)
     {
       /* Probably PATH_ELT ended with `vf' or some such, and FILENAME
-	 ends with `vf/ptmr.vf'.  In that case, we'll be at a
-	 directory separator.  On the other hand, if PATH_ELT ended
-	 with a / (as in `vf/'), FILENAME being the same `vf/ptmr.vf',
-	 we'll be at the `p'.  Upshot: if we're at a dir separator in
-	 FILENAME, skip it.  But if not, that's ok, as long as there
-	 are no more dir separators.  */
+         ends with `vf/ptmr.vf'.  In that case, we'll be at a
+         directory separator.  On the other hand, if PATH_ELT ended
+         with a / (as in `vf/'), FILENAME being the same `vf/ptmr.vf',
+         we'll be at the `p'.  Upshot: if we're at a dir separator in
+         FILENAME, skip it.  But if not, that's ok, as long as there
+         are no more dir separators.  */
 
       if (IS_DIR_SEP (*filename))
-	filename++;
+        filename++;
 
       while (*filename && !IS_DIR_SEP (*filename))
-	filename++;
+        filename++;
 
       matched = *filename == 0;
     }
 
   return matched;
 }
 
 /* If DB_DIR is a prefix of PATH_ELT, return true; otherwise false.
@@ -1794,38 +1794,38 @@ elt_in_db (const std::string& db_dir, co
 
   size_t i = 0;
 
   while (! found && db_dir[i] == path_elt[i])
     {
       i++;
       /* If we've matched the entire db directory, it's good.  */
       if (i == db_dir_len)
-	found = true;
+        found = true;
 
     /* If we've reached the end of PATH_ELT, but not the end of the db
        directory, it's no good.  */
       else if (i == path_elt_len)
-	break;
+        break;
     }
 
   return found;
 }
 
 /* Avoid doing anything if this PATH_ELT is irrelevant to the databases. */
 
 /* Return list of matches for NAME in the ls-R file matching PATH_ELT.  If
    ALL is set, return (null-terminated list) of all matches, else just
    the first.  If no matches, return a pointer to an empty list.  If no
    databases can be read, or PATH_ELT is not in any of the databases,
    return NULL.  */
 
 static string_vector
 kpse_db_search (const std::string& name_arg,
-		const std::string& orig_path_elt, bool all)
+                const std::string& orig_path_elt, bool all)
 {
   bool done;
   string_vector ret;
   string_vector aliases;
   bool relevant = false;
 
   std::string name = name_arg;
 
@@ -1877,69 +1877,69 @@ kpse_db_search (const std::string& name_
   for (int i = 0; i < len && !done; i++)
     {
       std::string atry = aliases[i];
 
       /* We have an ls-R db.  Look up `atry'.  */
       string_vector db_dirs = hash_lookup (db, atry);
 
       /* For each filename found, see if it matches the path element.  For
-	 example, if we have .../cx/cmr10.300pk and .../ricoh/cmr10.300pk,
-	 and the path looks like .../cx, we don't want the ricoh file.  */
+         example, if we have .../cx/cmr10.300pk and .../ricoh/cmr10.300pk,
+         and the path looks like .../cx, we don't want the ricoh file.  */
 
       int db_dirs_len = db_dirs.length ();
       for (int j = 0; j < db_dirs_len && !done; j++)
-	{
-	  std::string db_file = db_dirs[j] + atry;
-	  bool matched = match (db_file, path_elt);
+        {
+          std::string db_file = db_dirs[j] + atry;
+          bool matched = match (db_file, path_elt);
 
 #ifdef KPSE_DEBUG
-	  if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
-	    DEBUGF3 ("db:match (%s,%s) = %d\n", db_file.c_str (), path_elt.c_str (), matched);
+          if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
+            DEBUGF3 ("db:match (%s,%s) = %d\n", db_file.c_str (), path_elt.c_str (), matched);
 #endif
 
-	  /* We got a hit in the database.  Now see if the file actually
-	     exists, possibly under an alias.  */
-	  if (matched)
-	    {
-	      std::string found;
-	      std::string tmp = kpse_readable_file (db_file);
-	      if (! tmp.empty ())
-		found = db_file;
-	      else
-		{
-		  /* The hit in the DB doesn't exist in disk.  Now try
-		     all its aliases.  For example, suppose we have a
-		     hierarchy on CD, thus `mf.bas', but ls-R contains
-		     `mf.base'.  Find it anyway.  Could probably work
-		     around this with aliases, but this is pretty easy
-		     and shouldn't hurt.  The upshot is that if one of
-		     the aliases actually exists, we use that.  */
-
-		  int aliases_len = aliases.length ();
-
-		  for (int k = 1; k < aliases_len && found.empty (); k++)
-		    {
-		      std::string aatry = db_dirs[j] + aliases[k];
-		      tmp = kpse_readable_file (aatry);
-		      if (! tmp.empty ())
-			found = aatry;
-		    }
-		}
-
-	      /* If we have a real file, add it to the list, maybe done.  */
-	      if (! found.empty ())
-		{
-		  ret.append (found);
-
-		  if (! (all || found.empty ()))
-		    done = true;
-		}
-	    }
-	}
+          /* We got a hit in the database.  Now see if the file actually
+             exists, possibly under an alias.  */
+          if (matched)
+            {
+              std::string found;
+              std::string tmp = kpse_readable_file (db_file);
+              if (! tmp.empty ())
+                found = db_file;
+              else
+                {
+                  /* The hit in the DB doesn't exist in disk.  Now try
+                     all its aliases.  For example, suppose we have a
+                     hierarchy on CD, thus `mf.bas', but ls-R contains
+                     `mf.base'.  Find it anyway.  Could probably work
+                     around this with aliases, but this is pretty easy
+                     and shouldn't hurt.  The upshot is that if one of
+                     the aliases actually exists, we use that.  */
+
+                  int aliases_len = aliases.length ();
+
+                  for (int k = 1; k < aliases_len && found.empty (); k++)
+                    {
+                      std::string aatry = db_dirs[j] + aliases[k];
+                      tmp = kpse_readable_file (aatry);
+                      if (! tmp.empty ())
+                        found = aatry;
+                    }
+                }
+
+              /* If we have a real file, add it to the list, maybe done.  */
+              if (! found.empty ())
+                {
+                  ret.append (found);
+
+                  if (! (all || found.empty ()))
+                    done = true;
+                }
+            }
+        }
     }
 
   return ret;
 }
 
 /* Expand extra colons.  */
 
 /* Check for leading colon first, then trailing, then doubled, since
@@ -1977,25 +1977,25 @@ kpse_expand_default (const std::string& 
   else
     {
       /* What we'll return if we find none.  */
       expansion = path;
 
       for (size_t i = 0; i < path_len; i++)
         {
           if (i + 1 < path_len
-	      && IS_ENV_SEP (path[i]) && IS_ENV_SEP (path[i+1]))
+              && IS_ENV_SEP (path[i]) && IS_ENV_SEP (path[i+1]))
             {
-	      /* We have a doubled colon.  */
+              /* We have a doubled colon.  */
 
               /* Copy stuff up to and including the first colon.  */
               /* Copy in FALLBACK, and then the rest of PATH.  */
-	      expansion = path.substr (0, i+1) + fallback + path.substr (i+1);
-
-	      break;
+              expansion = path.substr (0, i+1) + fallback + path.substr (i+1);
+
+              break;
             }
         }
     }
 
   return expansion;
 }
 
 /* Translate a path element to its corresponding director{y,ies}.  */
@@ -2132,34 +2132,34 @@ dir_links (const std::string& fn)
 
   if (link_table.find (fn) != link_table.end ())
     ret = link_table[fn];
   else
     {
       struct stat stats;
 
       ret = stat (fn.c_str (), &stats) == 0 && S_ISDIR (stats.st_mode)
-	? stats.st_nlink : static_cast<unsigned> (-1);
+        ? stats.st_nlink : static_cast<unsigned> (-1);
 
       link_table[fn] = ret;
 
 #ifdef KPSE_DEBUG
       if (KPSE_DEBUG_P (KPSE_DEBUG_STAT))
         DEBUGF2 ("dir_links (%s) => %ld\n", fn.c_str (), ret);
 #endif
     }
 
   return ret;
 }
 
 #endif /* WIN32 */
 
 static void
 do_subdir (str_llist_type *str_list_ptr, const std::string& elt,
-	   unsigned elt_length, const std::string& post)
+           unsigned elt_length, const std::string& post)
 {
 #ifdef WIN32
   WIN32_FIND_DATA find_file_data;
   HANDLE hnd;
   int proceed;
 #else
   DIR *dir;
   struct dirent *e;
@@ -2180,42 +2180,42 @@ do_subdir (str_llist_type *str_list_ptr,
     return;
 
   /* Include top level before subdirectories, if nothing to match.  */
   if (post.empty ())
     dir_list_add (str_list_ptr, name);
   else
     {
       /* If we do have something to match, see if it exists.  For
-	 example, POST might be `pk/ljfour', and they might have a
-	 directory `$TEXMF/fonts/pk/ljfour' that we should find.  */
+         example, POST might be `pk/ljfour', and they might have a
+         directory `$TEXMF/fonts/pk/ljfour' that we should find.  */
       name += post;
       expand_elt (str_list_ptr, name, elt_length);
       name.resize (elt_length);
     }
 
   proceed = 1;
 
   while (proceed)
     {
       if (find_file_data.cFileName[0] != '.')
-	{
-	  /* Construct the potential subdirectory name.  */
-	  name += find_file_data.cFileName;
-
-	  if (find_file_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
-	    {
-	      /* It's a directory, so append the separator.  */
-	      name += DIR_SEP_STRING;
-	      unsigned potential_len = name.length ();
-
-	      do_subdir (str_list_ptr, name, potential_len, post);
-	    }
-	  name.resize (elt_length);
-	}
+        {
+          /* Construct the potential subdirectory name.  */
+          name += find_file_data.cFileName;
+
+          if (find_file_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+            {
+              /* It's a directory, so append the separator.  */
+              name += DIR_SEP_STRING;
+              unsigned potential_len = name.length ();
+
+              do_subdir (str_list_ptr, name, potential_len, post);
+            }
+          name.resize (elt_length);
+        }
 
       proceed = FindNextFile (hnd, &find_file_data);
     }
 
   FindClose (hnd);
 
 #else /* not WIN32 */
 
@@ -2293,48 +2293,48 @@ do_subdir (str_llist_type *str_list_ptr,
 }
 
 /* Assume ELT is non-empty and non-NULL.  Return list of corresponding
    directories (with no terminating NULL entry) in STR_LIST_PTR.  Start
    looking for magic constructs at START.  */
 
 static void
 expand_elt (str_llist_type *str_list_ptr, const std::string& elt,
-	    unsigned /* start */)
+            unsigned /* start */)
 {
 #if 0
   // We don't want magic constructs.
 
   size_t elt_len = elt.length ();
 
   size_t dir = start;
 
 
   while (dir < elt_len)
     {
       if (IS_DIR_SEP (elt[dir]))
         {
           /* If two or more consecutive /'s, find subdirectories.  */
           if (++dir < elt_len && IS_DIR_SEP (elt[dir]))
             {
-	      size_t i = dir;
-	      while (i < elt_len && IS_DIR_SEP (elt[i]))
-		i++;
-
-	      std::string post = elt.substr (i);
+              size_t i = dir;
+              while (i < elt_len && IS_DIR_SEP (elt[i]))
+                i++;
+
+              std::string post = elt.substr (i);
 
               do_subdir (str_list_ptr, elt, dir, post);
 
-	      return;
+              return;
             }
 
           /* No special stuff at this slash.  Keep going.  */
         }
       else
-	dir++;
+        dir++;
     }
 #endif
 
   /* When we reach the end of ELT, it will be a normal filename.  */
   checked_dir_list_add (str_list_ptr, elt);
 }
 
 /* Here is the entry point.  Returns directory list for ELT.  */
@@ -2416,17 +2416,17 @@ xclosedir (DIR *d)
 static FILE *
 fopen (const char *filename, const char *mode)
 {
 #undef fopen
   FILE *ret = fopen (filename, mode);
 
   if (KPSE_DEBUG_P (KPSE_DEBUG_FOPEN))
     DEBUGF3 ("fopen (%s, %s) => 0x%lx\n", filename, mode,
-	     reinterpret_cast<unsigned long> (ret));
+             reinterpret_cast<unsigned long> (ret));
 
   return ret;
 }
 
 #endif
 
 /* Implementation of a linked list of strings.  */
 
@@ -2532,31 +2532,31 @@ expanding_p (const std::string& var)
    This is a subroutine for the more complicated expansion function.  */
 
 static void
 expand (std::string &expansion, const std::string& var)
 {
   if (expanding_p (var))
     {
       (*current_liboctave_warning_handler)
-	("kpathsea: variable `%s' references itself (eventually)",
-	 var.c_str ());
+        ("kpathsea: variable `%s' references itself (eventually)",
+         var.c_str ());
     }
   else
     {
       /* Check for an environment variable.  */
       std::string value = octave_env::getenv (var);
 
       if (! value.empty ())
-	{
-	  expanding (var, true);
-	  std::string tmp = kpse_var_expand (value);
-	  expanding (var, false);
-	  expansion += tmp;
-	}
+        {
+          expanding (var, true);
+          std::string tmp = kpse_var_expand (value);
+          expanding (var, false);
+          expansion += tmp;
+        }
     }
 }
 
 /* Can't think of when it would be useful to change these (and the
    diagnostic messages assume them), but ... */
 #ifndef IS_VAR_START /* starts all variable references */
 #define IS_VAR_START(c) ((c) == '$')
 #endif
@@ -2579,64 +2579,64 @@ kpse_var_expand (const std::string& src)
   std::string expansion;
 
   size_t src_len = src.length ();
 
   /* Copy everything but variable constructs.  */
   for (size_t i = 0; i < src_len; i++)
     {
       if (IS_VAR_START (src[i]))
-	{
-	  i++;
-
-	  /* Three cases: `$VAR', `${VAR}', `$<anything-else>'.  */
-	  if (IS_VAR_CHAR (src[i]))
-	    {
-	      /* $V: collect name constituents, then expand.  */
-	      size_t var_end = i;
-
-	      do
-		{
-		  var_end++;
-		}
-	      while (IS_VAR_CHAR (src[var_end]));
-
-	      var_end--; /* had to go one past */
-	      expand (expansion, src.substr (i, var_end - i + 1));
-	      i = var_end;
-
-	    }
-	  else if (IS_VAR_BEGIN_DELIMITER (src[i]))
-	    {
-	      /* ${: scan ahead for matching delimiter, then expand.  */
-	      size_t var_end = ++i;
-
-	      while (var_end < src_len && !IS_VAR_END_DELIMITER (src[var_end]))
-		var_end++;
-
-	      if (var_end == src_len)
-		{
-		  (*current_liboctave_warning_handler)
-		    ("%s: No matching } for ${", src.c_str ());
-		  i = var_end - 1; /* will incr to eos at top of loop */
-		}
-	      else
-		{
-		  expand (expansion, src.substr (i, var_end - i));
-		  i = var_end; /* will incr past } at top of loop*/
-		}
-	    }
-	  else
-	    {
-	      /* $<something-else>: error.  */
-	      (*current_liboctave_warning_handler)
-		("%s: Unrecognized variable construct `$%c'",
-		 src.c_str (), src[i]);
-
-	      /* Just ignore those chars and keep going.  */
-	    }
-	}
+        {
+          i++;
+
+          /* Three cases: `$VAR', `${VAR}', `$<anything-else>'.  */
+          if (IS_VAR_CHAR (src[i]))
+            {
+              /* $V: collect name constituents, then expand.  */
+              size_t var_end = i;
+
+              do
+                {
+                  var_end++;
+                }
+              while (IS_VAR_CHAR (src[var_end]));
+
+              var_end--; /* had to go one past */
+              expand (expansion, src.substr (i, var_end - i + 1));
+              i = var_end;
+
+            }
+          else if (IS_VAR_BEGIN_DELIMITER (src[i]))
+            {
+              /* ${: scan ahead for matching delimiter, then expand.  */
+              size_t var_end = ++i;
+
+              while (var_end < src_len && !IS_VAR_END_DELIMITER (src[var_end]))
+                var_end++;
+
+              if (var_end == src_len)
+                {
+                  (*current_liboctave_warning_handler)
+                    ("%s: No matching } for ${", src.c_str ());
+                  i = var_end - 1; /* will incr to eos at top of loop */
+                }
+              else
+                {
+                  expand (expansion, src.substr (i, var_end - i));
+                  i = var_end; /* will incr past } at top of loop*/
+                }
+            }
+          else
+            {
+              /* $<something-else>: error.  */
+              (*current_liboctave_warning_handler)
+                ("%s: Unrecognized variable construct `$%c'",
+                 src.c_str (), src[i]);
+
+              /* Just ignore those chars and keep going.  */
+            }
+        }
       else
-	expansion += src[i];
+        expansion += src[i];
     }
 
   return expansion;
 }
diff --git a/liboctave/lo-ieee.cc b/liboctave/lo-ieee.cc
--- a/liboctave/lo-ieee.cc
+++ b/liboctave/lo-ieee.cc
@@ -64,108 +64,108 @@ octave_ieee_init (void)
 
   oct_mach_info::float_format ff = oct_mach_info::native_float_format ();
 
   switch (ff)
     {
     case oct_mach_info::flt_fmt_ieee_big_endian:
     case oct_mach_info::flt_fmt_ieee_little_endian:
       {
-	// Don't optimize away tmp_inf / tmp_inf to generate octave_NaN.
+        // Don't optimize away tmp_inf / tmp_inf to generate octave_NaN.
 
-	volatile double tmp_inf;
+        volatile double tmp_inf;
 
 #if defined (SCO)
-	volatile double tmp = 1.0;
-	tmp_inf = 1.0 / (tmp - tmp);
+        volatile double tmp = 1.0;
+        tmp_inf = 1.0 / (tmp - tmp);
 #elif defined (__alpha__) && defined (__osf__)
-	extern unsigned int DINFINITY[2];
-	tmp_inf =  (*(X_CAST(double *, DINFINITY)));
+        extern unsigned int DINFINITY[2];
+        tmp_inf =  (*(X_CAST(double *, DINFINITY)));
 #else
-	double tmp = 1e+10;
-	tmp_inf = tmp;
-	for (;;)
-	  {
-	    tmp_inf *= 1e+10;
-	    if (tmp_inf == tmp)
-	      break;
-	    tmp = tmp_inf;
-	  }
+        double tmp = 1e+10;
+        tmp_inf = tmp;
+        for (;;)
+          {
+            tmp_inf *= 1e+10;
+            if (tmp_inf == tmp)
+              break;
+            tmp = tmp_inf;
+          }
 #endif
 
 #if defined (__alpha__) && defined (__osf__)
-	extern unsigned int DQNAN[2];
-	octave_NaN = (*(X_CAST(double *, DQNAN)));
+        extern unsigned int DQNAN[2];
+        octave_NaN = (*(X_CAST(double *, DQNAN)));
 #elif defined (__NetBSD__)
-	octave_NaN = nan ("");
+        octave_NaN = nan ("");
 #else
-	octave_NaN = tmp_inf / tmp_inf;
+        octave_NaN = tmp_inf / tmp_inf;
         // try to ensure that lo_ieee_sign gives false for a NaN.
         if (lo_ieee_signbit (octave_NaN))
           octave_NaN = -octave_NaN;
 
 #endif
 
-	octave_Inf = tmp_inf;
+        octave_Inf = tmp_inf;
 
-	// This is patterned after code in R.
+        // This is patterned after code in R.
 
-	if (ff == oct_mach_info::flt_fmt_ieee_big_endian)
-	  {
-	    lo_ieee_hw = 0;
-	    lo_ieee_lw = 1;
-	  }
-	else
-	  {
-	    lo_ieee_hw = 1;
-	    lo_ieee_lw = 0;
-	  }
+        if (ff == oct_mach_info::flt_fmt_ieee_big_endian)
+          {
+            lo_ieee_hw = 0;
+            lo_ieee_lw = 1;
+          }
+        else
+          {
+            lo_ieee_hw = 1;
+            lo_ieee_lw = 0;
+          }
 
-	lo_ieee_double t;
-	t.word[lo_ieee_hw] = LO_IEEE_NA_HW;
-	t.word[lo_ieee_lw] = LO_IEEE_NA_LW;
+        lo_ieee_double t;
+        t.word[lo_ieee_hw] = LO_IEEE_NA_HW;
+        t.word[lo_ieee_lw] = LO_IEEE_NA_LW;
 
-	octave_NA = t.value;
+        octave_NA = t.value;
 
-	volatile float float_tmp_inf;
+        volatile float float_tmp_inf;
 
 #if defined (SCO)
-	volatile float float_tmp = 1.0;
-	float_tmp_inf = 1.0 / (float_tmp - float_tmp);
+        volatile float float_tmp = 1.0;
+        float_tmp_inf = 1.0 / (float_tmp - float_tmp);
 #else
-	float float_tmp = 1e+10;
-	float_tmp_inf = float_tmp;
-	for (;;)
-	  {
-	    float_tmp_inf *= 1e+10;
-	    if (float_tmp_inf == float_tmp)
-	      break;
-	    float_tmp = float_tmp_inf;
-	  }
+        float float_tmp = 1e+10;
+        float_tmp_inf = float_tmp;
+        for (;;)
+          {
+            float_tmp_inf *= 1e+10;
+            if (float_tmp_inf == float_tmp)
+              break;
+            float_tmp = float_tmp_inf;
+          }
 #endif
 
 #if defined (__NetBSD__)
-	octave_Float_NaN = nanf ("");
+        octave_Float_NaN = nanf ("");
 #else
-	octave_Float_NaN = float_tmp_inf / float_tmp_inf;
+        octave_Float_NaN = float_tmp_inf / float_tmp_inf;
 #endif
-	octave_Float_Inf = float_tmp_inf;
+        octave_Float_Inf = float_tmp_inf;
 
-	lo_ieee_float tf;
-	tf.word = LO_IEEE_NA_FLOAT;
-	octave_Float_NA = tf.value;
+        lo_ieee_float tf;
+        tf.word = LO_IEEE_NA_FLOAT;
+        octave_Float_NA = tf.value;
       }
       break;
 
     case oct_mach_info::flt_fmt_cray:
     case oct_mach_info::flt_fmt_vax_d:
     case oct_mach_info::flt_fmt_vax_g:
     default:
       // If the format is unknown, then you will probably not have a
       // useful system, so we will abort here.  Anyone wishing to
       // experiment with building Octave on a system without IEEE
       // floating point should be capable of removing this check and
       // the configure test.
       (*current_liboctave_error_handler)
-	("lo_ieee_init: floating point format is not IEEE!  Maybe DLAMCH is miscompiled, or you are using some strange system without IEEE floating point math?");
+        ("lo_ieee_init: floating point format is not IEEE!  Maybe DLAMCH is miscompiled, or you are using some strange system without IEEE floating point math?");
       abort ();
     }
 }
diff --git a/liboctave/lo-mappers.cc b/liboctave/lo-mappers.cc
--- a/liboctave/lo-mappers.cc
+++ b/liboctave/lo-mappers.cc
@@ -75,26 +75,26 @@ xround (double x)
 #if defined (HAVE_ROUND)
   return round (x);
 #else
   if (x >= 0)
     {
       double y = floor (x);
 
       if ((x - y) >= 0.5)
-	y += 1.0;
+        y += 1.0;
 
       return y;
     }
   else
     {
       double y = ceil (x);
 
       if ((y - x) >= 0.5)
-	y -= 1.0;
+        y -= 1.0;
 
       return y;
     }
 #endif
 }
 
 double
 xtrunc (double x)
@@ -379,26 +379,26 @@ xround (float x)
 #if defined (HAVE_ROUND)
   return round (x);
 #else
   if (x >= 0)
     {
       float y = floor (x);
 
       if ((x - y) >= 0.5)
-	y += 1.0;
+        y += 1.0;
 
       return y;
     }
   else
     {
       float y = ceil (x);
 
       if ((y - x) >= 0.5)
-	y -= 1.0;
+        y -= 1.0;
 
       return y;
     }
 #endif
 }
 
 float
 xtrunc (float x)
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -48,81 +48,81 @@ along with Octave; see the file COPYING.
 #ifndef M_PI
 #define M_PI 3.14159265358979323846
 #endif
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zbesj, ZBESJ) (const double&, const double&, const double&,
-			   const octave_idx_type&, const octave_idx_type&, double*, double*,
-			   octave_idx_type&, octave_idx_type&);
+                           const octave_idx_type&, const octave_idx_type&, double*, double*,
+                           octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zbesy, ZBESY) (const double&, const double&, const double&,
-			   const octave_idx_type&, const octave_idx_type&, double*, double*,
-			   octave_idx_type&, double*, double*, octave_idx_type&);
+                           const octave_idx_type&, const octave_idx_type&, double*, double*,
+                           octave_idx_type&, double*, double*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zbesi, ZBESI) (const double&, const double&, const double&,
-			   const octave_idx_type&, const octave_idx_type&, double*, double*,
-			   octave_idx_type&, octave_idx_type&);
+                           const octave_idx_type&, const octave_idx_type&, double*, double*,
+                           octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zbesk, ZBESK) (const double&, const double&, const double&,
-			   const octave_idx_type&, const octave_idx_type&, double*, double*,
-			   octave_idx_type&, octave_idx_type&);
+                           const octave_idx_type&, const octave_idx_type&, double*, double*,
+                           octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zbesh, ZBESH) (const double&, const double&, const double&,
-			   const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
-			   double*, octave_idx_type&, octave_idx_type&);
+                           const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
+                           double*, octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cbesj, cBESJ) (const FloatComplex&, const float&,
-			   const octave_idx_type&, const octave_idx_type&,
-			   FloatComplex*, octave_idx_type&, octave_idx_type&);
+                           const octave_idx_type&, const octave_idx_type&,
+                           FloatComplex*, octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cbesy, CBESY) (const FloatComplex&, const float&,
-			   const octave_idx_type&, const octave_idx_type&,
-			   FloatComplex*, octave_idx_type&,
-			   FloatComplex*, octave_idx_type&);
+                           const octave_idx_type&, const octave_idx_type&,
+                           FloatComplex*, octave_idx_type&,
+                           FloatComplex*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cbesi, CBESI) (const FloatComplex&, const float&,
-			   const octave_idx_type&, const octave_idx_type&,
-			   FloatComplex*, octave_idx_type&, octave_idx_type&);
+                           const octave_idx_type&, const octave_idx_type&,
+                           FloatComplex*, octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cbesk, CBESK) (const FloatComplex&, const float&,
-			   const octave_idx_type&, const octave_idx_type&,
-			   FloatComplex*, octave_idx_type&, octave_idx_type&);
+                           const octave_idx_type&, const octave_idx_type&,
+                           FloatComplex*, octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cbesh, CBESH) (const FloatComplex&, const float&,
-			   const octave_idx_type&, const octave_idx_type&,
-			   const octave_idx_type&, FloatComplex*,
-			   octave_idx_type&, octave_idx_type&);
+                           const octave_idx_type&, const octave_idx_type&,
+                           const octave_idx_type&, FloatComplex*,
+                           octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zairy, ZAIRY) (const double&, const double&, const octave_idx_type&,
-			   const octave_idx_type&, double&, double&, octave_idx_type&, octave_idx_type&);
+                           const octave_idx_type&, double&, double&, octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cairy, CAIRY) (const float&, const float&, const octave_idx_type&,
-			   const octave_idx_type&, float&, float&, octave_idx_type&, octave_idx_type&);
+                           const octave_idx_type&, float&, float&, octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zbiry, ZBIRY) (const double&, const double&, const octave_idx_type&,
-			   const octave_idx_type&, double&, double&, octave_idx_type&);
+                           const octave_idx_type&, double&, double&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cbiry, CBIRY) (const float&, const float&, const octave_idx_type&,
-			   const octave_idx_type&, float&, float&, octave_idx_type&);
+                           const octave_idx_type&, float&, float&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (xdacosh, XDACOSH) (const double&, double&);
 
   F77_RET_T
   F77_FUNC (xacosh, XACOSH) (const float&, float&);
 
   F77_RET_T
@@ -146,21 +146,21 @@ extern "C"
   F77_RET_T
   F77_FUNC (xderfc, XDERFC) (const double&, double&);
 
   F77_RET_T
   F77_FUNC (xerfc, XERFC) (const float&, float&);
 
   F77_RET_T
   F77_FUNC (xdbetai, XDBETAI) (const double&, const double&,
-			       const double&, double&);
+                               const double&, double&);
 
   F77_RET_T
   F77_FUNC (xbetai, XBETAI) (const float&, const float&,
-			     const float&, float&);
+                             const float&, float&);
 
   F77_RET_T
   F77_FUNC (xdgamma, XDGAMMA) (const double&, double&);
 
   F77_RET_T
   F77_FUNC (xgamma, XGAMMA) (const float&, float&);
 
   F77_RET_T
@@ -546,17 +546,17 @@ log1p (const Complex& x)
   Complex retval;
 
   double r = x.real (), i = x.imag();
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       double u = 2*r + r*r + i*i;
       retval = Complex (log1p (u / (1+sqrt (u+1))),
-			atan2 (1 + r, i));
+                        atan2 (1 + r, i));
     }
   else
     retval = std::log (Complex(1) + x);
 
   return retval;
 }
 
 #if !defined (HAVE_LOG1PF)
@@ -589,17 +589,17 @@ log1p (const FloatComplex& x)
   FloatComplex retval;
 
   float r = x.real (), i = x.imag();
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       float u = 2*r + r*r + i*i;
       retval = FloatComplex (log1p (u / (1+sqrt (u+1))),
-			atan2 (1 + r, i));
+                        atan2 (1 + r, i));
     }
   else
     retval = std::log (FloatComplex(1) + x);
 
   return retval;
 }
 
 static inline Complex
@@ -666,50 +666,50 @@ zbesj (const Complex& z, double alpha, i
       octave_idx_type nz;
 
       double zr = z.real ();
       double zi = z.imag ();
 
       F77_FUNC (zbesj, ZBESJ) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
 
       if (kode != 2)
-	{
-	  double expz = exp (std::abs (zi)); 
-	  yr *= expz;
-	  yi *= expz;
-	}
+        {
+          double expz = exp (std::abs (zi)); 
+          yr *= expz;
+          yi *= expz;
+        }
 
       if (zi == 0.0 && zr >= 0.0)
-	yi = 0.0;
+        yi = 0.0;
 
       retval = bessel_return_value (Complex (yr, yi), ierr);
     }
   else if (is_integer_value (alpha))
     {
       // zbesy can overflow as z->0, and cause troubles for generic case below
       alpha = -alpha;
       Complex tmp = zbesj (z, alpha, kode, ierr);
       if ((static_cast <long> (alpha)) & 1) 
-	tmp = - tmp;
+        tmp = - tmp;
       retval = bessel_return_value (tmp, ierr);
     }
   else
     {
       alpha = -alpha;
 
       Complex tmp = cos (M_PI * alpha) * zbesj (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
-	{
-	  tmp -= sin (M_PI * alpha) * zbesy (z, alpha, kode, ierr);
-
-	  retval = bessel_return_value (tmp, ierr);
-	}
+        {
+          tmp -= sin (M_PI * alpha) * zbesy (z, alpha, kode, ierr);
+
+          retval = bessel_return_value (tmp, ierr);
+        }
       else
-	retval = Complex (octave_NaN, octave_NaN);
+        retval = Complex (octave_NaN, octave_NaN);
     }
 
   return retval;
 }
 
 static inline Complex
 zbesy (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
 {
@@ -725,61 +725,61 @@ zbesy (const Complex& z, double alpha, i
       double wr, wi;
 
       double zr = z.real ();
       double zi = z.imag ();
 
       ierr = 0;
 
       if (zr == 0.0 && zi == 0.0)
-	{
-	  yr = -octave_Inf;
-	  yi = 0.0;
-	}
+        {
+          yr = -octave_Inf;
+          yi = 0.0;
+        }
       else
-	{
-	  F77_FUNC (zbesy, ZBESY) (zr, zi, alpha, 2, 1, &yr, &yi, nz,
-				   &wr, &wi, ierr);
-
-	  if (kode != 2)
-	    {
-	      double expz = exp (std::abs (zi));
-	      yr *= expz;
-	      yi *= expz;
-	    }
-
-	  if (zi == 0.0 && zr >= 0.0)
-	    yi = 0.0;
-	}
+        {
+          F77_FUNC (zbesy, ZBESY) (zr, zi, alpha, 2, 1, &yr, &yi, nz,
+                                   &wr, &wi, ierr);
+
+          if (kode != 2)
+            {
+              double expz = exp (std::abs (zi));
+              yr *= expz;
+              yi *= expz;
+            }
+
+          if (zi == 0.0 && zr >= 0.0)
+            yi = 0.0;
+        }
 
       return bessel_return_value (Complex (yr, yi), ierr);
     }
   else if (is_integer_value (alpha - 0.5))
     {
       // zbesy can overflow as z->0, and cause troubles for generic case below
       alpha = -alpha;
       Complex tmp = zbesj (z, alpha, kode, ierr);
       if ((static_cast <long> (alpha - 0.5)) & 1) 
-	tmp = - tmp;
+        tmp = - tmp;
       retval = bessel_return_value (tmp, ierr);
     }
   else
     {
       alpha = -alpha;
 
       Complex tmp = cos (M_PI * alpha) * zbesy (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
-	{
-	  tmp += sin (M_PI * alpha) * zbesj (z, alpha, kode, ierr);
-
-	  retval = bessel_return_value (tmp, ierr);
-	}
+        {
+          tmp += sin (M_PI * alpha) * zbesj (z, alpha, kode, ierr);
+
+          retval = bessel_return_value (tmp, ierr);
+        }
       else
-	retval = Complex (octave_NaN, octave_NaN);
+        retval = Complex (octave_NaN, octave_NaN);
     }
 
   return retval;
 }
 
 static inline Complex
 zbesi (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
 {
@@ -793,50 +793,50 @@ zbesi (const Complex& z, double alpha, i
       octave_idx_type nz;
 
       double zr = z.real ();
       double zi = z.imag ();
 
       F77_FUNC (zbesi, ZBESI) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
 
       if (kode != 2)
-	{
-	  double expz = exp (std::abs (zr));
-	  yr *= expz;
-	  yi *= expz;
-	}
+        {
+          double expz = exp (std::abs (zr));
+          yr *= expz;
+          yi *= expz;
+        }
 
       if (zi == 0.0 && zr >= 0.0)
-	yi = 0.0;
+        yi = 0.0;
 
       retval = bessel_return_value (Complex (yr, yi), ierr);
     }
   else
     {
       alpha = -alpha;
 
       Complex tmp = zbesi (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
-	{
-	  Complex tmp2 = (2.0 / M_PI) * sin (M_PI * alpha)
-	    * zbesk (z, alpha, kode, ierr);
-	
-	  if (kode == 2) 
-	    {
-	      // Compensate for different scaling factor of besk.
-	      tmp2 *= exp(-z - std::abs(z.real()));
-	    }
-	  
-	  tmp += tmp2;
-
-	  retval = bessel_return_value (tmp, ierr);
-	}
+        {
+          Complex tmp2 = (2.0 / M_PI) * sin (M_PI * alpha)
+            * zbesk (z, alpha, kode, ierr);
+        
+          if (kode == 2) 
+            {
+              // Compensate for different scaling factor of besk.
+              tmp2 *= exp(-z - std::abs(z.real()));
+            }
+          
+          tmp += tmp2;
+
+          retval = bessel_return_value (tmp, ierr);
+        }
       else
-	retval = Complex (octave_NaN, octave_NaN);
+        retval = Complex (octave_NaN, octave_NaN);
     }
 
   return retval;
 }
 
 static inline Complex
 zbesk (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
 {
@@ -850,40 +850,40 @@ zbesk (const Complex& z, double alpha, i
       octave_idx_type nz;
 
       double zr = z.real ();
       double zi = z.imag ();
 
       ierr = 0;
 
       if (zr == 0.0 && zi == 0.0)
-	{
-	  yr = octave_Inf;
-	  yi = 0.0;
-	}
+        {
+          yr = octave_Inf;
+          yi = 0.0;
+        }
       else
-	{
-	  F77_FUNC (zbesk, ZBESK) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
-
-	  if (kode != 2)
-	    {
-	      Complex expz = exp (-z);
-
-	      double rexpz = real (expz);
-	      double iexpz = imag (expz);
-
-	      double tmp = yr*rexpz - yi*iexpz;
-
-	      yi = yr*iexpz + yi*rexpz;
-	      yr = tmp;
-	    }
-
-	  if (zi == 0.0 && zr >= 0.0)
-	    yi = 0.0;
-	}
+        {
+          F77_FUNC (zbesk, ZBESK) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
+
+          if (kode != 2)
+            {
+              Complex expz = exp (-z);
+
+              double rexpz = real (expz);
+              double iexpz = imag (expz);
+
+              double tmp = yr*rexpz - yi*iexpz;
+
+              yi = yr*iexpz + yi*rexpz;
+              yr = tmp;
+            }
+
+          if (zi == 0.0 && zr >= 0.0)
+            yi = 0.0;
+        }
 
       retval = bessel_return_value (Complex (yr, yi), ierr);
     }
   else
     {
       Complex tmp = zbesk (z, -alpha, kode, ierr);
 
       retval = bessel_return_value (tmp, ierr);
@@ -905,27 +905,27 @@ zbesh1 (const Complex& z, double alpha, 
       octave_idx_type nz;
 
       double zr = z.real ();
       double zi = z.imag ();
 
       F77_FUNC (zbesh, ZBESH) (zr, zi, alpha, 2, 1, 1, &yr, &yi, nz, ierr);
 
       if (kode != 2)
-	{
-	  Complex expz = exp (Complex (0.0, 1.0) * z);
-
-	  double rexpz = real (expz);
-	  double iexpz = imag (expz);
-
-	  double tmp = yr*rexpz - yi*iexpz;
-
-	  yi = yr*iexpz + yi*rexpz;
-	  yr = tmp;
-	}
+        {
+          Complex expz = exp (Complex (0.0, 1.0) * z);
+
+          double rexpz = real (expz);
+          double iexpz = imag (expz);
+
+          double tmp = yr*rexpz - yi*iexpz;
+
+          yi = yr*iexpz + yi*rexpz;
+          yr = tmp;
+        }
 
       retval = bessel_return_value (Complex (yr, yi), ierr);
     }
   else
     {
       alpha = -alpha;
 
       static const Complex eye = Complex (0.0, 1.0);
@@ -951,27 +951,27 @@ zbesh2 (const Complex& z, double alpha, 
       octave_idx_type nz;
 
       double zr = z.real ();
       double zi = z.imag ();
 
       F77_FUNC (zbesh, ZBESH) (zr, zi, alpha, 2, 2, 1, &yr, &yi, nz, ierr);
 
       if (kode != 2)
-	{
-	  Complex expz = exp (-Complex (0.0, 1.0) * z);
-
-	  double rexpz = real (expz);
-	  double iexpz = imag (expz);
-
-	  double tmp = yr*rexpz - yi*iexpz;
-
-	  yi = yr*iexpz + yi*rexpz;
-	  yr = tmp;
-	}
+        {
+          Complex expz = exp (-Complex (0.0, 1.0) * z);
+
+          double rexpz = real (expz);
+          double iexpz = imag (expz);
+
+          double tmp = yr*rexpz - yi*iexpz;
+
+          yi = yr*iexpz + yi*rexpz;
+          yr = tmp;
+        }
 
       retval = bessel_return_value (Complex (yr, yi), ierr);
     }
   else
     {
       alpha = -alpha;
 
       static const Complex eye = Complex (0.0, 1.0);
@@ -983,28 +983,28 @@ zbesh2 (const Complex& z, double alpha, 
 
   return retval;
 }
 
 typedef Complex (*dptr) (const Complex&, double, int, octave_idx_type&);
 
 static inline Complex
 do_bessel (dptr f, const char *, double alpha, const Complex& x,
-	   bool scaled, octave_idx_type& ierr)
+           bool scaled, octave_idx_type& ierr)
 {
   Complex retval;
 
   retval = f (x, alpha, (scaled ? 2 : 1), ierr);
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (dptr f, const char *, double alpha, const ComplexMatrix& x,
-	   bool scaled, Array2<octave_idx_type>& ierr)
+           bool scaled, Array2<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -1012,17 +1012,17 @@ do_bessel (dptr f, const char *, double 
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i,j), alpha, (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (dptr f, const char *, const Matrix& alpha, const Complex& x,
-	   bool scaled, Array2<octave_idx_type>& ierr)
+           bool scaled, Array2<octave_idx_type>& ierr)
 {
   octave_idx_type nr = alpha.rows ();
   octave_idx_type nc = alpha.cols ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -1030,17 +1030,17 @@ do_bessel (dptr f, const char *, const M
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x, alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (dptr f, const char *fn, const Matrix& alpha,
-	   const ComplexMatrix& x, bool scaled, Array2<octave_idx_type>& ierr)
+           const ComplexMatrix& x, bool scaled, Array2<octave_idx_type>& ierr)
 {
   ComplexMatrix retval;
 
   octave_idx_type x_nr = x.rows ();
   octave_idx_type x_nc = x.cols ();
 
   octave_idx_type alpha_nr = alpha.rows ();
   octave_idx_type alpha_nc = alpha.cols ();
@@ -1050,85 +1050,85 @@ do_bessel (dptr f, const char *fn, const
       octave_idx_type nr = x_nr;
       octave_idx_type nc = x_nc;
 
       retval.resize (nr, nc);
 
       ierr.resize (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
     }
   else
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
   return retval;
 }
 
 static inline ComplexNDArray
 do_bessel (dptr f, const char *, double alpha, const ComplexNDArray& x,
-	   bool scaled, Array<octave_idx_type>& ierr)
+           bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
       retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline ComplexNDArray
 do_bessel (dptr f, const char *, const NDArray& alpha, const Complex& x,
-	   bool scaled, Array<octave_idx_type>& ierr)
+           bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = alpha.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     retval(i) = f (x, alpha(i), (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline ComplexNDArray
 do_bessel (dptr f, const char *fn, const NDArray& alpha,
-	   const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr)
+           const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
   ComplexNDArray retval;
 
   if (dv == alpha.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
       ierr.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
-	retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
+        retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
     }
   else
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (dptr f, const char *, const RowVector& alpha,
-	   const ComplexColumnVector& x, bool scaled, Array2<octave_idx_type>& ierr)
+           const ComplexColumnVector& x, bool scaled, Array2<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.length ();
   octave_idx_type nc = alpha.length ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -1144,57 +1144,57 @@ do_bessel (dptr f, const char *, const R
   name (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define SM_BESSEL(name, fcn) \
   ComplexMatrix \
   name (double alpha, const ComplexMatrix& x, bool scaled, \
-	Array2<octave_idx_type>& ierr) \
+        Array2<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define MS_BESSEL(name, fcn) \
   ComplexMatrix \
   name (const Matrix& alpha, const Complex& x, bool scaled, \
-	Array2<octave_idx_type>& ierr) \
+        Array2<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define MM_BESSEL(name, fcn) \
   ComplexMatrix \
   name (const Matrix& alpha, const ComplexMatrix& x, bool scaled, \
-	Array2<octave_idx_type>& ierr) \
+        Array2<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define SN_BESSEL(name, fcn) \
   ComplexNDArray \
   name (double alpha, const ComplexNDArray& x, bool scaled, \
-	Array<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define NS_BESSEL(name, fcn) \
   ComplexNDArray \
   name (const NDArray& alpha, const Complex& x, bool scaled, \
-	Array<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define NN_BESSEL(name, fcn) \
   ComplexNDArray \
   name (const NDArray& alpha, const ComplexNDArray& x, bool scaled, \
-	Array<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define RC_BESSEL(name, fcn) \
   ComplexMatrix \
   name (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, \
         Array2<octave_idx_type>& ierr) \
@@ -1289,49 +1289,49 @@ cbesj (const FloatComplex& z, float alph
     {
       FloatComplex y = 0.0;
 
       octave_idx_type nz;
 
       F77_FUNC (cbesj, CBESJ) (z, alpha, 2, 1, &y, nz, ierr);
 
       if (kode != 2)
-	{
-	  float expz = exp (std::abs (imag (z)));
-	  y *= expz;
-	}
+        {
+          float expz = exp (std::abs (imag (z)));
+          y *= expz;
+        }
 
       if (imag (z) == 0.0 && real (z) >= 0.0)
-	y = FloatComplex (y.real (), 0.0);
+        y = FloatComplex (y.real (), 0.0);
 
       retval = bessel_return_value (y, ierr);
     }
   else if (is_integer_value (alpha))
     {
       // zbesy can overflow as z->0, and cause troubles for generic case below
       alpha = -alpha;
       FloatComplex tmp = cbesj (z, alpha, kode, ierr);
       if ((static_cast <long> (alpha)) & 1) 
-	tmp = - tmp;
+        tmp = - tmp;
       retval = bessel_return_value (tmp, ierr);
     }
   else
     {
       alpha = -alpha;
 
       FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha) * cbesj (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
-	{
-	  tmp -= sinf (static_cast<float> (M_PI) * alpha) * cbesy (z, alpha, kode, ierr);
-
-	  retval = bessel_return_value (tmp, ierr);
-	}
+        {
+          tmp -= sinf (static_cast<float> (M_PI) * alpha) * cbesy (z, alpha, kode, ierr);
+
+          retval = bessel_return_value (tmp, ierr);
+        }
       else
-	retval = FloatComplex (octave_Float_NaN, octave_Float_NaN);
+        retval = FloatComplex (octave_Float_NaN, octave_Float_NaN);
     }
 
   return retval;
 }
 
 static inline FloatComplex
 cbesy (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
 {
@@ -1343,58 +1343,58 @@ cbesy (const FloatComplex& z, float alph
 
       octave_idx_type nz;
 
       FloatComplex w;
 
       ierr = 0;
 
       if (real (z) == 0.0 && imag (z) == 0.0)
-	{
-	  y = FloatComplex (-octave_Float_Inf, 0.0);
-	}
+        {
+          y = FloatComplex (-octave_Float_Inf, 0.0);
+        }
       else
-	{
-	  F77_FUNC (cbesy, CBESY) (z, alpha, 2, 1, &y, nz, &w, ierr);
-
-	  if (kode != 2)
-	    {
-	      float expz = exp (std::abs (imag (z)));
-	      y *= expz;
-	    }
-
-	  if (imag (z) == 0.0 && real (z) >= 0.0)
-	    y = FloatComplex (y.real (), 0.0);
-	}
+        {
+          F77_FUNC (cbesy, CBESY) (z, alpha, 2, 1, &y, nz, &w, ierr);
+
+          if (kode != 2)
+            {
+              float expz = exp (std::abs (imag (z)));
+              y *= expz;
+            }
+
+          if (imag (z) == 0.0 && real (z) >= 0.0)
+            y = FloatComplex (y.real (), 0.0);
+        }
 
       return bessel_return_value (y, ierr);
     }
   else if (is_integer_value (alpha - 0.5))
     {
       // zbesy can overflow as z->0, and cause troubles for generic case below
       alpha = -alpha;
       FloatComplex tmp = cbesj (z, alpha, kode, ierr);
       if ((static_cast <long> (alpha - 0.5)) & 1) 
-	tmp = - tmp;
+        tmp = - tmp;
       retval = bessel_return_value (tmp, ierr);
     }
   else
     {
       alpha = -alpha;
 
       FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha) * cbesy (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
-	{
-	  tmp += sinf (static_cast<float> (M_PI) * alpha) * cbesj (z, alpha, kode, ierr);
-
-	  retval = bessel_return_value (tmp, ierr);
-	}
+        {
+          tmp += sinf (static_cast<float> (M_PI) * alpha) * cbesj (z, alpha, kode, ierr);
+
+          retval = bessel_return_value (tmp, ierr);
+        }
       else
-	retval = FloatComplex (octave_Float_NaN, octave_Float_NaN);
+        retval = FloatComplex (octave_Float_NaN, octave_Float_NaN);
     }
 
   return retval;
 }
 
 static inline FloatComplex
 cbesi (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
 {
@@ -1404,49 +1404,49 @@ cbesi (const FloatComplex& z, float alph
     {
       FloatComplex y = 0.0;
 
       octave_idx_type nz;
 
       F77_FUNC (cbesi, CBESI) (z, alpha, 2, 1, &y, nz, ierr);
 
       if (kode != 2)
-	{
-	  float expz = exp (std::abs (real (z)));
-	  y *= expz;
-	}
+        {
+          float expz = exp (std::abs (real (z)));
+          y *= expz;
+        }
 
       if (imag (z) == 0.0 && real (z) >= 0.0)
-	y = FloatComplex (y.real (), 0.0);
+        y = FloatComplex (y.real (), 0.0);
 
       retval = bessel_return_value (y, ierr);
     }
   else
     {
       alpha = -alpha;
 
       FloatComplex tmp = cbesi (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
-	{
-	  FloatComplex tmp2 = static_cast<float> (2.0 / M_PI) * sinf (static_cast<float> (M_PI) * alpha)
-	    * cbesk (z, alpha, kode, ierr);
-	  
-	  if (kode == 2) 
-	    {
-	      // Compensate for different scaling factor of besk.
-	      tmp2 *= exp(-z - std::abs(z.real()));
-	    }
-
-	  tmp += tmp2;
-
-	  retval = bessel_return_value (tmp, ierr);
-	}
+        {
+          FloatComplex tmp2 = static_cast<float> (2.0 / M_PI) * sinf (static_cast<float> (M_PI) * alpha)
+            * cbesk (z, alpha, kode, ierr);
+          
+          if (kode == 2) 
+            {
+              // Compensate for different scaling factor of besk.
+              tmp2 *= exp(-z - std::abs(z.real()));
+            }
+
+          tmp += tmp2;
+
+          retval = bessel_return_value (tmp, ierr);
+        }
       else
-	retval = FloatComplex (octave_Float_NaN, octave_Float_NaN);
+        retval = FloatComplex (octave_Float_NaN, octave_Float_NaN);
     }
 
   return retval;
 }
 
 static inline FloatComplex
 cbesk (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
 {
@@ -1456,39 +1456,39 @@ cbesk (const FloatComplex& z, float alph
     {
       FloatComplex y = 0.0;
 
       octave_idx_type nz;
 
       ierr = 0;
 
       if (real (z) == 0.0 && imag (z) == 0.0)
-	{
-	  y = FloatComplex (octave_Float_Inf, 0.0);
-	}
+        {
+          y = FloatComplex (octave_Float_Inf, 0.0);
+        }
       else
-	{
-	  F77_FUNC (cbesk, CBESK) (z, alpha, 2, 1, &y, nz, ierr);
-
-	  if (kode != 2)
-	    {
-	      FloatComplex expz = exp (-z);
-
-	      float rexpz = real (expz);
-	      float iexpz = imag (expz);
-
-	      float tmp_r = real (y) * rexpz - imag (y) * iexpz;
-	      float tmp_i = real (y) * iexpz + imag (y) * rexpz;
-
-	      y = FloatComplex (tmp_r, tmp_i);
-	    }
-
-	  if (imag (z) == 0.0 && real (z) >= 0.0)
-	    y = FloatComplex (y.real (), 0.0);
-	}
+        {
+          F77_FUNC (cbesk, CBESK) (z, alpha, 2, 1, &y, nz, ierr);
+
+          if (kode != 2)
+            {
+              FloatComplex expz = exp (-z);
+
+              float rexpz = real (expz);
+              float iexpz = imag (expz);
+
+              float tmp_r = real (y) * rexpz - imag (y) * iexpz;
+              float tmp_i = real (y) * iexpz + imag (y) * rexpz;
+
+              y = FloatComplex (tmp_r, tmp_i);
+            }
+
+          if (imag (z) == 0.0 && real (z) >= 0.0)
+            y = FloatComplex (y.real (), 0.0);
+        }
 
       retval = bessel_return_value (y, ierr);
     }
   else
     {
       FloatComplex tmp = cbesk (z, -alpha, kode, ierr);
 
       retval = bessel_return_value (tmp, ierr);
@@ -1506,27 +1506,27 @@ cbesh1 (const FloatComplex& z, float alp
     {
       FloatComplex y = 0.0;
 
       octave_idx_type nz;
 
       F77_FUNC (cbesh, CBESH) (z, alpha, 2, 1, 1, &y, nz, ierr);
 
       if (kode != 2)
-	{
-	  FloatComplex expz = exp (FloatComplex (0.0, 1.0) * z);
-
-	  float rexpz = real (expz);
-	  float iexpz = imag (expz);
-
-	  float tmp_r = real (y) * rexpz - imag (y) * iexpz;
-	  float tmp_i = real (y) * iexpz + imag (y) * rexpz;
-
-	  y = FloatComplex (tmp_r, tmp_i);
-	}
+        {
+          FloatComplex expz = exp (FloatComplex (0.0, 1.0) * z);
+
+          float rexpz = real (expz);
+          float iexpz = imag (expz);
+
+          float tmp_r = real (y) * rexpz - imag (y) * iexpz;
+          float tmp_i = real (y) * iexpz + imag (y) * rexpz;
+
+          y = FloatComplex (tmp_r, tmp_i);
+        }
 
       retval = bessel_return_value (y, ierr);
     }
   else
     {
       alpha = -alpha;
 
       static const FloatComplex eye = FloatComplex (0.0, 1.0);
@@ -1548,27 +1548,27 @@ cbesh2 (const FloatComplex& z, float alp
     {
       FloatComplex y = 0.0;
 
       octave_idx_type nz;
 
       F77_FUNC (cbesh, CBESH) (z, alpha, 2, 2, 1, &y, nz, ierr);
 
       if (kode != 2)
-	{
-	  FloatComplex expz = exp (-FloatComplex (0.0, 1.0) * z);
-
-	  float rexpz = real (expz);
-	  float iexpz = imag (expz);
-
-	  float tmp_r = real (y) * rexpz - imag (y) * iexpz;
-	  float tmp_i = real (y) * iexpz + imag (y) * rexpz;
-
-	  y = FloatComplex (tmp_r, tmp_i);
-	}
+        {
+          FloatComplex expz = exp (-FloatComplex (0.0, 1.0) * z);
+
+          float rexpz = real (expz);
+          float iexpz = imag (expz);
+
+          float tmp_r = real (y) * rexpz - imag (y) * iexpz;
+          float tmp_i = real (y) * iexpz + imag (y) * rexpz;
+
+          y = FloatComplex (tmp_r, tmp_i);
+        }
 
       retval = bessel_return_value (y, ierr);
     }
   else
     {
       alpha = -alpha;
 
       static const FloatComplex eye = FloatComplex (0.0, 1.0);
@@ -1580,28 +1580,28 @@ cbesh2 (const FloatComplex& z, float alp
 
   return retval;
 }
 
 typedef FloatComplex (*fptr) (const FloatComplex&, float, int, octave_idx_type&);
 
 static inline FloatComplex
 do_bessel (fptr f, const char *, float alpha, const FloatComplex& x,
-	   bool scaled, octave_idx_type& ierr)
+           bool scaled, octave_idx_type& ierr)
 {
   FloatComplex retval;
 
   retval = f (x, alpha, (scaled ? 2 : 1), ierr);
 
   return retval;
 }
 
 static inline FloatComplexMatrix
 do_bessel (fptr f, const char *, float alpha, const FloatComplexMatrix& x,
-	   bool scaled, Array2<octave_idx_type>& ierr)
+           bool scaled, Array2<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -1609,17 +1609,17 @@ do_bessel (fptr f, const char *, float a
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i,j), alpha, (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 static inline FloatComplexMatrix
 do_bessel (fptr f, const char *, const FloatMatrix& alpha, const FloatComplex& x,
-	   bool scaled, Array2<octave_idx_type>& ierr)
+           bool scaled, Array2<octave_idx_type>& ierr)
 {
   octave_idx_type nr = alpha.rows ();
   octave_idx_type nc = alpha.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -1627,17 +1627,17 @@ do_bessel (fptr f, const char *, const F
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x, alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 static inline FloatComplexMatrix
 do_bessel (fptr f, const char *fn, const FloatMatrix& alpha,
-	   const FloatComplexMatrix& x, bool scaled, Array2<octave_idx_type>& ierr)
+           const FloatComplexMatrix& x, bool scaled, Array2<octave_idx_type>& ierr)
 {
   FloatComplexMatrix retval;
 
   octave_idx_type x_nr = x.rows ();
   octave_idx_type x_nc = x.cols ();
 
   octave_idx_type alpha_nr = alpha.rows ();
   octave_idx_type alpha_nc = alpha.cols ();
@@ -1647,85 +1647,85 @@ do_bessel (fptr f, const char *fn, const
       octave_idx_type nr = x_nr;
       octave_idx_type nc = x_nc;
 
       retval.resize (nr, nc);
 
       ierr.resize (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
     }
   else
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
   return retval;
 }
 
 static inline FloatComplexNDArray
 do_bessel (fptr f, const char *, float alpha, const FloatComplexNDArray& x,
-	   bool scaled, Array<octave_idx_type>& ierr)
+           bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
       retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline FloatComplexNDArray
 do_bessel (fptr f, const char *, const FloatNDArray& alpha, const FloatComplex& x,
-	   bool scaled, Array<octave_idx_type>& ierr)
+           bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = alpha.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     retval(i) = f (x, alpha(i), (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline FloatComplexNDArray
 do_bessel (fptr f, const char *fn, const FloatNDArray& alpha,
-	   const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr)
+           const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
   FloatComplexNDArray retval;
 
   if (dv == alpha.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
       ierr.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
-	retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
+        retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
     }
   else
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
   return retval;
 }
 
 static inline FloatComplexMatrix
 do_bessel (fptr f, const char *, const FloatRowVector& alpha,
-	   const FloatComplexColumnVector& x, bool scaled, Array2<octave_idx_type>& ierr)
+           const FloatComplexColumnVector& x, bool scaled, Array2<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.length ();
   octave_idx_type nc = alpha.length ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -1741,57 +1741,57 @@ do_bessel (fptr f, const char *, const F
   name (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define SM_BESSEL(name, fcn) \
   FloatComplexMatrix \
   name (float alpha, const FloatComplexMatrix& x, bool scaled, \
-	Array2<octave_idx_type>& ierr) \
+        Array2<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define MS_BESSEL(name, fcn) \
   FloatComplexMatrix \
   name (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, \
-	Array2<octave_idx_type>& ierr) \
+        Array2<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define MM_BESSEL(name, fcn) \
   FloatComplexMatrix \
   name (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, \
-	Array2<octave_idx_type>& ierr) \
+        Array2<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define SN_BESSEL(name, fcn) \
   FloatComplexNDArray \
   name (float alpha, const FloatComplexNDArray& x, bool scaled, \
-	Array<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define NS_BESSEL(name, fcn) \
   FloatComplexNDArray \
   name (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, \
-	Array<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define NN_BESSEL(name, fcn) \
   FloatComplexNDArray \
   name (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, \
-	Array<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define RC_BESSEL(name, fcn) \
   FloatComplexMatrix \
   name (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, \
         Array2<octave_idx_type>& ierr) \
@@ -2083,26 +2083,26 @@ biry (const FloatComplexNDArray& z, bool
   for (octave_idx_type i = 0; i < nel; i++)
     retval (i) = biry (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 static void
 gripe_betainc_nonconformant (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2, octave_idx_type r3,
-			     octave_idx_type c3)
+                             octave_idx_type c3)
 {
   (*current_liboctave_error_handler)
    ("betainc: nonconformant arguments (x is %dx%d, a is %dx%d, b is %dx%d)",
      r1, c1, r2, c2, r3, c3);
 }
 
 static void
 gripe_betainc_nonconformant (const dim_vector& d1, const dim_vector& d2,
-			     const dim_vector& d3)
+                             const dim_vector& d3)
 {
   std::string d1_str = d1.str ();
   std::string d2_str = d2.str ();
   std::string d3_str = d3.str ();
 
   (*current_liboctave_error_handler)
   ("betainc: nonconformant arguments (x is %s, a is %s, b is %s)",
    d1_str.c_str (), d2_str.c_str (), d3_str.c_str ());
@@ -2157,18 +2157,18 @@ betainc (double x, const Matrix& a, cons
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nr == b_nr && a_nc == b_nc)
     {
       retval.resize (a_nr, a_nc);
 
       for (octave_idx_type j = 0; j < a_nc; j++)
-	for (octave_idx_type i = 0; i < a_nr; i++)
-	  retval(i,j) = betainc (x, a(i,j), b(i,j));
+        for (octave_idx_type i = 0; i < a_nr; i++)
+          retval(i,j) = betainc (x, a(i,j), b(i,j));
     }
   else
     gripe_betainc_nonconformant (1, 1, a_nr, a_nc, b_nr, b_nc);
 
   return retval;
 }
 
 NDArray
@@ -2207,17 +2207,17 @@ betainc (double x, const NDArray& a, con
 
   if (dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
-	retval (i) = betainc (x, a(i), b(i));
+        retval (i) = betainc (x, a(i), b(i));
     }
   else
     gripe_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
   
   return retval;
 }
 
 
@@ -2247,18 +2247,18 @@ betainc (const Matrix& x, double a, cons
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr == b_nr && nc == b_nc)
     {
       retval.resize (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  retval(i,j) = betainc (x(i,j), a, b(i,j));
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = betainc (x(i,j), a, b(i,j));
     }
   else
     gripe_betainc_nonconformant (nr, nc, 1, 1, b_nr, b_nc);
 
   return retval;
 }
 
 Matrix
@@ -2272,18 +2272,18 @@ betainc (const Matrix& x, const Matrix& 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr == a_nr && nc == a_nc)
     {
       retval.resize (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  retval(i,j) = betainc (x(i,j), a(i,j), b);
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = betainc (x(i,j), a(i,j), b);
     }
   else
     gripe_betainc_nonconformant (nr, nc, a_nr, a_nc, 1, 1);
 
   return retval;
 }
 
 Matrix
@@ -2300,18 +2300,18 @@ betainc (const Matrix& x, const Matrix& 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr == a_nr && nr == b_nr && nc == a_nc && nc == b_nc)
     {
       retval.resize (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  retval(i,j) = betainc (x(i,j), a(i,j), b(i,j));
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = betainc (x(i,j), a(i,j), b(i,j));
     }
   else
     gripe_betainc_nonconformant (nr, nc, a_nr, a_nc, b_nr, b_nc);
 
   return retval;
 }
 
 NDArray
@@ -2336,17 +2336,17 @@ betainc (const NDArray& x, double a, con
 
   if (dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
-	retval (i) = betainc (x(i), a, b(i));
+        retval (i) = betainc (x(i), a, b(i));
     }
   else
     gripe_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
   
   return retval;
 }
 
 NDArray
@@ -2357,17 +2357,17 @@ betainc (const NDArray& x, const NDArray
 
   if (dv == a.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
-	retval (i) = betainc (x(i), a(i), b);
+        retval (i) = betainc (x(i), a(i), b);
     }
   else
     gripe_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
   
   return retval;
 }
 
 NDArray
@@ -2378,17 +2378,17 @@ betainc (const NDArray& x, const NDArray
 
   if (dv == a.dims () && dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
-	retval (i) = betainc (x(i), a(i), b(i));
+        retval (i) = betainc (x(i), a(i), b(i));
     }
   else
     gripe_betainc_nonconformant (dv, a.dims (), b.dims ());
 
   return retval;
 }
 
 float
@@ -2440,18 +2440,18 @@ betainc (float x, const FloatMatrix& a, 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nr == b_nr && a_nc == b_nc)
     {
       retval.resize (a_nr, a_nc);
 
       for (octave_idx_type j = 0; j < a_nc; j++)
-	for (octave_idx_type i = 0; i < a_nr; i++)
-	  retval(i,j) = betainc (x, a(i,j), b(i,j));
+        for (octave_idx_type i = 0; i < a_nr; i++)
+          retval(i,j) = betainc (x, a(i,j), b(i,j));
     }
   else
     gripe_betainc_nonconformant (1, 1, a_nr, a_nc, b_nr, b_nc);
 
   return retval;
 }
 
 FloatNDArray
@@ -2490,17 +2490,17 @@ betainc (float x, const FloatNDArray& a,
 
   if (dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
-	retval (i) = betainc (x, a(i), b(i));
+        retval (i) = betainc (x, a(i), b(i));
     }
   else
     gripe_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
   
   return retval;
 }
 
 
@@ -2530,18 +2530,18 @@ betainc (const FloatMatrix& x, float a, 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr == b_nr && nc == b_nc)
     {
       retval.resize (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  retval(i,j) = betainc (x(i,j), a, b(i,j));
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = betainc (x(i,j), a, b(i,j));
     }
   else
     gripe_betainc_nonconformant (nr, nc, 1, 1, b_nr, b_nc);
 
   return retval;
 }
 
 FloatMatrix
@@ -2555,18 +2555,18 @@ betainc (const FloatMatrix& x, const Flo
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr == a_nr && nc == a_nc)
     {
       retval.resize (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  retval(i,j) = betainc (x(i,j), a(i,j), b);
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = betainc (x(i,j), a(i,j), b);
     }
   else
     gripe_betainc_nonconformant (nr, nc, a_nr, a_nc, 1, 1);
 
   return retval;
 }
 
 FloatMatrix
@@ -2583,18 +2583,18 @@ betainc (const FloatMatrix& x, const Flo
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr == a_nr && nr == b_nr && nc == a_nc && nc == b_nc)
     {
       retval.resize (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  retval(i,j) = betainc (x(i,j), a(i,j), b(i,j));
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = betainc (x(i,j), a(i,j), b(i,j));
     }
   else
     gripe_betainc_nonconformant (nr, nc, a_nr, a_nc, b_nr, b_nc);
 
   return retval;
 }
 
 FloatNDArray
@@ -2619,17 +2619,17 @@ betainc (const FloatNDArray& x, float a,
 
   if (dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
-	retval (i) = betainc (x(i), a, b(i));
+        retval (i) = betainc (x(i), a, b(i));
     }
   else
     gripe_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
   
   return retval;
 }
 
 FloatNDArray
@@ -2640,17 +2640,17 @@ betainc (const FloatNDArray& x, const Fl
 
   if (dv == a.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
-	retval (i) = betainc (x(i), a(i), b);
+        retval (i) = betainc (x(i), a(i), b);
     }
   else
     gripe_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
   
   return retval;
 }
 
 FloatNDArray
@@ -2661,17 +2661,17 @@ betainc (const FloatNDArray& x, const Fl
 
   if (dv == a.dims () && dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
-	retval (i) = betainc (x(i), a(i), b(i));
+        retval (i) = betainc (x(i), a(i), b(i));
     }
   else
     gripe_betainc_nonconformant (dv, a.dims (), b.dims ());
 
   return retval;
 }
 
 // FIXME -- there is still room for improvement here...
@@ -2681,17 +2681,17 @@ gammainc (double x, double a, bool& err)
 {
   double retval;
 
   err = false;
 
   if (a < 0.0 || x < 0.0)
     {
       (*current_liboctave_error_handler)
-	("gammainc: A and X must be non-negative");
+        ("gammainc: A and X must be non-negative");
 
       err = true;
     }
   else
     F77_XFCN (xgammainc, XGAMMAINC, (a, x, retval));
 
   return retval;
 }
@@ -2705,20 +2705,20 @@ gammainc (double x, const Matrix& a)
   Matrix result (nr, nc);
   Matrix retval;
 
   bool err;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	result(i,j) = gammainc (x, a(i,j), err);
-
-	if (err)
-	  goto done;
+        result(i,j) = gammainc (x, a(i,j), err);
+
+        if (err)
+          goto done;
       }
 
   retval = result;
 
  done:
 
   return retval;
 }
@@ -2732,20 +2732,20 @@ gammainc (const Matrix& x, double a)
   Matrix result (nr, nc);
   Matrix retval;
 
   bool err;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	result(i,j) = gammainc (x(i,j), a, err);
-
-	if (err)
-	  goto done;
+        result(i,j) = gammainc (x(i,j), a, err);
+
+        if (err)
+          goto done;
       }
 
   retval = result;
 
  done:
 
   return retval;
 }
@@ -2764,23 +2764,23 @@ gammainc (const Matrix& x, const Matrix&
 
   if (nr == a_nr && nc == a_nc)
     {
       result.resize (nr, nc);
 
       bool err;
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    result(i,j) = gammainc (x(i,j), a(i,j), err);
-
-	    if (err)
-	      goto done;
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            result(i,j) = gammainc (x(i,j), a(i,j), err);
+
+            if (err)
+              goto done;
+          }
 
       retval = result;
     }
   else
     (*current_liboctave_error_handler)
       ("gammainc: nonconformant arguments (arg 1 is %dx%d, arg 2 is %dx%d)",
        nr, nc, a_nr, a_nc);
 
@@ -2800,17 +2800,17 @@ gammainc (double x, const NDArray& a)
 
   bool err;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       result (i) = gammainc (x, a(i), err);
 
       if (err)
-	goto done;
+        goto done;
     }
 
   retval = result;
 
  done:
 
   return retval;
 }
@@ -2826,17 +2826,17 @@ gammainc (const NDArray& x, double a)
 
   bool err;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       result (i) = gammainc (x(i), a, err);
 
       if (err)
-	goto done;
+        goto done;
     }
 
   retval = result;
 
  done:
 
   return retval;
 }
@@ -2852,33 +2852,33 @@ gammainc (const NDArray& x, const NDArra
 
   if (dv == a.dims ())
     {
       result.resize (dv);
 
       bool err;
 
       for (octave_idx_type i = 0; i < nel; i++)
-	{
-	  result (i) = gammainc (x(i), a(i), err);
-	  
-	  if (err)
-	    goto done;
-	}
+        {
+          result (i) = gammainc (x(i), a(i), err);
+          
+          if (err)
+            goto done;
+        }
 
       retval = result;
     }
   else
     {
       std::string x_str = dv.str ();
       std::string a_str = a.dims ().str ();
 
       (*current_liboctave_error_handler)
-	("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
-	 x_str.c_str (), a_str. c_str ());
+        ("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
+         x_str.c_str (), a_str. c_str ());
     }
 
  done:
 
   return retval;
 }
 
 float
@@ -2886,17 +2886,17 @@ gammainc (float x, float a, bool& err)
 {
   float retval;
 
   err = false;
 
   if (a < 0.0 || x < 0.0)
     {
       (*current_liboctave_error_handler)
-	("gammainc: A and X must be non-negative");
+        ("gammainc: A and X must be non-negative");
 
       err = true;
     }
   else
     F77_XFCN (xsgammainc, XSGAMMAINC, (a, x, retval));
 
   return retval;
 }
@@ -2910,20 +2910,20 @@ gammainc (float x, const FloatMatrix& a)
   FloatMatrix result (nr, nc);
   FloatMatrix retval;
 
   bool err;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	result(i,j) = gammainc (x, a(i,j), err);
-
-	if (err)
-	  goto done;
+        result(i,j) = gammainc (x, a(i,j), err);
+
+        if (err)
+          goto done;
       }
 
   retval = result;
 
  done:
 
   return retval;
 }
@@ -2937,20 +2937,20 @@ gammainc (const FloatMatrix& x, float a)
   FloatMatrix result (nr, nc);
   FloatMatrix retval;
 
   bool err;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	result(i,j) = gammainc (x(i,j), a, err);
-
-	if (err)
-	  goto done;
+        result(i,j) = gammainc (x(i,j), a, err);
+
+        if (err)
+          goto done;
       }
 
   retval = result;
 
  done:
 
   return retval;
 }
@@ -2969,23 +2969,23 @@ gammainc (const FloatMatrix& x, const Fl
 
   if (nr == a_nr && nc == a_nc)
     {
       result.resize (nr, nc);
 
       bool err;
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    result(i,j) = gammainc (x(i,j), a(i,j), err);
-
-	    if (err)
-	      goto done;
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            result(i,j) = gammainc (x(i,j), a(i,j), err);
+
+            if (err)
+              goto done;
+          }
 
       retval = result;
     }
   else
     (*current_liboctave_error_handler)
       ("gammainc: nonconformant arguments (arg 1 is %dx%d, arg 2 is %dx%d)",
        nr, nc, a_nr, a_nc);
 
@@ -3005,17 +3005,17 @@ gammainc (float x, const FloatNDArray& a
 
   bool err;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       result (i) = gammainc (x, a(i), err);
 
       if (err)
-	goto done;
+        goto done;
     }
 
   retval = result;
 
  done:
 
   return retval;
 }
@@ -3031,17 +3031,17 @@ gammainc (const FloatNDArray& x, float a
 
   bool err;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       result (i) = gammainc (x(i), a, err);
 
       if (err)
-	goto done;
+        goto done;
     }
 
   retval = result;
 
  done:
 
   return retval;
 }
@@ -3057,33 +3057,33 @@ gammainc (const FloatNDArray& x, const F
 
   if (dv == a.dims ())
     {
       result.resize (dv);
 
       bool err;
 
       for (octave_idx_type i = 0; i < nel; i++)
-	{
-	  result (i) = gammainc (x(i), a(i), err);
-	  
-	  if (err)
-	    goto done;
-	}
+        {
+          result (i) = gammainc (x(i), a(i), err);
+          
+          if (err)
+            goto done;
+        }
 
       retval = result;
     }
   else
     {
       std::string x_str = dv.str ();
       std::string a_str = a.dims ().str ();
 
       (*current_liboctave_error_handler)
-	("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
-	 x_str.c_str (), a_str. c_str ());
+        ("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
+         x_str.c_str (), a_str. c_str ());
     }
 
  done:
 
   return retval;
 }
 
 
diff --git a/liboctave/lo-sysdep.cc b/liboctave/lo-sysdep.cc
--- a/liboctave/lo-sysdep.cc
+++ b/liboctave/lo-sysdep.cc
@@ -80,17 +80,17 @@ octave_chdir (const std::string& path_ar
 
   char *tmp_path = strsave (path.c_str ());
 
   if (path.length () == 2 && path[1] == ':')
     {
       char *upper_case_dir_name = strupr (tmp_path);
       _chdrive (upper_case_dir_name[0]);
       if (_getdrive () == upper_case_dir_name[0])
-	retval = _chdir2 ("/");
+        retval = _chdir2 ("/");
     }
   else
     retval = _chdir2 (tmp_path);
 
   delete [] tmp_path;
 
   return retval;
 #else
@@ -219,16 +219,16 @@ closedir (DIR *d)
 }
 
 struct direct *
 readdir (DIR *d)
 {
   if (! d->dirty)
     {
       if (! FindNextFile(d->hnd, &(d->fd)))
-	return 0;
+        return 0;
     }
   d->d.d_name = d->fd.cFileName;
   d->dirty = 0;
   return &(d->d);
 }
 
 #endif
diff --git a/liboctave/lo-utils.cc b/liboctave/lo-utils.cc
--- a/liboctave/lo-utils.cc
+++ b/liboctave/lo-utils.cc
@@ -166,55 +166,55 @@ octave_fgets (FILE *f, bool& eof)
 
   char *buf = static_cast<char *> (malloc (max_size));
   char *bufptr = buf;
   int len = 0;
 
   do
     {
       if (fgets (bufptr, grow_size, f))
-	{
-	  len = strlen (bufptr);
+        {
+          len = strlen (bufptr);
 
-	  if (len == grow_size - 1)
-	    {
-	      int tmp = bufptr - buf + grow_size - 1;
-	      grow_size *= 2;
-	      max_size += grow_size;
-	      buf = static_cast<char *> (realloc (buf, max_size));
-	      bufptr = buf + tmp;
+          if (len == grow_size - 1)
+            {
+              int tmp = bufptr - buf + grow_size - 1;
+              grow_size *= 2;
+              max_size += grow_size;
+              buf = static_cast<char *> (realloc (buf, max_size));
+              bufptr = buf + tmp;
 
-	      if (*(bufptr-1) == '\n')
-		{
-		  *bufptr = '\0';
-		  retval = buf;
-		}
-	    }
-	  else if (bufptr[len-1] != '\n')
-	    {
-	      bufptr[len++] = '\n';
-	      bufptr[len] = '\0';
-	      retval = buf;
-	    }
-	  else
-	    retval = buf;
-	}
+              if (*(bufptr-1) == '\n')
+                {
+                  *bufptr = '\0';
+                  retval = buf;
+                }
+            }
+          else if (bufptr[len-1] != '\n')
+            {
+              bufptr[len++] = '\n';
+              bufptr[len] = '\0';
+              retval = buf;
+            }
+          else
+            retval = buf;
+        }
       else
-	{
-	  if (len == 0)
-	    {
-	      eof = true;
+        {
+          if (len == 0)
+            {
+              eof = true;
 
-	      free (buf);
+              free (buf);
 
-	      buf = 0;
-	    }
+              buf = 0;
+            }
 
-	  break;
-	}
+          break;
+        }
     }
   while (retval.empty ());
 
   if (buf)
     free (buf);
 
   octave_quit ();
 
@@ -245,46 +245,46 @@ static inline double
 read_inf_nan_na (std::istream& is, char c, char sign = '+')
 {
   double d = 0.0;
 
   switch (c)
     {
     case 'i': case 'I':
       {
-	c = is.get ();
-	if (c == 'n' || c == 'N')
-	  {
-	    c = is.get ();
-	    if (c == 'f' || c == 'F')
-	      d = sign == '-' ? -octave_Inf : octave_Inf;
-	    else
-	      is.putback (c);
-	  }
-	else
-	  is.putback (c);
+        c = is.get ();
+        if (c == 'n' || c == 'N')
+          {
+            c = is.get ();
+            if (c == 'f' || c == 'F')
+              d = sign == '-' ? -octave_Inf : octave_Inf;
+            else
+              is.putback (c);
+          }
+        else
+          is.putback (c);
       }
       break;
 
     case 'n': case 'N':
       {
-	c = is.get ();
-	if (c == 'a' || c == 'A')
-	  {
-	    c = is.get ();
-	    if (c == 'n' || c == 'N')
-	      d = octave_NaN;
-	    else
-	      {
-		is.putback (c);
-		d = octave_NA;
-	      }
-	  }
-	else
-	  is.putback (c);
+        c = is.get ();
+        if (c == 'a' || c == 'A')
+          {
+            c = is.get ();
+            if (c == 'n' || c == 'N')
+              d = octave_NaN;
+            else
+              {
+                is.putback (c);
+                d = octave_NA;
+              }
+          }
+        else
+          is.putback (c);
       }
       break;
 
     default:
       abort ();
     }
 
   return d;
@@ -300,41 +300,41 @@ octave_read_value (std::istream& is)
 
   while (isspace (c1))
     c1 = is.get ();
 
   switch (c1)
     {
     case '-':
       {
-	char c2 = 0;
-	c2 = is.get ();
-	if (c2 == 'i' || c2 == 'I')
-	  d = read_inf_nan_na (is, c2, c1);
-	else
-	  {
-	    is.putback (c2);
-	    is.putback (c1);
-	    is >> d;
-	  }
+        char c2 = 0;
+        c2 = is.get ();
+        if (c2 == 'i' || c2 == 'I')
+          d = read_inf_nan_na (is, c2, c1);
+        else
+          {
+            is.putback (c2);
+            is.putback (c1);
+            is >> d;
+          }
       }
       break;
 
     case '+':
       {
-	char c2 = 0;
-	c2 = is.get ();
-	if (c2 == 'i' || c2 == 'I')
-	  d = read_inf_nan_na (is, c2, c1);
-	else
-	  {
-	    is.putback (c2);
-	    is.putback (c1);
-	    is >> d;
-	  }
+        char c2 = 0;
+        c2 = is.get ();
+        if (c2 == 'i' || c2 == 'I')
+          d = read_inf_nan_na (is, c2, c1);
+        else
+          {
+            is.putback (c2);
+            is.putback (c1);
+            is >> d;
+          }
       }
       break;
 
     case 'i': case 'I':
     case 'n': case 'N':
       d = read_inf_nan_na (is, c1);
       break;
 
@@ -360,29 +360,29 @@ octave_read_value (std::istream& is)
     ch = is.get ();
 
   if (ch == '(')
     {
       re = octave_read_value<double> (is);
       ch = is.get ();
 
       if (ch == ',')
-	{
-	  im = octave_read_value<double> (is);
-	  ch = is.get ();
+        {
+          im = octave_read_value<double> (is);
+          ch = is.get ();
 
-	  if (ch == ')')
-	    cx = Complex (re, im);
-	  else
-	    is.setstate (std::ios::failbit);
-	}
+          if (ch == ')')
+            cx = Complex (re, im);
+          else
+            is.setstate (std::ios::failbit);
+        }
       else if (ch == ')')
-	cx = re;
+        cx = re;
       else
-	is.setstate (std::ios::failbit);
+        is.setstate (std::ios::failbit);
     }
   else
     {
       is.putback (ch);
       cx = octave_read_value<double> (is);
     }
 
   return cx;
@@ -393,46 +393,46 @@ static inline float
 read_float_inf_nan_na (std::istream& is, char c, char sign = '+')
 {
   float d = 0.0;
 
   switch (c)
     {
     case 'i': case 'I':
       {
-	c = is.get ();
-	if (c == 'n' || c == 'N')
-	  {
-	    c = is.get ();
-	    if (c == 'f' || c == 'F')
-	      d = sign == '-' ? -octave_Inf : octave_Inf;
-	    else
-	      is.putback (c);
-	  }
-	else
-	  is.putback (c);
+        c = is.get ();
+        if (c == 'n' || c == 'N')
+          {
+            c = is.get ();
+            if (c == 'f' || c == 'F')
+              d = sign == '-' ? -octave_Inf : octave_Inf;
+            else
+              is.putback (c);
+          }
+        else
+          is.putback (c);
       }
       break;
 
     case 'n': case 'N':
       {
-	c = is.get ();
-	if (c == 'a' || c == 'A')
-	  {
-	    c = is.get ();
-	    if (c == 'n' || c == 'N')
-	      d = octave_NaN;
-	    else
-	      {
-		is.putback (c);
-		d = octave_NA;
-	      }
-	  }
-	else
-	  is.putback (c);
+        c = is.get ();
+        if (c == 'a' || c == 'A')
+          {
+            c = is.get ();
+            if (c == 'n' || c == 'N')
+              d = octave_NaN;
+            else
+              {
+                is.putback (c);
+                d = octave_NA;
+              }
+          }
+        else
+          is.putback (c);
       }
       break;
 
     default:
       abort ();
     }
 
   return d;
@@ -448,41 +448,41 @@ octave_read_value (std::istream& is)
 
   while (isspace (c1))
     c1 = is.get ();
 
   switch (c1)
     {
     case '-':
       {
-	char c2 = 0;
-	c2 = is.get ();
-	if (c2 == 'i' || c2 == 'I')
-	  d = read_float_inf_nan_na (is, c2, c1);
-	else
-	  {
-	    is.putback (c2);
-	    is.putback (c1);
-	    is >> d;
-	  }
+        char c2 = 0;
+        c2 = is.get ();
+        if (c2 == 'i' || c2 == 'I')
+          d = read_float_inf_nan_na (is, c2, c1);
+        else
+          {
+            is.putback (c2);
+            is.putback (c1);
+            is >> d;
+          }
       }
       break;
 
     case '+':
       {
-	char c2 = 0;
-	c2 = is.get ();
-	if (c2 == 'i' || c2 == 'I')
-	  d = read_float_inf_nan_na (is, c2, c1);
-	else
-	  {
-	    is.putback (c2);
-	    is.putback (c1);
-	    is >> d;
-	  }
+        char c2 = 0;
+        c2 = is.get ();
+        if (c2 == 'i' || c2 == 'I')
+          d = read_float_inf_nan_na (is, c2, c1);
+        else
+          {
+            is.putback (c2);
+            is.putback (c1);
+            is >> d;
+          }
       }
       break;
 
     case 'i': case 'I':
     case 'n': case 'N':
       d = read_float_inf_nan_na (is, c1);
       break;
 
@@ -508,29 +508,29 @@ octave_read_value (std::istream& is)
     ch = is.get ();
 
   if (ch == '(')
     {
       re = octave_read_value<float> (is);
       ch = is.get ();
 
       if (ch == ',')
-	{
-	  im = octave_read_value<float> (is);
-	  ch = is.get ();
+        {
+          im = octave_read_value<float> (is);
+          ch = is.get ();
 
-	  if (ch == ')')
-	    cx = FloatComplex (re, im);
-	  else
-	    is.setstate (std::ios::failbit);
-	}
+          if (ch == ')')
+            cx = FloatComplex (re, im);
+          else
+            is.setstate (std::ios::failbit);
+        }
       else if (ch == ')')
-	cx = re;
+        cx = re;
       else
-	is.setstate (std::ios::failbit);
+        is.setstate (std::ios::failbit);
     }
   else
     {
       is.putback (ch);
       cx = octave_read_value<float> (is);
     }
 
   return cx;
diff --git a/liboctave/mach-info.cc b/liboctave/mach-info.cc
--- a/liboctave/mach-info.cc
+++ b/liboctave/mach-info.cc
@@ -79,60 +79,60 @@ oct_mach_info::init_float_format (void) 
 
   native_float_fmt = oct_mach_info::flt_fmt_cray;
 
 #else
 
   float_params fp[5];
 
   INIT_FLT_PAR (fp[0], oct_mach_info::flt_fmt_ieee_big_endian,
-		   1048576,  0,
-		2146435071, -1,
-		1017118720,  0,
-		1018167296,  0);
+                   1048576,  0,
+                2146435071, -1,
+                1017118720,  0,
+                1018167296,  0);
 
   INIT_FLT_PAR (fp[1], oct_mach_info::flt_fmt_ieee_little_endian,
-		 0,    1048576,
-		-1, 2146435071,
-		 0, 1017118720,
-		 0, 1018167296);
+                 0,    1048576,
+                -1, 2146435071,
+                 0, 1017118720,
+                 0, 1018167296);
 
   INIT_FLT_PAR (fp[2], oct_mach_info::flt_fmt_vax_d,
-		   128,  0,
-		-32769, -1,
-		  9344,  0,
-		  9344,  0);
+                   128,  0,
+                -32769, -1,
+                  9344,  0,
+                  9344,  0);
 
   INIT_FLT_PAR (fp[3], oct_mach_info::flt_fmt_vax_g,
-		    16,  0,
-		-32769, -1,
-		 15552,  0,
-		 15552,  0);
+                    16,  0,
+                -32769, -1,
+                 15552,  0,
+                 15552,  0);
 
   INIT_FLT_PAR (fp[4], oct_mach_info::flt_fmt_unknown,
-		0, 0,
-		0, 0,
-		0, 0,
-		0, 0);
+                0, 0,
+                0, 0,
+                0, 0,
+                0, 0);
 
   equiv mach_fp_par[4];
 
   mach_fp_par[0].d = F77_FUNC (d1mach, D1MACH) (1);
   mach_fp_par[1].d = F77_FUNC (d1mach, D1MACH) (2);
   mach_fp_par[2].d = F77_FUNC (d1mach, D1MACH) (3);
   mach_fp_par[3].d = F77_FUNC (d1mach, D1MACH) (4);
 
   int i = 0;
   do
     {
       if (equiv_compare (fp[i].fp_par, mach_fp_par, 4))
-	{
-	  native_float_fmt = fp[i].fp_fmt;
-	  break;
-	}
+        {
+          native_float_fmt = fp[i].fp_fmt;
+          break;
+        }
     }
   while (fp[++i].fp_fmt != oct_mach_info::flt_fmt_unknown);
 
 #endif
 }
 
 void
 oct_mach_info::ten_little_endians (void) const
@@ -162,17 +162,17 @@ oct_mach_info::instance_ok (void)
   bool retval = true;
 
   if (! instance)
     instance = new oct_mach_info ();
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
-	("unable to create command history object!");
+        ("unable to create command history object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 oct_mach_info::float_format
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -416,19 +416,19 @@ mx_inline_equal (size_t n, const T1 *x, 
 
 #define OP_DUP_FCN(OP, F, R, T) \
   static inline R * \
   F (const T *x, size_t n) \
   { \
     R *r = 0; \
     if (n > 0) \
       { \
-	r = new R [n]; \
-	for (size_t i = 0; i < n; i++) \
-	  r[i] = OP (x[i]); \
+        r = new R [n]; \
+        for (size_t i = 0; i < n; i++) \
+          r[i] = OP (x[i]); \
       } \
     return r; \
   }
 
 OP_DUP_FCN (, mx_inline_dup, double,  double)
 OP_DUP_FCN (, mx_inline_dup, Complex, Complex)
 OP_DUP_FCN (, mx_inline_dup, float, float)
 OP_DUP_FCN (, mx_inline_dup, FloatComplex, FloatComplex)
@@ -1050,18 +1050,18 @@ void mx_inline_diff (const T *v, T *r, o
   switch (order)
     {
     case 1:
       for (octave_idx_type i = 0; i < n-1; i++)
         r[i] = v[i+1] - v[i];
       break;
     case 2:
       if (n > 1)
-	{
-	  T lst = v[1] - v[0];
+        {
+          T lst = v[1] - v[0];
           for (octave_idx_type i = 0; i < n-2; i++)
             {
               T dif = v[i+2] - v[i+1];
               r[i] = dif - lst;
               lst = dif;
             }
         }
       break;
diff --git a/liboctave/oct-alloc.cc b/liboctave/oct-alloc.cc
--- a/liboctave/oct-alloc.cc
+++ b/liboctave/oct-alloc.cc
@@ -33,17 +33,17 @@ void *
 octave_allocator::alloc (size_t size)
 {
   if (size != item_size)
     return ::new char [size];
 
   if (! head)
     {
       if (! grow ())
-	return 0;
+        return 0;
     }
 
   link *tmp = head;
   head = head->next;
   return tmp;
 }
 
 // FIXME -- if we free the last item on the list, shouldn't we
@@ -72,34 +72,34 @@ octave_allocator::grow (void)
   char *start = new char [grow_size * item_size];
 
   if (start)
     {
       char *last = &start[(grow_size - 1) * item_size];
 
       char *p = start;
       while (p < last)
-	{
-	  char *next = p + item_size;
-	  (reinterpret_cast<link *> (p)) -> next
-	    = reinterpret_cast<link *> (next);
-	  p = next;
-	}
+        {
+          char *next = p + item_size;
+          (reinterpret_cast<link *> (p)) -> next
+            = reinterpret_cast<link *> (next);
+          p = next;
+        }
 
       (reinterpret_cast<link *> (last)) -> next = 0;
 
       head = reinterpret_cast<link *> (start);
     }
   else
     {
       typedef void (*error_handler_function) (void);
 
       error_handler_function f = std::set_new_handler (0);
       std::set_new_handler (f);
 
       if (f)
-	f ();
+        f ();
 
       retval = false;
     }
 
   return retval;
 }
diff --git a/liboctave/oct-env.cc b/liboctave/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/oct-env.cc
@@ -82,17 +82,17 @@ octave_env::instance_ok (void)
   bool retval = true;
 
   if (! instance)
     instance = new octave_env ();
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
-	("unable to create current working directory object!");
+        ("unable to create current working directory object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 std::string
@@ -261,17 +261,17 @@ octave_env::do_absolute_pathname (const 
     return false;
 
   if (file_ops::is_dir_sep (s[0]))
     return true;
 
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM)
   if ((len == 2 && isalpha (s[0]) && s[1] == ':')
       || (len > 2 && isalpha (s[0]) && s[1] == ':'
-	  && file_ops::is_dir_sep (s[2])))
+          && file_ops::is_dir_sep (s[2])))
     return true;
 #endif
 
   return false;
 }
 
 bool
 octave_env::do_rooted_relative_pathname (const std::string& s) const
@@ -314,17 +314,17 @@ octave_env::do_base_pathname (const std:
     return s.substr (pos+1);
 }
 
 // Turn STRING (a pathname) into an absolute pathname, assuming that
 // DOT_PATH contains the symbolic location of the current directory.
 
 std::string
 octave_env::do_make_absolute (const std::string& s,
-			      const std::string& dot_path) const
+                              const std::string& dot_path) const
 {
 #if defined (__EMX__)
   if (s.length () > 1 && s[1] == ':')
     return s;
 #endif
 
   if (dot_path.empty () || s.empty () || do_absolute_pathname (s))
     return s;
@@ -342,52 +342,52 @@ octave_env::do_make_absolute (const std:
   // FIXME -- this is probably not correct for all systems.
 
   size_t i = 0;
   size_t slen = s.length ();
 
   while (i < slen)
     {
       if (s[i] == '.')
-	{
-	  if (i + 1 == slen)
-	    return current_dir;
+        {
+          if (i + 1 == slen)
+            return current_dir;
 
-	  if (file_ops::is_dir_sep (s[i+1]))
-	    {
-	      i += 2;
-	      continue;
-	    }
+          if (file_ops::is_dir_sep (s[i+1]))
+            {
+              i += 2;
+              continue;
+            }
 
-	  if (s[i+1] == '.'
-	      && (i + 2 == slen || file_ops::is_dir_sep (s[i+2])))
-	    {
-	      i += 2;
+          if (s[i+1] == '.'
+              && (i + 2 == slen || file_ops::is_dir_sep (s[i+2])))
+            {
+              i += 2;
 
-	      if (i != slen)
-		i++;
+              if (i != slen)
+                i++;
 
-	      pathname_backup (current_dir, 1);
+              pathname_backup (current_dir, 1);
 
-	      continue;
-	    }
-	}
+              continue;
+            }
+        }
 
       size_t tmp = s.find_first_of (file_ops::dir_sep_chars (), i);
 
       if (tmp == std::string::npos)
-	{
-	  current_dir.append (s, i, tmp-i);
-	  break;
-	}
+        {
+          current_dir.append (s, i, tmp-i);
+          break;
+        }
       else
-	{
-	  current_dir.append (s, i, tmp-i+1);
-	  i = tmp + 1;
-	}
+        {
+          current_dir.append (s, i, tmp-i+1);
+          i = tmp + 1;
+        }
     }
 
   return current_dir;
 }
 
 // Return a string which is the current working directory.
 
 std::string
@@ -411,19 +411,19 @@ octave_env::do_get_home_directory (void)
   std::string hd = do_getenv ("HOME");
 
 #if defined (__MINGW32__) || defined (_MSC_VER)
   // Maybe we are started directly from cmd.exe.
   if (hd.empty ())
     {
       std::string drv = do_getenv ("HOMEDRIVE");
       if (drv.empty ())
-	hd = do_getenv ("HOMEPATH");
+        hd = do_getenv ("HOMEPATH");
       else
-	hd = drv + do_getenv ("HOMEPATH");
+        hd = drv + do_getenv ("HOMEPATH");
     }
 #endif
 
   if (hd.empty ())
     {
       octave_passwd pw = octave_passwd::getpwuid (octave_syscalls::getuid ());
 
       hd = pw ? pw.dir () : std::string (file_ops::dir_sep_str ());
@@ -476,38 +476,38 @@ octave_env::do_chdir (const std::string&
 {
   bool retval = false;
 
   std::string tmp;
 
   if (follow_symbolic_links)
     {
       if (current_directory.empty ())
-	do_getcwd ();
+        do_getcwd ();
 
       if (current_directory.empty ())
-	tmp = newdir;
+        tmp = newdir;
       else
-	tmp = do_make_absolute (newdir, current_directory);
+        tmp = do_make_absolute (newdir, current_directory);
 
       // Get rid of trailing directory separator.
 
       size_t len = tmp.length ();
 
       if (len > 1)
-	{
-	  if (file_ops::is_dir_sep (tmp[--len]))
-	    tmp.resize (len);
-	}
+        {
+          if (file_ops::is_dir_sep (tmp[--len]))
+            tmp.resize (len);
+        }
 
       if (! ::octave_chdir (tmp))
-	{
-	  current_directory = tmp;
-	  retval = true;
-	}
+        {
+          current_directory = tmp;
+          retval = true;
+        }
     }
   else
     retval = (! ::octave_chdir (newdir));
 
   return retval;
 }
 
 // Remove the last N directories from PATH.
@@ -518,20 +518,20 @@ octave_env::pathname_backup (std::string
   if (path.empty ())
     return;
 
   size_t i = path.length () - 1;
 
   while (n--)
     {
       while (file_ops::is_dir_sep (path[i]) && i > 0)
-	i--;
+        i--;
 
       while (! file_ops::is_dir_sep (path[i]) && i > 0)
-	i--;
+        i--;
 
       i++;
     }
 
   path.resize (i);
 }
 
 void
diff --git a/liboctave/oct-fftw.cc b/liboctave/oct-fftw.cc
--- a/liboctave/oct-fftw.cc
+++ b/liboctave/oct-fftw.cc
@@ -80,34 +80,34 @@ octave_fftw_planner::instance_ok (void)
   bool retval = true;
 
   if (! instance)
     instance = new octave_fftw_planner ();
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
-	("unable to create octave_fftw_planner object!");
+        ("unable to create octave_fftw_planner object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 #define CHECK_SIMD_ALIGNMENT(x) \
   (((reinterpret_cast<ptrdiff_t> (x)) & 0xF) == 0)
 
 fftw_plan
 octave_fftw_planner::do_create_plan (int dir, const int rank,
-				     const dim_vector dims,
-				     octave_idx_type howmany,
-				     octave_idx_type stride,
-				     octave_idx_type dist, 
-				     const Complex *in, Complex *out)
+                                     const dim_vector dims,
+                                     octave_idx_type howmany,
+                                     octave_idx_type stride,
+                                     octave_idx_type dist, 
+                                     const Complex *in, Complex *out)
 {
   int which = (dir == FFTW_FORWARD) ? 0 : 1;
   fftw_plan *cur_plan_p = &plan[which];
   bool create_new_plan = false;
   bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
   bool ioinplace = (in == out);
 
   // Don't create a new plan if we have a non SIMD plan already but
@@ -119,21 +119,21 @@ octave_fftw_planner::do_create_plan (int
       || ioinplace != inplace[which]
       || ((ioalign != simd_align[which]) ? !ioalign : false))
     create_new_plan = true;
   else
     {
       // We still might not have the same shape of array.
 
       for (int i = 0; i < rank; i++)
-	if (dims(i) != n[which](i))
-	  {
-	    create_new_plan = true;
-	    break;
-	  }
+        if (dims(i) != n[which](i))
+          {
+            create_new_plan = true;
+            break;
+          }
     }
 
   if (create_new_plan)
     {
       d[which] = dist;
       s[which] = stride;
       r[which] = rank;
       h[which] = howmany;
@@ -141,95 +141,95 @@ octave_fftw_planner::do_create_plan (int
       inplace[which] = ioinplace;
       n[which] = dims;
 
       // Note reversal of dimensions for column major storage in FFTW.
       octave_idx_type nn = 1;
       OCTAVE_LOCAL_BUFFER (int, tmp, rank);
 
       for (int i = 0, j = rank-1; i < rank; i++, j--)
-	{
-	  tmp[i] = dims(j);
-	  nn *= dims(j);
-	}
+        {
+          tmp[i] = dims(j);
+          nn *= dims(j);
+        }
 
       int plan_flags = 0;
       bool plan_destroys_in = true;
 
       switch (meth) 
-	{
-	case UNKNOWN:
-	case ESTIMATE:
-	  plan_flags |= FFTW_ESTIMATE;
-	  plan_destroys_in = false;
-	  break;
-	case MEASURE:
-	  plan_flags |= FFTW_MEASURE;
-	  break;
-	case PATIENT:
-	  plan_flags |= FFTW_PATIENT;
-	  break;
-	case EXHAUSTIVE:
-	  plan_flags |= FFTW_EXHAUSTIVE;
-	  break;
-	case HYBRID:
-	  if (nn < 8193)
-	    plan_flags |= FFTW_MEASURE;
-	  else
-	    {
-	      plan_flags |= FFTW_ESTIMATE;
-	      plan_destroys_in = false;
-	    }
-	  break;
-	}
+        {
+        case UNKNOWN:
+        case ESTIMATE:
+          plan_flags |= FFTW_ESTIMATE;
+          plan_destroys_in = false;
+          break;
+        case MEASURE:
+          plan_flags |= FFTW_MEASURE;
+          break;
+        case PATIENT:
+          plan_flags |= FFTW_PATIENT;
+          break;
+        case EXHAUSTIVE:
+          plan_flags |= FFTW_EXHAUSTIVE;
+          break;
+        case HYBRID:
+          if (nn < 8193)
+            plan_flags |= FFTW_MEASURE;
+          else
+            {
+              plan_flags |= FFTW_ESTIMATE;
+              plan_destroys_in = false;
+            }
+          break;
+        }
 
       if (ioalign)
-	plan_flags &= ~FFTW_UNALIGNED;
+        plan_flags &= ~FFTW_UNALIGNED;
       else
-	plan_flags |= FFTW_UNALIGNED;
+        plan_flags |= FFTW_UNALIGNED;
 
       if (*cur_plan_p)
-	fftw_destroy_plan (*cur_plan_p);
+        fftw_destroy_plan (*cur_plan_p);
 
       if (plan_destroys_in)
-	{
-	  // Create matrix with the same size and 16-byte alignment as input
-	  OCTAVE_LOCAL_BUFFER (Complex, itmp, nn * howmany + 32);
-	  itmp = reinterpret_cast<Complex *>
-	    (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) + 
-	     ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
+        {
+          // Create matrix with the same size and 16-byte alignment as input
+          OCTAVE_LOCAL_BUFFER (Complex, itmp, nn * howmany + 32);
+          itmp = reinterpret_cast<Complex *>
+            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) + 
+             ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
-	  *cur_plan_p =
-	    fftw_plan_many_dft (rank, tmp, howmany,
-	      reinterpret_cast<fftw_complex *> (itmp),
-	      0, stride, dist, reinterpret_cast<fftw_complex *> (out),
-	      0, stride, dist, dir, plan_flags);
-	}
+          *cur_plan_p =
+            fftw_plan_many_dft (rank, tmp, howmany,
+              reinterpret_cast<fftw_complex *> (itmp),
+              0, stride, dist, reinterpret_cast<fftw_complex *> (out),
+              0, stride, dist, dir, plan_flags);
+        }
       else
-	{
-	  *cur_plan_p =
-	    fftw_plan_many_dft (rank, tmp, howmany,
-	      reinterpret_cast<fftw_complex *> (const_cast<Complex *> (in)),
-	      0, stride, dist, reinterpret_cast<fftw_complex *> (out),
-	      0, stride, dist, dir, plan_flags);
-	}
+        {
+          *cur_plan_p =
+            fftw_plan_many_dft (rank, tmp, howmany,
+              reinterpret_cast<fftw_complex *> (const_cast<Complex *> (in)),
+              0, stride, dist, reinterpret_cast<fftw_complex *> (out),
+              0, stride, dist, dir, plan_flags);
+        }
 
       if (*cur_plan_p == 0)
-	(*current_liboctave_error_handler) ("Error creating fftw plan");
+        (*current_liboctave_error_handler) ("Error creating fftw plan");
     }
 
   return *cur_plan_p;
 }
  
 fftw_plan
 octave_fftw_planner::do_create_plan (const int rank, const dim_vector dims, 
-				     octave_idx_type howmany,
-				     octave_idx_type stride,
-				     octave_idx_type dist, 
-				     const double *in, Complex *out)
+                                     octave_idx_type howmany,
+                                     octave_idx_type stride,
+                                     octave_idx_type dist, 
+                                     const double *in, Complex *out)
 {
   fftw_plan *cur_plan_p = &rplan;
   bool create_new_plan = false;
   bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
 
   // Don't create a new plan if we have a non SIMD plan already but
   // can do SIMD.  This prevents endlessly recreating plans if we
   // change the alignment.
@@ -237,104 +237,104 @@ octave_fftw_planner::do_create_plan (con
   if (rplan == 0 || rd != dist || rs != stride || rr != rank
       || rh != howmany || ((ioalign != rsimd_align) ? !ioalign : false))
     create_new_plan = true;
   else
     {
       // We still might not have the same shape of array.
 
       for (int i = 0; i < rank; i++)
-	if (dims(i) != rn(i))
-	  {
-	    create_new_plan = true;
-	    break;
-	  }
+        if (dims(i) != rn(i))
+          {
+            create_new_plan = true;
+            break;
+          }
     }
 
   if (create_new_plan)
     {
       rd = dist;
       rs = stride;
       rr = rank;
       rh = howmany;
       rsimd_align = ioalign;
       rn = dims;
 
       // Note reversal of dimensions for column major storage in FFTW.
       octave_idx_type nn = 1;
       OCTAVE_LOCAL_BUFFER (int, tmp, rank);
 
       for (int i = 0, j = rank-1; i < rank; i++, j--)
-	{
-	  tmp[i] = dims(j);
-	  nn *= dims(j);
-	}
+        {
+          tmp[i] = dims(j);
+          nn *= dims(j);
+        }
 
       int plan_flags = 0;
       bool plan_destroys_in = true;
 
       switch (meth) 
-	{
-	case UNKNOWN:
-	case ESTIMATE:
-	  plan_flags |= FFTW_ESTIMATE;
-	  plan_destroys_in = false;
-	  break;
-	case MEASURE:
-	  plan_flags |= FFTW_MEASURE;
-	  break;
-	case PATIENT:
-	  plan_flags |= FFTW_PATIENT;
-	  break;
-	case EXHAUSTIVE:
-	  plan_flags |= FFTW_EXHAUSTIVE;
-	  break;
-	case HYBRID:
-	  if (nn < 8193)
-	    plan_flags |= FFTW_MEASURE;
-	  else
-	    {
-	      plan_flags |= FFTW_ESTIMATE;
-	      plan_destroys_in = false;
-	    }
-	  break;
-	}
+        {
+        case UNKNOWN:
+        case ESTIMATE:
+          plan_flags |= FFTW_ESTIMATE;
+          plan_destroys_in = false;
+          break;
+        case MEASURE:
+          plan_flags |= FFTW_MEASURE;
+          break;
+        case PATIENT:
+          plan_flags |= FFTW_PATIENT;
+          break;
+        case EXHAUSTIVE:
+          plan_flags |= FFTW_EXHAUSTIVE;
+          break;
+        case HYBRID:
+          if (nn < 8193)
+            plan_flags |= FFTW_MEASURE;
+          else
+            {
+              plan_flags |= FFTW_ESTIMATE;
+              plan_destroys_in = false;
+            }
+          break;
+        }
 
       if (ioalign)
-	plan_flags &= ~FFTW_UNALIGNED;
+        plan_flags &= ~FFTW_UNALIGNED;
       else
-	plan_flags |= FFTW_UNALIGNED;
+        plan_flags |= FFTW_UNALIGNED;
 
       if (*cur_plan_p)
-	fftw_destroy_plan (*cur_plan_p);
+        fftw_destroy_plan (*cur_plan_p);
 
       if (plan_destroys_in)
-	{
-	  // Create matrix with the same size and 16-byte alignment as input
-	  OCTAVE_LOCAL_BUFFER (double, itmp, nn + 32);
-	  itmp = reinterpret_cast<double *>
-	    (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) + 
-	     ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
+        {
+          // Create matrix with the same size and 16-byte alignment as input
+          OCTAVE_LOCAL_BUFFER (double, itmp, nn + 32);
+          itmp = reinterpret_cast<double *>
+            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) + 
+             ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
-	  *cur_plan_p =
-	    fftw_plan_many_dft_r2c (rank, tmp, howmany, itmp,
-	      0, stride, dist, reinterpret_cast<fftw_complex *> (out),
-	      0, stride, dist, plan_flags);
-	}
+          *cur_plan_p =
+            fftw_plan_many_dft_r2c (rank, tmp, howmany, itmp,
+              0, stride, dist, reinterpret_cast<fftw_complex *> (out),
+              0, stride, dist, plan_flags);
+        }
       else
-	{
-	  *cur_plan_p =
-	    fftw_plan_many_dft_r2c (rank, tmp, howmany,
-	      (const_cast<double *> (in)),
-	      0, stride, dist, reinterpret_cast<fftw_complex *> (out),
-	      0, stride, dist, plan_flags);
-	}
+        {
+          *cur_plan_p =
+            fftw_plan_many_dft_r2c (rank, tmp, howmany,
+              (const_cast<double *> (in)),
+              0, stride, dist, reinterpret_cast<fftw_complex *> (out),
+              0, stride, dist, plan_flags);
+        }
 
       if (*cur_plan_p == 0)
-	(*current_liboctave_error_handler) ("Error creating fftw plan");
+        (*current_liboctave_error_handler) ("Error creating fftw plan");
     }
 
   return *cur_plan_p;
 }
 
 octave_fftw_planner::FftwMethod
 octave_fftw_planner::do_method (void)
 {
@@ -345,26 +345,26 @@ octave_fftw_planner::FftwMethod
 octave_fftw_planner::do_method (FftwMethod _meth)
 {
   FftwMethod ret = meth;
   if (_meth == ESTIMATE || _meth == MEASURE
       || _meth == PATIENT || _meth == EXHAUSTIVE
       || _meth == HYBRID)
     {
       if (meth != _meth) 
-	{
-	  meth = _meth;
-	  if (rplan)
-	    fftw_destroy_plan (rplan);
-	  if (plan[0])
-	    fftw_destroy_plan (plan[0]);
-	  if (plan[1])
-	    fftw_destroy_plan (plan[1]);
-	  rplan = plan[0] = plan[1] = 0;
-	}
+        {
+          meth = _meth;
+          if (rplan)
+            fftw_destroy_plan (rplan);
+          if (plan[0])
+            fftw_destroy_plan (plan[0]);
+          if (plan[1])
+            fftw_destroy_plan (plan[1]);
+          rplan = plan[0] = plan[1] = 0;
+        }
     }
   else
     ret = UNKNOWN;
   return ret;
 }
 
 octave_float_fftw_planner *octave_float_fftw_planner::instance = 0;
 
@@ -393,32 +393,32 @@ octave_float_fftw_planner::instance_ok (
   bool retval = true;
 
   if (! instance)
     instance = new octave_float_fftw_planner ();
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
-	("unable to create octave_fftw_planner object!");
+        ("unable to create octave_fftw_planner object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 fftwf_plan
 octave_float_fftw_planner::do_create_plan (int dir, const int rank,
-					   const dim_vector dims,
-					   octave_idx_type howmany,
-					   octave_idx_type stride,
-					   octave_idx_type dist, 
-					   const FloatComplex *in,
-					   FloatComplex *out)
+                                           const dim_vector dims,
+                                           octave_idx_type howmany,
+                                           octave_idx_type stride,
+                                           octave_idx_type dist, 
+                                           const FloatComplex *in,
+                                           FloatComplex *out)
 {
   int which = (dir == FFTW_FORWARD) ? 0 : 1;
   fftwf_plan *cur_plan_p = &plan[which];
   bool create_new_plan = false;
   bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
   bool ioinplace = (in == out);
 
   // Don't create a new plan if we have a non SIMD plan already but
@@ -430,21 +430,21 @@ octave_float_fftw_planner::do_create_pla
       || ioinplace != inplace[which]
       || ((ioalign != simd_align[which]) ? !ioalign : false))
     create_new_plan = true;
   else
     {
       // We still might not have the same shape of array.
 
       for (int i = 0; i < rank; i++)
-	if (dims(i) != n[which](i))
-	  {
-	    create_new_plan = true;
-	    break;
-	  }
+        if (dims(i) != n[which](i))
+          {
+            create_new_plan = true;
+            break;
+          }
     }
 
   if (create_new_plan)
     {
       d[which] = dist;
       s[which] = stride;
       r[which] = rank;
       h[which] = howmany;
@@ -452,96 +452,96 @@ octave_float_fftw_planner::do_create_pla
       inplace[which] = ioinplace;
       n[which] = dims;
 
       // Note reversal of dimensions for column major storage in FFTW.
       octave_idx_type nn = 1;
       OCTAVE_LOCAL_BUFFER (int, tmp, rank);
 
       for (int i = 0, j = rank-1; i < rank; i++, j--)
-	{
-	  tmp[i] = dims(j);
-	  nn *= dims(j);
-	}
+        {
+          tmp[i] = dims(j);
+          nn *= dims(j);
+        }
 
       int plan_flags = 0;
       bool plan_destroys_in = true;
 
       switch (meth) 
-	{
-	case UNKNOWN:
-	case ESTIMATE:
-	  plan_flags |= FFTW_ESTIMATE;
-	  plan_destroys_in = false;
-	  break;
-	case MEASURE:
-	  plan_flags |= FFTW_MEASURE;
-	  break;
-	case PATIENT:
-	  plan_flags |= FFTW_PATIENT;
-	  break;
-	case EXHAUSTIVE:
-	  plan_flags |= FFTW_EXHAUSTIVE;
-	  break;
-	case HYBRID:
-	  if (nn < 8193)
-	    plan_flags |= FFTW_MEASURE;
-	  else
-	    {
-	      plan_flags |= FFTW_ESTIMATE;
-	      plan_destroys_in = false;
-	    }
-	  break;
-	}
+        {
+        case UNKNOWN:
+        case ESTIMATE:
+          plan_flags |= FFTW_ESTIMATE;
+          plan_destroys_in = false;
+          break;
+        case MEASURE:
+          plan_flags |= FFTW_MEASURE;
+          break;
+        case PATIENT:
+          plan_flags |= FFTW_PATIENT;
+          break;
+        case EXHAUSTIVE:
+          plan_flags |= FFTW_EXHAUSTIVE;
+          break;
+        case HYBRID:
+          if (nn < 8193)
+            plan_flags |= FFTW_MEASURE;
+          else
+            {
+              plan_flags |= FFTW_ESTIMATE;
+              plan_destroys_in = false;
+            }
+          break;
+        }
 
       if (ioalign)
-	plan_flags &= ~FFTW_UNALIGNED;
+        plan_flags &= ~FFTW_UNALIGNED;
       else
-	plan_flags |= FFTW_UNALIGNED;
+        plan_flags |= FFTW_UNALIGNED;
 
       if (*cur_plan_p)
-	fftwf_destroy_plan (*cur_plan_p);
+        fftwf_destroy_plan (*cur_plan_p);
 
       if (plan_destroys_in)
-	{
-	  // Create matrix with the same size and 16-byte alignment as input
-	  OCTAVE_LOCAL_BUFFER (FloatComplex, itmp, nn * howmany + 32);
-	  itmp = reinterpret_cast<FloatComplex *>
-	    (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) + 
-	     ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
+        {
+          // Create matrix with the same size and 16-byte alignment as input
+          OCTAVE_LOCAL_BUFFER (FloatComplex, itmp, nn * howmany + 32);
+          itmp = reinterpret_cast<FloatComplex *>
+            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) + 
+             ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
-	  *cur_plan_p =
-	    fftwf_plan_many_dft (rank, tmp, howmany,
-	      reinterpret_cast<fftwf_complex *> (itmp),
-	      0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
-	      0, stride, dist, dir, plan_flags);
-	}
+          *cur_plan_p =
+            fftwf_plan_many_dft (rank, tmp, howmany,
+              reinterpret_cast<fftwf_complex *> (itmp),
+              0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
+              0, stride, dist, dir, plan_flags);
+        }
       else
-	{
-	  *cur_plan_p =
-	    fftwf_plan_many_dft (rank, tmp, howmany,
-	      reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *> (in)),
-	      0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
-	      0, stride, dist, dir, plan_flags);
-	}
+        {
+          *cur_plan_p =
+            fftwf_plan_many_dft (rank, tmp, howmany,
+              reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *> (in)),
+              0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
+              0, stride, dist, dir, plan_flags);
+        }
 
       if (*cur_plan_p == 0)
-	(*current_liboctave_error_handler) ("Error creating fftw plan");
+        (*current_liboctave_error_handler) ("Error creating fftw plan");
     }
 
   return *cur_plan_p;
 }
  
 fftwf_plan
 octave_float_fftw_planner::do_create_plan (const int rank,
-					   const dim_vector dims, 
-					   octave_idx_type howmany,
-					   octave_idx_type stride,
-					   octave_idx_type dist, 
-					   const float *in, FloatComplex *out)
+                                           const dim_vector dims, 
+                                           octave_idx_type howmany,
+                                           octave_idx_type stride,
+                                           octave_idx_type dist, 
+                                           const float *in, FloatComplex *out)
 {
   fftwf_plan *cur_plan_p = &rplan;
   bool create_new_plan = false;
   bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
 
   // Don't create a new plan if we have a non SIMD plan already but
   // can do SIMD.  This prevents endlessly recreating plans if we
   // change the alignment.
@@ -549,104 +549,104 @@ octave_float_fftw_planner::do_create_pla
   if (rplan == 0 || rd != dist || rs != stride || rr != rank
       || rh != howmany || ((ioalign != rsimd_align) ? !ioalign : false))
     create_new_plan = true;
   else
     {
       // We still might not have the same shape of array.
 
       for (int i = 0; i < rank; i++)
-	if (dims(i) != rn(i))
-	  {
-	    create_new_plan = true;
-	    break;
-	  }
+        if (dims(i) != rn(i))
+          {
+            create_new_plan = true;
+            break;
+          }
     }
 
   if (create_new_plan)
     {
       rd = dist;
       rs = stride;
       rr = rank;
       rh = howmany;
       rsimd_align = ioalign;
       rn = dims;
 
       // Note reversal of dimensions for column major storage in FFTW.
       octave_idx_type nn = 1;
       OCTAVE_LOCAL_BUFFER (int, tmp, rank);
 
       for (int i = 0, j = rank-1; i < rank; i++, j--)
-	{
-	  tmp[i] = dims(j);
-	  nn *= dims(j);
-	}
+        {
+          tmp[i] = dims(j);
+          nn *= dims(j);
+        }
 
       int plan_flags = 0;
       bool plan_destroys_in = true;
 
       switch (meth) 
-	{
-	case UNKNOWN:
-	case ESTIMATE:
-	  plan_flags |= FFTW_ESTIMATE;
-	  plan_destroys_in = false;
-	  break;
-	case MEASURE:
-	  plan_flags |= FFTW_MEASURE;
-	  break;
-	case PATIENT:
-	  plan_flags |= FFTW_PATIENT;
-	  break;
-	case EXHAUSTIVE:
-	  plan_flags |= FFTW_EXHAUSTIVE;
-	  break;
-	case HYBRID:
-	  if (nn < 8193)
-	    plan_flags |= FFTW_MEASURE;
-	  else
-	    {
-	      plan_flags |= FFTW_ESTIMATE;
-	      plan_destroys_in = false;
-	    }
-	  break;
-	}
+        {
+        case UNKNOWN:
+        case ESTIMATE:
+          plan_flags |= FFTW_ESTIMATE;
+          plan_destroys_in = false;
+          break;
+        case MEASURE:
+          plan_flags |= FFTW_MEASURE;
+          break;
+        case PATIENT:
+          plan_flags |= FFTW_PATIENT;
+          break;
+        case EXHAUSTIVE:
+          plan_flags |= FFTW_EXHAUSTIVE;
+          break;
+        case HYBRID:
+          if (nn < 8193)
+            plan_flags |= FFTW_MEASURE;
+          else
+            {
+              plan_flags |= FFTW_ESTIMATE;
+              plan_destroys_in = false;
+            }
+          break;
+        }
 
       if (ioalign)
-	plan_flags &= ~FFTW_UNALIGNED;
+        plan_flags &= ~FFTW_UNALIGNED;
       else
-	plan_flags |= FFTW_UNALIGNED;
+        plan_flags |= FFTW_UNALIGNED;
 
       if (*cur_plan_p)
-	fftwf_destroy_plan (*cur_plan_p);
+        fftwf_destroy_plan (*cur_plan_p);
 
       if (plan_destroys_in)
-	{
-	  // Create matrix with the same size and 16-byte alignment as input
-	  OCTAVE_LOCAL_BUFFER (float, itmp, nn + 32);
-	  itmp = reinterpret_cast<float *>
-	    (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) + 
-	     ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
+        {
+          // Create matrix with the same size and 16-byte alignment as input
+          OCTAVE_LOCAL_BUFFER (float, itmp, nn + 32);
+          itmp = reinterpret_cast<float *>
+            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) + 
+             ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
-	  *cur_plan_p =
-	    fftwf_plan_many_dft_r2c (rank, tmp, howmany, itmp,
-	      0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
-	      0, stride, dist, plan_flags);
-	}
+          *cur_plan_p =
+            fftwf_plan_many_dft_r2c (rank, tmp, howmany, itmp,
+              0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
+              0, stride, dist, plan_flags);
+        }
       else
-	{
-	  *cur_plan_p =
-	    fftwf_plan_many_dft_r2c (rank, tmp, howmany,
-	      (const_cast<float *> (in)),
-	      0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
-	      0, stride, dist, plan_flags);
-	}
+        {
+          *cur_plan_p =
+            fftwf_plan_many_dft_r2c (rank, tmp, howmany,
+              (const_cast<float *> (in)),
+              0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
+              0, stride, dist, plan_flags);
+        }
 
       if (*cur_plan_p == 0)
-	(*current_liboctave_error_handler) ("Error creating fftw plan");
+        (*current_liboctave_error_handler) ("Error creating fftw plan");
     }
 
   return *cur_plan_p;
 }
 
 octave_float_fftw_planner::FftwMethod
 octave_float_fftw_planner::do_method (void)
 {
@@ -657,36 +657,36 @@ octave_float_fftw_planner::FftwMethod
 octave_float_fftw_planner::do_method (FftwMethod _meth)
 {
   FftwMethod ret = meth;
   if (_meth == ESTIMATE || _meth == MEASURE
       || _meth == PATIENT || _meth == EXHAUSTIVE
       || _meth == HYBRID)
     {
       if (meth != _meth) 
-	{
-	  meth = _meth;
-	  if (rplan)
-	    fftwf_destroy_plan (rplan);
-	  if (plan[0])
-	    fftwf_destroy_plan (plan[0]);
-	  if (plan[1])
-	    fftwf_destroy_plan (plan[1]);
-	  rplan = plan[0] = plan[1] = 0;
-	}
+        {
+          meth = _meth;
+          if (rplan)
+            fftwf_destroy_plan (rplan);
+          if (plan[0])
+            fftwf_destroy_plan (plan[0]);
+          if (plan[1])
+            fftwf_destroy_plan (plan[1]);
+          rplan = plan[0] = plan[1] = 0;
+        }
     }
   else
     ret = UNKNOWN;
   return ret;
 }
 
 template <class T>
 static inline void
 convert_packcomplex_1d (T *out, size_t nr, size_t nc,
-			octave_idx_type stride, octave_idx_type dist)
+                        octave_idx_type stride, octave_idx_type dist)
 {
   octave_quit ();
 
   // Fill in the missing data.
 
   for (size_t i = 0; i < nr; i++)
     for (size_t j = nc/2+1; j < nc; j++)
       out[j*stride + i*dist] = conj(out[(nc - j)*stride + i*dist]);
@@ -708,313 +708,313 @@ convert_packcomplex_Nd (T *out, const di
 
   // Create space for the missing elements.
 
   for (size_t i = 0; i < nrp; i++)
     {
       ptr1 = out + i * (nc/2 + 1) + nrp*((nc-1)/2);
       ptr2 = out + i * nc;
       for (size_t j = 0; j < nc/2+1; j++)
-	*ptr2++ = *ptr1++;
+        *ptr2++ = *ptr1++;
     }
 
   octave_quit ();
 
   // Fill in the missing data for the rank = 2 case directly for speed.
 
   for (size_t i = 0; i < np; i++)
     {
       for (size_t j = 1; j < nr; j++)
-	for (size_t k = nc/2+1; k < nc; k++)
-	  out[k + (j + i*nr)*nc] = conj(out[nc - k + ((i+1)*nr - j)*nc]);
+        for (size_t k = nc/2+1; k < nc; k++)
+          out[k + (j + i*nr)*nc] = conj(out[nc - k + ((i+1)*nr - j)*nc]);
 
       for (size_t j = nc/2+1; j < nc; j++)
-	out[j + i*nr*nc] = conj(out[(i*nr+1)*nc - j]);
+        out[j + i*nr*nc] = conj(out[(i*nr+1)*nc - j]);
     }
 
   octave_quit ();
 
   // Now do the permutations needed for rank > 2 cases.
 
   size_t jstart = dv(0) * dv(1);
   size_t kstep = dv(0);
   size_t nel = dv.numel ();
 
   for (int inner = 2; inner < dv.length (); inner++) 
     {
       size_t jmax = jstart * dv(inner);
       for (size_t i = 0; i < nel; i+=jmax)
-	for (size_t j = jstart, jj = jmax-jstart; j < jj; 
-	     j+=jstart, jj-=jstart)
-	  for (size_t k = 0; k < jstart; k+= kstep)
-	    for (size_t l = nc/2+1; l < nc; l++)
-	      {
-		T tmp = out[i+ j + k + l];
-		out[i + j + k + l] =  out[i + jj + k + l];
-		out[i + jj + k + l] = tmp;
-	      }
+        for (size_t j = jstart, jj = jmax-jstart; j < jj; 
+             j+=jstart, jj-=jstart)
+          for (size_t k = 0; k < jstart; k+= kstep)
+            for (size_t l = nc/2+1; l < nc; l++)
+              {
+                T tmp = out[i+ j + k + l];
+                out[i + j + k + l] =  out[i + jj + k + l];
+                out[i + jj + k + l] = tmp;
+              }
       jstart = jmax;
     }
 
   octave_quit ();
 }
 
 int
 octave_fftw::fft (const double *in, Complex *out, size_t npts, 
-		  size_t nsamples, octave_idx_type stride, octave_idx_type dist)
+                  size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts);
   fftw_plan plan = octave_fftw_planner::create_plan (1, dv, nsamples,
-						     stride, dist, in, out);
+                                                     stride, dist, in, out);
 
   fftw_execute_dft_r2c (plan, (const_cast<double *>(in)),
-			 reinterpret_cast<fftw_complex *> (out));
+                         reinterpret_cast<fftw_complex *> (out));
 
   // Need to create other half of the transform.
 
   convert_packcomplex_1d (out, nsamples, npts, stride, dist);
 
   return 0;
 }
 
 int
 octave_fftw::fft (const Complex *in, Complex *out, size_t npts, 
-		  size_t nsamples, octave_idx_type stride, octave_idx_type dist)
+                  size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts);
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_FORWARD, 1, dv,
-						     nsamples, stride,
-						     dist, in, out);
+                                                     nsamples, stride,
+                                                     dist, in, out);
 
   fftw_execute_dft (plan, 
-	reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
-	reinterpret_cast<fftw_complex *> (out));
+        reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
+        reinterpret_cast<fftw_complex *> (out));
 
   return 0;
 }
 
 int
 octave_fftw::ifft (const Complex *in, Complex *out, size_t npts, 
-		   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
+                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts);
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_BACKWARD, 1, dv,
-						     nsamples, stride,
-						     dist, in, out);
+                                                     nsamples, stride,
+                                                     dist, in, out);
 
   fftw_execute_dft (plan, 
-	reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
-	reinterpret_cast<fftw_complex *> (out));
+        reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
+        reinterpret_cast<fftw_complex *> (out));
 
   const Complex scale = npts;
   for (size_t j = 0; j < nsamples; j++)
     for (size_t i = 0; i < npts; i++)
       out[i*stride + j*dist] /= scale;
 
   return 0;
 }
 
 int
 octave_fftw::fftNd (const double *in, Complex *out, const int rank, 
-		    const dim_vector &dv)
+                    const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   // Fool with the position of the start of the output matrix, so that
   // creating other half of the matrix won't cause cache problems.
 
   octave_idx_type offset = (dv.numel () / dv(0)) * ((dv(0) - 1) / 2); 
   
   fftw_plan plan = octave_fftw_planner::create_plan (rank, dv, 1, 1, dist,
-						     in, out + offset);
+                                                     in, out + offset);
 
   fftw_execute_dft_r2c (plan, (const_cast<double *>(in)),
-			reinterpret_cast<fftw_complex *> (out+ offset));
+                        reinterpret_cast<fftw_complex *> (out+ offset));
 
   // Need to create other half of the transform.
 
   convert_packcomplex_Nd (out, dv);
 
   return 0;
 }
 
 int
 octave_fftw::fftNd (const Complex *in, Complex *out, const int rank, 
-		    const dim_vector &dv)
+                    const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_FORWARD, rank,
-						     dv, 1, 1, dist, in, out);
+                                                     dv, 1, 1, dist, in, out);
 
   fftw_execute_dft (plan, 
-	reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
-	reinterpret_cast<fftw_complex *> (out));
+        reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
+        reinterpret_cast<fftw_complex *> (out));
 
   return 0;
 }
 
 int
 octave_fftw::ifftNd (const Complex *in, Complex *out, const int rank, 
-		     const dim_vector &dv)
+                     const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_BACKWARD, rank,
-						     dv, 1, 1, dist, in, out);
+                                                     dv, 1, 1, dist, in, out);
 
   fftw_execute_dft (plan, 
-	reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
-	reinterpret_cast<fftw_complex *> (out));
+        reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
+        reinterpret_cast<fftw_complex *> (out));
 
   const size_t npts = dv.numel ();
   const Complex scale = npts;
   for (size_t i = 0; i < npts; i++)
     out[i] /= scale;
 
   return 0;
 }
 
 int
 octave_fftw::fft (const float *in, FloatComplex *out, size_t npts, 
-		  size_t nsamples, octave_idx_type stride, octave_idx_type dist)
+                  size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts);
   fftwf_plan plan = octave_float_fftw_planner::create_plan (1, dv, nsamples,
-							    stride, dist,
-							    in, out);
+                                                            stride, dist,
+                                                            in, out);
 
   fftwf_execute_dft_r2c (plan, (const_cast<float *>(in)),
-			reinterpret_cast<fftwf_complex *> (out));
+                        reinterpret_cast<fftwf_complex *> (out));
 
   // Need to create other half of the transform.
 
   convert_packcomplex_1d (out, nsamples, npts, stride, dist);
 
   return 0;
 }
 
 int
 octave_fftw::fft (const FloatComplex *in, FloatComplex *out, size_t npts, 
-		  size_t nsamples, octave_idx_type stride, octave_idx_type dist)
+                  size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts);
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_FORWARD, 1,
-							    dv, nsamples,
-							    stride, dist,
-							    in, out);
+                                                            dv, nsamples,
+                                                            stride, dist,
+                                                            in, out);
 
   fftwf_execute_dft (plan, 
-	reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
-	reinterpret_cast<fftwf_complex *> (out));
+        reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
+        reinterpret_cast<fftwf_complex *> (out));
 
   return 0;
 }
 
 int
 octave_fftw::ifft (const FloatComplex *in, FloatComplex *out, size_t npts, 
-		   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
+                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts);
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_BACKWARD, 1,
-							    dv, nsamples,
-							    stride, dist,
-							    in, out);
+                                                            dv, nsamples,
+                                                            stride, dist,
+                                                            in, out);
 
   fftwf_execute_dft (plan, 
-	reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
-	reinterpret_cast<fftwf_complex *> (out));
+        reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
+        reinterpret_cast<fftwf_complex *> (out));
 
   const FloatComplex scale = npts;
   for (size_t j = 0; j < nsamples; j++)
     for (size_t i = 0; i < npts; i++)
       out[i*stride + j*dist] /= scale;
 
   return 0;
 }
 
 int
 octave_fftw::fftNd (const float *in, FloatComplex *out, const int rank, 
-		    const dim_vector &dv)
+                    const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   // Fool with the position of the start of the output matrix, so that
   // creating other half of the matrix won't cause cache problems.
 
   octave_idx_type offset = (dv.numel () / dv(0)) * ((dv(0) - 1) / 2); 
   
   fftwf_plan plan = octave_float_fftw_planner::create_plan (rank, dv, 1, 1,
-							    dist, in,
-							    out + offset);
+                                                            dist, in,
+                                                            out + offset);
 
   fftwf_execute_dft_r2c (plan, (const_cast<float *>(in)),
-			reinterpret_cast<fftwf_complex *> (out+ offset));
+                        reinterpret_cast<fftwf_complex *> (out+ offset));
 
   // Need to create other half of the transform.
 
   convert_packcomplex_Nd (out, dv);
 
   return 0;
 }
 
 int
 octave_fftw::fftNd (const FloatComplex *in, FloatComplex *out, const int rank, 
-		    const dim_vector &dv)
+                    const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_FORWARD,
-							    rank, dv, 1, 1,
-							    dist, in, out);
+                                                            rank, dv, 1, 1,
+                                                            dist, in, out);
 
   fftwf_execute_dft (plan, 
-	reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
-	reinterpret_cast<fftwf_complex *> (out));
+        reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
+        reinterpret_cast<fftwf_complex *> (out));
 
   return 0;
 }
 
 int
 octave_fftw::ifftNd (const FloatComplex *in, FloatComplex *out, const int rank, 
-		     const dim_vector &dv)
+                     const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_BACKWARD,
-							    rank, dv, 1, 1,
-							    dist, in, out);
+                                                            rank, dv, 1, 1,
+                                                            dist, in, out);
 
   fftwf_execute_dft (plan, 
-	reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
-	reinterpret_cast<fftwf_complex *> (out));
+        reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
+        reinterpret_cast<fftwf_complex *> (out));
 
   const size_t npts = dv.numel ();
   const FloatComplex scale = npts;
   for (size_t i = 0; i < npts; i++)
     out[i] /= scale;
 
   return 0;
 }
diff --git a/liboctave/oct-glob.cc b/liboctave/oct-glob.cc
--- a/liboctave/oct-glob.cc
+++ b/liboctave/oct-glob.cc
@@ -70,41 +70,41 @@ octave_glob (const string_vector& pat)
 
   int k = 0;
 
   for (int i = 0; i < npat; i++)
     {
       std::string xpat = pat(i);
 
       if (! xpat.empty ())
-	{
-	  glob_t glob_info;
+        {
+          glob_t glob_info;
 
-	  int err = ::glob (xpat.c_str (), GLOB_NOSORT, 0, &glob_info);
+          int err = ::glob (xpat.c_str (), GLOB_NOSORT, 0, &glob_info);
 
-	  if (! err)
-	    {
-	      int n = glob_info.gl_pathc;
+          if (! err)
+            {
+              int n = glob_info.gl_pathc;
 
-	      const char * const *matches = glob_info.gl_pathv;
+              const char * const *matches = glob_info.gl_pathv;
 
-	      // FIXME -- we shouldn't have to check to see if
-	      // a single match exists, but it seems that glob() won't
-	      // check for us unless the pattern contains globbing
-	      // characters.  Hmm.
+              // FIXME -- we shouldn't have to check to see if
+              // a single match exists, but it seems that glob() won't
+              // check for us unless the pattern contains globbing
+              // characters.  Hmm.
 
-	      if (n > 1
-		  || (n == 1
-		      && single_match_exists (std::string (matches[0]))))
-		{
-		  retval.resize (k+n);
+              if (n > 1
+                  || (n == 1
+                      && single_match_exists (std::string (matches[0]))))
+                {
+                  retval.resize (k+n);
 
-		  for (int j = 0; j < n; j++)
-		    retval[k++] = matches[j];
-		}
+                  for (int j = 0; j < n; j++)
+                    retval[k++] = matches[j];
+                }
 
-	      globfree (&glob_info);
-	    }
-	}
+              globfree (&glob_info);
+            }
+        }
     }
 
   return retval.sort ();
 }
diff --git a/liboctave/oct-group.cc b/liboctave/oct-group.cc
--- a/liboctave/oct-group.cc
+++ b/liboctave/oct-group.cc
@@ -192,27 +192,27 @@ octave_group::octave_group (void *p, std
       // FIXME -- maybe there should be a string_vector
       // constructor that takes a NUL terminated list of C
       // strings.
 
       const char * const *tmp = gr->gr_mem;
 
       int k = 0;
       while (*tmp++)
-	k++;
+        k++;
 
       if (k > 0)
-	{
-	  tmp = gr->gr_mem;
+        {
+          tmp = gr->gr_mem;
 
-	  gr_mem.resize (k);
+          gr_mem.resize (k);
 
-	  for (int i = 0; i < k; i++)
-	    gr_mem[i] = tmp[i];
-	}
+          for (int i = 0; i < k; i++)
+            gr_mem[i] = tmp[i];
+        }
 
       valid = true;
     }
 #else
   msg = NOT_SUPPORTED ("group functions");
 #endif
 }
 
diff --git a/liboctave/oct-inttypes.cc b/liboctave/oct-inttypes.cc
--- a/liboctave/oct-inttypes.cc
+++ b/liboctave/oct-inttypes.cc
@@ -547,25 +547,25 @@ pow (const octave_int<T>& a, const octav
       octave_int<T> a_val = a;
       T b_val = b; // no need to do saturation on b
 
       retval = a;
 
       b_val -= 1;
 
       while (b_val != 0)
-	{
-	  if (b_val & 1)
-	    retval = retval * a_val;
+        {
+          if (b_val & 1)
+            retval = retval * a_val;
 
-	  b_val = b_val >> 1;
+          b_val = b_val >> 1;
 
-	  if (b_val)
-	    a_val = a_val * a_val;
-	}
+          if (b_val)
+            a_val = a_val * a_val;
+        }
     }
 
   return retval;
 }
 
 template <class T>
 octave_int<T>
 pow (const double& a, const octave_int<T>& b)
diff --git a/liboctave/oct-md5.cc b/liboctave/oct-md5.cc
--- a/liboctave/oct-md5.cc
+++ b/liboctave/oct-md5.cc
@@ -48,17 +48,17 @@ std::string
 oct_md5 (const std::string str)
 {
   unsigned char buf[16];
 
   md5_buffer (str.data (), str.length (), buf);
 
   return oct_md5_result_to_str (buf);
 }
-	  
+          
 std::string
 oct_md5_file (const std::string file)
 {
   std::string retval;
 
   FILE *ifile = fopen (file.c_str (), "rb");
 
   if (ifile)
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -87,17 +87,17 @@ octave_rand::instance_ok (void)
   bool retval = true;
 
   if (! instance)
     instance = new octave_rand ();
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
-	("unable to create octave_rand object!");
+        ("unable to create octave_rand object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 double
@@ -215,17 +215,17 @@ octave_rand::do_distribution (void)
       break;
 
     case gamma_dist:
       retval = "gamma";
       break;
 
     default:
       (*current_liboctave_error_handler)
-	("rand: invalid distribution ID = %d", current_distribution);
+        ("rand: invalid distribution ID = %d", current_distribution);
       break;
     }
 
   return retval;
 }
 
 void
 octave_rand::do_distribution (const std::string& d)
@@ -251,17 +251,17 @@ octave_rand::do_distribution (const std:
       break;
 
     case gamma_dist:
       octave_rand::gamma_distribution ();
       break;
 
     default:
       (*current_liboctave_error_handler)
-	("rand: invalid distribution ID = %d", id);
+        ("rand: invalid distribution ID = %d", id);
       break;
     }
 }
 
 void
 octave_rand::do_uniform_distribution (void)
 {
   switch_to_generator (uniform_dist);
@@ -305,82 +305,82 @@ octave_rand::do_gamma_distribution (void
 double
 octave_rand::do_scalar (double a)
 {
   double retval = 0.0;
 
   if (use_old_generators)
     {
       switch (current_distribution)
-	{
-	case uniform_dist:
-	  F77_FUNC (dgenunf, DGENUNF) (0.0, 1.0, retval);
-	  break;
+        {
+        case uniform_dist:
+          F77_FUNC (dgenunf, DGENUNF) (0.0, 1.0, retval);
+          break;
 
-	case normal_dist:
-	  F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, retval);
-	  break;
+        case normal_dist:
+          F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, retval);
+          break;
 
-	case expon_dist:
-	  F77_FUNC (dgenexp, DGENEXP) (1.0, retval);
-	  break;
+        case expon_dist:
+          F77_FUNC (dgenexp, DGENEXP) (1.0, retval);
+          break;
 
-	case poisson_dist:
-	  if (a < 0.0 || xisnan(a) || xisinf(a))
-	    retval = octave_NaN;
-	  else
-	    {
-	      // workaround bug in ignpoi, by calling with different Mu
-	      F77_FUNC (dignpoi, DIGNPOI) (a + 1, retval);
-	      F77_FUNC (dignpoi, DIGNPOI) (a, retval);
-	    }
-	  break;
+        case poisson_dist:
+          if (a < 0.0 || xisnan(a) || xisinf(a))
+            retval = octave_NaN;
+          else
+            {
+              // workaround bug in ignpoi, by calling with different Mu
+              F77_FUNC (dignpoi, DIGNPOI) (a + 1, retval);
+              F77_FUNC (dignpoi, DIGNPOI) (a, retval);
+            }
+          break;
 
-	case gamma_dist:
-	  if (a <= 0.0 || xisnan(a) || xisinf(a))
-	    retval = octave_NaN;
-	  else
-	    F77_FUNC (dgengam, DGENGAM) (1.0, a, retval);
-	  break;
+        case gamma_dist:
+          if (a <= 0.0 || xisnan(a) || xisinf(a))
+            retval = octave_NaN;
+          else
+            F77_FUNC (dgengam, DGENGAM) (1.0, a, retval);
+          break;
 
-	default:
-	  (*current_liboctave_error_handler) 
-	    ("rand: invalid distribution ID = %d", current_distribution);
-	  break;
-	}
+        default:
+          (*current_liboctave_error_handler) 
+            ("rand: invalid distribution ID = %d", current_distribution);
+          break;
+        }
     }
   else
     {
       switch (current_distribution)
-	{
-	case uniform_dist:
-	  retval = oct_randu ();
-	  break;
+        {
+        case uniform_dist:
+          retval = oct_randu ();
+          break;
 
-	case normal_dist:
-	  retval = oct_randn ();
-	  break;
+        case normal_dist:
+          retval = oct_randn ();
+          break;
 
-	case expon_dist:
-	  retval = oct_rande ();
-	  break;
+        case expon_dist:
+          retval = oct_rande ();
+          break;
 
-	case poisson_dist:
-	  retval = oct_randp (a);
-	  break;
+        case poisson_dist:
+          retval = oct_randp (a);
+          break;
 
-	case gamma_dist:
-	  retval = oct_randg (a);
-	  break;
+        case gamma_dist:
+          retval = oct_randg (a);
+          break;
 
-	default:
-	  (*current_liboctave_error_handler)
-	    ("rand: invalid distribution ID = %d", current_distribution);
-	  break;
-	}
+        default:
+          (*current_liboctave_error_handler)
+            ("rand: invalid distribution ID = %d", current_distribution);
+          break;
+        }
 
       save_state ();
     }
 
   return retval;
 }
 
 Matrix
@@ -388,17 +388,17 @@ octave_rand::do_matrix (octave_idx_type 
 {
   Matrix retval;
 
   if (n >= 0 && m >= 0)
     {
       retval.clear (n, m);
 
       if (n > 0 && m > 0)
-	fill (retval.capacity(), retval.fortran_vec(), a);
+        fill (retval.capacity(), retval.fortran_vec(), a);
     }
   else
     (*current_liboctave_error_handler) ("rand: invalid negative argument");
 
   return retval;
 }
 
 NDArray
@@ -556,104 +556,104 @@ octave_rand::switch_to_generator (int di
     }
 }
 
 #define MAKE_RAND(len) \
   do \
     { \
       double val; \
       for (volatile octave_idx_type i = 0; i < len; i++) \
-	{ \
-	  octave_quit (); \
-	  RAND_FUNC (val); \
-	  v[i] = val; \
-	} \
+        { \
+          octave_quit (); \
+          RAND_FUNC (val); \
+          v[i] = val; \
+        } \
     } \
   while (0)
 
 void
 octave_rand::fill (octave_idx_type len, double *v, double a)
 {
   if (len < 1)
     return;
 
   switch (current_distribution)
     {
     case uniform_dist:
       if (use_old_generators)
-	{
+        {
 #define RAND_FUNC(x) F77_FUNC (dgenunf, DGENUNF) (0.0, 1.0, x)
-	  MAKE_RAND (len);
+          MAKE_RAND (len);
 #undef RAND_FUNC
-	}
+        }
       else
-	oct_fill_randu (len, v);
+        oct_fill_randu (len, v);
       break;
 
     case normal_dist:
       if (use_old_generators)
-	{
+        {
 #define RAND_FUNC(x) F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, x)
-	  MAKE_RAND (len);
+          MAKE_RAND (len);
 #undef RAND_FUNC
-	}
+        }
       else
-	oct_fill_randn (len, v);
+        oct_fill_randn (len, v);
       break;
 
     case expon_dist:
       if (use_old_generators)
-	{
+        {
 #define RAND_FUNC(x) F77_FUNC (dgenexp, DGENEXP) (1.0, x)
-	  MAKE_RAND (len);
+          MAKE_RAND (len);
 #undef RAND_FUNC
-	}
+        }
       else
-	oct_fill_rande (len, v);
+        oct_fill_rande (len, v);
       break;
 
     case poisson_dist:
       if (use_old_generators)
-	{
-	  if (a < 0.0 || xisnan(a) || xisinf(a))
+        {
+          if (a < 0.0 || xisnan(a) || xisinf(a))
 #define RAND_FUNC(x) x = octave_NaN;
-	    MAKE_RAND (len);
+            MAKE_RAND (len);
 #undef RAND_FUNC
-	  else
-	    {
-	      // workaround bug in ignpoi, by calling with different Mu
-	      double tmp;
-	      F77_FUNC (dignpoi, DIGNPOI) (a + 1, tmp);
+          else
+            {
+              // workaround bug in ignpoi, by calling with different Mu
+              double tmp;
+              F77_FUNC (dignpoi, DIGNPOI) (a + 1, tmp);
 #define RAND_FUNC(x) F77_FUNC (dignpoi, DIGNPOI) (a, x)
-		MAKE_RAND (len);
+                MAKE_RAND (len);
 #undef RAND_FUNC
-	    }
-	}
+            }
+        }
       else
-	oct_fill_randp (a, len, v);
+        oct_fill_randp (a, len, v);
       break;
 
     case gamma_dist:
       if (use_old_generators)
-	{
-	  if (a <= 0.0 || xisnan(a) || xisinf(a))
+        {
+          if (a <= 0.0 || xisnan(a) || xisinf(a))
 #define RAND_FUNC(x) x = octave_NaN;
-	    MAKE_RAND (len);
+            MAKE_RAND (len);
 #undef RAND_FUNC
-	  else
+          else
 #define RAND_FUNC(x) F77_FUNC (dgengam, DGENGAM) (1.0, a, x)
-	    MAKE_RAND (len);
+            MAKE_RAND (len);
 #undef RAND_FUNC
-	}
+        }
       else
-	oct_fill_randg (a, len, v);
+        oct_fill_randg (a, len, v);
       break;
 
     default:
       (*current_liboctave_error_handler)
-	("rand: invalid distribution ID = %d", current_distribution);
+        ("rand: invalid distribution ID = %d", current_distribution);
       break;
     }
 
   save_state ();
 
   return;
 }
diff --git a/liboctave/oct-shlib.cc b/liboctave/oct-shlib.cc
--- a/liboctave/oct-shlib.cc
+++ b/liboctave/oct-shlib.cc
@@ -212,26 +212,26 @@ octave_dlopen_shlib::octave_dlopen_shlib
 octave_dlopen_shlib::~octave_dlopen_shlib (void)
 {
   if (library)
     dlclose (library);
 }
 
 void *
 octave_dlopen_shlib::search (const std::string& name,
-			     octave_shlib::name_mangler mangler)
+                             octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
   if (is_open ())
     {
       std::string sym_name = name;
 
       if (mangler)
-	sym_name = mangler (name);
+        sym_name = mangler (name);
 
       function = dlsym (library, sym_name.c_str ());
     }
   else
     (*current_liboctave_error_handler)
       ("shared library %s is not open", file.c_str ());
 
   return function;
@@ -280,29 +280,29 @@ octave_shl_load_shlib::octave_shl_load_s
 octave_shl_load_shlib::~octave_shl_load_shlib (void)
 {
   if (library)
     shl_unload (library);
 }
 
 void *
 octave_shl_load_shlib::search (const std::string& name,
-			       octave_shlib::name_mangler mangler)
+                               octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
   if (is_open ())
     {
       std::string sym_name = name;
 
       if (mangler)
-	sym_name = mangler (name);
-	
+        sym_name = mangler (name);
+        
       int status = shl_findsym (&library, sym_name.c_str (),
-				TYPE_UNDEFINED, &function);
+                                TYPE_UNDEFINED, &function);
     }
   else
     (*current_liboctave_error_handler)
       ("shared library %s is not open", file.c_str ());
 
   return function;
 }
 
@@ -373,26 +373,26 @@ octave_w32_shlib::~octave_w32_shlib (voi
 
 extern "C"
 {
   void * octave_w32_search (HINSTANCE handle, const char * name);
 }
 
 void *
 octave_w32_shlib::search (const std::string& name,
-			  octave_shlib::name_mangler mangler)
+                          octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
   if (is_open ())
     {
       std::string sym_name = name;
 
       if (mangler)
-	sym_name = mangler (name);
+        sym_name = mangler (name);
 
       function = octave_w32_library_search (handle, sym_name.c_str ());
     }
   else
     (*current_liboctave_error_handler)
       ("shared library %s is not open", file.c_str ());
 
   return function;
@@ -447,17 +447,17 @@ octave_dyld_shlib::octave_dyld_shlib (co
           const char *errstr = 0;
 
           NSLinkEditError (&ler, &lerno, &file2, &errstr);
 
           if (! errstr)
             errstr = "unspecified error";
 
           (*current_liboctave_error_handler)
-            ("%s: %s", file.c_str (), errstr);	
+            ("%s: %s", file.c_str (), errstr);  
         }
     }
   else
     {
       (*current_liboctave_error_handler)
         ("got NSObjectFileImageReturnCode %d", returnCode);
 
       // FIXME -- should use NSLinkEditError () to get
@@ -470,33 +470,33 @@ octave_dyld_shlib::~octave_dyld_shlib (v
   if (handle)
     NSUnLinkModule (handle, NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);
 
   NSDestroyObjectFileImage (img);
 }
 
 void *
 octave_dyld_shlib::search (const std::string& name,
-			   octave_shlib::name_mangler mangler)
+                           octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
   if (is_open ())
     {
       std::string sym_name = name;
 
       if (mangler)
-	sym_name = mangler (name);
+        sym_name = mangler (name);
 
       NSSymbol symbol = NSLookupSymbolInModule (handle, sym_name.c_str ());
 
       if (symbol)
-	{
-	  function = NSAddressOfSymbol (symbol);
-	}
+        {
+          function = NSAddressOfSymbol (symbol);
+        }
     }
   else
     (*current_liboctave_error_handler)
       ("bundle %s is not open", file.c_str ());
 
   return function;
 }
 
diff --git a/liboctave/oct-sort.cc b/liboctave/oct-sort.cc
--- a/liboctave/oct-sort.cc
+++ b/liboctave/oct-sort.cc
@@ -159,31 +159,31 @@ octave_sort<T>::binarysort (T *data, oct
       octave_idx_type l = 0, r = start;
       T pivot = data[start];
       /* Invariants:
        * pivot >= all in [lo, l).
        * pivot  < all in [r, start).
        * The second is vacuously true at the start.
        */
       do 
-	{
-	  octave_idx_type p = l + ((r - l) >> 1);
-	  if (comp (pivot, data[p]))
-	    r = p;
-	  else
-	    l = p+1;
-	} 
+        {
+          octave_idx_type p = l + ((r - l) >> 1);
+          if (comp (pivot, data[p]))
+            r = p;
+          else
+            l = p+1;
+        } 
       while (l < r);
       /* The invariants still hold, so pivot >= all in [lo, l) and
-	 pivot < all in [l, start), so pivot belongs at l.  Note
-	 that if there are elements equal to pivot, l points to the
-	 first slot after them -- that's why this sort is stable.
-	 Slide over to make room.
-	 Caution: using memmove is much slower under MSVC 5;
-	 we're not usually moving many slots. */
+         pivot < all in [l, start), so pivot belongs at l.  Note
+         that if there are elements equal to pivot, l points to the
+         first slot after them -- that's why this sort is stable.
+         Slide over to make room.
+         Caution: using memmove is much slower under MSVC 5;
+         we're not usually moving many slots. */
       // NOTE: using swap and going upwards appears to be faster.
       for (octave_idx_type p = l; p < start; p++)
         std::swap (pivot, data[p]);
       data[start] = pivot;
     }
 
   return;
 }
@@ -203,31 +203,31 @@ octave_sort<T>::binarysort (T *data, oct
       octave_idx_type l = 0, r = start;
       T pivot = data[start];
       /* Invariants:
        * pivot >= all in [lo, l).
        * pivot  < all in [r, start).
        * The second is vacuously true at the start.
        */
       do 
-	{
-	  octave_idx_type p = l + ((r - l) >> 1);
-	  if (comp (pivot, data[p]))
-	    r = p;
-	  else
-	    l = p+1;
-	} 
+        {
+          octave_idx_type p = l + ((r - l) >> 1);
+          if (comp (pivot, data[p]))
+            r = p;
+          else
+            l = p+1;
+        } 
       while (l < r);
       /* The invariants still hold, so pivot >= all in [lo, l) and
-	 pivot < all in [l, start), so pivot belongs at l.  Note
-	 that if there are elements equal to pivot, l points to the
-	 first slot after them -- that's why this sort is stable.
-	 Slide over to make room.
-	 Caution: using memmove is much slower under MSVC 5;
-	 we're not usually moving many slots. */
+         pivot < all in [l, start), so pivot belongs at l.  Note
+         that if there are elements equal to pivot, l points to the
+         first slot after them -- that's why this sort is stable.
+         Slide over to make room.
+         Caution: using memmove is much slower under MSVC 5;
+         we're not usually moving many slots. */
       // NOTE: using swap and going upwards appears to be faster.
       for (octave_idx_type p = l; p < start; p++)
         std::swap (pivot, data[p]);
       data[start] = pivot;
       octave_idx_type ipivot = idx[start];
       for (octave_idx_type p = l; p < start; p++)
         std::swap (ipivot, idx[p]);
       idx[start] = ipivot;
@@ -268,30 +268,30 @@ octave_sort<T>::count_run (T *lo, octave
     return 1;
 
   n = 2;
 
   if (comp (*lo, *(lo-1)))
     {
       descending = true;
       for (lo = lo+1; lo < hi; ++lo, ++n) 
-	{
-	  if (comp (*lo, *(lo-1)))
-	    ;
-	  else
-	    break;
-	}
+        {
+          if (comp (*lo, *(lo-1)))
+            ;
+          else
+            break;
+        }
     }
   else 
     {
       for (lo = lo+1; lo < hi; ++lo, ++n) 
-	{
-	  if (comp (*lo, *(lo-1)))
-	    break;
-	}
+        {
+          if (comp (*lo, *(lo-1)))
+            break;
+        }
     }
 
   return n;
 }
 
 /*
 Locate the proper position of key in a sorted vector; if the vector contains
 an element equal to key, return the position immediately to the left of
@@ -326,53 +326,53 @@ octave_sort<T>::gallop_left (T key, T *a
   a += hint;
   lastofs = 0;
   ofs = 1;
   if (comp (*a, key))
     {
       /* a[hint] < key -- gallop right, until
        * a[hint + lastofs] < key <= a[hint + ofs]
        */
-      const octave_idx_type maxofs = n - hint;	/* &a[n-1] is highest */
+      const octave_idx_type maxofs = n - hint;  /* &a[n-1] is highest */
       while (ofs < maxofs) 
-	{
-	  if (comp (a[ofs], key))
-	    {
-	      lastofs = ofs;
-	      ofs = (ofs << 1) + 1;
-	      if (ofs <= 0)	/* int overflow */
-		ofs = maxofs;
-	    }
-	  else	/* key <= a[hint + ofs] */
-	    break;
-	}
+        {
+          if (comp (a[ofs], key))
+            {
+              lastofs = ofs;
+              ofs = (ofs << 1) + 1;
+              if (ofs <= 0)     /* int overflow */
+                ofs = maxofs;
+            }
+          else  /* key <= a[hint + ofs] */
+            break;
+        }
       if (ofs > maxofs)
-	ofs = maxofs;
+        ofs = maxofs;
       /* Translate back to offsets relative to &a[0]. */
       lastofs += hint;
       ofs += hint;
     }
   else 
     {
       /* key <= a[hint] -- gallop left, until
        * a[hint - ofs] < key <= a[hint - lastofs]
        */
-      const octave_idx_type maxofs = hint + 1;	/* &a[0] is lowest */
+      const octave_idx_type maxofs = hint + 1;  /* &a[0] is lowest */
       while (ofs < maxofs) 
-	{
-	  if (comp (*(a-ofs), key))
-	    break;
-	  /* key <= a[hint - ofs] */
-	  lastofs = ofs;
-	  ofs = (ofs << 1) + 1;
-	  if (ofs <= 0)	/* int overflow */
-	    ofs = maxofs;
-	}
+        {
+          if (comp (*(a-ofs), key))
+            break;
+          /* key <= a[hint - ofs] */
+          lastofs = ofs;
+          ofs = (ofs << 1) + 1;
+          if (ofs <= 0) /* int overflow */
+            ofs = maxofs;
+        }
       if (ofs > maxofs)
-	ofs = maxofs;
+        ofs = maxofs;
       /* Translate back to positive offsets relative to &a[0]. */
       k = lastofs;
       lastofs = hint - ofs;
       ofs = hint - k;
     }
   a -= hint;
 
   /* Now a[lastofs] < key <= a[ofs], so key belongs somewhere to the
@@ -380,19 +380,19 @@ octave_sort<T>::gallop_left (T key, T *a
    * search, with invariant a[lastofs-1] < key <= a[ofs].
    */
   ++lastofs;
   while (lastofs < ofs) 
     {
       octave_idx_type m = lastofs + ((ofs - lastofs) >> 1);
 
       if (comp (a[m], key))
-	lastofs = m+1;	/* a[m] < key */
+        lastofs = m+1;  /* a[m] < key */
       else
-	ofs = m;	/* key <= a[m] */
+        ofs = m;        /* key <= a[m] */
     }
 
   return ofs;
 }
 
 /*
 Exactly like gallop_left(), except that if key already exists in a[0:n],
 finds the position immediately to the right of the rightmost equal value.
@@ -420,73 +420,73 @@ octave_sort<T>::gallop_right (T key, T *
   a += hint;
   lastofs = 0;
   ofs = 1;
   if (comp (key, *a))
     {
       /* key < a[hint] -- gallop left, until
        * a[hint - ofs] <= key < a[hint - lastofs]
        */
-      const octave_idx_type maxofs = hint + 1;	/* &a[0] is lowest */
+      const octave_idx_type maxofs = hint + 1;  /* &a[0] is lowest */
       while (ofs < maxofs) 
-	{
-	  if (comp (key, *(a-ofs)))
-	    {
-	      lastofs = ofs;
-	      ofs = (ofs << 1) + 1;
-	      if (ofs <= 0)	/* int overflow */
-		ofs = maxofs;
-	    }
-	  else	/* a[hint - ofs] <= key */
-	    break;
-	}
+        {
+          if (comp (key, *(a-ofs)))
+            {
+              lastofs = ofs;
+              ofs = (ofs << 1) + 1;
+              if (ofs <= 0)     /* int overflow */
+                ofs = maxofs;
+            }
+          else  /* a[hint - ofs] <= key */
+            break;
+        }
       if (ofs > maxofs)
-	ofs = maxofs;
+        ofs = maxofs;
       /* Translate back to positive offsets relative to &a[0]. */
       k = lastofs;
       lastofs = hint - ofs;
       ofs = hint - k;
     }
   else 
     {
       /* a[hint] <= key -- gallop right, until
        * a[hint + lastofs] <= key < a[hint + ofs]
        */
-      const octave_idx_type maxofs = n - hint;	/* &a[n-1] is highest */
+      const octave_idx_type maxofs = n - hint;  /* &a[n-1] is highest */
       while (ofs < maxofs) 
-	{
-	  if (comp (key, a[ofs]))
-	    break;
-	  /* a[hint + ofs] <= key */
-	  lastofs = ofs;
-	  ofs = (ofs << 1) + 1;
-	  if (ofs <= 0)	/* int overflow */
-	    ofs = maxofs;
-	}
+        {
+          if (comp (key, a[ofs]))
+            break;
+          /* a[hint + ofs] <= key */
+          lastofs = ofs;
+          ofs = (ofs << 1) + 1;
+          if (ofs <= 0) /* int overflow */
+            ofs = maxofs;
+        }
       if (ofs > maxofs)
-	ofs = maxofs;
+        ofs = maxofs;
       /* Translate back to offsets relative to &a[0]. */
       lastofs += hint;
       ofs += hint;
     }
   a -= hint;
 
   /* Now a[lastofs] <= key < a[ofs], so key belongs somewhere to the
    * right of lastofs but no farther right than ofs.  Do a binary
    * search, with invariant a[lastofs-1] <= key < a[ofs].
    */
   ++lastofs;
   while (lastofs < ofs) 
     {
       octave_idx_type m = lastofs + ((ofs - lastofs) >> 1);
 
       if (comp (key, a[m]))
-	ofs = m;	/* key < a[m] */
+        ofs = m;        /* key < a[m] */
       else
-	lastofs = m+1;	/* a[m] <= key */
+        lastofs = m+1;  /* a[m] <= key */
     }
 
   return ofs;
 }
 
 static inline octave_idx_type
 roundupsize (octave_idx_type n)
 {
@@ -574,17 +574,17 @@ template <class T>
 template <class Comp>
 int
 octave_sort<T>::merge_lo (T *pa, octave_idx_type na, 
                           T *pb, octave_idx_type nb,
                           Comp comp)
 {
   octave_idx_type k;
   T *dest;
-  int result = -1;	/* guilty until proved innocent */
+  int result = -1;      /* guilty until proved innocent */
   octave_idx_type min_gallop = ms->min_gallop;
 
   ms->getmem (na);
 
   std::copy (pa, pa + na, ms->a);
   dest = pa;
   pa = ms->a;
 
@@ -592,105 +592,105 @@ octave_sort<T>::merge_lo (T *pa, octave_
   --nb;
   if (nb == 0)
     goto Succeed;
   if (na == 1)
     goto CopyB;
 
   for (;;)
     {
-      octave_idx_type acount = 0;	/* # of times A won in a row */
-      octave_idx_type bcount = 0;	/* # of times B won in a row */
+      octave_idx_type acount = 0;       /* # of times A won in a row */
+      octave_idx_type bcount = 0;       /* # of times B won in a row */
 
       /* Do the straightforward thing until (if ever) one run
        * appears to win consistently.
        */
       for (;;)
-	{
+        {
 
           // FIXME: these loops are candidates for further optimizations.
           // Rather than testing everything in each cycle, it may be more
           // efficient to do it in hunks. 
-	  if (comp (*pb, *pa))
-	    {
-	      *dest++ = *pb++;
-	      ++bcount;
-	      acount = 0;
-	      --nb;
-	      if (nb == 0)
-		goto Succeed;
-	      if (bcount >= min_gallop)
-		break;
-	    }
-	  else
-	    {
-	      *dest++ = *pa++;
-	      ++acount;
-	      bcount = 0;
-	      --na;
-	      if (na == 1)
-		goto CopyB;
-	      if (acount >= min_gallop)
-		break;
-	    }
-	}
+          if (comp (*pb, *pa))
+            {
+              *dest++ = *pb++;
+              ++bcount;
+              acount = 0;
+              --nb;
+              if (nb == 0)
+                goto Succeed;
+              if (bcount >= min_gallop)
+                break;
+            }
+          else
+            {
+              *dest++ = *pa++;
+              ++acount;
+              bcount = 0;
+              --na;
+              if (na == 1)
+                goto CopyB;
+              if (acount >= min_gallop)
+                break;
+            }
+        }
 
       /* One run is winning so consistently that galloping may
        * be a huge win.  So try that, and continue galloping until
        * (if ever) neither run appears to be winning consistently
        * anymore.
        */
       ++min_gallop;
       do
-	{
-	  min_gallop -= min_gallop > 1;
-	  ms->min_gallop = min_gallop;
-	  k = gallop_right (*pb, pa, na, 0, comp);
-	  acount = k;
-	  if (k)
-	    {
-	      if (k < 0)
-		goto Fail;
+        {
+          min_gallop -= min_gallop > 1;
+          ms->min_gallop = min_gallop;
+          k = gallop_right (*pb, pa, na, 0, comp);
+          acount = k;
+          if (k)
+            {
+              if (k < 0)
+                goto Fail;
               dest = std::copy (pa, pa + k, dest);
-	      pa += k;
-	      na -= k;
-	      if (na == 1)
-		goto CopyB;
-	      /* na==0 is impossible now if the comparison
-	       * function is consistent, but we can't assume
-	       * that it is.
-	       */
-	      if (na == 0)
-		goto Succeed;
-	    }
-	  *dest++ = *pb++;
-	  --nb;
-	  if (nb == 0)
-	    goto Succeed;
+              pa += k;
+              na -= k;
+              if (na == 1)
+                goto CopyB;
+              /* na==0 is impossible now if the comparison
+               * function is consistent, but we can't assume
+               * that it is.
+               */
+              if (na == 0)
+                goto Succeed;
+            }
+          *dest++ = *pb++;
+          --nb;
+          if (nb == 0)
+            goto Succeed;
 
-	  k = gallop_left (*pa, pb, nb, 0, comp);
-	  bcount = k;
-	  if (k)
-	    {
-	      if (k < 0)
-		goto Fail;
+          k = gallop_left (*pa, pb, nb, 0, comp);
+          bcount = k;
+          if (k)
+            {
+              if (k < 0)
+                goto Fail;
               dest = std::copy (pb, pb + k, dest);
-	      pb += k;
-	      nb -= k;
-	      if (nb == 0)
-		goto Succeed;
-	    }
-	  *dest++ = *pa++;
-	  --na;
-	  if (na == 1)
-	    goto CopyB;
-	}
+              pb += k;
+              nb -= k;
+              if (nb == 0)
+                goto Succeed;
+            }
+          *dest++ = *pa++;
+          --na;
+          if (na == 1)
+            goto CopyB;
+        }
       while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
 
-      ++min_gallop;	/* penalize it for leaving galloping mode */
+      ++min_gallop;     /* penalize it for leaving galloping mode */
       ms->min_gallop = min_gallop;
     }
 
  Succeed:
   result = 0;
 
  Fail:
   if (na)
@@ -710,17 +710,17 @@ template <class Comp>
 int
 octave_sort<T>::merge_lo (T *pa, octave_idx_type *ipa, octave_idx_type na, 
                           T *pb, octave_idx_type *ipb, octave_idx_type nb,
                           Comp comp)
 {
   octave_idx_type k;
   T *dest;
   octave_idx_type *idest;
-  int result = -1;	/* guilty until proved innocent */
+  int result = -1;      /* guilty until proved innocent */
   octave_idx_type min_gallop = ms->min_gallop;
 
   ms->getmemi (na);
 
   std::copy (pa, pa + na, ms->a);
   std::copy (ipa, ipa + na, ms->ia);
   dest = pa; idest = ipa;
   pa = ms->a; ipa = ms->ia;
@@ -729,104 +729,104 @@ octave_sort<T>::merge_lo (T *pa, octave_
   --nb;
   if (nb == 0)
     goto Succeed;
   if (na == 1)
     goto CopyB;
 
   for (;;)
     {
-      octave_idx_type acount = 0;	/* # of times A won in a row */
-      octave_idx_type bcount = 0;	/* # of times B won in a row */
+      octave_idx_type acount = 0;       /* # of times A won in a row */
+      octave_idx_type bcount = 0;       /* # of times B won in a row */
 
       /* Do the straightforward thing until (if ever) one run
        * appears to win consistently.
        */
       for (;;)
-	{
+        {
 
-	  if (comp (*pb, *pa))
-	    {
-	      *dest++ = *pb++; *idest++ = *ipb++;
-	      ++bcount;
-	      acount = 0;
-	      --nb;
-	      if (nb == 0)
-		goto Succeed;
-	      if (bcount >= min_gallop)
-		break;
-	    }
-	  else
-	    {
-	      *dest++ = *pa++; *idest++ = *ipa++;
-	      ++acount;
-	      bcount = 0;
-	      --na;
-	      if (na == 1)
-		goto CopyB;
-	      if (acount >= min_gallop)
-		break;
-	    }
-	}
+          if (comp (*pb, *pa))
+            {
+              *dest++ = *pb++; *idest++ = *ipb++;
+              ++bcount;
+              acount = 0;
+              --nb;
+              if (nb == 0)
+                goto Succeed;
+              if (bcount >= min_gallop)
+                break;
+            }
+          else
+            {
+              *dest++ = *pa++; *idest++ = *ipa++;
+              ++acount;
+              bcount = 0;
+              --na;
+              if (na == 1)
+                goto CopyB;
+              if (acount >= min_gallop)
+                break;
+            }
+        }
 
       /* One run is winning so consistently that galloping may
        * be a huge win.  So try that, and continue galloping until
        * (if ever) neither run appears to be winning consistently
        * anymore.
        */
       ++min_gallop;
       do
-	{
-	  min_gallop -= min_gallop > 1;
-	  ms->min_gallop = min_gallop;
-	  k = gallop_right (*pb, pa, na, 0, comp);
-	  acount = k;
-	  if (k)
-	    {
-	      if (k < 0)
-		goto Fail;
+        {
+          min_gallop -= min_gallop > 1;
+          ms->min_gallop = min_gallop;
+          k = gallop_right (*pb, pa, na, 0, comp);
+          acount = k;
+          if (k)
+            {
+              if (k < 0)
+                goto Fail;
               dest = std::copy (pa, pa + k, dest);
               idest = std::copy (ipa, ipa + k, idest);
-	      pa += k; ipa += k;
-	      na -= k;
-	      if (na == 1)
-		goto CopyB;
-	      /* na==0 is impossible now if the comparison
-	       * function is consistent, but we can't assume
-	       * that it is.
-	       */
-	      if (na == 0)
-		goto Succeed;
-	    }
-	  *dest++ = *pb++; *idest++ = *ipb++;
-	  --nb;
-	  if (nb == 0)
-	    goto Succeed;
+              pa += k; ipa += k;
+              na -= k;
+              if (na == 1)
+                goto CopyB;
+              /* na==0 is impossible now if the comparison
+               * function is consistent, but we can't assume
+               * that it is.
+               */
+              if (na == 0)
+                goto Succeed;
+            }
+          *dest++ = *pb++; *idest++ = *ipb++;
+          --nb;
+          if (nb == 0)
+            goto Succeed;
 
-	  k = gallop_left (*pa, pb, nb, 0, comp);
-	  bcount = k;
-	  if (k)
-	    {
-	      if (k < 0)
-		goto Fail;
+          k = gallop_left (*pa, pb, nb, 0, comp);
+          bcount = k;
+          if (k)
+            {
+              if (k < 0)
+                goto Fail;
               dest = std::copy (pb, pb + k, dest);
               idest = std::copy (ipb, ipb + k, idest);
-	      pb += k; ipb += k;
-	      nb -= k;
-	      if (nb == 0)
-		goto Succeed;
-	    }
-	  *dest++ = *pa++; *idest++ = *ipa++;
-	  --na;
-	  if (na == 1)
-	    goto CopyB;
-	}
+              pb += k; ipb += k;
+              nb -= k;
+              if (nb == 0)
+                goto Succeed;
+            }
+          *dest++ = *pa++; *idest++ = *ipa++;
+          --na;
+          if (na == 1)
+            goto CopyB;
+        }
       while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
 
-      ++min_gallop;	/* penalize it for leaving galloping mode */
+      ++min_gallop;     /* penalize it for leaving galloping mode */
       ms->min_gallop = min_gallop;
     }
 
  Succeed:
   result = 0;
 
  Fail:
   if (na)
@@ -856,17 +856,17 @@ template <class T>
 template <class Comp>
 int
 octave_sort<T>::merge_hi (T *pa, octave_idx_type na, 
                           T *pb, octave_idx_type nb,
                           Comp comp)
 {
   octave_idx_type k;
   T *dest;
-  int result = -1;	/* guilty until proved innocent */
+  int result = -1;      /* guilty until proved innocent */
   T *basea, *baseb;
   octave_idx_type min_gallop = ms->min_gallop;
 
   ms->getmem (nb);
 
   dest = pb + nb - 1;
   std::copy (pb, pb + nb, ms->a);
   basea = pa;
@@ -878,102 +878,102 @@ octave_sort<T>::merge_hi (T *pa, octave_
   --na;
   if (na == 0)
     goto Succeed;
   if (nb == 1)
     goto CopyA;
 
   for (;;) 
     {
-      octave_idx_type acount = 0;	/* # of times A won in a row */
-      octave_idx_type bcount = 0;	/* # of times B won in a row */
+      octave_idx_type acount = 0;       /* # of times A won in a row */
+      octave_idx_type bcount = 0;       /* # of times B won in a row */
 
       /* Do the straightforward thing until (if ever) one run
        * appears to win consistently.
        */
       for (;;) 
-	{
-	  if (comp (*pb, *pa))
-	    {
-	      *dest-- = *pa--;
-	      ++acount;
-	      bcount = 0;
-	      --na;
-	      if (na == 0)
-		goto Succeed;
-	      if (acount >= min_gallop)
-		break;
-	    }
-	  else 
-	    {
-	      *dest-- = *pb--;
-	      ++bcount;
-	      acount = 0;
-	      --nb;
-	      if (nb == 1)
-		goto CopyA;
-	      if (bcount >= min_gallop)
-		break;
-	    }
-	}
+        {
+          if (comp (*pb, *pa))
+            {
+              *dest-- = *pa--;
+              ++acount;
+              bcount = 0;
+              --na;
+              if (na == 0)
+                goto Succeed;
+              if (acount >= min_gallop)
+                break;
+            }
+          else 
+            {
+              *dest-- = *pb--;
+              ++bcount;
+              acount = 0;
+              --nb;
+              if (nb == 1)
+                goto CopyA;
+              if (bcount >= min_gallop)
+                break;
+            }
+        }
 
       /* One run is winning so consistently that galloping may
        * be a huge win.  So try that, and continue galloping until
        * (if ever) neither run appears to be winning consistently
        * anymore.
        */
       ++min_gallop;
       do 
-	{
-	  min_gallop -= min_gallop > 1;
-	  ms->min_gallop = min_gallop;
-	  k = gallop_right (*pb, basea, na, na-1, comp);
-	  if (k < 0)
-	    goto Fail;
-	  k = na - k;
-	  acount = k;
-	  if (k) 
-	    {
+        {
+          min_gallop -= min_gallop > 1;
+          ms->min_gallop = min_gallop;
+          k = gallop_right (*pb, basea, na, na-1, comp);
+          if (k < 0)
+            goto Fail;
+          k = na - k;
+          acount = k;
+          if (k) 
+            {
               dest = std::copy_backward (pa+1 - k, pa+1, dest+1) - 1;
-	      pa -= k;
-	      na -= k;
-	      if (na == 0)
-		goto Succeed;
-	    }
-	  *dest-- = *pb--;
-	  --nb;
-	  if (nb == 1)
-	    goto CopyA;
+              pa -= k;
+              na -= k;
+              if (na == 0)
+                goto Succeed;
+            }
+          *dest-- = *pb--;
+          --nb;
+          if (nb == 1)
+            goto CopyA;
 
-	  k = gallop_left (*pa, baseb, nb, nb-1, comp);
-	  if (k < 0)
-	    goto Fail;
-	  k = nb - k;
-	  bcount = k;
-	  if (k) 
-	    {
-	      dest -= k;
-	      pb -= k;
+          k = gallop_left (*pa, baseb, nb, nb-1, comp);
+          if (k < 0)
+            goto Fail;
+          k = nb - k;
+          bcount = k;
+          if (k) 
+            {
+              dest -= k;
+              pb -= k;
               std::copy (pb+1, pb+1 + k, dest+1);
-	      nb -= k;
-	      if (nb == 1)
-		goto CopyA;
-	      /* nb==0 is impossible now if the comparison
-	       * function is consistent, but we can't assume
-	       * that it is.
-	       */
-	      if (nb == 0)
-		goto Succeed;
-	    }
-	  *dest-- = *pa--;
-	  --na;
-	  if (na == 0)
-	    goto Succeed;
-	} while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
-      ++min_gallop;	/* penalize it for leaving galloping mode */
+              nb -= k;
+              if (nb == 1)
+                goto CopyA;
+              /* nb==0 is impossible now if the comparison
+               * function is consistent, but we can't assume
+               * that it is.
+               */
+              if (nb == 0)
+                goto Succeed;
+            }
+          *dest-- = *pa--;
+          --na;
+          if (na == 0)
+            goto Succeed;
+        } while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
+      ++min_gallop;     /* penalize it for leaving galloping mode */
       ms->min_gallop = min_gallop;
     }
 
 Succeed:
   result = 0;
 
 Fail:
   if (nb)
@@ -994,17 +994,17 @@ template <class Comp>
 int
 octave_sort<T>::merge_hi (T *pa, octave_idx_type *ipa, octave_idx_type na, 
                           T *pb, octave_idx_type *ipb, octave_idx_type nb,
                           Comp comp)
 {
   octave_idx_type k;
   T *dest;
   octave_idx_type *idest;
-  int result = -1;	/* guilty until proved innocent */
+  int result = -1;      /* guilty until proved innocent */
   T *basea, *baseb;
   octave_idx_type *ibasea, *ibaseb;
   octave_idx_type min_gallop = ms->min_gallop;
 
   ms->getmemi (nb);
 
   dest = pb + nb - 1;
   idest = ipb + nb - 1;
@@ -1019,104 +1019,104 @@ octave_sort<T>::merge_hi (T *pa, octave_
   --na;
   if (na == 0)
     goto Succeed;
   if (nb == 1)
     goto CopyA;
 
   for (;;) 
     {
-      octave_idx_type acount = 0;	/* # of times A won in a row */
-      octave_idx_type bcount = 0;	/* # of times B won in a row */
+      octave_idx_type acount = 0;       /* # of times A won in a row */
+      octave_idx_type bcount = 0;       /* # of times B won in a row */
 
       /* Do the straightforward thing until (if ever) one run
        * appears to win consistently.
        */
       for (;;) 
-	{
-	  if (comp (*pb, *pa))
-	    {
-	      *dest-- = *pa--; *idest-- = *ipa--;
-	      ++acount;
-	      bcount = 0;
-	      --na;
-	      if (na == 0)
-		goto Succeed;
-	      if (acount >= min_gallop)
-		break;
-	    }
-	  else 
-	    {
-	      *dest-- = *pb--; *idest-- = *ipb--;
-	      ++bcount;
-	      acount = 0;
-	      --nb;
-	      if (nb == 1)
-		goto CopyA;
-	      if (bcount >= min_gallop)
-		break;
-	    }
-	}
+        {
+          if (comp (*pb, *pa))
+            {
+              *dest-- = *pa--; *idest-- = *ipa--;
+              ++acount;
+              bcount = 0;
+              --na;
+              if (na == 0)
+                goto Succeed;
+              if (acount >= min_gallop)
+                break;
+            }
+          else 
+            {
+              *dest-- = *pb--; *idest-- = *ipb--;
+              ++bcount;
+              acount = 0;
+              --nb;
+              if (nb == 1)
+                goto CopyA;
+              if (bcount >= min_gallop)
+                break;
+            }
+        }
 
       /* One run is winning so consistently that galloping may
        * be a huge win.  So try that, and continue galloping until
        * (if ever) neither run appears to be winning consistently
        * anymore.
        */
       ++min_gallop;
       do 
-	{
-	  min_gallop -= min_gallop > 1;
-	  ms->min_gallop = min_gallop;
-	  k = gallop_right (*pb, basea, na, na-1, comp);
-	  if (k < 0)
-	    goto Fail;
-	  k = na - k;
-	  acount = k;
-	  if (k) 
-	    {
+        {
+          min_gallop -= min_gallop > 1;
+          ms->min_gallop = min_gallop;
+          k = gallop_right (*pb, basea, na, na-1, comp);
+          if (k < 0)
+            goto Fail;
+          k = na - k;
+          acount = k;
+          if (k) 
+            {
               dest = std::copy_backward (pa+1 - k, pa+1, dest+1) - 1;
               idest = std::copy_backward (ipa+1 - k, ipa+1, idest+1) - 1;
-	      pa -= k; ipa -= k;
-	      na -= k;
-	      if (na == 0)
-		goto Succeed;
-	    }
-	  *dest-- = *pb--; *idest-- = *ipb--;
-	  --nb;
-	  if (nb == 1)
-	    goto CopyA;
+              pa -= k; ipa -= k;
+              na -= k;
+              if (na == 0)
+                goto Succeed;
+            }
+          *dest-- = *pb--; *idest-- = *ipb--;
+          --nb;
+          if (nb == 1)
+            goto CopyA;
 
-	  k = gallop_left (*pa, baseb, nb, nb-1, comp);
-	  if (k < 0)
-	    goto Fail;
-	  k = nb - k;
-	  bcount = k;
-	  if (k) 
-	    {
-	      dest -= k; idest -= k;
-	      pb -= k; ipb -= k;
+          k = gallop_left (*pa, baseb, nb, nb-1, comp);
+          if (k < 0)
+            goto Fail;
+          k = nb - k;
+          bcount = k;
+          if (k) 
+            {
+              dest -= k; idest -= k;
+              pb -= k; ipb -= k;
               std::copy (pb+1, pb+1 + k, dest+1);
               std::copy (ipb+1, ipb+1 + k, idest+1);
-	      nb -= k;
-	      if (nb == 1)
-		goto CopyA;
-	      /* nb==0 is impossible now if the comparison
-	       * function is consistent, but we can't assume
-	       * that it is.
-	       */
-	      if (nb == 0)
-		goto Succeed;
-	    }
-	  *dest-- = *pa--; *idest-- = *ipa--;
-	  --na;
-	  if (na == 0)
-	    goto Succeed;
-	} while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
-      ++min_gallop;	/* penalize it for leaving galloping mode */
+              nb -= k;
+              if (nb == 1)
+                goto CopyA;
+              /* nb==0 is impossible now if the comparison
+               * function is consistent, but we can't assume
+               * that it is.
+               */
+              if (nb == 0)
+                goto Succeed;
+            }
+          *dest-- = *pa--; *idest-- = *ipa--;
+          --na;
+          if (na == 0)
+            goto Succeed;
+        } while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
+      ++min_gallop;     /* penalize it for leaving galloping mode */
       ms->min_gallop = min_gallop;
     }
 
 Succeed:
   result = 0;
 
 Fail:
   if (nb)
@@ -1260,58 +1260,58 @@ int
 octave_sort<T>::merge_collapse (T *data, Comp comp)
 {
   struct s_slice *p = ms->pending;
 
   while (ms->n > 1) 
     {
       octave_idx_type n = ms->n - 2;
       if (n > 0 && p[n-1].len <= p[n].len + p[n+1].len) 
-	{
-	  if (p[n-1].len < p[n+1].len)
-	    --n;
-	  if (merge_at (n, data, comp) < 0)
-	    return -1;
-	}
+        {
+          if (p[n-1].len < p[n+1].len)
+            --n;
+          if (merge_at (n, data, comp) < 0)
+            return -1;
+        }
       else if (p[n].len <= p[n+1].len) 
-	{
-	  if (merge_at (n, data, comp) < 0)
-	    return -1;
-	}
+        {
+          if (merge_at (n, data, comp) < 0)
+            return -1;
+        }
       else
-	break;
+        break;
     }
 
   return 0;
 }
 
 template <class T>
 template <class Comp>
 int
 octave_sort<T>::merge_collapse (T *data, octave_idx_type *idx, Comp comp)
 {
   struct s_slice *p = ms->pending;
 
   while (ms->n > 1) 
     {
       octave_idx_type n = ms->n - 2;
       if (n > 0 && p[n-1].len <= p[n].len + p[n+1].len) 
-	{
-	  if (p[n-1].len < p[n+1].len)
-	    --n;
-	  if (merge_at (n, data, idx, comp) < 0)
-	    return -1;
-	}
+        {
+          if (p[n-1].len < p[n+1].len)
+            --n;
+          if (merge_at (n, data, idx, comp) < 0)
+            return -1;
+        }
       else if (p[n].len <= p[n+1].len) 
-	{
-	  if (merge_at (n, data, idx, comp) < 0)
-	    return -1;
-	}
+        {
+          if (merge_at (n, data, idx, comp) < 0)
+            return -1;
+        }
       else
-	break;
+        break;
     }
 
   return 0;
 }
 
 /* Regardless of invariants, merge all runs on the stack until only one
  * remains.  This is used at the end of the mergesort.
  *
@@ -1323,38 +1323,38 @@ int
 octave_sort<T>::merge_force_collapse (T *data, Comp comp)
 {
   struct s_slice *p = ms->pending;
 
   while (ms->n > 1) 
     {
       octave_idx_type n = ms->n - 2;
       if (n > 0 && p[n-1].len < p[n+1].len)
-	--n;
+        --n;
       if (merge_at (n, data, comp) < 0)
-	return -1;
+        return -1;
     }
 
   return 0;
 }
 
 template <class T>
 template <class Comp>
 int
 octave_sort<T>::merge_force_collapse (T *data, octave_idx_type *idx, Comp comp)
 {
   struct s_slice *p = ms->pending;
 
   while (ms->n > 1) 
     {
       octave_idx_type n = ms->n - 2;
       if (n > 0 && p[n-1].len < p[n+1].len)
-	--n;
+        --n;
       if (merge_at (n, data, idx, comp) < 0)
-	return -1;
+        return -1;
     }
 
   return 0;
 }
 
 /* Compute a good value for the minimum run length; natural runs shorter
  * than this are boosted artificially via binary insertion.
  *
@@ -1364,17 +1364,17 @@ octave_sort<T>::merge_force_collapse (T 
  * strictly less than, an exact power of 2.
  *
  * See listsort.txt for more info.
  */
 template <class T>
 octave_idx_type
 octave_sort<T>::merge_compute_minrun (octave_idx_type n)
 {
-  octave_idx_type r = 0;	/* becomes 1 if any 1 bits are shifted off */
+  octave_idx_type r = 0;        /* becomes 1 if any 1 bits are shifted off */
 
   while (n >= 64)
     {
       r |= n & 1;
       n >>= 1;
     }
 
   return n + r;
@@ -1396,44 +1396,44 @@ octave_sort<T>::sort (T *data, octave_id
       octave_idx_type nremaining = nel; 
       octave_idx_type lo = 0;
 
       /* March over the array once, left to right, finding natural runs,
        * and extending short natural runs to minrun elements.
        */
       octave_idx_type minrun = merge_compute_minrun (nremaining);
       do 
-	{
-	  bool descending;
-	  octave_idx_type n;
+        {
+          bool descending;
+          octave_idx_type n;
 
-	  /* Identify next run. */
-	  n = count_run (data + lo, nremaining, descending, comp);
-	  if (n < 0)
-	    goto fail;
-	  if (descending)
+          /* Identify next run. */
+          n = count_run (data + lo, nremaining, descending, comp);
+          if (n < 0)
+            goto fail;
+          if (descending)
             std::reverse (data + lo, data + lo + n);
-	  /* If short, extend to min(minrun, nremaining). */
-	  if (n < minrun) 
-	    {
-	      const octave_idx_type force = nremaining <= minrun ? nremaining : minrun;
-	      binarysort (data + lo, force, n, comp);
-	      n = force;
-	    }
-	  /* Push run onto pending-runs stack, and maybe merge. */
-	  assert (ms->n < MAX_MERGE_PENDING);
-	  ms->pending[ms->n].base = lo;
-	  ms->pending[ms->n].len = n;
-	  ms->n++;
-	  if (merge_collapse (data, comp) < 0)
-	    goto fail;
-	  /* Advance to find next run. */
-	  lo += n;
-	  nremaining -= n;
-	}
+          /* If short, extend to min(minrun, nremaining). */
+          if (n < minrun) 
+            {
+              const octave_idx_type force = nremaining <= minrun ? nremaining : minrun;
+              binarysort (data + lo, force, n, comp);
+              n = force;
+            }
+          /* Push run onto pending-runs stack, and maybe merge. */
+          assert (ms->n < MAX_MERGE_PENDING);
+          ms->pending[ms->n].base = lo;
+          ms->pending[ms->n].len = n;
+          ms->n++;
+          if (merge_collapse (data, comp) < 0)
+            goto fail;
+          /* Advance to find next run. */
+          lo += n;
+          nremaining -= n;
+        }
       while (nremaining);
 
       merge_force_collapse (data, comp);
     }
 
 fail:
   return;
 }
@@ -1455,47 +1455,47 @@ octave_sort<T>::sort (T *data, octave_id
       octave_idx_type nremaining = nel; 
       octave_idx_type lo = 0;
 
       /* March over the array once, left to right, finding natural runs,
        * and extending short natural runs to minrun elements.
        */
       octave_idx_type minrun = merge_compute_minrun (nremaining);
       do 
-	{
-	  bool descending;
-	  octave_idx_type n;
+        {
+          bool descending;
+          octave_idx_type n;
 
-	  /* Identify next run. */
-	  n = count_run (data + lo, nremaining, descending, comp);
-	  if (n < 0)
-	    goto fail;
-	  if (descending)
+          /* Identify next run. */
+          n = count_run (data + lo, nremaining, descending, comp);
+          if (n < 0)
+            goto fail;
+          if (descending)
             {
               std::reverse (data + lo, data + lo + n);
               std::reverse (idx + lo, idx + lo + n);
             }
-	  /* If short, extend to min(minrun, nremaining). */
-	  if (n < minrun) 
-	    {
-	      const octave_idx_type force = nremaining <= minrun ? nremaining : minrun;
-	      binarysort (data + lo, idx + lo, force, n, comp);
-	      n = force;
-	    }
-	  /* Push run onto pending-runs stack, and maybe merge. */
-	  assert (ms->n < MAX_MERGE_PENDING);
-	  ms->pending[ms->n].base = lo;
-	  ms->pending[ms->n].len = n;
-	  ms->n++;
-	  if (merge_collapse (data, idx, comp) < 0)
-	    goto fail;
-	  /* Advance to find next run. */
-	  lo += n;
-	  nremaining -= n;
-	}
+          /* If short, extend to min(minrun, nremaining). */
+          if (n < minrun) 
+            {
+              const octave_idx_type force = nremaining <= minrun ? nremaining : minrun;
+              binarysort (data + lo, idx + lo, force, n, comp);
+              n = force;
+            }
+          /* Push run onto pending-runs stack, and maybe merge. */
+          assert (ms->n < MAX_MERGE_PENDING);
+          ms->pending[ms->n].base = lo;
+          ms->pending[ms->n].len = n;
+          ms->n++;
+          if (merge_collapse (data, idx, comp) < 0)
+            goto fail;
+          /* Advance to find next run. */
+          lo += n;
+          nremaining -= n;
+        }
       while (nremaining);
 
       merge_force_collapse (data, idx, comp);
     }
 
 fail:
   return;
 }
@@ -1936,20 +1936,20 @@ octave_sort<T>::nth_element (T *data, oc
 #endif
     if (compare)
       nth_element (data, nel, lo, up, std::ptr_fun (compare));
 }
 
 template <class T>
 bool 
 octave_sort<T>::ascending_compare (typename ref_param<T>::type x,
-				   typename ref_param<T>::type y)
+                                   typename ref_param<T>::type y)
 {
   return x < y;
 }
 
 template <class T>
 bool 
 octave_sort<T>::descending_compare (typename ref_param<T>::type x,
-				    typename ref_param<T>::type y)
+                                    typename ref_param<T>::type y)
 {
   return x > y;
 }
diff --git a/liboctave/oct-spparms.cc b/liboctave/oct-spparms.cc
--- a/liboctave/oct-spparms.cc
+++ b/liboctave/oct-spparms.cc
@@ -38,17 +38,17 @@ octave_sparse_params::instance_ok (void)
   bool retval = true;
 
   if (! instance)
     instance = new octave_sparse_params ();
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
-	("unable to create octave_sparse_params object!");
+        ("unable to create octave_sparse_params object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 void
@@ -171,55 +171,55 @@ octave_sparse_params::do_get_bandden (vo
 bool
 octave_sparse_params::do_set_vals (const NDArray& vals)
 {
   octave_idx_type len = vals.length ();
 
   if (len > OCTAVE_SPARSE_CONTROLS_SIZE)
     {
       (*current_liboctave_error_handler)
-	("octave_sparse_params::do_set_vals: too many values");
+        ("octave_sparse_params::do_set_vals: too many values");
 
       return false;
     }
   else
     {
       for (int i = 0; i < len; i++)
-	params(i) = vals(i);
+        params(i) = vals(i);
 
       return true;
     }
 }
 
 bool
 octave_sparse_params::do_set_key (const std::string& key, const double& val)
 {
   for (int i = 0; i < OCTAVE_SPARSE_CONTROLS_SIZE; i++)
     {
       if (keys (i) == key)
-	{
-	  params(i) = val;
-	  return true;
-	}
+        {
+          params(i) = val;
+          return true;
+        }
     }
 
   return false;
 }
 
 double
 octave_sparse_params::do_get_key (const std::string& key)
 {
   for (int i = 0; i < OCTAVE_SPARSE_CONTROLS_SIZE; i++)
     {
       if (keys (i) == key)
-	return params(i);
+        return params(i);
     }
 
   return octave_NaN;
 }
 
 void
 octave_sparse_params::do_print_info (std::ostream& os,
-				     const std::string& prefix) const
+                                     const std::string& prefix) const
 {
   for (int i = 0; i < OCTAVE_SPARSE_CONTROLS_SIZE; i++)
     os << prefix << keys(i) << ": " << params(i) << "\n";
 }
diff --git a/liboctave/oct-syscalls.cc b/liboctave/oct-syscalls.cc
--- a/liboctave/oct-syscalls.cc
+++ b/liboctave/oct-syscalls.cc
@@ -81,17 +81,17 @@ int
 octave_syscalls::execvp (const std::string& file, const string_vector& argv)
 {
   std::string msg;
   return execvp (file, argv, msg);
 }
 
 int
 octave_syscalls::execvp (const std::string& file, const string_vector& args,
-			 std::string& msg)
+                         std::string& msg)
 {
   msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_EXECVP)
   char **argv = args.c_str_vec ();
 
@@ -268,17 +268,17 @@ pid_t
 octave_syscalls::waitpid (pid_t pid, int *status, int options)
 {
   std::string msg;
   return waitpid (pid, status, options, msg);
 }
 
 pid_t
 octave_syscalls::waitpid (pid_t pid, int *status, int options,
-			  std::string& msg)
+                          std::string& msg)
 {
   pid_t retval = -1;
   msg = std::string ();
 
 #if defined (HAVE_WAITPID)
   retval = ::octave_waitpid (pid, status, options);
 
   if (retval < 0)
@@ -353,19 +353,19 @@ octave_syscalls::popen2 (const std::stri
     {
       if (pipe (child_stdout, msg) == 0)
         {
           pid = fork (msg);
           if (pid < 0)
             msg = "popen2: process creation failed -- " + msg;
           else if (pid == 0)
             {
-	      std::string child_msg;
+              std::string child_msg;
 
-	      interactive = false;
+              interactive = false;
 
               // Child process
               ::close (child_stdin[1]);
               ::close (child_stdout[0]);
 
               if (dup2 (child_stdin[0], STDIN_FILENO) >= 0)
                 {
                   ::close (child_stdin[0]);
@@ -375,20 +375,20 @@ octave_syscalls::popen2 (const std::stri
                       if (execvp (cmd, args, child_msg) < 0)
                         child_msg = "popen2 (child): unable to start process -- " + child_msg;
                     }
                   else
                     child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
                 }
               else
                 child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
-	      
-	      (*current_liboctave_error_handler)(child_msg.c_str());
-	      
-	      exit(0);
+              
+              (*current_liboctave_error_handler)(child_msg.c_str());
+              
+              exit(0);
             }
           else
             {
               // Parent process
               ::close (child_stdin[0]);
               ::close (child_stdout[1]);
 #if defined (F_SETFL) && defined (O_NONBLOCK)
               if (! sync_mode && octave_fcntl (child_stdout[0], F_SETFL, O_NONBLOCK, msg) < 0)
diff --git a/liboctave/oct-time.cc b/liboctave/oct-time.cc
--- a/liboctave/oct-time.cc
+++ b/liboctave/oct-time.cc
@@ -86,30 +86,30 @@ octave_time::stamp (void)
 
 // From the mktime() manual page:
 //
 //     The  mktime()  function converts a broken-down time structure,
 //     expressed as local time, to calendar time representation.
 //
 //     <snip>
 //
-//     If structure members are outside  their	legal interval, they
+//     If structure members are outside  their  legal interval, they
 //     will be normalized (so that, e.g., 40 October is changed into
 //     9 November).
 //
 // So, we no longer check limits here.
 
 #if 0
 #define DEFINE_SET_INT_FIELD_FCN(f, lo, hi) \
   octave_base_tm& \
   octave_base_tm::f (int v) \
   { \
     if (v < lo || v > hi) \
       (*current_liboctave_error_handler) \
-	("invalid value specified for " #f); \
+        ("invalid value specified for " #f); \
  \
     tm_ ## f = v; \
  \
     return *this; \
   }
 #else
 #define DEFINE_SET_INT_FIELD_FCN(f, lo, hi) \
   octave_base_tm& \
@@ -169,25 +169,25 @@ octave_base_tm::strftime (const std::str
 
       const char *fmt_str = fmt.c_str ();
 
       char *buf = 0;
       size_t bufsize = STRFTIME_BUF_INITIAL_SIZE;
       size_t chars_written = 0;
 
       while (chars_written == 0)
-	{
-	  delete [] buf;
-	  buf = new char[bufsize];
-	  buf[0] = '\0';
+        {
+          delete [] buf;
+          buf = new char[bufsize];
+          buf[0] = '\0';
 
-	  chars_written = nstrftime (buf, bufsize, fmt_str, &t, 0, 0);
+          chars_written = nstrftime (buf, bufsize, fmt_str, &t, 0, 0);
 
-	  bufsize *= 2;
-	}
+          bufsize *= 2;
+        }
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
       delete [] ps;
 #endif
 
       retval = buf;
 
       delete [] buf;
diff --git a/liboctave/pathsearch.cc b/liboctave/pathsearch.cc
--- a/liboctave/pathsearch.cc
+++ b/liboctave/pathsearch.cc
@@ -48,17 +48,17 @@ dir_path::static_members::instance_ok (v
   bool retval = true;
 
   if (! instance)
     instance = new static_members ();
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
-	("unable to create dir_path::static_members object!");
+        ("unable to create dir_path::static_members object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 string_vector
@@ -77,39 +77,39 @@ dir_path::all_directories (void)
     {
       int len = pv.length ();
 
       int nmax = len > 32 ? len : 32;
 
       retval.resize (len);
 
       for (int i = 0; i < len; i++)
-	{
-	  str_llist_type *elt_dirs = kpse_element_dirs (pv[i]);
+        {
+          str_llist_type *elt_dirs = kpse_element_dirs (pv[i]);
 
-	  if (elt_dirs)
-	    {
-	      str_llist_elt_type *dir;
+          if (elt_dirs)
+            {
+              str_llist_elt_type *dir;
 
-	      for (dir = *elt_dirs; dir; dir = STR_LLIST_NEXT (*dir))
-		{
-		  const std::string elt_dir = STR_LLIST (*dir);
+              for (dir = *elt_dirs; dir; dir = STR_LLIST_NEXT (*dir))
+                {
+                  const std::string elt_dir = STR_LLIST (*dir);
 
-		  if (! elt_dir.empty ())
-		    {
-		      if (count == nmax)
-			nmax *= 2;
+                  if (! elt_dir.empty ())
+                    {
+                      if (count == nmax)
+                        nmax *= 2;
 
-		      retval.resize (nmax);
+                      retval.resize (nmax);
 
-		      retval[count++] = elt_dir;
-		    }
-		}
-	    }
-	}
+                      retval[count++] = elt_dir;
+                    }
+                }
+            }
+        }
 
       retval.resize (count);
     }
 
   return retval;
 }
 
 std::string
@@ -143,23 +143,23 @@ dir_path::init (void)
 {
   static bool octave_kpathsea_initialized = false;
 
   if (! octave_kpathsea_initialized)
     {
       std::string val = octave_env::getenv ("KPATHSEA_DEBUG");
 
       if (! val.empty ())
-	kpathsea_debug |= atoi (val.c_str ());
+        kpathsea_debug |= atoi (val.c_str ());
 
       octave_kpathsea_initialized = true;
     }
 
   p = kpse_path_expand (p_default.empty ()
-			? p_orig : kpse_expand_default (p_orig, p_default));
+                        ? p_orig : kpse_expand_default (p_orig, p_default));
 
   int count = 0;
   for (kpse_path_iterator pi (p); pi != std::string::npos; pi++)
     count++;
 
   pv.resize (count);
 
   kpse_path_iterator pi (p);
diff --git a/liboctave/regex-match.cc b/liboctave/regex-match.cc
--- a/liboctave/regex-match.cc
+++ b/liboctave/regex-match.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 
 regex_match& 
 regex_match::operator = (const regex_match& gm)
 {
   if (this != &gm)
     {
 #if HAVE_REGEX
       for (int i = 0; i < pat.length (); i++)
-	regfree (compiled +i);
+        regfree (compiled +i);
       delete [] compiled;
 #endif
       pat = gm.pat;
       case_insen = gm.case_insen;
       init ();
     }
   return *this;
 }
@@ -91,32 +91,32 @@ regex_match::init (void)
   int err = 0;
   int i;
 
   compiled = new regex_t [npat];
 
   for (i = 0; i < npat; i++)
     {
       err = regcomp (compiled + i, pat(i).c_str (), 
-		     (REG_NOSUB | REG_EXTENDED |
-		      (case_insen ? REG_ICASE : 0)));
+                     (REG_NOSUB | REG_EXTENDED |
+                      (case_insen ? REG_ICASE : 0)));
       if (err)
-	break;
+        break;
     }
   
   if (err)
     {
       int len = regerror (err, compiled + i, 0, 0);
       OCTAVE_LOCAL_BUFFER (char, errmsg, len);
       regerror(err, compiled + i, errmsg, len);
       (*current_liboctave_error_handler) ("%s in pattern (%s)", errmsg, 
-					  pat(i).c_str());
+                                          pat(i).c_str());
 
       for (int j = 0; j < i + 1; j++)
-	regfree (compiled + j);
+        regfree (compiled + j);
     }
 #else
   (*current_liboctave_error_handler) 
     ("regex not available in this version of Octave"); 
 #endif
 }
 
 bool
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -55,28 +55,28 @@ sparse_base_chol<chol_type, chol_elt, p_
   ncol = S->ncol;
 
   for (k = 0; k < ncol; k++)
     {
       p = Sp [k];
       pend = Sp [k+1];
       Sp [k] = pdest;
       for (; p < pend; p++)
-	{
-	  sik = Sx [p];
-	  if (CHOLMOD_IS_NONZERO (sik))
-	    {
-	      if (p != pdest)
-		{
-		  Si [pdest] = Si [p];
-		  Sx [pdest] = sik;
-		}
-	      pdest++;
-	    }
-	}
+        {
+          sik = Sx [p];
+          if (CHOLMOD_IS_NONZERO (sik))
+            {
+              if (p != pdest)
+                {
+                  Si [pdest] = Si [p];
+                  Sx [pdest] = sik;
+                }
+              pdest++;
+            }
+        }
     }
   Sp [ncol] = pdest;
 }
 #endif
 
 template <class chol_type, class chol_elt, class p_type>
 octave_idx_type
 sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::init 
@@ -85,17 +85,17 @@ sparse_base_chol<chol_type, chol_elt, p_
   volatile octave_idx_type info = 0;
 #ifdef HAVE_CHOLMOD
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) 
-	("SparseCHOL requires square matrix");
+        ("SparseCHOL requires square matrix");
       return -1;
     }
 
   cholmod_common *cm = &Common;
 
   // Setup initial parameters
   CHOLMOD_NAME(start) (cm);
   cm->prefer_zomplex = false;
@@ -178,36 +178,36 @@ sparse_base_chol<chol_type, chol_elt, p_
 
       minor_p = Lfactor->minor;
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       Lsparse = CHOLMOD_NAME(factor_to_sparse) (Lfactor, cm);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       if (minor_p > 0 && minor_p < a_nr)
-	{
-	  size_t n1 = a_nr + 1;
-	  Lsparse->p = CHOLMOD_NAME(realloc) (minor_p+1,
-					      sizeof(octave_idx_type),
-					      Lsparse->p, &n1, cm);
-	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CHOLMOD_NAME(reallocate_sparse) 
-	    (static_cast<octave_idx_type *>(Lsparse->p)[minor_p], Lsparse, cm);
-	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  Lsparse->ncol = minor_p;
-	}
+        {
+          size_t n1 = a_nr + 1;
+          Lsparse->p = CHOLMOD_NAME(realloc) (minor_p+1,
+                                              sizeof(octave_idx_type),
+                                              Lsparse->p, &n1, cm);
+          BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          CHOLMOD_NAME(reallocate_sparse) 
+            (static_cast<octave_idx_type *>(Lsparse->p)[minor_p], Lsparse, cm);
+          END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+          Lsparse->ncol = minor_p;
+        }
 
       drop_zeros (Lsparse);
 
       if (! natural)
-	{
-	  perms.resize (a_nr);
-	  for (octave_idx_type i = 0; i < a_nr; i++)
-	    perms(i) = static_cast<octave_idx_type *>(Lfactor->Perm)[i];
-	}
+        {
+          perms.resize (a_nr);
+          for (octave_idx_type i = 0; i < a_nr; i++)
+            perms(i) = static_cast<octave_idx_type *>(Lfactor->Perm)[i];
+        }
 
       static char tmp[] = " ";
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CHOLMOD_NAME(free_factor) (&Lfactor, cm);
       CHOLMOD_NAME(finish) (cm);
       CHOLMOD_NAME(print_common) (tmp, cm);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
diff --git a/liboctave/sparse-base-lu.cc b/liboctave/sparse-base-lu.cc
--- a/liboctave/sparse-base-lu.cc
+++ b/liboctave/sparse-base-lu.cc
@@ -37,30 +37,30 @@ sparse_base_lu <lu_type, lu_elt_type, p_
 
   lu_type Yout (nr, nc, Lfact.nnz() + Ufact.nnz());
   octave_idx_type ii = 0;
   Yout.xcidx(0) = 0;
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = Ufact.cidx (j); i < Ufact.cidx(j + 1); i++)
-	{
-	  Yout.xridx (ii) = Ufact.ridx(i);
-	  Yout.xdata (ii++) = Ufact.data(i);
-	}
+        {
+          Yout.xridx (ii) = Ufact.ridx(i);
+          Yout.xdata (ii++) = Ufact.data(i);
+        }
       if (j < rcmin)
-	{
-	  // Note the +1 skips the 1.0 on the diagonal 
-	  for (octave_idx_type i = Lfact.cidx (j) + 1; 
-	       i < Lfact.cidx(j +1); i++)
-	    {
-	      Yout.xridx (ii) = Lfact.ridx(i);
-	      Yout.xdata (ii++) = Lfact.data(i);
-	    }
-	}
+        {
+          // Note the +1 skips the 1.0 on the diagonal 
+          for (octave_idx_type i = Lfact.cidx (j) + 1; 
+               i < Lfact.cidx(j +1); i++)
+            {
+              Yout.xridx (ii) = Lfact.ridx(i);
+              Yout.xdata (ii++) = Lfact.data(i);
+            }
+        }
       Yout.xcidx(j + 1) = ii;
     }
 
   return Yout;
 }
 
 template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
 p_type
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -32,100 +32,100 @@ along with Octave; see the file COPYING.
 #include "SparseCmplxQR.h"
 #include "MatrixType.h"
 #include "oct-sort.h"
 #include "oct-locbuf.h"
 
 template <class T>
 static MSparse<T>
 dmsolve_extract (const MSparse<T> &A, const octave_idx_type *Pinv, 
-		const octave_idx_type *Q, octave_idx_type rst, 
-		octave_idx_type rend, octave_idx_type cst, 
-		octave_idx_type cend, octave_idx_type maxnz = -1,
-		bool lazy = false)
+                const octave_idx_type *Q, octave_idx_type rst, 
+                octave_idx_type rend, octave_idx_type cst, 
+                octave_idx_type cend, octave_idx_type maxnz = -1,
+                bool lazy = false)
 {
   octave_idx_type nz = (rend - rst) * (cend - cst);
   maxnz = (maxnz < 0 ? A.nnz () : maxnz);
   MSparse<T> B (rend - rst, cend - cst, (nz < maxnz ? nz : maxnz));
   // Some sparse functions can support lazy indexing (where elements
   // in the row are in no particular order), even though octave in 
   // general can't. For those functions that can using it is a big 
   // win here in terms of speed.
   if (lazy)
     {
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
-	{
-	  octave_idx_type qq = (Q ? Q [j] : j);
-	  B.xcidx (j - cst) = nz;
-	  for (octave_idx_type p = A.cidx(qq) ; p < A.cidx (qq+1) ; p++)
-	    {
-	      octave_quit ();
-	      octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
-	      if (r >= rst && r < rend)
-		{
-		  B.xdata (nz) = A.data (p);
-		  B.xridx (nz++) =  r - rst ;
-		}
-	    }
-	}
+        {
+          octave_idx_type qq = (Q ? Q [j] : j);
+          B.xcidx (j - cst) = nz;
+          for (octave_idx_type p = A.cidx(qq) ; p < A.cidx (qq+1) ; p++)
+            {
+              octave_quit ();
+              octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
+              if (r >= rst && r < rend)
+                {
+                  B.xdata (nz) = A.data (p);
+                  B.xridx (nz++) =  r - rst ;
+                }
+            }
+        }
       B.xcidx (cend - cst) = nz ;
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (T, X, rend - rst);
       octave_sort<octave_idx_type> sort;
       octave_idx_type *ri = B.xridx();
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
-	{
-	  octave_idx_type qq = (Q ? Q [j] : j);
-	  B.xcidx (j - cst) = nz;
-	  for (octave_idx_type p = A.cidx(qq) ; p < A.cidx (qq+1) ; p++)
-	    {
-	      octave_quit ();
-	      octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
-	      if (r >= rst && r < rend)
-		{
-		  X [r-rst] = A.data (p);
-		  B.xridx (nz++) =  r - rst ;
-		}
-	    }
-	  sort.sort (ri + B.xcidx (j - cst), nz - B.xcidx (j - cst));
-	  for (octave_idx_type p = B.cidx (j - cst); p < nz; p++)
-	    B.xdata (p) = X [B.xridx (p)]; 
-	}
+        {
+          octave_idx_type qq = (Q ? Q [j] : j);
+          B.xcidx (j - cst) = nz;
+          for (octave_idx_type p = A.cidx(qq) ; p < A.cidx (qq+1) ; p++)
+            {
+              octave_quit ();
+              octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
+              if (r >= rst && r < rend)
+                {
+                  X [r-rst] = A.data (p);
+                  B.xridx (nz++) =  r - rst ;
+                }
+            }
+          sort.sort (ri + B.xcidx (j - cst), nz - B.xcidx (j - cst));
+          for (octave_idx_type p = B.cidx (j - cst); p < nz; p++)
+            B.xdata (p) = X [B.xridx (p)]; 
+        }
       B.xcidx (cend - cst) = nz ;
     }
 
   return B;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static MSparse<double>
 dmsolve_extract (const MSparse<double> &A, const octave_idx_type *Pinv, 
-		const octave_idx_type *Q, octave_idx_type rst, 
-		octave_idx_type rend, octave_idx_type cst, 
-		octave_idx_type cend, octave_idx_type maxnz,
-		bool lazy);
+                const octave_idx_type *Q, octave_idx_type rst, 
+                octave_idx_type rend, octave_idx_type cst, 
+                octave_idx_type cend, octave_idx_type maxnz,
+                bool lazy);
 
 static MSparse<Complex>
 dmsolve_extract (const MSparse<Complex> &A, const octave_idx_type *Pinv, 
-		const octave_idx_type *Q, octave_idx_type rst, 
-		octave_idx_type rend, octave_idx_type cst, 
-		octave_idx_type cend, octave_idx_type maxnz,
-		bool lazy);
+                const octave_idx_type *Q, octave_idx_type rst, 
+                octave_idx_type rend, octave_idx_type cst, 
+                octave_idx_type cend, octave_idx_type maxnz,
+                bool lazy);
 #endif
 
 template <class T>
 static MArray2<T>
 dmsolve_extract (const MArray2<T> &m, const octave_idx_type *, 
-		 const octave_idx_type *, octave_idx_type r1, 
-		 octave_idx_type r2, octave_idx_type c1, 
-		 octave_idx_type c2)
+                 const octave_idx_type *, octave_idx_type r1, 
+                 octave_idx_type r2, octave_idx_type c1, 
+                 octave_idx_type c2)
 {
   r2 -= 1;
   c2 -= 1;
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   octave_idx_type new_r = r2 - r1 + 1;
   octave_idx_type new_c = c2 - c1 + 1;
@@ -137,63 +137,63 @@ dmsolve_extract (const MArray2<T> &m, co
       result.xelem (i, j) = m.elem (r1+i, c1+j);
 
   return result;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static MArray2<double>
 dmsolve_extract (const MArray2<double> &m, const octave_idx_type *, 
-		 const octave_idx_type *, octave_idx_type r1, 
-		 octave_idx_type r2, octave_idx_type c1, 
-		 octave_idx_type c2)
+                 const octave_idx_type *, octave_idx_type r1, 
+                 octave_idx_type r2, octave_idx_type c1, 
+                 octave_idx_type c2)
 
 static MArray2<Complex>
 dmsolve_extract (const MArray2<Complex> &m, const octave_idx_type *, 
-		 const octave_idx_type *, octave_idx_type r1, 
-		 octave_idx_type r2, octave_idx_type c1, 
-		 octave_idx_type c2)
+                 const octave_idx_type *, octave_idx_type r1, 
+                 octave_idx_type r2, octave_idx_type c1, 
+                 octave_idx_type c2)
 #endif
 
 template <class T>
 static void
 dmsolve_insert (MArray2<T> &a, const MArray2<T> &b, const octave_idx_type *Q,
-	       octave_idx_type r, octave_idx_type c)
+               octave_idx_type r, octave_idx_type c)
 {
   T *ax = a.fortran_vec();
   const T *bx = b.fortran_vec();
   octave_idx_type anr = a.rows();
   octave_idx_type nr = b.rows();
   octave_idx_type nc = b.cols();
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_idx_type aoff = (c + j) * anr;
       octave_idx_type boff = j * nr;
       for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  octave_quit ();
-	  ax [Q [r + i] + aoff] = bx [i + boff];
-	}
+        {
+          octave_quit ();
+          ax [Q [r + i] + aoff] = bx [i + boff];
+        }
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_insert (MArray2<double> &a, const MArray2<double> &b, 
-	       const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
+               const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 
 static void
 dmsolve_insert (MArray2<Complex> &a, const MArray2<Complex> &b,
-	       const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
+               const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 #endif
 
 template <class T>
 static void
 dmsolve_insert (MSparse<T> &a, const MSparse<T> &b, const octave_idx_type *Q,
-	       octave_idx_type r, octave_idx_type c)
+               octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type b_rows = b.rows ();
   octave_idx_type b_cols = b.cols ();
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Qinv, nr);
   for (octave_idx_type i = 0; i < nr; i++)
@@ -203,17 +203,17 @@ dmsolve_insert (MSparse<T> &a, const MSp
   octave_idx_type nel = a.xcidx(c) + b.nnz ();
 
   if (c + b_cols < nc)
     nel += a.xcidx(nc) - a.xcidx(c + b_cols);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
     for (octave_idx_type j = a.xcidx(i); j < a.xcidx(i+1); j++)
       if (Qinv [a.xridx(j)] < r || Qinv [a.xridx(j)] >= r + b_rows)
-	nel++;
+        nel++;
 
   OCTAVE_LOCAL_BUFFER (T, X, nr);
   octave_sort<octave_idx_type> sort;
   MSparse<T> tmp (a);
   a = MSparse<T> (nr, nc, nel);
   octave_idx_type *ri = a.xridx();
 
   for (octave_idx_type i = 0; i < tmp.cidx(c); i++)
@@ -226,89 +226,89 @@ dmsolve_insert (MSparse<T> &a, const MSp
 
   octave_idx_type ii = a.xcidx(c);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
     {
       octave_quit ();
 
       for (octave_idx_type j = tmp.xcidx(i); j < tmp.xcidx(i+1); j++)
-	if (Qinv [tmp.xridx(j)] < r || 	Qinv [tmp.xridx(j)] >= r + b_rows)
-	  {
-	    X [tmp.xridx(j)] = tmp.xdata(j);
-	    a.xridx(ii++) = tmp.xridx(j);
-	  }
+        if (Qinv [tmp.xridx(j)] < r ||  Qinv [tmp.xridx(j)] >= r + b_rows)
+          {
+            X [tmp.xridx(j)] = tmp.xdata(j);
+            a.xridx(ii++) = tmp.xridx(j);
+          }
 
       octave_quit ();
 
       for (octave_idx_type j = b.cidx(i-c); j < b.cidx(i-c+1); j++)
-	{
-	  X [Q [r + b.ridx(j)]] = b.data(j);
-	  a.xridx(ii++) = Q [r + b.ridx(j)];
-	}
+        {
+          X [Q [r + b.ridx(j)]] = b.data(j);
+          a.xridx(ii++) = Q [r + b.ridx(j)];
+        }
 
       sort.sort (ri + a.xcidx (i), ii - a.xcidx (i));
       for (octave_idx_type p = a.xcidx (i); p < ii; p++)
-	a.xdata (p) = X [a.xridx (p)]; 
+        a.xdata (p) = X [a.xridx (p)]; 
       a.xcidx(i+1) = ii;
     }
 
   for (octave_idx_type i = c + b_cols; i < nc; i++)
     {
       for (octave_idx_type j = tmp.xcidx(i); j < tmp.cidx(i+1); j++)
-	{
-	  a.xdata(ii) = tmp.xdata(j);
-	  a.xridx(ii++) = tmp.xridx(j);
-	}
+        {
+          a.xdata(ii) = tmp.xdata(j);
+          a.xridx(ii++) = tmp.xridx(j);
+        }
       a.xcidx(i+1) = ii;
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_insert (MSparse<double> &a, const SparseMatrix &b, 
-	       const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
+               const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 
 static void
 dmsolve_insert (MSparse<Complex> &a, const MSparse<Complex> &b,
-	       const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
+               const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 #endif
 
 template <class T, class RT>
 static void
 dmsolve_permute (MArray2<RT> &a, const MArray2<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   const T *Bx = b.fortran_vec();
   a.resize(b_nr, b_nc);
   RT *Btx = a.fortran_vec();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       octave_idx_type off = j * b_nr;
       for (octave_idx_type i = 0; i < b_nr; i++)
-	{
-	  octave_quit ();
-	  Btx [p [i] + off] = Bx [ i + off];
-	}
+        {
+          octave_quit ();
+          Btx [p [i] + off] = Bx [ i + off];
+        }
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_permute (MArray2<double> &a, const MArray2<double>& b,
-		 const octave_idx_type *p);
+                 const octave_idx_type *p);
 
 static void
 dmsolve_permute (MArray2<Complex> &a, const MArray2<double>& b,
-		 const octave_idx_type *p);
+                 const octave_idx_type *p);
 
 static void
 dmsolve_permute (MArray2<Complex> &a, const MArray2<Complex>& b,
-		 const octave_idx_type *p);
+                 const octave_idx_type *p);
 #endif
 
 template <class T, class RT>
 static void
 dmsolve_permute (MSparse<RT> &a, const MSparse<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
@@ -317,44 +317,44 @@ dmsolve_permute (MSparse<RT> &a, const M
   a = MSparse<RT> (b_nr, b_nc, b_nz);
   octave_sort<octave_idx_type> sort;
   octave_idx_type *ri = a.xridx();
   OCTAVE_LOCAL_BUFFER (RT, X, b_nr);
   a.xcidx(0) = 0;
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-	{
-	  octave_quit ();
-	  octave_idx_type r = p [b.ridx (i)];
-	  X [r] = b.data (i);
-	  a.xridx(nz++) = p [b.ridx (i)];
-	}
+        {
+          octave_quit ();
+          octave_idx_type r = p [b.ridx (i)];
+          X [r] = b.data (i);
+          a.xridx(nz++) = p [b.ridx (i)];
+        }
       sort.sort (ri + a.xcidx (j), nz - a.xcidx (j));
       for (octave_idx_type i = a.cidx (j); i < nz; i++)
-	{
-	  octave_quit ();
-	  a.xdata (i) = X [a.xridx (i)]; 
-	}
+        {
+          octave_quit ();
+          a.xdata (i) = X [a.xridx (i)]; 
+        }
       a.xcidx(j+1) = nz;
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_permute (MSparse<double> &a, const MSparse<double>& b, 
-		 const octave_idx_type *p);
+                 const octave_idx_type *p);
 
 static void
 dmsolve_permute (MSparse<Complex> &a, const MSparse<double>& b,
-		 const octave_idx_type *p);
+                 const octave_idx_type *p);
 
 static void
 dmsolve_permute (MSparse<Complex> &a, const MSparse<Complex>& b,
-		 const octave_idx_type *p);
+                 const octave_idx_type *p);
 #endif
 
 static void
 solve_singularity_warning (double)
 {
   // Dummy singularity handler so that LU solver doesn't flag
   // an error for numerically rank defficient matrices
 }
@@ -395,118 +395,118 @@ dmsolve (const ST &a, const T &b, octave
       octave_idx_type *q = dm->q;
 #else
       CXSPARSE_DNAME (d) *dm = CXSPARSE_DNAME(_dmperm) (&csm);
       octave_idx_type *p = dm->P;
       octave_idx_type *q = dm->Q;
 #endif
       OCTAVE_LOCAL_BUFFER (octave_idx_type, pinv, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-	pinv [p [i]] = i;
+        pinv [p [i]] = i;
       RT btmp;
       dmsolve_permute (btmp, b, pinv);
       info = 0;
       retval.resize (nc, b_nc);
 
       // Leading over-determined block
       if (dm->rr [2] < nr && dm->cc [3] < nc)
-	{
-	  ST m = dmsolve_extract (a, pinv, q, dm->rr [2], nr, dm->cc [3], nc, 
-				  nnz_remaining, true);
-	  nnz_remaining -= m.nnz();
-	  RT mtmp = 
-	    qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2], b_nr, 0,
-					 b_nc), info);
-	  dmsolve_insert (retval, mtmp, q, dm->cc [3], 0);
-	  if (dm->rr [2] > 0 && !info)
-	    {
-	      m = dmsolve_extract (a, pinv, q, 0, dm->rr [2], 
-				   dm->cc [3], nc, nnz_remaining, true);
-	      nnz_remaining -= m.nnz();
-	      RT ctmp = dmsolve_extract (btmp, 0, 0, 0, 
-					 dm->rr[2], 0, b_nc);
-	      btmp.insert (ctmp - m * mtmp, 0, 0);
-	    }
-	}
+        {
+          ST m = dmsolve_extract (a, pinv, q, dm->rr [2], nr, dm->cc [3], nc, 
+                                  nnz_remaining, true);
+          nnz_remaining -= m.nnz();
+          RT mtmp = 
+            qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2], b_nr, 0,
+                                         b_nc), info);
+          dmsolve_insert (retval, mtmp, q, dm->cc [3], 0);
+          if (dm->rr [2] > 0 && !info)
+            {
+              m = dmsolve_extract (a, pinv, q, 0, dm->rr [2], 
+                                   dm->cc [3], nc, nnz_remaining, true);
+              nnz_remaining -= m.nnz();
+              RT ctmp = dmsolve_extract (btmp, 0, 0, 0, 
+                                         dm->rr[2], 0, b_nc);
+              btmp.insert (ctmp - m * mtmp, 0, 0);
+            }
+        }
       
       // Structurally non-singular blocks
       // FIXME Should use fine Dulmange-Mendelsohn decomposition here.
       if (dm->rr [1] < dm->rr [2] && dm->cc [2] < dm->cc [3] && !info)
-	{
-	  ST m = dmsolve_extract (a, pinv, q, dm->rr [1], dm->rr [2], 
-				  dm->cc [2], dm->cc [3], nnz_remaining, false);
-	  nnz_remaining -= m.nnz();
-	  RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr [1], dm->rr [2], 
-				      0, b_nc);
-	  double rcond = 0.0;
-	  MatrixType mtyp (MatrixType::Full);
-	  RT mtmp = m.solve (mtyp, btmp2, info, rcond, 
-			     solve_singularity_warning, false);	
-	  if (info != 0)
-	    {
-	      info = 0;
-	      mtmp = qrsolve (m, btmp2, info);
-	    }
+        {
+          ST m = dmsolve_extract (a, pinv, q, dm->rr [1], dm->rr [2], 
+                                  dm->cc [2], dm->cc [3], nnz_remaining, false);
+          nnz_remaining -= m.nnz();
+          RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr [1], dm->rr [2], 
+                                      0, b_nc);
+          double rcond = 0.0;
+          MatrixType mtyp (MatrixType::Full);
+          RT mtmp = m.solve (mtyp, btmp2, info, rcond, 
+                             solve_singularity_warning, false); 
+          if (info != 0)
+            {
+              info = 0;
+              mtmp = qrsolve (m, btmp2, info);
+            }
 
-	  dmsolve_insert (retval, mtmp, q, dm->cc [2], 0);
-	  if (dm->rr [1] > 0 && !info)
-	    {
-	      m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], dm->cc [2],
-				   dm->cc [3], nnz_remaining, true);
-	      nnz_remaining -= m.nnz();
-	      RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
-					 dm->rr[1], 0, b_nc);
-	      btmp.insert (ctmp - m * mtmp, 0, 0);
-	    }
-	}
+          dmsolve_insert (retval, mtmp, q, dm->cc [2], 0);
+          if (dm->rr [1] > 0 && !info)
+            {
+              m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], dm->cc [2],
+                                   dm->cc [3], nnz_remaining, true);
+              nnz_remaining -= m.nnz();
+              RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
+                                         dm->rr[1], 0, b_nc);
+              btmp.insert (ctmp - m * mtmp, 0, 0);
+            }
+        }
 
       // Trailing under-determined block
       if (dm->rr [1] > 0 && dm->cc [2] > 0 && !info)
-	{
-	  ST m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], 0, 
-				  dm->cc [2], nnz_remaining, true);
-	  RT mtmp = 
-	    qrsolve (m, dmsolve_extract(btmp, 0, 0, 0, dm->rr [1] , 0, 
-					b_nc), info);
-	  dmsolve_insert (retval, mtmp, q, 0, 0);
-	}
+        {
+          ST m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], 0, 
+                                  dm->cc [2], nnz_remaining, true);
+          RT mtmp = 
+            qrsolve (m, dmsolve_extract(btmp, 0, 0, 0, dm->rr [1] , 0, 
+                                        b_nc), info);
+          dmsolve_insert (retval, mtmp, q, 0, 0);
+        }
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
   return retval;
 #else
   return RT ();
 #endif
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern Matrix
 dmsolve (const SparseMatrix &a, const Matrix &b, 
-	 octave_idx_type &info);
+         octave_idx_type &info);
 
 extern ComplexMatrix
 dmsolve (const SparseMatrix &a, const ComplexMatrix &b, 
-	 octave_idx_type &info);
+         octave_idx_type &info);
 
 extern ComplexMatrix
 dmsolve (const SparseComplexMatrix &a, const Matrix &b, 
-	 octave_idx_type &info);
+         octave_idx_type &info);
 
 extern ComplexMatrix
 dmsolve (const SparseComplexMatrix &a, const ComplexMatrix &b, 
-	 octave_idx_type &info);
+         octave_idx_type &info);
 
 extern SparseMatrix
 dmsolve (const SparseMatrix &a, const SparseMatrix &b, 
-	 octave_idx_type &info);
+         octave_idx_type &info);
 
 extern SparseComplexMatrix
 dmsolve (const SparseMatrix &a, const SparseComplexMatrix &b, 
-	 octave_idx_type &info);
+         octave_idx_type &info);
 
 extern SparseComplexMatrix
 dmsolve (const SparseComplexMatrix &a, const SparseMatrix &b, 
-	 octave_idx_type &info);
+         octave_idx_type &info);
 
 extern SparseComplexMatrix
 dmsolve (const SparseComplexMatrix &a, const SparseComplexMatrix &b, 
-	 octave_idx_type &info);
+         octave_idx_type &info);
 #endif
diff --git a/liboctave/sparse-sort.cc b/liboctave/sparse-sort.cc
--- a/liboctave/sparse-sort.cc
+++ b/liboctave/sparse-sort.cc
@@ -34,30 +34,30 @@ along with Octave; see the file COPYING.
 #include "sparse-sort.h"
 
 // A simple class and instantiation of the octave merge sort class
 // to sort sparse data before matrix creation. This is significantly
 // faster than using octave_qsort.
 
 bool
 octave_sparse_sidxl_comp (octave_sparse_sort_idxl* i, 
-			  octave_sparse_sort_idxl* j)
+                          octave_sparse_sort_idxl* j)
 {
   octave_idx_type tmp = i->c - j->c;
   if (tmp < 0)
     return true;
   else if (tmp > 0)
     return false;
   return  (i->r < j->r);
 }
 
 template class octave_sort<octave_sparse_sort_idxl *>;
 
 // Need to know the original order of the sorted indexes in
 // sparse assignments, and this class does that
 bool
 octave_idx_vector_comp (octave_idx_vector_sort* i,
-			octave_idx_vector_sort* j)
+                        octave_idx_vector_sort* j)
 {
   return (i->i < j->i);
 }
 
 template class octave_sort<octave_idx_vector_sort *>;
diff --git a/liboctave/sparse-util.cc b/liboctave/sparse-util.cc
--- a/liboctave/sparse-util.cc
+++ b/liboctave/sparse-util.cc
@@ -36,17 +36,17 @@ SparseCholError (int status, char *file,
 {
   SparseCholError (status, file, line, message);
 }
 
 void
 SparseCholError (int status, const char *file, int line, const char *message)
 {
   (*current_liboctave_warning_handler)("warning %i, at line %i in file %s",
-				     status, line, file);
+                                     status, line, file);
 
   (*current_liboctave_warning_handler)(message);
 }
 
 int
 SparseCholPrint (const char *fmt, ...)
 {
   va_list args;
@@ -55,65 +55,65 @@ SparseCholPrint (const char *fmt, ...)
   fflush (stderr);
   va_end (args);
   return ret;
 }
 
 
 bool
 sparse_indices_ok (octave_idx_type *r, octave_idx_type *c,
-		   octave_idx_type nrows, octave_idx_type ncols,
-		   octave_idx_type nnz)
+                   octave_idx_type nrows, octave_idx_type ncols,
+                   octave_idx_type nnz)
 {
   if (nnz > 0)
     {
       if (c[0] != 0)
-	{
-	  (*current_liboctave_error_handler)
-	    ("invalid sparse matrix: cidx[0] must be zero");
-	  return false;
-	}
+        {
+          (*current_liboctave_error_handler)
+            ("invalid sparse matrix: cidx[0] must be zero");
+          return false;
+        }
 
       octave_idx_type jold = 0;
 
       for (octave_idx_type j = 1; j < ncols+1; j++)
-	{
-	  if (c[j] < c[j-1])
-	    {
-	      (*current_liboctave_error_handler)
-		("invalid sparse matrix: cidx elements must appear in ascending order");
-	      return false;
-	    }
+        {
+          if (c[j] < c[j-1])
+            {
+              (*current_liboctave_error_handler)
+                ("invalid sparse matrix: cidx elements must appear in ascending order");
+              return false;
+            }
 
-	  if (c[j] > nnz)
-	    {
-	      (*current_liboctave_error_handler)
-		("invalid sparse matrix: cidx[%d] = %d exceeds number of nonzero elements", j, c[j]+1);
-	      return false;
-	    }
+          if (c[j] > nnz)
+            {
+              (*current_liboctave_error_handler)
+                ("invalid sparse matrix: cidx[%d] = %d exceeds number of nonzero elements", j, c[j]+1);
+              return false;
+            }
 
-	  if (c[j] != jold)
-	    {
-	      for (octave_idx_type i = jold+1; i < c[j]; i++)
-		{
-		  if (r[i] < r[i-1])
-		    {
-		      (*current_liboctave_error_handler)
-			("invalid sparse matrix: ridx elements must appear in ascending order for each column");
-		      return false;
-		    }
+          if (c[j] != jold)
+            {
+              for (octave_idx_type i = jold+1; i < c[j]; i++)
+                {
+                  if (r[i] < r[i-1])
+                    {
+                      (*current_liboctave_error_handler)
+                        ("invalid sparse matrix: ridx elements must appear in ascending order for each column");
+                      return false;
+                    }
 
-		  if (r[i] >= nrows)
-		    {
-		      (*current_liboctave_error_handler)
-			("invalid sparse matrix: ridx[%d] = %d out of range",
-			 i, r[i]+1);
-		      return false;
-		    }
-		}
+                  if (r[i] >= nrows)
+                    {
+                      (*current_liboctave_error_handler)
+                        ("invalid sparse matrix: ridx[%d] = %d out of range",
+                         i, r[i]+1);
+                      return false;
+                    }
+                }
 
-	      jold = c[j];
-	    }
-	}
+              jold = c[j];
+            }
+        }
     }
 
   return true;
 }
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -118,22 +118,22 @@ string_vector::uniq (void)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       octave_idx_type k = 0;
 
       for (octave_idx_type i = 1; i < len; i++)
-	if (elem(i) != elem(k))
-	  if (++k != i)
-	    elem(k) = elem(i);
+        if (elem(i) != elem(k))
+          if (++k != i)
+            elem(k) = elem(i);
 
       if (len != ++k)
-	resize (k);
+        resize (k);
     }
 
   return *this;
 }
 
 string_vector&
 string_vector::append (const std::string& s)
 {
@@ -204,17 +204,17 @@ string_vector::list_in_columns (std::ost
       os << "\n";
       return os;
     }
 
   for (octave_idx_type i = 0; i < total_names; i++)
     {
       octave_idx_type name_length = elem (i).length ();
       if (name_length > max_name_length)
-	max_name_length = name_length;
+        max_name_length = name_length;
     }
 
   // Allow at least two spaces between names.
 
   max_name_length += 2;
 
   // Calculate the maximum number of columns that will fit.
 
@@ -238,28 +238,28 @@ string_vector::list_in_columns (std::ost
   for (octave_idx_type row = 0; row < nr; row++)
     {
       count = row;
       octave_idx_type pos = 0;
 
       // Print the next row.
 
       while (1)
-	{
-	  std::string nm = elem (count);
+        {
+          std::string nm = elem (count);
 
-	  os << nm;
-	  octave_idx_type name_length = nm.length ();
+          os << nm;
+          octave_idx_type name_length = nm.length ();
 
-	  count += nr;
-	  if (count >= total_names)
-	    break;
+          count += nr;
+          if (count >= total_names)
+            break;
 
-	  octave_idx_type spaces_to_pad = max_name_length - name_length;
-	  for (octave_idx_type i = 0; i < spaces_to_pad; i++)
-	    os << " ";
-	  pos += max_name_length;
-	}
+          octave_idx_type spaces_to_pad = max_name_length - name_length;
+          for (octave_idx_type i = 0; i < spaces_to_pad; i++)
+            os << " ";
+          pos += max_name_length;
+        }
       os << "\n";
     }
 
   return os;
 }
