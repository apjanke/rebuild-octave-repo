# HG changeset patch
# User jwe
# Date 1068479440 0
#      Mon Nov 10 15:50:40 2003 +0000
# Node ID 7b957b4428184c989575cfdd46687d03a38ca0f3
# Parent  7e08de0d1a98a1157cf08aeb4e802821ad63d588
[project @ 2003-11-10 15:50:39 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,13 @@
+2003-11-10  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in: Preserve CFLAGS and CXXFLAGS before doing anything.
+	Maybe add -Wshadow to CFLAGS and CXXFLAGS.
+
 2003-10-24  Stefan Monnier  <monnier@iro.umontreal.ca>
 
 	* emacs/octave-mod.el (octave-comment-start): Simplify.
 	(octave-point): Remove.
 	(octave-in-comment-p, octave-in-string-p)
 	(octave-not-in-string-or-comment-p, calculate-octave-indent)
 	(octave-blink-matching-block-open, octave-auto-fill):
 	Use line-(beginning|end)-position instead.
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -16,18 +16,25 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, write to the Free
 ### Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ### 02111-1307, USA. 
 
+### Preserve CFLAGS and CXXFLAGS from the environment before doing
+### anything else because we don't know which macros might call
+### AC_PROG_CC or AC_PROG_CXX.
+
+EXTERN_CFLAGS="$CFLAGS"
+EXTERN_CXXFLAGS="$CXXFLAGS"
+
 AC_INIT
-AC_REVISION($Revision: 1.435 $)
+AC_REVISION($Revision: 1.436 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -156,18 +163,16 @@ fi
 ### the GNU libc.  Since I'm not sure how to test whether we are using
 ### GNU libc, just disable them for all platforms.
 
 AC_MSG_RESULT([defining __NO_MATH_INLINES avoids buggy GNU libc exp function])
 AC_DEFINE(__NO_MATH_INLINES, 1, [Define if your version of GNU libc has buggy inline assembly code for math functions like exp.])
 
 ### See which C++ compiler to use (we expect to find g++).
 
-EXTERN_CXXFLAGS="$CXXFLAGS"
-
 AC_PROG_CXX
 AC_PROG_CXXCPP
 
 ### Do special things for g++.
 
 gxx_version=`$CXX -v 2>&1 | grep "^.*g.. version" | \
   sed -e 's/^.*g.. version *//' -e 's/cygnus-//' -e 's/egcs-//' -e 's/ .*//'`
 
@@ -188,18 +193,16 @@ OCTAVE_CXX_ISO_COMPLIANT_LIBRARY
 
 # Determine the ABI used the C++ compiler, needed by the dynamic loading
 # code. Currently supported ABIs are GNU v2, GNU v3 and Sun Workshop.
 
 OCTAVE_CXX_ABI
 
 ### See which C compiler to use (we expect to find gcc).
 
-EXTERN_CFLAGS="$CFLAGS"
-
 AC_PROG_CC
 AC_PROG_CPP
 AC_PROG_GCC_TRADITIONAL
 
 ### Do special things for gcc.
 
 gcc_version=`$CC -v 2>&1 | grep "^.*gcc version" | \
   sed -e 's/^.*g.. version *//' -e 's/cygnus-//' -e 's/egcs-//'`
@@ -1270,25 +1273,27 @@ case "$canonical_host_type" in
   ;;
   *)
     UGLY_DEFS=`echo $DEFS | sed 's,\\",\\\\\\\\\\\\\\\\\\",g'`
   ;;
 esac
 AC_MSG_RESULT([defining UGLY_DEFS to be $UGLY_DEFS])
 AC_SUBST(UGLY_DEFS)
 
-### Maybe add -Wall to compiler flags now that we're done feature
-### testing. 
+### Maybe add -Wall and -Wshadow to compiler flags now that we're
+### done feature testing. 
 
 if test -z "$EXTERN_CFLAGS"; then
   OCTAVE_CC_FLAG(-Wall)
+  OCTAVE_CC_FLAG(-Wshadow)
 fi
 
 if test -z "$EXTERN_CXXFLAGS"; then
   OCTAVE_CXX_FLAG(-Wall)
+  OCTAVE_CXX_FLAG(-Wshadow)
 fi
 
 ### Someday, maybe include -ansi and even -pedantic in this list...
 
 GCC_PICKY_FLAGS="-Wcast-align -Wcast-qual -Wid-clash-31 \
  -Winline -Wmissing-prototypes -Wnested-externs -Wpointer-arith \
  -Wstrict-prototypes -Wwrite-strings"
 
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -387,23 +387,23 @@ Array<T>::resize_no_fill (int n)
     }
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 void
-Array<T>::resize_no_fill (const dim_vector& dims)
+Array<T>::resize_no_fill (const dim_vector& dv)
 {
-  int n = dims.length ();
+  int n = dv.length ();
 
   for (int i = 0; i < n; i++)
     {
-      if (dims(i) < 0)
+      if (dv(i) < 0)
 	{
 	  (*current_liboctave_error_handler)
 	    ("can't resize to negative dimension");
 	  return;
 	}
     }
 
   bool same_size = true;
@@ -411,35 +411,35 @@ Array<T>::resize_no_fill (const dim_vect
   if (dimensions.length () != n)
     {
       same_size = false;
     }
   else
     {
       for (int i = 0; i < n; i++)
 	{
-	  if (dims(i) != dimensions(i))
+	  if (dv(i) != dimensions(i))
 	    {
 	      same_size = false;
 	      break;
 	    }
 	}
     }
 
   if (same_size)
     return;
 
   int old_len = length ();
 
   typename Array<T>::ArrayRep *old_rep = rep;
   const T *old_data = data ();
 
-  rep = new typename Array<T>::ArrayRep (get_size (dims));
-
-  dimensions = dims;
+  rep = new typename Array<T>::ArrayRep (get_size (dv));
+
+  dimensions = dv;
 
   Array<int> ra_idx (dimensions.length (), 0);
 
   for (int i = 0; i < old_len; i++)
     {
       if (index_in_bounds (ra_idx, dimensions))
 	xelem (ra_idx) = old_data[i];
 
@@ -700,23 +700,23 @@ Array<T>::resize_and_fill (int r, int c,
 	xelem (i, j, k) = val;
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 void
-Array<T>::resize_and_fill (const dim_vector& dims, const T& val)
+Array<T>::resize_and_fill (const dim_vector& dv, const T& val)
 {
-  int n = dims.length ();
+  int n = dv.length ();
 
   for (int i = 0; i < n; i++)
     {
-      if (dims(i) < 0)
+      if (dv(i) < 0)
 	{
 	  (*current_liboctave_error_handler)
 	    ("can't resize to negative dimension");
 	  return;
 	}
     }
 
   bool same_size = true;
@@ -724,37 +724,37 @@ Array<T>::resize_and_fill (const dim_vec
   if (dimensions.length () != n)
     {
       same_size = false;
     }
   else
     {
       for (int i = 0; i < n; i++)
 	{
-	  if (dims(i) != dimensions(i))
+	  if (dv(i) != dimensions(i))
 	    {
 	      same_size = false;
 	      break;
 	    }
 	}
     }
 
   if (same_size)
     return;
 
   typename Array<T>::ArrayRep *old_rep = rep;
   const T *old_data = data ();
 
   int old_len = length ();
 
-  int len = get_size (dims);
+  int len = get_size (dv);
 
   rep = new typename Array<T>::ArrayRep (len);
 
-  dimensions = dims;
+  dimensions = dv;
 
   Array<int> ra_idx (dimensions.length (), 0);
 
   // XXX FIXME XXX -- it is much simpler to fill the whole array
   // first, but probably slower for large arrays, or if the assignment
   // operator for the type T is expensive.  OTOH, the logic for
   // deciding whether an element needs the copied value or the filled
   // value might be more expensive.
@@ -867,38 +867,38 @@ Array<T>::fortran_vec (void)
     }
   return rep->data;
 }
 
 template <class T>
 void
 Array<T>::maybe_delete_dims (void)
 {
-  int ndims = dimensions.length ();
+  int nd = dimensions.length ();
 
   dim_vector new_dims (1, 1);
 
   bool delete_dims = true;
 
-  for (int i = ndims - 1; i >= 0; i--)
+  for (int i = nd - 1; i >= 0; i--)
     {
       if (delete_dims)
         {
           if (dimensions(i) != 1)
 	    {
 	      delete_dims = false;
 
 	      new_dims = dim_vector (i + 1, dimensions(i));
 	    }
         }
       else
 	new_dims(i) = dimensions(i);
     }
 
-  if (ndims != new_dims.length ())
+  if (nd != new_dims.length ())
     dimensions = new_dims;
 }
 
 template <class T>
 void
 Array<T>::clear_index (void)
 {
   delete [] idx;
@@ -1829,34 +1829,34 @@ Array<T>::indexN (idx_vector& ra_idx, in
 	    }
 
 	  retval.resize (result_dims);
 
 	  int n = number_of_elements (result_dims);
 
 	  int r_dims = result_dims.length ();
 
-	  Array<int> index (r_dims, 0);
+	  Array<int> iidx (r_dims, 0);
 
 	  int k = 0;
 
 	  for (int i = 0; i < n; i++)
 	    {
 	      int ii = ra_idx.elem (k++);
 
 	      if (ii >= orig_len)
-	        retval.elem (index) = rfv;
+	        retval.elem (iidx) = rfv;
 	      else
 	        {
 		  Array<int> temp = get_ra_idx (ii, dims ());
 
-		  retval.elem (index) = elem (temp);
+		  retval.elem (iidx) = elem (temp);
 		}
 	      if (i != n - 1)
-		increment_index (index, result_dims);
+		increment_index (iidx, result_dims);
 	    }
 	}
     }
   else if (ra_idx.capacity () == 1)
     {
       // i.e. A(8) for A(3x3x3)
 
       ra_idx.freeze (orig_len, "nd-array", resize_ok);
@@ -2600,18 +2600,18 @@ assignN (Array<LT>& lhs, const Array<RT>
 
 	  for (int i = 0; i < n; i++)
 	    {
 	      elt_idx = get_elt_idx (idx, result_idx);
 
 	      dim_vector lhs_inc;
 	      lhs_inc.resize (lhs_dims.length ());
 
-	      for (int i = 0; i < lhs_dims.length (); i++)
-		lhs_inc(i) = lhs_dims(i) + 1;
+	      for (int j = 0; j < lhs_dims.length (); j++)
+		lhs_inc(j) = lhs_dims(j) + 1;
 
 	      if (index_in_bounds(elt_idx, lhs_inc))
 		lhs.checkelem (elt_idx) = scalar;
 	      else
 		lhs.checkelem (elt_idx) = rfv;
 
 	      increment_index (result_idx, frozen_len);
 	    }
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -147,19 +147,19 @@ protected:
 
   idx_vector *idx;
   int idx_count;
 
   Array (T *d, int n)
     : rep (new typename Array<T>::ArrayRep (d, n)), dimensions (n),
       idx (0), idx_count (0) { }
 
-  Array (T *d, const dim_vector& dims)
-    : rep (new typename Array<T>::ArrayRep (d, get_size (dims))),
-      dimensions (dims), idx (0), idx_count (0) { }
+  Array (T *d, const dim_vector& dv)
+    : rep (new typename Array<T>::ArrayRep (d, get_size (dv))),
+      dimensions (dv), idx (0), idx_count (0) { }
 
 private:
 
   typename Array<T>::ArrayRep *nil_rep (void) const
     {
       static typename Array<T>::ArrayRep *nr
 	= new typename Array<T>::ArrayRep ();
 
@@ -186,29 +186,29 @@ public:
   Array (const Array<T>& a)
     : rep (a.rep), dimensions (a.dimensions), idx (0), idx_count (0)
     {
       rep->count++;
     }
 
 public:
 
-  Array (const dim_vector& dims)
-    : rep (new typename Array<T>::ArrayRep (get_size (dims))),
-      dimensions (dims), idx (0), idx_count (0) { }
+  Array (const dim_vector& dv)
+    : rep (new typename Array<T>::ArrayRep (get_size (dv))),
+      dimensions (dv), idx (0), idx_count (0) { }
 
-  Array (const dim_vector& dims, const T& val)
-    : rep (new typename Array<T>::ArrayRep (get_size (dims))),
-      dimensions (dims), idx (0), idx_count (0)
+  Array (const dim_vector& dv, const T& val)
+    : rep (new typename Array<T>::ArrayRep (get_size (dv))),
+      dimensions (dv), idx (0), idx_count (0)
     {
       fill (val);
     }
 
-  Array (const Array<T>& a, const dim_vector& dims)
-    : rep (a.rep), dimensions (dims), idx (0), idx_count (0)
+  Array (const Array<T>& a, const dim_vector& dv)
+    : rep (a.rep), dimensions (dv), idx (0), idx_count (0)
     {
       rep->count++;
     }
 
   ~Array (void);
 
   Array<T>& operator = (const Array<T>& a)
     {
@@ -246,17 +246,17 @@ public:
   int pages (void) const { return dim3 (); }
 
   dim_vector dims (void) const { return dimensions; }
 
   Array<T> squeeze (void) const;
 
   static int get_size (int r, int c);
   static int get_size (int r, int c, int p);
-  static int get_size (const dim_vector& dims);
+  static int get_size (const dim_vector& dv);
 
   int compute_index (const Array<int>& ra_idx) const;
 
   T range_error (const char *fcn, int n) const;
   T& range_error (const char *fcn, int n);
 
   T range_error (const char *fcn, int i, int j) const;
   T& range_error (const char *fcn, int i, int j);
@@ -419,33 +419,33 @@ public:
   // protected:
 
   void resize_no_fill (int r, int c);
   void resize_and_fill (int r, int c, const T& val);
 
   void resize_no_fill (int r, int c, int p);
   void resize_and_fill (int r, int c, int p, const T& val);
 
-  void resize_no_fill (const dim_vector& dims);
-  void resize_and_fill (const dim_vector& dims, const T& val);
+  void resize_no_fill (const dim_vector& dv);
+  void resize_and_fill (const dim_vector& dv, const T& val);
 
 public:
 
   void resize (int n) { resize_no_fill (n); }
 
   //  void resize (int n, const T& val) { resize_and_fill (n, val); }
 
-  void resize (const dim_vector& dims) { resize_no_fill (dims); }
+  void resize (const dim_vector& dv) { resize_no_fill (dv); }
 
-  void resize (const dim_vector& dims, const T& val)
-    { resize_and_fill (dims, val); }
+  void resize (const dim_vector& dv, const T& val)
+    { resize_and_fill (dv, val); }
 
   Array<T>& insert (const Array<T>& a, int r, int c);
 
-  Array<T>& insert (const Array<T>& a, const Array<int>& dims);
+  Array<T>& insert (const Array<T>& a, const Array<int>& dv);
 
   bool is_square (void) const { return (dim1 () == dim2 ()); }
 
   bool is_empty (void) const { return numel () == 0; }
 
   Array<T> transpose (void) const;
 
   const T *data (void) const { return rep->data; }
diff --git a/liboctave/ArrayN.h b/liboctave/ArrayN.h
--- a/liboctave/ArrayN.h
+++ b/liboctave/ArrayN.h
@@ -47,60 +47,60 @@ template <class T>
 class
 ArrayN : public Array<T>
 {
 protected:
 
   static int get_size (const dim_vector& dims)
     { return Array<T>::get_size (dims); }
 
-  ArrayN (T *d, const dim_vector& dims) : Array<T> (d, dims) { }
+  ArrayN (T *d, const dim_vector& dv) : Array<T> (d, dv) { }
 
 public:
 
   // These really need to be protected (and they will be in the
   // future, so don't depend on them being here!), but they can't be
   // until template friends work correctly in g++.
 
   ArrayN (void) : Array<T> () { }
 
-  ArrayN (const dim_vector& dims) : Array<T> (dims) { }
+  ArrayN (const dim_vector& dv) : Array<T> (dv) { }
 
-  ArrayN (const dim_vector& dims, const T& val)
-    : Array<T> (dims) { fill (val); }
+  ArrayN (const dim_vector& dv, const T& val)
+    : Array<T> (dv) { fill (val); }
 
   ArrayN (const Array2<T>& a) : Array<T> (a, a.dims ()) { }
 
   ArrayN (const ArrayN<T>& a) : Array<T> (a, a.dims ()) { }
 
   ArrayN (const Array<T>& a) : Array<T> (a) { }
 
-  ArrayN (const Array<T>& a, const dim_vector& dims) : Array<T> (a, dims) { }
+  ArrayN (const Array<T>& a, const dim_vector& dv) : Array<T> (a, dv) { }
 
   ~ArrayN (void) { }
 
   ArrayN<T>& operator = (const ArrayN<T>& a)
     {
       if (this != &a)
 	Array<T>::operator = (a);
 
       return *this;
     }
 
-  void resize (const dim_vector& dims)
-    { Array<T>::resize_no_fill (dims); }
+  void resize (const dim_vector& dv)
+    { Array<T>::resize_no_fill (dv); }
 
-  void resize (const dim_vector& dims, const T& val)
-    { Array<T>::resize (dims, val); }
+  void resize (const dim_vector& dv, const T& val)
+    { Array<T>::resize (dv, val); }
 
   ArrayN<T> squeeze (void) const { return Array<T>::squeeze (); }
 
-  ArrayN<T>& insert (const ArrayN<T>& a, const dim_vector& dims)
+  ArrayN<T>& insert (const ArrayN<T>& a, const dim_vector& dv)
     {
-      Array<T>::insert (a, dims);
+      Array<T>::insert (a, dv);
       return *this;
     }
 
   ArrayN<T> index (idx_vector& i, int resize_ok = 0,
 		   const T& rfv = resize_fill_value (T ())) const
     {
       Array<T> tmp = Array<T>::index (i, resize_ok, rfv);
       return ArrayN<T> (tmp, tmp.dims ());
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1665,17 +1665,17 @@ ComplexMatrix::solve (const ComplexMatri
 		}
 	      else
 		{
 		  retval = b;
 		  Complex *result = retval.fortran_vec ();
 
 		  int b_nc = b.cols ();
 
-		  char job = 'N';
+		  job = 'N';
 		  F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nr, b_nc, tmp_data, nr,
 					     pipvt, result, b.rows(), info
 					     F77_CHAR_ARG_LEN (1))); 
 
 		  if (f77_exception_encountered)
 		    (*current_liboctave_error_handler)
 		      ("unrecoverable error in zgetrs");
@@ -1816,17 +1816,17 @@ ComplexMatrix::solve (const ComplexColum
 		      ("matrix singular to machine precision, rcond = %g",
 		       rcond);
 		}
 	      else
 		{
 		  retval = b;
 		  Complex *result = retval.fortran_vec ();
 
-		  char job = 'N';
+		  job = 'N';
 		  F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nr, 1, tmp_data, nr, pipvt,
 					     result, b.length(), info
 					     F77_CHAR_ARG_LEN (1))); 
 
 		  if (f77_exception_encountered)
 		    (*current_liboctave_error_handler)
 		      ("unrecoverable error in zgetrs");
@@ -2779,32 +2779,32 @@ ComplexMatrix::column_is_real_only (int 
     }
 
   return retval;	      
 }
 
 ComplexColumnVector
 ComplexMatrix::row_min (void) const
 {
-  Array<int> index;
-  return row_min (index);
+  Array<int> dummy_idx;
+  return row_min (dummy_idx);
 }
 
 ComplexColumnVector
-ComplexMatrix::row_min (Array<int>& index) const
+ComplexMatrix::row_min (Array<int>& idx_arg) const
 {
   ComplexColumnVector result;
 
   int nr = rows ();
   int nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      index.resize (nr);
+      idx_arg.resize (nr);
 
       for (int i = 0; i < nr; i++)
         {
 	  bool real_only = row_is_real_only (i);
 
 	  int idx_j;
 
 	  Complex tmp_min;
@@ -2837,48 +2837,48 @@ ComplexMatrix::row_min (Array<int>& inde
 		  tmp_min = tmp;
 		  abs_min = abs_tmp;
 		}
 	    }
 
 	  if (octave_is_NaN_or_NA (tmp_min))
 	    {
 	      result.elem (i) = Complex_NaN_result;
-	      index.elem (i) = 0;
+	      idx_arg.elem (i) = 0;
 	    }
 	  else
 	    {
 	      result.elem (i) = tmp_min;
-	      index.elem (i) = idx_j;
+	      idx_arg.elem (i) = idx_j;
 	    }
         }
     }
 
   return result;
 }
 
 ComplexColumnVector
 ComplexMatrix::row_max (void) const
 {
-  Array<int> index;
-  return row_max (index);
+  Array<int> dummy_idx;
+  return row_max (dummy_idx);
 }
 
 ComplexColumnVector
-ComplexMatrix::row_max (Array<int>& index) const
+ComplexMatrix::row_max (Array<int>& idx_arg) const
 {
   ComplexColumnVector result;
 
   int nr = rows ();
   int nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      index.resize (nr);
+      idx_arg.resize (nr);
 
       for (int i = 0; i < nr; i++)
         {
 	  bool real_only = row_is_real_only (i);
 
 	  int idx_j;
 
 	  Complex tmp_max;
@@ -2911,48 +2911,48 @@ ComplexMatrix::row_max (Array<int>& inde
 		  tmp_max = tmp;
 		  abs_max = abs_tmp;
 		}
 	    }
 
 	  if (octave_is_NaN_or_NA (tmp_max))
 	    {
 	      result.elem (i) = Complex_NaN_result;
-	      index.elem (i) = 0;
+	      idx_arg.elem (i) = 0;
 	    }
 	  else
 	    {
 	      result.elem (i) = tmp_max;
-	      index.elem (i) = idx_j;
+	      idx_arg.elem (i) = idx_j;
 	    }
         }
     }
 
   return result;
 }
 
 ComplexRowVector
 ComplexMatrix::column_min (void) const
 {
-  Array<int> index;
-  return column_min (index);
+  Array<int> dummy_idx;
+  return column_min (dummy_idx);
 }
 
 ComplexRowVector
-ComplexMatrix::column_min (Array<int>& index) const
+ComplexMatrix::column_min (Array<int>& idx_arg) const
 {
   ComplexRowVector result;
 
   int nr = rows ();
   int nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      index.resize (nc);
+      idx_arg.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
 	  bool real_only = column_is_real_only (j);
 
 	  int idx_i;
 
 	  Complex tmp_min;
@@ -2985,48 +2985,48 @@ ComplexMatrix::column_min (Array<int>& i
 		  tmp_min = tmp;
 		  abs_min = abs_tmp;
 		}
 	    }
 
 	  if (octave_is_NaN_or_NA (tmp_min))
 	    {
 	      result.elem (j) = Complex_NaN_result;
-	      index.elem (j) = 0;
+	      idx_arg.elem (j) = 0;
 	    }
 	  else
 	    {
 	      result.elem (j) = tmp_min;
-	      index.elem (j) = idx_i;
+	      idx_arg.elem (j) = idx_i;
 	    }
         }
     }
 
   return result;
 }
 
 ComplexRowVector
 ComplexMatrix::column_max (void) const
 {
-  Array<int> index;
-  return column_max (index);
+  Array<int> dummy_idx;
+  return column_max (dummy_idx);
 }
 
 ComplexRowVector
-ComplexMatrix::column_max (Array<int>& index) const
+ComplexMatrix::column_max (Array<int>& idx_arg) const
 {
   ComplexRowVector result;
 
   int nr = rows ();
   int nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      index.resize (nc);
+      idx_arg.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
 	  bool real_only = column_is_real_only (j);
 
 	  int idx_i;
 
 	  Complex tmp_max;
@@ -3059,22 +3059,22 @@ ComplexMatrix::column_max (Array<int>& i
 		  tmp_max = tmp;
 		  abs_max = abs_tmp;
 		}
 	    }
 
 	  if (octave_is_NaN_or_NA (tmp_max))
 	    {
 	      result.elem (j) = Complex_NaN_result;
-	      index.elem (j) = 0;
+	      idx_arg.elem (j) = 0;
 	    }
 	  else
 	    {
 	      result.elem (j) = tmp_max;
-	      index.elem (j) = idx_i;
+	      idx_arg.elem (j) = idx_i;
 	    }
         }
     }
 
   return result;
 }
 
 // i/o
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -38,20 +38,20 @@ Software Foundation, 59 Temple Place - S
 
 class
 ComplexNDArray : public MArrayN<Complex>
 {
 public:
   
   ComplexNDArray (void) : MArrayN<Complex> () { }
 
-  ComplexNDArray (const dim_vector& dims) : MArrayN<Complex> (dims) { }
+  ComplexNDArray (const dim_vector& dv) : MArrayN<Complex> (dv) { }
 
-  ComplexNDArray (const dim_vector& dims, const Complex& val)
-    : MArrayN<Complex> (dims, val) { }
+  ComplexNDArray (const dim_vector& dv, const Complex& val)
+    : MArrayN<Complex> (dv, val) { }
   
   ComplexNDArray (const ComplexNDArray& a) : MArrayN<Complex> (a) { }
 
   ComplexNDArray (const ComplexMatrix& a) : MArrayN<Complex> (a) { }
 
   ComplexNDArray (const MArrayN<Complex>& a) : MArrayN<Complex> (a) { }
 
   ComplexNDArray (const ArrayN<Complex>& a) : MArrayN<Complex> (a) { }
@@ -103,18 +103,18 @@ public:
 
   static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
 private:
 
-  ComplexNDArray (Complex *d, dim_vector& dims)
-    : MArrayN<Complex> (d, dims) { }
+  ComplexNDArray (Complex *d, dim_vector& dv)
+    : MArrayN<Complex> (d, dv) { }
 };
 
 NDS_CMP_OP_DECLS (ComplexNDArray, Complex)
 NDS_BOOL_OP_DECLS (ComplexNDArray, Complex)
 
 SND_CMP_OP_DECLS (Complex, ComplexNDArray)
 SND_BOOL_OP_DECLS (Complex, ComplexNDArray)
 
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -329,19 +329,16 @@ operator * (const ComplexRowVector& v, c
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
   if (a_nr != len)
     gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
-      int a_nr = a.rows ();
-      int a_nc = a.cols ();
-
       if (len == 0)
 	retval.resize (a_nc, 0.0);
       else
 	{
 	  // Transpose A to form A'*x == (x'*A)'
 
 	  int ld = a_nr;
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,9 +1,18 @@
-2003-11-08  John Eaton  <osc0383@coe3.osc.edu>
+2003-11-10  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* Array.cc, Array.h, ArrayN.h, CMatrix.cc, CNDArray.h,
+	CRowVector.cc, CmplxQR.cc, CollocWt.h, DASPK.h, DASRT.h, DASSL.h,
+	FEGrid.cc, LP.h, LSODE.h, MArrayN.h, ODE.h, ODES.h, ODESSA.cc,
+	boolNDArray.h, chNDArray.h, dMatrix.cc, dNDArray.h, dRowVector.cc,
+	dbleQR.cc, kpse.cc, oct-rl-hist.c, str-vec.cc, str-vec.h:
+	Avoid -Wshadow warnings.
+
+2003-11-08  John Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Array.h (Array<T>::nil_rep): Qualify return type with typename.
 
 	* mk-ops.awk: Delete elements of bool_headers array individually.
 
 2003-11-07  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Array.cc (maybe_delete_elements): Rename arg idx to ra_idx.
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -119,17 +119,17 @@ ComplexQR::init (const ComplexMatrix& a,
 	    {
 	      int limit = j < min_mn-1 ? j : min_mn-1;
 	      for (int i = 0; i <= limit; i++)
 		r.elem (i, j) = A_fact.elem (i, j);
 	    }
 
 	  lwork = 32 * n2;
 	  work.resize (lwork);
-	  Complex *pwork = work.fortran_vec ();
+	  pwork = work.fortran_vec ();
 
 	  F77_XFCN (zungqr, ZUNGQR, (m, n2, min_mn, tmp_data, m, ptau,
 				     pwork, lwork, info));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in zungqr");
 	  else
diff --git a/liboctave/CollocWt.h b/liboctave/CollocWt.h
--- a/liboctave/CollocWt.h
+++ b/liboctave/CollocWt.h
@@ -40,27 +40,27 @@ public:
   CollocWt (void)
     : n (0), inc_left (0), inc_right (0), lb (0.0), rb (1.0),
       Alpha (0.0), Beta (0.0), r (), q (), A (), B (), initialized (0) { }
 
   CollocWt (int nc, int il, int ir)
     : n (nc), inc_left (il), inc_right (ir), lb (0.0), rb (1.0),
       Alpha (0.0), Beta (0.0), r (), q (), A (), B (), initialized (0) { }
 
-  CollocWt (int nc, int il, int ir, double l, double r)
-    : n (nc), inc_left (il), inc_right (ir), lb (l), rb (r),
+  CollocWt (int nc, int il, int ir, double l, double rr)
+    : n (nc), inc_left (il), inc_right (ir), lb (l), rb (rr),
       Alpha (0.0), Beta (0.0), r (), q (), A (), B (), initialized (0) { }
 
   CollocWt (int nc, double a, double b, int il, int ir)
     : n (nc), inc_left (il), inc_right (ir), lb (0.0), rb (1.0),
       Alpha (a), Beta (b), initialized (0) { }
 
   CollocWt (int nc, double a, double b, int il, int ir,
-		      double l, double r)  
-    : n (nc), inc_left (il), inc_right (ir), lb (l), rb (r),
+		      double ll, double rr)  
+    : n (nc), inc_left (il), inc_right (ir), lb (ll), rb (rr),
       Alpha (a), Beta (b), r (), q (), A (), B (), initialized (0) { }
 
   CollocWt (const CollocWt& a)
     : n (a.n), inc_left (a.inc_left), inc_right (a.inc_right),
       lb (a.lb), rb (a.rb), Alpha (a.Alpha), Beta (a.Beta),
       r (a.r), q (a.q), A (a.A), B (a.B),
       initialized (a.initialized) { } 
 
@@ -79,19 +79,19 @@ public:
 	  B = a.B;
 	  initialized = a.initialized;
 	}
       return *this;
     }
 
   ~CollocWt (void) { }
 
-  CollocWt& resize (int ncol)
+  CollocWt& resize (int nc)
     {
-      n = ncol;
+      n = nc;
       initialized = 0;
       return *this;
     }
 
   CollocWt& add_left (void)
     {
       inc_left = 1;
       initialized = 0;
diff --git a/liboctave/DASPK.h b/liboctave/DASPK.h
--- a/liboctave/DASPK.h
+++ b/liboctave/DASPK.h
@@ -34,22 +34,22 @@ Software Foundation, 59 Temple Place - S
 
 class
 DASPK : public DAE, public DASPK_options
 {
 public:
 
   DASPK (void) : DAE (), DASPK_options (), initialized (false) { }
 
-  DASPK (const ColumnVector& state, double time, DAEFunc& f)
-    : DAE (state, time, f), DASPK_options (), initialized (false) { }
+  DASPK (const ColumnVector& s, double tm, DAEFunc& f)
+    : DAE (s, tm, f), DASPK_options (), initialized (false) { }
 
-  DASPK (const ColumnVector& state, const ColumnVector& deriv,
-	 double time, DAEFunc& f)
-    : DAE (state, deriv, time, f), DASPK_options (), initialized (false) { }
+  DASPK (const ColumnVector& s, const ColumnVector& deriv,
+	 double tm, DAEFunc& f)
+    : DAE (s, deriv, tm, f), DASPK_options (), initialized (false) { }
 
   ~DASPK (void) { }
 
   ColumnVector do_integrate (double t);
 
   Matrix do_integrate (const ColumnVector& tout);
 
   Matrix do_integrate (const ColumnVector& tout, const ColumnVector& tcrit); 
diff --git a/liboctave/DASRT.h b/liboctave/DASRT.h
--- a/liboctave/DASRT.h
+++ b/liboctave/DASRT.h
@@ -71,22 +71,22 @@ private:
 
 class
 DASRT : public DAERT, public DASRT_options
 {
 public:
 
   DASRT (void) : DAERT (), DASRT_options (), initialized (false) { }
 
-  DASRT (const ColumnVector& state, double time, DAERTFunc& f)
-    : DAERT (state, time, f), DASRT_options (), initialized (false) { }
+  DASRT (const ColumnVector& s, double tm, DAERTFunc& f)
+    : DAERT (s, tm, f), DASRT_options (), initialized (false) { }
 
-  DASRT (const ColumnVector& state, const ColumnVector& deriv,
-	 double time, DAERTFunc& f)
-    : DAERT (state, deriv, time, f), DASRT_options (), initialized (false) { }
+  DASRT (const ColumnVector& s, const ColumnVector& deriv,
+	 double tm, DAERTFunc& f)
+    : DAERT (s, deriv, tm, f), DASRT_options (), initialized (false) { }
 
   ~DASRT (void) { }
 
   DASRT_result integrate (const ColumnVector& tout);
 
   DASRT_result integrate (const ColumnVector& tout,
 			  const ColumnVector& tcrit); 
 
diff --git a/liboctave/DASSL.h b/liboctave/DASSL.h
--- a/liboctave/DASSL.h
+++ b/liboctave/DASSL.h
@@ -34,22 +34,22 @@ Software Foundation, 59 Temple Place - S
 
 class
 DASSL : public DAE, public DASSL_options
 {
 public:
 
   DASSL (void) : DAE (), DASSL_options (), initialized (false) { }
 
-  DASSL (const ColumnVector& state, double time, DAEFunc& f)
-    : DAE (state, time, f), DASSL_options (), initialized (false) { }
+  DASSL (const ColumnVector& s, double tm, DAEFunc& f)
+    : DAE (s, tm, f), DASSL_options (), initialized (false) { }
 
-  DASSL (const ColumnVector& state, const ColumnVector& deriv,
-	 double time, DAEFunc& f)
-    : DAE (state, deriv, time, f), DASSL_options (), initialized (false) { }
+  DASSL (const ColumnVector& s, const ColumnVector& deriv,
+	 double tm, DAEFunc& f)
+    : DAE (s, deriv, tm, f), DASSL_options (), initialized (false) { }
 
   ~DASSL (void) { }
 
   ColumnVector do_integrate (double t);
 
   Matrix do_integrate (const ColumnVector& tout);
 
   Matrix do_integrate (const ColumnVector& tout, const ColumnVector& tcrit); 
diff --git a/liboctave/FEGrid.cc b/liboctave/FEGrid.cc
--- a/liboctave/FEGrid.cc
+++ b/liboctave/FEGrid.cc
@@ -58,30 +58,30 @@ FEGrid::FEGrid (int nel, double width)
     }
 
   elem.resize (nel+1);
 
   for (int i = 0; i <= nel; i++)
     elem.elem (i) = i * width;
 }
 
-FEGrid::FEGrid (int nel, double left, double right)
+FEGrid::FEGrid (int nel, double l, double r)
 {
   if (nel < 1)
     {
       nel_error ();
       return;
     }
 
   elem.resize (nel+1);
 
-  double width = (right - left) / nel;
+  double width = (r - l) / nel;
 
   for (int i = 0; i <= nel; i++)
-    elem.elem (i) = i * width + left;
+    elem.elem (i) = i * width + l;
 
   check_grid ();
 }
 
 int
 FEGrid::element (double x) const
 {
   if (! in_bounds (x))
diff --git a/liboctave/LP.h b/liboctave/LP.h
--- a/liboctave/LP.h
+++ b/liboctave/LP.h
@@ -29,59 +29,59 @@ Software Foundation, 59 Temple Place - S
 #include "base-min.h"
 
 class
 octave_LP : public base_minimizer
 {
 public:
 
   octave_LP (void)
-    : base_minimizer (), c (), bnds (), lc () { }
+    : base_minimizer (), cvec (), bnds (), lin_constr () { }
 
-  octave_LP (const ColumnVector& c_arg)
-    : base_minimizer (), c (c_arg), bnds (), lc () { }
+  octave_LP (const ColumnVector& c)
+    : base_minimizer (), cvec (c), bnds (), lin_constr () { }
 
-  octave_LP (const ColumnVector& c_arg, const Bounds& b)
-    : base_minimizer (), c (c_arg), bnds (b), lc () { }
+  octave_LP (const ColumnVector& c, const Bounds& b)
+    : base_minimizer (), cvec (c), bnds (b), lin_constr () { }
 
-  octave_LP (const ColumnVector& c_arg, const Bounds& b, const LinConst& l)
-    : base_minimizer (), c (c_arg), bnds (b), lc (l) { }
+  octave_LP (const ColumnVector& c, const Bounds& b, const LinConst& l)
+    : base_minimizer (), cvec (c), bnds (b), lin_constr (l) { }
 
-  octave_LP (const ColumnVector& c_arg, const LinConst& l)
-    : base_minimizer (), c (c_arg), bnds (), lc (l) { }
+  octave_LP (const ColumnVector& c, const LinConst& l)
+    : base_minimizer (), cvec (c), bnds (), lin_constr (l) { }
 
   octave_LP (const octave_LP& a)
-    : base_minimizer (a), c (a.c), bnds (a.bnds), lc (a.lc) { }
+    : base_minimizer (a), cvec (a.cvec), bnds (a.bnds), lin_constr (a.lin_constr) { }
 
   octave_LP& operator = (const octave_LP& a)
     {
       if (this != &a)
 	{
 	  base_minimizer::operator = (a);
 
-	  c = a.c;
+	  cvec = a.cvec;
 	  bnds = a.bnds;
-	  lc = a.lc;
+	  lin_constr = a.lin_constr;
 	}
       return *this;
     }
 
   ~octave_LP (void) { }
 
-  ColumnVector linear_obj_coeff (void) const { return c; }
+  ColumnVector linear_obj_coeff (void) const { return cvec; }
 
   Bounds bounds (void) const { return bnds; }
 
-  LinConst linear_constraints (void) const { return lc; }
+  LinConst linear_constraints (void) const { return lin_constr; }
 
 protected:
 
-  ColumnVector c;
+  ColumnVector cvec;
   Bounds bnds;
-  LinConst lc;
+  LinConst lin_constr;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/LSODE.h b/liboctave/LSODE.h
--- a/liboctave/LSODE.h
+++ b/liboctave/LSODE.h
@@ -34,18 +34,18 @@ Software Foundation, 59 Temple Place - S
 
 class
 LSODE : public ODE, public LSODE_options
 {
 public:
 
   LSODE (void) : ODE (), LSODE_options (), initialized (false) { }
 
-  LSODE (const ColumnVector& state, double time, const ODEFunc& f)
-    : ODE (state, time, f), LSODE_options (), initialized (false) { }
+  LSODE (const ColumnVector& s, double tm, const ODEFunc& f)
+    : ODE (s, tm, f), LSODE_options (), initialized (false) { }
 
   ~LSODE (void) { }
 
   ColumnVector do_integrate (double t);
 
   Matrix do_integrate (const ColumnVector& tout);
 
   Matrix do_integrate (const ColumnVector& tout, const ColumnVector& tcrit);
diff --git a/liboctave/MArrayN.h b/liboctave/MArrayN.h
--- a/liboctave/MArrayN.h
+++ b/liboctave/MArrayN.h
@@ -41,25 +41,25 @@ Software Foundation, 59 Temple Place - S
 MARRAY_OPS_FORWARD_DECLS (MArrayN)
 
 template <class T>
 class
 MArrayN : public ArrayN<T>
 {
 protected:
 
-  MArrayN (T *d, const dim_vector& dims) : ArrayN<T> (d, dims) { }
+  MArrayN (T *d, const dim_vector& dv) : ArrayN<T> (d, dv) { }
 
 public:
   
   MArrayN (void) : ArrayN<T> () {}
   
-  MArrayN (const dim_vector& dims) : ArrayN<T> (dims) { }
+  MArrayN (const dim_vector& dv) : ArrayN<T> (dv) { }
   
-  MArrayN (const dim_vector& dims, const T& val) : ArrayN<T> (dims, val) { }
+  MArrayN (const dim_vector& dv, const T& val) : ArrayN<T> (dv, val) { }
 
   MArrayN (const Array2<T>& a) : ArrayN<T> (a) { }
 
   MArrayN (const ArrayN<T>& a) : ArrayN<T> (a) { }
 
   MArrayN (const MArrayN<T>& a) : ArrayN<T> (a) { }
 
   ~MArrayN (void) { }
diff --git a/liboctave/ODE.h b/liboctave/ODE.h
--- a/liboctave/ODE.h
+++ b/liboctave/ODE.h
@@ -29,18 +29,18 @@ Software Foundation, 59 Temple Place - S
 class
 ODE : public base_diff_eqn, public ODEFunc
 {
 public:
 
   ODE (void)
     : base_diff_eqn (), ODEFunc () { }
 
-  ODE (const ColumnVector& state, double time, const ODEFunc& f)
-    : base_diff_eqn (state, time), ODEFunc (f) { }
+  ODE (const ColumnVector& s, double tm, const ODEFunc& f)
+    : base_diff_eqn (s, tm), ODEFunc (f) { }
 
   ODE (const ODE& a)
     : base_diff_eqn (a), ODEFunc (a) { }
 
   ODE& operator = (const ODE& a)
     {
       if (this != &a)
 	{
diff --git a/liboctave/ODES.h b/liboctave/ODES.h
--- a/liboctave/ODES.h
+++ b/liboctave/ODES.h
@@ -33,22 +33,22 @@ Software Foundation, 59 Temple Place - S
 class
 ODES : public base_diff_eqn, public ODESFunc
 {
 public:
 
   ODES (void)
     : base_diff_eqn (), ODESFunc (), theta () { }
 
-  ODES (const ColumnVector& x, double t, ODESFunc& f)
-    : base_diff_eqn (x, t), ODESFunc (f), xdot (x.length (), 0.0), theta () { }
+  ODES (const ColumnVector& s, double tm, ODESFunc& f)
+    : base_diff_eqn (s, tm), ODESFunc (f), xdot (s.length (), 0.0), theta () { }
 
-  ODES (const ColumnVector& x, const ColumnVector& xtheta, double t,
+  ODES (const ColumnVector& s, const ColumnVector& xtheta, double tm,
 	ODESFunc& f)
-    : base_diff_eqn (x, t), ODESFunc (f), xdot (x.length (), 0.0),
+    : base_diff_eqn (s, tm), ODESFunc (f), xdot (s.length (), 0.0),
       theta (xtheta) { }
 
   ODES (const ODES& a)
     : base_diff_eqn (a), ODESFunc (a), theta (a.theta) { }
 
   ODES& operator = (const ODES& a)
     {
       if (this != &a)
diff --git a/liboctave/ODESSA.cc b/liboctave/ODESSA.cc
--- a/liboctave/ODESSA.cc
+++ b/liboctave/ODESSA.cc
@@ -187,18 +187,18 @@ ODESSA::ODESSA (void) : ODES (), ODESSA_
   iopt(1) = isopt;
   npar = 0;
   neq(0) = n;
   neq(1) = npar;
 
   sanity_checked = false;
 }
 
-ODESSA::ODESSA (const ColumnVector& state, double time, ODESFunc& f)
-  : ODES (state, time, f), ODESSA_options ()
+ODESSA::ODESSA (const ColumnVector& s, double tm, ODESFunc& f)
+  : ODES (s, tm, f), ODESSA_options ()
 {
   initialized = false;
 
   neq.resize(2);
   n = size ();
 
   iopt.resize(4);
   itask = 1;
@@ -210,24 +210,24 @@ ODESSA::ODESSA (const ColumnVector& stat
 
   npar = 0;
   neq(0) = n;
   neq(1) = npar;
 
   y.resize (n, 1, 0.0);
 }
 
-ODESSA::ODESSA (const ColumnVector& state, const ColumnVector& xtheta,
-		const Matrix& sensitivity_guess, double time, ODESFunc& f)
-  : ODES (state, xtheta, time, f)
+ODESSA::ODESSA (const ColumnVector& s, const ColumnVector& xtheta,
+		const Matrix& sensitivity_guess, double tm, ODESFunc& f)
+  : ODES (s, xtheta, tm, f)
 {
   initialized = false;
 
   neq.resize(2);
-  n = state.length();
+  n = s.length();
   npar = xtheta.length();
 
   neq(0) = n;
   neq(1) = npar;
 
   sx0 = sensitivity_guess;
   par.resize (npar);
 
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -38,20 +38,20 @@ Software Foundation, 59 Temple Place - S
 
 class
 boolNDArray : public ArrayN<bool>
 {
 public:
   
   boolNDArray (void) : ArrayN<bool> () { }
 
-  boolNDArray (dim_vector& dims) : ArrayN<bool> (dims) { }
+  boolNDArray (dim_vector& dv) : ArrayN<bool> (dv) { }
 
-  boolNDArray (dim_vector& dims, const bool& val)
-    : ArrayN<bool> (dims, val) { }
+  boolNDArray (dim_vector& dv, const bool& val)
+    : ArrayN<bool> (dv, val) { }
   
   boolNDArray (const boolNDArray& a) : ArrayN<bool> (a) { }
 
   boolNDArray (const boolMatrix& a) : ArrayN<bool> (a) { }
 
   boolNDArray (const Array2<bool>& a) : ArrayN<bool> (a) { }
 
   boolNDArray (const ArrayN<bool>& a) : ArrayN<bool> (a) { }
@@ -89,17 +89,17 @@ public:
 
   static bool resize_fill_value (void) { return false; }
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
 private:
 
-  boolNDArray (bool *d, dim_vector& dims) : ArrayN<bool> (d, dims) { }
+  boolNDArray (bool *d, dim_vector& dv) : ArrayN<bool> (d, dv) { }
 };
 
 NDND_CMP_OP_DECLS (boolNDArray, boolNDArray)
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -38,19 +38,19 @@ Software Foundation, 59 Temple Place - S
 
 class
 charNDArray : public MArrayN<char>
 {
 public:
   
   charNDArray (void) : MArrayN<char> () { }
 
-  charNDArray (dim_vector& dims) : MArrayN<char> (dims) { }
+  charNDArray (dim_vector& dv) : MArrayN<char> (dv) { }
 
-  charNDArray (dim_vector& dims, char val) : MArrayN<char> (dims, val) { }
+  charNDArray (dim_vector& dv, char val) : MArrayN<char> (dv, val) { }
   
   charNDArray (const charNDArray& a) : MArrayN<char> (a) { }
 
   charNDArray (const charMatrix& a) : MArrayN<char> (a) { }
 
   charNDArray (char c) : MArrayN<char> (charMatrix (c)) { }
 
   charNDArray (const char *s) : MArrayN<char> (charMatrix (s)) { }
@@ -87,17 +87,17 @@ public:
 
   // friend std::ostream& operator << (std::ostream& os, const charNDArray& a);
   // friend std::istream& operator >> (std::istream& is, charNDArray& a);
 
   static char resize_fill_value (void) { return '\0'; }
 
 private:
 
-  charNDArray (char *d, dim_vector& dims) : MArrayN<char> (d, dims) { }
+  charNDArray (char *d, dim_vector& dv) : MArrayN<char> (d, dv) { }
 };
 
 MARRAY_FORWARD_DEFS (MArrayN, charNDArray, char)
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -1302,17 +1302,17 @@ Matrix::solve (const Matrix& b, int& inf
 		}
 	      else
 		{
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
 		  int b_nc = b.cols ();
 
-		  char job = 'N';
+		  job = 'N';
 		  F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nr, b_nc, tmp_data, nr,
 					     pipvt, result, b.rows(), info
 					     F77_CHAR_ARG_LEN (1)));
 		
 		  if (f77_exception_encountered)
 		    (*current_liboctave_error_handler)
 		      ("unrecoverable error in dgetrs");
@@ -1451,17 +1451,17 @@ Matrix::solve (const ColumnVector& b, in
 		      ("matrix singular to machine precision, rcond = %g",
 		       rcond);
 		}
 	      else
 		{
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
-		  char job = 'N';
+		  job = 'N';
 		  F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nr, 1, tmp_data, nr, pipvt,
 					     result, b.length(), info
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (f77_exception_encountered)
 		    (*current_liboctave_error_handler)
 		      ("unrecoverable error in dgetrs");
@@ -2259,32 +2259,32 @@ Matrix::diag (int k) const
       ("diag: requested diagonal out of range");
 
   return d;
 }
 
 ColumnVector
 Matrix::row_min (void) const
 {
-  Array<int> index;
-  return row_min (index);
+  Array<int> dummy_idx;
+  return row_min (dummy_idx);
 }
 
 ColumnVector
-Matrix::row_min (Array<int>& index) const
+Matrix::row_min (Array<int>& idx_arg) const
 {
   ColumnVector result;
 
   int nr = rows ();
   int nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      index.resize (nr);
+      idx_arg.resize (nr);
 
       for (int i = 0; i < nr; i++)
         {
 	  int idx_j;
 
 	  double tmp_min = octave_NaN;
 
 	  for (idx_j = 0; idx_j < nc; idx_j++)
@@ -2304,42 +2304,42 @@ Matrix::row_min (Array<int>& index) cons
 	      else if (tmp < tmp_min)
 		{
 		  idx_j = j;
 		  tmp_min = tmp;
 		}
 	    }
 
 	  result.elem (i) = tmp_min;
-	  index.elem (i) = octave_is_NaN_or_NA (tmp_min) ? 0 : idx_j;
+	  idx_arg.elem (i) = octave_is_NaN_or_NA (tmp_min) ? 0 : idx_j;
         }
     }
 
   return result;
 }
 
 ColumnVector
 Matrix::row_max (void) const
 {
-  Array<int> index;
-  return row_max (index);
+  Array<int> dummy_idx;
+  return row_max (dummy_idx);
 }
 
 ColumnVector
-Matrix::row_max (Array<int>& index) const
+Matrix::row_max (Array<int>& idx_arg) const
 {
   ColumnVector result;
 
   int nr = rows ();
   int nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      index.resize (nr);
+      idx_arg.resize (nr);
 
       for (int i = 0; i < nr; i++)
         {
 	  int idx_j;
 
 	  double tmp_max = octave_NaN;
 
 	  for (idx_j = 0; idx_j < nc; idx_j++)
@@ -2359,42 +2359,42 @@ Matrix::row_max (Array<int>& index) cons
 	      else if (tmp > tmp_max)
 		{
 		  idx_j = j;
 		  tmp_max = tmp;
 		}
 	    }
 
 	  result.elem (i) = tmp_max;
-	  index.elem (i) = octave_is_NaN_or_NA (tmp_max) ? 0 : idx_j;
+	  idx_arg.elem (i) = octave_is_NaN_or_NA (tmp_max) ? 0 : idx_j;
         }
     }
 
   return result;
 }
 
 RowVector
 Matrix::column_min (void) const
 {
-  Array<int> index;
-  return column_min (index);
+  Array<int> dummy_idx;
+  return column_min (dummy_idx);
 }
 
 RowVector
-Matrix::column_min (Array<int>& index) const
+Matrix::column_min (Array<int>& idx_arg) const
 {
   RowVector result;
 
   int nr = rows ();
   int nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      index.resize (nc);
+      idx_arg.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
 	  int idx_i;
 
 	  double tmp_min = octave_NaN;
 
 	  for (idx_i = 0; idx_i < nr; idx_i++)
@@ -2414,42 +2414,42 @@ Matrix::column_min (Array<int>& index) c
 	      else if (tmp < tmp_min)
 		{
 		  idx_i = i;
 		  tmp_min = tmp;
 		}
 	    }
 
 	  result.elem (j) = tmp_min;
-	  index.elem (j) = octave_is_NaN_or_NA (tmp_min) ? 0 : idx_i;
+	  idx_arg.elem (j) = octave_is_NaN_or_NA (tmp_min) ? 0 : idx_i;
         }
     }
 
   return result;
 }
 
 RowVector
 Matrix::column_max (void) const
 {
-  Array<int> index;
-  return column_max (index);
+  Array<int> dummy_idx;
+  return column_max (dummy_idx);
 }
 
 RowVector
-Matrix::column_max (Array<int>& index) const
+Matrix::column_max (Array<int>& idx_arg) const
 {
   RowVector result;
 
   int nr = rows ();
   int nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      index.resize (nc);
+      idx_arg.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
 	  int idx_i;
 
 	  double tmp_max = octave_NaN;
 
 	  for (idx_i = 0; idx_i < nr; idx_i++)
@@ -2469,17 +2469,17 @@ Matrix::column_max (Array<int>& index) c
 	      else if (tmp > tmp_max)
 		{
 		  idx_i = i;
 		  tmp_max = tmp;
 		}
 	    }
 
 	  result.elem (j) = tmp_max;
-	  index.elem (j) = octave_is_NaN_or_NA (tmp_max) ? 0 : idx_i;
+	  idx_arg.elem (j) = octave_is_NaN_or_NA (tmp_max) ? 0 : idx_i;
         }
     }
 
   return result;
 }
 
 std::ostream&
 operator << (std::ostream& os, const Matrix& a)
@@ -2693,41 +2693,41 @@ Matrix::read (std::istream& is, int nr, 
     }
 
   int retval = -1;
 
   bool ok = true;
 
   int count = 0;
 
-  double *data = 0;
+  double *dat = 0;
   int max_size = 0;
 
   int final_nr = 0;
   int final_nc = 0;
 
   if (nr > 0)
     {
       if (nc > 0)
 	{
 	  resize (nr, nc, 0.0);
-	  data = fortran_vec ();
+	  dat = fortran_vec ();
 	  max_size = nr * nc;
 	}
       else
 	{
 	  resize (nr, 32, 0.0);
-	  data = fortran_vec ();
+	  dat = fortran_vec ();
 	  max_size = nr * 32;
 	}
     }
   else
     {
       resize (32, 1, 0.0);
-      data = fortran_vec ();
+      dat = fortran_vec ();
       max_size = 32;
     }
 
   oct_mach_info::float_format native_flt_fmt
     = oct_mach_info::float_format ();
 
   bool do_float_conversion = (flt_fmt != native_flt_fmt);
 
@@ -2769,20 +2769,20 @@ Matrix::read (std::istream& is, int nr, 
 		    {
 		      max_size *= 2;
 
 		      if (nr > 0)
 			resize (nr, max_size / nr, 0.0);
 		      else
 			resize (max_size, 1, 0.0);
 
-		      data = fortran_vec ();
+		      dat = fortran_vec ();
 		    }
 
-		  data[count++] = tmp;
+		  dat[count++] = tmp;
 		}
 
 	      if (skip != 0)
 		is.seekg (skip, std::ios::cur);
 
 	      if (is.eof ())
 		{
 		  if (nr > 0)
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -38,20 +38,20 @@ Software Foundation, 59 Temple Place - S
 
 class
 NDArray : public MArrayN<double>
 {
 public:
   
   NDArray (void) : MArrayN<double> () { }
 
-  NDArray (const dim_vector& dims) : MArrayN<double> (dims) { }
+  NDArray (const dim_vector& dv) : MArrayN<double> (dv) { }
 
-  NDArray (const dim_vector& dims, double val)
-    : MArrayN<double> (dims, val) { }
+  NDArray (const dim_vector& dv, double val)
+    : MArrayN<double> (dv, val) { }
   
   NDArray (const NDArray& a) : MArrayN<double> (a) { }
 
   NDArray (const Matrix& a) : MArrayN<double> (a) { }
 
   NDArray (const MArrayN<double>& a) : MArrayN<double> (a) { }
 
   NDArray (const ArrayN<double>& a) : MArrayN<double> (a) { }
@@ -101,17 +101,17 @@ public:
 
   static double resize_fill_value (void) { return 0; }
 
   bool any_element_is_negative (bool = false) const;
   bool all_integers (double& max_val, double& min_val) const;
 
 private:
 
-  NDArray (double *d, dim_vector& dims) : MArrayN<double> (d, dims) { }
+  NDArray (double *d, dim_vector& dv) : MArrayN<double> (d, dv) { }
 };
 
 NDS_CMP_OP_DECLS (NDArray, double)
 NDS_BOOL_OP_DECLS (NDArray, double)
 
 SND_CMP_OP_DECLS (double, NDArray)
 SND_BOOL_OP_DECLS (double, NDArray)
 
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -205,19 +205,16 @@ operator * (const RowVector& v, const Ma
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
   if (a_nr != len)
     gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
-      int a_nr = a.rows ();
-      int a_nc = a.cols ();
-
       if (len == 0)
 	retval.resize (a_nc, 0.0);
       else
 	{
 	  // Transpose A to form A'*x == (x'*A)'
 
 	  int ld = a_nr;
 
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -110,17 +110,17 @@ QR::init (const Matrix& a, QR::type qr_t
 	    {
 	      int limit = j < min_mn-1 ? j : min_mn-1;
 	      for (int i = 0; i <= limit; i++)
 		r.elem (i, j) = tmp_data[m*j+i];
 	    }
 
 	  lwork = 32 * n2;
 	  work.resize (lwork);
-	  double *pwork = work.fortran_vec ();
+	  pwork = work.fortran_vec ();
 
 	  F77_XFCN (dorgqr, DORGQR, (m, n2, min_mn, tmp_data, m, ptau,
 				     pwork, lwork, info));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in dorgqr");
 	  else
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -2514,20 +2514,20 @@ kpse_db_search (const std::string& name_
 		     around this with aliases, but this is pretty easy
 		     and shouldn't hurt.  The upshot is that if one of
 		     the aliases actually exists, we use that.  */
 
 		  int aliases_len = aliases.length ();
 
 		  for (int k = 1; k < aliases_len && found.empty (); k++)
 		    {
-		      std::string atry = db_dirs[j] + aliases[k];
-		      std::string tmp = kpse_readable_file (atry);
+		      std::string aatry = db_dirs[j] + aliases[k];
+		      tmp = kpse_readable_file (aatry);
 		      if (! tmp.empty ())
-			found = atry;
+			found = aatry;
 		    }
 		}
 
 	      /* If we have a real file, add it to the list, maybe done.  */
 	      if (! found.empty ())
 		{
 		  ret.append (found);
 
diff --git a/liboctave/oct-rl-hist.c b/liboctave/oct-rl-hist.c
--- a/liboctave/oct-rl-hist.c
+++ b/liboctave/oct-rl-hist.c
@@ -23,16 +23,17 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #if defined (USE_READLINE)
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 
 #include <readline/history.h>
 
 void
 octave_add_history (const char *line)
 {
   add_history (line);
 }
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -167,45 +167,45 @@ string_vector::list_in_columns (std::ost
 
   // Allow at least two spaces between names.
 
   max_name_length += 2;
 
   // Calculate the maximum number of columns that will fit.
 
   int line_length = command_editor::terminal_cols ();
-  int cols = line_length / max_name_length;
-  if (cols == 0)
-    cols = 1;
+  int nc = line_length / max_name_length;
+  if (nc == 0)
+    nc = 1;
 
   // Calculate the number of rows that will be in each column except
   // possibly  for a short column on the right.
 
-  int rows = total_names / cols + (total_names % cols != 0);
+  int nr = total_names / nc + (total_names % nc != 0);
 
   // Recalculate columns based on rows.
 
-  cols = total_names / rows + (total_names % rows != 0);
+  nc = total_names / nr + (total_names % nr != 0);
 
   int count;
-  for (int row = 0; row < rows; row++)
+  for (int row = 0; nr < nr; row++)
     {
       count = row;
       int pos = 0;
 
       // Print the next row.
 
       while (1)
 	{
 	  std::string nm = elem (count);
 
 	  os << nm;
 	  int name_length = nm.length ();
 
-	  count += rows;
+	  count += nr;
 	  if (count >= total_names)
 	    break;
 
 	  int spaces_to_pad = max_name_length - name_length;
 	  for (int i = 0; i < spaces_to_pad; i++)
 	    os << " ";
 	  pos += max_name_length;
 	}
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -76,21 +76,21 @@ public:
   }
 
   std::string& operator[] (int i) { return Array<std::string>::elem (i); }
 
   std::string operator[] (int i) const { return Array<std::string>::elem (i); }
 
   static int compare (const void *a_arg, const void *b_arg);
 
-  string_vector& qsort (bool make_unique = false)
+  string_vector& qsort (bool make_uniq = false)
   {
     Array<std::string>::qsort (compare);
 
-    if (make_unique)
+    if (make_uniq)
       uniq ();
 
     return *this;
   }
 
   string_vector& uniq (void);
 
   string_vector& append (const std::string& s);
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -42,63 +42,63 @@ Cell::Cell (const string_vector& sv)
       resize_no_fill (n, 1);
 
       for (int i = 0; i < n; i++)
 	elem(i,0) = sv[i];
     }
 }
 
 Cell
-Cell::index (const octave_value_list& idx, bool resize_ok) const
+Cell::index (const octave_value_list& idx_arg, bool resize_ok) const
 {
   Cell retval;
 
-  int n = idx.length ();
+  int n = idx_arg.length ();
 
   switch (n)
     {
     case 1:
       {
-	idx_vector i = idx(0).index_vector ();
+	idx_vector i = idx_arg(0).index_vector ();
 
 	retval = index (i, resize_ok);
       }
       break;
 
     case 2:
       {
-	idx_vector i = idx(0).index_vector ();
-	idx_vector j = idx(1).index_vector ();
+	idx_vector i = idx_arg(0).index_vector ();
+	idx_vector j = idx_arg(1).index_vector ();
 
 	retval = index (i, j, resize_ok);
       }
       break;
 
     default:
       {
 	Array<idx_vector> iv (n);
 
 	for (int i = 0; i < n; i++)
-	  iv(i) = idx(i).index_vector ();
+	  iv(i) = idx_arg(i).index_vector ();
 
 	retval = index (iv, resize_ok);
       }
       break;
     }
 
   return retval;
 }
 
 Cell&
-Cell::assign (const octave_value_list& idx, const Cell& rhs,
+Cell::assign (const octave_value_list& idx_arg, const Cell& rhs,
 	      const octave_value& fill_val)
 
 {
-  for (int i = 0; i < idx.length (); i++)
-    set_index (idx(i).index_vector ());
+  for (int i = 0; i < idx_arg.length (); i++)
+    set_index (idx_arg(i).index_vector ());
 
   ::assign (*this, rhs, fill_val);
 
   return *this;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -51,19 +51,18 @@ public:
     {
       for (int i = 0; i < ovl.length (); i++)
 	elem (i) = ovl (i);
     }
 
   Cell (int n, int m, const octave_value& val = resize_fill_value ())
     : ArrayN<octave_value> (dim_vector (n, m), val) { }
 
-  Cell (const dim_vector& dims,
-		 const octave_value& val = resize_fill_value ())
-    : ArrayN<octave_value> (dims, val) { }
+  Cell (const dim_vector& dv, const octave_value& val = resize_fill_value ())
+    : ArrayN<octave_value> (dv, val) { }
 
   Cell (const ArrayN<octave_value>& c)
     : ArrayN<octave_value> (c) { }
 
   Cell (const Array<octave_value>& c)
     : ArrayN<octave_value> (c) { }
 
   Cell (const Array<octave_value>& c, int nr, int nc)
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,24 @@
+2003-11-10  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* ov-cell.cc (octave_cell::print_raw): Use dim_vector::str.
+
+	* Cell.cc, Cell.h, debug.cc, file-io.cc, load-save.cc,
+	oct-fstrm.cc, oct-iostrm.cc, oct-iostrm.h, oct-map.cc, oct-map.h,
+	oct-prcstrm.cc, oct-stdstrm.h, oct-stream.cc, oct-strstrm.h,
+	octave.cc, ov-base.h, ov-cell.cc, ov.cc, ov.h, pt-cell.h,
+	pt-mat.cc, pt-mat.h, pt-plot.cc, pt-stmt.cc, variables.cc,
+	DLD-FUNCTIONS/rand.cc: Avoid -Wshadow warnings.
+
+2003-11-01  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* ov.h (octave_base_value::is_bool_matrix): New virtual function.
+	* ov-base.h (octave_base_value::is_bool_matrix): New function.
+
 2003-10-31  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* ov.cc (octave_value::length): If any dim is zero, return 0.
 
 	* ov-cell.cc (octave_cell::subsref): When indexing with '{', quit
 	early if an error occurs in do_index_op.
 
 	* ov.cc (octave_value::next_subsref): Don't do anything if
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -185,18 +185,16 @@ do_rand (const octave_value_list& args, 
 		if (! error_state)
 		  octave_rand::seed (d);
 	      }
 	    else
 	      error ("rand: unrecognized string argument");
 	  }
 	else
 	  {
-	    int nargin = args.length ();
-
 	    dims.resize (nargin);
 
 	    for (int i = 0; i < nargin; i++)
 	      {
 		dims(i) = args(i).int_value ();
 
 		if (error_state)
 		  {
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -59,17 +59,17 @@ get_user_function (std::string str = "")
 
       if (ptr && ptr->is_user_function ())
 	{
 	  octave_value tmp = ptr->def ();
 	  dbg_fcn = dynamic_cast<octave_user_function *> (tmp.function_value ());
 	}
       else
 	{
-	  symbol_record *ptr = lookup_by_name (str, false);
+	  ptr = lookup_by_name (str, false);
 	
 	  if (ptr && ptr->is_user_function ())
 	    {
 	      octave_value tmp = ptr->def ();
 	      dbg_fcn = dynamic_cast<octave_user_function *> (tmp.function_value ());
 	    }
 	}
     }
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -683,18 +683,16 @@ written to the stream @var{fid} instead 
       else
 	{
 	  fmt_n = 1;
 	  os = octave_stream_list::lookup (args(0), who);
 	}
 
       if (! error_state)
 	{
-	  std::string who;
-
 	  if (args(fmt_n).is_string ())
 	    {
 	      std::string fmt = args(fmt_n).string_value ();
 
 	      octave_value_list tmp_args;
 
 	      if (nargin > 1 + fmt_n)
 		{
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -408,17 +408,17 @@ extract_keyword (std::istream& is, const
     }
 
   int len = retval.length ();
 
   if (len > 0)
     {
       while (len)
 	{
-	  char c = retval[len-1];
+	  c = retval[len-1];
 
 	  if (c == ' ' || c == '\t')
 	    len--;
 	  else
 	    {
 	      retval.resize (len);
 	      break;
 	    }
@@ -1059,26 +1059,26 @@ read_binary_data (std::istream& is, bool
 	int max_len = 0;
 	for (int i = 0; i < elements; i++)
 	  {
 	    FOUR_BYTE_INT len;
 	    if (! is.read (X_CAST (char *, &len), 4))
 	      goto data_read_error;
 	    if (swap)
 	      swap_4_bytes (X_CAST (char *, &len));
-	    OCTAVE_LOCAL_BUFFER (char, tmp, len+1);
-	    if (! is.read (X_CAST (char *, tmp), len))
+	    OCTAVE_LOCAL_BUFFER (char, btmp, len+1);
+	    if (! is.read (X_CAST (char *, btmp), len))
 	      goto data_read_error;
 	    if (len > max_len)
 	      {
 		max_len = len;
 		chm.resize (elements, max_len, 0);
 	      }
-	    tmp [len] = '\0';
-	    chm.insert (tmp, i, 0);
+	    btmp [len] = '\0';
+	    chm.insert (btmp, i, 0);
 	  }
 	tc = octave_value (chm, true);
       }
       break;
 
     default:
     data_read_error:
       error ("load: trouble reading binary file `%s'", filename.c_str ());
@@ -2668,54 +2668,54 @@ read_mat5_binary_element (std::istream& 
   imag = (flags & 0x0800) != 0;	// has an imaginary part?
   global = (flags & 0x0400) != 0; // global variable?
   logicalvar = (flags & 0x0200) != 0; // we don't use this yet
   arrayclass = (arrayclasstype)(flags & 0xff);
   read_int (is, swap, junk);	// an "undefined" entry
   
   // dimensions array subelement
   {
-    std::streampos pos;
+    std::streampos tmp_pos;
 
     if (read_mat5_tag (is, swap, type, dimension_length) || type != miINT32)
       {
 	error ("load: invalid dimensions array subelement");
 	goto early_read_error;
       }
 
-    pos = is.tellg ();
+    tmp_pos = is.tellg ();
     read_int (is, swap, nr);
     read_int (is, swap, nc);
     re.resize (nr, nc);
 
     // delay checking for a multidimensional array until we have read
     // the variable name
-    is.seekg (pos + static_cast<std::streamoff> (dimension_length));
+    is.seekg (tmp_pos + static_cast<std::streamoff> (dimension_length));
   }
 
   // array name subelement
   {
-    std::streampos pos;
+    std::streampos tmp_pos;
       
     if (read_mat5_tag (is, swap, type, len) || type != miINT8)
       {
 	error ("load: invalid array name subelement");
 	goto early_read_error;
       }
 
-    pos = is.tellg ();
+    tmp_pos = is.tellg ();
     OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
     if (len)			// structure field subelements have
 				// zero-length array name subelements
       {
 	if (! is.read (X_CAST (char *, name), len ))
 	  goto data_read_error;
 	
-	is.seekg (pos + static_cast<std::streamoff> (PAD (len)));
+	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
       }
 
     name[len] = '\0';
     retval = name;
   }
 
   if (dimension_length != 8)
     {
@@ -2758,53 +2758,53 @@ read_mat5_binary_element (std::istream& 
 
     case mxSPARSE_CLASS:
       warning ("load: sparse arrays are not implemented");
       goto skip_ahead;
 
     case mxSTRUCT_CLASS:
       {
 	Octave_map m;
-	FOUR_BYTE_INT type;
-	FOUR_BYTE_INT len;
+	FOUR_BYTE_INT fn_type;
+	FOUR_BYTE_INT fn_len;
 	FOUR_BYTE_INT field_name_length;
 	int i;
 
 	// field name length subelement -- actually the maximum length
 	// of a field name.  The Matlab docs promise this will always
 	// be 32.  We read and use the actual value, on the theory
 	// that eventually someone will recognize that's a waste of
 	// space.
-	if (read_mat5_tag (is, swap, type, len) || type != miINT32)
+	if (read_mat5_tag (is, swap, fn_type, fn_len) || fn_type != miINT32)
 	  {
 	    error ("load: invalid field name subelement");
 	    goto data_read_error;
 	  }
 
-	if (! is.read (X_CAST (char *, &field_name_length), len ))
+	if (! is.read (X_CAST (char *, &field_name_length), fn_len ))
 	  goto data_read_error;
 
 	if (swap)
 	  swap_4_bytes ((char *)&field_name_length);
 
 	// field name subelement.  The length of this subelement tells
 	// us how many fields there are.
-	if (read_mat5_tag (is, swap, type, len) || type != miINT8)
+	if (read_mat5_tag (is, swap, fn_type, fn_len) || fn_type != miINT8)
 	  {
 	    error ("load: invalid field name subelement");
 	    goto data_read_error;
 	  }
 
-	int n_fields = len/field_name_length;
-
-	len = PAD (len);
-
-	OCTAVE_LOCAL_BUFFER (char, elname, len);
-
-	if (! is.read (elname, len))
+	int n_fields = fn_len/field_name_length;
+
+	fn_len = PAD (fn_len);
+
+	OCTAVE_LOCAL_BUFFER (char, elname, fn_len);
+
+	if (! is.read (elname, fn_len))
 	  goto data_read_error;
 
 	int n;
 	if (nr == 1)
 	  n = nc;
 	else if (nc == 1)
 	  n = nr;
 	else
@@ -2821,22 +2821,22 @@ read_mat5_binary_element (std::istream& 
 	    for (i = 0; i < n_fields; i++)
 	      {
 		octave_value fieldtc;
 		read_mat5_binary_element (is, filename, swap, global, fieldtc);
 		field_elts(i,j) = fieldtc;
 	      }
 	  }
 
-	for (int i = n_fields-1; i >= 0; i--)
+	for (int j = n_fields-1; j >= 0; j--)
 	  {
-	    const char *key = elname + i*field_name_length;
-
-	    for (int j = n-1; j >=0; j--)
-	      m[key](j) = field_elts(i,j);
+	    const char *key = elname + j*field_name_length;
+
+	    for (int k = n-1; k >=0; k--)
+	      m[key](k) = field_elts(j,k);
 	  }
 
 	tc = m;
       }
       break;
 
     case mxCHAR_CLASS:
       // handle as a numerical array to start with
@@ -2849,35 +2849,35 @@ read_mat5_binary_element (std::istream& 
     case mxUINT16_CLASS:
     case mxINT32_CLASS:
     case mxUINT32_CLASS:
     default:
       // handle all these numerical formats as double arrays
       
       // real data subelement
       {
-	std::streampos pos;
+	std::streampos tmp_pos;
 	
 	if (read_mat5_tag (is, swap, type, len))
 	  {
 	    error ("load: reading matrix data for `%s'", retval.c_str ());
 	    goto data_read_error;
 	  }
 
-	pos = is.tellg ();
+	tmp_pos = is.tellg ();
 	read_mat5_binary_data (is, re.fortran_vec (), nr*nc, swap,
 			       (enum mat5_data_type) type, flt_fmt);
 
 	if (! is || error_state)
 	  {
 	    error ("load: reading matrix data for `%s'", retval.c_str ());
 	    goto data_read_error;
 	  }
 
-	is.seekg (pos + static_cast<std::streamoff> (PAD (len)));
+	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
       }
       
       // imaginary data subelement
       if (imag)
 	{
 	  Matrix im (nr, nc);
 	  
 	  if (read_mat5_tag (is, swap, type, len))
@@ -3605,18 +3605,18 @@ save_binary_data (std::ostream& os, cons
       FOUR_BYTE_INT nr = tc.rows ();
       os.write (X_CAST (char *, &nr), 4);
       charMatrix chm = tc.char_matrix_value ();
       for (int i = 0; i < nr; i++)
 	{
 	  FOUR_BYTE_INT len = chm.cols ();
 	  os.write (X_CAST (char *, &len), 4);
 	  std::string tstr = chm.row_as_string (i);
-	  const char *tmp = tstr.data ();
-	  os.write (X_CAST (char *, tmp), len);
+	  const char *btmp = tstr.data ();
+	  os.write (X_CAST (char *, btmp), len);
 	}
     }
   else if (tc.is_range ())
     {
       tmp = 6;
       os.write (X_CAST (char *, &tmp), 1);
       tmp = (char) LS_DOUBLE;
       os.write (X_CAST (char *, &tmp), 1);
@@ -3629,18 +3629,18 @@ save_binary_data (std::ostream& os, cons
       os.write (X_CAST (char *, &inc), 8);
     }
   else if (tc.is_real_scalar ())
     {
       tmp = 1;
       os.write (X_CAST (char *, &tmp), 1);
       tmp = (char) LS_DOUBLE;
       os.write (X_CAST (char *, &tmp), 1);
-      double tmp = tc.double_value ();
-      os.write (X_CAST (char *, &tmp), 8);
+      double dtmp = tc.double_value ();
+      os.write (X_CAST (char *, &dtmp), 8);
     }
   else if (tc.is_real_matrix ())
     {
       tmp = 2;
       os.write (X_CAST (char *, &tmp), 1);
       Matrix m = tc.matrix_value ();
       FOUR_BYTE_INT nr = m.rows ();
       FOUR_BYTE_INT nc = m.columns ();
@@ -3668,18 +3668,18 @@ save_binary_data (std::ostream& os, cons
       write_doubles (os, mtmp, st, len);
     }
   else if (tc.is_complex_scalar ())
     {
       tmp = 3;
       os.write (X_CAST (char *, &tmp), 1);
       tmp = (char) LS_DOUBLE;
       os.write (X_CAST (char *, &tmp), 1);
-      Complex tmp = tc.complex_value ();
-      os.write (X_CAST (char *, &tmp), 16);
+      Complex ctmp = tc.complex_value ();
+      os.write (X_CAST (char *, &ctmp), 16);
     }
   else if (tc.is_complex_matrix ())
     {
       tmp = 4;
       os.write (X_CAST (char *, &tmp), 1);
       ComplexMatrix m = tc.complex_matrix_value ();
       FOUR_BYTE_INT nr = m.rows ();
       FOUR_BYTE_INT nc = m.columns ();
@@ -4345,32 +4345,32 @@ save_mat5_binary_element (std::ostream& 
     strncpy (paddedname, name.c_str (), namelen);
     os.write (paddedname, paddedlength);
   }
 
   // data element
   if (tc.is_string ())
     {
       charMatrix chm = tc.char_matrix_value ();
-      int nc = chm.cols ();
-      int len = nr*nc*2;
-      int paddedlength = PAD (nr*nc*2);
-
-      OCTAVE_LOCAL_BUFFER (TWO_BYTE_INT, buf, nc*nr+3);
+      int ncol = chm.cols ();
+      int len = nr*ncol*2;
+      int paddedlength = PAD (nr*ncol*2);
+
+      OCTAVE_LOCAL_BUFFER (TWO_BYTE_INT, buf, ncol*nr+3);
       write_mat5_tag (os, miUINT16, len);
 
       for (int i = 0; i < nr; i++)
 	{
 	  std::string tstr = chm.row_as_string (i);
 	  const char *s = tstr.data ();
 
-	  for (int j = 0; j < nc; j++)
+	  for (int j = 0; j < ncol; j++)
 	    buf[j*nr+i] = *s++ & 0x00FF;
 	}
-      os.write ((char *)buf, nr*nc*2);
+      os.write ((char *)buf, nr*ncol*2);
       
       if (paddedlength > len)
 	os.write ((char *)buf, paddedlength - len);
     }
   else if (tc.is_real_scalar () || tc.is_real_matrix () || tc.is_range ())
     {
       Matrix m = tc.matrix_value ();
 
@@ -4495,30 +4495,30 @@ save_mat_binary_data (std::ostream& os, 
   os << name << '\0';
 
   if (tc.is_string ())
     {
       unwind_protect::begin_frame ("save_mat_binary_data");
 
       charMatrix chm = tc.char_matrix_value ();
 
-      int nr = chm.rows ();
-      int nc = chm.cols ();
+      int nrow = chm.rows ();
+      int ncol = chm.cols ();
 	
-      OCTAVE_LOCAL_BUFFER (double, buf, nc*nr);
+      OCTAVE_LOCAL_BUFFER (double, buf, ncol*nrow);
 	
-      for (int i = 0; i < nr; i++)
+      for (int i = 0; i < nrow; i++)
       	{
 	  std::string tstr = chm.row_as_string (i);
 	  const char *s = tstr.data ();
 	  
-	  for (int j = 0; j < nc; j++)
-	    buf[j*nr+i] = static_cast<double> (*s++ & 0x00FF);
+	  for (int j = 0; j < ncol; j++)
+	    buf[j*nrow+i] = static_cast<double> (*s++ & 0x00FF);
        	}
-      os.write ((char *)buf, nr*nc*sizeof(double));
+      os.write ((char *)buf, nrow*ncol*sizeof(double));
       
       unwind_protect::run_frame ("save_mat_binary_data");
     }
   else if (tc.is_range ())
     {
       Range r = tc.range_value ();
       double base = r.base ();
       double inc = r.inc ();
diff --git a/src/oct-fstrm.cc b/src/oct-fstrm.cc
--- a/src/oct-fstrm.cc
+++ b/src/oct-fstrm.cc
@@ -27,25 +27,25 @@ Software Foundation, 59 Temple Place - S
 #include <cerrno>
 #include <cstring>
 
 #include "error.h"
 #include "oct-fstrm.h"
 
 octave_stream
 octave_fstream::create (const std::string& nm_arg, std::ios::openmode arg_md,
-			oct_mach_info::float_format flt_fmt)
+			oct_mach_info::float_format ff)
 {
-  return octave_stream (new octave_fstream (nm_arg, arg_md, flt_fmt));
+  return octave_stream (new octave_fstream (nm_arg, arg_md, ff));
 }
 
 octave_fstream::octave_fstream (const std::string& nm_arg,
 				std::ios::openmode arg_md,
-				oct_mach_info::float_format flt_fmt)
-  : octave_base_stream (arg_md, flt_fmt), nm (nm_arg)
+				oct_mach_info::float_format ff)
+  : octave_base_stream (arg_md, ff), nm (nm_arg)
 {
 
 #if CXX_ISO_COMPLIANT_LIBRARY
 
   fs.open (nm.c_str (), arg_md);
 
 #else
   // Override default protection of 0664 so that umask will appear to
diff --git a/src/oct-iostrm.cc b/src/oct-iostrm.cc
--- a/src/oct-iostrm.cc
+++ b/src/oct-iostrm.cc
@@ -64,32 +64,32 @@ octave_base_iostream::invalid_operation 
 
 bool
 octave_istream::eof (void) const
 {
   return is && is->eof ();
 }
 
 octave_stream
-octave_istream::create (std::istream *arg, const std::string& nm)
+octave_istream::create (std::istream *arg, const std::string& n)
 {
-  return octave_stream (new octave_istream (arg, nm));
+  return octave_stream (new octave_istream (arg, n));
 }
 
 // Return non-zero if EOF has been reached on this stream.
 
 bool
 octave_ostream::eof (void) const
 {
   return os && os->eof ();
 }
 
 octave_stream
-octave_ostream::create (std::ostream *arg, const std::string& nm)
+octave_ostream::create (std::ostream *arg, const std::string& n)
 {
-  return octave_stream (new octave_ostream (arg, nm));
+  return octave_stream (new octave_ostream (arg, n));
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/oct-iostrm.h b/src/oct-iostrm.h
--- a/src/oct-iostrm.h
+++ b/src/oct-iostrm.h
@@ -28,20 +28,20 @@ Software Foundation, 59 Temple Place - S
 #include "oct-stream.h"
 
 class
 octave_base_iostream : public octave_base_stream
 {
 public:
 
   octave_base_iostream (const std::string& n = std::string (),
-			std::ios::openmode md = std::ios::in|std::ios::out,
-			oct_mach_info::float_format flt_fmt =
+			std::ios::openmode m = std::ios::in|std::ios::out,
+			oct_mach_info::float_format ff =
 			oct_mach_info::flt_fmt_native)
-    : octave_base_stream (md, flt_fmt), nm (n) { }
+    : octave_base_stream (m, ff), nm (n) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (std::streamoff offset, std::ios::seekdir origin);
 
   // Return current stream position.
 
   long tell (void) const;
@@ -73,22 +73,22 @@ private:
   octave_base_iostream& operator = (const octave_base_iostream&);
 };
 
 class
 octave_istream : public octave_base_iostream
 {
 public:
 
-  octave_istream (std::istream *arg = 0, const std::string& nm = std::string ())
-    : octave_base_iostream (nm, std::ios::in, oct_mach_info::flt_fmt_native),
+  octave_istream (std::istream *arg = 0, const std::string& n = std::string ())
+    : octave_base_iostream (n, std::ios::in, oct_mach_info::flt_fmt_native),
       is (arg) { }
 
   static octave_stream
-  create (std::istream *arg = 0, const std::string& nm = std::string ());
+  create (std::istream *arg = 0, const std::string& n = std::string ());
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   std::istream *input_stream (void) { return is; }
 
   std::ostream *output_stream (void) { return 0; }
@@ -110,22 +110,22 @@ private:
   octave_istream& operator = (const octave_istream&);
 };
 
 class
 octave_ostream : public octave_base_iostream
 {
 public:
 
-  octave_ostream (std::ostream *arg, const std::string& nm = std::string ())
-    : octave_base_iostream (nm, std::ios::out, oct_mach_info::flt_fmt_native),
+  octave_ostream (std::ostream *arg, const std::string& n = std::string ())
+    : octave_base_iostream (n, std::ios::out, oct_mach_info::flt_fmt_native),
       os (arg) { }
 
   static octave_stream
-  create (std::ostream *arg, const std::string& nm = std::string ());
+  create (std::ostream *arg, const std::string& n = std::string ());
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   std::istream *input_stream (void) { return 0; }
 
   std::ostream *output_stream (void) { return os; }
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -30,19 +30,19 @@ Software Foundation, 59 Temple Place - S
 
 #include "error.h"
 #include "str-vec.h"
 
 #include "oct-map.h"
 #include "utils.h"
 
 Cell
-Octave_map::operator [] (const std::string& key) const
+Octave_map::operator [] (const std::string& k) const
 {
-  const_iterator p = seek (key);
+  const_iterator p = seek (k);
 
   return p != end () ? p->second : Cell ();
 }
 
 string_vector
 Octave_map::keys (void) const
 {
   int len = length ();
@@ -119,21 +119,21 @@ Octave_map::assign (const octave_value_l
   string_vector t_keys = empty () ? rhs.keys () : equiv_keys (*this, rhs);
 
   if (! t_keys.empty ())
     {
       int len = t_keys.length ();
 
       for (int i = 0; i < len; i++)
 	{
-	  std::string key = t_keys[i];
+	  std::string k = t_keys[i];
 
-	  Cell t_rhs = rhs[key];
+	  Cell t_rhs = rhs[k];
 
-	  assign (idx, key, t_rhs);
+	  assign (idx, k, t_rhs);
 
 	  if (error_state)
 	    break;
 	}
     }
   else
     error ("field name mismatch in structure assignment");
 
@@ -166,20 +166,20 @@ common_size (const dim_vector& a, const 
       for (int i = min_len; i < a_len; i++)
 	retval(i) = a(i);
     }
 
   return retval;
 }
 
 Octave_map&
-Octave_map::assign (const octave_value_list& idx, const std::string& key,
+Octave_map::assign (const octave_value_list& idx, const std::string& k,
 		    const Cell& rhs)
 {
-  Cell tmp = map[key];
+  Cell tmp = map[k];
 
   octave_value fill_value = Matrix ();
 
   tmp.assign (idx, rhs, fill_value);
 
   if (! error_state)
     {
       dim_vector rhs_dims = tmp.dims ();
@@ -195,35 +195,35 @@ Octave_map::assign (const octave_value_l
       else if (new_dims != curr_dims)
 	{
 	  for (iterator p = begin (); p != end (); p++)
 	    contents(p).resize_and_fill (rhs_dims, fill_value);
 	}
 
       dimensions = new_dims;
 
-      map[key] = tmp;
+      map[k] = tmp;
     }
 
   return *this;
 }
 
 Octave_map&
-Octave_map::assign (const std::string& key, const Cell& rhs)
+Octave_map::assign (const std::string& k, const Cell& rhs)
 {
   if (empty ())
     {
-      map[key] = rhs;
+      map[k] = rhs;
 
       dimensions = dim_vector (1, 1);
     }
   else
     {
       if (dims () == rhs.dims ())
-	map[key] = rhs;
+	map[k] = rhs;
       else
 	error ("invalid structure assignment");
     }
 
   return *this;
 }
 
 Octave_map
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -39,27 +39,27 @@ Octave_map
 {
  public:
 
   typedef std::map<std::string, Cell>::iterator iterator;
   typedef std::map<std::string, Cell>::const_iterator const_iterator;
 
   Octave_map (void) : map (), dimensions (0, 0) { }
 
-  Octave_map (const std::string& key, const octave_value& value)
+  Octave_map (const std::string& k, const octave_value& value)
     : map (), dimensions (1, 1)
-    { map[key] = value; }
+    { map[k] = value; }
 
-  Octave_map (const std::string& key, const Cell& vals)
+  Octave_map (const std::string& k, const Cell& vals)
     : map (), dimensions (vals.dims ())
-    { map[key] = vals; }
+    { map[k] = vals; }
 
-  Octave_map (const std::string& key, const octave_value_list& val_list)
+  Octave_map (const std::string& k, const octave_value_list& val_list)
     : map (), dimensions (1, val_list.length ())
-  { map[key] = val_list; }
+  { map[k] = val_list; }
 
   Octave_map (const Octave_map& m) : map (m.map), dimensions (m.dimensions) { }
 
   Octave_map& operator = (const Octave_map& m)
     {
       if (this != &m)
 	{
 	  map = m.map;
@@ -71,23 +71,23 @@ Octave_map
 
   ~Octave_map (void) { }
 
   // This is the number of keys.
   int length (void) const { return map.size (); }
 
   int empty (void) const { return map.empty (); }
 
-  Cell& operator [] (const std::string& key) { return map[key]; }
+  Cell& operator [] (const std::string& k) { return map[k]; }
 
-  Cell operator [] (const std::string& key) const;
+  Cell operator [] (const std::string& k) const;
 
-  void del (const std::string& key)
+  void del (const std::string& k)
     {
-      iterator p = map.find (key);
+      iterator p = map.find (k);
       if (p != map.end ())
 	map.erase (p);
     }
 
   iterator begin (void) { return iterator (map.begin ()); }
   const_iterator begin (void) const { return const_iterator (map.begin ()); }
 
   iterator end (void) { return iterator (map.end ()); }
@@ -96,20 +96,20 @@ Octave_map
   std::string key (const_iterator p) const { return p->first; }
 
   Cell& contents (const_iterator p)
     { return operator [] (key(p)); }
 
   Cell contents (const_iterator p) const
     { return operator [] (key(p)); }
 
-  const_iterator seek (const std::string& key) const { return map.find (key); }
+  const_iterator seek (const std::string& k) const { return map.find (k); }
 
-  int contains (const std::string& key) const
-    { return (seek (key) != map.end ()); }
+  int contains (const std::string& k) const
+    { return (seek (k) != map.end ()); }
 
   void clear (void) { map.clear (); }
 
   string_vector keys (void) const;
 
   int rows (void) const { return dimensions(0); }
 
   int columns (void) const { return dimensions(1); }
@@ -117,20 +117,20 @@ Octave_map
   dim_vector dims (void) const { return dimensions; }
 
   Octave_map reshape (const dim_vector& new_dims) const;
 
   int numel (void) const;
 
   Octave_map& assign (const octave_value_list& idx, const Octave_map& rhs);
 
-  Octave_map& assign (const octave_value_list& idx, const std::string& key,
+  Octave_map& assign (const octave_value_list& idx, const std::string& k,
 		      const Cell& rhs);
 
-  Octave_map& assign (const std::string& key, const Cell& rhs);
+  Octave_map& assign (const std::string& k, const Cell& rhs);
 
   Octave_map index (const octave_value_list& idx);
 
 private:
 
   // The map of names to values.
   std::map<std::string, Cell> map;
 
diff --git a/src/oct-prcstrm.cc b/src/oct-prcstrm.cc
--- a/src/oct-prcstrm.cc
+++ b/src/oct-prcstrm.cc
@@ -31,46 +31,46 @@ Software Foundation, 59 Temple Place - S
 static int
 cxx_pclose (FILE *f)
 {
   return ::pclose (f);
 }
 
 octave_stream
 octave_iprocstream::create (const std::string& n, std::ios::openmode arg_md,
-			    oct_mach_info::float_format flt_fmt)
+			    oct_mach_info::float_format ff)
 {
-  return octave_stream (new octave_iprocstream (n, arg_md, flt_fmt));
+  return octave_stream (new octave_iprocstream (n, arg_md, ff));
 }
 
 octave_iprocstream::octave_iprocstream (const std::string& n,
 					std::ios::openmode arg_md,
-					oct_mach_info::float_format flt_fmt)
+					oct_mach_info::float_format ff)
   : octave_stdiostream (n, ::popen (n.c_str (), "r"),
-			arg_md, flt_fmt, cxx_pclose)
+			arg_md, ff, cxx_pclose)
 {
 }
 
 octave_iprocstream::~octave_iprocstream (void)
 {
   do_close ();
 }
 
 octave_stream
 octave_oprocstream::create (const std::string& n, std::ios::openmode arg_md,
-			    oct_mach_info::float_format flt_fmt)
+			    oct_mach_info::float_format ff)
 {
-  return octave_stream (new octave_oprocstream (n, arg_md, flt_fmt));
+  return octave_stream (new octave_oprocstream (n, arg_md, ff));
 }
 
 octave_oprocstream::octave_oprocstream (const std::string& n,
 					std::ios::openmode arg_md,
-					oct_mach_info::float_format flt_fmt)
+					oct_mach_info::float_format ff)
   : octave_stdiostream (n, ::popen (n.c_str (), "w"),
-			arg_md, flt_fmt, cxx_pclose)
+			arg_md, ff, cxx_pclose)
 {
 }
 
 octave_oprocstream::~octave_oprocstream (void)
 {
   do_close ();
 }
 
diff --git a/src/oct-stdstrm.h b/src/oct-stdstrm.h
--- a/src/oct-stdstrm.h
+++ b/src/oct-stdstrm.h
@@ -27,32 +27,33 @@ Software Foundation, 59 Temple Place - S
 #include "c-file-ptr-stream.h"
 
 class
 octave_stdiostream : public octave_base_stream
 {
 public:
 
   octave_stdiostream (const std::string& n, FILE *f = 0,
-		      std::ios::openmode arg_md = std::ios::in|std::ios::out,
-		      oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_native,
+		      std::ios::openmode m = std::ios::in|std::ios::out,
+		      oct_mach_info::float_format ff =
+		      oct_mach_info::flt_fmt_native,
 		      c_file_ptr_buf::close_fcn cf = c_file_ptr_buf::fclose)
-    : octave_base_stream (arg_md, flt_fmt), nm (n), md (arg_md), s(0)
+    : octave_base_stream (m, ff), nm (n), md (m), s(0)
   {
     if (f)
       s = new io_c_file_ptr_stream (f, cf);
   }
 
   static octave_stream
   create (const std::string& n, FILE *f = 0,
-	  std::ios::openmode arg_md = std::ios::in|std::ios::out,
-	  oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_native,
+	  std::ios::openmode m = std::ios::in|std::ios::out,
+	  oct_mach_info::float_format ff = oct_mach_info::flt_fmt_native,
 	  c_file_ptr_buf::close_fcn cf = c_file_ptr_buf::fclose)
   {
-    return octave_stream (new octave_stdiostream (n, f, arg_md, flt_fmt, cf));
+    return octave_stream (new octave_stdiostream (n, f, m, ff, cf));
   }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (std::streamoff offset, std::ios::seekdir origin);
 
   // Return current stream position.
 
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -705,51 +705,51 @@ printf_format_list::process_conversion
   flags = "";
   fw = 0;
   prec = 0;
   modifier = '\0';
   type = '\0';
 
   *buf << s[i++];
 
-  bool next = false;
+  bool nxt = false;
 
   while (i < n)
     {
       switch (s[i])
 	{
 	case '-': case '+': case ' ': case '0': case '#':
 	  flags += s[i];
 	  *buf << s[i++];
 	  break;
 
 	default:
-	  next = true;
+	  nxt = true;
 	  break;
 	}
 
-      if (next)
+      if (nxt)
 	break;
     }
 
   if (i < n)
     {
       if (s[i] == '*')
 	{
 	  fw = -1;
 	  args++;
 	  *buf << s[i++];
 	}
       else
 	{
 	  if (isdigit (s[i]))
 	    {
-	      int n = 0;
+	      int nn = 0;
 	      std::string tmp = s.substr (i);
-	      sscanf (tmp.c_str (), "%d%n", &fw, &n);
+	      sscanf (tmp.c_str (), "%d%n", &fw, &nn);
 	    }
 
 	  while (i < n && isdigit (s[i]))
 	    *buf << s[i++];
 	}
     }
 
   if (i < n && s[i] == '.')
@@ -763,19 +763,19 @@ printf_format_list::process_conversion
 	      prec = -1;
 	      args++;
 	      *buf << s[i++];
 	    }
 	  else
 	    {
 	      if (isdigit (s[i]))
 		{
-		  int n = 0;
+		  int nn = 0;
 		  std::string tmp = s.substr (i);
-		  sscanf (tmp.c_str (), "%d%n", &prec, &n);
+		  sscanf (tmp.c_str (), "%d%n", &prec, &nn);
 		}
 
 	      while (i < n && isdigit (s[i]))
 		*buf << s[i++];
 	    }
 	}
     }
 
diff --git a/src/oct-strstrm.h b/src/oct-strstrm.h
--- a/src/oct-strstrm.h
+++ b/src/oct-strstrm.h
@@ -29,20 +29,20 @@ Software Foundation, 59 Temple Place - S
 
 #include "oct-stream.h"
 
 class
 octave_base_strstream : public octave_base_stream
 {
 public:
 
-  octave_base_strstream (std::ios::openmode arg_md = std::ios::out,
-			 oct_mach_info::float_format flt_fmt =
+  octave_base_strstream (std::ios::openmode m = std::ios::out,
+			 oct_mach_info::float_format ff =
 			 oct_mach_info::flt_fmt_native)
-    : octave_base_stream (arg_md, flt_fmt) { }
+    : octave_base_stream (m, ff) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (std::streamoff offset, std::ios::seekdir origin);
 
   // Return current stream position.
 
   long tell (void) const;
@@ -72,33 +72,33 @@ private:
 
 class
 octave_istrstream : public octave_base_strstream
 {
 public:
 
   octave_istrstream (const char *data,
 		     std::ios::openmode arg_md = std::ios::out,
-		     oct_mach_info::float_format flt_fmt =
+		     oct_mach_info::float_format ff =
 		     oct_mach_info::flt_fmt_native)
-    : octave_base_strstream (arg_md, flt_fmt), is (data) { }
+    : octave_base_strstream (arg_md, ff), is (data) { }
 
   octave_istrstream (const std::string& data,
 		     std::ios::openmode arg_md = std::ios::out,
-		     oct_mach_info::float_format flt_fmt =
+		     oct_mach_info::float_format ff =
 		     oct_mach_info::flt_fmt_native)
-    : octave_base_strstream (arg_md, flt_fmt), is (data.c_str ()) { }
+    : octave_base_strstream (arg_md, ff), is (data.c_str ()) { }
 
   static octave_stream
   create (const char *data, std::ios::openmode arg_md = std::ios::out,
-	  oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_native);
+	  oct_mach_info::float_format ff = oct_mach_info::flt_fmt_native);
 
   static octave_stream
   create (const std::string& data, std::ios::openmode arg_md = std::ios::out,
-	  oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_native);
+	  oct_mach_info::float_format ff = oct_mach_info::flt_fmt_native);
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const { return is.eof (); }
 
   std::istream *input_stream (void) { return &is; }
 
   std::ostream *output_stream (void) { return 0; }
@@ -125,23 +125,23 @@ private:
 };
 
 class
 octave_ostrstream : public octave_base_strstream
 {
 public:
 
   octave_ostrstream (std::ios::openmode arg_md = std::ios::out,
-		     oct_mach_info::float_format flt_fmt =
+		     oct_mach_info::float_format ff =
 		     oct_mach_info::flt_fmt_native)
-    : octave_base_strstream (arg_md, flt_fmt) { }
+    : octave_base_strstream (arg_md, ff) { }
 
   static octave_stream
   create (std::ios::openmode arg_md = std::ios::out,
-	  oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_native);
+	  oct_mach_info::float_format ff = oct_mach_info::flt_fmt_native);
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const { return os.eof (); }
 
   std::istream *input_stream (void) { return 0; }
 
   std::ostream *output_stream (void) { return &os; }
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -161,31 +161,31 @@ long_options long_opts[] =
 
 // Store the command-line options for later use.
 
 static void
 intern_argv (int argc, char **argv)
 {
   bind_builtin_variable ("nargin", argc-1, true, true, 0);
 
-  Cell octave_argv;
+  Cell args;
 
   if (argc > 1)
     {
       Array<octave_value> tmp (argc-1);
 
       // Skip program name in argv.
       int i = argc;
       while (--i > 0)
 	tmp(i-1) = octave_value (*(argv+i));
 
-      octave_argv = Cell (tmp, argc-1, 1);
+      args = Cell (tmp, argc-1, 1);
     }
 
-  bind_builtin_constant ("argv", octave_argv, true, true);
+  bind_builtin_constant ("argv", args, true, true);
 }
 
 static void
 initialize_pathsearch (void)
 {
   // This may seem odd, but doing it this way means that we don't have
   // to modify the kpathsea library...
 
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -107,16 +107,18 @@ public:
   bool is_real_matrix (void) const { return false; }
 
   bool is_real_nd_array (void) const { return false; }
 
   bool is_complex_scalar (void) const { return false; }
 
   bool is_complex_matrix (void) const { return false; }
 
+  bool is_bool_matrix (void) const { return false; }
+
   bool is_char_matrix (void) const { return false; }
 
   bool is_string (void) const { return false; }
 
   bool is_range (void) const { return false; }
 
   bool is_map (void) const { return false; }
 
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -329,19 +329,19 @@ void
 octave_cell::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
 octave_cell::print_raw (std::ostream& os, bool) const
 {
-  int ndims = matrix.ndims ();
+  int nd = matrix.ndims ();
 
-  if (ndims == 2)
+  if (nd == 2)
     {
       int nr = rows ();
       int nc = columns ();
 
       if (nr > 0 && nc > 0)
 	{
 	  indent (os);
 	  os << "{";
@@ -378,25 +378,18 @@ octave_cell::print_raw (std::ostream& os
 	  if (nr > 0 || nc > 0)
 	    os << "(" << nr << "x" << nc << ")";
 	  os << "\n";
 	}
     }
   else
     {
       indent (os);
-      os << "{";
       dim_vector dv = matrix.dims ();
-      for (int i = 0; i < ndims; i++)
-	{
-	  if (i > 0)
-	    os << "x";
-	  os << dv(i);
-	}
-      os << " Cell Array}";
+      os << "{" << dv.str () << " Cell Array}";
       newline (os);
     }
 }
 
 bool
 octave_cell::print_name_tag (std::ostream& os, const std::string& name) const
 {
   indent (os);
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -394,33 +394,33 @@ octave_value::octave_value (octave_time 
 }
 
 octave_value::octave_value (double d)
   : rep (new octave_scalar (d))
 {
   rep->count = 1;
 }
 
-octave_value::octave_value (const Cell& c, bool is_cs_list)
+octave_value::octave_value (const Cell& c, bool is_csl)
   : rep (0)
 {
-  if (is_cs_list)
+  if (is_csl)
     rep = new octave_cs_list (c);
   else
     rep = new octave_cell (c);
 
   rep->count = 1;
 }
 
-octave_value::octave_value (const ArrayN<octave_value>& a, bool is_cs_list)
+octave_value::octave_value (const ArrayN<octave_value>& a, bool is_csl)
   : rep (0)
 {
   Cell c (a);
 
-  if (is_cs_list)
+  if (is_csl)
     rep = new octave_cs_list (c);
   else
     rep = new octave_cell (c);
 
   rep->count = 1;
 }
 
 octave_value::octave_value (const Matrix& m)
@@ -543,27 +543,27 @@ octave_value::octave_value (const std::s
 
 octave_value::octave_value (const string_vector& s)
   : rep (new octave_char_matrix_str (s))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
-octave_value::octave_value (const charMatrix& chm, bool is_string)
-  : rep (is_string
+octave_value::octave_value (const charMatrix& chm, bool is_str)
+  : rep (is_str
 	 ? new octave_char_matrix_str (chm)
 	 : new octave_char_matrix (chm))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
-octave_value::octave_value (const charNDArray& chm, bool is_string)
-  : rep (is_string
+octave_value::octave_value (const charNDArray& chm, bool is_str)
+  : rep (is_str
 	 ? new octave_char_matrix_str (chm)
 	 : new octave_char_matrix (chm))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (double base, double limit, double inc)
@@ -599,18 +599,18 @@ octave_value::octave_value (octave_funct
 }
 
 octave_value::octave_value (const octave_fcn_handle& fh)
   : rep (new octave_fcn_handle (fh))
 {
   rep->count = 1;
 }
 
-octave_value::octave_value (const octave_value_list& l, bool is_cs_list)
-  : rep (is_cs_list ? new octave_cs_list (l) : new octave_list (l))
+octave_value::octave_value (const octave_value_list& l, bool is_csl)
+  : rep (is_csl ? new octave_cs_list (l) : new octave_list (l))
 {
   rep->count = 1;
 }
 
 octave_value::octave_value (octave_value::magic_colon)
   : rep (new octave_magic_colon ())
 {
   rep->count = 1;
@@ -1467,18 +1467,17 @@ do_binary_op (octave_value::binary_op op
 	      return retval;
 	    }
 	}
       else
 	tv2 = v2;
 
       if (cf1 || cf2)
 	{
-	  binary_op_fcn f
-	    = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
+	  f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
 	  if (f)
 	    retval = f (*tv1.rep, *tv2.rep);
 	  else
 	    gripe_binary_op (octave_value::binary_op_as_string (op),
 			     v1.type_name (), v2.type_name ());
 	}
       else
@@ -1532,17 +1531,17 @@ do_unary_op (octave_value::unary_op op, 
 	{
 	  octave_value *tmp = cf (*v.rep);
 
 	  if (tmp)
 	    {
 	      tv = octave_value (tmp);
 	      t = tv.type_id ();
 
-	      unary_op_fcn f = octave_value_typeinfo::lookup_unary_op (op, t);
+	      f = octave_value_typeinfo::lookup_unary_op (op, t);
 
 	      if (f)
 		retval = f (*tv.rep);
 	      else
 		gripe_unary_op (octave_value::unary_op_as_string (op),
 				v.type_name ());
 	    }
 	  else
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -324,18 +324,18 @@ public:
   int columns (void) const;
 
   int length (void) const;
 
   int ndims (void) const;
 
   int numel (void) const;
 
-  virtual octave_value reshape (const dim_vector& dims) const
-    { return rep->reshape (dims); }
+  virtual octave_value reshape (const dim_vector& dv) const
+    { return rep->reshape (dv); }
 
   // Does this constant have a type?  Both of these are provided since
   // it is sometimes more natural to write is_undefined() instead of
   // ! is_defined().
 
   virtual bool is_defined (void) const
     { return rep->is_defined (); }
 
@@ -358,16 +358,19 @@ public:
     { return rep->is_real_nd_array (); }
 
   virtual bool is_complex_scalar (void) const
     { return rep->is_complex_scalar (); }
 
   virtual bool is_complex_matrix (void) const
     { return rep->is_complex_matrix (); }
 
+  virtual bool is_bool_matrix (void) const
+    { return rep->is_bool_matrix (); }
+
   virtual bool is_char_matrix (void) const
     { return rep->is_char_matrix (); }
 
   virtual bool is_string (void) const
     { return rep->is_string (); }
 
   virtual bool is_range (void) const
     { return rep->is_range (); }
diff --git a/src/pt-cell.h b/src/pt-cell.h
--- a/src/pt-cell.h
+++ b/src/pt-cell.h
@@ -39,17 +39,18 @@ class tree_walker;
 
 // General cells.
 
 class
 tree_cell : public tree_matrix
 {
 public:
 
-  tree_cell (tree_argument_list *row = 0, int line = -1, int column = -1) : tree_matrix (row, line, column) { }
+  tree_cell (tree_argument_list *row = 0, int l = -1, int c = -1)
+    : tree_matrix (row, l, c) { }
 
   ~tree_cell (void) { }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int);
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -227,21 +227,21 @@ tm_row_const::tm_row_const_rep::init (co
       octave_value tmp = elt->rvalue ();
 
       if (error_state || tmp.is_undefined ())
 	break;
       else
 	{
 	  if (tmp.is_cs_list ())
 	    {
-	      octave_value_list lst = tmp.list_value ();
+	      octave_value_list tlst = tmp.list_value ();
 
-	      for (int i = 0; i < lst.length (); i++)
+	      for (int i = 0; i < tlst.length (); i++)
 		{
-		  if (! do_init_element (elt, lst(i), first_elem))
+		  if (! do_init_element (elt, tlst(i), first_elem))
 		    goto done;
 		}
 	    }
 	  else
 	    {
 	      if (! do_init_element (elt, tmp, first_elem))
 		goto done;
 	    }
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -42,18 +42,18 @@ class tree_walker;
 // other matrices, variables, and functions.
 
 class
 tree_matrix : public tree_expression,
 	      public octave_base_list<tree_argument_list *>
 {
 public:
 
-  tree_matrix (tree_argument_list *row = 0, int line = -1, int column = -1)
-    : tree_expression (line, column)
+  tree_matrix (tree_argument_list *row = 0, int l = -1, int c = -1)
+    : tree_expression (l, c)
   {
     if (row)
       append (row);
   }
 
   ~tree_matrix (void);
 
   bool has_magic_end (void) const;
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -771,17 +771,18 @@ subplot::print (int ndim, OSSTREAM& plot
 {
   int status = handle_plot_data (ndim, plot_buf);
 
   if (status < 0)
     return -1;
 
   if (sp_axes_clause)
     {
-      int status = sp_axes_clause->print (plot_buf);
+      status = sp_axes_clause->print (plot_buf);
+
       if (status < 0)
 	return -1;
     }
 
   if (sp_title_clause)
     {
       octave_value tmp = sp_title_clause->rvalue ();
 
@@ -796,17 +797,18 @@ subplot::print (int ndim, OSSTREAM& plot
 	}
     }
   else
     plot_buf << " " << Vgnuplot_command_title << " "
       << '"' << "line " << plot_line_count << '"';
 
   if (sp_style_clause)
     {
-      int status = sp_style_clause->print (plot_buf);
+      status = sp_style_clause->print (plot_buf);
+
       if (status < 0)
 	return -1;
     }
 
   return 0;
 }
 
 void
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -199,19 +199,19 @@ void
 tree_statement_list::delete_breakpoint (int line)
 {
   if (line < 0)
     {
       octave_value_list bp_lst = list_breakpoints ();
 
       int len = bp_lst.length ();
 
-      for (int line = 0; line < len; line++)
+      for (int i = 0; i < len; i++)
 	{
-	  tree_breakpoint tbp (line, tree_breakpoint::clear);
+	  tree_breakpoint tbp (i, tree_breakpoint::clear);
 	  accept (tbp);
 	}
     }
   else
     {
       tree_breakpoint tbp (line, tree_breakpoint::clear); 
       accept (tbp);
     }
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -372,17 +372,17 @@ get_struct_elts (const std::string& text
     }
 
   string_vector retval (n);
 
   pos = 0;
 
   for (int i = 0; i < n; i++)
     {
-      size_t len = text.find ('.', pos);
+      len = text.find ('.', pos);
 
       if (len != NPOS)
 	len -= pos;
 
       retval[i] = text.substr (pos, len);
 
       if (len != NPOS)
 	pos += len + 1;
@@ -1166,18 +1166,18 @@ do_who (int argc, const string_vector& a
 	}
 
       if (show_verbose)
 	{
 	  int len = names.length ();
 
 	  octave_value_list ovl (len, octave_value ());
 
-	  for (int i = 0; i < len; i++)
-	    ovl(i) = names(i);
+	  for (int j = 0; j < len; i++)
+	    ovl(j) = names(j);
 
 	  retval = Octave_map ("name", ovl);
 	}
       else
 	retval = Cell (names);
     }
   else
     {
