# HG changeset patch
# User jwe
# Date 1198875418 0
#      Fri Dec 28 20:56:58 2007 +0000
# Node ID 745a8299c2b559b5559cb2c4e087b193eafe6bd4
# Parent  58f5fab3ebe5be60a39addd9b5bee8ac9e742836
[project @ 2007-12-28 20:56:55 by jwe]

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,17 @@
+2007-12-28  John W. Eaton  <jwe@octave.org>
+
+	Merge changes from object branch:
+
+	2007-06-20  John W. Eaton  <jwe@octave.org>
+
+	* interpreter/var.txi, interpreter/io.txi:
+	Eliminate print_answer_id_name.
+
 2007-12-21  John W. Eaton  <jwe@octave.org>
 
 	Version 3.0.0 released.
 
 2007-12-13  John W. Eaton  <jwe@octave.org>
 
 	* Makefile.in (conf.texi): Also depend on $(top_srcdir)/src/version.h.
 
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -64,18 +64,16 @@ The @code{format} command offers some co
 values with @code{disp} and through the normal echoing mechanism.
 
 @DOCSTRING(ans)
 
 @DOCSTRING(disp)
 
 @DOCSTRING(format)
 
-@DOCSTRING(print_answer_id_name)
-
 @menu
 * Paging Screen Output::
 @end menu
 
 @node Paging Screen Output
 @subsubsection Paging Screen Output
 
 When running interactively, Octave normally sends any output intended
diff --git a/doc/interpreter/var.txi b/doc/interpreter/var.txi
--- a/doc/interpreter/var.txi
+++ b/doc/interpreter/var.txi
@@ -472,21 +472,16 @@ Default value: 10.
 
 Default value: 5.
 
 @item page_screen_output
 @xref{Input and Output}.
 
 Default value: 1.
 
-@item print_answer_id_name
-@xref{Terminal Output}.
-
-Default value: 1.
-
 @item print_empty_dimensions
 @xref{Empty Matrices}.
 
 Default value: 1.
 
 @item return_last_computed_value
 @xref{Returning From a Function}.
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,423 @@
+2007-12-28  John W. Eaton  <jwe@octave.org>
+
+	Merge changes from object branch:
+
+	2007-12-12  John W. Eaton  <jwe@octave.org>
+
+	* load-path.cc (load_path::dir_info::get_file_list,
+	load_path::move_method_map, load_path::remove_method_map,
+	load_path::do_find_fcn, load_path::do_find_private_fcn,
+	load_path::do_find_method, load_path::do_find_file,
+	load_path::do_find_first_of, load_path::do_find_all_first_of,
+	load_path::do_display, load_path::add_to_method_map, genpath,
+	execute_pkg_add_or_del): Use file_ops::concat.
+
+	2007-08-24  John W. Eaton  <jwe@octave.org>
+
+	* variables.cc (Fmislocked): return value for nargin == 0 case.
+
+	2007-07-27  John W. Eaton  <jwe@octave.org>
+
+	* pt-idx.cc (tree_index_expression::rvalue):
+	Pass substring of type to subsref when doing partial evaluation.
+	(tree_index_expression::lvalue): Likewise.
+
+	2007-06-29  John W. Eaton  <jwe@octave.org>
+
+	* ov-class.cc (is_built_in_class, set_class_relationship,
+	Fsuperiorto, Finferiorto): New functions.
+	(octave_class::in_class_method): New function.
+	(octave_class::subsref, octave_class:subsasgn): Use it.
+
+	2007-06-28  John W. Eaton  <jwe@octave.org>
+
+	* src/ov-class.cc (sanitize): New function.
+	(make_idx_args): Use it.
+
+	2007-06-28  John W. Eaton  <jwe@octave.org>
+
+	* src/ov-class.cc (octave_class::subsasgn): Expect and use only
+	one return value from feval of subsasgn method.
+
+	* ov.cc (octave_value::assign): Don't convert to struct if
+	indexing a class object with ".".
+
+	* pt-idx.cc (tree_index_expression::make_arg_struct):
+	Use Cell instead of octave_value_list for subscripts.
+
+	* ov-class.cc (make_idx_args): For "." index, subs field is
+	string, not cell.
+
+	2007-06-27  John W. Eaton  <jwe@octave.org>
+
+	* ov-fcn-handle.cc (octave_fcn_handle::save_ascii,
+	octave_fcn_handle::load_ascii, octave_fcn_handle::save_binary,
+	octave_fcn_handle::load_binary, octave_fcn_handle::save_hdf5,
+	octave_fcn_handle::load_hdf5): Adapt to new symbol table objects.
+
+	* symtab.h (symbol_table::all_variables,
+	symbol_table::do_all_variables): New arg, defined_only.
+
+	2007-06-26  John W. Eaton  <jwe@octave.org>
+
+	* ls-mat5.cc (read_mat5_binary_element): Adapt to new symbol table
+	objects.
+
+	* variables.cc (Vwhos_line_format): New static variable.
+	(Fwhos_line_format): New function.
+	(symbol_record_name_compare): Delete function.
+	(symbol_record_name_compare, whos_parameter): New structs.
+	(print_descriptor, dimensions_string_req_first_space,
+	dimensions_string_req_total_space, make_dimensions_string,
+	parse_whos_line_format, print_symbol_info_line): New static
+	functions, adapted from old symbol table class.
+	(do_who): Adapt to new symbol table objects.
+
+	* symtab.h (symbol_table::glob_variables): New functions.
+	(symbol_table::do_glob): New argument, vars_only.  Change all uses.
+
+	2007-06-22  John W. Eaton  <jwe@octave.org>
+
+	* symtab.cc (symbol_table::fcn_info::fcn_info_rep::help_for_dispatch):
+	New function.
+	* symtab.h: Provide decl.
+	(symbol_table::fcn_info::help_for_dispatch,
+	symbol_table::help_for_dispatch): New functions.
+
+	* help.cc (help_from_symbol_table): Call
+	symbol_table::help_for_dispatch instead of
+	extract_help_from_dispatch.
+
+	* help.cc (extract_help_from_dispatch): Delete.
+	* help.h: Delete decl.
+
+	2007-06-21  John W. Eaton  <jwe@octave.org>
+
+	* DLD-FUNCTIONS/dispatch.cc (class octave_dispatch): Delete class.
+	(builtin, any_arg_is_magic_colon, dispatch_record): Delete functions.
+	(Fbuiltin, Fdispatch): Adapt to new symbol table objects.
+
+	* symtab.cc (symbol_table::fcn_info::fcn_info_rep::print_dispatch):
+	New function.
+	* symtab.h: Provide decl.
+	(symbol_table::fcn_info::print_dispatch, symbol_table::print_dispatch):
+	New functions.
+
+	* symtab.h (symbol_table::fcn_info::fcn_info_rep::clear_dispatch,
+	symbol_table::fcn_info::clear_dispatch, symbol_table::clear_dispatch):
+	New functions.
+
+	* symtab.h (symbol_table::fcn_info::fcn_info_rep::get_dispatch,
+	symbol_table::fcn_info::get_dispatch, symbol_table::get_dispatch):
+	New functions.
+
+	* symtab.cc (symbol_table::fcn_info::fcn_info_rep::find):
+	Use leftmost class argument as dispatch type, or first argument if
+	there are no class arguments.
+
+	2007-06-20  John W. Eaton  <jwe@octave.org>
+
+	* ov-base.cc (Vprint_answer_id_name, Fprint_answer_id_name): Delete.
+	(octave_base_value::print_with_name): Always print name.
+
+	* ov-base.cc (Vsilent_functions): No longer static.
+	* ov-base.h: Provide decl.
+
+	* ov-class.cc (Fmethods): Define as command.
+
+	* ov-class.cc (octave_class::print): Simply call print_raw.
+
+	* ov-class.cc (octave_class::print_with_name): New function.
+	* ov-class.h: Provide decl.
+
+	2007-06-19  John W. Eaton  <jwe@octave.org>
+
+	* ov.cc (octave_value::do_unary_op, octave_value::do_binary_op):
+	Handle class methods.
+
+	* ov.cc (octave_value::unary_op_fcn_name,
+	octave_value::binary_op_fcn_name): New functions.
+	* ov.h: Provide decls.
+
+	* ov-typeinfo.cc (octave_value_typeinfo::register_unary_class_op,
+	octave_value_typeinfo::register_binary_class_op,
+	octave_value_typeinfo::do_register_unary_class_op,
+	octave_value_typeinfo::do_register_binary_class_op,
+	octave_value_typeinfo::do_lookup_unary_class_op,
+	octave_value_typeinfo::do_lookup_binary_class_op): New functions.
+	* ov-typeinfo.h: Provide decls.
+	
+	* ov-typeinfo.h (octave_value_typeinfo::unary_class_op_fcn,
+	octave_value_typeinfo::binary_class_op_fcn): New typedefs.
+	(octave_value_typeinfo::unary_class_ops,
+	octave_value_typeinfo::binary_class_ops): New data members.
+	(octave_value_typeinfo::octave_value_typeinfo): Initialize them.
+	(octave_value_typeinfo::lookup_unary_class_op,
+	octave_value_typeinfo::lookup_binary_class_op): New functions.
+
+	* OPERATORS/op-class.cc: New file.
+	* Makefile.in (OP_XSRC): Add it to the list.
+
+	* ov.cc (install_types): Call octave_class::register_type here.
+
+	* ov-class.h (octave_class): Implement by containing a map object
+	instead of deriving from octave_struct.
+	* ov-class.cc (octave_class::subsref, octave_class::subsasgn):
+	Don't use octave_class implementation as default action.
+
+	* ov.h, ov.cc (octave_value::octave_value (const Octave_map&, const
+	std::string&)): New constructor.
+
+	2007-06-18  John W. Eaton  <jwe@octave.org>
+
+	* ov-class.cc (octave_class::subsref, octave_class::subsasgn):
+	Handle dispatch to user-defined methods.
+
+	* parse.y (load_fcn_from_file): New arg, dispatch_type.
+	Change all uses.
+
+	* ov-fcn.h (octave_function::is_class_constructor,
+	octave_function::is_class_method, octave_function::dispatch_class):
+	New virtual functions.
+
+	* ov-usr-fcn.h (octave_user_function::dispatch_class,
+	octave_usr_function::stash_dispatch_class): New functions.
+	(octave_usr_fucntion::xdispatch_class): New data member.
+	* parse.y (frob_function): Call stash_dispatch_class here.
+
+	* ov-struct.cc (Ffieldnames): Also handle objects.
+
+	* ov-class.cc (Fmethods): New function.
+	* load-path.cc (load_path::do_methods): New function.
+	* load-path.h (load_path::methods): New function.
+
+	* ov.h (octave_value::is_object): New function.
+	* ov-base.h (octave_base_value::is_object): New virtual function.
+	* ov-class.h (octave_class::is_object): New function.
+	* ov-class.cc (Fisobject): New function.
+
+	2007-06-15  John W. Eaton  <jwe@octave.org>
+
+	* ov-class.cc (octave_class::print): Call display method if found.
+
+	* symtab.h (symbol_table::fcn_info::find_method): New function.
+	(symbol_table::find_method): New function.
+	(symbol_table::fcn_info::fcn_info_rep::find_method): Provide decl.
+	* symtab.cc (symbol_table::fcn_info::fcn_info_rep::find_method):
+	New function.
+	(symbol_table::fcn_info::fcn_info_rep::find): Use it.
+
+	2007-06-14  John W. Eaton  <jwe@octave.org>
+
+	* symtab.h (symbol_table::clear_mex_functions): Make it work.
+	(symbol_table::fcn_info::fcn_info_rep::clear_mex_function,
+	symbol_table::fcn_info::clear_mex_function): New functions.
+
+	2007-06-08  John W. Eaton  <jwe@octave.org>
+
+	* defun.cc (Falias): Delete.
+
+	* variables.cc (load_fcn_try_ctor): New function.
+	(lookup): call load_fcn_try_ctor instead of load_fcn_from_file.
+
+	* variables.cc, variables.h (at_top_level, lookup_by_name, lookup,
+	initialize_symbol_tables, fcn_out_of_date, symbol_out_of_date,
+	lookup_function, lookup_user_function, link_to_global_variable,
+	link_to_builtin_or_function, force_link_to_function, Fdocument,
+	is_local_variable, do_clear_all, do_clear_functions,
+	do_clear_globals, do_clear_variables, do_clear_function,
+	do_clear_global, do_clear_variable, do_clear_symbol,
+	do_clear_function_pattern, do_clear_global_pattern,
+	do_clear_variable_pattern, do_clear_symbol_pattern,
+	clear_function, clear_variable, clear_symbol):
+	Delete (some functionality moved to the new symtab.cc and some is
+	no longer needed).
+	(Fignore_function_time_stamp): Move to symtab.cc.
+
+	* lex.l (lookup_identifier): Delete.
+
+	* parse.y (is_function_file): New function.
+	(load_fcn_from_file): Return pointer to octave_function, not bool.
+
+	* ov-usr-fcn.h, ov-usr-fcn.cc (octave_user_function::argn_sr,
+	octave_user_function::nargin_sr, octave_user_function::nargout_sr,
+	octave_user_function::varargin_sr): Delete data members.
+	(octave_user_function::install_automatic_vars): Delete.
+	(octave_user_script::do_multi_index_op): New function.
+
+	* ov-fcn.h (octave_function::locked, octave_function::my_dir_name):
+	New data members.
+	(octave_function::dir_name, octave_function::stash_dir_name,
+	octave_function::lock, octave_function::unlock,
+	octave_function::islocked): New functions.
+
+	* of-fcn-handle.h, ov-fcn-handle.cc (octave_fcn_handle::subsref):
+	Call out_of_date_check here to simplify time stamp checking.
+	(octave_fcn_handle::reload_warning): Delete.
+
+	* ov.h (octave_value::is_user_script, octave_value::is_user_function):
+	New functions.
+	* ov-base.h (octave_base_value::is_user_script,
+	octave_base_value::is_user_function): New pure virtual functions.
+	* ov-fcn.h (octave_function::is_user_script,
+	octave_function::is_user_function): Delete.
+
+	* load-save.cc (install_loaded_variable): Greatly simplify.
+
+	* load-path.h, load-path.cc: Change private_fcn_file to private_file.
+	(load_path::private_fcn_map): New data member.
+	(load_path::do_add, load_path::do_remove, load_path::do_update):
+	Also manage private_file_map here.
+	(load_path::add_to_private_fcn_map): New function.
+	(load_path::remove_private_fcn_map): New function.
+	(load_path::do_find_private_fcn): Make it work.
+	(get_file_list): New function.
+	(load_path::do_display): Use it.  Display private map.
+	(load_path::find_method, load_path::find_fcn): Handle directory name.
+
+	* token.cc, token.h, toplev.cc, debug.cc, defun.cc, defun-dld.h,
+	defun-int.h, error.cc, help.cc, load-save.h, load-save.cc, mex.cc,
+	octave.cc, ov-fcn-handle.cc, ov-usr-fcn.cc, parse.h, parse.y,
+	lex.l, variables.cc: Adapt to new symbol table objects (my
+	apologies for the lack of detail).
+
+	* unwind-prot.h (unwind_protect::add): Set default value for ptr arg.
+
+	* pt-stmt.cc (tree_statement::eval): Rework method for deciding
+	whether to assign value to ans.
+
+	* pt-idx.cc (tree_index_expression::rvalue):
+	Looking up symbol may evaluaate first args now.
+
+	* pt-id.h, pt-id.cc (tree_identifier::document,
+	tree_identifier::is_defined, tree_identifier::define,
+	tree_identifier::is_function, tree_identifier::lookup,
+	tree_identifier::link_to_global): Delete.
+	(tree_identifier::do_lookup): Simplify.
+	(tree_identifier::rvalue): Looking up symbol can't execute script now.
+
+	* pt-misc.cc (tree_parameter_list::initialize_undefined,
+	tree_parameter_list::is_defined): Call is_variable for elt, not
+	is_defined.
+
+	* pt-fcn-handle.h (tree_anon_fcn_handle::fcn): Now pointer to
+	octave_user_function, not value.  Change all uses.
+
+	* pt-decl.h (tree_decl_command::initialized): Delete data member.
+	(tree_decl_elt::is_variable): New function.
+	* pt-decl.cc: Fix all uses of tree_decl_command::initialized.
+
+	* ls-hdf5.cc, ls-mat-ascii.cc, ls-mat4.cc, ls-mat5.cc,
+	ls-oct-ascii.cc, ls-oct-binary.cc, input.cc: Don't include symtab.h.
+
+	* dynamic-ld.h, dynamic-ld.cc (octave_dynamic_loader::load_oct,
+	octave_dynamic_loader::load_mex, octave_dynamic_loader::do_load_oct,
+	octave_dynamic_loader::do_load_mex): Adapt to new symbol table
+	objects.  Return pointer octave_function instead of bool.
+
+	* DLD-FUNCTIONS/dispatch.cc (Fbuiltin): Disable for now.
+	Disable code that works with old symbol tables.
+	(Fbuiltin): Simply call symbol_table::add_dispatch.
+
+	* pt-arg-list.cc, pt-arg-list.h, pt-assign.cc, pt-assign.h,
+	pt-binop.cc, pt-binop.h, pt-bp.h, pt-cell.cc, pt-cell.h,
+	pt-cmd.cc, pt-cmd.h, pt-colon.cc, pt-colon.h, pt-const.cc,
+	pt-const.h, pt-decl.cc, pt-decl.h, pt-except.cc, pt-except.h,
+	pt-exp.h, pt-fcn-handle.cc, pt-fcn-handle.h, pt-id.cc, pt-id.h,
+	pt-idx.cc, pt-idx.h, pt-jump.cc, pt-jump.h, pt-loop.cc, pt-loop.h,
+	pt-mat.cc, pt-mat.h, pt-misc.cc, pt-misc.h, pt-select.cc,
+	pt-select.h, pt-stmt.cc, pt-stmt.h, pt-unop.cc, pt-unop.h:
+	Adapt dup functions to use scope instead of symbol_table objects.
+
+	* TEMPLATE-INST/Array-sym.cc: Delete.
+	* Makefile.in (TI_XSRC): Remove it from the list.
+
+	* symtab.h, symtab.cc: Replace with new versions.
+
+	2007-05-16  John W. Eaton  <jwe@octave.org>
+
+	* oct-lvalue.cc, oct-lvalue.h (octave_lvalue::chg_fcn): Delete.
+	Fix all uses.
+
+	2007-05-15  John W. Eaton  <jwe@octave.org>
+
+	* load-path.cc (load_path::do_find_private_function): New function.
+	* load-path.h (load_path::do_find_private_function): Provide decl.
+        (load_path::find_private_function): New function.
+
+	2007-05-08  John W. Eaton  <jwe@octave.org>
+
+	* pt-idx.cc (tree_index_expression::rvalue): Handle dispatch here.
+
+	* pt-id.cc (tree_identifier::is_variable, tree_identifier::lookup):
+	New functions.
+	* pt-id.cc: Provide decls.
+
+	* parse.y (current_class_name): New global variable.
+	* parse.h: Provide decl.
+
+	* parse.y (load_fcn_from_file, parse_fcn_file):
+	New arg, dispatch_type.
+	(parse_fcn_file): Protect current_class_name and set it to
+	dispatch_type before parsing function.
+	(load_fcn_from_file): If dispatch_type is not empty, call
+	load_path::find_method instead of load_path::find_fcn.
+	* parse.h: Fix decls for extern functions.
+
+	* lex.h (lexical_feedback::parsing_class_method): New data member.
+	* lex.l (lexical_feedback::init): Initialize it.
+	(lookup_identifier): Check it and set sym_name accordingly.
+
+	* ov-usr-fcn.h (octave_user_function::mark_as_class_constructor,
+	octave_user_function::is_class_constructor,
+	octave_user_function::mark_as_class_method,
+	octave_user_function::is_class_method): New functions.
+	(octave_user_function::class_constructor,
+	octave_user_function::class_method): New data members.
+	* ov-usr-fcn.cc (octave_user_function::octave_user_function):
+	Initialize them.
+
+	* load-path.h, load-path.cc: Use typedefs to simplify template decls.
+	Use fcn consistently instead of function.
+	
+	2007-05-03  John W. Eaton  <jwe@octave.org>
+
+	* ov-class.cc (Fclass): Move here.
+	* ov-typeinfo.cc: From here.
+
+	* input.cc (octave_gets): Call load_path::update if user input
+	contains something other than one of the characters " \t\n\r".
+
+	* ov-class.cc, ov-class.h: New files.
+	* Makefile.in: Add them to the appropriate lists.
+
+	* load-path.cc (genpath): Skip directories beginning with "@".
+	(load_path::dir_info::get_file_list):  Don't return anything.
+	Call get_private_function_map here.
+	(load_path::dir_info::initialize): Not here.
+	(load_path::dir_info_::get_method_file_map): New function.
+	(load_path::method_map): New data member.
+	(load_path::do_clear): Also clear method_map.
+	(load_path::do_add): Also call add_to_method_map.
+	(load_path::do_update): Also clear method_map and call
+	(load_path::do_find_method): New function.
+	(load_path::do_add_to_method_map): New function.
+	(load_path::move_fcn_map, load_path::move_method_map): New functions.
+	(load_path::move): Use them.
+	(load_path::remove_fcn_map, load_path::remove_method_map):
+	New functions.
+	(load_path::remove): Use them.
+	* load-path.h: Provide/fix decls.
+	(load_path::find_method): New static function.
+
+	* Makefile.in (%.df : %.cc): Use mv instead of
+	$(simple-move-if-change-rule).
+
 2007-12-21  John W. Eaton  <jwe@octave.org>
 
 	Version 3.0.0 released.
 
 	* version.h (OCTAVE_VERSION): Now 3.0.0.
 	(OCTAVE_API_VERSION): Now api-v32.
 	(OCTAVE_RELEASE_DATE): Now 2007-12-21.
 
diff --git a/src/DLD-FUNCTIONS/dispatch.cc b/src/DLD-FUNCTIONS/dispatch.cc
--- a/src/DLD-FUNCTIONS/dispatch.cc
+++ b/src/DLD-FUNCTIONS/dispatch.cc
@@ -23,414 +23,63 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <list>
 #include <map>
 #include <string>
 
+#include "Cell.h"
+#include "oct-map.h"
 #include "defun-dld.h"
 #include "ov.h"
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
 #include "pager.h"
 #include "parse.h"
 #include "symtab.h"
 #include "variables.h"
 
-// FIXME should be using a map from type_id->name, rather
-// than type_name->name
-
-template class std::map<std::string,std::string>;
-
-typedef std::map<std::string,std::string> Table;
-
-class
-octave_dispatch : public octave_function
-{
-public:
-
-  // FIXME need to handle doc strings of dispatched functions, for
-  // example, by appending "for <f>(<type>,...) see <name>" for each
-  // time dispatch(f,type,name) is called.
-  octave_dispatch (const std::string &nm)
-    : octave_function (nm, "Overloaded function"), tab (), base (nm),
-      has_alias (false)
-  { }
-
-  // FIXME if we get deleted, we should restore the original
-  // symbol_record from base before dying.
-  ~octave_dispatch (void) { }
-
-  bool is_builtin_function (void) const { return true; }
-
-  octave_function *function_value (bool) { return this; }
-
-  octave_value do_index_op (const octave_value_list&, bool = false)
-  {
-    error ("dispatch: do_index_op");
-    return octave_value ();
-  }
-
-  octave_value subsref (const std::string&,
-			const std::list<octave_value_list>&)
-  {
-    error ("dispatch: subsref (str, list)");
-    panic_impossible ();
-    return octave_value ();
-  }
-
-  octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx,
-			     int nargout);
-
-  octave_value_list do_multi_index_op (int, const octave_value_list&);
-
-  void add (const std::string t, const std::string n);
-
-  void clear (const std::string t);
-
-  void print (std::ostream& os, bool pr_as_read=false) const;
-
-private:
-
-  Table tab;
-  std::string base;
-  bool has_alias;
-
-  octave_dispatch (void) 
-    : octave_function (), tab (), base (), has_alias (false) { }
-
-  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
-
-  DECLARE_OCTAVE_ALLOCATOR
-};
-
-DEFINE_OCTAVE_ALLOCATOR (octave_dispatch);
-
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_dispatch,
-				     "overloaded function", "function");
-
-void 
-octave_dispatch::add (const std::string t, const std::string n)
-{ 
-  if (tab.count (t) > 0 && tab[t] != n)
-    warning ("replacing %s(%s,...)->%s with %s",
-	     base.c_str (), t.c_str (), tab[t].c_str (), n.c_str ());
-
-  tab[t] = n;
-
-  if (t == "any")
-    has_alias = true;
-}
-
-void
-octave_dispatch::clear (const std::string t)
-{
-  tab.erase (t); 
-
-  if (t == "any")
-    has_alias = false;
-}
-
-octave_value_list
-octave_dispatch::subsref (const std::string& type,
-			  const std::list<octave_value_list>& idx,
-			  int nargout)
-{
-  octave_value_list retval;
-
-  switch (type[0])
-    {
-    case '(':
-      retval = do_multi_index_op (nargout, idx.front ());
-      break;
-
-    case '{':
-    case '.':
-      {
-	const std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
-      }
-      break;
-
-    default:
-      panic_impossible ();
-    }
-
-  if (idx.size () > 1)
-    retval = retval(0).next_subsref (type, idx);
-
-  return retval;
-}
-
-static octave_function*
-builtin (const std::string& base)
-{
-  octave_function *fcn = 0;
-
-  // Check if we are overriding a builtin function.  This is the
-  // case if builtin is protected.
-  symbol_record *builtin = fbi_sym_tab->lookup ("builtin:" + base, 0);
-
-  if (! builtin)
-    error ("builtin record has gone missing");
-
-  if (error_state)
-    return fcn;
-
-  if (builtin->is_read_only ())
-    {
-      // builtin is read only, so checking for updates is pointless
-      if (builtin->is_function ())
-        fcn = builtin->def().function_value ();
-      else
-	error ("builtin %s is not a function", base.c_str ());
-    }
-  else
-    {
-      // Check that builtin is up to date.
- 
-      // Don't try to fight octave's function name handling
-      // mechanism.  Instead, move dispatch record out of the way,
-      // and restore the builtin to its original name.
-      symbol_record *dispatch = fbi_sym_tab->lookup (base, 0);
-      if (! dispatch)
-	error ("dispatch record has gone missing");
-
-      dispatch->unprotect ();
-
-      fbi_sym_tab->rename (base, "dispatch:" + base);
-
-      fbi_sym_tab->rename ("builtin:" + base, base);
-
-      // check for updates to builtin function; ignore errors that
-      // appear (they interfere with renaming), and remove the updated
-      // name from the current symbol table.  FIXME check that
-      // updating a function updates it in all contexts --- it may be
-      // that it is updated only in the current symbol table, and not
-      // the caller.  I believe this won't be a problem because the
-      // caller will go through the same logic and end up with the
-      // newer version.
-      fcn = is_valid_function (base, "dispatch", 1);
-      int cache_error = error_state;
-      error_state = 0;
-      curr_sym_tab->clear_function (base);
-
-      // Move the builtin function out of the way and restore the
-      // dispatch fuction.
-      // FIXME what if builtin wants to protect itself?
-      symbol_record *found = fbi_sym_tab->lookup (base, 0);
-      bool readonly = found->is_read_only ();
-      found->unprotect ();
-      fbi_sym_tab->rename (base, "builtin:" + base);
-      fbi_sym_tab->rename ("dispatch:" + base, base);
-      if (readonly)
-	found->protect ();
-      dispatch->protect ();
-
-      // remember if there were any errors.
-      error_state = cache_error;
-    }
-
-  return fcn;
-}
-
-static bool
-any_arg_is_magic_colon (const octave_value_list& args)
-{
-  int nargin = args.length ();
-
-  for (int i = 0; i < nargin; i++)
-    if (args(i).is_magic_colon ())
-      return true;
-
-  return false;
-}
-
-octave_value_list
-octave_dispatch::do_multi_index_op (int nargout, const octave_value_list& args)
-{
-  octave_value_list retval;
-
-  if (error_state) return retval;
-
-  if (any_arg_is_magic_colon (args))
-    {
-      ::error ("invalid use of colon in function argument list");
-      return retval;
-    }
-
-  // If more than one argument, check if argument template matches any
-  // overloaded functions.  Also provide a catch-all '*' type to provide
-  // single level pseudo rename and replace functionality.
-  if (args.length () > 0 && tab.count (args(0).type_name ()) > 0)
-    retval = feval (tab[args(0).type_name()], args, nargout);
-  else if (has_alias)
-    retval = feval (tab["any"], args, nargout);
-  else
-    {
-      octave_function *fcn = builtin (base);
-      if (! error_state && fcn)
-        retval = fcn->do_multi_index_op (nargout, args);
-    }
-
-  return retval;
-}
-
-void 
-octave_dispatch::print (std::ostream& os, bool) const
-{
-  os << "Overloaded function " << base << std::endl;
-
-  for (Table::const_iterator it = tab.begin (); it != tab.end (); it++)
-    os << base << "(" << it->first << ",...)->" 
-       << it->second << "(" << it->first << ",...)"
-       << std::endl;
-}
-
 DEFUN_DLD (builtin, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@dots{}]} builtin (@var{f}, @dots{})\n\
 Call the base function @var{f} even if @var{f} is overloaded to\n\
 some other function for the given type signature.\n\
 @seealso{dispatch}\n\
 @end deftypefn")
 {
   octave_value_list retval; 
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       const std::string name (args(0).string_value ());
  
-      if (error_state)
-	return retval;
-
-      symbol_record *sr = lookup_by_name (name, 0);
-
-      if (sr && sr->is_function ())
+      if (! error_state)
 	{
-	  if (sr->def().type_id () == octave_dispatch::static_type_id ())
-	    {
-	      octave_function *fcn = builtin (name);
+	  octave_value fcn = symbol_table::find_function (name);
 
-	      if (!error_state && fcn)
-		retval = fcn->do_multi_index_op (nargout, args.splice (0, 1));
-	    }
+	  if (fcn.is_defined ())
+	    retval = feval (fcn.function_value (), args.splice (0, 1),
+			    nargout);
 	  else
-	    retval = feval (name, args.splice (0, 1), nargout);
+	    error ("builtin: lookup for symbol `%s' failed", name.c_str ());
 	}
       else
-	error ("builtin: lookup for symbol `%s' failed", name.c_str ());
+	error ("builtin: expecting function name as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
-static void
-dispatch_record (const std::string &f, const std::string &n, 
-		 const std::string &t)
-{
-  // find the base function in the symbol table, loading it if it
-  // is not already there; if it is already a dispatch, then bonus
-
-  symbol_record *sr = fbi_sym_tab->lookup (f, true);
-
-  if (sr->def().type_id () != octave_dispatch::static_type_id ())
-    {
-      // Preserve mark_as_command status
-      bool iscommand = sr->is_command ();
-
-      // Not an overloaded name, so if only display or clear then we are done
-      if (t.empty ())
-	return;
-
-      // sr is the base symbol; rename it to keep it safe.  When we need
-      // it we will rename it back again.
-      if (sr->is_read_only ()) 
-        {
-          sr->unprotect ();
-          fbi_sym_tab->rename (f, "builtin:" + f);
-  	  sr = fbi_sym_tab->lookup (f, true);
-          sr->protect ();
-	}
-      else 
-        fbi_sym_tab->rename (f, "builtin:" + f);
-
-      // It would be good to hide the builtin:XXX name, but since the
-      // new XXX name in the symbol table is set to BUILTIN_FUNCTION,
-      // things don't work quite the way we would like.
-      // sr->hide ();
-
-      // Problem:  when a function is first called a new record
-      // is created for it in the current symbol table, so calling
-      // dispatch on a function that has already been called, we
-      // should also clear it from all existing symbol tables.
-      // This is too much work, so we will only do it for the
-      // top level symbol table.  We can't use the clear_function() 
-      // method, because it won't clear builtin functions.  Instead 
-      // we check if the symbol is a function and clear it then.  This
-      // won't properly clear shadowed functions, or functions in
-      // other namespaces (such as the current, if called from a
-      // function).
-      symbol_record *local = top_level_sym_tab->lookup (f, false);
-      if (local && local->is_function ())
-	local->clear ();
-
-      // Build a new dispatch object based on the function definition
-      octave_dispatch *dispatch = new octave_dispatch (f);
-  
-      // Create a symbol record for the dispatch object.
-      sr = fbi_sym_tab->lookup (f, true);
-      sr->unprotect ();
-      sr->define (octave_value (dispatch), symbol_record::BUILTIN_FUNCTION); 
-      // std::cout << "iscommand('"<<f<<"')=" << iscommand << std::endl;
-      if (iscommand)
-	sr->mark_as_command();
-      sr->document ("\n\n@noindent\nOverloaded function:\n");
-      sr->make_eternal (); // FIXME why??
-      sr->mark_as_static ();
-      sr->protect ();
-    }
-
-  // clear/replace/extend the map with the new type-function pair
-  const octave_dispatch& rep
-    = dynamic_cast<const octave_dispatch&> (sr->def().get_rep ());
-
-  if (t.empty ())
-    // FIXME should return the list if nargout > 1
-    rep.print (octave_stdout);
-  else if (n.empty ())
-    {
-      // FIXME should we eliminate the dispatch function if
-      // there are no more elements?
-      // FIXME should clear the " $t:\w+" from the help string.
-      // FIXME -- seems bad to cast away const here...
-      octave_dispatch& xrep = const_cast<octave_dispatch&> (rep);
-
-      xrep.clear (t);
-    }
-  else
-    {
-      // FIXME -- seems bad to cast away const here...
-      octave_dispatch& xrep = const_cast<octave_dispatch&> (rep);
-
-      xrep.add (t, n);
-
-      if (! sr->help().empty ())
-	sr->document (sr->help() + "\n" + n + " (" + t + ", ...)\n");
-    }
-}
-
-DEFUN_DLD (dispatch, args, ,
+DEFUN_DLD (dispatch, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dispatch (@var{f}, @var{r}, @var{type})\n\
 \n\
 Replace the function @var{f} with a dispatch so that function @var{r}\n\
 is called when @var{f} is called with the first argument of the named\n\
 @var{type}. If the type is @var{any} then call @var{r} if no other type\n\
 matches.  The original function @var{f} is accessible using\n\
 @code{builtin (@var{f}, @dots{})}.\n\
@@ -438,50 +87,99 @@ matches.  The original function @var{f} 
 If @var{r} is omitted, clear dispatch function associated with @var{type}.\n\
 \n\
 If both @var{r} and @var{type} are omitted, list dispatch functions\n\
 for @var{f}.\n\
 @seealso{builtin}\n\
 @end deftypefn")
 {
   octave_value retval;
+
   int nargin = args.length ();
 
-  if (nargin < 1 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+  std::string f, r, t;
 
-  std::string f, t, n;
-  if (nargin > 0)
-    f = args(0).string_value ();
-
-  if (nargin == 2)
-    t = args(1).string_value ();
-  else if (nargin > 2)
+  if (nargin > 0 && nargin < 4)
     {
-      n = args(1).string_value ();
-      t = args(2).string_value ();
-    }
+      if (nargin > 0)
+	{
+	  f = args(0).string_value ();
+
+	  if (error_state)
+	    {
+	      error ("dispatch: expecting first argument to be function name");
+	      return retval;
+	    }
+	}
+
+      if (nargin > 1)
+	{
+	  r = args(1).string_value ();
 
-  if (error_state)
-    return retval;
-  
-  static bool register_type = true;
+	  if (error_state)
+	    {
+	      error ("dispatch: expecting second argument to be function name");
+	      return retval;
+	    }
+	}
+
+      if (nargin > 2)
+	{
+	  t = args(2).string_value ();
+
+	  if (error_state)
+	    {
+	      error ("dispatch: expecting third argument to be type name");
+	      return retval;
+	    }
+	}
 
-  // register dispatch function type if you have not already done so
-  if (register_type)
-    {
-      octave_dispatch::register_type ();
-      register_type = false;
-      fbi_sym_tab->lookup("dispatch")->mark_as_static ();
+      if (nargin == 1)
+	{
+	  if (nargout > 0)
+	    {
+	      symbol_table::fcn_info::dispatch_map_type dm
+		= symbol_table::get_dispatch (f);
+
+	      size_t len = dm.size ();
+
+	      Cell type_field (len, 1);
+	      Cell name_field (len, 1);
+
+	      symbol_table::fcn_info::dispatch_map_type::const_iterator p
+		= dm.begin ();
+
+	      for (size_t i = 0; i < len; i++)
+		{
+		  type_field(i) = p->first;
+		  name_field(i) = p->second;
+
+		  p++;
+		}
+
+	      Octave_map m;
+
+	      m.assign ("type", type_field);
+	      m.assign ("name", name_field);
+
+	      retval = m;
+	    }
+	  else
+	    symbol_table::print_dispatch (octave_stdout, f);
+	}
+      else if (nargin == 2)
+	{
+	  t = r;
+	  symbol_table::clear_dispatch (f, t);
+	}
+      else
+	symbol_table::add_dispatch (f, t, r);
     }
-
-  dispatch_record (f, n, t);
+  else
+    print_usage ();
 
   return retval;
 }
 
 /*
 
 %!test # builtin function replacement
 %! dispatch('sin','length','string')
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -95,17 +95,17 @@ OV_INTTYPE_INC := ov-base-int.h ov-int-t
 	ov-uint8.h ov-uint16.h ov-uint32.h ov-uint64.h
 
 OV_INCLUDES := ov-re-mat.h ov-cx-mat.h ov-ch-mat.h ov-cs-list.h ov-list.h \
 	ov-struct.h ov-scalar.h ov-range.h ov-complex.h \
 	ov-colon.h ov-base.h ov-base-mat.h ov-base-scalar.h \
 	ov-streamoff.h ov-str-mat.h ov-bool-mat.h ov-bool.h \
 	ov-cell.h ov.h ov-fcn.h ov-builtin.h ov-dld-fcn.h \
 	ov-mapper.h ov-mex-fcn.h ov-usr-fcn.h ov-fcn-handle.h \
-	ov-fcn-inline.h ov-typeinfo.h ov-type-conv.h \
+	ov-fcn-inline.h ov-class.h ov-typeinfo.h ov-type-conv.h \
 	$(OV_INTTYPE_INC)
 
 OV_SPARSE_INCLUDES := \
 	ov-base-sparse.h ov-bool-sparse.h ov-cx-sparse.h ov-re-sparse.h
 
 PT_INCLUDES := pt.h pt-all.h pt-arg-list.h pt-assign.h pt-binop.h \
         pt-bp.h	pt-cell.h pt-check.h pt-cmd.h pt-colon.h pt-const.h \
 	pt-decl.h pt-except.h pt-exp.h pt-fcn-handle.h pt-id.h pt-idx.h \
@@ -124,33 +124,33 @@ INCLUDES := Cell.h base-list.h builtins.
 	pager.h parse.h pr-output.h procstream.h sighandlers.h \
 	siglist.h sparse-xdiv.h sparse-xpow.h symtab.h sysdep.h \
 	token.h toplev.h unwind-prot.h utils.h variables.h \
 	version.h xdiv.h xpow.h \
 	$(OV_INCLUDES) \
 	$(PT_INCLUDES) \
 	$(OV_SPARSE_INCLUDES)
 
-TI_XSRC := Array-os.cc Array-sym.cc Array-tc.cc
+TI_XSRC := Array-os.cc Array-tc.cc
 
 TI_SRC := $(addprefix TEMPLATE-INST/, $(TI_XSRC))
 
 INTTYPE_OP_XSRC := op-int-concat.cc op-int-conv.cc op-double-conv.cc \
 	op-i8-i8.cc op-i16-i16.cc op-i32-i32.cc op-i64-i64.cc \
 	op-ui8-ui8.cc op-ui16-ui16.cc op-ui32-ui32.cc op-ui64-ui64.cc
 
 SPARSE_OP_XSRC := op-bm-sbm.cc op-b-sbm.cc op-cm-scm.cc op-cm-sm.cc \
 	op-cs-scm.cc op-cs-sm.cc op-m-scm.cc op-m-sm.cc op-sbm-b.cc \
 	op-sbm-bm.cc op-sbm-sbm.cc op-scm-cm.cc op-scm-cs.cc op-scm-m.cc \
 	op-scm-s.cc op-scm-scm.cc op-scm-sm.cc op-sm-cm.cc \
 	op-sm-cs.cc op-sm-m.cc op-sm-s.cc op-sm-scm.cc op-sm-sm.cc \
 	op-s-scm.cc op-s-sm.cc
 
-OP_XSRC := op-b-b.cc op-b-bm.cc op-bm-b.cc op-bm-bm.cc \
-	op-cell.cc op-chm.cc op-cm-cm.cc op-cm-cs.cc op-cm-m.cc \
+OP_XSRC := op-b-b.cc op-b-bm.cc op-bm-b.cc op-bm-bm.cc op-cell.cc \
+	op-chm.cc op-class.cc op-cm-cm.cc op-cm-cs.cc op-cm-m.cc \
 	op-cm-s.cc op-cs-cm.cc op-cs-cs.cc op-cs-m.cc \
 	op-cs-s.cc op-list.cc op-m-cm.cc \
 	op-m-cs.cc op-m-m.cc op-m-s.cc op-range.cc op-s-cm.cc \
 	op-s-cs.cc op-s-m.cc op-s-s.cc op-str-m.cc \
 	op-str-s.cc op-str-str.cc op-streamoff.cc op-struct.cc \
 	$(INTTYPE_OP_XSRC) \
 	$(SPARSE_OP_XSRC)
 
@@ -167,17 +167,17 @@ OV_SPARSE_SRC := \
 
 OV_SRC := ov-base.cc ov-ch-mat.cc \
 	ov-cs-list.cc ov-list.cc ov-re-mat.cc ov-cx-mat.cc \
 	ov-range.cc ov-scalar.cc ov-complex.cc ov-str-mat.cc \
 	ov-streamoff.cc ov-struct.cc \
 	ov-colon.cc ov-bool-mat.cc ov-bool.cc ov-cell.cc \
 	ov.cc ov-fcn.cc ov-builtin.cc ov-dld-fcn.cc ov-mapper.cc \
 	ov-mex-fcn.cc ov-usr-fcn.cc ov-fcn-handle.cc ov-fcn-inline.cc \
-	ov-typeinfo.cc \
+	ov-class.cc ov-typeinfo.cc \
 	$(OV_INTTYPE_SRC) \
 	$(OV_SPARSE_SRC)
 
 PT_SRC := pt.cc pt-arg-list.cc pt-assign.cc pt-bp.cc pt-binop.cc \
 	pt-cell.cc pt-check.cc pt-cmd.cc pt-colon.cc pt-const.cc \
 	pt-decl.cc pt-except.cc pt-exp.cc pt-fcn-handle.cc pt-id.cc \
 	pt-idx.cc pt-jump.cc pt-loop.cc pt-mat.cc pt-misc.cc \
 	pt-pr-code.cc pt-select.cc pt-stmt.cc pt-unop.cc
@@ -188,17 +188,17 @@ DIST_SRC := Cell.cc bitfcns.cc c-file-pt
 	help.cc input.cc lex.l load-path.cc load-save.cc ls-hdf5.cc \
 	ls-mat-ascii.cc ls-mat4.cc ls-mat5.cc ls-oct-ascii.cc \
 	ls-oct-binary.cc ls-utils.cc main.c mappers.cc matherr.c \
 	mex.cc oct-fstrm.cc oct-hist.cc oct-iostrm.cc oct-map.cc \
 	oct-obj.cc oct-prcstrm.cc oct-procbuf.cc oct-stream.cc \
 	octave.cc zfstream.cc oct-strstrm.cc oct-lvalue.cc pager.cc \
 	parse.y pr-output.cc procstream.cc sighandlers.cc \
 	siglist.c sparse-xdiv.cc sparse-xpow.cc strfns.cc \
-	symtab.cc syscalls.cc sysdep.cc token.cc toplev.cc \
+	syscalls.cc symtab.cc sysdep.cc token.cc toplev.cc \
 	unwind-prot.cc utils.cc variables.cc xdiv.cc xpow.cc \
 	$(OV_SRC) \
 	$(PT_SRC)
 
 SOURCES := $(DIST_SRC) $(OP_SRC) $(TI_SRC)
 
 BUILT_EXTRAS := graphics.h mxarray.h
 
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -65,33 +65,19 @@ static octave_user_function *
 get_user_function (const std::string& fname = std::string ())
 {
   octave_user_function *dbg_fcn = 0;
 
   if (fname.empty ())
     dbg_fcn = octave_call_stack::caller_user_function ();
   else
     {
-      symbol_record *ptr = curr_sym_tab->lookup (fname);
+      octave_value fcn = symbol_table::find_user_function (fname);
 
-      if (ptr && ptr->is_user_function ())
-	{
-	  octave_value tmp = ptr->def ();
-	  dbg_fcn = dynamic_cast<octave_user_function *> (tmp.function_value ());
-	}
-      else
-	{
-	  ptr = lookup_by_name (fname, false);
-
-	  if (ptr && ptr->is_user_function ())
-	    {
-	      octave_value tmp = ptr->def ();
-	      dbg_fcn = dynamic_cast<octave_user_function *> (tmp.function_value ());
-	    }
-	}
+      dbg_fcn = fcn.user_function_value ();
     }
 
   return dbg_fcn;
 }
 
 static void
 parse_dbfunction_params (const octave_value_list& args, 
 			 std::string& symbol_name, 
diff --git a/src/defun-dld.h b/src/defun-dld.h
--- a/src/defun-dld.h
+++ b/src/defun-dld.h
@@ -45,29 +45,29 @@ along with Octave; see the file COPYING.
 #define DEFUN_DLD(name, args_name, nargout_name, doc) \
   DEFUN_DLD_INTERNAL (name, args_name, nargout_name, false, doc)
 
 // This one can be used when `name' cannot be used directly (if it is
 // already defined as a macro).  In that case, name is already a
 // quoted string, and the internal name of the function must be passed
 // too (the convention is to use a prefix of "F", so "foo" becomes "Ffoo").
 
-#define DEFUNX_DLD(name, fname, fsname, args_name, nargout_name, doc) \
+#define DEFUNX_DLD(name, fname, fsname, gname, args_name, nargout_name, doc) \
   DEFUNX_DLD_INTERNAL (name, fname, args_name, nargout_name, false, doc)
 
 #else
 
 #define DEFUN_DLD(name, args_name, nargout_name, doc) \
   DECLARE_FUN (name, args_name, nargout_name); \
   DEFINE_FUN_INSTALLER_FUN (name, doc) \
   DECLARE_FUN (name, args_name, nargout_name)
 
-#define DEFUNX_DLD(name, fname, fsname, args_name, nargout_name, doc) \
+#define DEFUNX_DLD(name, fname, fsname, gname, args_name, nargout_name, doc) \
   DECLARE_FUNX (fname, args_name, nargout_name); \
-  DEFINE_FUNX_INSTALLER_FUN (name, fname, fsname, doc) \
+  DEFINE_FUNX_INSTALLER_FUN (name, fname, fsname, gname, doc) \
   DECLARE_FUNX (fname, args_name, nargout_name)
 
 #endif
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 class octave_value;
 
 extern OCTINTERP_API void print_usage (void);
 extern OCTINTERP_API void print_usage (const std::string&) GCC_ATTR_DEPRECATED;
 
 extern OCTINTERP_API void check_version (const std::string& version, const std::string& fcn);
 
 extern OCTINTERP_API void
-install_builtin_mapper (octave_mapper *mf);
+install_builtin_mapper (octave_mapper *mf, const std::string& name);
 
 extern OCTINTERP_API void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
 			  const std::string& doc, bool is_text_fcn = false,
 			  bool can_hide_function = true);
 
 extern OCTINTERP_API void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
@@ -69,47 +69,71 @@ alias_builtin (const std::string& alias,
   DECLARE_FUNX (F ## name, args_name, nargout_name)
 
 // Define the code that will be used to insert the new function into
 // the symbol table.  We look for this name instead of the actual
 // function so that we can easily install the doc std::string too.
 
 typedef bool (*octave_dld_fcn_installer) (const octave_shlib&, bool relative);
 
+typedef octave_function * (*octave_dld_fcn_getter) (const octave_shlib&, bool relative);
+
 #define DEFINE_FUN_INSTALLER_FUN(name, doc) \
   DEFINE_FUN_INSTALLER_FUN2(name, doc, CXX_ABI)
 
 #define DEFINE_FUN_INSTALLER_FUN2(name, doc, cxx_abi) \
   DEFINE_FUN_INSTALLER_FUN3(name, doc, cxx_abi)
 
 #define DEFINE_FUN_INSTALLER_FUN3(name, doc, cxx_abi) \
-  DEFINE_FUNX_INSTALLER_FUN3(#name, F ## name, FS ## name, doc, cxx_abi)
+  DEFINE_FUNX_INSTALLER_FUN3(#name, F ## name, FS ## name, G ## name, doc, cxx_abi)
 
-#define DEFINE_FUNX_INSTALLER_FUN(name, fname, fsname, doc) \
-  DEFINE_FUNX_INSTALLER_FUN2(name, fname, fsname, doc, CXX_ABI)
+#define DEFINE_FUNX_INSTALLER_FUN(name, fname, fsname, gname, doc) \
+  DEFINE_FUNX_INSTALLER_FUN2(name, fname, fsname, gname, doc, CXX_ABI)
 
-#define DEFINE_FUNX_INSTALLER_FUN2(name, fname, fsname, doc, cxx_abi) \
-  DEFINE_FUNX_INSTALLER_FUN3(name, fname, fsname, doc, cxx_abi)
+#define DEFINE_FUNX_INSTALLER_FUN2(name, fname, fsname, gname, doc, cxx_abi) \
+  DEFINE_FUNX_INSTALLER_FUN3(name, fname, fsname, gname, doc, cxx_abi)
 
-#define DEFINE_FUNX_INSTALLER_FUN3(name, fname, fsname, doc, cxx_abi) \
+#define DEFINE_FUNX_INSTALLER_FUN3(name, fname, fsname, gname, doc, cxx_abi) \
   extern "C" \
   OCTAVE_EXPORT \
   bool \
   fsname ## _ ## cxx_abi (const octave_shlib& shl, bool relative) \
   { \
     bool retval = true; \
  \
     check_version (OCTAVE_API_VERSION, name); \
  \
     if (error_state) \
       retval = false; \
     else \
       install_dld_function (fname, name, shl, doc, false, relative); \
  \
     return retval; \
+  } \
+ \
+  extern "C" \
+  OCTAVE_EXPORT \
+  octave_function * \
+  gname ## _ ## cxx_abi (const octave_shlib& shl, bool relative) \
+  { \
+    octave_function *retval = 0; \
+ \
+    check_version (OCTAVE_API_VERSION, name); \
+ \
+    if (! error_state) \
+      { \
+	octave_dld_function *fcn = new octave_dld_function (fname, shl, name, doc); \
+ \
+        if (relative) \
+          fcn->mark_relative (); \
+ \
+        retval = fcn; \
+      } \
+ \
+    return retval; \
   }
 
 // MAKE_BUILTINS is defined to extract function names and related
 // information and create the *.df files that are eventually used to
 // create the builtins.cc file.
 
 #if defined (MAKE_BUILTINS)
 
@@ -188,18 +212,19 @@ typedef bool (*octave_dld_fcn_installer)
 // FIXME -- Really want to avoid the following casts, since
 // (as always with casts) it may mask some real errors...
 
 #define DEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
 			      d_c_map, c_c_map, lo, hi, \
 			      ch_map_flag, can_ret_cmplx_for_real, doc) \
   install_builtin_mapper \
     (new octave_mapper \
-     (ch_map, d_b_map, c_b_map, d_d_map, d_c_map, c_c_map, \
-      lo, hi, ch_map_flag, can_ret_cmplx_for_real, #name, doc))
+       (ch_map, d_b_map, c_b_map, d_d_map, d_c_map, c_c_map, \
+        lo, hi, ch_map_flag, can_ret_cmplx_for_real, #name, doc), \
+     #name)
 
 #endif /* ! MAKE_BUILTINS */
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -124,166 +124,74 @@ check_version (const std::string& versio
 	     "       you can fix this problem by recompiling this .oct file",
 	     version.c_str (), fcn.c_str (), OCTAVE_API_VERSION);
     }
 }
 
 // Install variables and functions in the symbol tables.
 
 void
-install_builtin_mapper (octave_mapper *mf)
+install_builtin_mapper (octave_mapper *mf, const std::string& name)
 {
-  symbol_record *sym_rec = fbi_sym_tab->lookup (mf->name (), true);
-
-  unsigned int t
-    = symbol_record::BUILTIN_FUNCTION | symbol_record::MAPPER_FUNCTION;
-
-  sym_rec->unprotect ();
-  sym_rec->define (mf, t);
-  sym_rec->document (mf->doc_string ());
-  sym_rec->make_eternal ();
-  sym_rec->protect ();
+  symbol_table::install_built_in_function (name, octave_value (mf));
 }
 
 void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
 			  const std::string& doc, bool is_text_fcn,
 			  bool /* can_hide_function -- not yet implemented */)
 {
-  symbol_record *sym_rec = fbi_sym_tab->lookup (name, true);
+  octave_value fcn (new octave_builtin (f, name, doc));
 
-  unsigned int t = symbol_record::BUILTIN_FUNCTION;
+  symbol_table::install_built_in_function (name, fcn);
 
   if (is_text_fcn)
-    t |= symbol_record::COMMAND;
-
-  sym_rec->unprotect ();
-  sym_rec->define (new octave_builtin (f, name, doc), t);
-  sym_rec->document (doc);
-  sym_rec->make_eternal ();
-  sym_rec->protect ();
+    mark_as_command (name);
 }
 
 void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
 		      const octave_shlib& shl,
 		      const std::string& doc, bool is_text_fcn,
 		      bool relative)
 {
-  symbol_record *sym_rec = fbi_sym_tab->lookup (name, true);
-
-  unsigned int t = symbol_record::DLD_FUNCTION;
-
-  if (is_text_fcn)
-    t |= symbol_record::COMMAND;
-
-  sym_rec->unprotect ();
-
-  octave_dld_function *df = new octave_dld_function (f, shl, name, doc);
+  octave_dld_function *fcn = new octave_dld_function (f, shl, name, doc);
 
   if (relative)
-    df->mark_relative ();
+    fcn->mark_relative ();
 
-  sym_rec->define (df, t);
-  sym_rec->document (doc);
+  octave_value fval (fcn);
 
-  // Also insert the full name in the symbol table.  This way, we can
-  // properly cope with changes to LOAD_PATH.
+  symbol_table::install_built_in_function (name, fval);
 
-  symbol_record *full_sr = fbi_sym_tab->lookup (shl.file_name (), true);
-
-  full_sr->alias (sym_rec, true);
-  full_sr->hide ();
+  if (is_text_fcn)
+    mark_as_command (name);
 }
 
 void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
 		      const octave_shlib& shl, bool is_text_fcn,
 		      bool relative)
 {
-  symbol_record *sym_rec = fbi_sym_tab->lookup (name, true);
-
-  unsigned int t = symbol_record::MEX_FUNCTION;
-
-  if (is_text_fcn)
-    t |= symbol_record::COMMAND;
-
-  sym_rec->unprotect ();
-
-  octave_mex_function *mf = new octave_mex_function (fptr, fmex, shl, name);
+  octave_mex_function *fcn = new octave_mex_function (fptr, fmex, shl, name);
 
   if (relative)
-    mf->mark_relative ();
+    fcn->mark_relative ();
 
-  sym_rec->define (mf, t);
+  octave_value fval (fcn);
 
-  // Also insert the full name in the symbol table.  This way, we can
-  // properly cope with changes to LOAD_PATH.
+  symbol_table::install_built_in_function (name, fval);
 
-  symbol_record *full_sr = fbi_sym_tab->lookup (shl.file_name (), true);
-
-  full_sr->alias (sym_rec, true);
-  full_sr->hide ();
+  if (is_text_fcn)
+    mark_as_command (name);
 }
 
 void
 alias_builtin (const std::string& alias, const std::string& name)
 {
-  symbol_record *sr_name = fbi_sym_tab->lookup (name);
-
-  if (! sr_name)
-    panic ("can't alias to undefined name!");
-
-  symbol_record *sr_alias = fbi_sym_tab->lookup (alias, true);
-
-  if (sr_alias)
-    sr_alias->alias (sr_name);
-  else
-    panic ("can't find symbol record for builtin function `%s'",
-	   alias.c_str ());
+  symbol_table::alias_built_in_function (alias, name);
 }
 
-#if 0
-// This is insufficient to really make it possible to define an alias
-// for function.  There are a number of subtle problems related to
-// automatically reloading functions.
-DEFUN (alias, args, ,
-  "alias (alias, name)")
-{
-  octave_value retval;
-
-  int nargin = args.length ();
-
-  if (nargin == 2)
-    {
-      string alias = args(0).string_value ();
-      string name = args(1).string_value ();
-
-      if (! error_state)
-	{
-	  symbol_record *sr_name = lookup_by_name (name, false);
-
-	  if (sr_name && sr_name->is_function ())
-	    {
-	      symbol_record *sr_alias = fbi_sym_tab->lookup (alias, true);
-
-	      if (sr_alias)
-		sr_alias->alias (sr_name);
-	      else
-		error ("alias: unable to insert `%s' in symbol table",
-		       alias.c_str ());
-	    }
-	  else
-	    error ("alias: function `%s' does not exist", name.c_str ());
-	}
-    }
-  else
-    print_usage ();
-
-  return retval;
-}
-#endif
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -30,16 +30,19 @@ along with Octave; see the file COPYING.
 #include "oct-env.h"
 #include "oct-time.h"
 #include "file-stat.h"
 
 #include <defaults.h>
 
 #include "defun.h"
 #include "dynamic-ld.h"
+#include "ov-fcn.h"
+#include "ov-dld-fcn.h"
+#include "ov-mex-fcn.h"
 #include "parse.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 #define STRINGIFY(s) STRINGIFY1(s)
 #define STRINGIFY1(s) #s
 
@@ -290,52 +293,47 @@ octave_dynamic_loader::instance_ok (void
   return retval;
 }
 
 static
 void do_clear_function (const std::string& fcn_name)
 {
   warning_with_id ("Octave:reload-forces-clear", "  %s", fcn_name.c_str ());
 
-  curr_sym_tab->clear (fcn_name);
-
-  if (curr_sym_tab != top_level_sym_tab)
-    top_level_sym_tab->clear (fcn_name);
-
-  fbi_sym_tab->clear (fcn_name);
+  symbol_table::clear_user_function (fcn_name);
 }
 
 static void
 clear (octave_shlib& oct_file)
 {
   if (oct_file.number_of_functions_loaded () > 1)
     warning_with_id ("Octave:reload-forces-clear",
 		     "reloading %s clears the following functions:",
 		     oct_file.file_name().c_str ());
 
   octave_shlib_list::remove (oct_file, do_clear_function);
 }
 
-bool
+octave_function *
 octave_dynamic_loader::do_load_oct (const std::string& fcn_name,
 				    const std::string& file_name,
 				    bool relative)
 {
-  bool retval = false;
+  octave_function *retval = 0;
 
   octave_shlib oct_file;
 
   unwind_protect::begin_frame ("octave_dynamic_loader::do_load");
 
   unwind_protect_bool (octave_dynamic_loader::doing_load);
 
   doing_load = true;
 
   void *function
-    = octave_shlib_list::search (fcn_name, oct_file, mangle_name);
+    = octave_shlib_list::search (fcn_name, oct_file, xmangle_name);
 
   if (! error_state)
     {
       if (function
 	  && (! same_file (file_name, oct_file.file_name ())
 	      || oct_file.is_out_of_date ()))
 	{
 	  clear (oct_file);
@@ -372,49 +370,49 @@ octave_dynamic_loader::do_load_oct (cons
 		{
 		  if (oct_file)
 		    {
 		      if (relative)
 			oct_file.mark_relative ();
 
 		      octave_shlib_list::append (oct_file);
 
-		      function = oct_file.search (fcn_name, mangle_name);
+		      function = oct_file.search (fcn_name, xmangle_name);
 		    }
 		  else
 		    ::error ("%s is not a valid shared library",
 			     oct_file_name.c_str ());
 		}
 	    }
 	}
     }
 
   if (function)
     {
-      octave_dld_fcn_installer f
-	= FCN_PTR_CAST (octave_dld_fcn_installer, function);
+      octave_dld_fcn_getter f
+	= FCN_PTR_CAST (octave_dld_fcn_getter, function);
 
       retval = f (oct_file, relative);
 
       if (! retval)
 	::error ("failed to install .oct file function `%s'",
 		 fcn_name.c_str ());
     }
   
   unwind_protect::run_frame ("octave_dynamic_loader::do_load");
 
   return retval;
 }
 
-bool
+octave_function *
 octave_dynamic_loader::do_load_mex (const std::string& fcn_name,
 				    const std::string& file_name,
 				    bool relative)
 {
-  bool retval = false;
+  octave_function *retval = 0;
 
   octave_shlib mex_file;
 
   unwind_protect::begin_frame ("octave_dynamic_loader::do_load");
 
   unwind_protect_bool (octave_dynamic_loader::doing_load);
 
   doing_load = true;
@@ -462,21 +460,17 @@ octave_dynamic_loader::do_load_mex (cons
 	    }
 	  else
 	    ::error ("%s is not a valid shared library",
 		     mex_file_name.c_str ());
 	}
     }
 
   if (function)
-    {
-      install_mex_function (function, have_fmex, fcn_name, mex_file, relative);
-
-      retval = true;
-    }
+    retval = new octave_mex_function (function, have_fmex, mex_file, fcn_name);
   else
     ::error ("failed to install .mex file function `%s'", fcn_name.c_str ());
   
   unwind_protect::run_frame ("octave_dynamic_loader::do_load");
 
   return retval;
 }
 
@@ -494,32 +488,32 @@ octave_dynamic_loader::do_remove (const 
 
       if (shl.number_of_functions_loaded () == 0)
 	octave_shlib_list::remove (shl);
     }
 
   return retval;
 }
 
-bool
+octave_function *
 octave_dynamic_loader::load_oct (const std::string& fcn_name,
-				 const std::string& file_name,
-				 bool relative)
+				  const std::string& file_name,
+				  bool relative)
 {
   return (instance_ok ())
-    ? instance->do_load_oct (fcn_name, file_name, relative) : false;
+    ? instance->do_load_oct (fcn_name, file_name, relative) : 0;
 }
 
-bool
+octave_function *
 octave_dynamic_loader::load_mex (const std::string& fcn_name,
-				 const std::string& file_name,
-				 bool relative)
+				  const std::string& file_name,
+				  bool relative)
 {
   return (instance_ok ())
-    ? instance->do_load_mex (fcn_name, file_name, relative) : false;
+    ? instance->do_load_mex (fcn_name, file_name, relative) : 0;
 }
 
 bool
 octave_dynamic_loader::remove (const std::string& fcn_name, octave_shlib& shl)
 {
   return (instance_ok ()) ? instance->do_remove (fcn_name, shl) : false;
 }
 
@@ -532,13 +526,27 @@ octave_dynamic_loader::mangle_name (cons
   std::string retval ("FS");
 #endif
   retval.append (name);
   retval.append ("_");
   retval.append (STRINGIFY (CXX_ABI));
   return retval;
 }
 
+std::string
+octave_dynamic_loader::xmangle_name (const std::string& name)
+{
+#if defined (CXX_PREPENDS_UNDERSCORE)
+  std::string retval ("_G");
+#else
+  std::string retval ("G");
+#endif
+  retval.append (name);
+  retval.append ("_");
+  retval.append (STRINGIFY (CXX_ABI));
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -23,64 +23,72 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_dynamic_ld_h)
 #define octave_dynamic_ld_h 1
 
 #include <string>
 
 #include "oct-shlib.h"
 
+class octave_function;
+
 class
 octave_dynamic_loader
 {
 protected:
 
   octave_dynamic_loader (void) { }
 
 public:
 
   virtual ~octave_dynamic_loader (void) { }
 
-  static bool load_oct (const std::string& fcn_name,
-			const std::string& file_name = std::string (),
-			bool relative = false);
+  static octave_function *
+  load_oct (const std::string& fcn_name,
+	     const std::string& file_name = std::string (),
+	     bool relative = false);
 
-  static bool load_mex (const std::string& fcn_name,
-			const std::string& file_name = std::string (),
-			bool relative = false);
+  static octave_function *
+  load_mex (const std::string& fcn_name,
+	     const std::string& file_name = std::string (),
+	     bool relative = false);
 
   static bool remove (const std::string& fcn_name, octave_shlib& shl);
 
 private:
 
   // No copying!
 
   octave_dynamic_loader (const octave_dynamic_loader&);
 
   octave_dynamic_loader& operator = (const octave_dynamic_loader&);
 
   static octave_dynamic_loader *instance;
 
   static bool instance_ok (void);
 
-  bool do_load_oct (const std::string& fcn_name,
-		    const std::string& file_name = std::string (),
-		    bool relative = false);
+  octave_function *
+  do_load_oct (const std::string& fcn_name,
+		const std::string& file_name = std::string (),
+		bool relative = false);
 
-  bool do_load_mex (const std::string& fcn_name,
-		    const std::string& file_name = std::string (),
-		    bool relative = false);
+  octave_function *
+  do_load_mex (const std::string& fcn_name,
+		const std::string& file_name = std::string (),
+		bool relative = false);
 
   bool do_remove (const std::string& fcn_name, octave_shlib& shl);
 
   static bool doing_load;
 
 protected:
 
   static std::string mangle_name (const std::string& name);
+
+  static std::string xmangle_name (const std::string& name);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -638,17 +638,17 @@ warning_1 (const char *id, const char *f
   if (warn_opt == 2)
     {
       // Handle this warning as an error.
 
       error_2 (id, fmt, args);
     }
   else if (warn_opt == 1)
     {
-      if (curr_sym_tab != top_level_sym_tab
+      if (symbol_table::at_top_level ()
 	  && Vbacktrace_on_warning
 	  && ! warning_state
 	  && ! discard_warning_messages)
 	pr_where ("warning", false);
 
       vwarning ("warning", id, fmt, args);
 
       warning_state = 1;
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -39,16 +39,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <cerrno>
 #include <climits>
 #include <cstdio>
 
 #include <iostream>
+#include <stack>
 #include <vector>
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -56,16 +56,17 @@ along with Octave; see the file COPYING.
 #include "input.h"
 #include "load-path.h"
 #include "oct-obj.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pathsearch.h"
 #include "procstream.h"
+#include "pt-pr-code.h"
 #include "sighandlers.h"
 #include "symtab.h"
 #include "syswait.h"
 #include "toplev.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "quit.h"
@@ -558,49 +559,52 @@ keyword_help (void)
 // It's not likely that this does the right thing now.  FIXME
 
 string_vector
 make_name_list (void)
 {
   string_vector key = names (keyword_help ());
   int key_len = key.length ();
 
-  string_vector fbi = fbi_sym_tab->name_list ();
-  int fbi_len = fbi.length ();
+  string_vector bif = symbol_table::built_in_function_names ();
+  int bif_len = bif.length ();
 
-  string_vector glb = global_sym_tab->name_list ();
+  string_vector glb
+    = symbol_table::variable_names (symbol_table::global_scope ());
   int glb_len = glb.length ();
 
-  string_vector top = top_level_sym_tab->name_list ();
+  string_vector top
+    = symbol_table::variable_names (symbol_table::top_scope ());
   int top_len = top.length ();
 
   string_vector lcl;
-  if (top_level_sym_tab != curr_sym_tab)
-    lcl = curr_sym_tab->name_list ();
+  if (! symbol_table::at_top_level ())
+    lcl = symbol_table::variable_names ();
   int lcl_len = lcl.length ();
 
   string_vector ffl = load_path::fcn_names ();
   int ffl_len = ffl.length ();
 
   string_vector afl = autoloaded_functions ();
   int afl_len = afl.length ();
 
-  int total_len = key_len + fbi_len + glb_len + top_len + lcl_len + ffl_len + afl_len;
+  int total_len = key_len + bif_len + glb_len + top_len + lcl_len
+    + ffl_len + afl_len;
 
   string_vector list (total_len);
 
   // Put all the symbols in one big list.
 
   int j = 0;
   int i = 0;
   for (i = 0; i < key_len; i++)
     list[j++] = key[i];
 
-  for (i = 0; i < fbi_len; i++)
-    list[j++] = fbi[i];
+  for (i = 0; i < bif_len; i++)
+    list[j++] = bif[i];
 
   for (i = 0; i < glb_len; i++)
     list[j++] = glb[i];
 
   for (i = 0; i < top_len; i++)
     list[j++] = top[i];
 
   for (i = 0; i < lcl_len; i++)
@@ -644,63 +648,47 @@ display_names_from_help_list (std::ostre
 
       symbols.qsort ();
 
       symbols.list_in_columns (os);
     }
 }
 
 static void
-display_symtab_names (std::ostream& os, const string_vector& names,
+display_symtab_names (std::ostream& os, const std::list<std::string>& names,
 		      const std::string& desc)
 {
   if (! names.empty ())
     {
       os << "\n*** " << desc << ":\n\n";
-      names.list_in_columns (os);
+
+      string_vector sv (names);
+
+      sv.list_in_columns (os);
     }
 }
 
-#ifdef LIST_SYMBOLS
-#undef LIST_SYMBOLS
-#endif
-#define LIST_SYMBOLS(type, msg) \
-  do \
-    { \
-      string_vector names \
-	= fbi_sym_tab->name_list (string_vector (), true, type); \
-      display_symtab_names (octave_stdout, names, msg); \
-    } \
-  while (0)
-
 static void
 simple_help (void)
 {
   octave_stdout << "Help is available for the topics listed below.\n";
 
   additional_help_message (octave_stdout);
 
   display_names_from_help_list (octave_stdout, operator_help (),
 				"operators");
 
   display_names_from_help_list (octave_stdout, keyword_help (),
 				"reserved words");
 
-  // FIXME -- is this distinction needed?
-
-  LIST_SYMBOLS (symbol_record::COMMAND, "commands");
-
-  LIST_SYMBOLS (symbol_record::MAPPER_FUNCTION, "mapper functions");
+  display_symtab_names (octave_stdout,
+			symbol_table::built_in_function_names (),
+			"built-in functions");
 
-  LIST_SYMBOLS (symbol_record::BUILTIN_FUNCTION, "general functions");
-
-  // Also need to list variables and currently compiled functions from
-  // the symbol table, if there are any.
-
-  // Also need to search octave_path for script files.
+  // FIXME -- list functions defined on command line?
 
   load_path::display (octave_stdout);
 
   string_vector autoloaded = autoloaded_functions ();
 
   if (! autoloaded.empty ())
     {
       octave_stdout << "\n*** autoloaded functions:\n\n";
@@ -939,90 +927,44 @@ help_from_list (std::ostream& os, const 
 
 	  retval = true;
 	}
     }
 
   return retval;
 }
 
-std::string
-extract_help_from_dispatch (const std::string& nm)
-{
-  std::string retval;
-
-  symbol_record *builtin = fbi_sym_tab->lookup ("builtin:" + nm, 0);
-
-  if (builtin)
-    {
-      // Check that builtin is up to date.
- 
-      // Don't try to fight octave's function name handling
-      // mechanism.  Instead, move dispatch record out of the way,
-      // and restore the builtin to its original name.
-      symbol_record *dispatch = fbi_sym_tab->lookup (nm, 0);
-
-      if (dispatch)
-	{
-	  dispatch->unprotect ();
-
-	  fbi_sym_tab->rename (nm, "dispatch:" + nm);
-	  fbi_sym_tab->rename ("builtin:" + nm, nm);
-
-	  // Check for updates to builtin function; ignore errors
-	  // that appear (they interfere with renaming), and remove
-	  // the updated name from the current symbol table.  FIXME --
-	  // check that updating a function updates it in all
-	  // contexts.  It may be that it is updated only in the 
-	  // current symbol table, and not the caller.  I believe this
-	  // won't be a problem because the caller will go through the
-	  // same logic and end up with the newer version.
-
-	  octave_function *f = is_valid_function (nm);
-
-	  if (f)
-	    retval = builtin->help ();
-
-	  curr_sym_tab->clear_function (nm);
-
-	  // Move the builtin function out of the way and restore the
-	  // dispatch fuction.  FIXME what if builtin wants to
-	  // protect itself?
-
-	  fbi_sym_tab->rename (nm, "builtin:" + nm);
-	  fbi_sym_tab->rename ("dispatch:" + nm, nm);
-
-	  dispatch->protect ();
-	}
-      else
-	error ("failed to find dispatch record for `builtin:%s'", nm.c_str ());
-    }
-
-  return retval;
-}
-
 static bool
 raw_help_from_symbol_table (const std::string& nm, std::string& h, 
 			    std::string& w, bool& symbol_found)
 {
   bool retval = false;
 
-  symbol_record *sym_rec = lookup_by_name (nm, 0);
+  octave_value val = symbol_table::find_function (nm);
 
-  if (sym_rec && sym_rec->is_defined ())
+  if (val.is_defined ())
     {
-      symbol_found = true;
+      octave_function *fcn = val.function_value ();
+
+      if (fcn)
+	{
+	  symbol_found = true;
 
-      h = sym_rec->help ();
+	  h = fcn->doc_string ();
+
+	  if (! h.empty ())
+	    {
+	      retval = true;
 
-      if (h.length () > 0)
-	{
-	  w = sym_rec->which ();
+	      w = fcn->fcn_file_name ();
 
-	  retval = true;
+	      if (w.empty ())
+		w = fcn->is_user_function ()
+		  ? "command-line function" : "built-in function";
+	    }
 	}
     }
 
   return retval;
 }
 
 static bool
 help_from_symbol_table (std::ostream& os, const std::string& nm,
@@ -1032,17 +974,17 @@ help_from_symbol_table (std::ostream& os
 
   std::string h;
   std::string w;
 
   if (raw_help_from_symbol_table (nm, h, w, symbol_found))
     {
       if (h.length () > 0)
 	{
-	  h = extract_help_from_dispatch (nm) + h;
+	  h += "\n\n@noindent\n" + symbol_table::help_for_dispatch (nm);
 
 	  display_help_text (os, h);
 
 	  if (w.length () > 0 && ! Vsuppress_verbose_help_message)
 	    os << w << "\n";
 
 	  os << "\n";
 
@@ -1188,46 +1130,92 @@ for those, you must type @kbd{help comma
       else
 	builtin_help (argc, argv);
     }
 
   return retval;
 }
 
 static void
+display_file (std::ostream& os, const std::string& name,
+	      const std::string& fname, const std::string& type,
+	      bool pr_type_info, bool quiet)
+{
+  std::ifstream fs (fname.c_str (), std::ios::in);
+
+  if (fs)
+    {
+      if (pr_type_info && ! quiet)
+	os << name << " is the " << type
+		   << " defined from: " << fname << "\n\n";
+
+      char ch;
+
+      while (fs.get (ch))
+	os << ch;
+    }
+  else
+    os << "unable to open `" << fname << "' for reading!\n";
+}
+
+static void
 do_type (std::ostream& os, const std::string& name, bool pr_type_info,
 	 bool quiet, bool pr_orig_txt)
 {
-  symbol_record *sym_rec = lookup_by_name (name, 0);
+  // FIXME -- should we bother with variables here (earlier versions
+  // of Octave displayed them)?
+
+  octave_value val = symbol_table::varval (name);
 
-  if (sym_rec && sym_rec->is_defined ())
-    sym_rec->type (os, pr_type_info, quiet, pr_orig_txt);
+  if (val.is_defined ())
+    {
+      if (pr_type_info && ! quiet)
+	os << name << " is a variable\n";
+
+      val.print_raw (os, pr_orig_txt);
+
+      if (pr_type_info)
+	os << "\n";
+    }
   else
     {
-      std::string ff = fcn_file_in_path (name);
+      val = symbol_table::find_function (name);
 
-      if (! ff.empty ())
+      if (val.is_defined ())
 	{
-	  std::ifstream fs (ff.c_str (), std::ios::in);
+	  octave_function *fcn = val.function_value ();
+
+	  std::string fn = fcn ? fcn->fcn_file_name () : std::string ();
 
-	  if (fs)
+	  if (pr_orig_txt && ! fn.empty ())
+	    display_file (os, name, fn, "function", pr_type_info, quiet);
+	  else
 	    {
 	      if (pr_type_info && ! quiet)
-		os << name << " is the script file: " << ff << "\n\n";
-
-	      char ch;
+		{
+		  std::string type
+		    = fcn->is_user_function () ? "command-line" : "built-in";
 
-	      while (fs.get (ch))
-		os << ch;
+		  os << name << " is a " << type << " function:\n\n";
+		}
+
+	      tree_print_code tpc (os, "", pr_orig_txt);
+
+	      fcn->accept (tpc);
 	    }
-	  else
-	    os << "unable to open `" << ff << "' for reading!\n";
 	}
       else
-	error ("type: `%s' undefined", name.c_str ());
+	{
+	  std::string fn = fcn_file_in_path (name);
+
+	  if (! fn.empty ())
+	    display_file (os, name, fn, "script", pr_type_info, quiet);
+	  else
+	    error ("type: `%s' undefined", name.c_str ());
+	}
     }
 }
 
 DEFCMD (type, args, nargout,
   "-*- texinfo -*-\n\
 \n\
 @deffn {Command} type options name @dots{}\n\
 Display the definition of each @var{name} that refers to a function.\n\
@@ -1293,45 +1281,74 @@ the @code{-q} option suppresses this beh
  abort:
 
   return retval;
 }
 
 std::string
 do_which (const std::string& name)
 {
-  std::string retval;
+  octave_value val = symbol_table::find_function (name);
 
-  symbol_record *sym_rec = lookup_by_name (name, 0);
+  if (val.is_defined ())
+    {
+      octave_function *fcn = val.function_value ();
 
-  if (sym_rec && sym_rec->is_defined ())
-    retval = sym_rec->which ();
-  else
-    retval = fcn_file_in_path (name);
+      if (fcn)
+	{
+	  std::string fn = fcn->fcn_file_name ();
 
-  return retval;
+	  return fn.empty ()
+	    ? (fcn->is_user_function ()
+	       ? "command-line function" : "built-in function")
+	    : fn;
+	}
+    }
+
+  return fcn_file_in_path (name);
 }
 
 static void
 do_which (std::ostream& os, const std::string& name)
 {
-  symbol_record *sym_rec = lookup_by_name (name, 0);
+  std::string desc;
 
-  if (sym_rec && sym_rec->is_defined ())
-    sym_rec->which (os);
-  else
+  octave_value val = symbol_table::find_function (name);
+
+  if (val.is_defined ())
     {
-      std::string path = fcn_file_in_path (name);
+      octave_function *fcn = val.function_value ();
+
+      if (fcn)
+	{
+	  desc = fcn->fcn_file_name ();
 
-      if (! path.empty ())
-	os << "which: `" << name << "' is the script file\n"
-	   << path << "\n";
+	  if (desc.empty ())
+	    {
+	      if (fcn->is_user_function ())
+		desc = "is a command-line function";
+	      else
+		desc = "is a built-in function";
+	    }
+	  else
+	    desc = "is the function from the file " + desc;
+	}
+    }
+
+  if (desc.empty ())
+    {
+      std::string fn = fcn_file_in_path (name);
+
+      if (! fn.empty ())
+	desc = "is the script file " + fn;
       else
-	os << "which: `" << name << "' is undefined\n";
+	desc = "is undefined";
     }
+
+  os << "which: `" << name << "' " << desc << std::endl;
 }
 
 DEFCMD (which, args, nargout,
   "-*- texinfo -*-\n\
 @deffn {Command} which name @dots{}\n\
 Display the type of each @var{name}.  If @var{name} is defined from a\n\
 function file, the full name of the file is also displayed.\n\
 @seealso{help, lookfor}\n\
@@ -1759,16 +1776,17 @@ sentence of the help of the functions is
 functions help. All of the functions in Octave itself will correctly\n\
 find the first sentence, but the same can not be guaranteed for other\n\
 functions. Therefore the use of the '-all' argument might be necessary\n\
 to find related functions that are not part of Octave.\n\
 @seealso{help, which}\n\
 @end deffn")
 {
   octave_value_list retval;
+
   int nargin = args.length ();
   bool first_sentence_only = true;
 
   if (nargin != 1 && nargin != 2)
     {
       print_usage ();
       return retval;
     }
@@ -1892,19 +1910,21 @@ to find related functions that are not p
 		}
 	    }
 
 	  OCTAVE_QUIT;
 
 	  ptr++;
 	}
 
+      string_vector names;
+
+#ifdef OLD_SYMTAB
       // Check the symbol record table
-      string_vector names
-	= fbi_sym_tab->name_list (string_vector (), true);
+      names = fbi_sym_tab->name_list (string_vector (), true);
 
       for (octave_idx_type i = 0; i < names.length (); i++)
 	{
 	  std::string name = names (i);
 
 	  OCTAVE_QUIT;
 
 	  symbol_record *sr = lookup_by_name (name, 0);
@@ -1942,16 +1962,17 @@ to find related functions that are not p
 			  ret[1].append (first_help_sentence (h));
 			}
 		      else
 			print_lookfor (name, first_help_sentence (h));
 		    }
 		}
 	    }
 	}
+#endif
 
       string_vector dirs = load_path::dirs ();
 
       int len = dirs.length ();
 
       for (int i = 0; i < len; i++)
 	{
 	  names = load_path::files (dirs[i]);
@@ -1968,16 +1989,17 @@ to find related functions that are not p
 		  size_t l = name.length ();
 		  if (l > 4 && name.substr (l-4) == ".oct")
 		    name = name.substr (0, l - 4);
 		  else if (l > 2 && name.substr (l-2) == ".m")
 		    name = name.substr (0, l - 2);
 		  else
 		    continue;
 
+#ifdef OLD_SYMTAB
 		  // Check if already in symbol table
 		  symbol_record *sr = fbi_sym_tab->lookup (name);
 
 		  if (!sr)
 		    {
 		      // Check if this version is first in the path
 
 		      std::string file_name = load_path::find_fcn (name);
@@ -2032,28 +2054,30 @@ to find related functions that are not p
 				      ret[1].append (first_help_sentence (h));
 				    }
 				  else
 				    print_lookfor (name, first_help_sentence (h));
 				}
 			    }
 			}
 		    }
+#endif
 
 		  // Check if this function has autoloaded functions attached to it
 		  std::string file_name = load_path::find_fcn (name);
 
 		  string_vector autoload_fcns = reverse_lookup_autoload (file_name);
 
 		  if (! autoload_fcns.empty ())
 		    {
 		      for (int k = 0; k < autoload_fcns.length (); k++)
 			{
 			  std::string aname = autoload_fcns (k);
 
+#ifdef OLD_SYMTAB
 			  // Check if already in symbol table
 			  sr = fbi_sym_tab->lookup (aname);
 
 			  if (!sr)
 			    {
 			      // Must load to get help
 			      sr = lookup_by_name (aname, false);
 
@@ -2089,16 +2113,17 @@ to find related functions that are not p
 					  ret[0].append (aname);
 					  ret[1].append (first_help_sentence (h));
 					}
 				      else
 					print_lookfor (aname, first_help_sentence (h));
 				    }
 				}
 			    }
+#endif
 			}
 		    }
 		}
 	    }
 	}
 
       if (nargout != 0)
 	{
diff --git a/src/help.h b/src/help.h
--- a/src/help.h
+++ b/src/help.h
@@ -26,18 +26,16 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <string>
 
 class string_vector;
 
 extern string_vector make_name_list (void);
 
-extern std::string extract_help_from_dispatch (const std::string&);
-
 extern void display_help_text (std::ostream&, const std::string&);
 
 extern void display_usage_text (std::ostream&, const std::string&);
 
 extern void additional_help_message (std::ostream&);
 
 extern OCTINTERP_API std::string raw_help (const std::string&, bool&);
 
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -61,17 +61,16 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 #include "pager.h"
 #include "parse.h"
 #include "pathlen.h"
 #include "pt.h"
 #include "pt-const.h"
 #include "pt-stmt.h"
 #include "sighandlers.h"
-#include "symtab.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // Primary prompt string.
 static std::string VPS1 = "\\s:\\#> ";
 
@@ -260,17 +259,17 @@ octave_gets (void)
       flush_octave_stdout ();
 
       octave_diary << prompt;
 
       retval = interactive_input (prompt);
 
       // There is no need to update the load_path cache if there is no
       // user input.
-      if (! retval.empty ())
+      if (! retval.empty () && retval.find_first_not_of (" \t\n\r") != NPOS)
 	load_path::update ();
     }
   else
     retval = gnu_readline ("");
 
   current_input_line = retval;
 
   if (! current_input_line.empty ())
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -114,16 +114,19 @@ public:
   bool parsed_function_name;
 
   // Are we parsing a nested function?
   //   1 ==> Yes.
   //   0 ==> No.
   //  -1 ==> Yes, but it is the last one because we have seen EOF.
   int parsing_nested_function;
 
+  // TRUE means we are parsing a class method.
+  bool parsing_class_method;
+
   // Return transpose or start a string?
   bool quote_is_transpose;
 
 private:
 
   lexical_feedback (const lexical_feedback&);
 
   lexical_feedback& operator = (const lexical_feedback&);
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -237,17 +237,16 @@ static unsigned int Vtoken_count = 0;
 // Forward declarations for functions defined at the bottom of this
 // file.
 
 static void fixup_column_count (char *s);
 static void do_comma_insert_check (void);
 static int is_keyword_token (const std::string& s);
 static void prep_for_function (void);
 static void prep_for_nested_function (void);
-static symbol_record *lookup_identifier (const std::string& s);
 static std::string grab_help_text (void);
 static bool match_any (char c, const char *s);
 static bool next_token_is_sep_op (void);
 static bool next_token_is_bin_op (bool spc_prev);
 static bool next_token_is_postfix_unary_op (bool spc_prev);
 static std::string strip_trailing_whitespace (char *s);
 static void handle_number (void);
 static int handle_string (char delim, int text_style = 0);
@@ -839,16 +838,18 @@ reset_parser (void)
   BEGIN (INITIAL);
 
   parser_end_of_input = false;
   end_tokens_expected = 0;
 
   while (! symtab_context.empty ())
     symtab_context.pop ();
 
+  symbol_table::reset_parent_scope ();
+
   // We do want a prompt by default.
   promptflag = 1;
 
   // Error may have occurred inside some brackets, braces, or parentheses.
   nesting_level.clear ();
 
   // Clear out the stack of token info used to track line and column
   // numbers.
@@ -954,20 +955,16 @@ delete_input_buffer (void *buf)
   delete_buffer (static_cast<YY_BUFFER_STATE> (buf));
 }
 
 static void
 prep_for_function (void)
 {
   end_tokens_expected++;
 
-  // Prepare for local symbols.
-
-  tmp_local_sym_tab = new symbol_table ();
-
   promptflag--;
 
   lexer_flags.defining_func = true;
   lexer_flags.parsed_function_name = false;
   lexer_flags.beginning_of_function = true;
 
   if (! (reading_fcn_file || reading_script_file))
     input_line_number = 1;
@@ -1169,49 +1166,29 @@ is_keyword_token (const std::string& s)
       token_stack.push (yylval.tok_val);
 
       return kw->tok;
     }
 
   return 0;
 }
 
-// Try to find an identifier.  All binding to global or builtin
-// variables occurs when expressions are evaluated.
-
-static symbol_record *
-lookup_identifier (const std::string& name)
-{
-  std::string sym_name = name;
-
-  if (curr_sym_tab == fbi_sym_tab
-      && lexer_flags.parsing_nested_function)
-    sym_name = parent_function_name + ":" + sym_name;
-
-  return curr_sym_tab->lookup (sym_name, true);
-}
-
 static bool
 is_variable (const std::string& name)
 {
-  symbol_record *sr = curr_sym_tab->lookup (name);
-
-  return sr && sr->is_variable ();
+  return symbol_table::is_variable (name);
 }
 
 static void
 force_local_variable (const std::string& name)
 {
-  if (! is_variable (name))
-    curr_sym_tab->clear (name);
-
-  symbol_record *sr = curr_sym_tab->lookup (name, true);
-
-  if (sr)
-    sr->define (octave_value ());
+  octave_value& val = symbol_table::varref (name);
+
+  if (! val.is_defined ())
+    val = Matrix ();
 }
 
 // Grab the help text from an function file.
 
 // FIXME -- gobble_leading_white_space() in parse.y
 // duplicates some of this code!
 
 static std::string
@@ -2302,29 +2279,16 @@ handle_identifier (void)
       yyunput (c2, yytext);
 
       if (c2 != '=')
 	next_tok_is_eq = true;
     }
 
   yyunput (c1, yytext);
 
-  // Make sure we put the return values of a function in the symbol
-  // table that is local to the function.
-
-  // If we are defining a function and we have not seen the function
-  // name yet and the next token is `=', then this identifier must be
-  // the only return value for the function and it belongs in the
-  // local symbol table.
-
-  if (next_tok_is_eq
-      && lexer_flags.defining_func
-      && ! lexer_flags.parsed_function_name)
-    curr_sym_tab = tmp_local_sym_tab;
-
   // Kluge alert.
   //
   // If we are looking at a text style function, set up to gobble its
   // arguments.
   //
   // If the following token is `=', or if we are parsing a function
   // return list or function parameter list, or if we are looking at
   // something like [ab,cd] = foo (), force the symbol to be inserted
@@ -2352,19 +2316,23 @@ handle_identifier (void)
     }
 
   // Find the token in the symbol table.  Beware the magic
   // transformation of the end keyword...
 
   if (tok == "end")
     tok = "__end__";    
 
-  yylval.tok_val = new token (lookup_identifier (tok),
-			      input_line_number,
-			      current_input_column);
+  yylval.tok_val = new token (&(symbol_table::insert (tok)),
+			      input_line_number, current_input_column);
+
+  // FIXME -- this forces a link for tok in the chain of variables for
+  // the current scope.  Probably this step should be done
+  // differently, maybe in symbol_table::insert?
+  symbol_table::varref (tok);
 
   token_stack.push (yylval.tok_val);
 
   // After seeing an identifer, it is ok to convert spaces to a comma
   // (if needed).
 
   lexer_flags.convert_spaces_to_comma = true;
 
@@ -2394,16 +2362,17 @@ lexical_feedback::init (void)
   // Not initially inside a loop or if statement.
   looping = 0;
 
   // Not initially defining a function.
   beginning_of_function = false;
   defining_func = false;
   parsed_function_name = false;
   parsing_nested_function = 0;
+  parsing_class_method = false;
 
   // Not initiallly looking at a function handle.
   looking_at_function_handle = 0;
 
   // Not parsing a function return or parameter list.
   looking_at_return_list = false;
   looking_at_parameter_list = false;
 
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -38,18 +38,18 @@ along with Octave; see the file COPYING.
 #include "load-path.h"
 #include "pager.h"
 #include "parse.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
 load_path *load_path::instance = 0;
-load_path::hook_function_ptr load_path::add_hook = execute_pkg_add;
-load_path::hook_function_ptr load_path::remove_hook = execute_pkg_del;
+load_path::hook_fcn_ptr load_path::add_hook = execute_pkg_add;
+load_path::hook_fcn_ptr load_path::remove_hook = execute_pkg_del;
 std::string load_path::command_line_path;
 std::string load_path::sys_path;
 
 void
 load_path::dir_info::update (void)
 {
   if (is_relative)
     initialize ();
@@ -76,40 +76,28 @@ load_path::dir_info::initialize (void)
   is_relative = ! octave_env::absolute_pathname (dir_name);
 
   file_stat fs (dir_name);
 
   if (fs)
     {
       dir_mtime = fs.mtime ();
 
-      bool has_private_subdir = get_file_list (dir_name);
-
-      if (! error_state)
-	{
-	  if (has_private_subdir)
-	    {
-	      std::string pdn = file_ops::concat (dir_name, "private");
-
-	      get_private_function_map (pdn);
-	    }
-	}
+      get_file_list (dir_name);
     }
   else
     {
       std::string msg = fs.error ();
       warning ("load_path: %s: %s", dir_name.c_str (), msg.c_str ());
     }
 }
 
-bool
+void
 load_path::dir_info::get_file_list (const std::string& d)
 {
-  bool has_private_subdir = false;
-
   dir_entry dir (d);
 
   if (dir)
     {
       string_vector flist = dir.read ();
 
       octave_idx_type len = flist.length ();
 
@@ -126,18 +114,20 @@ load_path::dir_info::get_file_list (cons
 	  std::string full_name = file_ops::concat (d, fname);
 
 	  file_stat fs (full_name);
 
 	  if (fs)
 	    {
 	      if (fs.is_dir ())
 		{
-		  if (! has_private_subdir && fname == "private")
-		    has_private_subdir = true;
+		  if (fname == "private")
+		    get_private_file_map (full_name);
+		  else if (fname[0] == '@')
+		    get_method_file_map (full_name, fname.substr (1));
 		}
 	      else
 		{
 		  all_files[all_files_count++] = fname;
 
 		  size_t pos = fname.rfind ('.');
 
 		  if (pos != NPOS)
@@ -159,23 +149,23 @@ load_path::dir_info::get_file_list (cons
       all_files.resize (all_files_count);
       fcn_files.resize (fcn_files_count);
     }
   else
     {
       std::string msg = dir.error ();
       warning ("load_path: %s: %s", d.c_str (), msg.c_str ());
     }
-
-  return has_private_subdir;
 }
 
-void
-load_path::dir_info::get_private_function_map (const std::string& d)
+load_path::dir_info::fcn_file_map_type
+get_fcn_files (const std::string& d)
 {
+  load_path::dir_info::fcn_file_map_type retval;
+
   dir_entry dir (d);
 
   if (dir)
     {
       string_vector flist = dir.read ();
 
       octave_idx_type len = flist.length ();
 
@@ -199,26 +189,41 @@ load_path::dir_info::get_private_functio
 
 		  if (ext == ".m")
 		    t = load_path::M_FILE;
 		  else if (ext == ".oct")
 		    t = load_path::OCT_FILE;
 		  else if (ext == ".mex")
 		    t = load_path::MEX_FILE;
 
-		  private_function_map[base] |= t;
+		  retval[base] |= t;
 		}
 	    }
 	}
     }
   else
     {
       std::string msg = dir.error ();
       warning ("load_path: %s: %s", d.c_str (), msg.c_str ());
     }
+
+  return retval;
+}
+
+void
+load_path::dir_info::get_private_file_map (const std::string& d)
+{
+  private_file_map = get_fcn_files (d);
+}
+
+void
+load_path::dir_info::get_method_file_map (const std::string& d,
+					  const std::string& class_name)
+{
+  method_file_map[class_name] = get_fcn_files (d);
 }
 
 bool
 load_path::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
@@ -229,16 +234,19 @@ load_path::instance_ok (void)
       ::error ("unable to create load path object!");
 
       retval = false;
     }
 
   return retval;
 }
 
+// FIXME -- maybe we should also maintain a map to speed up this
+// method of access.
+
 load_path::const_dir_info_list_iterator
 load_path::find_dir_info (const std::string& dir_arg) const
 {
   std::string dir = file_ops::tilde_expand (dir_arg);
 
   const_dir_info_list_iterator retval = dir_info_list.begin ();
 
   while (retval != dir_info_list.end ())
@@ -272,61 +280,91 @@ load_path::find_dir_info (const std::str
 
 bool
 load_path::contains (const std::string& dir) const
 {
   return find_dir_info (dir) != dir_info_list.end ();
 }
 
 void
-load_path::move (dir_info_list_iterator i, bool at_end)
+load_path::move_fcn_map (const std::string& dir_name,
+			 const string_vector& fcn_files, bool at_end)
 {
-  if (dir_info_list.size () > 1)
+  octave_idx_type len = fcn_files.length ();
+
+  for (octave_idx_type k = 0; k < len; k++)
     {
-      dir_info di = *i;
-
-      dir_info_list.erase (i);
+      std::string fname = fcn_files[k];
 
-      if (at_end)
-	dir_info_list.push_back (di);
-      else
-	dir_info_list.push_front (di);
+      std::string ext;
+      std::string base = fname;
+
+      size_t pos = fname.rfind ('.');
 
-      std::string dir = di.dir_name;
+      if (pos != NPOS)
+	{
+	  base = fname.substr (0, pos);
+	  ext = fname.substr (pos);
+	}
 
-      string_vector fcn_files = di.fcn_files;
+      file_info_list_type& file_info_list = fcn_map[base];
 
-      octave_idx_type len = fcn_files.length ();
-
-      for (octave_idx_type k = 0; k < len; k++)
+      if (file_info_list.size () == 1)
+	continue;
+      else
 	{
-	  std::string fname = fcn_files[k];
+	  for (file_info_list_iterator p = file_info_list.begin ();
+	       p != file_info_list.end ();
+	       p++)
+	    {
+	      if (p->dir_name == dir_name)
+		{
+		  file_info fi = *p;
 
-	  std::string ext;
-	  std::string base = fname;
+		  file_info_list.erase (p);
+
+		  if (at_end)
+		    file_info_list.push_back (fi);
+		  else
+		    file_info_list.push_front (fi);
 
-	  size_t pos = fname.rfind ('.');
+		  break;
+		}
+	    }
+	}
+    }
+}
 
-	  if (pos != NPOS)
-	    {
-	      base = fname.substr (0, pos);
-	      ext = fname.substr (pos);
-	    }
+void
+load_path::move_method_map (const std::string& dir_name, bool at_end)
+{
+  for (method_map_iterator i = method_map.begin ();
+       i != method_map.end ();
+       i++)
+    {
+      std::string class_name = i->first;
 
-	  std::list<file_info>& file_info_list = fcn_map[base];
+      fcn_map_type& fm = i->second;
+
+      std::string full_dir_name
+	= file_ops::concat (dir_name, "@" + class_name);
+
+      for (fcn_map_iterator q = fm.begin (); q != fm.end (); q++)
+	{
+	  file_info_list_type& file_info_list = q->second;
 
 	  if (file_info_list.size () == 1)
 	    continue;
 	  else
 	    {
-	      for (std::list<file_info>::iterator p = file_info_list.begin ();
-		   p != file_info_list.end ();
-		   p++)
+	      for (file_info_list_iterator p = file_info_list.begin ();
+	       p != file_info_list.end ();
+	       p++)
 		{
-		  if (p->dir_name == dir)
+		  if (p->dir_name == full_dir_name)
 		    {
 		      file_info fi = *p;
 
 		      file_info_list.erase (p);
 
 		      if (at_end)
 			file_info_list.push_back (fi);
 		      else
@@ -335,16 +373,40 @@ load_path::move (dir_info_list_iterator 
 		      break;
 		    }
 		}
 	    }
 	}
     }
 }
 
+void
+load_path::move (dir_info_list_iterator i, bool at_end)
+{
+  if (dir_info_list.size () > 1)
+    {
+      dir_info di = *i;
+
+      dir_info_list.erase (i);
+
+      if (at_end)
+	dir_info_list.push_back (di);
+      else
+	dir_info_list.push_front (di);
+
+      std::string dir_name = di.dir_name;
+
+      move_fcn_map (dir_name, di.fcn_files, at_end);
+
+      // No need to move elements of private function map.
+
+      move_method_map (dir_name, at_end);
+    }
+}
+
 static void
 maybe_add_path_elts (std::string& path, const std::string& dir)
 {
   std::string tpath = genpath (dir);
 
   if (! tpath.empty ())
     path += dir_path::path_sep_str + tpath;
 }
@@ -382,16 +444,18 @@ load_path::do_initialize (bool set_initi
   do_set (xpath, false);
 }
 
 void
 load_path::do_clear (void)
 {
   dir_info_list.clear ();
   fcn_map.clear ();
+  private_fcn_map.clear ();
+  method_map.clear ();
 
   do_append (".", false);
 }
 
 static std::list<std::string>
 split_path (const std::string& p)
 {
   std::list<std::string> retval;
@@ -498,16 +562,20 @@ load_path::do_add (const std::string& di
 		{
 		  if (at_end)
 		    dir_info_list.push_back (di);
 		  else
 		    dir_info_list.push_front (di);
 
 		  add_to_fcn_map (di, true);
 
+		  add_to_private_fcn_map (di);
+
+		  add_to_method_map (di, true);
+
 		  if (add_hook)
 		    add_hook (dir);
 		}
 	    }
 	  else if (warn)
 	    warning ("addpath: %s: not a directory", dir_arg.c_str ());
 	}
       else if (warn)
@@ -522,16 +590,106 @@ load_path::do_add (const std::string& di
   i = find_dir_info (".");
 
   if (i != dir_info_list.end ())
     move (i, false);
   else
     panic_impossible ();
 }
 
+void
+load_path::remove_fcn_map (const std::string& dir,
+			   const string_vector& fcn_files)
+{
+  octave_idx_type len = fcn_files.length ();
+
+  for (octave_idx_type k = 0; k < len; k++)
+    {
+      std::string fname = fcn_files[k];
+
+      std::string ext;
+      std::string base = fname;
+
+      size_t pos = fname.rfind ('.');
+
+      if (pos != NPOS)
+	{
+	  base = fname.substr (0, pos);
+	  ext = fname.substr (pos);
+	}
+
+      file_info_list_type& file_info_list = fcn_map[base];
+
+      for (file_info_list_iterator p = file_info_list.begin ();
+	   p != file_info_list.end ();
+	   p++)
+	{
+	  if (p->dir_name == dir)
+	    {
+	      file_info_list.erase (p);
+
+	      if (file_info_list.empty ())
+		fcn_map.erase (fname);
+
+	      break;
+	    }
+	}
+    }
+}
+
+void
+load_path::remove_private_fcn_map (const std::string& dir)
+{
+  private_fcn_map_iterator p = private_fcn_map.find (dir);
+
+  if (p != private_fcn_map.end ())
+    private_fcn_map.erase (p);
+}
+
+void
+load_path::remove_method_map (const std::string& dir)
+{
+  for (method_map_iterator i = method_map.begin ();
+       i != method_map.end ();
+       i++)
+    {
+      std::string class_name = i->first;
+
+      fcn_map_type& fm = i->second;
+
+      std::string full_dir_name = file_ops::concat (dir, "@" + class_name);
+
+      for (fcn_map_iterator q = fm.begin (); q != fm.end (); q++)
+	{
+	  file_info_list_type& file_info_list = q->second;
+
+	  if (file_info_list.size () == 1)
+	    continue;
+	  else
+	    {
+	      for (file_info_list_iterator p = file_info_list.begin ();
+	       p != file_info_list.end ();
+	       p++)
+		{
+		  if (p->dir_name == full_dir_name)
+		    {
+		      file_info_list.erase (p);
+
+		      // FIXME -- if there are no other elements, we
+		      // should remove this element of fm but calling
+		      // erase here would invalidate the iterator q.
+
+		      break;
+		    }
+		}
+	    }
+	}
+    }
+}
+
 bool
 load_path::do_remove (const std::string& dir_arg)
 {
   bool retval = false;
 
   if (! dir_arg.empty ())
     {
       if (dir_arg == ".")
@@ -553,195 +711,290 @@ load_path::do_remove (const std::string&
 
 	      if (remove_hook)
 		remove_hook (dir);
 
 	      string_vector fcn_files = i->fcn_files;
 
 	      dir_info_list.erase (i);
 
-	      octave_idx_type len = fcn_files.length ();
-
-	      for (octave_idx_type k = 0; k < len; k++)
-		{
-		  std::string fname = fcn_files[k];
-
-		  std::string ext;
-		  std::string base = fname;
-
-		  size_t pos = fname.rfind ('.');
-
-		  if (pos != NPOS)
-		    {
-		      base = fname.substr (0, pos);
-		      ext = fname.substr (pos);
-		    }
+	      remove_fcn_map (dir, fcn_files);
 
-		  std::list<file_info>& file_info_list = fcn_map[base];
+	      remove_private_fcn_map (dir);
 
-		  for (std::list<file_info>::iterator p = file_info_list.begin ();
-		       p != file_info_list.end ();
-		       p++)
-		    {
-		      if (p->dir_name == dir)
-			{
-			  file_info_list.erase (p);
-
-			  if (file_info_list.empty ())
-			    fcn_map.erase (fname);
-
-			  break;
-			}
-		    }
-		}
+	      remove_method_map (dir);
 	    }
 	}
     }
 
   return retval;
 }
 
 void
 load_path::do_update (void) const
 {
   // I don't see a better way to do this because we need to
   // preserve the correct directory ordering for new files that
   // have appeared.
 
   fcn_map.clear ();
 
+  private_fcn_map.clear ();
+
+  method_map.clear ();
+
   for (dir_info_list_iterator p = dir_info_list.begin ();
        p != dir_info_list.end ();
        p++)
     {
       dir_info& di = *p;
 
       di.update ();
 
       add_to_fcn_map (di, true);
+
+      add_to_private_fcn_map (di);
+
+      add_to_method_map (di, true);
     }
 }
 
+bool
+load_path::check_file_type (std::string& fname, int type, int possible_types,
+			    const std::string& fcn, const char *who)
+{
+  bool retval = false;
+
+  if (type == load_path::OCT_FILE)
+    {
+      if ((type & possible_types) == load_path::OCT_FILE)
+	{
+	  fname += ".oct";
+	  retval = true;
+	}
+    }
+  else if (type == load_path::M_FILE)
+    {
+      if ((type & possible_types) == load_path::M_FILE)
+	{
+	  fname += ".m";
+	  retval = true;
+	}
+    }
+  else if (type == load_path::MEX_FILE)
+    {
+      if ((type & possible_types) == load_path::MEX_FILE)
+	{
+	  fname += ".mex";
+	  retval = true;
+	}
+    }
+  else if (type == (load_path::M_FILE | load_path::OCT_FILE))
+    {
+      if (possible_types & load_path::OCT_FILE)
+	{
+	  fname += ".oct";
+	  retval = true;
+	}
+      else if (possible_types & load_path::M_FILE)
+	{
+	  fname += ".m";
+	  retval = true;
+	}
+    }
+  else if (type == (load_path::M_FILE | load_path::MEX_FILE))
+    {
+      if (possible_types & load_path::MEX_FILE)
+	{
+	  fname += ".mex";
+	  retval = true;
+	}
+      else if (possible_types & load_path::M_FILE)
+	{
+	  fname += ".m";
+	  retval = true;
+	}
+    }
+  else if (type == (load_path::OCT_FILE | load_path::MEX_FILE))
+    {
+      if (possible_types & load_path::OCT_FILE)
+	{
+	  fname += ".oct";
+	  retval = true;
+	}
+      else if (possible_types & load_path::MEX_FILE)
+	{
+	  fname += ".mex";
+	  retval = true;
+	}
+    }
+  else if (type == (load_path::M_FILE | load_path::OCT_FILE
+		    | load_path::MEX_FILE))
+    {
+      if (possible_types & load_path::OCT_FILE)
+	{
+	  fname += ".oct";
+	  retval = true;
+	}
+      else if (possible_types & load_path::MEX_FILE)
+	{
+	  fname += ".mex";
+	  retval = true;
+	}
+      else if (possible_types & load_path::M_FILE)
+	{
+	  fname += ".m";
+	  retval = true;
+	}
+    }
+  else
+    error ("%s: %s: invalid type code = %d", who, fcn.c_str (), type);
+
+  return retval;
+} 
+
 std::string
-load_path::do_find_fcn (const std::string& fcn, int type) const
+load_path::do_find_fcn (const std::string& fcn, std::string& dir_name,
+			int type) const
 {
   std::string retval;
+  
+  //  update ();
 
-  update ();
+  dir_name = std::string ();
 
   const_fcn_map_iterator p = fcn_map.find (fcn);
 
   if (p != fcn_map.end ())
     {
-      const std::list<file_info>& file_info_list = p->second;
+      const file_info_list_type& file_info_list = p->second;
 
       for (const_file_info_list_iterator i = file_info_list.begin ();
 	   i != file_info_list.end ();
 	   i++)
 	{
 	  const file_info& fi = *i;
 
-	  int t = fi.types;
-
 	  retval = file_ops::concat (fi.dir_name, fcn);
 
-	  if (type == load_path::OCT_FILE)
+	  if (check_file_type (retval, type, fi.types,
+			       fcn, "load_path::do_find_fcn"))
 	    {
-	      if ((type & t) == load_path::OCT_FILE)
-		{
-		  retval += ".oct";
-		  break;
-		}
-	    }
-	  else if (type == load_path::M_FILE)
-	    {
-	      if ((type & t) == load_path::M_FILE)
-		{
-		  retval += ".m";
-		  break;
-		}
+	      dir_name = fi.dir_name;
+	      break;
 	    }
-	  else if (type == load_path::MEX_FILE)
+	  else
+	    retval = std::string ();
+	}
+    }
+
+  return retval;
+}
+
+std::string
+load_path::do_find_private_fcn (const std::string& dir,
+				const std::string& fcn, int type) const
+{
+  std::string retval;
+
+  //  update ();
+
+  const_private_fcn_map_iterator q = private_fcn_map.find (dir);
+
+  if (q != private_fcn_map.end ())
+    {
+      const dir_info::fcn_file_map_type& m = q->second;
+
+      dir_info::const_fcn_file_map_iterator p = m.find (fcn);
+
+      if (p != m.end ())
+	{
+	  std::string fname
+	    = file_ops::concat (file_ops::concat (dir, "private"), fcn);
+
+	  if (check_file_type (fname, type, p->second, fcn,
+			       "load_path::find_private_fcn"))
+	    retval = fname;
+	}
+    }
+
+  return retval;
+}
+
+std::string
+load_path::do_find_method (const std::string& class_name,
+			   const std::string& meth,
+			   std::string& dir_name, int type) const
+{
+  std::string retval;
+
+  //  update ();
+
+  dir_name = std::string ();
+
+  const_method_map_iterator q = method_map.find (class_name);
+
+  if (q != method_map.end ())
+    {
+      const fcn_map_type& m = q->second;
+
+      const_fcn_map_iterator p = m.find (meth);
+
+      if (p != m.end ())
+	{
+	  const file_info_list_type& file_info_list = p->second;
+
+	  for (const_file_info_list_iterator i = file_info_list.begin ();
+	       i != file_info_list.end ();
+	       i++)
 	    {
-	      if ((type & t) == load_path::MEX_FILE)
+	      const file_info& fi = *i;
+
+	      retval = file_ops::concat (fi.dir_name, meth);
+
+	      bool found = check_file_type (retval, type, fi.types,
+					    meth, "load_path::do_find_method");
+
+	      if (found)
 		{
-		  retval += ".mex";
-		  break;
-		}
-	    }
-	  else if (type == (load_path::M_FILE | load_path::OCT_FILE))
-	    {
-	      if (t & load_path::OCT_FILE)
-		{
-		  retval += ".oct";
-		  break;
-		}
-	      else if (t & load_path::M_FILE)
-		{
-		  retval += ".m";
+		  dir_name = fi.dir_name;
 		  break;
 		}
-	    }
-	  else if (type == (load_path::M_FILE | load_path::MEX_FILE))
-	    {
-	      if (t & load_path::MEX_FILE)
-		{
-		  retval += ".mex";
-		  break;
-		}
-	      else if (t & load_path::M_FILE)
-		{
-		  retval += ".m";
-		  break;
-		}
+	      else
+		retval = std::string ();
 	    }
-	  else if (type == (load_path::OCT_FILE | load_path::MEX_FILE))
-	    {
-	      if (t & load_path::OCT_FILE)
-		{
-		  retval += ".oct";
-		  break;
-		}
-	      else if (t & load_path::MEX_FILE)
-		{
-		  retval += ".mex";
-		  break;
-		}
-	    }
-	  else if (type == (load_path::M_FILE | load_path::OCT_FILE
-			    | load_path::MEX_FILE))
-	    {
-	      if (t & load_path::OCT_FILE)
-		{
-		  retval += ".oct";
-		  break;
-		}
-	      else if (t & load_path::MEX_FILE)
-		{
-		  retval += ".mex";
-		  break;
-		}
-	      else if (t & load_path::M_FILE)
-		{
-		  retval += ".m";
-		  break;
-		}
-	    }
-	  else
-	    error ("load_path::do_find_fcn: %s: invalid type code = %d",
-		   fcn.c_str (), type);
- 
- 	  // Reset the return string, in case the above tesst fail.
- 	  retval = std::string ();
 	}
     }
 
   return retval;
 }
 
+std::list<std::string>
+load_path::do_methods (const std::string& class_name) const
+{
+  std::list<std::string> retval;
+
+  //  update ();
+
+  const_method_map_iterator q = method_map.find (class_name);
+
+  if (q != method_map.end ())
+    {
+      const fcn_map_type& m = q->second;
+
+      for (const_fcn_map_iterator p = m.begin (); p != m.end (); p++)
+	retval.push_back (p->first);
+    }
+
+  if (! retval.empty ())
+    retval.sort ();
+
+  return retval;
+}
+
 std::string
 load_path::do_find_file (const std::string& file) const
 {
   std::string retval;
 
   if (file.find_first_of (file_ops::dir_sep_chars) != NPOS)
     {
       if (octave_env::absolute_pathname (file)
@@ -982,124 +1235,184 @@ load_path::do_path (void) const
 
   for (octave_idx_type i = 1; i < len; i++)
     xpath += dir_path::path_sep_str + xdirs[i];
 
   return xpath;
 }
 
 void
+print_types (std::ostream& os, int types)
+{
+  bool printed_type = false;
+
+  if (types & load_path::OCT_FILE)
+    {
+      os << "oct";
+      printed_type = true;
+    }
+
+  if (types & load_path::MEX_FILE)
+    {
+      if (printed_type)
+	os << "|";
+      os << "mex";
+      printed_type = true;
+    }
+
+  if (types & load_path::M_FILE)
+    {
+      if (printed_type)
+	os << "|";
+      os << "m";
+      printed_type = true;
+    }
+}
+
+void
+print_fcn_list (std::ostream& os,
+		const load_path::dir_info::fcn_file_map_type& lst)
+{
+  for (load_path::dir_info::const_fcn_file_map_iterator p = lst.begin ();
+       p != lst.end ();
+       p++)
+    {
+      os << "  " << p->first << " (";
+
+      print_types (os, p->second);
+
+      os << ")\n";
+    }
+}
+
+string_vector
+get_file_list (const load_path::dir_info::fcn_file_map_type& lst)
+{
+  octave_idx_type n = lst.size ();
+
+  string_vector retval (n);
+
+  octave_idx_type count = 0;
+
+  for (load_path::dir_info::const_fcn_file_map_iterator p = lst.begin ();
+       p != lst.end ();
+       p++)
+    {
+      std::string nm = p->first;
+
+      int types = p->second;
+
+      if (types & load_path::OCT_FILE)
+	nm += ".oct";
+      else if (types & load_path::MEX_FILE)
+	nm += ".mex";
+      else
+	nm += ".m";
+
+      retval[count++] = nm;
+    }
+
+  return retval;
+}
+
+void
 load_path::do_display (std::ostream& os) const
 {
   for (const_dir_info_list_iterator i = dir_info_list.begin ();
        i != dir_info_list.end ();
        i++)
     {
       string_vector fcn_files = i->fcn_files;
 
       if (! fcn_files.empty ())
 	{
 	  os << "\n*** function files in " << i->dir_name << ":\n\n";
 
 	  fcn_files.list_in_columns (os);
 	}
 
-#if defined (DEBUG_LOAD_PATH)
-
-      const std::map<std::string, int>& private_function_map
-	= i->private_function_map;
+      const dir_info::method_file_map_type& method_file_map
+	= i->method_file_map;
 
-      if (private_function_map.size () > 0)
+      if (! method_file_map.empty ())
 	{
-	  os << "private:\n";
-
-	  for (std::map<std::string, int>::const_iterator p = private_function_map.begin ();
-	       p != private_function_map.end ();
+	  for (dir_info::const_method_file_map_iterator p = method_file_map.begin ();
+	       p != method_file_map.end ();
 	       p++)
 	    {
-	      os << "  " << p->first << " (";
-
-	      bool printed_type = false;
-
-	      int types = p->second;
+	      os << "\n*** methods in " << i->dir_name
+		 << "/@" << p->first << ":\n\n";
 
-	      if (types & load_path::OCT_FILE)
-		{
-		  os << "oct";
-		  printed_type = true;
-		}
+	      string_vector method_files = get_file_list (p->second);
 
-	      if (types & load_path::MEX_FILE)
-		{
-		  if (printed_type)
-		    os << "|";
-		  os << "mex";
-		  printed_type = true;
-		}
+	      method_files.list_in_columns (os);
+	    }
+	}
+    }
 
-	      if (types & load_path::M_FILE)
-		{
-		  if (printed_type)
-		    os << "|";
-		  os << "m";
-		  printed_type = true;
-		}
+  for (const_private_fcn_map_iterator i = private_fcn_map.begin ();
+       i != private_fcn_map.end (); i++)
+    {
+      os << "\n*** private functions in "
+	 << file_ops::concat (i->first, "private") << ":\n\n";
 
-	      os << ")\n";
-	    }
-
-	  os << "\n";
-	}
-#endif
+      print_fcn_list (os, i->second);
     }
 
 #if defined (DEBUG_LOAD_PATH)
 
   for (const_fcn_map_iterator i = fcn_map.begin ();
        i != fcn_map.end ();
        i++)
     {
       os << i->first << ":\n";
 
-      const std::list<file_info>& file_info_list = i->second;
+      const file_info_list_type& file_info_list = i->second;
 
       for (const_file_info_list_iterator p = file_info_list.begin ();
 	   p != file_info_list.end ();
 	   p++)
 	{
 	  os << "  " << p->dir_name << " (";
 
-	  bool printed_type = false;
-
-	  if (p->types & load_path::OCT_FILE)
-	    {
-	      os << "oct";
-	      printed_type = true;
-	    }
-
-	  if (p->types & load_path::MEX_FILE)
-	    {
-	      if (printed_type)
-		os << "|";
-	      os << "mex";
-	      printed_type = true;
-	    }
-
-	  if (p->types & load_path::M_FILE)
-	    {
-	      if (printed_type)
-		os << "|";
-	      os << "m";
-	      printed_type = true;
-	    }
+	  print_types (os, p->types);
 
 	  os << ")\n";
 	}
     }
 
+  for (const_method_map_iterator i = method_map.begin ();
+       i != method_map.end ();
+       i++)
+    {
+      os << "CLASS " << i->first << ":\n";
+
+      const fcn_map_type& fm = i->second;
+
+      for (const_fcn_map_iterator q = fm.begin ();
+	   q != fm.end ();
+	   q++)
+	{
+	  os << "  " << q->first << ":\n";
+
+	  const file_info_list_type& file_info_list = q->second;
+
+	  for (const_file_info_list_iterator p = file_info_list.begin ();
+	       p != file_info_list.end ();
+	       p++)
+	    {
+	      os << "  " << p->dir_name << " (";
+
+	      print_types (os, p->types);
+
+	      os << ")\n";
+	    }
+	}
+    }
+
   os << "\n";
 
 #endif
 }
 
 void
 load_path::add_to_fcn_map (const dir_info& di, bool at_end) const
 {
@@ -1119,17 +1432,17 @@ load_path::add_to_fcn_map (const dir_inf
       size_t pos = fname.rfind ('.');
 
       if (pos != NPOS)
 	{
 	  base = fname.substr (0, pos);
 	  ext = fname.substr (pos);
 	}
 
-      std::list<file_info>& file_info_list = fcn_map[base];
+      file_info_list_type& file_info_list = fcn_map[base];
 
       file_info_list_iterator p = file_info_list.begin ();
 
       while (p != file_info_list.end ())
 	{
 	  if (p->dir_name == dir_name)
 	    break;
 
@@ -1157,16 +1470,88 @@ load_path::add_to_fcn_map (const dir_inf
 	{
 	  file_info& fi = *p;
 
 	  fi.types |= t;
 	}
     }
 }
 
+void
+load_path::add_to_private_fcn_map (const dir_info& di) const
+{
+  dir_info::fcn_file_map_type private_file_map = di.private_file_map;
+
+  if (! private_file_map.empty ())
+    private_fcn_map[di.dir_name] = private_file_map;
+}
+
+void
+load_path::add_to_method_map (const dir_info& di, bool at_end) const
+{
+  std::string dir_name = di.dir_name;
+
+  // <CLASS_NAME, <FCN_NAME, TYPES>>
+  dir_info::method_file_map_type method_file_map = di.method_file_map;
+
+  for (dir_info::const_method_file_map_iterator q = method_file_map.begin ();
+       q != method_file_map.end ();
+       q++)
+    {
+      std::string class_name = q->first;
+
+      fcn_map_type& fm = method_map[class_name];
+
+      std::string full_dir_name
+	= file_ops::concat (dir_name, "@" + class_name);
+
+      // <FCN_NAME, TYPES>
+      const dir_info::fcn_file_map_type& m = q->second;
+
+      for (dir_info::const_fcn_file_map_iterator p = m.begin ();
+	   p != m.end ();
+	   p++)
+	{
+	  std::string base = p->first;
+
+	  int types = p->second;
+
+	  file_info_list_type& file_info_list = fm[base];
+
+	  file_info_list_iterator p2 = file_info_list.begin ();
+
+	  while (p2 != file_info_list.end ())
+	    {
+	      if (p2->dir_name == full_dir_name)
+		break;
+
+	      p2++;
+	    }
+
+	  if (p2 == file_info_list.end ())
+	    {
+	      file_info fi (full_dir_name, types);
+
+	      if (at_end)
+		file_info_list.push_back (fi);
+	      else
+		file_info_list.push_front (fi);
+	    }
+	  else
+	    {
+	      // FIXME -- is this possible?
+
+	      file_info& fi = *p2;
+
+	      fi.types = types;
+	    }
+	}
+    }
+}
+
 std::string
 genpath (const std::string& dirname, const string_vector& skip)
 {
   std::string retval;
 
   dir_entry dir (dirname);
 
   if (dir)
@@ -1177,19 +1562,20 @@ genpath (const std::string& dirname, con
       
       octave_idx_type len = dirlist.length ();
 
       for (octave_idx_type i = 0; i < len; i++)
 	{
 	  std::string elt = dirlist[i];
 
 	  // FIXME -- the caller should be able to specify the list of
-	  // directories to skip in addition to "." and "..".
+	  // directories to skip in addition to ".", "..", and
+	  // directories beginning with "@".
 
-	  bool skip_p = (elt == "." || elt == "..");
+	  bool skip_p = (elt == "." || elt == ".." || elt[0] == '@');
 
 	  if (! skip_p)
 	    {
 	      for (octave_idx_type j = 0; j < skip.length (); j++)
 		{
 		  skip_p = (elt == skip[j]);
 		  if (skip_p)
 		    break;
diff --git a/src/load-path.h b/src/load-path.h
--- a/src/load-path.h
+++ b/src/load-path.h
@@ -32,21 +32,21 @@ along with Octave; see the file COPYING.
 #include "str-vec.h"
 
 class
 OCTINTERP_API
 load_path
 {
 protected:
 
-  load_path (void) : dir_info_list (), fcn_map () { }
+  load_path (void) : dir_info_list (), fcn_map (), method_map () { }
 
 public:
 
-  typedef void (*hook_function_ptr) (const std::string& dir);
+  typedef void (*hook_fcn_ptr) (const std::string& dir);
 
   ~load_path (void) { }
 
   static void initialize (bool set_initial_path = false)
   {
     if (instance_ok ())
       instance->do_initialize (set_initial_path);
   }
@@ -81,38 +81,78 @@ public:
   }
 
   static void update (void)
   {
     if (instance_ok ())
       instance->do_update ();
   }
 
+  static std::string find_method (const std::string& class_name,
+				  const std::string& meth,
+				  std::string& dir_name)
+  {
+    return instance_ok ()
+      ? instance->do_find_method (class_name, meth, dir_name) : std::string ();
+  }
+
+  static std::string find_method (const std::string& class_name,
+				  const std::string& meth)
+  {
+    std::string dir_name;
+    return find_method (class_name, meth, dir_name);
+  }
+
+  static std::list<std::string> methods (const std::string& class_name)
+  {
+    return instance_ok ()
+      ? instance->do_methods (class_name) : std::list<std::string> ();
+  }
+
+  static std::string find_fcn (const std::string& fcn, std::string& dir_name)
+  {
+    return instance_ok ()
+      ? instance->do_find_fcn (fcn, dir_name) : std::string ();
+  }
+
   static std::string find_fcn (const std::string& fcn)
   {
+    std::string dir_name;
+    return find_fcn (fcn, dir_name);
+  }
+
+  static std::string find_private_fcn (const std::string& dir,
+				       const std::string& fcn)
+  {
     return instance_ok ()
-      ? instance->do_find_fcn (fcn) : std::string ();
+      ? instance->do_find_private_fcn (dir, fcn) : std::string ();
   }
 
   static std::string find_fcn_file (const std::string& fcn)
   {
+    std::string dir_name;
+
     return instance_ok () ?
-      instance->do_find_fcn (fcn, M_FILE) : std::string ();
+      instance->do_find_fcn (fcn, dir_name, M_FILE) : std::string ();
   }
 
   static std::string find_oct_file (const std::string& fcn)
   {
+    std::string dir_name;
+
     return instance_ok () ?
-      instance->do_find_fcn (fcn, OCT_FILE) : std::string ();
+      instance->do_find_fcn (fcn, dir_name, OCT_FILE) : std::string ();
   }
 
   static std::string find_mex_file (const std::string& fcn)
   {
+    std::string dir_name;
+
     return instance_ok () ?
-      instance->do_find_fcn (fcn, MEX_FILE) : std::string ();
+      instance->do_find_fcn (fcn, dir_name, MEX_FILE) : std::string ();
   }
 
   static std::string find_file (const std::string& file)
   {
     return instance_ok ()
       ? instance->do_find_file (file) : std::string ();
   }
 
@@ -155,19 +195,19 @@ public:
   }
 
   static void display (std::ostream& os)
   {
     if (instance_ok ())
       instance->do_display (os);
   }
 
-  static void set_add_hook (hook_function_ptr f) { add_hook = f; }
+  static void set_add_hook (hook_fcn_ptr f) { add_hook = f; }
 
-  static void set_remove_hook (hook_function_ptr f) { remove_hook = f; }
+  static void set_remove_hook (hook_fcn_ptr f) { remove_hook = f; }
 
   static void set_command_line_path (const std::string& p)
   {
     if (command_line_path.empty ())
       command_line_path = p;
     else
       command_line_path += dir_path::path_sep_str + p;
   }
@@ -182,57 +222,77 @@ private:
   static const int M_FILE = 1;
   static const int OCT_FILE = 2;
   static const int MEX_FILE = 4;
 
   class dir_info
   {
   public:
 
+    // <FCN_NAME, TYPE>
+    typedef std::map<std::string, int> fcn_file_map_type;
+
+    typedef fcn_file_map_type::const_iterator const_fcn_file_map_iterator;
+    typedef fcn_file_map_type::iterator fcn_file_map_iterator;
+
+    // <CLASS_NAME, <FCN_NAME, TYPE>>
+    typedef std::map<std::string, fcn_file_map_type> method_file_map_type;
+
+    typedef method_file_map_type::const_iterator const_method_file_map_iterator;
+    typedef method_file_map_type::iterator method_file_map_iterator;
+
     dir_info (const std::string& d) : dir_name (d) { initialize (); }
 
     dir_info (const dir_info& di)
       : dir_name (di.dir_name), is_relative (di.is_relative),
 	dir_mtime (di.dir_mtime), all_files (di.all_files),
 	fcn_files (di.fcn_files),
-	private_function_map (di.private_function_map) { }
+	private_file_map (di.private_file_map),
+	method_file_map (di.method_file_map) { }
 
     ~dir_info (void) { }
 
     dir_info& operator = (const dir_info& di)
     {
       if (&di != this)
 	{
 	  dir_name = di.dir_name;
 	  is_relative = di.is_relative;
 	  dir_mtime = di.dir_mtime;
 	  all_files = di.all_files;
 	  fcn_files = di.fcn_files;
-	  private_function_map = di.private_function_map;
+	  private_file_map = di.private_file_map;
+	  method_file_map = di.method_file_map;
 	}
 
       return *this;
     }
 
     void update (void);
 
     std::string dir_name;
     bool is_relative;
     octave_time dir_mtime;
     string_vector all_files;
     string_vector fcn_files;
-    std::map<std::string, int> private_function_map;
+    fcn_file_map_type private_file_map;
+    method_file_map_type method_file_map;
 
   private:
 
     void initialize (void);
 
-    bool get_file_list (const std::string& d);
+    void get_file_list (const std::string& d);
+
+    void get_private_file_map (const std::string& d);
 
-    void get_private_function_map (const std::string& d);
+    void get_method_file_map (const std::string& d,
+			      const std::string& class_name);
+
+    friend fcn_file_map_type get_fcn_files (const std::string& d);
   };
 
   class file_info
   {
   public:
 
     file_info (const std::string& d, int t) : dir_name (d), types (t) { }
 
@@ -258,94 +318,157 @@ private:
 
   // We maintain two ways of looking at the same information.
   //
   // First, a list of directories and the set of "public" files and
   // private files (those found in the special "private" subdirectory)
   // in each directory.
   //
   // Second, a map from file names (the union of all "public" files for all
-  // directories, but without filename exteinsions) to a list of
+  // directories, but without filename extensions) to a list of
   // corresponding information (directory name and file types).  This
   // way, we can quickly find shadowed file names and look up all
   // overloaded functions (in the "@" directories used to implement
   // classes).
 
-  mutable std::list<dir_info> dir_info_list;
+  typedef std::list<dir_info> dir_info_list_type;
+
+  typedef dir_info_list_type::const_iterator const_dir_info_list_iterator;
+  typedef dir_info_list_type::iterator dir_info_list_iterator;
+
+  typedef std::list<file_info> file_info_list_type;
+
+  typedef file_info_list_type::const_iterator const_file_info_list_iterator;
+  typedef file_info_list_type::iterator file_info_list_iterator;
+
+  // <FCN_NAME, FILE_INFO_LIST>
+  typedef std::map<std::string, file_info_list_type> fcn_map_type;
+
+  typedef fcn_map_type::const_iterator const_fcn_map_iterator;
+  typedef fcn_map_type::iterator fcn_map_iterator;
 
-  mutable std::map<std::string, std::list<file_info> > fcn_map;
+  // <DIR_NAME, <FCN_NAME, TYPE>>
+  typedef std::map<std::string, dir_info::fcn_file_map_type> private_fcn_map_type;
+
+  typedef private_fcn_map_type::const_iterator const_private_fcn_map_iterator;
+  typedef private_fcn_map_type::iterator private_fcn_map_iterator;
+
+  // <CLASS_NAME, <FCN_NAME, FILE_INFO_LIST>>
+  typedef std::map<std::string, fcn_map_type> method_map_type;
+
+  typedef method_map_type::const_iterator const_method_map_iterator;
+  typedef method_map_type::iterator method_map_iterator;
+
+  mutable dir_info_list_type dir_info_list;
+
+  mutable fcn_map_type fcn_map;
+
+  mutable private_fcn_map_type private_fcn_map;
+
+  mutable method_map_type method_map;
 
   static load_path *instance;
 
-  static hook_function_ptr add_hook;
+  static hook_fcn_ptr add_hook;
 
-  static hook_function_ptr remove_hook;
+  static hook_fcn_ptr remove_hook;
 
   static std::string command_line_path;
 
   static std::string sys_path;
 
   static bool instance_ok (void);
 
-  typedef std::list<dir_info>::const_iterator const_dir_info_list_iterator;
-  typedef std::list<dir_info>::iterator dir_info_list_iterator;
-
-  typedef std::map<std::string, std::list<file_info> >::const_iterator const_fcn_map_iterator;
-  typedef std::map<std::string, std::list<file_info> >::iterator fcn_map_iterator;
-
-  typedef std::list<file_info>::const_iterator const_file_info_list_iterator;
-  typedef std::list<file_info>::iterator file_info_list_iterator;
-
   const_dir_info_list_iterator find_dir_info (const std::string& dir) const;
   dir_info_list_iterator find_dir_info (const std::string& dir);
 
   bool contains (const std::string& dir) const;
 
+  void move_fcn_map (const std::string& dir,
+		     const string_vector& fcn_files, bool at_end);
+
+  void move_method_map (const std::string& dir, bool at_end);
+
   void move (std::list<dir_info>::iterator i, bool at_end);
 
   void do_initialize (bool set_initial_path);
 
   void do_clear (void);
 
   void do_set (const std::string& p, bool warn);
 
   void do_append (const std::string& dir, bool warn);
 
   void do_prepend (const std::string& dir, bool warn);
 
   void do_add (const std::string& dir, bool at_end, bool warn);
 
+  void remove_fcn_map (const std::string& dir, const string_vector& fcn_files);
+
+  void remove_private_fcn_map (const std::string& dir);
+
+  void remove_method_map (const std::string& dir);
+
   bool do_remove (const std::string& dir);
 
   void do_update (void) const;
 
+  static bool
+  check_file_type (std::string& fname, int type, int possible_types,
+		   const std::string& fcn, const char *who);
+
   std::string do_find_fcn (const std::string& fcn,
+			   std::string& dir_name,
 			   int type = M_FILE | OCT_FILE | MEX_FILE) const;
 
+  std::string do_find_private_fcn (const std::string& dir,
+				   const std::string& fcn,
+				   int type = M_FILE | OCT_FILE | MEX_FILE) const;
+
+  std::string do_find_method (const std::string& class_name,
+			      const std::string& meth,
+			      std::string& dir_name,
+			      int type = M_FILE | OCT_FILE | MEX_FILE) const;
+
+  std::list<std::string> do_methods (const std::string& class_name) const;
+
   std::string do_find_file (const std::string& file) const;
 
   std::string do_find_first_of (const string_vector& files) const;
 
   string_vector do_find_all_first_of (const string_vector& files) const;
 
   string_vector do_dirs (void) const;
 
   std::list<std::string> do_dir_list (void) const;
 
   string_vector do_files (const std::string& dir) const;
 
   string_vector do_fcn_names (void) const;
 
   std::string do_path (void) const;
 
+  friend void print_types (std::ostream& os, int types);
+
+  friend string_vector get_file_list (const dir_info::fcn_file_map_type& lst);
+
+  friend void
+  print_fcn_list (std::ostream& os, const dir_info::fcn_file_map_type& lst);
+
   void do_display (std::ostream& os) const;
 
   std::string do_system_path (void) const { return sys_path; }
 
   void add_to_fcn_map (const dir_info& di, bool at_end) const;
+
+  void add_to_private_fcn_map (const dir_info& di) const;
+
+  void add_to_method_map (const dir_info& di, bool at_end) const;
+
+  friend dir_info::fcn_file_map_type get_fcn_files (const std::string& d);
 };
 
 extern std::string
 genpath (const std::string& dir, const string_vector& skip = "private");
 
 extern void execute_pkg_add (const std::string& dir);
 extern void execute_pkg_del (const std::string& dir);
 
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -127,159 +127,32 @@ gripe_file_open (const std::string& fcn,
   if (fcn == "load")
     error ("%s: unable to open input file `%s'", fcn.c_str (), file.c_str ());
   else if (fcn == "save")
     error ("%s: unable to open output file `%s'", fcn.c_str (), file.c_str ());
   else
     error ("%s: unable to open file `%s'", fcn.c_str (), file.c_str ());
 }
 
-// FIXME -- shouldn't this be implemented in terms of other
-// functions that are already available?
-
-// Install a variable with name NAME and the value specified TC in the
-// symbol table.  If FORCE is TRUE, replace any existing definition
-// for NAME.  If GLOBAL is TRUE, make the variable global.
-//
-// Assumes TC is defined.
+// Install a variable with name NAME and the value VAL in the
+// symbol table.  If GLOBAL is TRUE, make the variable global.
 
 static void
-install_loaded_variable (int force, const std::string& name,
+install_loaded_variable (const std::string& name,
 			 const octave_value& val,
-			 int global, const std::string& doc)
+			 bool global, const std::string& /*doc*/)
 {
-  // Is there already a symbol by this name?  If so, what is it?
-
-  symbol_record *lsr = curr_sym_tab->lookup (name);
-
-  bool is_undefined = true;
-  bool is_variable = false;
-  bool is_function = false;
-  bool is_global = false;
-
-  if (lsr)
-    {
-      is_undefined = ! lsr->is_defined ();
-      is_variable = lsr->is_variable ();
-      is_function = lsr->is_function ();
-      is_global = lsr->is_linked_to_global ();
-    }
-
-  symbol_record *sr = 0;
-
   if (global)
     {
-      if (is_global || is_undefined)
-	{
-	  if (force || is_undefined)
-	    {
-	      lsr = curr_sym_tab->lookup (name, true);
-	      link_to_global_variable (lsr);
-	      sr = lsr;
-	    }
-	  else
-	    {
-	      warning ("load: global variable name `%s' exists",
-		       name.c_str ());
-	      warning ("use `load -force' to overwrite");
-	    }
-	}
-      else if (is_function)
-	{
-	  if (force)
-	    {
-	      lsr = curr_sym_tab->lookup (name, true);
-	      link_to_global_variable (lsr);
-	      sr = lsr;
-	    }
-	  else
-	    {
-	      warning ("load: `%s' is currently a function in this scope",
-		       name.c_str ());
-	      warning ("`load -force' will load variable and hide function");
-	    }
-	}
-      else if (is_variable)
-	{
-	  if (force)
-	    {
-	      lsr = curr_sym_tab->lookup (name, true);
-	      link_to_global_variable (lsr);
-	      sr = lsr;
-	    }
-	  else
-	    {
-	      warning ("load: local variable name `%s' exists",
-		       name.c_str ());
-	      warning ("use `load -force' to overwrite");
-	    }
-	}
-      else
-	error ("load: unable to load data for unknown symbol type");
+      symbol_table::clear (name);
+      symbol_table::mark_global (name);
+      symbol_table::varref (name, symbol_table::global_scope ()) = val;
     }
   else
-    {
-      if (is_global)
-	{
-	  if (force || is_undefined)
-	    {
-	      lsr = curr_sym_tab->lookup (name, true);
-	      link_to_global_variable (lsr);
-	      sr = lsr;
-	    }
-	  else
-	    {
-	      warning ("load: global variable name `%s' exists",
-		       name.c_str ());
-	      warning ("use `load -force' to overwrite");
-	    }
-	}
-      else if (is_function)
-	{
-	  if (force)
-	    {
-	      lsr = curr_sym_tab->lookup (name, true);
-	      link_to_global_variable (lsr);
-	      sr = lsr;
-	    }
-	  else
-	    {
-	      warning ("load: `%s' is currently a function in this scope",
-		       name.c_str ());
-	      warning ("`load -force' will load variable and hide function");
-	    }
-	}
-      else if (is_variable || is_undefined)
-	{
-	  if (force || is_undefined)
-	    {
-	      lsr = curr_sym_tab->lookup (name, true);
-	      sr = lsr;
-	    }
-	  else
-	    {
-	      warning ("load: local variable name `%s' exists",
-		       name.c_str ());
-	      warning ("use `load -force' to overwrite");
-	    }
-	}
-      else
-	error ("load: unable to load data for unknown symbol type");
-    }
-
-  if (sr)
-    {
-      sr->define (val);
-      sr->document (doc);
-      return;
-    }
-  else
-    error ("load: unable to load variable `%s'", name.c_str ());
-
-  return;
+    symbol_table::varref (name) = val;
 }
 
 // Return TRUE if NAME matches one of the given globbing PATTERNS.
 
 static bool
 matches_patterns (const string_vector& patterns, int pat_idx,
 		  int num_pat, const std::string& name)
 {
@@ -446,17 +319,17 @@ get_file_format (const std::string& fnam
     }
   else
     gripe_file_open ("load", orig_fname);
 
   return retval;
 }
 
 octave_value
-do_load (std::istream& stream, const std::string& orig_fname, bool force,
+do_load (std::istream& stream, const std::string& orig_fname,
 	 load_save_format format, oct_mach_info::float_format flt_fmt,
 	 bool list_only, bool swap, bool verbose,
 	 const string_vector& argv, int argv_idx, int argc, int nargout)
 {
   octave_value retval;
 
   Octave_map retstruct;
 
@@ -547,17 +420,17 @@ do_load (std::istream& stream, const std
 		      if (nargout == 1)
 			{
 			  if (format == LS_MAT_ASCII)
 			    retval = tc;
 			  else
 			    retstruct.assign (name, tc);
 			}
 		      else
-			install_loaded_variable (force, name, tc, global, doc);
+			install_loaded_variable (name, tc, global, doc);
 		    }
 		}
 
 	      // Only attempt to read one item from a headless text file.
 
 	      if (format == LS_MAT_ASCII)
 		break;
 	    }
@@ -761,17 +634,16 @@ Force Octave to assume the file is in Oc
     return retval;
 
   // It isn't necessary to have the default load format stored in a
   // user preference variable since we can determine the type of file
   // as we are reading.
 
   load_save_format format = LS_UNKNOWN;
 
-  bool force = true;
   bool list_only = false;
   bool verbose = false;
 
   int i;
   for (i = 1; i < argc; i++)
     {
       if (argv[i] == "-force" || argv[i] == "-f")
 	{
@@ -852,17 +724,17 @@ Force Octave to assume the file is in Oc
 #endif /* HAVE_HDF5 */
       if (format != LS_UNKNOWN)
 	{
 	  // FIXME -- if we have already seen EOF on a
 	  // previous call, how do we fix up the state of std::cin so
 	  // that we can get additional input?  I'm afraid that we
 	  // can't fix this using std::cin only.
 
-	  retval = do_load (std::cin, orig_fname, force, format, flt_fmt,
+	  retval = do_load (std::cin, orig_fname, format, flt_fmt,
 			    list_only, swap, verbose, argv, i, argc,
 			    nargout);
 	}
       else
 	error ("load: must specify file format if reading from stdin");
     }
   else
     {
@@ -882,17 +754,17 @@ Force Octave to assume the file is in Oc
       if (format == LS_HDF5)
 	{
 	  i++;
 
 	  hdf5_ifstream hdf5_file (fname.c_str ());
 
 	  if (hdf5_file.file_id >= 0)
 	    {
-	      retval = do_load (hdf5_file, orig_fname, force, format,
+	      retval = do_load (hdf5_file, orig_fname, format,
 				flt_fmt, list_only, swap, verbose,
 				argv, i, argc, nargout);
 
 	      hdf5_file.close ();
 	    }
 	  else
 	    gripe_file_open ("load", orig_fname);
 	}
@@ -935,17 +807,17 @@ Force Octave to assume the file is in Oc
 		    {
 		      if (read_mat5_binary_file_header (file, swap, false, orig_fname) < 0)
 			{
 			  if (file) file.close ();
 			  return retval;
 			}
 		    }
 
-		  retval = do_load (file, orig_fname, force, format,
+		  retval = do_load (file, orig_fname, format,
 				    flt_fmt, list_only, swap, verbose,
 				argv, i, argc, nargout);
 
 		  file.close ();
 		}
 	      else
 		gripe_file_open ("load", orig_fname);
 	    }
@@ -969,17 +841,17 @@ Force Octave to assume the file is in Oc
 		    {
 		      if (read_mat5_binary_file_header (file, swap, false, orig_fname) < 0)
 			{
 			  if (file) file.close ();
 			  return retval;
 			}
 		    }
 
-		  retval = do_load (file, orig_fname, force, format,
+		  retval = do_load (file, orig_fname, format,
 				    flt_fmt, list_only, swap, verbose,
 				    argv, i, argc, nargout);
 
 		  file.close ();
 		}
 	      else
 		error ("load: unable open input file `%s'",
 		       orig_fname.c_str ());
@@ -1028,17 +900,17 @@ glob_pattern_p (const std::string& patte
     }
 
   return false;
 }
 
 static void
 do_save (std::ostream& os, const octave_value& tc,
 	 const std::string& name, const std::string& help,
-	 int global, load_save_format fmt, bool save_as_floats)
+	 bool global, load_save_format fmt, bool save_as_floats)
 {
   switch (fmt)
     {
     case LS_ASCII:
       save_ascii_data (os, tc, name, global, 0);
       break;
 
     case LS_BINARY:
@@ -1073,56 +945,52 @@ do_save (std::ostream& os, const octave_
       gripe_unrecognized_data_fmt ("save");
       break;
     }
 }
 
 // Save the info from SR on stream OS in the format specified by FMT.
 
 void
-do_save (std::ostream& os, symbol_record *sr, load_save_format fmt,
-	 bool save_as_floats)
+do_save (std::ostream& os, const symbol_table::symbol_record& sr,
+	 load_save_format fmt, bool save_as_floats)
 {
-  if (! sr->is_variable ())
-    {
-      error ("save: can only save variables, not functions");
-      return;
-    }
+  octave_value val = sr.varval ();
 
-  octave_value tc = sr->def ();
-
-  if (tc.is_defined ())
+  if (val.is_defined ())
     {
-      std::string name = sr->name ();
-      std::string help = sr->help ();
+      std::string name = sr.name ();
+      std::string help;
+      bool global = sr.is_global ();
 
-      int global = sr->is_linked_to_global ();
-
-      do_save (os, tc, name, help, global, fmt, save_as_floats);
+      do_save (os, val, name, help, global, fmt, save_as_floats);
     }
 }
 
 // Save variables with names matching PATTERN on stream OS in the
 // format specified by FMT.
 
-static int
+static size_t
 save_vars (std::ostream& os, const std::string& pattern,
 	   load_save_format fmt, bool save_as_floats)
 {
-  Array<symbol_record *> vars = curr_sym_tab->glob
-    (pattern, symbol_record::USER_VARIABLE, SYMTAB_ALL_SCOPES);
+  std::list<symbol_table::symbol_record> vars = symbol_table::glob (pattern);
+
+  size_t saved = 0;
 
-  int saved = vars.length ();
+  typedef std::list<symbol_table::symbol_record>::const_iterator const_vars_iterator;
 
-  for (int i = 0; i < saved; i++)
+  for (const_vars_iterator p = vars.begin (); p != vars.end (); p++)
     {
-      do_save (os, vars(i), fmt, save_as_floats);
+      do_save (os, *p, fmt, save_as_floats);
 
       if (error_state)
 	break;
+
+      saved++;
     }
 
   return saved;
 }
 
 static int
 parse_save_options (const string_vector &argv, int argc, 
 		    load_save_format &format, bool &append,
@@ -1328,53 +1196,45 @@ save_vars (const string_vector& argv, in
 }
 
 static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
 		  bool save_as_floats)
 {
   write_header (os, fmt);
 
-  Array<symbol_record *> vars = curr_sym_tab->glob
-    ("*", symbol_record::USER_VARIABLE, SYMTAB_ALL_SCOPES);
-
-  int num_to_save = vars.length ();
+  std::list<symbol_table::symbol_record> vars = symbol_table::all_variables ();
 
   double save_mem_size = 0;
 
-  for (int i = 0; i < num_to_save; i++)
+  typedef std::list<symbol_table::symbol_record>::const_iterator const_vars_iterator;
+
+  for (const_vars_iterator p = vars.begin (); p != vars.end (); p++)
     {
-      symbol_record *sr = vars(i);
+      octave_value val = p->varval ();
 
-      if (sr->is_variable ())
+      if (val.is_defined ())
 	{
-	  octave_value tc = sr->def ();
-
-	  if (tc.is_defined ())
-	    {
-	      double tc_size = tc.byte_size () / 1024;
-
-	      // FIXME -- maybe we should try to throw out the
-	      // largest first...
+	  std::string name = p->name ();
+	  std::string help;
+	  bool global = p->is_global ();
 
-	      if (Voctave_core_file_limit < 0
-		  || save_mem_size + tc_size < Voctave_core_file_limit)
-		{
-		  save_mem_size += tc_size;
+	  double val_size = val.byte_size () / 1024;
 
-		  std::string name = sr->name ();
-		  std::string help = sr->help ();
+	  // FIXME -- maybe we should try to throw out the largest first...
 
-		  int global = sr->is_linked_to_global ();
-
-		  do_save (os, tc, name, help, global, fmt, save_as_floats);
+	  if (Voctave_core_file_limit < 0
+	      || save_mem_size + val_size < Voctave_core_file_limit)
+	    {
+	      save_mem_size += val_size;
 
-		  if (error_state)
-		    break;
-		}
+	      do_save (os, val, name, help, global, fmt, save_as_floats);
+
+	      if (error_state)
+		break;
 	    }
 	}
     }
 
   message (0, "save to `%s' complete", fname);
 }
 
 void
diff --git a/src/load-save.h b/src/load-save.h
--- a/src/load-save.h
+++ b/src/load-save.h
@@ -54,18 +54,18 @@ read_binary_file_header (std::istream& i
 
 extern octave_value
 do_load (std::istream& stream, const std::string& orig_fname, bool force,
 	 load_save_format format, oct_mach_info::float_format flt_fmt,
 	 bool list_only, bool swap, bool verbose,
 	 const string_vector& argv, int argv_idx, int argc, int nargout);
 
 extern void
-do_save (std::ostream& os, symbol_record *sr, load_save_format fmt,
-	 bool save_as_floats);
+do_save (std::ostream& os, const symbol_table::symbol_record& sr,
+	 load_save_format fmt, bool save_as_floats);
 
 extern void
 write_header (std::ostream& os, load_save_format format);
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -56,17 +56,16 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "gripes.h"
 #include "load-save.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
-#include "symtab.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "dMatrix.h"
 
 #include "ls-utils.h"
diff --git a/src/ls-mat-ascii.cc b/src/ls-mat-ascii.cc
--- a/src/ls-mat-ascii.cc
+++ b/src/ls-mat-ascii.cc
@@ -51,17 +51,16 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "lex.h"
 #include "load-save.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
-#include "symtab.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "dMatrix.h"
 
 #include "ls-mat-ascii.h"
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -50,17 +50,16 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "gripes.h"
 #include "load-save.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
-#include "symtab.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "dMatrix.h"
 
 #include "ls-mat4.h"
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -56,17 +56,16 @@ along with Octave; see the file COPYING.
 #include "load-save.h"
 #include "load-path.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "ov-fcn-inline.h"
 #include "pager.h"
 #include "pt-exp.h"
-#include "symtab.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "dMatrix.h"
 
 #include "ls-utils.h"
@@ -770,85 +769,79 @@ read_mat5_binary_element (std::istream& 
 		    
 		    // First check if just replacing matlabroot is enough
 		    std::string str = OCTAVE_EXEC_PREFIX + 
 		      fpath.substr (mroot.length ());		    
 		    file_stat fs (str);
 
 		    if (fs.exists ())
 		      {
-			symbol_record *sr = fbi_sym_tab->lookup (str, true);
-		    
-			if (sr)
-			  {
-			    load_fcn_from_file (sr, false);
+			size_t xpos = str.find_last_of (file_ops::dir_sep_chars);
+
+			std::string dir_name = str.substr (0, xpos);
 
-			    tc = octave_value (new octave_fcn_handle 
-					       (sr->def (), fname));
+			octave_function *fcn
+			  = load_fcn_from_file (str, dir_name, "", fname);
+		    
+			if (fcn)
+			  {
+			    octave_value tmp (fcn);
 
-			    // The next two lines are needed to force the 
-			    // definition of the function back to the one 
-			    // that is on the user path.
-			    sr = fbi_sym_tab->lookup (fname, true);
-
-			    load_fcn_from_file (sr, false);
+			    tc = octave_value (new octave_fcn_handle (tmp, fname));
 			  }
 		      }
 		    else
 		      {
 			// Next just search for it anywhere in the
 			// system path
 			string_vector names(3);
 			names(0) = fname + ".oct";
 			names(1) = fname + ".mex";
 			names(2) = fname + ".m";
 
 			dir_path p (load_path::system_path ());
 
 			str = octave_env::make_absolute 
 			  (p.find_first_of (names), octave_env::getcwd ());
 
-			symbol_record *sr = fbi_sym_tab->lookup (str, true);
+			size_t xpos = str.find_last_of (file_ops::dir_sep_chars);
 
-			if (sr)
-			  {
-			    load_fcn_from_file (sr, false);
+			std::string dir_name = str.substr (0, xpos);
 
-			    tc = octave_value (new octave_fcn_handle 
-					       (sr->def (), fname));
+			octave_function *fcn
+			  = load_fcn_from_file (str, dir_name, "", fname);
 
-			    // The next two lines are needed to force the 
-			    // definition of the function back to the one 
-			    // that is on the user path.
-			    sr = fbi_sym_tab->lookup (fname, true);
+			if (fcn)
+			  {
+			    octave_value tmp (fcn);
 
-			    load_fcn_from_file (sr, false);
+			    tc = octave_value (new octave_fcn_handle (tmp, fname));
 			  }
 			else
 			  {
 			    warning ("load: can't find the file %s", 
 				     fpath.c_str());
 			    goto skip_ahead;
 			  }
 		      }
 		  }
 		else
 		  {
-		    symbol_record *sr = fbi_sym_tab->lookup (fpath, true);
+		    size_t xpos = fpath.find_last_of (file_ops::dir_sep_chars);
 
-		    if (sr)
-		      {
-			load_fcn_from_file (sr, false);
+		    std::string dir_name = fpath.substr (0, xpos);
 
-			tc = octave_value (new octave_fcn_handle (sr->def (), 
-								  fname));
+		    octave_function *fcn
+		      = load_fcn_from_file (fpath, dir_name, "", fname);
 
-			sr = fbi_sym_tab->lookup (fname, true);
+		    if (fcn)
+		      {
+			octave_value tmp (fcn);
 
-			load_fcn_from_file (sr, false);
+			tc = octave_value (new octave_fcn_handle (tmp, fname));
 		      }
 		    else
 		      {
 			warning ("load: can't find the file %s", 
 				 fpath.c_str());
 			goto skip_ahead;
 		      }
 		  }
@@ -863,47 +856,38 @@ read_mat5_binary_element (std::istream& 
 	  {
 	    Octave_map m2 = m1.contents("workspace")(0).map_value();
 	    uint32NDArray MCOS = m2.contents("MCOS")(0).uint32_array_value();
 	    octave_idx_type off = static_cast<octave_idx_type>(MCOS(4).double_value ());
 	    m2 = subsys_ov.map_value();
 	    m2 = m2.contents("MCOS")(0).map_value();
 	    tc2 = m2.contents("MCOS")(0).cell_value()(1 + off).cell_value()(1);
 	    m2 = tc2.map_value();
-	    symbol_table *local_sym_tab = 0;
+
+	    symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
+
 	    if (m2.nfields() > 0)
 	      {
 		octave_value tmp;
-
-		local_sym_tab = new symbol_table (((m2.nfields() + 1) & ~1), 
-						  "LOCAL");
-	      
+      
 		for (Octave_map::iterator p0 = m2.begin() ; 
 		     p0 != m2.end(); p0++)
 		  {
 		    std::string key = m2.key(p0);
 		    octave_value val = m2.contents(p0)(0);
 
-		    symbol_record *sr = local_sym_tab->lookup (key, true);
-
-		    if (sr)
-		      sr->define (val);
-		    else
-		      {
-			error ("load: failed to load anonymous function handle");
-			goto skip_ahead;
-		      }
+		    symbol_table::varref (key, local_scope) = val;
                   }
 	      }
 	    
 	    unwind_protect::begin_frame ("anon_mat5_load");
-	    unwind_protect_ptr (curr_sym_tab);
+	    
+	    symbol_table::push_scope (local_scope);
 
-	    if (local_sym_tab)
-	      curr_sym_tab = local_sym_tab;
+	    unwind_protect::add (symbol_table::pop_scope);
 
 	    int parse_status;
 	    octave_value anon_fcn_handle = 
 	      eval_string (fname.substr (4), true, parse_status);
 
 	    if (parse_status == 0)
 	      {
 		octave_fcn_handle *fh = 
@@ -919,18 +903,17 @@ read_mat5_binary_element (std::istream& 
 	    else
 	      {
 		error ("load: failed to load anonymous function handle");
 		goto skip_ahead;
 	      }
 
 	    unwind_protect::run_frame ("anon_mat5_load");
 
-	    if (local_sym_tab)
-	      delete local_sym_tab;	    
+	    symbol_table::erase_scope (local_scope);
 	  }
 	else
 	  {
 	    error ("load: invalid function handle type");
 	    goto skip_ahead;
 	  }
       }
       break;
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -51,18 +51,16 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "gripes.h"
 #include "load-save.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
-#include "symtab.h"
-#include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "dMatrix.h"
 
 #include "ls-oct-ascii.h"
 
diff --git a/src/ls-oct-binary.cc b/src/ls-oct-binary.cc
--- a/src/ls-oct-binary.cc
+++ b/src/ls-oct-binary.cc
@@ -50,17 +50,16 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "gripes.h"
 #include "load-save.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
-#include "symtab.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "dMatrix.h"
 
 #include "ls-utils.h"
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -3237,41 +3237,36 @@ mexPrintf (const char *fmt, ...)
   va_end (args);
 }
 
 mxArray *
 mexGetVariable (const char *space, const char *name)
 {
   mxArray *retval = 0;
 
-  // FIXME -- this should be in variable.cc, but the correct
-  // functionality is not exported.  Particularly, get_global_value()
-  // generates an error if the symbol is undefined.
-
-  symbol_record *sr = 0;
+  // FIXME -- should this be in variables.cc?
+
+  symbol_table::scope_id scope = -1;
 
   if (! strcmp (space, "global"))
-    sr = global_sym_tab->lookup (name);
+    scope = symbol_table::global_scope ();
   else if (! strcmp (space, "caller"))
-    sr = curr_sym_tab->lookup (name);
+    scope = symbol_table::current_caller_scope ();
   else if (! strcmp (space, "base"))
-    sr = top_level_sym_tab->lookup (name);
+    scope = symbol_table::top_scope ();
   else
     mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
 
-  if (sr)
+  octave_value val = symbol_table::varval (name, scope);
+
+  if (val.is_defined ())
     {
-      octave_value sr_def = sr->def ();
-
-      if (sr_def.is_defined ())
-	{
-	  retval = mex_context->make_value (sr_def);
-
-	  retval->set_name (name);
-	}
+      retval = mex_context->make_value (val);
+
+      retval->set_name (name);
     }
 
   return retval;
 }
 
 const mxArray *
 mexGetVariablePtr (const char *space, const char *name)
 {
@@ -3292,31 +3287,30 @@ mexPutVariable (const char *space, const
 
   if (! name || name[0] == '\0')
     return 1;
 
   if (! strcmp (space, "global"))
     set_global_value (name, mxArray::as_octave_value (ptr));
   else
     {
-      // FIXME -- this belongs in variables.cc.
-
-      symbol_record *sr = 0;
-
-      if (! strcmp (space, "caller"))
-	sr = curr_sym_tab->lookup (name, true);
+      // FIXME -- should this be in variables.cc?
+
+      symbol_table::scope_id scope = -1;
+
+      if (! strcmp (space, "global"))
+	scope = symbol_table::global_scope ();
+      else if (! strcmp (space, "caller"))
+	scope = symbol_table::current_caller_scope ();
       else if (! strcmp (space, "base"))
-	sr = top_level_sym_tab->lookup (name, true);
+	scope = symbol_table::top_scope ();
       else
 	mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
 
-      if (sr)
-	sr->define (mxArray::as_octave_value (ptr));
-      else
-	panic_impossible ();
+      symbol_table::varref (name, scope) = mxArray::as_octave_value (ptr);
     }
 
   return 0;
 }
 
 void
 mexMakeArrayPersistent (mxArray *ptr)
 {
@@ -3385,17 +3379,17 @@ mexLock (void)
     {
       const char *fname = mexFunctionName ();
 
       if (mex_lock_count.find (fname) == mex_lock_count.end ())
 	mex_lock_count[fname] = 1;
       else
 	mex_lock_count[fname]++;
 
-      mlock (fname);
+      mlock ();
     }
 }
 
 int
 mexSet (double handle, const char *property, mxArray *val)
 {
   bool ret = 
     set_property_in_handle (handle, property, mxArray::as_octave_value (val),
diff --git a/src/oct-lvalue.cc b/src/oct-lvalue.cc
--- a/src/oct-lvalue.cc
+++ b/src/oct-lvalue.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 
 void
 octave_lvalue::assign (octave_value::assign_op op, const octave_value& rhs)
 {
   octave_value tmp (idx.empty ()
 		    ? val->assign (op, rhs)
 		    : val->assign (op, type, idx, rhs));
 
-  if (! (error_state || (chg_fcn && chg_fcn () < 0)))
+  if (! error_state)
     *val = tmp;
 }
 
 void
 octave_lvalue::set_index (const std::string& t,
 			  const std::list<octave_value_list>& i)
 {
   if (! index_set)
@@ -57,17 +57,17 @@ octave_lvalue::set_index (const std::str
 
 void
 octave_lvalue::do_unary_op (octave_value::unary_op op)
 {
   octave_value tmp (idx.empty ()
 		    ? val->do_non_const_unary_op (op)
 		    : val->do_non_const_unary_op (op, type, idx));
 
-  if (! (error_state || (chg_fcn && chg_fcn () < 0)))
+  if (! error_state)
     *val = tmp;
 }
 
 octave_value
 octave_lvalue::value (void)
 {
   octave_value retval;
 
diff --git a/src/oct-lvalue.h b/src/oct-lvalue.h
--- a/src/oct-lvalue.h
+++ b/src/oct-lvalue.h
@@ -26,44 +26,41 @@ along with Octave; see the file COPYING.
 
 class octave_value;
 class octave_value_list;
 
 #include <string>
 
 #include "oct-obj.h"
 #include "pt-idx.h"
-#include "symtab.h"
 
 // FIXME -- eliminate the following kluge?
 
 // This variable is used when creating dummy octave_lvalue objects.
 static octave_value dummy_val;
 
 class
 octave_lvalue
 {
 public:
 
-  octave_lvalue (octave_value *v = &dummy_val,
-		 symbol_record::change_function f = 0)
-    : val (v), type (), idx (), chg_fcn (f), nel (1), index_set (false) { }
+  octave_lvalue (octave_value *v = &dummy_val)
+    : val (v), type (), idx (), nel (1), index_set (false) { }
 
   octave_lvalue (const octave_lvalue& vr)
-    : val (vr.val), type (vr.type), idx (vr.idx), chg_fcn (vr.chg_fcn),
-      nel (vr.nel), index_set (vr.index_set) { }
+    : val (vr.val), type (vr.type), idx (vr.idx), nel (vr.nel),
+      index_set (vr.index_set) { }
 
   octave_lvalue& operator = (const octave_lvalue& vr)
     {
       if (this != &vr)
 	{
 	  val = vr.val;
 	  type = vr.type;
 	  idx = vr.idx;
-	  chg_fcn = vr.chg_fcn;
 	  nel = vr.nel;
 	  index_set = vr.index_set;
 	}
 
       return *this;
     }
 
   ~octave_lvalue (void) { }
@@ -95,18 +92,16 @@ public:
 private:
 
   octave_value *val;
 
   std::string type;
 
   std::list<octave_value_list> idx;
 
-  symbol_record::change_function chg_fcn;
-
   octave_idx_type nel;
 
   bool index_set;
 };
 
 #endif
 
 /*
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -184,25 +184,23 @@ long_options long_opts[] =
     { 0,                  0,                       0, 0 }
   };
 
 // Store the command-line options for later use.
 
 static void
 intern_argv (int argc, char **argv)
 {
-  symbol_record *nargin_sr = top_level_sym_tab->lookup ("__nargin__", true);
+  symbol_table::varref (".nargin.", symbol_table::top_scope ()) = argc - 1;
 
-  nargin_sr->mark_as_static ();
-
-  nargin_sr->define (argc-1);
+  symbol_table::mark_hidden (".nargin.", symbol_table::top_scope ());
 
   if (argc > 1)
     {
-      octave_argv.resize (argc-1);
+      octave_argv.resize (argc - 1);
 
       // Skip program name in argv.
       int i = argc;
       while (--i > 0)
 	octave_argv[i-1] = *(argv+i);
     }
 }
 
@@ -594,18 +592,16 @@ octave_main (int argc, char **argv, int 
 
   initialize_pathsearch ();
 
   if (! embedded)
     install_signal_handlers ();
 
   initialize_file_io ();
 
-  initialize_symbol_tables ();
-
   install_types ();
 
   install_ops ();
 
   install_builtins ();
 
   prog_args args (argc, argv, short_opts, long_opts);
 
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -53,22 +53,19 @@ along with Octave; see the file COPYING.
 #include "ov-fcn-handle.h"
 #include "parse.h"
 #include "utils.h"
 #include "variables.h"
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_base_value,
 				     "<unknown type>", "unknown");
 
-// If TRUE, print the name along with the value.
-static bool Vprint_answer_id_name = true;
-
 // If TRUE, turn off printing of results in functions (as if a
 // semicolon has been appended to each statement).
-static bool Vsilent_functions = false;
+bool Vsilent_functions = false;
 
 // TRUE means to perform automatic sparse to real mutation if there
 // is memory to be saved
 bool Vsparse_auto_mutate = false;
 
 octave_value
 octave_base_value::squeeze (void) const
 {
@@ -342,20 +339,17 @@ octave_base_value::print_name_tag (std::
 
 void
 octave_base_value::print_with_name (std::ostream& output_buf,
 				    const std::string& name, 
 				    bool print_padding) const
 {
   if (! (evaluating_function_body && Vsilent_functions))
     {
-      bool pad_after = false;
-
-      if (Vprint_answer_id_name)
-	pad_after = print_name_tag (output_buf, name);
+      bool pad_after = print_name_tag (output_buf, name);
 
       print (output_buf);
 
       if (print_padding && pad_after)
 	newline (output_buf);
     }
 }
 
@@ -1106,27 +1100,16 @@ install_base_type_conversions (void)
   INSTALL_ASSIGNCONV (octave_base_value, octave_cell, octave_cell);
 
   INSTALL_WIDENOP (octave_base_value, octave_matrix, matrix_conv);
   INSTALL_WIDENOP (octave_base_value, octave_complex_matrix, complex_matrix_conv);
   INSTALL_WIDENOP (octave_base_value, octave_char_matrix_str, string_conv);
   INSTALL_WIDENOP (octave_base_value, octave_cell, cell_conv);
 }
 
-DEFUN (print_answer_id_name, args, nargout,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} print_answer_id_name ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} print_answer_id_name (@var{new_val})\n\
-Query or set the internal variable that controls whether variable\n\
-names are printed along with results produced by evaluating an expression.\n\
-@end deftypefn")
-{
-  return SET_INTERNAL_VARIABLE (print_answer_id_name);
-}
-
 DEFUN (silent_functions, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} silent_functions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} silent_functions (@var{new_val})\n\
 Query or set the internal variable that controls whether internal\n\
 output from a function is suppressed.  If this option is disabled,\n\
 Octave will display the results produced by evaluating expressions\n\
 within a function body that are not terminated with a semicolon.\n\
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -217,16 +217,18 @@ public:
   virtual bool is_string (void) const { return false; }
 
   virtual bool is_sq_string (void) const { return false; }
 
   virtual bool is_range (void) const { return false; }
 
   virtual bool is_map (void) const { return false; }
 
+  virtual bool is_object (void) const { return false; }
+
   virtual bool is_streamoff (void) const { return false; }
 
   virtual bool is_cs_list (void) const { return false; }
 
   virtual bool is_list (void) const { return false; }
 
   virtual bool is_magic_colon (void) const { return false; }
 
@@ -283,16 +285,20 @@ public:
   virtual bool is_constant (void) const { return false; }
 
   virtual bool is_function_handle (void) const { return false; }
 
   virtual bool is_inline_function (void) const { return false; }
 
   virtual bool is_function (void) const { return false; }
 
+  virtual bool is_user_script (void) const { return false; }
+
+  virtual bool is_user_function (void) const { return false; }
+
   virtual bool is_builtin_function (void) const { return false; }
 
   virtual bool is_dld_function (void) const { return false; }
 
   virtual bool is_mex_function (void) const { return false; }
 
   virtual short int short_value (bool = false, bool = false) const;
 
@@ -482,16 +488,20 @@ protected:
 private:
 
   static int curr_print_indent_level;
   static bool beginning_of_line;
 
   DECLARE_OV_BASE_TYPEID_FUNCTIONS_AND_DATA
 };
 
+// If TRUE, turn off printing of results in functions (as if a
+// semicolon has been appended to each statement).
+extern bool Vsilent_functions;
+
 // TRUE means to perform automatic sparse to real mutation if there
 // is memory to be saved
 extern bool Vsparse_auto_mutate;
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -23,16 +23,18 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 #include <sstream>
 #include <vector>
 
+#include "file-ops.h"
+
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "input.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
@@ -58,80 +60,43 @@ along with Octave; see the file COPYING.
 #include "ls-utils.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_fcn_handle);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_fcn_handle,
 				     "function handle",
 				     "function_handle");
 
-void
-octave_fcn_handle::reload_warning (const std::string& fcn_type) const
-{
-  if (warn_reload)
-    {
-      warn_reload = false;
-
-      warning ("reloading %s functions referenced by function handles is not implemented",
-	       fcn_type.c_str ());
-    }
-}
-
 octave_value_list
 octave_fcn_handle::subsref (const std::string& type,
 			    const std::list<octave_value_list>& idx,
 			    int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       {
-	octave_function *f = function_value ();
-
-	if (f && f->time_checked () < Vlast_prompt_time)
-	  {
-	    std::string ff_nm = f->fcn_file_name ();
+	out_of_date_check (fcn);
 
-	    octave_time ottp = f->time_parsed ();
-	    time_t tp = ottp.unix_time ();
+	if (fcn.is_defined ())
+	  {
+	    octave_function *f = function_value ();
 
-	    if (ff_nm.empty ())
-	      {
-		// FIXME -- need to handle inline and
-		// command-line functions here.
-	      }
+	    if (f)
+	      retval = f->subsref (type, idx, nargout);
 	    else
-	      {
-		if (fcn_out_of_date (f, ff_nm, tp))
-		  {
-		    // FIXME -- there is currently no way to
-		    // parse a .m file or reload a .oct file that
-		    // leaves the fbi symbol table untouched.  We need
-		    // a function that will parse the file and return
-		    // a pointer to the new function definition
-		    // without altering the symbol table.
-
-		    if (f->is_nested_function ())
-		      reload_warning ("nested");
-		    else
-		      reload_warning ("functions");
-		  }
-	      }
+	      error ("invalid function handle");
 	  }
-
-	if (f)
-	  retval = f->subsref (type, idx, nargout);
 	else
 	  error ("invalid function handle");
       }
       break;
 
-
     case '{':
     case '.':
       {
 	std::string typ_nm = type_name ();
 	error ("%s cannot be indexed with %c", typ_nm.c_str (), type[0]);
       }
       break;
 
@@ -162,31 +127,28 @@ octave_fcn_handle::set_fcn (const std::s
     {
       // First check if just replacing matlabroot is enough
       std::string str = OCTAVE_EXEC_PREFIX + 
 	fpath.substr (octaveroot.length ());		    
       file_stat fs (str);
 
       if (fs.exists ())
 	{
-	  symbol_record *sr = fbi_sym_tab->lookup (str, true);
-		    
-	  if (sr)
-	    {
-	      load_fcn_from_file (sr, false);
+	  size_t xpos = str.find_last_of (file_ops::dir_sep_chars);
 
-	      fcn = octave_value (new octave_fcn_handle (sr->def (), nm));
+	  std::string dir_name = str.substr (0, xpos);
 
-	      // The next two lines are needed to force the 
-	      // definition of the function back to the one 
-	      // that is on the user path.
-	      sr = fbi_sym_tab->lookup (nm, true);
+	  octave_function *xfcn
+	    = load_fcn_from_file (str, dir_name, "", nm);
 
-	      load_fcn_from_file (sr, false);
+	  if (xfcn)
+	    {
+	      octave_value tmp (xfcn);
 
+	      fcn = octave_value (new octave_fcn_handle (tmp, nm));
 	    }
 	  else
 	    {
 	      error ("function handle points to non-existent function");
 	      success = false;
 	    }
 	}
       else
@@ -197,63 +159,61 @@ octave_fcn_handle::set_fcn (const std::s
 	  names(1) = nm + ".mex";
 	  names(2) = nm + ".m";
 
 	  dir_path p (load_path::system_path ());
 
 	  str = octave_env::make_absolute 
 	    (p.find_first_of (names), octave_env::getcwd ());
 
-	  symbol_record *sr = fbi_sym_tab->lookup (str, true);
+	  size_t xpos = str.find_last_of (file_ops::dir_sep_chars);
 
-	  if (sr)
-	    {
-	      load_fcn_from_file (sr, false);
+	  std::string dir_name = str.substr (0, xpos);
+
+	  octave_function *xfcn = load_fcn_from_file (str, dir_name, "", nm);
 
-	      fcn = octave_value (new octave_fcn_handle (sr->def (), nm));
+	  if (xfcn)
+	    {
+	      octave_value tmp (xfcn);
 
-	      // The next two lines are needed to force the 
-	      // definition of the function back to the one 
-	      // that is on the user path.
-	      sr = fbi_sym_tab->lookup (nm, true);
-
-	      load_fcn_from_file (sr, false);
+	      fcn = octave_value (new octave_fcn_handle (tmp, nm));
 	    }
 	  else
 	    {
 	      error ("function handle points to non-existent function");
 	      success = false;
 	    }
 	}
     }
   else
     {
       if (fpath.length () > 0)
 	{
-	  symbol_record *sr = fbi_sym_tab->lookup (fpath, true);
+	  size_t xpos = fpath.find_last_of (file_ops::dir_sep_chars);
 
-	  if (sr)
-	    {
-	      load_fcn_from_file (sr, false);
+	  std::string dir_name = fpath.substr (0, xpos);
+
+	  octave_function *xfcn = load_fcn_from_file (fpath, dir_name, "", nm);
 
-	      fcn = octave_value (new octave_fcn_handle (sr->def (), nm));
+	  if (xfcn)
+	    {
+	      octave_value tmp (xfcn);
 
-	      sr = fbi_sym_tab->lookup (nm, true);
-
-	      load_fcn_from_file (sr, false);
+	      fcn = octave_value (new octave_fcn_handle (tmp, nm));
 	    }
 	  else
 	    {
 	      error ("function handle points to non-existent function");
 	      success = false;
 	    }
 	}
       else
 	{
-	  fcn = lookup_function (nm);
+	  fcn = symbol_table::find_function (nm);
+
 	  if (! fcn.is_function ())
 	    {
 	      error ("function handle points to non-existent function");
 	      success = false;
 	    }
 	}
     }
 
@@ -265,40 +225,34 @@ octave_fcn_handle::save_ascii (std::ostr
 {
   if (nm == "@<anonymous>")
     {
       os << nm << "\n";
 
       print_raw (os, true);
       os << "\n";
 
-      if (fcn.is_undefined())
+      if (fcn.is_undefined ())
 	return false;
 
       octave_user_function *f = fcn.user_function_value ();
 
-      Array<symbol_record *> vars = f->sym_tab()->symbol_list();
-      octave_idx_type varlen = vars.length();
+      std::list<symbol_table::symbol_record> vars
+	= symbol_table::all_variables (f->scope ());
 
-      // Exclude undefined values like __retval__
-      for (octave_idx_type i = 0; i < vars.length(); i++)
-	{
-	  if (! vars(i)->is_defined ())
-	    varlen--;
-	}
+      size_t varlen = vars.size ();
 
       if (varlen > 0)
 	{
 	  os << "# length: " << varlen << "\n";
 
-	  for (octave_idx_type i = 0; i < vars.length(); i++)
+	  for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
+	       p != vars.end (); p++)
 	    {
-	      if (vars(i)->is_defined () &&
-		  ! save_ascii_data (os, vars(i)->def(), vars(i)->name(), 
-				     false, 0))
+	      if (! save_ascii_data (os, p->varval (), p->name (), false, 0))
 		return os;
 	    }
 	}
     }
   else
     {
       os << "# octaveroot: " << OCTAVE_EXEC_PREFIX << "\n";
       os << "# path: " << user_function_value ()-> fcn_file_name () << "\n";
@@ -352,68 +306,54 @@ octave_fcn_handle::load_ascii (std::istr
 	      is.get (c);
 	      if (! is)
 		break;
 	      buf << c;
 	    }
 	}
 
       pos = is.tellg ();
-      symbol_table *local_sym_tab = 0;
+
+      symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
 
       if (extract_keyword (is, "length", len, true) && len >= 0)
 	{
 	  if (len > 0)
 	    {
-	      octave_idx_type nlen = len;
-	      if (nlen % 2)
-		nlen++;
-	      
-	      local_sym_tab = new symbol_table (((nlen + 1) & ~1) , "LOCAL");
-	      
 	      for (octave_idx_type i = 0; i < len; i++)
 		{
 		  octave_value t2;
 		  bool dummy;
 
 		  std::string name
 		    = read_ascii_data (is, std::string (), dummy, t2, i);
 
 		  if (!is)
 		    {
 		      error ("load: failed to load anonymous function handle");
 		      break;
 		    }
 
-		  symbol_record *sr = local_sym_tab->lookup (name, true);
-
-		  if (sr)
-		    sr->define (t2);
-		  else
-		    {
-		      error ("load: failed to load anonymous function handle");
-		      success = false;
-		      break;
-		    }
+		  symbol_table::varref (name, local_scope) = t2;
 		}
 	    }
 	}
       else
 	{
 	  is.seekg (pos);
 	  is.clear ();
 	}
 
       if (is && success)
 	{
 	  unwind_protect::begin_frame ("anon_ascii_load");
-	  unwind_protect_ptr (curr_sym_tab);
 
-	  if (local_sym_tab)
-	    curr_sym_tab = local_sym_tab;
+	  symbol_table::push_scope (local_scope);
+
+	  unwind_protect::add (symbol_table::pop_scope);
 
 	  int parse_status;
 	  octave_value anon_fcn_handle = 
 	    eval_string (buf.str (), true, parse_status);
 
 	  if (parse_status == 0)
 	    {
 	      octave_fcn_handle *fh = 
@@ -426,18 +366,17 @@ octave_fcn_handle::load_ascii (std::istr
 	  else
 	    success = false;
 
 	  unwind_protect::run_frame ("anon_ascii_load");
 	}
       else
 	success = false;
 
-      if (local_sym_tab)
-	delete local_sym_tab;
+      symbol_table::erase_scope (local_scope);
     }
   else
     success = set_fcn (octaveroot, fpath);
 
   return success;
 }
 
 /* 
@@ -468,30 +407,25 @@ octave_fcn_handle::load_ascii (std::istr
 
 bool
 octave_fcn_handle::save_binary (std::ostream& os, bool& save_as_floats)
 {
   if (nm == "@<anonymous>")
     {
       std::ostringstream nmbuf;
 
-      if (fcn.is_undefined())
+      if (fcn.is_undefined ())
 	return false;
 
       octave_user_function *f = fcn.user_function_value ();
 
-      Array<symbol_record *> vars = f->sym_tab()->symbol_list();
-      octave_idx_type varlen = vars.length();
+      std::list<symbol_table::symbol_record> vars
+	= symbol_table::all_variables (f->scope ());
 
-      // Exclude undefined values like __retval__
-      for (octave_idx_type i = 0; i < vars.length(); i++)
-	{
-	  if (! vars(i)->is_defined ())
-	    varlen--;
-	}
+      size_t varlen = vars.size ();
 
       if (varlen > 0)
 	nmbuf << nm << " " << varlen;
       else
 	nmbuf << nm;
 
       std::string buf_str = nmbuf.str();
       int32_t tmp = buf_str.length ();
@@ -502,20 +436,20 @@ octave_fcn_handle::save_binary (std::ost
       print_raw (buf, true);
       std::string stmp = buf.str ();
       tmp = stmp.length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (stmp.c_str (), stmp.length ());
 
       if (varlen > 0)
 	{
-	  for (octave_idx_type i = 0; i < vars.length(); i++)
+	  for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
+	       p != vars.end (); p++)
 	    {
-	      if (vars(i)->is_defined () &&
-		  ! save_binary_data (os, vars(i)->def(), vars(i)->name(), 
+	      if (! save_binary_data (os, p->varval (), p->name (),
 				      "", 0, save_as_floats))
 		return os;
 	    }
 	}
     }
   else
     {
       std::ostringstream nmbuf;
@@ -523,24 +457,26 @@ octave_fcn_handle::save_binary (std::ost
       nmbuf << nm << "\n" << OCTAVE_EXEC_PREFIX << "\n" 
 	    << user_function_value ()-> fcn_file_name () ;
 
       std::string buf_str = nmbuf.str ();
       int32_t tmp = buf_str.length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (buf_str.c_str (), buf_str.length ());
     }
+
   return true;
 }
 
 bool
 octave_fcn_handle::load_binary (std::istream& is, bool swap,
 				oct_mach_info::float_format fmt)
 {
   bool success = true;
+
   int32_t tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
   if (swap)
     swap_bytes<4> (&tmp);
 
   OCTAVE_LOCAL_BUFFER (char, ctmp1, tmp+1);
   is.read (ctmp1, tmp);
@@ -563,64 +499,47 @@ octave_fcn_handle::load_binary (std::ist
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
 
       OCTAVE_LOCAL_BUFFER (char, ctmp2, tmp+1);
       is.read (ctmp2, tmp);
 
-      symbol_table *local_sym_tab = 0;
+      symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
+	      
       if (len > 0)
 	{
-	  octave_idx_type nlen = len;
-	  if (nlen % 2)
-	    nlen++;
-	      
-	  local_sym_tab = new symbol_table (nlen, "LOCAL");
-	      
 	  for (octave_idx_type i = 0; i < len; i++)
 	    {
 	      octave_value t2;
 	      bool dummy;
 	      std::string doc;
 
 	      std::string name = 
 		read_binary_data (is, swap, fmt, std::string (), 
 				  dummy, t2, doc);
 
 	      if (!is)
 		{
 		  error ("load: failed to load anonymous function handle");
 		  break;
 		}
 
-	      symbol_record *sr = local_sym_tab->lookup (name, true);
-
-	      if (sr)
-		{
-		  sr->define (t2);
-		  sr->document (doc);
-		}
-	      else
-		{
-		  error ("load: failed to load anonymous function handle");
-		  success = false;
-		  break;
-		}
+	      symbol_table::varref (name, local_scope) = t2;
 	    }
 	}
 
       if (is && success)
 	{
 	  unwind_protect::begin_frame ("anon_binary_load");
-	  unwind_protect_ptr (curr_sym_tab);
 
-	  if (local_sym_tab)
-	    curr_sym_tab = local_sym_tab;
+	  symbol_table::push_scope (local_scope);
+
+	  unwind_protect::add (symbol_table::pop_scope);
 
 	  int parse_status;
 	  octave_value anon_fcn_handle = 
 	    eval_string (ctmp2, true, parse_status);
 
 	  if (parse_status == 0)
 	    {
 	      octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
@@ -630,18 +549,17 @@ octave_fcn_handle::load_binary (std::ist
 		success = false;
 	    }
 	  else
 	    success = false;
 
 	  unwind_protect::run_frame ("anon_binary_load");
 	}
 
-      if (local_sym_tab)
-	delete local_sym_tab;
+      symbol_table::erase_scope (local_scope);
     }
   else
     {
       std::string octaveroot;
       std::string fpath;
 
       if (nm.find_first_of ("\n") != NPOS)
 	{
@@ -684,22 +602,24 @@ octave_fcn_handle::load_binary (std::ist
 
 */
 
 #if defined (HAVE_HDF5)
 bool
 octave_fcn_handle::save_hdf5 (hid_t loc_id, const char *name,
 			      bool save_as_floats)
 {
+  bool retval = true;
+
   hid_t group_hid = -1;
   group_hid = H5Gcreate (loc_id, name, 0);
-  if (group_hid < 0 ) return false;
+  if (group_hid < 0)
+    return false;
 
   hid_t space_hid = -1, data_hid = -1, type_hid = -1;;
-  bool retval = true;
 
   // attach the type of the variable
   type_hid = H5Tcopy (H5T_C_S1);
   H5Tset_size (type_hid, nm.length () + 1);
   if (type_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
@@ -751,25 +671,21 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
 	  H5Tclose (type_hid);
 	  H5Gclose (group_hid);
 	  return false;
 	}
 
       H5Dclose (data_hid);
 
       octave_user_function *f = fcn.user_function_value ();
-      Array<symbol_record *> vars = f->sym_tab()->symbol_list();
-      octave_idx_type varlen = vars.length();
 
-      // Exclude undefined values like __retval__
-      for (octave_idx_type i = 0; i < vars.length(); i++)
-	{
-	  if (! vars(i)->is_defined ())
-	    varlen--;
-	}
+      std::list<symbol_table::symbol_record> vars
+	= symbol_table::all_variables (f->scope ());
+
+      size_t varlen = vars.size ();
 
       if (varlen > 0)
 	{
 	  hid_t as_id = H5Screate (H5S_SCALAR);
 
 	  if (as_id >= 0)
 	    {
 	      hid_t a_id = H5Acreate (group_hid, "SYMBOL_TABLE",
@@ -793,20 +709,20 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
 	  if (data_hid < 0) 
 	    {
 	      H5Sclose (space_hid);
 	      H5Tclose (type_hid);
 	      H5Gclose (group_hid);
 	      return false;
 	    }
 
-	  for (octave_idx_type i = 0; i < vars.length(); i++)
+	  for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
+	       p != vars.end (); p++)
 	    {
-	      if (vars(i)->is_defined () &&
-		  ! add_hdf5_data (data_hid, vars(i)->def(), vars(i)->name(), 
+	      if (! add_hdf5_data (data_hid, p->varval (), p->name (),
 				   "", false, save_as_floats))
 		break;
 	    }
 	  H5Gclose (data_hid);
 	}
     }
   else
     {
@@ -878,23 +794,25 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
 
   return retval;
 }
 
 bool
 octave_fcn_handle::load_hdf5 (hid_t loc_id, const char *name,
 			      bool have_h5giterate_bug)
 {
+  bool success = true;
+
   hid_t group_hid, data_hid, space_hid, type_hid, type_class_hid, st_id;
   hsize_t rank;
   int slen;
-  bool success = true;
 
   group_hid = H5Gopen (loc_id, name);
-  if (group_hid < 0 ) return false;
+  if (group_hid < 0)
+    return false;
 
   data_hid = H5Dopen (group_hid, "nm");
 
   if (data_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
@@ -1012,17 +930,16 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 	  H5Tclose (type_hid);
 	  H5Dclose (data_hid);
 	  H5Gclose (group_hid);
 	  return false;
 	}
       H5Tclose (st_id);
       H5Dclose (data_hid);
 
-      symbol_table *local_sym_tab = 0;
       octave_idx_type len = 0;
 
       // we have to pull some shenanigans here to make sure
       // HDF5 doesn't print out all sorts of error messages if we
       // call H5Aopen for a non-existing attribute
 
       H5E_auto_t err_func;
       void *err_func_data;
@@ -1040,24 +957,20 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 	    success = false;
 
 	  H5Aclose (attr_id);
 	}
 
       // restore error reporting:
       H5Eset_auto (err_func, err_func_data);
 
+      symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
+
       if (len > 0 && success)
 	{
-	  octave_idx_type nlen = len;
-	  if (nlen % 2)
-	    nlen++;
-	      
-	  local_sym_tab = new symbol_table (nlen, "LOCAL");
-	      
 #ifdef HAVE_H5GGET_NUM_OBJS
 	  hsize_t num_obj = 0;
 	  data_hid = H5Gopen (group_hid, "symbol table"); 
 	  H5Gget_num_objs (data_hid, &num_obj);
 	  H5Gclose (data_hid);
 
 	  if (num_obj != static_cast<hsize_t>(len))
 	    {
@@ -1078,37 +991,28 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 		      error ("load: failed to load anonymous function handle");
 		      success = false;
 		      break;
 		    }
 
 		  if (have_h5giterate_bug)
 		    current_item++;  // H5Giterate returns last index processed
 
-		  symbol_record *sr = local_sym_tab->lookup (dsub.name, true);
-
-		  if (sr)
-		    sr->define (dsub.tc);
-		  else
-		    {
-		      error ("load: failed to load anonymous function handle");
-		      success = false;
-		      break;
-		    }
+		  symbol_table::varref (dsub.name, local_scope) = dsub.tc;
 		}
 	    }
 	}
 
       if (success)
 	{
 	  unwind_protect::begin_frame ("anon_hdf5_load");
-	  unwind_protect_ptr (curr_sym_tab);
 
-	  if (local_sym_tab)
-	    curr_sym_tab = local_sym_tab;
+	  symbol_table::push_scope (local_scope);
+
+	  unwind_protect::add (symbol_table::pop_scope);
 
 	  int parse_status;
 	  octave_value anon_fcn_handle = 
 	    eval_string (fcn_tmp, true, parse_status);
 
 	  if (parse_status == 0)
 	    {
 	      octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
@@ -1118,18 +1022,17 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 		success = false;
 	    }
 	  else
 	    success = false;
 
 	  unwind_protect::run_frame ("anon_hdf5_load");
 	}
 
-      if (local_sym_tab)
-	delete local_sym_tab;
+      symbol_table::erase_scope (local_scope);
     }
   else
     {
       std::string octaveroot;
       std::string fpath;
 
       // we have to pull some shenanigans here to make sure
       // HDF5 doesn't print out all sorts of error messages if we
@@ -1313,31 +1216,19 @@ octave_fcn_handle::print_raw (std::ostre
 			   current_print_indent_level ());
 }
 
 octave_value
 make_fcn_handle (const std::string& nm)
 {
   octave_value retval;
 
-  octave_function *fcn = octave_call_stack::current ();
-
-  std::string parent_name = fcn ? fcn->name () : std::string ();
-
-  if (! parent_name.empty ())
-    {
-      size_t pos = parent_name.find (':');
+  octave_value f = symbol_table::find_function (nm);
 
-      if (pos != NPOS)
-	parent_name = parent_name.substr (0, pos);
-    }
-
-  octave_value f = lookup_function (nm, parent_name);
-
-  if (f.is_function ())
+  if (f.is_defined ())
     retval = octave_value (new octave_fcn_handle (f, nm));
   else
     error ("error creating function handle \"@%s\"", nm.c_str ());
 
   return retval;
 }
 
 DEFUN (functions, args, ,
@@ -1391,35 +1282,29 @@ Return a struct containing information a
 
 	      if (nm.empty ())
 		{
 		  if (fh_nm == "@<anonymous>")
 		    {
 		      m.assign ("file", "");
 
 		      octave_user_function *fu = fh->user_function_value ();
-		      Array <symbol_record *> vars = 
-			fu->sym_tab ()->symbol_list ();
-		      octave_idx_type varlen = vars.length ();
 
-		      // Exclude undefined values like __retval__
-		      for (int i = 0; i < vars.length (); i++)
-			{
-			  if (! vars (i)->is_defined ())
-			    varlen--;
-			}
+		      std::list<symbol_table::symbol_record> vars
+			= symbol_table::all_variables (fu->scope ());
+
+		      size_t varlen = vars.size ();
 
 		      if (varlen > 0)
 			{
 			  Octave_map ws;
-			  for (octave_idx_type i = 0; i < vars.length (); i++)
+			  for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
+			       p != vars.end (); p++)
 			    {
-			      if (vars (i)->is_defined ())
-				ws.assign (vars (i)->name (), 
-					   vars (i)->def ());
+			      ws.assign (p->name (), p->varval ());
 			    }
 
 			  m.assign ("workspace", ws);
 			}
 		    }
 		  else if (fcn->is_user_function ())
 		    {
 		      octave_user_function *fu = fh->user_function_value ();
diff --git a/src/ov-fcn-handle.h b/src/ov-fcn-handle.h
--- a/src/ov-fcn-handle.h
+++ b/src/ov-fcn-handle.h
@@ -113,18 +113,16 @@ private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
   // If TRUE, print a warning if the pointed-to fucntion is out of
   // date.  This variable may be removed when updating is properly
   // implemented.
   mutable bool warn_reload;
 
-  void reload_warning (const std::string& fcn_type) const;
-
 protected:
 
   // The function we are handling.
   octave_value fcn;
 
   // The name of the handle, including the "@".
   std::string nm;
 };
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 
 #include "oct-time.h"
 #include "str-vec.h"
 
 #include "oct-alloc.h"
 #include "oct-obj.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
+#include "symtab.h"
 
 class tree_walker;
 
 // Functions.
 
 class
 OCTINTERP_API
 octave_function : public octave_base_value
@@ -60,32 +61,46 @@ public:
   virtual bool is_system_fcn_file (void) const { return false; }
 
   virtual std::string fcn_file_name (void) const { return std::string (); }
 
   virtual std::string parent_fcn_name (void) const { return std::string (); }
 
   virtual void mark_fcn_file_up_to_date (const octave_time&) { }
 
+  virtual symbol_table::scope_id scope (void) { return -1; }
+
   virtual octave_time time_parsed (void) const
     { return octave_time (static_cast<time_t> (0)); }
 
   virtual octave_time time_checked (void) const
     { return octave_time (static_cast<time_t> (0)); }
 
   virtual bool is_nested_function (void) const { return false; }
 
-  virtual bool is_user_script (void) const { return false; }
+  virtual bool is_class_constructor (void) const { return false; }
 
-  virtual bool is_user_function (void) const { return false; }
+  virtual bool is_class_method (void) const { return false; }
+
+  virtual std::string dispatch_class (void) const { return std::string (); }
 
   virtual bool takes_varargs (void) const { return false; }
 
   virtual bool takes_var_return (void) const { return false; }
 
+  std::string dir_name (void) const { return my_dir_name; }
+
+  void stash_dir_name (const std::string& dir) { my_dir_name = dir; }
+
+  void lock (void) { locked = true; }
+
+  void unlock (void) { locked = false; }
+
+  bool islocked (void) { return locked; }
+
   void mark_relative (void) { relative = true; }
 
   bool is_relative (void) const { return relative; }
 
   std::string name (void) const { return my_name; }
 
   void document (const std::string& ds) { doc = ds; }
 
@@ -99,19 +114,26 @@ protected:
 
   octave_function (const std::string& nm,
 		   const std::string& ds = std::string ())
     : relative (false), my_name (nm), doc (ds) { }
 
   // TRUE if this function was found from a relative path element.
   bool relative;
 
+  // TRUE if this function is tagged so that it can't be cleared.
+  bool locked;
+
   // The name of this function.
   std::string my_name;
 
+  // The name of the directory in the path where we found this
+  // function.  May be relative.
+  std::string my_dir_name;
+
   // The help text for this function.
   std::string doc;
 
 private:
 
   // No copying!
 
   octave_function (const octave_function& f);
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -767,20 +767,24 @@ argument that is not a structure.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      if (args(0).is_map ())
+      octave_value arg = args(0);
+
+      if (arg.is_map () || arg.is_object ())
 	{
-	  Octave_map m = args(0).map_value ();
+	  Octave_map m = arg.map_value ();
+
 	  string_vector keys = m.keys ();
+
 	  if (keys.length () == 0)
 	    retval = Cell (0, 1);
 	  else
 	    retval = Cell (m.keys ());
 	}
       else
 	gripe_wrong_type_arg ("fieldnames", args(0));
     }
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -137,21 +137,23 @@ public:
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
 #endif
 
   mxArray *as_mxArray (void) const;
 
-private:
+protected:
 
   // The associative array used to manage the structure data.
   Octave_map map;
 
+private:
+
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -88,16 +88,24 @@ octave_value_typeinfo::register_type (co
 				      const std::string& c_name,
 				      const octave_value& val)
 {
   return (instance_ok ())
     ? instance->do_register_type (t_name, c_name, val) : -1;
 }
 
 bool
+octave_value_typeinfo::register_unary_class_op (octave_value::unary_op op,
+					        octave_value_typeinfo::unary_class_op_fcn f)
+{
+  return (instance_ok ())
+    ? instance->do_register_unary_class_op (op, f) : false;
+}
+
+bool
 octave_value_typeinfo::register_unary_op (octave_value::unary_op op,
 					   int t, octave_value_typeinfo::unary_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_unary_op (op, t, f) : false;
 }
 
 bool
@@ -105,16 +113,24 @@ octave_value_typeinfo::register_non_cons
 						    int t,
 						    octave_value_typeinfo::non_const_unary_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_non_const_unary_op (op, t, f) : false;
 }
 
 bool
+octave_value_typeinfo::register_binary_class_op (octave_value::binary_op op,
+						 octave_value_typeinfo::binary_class_op_fcn f)
+{
+  return (instance_ok ())
+    ? instance->do_register_binary_class_op (op, f) : false;
+}
+
+bool
 octave_value_typeinfo::register_binary_op (octave_value::binary_op op,
 					   int t1, int t2,
 					   octave_value_typeinfo::binary_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_binary_op (op, t1, t2, f) : false;
 }
 
@@ -220,16 +236,33 @@ octave_value_typeinfo::do_register_type 
   vals (i) = val;
 
   num_types++;
 
   return i;
 }
 
 bool
+octave_value_typeinfo::do_register_unary_class_op (octave_value::unary_op op,
+					           octave_value_typeinfo::unary_class_op_fcn f)
+{
+  if (lookup_unary_class_op (op))
+    {
+      std::string op_name = octave_value::unary_op_as_string (op);
+
+      warning ("duplicate unary operator `%s' for class dispatch",
+	       op_name.c_str ());
+    }
+
+  unary_class_ops.checkelem (static_cast<int> (op)) = f;
+
+  return false;
+}
+
+bool
 octave_value_typeinfo::do_register_unary_op (octave_value::unary_op op,
 					     int t, octave_value_typeinfo::unary_op_fcn f)
 {
   if (lookup_unary_op (op, t))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
       std::string type_name = types(t);
 
@@ -256,16 +289,33 @@ octave_value_typeinfo::do_register_non_c
     }
 
   non_const_unary_ops.checkelem (static_cast<int> (op), t) = f;
 
   return false;
 }
 
 bool
+octave_value_typeinfo::do_register_binary_class_op (octave_value::binary_op op,
+						    octave_value_typeinfo::binary_class_op_fcn f)
+{
+  if (lookup_binary_class_op (op))
+    {
+      std::string op_name = octave_value::binary_op_as_string (op);
+
+      warning ("duplicate binary operator `%s' for class dispatch",
+	       op_name.c_str ());
+    }
+
+  binary_class_ops.checkelem (static_cast<int> (op)) = f;
+
+  return false;
+}
+
+bool
 octave_value_typeinfo::do_register_binary_op (octave_value::binary_op op,
 					      int t1, int t2,
 					      octave_value_typeinfo::binary_op_fcn f)
 {
   if (lookup_binary_op (op, t1, t2))
     {
       std::string op_name = octave_value::binary_op_as_string (op);
       std::string t1_name = types(t1);
@@ -402,29 +452,41 @@ octave_value_typeinfo::do_lookup_type (c
 	  retval.make_unique ();
 	  break;
 	}
     }
 
   return retval;
 }
 
+octave_value_typeinfo::unary_class_op_fcn
+octave_value_typeinfo::do_lookup_unary_class_op (octave_value::unary_op op)
+{
+  return unary_class_ops.checkelem (static_cast<int> (op));
+}
+
 octave_value_typeinfo::unary_op_fcn
 octave_value_typeinfo::do_lookup_unary_op (octave_value::unary_op op, int t)
 {
   return unary_ops.checkelem (static_cast<int> (op), t);
 }
 
 octave_value_typeinfo::non_const_unary_op_fcn
 octave_value_typeinfo::do_lookup_non_const_unary_op
   (octave_value::unary_op op, int t)
 {
   return non_const_unary_ops.checkelem (static_cast<int> (op), t);
 }
 
+octave_value_typeinfo::binary_class_op_fcn
+octave_value_typeinfo::do_lookup_binary_class_op (octave_value::binary_op op)
+{
+  return binary_class_ops.checkelem (static_cast<int> (op));
+}
+
 octave_value_typeinfo::binary_op_fcn
 octave_value_typeinfo::do_lookup_binary_op (octave_value::binary_op op,
 					    int t1, int t2)
 {
   return binary_ops.checkelem (static_cast<int> (op), t1, t2);
 }
 
 octave_value_typeinfo::cat_op_fcn
@@ -494,32 +556,13 @@ currently installed data types.\n\
   else if (nargin == 1)
     retval = args(0).type_name ();
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN (class, args, ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} class (@var{expr})\n\
-\n\
-Return the class of the expression @var{expr}, as a string.\n\
-@end deftypefn")
-{
-  octave_value retval;
-
-  int nargin = args.length ();
-
-  if (nargin == 1)
-    retval = args(0).class_name ();
-  else
-    print_usage ();
-
-  return retval;
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -35,20 +35,25 @@ along with Octave; see the file COPYING.
 class string_vector;
 
 class
 OCTINTERP_API
 octave_value_typeinfo
 {
 public:
 
+  typedef octave_value (*unary_class_op_fcn) (const octave_value&);
+
   typedef octave_value (*unary_op_fcn) (const octave_base_value&);
 
   typedef void (*non_const_unary_op_fcn) (octave_base_value&);
 
+  typedef octave_value (*binary_class_op_fcn)
+    (const octave_value&, const octave_value&);
+
   typedef octave_value (*binary_op_fcn)
     (const octave_base_value&, const octave_base_value&);
 
   typedef octave_value (*cat_op_fcn)
     (octave_base_value&, const octave_base_value&, const Array<octave_idx_type>& ra_idx);
 
   typedef octave_value (*assign_op_fcn)
     (octave_base_value&, const octave_value_list&, const octave_base_value&);
@@ -56,21 +61,27 @@ public:
   typedef octave_value (*assignany_op_fcn)
     (octave_base_value&, const octave_value_list&, const octave_value&);
 
   static bool instance_ok (void);
 
   static int register_type (const std::string&, const std::string&,
 			    const octave_value&);
 
+  static bool register_unary_class_op (octave_value::unary_op,
+				       unary_class_op_fcn);
+
   static bool register_unary_op (octave_value::unary_op, int, unary_op_fcn);
 
   static bool register_non_const_unary_op (octave_value::unary_op, int,
 					   non_const_unary_op_fcn);
 
+  static bool register_binary_class_op (octave_value::binary_op,
+					binary_class_op_fcn);
+
   static bool register_binary_op (octave_value::binary_op, int, int,
 				  binary_op_fcn);
 
   static bool register_cat_op (int, int, cat_op_fcn);
 
   static bool register_assign_op (octave_value::assign_op, int, int,
 				  assign_op_fcn);
 
@@ -86,28 +97,40 @@ public:
   register_widening_op (int, int, octave_base_value::type_conv_fcn);
 
   static octave_value
   lookup_type (const std::string& nm)
   {
     return instance->do_lookup_type (nm);
   }
 
+  static unary_class_op_fcn
+  lookup_unary_class_op (octave_value::unary_op op)
+  {
+    return instance->do_lookup_unary_class_op (op);
+  }
+
   static unary_op_fcn
   lookup_unary_op (octave_value::unary_op op, int t)
   {
     return instance->do_lookup_unary_op (op, t);
   }
 
   static non_const_unary_op_fcn
   lookup_non_const_unary_op (octave_value::unary_op op, int t)
   {
     return instance->do_lookup_non_const_unary_op (op, t);
   }
 
+  static binary_class_op_fcn
+  lookup_binary_class_op (octave_value::binary_op op)
+  {
+    return instance->do_lookup_binary_class_op (op);
+  }
+
   static binary_op_fcn
   lookup_binary_op (octave_value::binary_op op, int t1, int t2)
   {
     return instance->do_lookup_binary_op (op, t1, t2);
   }
 
   static cat_op_fcn
   lookup_cat_op (int t1, int t2)
@@ -150,18 +173,20 @@ public:
     return instance->do_installed_type_names ();
   }
 
 protected:
 
   octave_value_typeinfo (void)
     : num_types (0), types (init_tab_sz, std::string ()),
       vals (init_tab_sz),
+      unary_class_ops (octave_value::num_unary_ops, 0),
       unary_ops (octave_value::num_unary_ops, init_tab_sz, 0),
       non_const_unary_ops (octave_value::num_unary_ops, init_tab_sz, 0),
+      binary_class_ops (octave_value::num_binary_ops, 0),
       binary_ops (octave_value::num_binary_ops, init_tab_sz, init_tab_sz, 0),
       cat_ops (init_tab_sz, init_tab_sz, 0),
       assign_ops (octave_value::num_assign_ops, init_tab_sz, init_tab_sz, 0),
       assignany_ops (octave_value::num_assign_ops, init_tab_sz, 0),
       pref_assign_conv (init_tab_sz, init_tab_sz, -1),
       type_conv_ops (init_tab_sz, init_tab_sz, 0),
       widening_ops (init_tab_sz, init_tab_sz, 0)  { }
 
@@ -172,20 +197,24 @@ private:
   static octave_value_typeinfo *instance;
 
   int num_types;
 
   Array<std::string> types;
 
   Array<octave_value> vals;
 
+  Array<unary_class_op_fcn> unary_class_ops;
+
   Array2<unary_op_fcn> unary_ops;
 
   Array2<non_const_unary_op_fcn> non_const_unary_ops;
 
+  Array<binary_class_op_fcn> binary_class_ops;
+
   Array3<binary_op_fcn> binary_ops;
 
   Array2<cat_op_fcn> cat_ops;
 
   Array3<assign_op_fcn> assign_ops;
 
   Array2<assignany_op_fcn> assignany_ops;
 
@@ -193,21 +222,26 @@ private:
 
   Array2<octave_base_value::type_conv_fcn> type_conv_ops;
 
   Array2<octave_base_value::type_conv_fcn> widening_ops;
 
   int do_register_type (const std::string&, const std::string&,
 			const octave_value&);
 
+  bool do_register_unary_class_op (octave_value::unary_op, unary_class_op_fcn);
+
   bool do_register_unary_op (octave_value::unary_op, int, unary_op_fcn);
 
   bool do_register_non_const_unary_op (octave_value::unary_op, int,
 				       non_const_unary_op_fcn);
 
+  bool do_register_binary_class_op (octave_value::binary_op,
+				    binary_class_op_fcn);
+
   bool do_register_binary_op (octave_value::binary_op, int, int,
 			      binary_op_fcn);
 
   bool do_register_cat_op (int, int, cat_op_fcn);
 
   bool do_register_assign_op (octave_value::assign_op, int, int,
 			      assign_op_fcn);
 
@@ -217,21 +251,25 @@ private:
   bool do_register_pref_assign_conv (int, int, int);
 
   bool do_register_type_conv_op (int, int, octave_base_value::type_conv_fcn);
 
   bool do_register_widening_op (int, int, octave_base_value::type_conv_fcn);
 
   octave_value do_lookup_type (const std::string& nm);
 
+  unary_class_op_fcn do_lookup_unary_class_op (octave_value::unary_op);
+
   unary_op_fcn do_lookup_unary_op (octave_value::unary_op, int);
 
   non_const_unary_op_fcn do_lookup_non_const_unary_op
     (octave_value::unary_op, int);
 
+  binary_class_op_fcn do_lookup_binary_class_op (octave_value::binary_op);
+
   binary_op_fcn do_lookup_binary_op (octave_value::binary_op, int, int);
 
   cat_op_fcn do_lookup_cat_op (int, int);
 
   assign_op_fcn do_lookup_assign_op (octave_value::assign_op, int, int);
 
   assignany_op_fcn do_lookup_assignany_op (octave_value::assign_op, int);
 
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -46,16 +46,41 @@ along with Octave; see the file COPYING.
 #include "unwind-prot.h"
 #include "utils.h"
 #include "parse.h"
 #include "variables.h"
 
 // Maximum nesting level for functions called recursively.
 static int Vmax_recursion_depth = 256;
 
+// Scripts.
+
+octave_value_list
+octave_user_script::do_multi_index_op (int nargout,
+				       const octave_value_list& args)
+{
+  octave_value_list retval;
+
+  if (! error_state)
+    {
+      if (args.length () == 0)
+	{
+	  // FIXME -- I think we need a way to protect against
+	  // recursion, but we can't use the same method as we use for
+	  // functions.
+
+	  source_file (file_name);
+	}
+      else
+	error ("invalid call to script");
+    }
+
+  return retval;
+}
+
 // User defined functions.
 
 DEFINE_OCTAVE_ALLOCATOR (octave_user_function);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_function,
 				     "user-defined function",
 				     "user-defined function");
 
@@ -64,40 +89,41 @@ DEFINE_OCTAVE_ALLOCATOR (octave_user_scr
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_script,
 				     "user-defined script",
 				     "user-defined script");
 
 // Ugh.  This really needs to be simplified (code/data?
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
-  (tree_parameter_list *pl, tree_parameter_list *rl,
-   tree_statement_list *cl, symbol_table *st)
+  (symbol_table::scope_id sid, tree_parameter_list *pl,
+   tree_parameter_list *rl, tree_statement_list *cl)
   : octave_function (std::string (), std::string ()),
     param_list (pl), ret_list (rl), cmd_list (cl),
-    local_sym_tab (st), lead_comm (), trail_comm (), file_name (),
+    lead_comm (), trail_comm (), file_name (),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (0), num_named_args (0),
-    nested_function (false), inline_function (false), args_passed (),
-    num_args_passed (0), symtab_entry (0), argn_sr (0),
-    nargin_sr (0), nargout_sr (0), varargin_sr (0)
+    nested_function (false), inline_function (false),
+    class_constructor (false), class_method (false), xdispatch_class (),
+    args_passed (), num_args_passed (0), local_scope (sid)
 {
   if (param_list)
     num_named_args = param_list->length ();
 }
 
 octave_user_function::~octave_user_function (void)
 {
   delete param_list;
   delete ret_list;
-  delete local_sym_tab;
   delete cmd_list;
   delete lead_comm;
   delete trail_comm;
+
+  symbol_table::erase_scope (local_scope);
 }
 
 octave_user_function *
 octave_user_function::define_ret_list (tree_parameter_list *t)
 {
   ret_list = t;
 
   return this;
@@ -158,32 +184,16 @@ octave_user_function::octave_all_va_args
       int k = 0;
       for (int i = num_named_args; i < num_args_passed; i++)
 	retval(k++) = args_passed(i);
     }
 
   return retval;
 }
 
-// For unwind protect.
-
-static void
-pop_symbol_table_context (void *table)
-{
-  symbol_table *tmp = static_cast<symbol_table *> (table);
-  tmp->pop_context ();
-}
-
-static void
-clear_symbol_table (void *table)
-{
-  symbol_table *tmp = static_cast<symbol_table *> (table);
-  tmp->clear ();
-}
-
 static void
 clear_param_list (void *lst)
 {
   tree_parameter_list *tmp = static_cast<tree_parameter_list *> (lst);
 
   if (tmp)
     tmp->undefine ();
 }
@@ -192,23 +202,16 @@ static void
 restore_args_passed (void *fcn)
 {
   octave_user_function *tmp = static_cast<octave_user_function *> (fcn);
 
   if (tmp)
     tmp->restore_args_passed ();
 }
 
-static void
-unprotect_function (void *sr_arg)
-{
-  symbol_record *sr = static_cast<symbol_record *> (sr_arg);
-  sr->unprotect ();
-}
-
 octave_value_list
 octave_user_function::subsref (const std::string& type,
 			       const std::list<octave_value_list>& idx,
 			       int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
@@ -264,42 +267,33 @@ octave_user_function::do_multi_index_op 
 
   if (call_depth > Vmax_recursion_depth)
     {
       ::error ("max_recursion_limit exceeded");
       unwind_protect::run_frame ("user_func_eval");
       return retval;
     }
 
-  if (symtab_entry && ! symtab_entry->is_read_only ())
-    {
-      symtab_entry->protect ();
-      unwind_protect::add (unprotect_function, symtab_entry);
-    }
+  // Save old and set current symbol table context, for
+  // eval_undefined_error().
+
+  symbol_table::push_scope (local_scope);
+  unwind_protect::add (symbol_table::pop_scope);
 
   if (call_depth > 1)
     {
-      local_sym_tab->push_context ();
-      unwind_protect::add (pop_symbol_table_context, local_sym_tab);
-    }
-
-  install_automatic_vars ();
-
-  // Force symbols to be undefined again when this function exits.
+      symbol_table::push_context ();
 
-  unwind_protect::add (clear_symbol_table, local_sym_tab);
-
-  // Save old and set current symbol table context, for
-  // eval_undefined_error().
-
-  unwind_protect_ptr (curr_caller_sym_tab);
-  curr_caller_sym_tab = curr_sym_tab;
-
-  unwind_protect_ptr (curr_sym_tab);
-  curr_sym_tab = local_sym_tab;
+      unwind_protect::add (symbol_table::pop_context);
+    }
+  else
+    {
+      // Force symbols to be undefined again when this function exits.
+      unwind_protect::add (symbol_table::clear_variables);
+    }
 
   unwind_protect_ptr (curr_caller_statement);
   curr_caller_statement = curr_statement;
 
   octave_call_stack::push (this);
 
   unwind_protect::add (octave_call_stack::unwind_pop, 0);
 
@@ -385,23 +379,21 @@ octave_user_function::do_multi_index_op 
     if (ret_list && ! is_inline_function ())
       {
 	ret_list->initialize_undefined_elements (my_name, nargout, Matrix ());
 
 	Cell varargout;
 
 	if (ret_list->takes_varargs ())
 	  {
-	    symbol_record *sr = local_sym_tab->lookup ("varargout");
+	    octave_value varargout_varval = symbol_table::varval ("varargout");
 
-	    if (sr && sr->is_variable ())
+	    if (varargout_varval.is_defined ())
 	      {
-		octave_value v = sr->def ();
-
-		varargout = v.cell_value ();
+		varargout = varargout_varval.cell_value ();
 
 		if (error_state)
 		  error ("expecting varargout to be a cell array object");
 	      }
 	  }
 
 	if (! error_state)
 	  retval = ret_list->convert_to_const_vector (varargout);
@@ -438,24 +430,23 @@ octave_user_function::traceback_error (v
 }
 
 void
 octave_user_function::accept (tree_walker& tw)
 {
   tw.visit_octave_user_function (*this);
 }
 
+#if 0
 void
 octave_user_function::print_symtab_info (std::ostream& os) const
 {
-  if (local_sym_tab)
-    local_sym_tab->print_info (os);
-  else
-    warning ("%s: no symbol table info!", my_name.c_str ());
+  symbol_table::print_info (os, local_scope);
 }
+#endif
 
 void
 octave_user_function::print_code_function_header (void)
 {
   tree_print_code tpc (octave_stdout, VPS4);
 
   tpc.visit_octave_user_function_header (*this);
 }
@@ -464,50 +455,39 @@ void
 octave_user_function::print_code_function_trailer (void)
 {
   tree_print_code tpc (octave_stdout, VPS4);
 
   tpc.visit_octave_user_function_trailer (*this);
 }
 
 void
-octave_user_function::install_automatic_vars (void)
-{
-  if (local_sym_tab)
-    {
-      argn_sr = local_sym_tab->lookup ("argn", true);
-      nargin_sr = local_sym_tab->lookup ("__nargin__", true);
-      nargout_sr = local_sym_tab->lookup ("__nargout__", true);
-
-      if (takes_varargs ())
-	varargin_sr = local_sym_tab->lookup ("varargin", true);
-    }
-}
-
-void
 octave_user_function::bind_automatic_vars
   (const string_vector& arg_names, int nargin, int nargout,
    const octave_value_list& va_args)
 {
   if (! arg_names.empty ())
-    argn_sr->define (arg_names);
+    symbol_table::varref ("argn") = arg_names;
 
-  nargin_sr->define (nargin);
-  nargout_sr->define (nargout);
+  symbol_table::varref (".nargin.") = nargin;
+  symbol_table::varref (".nargout.") = nargout;
+
+  symbol_table::mark_hidden (".nargin.");
+  symbol_table::mark_hidden (".nargout.");
 
   if (takes_varargs ())
     {
       int n = va_args.length ();
 
       Cell varargin (1, n);
 
       for (int i = 0; i < n; i++)
 	varargin(0,i) = va_args(i);
 
-      varargin_sr->define (varargin);
+      symbol_table::varref ("varargin") = varargin;
     }
 }
 
 DEFUN (nargin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} nargin ()\n\
 @deftypefnx {Built-in Function} {} nargin (@var{fcn_name})\n\
 Within a function, return the number of arguments passed to the function.\n\
@@ -523,17 +503,17 @@ function accepts a variable number of ar
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string fname = args(0).string_value ();
 
       if (! error_state)
 	{
-	  octave_value fcn_val = lookup_user_function (fname);
+	  octave_value fcn_val = symbol_table::find_user_function (fname);
 
 	  octave_user_function *fcn = fcn_val.user_function_value (true);
 
 	  if (fcn)
 	    {
 	      if (fcn->takes_varargs ())
 		retval = -1;
 	      else
@@ -546,19 +526,20 @@ function accepts a variable number of ar
 	  else
 	    error ("nargin: invalid function");
 	}
       else
 	error ("nargin: expecting string as first argument");
     }
   else if (nargin == 0)
     {
-      symbol_record *sr = curr_sym_tab->lookup ("__nargin__");
+      retval = symbol_table::varval (".nargin.");
 
-      retval = sr ? sr->def () : 0;
+      if (retval.is_undefined ())
+	retval = 0;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (nargout, args, ,
@@ -596,17 +577,17 @@ At the top level, @code{nargout} is unde
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string fname = args(0).string_value ();
 
       if (! error_state)
 	{
-	  octave_value fcn_val = lookup_user_function (fname);
+	  octave_value fcn_val = symbol_table::find_user_function (fname);
 
 	  octave_user_function *fcn = fcn_val.user_function_value (true);
 
 	  if (fcn)
 	    {
 	      if (fcn->takes_var_return ())
 		retval = -1;
 	      else
@@ -619,21 +600,22 @@ At the top level, @code{nargout} is unde
 	  else
 	    error ("nargout: invalid function");
 	}
       else
 	error ("nargout: expecting string as first argument");
     }
   else if (nargin == 0)
     {
-      if (! at_top_level ())
+      if (! symbol_table::at_top_level ())
 	{
-	  symbol_record *sr = curr_sym_tab->lookup ("__nargout__");
+	  retval = symbol_table::varval (".nargout.");
 
-	  retval = sr ? sr->def () : 0;
+	  if (retval.is_undefined ())
+	    retval = 0;
 	}
       else
 	error ("nargout: invalid call at top level");
     }
   else
     print_usage ();
 
   return retval;
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -28,54 +28,56 @@ along with Octave; see the file COPYING.
 
 #include <string>
 #include <stack>
 
 #include "comment-list.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
+#include "symtab.h"
 
 class string_vector;
 
 class octave_value;
 class tree_parameter_list;
 class tree_statement_list;
 class tree_va_return_list;
 class tree_walker;
-class symbol_table;
-class symbol_record;
 
 // Scripts.
 
 class
 octave_user_script : public octave_function
 {
 public:
 
   octave_user_script (void) { }
 
   octave_user_script (const std::string& fnm, const std::string& nm,
-		      const std::string& ds)
+		      const std::string& ds = std::string ())
     : octave_function (nm, ds), file_name (fnm) { }
 
   ~octave_user_script (void) { }
 
   // Scripts and user functions are both considered "scripts" because
   // they are written in Octave's scripting language.
 
   bool is_user_script (void) const { return true; }
 
   void stash_fcn_file_name (const std::string& nm) { file_name = nm; }
 
   std::string fcn_file_name (void) const { return file_name; }
 
+  octave_value_list
+  do_multi_index_op (int nargout, const octave_value_list& args);
+
 private:
 
-  // The name of the file we parsed
+  // The name of the file to parse.
   std::string file_name;
 
   // No copying!
 
   octave_user_script (const octave_user_script& f);
 
   octave_user_script& operator = (const octave_user_script& f);
 
@@ -86,20 +88,20 @@ private:
 
 // User-defined functions.
 
 class
 octave_user_function : public octave_function
 {
 public:
 
-  octave_user_function (tree_parameter_list *pl = 0,
+  octave_user_function (symbol_table::scope_id sid = -1,
+			tree_parameter_list *pl = 0,
 			tree_parameter_list *rl = 0,
-			tree_statement_list *cl = 0,
-			symbol_table *st = 0);
+			tree_statement_list *cl = 0);
 
   ~octave_user_function (void);
 
   octave_function *function_value (bool = false) { return this; }
 
   octave_user_function *user_function_value (bool = false) { return this; }
 
   octave_user_function *define_param_list (tree_parameter_list *t);
@@ -117,22 +119,22 @@ public:
   void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
 
   void stash_fcn_file_time (const octave_time& t)
     {
       t_parsed = t;
       mark_fcn_file_up_to_date (t);
     }
 
-  void stash_symtab_ptr (symbol_record *sr) { symtab_entry = sr; }
-
   std::string fcn_file_name (void) const { return file_name; }
 
   std::string parent_fcn_name (void) const { return parent_name; }
 
+  symbol_table::scope_id scope (void) { return local_scope; }
+
   octave_time time_parsed (void) const { return t_parsed; }
 
   octave_time time_checked (void) const { return t_checked; }
 
   void mark_as_system_fcn_file (void);
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
@@ -149,16 +151,28 @@ public:
   void mark_as_nested_function (void) { nested_function = true; }
 
   bool is_nested_function (void) const { return nested_function; }
 
   void mark_as_inline_function (void) { inline_function = true; }
 
   bool is_inline_function (void) const { return inline_function; }
 
+  void mark_as_class_constructor (void) { class_constructor = true; }
+
+  bool is_class_constructor (void) const { return class_constructor; }
+
+  void mark_as_class_method (void) { class_method = true; }
+
+  bool is_class_method (void) const { return class_method; }
+
+  void stash_dispatch_class (const std::string& nm) { xdispatch_class = nm; }
+
+  std::string dispatch_class (void) const { return xdispatch_class; }
+
   void save_args_passed (const octave_value_list& args)
     {
       if (call_depth > 1)
 	saved_args.push (args_passed);
 
       args_passed = args;
     }
 
@@ -190,41 +204,38 @@ public:
   void traceback_error (void) const;
 
   tree_parameter_list *parameter_list (void) { return param_list; }
 
   tree_parameter_list *return_list (void) { return ret_list; }
 
   tree_statement_list *body (void) { return cmd_list; }
 
-  symbol_table *sym_tab (void) { return local_sym_tab; }
-
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   void accept (tree_walker& tw);
 
+#if 0
   void print_symtab_info (std::ostream& os) const;
+#endif
 
 private:
 
   // List of arguments for this function.  These are local variables.
   tree_parameter_list *param_list;
 
   // List of parameters we return.  These are also local variables in
   // this function.
   tree_parameter_list *ret_list;
 
   // The list of commands that make up the body of this function.
   tree_statement_list *cmd_list;
 
-  // The local symbol table for this function.
-  symbol_table *local_sym_tab;
-
   // The comments preceding the FUNCTION token.
   octave_comment_list *lead_comm;
 
   // The comments preceding the ENDFUNCTION token.
   octave_comment_list *trail_comm;
 
   // The name of the file we parsed.
   std::string file_name;
@@ -251,46 +262,55 @@ private:
   int num_named_args;
 
   // TRUE means this is a nested function.
   bool nested_function;
 
   // TRUE means this is an inline function.
   bool inline_function;
 
+  // TRUE means this function is the constructor for class object.
+  bool class_constructor;
+
+  // TRUE means this function is a method for a class.
+  bool class_method;
+
+  // If this object is a class method or constructor, this is the name
+  // of the class to which the method belongs.
+  std::string xdispatch_class;
+
   // The values that were passed as arguments.
   octave_value_list args_passed;
 
   // A place to store the passed args for recursive calls.
   std::stack<octave_value_list> saved_args;
 
   // The number of arguments passed in.
   int num_args_passed;
 
-  // The symbol record for this function.
-  symbol_record *symtab_entry;
+  symbol_table::scope_id local_scope;
 
+#if 0
   // The symbol record for argn in the local symbol table.
-  symbol_record *argn_sr;
+  octave_value& argn_varref;
 
   // The symbol record for nargin in the local symbol table.
-  symbol_record *nargin_sr;
+  octave_value& nargin_varref;
 
   // The symbol record for nargout in the local symbol table.
-  symbol_record *nargout_sr;
+  octave_value& nargout_varref;
 
   // The symbol record for varargin in the local symbol table.
-  symbol_record *varargin_sr;
+  octave_value& varargin_varref;
+#endif
 
   void print_code_function_header (void);
 
   void print_code_function_trailer (void);
 
-  void install_automatic_vars (void);
-
   void bind_automatic_vars (const string_vector& arg_names, int nargin,
 			    int nargout, const octave_value_list& va_args);
 
   // No copying!
 
   octave_user_function (const octave_user_function& fn);
 
   octave_user_function& operator = (const octave_user_function& fn);
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -50,16 +50,17 @@ along with Octave; see the file COPYING.
 #include "ov-uint32.h"
 #include "ov-uint64.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-ch-mat.h"
 #include "ov-str-mat.h"
 #include "ov-range.h"
 #include "ov-struct.h"
+#include "ov-class.h"
 #include "ov-streamoff.h"
 #include "ov-list.h"
 #include "ov-cs-list.h"
 #include "ov-colon.h"
 #include "ov-builtin.h"
 #include "ov-mapper.h"
 #include "ov-dld-fcn.h"
 #include "ov-usr-fcn.h"
@@ -68,16 +69,17 @@ along with Octave; see the file COPYING.
 #include "ov-typeinfo.h"
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "pager.h"
 #include "parse.h"
 #include "pr-output.h"
+#include "symtab.h"
 #include "utils.h"
 #include "variables.h"
 
 // We are likely to have a lot of octave_value objects to allocate, so
 // make the grow_size large.
 DEFINE_OCTAVE_ALLOCATOR2(octave_value, 1024);
 
 // FIXME
@@ -122,16 +124,50 @@ octave_value::unary_op_as_string (unary_
     default:
       retval = "<unknown>";
     }
 
   return retval;
 }
 
 std::string
+octave_value::unary_op_fcn_name (unary_op op)
+{
+  std::string retval;
+
+  switch (op)
+    {
+    case op_not:
+      retval = "not";
+      break;
+
+    case op_uplus:
+      retval = "uplus";
+      break;
+
+    case op_uminus:
+      retval = "uminus";
+      break;
+
+    case op_transpose:
+      retval = "transpose";
+      break;
+
+    case op_hermitian:
+      retval = "ctranspose";
+      break;
+
+    default:
+      break;
+    }
+
+  return retval;
+}
+
+std::string
 octave_value::binary_op_as_string (binary_op op)
 {
   std::string retval;
 
   switch (op)
     {
     case op_add:
       retval = "+";
@@ -220,16 +256,102 @@ octave_value::binary_op_as_string (binar
     default:
       retval = "<unknown>";
     }
 
   return retval;
 }
 
 std::string
+octave_value::binary_op_fcn_name (binary_op op)
+{
+  std::string retval;
+
+  switch (op)
+    {
+    case op_add:
+      retval = "plus";
+      break;
+
+    case op_sub:
+      retval = "minus";
+      break;
+
+    case op_mul:
+      retval = "mtimes";
+      break;
+
+    case op_div:
+      retval = "mrdivide";
+      break;
+
+    case op_pow:
+      retval = "mpower";
+      break;
+
+    case op_ldiv:
+      retval = "mldivide";
+      break;
+
+    case op_lt:
+      retval = "lt";
+      break;
+
+    case op_le:
+      retval = "le";
+      break;
+
+    case op_eq:
+      retval = "eq";
+      break;
+
+    case op_ge:
+      retval = "ge";
+      break;
+
+    case op_gt:
+      retval = "gt";
+      break;
+
+    case op_ne:
+      retval = "ne";
+      break;
+
+    case op_el_mul:
+      retval = "times";
+      break;
+
+    case op_el_div:
+      retval = "rdivide";
+      break;
+
+    case op_el_pow:
+      retval = "power";
+      break;
+
+    case op_el_ldiv:
+      retval = "ldivide";
+      break;
+
+    case op_el_and:
+      retval = "and";
+      break;
+
+    case op_el_or:
+      retval = "or";
+      break;
+
+    default:
+      break;
+    }
+
+  return retval;
+}
+
+std::string
 octave_value::assign_op_as_string (assign_op op)
 {
   std::string retval;
 
   switch (op)
     {
     case op_asn_eq:
       retval = "=";
@@ -714,16 +836,21 @@ octave_value::octave_value (const Range&
   maybe_mutate ();
 }
 
 octave_value::octave_value (const Octave_map& m)
   : rep (new octave_struct (m))
 {
 }
 
+octave_value::octave_value (const Octave_map& m, const std::string& id)
+  : rep (new octave_class (m, id))
+{
+}
+
 octave_value::octave_value (const streamoff_array& off)
   : rep (new octave_streamoff (off))
 {
 }
 
 octave_value::octave_value (const octave_value_list& l, bool is_csl)
   : rep (is_csl
 	 ? dynamic_cast<octave_base_value *> (new octave_cs_list (l))
@@ -736,16 +863,22 @@ octave_value::octave_value (octave_value
 {
 }
 
 octave_value::octave_value (octave_base_value *new_rep)
   : rep (new_rep)
 {
 }
 
+octave_value::octave_value (octave_base_value *new_rep, int xcount)
+  : rep (new_rep)
+{
+  rep->count = xcount;
+}
+
 octave_base_value *
 octave_value::clone (void) const
 {
   panic_impossible ();
   return 0;
 }
 
 void
@@ -881,17 +1014,17 @@ octave_value::assign (assign_op op, cons
 
 	  if (! error_state)
 	    t_rhs = do_binary_op (binop, t, rhs);
 	}
     }
 
   if (! error_state)
     {
-      if (type[0] == '.' && ! is_map ())
+      if (type[0] == '.' && ! (is_map () || is_object ()))
 	{
 	  octave_value tmp = Octave_map ();
 	  retval = tmp.subsasgn (type, idx, t_rhs);
 	}
       else
 	retval = subsasgn (type, idx, t_rhs);
     }
 
@@ -1364,78 +1497,96 @@ octave_value
 do_binary_op (octave_value::binary_op op,
 	      const octave_value& v1, const octave_value& v2)
 {
   octave_value retval;
 
   int t1 = v1.type_id ();
   int t2 = v2.type_id ();
 
-  octave_value_typeinfo::binary_op_fcn f
-    = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
+  if (t1 == octave_class::static_type_id ()
+      || t2 == octave_class::static_type_id ())
+    {
+      octave_value_typeinfo::binary_class_op_fcn f
+	= octave_value_typeinfo::lookup_binary_class_op (op);
 
-  if (f)
-    retval = f (*v1.rep, *v2.rep);
+      if (f)
+	retval = f (v1, v2);
+      else
+	gripe_binary_op (octave_value::binary_op_as_string (op),
+			 v1.class_name (), v2.class_name ());
+    }
   else
     {
-      octave_value tv1;
-      octave_base_value::type_conv_fcn cf1 = v1.numeric_conversion_function ();
+      // FIXME -- we need to handle overloading operators for built-in
+      // classes (double, char, int8, etc.)
 
-      if (cf1)
+      octave_value_typeinfo::binary_op_fcn f
+	= octave_value_typeinfo::lookup_binary_op (op, t1, t2);
+
+      if (f)
+	retval = f (*v1.rep, *v2.rep);
+      else
 	{
-	  octave_base_value *tmp = cf1 (*v1.rep);
+	  octave_value tv1;
+	  octave_base_value::type_conv_fcn cf1 = v1.numeric_conversion_function ();
+
+	  if (cf1)
+	    {
+	      octave_base_value *tmp = cf1 (*v1.rep);
 
-	  if (tmp)
-	    {
-	      tv1 = octave_value (tmp);
-	      t1 = tv1.type_id ();
+	      if (tmp)
+		{
+		  tv1 = octave_value (tmp);
+		  t1 = tv1.type_id ();
+		}
+	      else
+		{
+		  gripe_binary_op_conv (octave_value::binary_op_as_string (op));
+		  return retval;
+		}
 	    }
 	  else
+	    tv1 = v1;
+
+	  octave_value tv2;
+	  octave_base_value::type_conv_fcn cf2 = v2.numeric_conversion_function ();
+
+	  if (cf2)
 	    {
-	      gripe_binary_op_conv (octave_value::binary_op_as_string (op));
-	      return retval;
-	    }
-	}
-      else
-	tv1 = v1;
+	      octave_base_value *tmp = cf2 (*v2.rep);
 
-      octave_value tv2;
-      octave_base_value::type_conv_fcn cf2 = v2.numeric_conversion_function ();
-
-      if (cf2)
-	{
-	  octave_base_value *tmp = cf2 (*v2.rep);
-
-	  if (tmp)
-	    {
-	      tv2 = octave_value (tmp);
-	      t2 = tv2.type_id ();
+	      if (tmp)
+		{
+		  tv2 = octave_value (tmp);
+		  t2 = tv2.type_id ();
+		}
+	      else
+		{
+		  gripe_binary_op_conv (octave_value::binary_op_as_string (op));
+		  return retval;
+		}
 	    }
 	  else
+	    tv2 = v2;
+
+	  if (cf1 || cf2)
 	    {
-	      gripe_binary_op_conv (octave_value::binary_op_as_string (op));
-	      return retval;
+	      f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
+
+	      if (f)
+		retval = f (*tv1.rep, *tv2.rep);
+	      else
+		gripe_binary_op (octave_value::binary_op_as_string (op),
+				 v1.type_name (), v2.type_name ());
 	    }
-	}
-      else
-	tv2 = v2;
-
-      if (cf1 || cf2)
-	{
-	  f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
-
-	  if (f)
-	    retval = f (*tv1.rep, *tv2.rep);
 	  else
 	    gripe_binary_op (octave_value::binary_op_as_string (op),
 			     v1.type_name (), v2.type_name ());
 	}
-      else
-	gripe_binary_op (octave_value::binary_op_as_string (op),
-			 v1.type_name (), v2.type_name ());
     }
 
   return retval;
 }
 
 static void
 gripe_cat_op (const std::string& tn1, const std::string& tn2)
 {
@@ -1555,49 +1706,67 @@ gripe_unary_op_conv (const std::string& 
 
 octave_value
 do_unary_op (octave_value::unary_op op, const octave_value& v)
 {
   octave_value retval;
 
   int t = v.type_id ();
 
-  octave_value_typeinfo::unary_op_fcn f
-    = octave_value_typeinfo::lookup_unary_op (op, t);
+  if (t == octave_class::static_type_id ())
+    {
+      octave_value_typeinfo::unary_class_op_fcn f
+	= octave_value_typeinfo::lookup_unary_class_op (op);
 
-  if (f)
-    retval = f (*v.rep);
+      if (f)
+	retval = f (v);
+      else
+	gripe_unary_op (octave_value::unary_op_as_string (op),
+			v.class_name ());
+    }
   else
     {
-      octave_value tv;
-      octave_base_value::type_conv_fcn cf = v.numeric_conversion_function ();
+      // FIXME -- we need to handle overloading operators for built-in
+      // classes (double, char, int8, etc.)
+
+      octave_value_typeinfo::unary_op_fcn f
+	= octave_value_typeinfo::lookup_unary_op (op, t);
 
-      if (cf)
+      if (f)
+	retval = f (*v.rep);
+      else
 	{
-	  octave_base_value *tmp = cf (*v.rep);
+	  octave_value tv;
+	  octave_base_value::type_conv_fcn cf
+	    = v.numeric_conversion_function ();
 
-	  if (tmp)
+	  if (cf)
 	    {
-	      tv = octave_value (tmp);
-	      t = tv.type_id ();
+	      octave_base_value *tmp = cf (*v.rep);
 
-	      f = octave_value_typeinfo::lookup_unary_op (op, t);
+	      if (tmp)
+		{
+		  tv = octave_value (tmp);
+		  t = tv.type_id ();
+
+		  f = octave_value_typeinfo::lookup_unary_op (op, t);
 
-	      if (f)
-		retval = f (*tv.rep);
+		  if (f)
+		    retval = f (*tv.rep);
+		  else
+		    gripe_unary_op (octave_value::unary_op_as_string (op),
+				    v.type_name ());
+		}
 	      else
-		gripe_unary_op (octave_value::unary_op_as_string (op),
-				v.type_name ());
+		gripe_unary_op_conv (octave_value::unary_op_as_string (op));
 	    }
 	  else
-	    gripe_unary_op_conv (octave_value::unary_op_as_string (op));
+	    gripe_unary_op (octave_value::unary_op_as_string (op),
+			    v.type_name ());
 	}
-      else
-	gripe_unary_op (octave_value::unary_op_as_string (op),
-			v.type_name ());
     }
 
   return retval;
 }
 
 static void
 gripe_unary_op_conversion_failed (const std::string& op,
 				  const std::string& tn)
@@ -1877,16 +2046,17 @@ install_types (void)
   octave_uint8_matrix::register_type ();
   octave_uint16_matrix::register_type ();
   octave_uint32_matrix::register_type ();
   octave_uint64_matrix::register_type ();
   octave_sparse_bool_matrix::register_type ();
   octave_sparse_matrix::register_type ();
   octave_sparse_complex_matrix::register_type ();
   octave_struct::register_type ();
+  octave_class::register_type ();
   octave_list::register_type ();
   octave_cs_list::register_type ();
   octave_magic_colon::register_type ();
   octave_builtin::register_type ();
   octave_mapper::register_type ();
   octave_user_function::register_type ();
   octave_dld_function::register_type ();
   octave_fcn_handle::register_type ();
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -125,18 +125,20 @@ public:
     op_el_pow_eq,
     op_el_and_eq,
     op_el_or_eq,
     num_assign_ops,
     unknown_assign_op
   };
 
   static std::string unary_op_as_string (unary_op);
+  static std::string unary_op_fcn_name (unary_op);
 
   static std::string binary_op_as_string (binary_op);
+  static std::string binary_op_fcn_name (binary_op);
 
   static std::string assign_op_as_string (assign_op);
 
   static octave_value empty_conv (const std::string& type,
 				  const octave_value& rhs = octave_value ());
 
   enum magic_colon { magic_colon_t };
 
@@ -220,21 +222,23 @@ public:
   octave_value (const ArrayN<octave_uint16>& inda);
   octave_value (const uint32NDArray& inda);
   octave_value (const ArrayN<octave_uint32>& inda);
   octave_value (const uint64NDArray& inda);
   octave_value (const ArrayN<octave_uint64>& inda);
   octave_value (double base, double limit, double inc);
   octave_value (const Range& r);
   octave_value (const Octave_map& m);
+  octave_value (const Octave_map& m, const std::string& id);
   octave_value (const streamoff_array& off);
   octave_value (const octave_value_list& m, bool is_cs_list = false);
   octave_value (octave_value::magic_colon);
 
   octave_value (octave_base_value *new_rep);
+  octave_value (octave_base_value *new_rep, int xcount);
 
   // Copy constructor.
 
   octave_value (const octave_value& a)
     {
       rep = a.rep;
       rep->count++;
     }
@@ -437,16 +441,19 @@ public:
     { return rep->is_string () && ! rep->is_sq_string (); }
 
   bool is_range (void) const
     { return rep->is_range (); }
 
   bool is_map (void) const
     { return rep->is_map (); }
 
+  bool is_object (void) const
+    { return rep->is_object (); }
+
   bool is_streamoff (void) const
     { return rep->is_streamoff (); }
 
   bool is_cs_list (void) const
     { return rep->is_cs_list (); }
 
   bool is_list (void) const
     { return rep->is_list (); }
@@ -545,16 +552,22 @@ public:
     { return rep->is_function_handle (); }
 
   bool is_inline_function (void) const
     { return rep->is_inline_function (); }
 
   bool is_function (void) const
     { return rep->is_function (); }
 
+  bool is_user_script (void) const
+    { return rep->is_user_script (); }
+
+  bool is_user_function (void) const
+    { return rep->is_user_function (); }
+
   bool is_builtin_function (void) const
     { return rep->is_builtin_function (); }
 
   bool is_dld_function (void) const
     { return rep->is_dld_function (); }
 
   bool is_mex_function (void) const
     { return rep->is_mex_function (); }
diff --git a/src/parse.h b/src/parse.h
--- a/src/parse.h
+++ b/src/parse.h
@@ -33,24 +33,19 @@ along with Octave; see the file COPYING.
 extern void reset_parser (void);
 extern int octave_lex (void);
 extern int octave_parse (void);
 
 class tree;
 class tree_matrix;
 class tree_identifier;
 class octave_function;
-class symbol_record;
-class symbol_table;
 
 #include "oct-obj.h"
 
-// Temporary symbol table pointer used to cope with bogus function syntax.
-extern symbol_table *tmp_local_sym_tab;
-
 // Nonzero means print parser debugging info (-d).
 extern int octave_debug;
 
 // The current input line number.
 extern int input_line_number;
 
 // The column of the current token.
 extern int current_input_column;
@@ -68,22 +63,26 @@ extern bool reading_startup_message_prin
 extern bool input_from_startup_file;
 
 // TRUE means that we are in the process of evaluating a function
 // body.  The parser might be called in that case if we are looking at
 // an eval() statement.
 extern bool evaluating_function_body;
 
 // Keep track of symbol table information when parsing functions.
-extern std::stack<symbol_table*> symtab_context;
+extern std::stack<symbol_table::scope_id> symtab_context;
 
 // Name of parent function when parsing function files that might
 // contain nested functions.
 extern std::string parent_function_name;
 
+// Name of the current class when we are parsing class methods or
+// constructors.
+extern std::string current_class_name;
+
 // Keep a count of how many END tokens we expect.
 extern int end_tokens_expected;
 
 extern OCTINTERP_API void
 parse_and_execute (FILE *f);
 
 extern OCTINTERP_API void
 parse_and_execute (const std::string& s, bool verbose = false,
@@ -97,21 +96,22 @@ extern OCTINTERP_API std::string
 get_help_from_file (const std::string& nm, bool& symbol_found);
 
 extern OCTINTERP_API std::string lookup_autoload (const std::string& nm);
 
 extern OCTINTERP_API string_vector autoloaded_functions (void);
 
 extern OCTINTERP_API string_vector reverse_lookup_autoload (const std::string& nm);
 
-extern OCTINTERP_API bool
-load_fcn_from_file (const std::string& nm, bool exec_script);
-
-extern OCTINTERP_API bool
-load_fcn_from_file (symbol_record *sym_rec, bool exec_script);
+extern OCTINTERP_API octave_function *
+load_fcn_from_file (const std::string& file_name,
+		    const std::string& dir_name = std::string (),
+		    const std::string& dispatch_type = std::string (),
+		    const std::string& fcn_name = std::string (),
+		    bool autoload = false);
 
 extern OCTINTERP_API void
 source_file (const std::string& file_name,
 	     const std::string& context = std::string ());
 
 extern OCTINTERP_API octave_value_list
 feval (const std::string& name,
        const octave_value_list& args = octave_value_list (),
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -70,19 +70,16 @@ along with Octave; see the file COPYING.
 #include "parse.h"
 #include "pt-all.h"
 #include "symtab.h"
 #include "token.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
-// Temporary symbol table pointer used to cope with bogus function syntax.
-symbol_table *tmp_local_sym_tab = 0;
-
 // The current input line number.
 int input_line_number = 0;
 
 // The column of the current token.
 int current_input_column = 1;
 
 // Buffer for help text snagged from function files.
 std::stack<std::string> help_buf;
@@ -104,29 +101,37 @@ bool input_from_startup_file = false;
 // body.  The parser might be called in that case if we are looking at
 // an eval() statement.
 bool evaluating_function_body = false;
 
 // Keep a count of how many END tokens we expect.
 int end_tokens_expected = 0;
 
 // Keep track of symbol table information when parsing functions.
-std::stack<symbol_table*> symtab_context;
+std::stack<symbol_table::scope_id> symtab_context;
 
 // Name of parent function when parsing function files that might
 // contain nested functions.
 std::string parent_function_name;
 
+// Name of the current class when we are parsing class methods or
+// constructors.
+std::string current_class_name;
+
 // TRUE means we are in the process of autoloading a function.
 static bool autoloading = false;
 
 // TRUE means the current function file was found in a relative path
 // element.
 static bool fcn_file_from_relative_lookup = false;
 
+// If nonzero, this is a pointer to the function we just finished
+// parsing.
+static octave_function *curr_fcn_ptr = 0;
+
 // List of autoloads (function -> file mapping).
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
 // Generic error messages.
 static void
@@ -258,22 +263,17 @@ make_assign_op (int op, tree_argument_li
 static octave_user_function *
 start_function (tree_parameter_list *param_list, tree_statement_list *body);
 
 // Do most of the work for defining a function.
 static octave_user_function *
 frob_function (const std::string& fname, octave_user_function *fcn);
 
 // Finish defining a function.
-static octave_user_function *
-finish_function (tree_identifier *id, octave_user_function *fcn,
-		 octave_comment_list *lc);
-
-// Finish defining a function a different way.
-static octave_user_function *
+static void
 finish_function (tree_parameter_list *ret_list,
 		 octave_user_function *fcn, octave_comment_list *lc);
 
 // Reset state after parsing function.
 static void
 recover_from_parsing_function (void);
 
 // Make an index expression.
@@ -311,17 +311,17 @@ set_stmt_print_flag (tree_statement_list
 
 #define ABORT_PARSE \
   do \
     { \
       global_command = 0; \
       yyerrok; \
       if (! symtab_context.empty ()) \
         { \
-	  curr_sym_tab = symtab_context.top (); \
+	  symbol_table::set_scope (symtab_context.top ()); \
 	  symtab_context.pop (); \
         } \
       if (interactive || forced_interactive) \
 	YYACCEPT; \
       else \
 	YYABORT; \
     } \
   while (0)
@@ -410,17 +410,17 @@ set_stmt_print_flag (tree_statement_list
 %type <tree_anon_fcn_handle_type> anon_fcn_handle
 %type <tree_fcn_handle_type> fcn_handle
 %type <tree_matrix_type> matrix_rows matrix_rows1
 %type <tree_cell_type> cell_rows cell_rows1
 %type <tree_expression_type> matrix cell
 %type <tree_expression_type> primary_expr postfix_expr prefix_expr binary_expr
 %type <tree_expression_type> simple_expr colon_expr assign_expr expression
 %type <tree_identifier_type> identifier fcn_name
-%type <octave_user_function_type> function1 function2 function3
+%type <octave_user_function_type> function1 function2
 %type <tree_index_expression_type> word_list_cmd
 %type <tree_colon_expression_type> colon_expr1
 %type <tree_argument_list_type> arg_list word_list assign_lhs
 %type <tree_argument_list_type> cell_or_matrix_row
 %type <tree_parameter_list_type> param_list param_list1 param_list2
 %type <tree_parameter_list_type> return_list return_list1
 %type <tree_command_type> command select_command loop_command
 %type <tree_command_type> jump_command except_command function
@@ -430,17 +430,17 @@ set_stmt_print_flag (tree_statement_list
 %type <tree_switch_command_type> switch_command
 %type <tree_switch_case_type> switch_case default_case
 %type <tree_switch_case_list_type> case_list1 case_list
 %type <tree_decl_elt_type> decl2
 %type <tree_decl_init_list_type> decl1
 %type <tree_decl_command_type> declaration
 %type <tree_statement_type> statement
 %type <tree_statement_list_type> simple_list simple_list1 list list1
-%type <tree_statement_list_type> opt_list input1 function4
+%type <tree_statement_list_type> opt_list input1
 
 // Precedence and associativity.
 %left ';' ',' '\n'
 %right '=' ADD_EQ SUB_EQ MUL_EQ DIV_EQ LEFTDIV_EQ POW_EQ EMUL_EQ EDIV_EQ ELEFTDIV_EQ EPOW_EQ OR_EQ AND_EQ LSHIFT_EQ RSHIFT_EQ
 %left EXPR_OR_OR
 %left EXPR_AND_AND
 %left EXPR_OR
 %left EXPR_AND
@@ -549,18 +549,18 @@ statement	: expression
 		;
 
 // ===========
 // Expressions
 // ===========
 
 identifier	: NAME
 		  {
-		    $$ = new tree_identifier
-		      ($1->sym_rec (), $1->line (), $1->column ());
+		    symbol_table::symbol_record *sr = $1->sym_rec ();
+		    $$ = new tree_identifier (*sr, $1->line (), $1->column ());
 		  }
 		;
 
 string		: DQ_STRING
 		  { $$ = make_constant (DQ_STRING, $1); }
 		| SQ_STRING
 		  { $$ = make_constant (SQ_STRING, $1); }
 		;
@@ -1093,44 +1093,38 @@ except_command	: UNWIND stash_comment op
 		      ABORT_PARSE;
 		  }
 		;
 
 // ===========================================
 // Some `subroutines' for function definitions
 // ===========================================
 
-save_symtab	: // empty
-		  { symtab_context.push (curr_sym_tab); }
-		;
-		   
-function_symtab	: // empty
-		  { curr_sym_tab = fbi_sym_tab; }
-		;
-
-local_symtab	: // empty
-		  { curr_sym_tab = tmp_local_sym_tab; }
+push_fcn_symtab	: // empty
+		  {
+		    symtab_context.push (symbol_table::current_scope ());
+		    symbol_table::set_scope (symbol_table::alloc_scope ());
+
+		    if (! lexer_flags.parsing_nested_function)
+		      symbol_table::set_parent_scope (symbol_table::current_scope ());
+		  }
 		;
 
 // ===========================
 // List of function parameters
 // ===========================
 
 param_list_beg	: '('
 		  {
 		    lexer_flags.looking_at_parameter_list = true;
 
 		    if (lexer_flags.looking_at_function_handle)
 		      {
-		        symtab_context.push (curr_sym_tab);
-
-			tmp_local_sym_tab = new symbol_table ();
-
-			curr_sym_tab = tmp_local_sym_tab;
-
+		        symtab_context.push (symbol_table::current_scope ());
+			symbol_table::set_scope (symbol_table::alloc_scope ());
 			lexer_flags.looking_at_function_handle--;
 		      }
 		  }
 		;
 
 param_list_end	: ')'
 		  { lexer_flags.looking_at_parameter_list = false; }
 		;
@@ -1177,129 +1171,114 @@ param_list2	: decl2
 		    $$ = $1;
 		  }
 		;
 
 // ===================================
 // List of function return value names
 // ===================================
 
-return_list_beg	: '[' local_symtab
-		;
-
-return_list	: return_list_beg return_list_end
+return_list	: '[' ']'
 		  {
 		    lexer_flags.looking_at_return_list = false;
 		    $$ = new tree_parameter_list ();
 		  }
-		| return_list_beg VARARGOUT return_list_end
+		| '[' VARARGOUT ']'
 		  {
 		    lexer_flags.looking_at_return_list = false;
 		    tree_parameter_list *tmp = new tree_parameter_list ();
 		    tmp->mark_varargs_only ();
 		    $$ = tmp;
 		  }
 		| VARARGOUT
 		  {
 		    lexer_flags.looking_at_return_list = false;
 		    tree_parameter_list *tmp = new tree_parameter_list ();
 		    tmp->mark_varargs_only ();
 		    $$ = tmp;
 		  }
-		| return_list_beg return_list1 return_list_end
+		| return_list1
+		  {
+		    lexer_flags.looking_at_return_list = false;
+		    $$ = $1;
+		  }
+		| '[' return_list1 ']'
 		  {
 		    lexer_flags.looking_at_return_list = false;
 		    $$ = $2;
 		  }
-		| return_list_beg return_list1 ',' VARARGOUT return_list_end
+		| '[' return_list1 ',' VARARGOUT ']'
 		  {
 		    lexer_flags.looking_at_return_list = false;
 		    $2->mark_varargs ();
 		    $$ = $2;
 		  }
 		;
 
 return_list1	: identifier
 		  { $$ = new tree_parameter_list (new tree_decl_elt ($1)); }
 		| return_list1 ',' identifier
 		  {
 		    $1->append (new tree_decl_elt ($3));
 		    $$ = $1;
 		  }
 		;
 
-return_list_end	: function_symtab ']'
-		;
-
 // ===================
 // Function definition
 // ===================
 
-function_beg	: save_symtab FCN function_symtab stash_comment
-		  { $$ = $4; }
+function_beg	: push_fcn_symtab FCN stash_comment
+		  { $$ = $3; }
 		;
 
-function	: function_beg function2
+function	: function_beg function1
 		  {
 		    $2->stash_leading_comment ($1);
 		    recover_from_parsing_function ();
 		    $$ = 0;
 		  }
-		| function_beg identifier function1
+		| function_beg return_list '=' function1
 		  {
-		    finish_function ($2, $3, $1);
-		    recover_from_parsing_function ();
-		    $$ = 0;
-		  }
-		| function_beg return_list function1
-		  {
-		    finish_function ($2, $3, $1);
+		    finish_function ($2, $4, $1);
 		    recover_from_parsing_function ();
 		    $$ = 0;
 		  }
 		;
 
-function1	: function_symtab '=' function2
-		  { $$ = $3; }
-		;
-
-fcn_name	: identifier local_symtab
+fcn_name	: identifier
 		  {
 		    std::string id_name = $1->name ();
 
 		    if (reading_fcn_file
 		        && ! lexer_flags.parsing_nested_function)
 		      parent_function_name = (curr_fcn_file_name == id_name)
 			? id_name : curr_fcn_file_name;
 
 		    lexer_flags.parsed_function_name = true;
 
 		    $$ = $1;
 		  }
 		;
 
-function2	: fcn_name function3
+function1	: fcn_name function2
 		  {
 		    std::string fname = $1->name ();
 
 		    delete $1;
 
 		    if (! ($$ = frob_function (fname, $2)))
 		      ABORT_PARSE;
 		  }
 		;
 
-function3	: param_list function4
-		  { $$ = start_function ($1, $2); }
-		| function4
-		  { $$ = start_function (0, $1); }
-		;
-
-function4	: opt_sep opt_list function_end
-		  { $$ = $2; }
+function2	: param_list opt_sep opt_list function_end
+		  { $$ = start_function ($1, $3); }
+		| opt_sep opt_list function_end
+		  { $$ = start_function (0, $2); }
 		;
 
 function_end	: END
 		  {
 		    if (! end_token_ok ($1, token::function_end))
 		      ABORT_PARSE;
 		  }
 		| END_OF_INPUT
@@ -1767,34 +1746,55 @@ make_anon_fcn_handle (tree_parameter_lis
 {
   // FIXME -- need to get these from the location of the @ symbol.
 
   int l = -1;
   int c = -1;
 
   tree_parameter_list *ret_list = 0;
 
-  symbol_table *fcn_sym_tab = curr_sym_tab;
+  symbol_table::scope_id fcn_scope = symbol_table::current_scope ();
 
   if (symtab_context.empty ())
     panic_impossible ();
 
-  curr_sym_tab = symtab_context.top ();
+  symbol_table::set_scope (symtab_context.top ());
 
   symtab_context.pop ();
 
   if (stmt && stmt->is_expression ())
-    stmt->set_print_flag (false);
+    {
+      symbol_table::symbol_record& sr = symbol_table::insert ("__retval__");
+
+      tree_expression *e = stmt->expression ();
+
+      tree_identifier *id = new tree_identifier (sr);
+
+      tree_simple_assignment *asn = new tree_simple_assignment (id, e);
+
+      stmt->set_expression (asn);
+
+      stmt->set_print_flag (false);
+
+      // FIXME -- would like to delete old_stmt here or
+      // replace expression inside it with the new expression we just
+      // created so we don't have to create a new statement at all.
+
+      id = new tree_identifier (sr);
+      tree_decl_elt *elt = new tree_decl_elt (id);
+
+      ret_list = new tree_parameter_list (elt);
+    }
 
   tree_statement_list *body = new tree_statement_list (stmt);
 
   body->mark_as_function_body ();
 
   tree_anon_fcn_handle *retval
-    = new tree_anon_fcn_handle (param_list, ret_list, body, fcn_sym_tab, l, c);
+    = new tree_anon_fcn_handle (param_list, ret_list, body, fcn_scope, l, c);
 
   return retval;
 }
 
 static void
 maybe_warn_associativity_change (tree_expression *op)
 {
   if (op->paren_count () == 0 && op->is_binary_expression ())
@@ -2418,17 +2418,19 @@ make_assign_op (int op, tree_argument_li
 static octave_user_function *
 start_function (tree_parameter_list *param_list, tree_statement_list *body)
 {
   body->mark_as_function_body ();
 
   // We'll fill in the return list later.
 
   octave_user_function *fcn
-    = new octave_user_function (param_list, 0, body, curr_sym_tab);
+    = new octave_user_function (symbol_table::current_scope (),
+				param_list, 0, body);
+				
 
   if (fcn)
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       fcn->stash_trailing_comment (tc);
     }
 
@@ -2444,39 +2446,64 @@ frob_function (const std::string& fname,
 
   // If input is coming from a file, issue a warning if the name of
   // the file does not match the name of the function stated in the
   // file.  Matlab doesn't provide a diagnostic (it ignores the stated
   // name).
 
   if (reading_fcn_file || autoloading)
     {
-      if (! (lexer_flags.parsing_nested_function || autoloading)
-          && curr_fcn_file_name != id_name)
+      if (! (autoloading
+	     || lexer_flags.parsing_nested_function
+	     || lexer_flags.parsing_class_method))
 	{
-	  warning_with_id
-	    ("Octave:function-name-clash",
-	     "function name `%s' does not agree with function file name `%s'",
-	     id_name.c_str (), curr_fcn_file_full_name.c_str ());
-
-	  id_name = curr_fcn_file_name;
+	  // FIXME -- should curr_fcn_file_name already be
+	  // preprocessed when we get here?  It seems to only be a
+	  // problem with relative file names.
+
+	  std::string nm = curr_fcn_file_name;
+
+	  size_t pos = nm.find_last_of (file_ops::dir_sep_chars);
+
+	  if (pos != NPOS)
+	    nm = curr_fcn_file_name.substr (pos+1);
+
+	  if (nm != id_name)
+	    {
+	      warning_with_id
+		("Octave:function-name-clash",
+		 "function name `%s' does not agree with function file name `%s'",
+		 id_name.c_str (), curr_fcn_file_full_name.c_str ());
+
+	      id_name = nm;
+	    }
 	}
 
       octave_time now;
 
       fcn->stash_fcn_file_name (curr_fcn_file_full_name);
       fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
 
       if (fcn_file_from_relative_lookup)
 	fcn->mark_relative ();
 
       if (lexer_flags.parsing_nested_function)
         fcn->stash_parent_fcn_name (parent_function_name);
 
+      if (lexer_flags.parsing_class_method)
+	{
+	  if (current_class_name == id_name)
+	    fcn->mark_as_class_constructor ();
+	  else
+	    fcn->mark_as_class_method ();
+
+	  fcn->stash_dispatch_class (current_class_name);
+	}
+
       std::string nm = fcn->fcn_file_name ();
 
       file_stat fs (nm);
 
       if (fs && fs.is_newer (now))
         warning_with_id ("Octave:future-time-stamp",
 			 "time stamp for `%s' is in the future", nm.c_str ());
     }
@@ -2485,132 +2512,74 @@ frob_function (const std::string& fname,
 	   && curr_fcn_file_name == id_name)
     {
       warning ("function `%s' defined within script file `%s'",
 	       id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
 
-  // Enter the new function in fbi_sym_tab.  If there is already a
-  // variable of the same name in the current symbol table, we won't
-  // find the new function when we try to call it, so we need to clear
-  // the old symbol from the current symbol table.  Note that this
-  // means that for things like
-  //
-  //   function f () eval ("function g () 1, end"); end
-  //   g = 13;
-  //   f ();
-  //   g
-  //
-  // G will still refer to the variable G (with value 13) rather
-  // than the function G, until the variable G is cleared.
-
-  curr_sym_tab->clear (id_name);
-
-  if (! lexer_flags.parsing_nested_function
-      && symtab_context.top () == top_level_sym_tab)
+  if (! help_buf.empty ())
+    {
+      fcn->document (help_buf.top ());
+
+      help_buf.pop ();
+    }
+
+  if (lexer_flags.parsing_nested_function)
     {
-      symbol_record *sr = top_level_sym_tab->lookup (id_name);
-
-      // Only clear the existing name if it is already defined as a
-      // function.  If there is already a variable defined with the
-      // same name as a the current function, it will continue to
-      // shadow this name until the variable is cleared.  This means
-      // that for something like the following at the command line,
-      //
-      //   f = 13;
-      //   function f () 7, end
-      //   f
-      //
-      // F will still refer to the variable F (with value 13) rather
-      // than the function F, until the variable F is cleared.
-
-      if (sr && sr->is_function ())
-	top_level_sym_tab->clear (id_name);
-    }
-
-  symbol_record *sr = fbi_sym_tab->lookup (id_name, true);
-
-  if (sr)
-    {
-      fcn->stash_symtab_ptr (sr);
-
-      if (lexer_flags.parsing_nested_function)
-        {
-          fcn->mark_as_nested_function ();
-	  sr->hide ();
+      std::string nm = fcn->name ();
+
+      fcn->mark_as_nested_function ();
+
+      symbol_table::install_subfunction (nm, octave_value (fcn));
+
+      if (lexer_flags.parsing_nested_function < 0)
+	{
+	  lexer_flags.parsing_nested_function = 0;
+	  symbol_table::reset_parent_scope ();
 	}
     }
-  else
-    panic_impossible ();
-
-  sr->define (fcn, symbol_record::USER_FUNCTION);
-
-  if (! help_buf.empty ())
+  else if (! reading_fcn_file)
     {
-      sr->document (help_buf.top ());
-      help_buf.pop ();
+      std::string nm = fcn->name ();
+
+      symbol_table::install_cmdline_function (nm, octave_value (fcn));
+
+      // Make sure that any variable with the same name as the new
+      // function is cleared.
+
+      symbol_table::varref (nm) = octave_value ();
     }
-
-  // Also insert the full name in the symbol table.  This way, we can
-  // properly cope with changes to LOADPATH.
-
-  if (reading_fcn_file)
-    {
-      symbol_record *full_sr
-        = fbi_sym_tab->lookup (curr_fcn_file_full_name, true);
-
-      full_sr->alias (sr, true);
-      full_sr->hide ();
-    }
-
-  if (lexer_flags.parsing_nested_function < 0)
-    lexer_flags.parsing_nested_function = 0;
+  else
+    curr_fcn_ptr = fcn;
 
   return fcn;
 }
 
 // Finish defining a function.
 
-static octave_user_function *
-finish_function (tree_identifier *id, octave_user_function *fcn,
-		 octave_comment_list *lc)
-{
-  tree_decl_elt *tmp = new tree_decl_elt (id);
-
-  tree_parameter_list *tpl = new tree_parameter_list (tmp);
-
-  tpl->mark_as_formal_parameters ();
-
-  fcn->stash_leading_comment (lc);
-
-  return fcn->define_ret_list (tpl);
-}
-
-// Finish defining a function a different way.
-
-static octave_user_function *
+static void
 finish_function (tree_parameter_list *ret_list,
 		 octave_user_function *fcn, octave_comment_list *lc)
 {
   ret_list->mark_as_formal_parameters ();
 
   fcn->stash_leading_comment (lc);
 
-  return fcn->define_ret_list (ret_list);
+  fcn->define_ret_list (ret_list);
 }
 
 static void
 recover_from_parsing_function (void)
 {
   if (symtab_context.empty ())
     panic_impossible ();
 
-  curr_sym_tab = symtab_context.top ();
+  symbol_table::set_scope (symtab_context.top ());
   symtab_context.pop ();
 
   lexer_flags.defining_func = false;
   lexer_flags.beginning_of_function = false;
   lexer_flags.parsed_function_name = false;
   lexer_flags.looking_at_return_list = false;
   lexer_flags.looking_at_parameter_list = false;
 }
@@ -2843,18 +2812,16 @@ parse_and_execute (FILE *f)
   unwind_protect_bool (line_editing);
   unwind_protect_bool (get_input_from_eval_string);
   unwind_protect_bool (parser_end_of_input);
 
   line_editing = false;
   get_input_from_eval_string = false;
   parser_end_of_input = false;
 
-  unwind_protect_ptr (curr_sym_tab);
-
   int retval;
   do
     {
       reset_parser ();
 
       retval = yyparse ();
 
       if (retval == 0)
@@ -3200,35 +3167,54 @@ is_function_file (FILE *ffile)
       && ! (isalnum (buf[8]) || buf[8] == '_'))
     status = 1;
 
   fseek (ffile, pos, SEEK_SET);
 
   return status;
 }
 
+static int
+is_function_file (const std::string& fname)
+{
+  int retval = 0;
+
+  FILE *fid = fopen (fname.c_str (), "r");
+
+  if (fid)
+    {
+      retval = is_function_file (fid);
+
+      fclose (fid);
+    }
+
+  return retval;
+}
+
 static void
 restore_command_history (void *)
 {
   command_history::ignore_entries (! Vsaving_history);
 }
 
 static void
 restore_input_stream (void *f)
 {
   command_editor::set_input_stream (static_cast<FILE *> (f));
 }
 
-static bool
-parse_fcn_file (const std::string& ff, bool exec_script,
-		bool force_script = false)
+typedef octave_function * octave_function_ptr;
+
+static octave_function *
+parse_fcn_file (const std::string& ff, const std::string& dispatch_type,
+		bool exec_script, bool force_script = false)
 {
   unwind_protect::begin_frame ("parse_fcn_file");
 
-  int script_file_executed = false;
+  octave_function *fcn_ptr = 0;
 
   // Open function file and parse.
 
   bool old_reading_fcn_file_state = reading_fcn_file;
 
   FILE *in_stream = command_editor::get_input_stream ();
 
   unwind_protect::add (restore_input_stream, in_stream);
@@ -3236,23 +3222,25 @@ parse_fcn_file (const std::string& ff, b
   unwind_protect_ptr (ff_instream);
 
   unwind_protect_int (input_line_number);
   unwind_protect_int (current_input_column);
   unwind_protect_int (end_tokens_expected);
   unwind_protect_bool (reading_fcn_file);
   unwind_protect_bool (line_editing);
   unwind_protect_str (parent_function_name);
+  unwind_protect_str (current_class_name);
 
   input_line_number = 0;
   current_input_column = 1;
   end_tokens_expected = 0;
   reading_fcn_file = true;
   line_editing = false;
   parent_function_name = "";
+  current_class_name = dispatch_type;
 
   FILE *ffile = get_input_from_file (ff, 0);
 
   unwind_protect::add (safe_fclose, ffile);
 
   if (ffile)
     {
       // Check to see if this file defines a function or is just a
@@ -3282,38 +3270,39 @@ parse_fcn_file (const std::string& ff, b
 	  YY_BUFFER_STATE old_buf = current_buffer ();
 	  YY_BUFFER_STATE new_buf = create_buffer (ffile);
 
 	  unwind_protect::add (restore_input_buffer, old_buf);
 	  unwind_protect::add (delete_input_buffer, new_buf);
 
 	  switch_to_buffer (new_buf);
 
-	  unwind_protect_ptr (curr_sym_tab);
+	  unwind_protect_ptr (curr_fcn_ptr);
+	  curr_fcn_ptr = 0;
 
 	  reset_parser ();
 
 	  std::string txt
 	    = gobble_leading_white_space (ffile, true, true, true, false);
 
 	  help_buf.push (txt);
 
 	  octave_comment_buffer::append (txt);
 
 	  // FIXME -- this should not be necessary.
 	  gobble_leading_white_space (ffile, false, true, false, false);
 
+	  lexer_flags.parsing_class_method = ! dispatch_type.empty ();
+
 	  int status = yyparse ();
 
+	  fcn_ptr = curr_fcn_ptr;
+
 	  if (status != 0)
-	    {
-	      error ("parse error while reading function file %s",
-		     ff.c_str ());
-	      fbi_sym_tab->clear (curr_fcn_file_name);
-	    }
+	    error ("parse error while reading function file %s", ff.c_str ());
 	}
       else if (exec_script)
 	{
 	  // The value of `reading_fcn_file' will be restored to the
 	  // proper value when we unwind from this frame.
 	  reading_fcn_file = old_reading_fcn_file_state;
 
 	  // FIXME -- we shouldn't need both the
@@ -3329,26 +3318,24 @@ parse_fcn_file (const std::string& ff, b
 	  Vsaving_history = false;
 	  reading_script_file = true;
 
 	  octave_user_script *script = new octave_user_script (ff, ff, "");
 	  octave_call_stack::push (script);
 	  unwind_protect::add (octave_call_stack::unwind_pop_script, 0);
 
 	  parse_and_execute (ffile);
-
-	  script_file_executed = true;
 	}
     }
   else
     error ("no such file, `%s'", ff.c_str ());
 
   unwind_protect::run_frame ("parse_fcn_file");
 
-  return script_file_executed;
+  return fcn_ptr;
 }
 
 std::string
 lookup_autoload (const std::string& nm)
 {
   std::string retval;
 
   typedef std::map<std::string, std::string>::const_iterator am_iter;
@@ -3382,107 +3369,93 @@ reverse_lookup_autoload (const std::stri
   typedef std::map<std::string, std::string>::const_iterator am_iter;
   for (am_iter p = autoload_map.begin (); p != autoload_map.end (); p++)
     if (nm == p->second)
       names.append (p->first);
 
   return names;
 }
 
-bool
-load_fcn_from_file (const std::string& nm_arg, bool exec_script)
+octave_function *
+load_fcn_from_file (const std::string& file_name, const std::string& dir_name,
+		    const std::string& dispatch_type,
+		    const std::string& fcn_name, bool autoload)
 {
+  octave_function *retval = 0;
+
   unwind_protect::begin_frame ("load_fcn_from_file");
 
-  bool script_file_executed = false;
-
-  std::string nm = nm_arg;
+  std::string nm = file_name;
 
   size_t nm_len = nm.length ();
 
   std::string file;
 
   unwind_protect_bool (fcn_file_from_relative_lookup);
 
   fcn_file_from_relative_lookup = false;
 
-  if (octave_env::absolute_pathname (nm)
-      && ((nm_len > 4 && nm.substr (nm_len-4) == ".oct")
-	  || (nm_len > 4 && nm.substr (nm_len-4) == ".mex")
-	  || (nm_len > 2 && nm.substr (nm_len-2) == ".m")))
+  file = nm;
+
+  if ((nm_len > 4 && nm.substr (nm_len-4) == ".oct")
+      || (nm_len > 4 && nm.substr (nm_len-4) == ".mex")
+      || (nm_len > 2 && nm.substr (nm_len-2) == ".m"))
     {
-      file = nm;
-
       nm = octave_env::base_pathname (file);
       nm = nm.substr (0, nm.find_last_of ('.'));
     }
-  else
+
+  if (autoload)
     {
-      file = lookup_autoload (nm);
-
-      if (! file.empty ())
-	{
-	  unwind_protect_bool (autoloading);
-
-	  autoloading = true;
-	  exec_script = true;
-	}
-      else
-        file = load_path::find_fcn (nm);
-
+      unwind_protect_bool (autoloading);
+      autoloading = true;
+    }
+
+  if (! file.empty ())
+    {
       fcn_file_from_relative_lookup = ! octave_env::absolute_pathname (file);
 
       file = octave_env::make_absolute (file, octave_env::getcwd ());
     }
 
   int len = file.length ();
 
   if (len > 4 && file.substr (len-4, len-1) == ".oct")
     {
-      if (octave_dynamic_loader::load_oct (nm, file, fcn_file_from_relative_lookup))
-        force_link_to_function (nm);
+      if (autoload && ! fcn_name.empty ())
+	nm = fcn_name;
+
+      retval = octave_dynamic_loader::load_oct (nm, file, fcn_file_from_relative_lookup);
     }
   else if (len > 4 && file.substr (len-4, len-1) == ".mex")
-    {
-      if (octave_dynamic_loader::load_mex (nm, file, fcn_file_from_relative_lookup))
-        force_link_to_function (nm);
-    }
+    retval = octave_dynamic_loader::load_mex (nm, file, fcn_file_from_relative_lookup);
   else if (len > 2)
     {
-      // These are needed by yyparse.
-
-      unwind_protect_str (curr_fcn_file_name);
-      unwind_protect_str (curr_fcn_file_full_name);
-
-      curr_fcn_file_name = nm;
-      curr_fcn_file_full_name = file;
-
-      script_file_executed = parse_fcn_file (file, exec_script, autoloading);
-
-      if (! error_state)
+      if (is_function_file (file))
 	{
-	  if (autoloading)
-	    {
-	      script_file_executed = false;
-	      force_link_to_function (nm);
-	    }
-	  else if (! script_file_executed)
-	    force_link_to_function (nm);
+	  // These are needed by yyparse.
+
+	  unwind_protect_str (curr_fcn_file_name);
+	  unwind_protect_str (curr_fcn_file_full_name);
+
+	  curr_fcn_file_name = nm;
+	  curr_fcn_file_full_name = file;
+
+	  retval = parse_fcn_file (file, dispatch_type, false, autoloading);
 	}
+      else
+	retval = new octave_user_script (file, fcn_name);
     }
 
+  if (retval)
+    retval->stash_dir_name (dir_name);
+
   unwind_protect::run_frame ("load_fcn_from_file");
 
-  return script_file_executed;
-}
-
-bool
-load_fcn_from_file (symbol_record *sym_rec, bool exec_script)
-{
-  return load_fcn_from_file (sym_rec->name (), exec_script);
+  return retval;
 }
 
 DEFCMD (autoload, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} autoload (@var{function}, @var{file})\n\
 Define @var{function} to autoload from @var{file}.\n\
 \n\
 The second argument, @var{file}, should be an absolute file name or\n\
@@ -3593,29 +3566,30 @@ source_file (const std::string& file_nam
   unwind_protect_str (curr_fcn_file_name);
   unwind_protect_str (curr_fcn_file_full_name);
 
   curr_fcn_file_name = file_name;
   curr_fcn_file_full_name = file_full_name;
 
   if (! context.empty ())
     {
-      unwind_protect_ptr (curr_sym_tab);
-
       if (context == "caller")
-	curr_sym_tab = curr_caller_sym_tab;
+	symbol_table::push_scope (symbol_table::current_caller_scope ());
       else if (context == "base")
-	curr_sym_tab = top_level_sym_tab;
+	symbol_table::push_scope (symbol_table::top_scope ());
       else
 	error ("source: context must be \"caller\" or \"base\"");
+
+      if (! error_state)
+	unwind_protect::add (symbol_table::pop_scope);
     }      
 
   if (! error_state)
     {
-      parse_fcn_file (file_full_name, true, true);
+      parse_fcn_file (file_full_name, "", true, true);
 
       if (error_state)
 	error ("source: error sourcing file `%s'",
 	       file_full_name.c_str ());
     }
 
   unwind_protect::run_frame ("source_file");
 }
@@ -3731,20 +3705,22 @@ be named @file{@var{file}.m}.\n\
 // call.  ARGS are the arguments to the function.  NARGOUT is the
 // number of output arguments expected. 
 
 octave_value_list
 feval (const std::string& name, const octave_value_list& args, int nargout)
 {
   octave_value_list retval;
 
-  octave_function *fcn = is_valid_function (name, "feval", 1);
-
-  if (fcn)
-    retval = fcn->do_multi_index_op (nargout, args);
+  octave_value fcn = symbol_table::find_function (name, args);
+
+  if (fcn.is_defined ())
+    retval = fcn.do_multi_index_op (nargout, args);
+  else
+    error ("feval: function `%s' not found", name.c_str ());
 
   return retval;
 }
 
 octave_value_list
 feval (octave_function *fcn, const octave_value_list& args, int nargout)
 {
   octave_value_list retval;
@@ -3891,18 +3867,16 @@ eval_string (const std::string& s, bool 
   YY_BUFFER_STATE old_buf = current_buffer ();
   YY_BUFFER_STATE new_buf = create_buffer (0);
 
   unwind_protect::add (restore_input_buffer, old_buf);
   unwind_protect::add (delete_input_buffer, new_buf);
 
   switch_to_buffer (new_buf);
 
-  unwind_protect_ptr (curr_sym_tab);
-
   do
     {
       reset_parser ();
 
       parse_status = yyparse ();
 
       tree_statement_list *command = global_command;
 
@@ -4043,55 +4017,47 @@ may be either @code{\"base\"} or @code{\
   int nargin = args.length ();
 
   if (nargin == 3)
     {
       std::string context = args(0).string_value ();
 
       if (! error_state)
         {
-	  unwind_protect::begin_frame ("Fassignin");
-
-	  unwind_protect_ptr (curr_sym_tab);
+	  symbol_table::scope_id scope = -1;
 
 	  if (context == "caller")
-	    curr_sym_tab = curr_caller_sym_tab;
+	    {
+	      if (symbol_table::current_scope () == symbol_table::current_caller_scope ())
+		{
+		  error ("assignin: assignment in caller not implemented yet for direct recursion");
+		  return retval;
+		}
+	      else
+		scope = symbol_table::current_caller_scope ();
+	    }
 	  else if (context == "base")
-	    curr_sym_tab = top_level_sym_tab;
+	    scope = symbol_table::top_scope ();
 	  else
 	    error ("assignin: context must be \"caller\" or \"base\"");
 
 	  if (! error_state)
 	    {
 	      std::string nm = args(1).string_value ();
 
 	      if (! error_state)
 		{
 		  if (valid_identifier (nm))
-		    {
-		      symbol_record *sr = curr_sym_tab->lookup (nm, true);
-
-		      if (sr)
-			{
-			  tree_identifier *id = new tree_identifier (sr);
-			  tree_constant *rhs = new tree_constant (args(2));
-		      
-			  tree_simple_assignment tsa (id, rhs);
-
-			  tsa.rvalue ();
-			}
-		    }
+		    symbol_table::varref (nm, scope) = args(2);
 		  else
 		    error ("assignin: invalid variable name");
 		}
 	      else
 		error ("assignin: expecting variable name as second argument");
 	    }
-
-	  unwind_protect::run_frame ("Fassignin");
 	}
       else
         error ("assignin: expecting string as first argument");
     }
   else
     print_usage ();
 
   return retval;
@@ -4112,27 +4078,35 @@ context @var{context}, which may be eith
   if (nargin > 1)
     {
       std::string context = args(0).string_value ();
 
       if (! error_state)
         {
 	  unwind_protect::begin_frame ("Fevalin");
 
-	  unwind_protect_ptr (curr_sym_tab);
-
 	  if (context == "caller")
-	    curr_sym_tab = curr_caller_sym_tab;
+	    {
+	      if (symbol_table::current_scope () == symbol_table::current_caller_scope ())
+		{
+		  error ("evalin: evaluation in caller not implemented yet for direct recursion");
+		  return retval;
+		}
+	      else
+		symbol_table::push_scope (symbol_table::current_caller_scope ());
+	    }
 	  else if (context == "base")
-	    curr_sym_tab = top_level_sym_tab;
+	    symbol_table::push_scope (symbol_table::top_scope ());
 	  else
 	    error ("evalin: context must be \"caller\" or \"base\"");
 
 	  if (! error_state)
 	    {
+	      unwind_protect::add (symbol_table::pop_scope);
+
 	      if (nargin > 2)
 	        {
 		  unwind_protect_int (buffer_error_messages);
 		  buffer_error_messages++;
 		}
 
 	      int parse_status = 0;
 
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -249,28 +249,28 @@ tree_argument_list::get_arg_names (void)
 
       retval(k++) = elt->str_print_code ();
     }
 
   return retval;
 }
 
 tree_argument_list *
-tree_argument_list::dup (symbol_table *sym_tab)
+tree_argument_list::dup (symbol_table::scope_id scope)
 {
   tree_argument_list *new_list = new tree_argument_list ();
 
   new_list->list_includes_magic_end = list_includes_magic_end;
   new_list->simple_assign_lhs = simple_assign_lhs;
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_expression *elt = *p;
 
-      new_list->append (elt ? elt->dup (sym_tab) : 0);
+      new_list->append (elt ? elt->dup (scope) : 0);
     }
 
   return new_list;
 }
 
 void
 tree_argument_list::accept (tree_walker& tw)
 {
diff --git a/src/pt-arg-list.h b/src/pt-arg-list.h
--- a/src/pt-arg-list.h
+++ b/src/pt-arg-list.h
@@ -73,17 +73,17 @@ public:
   bool all_elements_are_constant (void) const;
 
   octave_value_list convert_to_const_vector (const octave_value *object = 0);
 
   std::list<octave_lvalue> lvalue_list (void);
 
   string_vector get_arg_names (void) const;
 
-  tree_argument_list *dup (symbol_table *sym_tab);
+  tree_argument_list *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   bool list_includes_magic_end;
 
   bool simple_assign_lhs;
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -274,21 +274,21 @@ tree_simple_assignment::eval_error (void
 
 std::string
 tree_simple_assignment::oper (void) const
 {
   return octave_value::assign_op_as_string (etype);
 }
 
 tree_expression *
-tree_simple_assignment::dup (symbol_table *sym_tab)
+tree_simple_assignment::dup (symbol_table::scope_id scope)
 {
   tree_simple_assignment *new_sa
-    = new tree_simple_assignment (lhs ? lhs->dup (sym_tab) : 0,
-				  rhs ? rhs->dup (sym_tab) : 0,
+    = new tree_simple_assignment (lhs ? lhs->dup (scope) : 0,
+				  rhs ? rhs->dup (scope) : 0,
 				  preserve, etype);
 
   new_sa->copy_base (*this);
 
   return new_sa;
 }
 
 void
@@ -502,21 +502,21 @@ tree_multi_assignment::eval_error (void)
 
 std::string
 tree_multi_assignment::oper (void) const
 {
   return octave_value::assign_op_as_string (etype);
 }
 
 tree_expression *
-tree_multi_assignment::dup (symbol_table *sym_tab)
+tree_multi_assignment::dup (symbol_table::scope_id scope)
 {
   tree_multi_assignment *new_ma
-    = new tree_multi_assignment (lhs ? lhs->dup (sym_tab) : 0,
-				 rhs ? rhs->dup (sym_tab) : 0,
+    = new tree_multi_assignment (lhs ? lhs->dup (scope) : 0,
+				 rhs ? rhs->dup (scope) : 0,
 				 preserve, etype);
 
   new_ma->copy_base (*this);
 
   return new_ma;
 }
 
 void
diff --git a/src/pt-assign.h b/src/pt-assign.h
--- a/src/pt-assign.h
+++ b/src/pt-assign.h
@@ -31,16 +31,17 @@ class tree_argument_list;
 class tree_walker;
 
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "ov.h"
 #include "pt-exp.h"
+#include "symtab.h"
 
 // Simple assignment expressions.
 
 class
 tree_simple_assignment : public tree_expression
 {
 public:
 
@@ -67,17 +68,17 @@ public:
   void eval_error (void);
 
   std::string oper (void) const;
 
   tree_expression *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
-  tree_expression *dup (symbol_table *sym_tab);
+  tree_expression *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
   octave_value::assign_op op_type (void) const { return etype; }
 
 private:
 
   void do_assign (octave_lvalue& ult, const octave_value_list& args,
@@ -137,17 +138,17 @@ public:
   void eval_error (void);
 
   std::string oper (void) const;
 
   tree_argument_list *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
-  tree_expression *dup (symbol_table *sym_tab);
+  tree_expression *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
   
   octave_value::assign_op op_type (void) const { return etype; }
 
 private:
 
   // The left hand side of the assignment.
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -101,21 +101,21 @@ tree_binary_expression::eval_error (void
 
 std::string
 tree_binary_expression::oper (void) const
 {
   return octave_value::binary_op_as_string (etype);
 }
 
 tree_expression *
-tree_binary_expression::dup (symbol_table *sym_tab)
+tree_binary_expression::dup (symbol_table::scope_id scope)
 {
   tree_binary_expression *new_be
-    = new tree_binary_expression (op_lhs ? op_lhs->dup (sym_tab) : 0,
-				  op_rhs ? op_rhs->dup (sym_tab) : 0,
+    = new tree_binary_expression (op_lhs ? op_lhs->dup (scope) : 0,
+				  op_rhs ? op_rhs->dup (scope) : 0,
 				  line (), column (), etype);
 
   new_be->copy_base (*this);
 
   return new_be;
 }
 
 void
@@ -228,21 +228,21 @@ tree_boolean_expression::oper (void) con
     default:
       break;
     }
 
   return retval;
 }
 
 tree_expression *
-tree_boolean_expression::dup (symbol_table *sym_tab)
+tree_boolean_expression::dup (symbol_table::scope_id scope)
 {
   tree_boolean_expression *new_be
-    = new tree_boolean_expression (op_lhs ? op_lhs->dup (sym_tab) : 0,
-				   op_rhs ? op_rhs->dup (sym_tab) : 0,
+    = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope) : 0,
+				   op_rhs ? op_rhs->dup (scope) : 0,
 				   line (), column (), etype);
 
   new_be->copy_base (*this);
 
   return new_be;
 }
 
 /*
diff --git a/src/pt-binop.h b/src/pt-binop.h
--- a/src/pt-binop.h
+++ b/src/pt-binop.h
@@ -29,16 +29,17 @@ along with Octave; see the file COPYING.
 class tree_walker;
 
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "ov.h"
 #include "pt-exp.h"
+#include "symtab.h"
 
 // Binary expressions.
 
 class
 tree_binary_expression : public tree_expression
 {
 public:
 
@@ -77,17 +78,17 @@ public:
 
   std::string oper (void) const;
 
   octave_value::binary_op op_type (void) const { return etype; }
 
   tree_expression *lhs (void) { return op_lhs; }
   tree_expression *rhs (void) { return op_rhs; }
 
-  tree_expression *dup (symbol_table *sym_tab);
+  tree_expression *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 protected:
 
   // The operands for the expression.
   tree_expression *op_lhs;
   tree_expression *op_rhs;
@@ -134,17 +135,17 @@ public:
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   std::string oper (void) const;
 
   type op_type (void) const { return etype; }
 
-  tree_expression *dup (symbol_table *sym_tab);
+  tree_expression *dup (symbol_table::scope_id scope);
 
 private:
 
   // The type of the expression.
   type etype;
 
   // No copying!
 
diff --git a/src/pt-cell.cc b/src/pt-cell.cc
--- a/src/pt-cell.cc
+++ b/src/pt-cell.cc
@@ -97,25 +97,25 @@ tree_cell::rvalue (int nargout)
     error ("invalid number of output arguments for cell array");
   else
     retval = rvalue ();
 
   return retval;
 }
 
 tree_expression *
-tree_cell::dup (symbol_table *sym_tab)
+tree_cell::dup (symbol_table::scope_id scope)
 {
   tree_cell *new_cell = new tree_cell (0, line (), column ());
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_argument_list *elt = *p;
 
-      new_cell->append (elt ? elt->dup (sym_tab) : 0);
+      new_cell->append (elt ? elt->dup (scope) : 0);
     }
 
   new_cell->copy_base (*this);
 
   return new_cell;
 }
 
 void
diff --git a/src/pt-cell.h b/src/pt-cell.h
--- a/src/pt-cell.h
+++ b/src/pt-cell.h
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 
 class octave_value;
 class octave_value_list;
 class tree_argument_list;
 
 class tree_walker;
 
 #include "pt-mat.h"
+#include "symtab.h"
 
 // General cells.
 
 class
 tree_cell : public tree_matrix
 {
 public:
 
@@ -47,17 +48,17 @@ public:
   ~tree_cell (void) { }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int);
 
-  tree_expression *dup (symbol_table *sym_tab);
+  tree_expression *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_cell (const tree_cell&);
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "pt-cmd.h"
 #include "pt-walk.h"
 
 // No-op.
 
 tree_command *
-tree_no_op_command::dup (symbol_table *sym_tab)
+tree_no_op_command::dup (symbol_table::scope_id)
 {
   return new tree_no_op_command (orig_cmd, line (), column ());
 }
 
 void
 tree_no_op_command::accept (tree_walker& tw)
 {
   tw.visit_no_op_command (*this);
diff --git a/src/pt-cmd.h b/src/pt-cmd.h
--- a/src/pt-cmd.h
+++ b/src/pt-cmd.h
@@ -22,36 +22,36 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_tree_cmd_h)
 #define octave_tree_cmd_h 1
 
 #include <string>
 
 class tree_walker;
-class symbol_table;
 
 #include "pt.h"
 #include "pt-bp.h"
+#include "symtab.h"
 
 // A base class for commands.
 
 class
 tree_command : public tree
 {
 public:
 
   tree_command (int l = -1, int c = -1)
     : tree (l, c) { }
 
   virtual ~tree_command (void) { }
 
   virtual void eval (void) = 0;
 
-  virtual tree_command *dup (symbol_table *) = 0;
+  virtual tree_command *dup (symbol_table::scope_id) = 0;
 
 private:
 
   // No copying!
 
   tree_command (const tree_command&);
 
   tree_command& operator = (const tree_command&);
@@ -66,17 +66,17 @@ public:
 
   tree_no_op_command (const std::string& cmd = "no_op", int l = -1, int c = -1)
     : tree_command (l, c), orig_cmd (cmd) { }
 
   ~tree_no_op_command (void) { }
 
   void eval (void) { MAYBE_DO_BREAKPOINT; }
 
-  tree_command *dup (symbol_table *sym_tab);
+  tree_command *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
   std::string original_command (void) { return orig_cmd; }
 
 private:
 
   std::string orig_cmd;
diff --git a/src/pt-colon.cc b/src/pt-colon.cc
--- a/src/pt-colon.cc
+++ b/src/pt-colon.cc
@@ -205,22 +205,22 @@ tree_colon_expression::column (void) con
 {
   return (op_base ? op_base->column ()
 	  : (op_increment ? op_increment->column ()
 	     : (op_limit ? op_limit->column ()
 		: -1)));
 }
 
 tree_expression *
-tree_colon_expression::dup (symbol_table *sym_tab)
+tree_colon_expression::dup (symbol_table::scope_id scope)
 {
   tree_colon_expression *new_ce
-    = new tree_colon_expression (op_base ? op_base->dup (sym_tab) : 0,
-				 op_limit ? op_limit->dup (sym_tab) : 0,
-				 op_increment ? op_increment->dup (sym_tab) : 0,
+    = new tree_colon_expression (op_base ? op_base->dup (scope) : 0,
+				 op_limit ? op_limit->dup (scope) : 0,
+				 op_increment ? op_increment->dup (scope) : 0,
 				 line (), column ());
 
   new_ce->copy_base (*new_ce);
 
   return new_ce;
 }
 
 void
diff --git a/src/pt-colon.h b/src/pt-colon.h
--- a/src/pt-colon.h
+++ b/src/pt-colon.h
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 
 class tree_walker;
 
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "pt-exp.h"
+#include "symtab.h"
 
 // Colon expressions.
 
 class
 tree_colon_expression : public tree_expression
 {
 public:
 
@@ -86,17 +87,17 @@ public:
 
   tree_expression *limit (void) { return op_limit; }
 
   tree_expression *increment (void) { return op_increment; }
 
   int line (void) const;
   int column (void) const;
 
-  tree_expression *dup (symbol_table *sym_tab);
+  tree_expression *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The components of the expression.
   tree_expression *op_base;
   tree_expression *op_limit;
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -66,17 +66,17 @@ tree_constant::rvalue (int nargout)
     error ("invalid number of output arguments for constant expression");
   else
     retval = rvalue ();
 
   return retval;
 }
 
 tree_expression *
-tree_constant::dup (symbol_table *)
+tree_constant::dup (symbol_table::scope_id)
 {
   tree_constant *new_tc
     = new tree_constant (val, orig_text, line (), column ());
 
   new_tc->copy_base (*this);
 
   return new_tc;
 }
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -24,24 +24,23 @@ along with Octave; see the file COPYING.
 #if !defined (octave_tree_const_h)
 #define octave_tree_const_h 1
 
 #include <iostream>
 #include <string>
 
 #include "oct-alloc.h"
 
-#include "pt-bp.h"
-#include "pt-exp.h"
-
 class octave_value_list;
-
 class tree_walker;
 
 #include "ov.h"
+#include "pt-bp.h"
+#include "pt-exp.h"
+#include "symtab.h"
 
 class
 tree_constant : public tree_expression
 {
 public:
 
   tree_constant (int l = -1, int c = -1)
     : tree_expression (l, c), val (), orig_text () { }
@@ -78,17 +77,17 @@ public:
   octave_value rvalue (void)
     {
       MAYBE_DO_BREAKPOINT;
       return val;
     }
 
   octave_value_list rvalue (int nargout);
 
-  tree_expression *dup (symbol_table *sym_tab);
+  tree_expression *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
   // Store the original text corresponding to this constant for later
   // pretty printing.
 
   void stash_original_text (const std::string& s) { orig_text = s; }
 
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -64,20 +64,20 @@ tree_decl_elt::eval (void)
 	  retval = true;
 	}
     }
 
   return retval;
 }
 
 tree_decl_elt *
-tree_decl_elt::dup (symbol_table *sym_tab)
+tree_decl_elt::dup (symbol_table::scope_id scope)
 {
-  return new tree_decl_elt (id ? id->dup (sym_tab) : 0,
-			    expr ? expr->dup (sym_tab) : 0);
+  return new tree_decl_elt (id ? id->dup (scope) : 0,
+			    expr ? expr->dup (scope) : 0);
 }
 
 void
 tree_decl_elt::accept (tree_walker& tw)
 {
   tw.visit_decl_elt (*this);
 }
 
@@ -93,25 +93,25 @@ tree_decl_init_list::eval (tree_decl_elt
       f (*elt);
 
       if (error_state)
 	break;
     }
 }
 
 tree_decl_init_list *
-tree_decl_init_list::dup (symbol_table *sym_tab)
+tree_decl_init_list::dup (symbol_table::scope_id scope)
 {
   tree_decl_init_list *new_dil = new tree_decl_init_list ();
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_decl_elt *elt = *p;
 
-      new_dil->append (elt ? elt->dup (sym_tab) : 0);
+      new_dil->append (elt ? elt->dup (scope) : 0);
     }
   
   return new_dil;
 }
 
 void
 tree_decl_init_list::accept (tree_walker& tw)
 {
@@ -135,17 +135,17 @@ tree_decl_command::accept (tree_walker& 
 
 void
 tree_global_command::do_init (tree_decl_elt& elt)
 {
   tree_identifier *id = elt.ident ();
 
   if (id)
     {
-      id->link_to_global ();
+      id->mark_global ();
 
       if (! error_state)
 	{
 	  octave_lvalue ult = id->lvalue ();
 
 	  if (ult.is_undefined ())
 	    {
 	      tree_expression *expr = elt.expression ();
@@ -164,31 +164,27 @@ tree_global_command::do_init (tree_decl_
 }
 
 void
 tree_global_command::eval (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   if (init_list)
-    {
-      init_list->eval (do_init);
-
-      initialized = true;
-    }
+    init_list->eval (do_init);
 
   if (error_state)
     ::error ("evaluating global command near line %d, column %d",
 	     line (), column ());
 }
 
 tree_command *
-tree_global_command::dup (symbol_table *sym_tab)
+tree_global_command::dup (symbol_table::scope_id scope)
 {
-  return new tree_global_command (init_list ? init_list->dup (sym_tab) : 0,
+  return new tree_global_command (init_list ? init_list->dup (scope) : 0,
 				  line (), column ());
 }
 
 // Static.
 
 void
 tree_static_command::do_init (tree_decl_elt& elt)
 {
@@ -218,32 +214,28 @@ tree_static_command::do_init (tree_decl_
 
 void
 tree_static_command::eval (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   // Static variables only need to be marked and initialized once.
 
-  if (init_list && ! initialized)
-    {
-      init_list->eval (do_init);
+  if (init_list)
+    init_list->eval (do_init);
 
-      initialized = true;
-
-      if (error_state)
-	::error ("evaluating static command near line %d, column %d",
-		 line (), column ());
-    }
+  if (error_state)
+    ::error ("evaluating static command near line %d, column %d",
+	     line (), column ());
 }
 
 tree_command *
-tree_static_command::dup (symbol_table *sym_tab)
+tree_static_command::dup (symbol_table::scope_id scope)
 {
-  return new tree_static_command (init_list ? init_list->dup (sym_tab) : 0,
+  return new tree_static_command (init_list ? init_list->dup (scope) : 0,
 				  line (), column ());
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-decl.h b/src/pt-decl.h
--- a/src/pt-decl.h
+++ b/src/pt-decl.h
@@ -30,16 +30,17 @@ class tree_identifier;
 class tree_walker;
 
 #include <string>
 
 #include "base-list.h"
 #include "oct-lvalue.h"
 #include "pt-cmd.h"
 #include "pt-id.h"
+#include "symtab.h"
 
 // List of expressions that make up a declaration statement.
 
 class
 tree_decl_elt
 {
 public:
 
@@ -49,16 +50,18 @@ public:
     : id (i), expr (e) { }
 
   ~tree_decl_elt (void);
 
   bool eval (void);
 
   bool is_defined (void) { return id ? id->is_defined () : false; }
 
+  bool is_variable (void) { return id ? id->is_variable () : false; }
+
   void mark_as_formal_parameter (void)
   {
     if (id)
       id->mark_as_formal_parameter ();
   }
 
   bool lvalue_ok (void) { return id ? id->lvalue_ok () : false; }
 
@@ -70,17 +73,17 @@ public:
   }
 
   octave_lvalue lvalue (void) { return id ? id->lvalue () : octave_lvalue (); }
 
   tree_identifier *ident (void) { return id; }
 
   tree_expression *expression (void) { return expr; }
 
-  tree_decl_elt *dup (symbol_table *sym_tab);
+  tree_decl_elt *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // An identifier to tag with the declared property.
   tree_identifier *id;
 
@@ -110,17 +113,17 @@ public:
 	  iterator p = begin ();
 	  delete *p;
 	  erase (p);
 	}
     }
 
   void eval (tree_decl_elt::eval_fcn);
 
-  tree_decl_init_list *dup (symbol_table *sym_tab);
+  tree_decl_init_list *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_decl_init_list (const tree_decl_init_list&);
@@ -131,38 +134,35 @@ private:
 // Base class for declaration commands -- global, static, etc.
 
 class
 tree_decl_command : public tree_command
 {
 public:
 
   tree_decl_command (const std::string& n, int l = -1, int c = -1)
-    : tree_command (l, c), cmd_name (n), initialized (false), init_list (0) { }
+    : tree_command (l, c), cmd_name (n), init_list (0) { }
 
   tree_decl_command (const std::string& n, tree_decl_init_list *t,
 		     int l = -1, int c = -1)
-    : tree_command (l, c), cmd_name (n), initialized (false), init_list (t) { }
+    : tree_command (l, c), cmd_name (n), init_list (t) { }
 
   ~tree_decl_command (void);
 
   tree_decl_init_list *initializer_list (void) { return init_list; }
 
   void accept (tree_walker& tw);
 
   std::string name (void) { return cmd_name; }
 
 protected:
 
   // The name of this command -- global, static, etc.
   std::string cmd_name;
 
-  // TRUE if this command has been evaluated.
-  bool initialized;
-
   // The list of variables or initializers in this declaration command.
   tree_decl_init_list *init_list;
 
 private:
 
   // No copying!
 
   tree_decl_command (const tree_decl_command&);
@@ -182,17 +182,17 @@ public:
 
   tree_global_command (tree_decl_init_list *t, int l = -1, int c = -1)
     : tree_decl_command ("global", t, l, c) { }
 
   ~tree_global_command (void) { }
 
   void eval (void);
 
-  tree_command *dup (symbol_table *sym_tab);
+  tree_command *dup (symbol_table::scope_id scope);
 
 private:
 
   static void do_init (tree_decl_elt& elt);
 
   // No copying!
 
   tree_global_command (const tree_global_command&);
@@ -212,17 +212,17 @@ public:
 
   tree_static_command (tree_decl_init_list *t, int l = -1, int c = -1)
     : tree_decl_command ("static", t, l, c) { }
 
   ~tree_static_command (void) { }
 
   void eval (void);
 
-  tree_command *dup (symbol_table *sym_tab);
+  tree_command *dup (symbol_table::scope_id scope);
 
 private:
 
   static void do_init (tree_decl_elt& elt);
 
   // No copying!
 
   tree_static_command (const tree_static_command&);
diff --git a/src/pt-except.cc b/src/pt-except.cc
--- a/src/pt-except.cc
+++ b/src/pt-except.cc
@@ -122,20 +122,20 @@ tree_try_catch_command::eval (void)
       unwind_protect::run ();
 
       // Also clear the frame marker.
       unwind_protect::discard ();
     }
 }
 
 tree_command *
-tree_try_catch_command::dup (symbol_table *sym_tab)
+tree_try_catch_command::dup (symbol_table::scope_id scope)
 {
-  return new tree_try_catch_command (try_code ? try_code->dup (sym_tab) : 0,
-				     catch_code ? catch_code->dup (sym_tab) : 0,
+  return new tree_try_catch_command (try_code ? try_code->dup (scope) : 0,
+				     catch_code ? catch_code->dup (scope) : 0,
 				     lead_comm ? lead_comm->dup () : 0,
 				     mid_comm ? mid_comm->dup () : 0,
 				     trail_comm ? trail_comm->dup () : 0,
 				     line (), column ());
 }
 
 void
 tree_try_catch_command::accept (tree_walker& tw)
@@ -238,21 +238,21 @@ tree_unwind_protect_command::eval (void)
 
   if (unwind_protect_code)
     unwind_protect_code->eval ();
 
   unwind_protect::run ();
 }
 
 tree_command *
-tree_unwind_protect_command::dup (symbol_table *sym_tab)
+tree_unwind_protect_command::dup (symbol_table::scope_id scope)
 {
   return new tree_unwind_protect_command
-    (unwind_protect_code ? unwind_protect_code->dup (sym_tab) : 0,
-     cleanup_code ? cleanup_code->dup (sym_tab) : 0,
+    (unwind_protect_code ? unwind_protect_code->dup (scope) : 0,
+     cleanup_code ? cleanup_code->dup (scope) : 0,
      lead_comm ? lead_comm->dup () : 0,
      mid_comm ? mid_comm->dup () : 0,
      trail_comm ? trail_comm->dup () : 0,
      line (), column ());
 }
 
 void
 tree_unwind_protect_command::accept (tree_walker& tw)
diff --git a/src/pt-except.h b/src/pt-except.h
--- a/src/pt-except.h
+++ b/src/pt-except.h
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #define octave_tree_except_h 1
 
 class tree_statement_list;
 
 class tree_walker;
 
 #include "comment-list.h"
 #include "pt-cmd.h"
+#include "symtab.h"
 
 // Simple exception handling.
 
 class
 tree_try_catch_command : public tree_command
 {
 public:
 
@@ -59,17 +60,17 @@ public:
   tree_statement_list *cleanup (void) { return catch_code; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *middle_comment (void) { return mid_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table *sym_tab);
+  tree_command *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The first block of code to attempt to execute.
   tree_statement_list *try_code;
 
@@ -121,17 +122,17 @@ public:
   tree_statement_list *cleanup (void) { return cleanup_code; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *middle_comment (void) { return mid_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table *sym_tab);
+  tree_command *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The first body of code to attempt to execute.
   tree_statement_list *unwind_protect_code;
 
diff --git a/src/pt-exp.h b/src/pt-exp.h
--- a/src/pt-exp.h
+++ b/src/pt-exp.h
@@ -23,36 +23,36 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_tree_expr_h)
 #define octave_tree_expr_h 1
 
 #include <string>
 
 class octave_value;
 class octave_lvalue;
-class symbol_table;
 
 #include "pt.h"
+#include "symtab.h"
 
 // A base class for expressions.
 
 class
 tree_expression : public tree
 {
 public:
 
   tree_expression (int l = -1, int c = -1)
     : tree (l, c), num_parens (0), postfix_indexed (false),
       print_flag (false) { }
 
   virtual ~tree_expression (void) { }
 
   virtual bool has_magic_end (void) const = 0;
 
-  virtual tree_expression *dup (symbol_table *) = 0;
+  virtual tree_expression *dup (symbol_table::scope_id) = 0;
 
   virtual bool is_constant (void) const { return false; }
 
   virtual bool is_matrix_constant (void) const { return false; }
 
   virtual bool is_identifier (void) const { return false; }
 
   virtual bool is_index_expression (void) const { return false; }
diff --git a/src/pt-fcn-handle.cc b/src/pt-fcn-handle.cc
--- a/src/pt-fcn-handle.cc
+++ b/src/pt-fcn-handle.cc
@@ -66,17 +66,17 @@ tree_fcn_handle::rvalue (int nargout)
     error ("invalid number of output arguments for function handle expression");
   else
     retval = rvalue ();
 
   return retval;
 }
 
 tree_expression *
-tree_fcn_handle::dup (symbol_table *)
+tree_fcn_handle::dup (symbol_table::scope_id)
 {
   tree_fcn_handle *new_fh = new tree_fcn_handle (nm, line (), column ());
 
   new_fh->copy_base (*this);
 
   return new_fh;
 }
 
@@ -86,38 +86,31 @@ tree_fcn_handle::accept (tree_walker& tw
   tw.visit_fcn_handle (*this);
 }
 
 octave_value
 tree_anon_fcn_handle::rvalue (void)
 {
   MAYBE_DO_BREAKPOINT;
 
-  tree_parameter_list *param_list = fcn.parameter_list ();
-  tree_parameter_list *ret_list = fcn.return_list ();
-  tree_statement_list *cmd_list = fcn.body ();
-  symbol_table *sym_tab = fcn.sym_tab ();
-
-  symbol_table *new_sym_tab = sym_tab ? sym_tab->dup () : 0;
+  tree_parameter_list *param_list = parameter_list ();
+  tree_parameter_list *ret_list = return_list ();
+  tree_statement_list *cmd_list = body ();
+  symbol_table::scope_id this_scope = scope ();
 
-  if (new_sym_tab)
-    new_sym_tab->inherit (curr_sym_tab);
-
-  tree_parameter_list *new_param_list
-    = param_list ? param_list->dup (new_sym_tab) : 0;
+  symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
 
-  tree_statement_list *new_cmd_list
-    = cmd_list ? cmd_list->dup (new_sym_tab) : 0;
-
-  tree_parameter_list *new_ret_list
-    = ret_list ? ret_list->dup (new_sym_tab) : 0;
+  if (new_scope > 0)
+    symbol_table::inherit (new_scope, symbol_table::current_scope ());
 
   octave_user_function *uf
-    = new octave_user_function (new_param_list, new_ret_list,
-				new_cmd_list, new_sym_tab);
+    = new octave_user_function (new_scope,
+				param_list ? param_list->dup (new_scope) : 0,
+				ret_list ? ret_list->dup (new_scope) : 0,
+				cmd_list ? cmd_list->dup (new_scope) : 0);
 
   octave_function *curr_fcn = octave_call_stack::current ();
 
   if (curr_fcn)
     uf->stash_parent_fcn_name (curr_fcn->name ());
 
   uf->mark_as_inline_function ();
 
@@ -137,33 +130,33 @@ tree_anon_fcn_handle::rvalue (int nargou
     error ("invalid number of output arguments for anonymous function handle expression");
   else
     retval = rvalue ();
 
   return retval;
 }
 
 tree_expression *
-tree_anon_fcn_handle::dup (symbol_table *st)
+tree_anon_fcn_handle::dup (symbol_table::scope_id parent_scope)
 {
-  tree_parameter_list *param_list = fcn.parameter_list ();
-  tree_parameter_list *ret_list = fcn.return_list ();
-  tree_statement_list *cmd_list = fcn.body ();
-  symbol_table *sym_tab = fcn.sym_tab ();
+  tree_parameter_list *param_list = parameter_list ();
+  tree_parameter_list *ret_list = return_list ();
+  tree_statement_list *cmd_list = body ();
+  symbol_table::scope_id this_scope = scope ();
 
-  symbol_table *new_sym_tab = sym_tab ? sym_tab->dup () : 0;
+  symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
 
-  if (new_sym_tab)
-    new_sym_tab->inherit (st);
+  if (new_scope > 0)
+    symbol_table::inherit (new_scope, parent_scope);
 
   tree_anon_fcn_handle *new_afh
-    = new tree_anon_fcn_handle (param_list ? param_list->dup (new_sym_tab) : 0,
-				ret_list ? ret_list->dup (new_sym_tab) : 0,
-				cmd_list ? cmd_list->dup (new_sym_tab) : 0,
-				new_sym_tab, line (), column ());
+    = new tree_anon_fcn_handle (param_list ? param_list->dup (new_scope) : 0,
+				ret_list ? ret_list->dup (new_scope) : 0,
+				cmd_list ? cmd_list->dup (new_scope) : 0,
+				new_scope, line (), column ());
 
   new_afh->copy_base (*this);
 
   return new_afh;
 }
 
 void
 tree_anon_fcn_handle::accept (tree_walker& tw)
diff --git a/src/pt-fcn-handle.h b/src/pt-fcn-handle.h
--- a/src/pt-fcn-handle.h
+++ b/src/pt-fcn-handle.h
@@ -25,23 +25,25 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <string>
 
 #include "pt-bp.h"
 #include "pt-exp.h"
 #include "pt-misc.h"
 #include "pt-stmt.h"
+#include "symtab.h"
 
 class octave_value_list;
 
 class tree_walker;
 
 #include "ov.h"
 #include "ov-usr-fcn.h"
+#include "symtab.h"
 
 class
 tree_fcn_handle : public tree_expression
 {
 public:
 
   tree_fcn_handle (int l = -1, int c = -1)
     : tree_expression (l, c), nm () { }
@@ -62,17 +64,17 @@ public:
   std::string name (void) const { return nm; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  tree_expression *dup (symbol_table *sym_tab);
+  tree_expression *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The name of this function handle.
   std::string nm;
 
@@ -84,45 +86,56 @@ private:
 };
 
 class
 tree_anon_fcn_handle : public tree_expression
 {
 public:
 
   tree_anon_fcn_handle (int l = -1, int c = -1)
-    : tree_expression (l, c), fcn () { }
+    : tree_expression (l, c), fcn (0) { }
 
   tree_anon_fcn_handle (tree_parameter_list *pl, tree_parameter_list *rl,
-			tree_statement_list *cl, symbol_table *st,
+			tree_statement_list *cl, symbol_table::scope_id sid,
 			int l = -1, int c = -1)
-    : tree_expression (l, c), fcn (pl, rl, cl, st) { }
+    : tree_expression (l, c),
+      fcn (new octave_user_function (sid, pl, rl, cl)) { }
 
-  ~tree_anon_fcn_handle (void) { }
+  ~tree_anon_fcn_handle (void) { delete fcn; }
 
   bool has_magic_end (void) const { return false; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  tree_parameter_list *parameter_list (void) { return fcn.parameter_list (); }
+  tree_parameter_list *parameter_list (void)
+  {
+    return fcn ? fcn->parameter_list () : 0;
+  }
 
-  tree_statement_list *body (void) { return fcn.body (); }
+  tree_parameter_list *return_list (void)
+  {
+    return fcn ? fcn->return_list () : 0;
+  }
 
-  tree_expression *dup (symbol_table *sym_tab);
+  tree_statement_list *body (void) { return fcn ? fcn->body () : 0; }
+
+  symbol_table::scope_id scope (void) { return fcn ? fcn->scope () : -1; }
+
+  tree_expression *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The function.
-  octave_user_function fcn;
+  octave_user_function *fcn;
 
   // No copying!
 
   tree_anon_fcn_handle (const tree_anon_fcn_handle&);
 
   tree_anon_fcn_handle& operator = (const tree_anon_fcn_handle&);
 };
 
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -34,169 +34,74 @@ along with Octave; see the file COPYING.
 #include "pt-id.h"
 #include "pt-walk.h"
 #include "symtab.h"
 #include "utils.h"
 #include "variables.h"
 
 // Symbols from the symbol table.
 
-std::string
-tree_identifier::name (void) const
-{
-  std::string retval;
-  if (sym)
-    retval = sym->name ();
-  return retval;
-}
-
-tree_identifier *
-tree_identifier::define (octave_function *f, unsigned int sym_type)
-{
-  int status = sym->define (f, sym_type);
-  return status ? this : 0;
-}
-
-void
-tree_identifier::document (const std::string& s)
-{
-  if (sym)
-    sym->document (s);
-}
-
-bool
-tree_identifier::is_defined (void)
-{
-  return (sym && sym->is_defined ());
-}
-
-bool
-tree_identifier::is_function (void)
-{
-  return (sym && sym->is_function ());
-}
-
 void
 tree_identifier::eval_undefined_error (void)
 {
   int l = line ();
   int c = column ();
 
   if (l == -1 && c == -1)
     ::error ("`%s' undefined", name ().c_str ());
   else
     ::error ("`%s' undefined near line %d column %d",
 	     name ().c_str (), l, c);
 }
 
-// Try to find a definition for an identifier.  Here's how:
-//
-//   * If the identifier is already defined and is a function defined
-//     in an function file that has been modified since the last time 
-//     we parsed it, parse it again.
-//
-//   * If the identifier is not defined, try to find a builtin
-//     variable or an already compiled function with the same name.
-//
-//   * If the identifier is still undefined, try looking for an
-//     function file to parse.
-//
-//   * On systems that support dynamic linking, we prefer .oct files,
-//     then .mex files, then .m files.
-
-octave_value
-tree_identifier::do_lookup (bool& script_file_executed, bool exec_script)
-{
-  static octave_value foo;
-
-  script_file_executed = lookup (sym, exec_script);
-
-  return script_file_executed ? foo : sym->def ();
-}
-
-void
-tree_identifier::link_to_global (void)
-{
-  if (sym)
-    {
-      if (! sym->is_linked_to_global ())
-	{
-	  if (sym->is_defined () && sym->is_variable ())
-	    {
-	      std::string nm = sym->name ();
-
-	      warning ("value of local variable `%s' may have changed to match global",
-		       nm.c_str ());
-	    }
-
-	  link_to_global_variable (sym);
-	}
-    }
-}
-
-void
-tree_identifier::mark_as_static (void)
-{
-  if (sym)
-    sym->mark_as_static ();
-}
-
-void
-tree_identifier::mark_as_formal_parameter (void)
-{
-  if (sym)
-    sym->mark_as_formal_parameter ();
-}
-
 octave_value_list
 tree_identifier::rvalue (int nargout)
 {
   octave_value_list retval;
 
   MAYBE_DO_BREAKPOINT;
 
   if (error_state)
     return retval;
 
-  bool script_file_executed = false;
+  octave_value_list evaluated_args;
+  bool args_evaluated;
 
-  octave_value val = do_lookup (script_file_executed);
+  octave_value val = sym.find (0, string_vector (), evaluated_args,
+			       args_evaluated);
 
-  if (! script_file_executed)
+  if (val.is_defined ())
     {
-      if (val.is_defined ())
+      // GAGME -- this would be cleaner if we required
+      // parens to indicate function calls.
+      //
+      // If this identifier refers to a function, we need to know
+      // whether it is indexed so that we can do the same thing
+      // for `f' and `f()'.  If the index is present, return the
+      // function object and let tree_index_expression::rvalue
+      // handle indexing.  Otherwise, arrange to call the function
+      // here, so that we don't return the function definition as
+      // a value.
+
+      if (val.is_function () && ! is_postfix_indexed ())
 	{
-	  // GAGME -- this would be cleaner if we required
-	  // parens to indicate function calls.
-	  //
-	  // If this identifier refers to a function, we need to know
-	  // whether it is indexed so that we can do the same thing
-	  // for `f' and `f()'.  If the index is present, return the
-	  // function object and let tree_index_expression::rvalue
-	  // handle indexing.  Otherwise, arrange to call the function
-	  // here, so that we don't return the function definition as
-	  // a value.
+	  octave_value_list tmp_args;
 
-	  if (val.is_function () && ! is_postfix_indexed ())
-	    {
-	      octave_value_list tmp_args;
-
-	      retval = val.do_multi_index_op (nargout, tmp_args);
-	    }
-	  else
-	    {
-	      if (print_result () && nargout == 0)
-		val.print_with_name (octave_stdout, name ());
-
-	      retval = val;
-	    }
+	  retval = val.do_multi_index_op (nargout, tmp_args);
 	}
       else
-	eval_undefined_error ();
+	{
+	  if (print_result () && nargout == 0)
+	    val.print_with_name (octave_stdout, name ());
+
+	  retval = val;
+	}
     }
+  else
+    eval_undefined_error ();
 
   return retval;
 }
 
 octave_value
 tree_identifier::rvalue (void)
 {
   octave_value retval;
@@ -209,25 +114,31 @@ tree_identifier::rvalue (void)
   return retval;
 }
 
 octave_lvalue
 tree_identifier::lvalue (void)
 {
   MAYBE_DO_BREAKPOINT;
 
-  return sym->variable_reference ();
+  return octave_lvalue (&(sym.varref ()));
 }
 
 tree_identifier *
-tree_identifier::dup (symbol_table *sym_tab)
+tree_identifier::dup (symbol_table::scope_id scope)
 {
-  symbol_record *sr = (sym_tab && sym) ? sym_tab->lookup (sym->name ()) : 0;
+  // The new tree_identifier object contains a symbol_record
+  // entry from the duplicated scope.
 
-  tree_identifier *new_id = new tree_identifier (sr, line (), column ());
+  // FIXME -- is this the best way?
+  symbol_table::symbol_record new_sym
+    = symbol_table::find_symbol (sym.name (), scope);
+
+  tree_identifier *new_id
+    = new tree_identifier (new_sym, line (), column ());
 
   new_id->copy_base (*this);
 
   return new_id;
 }
 
 void
 tree_identifier::accept (tree_walker& tw)
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -25,83 +25,107 @@ along with Octave; see the file COPYING.
 #define octave_tree_identifier_h 1
 
 #include <iostream>
 #include <string>
 
 class octave_value;
 class octave_value_list;
 class octave_function;
-class symbol_record;
 
 class tree_walker;
 
 #include "pt-exp.h"
+#include "symtab.h"
 
 // Symbols from the symbol table.
 
 class
 tree_identifier : public tree_expression
 {
   friend class tree_index_expression;
 
 public:
 
   tree_identifier (int l = -1, int c = -1)
-    : tree_expression (l, c), sym (0) { }
+    : tree_expression (l, c), sym () { }
 
-  tree_identifier (symbol_record *s, int l = -1, int c = -1)
+  tree_identifier (const symbol_table::symbol_record& s, int l = -1, int c = -1)
     : tree_expression (l, c), sym (s) { }
 
   ~tree_identifier (void) { }
 
   bool has_magic_end (void) const { return (name () == "__end__"); }
 
   bool is_identifier (void) const { return true; }
 
-  std::string name (void) const;
+  std::string name (void) const { return sym.name (); }
 
-  tree_identifier *define (octave_function *f, unsigned int sym_type);
+  bool is_defined (void) { return sym.is_defined (); }
+
+  bool is_variable (void) { return sym.is_variable (); }
 
-  void document (const std::string& s);
-
-  bool is_defined (void);
-
-  bool is_function (void);
+  // Try to find a definition for an identifier.  Here's how:
+  //
+  //   * If the identifier is already defined and is a function defined
+  //     in an function file that has been modified since the last time 
+  //     we parsed it, parse it again.
+  //
+  //   * If the identifier is not defined, try to find a builtin
+  //     variable or an already compiled function with the same name.
+  //
+  //   * If the identifier is still undefined, try looking for an
+  //     function file to parse.
+  //
+  //   * On systems that support dynamic linking, we prefer .oct files,
+  //     then .mex files, then .m files.
 
   octave_value
-  do_lookup (bool& script_file_executed, bool exec_script = true);
-
-  void link_to_global (void);
+  do_lookup (bool& script_file_executed, bool exec_script = true)
+  {
+    // FIXME -- SYMTAB: what about executing script files?
+    octave_value_list evaluated_args;
+    bool args_evaluated;
+    return sym.find (0, string_vector (), evaluated_args, args_evaluated);
+  }
 
-  void mark_as_static (void);
+  octave_value
+  do_lookup (tree_argument_list *args, const string_vector& arg_names,
+	     octave_value_list& evaluated_args, bool& args_evaluated)
+  {
+    return sym.find (args, arg_names, evaluated_args, args_evaluated);
+  }
 
-  void mark_as_formal_parameter (void);
+  void mark_global (void) { sym.mark_global (); }
+
+  void mark_as_static (void) { sym.init_persistent (); }
+
+  void mark_as_formal_parameter (void) { sym.mark_formal (); }
 
   // We really need to know whether this symbol referst to a variable
   // or a function, but we may not know that yet.
 
   bool lvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
   void eval_undefined_error (void);
 
-  tree_identifier *dup (symbol_table *sym_tab);
+  tree_identifier *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The symbol record that this identifier references.
-  symbol_record *sym;
+  symbol_table::symbol_record sym;
 
   // No copying!
 
   tree_identifier (const tree_identifier&);
 
   tree_identifier& operator = (const tree_identifier&);
 };
 
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -29,16 +29,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pager.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
+#include "pt-id.h"
 #include "pt-idx.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
 
 // Index expressions.
 
 tree_index_expression::tree_index_expression (int l, int c)
@@ -214,41 +215,40 @@ tree_index_expression::get_struct_index
   return fn;
 }
 
 Octave_map
 tree_index_expression::make_arg_struct (void) const
 {
   int n = args.size ();
 
-  // FIXME -- why not just make these Cell objects?
-  octave_value_list subs_list (n, octave_value ());
-  octave_value_list type_list (n, octave_value ());
+  Cell type_field (n, 1);
+  Cell subs_field (n, 1);
 
   std::list<tree_argument_list *>::const_iterator p_args = args.begin ();
   std::list<string_vector>::const_iterator p_arg_nm = arg_nm.begin ();
   std::list<tree_expression *>::const_iterator p_dyn_field = dyn_field.begin ();
 
   Octave_map m;
 
   for (int i = 0; i < n; i++)
     {
       switch (type[i])
 	{
 	case '(':
-	  subs_list(i) = make_subs_cell (*p_args, *p_arg_nm);
+	  subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
 	  break;
 
 	case '{':
-	  subs_list(i) = make_subs_cell (*p_args, *p_arg_nm);
+	  subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
 	  break;
 
 	case '.':
 	  {
-	    subs_list(i) = get_struct_index (p_arg_nm, p_dyn_field);
+	    subs_field(i) = get_struct_index (p_arg_nm, p_dyn_field);
 
 	    if (error_state)
 	      eval_error ();
 	  }
 	  break;
 
 	default:
 	  panic_impossible ();
@@ -257,35 +257,62 @@ tree_index_expression::make_arg_struct (
       if (error_state)
 	return m;
 
       p_args++;
       p_arg_nm++;
       p_dyn_field++;
     }
 
-  m.assign ("subs", Cell (subs_list));
-  m.assign ("type", Cell (type_list));
+  m.assign ("type", type_field);
+  m.assign ("subs", subs_field);
 
   return m;
 }
 
 octave_value_list
 tree_index_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
-  octave_value first_expr_val = expr->rvalue ();
-  octave_value tmp = first_expr_val;
+  octave_value first_expr_val;
+
+  octave_value_list first_args;
+
+  bool have_args = false;
+
+  if (expr->is_identifier () && type[0] == '(')
+    {
+      tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
+
+      if (! (id->is_variable () || args.empty ()))
+	{
+	  tree_argument_list *al = *(args.begin ());
+
+	  size_t n = al ? al->length () : 0;
+
+	  if (n > 0)
+	    {
+	      string_vector anm = *(arg_nm.begin ());
+
+	      first_expr_val = id->do_lookup  (al, anm, first_args, have_args);
+	    }
+	}
+    }
 
   if (! error_state)
     {
+      if (first_expr_val.is_undefined ())
+	first_expr_val = expr->rvalue ();
+
+      octave_value tmp = first_expr_val;
+
       std::list<octave_value_list> idx;
 
       int n = args.size ();
 
       std::list<tree_argument_list *>::iterator p_args = args.begin ();
       std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
       std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
 
@@ -299,33 +326,39 @@ tree_index_expression::rvalue (int nargo
 		{
 		  // We have an expression like
 		  //
 		  //   x{end}.a(end)
 		  //
 		  // and we are looking at the argument list that
 		  // contains the second (or third, etc.) "end" token,
 		  // so we must evaluate everything up to the point of
-		  // that argument list so we pass the appropiate
+		  // that argument list so we can pass the appropriate
 		  // value to the built-in __end__ function.
 
 		  octave_value_list tmp_list
-		    = first_expr_val.subsref (type, idx, nargout);
+		    = first_expr_val.subsref (type.substr (0, i), idx, nargout);
 
 		  tmp = tmp_list(0);
 
 		  if (error_state)
 		    break;
 		}
 	    }
 
 	  switch (type[i])
 	    {
 	    case '(':
-	      idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
+	      if (have_args)
+		{
+		  idx.push_back (first_args);
+		  have_args = false;
+		}
+	      else
+		idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
 	      break;
 
 	    case '{':
 	      idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
 	      break;
 
 	    case '.':
 	      {
@@ -410,21 +443,21 @@ tree_index_expression::lvalue (void)
 		{
 		  // We have an expression like
 		  //
 		  //   x{end}.a(end)
 		  //
 		  // and we are looking at the argument list that
 		  // contains the second (or third, etc.) "end" token,
 		  // so we must evaluate everything up to the point of
-		  // that argument list so we pass the appropiate
+		  // that argument list so we pass the appropriate
 		  // value to the built-in __end__ function.
 
 		  octave_value_list tmp_list
-		    = first_retval_object.subsref (type, idx, 1);
+		    = first_retval_object.subsref (type.substr (0, i), idx, 1);
 
 		  tmp = tmp_list(0);
 
 		  if (error_state)
 		    break;
 		}
 	    }
 
@@ -651,49 +684,49 @@ tree_index_expression::eval_error (void)
 
   if (l != -1 && c != -1)
     ::error ("evaluating %s near line %d, column %d", type_str, l, c);
   else
     ::error ("evaluating %s", type_str);
 }
 
 tree_index_expression *
-tree_index_expression::dup (symbol_table *sym_tab)
+tree_index_expression::dup (symbol_table::scope_id scope)
 {
   tree_index_expression *new_idx_expr
     = new tree_index_expression (line (), column ());
 
-  new_idx_expr->expr = expr ? expr->dup (sym_tab) : 0;
+  new_idx_expr->expr = expr ? expr->dup (scope) : 0;
 
   std::list<tree_argument_list *> new_args;
 
   for (std::list<tree_argument_list *>::iterator p = args.begin ();
        p != args.end ();
        p++)
     {
       tree_argument_list *elt = *p;
 
-      new_args.push_back (elt ? elt->dup (sym_tab) : 0);
+      new_args.push_back (elt ? elt->dup (scope) : 0);
     }
 
   new_idx_expr->args = new_args;
   
   new_idx_expr->type = type;
 
   new_idx_expr->arg_nm = arg_nm;
 
   std::list<tree_expression *> new_dyn_field;
 
   for (std::list<tree_expression *>::iterator p = dyn_field.begin ();
        p != dyn_field.end ();
        p++)
     {
       tree_expression *elt = *p;
 
-      new_dyn_field.push_back (elt ? elt->dup (sym_tab) : 0);
+      new_dyn_field.push_back (elt ? elt->dup (scope) : 0);
     }
 
   new_idx_expr->dyn_field = new_dyn_field;
 
   new_idx_expr->copy_base (*this);
   
   return new_idx_expr;
 }
diff --git a/src/pt-idx.h b/src/pt-idx.h
--- a/src/pt-idx.h
+++ b/src/pt-idx.h
@@ -33,16 +33,17 @@ class tree_walker;
 class Octave_map;
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "str-vec.h"
 
 #include "pt-exp.h"
+#include "symtab.h"
 
 // Index expressions.
 
 class
 tree_index_expression : public tree_expression
 {
 public:
 
@@ -84,17 +85,17 @@ public:
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
   void eval_error (void) const;
 
-  tree_index_expression *dup (symbol_table *sym_tab);
+  tree_index_expression *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The LHS of this index expression.
   tree_expression *expr;
 
diff --git a/src/pt-jump.cc b/src/pt-jump.cc
--- a/src/pt-jump.cc
+++ b/src/pt-jump.cc
@@ -44,17 +44,17 @@ tree_break_command::eval (void)
   // Even if we have an error we should still enter debug mode.
   MAYBE_DO_BREAKPOINT;
 
   if (! error_state)
     breaking = 1;
 }
 
 tree_command *
-tree_break_command::dup (symbol_table *)
+tree_break_command::dup (symbol_table::scope_id)
 {
   return new tree_break_command (line (), column ());
 }
 
 void
 tree_break_command::accept (tree_walker& tw)
 {
   tw.visit_break_command (*this);
@@ -70,17 +70,17 @@ tree_continue_command::eval (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   if (! error_state)
     continuing = 1;
 }
 
 tree_command *
-tree_continue_command::dup (symbol_table *)
+tree_continue_command::dup (symbol_table::scope_id)
 {
   return new tree_continue_command (line (), column ());
 }
 
 void
 tree_continue_command::accept (tree_walker& tw)
 {
   tw.visit_continue_command (*this);
@@ -96,17 +96,17 @@ tree_return_command::eval (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   if (! error_state)
     returning = 1;
 }
 
 tree_command *
-tree_return_command::dup (symbol_table *)
+tree_return_command::dup (symbol_table::scope_id)
 {
   return new tree_return_command (line (), column ());
 }
 
 void
 tree_return_command::accept (tree_walker& tw)
 {
   tw.visit_return_command (*this);
diff --git a/src/pt-jump.h b/src/pt-jump.h
--- a/src/pt-jump.h
+++ b/src/pt-jump.h
@@ -21,32 +21,33 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_tree_jump_h)
 #define octave_tree_jump_h 1
 
 class tree_walker;
 
 #include "pt-cmd.h"
+#include "symtab.h"
 
 // Break.
 
 class
 tree_break_command : public tree_command
 {
 public:
 
   tree_break_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_break_command (void) { }
 
   void eval (void);
 
-  tree_command *dup (symbol_table *);
+  tree_command *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
   static int breaking;
 
 private:
 
   // No copying!
@@ -65,17 +66,17 @@ public:
 
   tree_continue_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_continue_command (void) { }
 
   void eval (void);
 
-  tree_command *dup (symbol_table *);
+  tree_command *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
   static int continuing;
 
 private:
 
   // No copying!
@@ -94,17 +95,17 @@ public:
 
   tree_return_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_return_command (void) { }
 
   void eval (void);
 
-  tree_command *dup (symbol_table *);
+  tree_command *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
   static int returning;
 
 private:
 
   // No copying!
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -121,20 +121,20 @@ tree_while_command::eval (void)
 void
 tree_while_command::eval_error (void)
 {
   ::error ("evaluating while command near line %d, column %d",
 	   line (), column ());
 }
 
 tree_command *
-tree_while_command::dup (symbol_table *sym_tab)
+tree_while_command::dup (symbol_table::scope_id scope)
 {
-  return new tree_while_command (expr ? expr->dup (sym_tab) : 0,
-				 list ? list->dup (sym_tab) : 0,
+  return new tree_while_command (expr ? expr->dup (scope) : 0,
+				 list ? list->dup (scope) : 0,
 				 lead_comm ? lead_comm->dup () : 0,
 				 trail_comm ? trail_comm->dup (): 0,
 				 line (), column ());
 }
 
 void
 tree_while_command::accept (tree_walker& tw)
 {
@@ -184,20 +184,20 @@ tree_do_until_command::eval (void)
 void
 tree_do_until_command::eval_error (void)
 {
   ::error ("evaluating do-until command near line %d, column %d",
 	   line (), column ());
 }
 
 tree_command *
-tree_do_until_command::dup (symbol_table *sym_tab)
+tree_do_until_command::dup (symbol_table::scope_id scope)
 {
-  return new tree_do_until_command (expr ? expr->dup (sym_tab) : 0,
-				    list ? list->dup (sym_tab) : 0,
+  return new tree_do_until_command (expr ? expr->dup (scope) : 0,
+				    list ? list->dup (scope) : 0,
 				    lead_comm ? lead_comm->dup () : 0,
 				    trail_comm ? trail_comm->dup (): 0,
 				    line (), column ());
 }
 
 void
 tree_do_until_command::accept (tree_walker& tw)
 {
@@ -482,21 +482,21 @@ tree_simple_for_command::eval (void)
 void
 tree_simple_for_command::eval_error (void)
 {
   ::error ("evaluating for command near line %d, column %d",
 	   line (), column ());
 }
 
 tree_command *
-tree_simple_for_command::dup (symbol_table *sym_tab)
+tree_simple_for_command::dup (symbol_table::scope_id scope)
 {
-  return new tree_simple_for_command (lhs ? lhs->dup (sym_tab) : 0,
-				      expr ? expr->dup (sym_tab) : 0,
-				      list ? list->dup (sym_tab) : 0,
+  return new tree_simple_for_command (lhs ? lhs->dup (scope) : 0,
+				      expr ? expr->dup (scope) : 0,
+				      list ? list->dup (scope) : 0,
 				      lead_comm ? lead_comm->dup () : 0,
 				      trail_comm ? trail_comm->dup () : 0,
 				      line (), column ());
 }
 
 void
 tree_simple_for_command::accept (tree_walker& tw)
 {
@@ -603,21 +603,21 @@ tree_complex_for_command::eval (void)
 void
 tree_complex_for_command::eval_error (void)
 {
   ::error ("evaluating for command near line %d, column %d",
 	   line (), column ());
 }
 
 tree_command *
-tree_complex_for_command::dup (symbol_table *sym_tab)
+tree_complex_for_command::dup (symbol_table::scope_id scope)
 {
-  return new tree_complex_for_command (lhs ? lhs->dup (sym_tab) : 0,
-				      expr ? expr->dup (sym_tab) : 0,
-				      list ? list->dup (sym_tab) : 0,
+  return new tree_complex_for_command (lhs ? lhs->dup (scope) : 0,
+				      expr ? expr->dup (scope) : 0,
+				      list ? list->dup (scope) : 0,
 				      lead_comm ? lead_comm->dup () : 0,
 				      trail_comm ? trail_comm->dup () : 0,
 				      line (), column ());
 }
 
 void
 tree_complex_for_command::accept (tree_walker& tw)
 {
diff --git a/src/pt-loop.h b/src/pt-loop.h
--- a/src/pt-loop.h
+++ b/src/pt-loop.h
@@ -30,16 +30,17 @@ class octave_lvalue;
 class tree_argument_list;
 class tree_expression;
 class tree_statement_list;
 
 class tree_walker;
 
 #include "comment-list.h"
 #include "pt-cmd.h"
+#include "symtab.h"
 
 // TRUE means we are evaluating some kind of looping construct.
 extern bool evaluating_looping_command;
 
 // While.
 
 class
 tree_while_command : public tree_command
@@ -73,17 +74,17 @@ public:
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table *sym_tab);
+  tree_command *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 protected:
 
   // Expression to test.
   tree_expression *expr;
 
@@ -128,17 +129,17 @@ public:
     : tree_while_command (e, lst, lc, tc, l, c) { }
 
   ~tree_do_until_command (void) { }
 
   void eval (void);
 
   void eval_error (void);
 
-  tree_command *dup (symbol_table *sym_tab);
+  tree_command *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_do_until_command (const tree_do_until_command&);
@@ -176,17 +177,17 @@ public:
   tree_expression *control_expr (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table *sym_tab);
+  tree_command *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // Expression to modify.
   tree_expression *lhs;
 
@@ -240,17 +241,17 @@ public:
   tree_expression *control_expr (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table *sym_tab);
+  tree_command *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // Expression to modify.
   tree_argument_list *lhs;
 
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -946,25 +946,25 @@ tree_matrix::rvalue (void)
 	}
     }
 
 done:
   return retval;
 }
 
 tree_expression *
-tree_matrix::dup (symbol_table *sym_tab)
+tree_matrix::dup (symbol_table::scope_id scope)
 {
   tree_matrix *new_matrix = new tree_matrix (0, line (), column ());
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_argument_list *elt = *p;
 
-      new_matrix->append (elt ? elt->dup (sym_tab) : 0);
+      new_matrix->append (elt ? elt->dup (scope) : 0);
     }
 
   new_matrix->copy_base (*this);
 
   return new_matrix;
 }
 
 void
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -29,16 +29,17 @@ along with Octave; see the file COPYING.
 class octave_value;
 class octave_value_list;
 class tree_argument_list;
 
 class tree_walker;
 
 #include "base-list.h"
 #include "pt-exp.h"
+#include "symtab.h"
 
 // General matrices.  This allows us to construct matrices from
 // other matrices, variables, and functions.
 
 class
 tree_matrix : public tree_expression,
 	      public octave_base_list<tree_argument_list *>
 {
@@ -58,17 +59,17 @@ public:
   bool all_elements_are_constant (void) const;
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  tree_expression *dup (symbol_table *sym_tab);
+  tree_expression *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_matrix (const tree_matrix&);
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -70,17 +70,17 @@ tree_parameter_list::initialize_undefine
 
   for (iterator p = begin (); p != end (); p++)
     {
       if (++count > nargout)
 	break;
 
       tree_decl_elt *elt = *p;
 
-      if (! elt->is_defined ())
+      if (! elt->is_variable ())
 	{
 	  if (! warned)
 	    {
 	      warned = true;
 
 	      warning_with_id
 		("Octave:undefined-return-values",
 		 "%s: some elements in list of return values are undefined",
@@ -172,39 +172,39 @@ bool
 tree_parameter_list::is_defined (void)
 {
   bool status = true;
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_decl_elt *elt = *p;
 
-      if (! elt->is_defined ())
+      if (! elt->is_variable ())
 	{
 	  status = false;
 	  break;
 	}
     }
 
   return status;
 }
 
 tree_parameter_list *
-tree_parameter_list::dup (symbol_table *sym_tab)
+tree_parameter_list::dup (symbol_table::scope_id scope)
 {
   tree_parameter_list *new_list = new tree_parameter_list ();
 
   if (takes_varargs ())
     new_list->mark_varargs ();
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_decl_elt *elt = *p;
 
-      new_list->append (elt->dup (sym_tab));
+      new_list->append (elt->dup (scope));
     }
 
   return new_list;
 }
 
 void
 tree_parameter_list::accept (tree_walker& tw)
 {
@@ -219,25 +219,25 @@ tree_return_list::~tree_return_list (voi
     {
       iterator p = begin ();
       delete *p;
       erase (p);
     }
 }
 
 tree_return_list *
-tree_return_list::dup (symbol_table *sym_tab)
+tree_return_list::dup (symbol_table::scope_id scope)
 {
   tree_return_list *new_list = new tree_return_list ();
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_index_expression *elt = *p;
 
-      new_list->append (elt->dup (sym_tab));
+      new_list->append (elt->dup (scope));
     }
 
   return new_list;
 }
 
 void
 tree_return_list::accept (tree_walker& tw)
 {
diff --git a/src/pt-misc.h b/src/pt-misc.h
--- a/src/pt-misc.h
+++ b/src/pt-misc.h
@@ -32,16 +32,17 @@ class octave_value_list;
 class tree_identifier;
 class tree_index_expression;
 class tree_va_return_list;
 
 class tree_walker;
 
 #include "base-list.h"
 #include "pt-decl.h"
+#include "symtab.h"
 
 // Parameter lists.  Used to hold the list of input and output
 // parameters in a function definition.  Elements are identifiers
 // only.
 
 class
 tree_parameter_list : public octave_base_list<tree_decl_elt *>
 {
@@ -71,17 +72,17 @@ public:
   void define_from_arg_vector (const octave_value_list& args);
 
   void undefine (void);
 
   bool is_defined (void);
 
   octave_value_list convert_to_const_vector (const Cell& varargout);
 
-  tree_parameter_list *dup (symbol_table *sym_tab);
+  tree_parameter_list *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   int marked_for_varargs;
 
   // No copying!
@@ -100,17 +101,17 @@ tree_return_list : public octave_base_li
 public:
 
   tree_return_list (void) { }
 
   tree_return_list (tree_index_expression *t) { append (t); }
 
   ~tree_return_list (void);
 
-  tree_return_list *dup (symbol_table *sym_tab);
+  tree_return_list *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_return_list (const tree_return_list&);
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -55,20 +55,20 @@ tree_if_clause::eval (void)
 
       return 1;
     }
 
   return 0;
 }
 
 tree_if_clause *
-tree_if_clause::dup (symbol_table *sym_tab)
+tree_if_clause::dup (symbol_table::scope_id scope)
 {
-  return new tree_if_clause (expr ? expr->dup (sym_tab) : 0,
-			     list ? list->dup (sym_tab) : 0,
+  return new tree_if_clause (expr ? expr->dup (scope) : 0,
+			     list ? list->dup (scope) : 0,
 			     lead_comm ? lead_comm->dup () : 0);
 }
 
 void
 tree_if_clause::accept (tree_walker& tw)
 {
   tw.visit_if_clause (*this);
 }
@@ -83,25 +83,25 @@ tree_if_command_list::eval (void)
       tree_if_clause *t = *p;
 
       if (t->eval () || error_state)
 	break;
     }
 }
 
 tree_if_command_list *
-tree_if_command_list::dup (symbol_table *sym_tab)
+tree_if_command_list::dup (symbol_table::scope_id scope)
 {
   tree_if_command_list *new_icl = new tree_if_command_list ();
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_if_clause *elt = *p;
 
-      new_icl->append (elt ? elt->dup (sym_tab) : 0);
+      new_icl->append (elt ? elt->dup (scope) : 0);
     }
 
   return new_icl;
 }
 
 void
 tree_if_command_list::accept (tree_walker& tw)
 {
@@ -124,19 +124,19 @@ tree_if_command::eval (void)
     list->eval ();
 
   if (error_state)
     ::error ("evaluating if command near line %d, column %d",
 	     line (), column ());
 }
 
 tree_command *
-tree_if_command::dup (symbol_table *sym_tab)
+tree_if_command::dup (symbol_table::scope_id scope)
 {
-  return new tree_if_command (list ? list->dup (sym_tab) : 0,
+  return new tree_if_command (list ? list->dup (scope) : 0,
 			      lead_comm ? lead_comm->dup () : 0,
 			      trail_comm ? trail_comm->dup () : 0,
 			      line (), column ());
 }
 
 void
 tree_if_command::accept (tree_walker& tw)
 {
@@ -238,20 +238,20 @@ tree_switch_case::eval (const octave_val
 
 void
 tree_switch_case::eval_error (void)
 {
   ::error ("evaluating switch case label");
 }
 
 tree_switch_case *
-tree_switch_case::dup (symbol_table *sym_tab)
+tree_switch_case::dup (symbol_table::scope_id scope)
 {
-  return new tree_switch_case (label ? label->dup (sym_tab) : 0,
-			       list ? list->dup (sym_tab) : 0,
+  return new tree_switch_case (label ? label->dup (scope) : 0,
+			       list ? list->dup (scope) : 0,
 			       lead_comm ? lead_comm->dup () : 0);
 }
 
 void
 tree_switch_case::accept (tree_walker& tw)
 {
   tw.visit_switch_case (*this);
 }
@@ -266,25 +266,25 @@ tree_switch_case_list::eval (const octav
       tree_switch_case *t = *p;
 
       if (t->eval (val) || error_state)
 	break;
     }
 }
 
 tree_switch_case_list *
-tree_switch_case_list::dup (symbol_table *sym_tab)
+tree_switch_case_list::dup (symbol_table::scope_id scope)
 {
   tree_switch_case_list *new_scl = new tree_switch_case_list ();
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_switch_case *elt = *p;
 
-      new_scl->append (elt ? elt->dup (sym_tab) : 0);
+      new_scl->append (elt ? elt->dup (scope) : 0);
     }
   
   return new_scl;
 }
 
 void
 tree_switch_case_list::accept (tree_walker& tw)
 {
@@ -327,20 +327,20 @@ tree_switch_command::eval (void)
 void
 tree_switch_command::eval_error (void)
 {
   ::error ("evaluating switch command near line %d, column %d",
 	   line (), column ());
 }
 
 tree_command *
-tree_switch_command::dup (symbol_table *sym_tab)
+tree_switch_command::dup (symbol_table::scope_id scope)
 {
-  return new tree_switch_command (expr ? expr->dup (sym_tab) : 0,
-				  list ? list->dup (sym_tab) : 0,
+  return new tree_switch_command (expr ? expr->dup (scope) : 0,
+				  list ? list->dup (scope) : 0,
 				  lead_comm ? lead_comm->dup () : 0,
 				  trail_comm ? trail_comm->dup () : 0,
 				  line (), column ());
 }
 
 void
 tree_switch_command::accept (tree_walker& tw)
 {
diff --git a/src/pt-select.h b/src/pt-select.h
--- a/src/pt-select.h
+++ b/src/pt-select.h
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 class expression;
 class tree_statement_list;
 
 class tree_walker;
 
 #include "base-list.h"
 #include "comment-list.h"
 #include "pt-cmd.h"
+#include "symtab.h"
 
 // If.
 
 class
 tree_if_clause
 {
 public:
 
@@ -58,17 +59,17 @@ public:
   int eval (void);
 
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *commands (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
-  tree_if_clause *dup (symbol_table *sym_tab);
+  tree_if_clause *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The condition to test.
   tree_expression *expr;
 
@@ -101,17 +102,17 @@ public:
 	  iterator p = begin ();
 	  delete *p;
 	  erase (p);
 	}
     }
 
   void eval (void);
 
-  tree_if_command_list *dup (symbol_table *sym_tab);
+  tree_if_command_list *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_if_command_list (const tree_if_command_list&);
@@ -136,17 +137,17 @@ public:
   void eval (void);
 
   tree_if_command_list *cmd_list (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table *sym_tab);
+  tree_command *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // List of if commands (if, elseif, elseif, ... else, endif)
   tree_if_command_list *list;
 
@@ -191,17 +192,17 @@ public:
   void eval_error (void);
 
   tree_expression *case_label (void) { return label; }
 
   tree_statement_list *commands (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
-  tree_switch_case *dup (symbol_table *sym_tab);
+  tree_switch_case *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The case label.
   tree_expression *label;
 
@@ -234,17 +235,17 @@ public:
 	  iterator p = begin ();
 	  delete *p;
 	  erase (p);
 	}
     }
 
   void eval (const octave_value& val);
 
-  tree_switch_case_list *dup (symbol_table *sym_tab);
+  tree_switch_case_list *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_switch_case_list (const tree_switch_case_list&);
@@ -276,17 +277,17 @@ public:
   tree_expression *switch_value (void) { return expr; }
 
   tree_switch_case_list *case_list (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table *sym_tab);
+  tree_command *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // Value on which to switch.
   tree_expression *expr;
 
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -110,52 +110,45 @@ tree_statement::eval (bool silent, int n
 	  // printing the result.
 
 	  // FIXME -- it seems that we should just have to
 	  // call expr->rvalue () and that should take care of
 	  // everything, binding ans as necessary?
 
 	  bool do_bind_ans = false;
 
-	  bool script_file_executed = false;
-
 	  if (expr->is_identifier ())
 	    {
 	      tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
-	      id->do_lookup (script_file_executed, true);
-
-	      do_bind_ans = id->is_function ();
+	      do_bind_ans = (! id->is_variable ());
 	    }
 	  else
 	    do_bind_ans = (! expr->is_assignment_expression ());
 
-	  if (! script_file_executed)
-	    {
-	      retval = expr->rvalue (nargout);
+	  retval = expr->rvalue (nargout);
 
-	      if (do_bind_ans && ! (error_state || retval.empty ()))
-		bind_ans (retval(0), pf);
-	    }
+	  if (do_bind_ans && ! (error_state || retval.empty ()))
+	    bind_ans (retval(0), pf);
 	}
 
       unwind_protect::run ();
     }
 
   return retval;
 }
 
 tree_statement *
-tree_statement::dup (symbol_table *sym_tab)
+tree_statement::dup (symbol_table::scope_id scope)
 {
   tree_statement *new_stmt = new tree_statement ();
 
-  new_stmt->cmd = cmd ? cmd->dup (sym_tab) : 0;
+  new_stmt->cmd = cmd ? cmd->dup (scope) : 0;
 
-  new_stmt->expr = expr ? expr->dup (sym_tab) : 0;
+  new_stmt->expr = expr ? expr->dup (scope) : 0;
 
   new_stmt->comm = comm ? comm->dup () : 0;
 
   new_stmt->print_flag = print_flag;
 
   return new_stmt;
 }
 
@@ -263,27 +256,27 @@ tree_statement_list::list_breakpoints (v
 {
   tree_breakpoint tbp (0, tree_breakpoint::list);
   accept (tbp);
 
   return tbp.get_list ();
 }
 
 tree_statement_list *
-tree_statement_list::dup (symbol_table *sym_tab)
+tree_statement_list::dup (symbol_table::scope_id scope)
 {
   tree_statement_list *new_list = new tree_statement_list ();
 
   new_list->function_body = function_body;
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_statement *elt = *p;
 
-      new_list->append (elt ? elt->dup (sym_tab) : 0);
+      new_list->append (elt ? elt->dup (scope) : 0);
     }
 
   return new_list;
 }
 
 void
 tree_statement_list::accept (tree_walker& tw)
 {
diff --git a/src/pt-stmt.h b/src/pt-stmt.h
--- a/src/pt-stmt.h
+++ b/src/pt-stmt.h
@@ -28,16 +28,17 @@ class octave_value_list;
 
 class tree_command;
 class tree_expression;
 
 class tree_walker;
 
 #include "base-list.h"
 #include "comment-list.h"
+#include "symtab.h"
 
 // A statement is either a command to execute or an expression to
 // evaluate.
 
 class
 tree_statement
 {
 public:
@@ -77,17 +78,17 @@ public:
   // Allow modification of this statement.  Note that there is no
   // checking.  If you use these, are you sure you knwo what you are
   // doing?
 
   void set_command (tree_command *c) { cmd = c; }
 
   void set_expression (tree_expression *e) { expr = e; }
 
-  tree_statement *dup (symbol_table *sym_tab);
+  tree_statement *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // Only one of cmd or expr can be valid at once.
 
   // Command to execute.
@@ -136,17 +137,17 @@ public:
   octave_value_list eval (bool silent = false, int nargout = 0);
 
   int set_breakpoint (int line);
 
   void delete_breakpoint (int line);
 
   octave_value_list list_breakpoints (void);
 
-  tree_statement_list *dup (symbol_table *sym_tab);
+  tree_statement_list *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // Does this list of statements make up the body of a function?
   bool function_body;
 
diff --git a/src/pt-unop.cc b/src/pt-unop.cc
--- a/src/pt-unop.cc
+++ b/src/pt-unop.cc
@@ -116,20 +116,20 @@ tree_prefix_expression::rvalue (void)
 void
 tree_prefix_expression::eval_error (void)
 {
   ::error ("evaluating prefix operator `%s' near line %d, column %d",
 	   oper () . c_str (), line (), column ());
 }
 
 tree_expression *
-tree_prefix_expression::dup (symbol_table *sym_tab)
+tree_prefix_expression::dup (symbol_table::scope_id scope)
 {
   tree_prefix_expression *new_pe
-    = new tree_prefix_expression (op ? op->dup (sym_tab) : 0,
+    = new tree_prefix_expression (op ? op->dup (scope) : 0,
 				  line (), column (), etype);
 
   new_pe->copy_base (*this);
 
   return new_pe;
 }
 
 void
@@ -213,20 +213,20 @@ tree_postfix_expression::rvalue (void)
 void
 tree_postfix_expression::eval_error (void)
 {
   ::error ("evaluating postfix operator `%s' near line %d, column %d",
 	   oper () . c_str (), line (), column ());
 }
 
 tree_expression *
-tree_postfix_expression::dup (symbol_table *sym_tab)
+tree_postfix_expression::dup (symbol_table::scope_id scope)
 {
   tree_postfix_expression *new_pe
-    = new tree_postfix_expression (op ? op->dup (sym_tab) : 0,
+    = new tree_postfix_expression (op ? op->dup (scope) : 0,
 				   line (), column (), etype);
 
   new_pe->copy_base (*this);
 
   return new_pe;
 }
 
 void
diff --git a/src/pt-unop.h b/src/pt-unop.h
--- a/src/pt-unop.h
+++ b/src/pt-unop.h
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 
 class tree_walker;
 
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "pt-exp.h"
+#include "symtab.h"
 
 // Unary expressions.
 
 class
 tree_unary_expression : public tree_expression
 {
 public:
 
@@ -98,17 +99,17 @@ public:
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (void);
 
-  tree_expression *dup (symbol_table *sym_tab);
+  tree_expression *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_prefix_expression (const tree_prefix_expression&);
@@ -136,17 +137,17 @@ public:
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (void);
 
-  tree_expression *dup (symbol_table *sym_tab);
+  tree_expression *dup (symbol_table::scope_id scope);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_postfix_expression (const tree_postfix_expression&);
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1,13 +1,13 @@
 /*
 
 Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
               2002, 2003, 2004, 2005, 2006, 2007 John W. Eaton
-
+  
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
 Octave is distributed in the hope that it will be useful, but WITHOUT
@@ -20,1991 +20,786 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <cassert>
-#include <cctype>
-#include <climits>
-#include <cstdio>
-
-#include <iomanip>
-#include <fstream>
-#include <sstream>
-
-#include "glob-match.h"
-#include "str-vec.h"
+#include "oct-env.h"
+#include "oct-time.h"
+#include "file-ops.h"
+#include "file-stat.h"
 
 #include "defun.h"
-#include "error.h"
-#include "oct-lvalue.h"
-#include "ov.h"
-#include "pt-pr-code.h"
+#include "dirfns.h"
+#include "input.h"
+#include "load-path.h"
 #include "symtab.h"
+#include "ov-fcn.h"
+#include "pager.h"
+#include "parse.h"
+#include "pt-arg-list.h"
+#include "toplev.h"
+#include "unwind-prot.h"
 #include "utils.h"
-#include "variables.h"
-#include "ov-usr-fcn.h"
-#include "toplev.h"
+
+symbol_table *symbol_table::instance = 0;
 
-#include "gripes.h"
-#include "lo-mappers.h"
+std::map<symbol_table::scope_id, symbol_table*> symbol_table::all_instances;
 
-#include "parse.h"
+std::map<std::string, symbol_table::fcn_info> symbol_table::fcn_table;
 
-unsigned long int symbol_table::symtab_count = 0;
+const symbol_table::scope_id symbol_table::xglobal_scope = 0;
+const symbol_table::scope_id symbol_table::xtop_scope = 1;
 
-// Should variables be allowed to hide functions of the same name?  A
-// positive value means yes.  A negative value means yes, but print a
-// warning message.  Zero means it should be considered an error.
-static int Vvariables_can_hide_functions = 1;
+symbol_table::scope_id symbol_table::xcurrent_scope = 1;
+symbol_table::scope_id symbol_table::xcurrent_caller_scope = -1;
 
-// Nonzero means we print debugging info about symbol table lookups.
-static bool Vdebug_symtab_lookups = false;
+symbol_table::scope_id symbol_table::xparent_scope = -1;
+
+std::deque<symbol_table::scope_id> symbol_table::scope_stack;
 
-// Defines layout for the whos/who -long command
-std::string Vwhos_line_format
-  = "  %p:4; %ln:6; %cs:16:6:8:1;  %rb:12;  %lc:-1;\n";
-
-octave_allocator
-symbol_record::symbol_def::allocator (sizeof (symbol_record::symbol_def));
+symbol_table::scope_id symbol_table::next_available_scope = 2;
+std::set<symbol_table::scope_id> symbol_table::scope_ids_in_use;
+std::set<symbol_table::scope_id> symbol_table::scope_ids_free_list;
 
-#define SYMBOL_DEF symbol_record::symbol_def
-
-std::string
-SYMBOL_DEF::type_as_string (void) const
-{
-  std::string retval = "<unknown type>";
+// Should Octave always check to see if function files have changed
+// since they were last compiled?
+static int Vignore_function_time_stamp = 1;
 
-  if (is_user_variable ())
-    retval = "user-defined variable";
-  else if (is_command ())
-    retval = "built-in command";
-  else if (is_mapper_function ())
-    retval = "built-in mapper function";
-  else if (is_user_function ())
-    retval = "user-defined function";
-  else if (is_builtin_function ())
-    retval = "built-in function";
-  else if (is_dld_function ())
-    retval = "dynamically-linked function";
-  else if (is_mex_function ())
-    retval = "dynamically-linked mex function";
+octave_value
+symbol_table::symbol_record::find (tree_argument_list *args,
+				   const string_vector& arg_names,
+				   octave_value_list& evaluated_args,
+				   bool& args_evaluated) const
+{
+  octave_value retval;
 
-  return retval;
+  if (is_global ())
+    return symbol_table::varref (name (), symbol_table::xglobal_scope);
+  else
+    {
+      octave_value val = varval ();
+
+      if (val.is_defined ())
+	return val;
+    }
+
+  return symbol_table::find_function (name (), args, arg_names,
+				      evaluated_args, args_evaluated);
 }
 
-void
-SYMBOL_DEF::type (std::ostream& os, const std::string& name, bool pr_type_info,
-		  bool quiet, bool pr_orig_txt)
-{
-  if (is_user_function ())
-    {
-      octave_function *defn = definition.function_value ();
-
-      std::string fn = defn ? defn->fcn_file_name () : std::string ();
-
-      if (pr_orig_txt && ! fn.empty ())
-	{
-	  std::ifstream fs (fn.c_str (), std::ios::in);
-
-	  if (fs)
-	    {
-	      if (pr_type_info && ! quiet)
-		os << name << " is the " << type_as_string ()
-		   << " defined from: " << fn << "\n\n";
-
-	      char ch;
-
-	      while (fs.get (ch))
-		os << ch;
-	    }
-	  else
-	    os << "unable to open `" << fn << "' for reading!\n";
-	}
-      else
-	{
-	  if (pr_type_info && ! quiet)
-	    os << name << " is a " << type_as_string () << ":\n\n";
-
-	  tree_print_code tpc (os, "", pr_orig_txt);
-
-	  defn->accept (tpc);
-	}
-    }
-  else if (is_user_variable ())
-    {
-      if (pr_type_info && ! quiet)
-	os << name << " is a " << type_as_string () << "\n";
-
-      definition.print_raw (os, true);
-
-      if (pr_type_info)
-	os << "\n";
-    }
-  else
-    os << name << " is a " << type_as_string () << "\n";
-}
-
-std::string
-SYMBOL_DEF::which (const std::string& name)
-{
-  std::string retval;
-
-  if (is_user_function () || is_dld_function () || is_mex_function ())
-    {
-      octave_function *defn = definition.function_value ();
-
-      if (defn)
-	retval = defn->fcn_file_name ();
-    }
-  else
-    retval = name + " is a " + type_as_string ();
+// Check the load path to see if file that defined this is still
+// visible.  If the file is no longer visible, then erase the
+// definition and move on.  If the file is visible, then we also
+// need to check to see whether the file has changed since the the
+// function was loaded/parsed.  However, this check should only
+// happen once per prompt (for files found from relative path
+// elements, we also check if the working directory has changed
+// since the last time the function was loaded/parsed).
+//
+// FIXME -- perhaps this should be done for all loaded functions when
+// the prompt is printed or the directory has changed, and then we
+// would not check for it when finding symbol definitions.
 
-  return retval;
-}
-
-void
-SYMBOL_DEF::which (std::ostream& os, const std::string& name)
-{
-  os << name;
-
-  if (is_user_function () || is_dld_function () || is_mex_function ())
-    {
-      octave_function *defn = definition.function_value ();
-
-      std::string fn = defn ? defn->fcn_file_name () : std::string ();
-
-      if (! fn.empty ())
-	{
-	  os << " is the " << type_as_string () << " from the file\n"
-	     << fn << "\n";
-
-	  return;
-	}
-    }
-
-  os << " is a " << type_as_string () << "\n";
-}
-
-void
-SYMBOL_DEF::document (const std::string& h)
-{
-  help_string = h;
-
-  if (is_function ())
-    {
-      octave_function *defn = definition.function_value ();
-
-      if (defn)
-	defn->document (h);
-    }
-}
-
-
-void
-SYMBOL_DEF::print_info (std::ostream& os, const std::string& prefix) const
-{
-  os << prefix << "symbol_def::count: " << count << "\n";
-
-  definition.print_info (os, prefix + "  ");
-}
-
-// Individual records in a symbol table.
-
-void
-symbol_record::rename (const std::string& new_name)
-{
-  if (! read_only_error ("rename"))
-    nm = new_name;
-}
-
-void
-symbol_record::define (const octave_value& v, unsigned int sym_type)
-{
-  if (! (is_variable () && read_only_error ("redefine")))
-    definition->define (v, sym_type);
-}
-
-bool
-symbol_record::define (octave_function *f, unsigned int sym_type)
+static inline bool
+out_of_date_check_internal (octave_value& function)
 {
   bool retval = false;
 
-  if (! read_only_error ("redefine"))
-    {
-      maybe_delete_def ();
-
-      octave_value tmp (f);
-
-      definition = new symbol_def (tmp, sym_type);
-
-      retval = true;
-    }
-
-  return retval;
-}
-
-void
-symbol_record::clear (void)
-{
-  if (is_defined ())
-    {
-      if (! (tagged_static || is_eternal ()))
-	{
-	  while (! aliases_to_clear.empty ())
-	    {
-	      symbol_record *sr = aliases_to_clear.top ();
-	      aliases_to_clear.pop ();
-	      sr->clear ();
-	    }
-
-	  maybe_delete_def ();
-
-	  definition = new symbol_def ();
-	}
-
-      if (linked_to_global)
-	linked_to_global = 0;
-    }
-}
-
-void
-symbol_record::alias (symbol_record *s, bool mark_to_clear)
-{
-  chg_fcn = s->chg_fcn;
-
-  maybe_delete_def ();
-
-  if (mark_to_clear)
-    s->push_alias_to_clear (this);
-
-  definition = s->definition;
-
-  definition->count++;
-}
-
-void
-symbol_record::mark_as_formal_parameter (void)
-{
-  if (is_linked_to_global ())
-    error ("can't mark global variable `%s' as function parameter",
-	   nm.c_str ());
-  else if (is_static ())
-    error ("can't mark static variable `%s' as function parameter",
-	   nm.c_str ());
-  else
-    formal_param = 1;
-}
-
-void
-symbol_record::mark_as_automatic_variable (void)
-{
-  if (is_linked_to_global ())
-    error ("can't mark global variable `%s' as automatic variable",
-	   nm.c_str ());
-  else if (is_static ())
-    error ("can't mark static variable `%s' as automatic variable",
-	   nm.c_str ());
-  else
-    automatic_variable = 1;
-}
+  octave_function *fcn = function.function_value (true);
 
-void
-symbol_record::mark_as_linked_to_global (void)
-{
-  if (is_formal_parameter ())
-    error ("can't make function parameter `%s' global", nm.c_str ());
-  else if (is_static ())
-    error ("can't make static variable `%s' global", nm.c_str ());
-  else
-    linked_to_global = 1;
-}
-
-void
-symbol_record::mark_as_static (void)
-{
-  if (is_linked_to_global ())
-    error ("can't make global variable `%s' static", nm.c_str ());
-  else if (is_formal_parameter ())
-    error ("can't make formal parameter `%s' static", nm.c_str ());
-  else
-    tagged_static = 1;
-}
-
-octave_value&
-symbol_record::variable_value (void)
-{
-  static octave_value foo;
-
-  return is_variable () ? def () : foo;
-}
-
-octave_lvalue
-symbol_record::variable_reference (void)
-{
-  if ((Vvariables_can_hide_functions <= 0 || ! can_hide_function)
-      && (is_function ()
-	  || (! is_defined () && is_valid_function (nm))))
-    {
-      if (Vvariables_can_hide_functions < 0 && can_hide_function)
-	warning ("variable `%s' hides function", nm.c_str ());
-      else
-	{
-	  error ("variable `%s' hides function", nm.c_str ());
-	  return octave_lvalue ();
-	}
-    }
-
-  if (is_function ())
-    clear ();
-
-  if (! is_defined ())
-    {
-      octave_value tmp;
-      define (tmp);
-    }
-
-  return octave_lvalue (&(def ()), chg_fcn);
-}
-
-void
-symbol_record::push_context (void)
-{
-  if (! is_static ())
-    {
-      context.push (definition);
-
-      definition = new symbol_def ();
-
-      global_link_context.push (static_cast<unsigned int> (linked_to_global));
-
-      linked_to_global = 0;
-    }
-}
-
-void
-symbol_record::pop_context (void)
-{
-  // It is possible for context to be empty if new symbols have been
-  // inserted in the symbol table during recursive calls.  This can
-  // happen as a result of calls to eval() and feval().
-
-  if (! context.empty ())
+  if (fcn)
     {
-      maybe_delete_def ();
-
-      definition = context.top ();
-      context.pop ();
-
-      linked_to_global = global_link_context.top ();
-      global_link_context.pop ();
-    }
-}
-
-// Calculate how much space needs to be reserved for the first part of
-// the dimensions string.  For example,
-//
-//   mat is a 12x3 matrix
-//            ^^  => 2 columns
+      // FIXME -- we need to handle nested functions properly here.
 
-int
-symbol_record::dimensions_string_req_first_space (int print_dims) const
-{
-  int first_param_space = 0;
-
-  // Calculating dimensions.
-
-  std::string dim_str = "";
-  std::stringstream ss;
-  dim_vector dimensions = dims ();
-  long dim = dimensions.length ();
-
-  first_param_space = (first_param_space >= 1 ? first_param_space : 1);
-
-  // Preparing dimension string.
-
-  if ((dim <= print_dims || print_dims < 0) && print_dims != 0)
-    {
-      // Dimensions string must be printed like this: 2x3x4x2.
+      if (! fcn->is_nested_function ())
+	{
+	  std::string ff = fcn->fcn_file_name ();
 
-      if (dim == 0 || dim == 1)
-	first_param_space = 1; // First parameter is 1.
-      else
-        {
-	  ss << dimensions (0);
-	 
-	  dim_str = ss.str ();
-	  first_param_space = dim_str.length ();
-	}
-    }
-  else
-    {
-      // Printing dimension string as: a-D.
-
-      ss << dim;
-
-      dim_str = ss.str ();
-      first_param_space = dim_str.length ();
-    }
+	  if (! ff.empty ())
+	    {
+	      octave_time tc = fcn->time_checked ();
 
-  return first_param_space;
-}
-
-// Calculate how much space needs to be reserved for the
-// dimensions string.  For example,
-//
-//   mat is a 12x3 matrix
-//            ^^^^ => 4 columns
-//
-// FIXME -- why not just use the dim_vector::str () method?
-
-int
-symbol_record::dimensions_string_req_total_space (int print_dims) const
-{
-  std::string dim_str = "";
-  std::stringstream ss;
-
-  ss << make_dimensions_string (print_dims);
-  dim_str = ss.str ();
-
-  return dim_str.length ();
-}
+	      bool relative = fcn->is_relative ();
 
-// Make the dimensions-string.  For example: mat is a 2x3 matrix.
-//                                                    ^^^
-//
-// FIXME -- why not just use the dim_vector::str () method?
-
-std::string
-symbol_record::make_dimensions_string (int print_dims) const
-{
-  // Calculating dimensions.
-
-  std::string dim_str = "";
-  std::stringstream ss;
-  dim_vector dimensions = dims ();
-  long dim = dimensions.length ();
-
-  // Preparing dimension string.
-
-  if ((dim <= print_dims || print_dims < 0) && print_dims != 0)
-    {
-      // Only printing the dimension string as: axbxc...
-
-      if (dim == 0)
-	ss << "1x1";
-      else
-        {
-	  for (int i = 0; i < dim; i++)
-	    {
-	      if (i == 0)
+	      if (tc < Vlast_prompt_time
+		  || (relative && tc < Vlast_chdir_time))
 		{
-		  if (dim == 1)
-		    {
-		      // Looks like this is not going to happen in
-		      // Octave, but ...
+		  octave_time ottp = fcn->time_parsed ();
+		  time_t tp = ottp.unix_time ();
 
-		      ss << "1x" << dimensions (i);
-		    }
-		  else
-		    ss << dimensions (i);
-		}
-	      else if (i < dim && dim != 1)
-		ss << "x" << dimensions (i);
-	    }
-	}
-    }
-  else
-    {
-      // Printing dimension string as: a-D.
-
-      ss << dim << "-D";
-    }
-
-  dim_str = ss.str ();
-
-  return dim_str;
-}
-
-// Print a line of information on a given symbol.
+		  std::string nm = fcn->name ();
 
-void
-symbol_record::print_symbol_info_line (std::ostream& os,
-				       std::list<whos_parameter>& params) const
-{
-  std::list<whos_parameter>::iterator i = params.begin ();
-  while (i != params.end ())
-    {
-      whos_parameter param = * i;
+		  int nm_len = nm.length ();
 
-      if (param.command != '\0')
-        {
-	  // Do the actual printing.
-
-	  switch (param.modifier)
-	    {
-	    case 'l':
-	      os << std::setiosflags (std::ios::left)
-		 << std::setw (param.parameter_length);
-	      break;
-
-	    case 'r':
-	      os << std::setiosflags (std::ios::right)
-		 << std::setw (param.parameter_length);
-	      break;
+		  std::string file;
+		  std::string dir_name;
 
-	    case 'c':
-	      if (param.command == 's')
-	        {
-		  int front = param.first_parameter_length
-		    - dimensions_string_req_first_space (param.dimensions);
-		  int back = param.parameter_length
-		    - dimensions_string_req_total_space (param.dimensions)
-		    - front;
-		  front = (front > 0) ? front : 0;
-		  back = (back > 0) ? back : 0;
-
-		  os << std::setiosflags (std::ios::left)
-		     << std::setw (front)
-		     << ""
-		     << std::resetiosflags (std::ios::left)
-		     << make_dimensions_string (param.dimensions)
-		     << std::setiosflags (std::ios::left)
-		     << std::setw (back)
-		     << ""
-		     << std::resetiosflags (std::ios::left);
-		}
-	      else
-	        {
-		  os << std::setiosflags (std::ios::left)
-		     << std::setw (param.parameter_length);
-		}
-	      break;
-
-	    default:
-	      error ("whos_line_format: modifier `%c' unknown",
-		     param.modifier);
-
-	      os << std::setiosflags (std::ios::right)
-		 << std::setw (param.parameter_length);
-	    }
-
-	  switch (param.command)
-	    {
-	    case 'b':
-	      os << byte_size ();
-	      break;
-
-	    case 'c':
-	      os << class_name ();
-	      break;
-
-	    case 'e':
-	      os << capacity ();
-	      break;
-
-	    case 'n':
-	      os << name ();
-	      break;
-
-	    case 'p':
-	      {
-		std::stringstream ss;
-		std::string str;
-
-		ss << (is_read_only () ? "r-" : "rw")
-		   << (is_static () || is_eternal () ? "-" : "d");
-		str = ss.str ();
-
-		os << str;
-	      }
-	      break;
-
-	    case 's':
-	      if (param.modifier != 'c')
-		os << make_dimensions_string (param.dimensions);
-	      break;
-
-	    case 't':
-	      os << type_name ();
-	      break;
-	    
-	    default:
-	      error ("whos_line_format: command `%c' unknown", param.command);
-	    }
+		  if (octave_env::absolute_pathname (nm)
+		      && ((nm_len > 4 && (nm.substr (nm_len-4) == ".oct"
+					  || nm.substr (nm_len-4) == ".mex"))
+			  || (nm_len > 2 && nm.substr (nm_len-4) == ".m")))
+		    file = nm;
+		  else
+		    // FIXME -- this lookup is not right since it doesn't
+		    // account for dispatch type.
+		    file = octave_env::make_absolute (load_path::find_fcn (nm, dir_name),
+						      octave_env::getcwd ());
 
-	  os << std::resetiosflags (std::ios::left)
-	     << std::resetiosflags (std::ios::right);
-	  i++;
-	}
-      else
-	{
-	  os << param.text;
-	  i++;
-	}
-    }
-}
-
-void
-symbol_record::print_info (std::ostream& os, const std::string& prefix) const
-{
-  os << prefix << "formal param:      " << formal_param << "\n"
-     << prefix << "linked to global:  " << linked_to_global << "\n"
-     << prefix << "tagged static:     " << tagged_static << "\n"
-     << prefix << "can hide function: " << can_hide_function << "\n"
-     << prefix << "visible:           " << visible << "\n";
-
-  if (definition)
-    definition->print_info (os, prefix);
-  else
-    os << prefix << "symbol " << name () << " is undefined\n";
-}
-
-bool
-symbol_record::read_only_error (const char *action)
-{
-  if (is_read_only ())
-    {
-      if (is_variable ())
-	::error ("can't %s read-only constant `%s'", action, nm.c_str ());
-      else if (is_function ())
-	::error ("can't %s read-only function `%s'", action, nm.c_str ());
-      else
-	::error ("can't %s read-only symbol `%s'", action, nm.c_str ());
+		  if (file.empty ())
+		    {
+		      // Can't see this function from current
+		      // directory, so we should clear it.
 
-      return true;
-    }
-  else
-    return false;
-}
-
-// A symbol table.
-
-symbol_table::~symbol_table (void)
-{
-  for (unsigned int i = 0; i < table_size; i++)
-    {
-      symbol_record *ptr = table[i].next ();
-
-      while (ptr)
-	{
-	  symbol_record *tmp = ptr;
-
-	  ptr = ptr->next ();
-
-	  delete tmp;
-	}
-    }
-
-  delete [] table;
-}
-
-symbol_record *
-symbol_table::lookup (const std::string& nm, bool insert, bool warn)
-{
-  if (Vdebug_symtab_lookups)
-    {
-      std::cerr << (table_name.empty () ? std::string ("???") : table_name)
-		<< " symtab::lookup ["
-		<< (insert ? "I" : "-")
-		<< (warn ? "W" : "-")
-		<< "] \"" << nm << "\"\n";
-    }
-
-  unsigned int index = hash (nm);
-
-  symbol_record *ptr = table[index].next ();
+		      function = octave_value ();
+		    }
+		  else if (same_file (file, ff))
+		    {
+		      fcn->mark_fcn_file_up_to_date (octave_time ());
 
-  while (ptr)
-    {
-      if (ptr->name () == nm)
-	return ptr;
-
-      ptr = ptr->next ();
-    }
-
-  if (insert)
-    {
-      symbol_record *sr = new symbol_record (nm, table[index].next ());
-
-      table[index].chain (sr);
-
-      return sr;
-    }
-  else if (warn)
-    warning ("lookup: symbol `%s' not found", nm.c_str ());
-
-  return 0;
-}
-
-void
-symbol_table::rename (const std::string& old_name, const std::string& new_name)
-{
-  if (Vdebug_symtab_lookups)
-    {
-      std::cerr << (table_name.empty () ? std::string ("???") : table_name)
-		<< " symtab::rename "
-		<< "\"" << old_name << "\""
-		<< " to "
-		<< "\"" << new_name << "\"\n";
-    }
-
-  unsigned int index = hash (old_name);
+		      if (! (Vignore_function_time_stamp == 2
+			     || (Vignore_function_time_stamp
+				 && fcn->is_system_fcn_file ())))
+			{
+			  file_stat fs (ff);
 
-  symbol_record *prev = &table[index];
-  symbol_record *ptr = prev->next ();
-
-  while (ptr)
-    {
-      if (ptr->name () == old_name)
-	{
-	  ptr->rename (new_name);
-
-	  if (! error_state)
-	    {
-	      prev->chain (ptr->next ());
-
-	      index = hash (new_name);
-	      ptr->chain (table[index].next ());
-	      table[index].chain (ptr);
-
-	      return;
-	    }
-
-	  break;
-	}
-
-      prev = ptr;
-      ptr = ptr->next ();
-    }
-
-  error ("unable to rename `%s' to `%s'", old_name.c_str (),
-	 new_name.c_str ());
-}
-
-// FIXME -- it would be nice to eliminate a lot of the
-// following duplicate code.
-
-void
-symbol_table::clear (void)
-{
-  for (unsigned int i = 0; i < table_size; i++)
-    {
-      symbol_record *ptr = table[i].next ();
+			  if (fs)
+			    {
+			      if (fs.is_newer (tp))
+				{
+				  fcn = load_fcn_from_file (ff, dir_name);
 
-      while (ptr)
-	{
-	  if (ptr->is_user_function())
-	    {
-	      octave_user_function *fcn = ptr->def ().user_function_value ();
-	      std::string parent = (fcn ? fcn->parent_fcn_name () :
-				    std::string ());
-
-	      if (! parent.empty ())
-		{
-		  if (curr_parent_function &&
-		      parent == curr_parent_function->name ())
-		    {
-		      ptr = ptr->next ();
-		      continue;
-		    }			  
-
-		  symbol_record *parent_sr = fbi_sym_tab->lookup (parent);
-
-		  if (parent_sr && (parent_sr->is_static () ||
-				    parent_sr->is_eternal ()))
-		  {
-		    ptr = ptr->next ();
-		    continue;
-		  }
-		}
-	    }
-
-	  ptr->clear ();
-
-	  ptr = ptr->next ();
-	}
-    }
-}
-
-void
-symbol_table::clear_variables (void)
-{
-  for (unsigned int i = 0; i < table_size; i++)
-    {
-      symbol_record *ptr = table[i].next ();
+				  if (fcn)
+				    {
+				      retval = true;
 
-      while (ptr)
-	{
-	  if (ptr->is_user_variable ())
-	    ptr->clear ();
-
-	  ptr = ptr->next ();
-	}
-    }
-}
-
-// Really only clear functions that can be reloaded.
-
-void
-symbol_table::clear_functions (void)
-{
-  for (unsigned int i = 0; i < table_size; i++)
-    {
-      symbol_record *ptr = table[i].next ();
-
-      while (ptr)
-	{
-	  if (ptr->is_user_function ()
-	      || ptr->is_dld_function ()
-	      || ptr->is_mex_function ())
-	    {
-
-	      if (ptr->is_user_function())
-		{
-		  octave_user_function *fcn = 
-		    ptr->def ().user_function_value ();
-		  std::string parent = (fcn ? fcn->parent_fcn_name () :
-					std::string ());
-
-		  if (! parent.empty ())
-		    {
-		      if (curr_parent_function &&
-			  parent == curr_parent_function->name ())
-			{
-			  ptr = ptr->next ();
-			  continue;
-			}			  
-
-		      symbol_record *parent_sr = fbi_sym_tab->lookup (parent);
-
-		      if (parent_sr && (parent_sr->is_static () ||
-					parent_sr->is_eternal ()))
-			{
-			  ptr = ptr->next ();
-			  continue;
+				      function = octave_value (fcn);
+				    }
+				  else
+				    function = octave_value ();
+				}				
+			    }
+			  else
+			    function = octave_value ();
 			}
 		    }
 		}
-
-	      ptr->clear ();
 	    }
-
-	  ptr = ptr->next ();
-	}
-    }
-}
-
-void
-symbol_table::clear_mex_functions (void)
-{
-  for (unsigned int i = 0; i < table_size; i++)
-    {
-      symbol_record *ptr = table[i].next ();
-
-      while (ptr)
-	{
-	  if (ptr->is_mex_function ())
-	    ptr->clear ();
-
-	  ptr = ptr->next ();
-	}
-    }
-}
-
-void
-symbol_table::clear_globals (void)
-{
-  for (unsigned int i = 0; i < table_size; i++)
-    {
-      symbol_record *ptr = table[i].next ();
-
-      while (ptr)
-	{
-	  if (ptr->is_user_variable () && ptr->is_linked_to_global ())
-	    ptr->clear ();
-
-	  ptr = ptr->next ();
-	}
-    }
-}
-
-bool
-symbol_table::clear (const std::string& nm)
-{
-  unsigned int index = hash (nm);
-
-  symbol_record *ptr = table[index].next ();
-
-  while (ptr)
-    {
-      if (ptr->name () == nm)
-	{
-	  if (ptr->is_user_function())
-	    {
-	      octave_user_function *fcn = 
-		ptr->def ().user_function_value ();
-	      std::string parent = (fcn ? fcn->parent_fcn_name () :
-				    std::string ());
-
-	      if (! parent.empty ())
-		{
-		  if (curr_parent_function &&
-		      parent == curr_parent_function->name ())
-		    return true;
-
-		  symbol_record *parent_sr = fbi_sym_tab->lookup (parent);
-		  
-		  if (parent_sr && (parent_sr->is_static () ||
-				    parent_sr->is_eternal ()))
-		    return true;
-		}
-	    }
-
-	  ptr->clear ();
-
-	  return true;
-	}
-      ptr = ptr->next ();
-    }
-
-  return false;
-}
-
-bool
-symbol_table::clear_variable (const std::string& nm)
-{
-  unsigned int index = hash (nm);
-
-  symbol_record *ptr = table[index].next ();
-
-  while (ptr)
-    {
-      if (ptr->name () == nm && ptr->is_user_variable ())
-	{
-	  ptr->clear ();
-	  return true;
-	}
-      ptr = ptr->next ();
-    }
-
-  return false;
-}
-
-bool
-symbol_table::clear_global (const std::string& nm)
-{
-  unsigned int index = hash (nm);
-
-  symbol_record *ptr = table[index].next ();
-
-  while (ptr)
-    {
-      if (ptr->name () == nm
-	  && ptr->is_user_variable ()
-	  && ptr->is_linked_to_global ())
-	{
-	  ptr->clear ();
-	  return true;
-	}
-      ptr = ptr->next ();
-    }
-
-  return false;
-}
-
-// Really only clear functions that can be reloaded.
-
-bool
-symbol_table::clear_function (const std::string& nm)
-{
-  unsigned int index = hash (nm);
-
-  symbol_record *ptr = table[index].next ();
-
-  while (ptr)
-    {
-      if (ptr->name () == nm
-	  && (ptr->is_user_function ()
-	      || ptr->is_dld_function ()
-	      || ptr->is_mex_function ()))
-	{
-	  if (ptr->is_user_function())
-	    {
-	      octave_user_function *fcn = 
-		ptr->def ().user_function_value ();
-	      std::string parent = (fcn ? fcn->parent_fcn_name () :
-				    std::string ());
-
-	      if (! parent.empty ())
-		{
-		  if (curr_parent_function &&
-		      parent == curr_parent_function->name ())
-		    return true;
-
-		  symbol_record *parent_sr = fbi_sym_tab->lookup (parent);
-		  
-		  if (parent_sr && (parent_sr->is_static () ||
-				    parent_sr->is_eternal ()))
-		    return true;
-		}
-	    }
-
-	  ptr->clear ();
-	  return true;
-	}
-      ptr = ptr->next ();
-    }
-
-  return false;
-}
-
-bool
-symbol_table::clear_variable_pattern (const std::string& pat)
-{
-  bool retval = false;
-
-  for (unsigned int i = 0; i < table_size; i++)
-    {
-      symbol_record *ptr = table[i].next ();
-
-      while (ptr)
-	{
-	  if (ptr->is_user_variable ())
-	    {
-	      glob_match pattern (pat);
-
-	      if (pattern.match (ptr->name ()))
-		{
-		  ptr->clear ();
-
-		  retval = true;
-		}
-	    }
-
-	  ptr = ptr->next ();
 	}
     }
 
   return retval;
 }
 
 bool
-symbol_table::clear_global_pattern (const std::string& pat)
+out_of_date_check (octave_value& function)
 {
-  bool retval = false;
+  return out_of_date_check_internal (function);
+}
 
-  for (unsigned int i = 0; i < table_size; i++)
+octave_value
+symbol_table::fcn_info::fcn_info_rep::load_private_function
+  (const std::string& dir_name)
+{
+  octave_value retval;
+
+  std::string file_name = load_path::find_private_fcn (dir_name, name);
+
+  if (! file_name.empty ())
     {
-      symbol_record *ptr = table[i].next ();
+      octave_function *fcn = load_fcn_from_file (file_name);
 
-      while (ptr)
+      if (fcn)
 	{
-	  if (ptr->is_user_variable () && ptr->is_linked_to_global ())
-	    {
-	      glob_match pattern (pat);
+	  retval = octave_value (fcn);
 
-	      if (pattern.match (ptr->name ()))
-		{
-		  ptr->clear ();
-
-		  retval = true;
-		}
-	    }
-
-	  ptr = ptr->next ();
+	  private_functions[dir_name] = retval;
 	}
     }
 
   return retval;
 }
 
-// Really only clear functions that can be reloaded.
-
-bool
-symbol_table::clear_function_pattern (const std::string& pat)
+octave_value
+symbol_table::fcn_info::fcn_info_rep::load_class_constructor (void)
 {
-  bool retval = false;
+  octave_value retval;
+
+  std::string dir_name;
 
-  for (unsigned int i = 0; i < table_size; i++)
+  std::string file_name = load_path::find_method (name, name, dir_name);
+
+  if (! file_name.empty ())
     {
-      symbol_record *ptr = table[i].next ();
+      octave_function *fcn = load_fcn_from_file (file_name, dir_name, name);
 
-      while (ptr)
+      if (fcn)
 	{
-	  if (ptr->is_user_function ()
-	      || ptr->is_dld_function ()
-	      || ptr->is_mex_function ())
-	    {
-	      glob_match pattern (pat);
+	  retval = octave_value (fcn);
+
+	  class_constructors[name] = retval;
+	}
+    }
+
+  return retval;
+}
+
+octave_value
+symbol_table::fcn_info::fcn_info_rep::load_class_method
+  (const std::string& dispatch_type)
+{
+  octave_value retval;
 
-	      if (pattern.match (ptr->name ()))
-		{
-		  ptr->clear ();
+  std::string dir_name;
+
+  std::string file_name = load_path::find_method (dispatch_type, name, dir_name);
 
-		  retval = true;
-		}
-	    }
+  if (! file_name.empty ())
+    {
+      octave_function *fcn = load_fcn_from_file (file_name, dir_name,
+						 dispatch_type);
 
-	  ptr = ptr->next ();
+      if (fcn)
+	{
+	  retval = octave_value (fcn);
+
+	  class_methods[dispatch_type] = retval;
 	}
     }
 
   return retval;
 }
 
-int
-symbol_table::size (void) const
+void
+symbol_table::fcn_info::fcn_info_rep::print_dispatch (std::ostream& os) const
 {
-  int count = 0;
+  if (dispatch_map.empty ())
+    os << "dispatch: " << name << " is not overloaded" << std::endl;
+  else
+    {
+      os << "Overloaded function " << name << ":\n\n";
+
+      for (const_dispatch_map_iterator p = dispatch_map.begin ();
+	   p != dispatch_map.end (); p++)
+	os << "  " << name << " (" << p->first << ", ...) -> " 
+	   << p->second << " (" << p->first << ", ...)\n";
 
-  for (unsigned int i = 0; i < table_size; i++)
+      os << std::endl;
+    }
+}
+
+std::string
+symbol_table::fcn_info::fcn_info_rep::help_for_dispatch (void) const
+{
+  std::string retval;
+
+  if (! dispatch_map.empty ())
     {
-      symbol_record *ptr = table[i].next ();
+      retval = "Overloaded function:\n\n";
+
+      for (const_dispatch_map_iterator p = dispatch_map.begin ();
+	   p != dispatch_map.end (); p++)
+	retval += "  " + p->second + " (" + p->first + ", ...)\n\n";
+    }
+
+  return retval;
+}
+
+// Find the definition of NAME according to the following precedence
+// list:
+//
+//   variable
+//   subfunction
+//   private function
+//   class constructor
+//   class method
+//   legacy dispatch
+//   command-line function
+//   autoload function
+//   function on the path
+//   built-in function
 
-      while (ptr)
+// Notes:
+//
+// FIXME -- we need to evaluate the argument list to determine the
+// dispatch type.  The method used here works (pass in the args, pass
+// out the evaluated args and a flag saying whether the evaluation was
+// needed), but it seems a bit inelegant.  We do need to save the
+// evaluated args in some way to avoid evaluating them multiple times.
+//  Maybe evaluated args could be attached to the tree_argument_list
+// object?  Then the argument list could be evaluated outside of this
+// function and we could elimnate the arg_names, evaluated_args, and
+// args_evaluated arguments.  We would still want to avoid computing
+// the dispatch type unless it is needed, so the args should be passed
+// rather than the dispatch type.  But the arguments will need to be
+// evaluated no matter what, so evaluating them beforehand should be
+// OK.  If the evaluated arguments are attached to args, then we would
+// need to determine the appropriate place(s) to clear them (for
+// example, before returning from tree_index_expression::rvalue).
+
+octave_value
+symbol_table::fcn_info::fcn_info_rep::find
+  (tree_argument_list *args, const string_vector& arg_names,
+   octave_value_list& evaluated_args, bool& args_evaluated,
+   scope_id scope)
+{
+  static bool deja_vu = false;
+
+  // Subfunction.  I think it only makes sense to check for
+  // subfunctions if we are currently executing a function defined
+  // from a .m file.
+
+  scope_val_iterator r = subfunctions.find (scope);
+
+  if (r != subfunctions.end ())
+    {
+      // FIXME -- out-of-date check here.
+
+      return r->second;
+    }
+  else if (curr_parent_function)
+    {
+      scope_id pscope = curr_parent_function->scope ();
+
+      r = subfunctions.find (pscope);
+
+      if (r != subfunctions.end ())
 	{
-	  count++;
-	  ptr = ptr->next ();
+	  // FIXME -- out-of-date check here.
+
+	  return r->second;
 	}
     }
 
-  return count;
-}
+  // Private function.
 
-static bool
-matches_patterns (const std::string& name, const string_vector& pats)
-{
-  int npats = pats.length ();
+  octave_function *curr_fcn = octave_call_stack::current ();
 
-  if (npats == 0)
-    return true;
-
-  glob_match pattern (pats);
-
-  return pattern.match (name);
-}
+  if (curr_fcn)
+    {
+      std::string dir_name = curr_fcn->dir_name ();
 
-Array<symbol_record *>
-symbol_table::subsymbol_list (const string_vector& pats,
-			      unsigned int type, unsigned int scope) const
-{
-  int count = 0;
-
-  int n = size ();
+      if (! dir_name.empty ())
+	{
+	  str_val_iterator q = private_functions.find (dir_name);
 
-  Array<symbol_record *> subsymbols (dim_vector (n, 1));
-  int pats_length = pats.length ();
-
-  if (n == 0)
-    return subsymbols;
-
-  // Look for separators like .({
-  for (int j = 0; j < pats_length; j++)
-    {
-      std::string var_name = pats (j);
+	  if (q == private_functions.end ())
+	    {
+	      octave_value val = load_private_function (dir_name);
 
-      size_t pos = var_name.find_first_of (".({");
-
-      if ((pos != NPOS) && (pos > 0))
-        {
-	  std::string first_name = var_name.substr(0,pos);
-
-	  for (unsigned int i = 0; i < table_size; i++)
+	      if (val.is_defined ())
+		return val;
+	    }
+	  else
 	    {
-	      symbol_record *ptr = table[i].next ();
-
-	      while (ptr)
-	        {
-		  assert (count < n);
-
-		  unsigned int my_scope = ptr->is_linked_to_global () + 1; // Tricky...
+	      octave_value& fval = q->second;
 
-		  unsigned int my_type = ptr->type ();
-
-		  std::string my_name = ptr->name ();
+	      if (fval.is_defined ())
+		out_of_date_check_internal (fval);
 
-		  if ((type & my_type) && (scope & my_scope) && (first_name == my_name))
-		    {
-		      symbol_record *sym_ptr = new symbol_record ();
-		      octave_value value;
-		      int parse_status;
-	 
-		      value = eval_string (var_name, true, parse_status);
-	 
-		      sym_ptr->define (value);
-		      sym_ptr->rename (var_name);
-		      subsymbols(count++) = sym_ptr;
-		    }
+	      if (fval.is_defined ())
+		return fval;
+	      else
+		{
+		  octave_value val = load_private_function (dir_name);
 
-		  ptr = ptr->next ();
+		  if (val.is_defined ())
+		    return val;
 		}
 	    }
 	}
     }
 
-  subsymbols.resize (dim_vector (count, 1));
+  // Class constructors.  The class name and function name are the same.
 
-  return subsymbols;
-}
+  str_val_iterator q = class_constructors.find (name);
 
-Array<symbol_record *>
-symbol_table::symbol_list (const string_vector& pats,
-			   unsigned int type, unsigned int scope) const
-{
-  int count = 0;
+  if (q == class_constructors.end ())
+    {
+      octave_value val = load_class_constructor ();
 
-  int n = size ();
-
-  Array<symbol_record *> symbols (dim_vector (n, 1));
-
-  if (n == 0)
-    return symbols;
-
-  for (unsigned int i = 0; i < table_size; i++)
+      if (val.is_defined ())
+	return val;
+    }
+  else
     {
-      symbol_record *ptr = table[i].next ();
+      octave_value& fval = q->second;
 
-      while (ptr)
-	{
-	  if (ptr->is_visible ())
-	    {
-	      assert (count < n);
-
-	      unsigned int my_scope = ptr->is_linked_to_global () + 1; // Tricky...
+      if (fval.is_defined ())
+	out_of_date_check_internal (fval);
 
-	      unsigned int my_type = ptr->type ();
-
-	      std::string my_name = ptr->name ();
+      if (fval.is_defined ())
+	return fval;
+      else
+	{
+	  octave_value val = load_class_constructor ();
 
-	      if ((type & my_type) && (scope & my_scope) && (matches_patterns (my_name, pats)))
-		symbols(count++) = ptr;
-	    }
-
-	  ptr = ptr->next ();
+	  if (val.is_defined ())
+	    return val;
 	}
     }
 
-  symbols.resize (dim_vector (count, 1));
+  // Class methods.
 
-  return symbols;
-}
+  if (args_evaluated || (args && args->length () > 0))
+    {
+      if (! args_evaluated)
+	evaluated_args = args->convert_to_const_vector ();
 
-string_vector
-symbol_table::name_list (const string_vector& pats, bool sort,
-			 unsigned int type, unsigned int scope) const
-{
-  Array<symbol_record *> symbols = symbol_list (pats, type, scope);
+      if (! error_state)
+	{
+	  int n = evaluated_args.length ();
+
+	  if (n > 0 && ! args_evaluated)
+	    evaluated_args.stash_name_tags (arg_names);
+
+	  args_evaluated = true;
+
+	  // FIXME -- need to handle precedence.
 
-  string_vector names;
+	  std::string dispatch_type = evaluated_args(0).class_name ();
 
-  int n = symbols.length ();
+	  for (int i = 1; i < n; i++)
+	    {
+	      octave_value arg = evaluated_args(i);
 
-  if (n > 0)
-    {
-      names.resize (n);
+	      if (arg.is_object ())
+		{
+		  dispatch_type = arg.class_name ();
+		  break;
+		}
+	    }
 
-      for (int i = 0; i < n; i++)
-	names[i] = symbols(i)->name ();
+	  octave_value fcn = find_method (dispatch_type);
+
+	  if (fcn.is_defined ())
+	    return fcn;
+	}
+      else
+	return octave_value ();
     }
 
-  if (sort)
-    names.qsort ();
+  // Legacy dispatch.  We just check args_evaluated here because the
+  // actual evaluation will have happened already when searching for
+  // class methods.
+
+  if (args_evaluated && ! dispatch_map.empty ())
+    {
+      std::string dispatch_type = evaluated_args(0).type_name ();
+
+      std::string fname;
+
+      dispatch_map_iterator p = dispatch_map.find (dispatch_type);
+
+      if (p == dispatch_map.end ())
+	p = dispatch_map.find ("any");
 
-  return names;
-}
+      if (p != dispatch_map.end ())
+	{
+	  fname = p->second;
+
+	  octave_value fcn
+	    = symbol_table::find_function (fname, evaluated_args, scope);
+
+	  if (fcn.is_defined ())
+	    return fcn;
+	}
+    }
+
+  // Command-line function.
+
+  if (cmdline_function.is_defined ())
+    return cmdline_function;
+
+  // Autoload?
 
-static int
-maybe_list_cmp_fcn (const void *a_arg, const void *b_arg)
-{
-  const symbol_record *a = *(static_cast<symbol_record *const*> (a_arg));
-  const symbol_record *b = *(static_cast<symbol_record *const*> (b_arg));
+  octave_value fcn = find_autoload ();
+
+  if (fcn.is_defined ())
+    return fcn;
+
+  // Function on the path.
+
+  fcn = find_user_function ();
+
+  if (fcn.is_defined ())
+    return fcn;
+
+  // Built-in function.
+
+  if (built_in_function.is_defined ())
+    return built_in_function;
 
-  std::string a_nm = a->name ();
-  std::string b_nm = b->name ();
+  // At this point, we failed to find anything.  It is possible that
+  // the user created a file on the fly since the last prompt or
+  // chdir, so try updating the load path and searching again.
+
+  octave_value retval;
 
-  return a_nm.compare (b_nm);
+  if (! deja_vu)
+    {
+      load_path::update ();
+
+      deja_vu = true;
+
+      retval = find (args, arg_names, evaluated_args, args_evaluated, scope);
+    }
+
+  deja_vu = false;
+
+  return retval;
 }
 
-void
-symbol_table::print_descriptor (std::ostream& os,
-				std::list<whos_parameter> params) const
+octave_value
+symbol_table::fcn_info::fcn_info_rep::find_method (const std::string& dispatch_type)
 {
-  // This method prints a line of information on a given symbol
-  std::list<whos_parameter>::iterator i = params.begin ();
-  std::ostringstream param_buf;
-
-  while (i != params.end ())
-    {
-      whos_parameter param = * i;
+  octave_value retval;
 
-      if (param.command != '\0')
-        {
-	  // Do the actual printing
-	  switch (param.modifier)
-	    {
-	    case 'l':
-	      os << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
-	      param_buf << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
-	      break;
+  str_val_iterator q = class_methods.find (dispatch_type);
 
-	    case 'r':
-	      os << std::setiosflags (std::ios::right) << std::setw (param.parameter_length);
-	      param_buf << std::setiosflags (std::ios::right) << std::setw (param.parameter_length);
-	      break;
-
-	    case 'c':
-	      if (param.command != 's')
-	        {
-		  os << std::setiosflags (std::ios::left)
-		     << std::setw (param.parameter_length);
-		  param_buf << std::setiosflags (std::ios::left)
-			    << std::setw (param.parameter_length);
-		}
-	      break;
+  if (q == class_methods.end ())
+    {
+      octave_value val = load_class_method (dispatch_type);
 
-	    default:
-	      os << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
-	      param_buf << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
-	    }
+      if (val.is_defined ())
+	return val;
+    }
+  else
+    {
+      octave_value& fval = q->second;
 
-	  if (param.command == 's' && param.modifier == 'c')
-	    {
-	      int a, b;
-	     
-	      if (param.modifier == 'c')
-	        {
-		  a = param.first_parameter_length - param.balance;
-		  a = (a < 0 ? 0 : a);
-		  b = param.parameter_length - a - param.text . length ();
-		  b = (b < 0 ? 0 : b);
-		  os << std::setiosflags (std::ios::left) << std::setw (a)
-		     << "" << std::resetiosflags (std::ios::left) << param.text
-		     << std::setiosflags (std::ios::left)
-		     << std::setw (b) << ""
-		     << std::resetiosflags (std::ios::left);
-		  param_buf << std::setiosflags (std::ios::left) << std::setw (a)
-		     << "" << std::resetiosflags (std::ios::left) << param.line
-		     << std::setiosflags (std::ios::left)
-		     << std::setw (b) << ""
-		     << std::resetiosflags (std::ios::left);
-		}
-	    }
-	  else
-	    {
-	      os << param.text;
-	      param_buf << param.line;
-	    }
-	  os << std::resetiosflags (std::ios::left)
-	     << std::resetiosflags (std::ios::right);
-	  param_buf << std::resetiosflags (std::ios::left)
-		    << std::resetiosflags (std::ios::right);
-	  i++;
-	}
+      if (fval.is_defined ())
+	out_of_date_check_internal (fval);
+
+      if (fval.is_defined ())
+	return fval;
       else
 	{
-	  os << param.text;
-	  param_buf << param.line;
-	  i++;
+	  octave_value val = load_class_method (dispatch_type);
+
+	  if (val.is_defined ())
+	    return val;
 	}
     }
 
-  os << param_buf.str ();
+  return retval;
 }
 
-std::list<whos_parameter>
-symbol_table::parse_whos_line_format (Array<symbol_record *>& symbols) const
+octave_value
+symbol_table::fcn_info::fcn_info_rep::find_autoload (void)
 {
-  // This method parses the string whos_line_format, and returns
-  // a parameter list, containing all information needed to print
-  // the given attributtes of the symbols
-  int idx;
-  size_t format_len = Vwhos_line_format.length ();
-  char garbage;
-  std::list<whos_parameter> params;
-
-  size_t bytes1;
-  int elements1;
+  octave_value retval;
 
-  int len = symbols.length ();
-
-  std::string param_string = "bcenpst";
-  Array<int> param_length (dim_vector (param_string.length (), 1));
-  Array<std::string> param_names (dim_vector (param_string.length (), 1));
-  size_t pos_b, pos_c, pos_e, pos_n, pos_p, pos_s, pos_t;
+  // Autoloaded function.
 
-  pos_b = param_string.find ('b'); // Bytes
-  pos_c = param_string.find ('c'); // Class
-  pos_e = param_string.find ('e'); // Elements
-  pos_n = param_string.find ('n'); // Name
-  pos_p = param_string.find ('p'); // Protected
-  pos_s = param_string.find ('s'); // Size
-  pos_t = param_string.find ('t'); // Type
+  if (autoload_function.is_defined ())
+    out_of_date_check_internal (autoload_function);
 
-  param_names(pos_b) = "Bytes";
-  param_names(pos_c) = "Class";
-  param_names(pos_e) = "Elements";
-  param_names(pos_n) = "Name";
-  param_names(pos_p) = "Prot";
-  param_names(pos_s) = "Size";
-  param_names(pos_t) = "Type";
+  if (! autoload_function.is_defined ())
+    {
+      std::string file_name = lookup_autoload (name);
 
-  for (size_t i = 0; i < param_string.length (); i++)
-    param_length(i) = param_names(i) . length ();
-
-  // Calculating necessary spacing for name column,
-  // bytes column, elements column and class column
-  for (int i = 0; i < static_cast<int> (len); i++)
-    {
-      std::stringstream ss1, ss2;
-      std::string str;
+      if (! file_name.empty ())
+	{
+	  size_t pos = file_name.find_last_of (file_ops::dir_sep_chars);
 
-      str = symbols(i)->name ();
-      param_length(pos_n) = ((str.length ()
-			      > static_cast<size_t> (param_length(pos_n)))
-			     ? str.length () : param_length(pos_n));
-
-      str = symbols(i)->type_name ();
-      param_length(pos_t) = ((str.length ()
-			      > static_cast<size_t> (param_length(pos_t)))
-			     ? str.length () : param_length(pos_t));
+	  std::string dir_name = file_name.substr (0, pos);
 
-      elements1 = symbols(i)->capacity ();
-      ss1 << elements1;
-      str = ss1.str ();
-      param_length(pos_e) = ((str.length ()
-			      > static_cast<size_t> (param_length(pos_e)))
-			     ? str.length () : param_length(pos_e));
+	  octave_function *fcn = load_fcn_from_file (file_name, dir_name,
+						     "", name, true);
 
-      bytes1 = symbols(i)->byte_size ();
-      ss2 << bytes1;
-      str = ss2.str ();
-      param_length(pos_b) = ((str.length ()
-			      > static_cast<size_t> (param_length(pos_b)))
-			     ? str.length () : param_length (pos_b));
+	  if (fcn)
+	    autoload_function = octave_value (fcn);
+	}
     }
 
-  idx = 0;
-  while (static_cast<size_t> (idx) < format_len)
-    {
-      whos_parameter param;
-      param.command = '\0';
-
-      if (Vwhos_line_format[idx] == '%')
-        {
-	  bool error_encountered = false;
-	  param.modifier = 'r';
-	  param.parameter_length = 0;
-	  param.dimensions = 8;
-
-	  int a = 0, b = -1, c = 8, balance = 1;
-	  unsigned int items;
-	  size_t pos;
-	  std::string cmd;
-
-	  // Parse one command from whos_line_format
-	  cmd = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
-	  pos = cmd.find (';');
-	  if (pos != NPOS)
-	    cmd = cmd.substr (0, pos+1);
-	  else
-	    error ("parameter without ; in whos_line_format");
-
-	  idx += cmd.length ();
-
-	  // FIXME -- use iostream functions instead of sscanf!
+  return autoload_function;
+}
 
-	  if (cmd.find_first_of ("crl") != 1)
-	    items = sscanf (cmd.c_str (), "%c%c:%d:%d:%d:%d;",
-			    &garbage, &param.command, &a, &b, &c, &balance);
-	  else
-	    items = sscanf (cmd.c_str (), "%c%c%c:%d:%d:%d:%d;",
-			    &garbage, &param.modifier, &param.command,
-			    &a, &b, &c, &balance) - 1;
-	 
-	  if (items < 2)
-	    {
-	      error ("whos_line_format: parameter structure without command in whos_line_format");
-	      error_encountered = true;
-	    }
+octave_value
+symbol_table::fcn_info::fcn_info_rep::find_user_function (void)
+{
+  // Function on the path.
 
-	  // Insert data into parameter
-	  param.first_parameter_length = 0;
-	  pos = param_string.find (param.command);
-	  if (pos != NPOS)
-	    {
-	      param.parameter_length = param_length(pos);
-	      param.text = param_names(pos);
-	      param.line.assign (param_names(pos).length (), '=');
-
-	      param.parameter_length = (a > param.parameter_length
-					? a : param.parameter_length);
-	      if (param.command == 's' && param.modifier == 'c' && b > 0)
-		param.first_parameter_length = b;
-	    }
-	  else
-	    {
-	      error ("whos_line_format: '%c' is not a command",
-		     param.command);
-	      error_encountered = true;
-	    }
+  if (function_on_path.is_defined ())
+    out_of_date_check_internal (function_on_path);
 
-	  if (param.command == 's')
-	    {
-	      // Have to calculate space needed for printing matrix dimensions
-	      // Space needed for Size column is hard to determine in prior,
-	      // because it depends on dimensions to be shown. That is why it is
-	      // recalculated for each Size-command
-	      int j, first, rest = 0, total;
-	      param.dimensions = c;
-	      first = param.first_parameter_length;
-	      total = param.parameter_length;
-	     
-	      for (j = 0; j < len; j++)
-		{
-		  int first1 = symbols(j)->dimensions_string_req_first_space (param.dimensions);
-		  int total1 = symbols(j)->dimensions_string_req_total_space (param.dimensions);
-		  int rest1 = total1 - first1;
-		  rest = (rest1 > rest ? rest1 : rest);
-		  first = (first1 > first ? first1 : first);
-		  total = (total1 > total ? total1 : total);
-		}
+  if (! function_on_path.is_defined ())
+    {
+      std::string dir_name;
 
-	      if (param.modifier == 'c')
-	        {
-		  if (first < balance)
-		    first += balance - first;
-		  if (rest + balance < param.parameter_length)
-		    rest += param.parameter_length - rest - balance;
+      std::string file_name = load_path::find_fcn (name, dir_name);
 
-		  param.parameter_length = first + rest;
-		  param.first_parameter_length = first;
-		  param.balance = balance;
-		}
-	      else
-	        {
-		  param.parameter_length = total;
-		  param.first_parameter_length = 0;
-		}
-	    }
-	  else if (param.modifier == 'c')
-	    {
-	      error ("whos_line_format: modifier 'c' not available for command '%c'",
-		     param.command);
-	      error_encountered = true;
-	    }
+      if (! file_name.empty ())
+	{
+	  octave_function *fcn = load_fcn_from_file (file_name, dir_name);
 
-	  // What happens if whos_line_format contains negative numbers
-	  // at param_length positions?
-	  param.balance = (b < 0 ? 0 : param.balance);
-	  param.first_parameter_length = (b < 0 ? 0 :
-					  param.first_parameter_length);
-	  param.parameter_length = (a < 0
-				    ? 0
-				    : (param.parameter_length
-				       < param_length(pos_s)
-				       ? param_length(pos_s)
-				       : param.parameter_length));
-
-	  // Parameter will not be pushed into parameter list if ...
-	  if (! error_encountered)
-	    params.push_back (param);
-	}
-      else
-        {
-	  // Text string, to be printed as it is ...
-	  std::string text;
-	  size_t pos;
-	  text = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
-	  pos = text.find ('%');
-	  if (pos != NPOS)
-	    text = text.substr (0, pos);
-
-	  // Push parameter into list ...
-	  idx += text.length ();
-	  param.text=text;
-	  param.line.assign (text.length(), ' ');
-	  params.push_back (param);
+	  if (fcn)
+	    function_on_path = octave_value (fcn);
 	}
     }
 
-  return params;
+  return function_on_path;
+}
+
+octave_value
+symbol_table::fcn_info::find (tree_argument_list *args,
+			      const string_vector& arg_names,
+			      octave_value_list& evaluated_args,
+			      bool& args_evaluated, scope_id scope)
+{
+  return rep->find (args, arg_names, evaluated_args, args_evaluated, scope);
+}
+
+octave_value
+symbol_table::find (const std::string& name, tree_argument_list *args,
+		    const string_vector& arg_names,
+		    octave_value_list& evaluated_args, bool& args_evaluated,
+		    symbol_table::scope_id scope, bool skip_variables)
+{
+  symbol_table *inst = get_instance (scope);
+
+  return inst
+    ? inst->do_find (name, args, arg_names, evaluated_args,
+		       args_evaluated, scope, skip_variables)
+    : octave_value ();
+}
+
+octave_value
+symbol_table::find_function (const std::string& name, tree_argument_list *args,
+			     const string_vector& arg_names,
+			     octave_value_list& evaluated_args,
+			     bool& args_evaluated, scope_id scope)
+{
+  return find (name, args, arg_names, evaluated_args, args_evaluated,
+	       scope, true);
 }
 
-int
-symbol_table::maybe_list (const char *header, const string_vector& argv,
-			  std::ostream& os, bool show_verbose,
-			  unsigned type, unsigned scope)
+octave_value
+symbol_table::do_find (const std::string& name, tree_argument_list *args,
+		       const string_vector& arg_names,
+		       octave_value_list& evaluated_args,
+		       bool& args_evaluated, scope_id scope,
+		       bool skip_variables)
 {
-  // This method prints information for sets of symbols, but only one
-  // set at a time (like, for instance: all variables, or all
-  // built-in-functions).
+  octave_value retval;
 
-  // This method invokes print_symbol_info_line to print info on every
-  // symbol.
+  // Variable.
 
-  int status = 0;
-
-  if (show_verbose)
+  if (! skip_variables)
     {
-      // FIXME Should separate argv to lists with and without dots.
-      Array<symbol_record *> xsymbols = symbol_list (argv, type, scope);
-      Array<symbol_record *> xsubsymbols = subsymbol_list (argv, type, scope);
+      table_iterator p = table.find (name);
 
-      int sym_len = xsymbols.length (), subsym_len = xsubsymbols.length (),
-	len = sym_len + subsym_len;
- 
-      Array<symbol_record *> symbols (dim_vector (len, 1));
+      if (p != table.end ())
+	{
+	  symbol_record& sr = p->second;
 
-      if (len > 0)
-	{
-	  size_t bytes = 0;
-	  size_t elements = 0;
-
-	  int i;
+	  // FIXME -- should we be using something other than varref here?
 
-	  std::list<whos_parameter> params;
-
-	  // Joining symbolic tables.
-	  for (i = 0; i < sym_len; i++)
-	    symbols(i) = xsymbols(i);
-
-	  for (i = 0; i < subsym_len; i++)
-	    symbols(i+sym_len) = xsubsymbols(i);
-
-	  os << "\n" << header << "\n\n";
-
-	  symbols.qsort (maybe_list_cmp_fcn);
-
-	  params = parse_whos_line_format (symbols);
-
-	  print_descriptor (os, params);
+	  if (sr.is_global ())
+	    return symbol_table::varref (name, xglobal_scope);
+	  else
+	    {
+	      octave_value& val = sr.varref ();
 
-	  os << "\n";
+	      if (val.is_defined ())
+		return val;
+	    }
+	}
+    }
 
-	  for (int j = 0; j < len; j++)
-	    {
-	      symbols(j)->print_symbol_info_line (os, params);
-	      elements += symbols(j)->capacity ();
-	      bytes += symbols(j)->byte_size ();
-	    }
+  fcn_table_iterator p = fcn_table.find (name);
 
-	  os << "\nTotal is "
-	     << elements << (elements == 1 ? " element" : " elements")
-	     << " using "
-	     << bytes << (bytes == 1 ? " byte" : " bytes")
-	     << "\n";
+  if (p != fcn_table.end ())
+    {
+      evaluated_args = octave_value_list ();
+      args_evaluated = false;
 
-	  status = 1;
-	}
+      return p->second.find (args, arg_names, evaluated_args, args_evaluated,
+			     scope);
     }
   else
     {
-      string_vector symbols = name_list (argv, 1, type, scope);
+      fcn_info finfo (name);
+
+      octave_value fcn = finfo.find (args, arg_names, evaluated_args,
+				     args_evaluated, scope);
 
-      if (! symbols.empty ())
-	{
-	  os << "\n" << header << "\n\n";
+      if (fcn.is_defined ())
+	fcn_table[name] = finfo;
 
-	  symbols.list_in_columns (os);
-
-	  status = 1;
-	}
+      return fcn;
     }
 
-  return status;
-}
-
-Array<symbol_record *>
-symbol_table::glob (const std::string& pat, unsigned int type,
-		    unsigned int scope) const
-{
-  int count = 0;
-
-  int n = size ();
-
-  Array<symbol_record *> symbols (dim_vector (n, 1));
-
-  if (n == 0)
-    return symbols;
-
-  for (unsigned int i = 0; i < table_size; i++)
-    {
-      symbol_record *ptr = table[i].next ();
-
-      while (ptr)
-	{
-	  assert (count < n);
-
-	  unsigned int my_scope = ptr->is_linked_to_global () + 1; // Tricky...
-
-	  unsigned int my_type = ptr->type ();
-
-	  glob_match pattern (pat);
-
-	  if ((type & my_type) && (scope & my_scope)
-	      && pattern.match (ptr->name ()))
-	    {
-	      symbols(count++) = ptr;
-	    }
-
-	  ptr = ptr->next ();
-	}
-    }
-
-  symbols.resize (dim_vector (count, 1));
-
-  return symbols;
+  return retval;
 }
 
-void
-symbol_table::push_context (void)
+DEFUN (ignore_function_time_stamp, args, nargout,
+    "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} ignore_function_time_stamp ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})\n\
+Query or set the internal variable that controls whether Octave checks\n\
+the time stamp on files each time it looks up functions defined in\n\
+function files.  If the internal variable is set to @code{\"system\"},\n\
+Octave will not automatically recompile function files in subdirectories of\n\
+@file{@var{octave-home}/lib/@var{version}} if they have changed since\n\
+they were last compiled, but will recompile other function files in the\n\
+search path if they change.  If set to @code{\"all\"}, Octave will not\n\
+recompile any function files unless their definitions are removed with\n\
+@code{clear}.  If set to \"none\", Octave will always check time stamps\n\
+on files to determine whether functions defined in function files\n\
+need to recompiled.\n\
+@end deftypefn")
 {
-  for (unsigned int i = 0; i < table_size; i++)
-    {
-      symbol_record *ptr = table[i].next ();
-
-      while (ptr)
-	{
-	  ptr->push_context ();
-	  ptr = ptr->next ();
-	}
-    }
-}
-
-void
-symbol_table::pop_context (void)
-{
-  for (unsigned int i = 0; i < table_size; i++)
-    {
-      symbol_record *ptr = table[i].next ();
-
-      while (ptr)
-	{
-	  ptr->pop_context ();
-	  ptr = ptr->next ();
-	}
-    }
-}
+  octave_value retval;
 
-// Create a new symbol table with the same entries.  Only the symbol
-// names and some attributes are copied, not values.
-
-symbol_table *
-symbol_table::dup (void)
-{
-  symbol_table *new_sym_tab = new symbol_table (table_size);
-
-  for (unsigned int i = 0; i < table_size; i++)
+  if (nargout > 0)
     {
-      symbol_record *ptr = table[i].next ();
-
-      while (ptr)
+      switch (Vignore_function_time_stamp)
 	{
-	  std::string nm = ptr->name ();
+	case 1:
+	  retval = "system";
+	  break;
 
-	  symbol_record *sr = new_sym_tab->lookup (nm, true);
-
-	  if (sr)
-	    {
-	      if (ptr->is_formal_parameter ())
-		sr->mark_as_formal_parameter ();
+	case 2:
+	  retval = "all";
+	  break;
 
-	      if (ptr->is_automatic_variable ())
-		sr->mark_as_automatic_variable ();
-
-	      if (ptr->is_static ())
-		sr->mark_as_static ();
-	    }
-
-	  ptr = ptr->next ();
+	default:
+	  retval = "none";
+	  break;
 	}
     }
 
-  return new_sym_tab;
-}
-
-void
-symbol_table::inherit (symbol_table *parent_sym_tab)
-{
-  for (unsigned int i = 0; i < table_size; i++)
-    {
-      symbol_record *ptr = table[i].next ();
-
-      while (ptr)
-	{
-	  std::string nm = ptr->name ();
-
-	  if (! (nm == "__retval__"
-		 || ptr->is_automatic_variable ()
-		 || ptr->is_formal_parameter ()))
-	    {
-	      symbol_record *sr = parent_sym_tab->lookup (nm);
+  int nargin = args.length ();
 
-	      if (sr)
-		{
-		  ptr->define (sr->variable_value ());
-
-		  ptr->mark_as_static ();
-		}
-	    }
-
-	  ptr = ptr->next ();
-	}
-    }
-}
-
-void
-symbol_table::print_info (std::ostream& os) const
-{
-  int count = 0;
-  int empty_chains = 0;
-  int max_chain_length = 0;
-  int min_chain_length = INT_MAX;
-
-  for (unsigned int i = 0; i < table_size; i++)
+  if (nargin == 1)
     {
-      int num_this_chain = 0;
-
-      symbol_record *ptr = table[i].next ();
-
-      if (ptr)
-	os << "chain number " << i << ":\n";
-      else
-	{
-	  empty_chains++;
-	  min_chain_length = 0;
-	}
-
-      while (ptr)
-	{
-	  num_this_chain++;
-
-	  os << "  " << ptr->name () << "\n";
-
-	  ptr->print_info (os, "    ");
-
-	  ptr = ptr->next ();
-	}
-
-      count += num_this_chain;
-
-      if (num_this_chain > max_chain_length)
-	max_chain_length = num_this_chain;
-
-      if (num_this_chain < min_chain_length)
-	min_chain_length = num_this_chain;
-
-      if (num_this_chain > 0)
-	os << "\n";
-    }
-
-  os << "max chain length: " << max_chain_length << "\n";
-  os << "min chain length: " << min_chain_length << "\n";
-  os << "empty chains:     " << empty_chains << "\n";
-  os << "total chains:     " << table_size << "\n";
-  os << "total symbols:    " << count << "\n";
-}
-
-// Chris Torek's fave hash function.
+      std::string sval = args(0).string_value ();
 
-unsigned int
-symbol_table::hash (const std::string& str)
-{
-  unsigned int h = 0;
-
-  for (unsigned int i = 0; i < str.length (); i++)
-    h = h * 33 + str[i];
-
-  return h & (table_size - 1);
-}
-
-DEFUN (debug_symtab_lookups, args, nargout,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} debug_symtab_lookups ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} debug_symtab_lookups (@var{new_val})\n\
-Query or set the internal variable that controls whether debugging\n\
-information is printed when searching for symbols in the symbol tables.\n\
-@end deftypefn")
-{
-  return SET_INTERNAL_VARIABLE (debug_symtab_lookups);
-}
+      if (! error_state)
+	{
+	  if (sval == "all")
+	    Vignore_function_time_stamp = 2;
+	  else if (sval == "system")
+	    Vignore_function_time_stamp = 1;
+	  else if (sval == "none")
+	    Vignore_function_time_stamp = 0;
+	  else
+	    error ("ignore_function_time_stamp: expecting argument to be \"all\", \"system\", or \"none\"");
+	}
+      else
+	error ("ignore_function_time_stamp: expecting argument to be character string");
+    }
+  else if (nargin > 1)
+    print_usage ();
 
-DEFUN (whos_line_format, args, nargout,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} whos_line_format ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} whos_line_format (@var{new_val})\n\
-Query or set the format string used by the @code{whos}.\n\
-\n\
-The following escape sequences may be used in the format:\n\
-@table @code\n\
-@item %b\n\
-Prints number of bytes occupied by variables.\n\
-@item %c\n\
-Prints class names of variables.\n\
-@item %e\n\
-Prints elements held by variables.\n\
-@item %n\n\
-Prints variable names.\n\
-@item %p\n\
-Prints protection attributes of variables.\n\
-@item %s\n\
-Prints dimensions of variables.\n\
-@item %t\n\
-Prints type names of variables.\n\
-@end table\n\
-\n\
-Every command may also have a modifier:\n\
-@table @code\n\
-@item l\n\
-Left alignment.\n\
-@item r\n\
-Right alignment (this is the default).\n\
-@item c\n\
-Centered (may only be applied to command %s).\n\
-@end table\n\
-\n\
-A command is composed like this:\n\
-\n\
-@example\n\
-%[modifier]<command>[:size_of_parameter[:center-specific[\n\
-       :print_dims[:balance]]]];\n\
-@end example\n\
-\n\
-Command and modifier is already explained. Size_of_parameter\n\
-tells how many columns the parameter will need for printing.\n\
-print_dims tells how many dimensions to print. If number of\n\
-dimensions exceeds print_dims, dimensions will be printed like\n\
-x-D.\n\
-center-specific and print_dims may only be applied to command\n\
-%s. A negative value for print_dims will cause Octave to print all\n\
-dimensions whatsoever.\n\
-balance specifies the offset for printing of the dimensions string.\n\
-\n\
-The default format is \"  %p:4; %ln:6; %cs:16:6:8:1;  %rb:12;  %lc:-1;\\n\".\n\
-@end deftypefn")
-{
-  return SET_INTERNAL_VARIABLE (whos_line_format);
-}
-
-DEFUN (variables_can_hide_functions, args, nargout,
-    "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} variables_can_hide_functions ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} variables_can_hide_functions (@var{new_val})\n\
-Query or set the internal variable that controls whether assignments\n\
-to variables may hide previously defined functions of the same name.\n\
-If set to a nonzero value allows hiding, zero causes Octave to\n\
-generate an error, and a negative value cause Octave to print a\n\
-warning, but allow the operation.\n\
-@end deftypefn")
-{
-  return SET_INTERNAL_VARIABLE (variables_can_hide_functions);
+  return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -1,13 +1,13 @@
 /*
 
 Copyright (C) 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2002, 2003,
               2004, 2005, 2006, 2007 John W. Eaton
-
+  
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
 Octave is distributed in the hope that it will be useful, but WITHOUT
@@ -19,620 +19,1767 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_symtab_h)
 #define octave_symtab_h 1
 
-#include <cassert>
-
-#include <string>
+#include <deque>
+#include <list>
+#include <map>
+#include <set>
 #include <stack>
-#include <sstream>
-
-#include "oct-alloc.h"
-#include "str-vec.h"
-
-#include "ov.h"
-
-class octave_lvalue;
-
-class string_vector;
-
-class symbol_record;
-class symbol_table;
-
-struct
-whos_parameter
-{
-  char command;
-  char modifier;
-  int parameter_length;
-  int first_parameter_length;
-  int dimensions;
-  int balance;
-  std::string text;
-  std::string line;
-};
-
-// Individual records in a symbol table.
-
-class
-OCTINTERP_API
-symbol_record
-{
-public:
-
-  // If you add or delete an entry here, you'll also need to change
-  // the width parameter in the declaration for symbol_type below...
-
-  enum TYPE
-    {
-      UNKNOWN = 0,
-      USER_FUNCTION = 1,
-      USER_VARIABLE = 2,
-      DLD_FUNCTION = 4,
-      BUILTIN_FUNCTION = 8,
-      COMMAND = 16,
-      RAWCOMMAND = 32,
-      MAPPER_FUNCTION = 64,
-      MEX_FUNCTION = 128
-    };
-
-private:
-
-  // Variables or functions.
-
-  class symbol_def
-  {
-  public:
-
-    symbol_def (const octave_value& val = octave_value (),
-		unsigned int sym_type = 0)
-      : symbol_type (sym_type), read_only (0), help_string (),
-	definition (val), count (1) { }
-
-    ~symbol_def (void) { }
-
-    bool is_variable (void) const
-      { return (symbol_type & symbol_record::USER_VARIABLE); }
-
-    // It's not necessary to check for COMMAND and MAPPER_FUNCTION
-    // here.  Those tags are just used as additional qualifiers for
-    // the other types of functions.
-
-    bool is_function (void) const
-      {
-	return (symbol_type & symbol_record::USER_FUNCTION
-		|| symbol_type & symbol_record::DLD_FUNCTION
-		|| symbol_type & symbol_record::MEX_FUNCTION
-		|| symbol_type & symbol_record::BUILTIN_FUNCTION);
-      }
-
-    bool is_user_variable (void) const
-      { return (symbol_type & symbol_record::USER_VARIABLE); }
-
-    // Don't use |= here to avoid error with AIX compiler.
-    void mark_as_command (void)
-      { symbol_type = symbol_type | symbol_record::COMMAND; }
-
-    void unmark_command (void)
-      { symbol_type &= ~symbol_record::COMMAND; }
-
-    bool is_command (void) const
-      { return (symbol_type & symbol_record::COMMAND); }
-
-    void mark_as_rawcommand (void)
-      { symbol_type |= (symbol_record::COMMAND
-			| symbol_record::RAWCOMMAND); }
-
-    void unmark_rawcommand (void)
-      { symbol_type &= ~symbol_record::RAWCOMMAND; }
-
-    bool is_rawcommand (void) const
-      { return (symbol_type & symbol_record::RAWCOMMAND); }      
-
-    bool is_mapper_function (void) const
-      { return (symbol_type & symbol_record::MAPPER_FUNCTION); }
-
-    bool is_user_function (void) const
-      { return (symbol_type & symbol_record::USER_FUNCTION); }
-
-    bool is_builtin_function (void) const
-      { return (symbol_type & symbol_record::BUILTIN_FUNCTION); }
-
-    bool is_dld_function (void) const
-      { return (symbol_type & symbol_record::DLD_FUNCTION); }
-
-    bool is_mex_function (void) const
-      { return (symbol_type & symbol_record::MEX_FUNCTION); }
-
-    // FIXME
-    bool is_map_element (const std::string& /* elts */) const
-      { return false; }
-
-    bool is_defined (void) const
-      { return definition.is_defined (); }
-
-    bool is_read_only (void) const
-      { return read_only; }
-
-    bool is_matrix_type (void) const 
-      { return definition.is_matrix_type (); }
-
-    bool is_sparse_type (void) const
-      { return definition.is_sparse_type (); }
-
-    bool is_complex_type (void) const
-      { return definition.is_complex_type (); }
-
-    std::string class_name (void) const
-      { return definition.class_name (); }
-
-    Matrix size (void) const
-      { return definition.size (); }
-
-    size_t byte_size (void) const
-      { return definition.byte_size (); };
-
-    octave_idx_type numel (void) const
-      { return definition.numel (); };
-
-    octave_idx_type capacity (void) const
-      { return definition.capacity (); };
-
-    dim_vector dims (void) const 
-      { return definition.dims (); }
-
-    octave_idx_type rows (void) const { return definition.rows (); }
-    octave_idx_type columns (void) const { return definition.columns (); }
-
-    std::string type_name (void) const { return definition.type_name (); }
-
-    std::string type_as_string (void) const;
-
-    void type (std::ostream& os, const std::string& name, bool pr_type_info,
-	       bool quiet, bool pr_orig_txt);
-
-    std::string which (const std::string& name);
-
-    void which (std::ostream& os, const std::string& name);
-
-    void define (const octave_value& val, unsigned int sym_type)
-      {
-	definition = val;
-	symbol_type = sym_type;
-      }
-
-    void protect (void) { read_only = 1; }
-
-    void unprotect (void) { read_only = 0; }
-
-    octave_value& def (void) { return definition; }
-
-    std::string help (void) const { return help_string; }
-
-    void document (const std::string& h);
-
-    unsigned int type (void) { return symbol_type; }
-
-    void *operator new (size_t size)
-      { return allocator.alloc (size); }
-
-    void operator delete (void *p, size_t size)
-      { allocator.free (p, size); }
-
-    static octave_allocator allocator;
-
-    // The type of this symbol (see the enum above).
-    unsigned int symbol_type : 9;
-
-    // Nonzero means this variable cannot be given a new value.
-    unsigned int read_only : 1;
-
-    // The doc string associated with this variable.
-    std::string help_string;
-
-    // The value of this definition.  See ov.h and related files.
-    octave_value definition;
-
-    // Reference count.
-    int count;
-
-    void print_info (std::ostream& os,
-		     const std::string& prefix = std::string ()) const;
-
-    // No copying!
-
-    symbol_def (const symbol_def& sd);
-
-    symbol_def& operator = (const symbol_def& sd);
-  };
-
-public:
-
-  typedef int (*change_function) (void);
+#include <string>
 
-  symbol_record (void)
-    : formal_param (false), automatic_variable (false),
-      linked_to_global (false), tagged_static (false),
-      can_hide_function (true), visible (true), eternal (false),
-      nm (), chg_fcn (0), definition (new symbol_def ()), next_elem (0) { }
-
-  // FIXME -- kluge alert!  We obviously need a better way of
-  // handling allow_shadow!
-
-  symbol_record (const std::string& n, symbol_record *nxt)
-    : formal_param (false), automatic_variable (false),
-      linked_to_global (false), tagged_static (false),
-      can_hide_function (n != "__end__"), visible (true),
-      eternal (false), nm (n), chg_fcn (0),
-      definition (new symbol_def ()), next_elem (nxt) { }
-
-  ~symbol_record (void)
-    {
-      if (--definition->count <= 0)
-	delete definition;
-    }
-
-  std::string name (void) const { return nm; }
-
-  std::string help (void) const { return definition->help (); }
-
-  octave_value& def (void) { return definition->def (); }
-
-  void rename (const std::string& new_name);
-
-  bool is_function (void) const
-    { return definition->is_function (); }
-
-  void mark_as_command (void)
-    { definition->mark_as_command (); }
-
-  void unmark_command (void)
-    { definition->unmark_command (); }
-
-  bool is_command (void) const
-    { return definition->is_command (); }
-
-  void mark_as_rawcommand (void)
-    { definition->mark_as_rawcommand (); }
-
-  void unmark_rawcommand (void)
-    { definition->unmark_rawcommand (); }
-
-  bool is_rawcommand (void) const
-    { return definition->is_rawcommand (); }    
-
-  bool is_mapper_function (void) const
-    { return definition->is_mapper_function (); }
-
-  bool is_user_function (void) const
-    { return definition->is_user_function (); }
-
-  bool is_builtin_function (void) const
-    { return definition->is_builtin_function (); }
-
-  bool is_dld_function (void) const
-    { return definition->is_dld_function (); }
-
-  bool is_mex_function (void) const
-    { return definition->is_mex_function (); }
-
-  bool is_variable (void) const
-    { return definition->is_variable (); }
-
-  bool is_user_variable (void) const
-    { return definition->is_user_variable (); }
-
-  bool is_map_element (const std::string& elts) const
-    { return definition->is_map_element (elts); }
-
-  unsigned int type (void) const { return definition->type (); }
-
-  bool is_defined (void) const { return definition->is_defined (); }
-
-  bool is_read_only (void) const { return definition->is_read_only (); }
-
-  bool is_eternal (void) const { return eternal; }
-
-  void protect (void) { definition->protect (); }
-
-  void unprotect (void) { definition->unprotect (); }
-
-  void make_eternal (void) { eternal = 1; }
-
-  void hide (void) { visible = false; }
-  void show (void) { visible = true; }
-  bool is_visible (void) const { return visible; }
-
-  void set_change_function (change_function f) { chg_fcn = f; }
-
-  void define (const octave_value& v, unsigned int sym_type = USER_VARIABLE);
-
-  bool define (octave_function *f, unsigned int sym_type);
-
-  void document (const std::string& h) { definition->document (h); }
-
-  void clear (void);
-
-  void alias (symbol_record *s, bool mark_to_clear = false);
-
-  void mark_as_formal_parameter (void);
-  bool is_formal_parameter (void) const { return formal_param; }
-
-  void mark_as_automatic_variable (void);
-  bool is_automatic_variable (void) const { return automatic_variable; }
-
-  void mark_as_linked_to_global (void);
-  bool is_linked_to_global (void) const { return linked_to_global; }
-
-  void mark_as_static (void);
-  bool is_static (void) const { return tagged_static; }
-  void unmark_static (void) { tagged_static = false; }
+#include "glob-match.h"
 
-  bool is_matrix_type (void) const 
-    { return definition->is_matrix_type (); }
-
-  bool is_sparse_type (void) const
-    { return definition->is_sparse_type (); }
-
-  bool is_complex_type (void) const
-    { return definition->is_complex_type (); }
-
-  std::string class_name (void) const
-    { return definition->class_name (); }
-
-  Matrix size (void) const
-    { return definition->size (); }
-
-  size_t byte_size (void) const
-    { return definition->byte_size (); };
-
-  octave_idx_type numel (void) const
-    { return definition->numel (); };
-
-  octave_idx_type capacity (void) const
-    { return definition->capacity (); };
-
-  dim_vector dims (void) const { return definition->dims (); }
-
-  int dimensions_string_req_first_space (int print_dims) const;
-
-  int dimensions_string_req_total_space (int print_dims) const;
-
-  std::string make_dimensions_string (int print_dims) const;
-
-  octave_idx_type rows (void) const { return definition->rows (); }
-  octave_idx_type columns (void) const { return definition->columns (); }
-
-  std::string type_name (void) const { return definition->type_name (); }
-
-  std::string type_as_string (void) const
-    { return definition->type_as_string (); }
-
-  void type (std::ostream& os, bool pr_type_info, bool quiet, bool pr_orig_txt)
-    { definition->type (os, name (), pr_type_info, quiet, pr_orig_txt); }
-
-  std::string which (void) { return definition->which (name ()); }
-
-  void which (std::ostream& os) { definition->which (os, name ()); }
-
-  octave_value& variable_value (void);
-  octave_lvalue variable_reference (void);
-
-  symbol_record *next (void) const { return next_elem; }
-
-  void chain (symbol_record *s) { next_elem = s; }
-
-  void push_context (void);
-
-  void pop_context (void);
-
-  void print_symbol_info_line (std::ostream& os,
-			       std::list<whos_parameter>& params) const;
+class tree_argument_list;
 
-  void print_info (std::ostream& os,
-		   const std::string& prefix = std::string ()) const;
-
-private:
-
-  unsigned int formal_param : 1;
-  unsigned int automatic_variable : 1;
-  unsigned int linked_to_global : 1;
-  unsigned int tagged_static : 1;
-  unsigned int can_hide_function : 1;
-  unsigned int visible : 1;
-  unsigned int eternal : 1;
-
-  std::string nm;
-  change_function chg_fcn;
-  symbol_def *definition;
-  symbol_record *next_elem;
-
-  // This should maybe be one stack with a structure containing all the
-  // items we need to save for recursive calls...
-  std::stack <symbol_def *> context;
-  std::stack <unsigned int> global_link_context;
-
-  std::stack <symbol_record *> aliases_to_clear;
-
-  void push_alias_to_clear (symbol_record *s)
-    { aliases_to_clear.push (s); }
-
-  bool read_only_error (const char *action);
-
-  void maybe_delete_def (void)
-    {
-      if (--definition->count <= 0)
-        delete definition;
-    }
-
-  // No copying!
-
-  symbol_record (const symbol_record& s);
-
-  symbol_record& operator = (const symbol_record& s);
-};
-
-// A symbol table.
-
-#define SYMTAB_LOCAL_SCOPE 1
-#define SYMTAB_GLOBAL_SCOPE 2
-
-#define SYMTAB_ALL_SCOPES (SYMTAB_LOCAL_SCOPE | SYMTAB_GLOBAL_SCOPE)
-
-#define SYMTAB_ALL_TYPES (symbol_record::USER_FUNCTION \
-			  | symbol_record::USER_VARIABLE \
-			  | symbol_record::DLD_FUNCTION \
-			  | symbol_record::BUILTIN_FUNCTION \
-			  | symbol_record::COMMAND \
-  			  | symbol_record::RAWCOMMAND \
-			  | symbol_record::MAPPER_FUNCTION \
-			  | symbol_record::MEX_FUNCTION)
-
-#define SYMTAB_VARIABLES (symbol_record::USER_VARIABLE)
+#include "oct-obj.h"
+#include "ov.h"
 
 class
 OCTINTERP_API
 symbol_table
 {
 public:
 
-  symbol_table (unsigned int tab_size = 64,
-		const std::string& nm = std::string ())
-    : table_size (tab_size), table (new symbol_record [table_size]),
-      table_name (nm)
+  typedef int scope_id;
+
+  class
+  symbol_record
+  {
+  public:
+
+    // generic variable
+    static const unsigned int local = 1;
+
+    // varargin, argn, .nargin., .nargout.
+    // (FIXME -- is this really used now?)
+    static const unsigned int automatic = 2;
+
+    // formal parameter
+    static const unsigned int formal = 4;
+
+    // not listed or cleared (.nargin., .nargout.)
+    static const unsigned int hidden = 8;
+
+    // inherited from parent scope; not cleared at function exit
+    static const unsigned int inherited = 16;
+
+    // global (redirects to global scope)
+    static const unsigned int global = 32;
+
+    // not cleared at function exit
+    static const unsigned int persistent = 64;
+
+  private:
+
+    class
+    symbol_record_rep
     {
-      assert ((tab_size % 2) == 0);
+    public:
+
+      symbol_record_rep (const std::string& nm, const octave_value& v,
+			 unsigned int sc)
+	: name (nm), value_stack (), storage_class (sc), count (1)
+      {
+	value_stack.push (v);
+      }
+
+      octave_value& varref (void) { return value_stack.top (); }
+
+      octave_value varval (void) const { return value_stack.top (); }
+
+      void push_context (void) { value_stack.push (octave_value ()); }
+
+      void pop_context (void) { value_stack.pop (); }
+
+      void clear (void)
+      {
+	if (! (is_hidden () || is_inherited ()))
+	  {
+	    if (is_global ())
+	      unmark_global ();
+
+	    if (is_persistent ())
+	      {
+		symbol_table::persistent_varref (name) = varval ();
+		unmark_persistent ();
+	      }
+
+	    varref () = octave_value ();
+	  }
+      }
+
+      bool is_defined (void) const { return varval ().is_defined (); }
+
+      bool is_variable (void) const
+      {
+	return (storage_class != local || is_defined ());
+      }
+
+      bool is_local (void) const { return storage_class & local; }
+      bool is_automatic (void) const { return storage_class & automatic; }
+      bool is_formal (void) const { return storage_class & formal; }
+      bool is_hidden (void) const { return storage_class & hidden; }
+      bool is_inherited (void) const { return storage_class & inherited; }
+      bool is_global (void) const { return storage_class & global; }
+      bool is_persistent (void) const { return storage_class & persistent; }
+
+      void mark_local (void) { storage_class |= local; }
+      void mark_automatic (void) { storage_class |= automatic; }
+      void mark_formal (void) { storage_class |= formal; }
+      void mark_hidden (void) { storage_class |= hidden; }
+      void mark_inherited (void) { storage_class |= inherited; }
+      void mark_global (void)
+      {
+	if (is_persistent ())
+	  error ("can't make persistent variable %s global", name.c_str ());
+	else
+	  storage_class |= global;
+      }
+      void mark_persistent (void)
+      {
+	if (is_global ())
+	  error ("can't make global variable %s persistent", name.c_str ());
+	else
+	  storage_class |= persistent;
+      }
+
+      void unmark_local (void) { storage_class &= ~local; }
+      void unmark_automatic (void) { storage_class &= ~automatic; }
+      void unmark_formal (void) { storage_class &= ~formal; }
+      void unmark_hidden (void) { storage_class &= ~hidden; }
+      void unmark_inherited (void) { storage_class &= ~inherited; }
+      void unmark_global (void) { storage_class &= ~global; }
+      void unmark_persistent (void) { storage_class &= ~persistent; }
+
+      void init_persistent (void)
+      {
+	if (! is_defined ())
+	  {
+	    mark_persistent ();
+
+	    varref () = symbol_table::persistent_varval (name);
+	  }
+	// FIXME -- this causes trouble with recursive calls.
+	// else
+	//   error ("unable to declare existing variable persistent");
+      }
+
+      void erase_persistent (void)
+      {
+	unmark_persistent ();
+	symbol_table::erase_persistent (name);
+      }
+
+      symbol_record_rep *dup (void)
+      {
+	return new symbol_record_rep (name, varval (), storage_class);
+      }
+
+      std::string name;
+
+      std::stack<octave_value> value_stack;
+
+      unsigned int storage_class;
+
+      size_t count;
+
+    private:
+
+      // No copying!
+
+      symbol_record_rep (const symbol_record_rep& ov);
+
+      symbol_record_rep& operator = (const symbol_record_rep&);
+    };
+
+  public:
+
+    symbol_record (const std::string& nm = std::string (),
+		   const octave_value& v = octave_value (),
+		   unsigned int sc = local)
+      : rep (new symbol_record_rep (nm, v, sc)) { }
+
+    symbol_record (const symbol_record& sr)
+      : rep (sr.rep)
+    { 
+      rep->count++;
+    }
+
+    symbol_record& operator = (const symbol_record& sr)
+    {
+      if (this != &sr)
+	{
+	  rep = sr.rep;
+	  rep->count++;
+	}
+
+      return *this;
+    }
+
+    ~symbol_record (void)
+    {
+      if (--rep->count == 0)
+	delete rep;
+    }
+
+    symbol_record dup (void) const { return symbol_record (rep->dup ()); }
+
+    std::string name (void) const { return rep->name; }
+
+    octave_value
+    find (tree_argument_list *args, const string_vector& arg_names,
+	  octave_value_list& evaluated_args, bool& args_evaluated) const;
+
+    octave_value& varref (void)
+    {
+      return is_global ()
+	? symbol_table::varref (name (), symbol_table::global_scope ())
+	: rep->varref ();
+    }
+
+    octave_value varval (void) const
+    {
+      return is_global ()
+	? symbol_table::varval (name (), symbol_table::global_scope ())
+	: rep->varval ();
+    }
+
+    void push_context (void)
+    {
+      if (! (is_persistent () || is_global ()))
+	rep->push_context ();
+    }
+
+    void pop_context (void)
+    {
+      if (! (is_persistent () || is_global ()))
+	rep->pop_context ();
+    }
+
+    void clear (void) { rep->clear (); }
+
+    bool is_defined (void) const { return rep->is_defined (); }
+    bool is_variable (void) const { return rep->is_variable (); }
+
+    bool is_local (void) const { return rep->is_local (); }
+    bool is_automatic (void) const { return rep->is_automatic (); }
+    bool is_formal (void) const { return rep->is_formal (); }
+    bool is_global (void) const { return rep->is_global (); }
+    bool is_hidden (void) const { return rep->is_hidden (); }
+    bool is_inherited (void) const { return rep->is_inherited (); }
+    bool is_persistent (void) const { return rep->is_persistent (); }
+
+    void mark_local (void) { rep->mark_local (); }
+    void mark_automatic (void) { rep->mark_automatic (); }
+    void mark_formal (void) { rep->mark_formal (); }
+    void mark_hidden (void) { rep->mark_hidden (); }
+    void mark_inherited (void) { rep->mark_inherited (); }
+    void mark_global (void) { rep->mark_global (); }
+    void mark_persistent (void) { rep->mark_persistent (); }
+
+    void unmark_local (void) { rep->unmark_local (); }
+    void unmark_automatic (void) { rep->unmark_automatic (); }
+    void unmark_formal (void) { rep->unmark_formal (); }
+    void unmark_hidden (void) { rep->unmark_hidden (); }
+    void unmark_inherited (void) { rep->unmark_inherited (); }
+    void unmark_global (void) { rep->unmark_global (); }
+    void unmark_persistent (void) { rep->unmark_persistent (); }
+
+    void init_persistent (void) { rep->init_persistent (); }
+
+    void erase_persistent (void) { rep->erase_persistent (); }
+
+    unsigned int xstorage_class (void) const { return rep->storage_class; }
+
+  private:
+
+    symbol_record_rep *rep;
+
+    symbol_record (symbol_record_rep *new_rep) : rep (new_rep) { }
+  };
+
+  class
+  fcn_info
+  {
+  public:
+
+    typedef std::map<std::string, std::string> dispatch_map_type;
+
+    typedef std::map<scope_id, octave_value>::const_iterator const_scope_val_iterator;
+    typedef std::map<scope_id, octave_value>::iterator scope_val_iterator;
 
-      if (table_name.empty ())
+    typedef std::map<std::string, octave_value>::const_iterator const_str_val_iterator;
+    typedef std::map<std::string, octave_value>::iterator str_val_iterator;
+
+    typedef dispatch_map_type::const_iterator const_dispatch_map_iterator;
+    typedef dispatch_map_type::iterator dispatch_map_iterator;
+
+  private:
+
+    class
+    fcn_info_rep
+    {
+    public:
+
+      fcn_info_rep (const std::string& nm)
+	: name (nm), subfunctions (), private_functions (),
+	  class_constructors (), class_methods (), cmdline_function (),
+	  autoload_function (), function_on_path (), built_in_function (),
+	  count (1) { }
+
+      octave_value load_private_function (const std::string& dir_name);
+
+      octave_value load_class_constructor (void);
+
+      octave_value load_class_method (const std::string& dispatch_type);
+
+      octave_value
+      find (tree_argument_list *args, const string_vector& arg_names,
+	    octave_value_list& evaluated_args, bool& args_evaluated,
+	    scope_id scope);
+
+      octave_value find_method (const std::string& dispatch_type);
+
+      octave_value find_autoload (void);
+
+      octave_value find_user_function (void);
+
+      bool is_user_function_defined (void) const
+      {
+	return function_on_path.is_defined ();
+      }
+
+      octave_value find_function (scope_id scope)
+      {
+	octave_value_list args;
+
+	return find_function (args, scope);
+      }
+
+      octave_value find_function (const octave_value_list& args,
+				  scope_id scope)
+      {
+	string_vector arg_names;
+	octave_value_list evaluated_args = args;
+	bool args_evaluated;
+
+	return find (0, arg_names, evaluated_args, args_evaluated, scope);
+      }
+
+      void install_cmdline_function (const octave_value& f)
+      {
+	cmdline_function = f;
+      }
+
+      void install_subfunction (const octave_value& f, scope_id scope)
+      {
+	subfunctions[scope] = f;
+      }
+
+      void install_user_function (const octave_value& f)
+      {
+	function_on_path = f;
+      }
+
+      void install_built_in_function (const octave_value& f)
+      {
+	built_in_function = f;
+      }
+
+      void clear (void)
+      {
+	subfunctions.clear ();
+	private_functions.clear ();
+	class_constructors.clear ();
+	class_methods.clear ();
+	cmdline_function = octave_value ();
+	autoload_function = octave_value ();
+	function_on_path = octave_value ();
+      }
+
+      // FIXME -- should this also clear the cmdline and other "user
+      // defined" functions?
+      void clear_user_function (void)
+      {
+	function_on_path = octave_value ();
+      }
+
+      void clear_mex_function (void)
+      {
+	if (function_on_path.is_mex_function ())
+	  function_on_path = octave_value ();
+      }
+
+      void add_dispatch (const std::string& type, const std::string& fname)
+      {
+	dispatch_map[type] = fname;
+      }
+
+      void clear_dispatch (const std::string& type)
+      {
+	dispatch_map_iterator p = dispatch_map.find (type);
+
+	if (p != dispatch_map.end ())
+	  dispatch_map.erase (p);
+      }
+
+      void print_dispatch (std::ostream& os) const;
+
+      std::string help_for_dispatch (void) const;
+
+      dispatch_map_type get_dispatch (void) const { return dispatch_map; }
+
+      std::string name;
+
+      // Scope id to function object.
+      std::map<scope_id, octave_value> subfunctions;
+
+      // Directory name to function object.
+      std::map<std::string, octave_value> private_functions;
+
+      // Class name to function object.
+      std::map<std::string, octave_value> class_constructors;
+
+      // Dispatch type to function object.
+      std::map<std::string, octave_value> class_methods;
+
+      // Legacy dispatch map (dispatch type name to function name).
+      dispatch_map_type dispatch_map;
+
+      octave_value cmdline_function;
+
+      octave_value autoload_function;
+
+      octave_value function_on_path;
+
+      octave_value built_in_function;
+
+      size_t count;
+
+    private:
+
+      // No copying!
+
+      fcn_info_rep (const fcn_info_rep&);
+
+      fcn_info_rep& operator = (const fcn_info_rep&);
+    };
+
+  public:
+
+    fcn_info (const std::string& nm = std::string ())
+      : rep (new fcn_info_rep (nm)) { }
+
+    fcn_info (const fcn_info& ov) : rep (ov.rep)
+    { 
+      rep->count++;
+    }
+
+    fcn_info& operator = (const fcn_info& ov)
+    {
+      if (this != &ov)
 	{
-	  std::ostringstream buf;
-	  buf << symtab_count++;
-	  table_name = buf.str ();
+	  rep = ov.rep;
+	  rep->count++;
 	}
+
+      return *this;
+    }
+
+    ~fcn_info (void)
+    {
+      if (--rep->count == 0)
+	delete rep;
+    }
+
+    octave_value
+    find (tree_argument_list *args, const string_vector& arg_names,
+	  octave_value_list& evaluated_args, bool& args_evaluated,
+	  scope_id scope);
+
+    octave_value find_method (const std::string& dispatch_type) const
+    {
+      return rep->find_method (dispatch_type);
+    }
+
+    octave_value find_built_in_function (void) const
+    {
+      return rep->built_in_function;
+    }
+
+    octave_value find_autoload (void)
+    {
+      return rep->find_autoload ();
+    }
+
+    octave_value find_user_function (void)
+    {
+      return rep->find_user_function ();
+    }
+
+    bool is_user_function_defined (void) const
+    {
+      return rep->is_user_function_defined ();
+    }
+
+    octave_value find_function (scope_id scope)
+    {
+      return rep->find_function (scope);
+    }
+
+    octave_value find_function (const octave_value_list& args,
+				scope_id scope)
+    {
+      return rep->find_function (args, scope);
+    }
+
+    void install_cmdline_function (const octave_value& f)
+    {
+      rep->install_cmdline_function (f);
+    }
+
+    void install_subfunction (const octave_value& f, scope_id scope)
+    {
+      rep->install_subfunction (f, scope);
+    }
+
+    void install_user_function (const octave_value& f)
+    {
+      rep->install_user_function (f);
+    }
+
+    void install_built_in_function (const octave_value& f)
+    {
+      rep->install_built_in_function (f);
+    }
+
+    void clear (void) { rep->clear (); }
+    
+    void clear_user_function (void) { rep->clear_user_function (); }
+    
+    void clear_mex_function (void) { rep->clear_mex_function (); }
+    
+    void add_dispatch (const std::string& type, const std::string& fname)
+    {
+      rep->add_dispatch (type, fname);
+    }
+
+    void clear_dispatch (const std::string& type)
+    {
+      rep->clear_dispatch (type);
+    }
+
+    void print_dispatch (std::ostream& os) const
+    {
+      rep->print_dispatch (os);
+    }
+
+    std::string help_for_dispatch (void) const { return rep->help_for_dispatch (); }
+
+    dispatch_map_type get_dispatch (void) const
+    {
+      return rep->get_dispatch ();
     }
 
-  ~symbol_table (void);
+  private:
+
+    fcn_info_rep *rep;
+  };
+
+  static scope_id global_scope (void) { return xglobal_scope; }
+  static scope_id top_scope (void) { return xtop_scope; }
+
+  static scope_id current_scope (void) { return xcurrent_scope; }
+  static scope_id current_caller_scope (void) { return xcurrent_caller_scope; }
+
+  // We use parent_scope to handle parsing subfunctions.
+  static scope_id parent_scope (void) { return xparent_scope; }
+
+  static scope_id alloc_scope (void)
+  {
+    scope_id retval;
+
+    scope_ids_free_list_iterator p = scope_ids_free_list.begin ();
+
+    if (p != scope_ids_free_list.end ())
+      {
+	retval = *p;
+	scope_ids_free_list.erase (p);
+      }
+    else
+      retval = next_available_scope++;
+
+    scope_ids_in_use.insert (retval);
+
+    return retval;
+  }
+
+  static void set_scope (scope_id scope)
+  {
+    if (scope == xglobal_scope)
+      error ("can't set scope to global");
+    else if (scope != xcurrent_scope)
+      {
+	all_instances_iterator p = all_instances.find (scope);
+
+	if (p == all_instances.end ())
+	  {
+	    instance = new symbol_table ();
 
-  symbol_record *lookup (const std::string& nm, bool insert = false,
-			 bool warn = false);
+	    all_instances[scope] = instance;
+	  }
+	else
+	  instance = p->second;
+
+	xcurrent_scope = scope;
+      }
+  }
+
+  static void push_scope (scope_id scope)
+  {
+    if (scope_stack.empty ())
+      scope_stack.push_front (xtop_scope);
+
+    xcurrent_caller_scope = xcurrent_scope;
+
+    set_scope (scope);
+
+    scope_stack.push_front (scope);
+  }
+
+  static void pop_scope (void)
+  {
+    scope_stack.pop_front ();
 
-  void rename (const std::string& old_name, const std::string& new_name);
+    set_scope (scope_stack[0]);
+
+    xcurrent_caller_scope = scope_stack[1];
+  }
+
+  static void pop_scope (void *) { pop_scope (); }
+
+  static void reset_scope (void)
+  {
+    scope_stack.clear ();
+
+    scope_stack.push_front (xtop_scope);
 
-  void clear (void);
+    set_scope (xtop_scope);
+
+    xcurrent_caller_scope = -1;
+  }
+
+  static void set_parent_scope (scope_id scope)
+  {
+    xparent_scope = scope;
+  }
+
+  static void reset_parent_scope (void)
+  {
+    set_parent_scope (-1);
+  }
 
-  void clear_variables (void);
-  void clear_functions (void);
-  void clear_mex_functions (void);
-  void clear_globals (void);
+  static void erase_scope (scope_id scope = xcurrent_scope)
+  {
+    all_instances_iterator p = all_instances.find (scope);
+
+    if (p != all_instances.end ())
+      all_instances.erase (p);
+
+    // free_scope (scope);
+  }
+
+  static scope_id dup_scope (scope_id scope = xcurrent_scope)
+  {
+    scope_id retval = -1;
+
+    symbol_table *inst = get_instance (scope);
+
+    if (inst)
+      {
+	scope_id new_scope = alloc_scope ();
+
+	symbol_table *new_symbol_table = new symbol_table ();
+
+	if (new_symbol_table)
+	  {
+	    all_instances[new_scope] = new_symbol_table;
+
+	    inst->do_dup_scope (*new_symbol_table);
+
+	    retval = new_scope;
+	  }
+      }
+
+    return retval;
+  }
+
+#if 0
+  static void print_scope (const std::string& tag, scope_id scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    if (inst)
+      {
+	std::cerr << "printing " << tag << ", scope: " << scope
+		  << ", inst: " << inst << std::endl;
+
+	inst->do_print_scope (std::cerr);
+      }
+  }
 
-  bool clear (const std::string& nm);
+  void do_print_scope (std::ostream& os) const
+  {
+    for (const_table_iterator p = table.begin (); p != table.end (); p++)
+      {
+	symbol_record sr = p->second;
+
+	octave_value val = sr.varval ();
+
+	if (val.is_defined ())
+	  sr.varval ().print_with_name (os, sr.name ());
+	else
+	  os << sr.name () << " is not defined" << std::endl;
+      }
+  }
+#endif
+
+  static symbol_record find_symbol (const std::string& name,
+				    scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    return inst ? inst->do_find_symbol (name) : symbol_record ();
+  }
 
-  bool clear_variable (const std::string& nm);
-  bool clear_function (const std::string& nm);
-  bool clear_global (const std::string& nm);
+  static void inherit (scope_id scope, scope_id donor_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    if (inst)
+      inst->do_inherit (donor_scope);
+  }
+
+  static bool at_top_level (void) { return xcurrent_scope == xtop_scope; }
+
+  // Find a value corresponding to the given name in the table.
+  static octave_value
+  find (const std::string& name, tree_argument_list *args,
+	const string_vector& arg_names,
+	octave_value_list& evaluated_args, bool& args_evaluated,
+	scope_id scope = xcurrent_scope, bool skip_variables = false);
+
+  // Insert a new name in the table.
+  static symbol_record&
+  insert (const std::string& name, scope_id scope = xcurrent_scope)
+  {
+    static symbol_record foobar;
+
+    symbol_table *inst = get_instance (scope);
 
-  bool clear_variable_pattern (const std::string& pat);
-  bool clear_function_pattern (const std::string& pat);
-  bool clear_global_pattern (const std::string& pat);
+    return inst ? inst->do_insert (name) : foobar;
+  }
+
+  static octave_value&
+  varref (const std::string& name, scope_id scope = xcurrent_scope)
+  {
+    static octave_value foobar;
+
+    symbol_table *inst = get_instance (scope);
+
+    return inst ? inst->do_varref (name) : foobar;
+  }
+
+  static octave_value
+  varval (const std::string& name, scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    return inst ? inst->do_varval (name) : octave_value ();
+  }
+
+  static octave_value&
+  persistent_varref (const std::string& name, scope_id scope = xcurrent_scope)
+  {
+    static octave_value foobar;
+
+    symbol_table *inst = get_instance (scope);
+
+    return inst ? inst->do_persistent_varref (name) : foobar;
+  }
+
+  static octave_value
+  persistent_varval (const std::string& name, scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    return inst ? inst->do_persistent_varval (name) : octave_value ();
+  }
+
+  static void
+  erase_persistent (const std::string& name, scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    if (inst)
+      inst->do_erase_persistent (name);
+  }
 
-  int size (void) const;
+  static bool
+  is_variable (const std::string& name, scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    return inst ? inst->do_is_variable (name) : false;
+  }
+
+  static bool
+  is_built_in_function_name (const std::string& name)
+  {
+    octave_value val = find_built_in_function (name);
+
+    return val.is_defined ();
+  }
+
+  static octave_value
+  find_method (const std::string& name, const std::string& dispatch_type)
+  {
+    const_fcn_table_iterator p = fcn_table.find (name);
 
-  Array<symbol_record *>
-  subsymbol_list (const string_vector& pats = string_vector (),
-		  unsigned int type = SYMTAB_ALL_TYPES,
-		  unsigned int scope = SYMTAB_ALL_SCOPES) const;
+    if (p != fcn_table.end ())
+      return p->second.find_method (dispatch_type);
+    else
+      {
+	fcn_info finfo (name);
+
+	octave_value fcn = finfo.find_method (dispatch_type);
+
+	if (fcn.is_defined ())
+	  fcn_table[name] = finfo;
+
+	return fcn;
+      }
+  }
+
+  static octave_value
+  find_built_in_function (const std::string& name)
+  {
+    const_fcn_table_iterator p = fcn_table.find (name);
+
+    return (p != fcn_table.end ())
+      ? p->second.find_built_in_function () : octave_value ();
+  }
+
+  static octave_value
+  find_autoload (const std::string& name)
+  {
+    fcn_table_iterator p = fcn_table.find (name);
 
-  Array<symbol_record *>
-  symbol_list (const string_vector& pats = string_vector (),
-	       unsigned int type = SYMTAB_ALL_TYPES,
-	       unsigned int scope = SYMTAB_ALL_SCOPES) const;
+    return (p != fcn_table.end ())
+      ? p->second.find_autoload () : octave_value ();
+  }
+
+  static octave_value
+  find_function (const std::string& name, tree_argument_list *args,
+		 const string_vector& arg_names,
+		 octave_value_list& evaluated_args, bool& args_evaluated,
+		 scope_id scope = xcurrent_scope);
+
+  static octave_value
+  find_user_function (const std::string& name)
+  {
+    fcn_table_iterator p = fcn_table.find (name);
+
+    return (p != fcn_table.end ())
+      ? p->second.find_user_function () : octave_value ();
+  }
+
+  static octave_value
+  find_function (const std::string& name, scope_id scope = xcurrent_scope)
+  {
+    octave_value_list evaluated_args;
+
+    return find_function (name, evaluated_args, scope);
+  }
+
+  static octave_value
+  find_function (const std::string& name, const octave_value_list& args,
+		 scope_id scope = xcurrent_scope)
+  {
+    string_vector arg_names;
+    octave_value_list evaluated_args = args;
+    bool args_evaluated = ! args.empty ();
+
+    return find_function (name, 0, arg_names, evaluated_args,
+			  args_evaluated, scope);
+  }
+
+  static void install_cmdline_function (const std::string& name,
+					const octave_value& fcn)
+  {
+    fcn_table_iterator p = fcn_table.find (name);
+
+    if (p != fcn_table.end ())
+      {
+	fcn_info& finfo = p->second;
 
+	finfo.install_cmdline_function (fcn);
+      }
+    else
+      {
+	fcn_info finfo (name);
 
-  string_vector
-  name_list (const string_vector& pats = string_vector (),
-	     bool sort = false, unsigned int type = SYMTAB_ALL_TYPES,
-	     unsigned int scope = SYMTAB_ALL_SCOPES) const;
+	finfo.install_cmdline_function (fcn);
+
+	fcn_table[name] = finfo;
+      }
+  }
+
+  static void install_subfunction (const std::string& name,
+				   const octave_value& fcn,
+				   scope_id scope = xparent_scope)
+  {
+    fcn_table_iterator p = fcn_table.find (name);
+
+    if (p != fcn_table.end ())
+      {
+	fcn_info& finfo = p->second;
+
+	finfo.install_subfunction (fcn, scope);
+      }
+    else
+      {
+	fcn_info finfo (name);
+
+	finfo.install_subfunction (fcn, scope);
+
+	fcn_table[name] = finfo;
+      }
+  }
+
+  static void install_user_function (const std::string& name,
+				     const octave_value& fcn)
+  {
+    fcn_table_iterator p = fcn_table.find (name);
+
+    if (p != fcn_table.end ())
+      {
+	fcn_info& finfo = p->second;
+
+	finfo.install_user_function (fcn);
+      }
+    else
+      {
+	fcn_info finfo (name);
+
+	finfo.install_user_function (fcn);
+
+	fcn_table[name] = finfo;
+      }
+  }
 
-  string_vector
-  user_function_name_list (void) const
-    {
-      return name_list
-	(string_vector (), false,
-	 symbol_record::USER_FUNCTION|symbol_record::DLD_FUNCTION|symbol_record::MEX_FUNCTION,
-	 SYMTAB_ALL_SCOPES);
-    }
+  static void install_built_in_function (const std::string& name,
+					 const octave_value& fcn)
+  {
+    fcn_table_iterator p = fcn_table.find (name);
+
+    if (p != fcn_table.end ())
+      {
+	fcn_info& finfo = p->second;
+
+	finfo.install_built_in_function (fcn);
+      }
+    else
+      {
+	fcn_info finfo (name);
+
+	finfo.install_built_in_function (fcn);
+
+	fcn_table[name] = finfo;
+      }
+  }
+
+  static void clear (const std::string& name, scope_id scope = xcurrent_scope)
+  {
+    clear_variable (name, scope);
+  }
+
+  static void clear_all (void)
+  {
+    clear_variables ();
+
+    clear_functions ();
+  }
+
+  static void clear_variables (scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    if (inst)
+      inst->do_clear_variables ();
+  }
+
+  // For unwind_protect.
+  static void clear_variables (void *) { clear_variables (); }
+
+  static void clear_functions (void)
+  {
+    for (fcn_table_iterator p = fcn_table.begin (); p != fcn_table.end (); p++)
+      p->second.clear ();
+  }
+
+  static void clear_function (const std::string& name)
+  {
+    clear_user_function (name);
+  }
+
+  static void clear_global (const std::string& name,
+			    scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    if (inst)
+      inst->do_clear_global (name);
+  }
+
+  static void clear_variable (const std::string& name,
+			      scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    if (inst)
+      inst->do_clear_variable (name);
+  }
+
+  static void clear_symbol (const std::string& name)
+  {
+    // FIXME -- are we supposed to do both here?
+
+    clear_variable (name);
+    clear_function (name);
+  }
+
+  static void clear_function_pattern (const std::string& pat)
+  {
+    glob_match pattern (pat);
+
+    for (fcn_table_iterator p = fcn_table.begin (); p != fcn_table.end (); p++)
+      {
+	if (pattern.match (p->first))
+	  p->second.clear_user_function ();
+      }
+  }
+
+  static void clear_global_pattern (const std::string& pat,
+				    scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
 
-  string_vector
-  global_variable_name_list (void) const
-    {
-      return name_list
-	(string_vector (), false, SYMTAB_VARIABLES, SYMTAB_GLOBAL_SCOPE);
-    }
+    if (inst)
+      inst->do_clear_global_pattern (pat);
+  }
+
+  static void clear_variable_pattern (const std::string& pat,
+				      scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    if (inst)
+      inst->do_clear_variable_pattern (pat);
+  }
+
+  static void clear_symbol_pattern (const std::string& pat)
+  {
+    // FIXME -- are we supposed to do both here?
+
+    clear_variable_pattern (pat);
+    clear_function_pattern (pat);
+  }
+
+  static void clear_user_function (const std::string& name)
+  {
+    fcn_table_iterator p = fcn_table.find (name);
+
+    if (p != fcn_table.end ())
+      {
+	fcn_info& finfo = p->second;
+
+	finfo.clear_user_function ();
+      }
+    // FIXME -- is this necessary, or even useful?
+    // else
+    //   error ("clear: no such function `%s'", name.c_str ());
+  }
+
+  static void clear_mex_functions (void)
+  {
+    for (fcn_table_iterator p = fcn_table.begin (); p != fcn_table.end (); p++)
+      {
+	fcn_info& finfo = p->second;
+
+	finfo.clear_mex_function ();
+      }
+  }
+
+  static void alias_built_in_function (const std::string& alias,
+				       const std::string& name)
+  {
+    octave_value fcn = find_built_in_function (name);
+
+    if (fcn.is_defined ())
+      {
+	fcn_info finfo (alias);
+
+	finfo.install_built_in_function (fcn);
+
+	fcn_table[alias] = finfo;
+      }
+    else
+      panic ("alias: `%s' is undefined", name.c_str ());
+  }
+
+  static void add_dispatch (const std::string& name, const std::string& type,
+			    const std::string& fname)
+  {
+    fcn_table_iterator p = fcn_table.find (name);
+
+    if (p != fcn_table.end ())
+      {
+	fcn_info& finfo = p->second;
+
+	finfo.add_dispatch (type, fname);
+      }
+    else
+      {
+	fcn_info finfo (name);
+
+	finfo.add_dispatch (type, fname);
+
+	fcn_table[name] = finfo;
+      }
+  }
+
+  static void clear_dispatch (const std::string& name, const std::string& type)
+  {
+    fcn_table_iterator p = fcn_table.find (name);
+
+    if (p != fcn_table.end ())
+      {
+	fcn_info& finfo = p->second;
+
+	finfo.clear_dispatch (type);
+      }
+  }
+
+  static void print_dispatch (std::ostream& os, const std::string& name)
+  {
+    fcn_table_iterator p = fcn_table.find (name);
 
-  string_vector
-  variable_name_list (void) const
-    {
-      return name_list
-	(string_vector (), false, SYMTAB_VARIABLES, SYMTAB_LOCAL_SCOPE);
-    }
+    if (p != fcn_table.end ())
+      {
+	fcn_info& finfo = p->second;
+
+	finfo.print_dispatch (os);
+      }
+  }
+
+  static fcn_info::dispatch_map_type get_dispatch (const std::string& name)
+  {
+    fcn_info::dispatch_map_type retval;
+
+    fcn_table_iterator p = fcn_table.find (name);
+
+    if (p != fcn_table.end ())
+      {
+	fcn_info& finfo = p->second;
+
+	retval = finfo.get_dispatch ();
+      }
+
+    return retval;
+  }
+
+  static std::string help_for_dispatch (const std::string& name)
+  {
+    std::string retval;
+
+    fcn_table_iterator p = fcn_table.find (name);
+
+    if (p != fcn_table.end ())
+      {
+	fcn_info& finfo = p->second;
+
+	retval = finfo.help_for_dispatch ();
+      }
+
+    return retval;
+  }
+
+  static void push_context (scope_id scope = xcurrent_scope)
+  {
+    if (scope == xglobal_scope || scope == xtop_scope)
+      error ("invalid call to xymtab::push_context");
+    else
+      {
+	symbol_table *inst = get_instance (scope);
+
+	if (inst)
+	  inst->do_push_context ();
+      }
+  }
+
+  static void pop_context (scope_id scope = xcurrent_scope)
+  {
+    if (scope == xglobal_scope || scope == xtop_scope)
+      error ("invalid call to xymtab::push_context");
+    else
+      {
+	symbol_table *inst = get_instance (scope);
+
+	if (inst)
+	  inst->do_pop_context ();
+      }
+  }
+
+  // For unwind_protect.
+  static void pop_context (void *) { pop_context (); }
+
+  static void mark_hidden (const std::string& name,
+			   scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    if (inst)
+      inst->do_mark_hidden (name);
+  }
+
+  static void mark_global (const std::string& name,
+			   scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    if (inst)
+      inst->do_mark_global (name);
+  }
+
+  static std::list<symbol_record>
+  all_variables (scope_id scope = xcurrent_scope, bool defined_only = true)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    return inst
+      ? inst->do_all_variables (defined_only) : std::list<symbol_record> ();
+  }
 
-  int maybe_list (const char *header, const string_vector& argv,
-		  std::ostream& os, bool show_verbose,
-		  unsigned type, unsigned scope);
-  
-  Array<symbol_record *> glob (const std::string& pat = std::string ("*"),
-			       unsigned int type = SYMTAB_ALL_TYPES,
-			       unsigned int scope = SYMTAB_ALL_SCOPES) const;
+  static std::list<symbol_record>
+  glob (const std::string& pattern, scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    return inst ? inst->do_glob (pattern) : std::list<symbol_record> ();
+  }
+
+  static std::list<symbol_record>
+  glob_variables (const std::string& pattern, scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    return inst ? inst->do_glob (pattern, true) : std::list<symbol_record> ();
+  }
+
+  static std::list<symbol_record>
+  glob_variables (const string_vector& patterns,
+		  scope_id scope = xcurrent_scope)
+  {
+    std::list<symbol_record> retval;
+
+    size_t len = patterns.length ();
 
-  void push_context (void);
+    for (size_t i = 0; i < len; i++)
+      {
+	std::list<symbol_record> tmp = glob_variables (patterns[i], scope);
+
+	retval.insert (retval.begin (), tmp.begin (), tmp.end ());
+      }
+
+    return retval;
+  }
+
+  static std::list<std::string> user_function_names (void)
+  {
+    std::list<std::string> retval;
+
+    for (fcn_table_iterator p = fcn_table.begin ();
+	 p != fcn_table.end (); p++)
+      {
+	if (p->second.is_user_function_defined ())
+	  retval.push_back (p->first);
+      }
+
+    if (! retval.empty ())
+      retval.sort ();
+
+    return retval;
+  }
 
-  void pop_context (void);
+  static std::list<std::string>
+  variable_names (scope_id scope = xcurrent_scope)
+  {
+    symbol_table *inst = get_instance (scope);
+
+    return inst ? inst->do_variable_names () : std::list<std::string> ();
+  }
+
+  static std::list<std::string> built_in_function_names (void)
+  {
+    std::list<std::string> retval;
+
+    for (const_fcn_table_iterator p = fcn_table.begin ();
+	 p != fcn_table.end (); p++)
+      {
+	octave_value fcn = p->second.find_built_in_function ();
+
+	if (fcn.is_defined ())
+	  retval.push_back (p->first);
+      }
+
+    if (! retval.empty ())
+      retval.sort ();
 
-  // Create a new symbol table with the same entries.  Only the symbol
-  // names and some attributes are copied, not values.
-  symbol_table *dup (void);
+    return retval;
+  }
+
+  static bool is_local_variable (const std::string& name,
+				 scope_id scope = xcurrent_scope)
+  {
+    if (scope == xglobal_scope)
+      return false;
+    else
+      {
+	symbol_table *inst = get_instance (scope);
 
-  // Inherit some values from the parent_sym_tab.
-  void inherit (symbol_table *parent_sym_tab);
+	return inst ? inst->do_is_local_variable (name) : false;
+      }
+  }
 
-  void print_info (std::ostream& os) const;
+  static bool is_global (const std::string& name,
+			 scope_id scope = xcurrent_scope)
+  {
+    if (scope == xglobal_scope)
+      return true;
+    else
+      {
+	symbol_table *inst = get_instance (scope);
+
+	return inst ? inst->do_is_global (name) : false;
+      }
+  }
 
 private:
 
-  unsigned int table_size;
+  typedef std::map<std::string, symbol_record>::const_iterator const_table_iterator;
+  typedef std::map<std::string, symbol_record>::iterator table_iterator;
+
+  typedef std::map<std::string, octave_value>::const_iterator const_persistent_table_iterator;
+  typedef std::map<std::string, octave_value>::iterator persistent_table_iterator;
+
+  typedef std::map<scope_id, symbol_table*>::const_iterator all_instances_const_iterator;
+  typedef std::map<scope_id, symbol_table*>::iterator all_instances_iterator;
+
+  typedef std::map<std::string, fcn_info>::const_iterator const_fcn_table_iterator;
+  typedef std::map<std::string, fcn_info>::iterator fcn_table_iterator;
+
+  typedef std::set<scope_id>::const_iterator scope_ids_free_list_const_iterator;
+  typedef std::set<scope_id>::iterator scope_ids_free_list_iterator;
+
+  typedef std::set<scope_id>::const_iterator scope_ids_in_use_const_iterator;
+  typedef std::set<scope_id>::iterator scope_ids_in_use_iterator;
+
+  // Map from symbol names to symbol info.
+  std::map<std::string, symbol_record> table;
+
+  // Map from names of persistent variables to values.
+  std::map<std::string, octave_value> persistent_table;
+
+  // Pointer to symbol table for current scope (variables only).
+  static symbol_table *instance;
 
-  symbol_record *table;
+  // Map from scope id to symbol table instances.
+  static std::map<scope_id, symbol_table*> all_instances;
+
+  // Map from function names to function info (subfunctions, private
+  // functions, class constructors, class methods, etc.)
+  static std::map<std::string, fcn_info> fcn_table;
+
+  static const scope_id xglobal_scope;
+  static const scope_id xtop_scope;
+
+  static scope_id xcurrent_scope;
+  static scope_id xcurrent_caller_scope;
+
+  // We use parent_scope to handle parsing subfunctions.
+  static scope_id xparent_scope;
+
+  static std::deque<scope_id> scope_stack;
+
+  // The next available scope ID.
+  static scope_id next_available_scope;
+
+  // The set of scope IDs that are currently allocated.
+  static std::set<scope_id> scope_ids_in_use;
+
+  // The set of scope IDs that are currently available.
+  static std::set<scope_id> scope_ids_free_list;
+
+  symbol_table (void) : table () { }
+
+  ~symbol_table (void) { }
 
-  std::string table_name;
+  static void free_scope (scope_id scope)
+  {
+    if (scope == xglobal_scope || scope == xtop_scope)
+      error ("can't free global or top-level scopes!");
+    else
+      {
+	scope_ids_in_use_iterator p = scope_ids_in_use.find (scope);
+
+	if (p != scope_ids_in_use.end ())
+	  {
+	    scope_ids_in_use.erase (p);
+	    scope_ids_free_list.insert (*p);
+	  }
+	else
+	  error ("scope id = %ld not found!", scope);
+      }
+  }
+
+  static symbol_table *get_instance (scope_id scope)
+  {
+    symbol_table *retval = 0;
+
+    if (scope == xcurrent_scope)
+      {
+	if (! instance)
+	  {
+	    instance = new symbol_table ();
 
-  static unsigned long int symtab_count;
+	    all_instances[scope] = instance;
+	  }
+
+	if (! instance)
+	  error ("unable to create symbol_table object!");
+
+	retval = instance;
+      }
+    else
+      {
+	all_instances_iterator p = all_instances.find (scope);
+
+	if (p == all_instances.end ())
+	  {
+	    retval = new symbol_table ();
+
+	    all_instances[scope] = retval;
+	  }
+	else
+	  retval = p->second;
+      }
+
+    return retval;
+  }
+
+  void insert_symbol_record (const symbol_record& sr)
+  {
+    table[sr.name ()] = sr;
+  }
 
   void
-  print_descriptor (std::ostream& os, 
-		    std::list<whos_parameter> params) const;
+  do_dup_scope (symbol_table& new_symbol_table) const
+  {
+    for (const_table_iterator p = table.begin (); p != table.end (); p++)
+      new_symbol_table.insert_symbol_record (p->second.dup ());
+  }
+
+  symbol_record do_find_symbol (const std::string& name)
+  {
+    table_iterator p = table.find (name);
+
+    if (p == table.end ())
+      return do_insert (name);
+    else
+      return p->second;
+  }
+
+  void do_inherit (scope_id donor_scope)
+  {
+    for (table_iterator p = table.begin (); p != table.end (); p++)
+      {
+	symbol_record& sr = p->second;
+
+	std::string nm = sr.name ();
+
+	if (! (sr.is_automatic () || sr.is_formal () || nm == "__retval__"))
+	  {
+	    octave_value val = symbol_table::varval (nm, donor_scope);
+
+	    if (val.is_defined ())
+	      {
+		sr.varref () = val;
+
+		sr.mark_inherited ();
+	      }
+	  }
+      }
+  }
+
+  octave_value
+  do_find (const std::string& name, tree_argument_list *args,
+	   const string_vector& arg_names,
+	   octave_value_list& evaluated_args, bool& args_evaluated,
+	   scope_id scope, bool skip_variables);
+
+  symbol_record& do_insert (const std::string& name)
+  {
+    table_iterator p = table.find (name);
+
+    return p == table.end ()
+      ? (table[name] = symbol_record (name)) : p->second;
+  }
+
+  octave_value& do_varref (const std::string& name)
+  {
+    table_iterator p = table.find (name);
+
+    if (p == table.end ())
+      {
+	symbol_record& sr = do_insert (name);
+
+	return sr.varref ();
+      }
+    else
+      return p->second.varref ();
+  }
 
-  std::list<whos_parameter>
-  parse_whos_line_format (Array<symbol_record *>& symbols) const;
+  octave_value do_varval (const std::string& name) const
+  {
+    const_table_iterator p = table.find (name);
+
+    return (p != table.end ()) ? p->second.varval () : octave_value ();
+  }
+
+  octave_value& do_persistent_varref (const std::string& name)
+  {
+    persistent_table_iterator p = persistent_table.find (name);
+
+    return (p == persistent_table.end ())
+      ? persistent_table[name] : p->second;
+  }
+
+  octave_value do_persistent_varval (const std::string& name)
+  {
+    const_persistent_table_iterator p = persistent_table.find (name);
+
+    return (p != persistent_table.end ()) ? p->second : octave_value ();
+  }
+
+  void do_erase_persistent (const std::string& name)
+  {
+    persistent_table_iterator p = persistent_table.find (name);
+
+    if (p != persistent_table.end ())
+      persistent_table.erase (p);
+  }
+
+  bool do_is_variable (const std::string& name) const
+  {
+    bool retval = false;
+
+    const_table_iterator p = table.find (name);
+
+    if (p != table.end ())
+      {
+	const symbol_record& sr = p->second;
+
+	retval = sr.is_variable ();
+      }
+
+    return retval;
+  }
+
+  void do_push_context (void)
+  {
+    for (table_iterator p = table.begin (); p != table.end (); p++)
+      p->second.push_context ();
+  }
+
+  void do_pop_context (void)
+  {
+    for (table_iterator p = table.begin (); p != table.end (); p++)
+      p->second.pop_context ();
+  }
+
+  void do_clear_variables (void)
+  {
+    for (table_iterator p = table.begin (); p != table.end (); p++)
+      p->second.clear ();
+  }
+
+  void do_clear_global (const std::string& name)
+  {
+    table_iterator p = table.find (name);
 
-  unsigned int hash (const std::string& s);
+    if (p != table.end ())
+      {
+	symbol_record& sr = p->second;
+
+	if (sr.is_global ())
+	  {
+	    symbol_table::clear_variable (p->first, xglobal_scope);
+
+	    sr.unmark_global ();
+	  }
+      }
+  }
+
+  void do_clear_variable (const std::string& name)
+  {
+    table_iterator p = table.find (name);
+
+    if (p != table.end ())
+      p->second.clear ();
+  }
+
+  void do_clear_global_pattern (const std::string& pat)
+  {
+    glob_match pattern (pat);
+
+    for (table_iterator p = table.begin (); p != table.end (); p++)
+      {
+	symbol_record& sr = p->second;
 
-  // No copying!
+	if (sr.is_global ())
+	  {
+	    if (pattern.match (sr.name ()))
+	      {
+		symbol_table::clear_variable (p->first, xglobal_scope);
+
+		sr.unmark_global ();
+	      }
+	  }
+      }
+  }
+
+  void do_clear_variable_pattern (const std::string& pat)
+  {
+    glob_match pattern (pat);
+
+    for (table_iterator p = table.begin (); p != table.end (); p++)
+      {
+	symbol_record& sr = p->second;
+
+	if (sr.is_defined () || sr.is_global ())
+	  {
+	    if (pattern.match (sr.name ()))
+	      sr.clear ();
+	  }
+      }
+  }
+
+  void do_mark_hidden (const std::string& name)
+  {
+    table_iterator p = table.find (name);
+
+    if (p != table.end ())
+      p->second.mark_hidden ();
+  }
+
+  void do_mark_global (const std::string& name)
+  {
+    table_iterator p = table.find (name);
 
-  symbol_table (const symbol_table&);
+    if (p != table.end ())
+      p->second.mark_global ();
+  }
+
+  std::list<symbol_record> do_all_variables (bool defined_only) const
+  {
+    std::list<symbol_record> retval;
+
+    for (const_table_iterator p = table.begin (); p != table.end (); p++)
+      {
+	const symbol_record& sr = p->second;
+
+	if (defined_only && ! sr.is_defined ())
+	  continue;
+
+	retval.push_back (sr);
+      }
+
+    return retval;
+  }
+
+  std::list<symbol_record> do_glob (const std::string& pattern,
+				    bool vars_only = false) const
+  {
+    std::list<symbol_record> retval;
+
+    glob_match pat (pattern);
+
+    for (const_table_iterator p = table.begin (); p != table.end (); p++)
+      {
+	if (pat.match (p->first))
+	  {
+	    const symbol_record& sr = p->second;
 
-  symbol_table& operator = (const symbol_table&);
+	    if (vars_only && ! sr.is_variable ())
+	      continue;
+
+	    retval.push_back (sr);
+	  }
+      }
+
+    return retval;
+  }
+
+  std::list<std::string> do_variable_names (void)
+  {
+    std::list<std::string> retval;
+
+    for (const_table_iterator p = table.begin (); p != table.end (); p++)
+      retval.push_back (p->first);
+
+    retval.sort ();
+
+    return retval;
+  }
+
+  bool do_is_local_variable (const std::string& name) const
+  {
+    const_table_iterator p = table.find (name);
+
+    return (p != table.end ()
+	    && ! p->second.is_global ()
+	    && p->second.is_defined ());
+  }
+
+  bool do_is_global (const std::string& name) const
+  {
+    const_table_iterator p = table.find (name);
+
+    return p != table.end () && p->second.is_global ();
+  }
 };
 
-// Defines layout for the whos/who -long command.
-extern std::string Vwhos_line_format;
+extern bool out_of_date_check (octave_value& function);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/token.cc b/src/token.cc
--- a/src/token.cc
+++ b/src/token.cc
@@ -68,17 +68,17 @@ token::token (end_tok_type t, int l, int
 token::token (plot_tok_type t, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = pttype_token;
   pt = t;
 }
 
-token::token (symbol_record *s, int l, int c)
+token::token (symbol_table::symbol_record *s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = sym_rec_token;
   sr = s;
 }
 
 token::~token (void)
@@ -110,17 +110,17 @@ token::ettype (void)
 
 token::plot_tok_type
 token::pttype (void)
 {
   assert (type_tag == pttype_token);
   return pt;
 }
 
-symbol_record *
+symbol_table::symbol_record *
 token::sym_rec (void)
 {
   assert (type_tag == sym_rec_token);
   return sr;
 }
 
 std::string
 token::text_rep (void)
diff --git a/src/token.h b/src/token.h
--- a/src/token.h
+++ b/src/token.h
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_token_h)
 #define octave_token_h 1
 
 #include <string>
 
-class symbol_record;
+class symbol_table::symbol_record;
 
 class
 token
 {
 public:
 
   enum token_type
     {
@@ -63,28 +63,28 @@ public:
     };
 
   token (int l = -1, int c = -1);
   token (const std::string& s, int l = -1, int c = -1);
   token (double d, const std::string& s = std::string (),
 	 int l = -1, int c = -1);
   token (end_tok_type t, int l = -1, int c = -1);
   token (plot_tok_type t, int l = -1, int c = -1);
-  token (symbol_record *s, int l = -1, int c = -1);
+  token (symbol_table::symbol_record *s, int l = -1, int c = -1);
 
   ~token (void);
 
   int line (void) { return line_num; }
   int column (void) { return column_num; }
 
   std::string text (void);
   double number (void);
   end_tok_type ettype (void);
   plot_tok_type pttype (void);
-  symbol_record *sym_rec (void);
+  symbol_table::symbol_record *sym_rec (void);
 
   std::string text_rep (void);
 
 private:
 
   // No copying!
 
   token (const token& tok);
@@ -95,17 +95,17 @@ private:
   int column_num;
   token_type type_tag;
   union
     {
       std::string *str;
       double num;
       end_tok_type et;
       plot_tok_type pt;
-      symbol_record *sr;
+      symbol_table::symbol_record *sr;
     };
   std::string orig_text;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -204,17 +204,17 @@ main_loop (void)
 
   // The big loop.
 
   int retval = 0;
   do
     {
       try
 	{
-	  curr_sym_tab = top_level_sym_tab;
+	  symbol_table::reset_scope ();
 
 	  reset_error_handler ();
 
 	  reset_parser ();
 
 	  // This is the same as yyparse in parse.y.
 	  retval = octave_parse ();
 
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -76,17 +76,17 @@ private:
 };
 
 class
 OCTINTERP_API
 unwind_protect
 {
 public:
 
-  static void add (unwind_elem::cleanup_func fptr, void *ptr);
+  static void add (unwind_elem::cleanup_func fptr, void *ptr = 0);
 
   static void run (void);
 
   static void discard (void);
 
   static void begin_frame (const std::string& tag);
 
   static void run_frame (const std::string& tag);
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -23,16 +23,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstdio>
 #include <cstring>
 
+#include <iomanip>
 #include <set>
 #include <string>
 
 #include "file-stat.h"
 #include "oct-env.h"
 #include "file-ops.h"
 #include "glob-match.h"
 #include "str-vec.h"
@@ -58,102 +59,72 @@ along with Octave; see the file COPYING.
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
 static int Vignore_function_time_stamp = 1;
 
-// Symbol table for symbols at the top level.
-symbol_table *top_level_sym_tab = 0;
-
-// Symbol table for the current scope.
-symbol_table *curr_sym_tab = 0;
-
-// Symbol table for the current caller scope.
-symbol_table *curr_caller_sym_tab = 0;
-
-// Symbol table for global symbols.
-symbol_table *global_sym_tab = 0;
-
-// Symbol table for functions and built-in symbols.
-symbol_table *fbi_sym_tab = 0;
-
-bool
-at_top_level (void)
-{
-  return (curr_sym_tab == top_level_sym_tab);
-}
-
-// Initialization.
-
-// Create the initial symbol tables and set the current scope at the
-// top level.
-
-void
-initialize_symbol_tables (void)
-{
-  if (! fbi_sym_tab)
-    fbi_sym_tab = new symbol_table (2048, "FBI");
-
-  if (! global_sym_tab)
-    global_sym_tab = new symbol_table (2048, "GLOBAL");
-
-  if (! top_level_sym_tab)
-    top_level_sym_tab = new symbol_table (4096, "TOP");
-
-  curr_caller_sym_tab = curr_sym_tab = top_level_sym_tab;
-}
+// Defines layout for the whos/who -long command
+static std::string Vwhos_line_format
+  = "  %a:4; %ln:6; %cs:16:6:8:1;  %rb:12;  %lc:-1;\n";
 
 void
 clear_mex_functions (void)
 {
-  fbi_sym_tab->clear_mex_functions ();
+  symbol_table::clear_mex_functions ();
+}
+
+void
+clear_function (const std::string& nm)
+{
+  symbol_table::clear_function (nm);
+}
+
+void
+clear_variable (const std::string& nm)
+{
+  symbol_table::clear_variable (nm);
+}
+
+void
+clear_symbol (const std::string& nm)
+{
+  symbol_table::clear_symbol (nm);
 }
 
 // Attributes of variables and functions.
 
 // Is this a command-style function?
 
 static std::set <std::string> command_set;
 
-static inline bool
-is_marked_as_command (const std::string& s)
-{
-  return command_set.find (s) != command_set.end ();
-}
-
-static inline void
+void
 mark_as_command (const std::string& s)
 {
   command_set.insert (s);
 }
 
 static inline void
 unmark_command (const std::string& s)
 {
   command_set.erase (s);
-
-  symbol_record *sr = fbi_sym_tab->lookup (s);
-
-  if (sr)
-    sr->unmark_command ();
 }
 
 DEFCMD (mark_as_command, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mark_as_command (@var{name})\n\
 Enter @var{name} into the list of commands.\n\
 @seealso{unmark_command, iscommand}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (at_top_level ())
+  if (symbol_table::at_top_level ())
     {
       int nargin = args.length ();
 
       if (nargin > 0)
 	{
 	  int argc = nargin + 1;
 
 	  string_vector argv = args.make_argv ("mark_as_command");
@@ -177,17 +148,17 @@ DEFCMD (unmark_command, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} unmark_command (@var{name})\n\
 Remove @var{name} from the list of commands.\n\
 @seealso{mark_as_command, iscommand}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (at_top_level ())
+  if (symbol_table::at_top_level ())
     {
       int nargin = args.length ();
 
       if (nargin > 0)
 	{
 	  int argc = nargin + 1;
 
 	  string_vector argv = args.make_argv ("unmark_command");
@@ -205,36 +176,20 @@ Remove @var{name} from the list of comma
     warning ("mark_as_command: invalid use inside function body");
 
   return retval;
 }
 
 bool
 is_command_name (const std::string& s)
 {
-  bool retval = false;
-
-  symbol_record *sr = fbi_sym_tab->lookup (s);
-
-  if (sr)
-    {
-      if (sr->is_command ())
-	retval = true;
-      else if (is_marked_as_command (s))
-	{
-	  sr->mark_as_command ();
-	  retval = true;
-	}
-    }
-  else
-    retval = is_marked_as_command (s);
-
-  return retval;
+  return command_set.find (s) != command_set.end ();
 }
 
+
 DEFCMD (iscommand, args, ,
 "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscommand (@var{name})\n\
 Return true if @var{name} is a command style function.  If @var{name}\n\
 is omitted, return a list of identifiers which are marked as commands with\n\
 @code{mark_as_command}.\n\
 @seealso{mark_as_command, unmark_command}\n\
 @end deftypefn")
@@ -269,38 +224,27 @@ is omitted, return a list of identifiers
 
   return retval;
 }
 
 // Is this a raw input command?
 
 static std::set <std::string> rawcommand_set;
 
-bool
-is_marked_as_rawcommand (const std::string& s)
-{
-  return rawcommand_set.find (s) != rawcommand_set.end ();
-}
-
 void
 mark_as_rawcommand (const std::string& s)
 {
   command_set.insert (s);    
   rawcommand_set.insert (s);
 }
 
 void
 unmark_rawcommand (const std::string& s)
 {
   rawcommand_set.erase (s);
-
-  symbol_record *sr = fbi_sym_tab->lookup (s);
-
-  if (sr)
-    sr->unmark_rawcommand ();
 }
 
 DEFCMD (mark_as_rawcommand, args, ,
 "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mark_as_rawcommand (@var{name})\n\
 Enter @var{name} into the list of raw input commands and to the list of\n\
 command style functions.\n\
 Raw input commands are like normal command style functions, but they\n\
@@ -309,17 +253,17 @@ and escapes they had when input). Howeve
 are handled as usual, you cannot pass a token starting with a comment\n\
 character ('#' or '%') to your function, and the last token cannot be\n\
 a continuation token ('\\' or '...').\n\
 @seealso{unmark_rawcommand, israwcommand, iscommand, mark_as_command}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (at_top_level ())
+  if (symbol_table::at_top_level ())
     {
       int nargin = args.length ();
 
       if (nargin > 0)
 	{
 	  int argc = nargin + 1;
 
 	  string_vector argv = args.make_argv ("mark_as_rawcommand");
@@ -345,17 +289,17 @@ DEFCMD (unmark_rawcommand, args, ,
 Remove @var{name} from the list of raw input commands.\n\
 Note that this does not remove @var{name} from the list of command style\n\
 functions.\n\
 @seealso{mark_as_rawcommand, israwcommand, iscommand, unmark_command}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (at_top_level ())
+  if (symbol_table::at_top_level ())
     {
       int nargin = args.length ();
 
       if (nargin > 0)
 	{
 	  int argc = nargin + 1;
 
 	  string_vector argv = args.make_argv ("unmark_rawcommand");
@@ -373,34 +317,17 @@ functions.\n\
     warning ("unmark_rawcommand: invalid use inside function body");
 
   return retval;
 }
 
 bool
 is_rawcommand_name (const std::string& s)
 {
-  bool retval = false;
-
-  symbol_record *sr = fbi_sym_tab->lookup (s);
-
-  if (sr)
-    {
-      if (sr->is_rawcommand ())
-	retval = true;
-      else if (is_marked_as_rawcommand (s))
-	{
-	  sr->mark_as_rawcommand ();
-	  retval = true;
-	}
-    }
-  else
-    retval = is_marked_as_rawcommand (s);
-
-  return retval;
+  return rawcommand_set.find (s) != rawcommand_set.end ();
 }
 
 DEFCMD (israwcommand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} israwcommand (@var{name})\n\
 Return true if @var{name} is a raw input command function.\n\
 If @var{name} is omitted, return a list of identifiers which are marked as\n\
 raw input commands with mark_as_rawcommand.\n\
@@ -434,73 +361,35 @@ raw input commands with mark_as_rawcomma
 	}
     }
   else
     print_usage ();
 
   return retval;
 }
 
-// Is this a built-in function?
-
-bool
-is_builtin_function_name (const std::string& s)
-{
-  symbol_record *sr = fbi_sym_tab->lookup (s);
-  return (sr && sr->is_builtin_function ());
-}
-
-// Is this a mapper function?
-
-bool
-is_mapper_function_name (const std::string& s)
-{
-  symbol_record *sr = fbi_sym_tab->lookup (s);
-  return (sr && sr->is_mapper_function ());
-}
-
-// Is this function globally in this scope?
-
-bool
-is_globally_visible (const std::string& name)
-{
-  symbol_record *sr = curr_sym_tab->lookup (name);
-  return (sr && sr->is_linked_to_global ());
-}
-
 // Is this octave_value a valid function?
 
 octave_function *
 is_valid_function (const std::string& fcn_name,
 		   const std::string& warn_for, bool warn)
 {
   octave_function *ans = 0;
 
-  symbol_record *sr = 0;
-
   if (! fcn_name.empty ())
     {
-      sr = fbi_sym_tab->lookup (fcn_name, true);
-
-      lookup (sr, false);
+      octave_value val = symbol_table::find_function (fcn_name);
+
+      if (val.is_defined ())
+	ans = val.function_value (true);
     }
 
-  if (sr)
-    {
-      octave_value tmp = sr->def ();
-      ans = tmp.function_value (true);
-    }
-
-  if (! sr || ! ans || ! sr->is_function ())
-    {
-      if (warn)
-	error ("%s: the symbol `%s' is not valid as a function",
-	       warn_for.c_str (), fcn_name.c_str ());
-      ans = 0;
-    }
+  if (! ans && warn)
+    error ("%s: the symbol `%s' is not valid as a function",
+	   warn_for.c_str (), fcn_name.c_str ());
 
   return ans;
 }
 
 octave_function *
 is_valid_function (const octave_value& arg,
 		   const std::string& warn_for, bool warn)
 {
@@ -608,22 +497,19 @@ get_struct_elts (const std::string& text
 
 static inline bool
 is_variable (const std::string& name)
 {
   bool retval = false;
 
   if (! name.empty ())
     {
-      symbol_record *sr = curr_sym_tab->lookup (name);
-
-      if (! sr)
-	sr = fbi_sym_tab->lookup (name);
-
-      retval = (sr  && sr->is_variable ());
+      octave_value val = symbol_table::varval (name);
+
+      retval = val.is_defined ();
     }
 
   return retval;
 }
 
 string_vector
 generate_struct_completions (const std::string& text,
 			     std::string& prefix, std::string& hint)
@@ -728,21 +614,17 @@ do_isglobal (const octave_value_list& ar
   std::string name = args(0).string_value ();
 
   if (error_state)
     {
       error ("isglobal: expecting std::string argument");
       return retval;
     }
 
-  symbol_record *sr = curr_sym_tab->lookup (name);
-
-  retval = (sr && sr->is_linked_to_global ());
-
-  return retval;
+  return symbol_table::is_global (name);
 }
 
 DEFUN (isglobal, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isglobal (@var{name})\n\
 Return 1 if @var{name} is globally visible.  Otherwise, return 0.  For\n\
 example,\n\
 \n\
@@ -782,53 +664,53 @@ symbol_exist (const std::string& name, c
       struct_elts = name.substr (pos+1);
       symbol_name = name.substr (0, pos);
     }
 
   // We shouldn't need to look in the global symbol table, since any
   // name that is visible in the current scope will be in the local
   // symbol table.
 
-  symbol_record *sr = curr_sym_tab->lookup (symbol_name);
-
-  if (! (sr && sr->is_defined ()))
-    sr = fbi_sym_tab->lookup (symbol_name);
-
-  if (sr && sr->is_defined ())
+  octave_value_list evaluated_args;
+  bool args_evaluated;
+
+  octave_value val = symbol_table::find (symbol_name, 0, string_vector (),
+					 evaluated_args, args_evaluated);
+
+  if (val.is_defined ())
     {
       bool not_a_struct = struct_elts.empty ();
-      bool var_ok = not_a_struct || sr->is_map_element (struct_elts);
+      bool var_ok = not_a_struct /* || val.is_map_element (struct_elts) */;
 
       if (! retval
 	  && var_ok
 	  && (type == "any" || type == "var")
-	  && sr->is_user_variable ())
+	  && val.is_constant ())
 	{
 	  retval = 1;
 	}
 
       if (! retval
 	  && (type == "any" || type == "builtin"))
 	{
-	  if (not_a_struct && sr->is_builtin_function ())
+	  if (not_a_struct && val.is_builtin_function ())
 	    {
 	      retval = 5;
 	    }
 	}
 
       if (! retval
 	  && not_a_struct
 	  && (type == "any" || type == "file")
-	  && (sr->is_user_function () || sr->is_dld_function ()))
+	  && (val.is_user_function () || val.is_dld_function ()))
 	{
-	  octave_value t = sr->def ();
-	  octave_function *f = t.function_value (true);
+	  octave_function *f = val.function_value (true);
 	  std::string s = f ? f->fcn_file_name () : std::string ();
 
-	  retval = s.empty () ? 103 : (sr->is_user_function () ? 2 : 3);
+	  retval = s.empty () ? 103 : (val.is_user_function () ? 2 : 3);
 	}
     }
 
   if (! (type == "var" || type == "builtin"))
     {
       if (! retval)
 	{
 	  std::string file_name = lookup_autoload (name);
@@ -957,299 +839,39 @@ Check only for directories.\n\
 	error ("exist: expecting first argument to be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
-bool
-fcn_out_of_date (octave_function *fcn, const std::string& ff, time_t tp)
-{
-  bool retval = false;
-
-  fcn->mark_fcn_file_up_to_date (octave_time ());
-
-  if (! (Vignore_function_time_stamp == 2
-	 || (Vignore_function_time_stamp && fcn->is_system_fcn_file ())))
-    {
-      file_stat fs (ff);
-
-      if (fs && fs.is_newer (tp))
-	retval = true;
-    }
-
-  return retval;
-}
-
-// Is there a corresponding function file that is newer than the
-// symbol definition?
-
-static bool
-symbol_out_of_date (symbol_record *sr)
-{
-  bool retval = false;
-
-  if (sr)
-    {
-      octave_value ans = sr->def ();
-
-      octave_function *fcn = ans.function_value (true);
-
-      if (fcn)
-	{
-	  std::string ff = fcn->fcn_file_name ();
-
-	  if (! ff.empty ())
-	    {
-	      octave_time tc = fcn->time_checked ();
-
-	      bool relative = fcn->is_relative ();
-
-	      if (tc < Vlast_prompt_time
-		  || (relative && tc < Vlast_chdir_time))
-		{
-		  octave_time ottp = fcn->time_parsed ();
-		  time_t tp = ottp.unix_time ();
-
-		  std::string nm = fcn->is_nested_function ()
-		    ? fcn->parent_fcn_name () : fcn->name ();
-
-		  // FIXME -- the following code is repeated
-		  // in load_fcn_from_file in parse.y.
-
-		  int nm_len = nm.length ();
-
-		  std::string file;
-
-		  if (octave_env::absolute_pathname (nm)
-		      && ((nm_len > 4 && (nm.substr (nm_len-4) == ".oct"
-					  || nm.substr (nm_len-4) == ".mex"))
-			  || (nm_len > 2 && nm.substr (nm_len-4) == ".m")))
-		    {
-		      file = nm;
-		    }
-		  else
-		    {
-		      file = lookup_autoload (nm);
-
-		      if (file.empty ())
-			file = load_path::find_fcn (nm);
-
-		      file = octave_env::make_absolute (file, octave_env::getcwd ());
-		    }
-
-		  if (file.empty ())
-		    {
-		      // Can't see this function now, so we should
-		      // clear it.
-
-		      sr->clear ();
-
-		      retval = true;
-		    }
-		  else if (same_file (file, ff))
-		    {
-		      retval = fcn_out_of_date (fcn, ff, tp);
-		    }
-		  else
-		    {
-		      // Check the full function name.  Maybe we already
-		      // parsed it.
-
-		      symbol_record *full_sr = fbi_sym_tab->lookup (file);
-
-		      if (full_sr)
-			{
-			  octave_value v = full_sr->def ();
-
-			  if (v.is_function ())
-			    {
-			      // OK, swap the aliases around.
-
-			      // FIXME -- this is a bit
-			      // tricky, so maybe some refactoring is
-			      // in order here too...
-
-			      symbol_record *short_sr = fbi_sym_tab->lookup (nm);
-
-			      if (short_sr)
-				short_sr->alias (full_sr);
-
-			      // Make local symbol table entry point
-			      // to correct global function too.
-
-			      sr->alias (full_sr);
-
-			      fcn = v.function_value ();
-
-			      retval = fcn_out_of_date (fcn, file, tp);
-			    }
-			  else
-			    retval = true;
-			}
-		      else
-			retval = true;
-		    }
-		}
-	    }
-	}
-    }
-
-  return retval;
-}
-
-bool
-lookup (symbol_record *sym_rec, bool exec_script)
-{
-  bool script_executed = false;
-
-  if (! sym_rec->is_linked_to_global ())
-    {
-      if (sym_rec->is_defined ())
-	{
-	  if (sym_rec->is_function () && symbol_out_of_date (sym_rec))
-	    script_executed = load_fcn_from_file (sym_rec, exec_script);
-	}
-      else if (! sym_rec->is_formal_parameter ())
-	{
-	  link_to_builtin_or_function (sym_rec);
-
-	  if (! sym_rec->is_defined ())
-	    script_executed = load_fcn_from_file (sym_rec, exec_script);
-	  else if (sym_rec->is_function () && symbol_out_of_date (sym_rec))
-	    script_executed = load_fcn_from_file (sym_rec, exec_script);
-	}
-    }
-
-  return script_executed;
-}
-
-// Get the symbol record for the given name that is visible in the
-// current scope.  Reread any function definitions that appear to be
-// out of date.  If a function is available in a file but is not
-// currently loaded, this will load it and insert the name in the
-// current symbol table.
-
-symbol_record *
-lookup_by_name (const std::string& nm, bool exec_script)
-{
-  symbol_record *sym_rec = curr_sym_tab->lookup (nm, true);
-
-  lookup (sym_rec, exec_script);
-
-  return sym_rec;
-}
-
-octave_value
-lookup_function (const std::string& nm, const std::string& parent)
-{
-  octave_value retval;
-
-  symbol_record *sr = 0;
-
-  if (! parent.empty ())
-    sr = fbi_sym_tab->lookup (parent + ":" + nm);
-
-  if (! sr || ! sr->is_function ())
-    {
-      if (curr_parent_function)
-	sr = fbi_sym_tab->lookup (curr_parent_function->name () + ":" + nm);
-
-      if (! sr || ! sr->is_function ())
-	sr = fbi_sym_tab->lookup (nm, true);
-
-      if (sr && ! sr->is_function ())
-	load_fcn_from_file (sr, false);
-    }
-
-  if (sr)
-    {
-      octave_value v = sr->def ();
-
-      if (v.is_function ())
-	retval = v;
-    }
-
-  return retval;
-}
-
-octave_value
-lookup_user_function (const std::string& nm)
-{
-  octave_value retval;
-
-  symbol_record *sr = 0;
-
-  if (curr_parent_function)
-    {
-      std::string parent = curr_parent_function->name ();
-
-      sr = fbi_sym_tab->lookup (parent + ":" + nm);
-    }
-
-  if (! sr || ! sr->is_user_function ())
-    {
-      sr = fbi_sym_tab->lookup (nm, true);
-
-      if (sr && ! sr->is_user_function ())
-	load_fcn_from_file (sr, false);
-    }
-
-  if (sr)
-    retval = sr->def ();
-
-  return retval;
-}
-
 octave_value
 lookup_function_handle (const std::string& nm)
 {
-  octave_value retval;
-
-  symbol_record *sr = curr_sym_tab->lookup (nm, true);
-
-  if (sr && sr->def ().is_function_handle ())
-    retval = sr->def ();
-
-  return retval;
+  octave_value val = symbol_table::varval (nm);
+
+  return val.is_function_handle () ? val : octave_value ();
 }
 
 octave_value
 get_global_value (const std::string& nm, bool silent)
 {
-  octave_value retval;
-
-  symbol_record *sr = global_sym_tab->lookup (nm);
-
-  if (sr)
-    {
-      octave_value sr_def = sr->def ();
-
-      if (sr_def.is_defined ())
-	retval = sr_def;
-      else if (! silent)
-	error ("get_global_by_name: undefined symbol `%s'", nm.c_str ());
-    }
-  else if (! silent)
-    error ("get_global_by_name: unknown symbol `%s'", nm.c_str ());
-
-  return retval;
+  octave_value val = symbol_table::varval (nm, symbol_table::global_scope ());
+
+  if (val.is_undefined () && ! silent)
+    error ("get_global_by_name: undefined symbol `%s'", nm.c_str ());
+
+  return val;
 }
 
 void
 set_global_value (const std::string& nm, const octave_value& val)
 {
-  symbol_record *sr = global_sym_tab->lookup (nm, true);
-
-  if (sr)
-    sr->define (val);
-  else
-    panic_impossible ();
+  symbol_table::varref (nm, symbol_table::global_scope ()) = val;
 }
 
 // Variable values.
 
 octave_value
 set_internal_variable (bool& var, const octave_value_list& args,
 		       int nargout, const char *nm)
 {
@@ -1410,316 +1032,685 @@ set_internal_variable (std::string& var,
 	error ("%s: expecting arg to be a character string", nm);
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
-// Global stuff and links to builtin variables and functions.
-
-// Make the definition of the symbol record sr be the same as the
-// definition of the global variable of the same name, creating it if
-// it doesn't already exist.
-
-void
-link_to_global_variable (symbol_record *sr)
+struct
+symbol_record_name_compare
+{
+  bool operator () (const symbol_table::symbol_record& a,
+		    const symbol_table::symbol_record& b)
+  {
+    std::string a_nm = a.name ();
+    std::string b_nm = b.name ();
+
+    return a_nm.compare (b_nm);
+  }
+};
+
+struct
+whos_parameter
 {
-  if (! sr->is_linked_to_global ())
+  char command;
+  char modifier;
+  int parameter_length;
+  int first_parameter_length;
+  int dimensions;
+  int balance;
+  std::string text;
+  std::string line;
+};
+
+static void
+print_descriptor (std::ostream& os, std::list<whos_parameter> params)
+{
+  // This method prints a line of information on a given symbol
+  std::list<whos_parameter>::iterator i = params.begin ();
+  std::ostringstream param_buf;
+
+  while (i != params.end ())
     {
-      sr->mark_as_linked_to_global ();
-
-      if (! error_state)
+      whos_parameter param = *i;
+
+      if (param.command != '\0')
+        {
+	  // Do the actual printing
+	  switch (param.modifier)
+	    {
+	    case 'l':
+	      os << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
+	      param_buf << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
+	      break;
+
+	    case 'r':
+	      os << std::setiosflags (std::ios::right) << std::setw (param.parameter_length);
+	      param_buf << std::setiosflags (std::ios::right) << std::setw (param.parameter_length);
+	      break;
+
+	    case 'c':
+	      if (param.command != 's')
+	        {
+		  os << std::setiosflags (std::ios::left)
+		     << std::setw (param.parameter_length);
+		  param_buf << std::setiosflags (std::ios::left)
+			    << std::setw (param.parameter_length);
+		}
+	      break;
+
+	    default:
+	      os << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
+	      param_buf << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
+	    }
+
+	  if (param.command == 's' && param.modifier == 'c')
+	    {
+	      int a, b;
+	     
+	      if (param.modifier == 'c')
+	        {
+		  a = param.first_parameter_length - param.balance;
+		  a = (a < 0 ? 0 : a);
+		  b = param.parameter_length - a - param.text . length ();
+		  b = (b < 0 ? 0 : b);
+		  os << std::setiosflags (std::ios::left) << std::setw (a)
+		     << "" << std::resetiosflags (std::ios::left) << param.text
+		     << std::setiosflags (std::ios::left)
+		     << std::setw (b) << ""
+		     << std::resetiosflags (std::ios::left);
+		  param_buf << std::setiosflags (std::ios::left) << std::setw (a)
+		     << "" << std::resetiosflags (std::ios::left) << param.line
+		     << std::setiosflags (std::ios::left)
+		     << std::setw (b) << ""
+		     << std::resetiosflags (std::ios::left);
+		}
+	    }
+	  else
+	    {
+	      os << param.text;
+	      param_buf << param.line;
+	    }
+	  os << std::resetiosflags (std::ios::left)
+	     << std::resetiosflags (std::ios::right);
+	  param_buf << std::resetiosflags (std::ios::left)
+		    << std::resetiosflags (std::ios::right);
+	  i++;
+	}
+      else
 	{
-	  std::string nm = sr->name ();
-
-	  symbol_record *gsr = global_sym_tab->lookup (nm, true);
-
-	  // Make sure this symbol is a variable.
-
-	  if (! gsr->is_user_variable ())
-	    gsr->define (octave_value ());
-
-	  sr->alias (gsr);
+	  os << param.text;
+	  param_buf << param.line;
+	  i++;
 	}
     }
+
+  os << param_buf.str ();
 }
 
-// Make the definition of the symbol record sr be the same as the
-// definition of the builtin variable of the same name.
-
-// Make the definition of the symbol record sr be the same as the
-// definition of the builtin function, or user function of the same
-// name, provided that the name has not been used as a formal parameter.
-
-void
-link_to_builtin_or_function (symbol_record *sr)
-{
-  std::string nm = sr->name ();
-
-  symbol_record *tmp_sym = 0;
-
-  octave_function *fcn = octave_call_stack::current ();
-
-  std::string parent = fcn ? fcn->parent_fcn_name () : std::string ();
-
-  if (! parent.empty ())
-    tmp_sym = fbi_sym_tab->lookup (parent + ":" + nm);
-
-  if (! tmp_sym && curr_parent_function)
-    tmp_sym = fbi_sym_tab->lookup (curr_parent_function->name () + ":" + nm);
-
-  if (! tmp_sym)
-    tmp_sym = fbi_sym_tab->lookup (nm);
-
-  if (tmp_sym
-      && tmp_sym->is_function ()
-      && ! tmp_sym->is_formal_parameter ())
-    sr->alias (tmp_sym);
-}
-
-// Force a link to a function in the current symbol table.  This is
-// used just after defining a function to avoid different behavior
-// depending on whether or not the function has been evaluated after
-// being defined.
+// Calculate how much space needs to be reserved for the first part of
+// the dimensions string.  For example,
 //
-// Return without doing anything if there isn't a function with the
-// given name defined in the global symbol table.
-
-void
-force_link_to_function (const std::string& id_name)
-{
-  symbol_record *fsr = fbi_sym_tab->lookup (id_name, true);
-  if (fsr->is_function ())
-    {
-      curr_sym_tab->clear (id_name);
-      symbol_record *csr = curr_sym_tab->lookup (id_name, true);
-      csr->alias (fsr);
-    }
-}
-
-DEFUN (document, args, ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} document (@var{symbol}, @var{text})\n\
-Set the documentation string for @var{symbol} to @var{text}.\n\
-@end deftypefn")
+//   mat is a 12x3 matrix
+//            ^^  => 2 columns
+
+static int
+dimensions_string_req_first_space (const dim_vector& dims, int print_dims)
 {
-  octave_value retval;
-
-  int nargin = args.length ();
-
-  if (nargin == 2)
+  int first_param_space = 0;
+
+  // Calculating dimensions.
+
+  std::string dim_str = "";
+  std::stringstream ss;
+  long dim = dims.length ();
+
+  first_param_space = (first_param_space >= 1 ? first_param_space : 1);
+
+  // Preparing dimension string.
+
+  if ((dim <= print_dims || print_dims < 0) && print_dims != 0)
+    {
+      // Dimensions string must be printed like this: 2x3x4x2.
+
+      if (dim == 0 || dim == 1)
+	first_param_space = 1; // First parameter is 1.
+      else
+        {
+	  ss << dims (0);
+	 
+	  dim_str = ss.str ();
+	  first_param_space = dim_str.length ();
+	}
+    }
+  else
     {
-      std::string name = args(0).string_value ();
-
-      if (! error_state)
-	{
-	  std::string help = args(1).string_value ();
-
-	  if (! error_state)
+      // Printing dimension string as: a-D.
+
+      ss << dim;
+
+      dim_str = ss.str ();
+      first_param_space = dim_str.length ();
+    }
+
+  return first_param_space;
+}
+
+// Make the dimensions-string.  For example: mat is a 2x3 matrix.
+//                                                    ^^^
+//
+// FIXME -- why not just use the dim_vector::str () method?
+
+std::string
+make_dimensions_string (const dim_vector& dims, int print_dims)
+{
+  // Calculating dimensions.
+
+  std::string dim_str = "";
+  std::stringstream ss;
+  long dim = dims.length ();
+
+  // Preparing dimension string.
+
+  if ((dim <= print_dims || print_dims < 0) && print_dims != 0)
+    {
+      // Only printing the dimension string as: axbxc...
+
+      if (dim == 0)
+	ss << "1x1";
+      else
+        {
+	  for (int i = 0; i < dim; i++)
 	    {
-	      if (is_command_name (name)
-		  || is_mapper_function_name (name)
-		  || is_builtin_function_name (name))
-		error ("document: can't redefine help for built-in functions");
-	      else
+	      if (i == 0)
 		{
-		  symbol_record *sym_rec = curr_sym_tab->lookup (name);
-
-		  if (sym_rec)
-		    sym_rec->document (help);
+		  if (dim == 1)
+		    {
+		      // Looks like this is not going to happen in
+		      // Octave, but ...
+
+		      ss << "1x" << dims (i);
+		    }
 		  else
-		    error ("document: no such symbol `%s'", name.c_str ());
+		    ss << dims (i);
 		}
+	      else if (i < dim && dim != 1)
+		ss << "x" << dims (i);
 	    }
 	}
     }
   else
-    print_usage ();
-
-  return retval;
+    {
+      // Printing dimension string as: a-D.
+
+      ss << dim << "-D";
+    }
+
+  dim_str = ss.str ();
+
+  return dim_str;
 }
 
-// FIXME -- this function is duplicated in symtab.cc with the
-// name maybe_list_cmp_fcn.
+// Calculate how much space needs to be reserved for the
+// dimensions string.  For example,
+//
+//   mat is a 12x3 matrix
+//            ^^^^ => 4 columns
+//
+// FIXME -- why not just use the dim_vector::str () method?
 
 static int
-symbol_record_name_compare (const void *a_arg, const void *b_arg)
+dimensions_string_req_total_space (const dim_vector& dims, int print_dims)
+{
+  std::string dim_str = "";
+  std::stringstream ss;
+
+  ss << make_dimensions_string (dims, print_dims);
+  dim_str = ss.str ();
+
+  return dim_str.length ();
+}
+
+static std::list<whos_parameter>
+parse_whos_line_format (const std::list<symbol_table::symbol_record>& symbols)
 {
-  const symbol_record *a = *(static_cast<symbol_record *const*> (a_arg));
-  const symbol_record *b = *(static_cast<symbol_record *const*> (b_arg));
-
-  std::string a_nm = a->name ();
-  std::string b_nm = b->name ();
-
-  return a_nm.compare (b_nm);
+  // This method parses the string whos_line_format, and returns
+  // a parameter list, containing all information needed to print
+  // the given attributtes of the symbols
+  int idx;
+  size_t format_len = Vwhos_line_format.length ();
+  char garbage;
+  std::list<whos_parameter> params;
+
+  size_t bytes1;
+  int elements1;
+
+  std::string param_string = "abcenst";
+  Array<int> param_length (dim_vector (param_string.length (), 1));
+  Array<std::string> param_names (dim_vector (param_string.length (), 1));
+  size_t pos_a, pos_b, pos_c, pos_e, pos_n, pos_s, pos_t;
+
+  pos_a = param_string.find ('a'); // Attributes
+  pos_b = param_string.find ('b'); // Bytes
+  pos_c = param_string.find ('c'); // Class
+  pos_e = param_string.find ('e'); // Elements
+  pos_n = param_string.find ('n'); // Name
+  pos_s = param_string.find ('s'); // Size
+  pos_t = param_string.find ('t'); // Type
+
+  param_names(pos_a) = "Attr";
+  param_names(pos_b) = "Bytes";
+  param_names(pos_c) = "Class";
+  param_names(pos_e) = "Elements";
+  param_names(pos_n) = "Name";
+  param_names(pos_s) = "Size";
+  param_names(pos_t) = "Type";
+
+  for (size_t i = 0; i < param_string.length (); i++)
+    param_length(i) = param_names(i) . length ();
+
+  // Calculating necessary spacing for name column,
+  // bytes column, elements column and class column
+
+  for (std::list<symbol_table::symbol_record>::const_iterator p = symbols.begin ();
+       p != symbols.end (); p++)
+    {
+      std::stringstream ss1, ss2;
+      std::string str;
+
+      str = p->name ();
+      param_length(pos_n) = ((str.length ()
+			      > static_cast<size_t> (param_length(pos_n)))
+			     ? str.length () : param_length(pos_n));
+
+      octave_value val = p->varval ();
+
+      str = val.type_name ();
+      param_length(pos_t) = ((str.length ()
+			      > static_cast<size_t> (param_length(pos_t)))
+			     ? str.length () : param_length(pos_t));
+
+      elements1 = val.capacity ();
+      ss1 << elements1;
+      str = ss1.str ();
+      param_length(pos_e) = ((str.length ()
+			      > static_cast<size_t> (param_length(pos_e)))
+			     ? str.length () : param_length(pos_e));
+
+      bytes1 = val.byte_size ();
+      ss2 << bytes1;
+      str = ss2.str ();
+      param_length(pos_b) = ((str.length ()
+			      > static_cast<size_t> (param_length(pos_b)))
+			     ? str.length () : param_length (pos_b));
+    }
+
+  idx = 0;
+  while (static_cast<size_t> (idx) < format_len)
+    {
+      whos_parameter param;
+      param.command = '\0';
+
+      if (Vwhos_line_format[idx] == '%')
+        {
+	  bool error_encountered = false;
+	  param.modifier = 'r';
+	  param.parameter_length = 0;
+	  param.dimensions = 8;
+
+	  int a = 0, b = -1, c = 8, balance = 1;
+	  unsigned int items;
+	  size_t pos;
+	  std::string cmd;
+
+	  // Parse one command from whos_line_format
+	  cmd = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
+	  pos = cmd.find (';');
+	  if (pos != NPOS)
+	    cmd = cmd.substr (0, pos+1);
+	  else
+	    error ("parameter without ; in whos_line_format");
+
+	  idx += cmd.length ();
+
+	  // FIXME -- use iostream functions instead of sscanf!
+
+	  if (cmd.find_first_of ("crl") != 1)
+	    items = sscanf (cmd.c_str (), "%c%c:%d:%d:%d:%d;",
+			    &garbage, &param.command, &a, &b, &c, &balance);
+	  else
+	    items = sscanf (cmd.c_str (), "%c%c%c:%d:%d:%d:%d;",
+			    &garbage, &param.modifier, &param.command,
+			    &a, &b, &c, &balance) - 1;
+	 
+	  if (items < 2)
+	    {
+	      error ("whos_line_format: parameter structure without command in whos_line_format");
+	      error_encountered = true;
+	    }
+
+	  // Insert data into parameter
+	  param.first_parameter_length = 0;
+	  pos = param_string.find (param.command);
+	  if (pos != NPOS)
+	    {
+	      param.parameter_length = param_length(pos);
+	      param.text = param_names(pos);
+	      param.line.assign (param_names(pos).length (), '=');
+
+	      param.parameter_length = (a > param.parameter_length
+					? a : param.parameter_length);
+	      if (param.command == 's' && param.modifier == 'c' && b > 0)
+		param.first_parameter_length = b;
+	    }
+	  else
+	    {
+	      error ("whos_line_format: '%c' is not a command",
+		     param.command);
+	      error_encountered = true;
+	    }
+
+	  if (param.command == 's')
+	    {
+	      // Have to calculate space needed for printing matrix dimensions
+	      // Space needed for Size column is hard to determine in prior,
+	      // because it depends on dimensions to be shown. That is why it is
+	      // recalculated for each Size-command
+	      int first, rest = 0, total;
+	      param.dimensions = c;
+	      first = param.first_parameter_length;
+	      total = param.parameter_length;
+
+	      for (std::list<symbol_table::symbol_record>::const_iterator p = symbols.begin ();
+		   p != symbols.end (); p++)
+		{
+		  octave_value val = p->varval ();
+		  dim_vector dims = val.dims ();
+		  int first1 = dimensions_string_req_first_space (dims, param.dimensions);
+		  int total1 = dimensions_string_req_total_space (dims, param.dimensions);
+		  int rest1 = total1 - first1;
+		  rest = (rest1 > rest ? rest1 : rest);
+		  first = (first1 > first ? first1 : first);
+		  total = (total1 > total ? total1 : total);
+		}
+
+	      if (param.modifier == 'c')
+	        {
+		  if (first < balance)
+		    first += balance - first;
+		  if (rest + balance < param.parameter_length)
+		    rest += param.parameter_length - rest - balance;
+
+		  param.parameter_length = first + rest;
+		  param.first_parameter_length = first;
+		  param.balance = balance;
+		}
+	      else
+	        {
+		  param.parameter_length = total;
+		  param.first_parameter_length = 0;
+		}
+	    }
+	  else if (param.modifier == 'c')
+	    {
+	      error ("whos_line_format: modifier 'c' not available for command '%c'",
+		     param.command);
+	      error_encountered = true;
+	    }
+
+	  // What happens if whos_line_format contains negative numbers
+	  // at param_length positions?
+	  param.balance = (b < 0 ? 0 : param.balance);
+	  param.first_parameter_length = (b < 0 ? 0 :
+					  param.first_parameter_length);
+	  param.parameter_length = (a < 0
+				    ? 0
+				    : (param.parameter_length
+				       < param_length(pos_s)
+				       ? param_length(pos_s)
+				       : param.parameter_length));
+
+	  // Parameter will not be pushed into parameter list if ...
+	  if (! error_encountered)
+	    params.push_back (param);
+	}
+      else
+        {
+	  // Text string, to be printed as it is ...
+	  std::string text;
+	  size_t pos;
+	  text = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
+	  pos = text.find ('%');
+	  if (pos != NPOS)
+	    text = text.substr (0, pos);
+
+	  // Push parameter into list ...
+	  idx += text.length ();
+	  param.text=text;
+	  param.line.assign (text.length(), ' ');
+	  params.push_back (param);
+	}
+    }
+
+  return params;
+}
+
+void
+print_symbol_info_line (std::ostream& os,
+			const symbol_table::symbol_record& sr,
+			std::list<whos_parameter>& params)
+{
+  octave_value val = sr.varval ();
+  dim_vector dims = val.dims ();
+
+  std::list<whos_parameter>::iterator i = params.begin ();
+
+  while (i != params.end ())
+    {
+      whos_parameter param = *i;
+
+      if (param.command != '\0')
+        {
+	  // Do the actual printing.
+
+	  switch (param.modifier)
+	    {
+	    case 'l':
+	      os << std::setiosflags (std::ios::left)
+		 << std::setw (param.parameter_length);
+	      break;
+
+	    case 'r':
+	      os << std::setiosflags (std::ios::right)
+		 << std::setw (param.parameter_length);
+	      break;
+
+	    case 'c':
+	      if (param.command == 's')
+	        {
+		  int front = param.first_parameter_length
+		    - dimensions_string_req_first_space (dims, param.dimensions);
+		  int back = param.parameter_length
+		    - dimensions_string_req_total_space (dims, param.dimensions)
+		    - front;
+		  front = (front > 0) ? front : 0;
+		  back = (back > 0) ? back : 0;
+
+		  os << std::setiosflags (std::ios::left)
+		     << std::setw (front)
+		     << ""
+		     << std::resetiosflags (std::ios::left)
+		     << make_dimensions_string (dims, param.dimensions)
+		     << std::setiosflags (std::ios::left)
+		     << std::setw (back)
+		     << ""
+		     << std::resetiosflags (std::ios::left);
+		}
+	      else
+	        {
+		  os << std::setiosflags (std::ios::left)
+		     << std::setw (param.parameter_length);
+		}
+	      break;
+
+	    default:
+	      error ("whos_line_format: modifier `%c' unknown",
+		     param.modifier);
+
+	      os << std::setiosflags (std::ios::right)
+		 << std::setw (param.parameter_length);
+	    }
+
+	  switch (param.command)
+	    {
+	    case 'a':
+	      {
+		char tmp[5];
+
+		tmp[0] = (sr.is_automatic () ? 'a' : ' ');
+		tmp[1] = (sr.is_formal () ? 'f' : ' ');
+		tmp[2] = (sr.is_global () ? 'g' : ' ');
+		tmp[3] = (sr.is_persistent () ? 'p' : ' ');
+		tmp[4] = 0;
+
+		os << tmp;
+	      }
+	      break;
+
+	    case 'b':
+	      os << val.byte_size ();
+	      break;
+
+	    case 'c':
+	      os << val.class_name ();
+	      break;
+
+	    case 'e':
+	      os << val.capacity ();
+	      break;
+
+	    case 'n':
+	      os << sr.name ();
+	      break;
+
+	    case 's':
+	      if (param.modifier != 'c')
+		os << make_dimensions_string (dims, param.dimensions);
+	      break;
+
+	    case 't':
+	      os << val.type_name ();
+	      break;
+	    
+	    default:
+	      error ("whos_line_format: command `%c' unknown", param.command);
+	    }
+
+	  os << std::resetiosflags (std::ios::left)
+	     << std::resetiosflags (std::ios::right);
+	  i++;
+        }
+      else
+	{
+	  os << param.text;
+	  i++;
+	}
+    }
 }
 
 static octave_value
-do_who (int argc, const string_vector& argv, int return_list)
+do_who (int argc, const string_vector& argv, bool return_list,
+	bool verbose = false)
 {
   octave_value retval;
 
-  bool show_builtins = false;
-  bool show_functions = false;
-  bool show_variables = false;
-  bool show_verbose = false;
-
   std::string my_name = argv[0];
 
+  bool global_only = false;
+
   int i;
   for (i = 1; i < argc; i++)
     {
-      if (argv[i] == "-all" || argv[i] == "-a")
+      if (argv[i] == "-regexp" || argv[i] == "-file")
 	{
-	  show_builtins = true;
-	  show_functions = true;
-	  show_variables = true;
+	  error ("%s: `%s' option not implemented", my_name.c_str (),
+		 argv[i].c_str ());
+
+	  return retval;
 	}
-      else if (argv[i] == "-builtins" || argv[i] == "-b")
-	show_builtins = true;
-      else if (argv[i] == "-functions" || argv[i] == "-f")
-	show_functions = true;
-      else if (argv[i] == "-long" || argv[i] == "-l")
-	show_verbose = true;
-      else if (argv[i] == "-variables" || argv[i] == "-v")
-	show_variables = true;
+      else if (argv[i] == "global")
+	global_only = true;
       else if (argv[i][0] == '-')
 	warning ("%s: unrecognized option `%s'", my_name.c_str (),
 		 argv[i].c_str ());
       else
 	break;
     }
 
-  // If no options were specified to select the type of symbol to
-  // display, then set defaults.
-
-  if (! (show_builtins || show_functions || show_variables))
+  int npats = argc - i;
+  string_vector pats (npats > 0 ? npats : 1);
+  if (npats > 0)
     {
-      show_functions = at_top_level ();
-      show_variables = true;
+      for (int j = 0; j < npats; j++)
+	pats[j] = argv[i+j];
     }
-
-  int npats = argc - i;
-  string_vector pats (npats);
-  for (int j = 0; j < npats; j++)
-    pats[j] = argv[i+j];
-
-  // If the user specified -l and nothing else, show variables.  If
-  // evaluating this at the top level, also show functions.
-
-  if (show_verbose && ! (show_builtins || show_functions || show_variables))
-    {
-      show_functions = at_top_level ();
-      show_variables = 1;
-    }
+  else
+    pats[0] = "*";
+    
+  symbol_table::scope_id scope = global_only
+    ? symbol_table::global_scope () : symbol_table::current_scope ();
+
+  std::list<symbol_table::symbol_record> symbols
+    = symbol_table::glob_variables (pats, scope);
+
+  size_t symbols_len = symbols.size ();
 
   if (return_list)
     {
-      // FIXME -- maybe symbol_list should return a std::list
-      // object instead of an Array.
-
-      dim_vector dv (0, 0);
-
-      Array<symbol_record *> s3 (dv);
-      Array<symbol_record *> s4 (dv);
-      Array<symbol_record *> s5 (dv);
-      Array<symbol_record *> s6 (dv);
-      Array<symbol_record *> s7 (dv);
-      Array<symbol_record *> s8 (dv);
-
-      if (show_builtins)
-	{
-	  s3 = fbi_sym_tab->symbol_list (pats, symbol_record::BUILTIN_FUNCTION,
-					 SYMTAB_ALL_SCOPES);
-	}
-
-      if (show_functions)
-	{
-	  s4 = fbi_sym_tab->symbol_list (pats, symbol_record::DLD_FUNCTION,
-					 SYMTAB_ALL_SCOPES);
-
-	  s5 = fbi_sym_tab->symbol_list (pats, symbol_record::USER_FUNCTION,
-					 SYMTAB_ALL_SCOPES);
-
-	  s6 = fbi_sym_tab->symbol_list (pats, symbol_record::MEX_FUNCTION,
-					 SYMTAB_ALL_SCOPES);
-	}
-
-      if (show_variables)
-	{
-	  s7 = curr_sym_tab->symbol_list (pats, symbol_record::USER_VARIABLE,
-					  SYMTAB_LOCAL_SCOPE);
-
-	  s8 = curr_sym_tab->symbol_list (pats, symbol_record::USER_VARIABLE,
-					  SYMTAB_GLOBAL_SCOPE);
-	}
-
-      octave_idx_type s3_len = s3.length ();
-      octave_idx_type s4_len = s4.length ();
-      octave_idx_type s5_len = s5.length ();
-      octave_idx_type s6_len = s6.length ();
-      octave_idx_type s7_len = s7.length ();
-      octave_idx_type s8_len = s8.length ();
-
-      octave_idx_type symbols_len
-	= s3_len + s4_len + s5_len + s6_len + s7_len + s8_len;
-
-      Array<symbol_record *> symbols (dim_vector (symbols_len, 1));
-
-      octave_idx_type k = 0;
-
-      symbols.insert (s3, k, 0);
-      k += s3_len;
-      symbols.insert (s4, k, 0);
-      k += s4_len;
-      symbols.insert (s5, k, 0);
-      k += s5_len;
-      symbols.insert (s6, k, 0);
-      k += s6_len;
-      symbols.insert (s7, k, 0);
-      k += s7_len;
-      symbols.insert (s8, k, 0);
-
-      symbols.qsort (symbol_record_name_compare);
-
-      if (show_verbose)
+      if (verbose)
 	{
 	  Array<octave_value> name_info (symbols_len, 1);
 	  Array<octave_value> size_info (symbols_len, 1);
 	  Array<octave_value> bytes_info (symbols_len, 1);
 	  Array<octave_value> class_info (symbols_len, 1);
 	  Array<octave_value> global_info (symbols_len, 1);
 	  Array<octave_value> sparse_info (symbols_len, 1);
 	  Array<octave_value> complex_info (symbols_len, 1);
 	  Array<octave_value> nesting_info (symbols_len, 1);
 
-	  for (octave_idx_type j = 0; j < symbols_len; j++)
+	  std::list<symbol_table::symbol_record>::const_iterator p
+	    = symbols.begin ();
+
+	  for (size_t j = 0; j < symbols_len; j++)
 	    {
-	      symbol_record *sr = symbols(j);
+	      const symbol_table::symbol_record& sr = *p++;
 
 	      Octave_map ni;
 
 	      std::string caller_function_name;
 
 	      octave_function *caller = octave_call_stack::caller ();
 	      if (caller)
 		caller_function_name = caller->name ();
 
 	      ni.assign ("function", caller_function_name);
 	      ni.assign ("level", 1);
 
-	      name_info(j) = sr->name ();
-	      size_info(j) = sr->size ();
-	      bytes_info(j) = sr->byte_size ();
-	      class_info(j) = sr->class_name ();
-	      global_info(j) = sr->is_linked_to_global ();
-	      sparse_info(j) = sr->is_sparse_type ();
-	      complex_info(j) = sr->is_complex_type ();
+	      name_info(j) = sr.name ();
+	      global_info(j) = sr.is_global ();
+
+	      octave_value val = sr.varval ();
+
+	      size_info(j) = val.size ();
+	      bytes_info(j) = val.byte_size ();
+	      class_info(j) = val.class_name ();
+	      sparse_info(j) = val.is_sparse_type ();
+	      complex_info(j) = val.is_complex_type ();
 	      nesting_info(j) = ni;
 	    }
 
 	  Octave_map info;
 
 	  info.assign ("name", name_info);
 	  info.assign ("size", size_info);
 	  info.assign ("bytes", bytes_info);
@@ -1734,66 +1725,80 @@ do_who (int argc, const string_vector& a
       else
 	{
 	  string_vector names;
 
 	  if (symbols_len > 0)
 	    {
 	      names.resize (symbols_len);
 
-	      for (octave_idx_type j = 0; j < symbols_len; j++)
-		names[j] = symbols(j)->name ();
+	      std::list<symbol_table::symbol_record>::const_iterator p
+		= symbols.begin ();
+
+	      for (size_t j = 0; j < symbols_len; j++)
+		{
+		  names[j] = p->name ();
+		  p++;
+		}
 	    }
 
 	  retval = Cell (names);
 	}
     }
-  else
+  else if (symbols_len > 0)
     {
-      int pad_after = 0;
-
-      if (show_builtins)
-	{
-	  pad_after += fbi_sym_tab->maybe_list
-	    ("*** built-in functions:", pats, octave_stdout,
-	     show_verbose, symbol_record::BUILTIN_FUNCTION, SYMTAB_ALL_SCOPES);
-	}
-
-      if (show_functions)
+      if (global_only)
+	octave_stdout << "Global variables:\n\n";
+      else
+	octave_stdout << "Variables in the current scope:\n\n";
+
+      if (verbose)
 	{
-	  pad_after += fbi_sym_tab->maybe_list
-	    ("*** dynamically linked functions:", pats,
-	     octave_stdout, show_verbose, symbol_record::DLD_FUNCTION,
-	     SYMTAB_ALL_SCOPES);
-
-	  pad_after += fbi_sym_tab->maybe_list
-	    ("*** currently compiled functions:", pats,
-	     octave_stdout, show_verbose, symbol_record::USER_FUNCTION,
-	     SYMTAB_ALL_SCOPES);
-
-	  pad_after += fbi_sym_tab->maybe_list
-	    ("*** mex functions:", pats,
-	     octave_stdout, show_verbose, symbol_record::MEX_FUNCTION,
-	     SYMTAB_ALL_SCOPES);
+	  size_t bytes = 0;
+	  size_t elements = 0;
+
+	  std::list<whos_parameter> params;
+
+	  params = parse_whos_line_format (symbols);
+
+	  print_descriptor (octave_stdout, params);
+
+	  octave_stdout << "\n";
+
+	  for (std::list<symbol_table::symbol_record>::const_iterator p = symbols.begin ();
+	       p != symbols.end (); p++)
+	    {
+	      print_symbol_info_line (octave_stdout, *p, params);
+	      octave_value val = p->varval ();
+	      elements += val.capacity ();
+	      bytes += val.byte_size ();
+	    }
+
+	  octave_stdout << "\nTotal is " << elements
+			<< (elements == 1 ? " element" : " elements")
+			<< " using " << bytes
+			<< (bytes == 1 ? " byte" : " bytes") << "\n";
 	}
-
-      if (show_variables)
+      else
 	{
-	  pad_after += curr_sym_tab->maybe_list
-	    ("*** local user variables:", pats, octave_stdout,
-	     show_verbose, symbol_record::USER_VARIABLE, SYMTAB_LOCAL_SCOPE);
-
-	  pad_after += curr_sym_tab->maybe_list
-	    ("*** globally visible user variables:", pats,
-	     octave_stdout, show_verbose, symbol_record::USER_VARIABLE,
-	     SYMTAB_GLOBAL_SCOPE);
+	  string_vector names (symbols_len);
+
+	  std::list<symbol_table::symbol_record>::const_iterator p
+	    = symbols.begin ();
+
+	  for (size_t j = 0; j < symbols_len; j++)
+	    {
+	      names[j] = p->name ();
+	      p++;
+	    }
+
+	  names.list_in_columns (octave_stdout);
 	}
 
-      if (pad_after)
-	octave_stdout << "\n";
+      octave_stdout << "\n";
     }
 
   return retval;
 }
 
 DEFCMD (who, args, nargout,
   "-*- texinfo -*-\n\
 @deffn {Command} who options pattern @dots{}\n\
@@ -1835,20 +1840,18 @@ The command @kbd{whos} is equivalent to 
   octave_value retval;
 
   if (nargout < 2)
     {
       int argc = args.length () + 1;
 
       string_vector argv = args.make_argv ("who");
 
-      if (error_state)
-	return retval;
-
-      retval = do_who (argc, argv, nargout == 1);
+      if (! error_state)
+	retval = do_who (argc, argv, nargout == 1);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFCMD (whos, args, nargout,
@@ -1856,122 +1859,109 @@ DEFCMD (whos, args, nargout,
 @deffn {Command} whos options pattern @dots{}\n\
 See who.\n\
 @end deffn")
 {
   octave_value retval;
 
   if (nargout < 2)
     {
-      int nargin = args.length ();
-
-      octave_value_list tmp_args;
-
-      for (int i = nargin; i > 0; i--)
-	tmp_args(i) = args(i-1);
-
-      tmp_args(0) = "-long";
-
-      int argc = tmp_args.length () + 1;
-
-      string_vector argv = tmp_args.make_argv ("whos");
-
-      if (error_state)
-	return retval;
-
-      retval = do_who (argc, argv, nargout == 1);
+      int argc = args.length () + 1;
+
+      string_vector argv = args.make_argv ("whos");
+
+      if (! error_state)
+	retval = do_who (argc, argv, nargout == 1, true);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 // Defining variables.
 
 void
 bind_ans (const octave_value& val, bool print)
 {
-  symbol_record *sr = curr_sym_tab->lookup ("ans", true);
+  static std::string ans = "ans";
 
   if (val.is_defined ())
     {
-      sr->define (val);
+      symbol_table::varref (ans) = val;
 
       if (print)
-	val.print_with_name (octave_stdout, "ans");
+	val.print_with_name (octave_stdout, ans);
     }
 }
 
 void
 bind_internal_variable (const std::string& fname, const octave_value& val)
 {
   octave_value_list args;
 
   args(0) = val;
 
   feval (fname, args, 0);
 }
 
 void 
-mlock (const std::string& nm)
+mlock (void)
 {
-  symbol_record *sr = fbi_sym_tab->lookup (nm, true);
-
-  if (sr)
-    sr->mark_as_static ();
+  octave_function *fcn = octave_call_stack::caller ();
+
+  if (fcn)
+    fcn->lock ();
+  else
+    error ("mlock: invalid use outside a function");
 }
 
 void 
 munlock (const std::string& nm)
 {
-  symbol_record *sr = fbi_sym_tab->lookup (nm);
-
-  if (sr && sr->is_static ())
-    sr->unmark_static ();
-  else
-    error ("munlock: %s is not locked", nm.c_str ());
+  octave_value val = symbol_table::find_function (nm);
+
+  if (val.is_defined ())
+    {
+      octave_function *fcn = val.function_value ();
+
+      if (fcn)
+	fcn->unlock ();
+    }
 }
 
 bool
 mislocked (const std::string& nm)
 {
-  symbol_record *sr = fbi_sym_tab->lookup (nm);
-
-  return (sr && sr->is_static ());
+  bool retval = false;
+
+  octave_value val = symbol_table::find_function (nm);
+
+  if (val.is_defined ())
+    {
+      octave_function *fcn = val.function_value ();
+
+      if (fcn)
+	retval = fcn->islocked ();
+    }
+
+  return retval;
 }
 
 DEFCMD (mlock, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mlock (@var{name})\n\
-Lock the named function into memory.  If no function is named\n\
-then lock in the current function.\n\
+Lock the current function into memory so that it can't be cleared.\n\
 @seealso{munlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (args.length () == 1)
-    {
-      std::string name = args(0).string_value ();
-
-      if (! error_state)
-	mlock (name);
-      else
-	error ("mlock: expecting argument to be a function name");
-    }
-  else if (args.length () == 0)
-    {
-      octave_user_function *fcn = octave_call_stack::caller_user_function ();
-
-      if (fcn)
-        mlock (fcn->name ());
-      else
-        error ("mlock: invalid use outside a function");
-    }
+  if (args.length () == 0)
+    mlock ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFCMD (munlock, args, ,
   "-*- texinfo -*-\n\
@@ -1989,20 +1979,20 @@ then unlock the current function.\n\
 
       if (! error_state)
         munlock (name);
       else
 	error ("munlock: expecting argument to be a function name");
     }
   else if (args.length () == 0)
     {
-      octave_user_function *fcn = octave_call_stack::caller_user_function ();
+      octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
-        munlock (fcn->name ());
+        fcn->unlock ();
       else
         error ("munlock: invalid use outside a function");
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -2024,20 +2014,20 @@ then return true if the current function
 
       if (! error_state)
         retval = mislocked (name);
       else
 	error ("mislocked: expecting argument to be a function name");
     }
   else if (args.length () == 0)
     {
-      octave_user_function *fcn = octave_call_stack::caller_user_function ();
+      octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
-        retval = mislocked (fcn->name ());
+        retval = fcn->islocked ();
       else
         error ("mislocked: invalid use outside a function");
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -2064,337 +2054,185 @@ name_matches_any_pattern (const std::str
 	      break;
 	    }
 	}
     }
 
   return retval;
 }
 
-static inline bool
-is_local_variable (const std::string& nm)
-{
-  symbol_record *sr = curr_sym_tab->lookup (nm);
-
-  return (sr && sr->is_variable ());
-}
-
 static inline void
 maybe_warn_exclusive (bool exclusive)
 {
   if (exclusive)
     warning ("clear: ignoring --exclusive option");
 }
 
-static inline void
-do_clear_all (void)
-{
-  curr_sym_tab->clear ();
-  fbi_sym_tab->clear_functions ();
-  global_sym_tab->clear ();
-}
-
-static inline void
-do_clear_functions (void)
-{
-  curr_sym_tab->clear_functions ();
-  fbi_sym_tab->clear_functions ();
-}
-
-static inline void
-do_clear_globals (void)
-{
-  curr_sym_tab->clear_globals ();
-  global_sym_tab->clear ();
-}
-
-static inline void
-do_clear_variables (void)
-{
-  curr_sym_tab->clear ();
-}
-
-static inline bool
-do_clear_function (const std::string& nm)
-{
-  bool b1 = curr_sym_tab->clear_function (nm);
-
-  bool b2 = fbi_sym_tab->clear_function (nm);
-
-  return b1 || b2;
-}
-
-static inline bool
-do_clear_global (const std::string& nm)
-{
-  bool b1 = curr_sym_tab->clear_global (nm);
-
-  bool b2 = global_sym_tab->clear_variable (nm);
-
-  return b1 || b2;
-}
-
-static inline bool
-do_clear_variable (const std::string& nm)
-{
-  return curr_sym_tab->clear_variable (nm);
-}
-
-static inline bool
-do_clear_symbol (const std::string& nm)
-{
-  bool cleared = curr_sym_tab->clear_variable (nm);
-
-  if (! cleared)
-    cleared = do_clear_function (nm);
-
-  return cleared;
-}
-
-static inline bool
-do_clear_function_pattern (const std::string& pat)
-{
-  bool b1 = curr_sym_tab->clear_function_pattern (pat);
-
-  bool b2 = fbi_sym_tab->clear_function_pattern (pat);
-
-  return b1 || b2;
-}
-
-static inline bool
-do_clear_global_pattern (const std::string& pat)
-{
-  bool b1 = curr_sym_tab->clear_global_pattern (pat);
-
-  bool b2 = global_sym_tab->clear_variable_pattern (pat);
-
-  return b1 || b2;
-}
-
-static inline bool
-do_clear_variable_pattern (const std::string& pat)
-{
-  return curr_sym_tab->clear_variable_pattern (pat);
-}
-
-static inline bool
-do_clear_symbol_pattern (const std::string& pat)
-{
-  // FIXME -- if we have a variable v1 and a function v2 and
-  // someone says clear v*, we will clear the variable but not the
-  // function.  Is that really what should happen?  (I think it is
-  // what Matlab does.)
-
-  bool cleared = curr_sym_tab->clear_variable_pattern (pat);
-
-  if (! cleared)
-    cleared = do_clear_function_pattern (pat);
-
-  return cleared;
-}
-
-static inline void
+static void
 do_clear_functions (const string_vector& argv, int argc, int idx,
 		    bool exclusive = false)
 {
   if (idx == argc)
-    do_clear_functions ();
+    symbol_table::clear_functions ();
   else
     {
       if (exclusive)
 	{
-	  string_vector lfcns = curr_sym_tab->user_function_name_list ();
-
-	  int lcount = lfcns.length ();
-
-	  for (int i = 0; i < lcount; i++)
-	    {
-	      std::string nm = lfcns[i];
-
-	      if (! name_matches_any_pattern (nm, argv, argc, idx))
-		do_clear_function (nm);
-	    }
-
-	  string_vector fcns = fbi_sym_tab->user_function_name_list ();
+	  string_vector fcns = symbol_table::user_function_names ();
 
 	  int fcount = fcns.length ();
 
 	  for (int i = 0; i < fcount; i++)
 	    {
 	      std::string nm = fcns[i];
 
 	      if (! name_matches_any_pattern (nm, argv, argc, idx))
-		do_clear_function (nm);
+		symbol_table::clear_function (nm);
 	    }
 	}
       else
 	{
 	  while (idx < argc)
-	    do_clear_function_pattern (argv[idx++]);
+	    symbol_table::clear_function_pattern (argv[idx++]);
 	}
     }
 }
 
-static inline void
+static void
 do_clear_globals (const string_vector& argv, int argc, int idx,
 		  bool exclusive = false)
 {
   if (idx == argc)
-    do_clear_globals ();
+    symbol_table::clear_variables(symbol_table::global_scope ());
   else
     {
       if (exclusive)
 	{
-	  string_vector lvars = curr_sym_tab->global_variable_name_list ();
-
-	  int lcount = lvars.length ();
-
-	  for (int i = 0; i < lcount; i++)
-	    {
-	      std::string nm = lvars[i];
-
-	      if (! name_matches_any_pattern (nm, argv, argc, idx))
-		do_clear_global (nm);
-	    }
-
-	  string_vector gvars = global_sym_tab->global_variable_name_list ();
+	  string_vector gvars
+	    = symbol_table::variable_names (symbol_table::global_scope ());
 
 	  int gcount = gvars.length ();
 
 	  for (int i = 0; i < gcount; i++)
 	    {
 	      std::string nm = gvars[i];
 
 	      if (! name_matches_any_pattern (nm, argv, argc, idx))
-		do_clear_global (nm);
+		symbol_table::clear_global (nm);
 	    }
 	}
       else
 	{
 	  while (idx < argc)
-	    do_clear_global_pattern (argv[idx++]);
+	    symbol_table::clear_global_pattern (argv[idx++]);
 	}
     }
 }
 
-static inline void
+static void
 do_clear_variables (const string_vector& argv, int argc, int idx,
 		    bool exclusive = false)
 {
   if (idx == argc)
-    do_clear_variables ();
+    symbol_table::clear_variables ();
   else
     {
       if (exclusive)
 	{
-	  string_vector lvars = curr_sym_tab->variable_name_list ();
+	  string_vector lvars = symbol_table::variable_names ();
 
 	  int lcount = lvars.length ();
 
 	  for (int i = 0; i < lcount; i++)
 	    {
 	      std::string nm = lvars[i];
 
 	      if (! name_matches_any_pattern (nm, argv, argc, idx))
-		do_clear_variable (nm);
+		symbol_table::clear_variable (nm);
 	    }
 	}
       else
 	{
 	  while (idx < argc)
-	    do_clear_variable_pattern (argv[idx++]);
+	    symbol_table::clear_variable_pattern (argv[idx++]);
 	}
     }
 }
 
-static inline void
+static void
 do_clear_symbols (const string_vector& argv, int argc, int idx,
 		  bool exclusive = false)
 {
   if (idx == argc)
-    do_clear_variables ();
+    symbol_table::clear_variables ();
   else
     {
       if (exclusive)
 	{
 	  // FIXME -- is this really what we want, or do we
 	  // somehow want to only clear the functions that are not
 	  // shadowed by local variables?  It seems that would be a
 	  // bit harder to do.
 
 	  do_clear_variables (argv, argc, idx, exclusive);
 	  do_clear_functions (argv, argc, idx, exclusive);
 	}
       else
 	{
 	  while (idx < argc)
-	    do_clear_symbol_pattern (argv[idx++]);
+	    symbol_table::clear_symbol_pattern (argv[idx++]);
 	}
     }
 }
 
 static void
 do_matlab_compatible_clear (const string_vector& argv, int argc, int idx)
 {
   // This is supposed to be mostly Matlab compatible.
 
   for (; idx < argc; idx++)
     {
-      if (argv[idx] == "all" && ! is_local_variable ("all"))
+      if (argv[idx] == "all"
+	  && ! symbol_table::is_local_variable ("all"))
 	{
-	  do_clear_all ();
+	  symbol_table::clear_all ();
 	}
-      else if (argv[idx] == "functions" && ! is_local_variable ("functions"))
+      else if (argv[idx] == "functions"
+	       && ! symbol_table::is_local_variable ("functions"))
 	{
 	  do_clear_functions (argv, argc, ++idx);
 	}
-      else if (argv[idx] == "global" && ! is_local_variable ("global"))
+      else if (argv[idx] == "global"
+	       && ! symbol_table::is_local_variable ("global"))
 	{
 	  do_clear_globals (argv, argc, ++idx);
 	}
-      else if (argv[idx] == "variables" && ! is_local_variable ("variables"))
+      else if (argv[idx] == "variables"
+	       && ! symbol_table::is_local_variable ("variables"))
 	{
-	  do_clear_variables ();
+	  symbol_table::clear_variables ();
 	}
       else
 	{
-	  do_clear_symbol_pattern (argv[idx]);
+	  symbol_table::clear_symbol_pattern (argv[idx]);
 	}
     }
 }
 
 #define CLEAR_OPTION_ERROR(cond) \
   do \
     { \
       if (cond) \
         { \
           print_usage (); \
           return retval; \
         } \
     } \
   while (0)
 
-bool
-clear_function (const std::string& nm)
-{
-  return do_clear_function (nm);
-}
-
-bool
-clear_variable (const std::string& nm)
-{
-  return do_clear_variable (nm);
-}
-
-bool
-clear_symbol (const std::string& nm)
-{
-  return do_clear_symbol (nm);
-}
-
 DEFCMD (clear, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} clear [-x] pattern @dots{}\n\
 Delete the names matching the given patterns from the symbol table.  The\n\
 pattern may contain the following special characters:\n\
 \n\
 @table @code\n\
 @item ?\n\
@@ -2438,17 +2276,17 @@ With -x, clear the variables that don't 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("clear");
 
   if (! error_state)
     {
       if (argc == 1)
 	{
-	  do_clear_variables ();
+	  symbol_table::clear_variables ();
 	}
       else
 	{
 	  int idx = 0;
 
 	  bool clear_all = false;
 	  bool clear_functions = false;
 	  bool clear_globals = false;
@@ -2506,19 +2344,17 @@ With -x, clear the variables that don't 
 		  if (clear_all)
 		    {
 		      maybe_warn_exclusive (exclusive);
 
 		      if (++idx < argc)
 			warning
 			  ("clear: ignoring extra arguments after -all");
 
-		      curr_sym_tab->clear ();
-		      fbi_sym_tab->clear_functions ();
-		      global_sym_tab->clear ();
+		      symbol_table::clear_all ();
 		    }
 		  else if (clear_functions)
 		    {
 		      do_clear_functions (argv, argc, idx, exclusive);
 		    }
 		  else if (clear_globals)
 		    {
 		      do_clear_globals (argv, argc, idx, exclusive);
@@ -2542,147 +2378,91 @@ With -x, clear the variables that don't 
 DEFUN (__print_symtab_info__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __print_symtab_info__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin == 1)
-    {
-      std::string arg = args(0).string_value ();
-
-      if (arg == "fbi")
-	fbi_sym_tab->print_info (octave_stdout);
-      else if (arg == "global")
-	global_sym_tab->print_info (octave_stdout);
-      else if (arg == "top-level")
-	top_level_sym_tab->print_info (octave_stdout);
-      else
-	{
-	  symbol_record *fsr = fbi_sym_tab->lookup (arg, true);
-
-	  if (fsr && fsr->is_user_function ())
-	    {
-	      octave_value tmp = fsr->def ();
-	      const octave_base_value& rep = tmp.get_rep ();
-	      
-	      const octave_user_function& fcn
-		= dynamic_cast<const octave_user_function&> (rep);
-
-	      fcn.print_symtab_info (octave_stdout);
-	    }
-	  else
-	    error ("no user-defined function named %s", arg.c_str ());
-	}
-    }
-  else if (nargin == 0)
-    curr_sym_tab->print_info (octave_stdout);
-  else
-    print_usage ();
+  // FIXME -- what should this function do now?  Print a summary for
+  // each scope?  Print the entire symbol table?  Accept a scope
+  // argument?
 
   return retval;
 }
 
 DEFUN (__print_symbol_info__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __dump_symbol_info__ (@var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin == 1)
-    {
-      std::string symbol_name = args(0).string_value ();
-
-      if (! error_state)
-	{
-	  symbol_record *sr = curr_sym_tab->lookup (symbol_name);
-
-	  if (sr)
-	    sr->print_info (octave_stdout);
-	  else
-	    error ("__print_symbol_info__: symbol %s not found",
-		   symbol_name.c_str ());
-	}
-      else
-	print_usage ();
-    }
-  else
-    print_usage ();
+  // FIXME -- what should this function do now?
 
   return retval;
 }
 
-DEFUN (ignore_function_time_stamp, args, nargout,
-    "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} ignore_function_time_stamp ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})\n\
-Query or set the internal variable that controls whether Octave checks\n\
-the time stamp on files each time it looks up functions defined in\n\
-function files.  If the internal variable is set to @code{\"system\"},\n\
-Octave will not automatically recompile function files in subdirectories of\n\
-@file{@var{octave-home}/lib/@var{version}} if they have changed since\n\
-they were last compiled, but will recompile other function files in the\n\
-search path if they change.  If set to @code{\"all\"}, Octave will not\n\
-recompile any function files unless their definitions are removed with\n\
-@code{clear}.  If set to \"none\", Octave will always check time stamps\n\
-on files to determine whether functions defined in function files\n\
-need to be recompiled.\n\
+DEFUN (whos_line_format, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} whos_line_format ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} whos_line_format (@var{new_val})\n\
+Query or set the format string used by the @code{whos}.\n\
+\n\
+The following escape sequences may be used in the format:\n\
+@table @code\n\
+@item %a\n\
+Prints attributes of variables (g=global, p=persistent,\n\
+f=formal parameter, a=automatic variable).\n\
+@item %b\n\
+Prints number of bytes occupied by variables.\n\
+@item %c\n\
+Prints class names of variables.\n\
+@item %e\n\
+Prints elements held by variables.\n\
+@item %n\n\
+Prints variable names.\n\
+@item %s\n\
+Prints dimensions of variables.\n\
+@item %t\n\
+Prints type names of variables.\n\
+@end table\n\
+\n\
+Every command may also have a modifier:\n\
+@table @code\n\
+@item l\n\
+Left alignment.\n\
+@item r\n\
+Right alignment (this is the default).\n\
+@item c\n\
+Centered (may only be applied to command %s).\n\
+@end table\n\
+\n\
+A command is composed like this:\n\
+\n\
+@example\n\
+%[modifier]<command>[:size_of_parameter[:center-specific[\n\
+       :print_dims[:balance]]]];\n\
+@end example\n\
+\n\
+Command and modifier is already explained. Size_of_parameter\n\
+tells how many columns the parameter will need for printing.\n\
+print_dims tells how many dimensions to print. If number of\n\
+dimensions exceeds print_dims, dimensions will be printed like\n\
+x-D.\n\
+center-specific and print_dims may only be applied to command\n\
+%s. A negative value for print_dims will cause Octave to print all\n\
+dimensions whatsoever.\n\
+balance specifies the offset for printing of the dimensions string.\n\
+\n\
+The default format is \"  %a:4; %ln:6; %cs:16:6:8:1;  %rb:12;  %lc:-1;\\n\".\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (nargout > 0)
-    {
-      switch (Vignore_function_time_stamp)
-	{
-	case 1:
-	  retval = "system";
-	  break;
-
-	case 2:
-	  retval = "all";
-	  break;
-
-	default:
-	  retval = "none";
-	  break;
-	}
-    }
-
-  int nargin = args.length ();
-
-  if (nargin == 1)
-    {
-      std::string sval = args(0).string_value ();
-
-      if (! error_state)
-	{
-	  if (sval == "all")
-	    Vignore_function_time_stamp = 2;
-	  else if (sval == "system")
-	    Vignore_function_time_stamp = 1;
-	  else if (sval == "none")
-	    Vignore_function_time_stamp = 0;
-	  else
-	    error ("ignore_function_time_stamp: expecting argument to be \"all\", \"system\", or \"none\"");
-	}
-      else
-	error ("ignore_function_time_stamp: expecting argument to be character string");
-    }
-  else if (nargin > 1)
-    print_usage ();
-
-  return retval;
+  return SET_INTERNAL_VARIABLE (whos_line_format);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -21,18 +21,16 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_variables_h)
 #define octave_variables_h 1
 
 class octave_function;
 class octave_user_function;
-class symbol_record;
-class symbol_table;
 
 class tree_identifier;
 class octave_value;
 class octave_value_list;
 class octave_builtin;
 class octave_mapper;
 class string_vector;
 
@@ -40,32 +38,27 @@ class string_vector;
 #include <cfloat>
 
 #include <string>
 
 #include "ov.h"
 #include "ov-builtin.h"
 #include "symtab.h"
 
-extern OCTINTERP_API bool at_top_level (void);
-
-extern OCTINTERP_API void initialize_symbol_tables (void);
 extern OCTINTERP_API void clear_mex_functions (void);
 
+extern OCTINTERP_API void mark_as_command (const std::string&);
 extern OCTINTERP_API bool is_command_name (const std::string&);
 
 // The next three are here temporarily...
 extern OCTINTERP_API bool is_marked_as_rawcommand (const std::string& s);
 extern OCTINTERP_API void mark_as_rawcommand (const std::string& s);
 extern OCTINTERP_API void unmark_rawcommand (const std::string& s);
 
 extern OCTINTERP_API bool is_rawcommand_name (const std::string&);
-extern OCTINTERP_API bool is_mapper_function_name (const std::string&);
-extern OCTINTERP_API bool is_builtin_function_name (const std::string&);
-extern OCTINTERP_API bool is_globally_visible (const std::string&);
 
 extern OCTINTERP_API octave_function *
 is_valid_function (const octave_value&, const std::string& = std::string (),
 		   bool warn = false); 
 
 extern OCTINTERP_API octave_function *
 is_valid_function (const std::string&, const std::string& = std::string (),
 		   bool warn = false); 
@@ -86,30 +79,16 @@ extern OCTINTERP_API bool
 looks_like_struct (const std::string& text);
 
 extern OCTINTERP_API int
 symbol_exist (const std::string& name, const std::string& type = "any");
 
 extern OCTINTERP_API std::string
 unique_symbol_name (const std::string& basename);
 
-extern OCTINTERP_API bool
-fcn_out_of_date (octave_function *fcn, const std::string& ff, time_t tp);
-
-extern OCTINTERP_API bool lookup (symbol_record *s, bool exec_script = true);
-
-extern OCTINTERP_API symbol_record *
-lookup_by_name (const std::string& nm, bool exec_script = true);
-
-extern OCTINTERP_API octave_value
-lookup_function (const std::string& nm,
-		 const std::string& parent = std::string ());
-
-extern OCTINTERP_API octave_value lookup_user_function (const std::string& nm);
-
 extern OCTINTERP_API octave_value lookup_function_handle (const std::string& nm);
 
 extern OCTINTERP_API octave_value
 get_global_value (const std::string& nm, bool silent = false);
 
 extern OCTINTERP_API void set_global_value (const std::string& nm, const octave_value& val);
 
 extern OCTINTERP_API octave_value
@@ -142,48 +121,28 @@ set_internal_variable (std::string& var,
 
 #define SET_INTERNAL_VARIABLE_WITH_LIMITS(NM, MINVAL, MAXVAL) \
   set_internal_variable (V ## NM, args, nargout, #NM, MINVAL, MAXVAL)
 
 extern OCTINTERP_API std::string builtin_string_variable (const std::string&);
 extern OCTINTERP_API int builtin_real_scalar_variable (const std::string&, double&);
 extern OCTINTERP_API octave_value builtin_any_variable (const std::string&);
 
-extern OCTINTERP_API void link_to_global_variable (symbol_record *sr);
-extern OCTINTERP_API void link_to_builtin_or_function (symbol_record *sr);
-
-extern OCTINTERP_API void force_link_to_function (const std::string&);
-
 extern OCTINTERP_API void bind_ans (const octave_value& val, bool print);
 
 extern OCTINTERP_API void
 bind_internal_variable (const std::string& fname, const octave_value& val);
 
-extern OCTINTERP_API void mlock (const std::string&);
+extern OCTINTERP_API void mlock (void);
 extern OCTINTERP_API void munlock (const std::string&);
 extern OCTINTERP_API bool mislocked (const std::string&);
 
-extern OCTINTERP_API bool clear_function (const std::string& nm);
-extern OCTINTERP_API bool clear_variable (const std::string& nm);
-extern OCTINTERP_API bool clear_symbol (const std::string& nm);
-
-// Symbol table for symbols at the top level.
-extern OCTINTERP_API symbol_table *top_level_sym_tab;
-
-// Symbol table for the current scope.
-extern OCTINTERP_API symbol_table *curr_sym_tab;
-
-// Symbol table for the current caller scope.
-extern OCTINTERP_API symbol_table *curr_caller_sym_tab;
-
-// Symbol table for global symbols.
-extern OCTINTERP_API symbol_table *global_sym_tab;
-
-// Symbol table for functions and built-in symbols.
-extern OCTINTERP_API symbol_table *fbi_sym_tab;
+extern OCTINTERP_API void clear_function (const std::string& nm);
+extern OCTINTERP_API void clear_variable (const std::string& nm);
+extern OCTINTERP_API void clear_symbol (const std::string& nm);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/version.h b/src/version.h
--- a/src/version.h
+++ b/src/version.h
@@ -19,19 +19,19 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_version_h)
 #define octave_version_h 1
 
-#define OCTAVE_VERSION "3.0.0"
+#define OCTAVE_VERSION "3.0.0+"
 
-#define OCTAVE_API_VERSION "api-v32"
+#define OCTAVE_API_VERSION "api-v32+"
 
 #define OCTAVE_RELEASE_DATE "2007-12-21"
 
 #define OCTAVE_COPYRIGHT "Copyright (C) 2007 John W. Eaton and others."
 
 // This is the first line printed by --version.  The GNU coding
 // standards say that the version number should follow the last space
 // on the line.
