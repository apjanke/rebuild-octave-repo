# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1504704346 14400
#      Wed Sep 06 09:25:46 2017 -0400
# Node ID 9107bae20480c6dff75307a1462c6986f4cb00c3
# Parent  584971932defc89b879c37e2a861fa5e1d350492
style fixes for some GUI source files

* color-picker.cc, color-picker.h, documentation-dock-widget.cc,
documentation-dock-widget.h, external-editor-interface.cc,
external-editor-interface.h, find-files-dialog.cc,
find-files-dialog.h, find-files-model.cc, find-files-model.h,
history-dock-widget.cc, history-dock-widget.h, settings-dialog.cc,
settings-dialog.h, terminal-dock-widget.cc, thread-manager.cc,
thread-manager.h: Use m_ prefix for member variables, order
functions consistently in header and source files, and follow more
Octave coding conventions.

diff --git a/libgui/src/color-picker.cc b/libgui/src/color-picker.cc
--- a/libgui/src/color-picker.cc
+++ b/libgui/src/color-picker.cc
@@ -27,46 +27,48 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "color-picker.h"
 
 // constuctor with initial color as parameter
-color_picker::color_picker (QColor old_color, QWidget *p) : QPushButton (p)
+color_picker::color_picker (QColor old_color, QWidget *p)
+  : QPushButton (p)
 {
-  _color = old_color;
+  m_color = old_color;
   setFlat (true);
   setFocusPolicy (Qt::NoFocus);  // no focus, would changes the color
   update_button ();
-  connect (this, SIGNAL (clicked ()), SLOT (select_color ()));
+  connect (this, SIGNAL (clicked (void)), SLOT (select_color (void)));
 }
 
 // slot for bitton clicked: selct a new color using QColorDialog
 void
-color_picker::select_color ()
+color_picker::select_color (void)
 {
-  QColor new_color = QColorDialog::getColor (_color);
-  if (new_color.isValid () && new_color != _color)
+  QColor new_color = QColorDialog::getColor (m_color);
+
+  if (new_color.isValid () && new_color != m_color)
     {
-      _color = new_color;
+      m_color = new_color;
       update_button ();
     }
 }
 
 // draw the button with the actual color (using a stylesheet)
-void color_picker::update_button ()
+void
+color_picker::update_button (void)
 {
   // Is this the right place to look for a "foreground" color that would
   // provide a reasonable border for the color swatches?
   QWidget *p = parentWidget ();
 
   QString bordercolor
     = (p ? p->palette ().text ().color ().name () : QString ("#000000"));
 
-  QString css = QString ("background-color: %1; border: 1px solid %2;")
-                .arg (_color.name ())
-                .arg (bordercolor);
+  setStyleSheet (QString ("background-color: %1; border: 1px solid %2;")
+                 .arg (m_color.name ())
+                 .arg (bordercolor));
 
-  setStyleSheet (css);
   repaint ();
 }
diff --git a/libgui/src/color-picker.h b/libgui/src/color-picker.h
--- a/libgui/src/color-picker.h
+++ b/libgui/src/color-picker.h
@@ -27,25 +27,30 @@ along with Octave; see the file COPYING.
 // Author: Torsten <ttl@justmail.de>
 
 #if ! defined (octave_color_picker_h)
 #define octave_color_picker_h 1
 
 #include <QPushButton>
 #include <QColorDialog>
 
-class color_picker: public QPushButton
+class color_picker : public QPushButton
 {
   Q_OBJECT
 
 public:
-  color_picker (QColor color = QColor (0,0,0), QWidget *parent = nullptr);
-  QColor color () const { return _color; }
+
+  color_picker (QColor color = QColor (0, 0, 0), QWidget *parent = nullptr);
+
+  QColor color (void) const { return m_color; }
 
 private slots:
-  void select_color ();
+
+  void select_color (void);
 
 private:
-  virtual void update_button ();
-  QColor _color;
+
+  virtual void update_button (void);
+
+  QColor m_color;
 };
 
 #endif
diff --git a/libgui/src/documentation-dock-widget.cc b/libgui/src/documentation-dock-widget.cc
--- a/libgui/src/documentation-dock-widget.cc
+++ b/libgui/src/documentation-dock-widget.cc
@@ -32,60 +32,62 @@ along with Octave; see the file COPYING.
 documentation_dock_widget::documentation_dock_widget (QWidget *p)
   : octave_dock_widget (p)
 {
   setObjectName ("DocumentationDockWidget");
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("Documentation"));
   setStatusTip (tr ("See the documentation for help."));
 
-  _webinfo = new webinfo (this);
-  setWidget (_webinfo);
-  setFocusProxy (_webinfo);
+  m_webinfo = new webinfo (this);
+  setWidget (m_webinfo);
+  setFocusProxy (m_webinfo);
 
-  connect (p, SIGNAL (show_doc_signal (const QString &)),
-           this, SLOT (showDoc (const QString &)));
+  connect (p, SIGNAL (show_doc_signal (const QString&)),
+           this, SLOT (showDoc (const QString&)));
+}
+
+void
+documentation_dock_widget::notice_settings (const QSettings *settings)
+{
+  m_webinfo->notice_settings (settings);
 }
 
 void
-documentation_dock_widget::copyClipboard ()
+documentation_dock_widget::load_info_file (void)
 {
-  _webinfo->copyClipboard ();
+  octave::help_system& help_sys
+    = octave::__get_help_system__ ("doc widget: load_info_file");
+
+  QString info_file = QString::fromStdString (help_sys.info_file ());
+
+  m_webinfo->load_info_file (info_file);
 }
+
 void
-documentation_dock_widget::pasteClipboard ()
+documentation_dock_widget::copyClipboard (void)
 {
-  _webinfo->pasteClipboard ();
+  m_webinfo->copyClipboard ();
 }
+
 void
-documentation_dock_widget::selectAll ()
+documentation_dock_widget::pasteClipboard (void)
 {
-  _webinfo->selectAll ();
+  m_webinfo->pasteClipboard ();
+}
+
+void
+documentation_dock_widget::selectAll (void)
+{
+  m_webinfo->selectAll ();
 }
 
 void
 documentation_dock_widget::showDoc (const QString& name)
 {
   // show the doc pane without focus for carrying on typing in the console
   if (! isVisible ())
     setVisible (true);
+
   raise ();
 
-  _webinfo->load_ref (name);
-
-}
-
-void
-documentation_dock_widget::notice_settings (const QSettings *settings)
-{
-  _webinfo->notice_settings (settings);
+  m_webinfo->load_ref (name);
 }
-
-void
-documentation_dock_widget::load_info_file ()
-{
-  octave::help_system& help_sys
-    = octave::__get_help_system__ ("doc widget: load_info_file");
-
-  QString info_file = QString::fromStdString (help_sys.info_file ());
-
-  _webinfo->load_info_file (info_file);
-}
diff --git a/libgui/src/documentation-dock-widget.h b/libgui/src/documentation-dock-widget.h
--- a/libgui/src/documentation-dock-widget.h
+++ b/libgui/src/documentation-dock-widget.h
@@ -34,23 +34,24 @@ class documentation_dock_widget : public
 public:
 
   documentation_dock_widget (QWidget *parent = nullptr);
 
 public slots:
 
   void notice_settings (const QSettings *settings);
 
-  void load_info_file ();
+  void load_info_file (void);
 
 protected slots:
-  void copyClipboard ();
-  void pasteClipboard ();
-  void selectAll ();
+
+  void copyClipboard (void);
+  void pasteClipboard (void);
+  void selectAll (void);
 
   void showDoc (const QString & name);
 
 private:
 
-  webinfo *_webinfo;
+  webinfo *m_webinfo;
 };
 
 #endif
diff --git a/libgui/src/external-editor-interface.cc b/libgui/src/external-editor-interface.cc
--- a/libgui/src/external-editor-interface.cc
+++ b/libgui/src/external-editor-interface.cc
@@ -27,44 +27,18 @@ along with Octave; see the file COPYING.
 #include <QSettings>
 #include <QMessageBox>
 #include <QProcess>
 
 #include "external-editor-interface.h"
 #include "resource-manager.h"
 
 external_editor_interface::external_editor_interface (QWidget *p)
-    : QWidget (p)
-{ };
-
-// Get and verify the settings of the external editor program
-QString
-external_editor_interface::external_editor ()
-{
-  QSettings *settings = resource_manager::get_settings ();
-  QString editor = settings->value ("customFileEditor").toString ();
-
-  // check the settings (avoid an empty string)
-  if (editor.trimmed ().isEmpty ())
-    {
-      QMessageBox *msgBox = new QMessageBox (QMessageBox::Warning,
-                              tr ("Octave Editor"),
-                              tr ("There is no custom editor configured yet.\n"
-                                  "Do you want to open the preferences?"),
-                              QMessageBox::No | QMessageBox::Yes);
-      msgBox->setDefaultButton (QMessageBox::Yes);
-      msgBox->setAttribute (Qt::WA_DeleteOnClose);
-      int button = msgBox->exec ();
-
-      if (button == QMessageBox::Yes)
-        emit request_settings_dialog ("editor");
-    }
-
-  return editor;
-}
+  : QWidget (p)
+{ }
 
 // Calling the external editor
 bool
 external_editor_interface::call_custom_editor (const QString& file, int line)
 {
   if (line > -1)  // check for a specific line (debugging)
     return true;  // yes: do not open a file in external editor
 
@@ -101,19 +75,47 @@ external_editor_interface::call_custom_e
 void
 external_editor_interface::request_new_file (const QString&)
 {
   call_custom_editor ();
 }
 
 void
 external_editor_interface::request_open_file (const QString& file_name,
-                const QString&, int line, bool, bool, bool, const QString&)
+                                              const QString&, int line,
+                                              bool, bool, bool, const QString&)
 {
   call_custom_editor (file_name, line);
 }
 
 void
 external_editor_interface::handle_edit_file_request (const QString& file)
 {
   call_custom_editor (file);
 }
 
+// Get and verify the settings of the external editor program
+QString
+external_editor_interface::external_editor (void)
+{
+  QSettings *settings = resource_manager::get_settings ();
+  QString editor = settings->value ("customFileEditor").toString ();
+
+  // check the settings (avoid an empty string)
+  if (editor.trimmed ().isEmpty ())
+    {
+      QMessageBox *msgBox
+        = new QMessageBox (QMessageBox::Warning,
+                           tr ("Octave Editor"),
+                           tr ("There is no custom editor configured yet.\n"
+                               "Do you want to open the preferences?"),
+                           QMessageBox::No | QMessageBox::Yes);
+      msgBox->setDefaultButton (QMessageBox::Yes);
+      msgBox->setAttribute (Qt::WA_DeleteOnClose);
+
+      int button = msgBox->exec ();
+
+      if (button == QMessageBox::Yes)
+        emit request_settings_dialog ("editor");
+    }
+
+  return editor;
+}
diff --git a/libgui/src/external-editor-interface.h b/libgui/src/external-editor-interface.h
--- a/libgui/src/external-editor-interface.h
+++ b/libgui/src/external-editor-interface.h
@@ -30,32 +30,35 @@ along with Octave; see the file COPYING.
 class external_editor_interface : public QWidget
 {
 
   Q_OBJECT
 
 public:
 
   external_editor_interface (QWidget *main_win);
-  ~external_editor_interface () { };
+
+  ~external_editor_interface (void) = default;
 
 signals:
 
   void request_settings_dialog (const QString&);
 
 public slots:
 
   bool call_custom_editor (const QString& file = QString (), int line = -1);
+
   void request_open_file (const QString& fileName,
                           const QString& encoding = QString (),
                           int line = -1, bool debug_pointer = false,
                           bool breakpoint_marker = false, bool insert = true,
                           const QString& cond = "");
+
   void request_new_file (const QString&);
+
   void handle_edit_file_request (const QString& file);
 
 private:
 
-  QString external_editor ();
-
+  QString external_editor (void);
 };
 
 #endif
diff --git a/libgui/src/find-files-dialog.cc b/libgui/src/find-files-dialog.cc
--- a/libgui/src/find-files-dialog.cc
+++ b/libgui/src/find-files-dialog.cc
@@ -47,300 +47,291 @@ along with Octave; see the file COPYING.
 #include "resource-manager.h"
 
 find_files_dialog::find_files_dialog (QWidget *p)
   : QDialog (p)
 {
   setWindowTitle (tr ("Find Files"));
   setWindowIcon (resource_manager::icon ("edit-find"));
 
-  _dir_iterator = nullptr;
+  m_dir_iterator = nullptr;
 
-  _timer = new QTimer (this);
-  connect (_timer, SIGNAL (timeout ()), this, SLOT (look_for_files ()));
+  m_timer = new QTimer (this);
+  connect (m_timer, SIGNAL (timeout (void)),
+           this, SLOT (look_for_files (void)));
 
   QSettings *settings = resource_manager::get_settings ();
 
   QLabel *file_name_label = new QLabel (tr ("Named:"));
-  _file_name_edit = new QLineEdit;
-  _file_name_edit->setToolTip (tr ("Enter the filename search expression"));
+  m_file_name_edit = new QLineEdit;
+  m_file_name_edit->setToolTip (tr ("Enter the filename search expression"));
 
-  _file_name_edit->setText (settings->value ("findfiles/file_name",
-                                             "*").toString ());
-  file_name_label->setBuddy (_file_name_edit);
+  m_file_name_edit->setText (settings->value ("findfiles/file_name",
+                                              "*").toString ());
+  file_name_label->setBuddy (m_file_name_edit);
 
   QLabel *start_dir_label = new QLabel (tr ("Start in:"));
 
-  _start_dir_edit = new QLineEdit;
-  _start_dir_edit->setText (settings->value ("findfiles/start_dir",
-                            QDir::currentPath ()).toString ());
-  _start_dir_edit->setToolTip (tr ("Enter the start directory"));
-  start_dir_label->setBuddy (_start_dir_edit);
+  m_start_dir_edit = new QLineEdit;
+  m_start_dir_edit->setText (settings->value ("findfiles/start_dir",
+                                              QDir::currentPath ()).toString ());
+  m_start_dir_edit->setToolTip (tr ("Enter the start directory"));
+  start_dir_label->setBuddy (m_start_dir_edit);
 
-  _browse_button = new QPushButton (tr ("Browse..."));
-  _browse_button->setToolTip (tr ("Browse for start directory"));
-  connect (_browse_button, SIGNAL (clicked ()), this, SLOT (browse_folders ()));
+  m_browse_button = new QPushButton (tr ("Browse..."));
+  m_browse_button->setToolTip (tr ("Browse for start directory"));
+  connect (m_browse_button, SIGNAL (clicked (void)),
+           this, SLOT (browse_folders (void)));
 
-  _recurse_dirs_check = new QCheckBox (tr ("Search subdirectories"));
-  _recurse_dirs_check->setChecked (settings->value ("findfiles/recurse_dirs",
-                                                    false).toBool ());
-  _recurse_dirs_check->setToolTip (
-    tr ("Search recursively through directories for matching files"));
+  m_recurse_dirs_check = new QCheckBox (tr ("Search subdirectories"));
+  m_recurse_dirs_check->setChecked (settings->value ("findfiles/recurse_dirs",
+                                                     false).toBool ());
+  m_recurse_dirs_check->setToolTip (tr ("Search recursively through directories for matching files"));
 
-  _include_dirs_check = new QCheckBox (tr ("Include directory names"));
-  _include_dirs_check->setChecked (settings->value ("findfiles/include_dirs",
-                                                    false).toBool ());
-  _include_dirs_check->setToolTip (
-    tr ("Include matching directories in search results"));
+  m_include_dirs_check = new QCheckBox (tr ("Include directory names"));
+  m_include_dirs_check->setChecked (settings->value ("findfiles/include_dirs",
+                                                     false).toBool ());
+  m_include_dirs_check->setToolTip (tr ("Include matching directories in search results"));
 
-  _name_case_check = new QCheckBox (tr ("Name case insensitive"));
-  _name_case_check->setChecked (settings->value ("findfiles/name_case",
-                                                 false).toBool ());
-  _name_case_check->setToolTip (tr ("Set matching name is case insensitive"));
+  m_name_case_check = new QCheckBox (tr ("Name case insensitive"));
+  m_name_case_check->setChecked (settings->value ("findfiles/name_case",
+                                                  false).toBool ());
+  m_name_case_check->setToolTip (tr ("Set matching name is case insensitive"));
 
-  _contains_text_check = new QCheckBox (tr ("Contains text:"));
-  _contains_text_check->setToolTip (tr ("Enter the file content search expression"));
-  _contains_text_check->setChecked (settings->value ("findfiles/check_text",
+  m_contains_text_check = new QCheckBox (tr ("Contains text:"));
+  m_contains_text_check->setToolTip (tr ("Enter the file content search expression"));
+  m_contains_text_check->setChecked (settings->value ("findfiles/check_text",
                                                       false).toBool ());
 
-  _contains_text_edit = new QLineEdit ();
-  _contains_text_edit->setToolTip (tr ("Text to match"));
-  _contains_text_edit->setText (settings->value ("findfiles/contains_text",
-                                                 "").toString ());
+  m_contains_text_edit = new QLineEdit ();
+  m_contains_text_edit->setToolTip (tr ("Text to match"));
+  m_contains_text_edit->setText (settings->value ("findfiles/contains_text",
+                                                  "").toString ());
 
-  _content_case_check = new QCheckBox (tr ("Text case insensitive"));
-  _content_case_check->setChecked (settings->value ("findfiles/content_case",
-                                                    false).toBool ());
-  _content_case_check->setToolTip (tr ("Set text content is case insensitive"));
+  m_content_case_check = new QCheckBox (tr ("Text case insensitive"));
+  m_content_case_check->setChecked (settings->value ("findfiles/content_case",
+                                                     false).toBool ());
+  m_content_case_check->setToolTip (tr ("Set text content is case insensitive"));
 
   find_files_model *model = new find_files_model (this);
 
-  _file_list = new QTableView;
-  _file_list->setWordWrap (false);
-  _file_list->setModel (model);
-  _file_list->setShowGrid (false);
-  _file_list->setSelectionBehavior (QAbstractItemView::SelectRows);
-  _file_list->setSelectionMode (QAbstractItemView::SingleSelection);
-  _file_list->setAlternatingRowColors (true);
-  _file_list->setToolTip (tr ("Search results"));
-  _file_list->setSortingEnabled (true);
-  _file_list->horizontalHeader ()->restoreState (
-    settings->value ("findfiles/column_state").toByteArray ());
-  _file_list->horizontalHeader ()->setSortIndicatorShown (true);
+  m_file_list = new QTableView;
+  m_file_list->setWordWrap (false);
+  m_file_list->setModel (model);
+  m_file_list->setShowGrid (false);
+  m_file_list->setSelectionBehavior (QAbstractItemView::SelectRows);
+  m_file_list->setSelectionMode (QAbstractItemView::SingleSelection);
+  m_file_list->setAlternatingRowColors (true);
+  m_file_list->setToolTip (tr ("Search results"));
+  m_file_list->setSortingEnabled (true);
+  m_file_list->horizontalHeader ()->restoreState (settings->value ("findfiles/column_state").toByteArray ());
+  m_file_list->horizontalHeader ()->setSortIndicatorShown (true);
 #if defined (HAVE_QT4)
-  _file_list->horizontalHeader ()->setClickable (true);
+  m_file_list->horizontalHeader ()->setClickable (true);
 #else
-  _file_list->horizontalHeader ()->setSectionsClickable (true);
+  m_file_list->horizontalHeader ()->setSectionsClickable (true);
 #endif
-  _file_list->horizontalHeader ()->setStretchLastSection (true);
-  _file_list->sortByColumn (
-                settings->value ("findfiles/sort_files_by_column",0).toInt (),
-                static_cast<Qt::SortOrder>
-                  (settings->value ("findfiles/sort_files_by_order",
-                                    Qt::AscendingOrder).toUInt ()));
+  m_file_list->horizontalHeader ()->setStretchLastSection (true);
+  m_file_list->sortByColumn (settings->value ("findfiles/sort_files_by_column",0).toInt (),
+                             static_cast<Qt::SortOrder>
+                             (settings->value ("findfiles/sort_files_by_order",
+                                               Qt::AscendingOrder).toUInt ()));
 
-  connect (_file_list, SIGNAL (doubleClicked (const QModelIndex&)),
-           this,       SLOT (item_double_clicked (const QModelIndex &)));
+  connect (m_file_list, SIGNAL (doubleClicked (const QModelIndex&)),
+           this, SLOT (item_double_clicked (const QModelIndex &)));
 
-  _status_bar = new QStatusBar;
-  _status_bar->showMessage (tr ("Idle."));
+  m_status_bar = new QStatusBar;
+  m_status_bar->showMessage (tr ("Idle."));
 
-  _find_button = new QPushButton (tr ("Find"));
-  _find_button->setToolTip (tr ("Start search for matching files"));
-  connect (_find_button, SIGNAL (clicked ()), this, SLOT (start_find ()));
+  m_find_button = new QPushButton (tr ("Find"));
+  m_find_button->setToolTip (tr ("Start search for matching files"));
+  connect (m_find_button, SIGNAL (clicked (void)),
+           this, SLOT (start_find (void)));
 
-  _stop_button = new QPushButton (tr ("Stop"));
-  _stop_button->setToolTip (tr ("Stop searching"));
-  _stop_button->setEnabled (false);
-  connect (_stop_button, SIGNAL (clicked ()), this, SLOT (stop_find ()));
+  m_stop_button = new QPushButton (tr ("Stop"));
+  m_stop_button->setToolTip (tr ("Stop searching"));
+  m_stop_button->setEnabled (false);
+  connect (m_stop_button, SIGNAL (clicked (void)),
+           this, SLOT (stop_find (void)));
 
   // layout everything
   QDialogButtonBox *button_box = new QDialogButtonBox (Qt::Vertical);
-  button_box->addButton (_find_button, QDialogButtonBox::ActionRole);
-  button_box->addButton (_stop_button, QDialogButtonBox::ActionRole);
+  button_box->addButton (m_find_button, QDialogButtonBox::ActionRole);
+  button_box->addButton (m_stop_button, QDialogButtonBox::ActionRole);
 
   // add dialog close button
-  _close_button = button_box->addButton (QDialogButtonBox::Close);
-  connect (button_box,    SIGNAL (rejected ()),
-           this,          SLOT (close ()));
+  m_close_button = button_box->addButton (QDialogButtonBox::Close);
+  connect (button_box, SIGNAL (rejected (void)), this, SLOT (close (void)));
 
   // name options
   QGroupBox *name_group = new QGroupBox (tr ("Filename/location"));
   QGridLayout *name_layout = new QGridLayout;
   name_group->setLayout (name_layout);
 
   name_layout->addWidget (file_name_label,1,1, 1,1);
-  name_layout->addWidget (_file_name_edit,1,2, 1,-1);
+  name_layout->addWidget (m_file_name_edit,1,2, 1,-1);
 
   name_layout->addWidget (start_dir_label,2,1);
-  name_layout->addWidget (_start_dir_edit,2,2,1,3);
-  name_layout->addWidget (_browse_button,2,5);
+  name_layout->addWidget (m_start_dir_edit,2,2,1,3);
+  name_layout->addWidget (m_browse_button,2,5);
   name_layout->setColumnStretch (2,1);
 
-  name_layout->addWidget (_recurse_dirs_check,3,1);
-  name_layout->addWidget (_include_dirs_check,3,2);
-  name_layout->addWidget (_name_case_check,3,3);
+  name_layout->addWidget (m_recurse_dirs_check,3,1);
+  name_layout->addWidget (m_include_dirs_check,3,2);
+  name_layout->addWidget (m_name_case_check,3,3);
 
   // content options
   QGroupBox *content_group = new QGroupBox (tr ("File contents"));
   QGridLayout *content_layout = new QGridLayout;
   content_group->setLayout (content_layout);
-  content_layout->addWidget (_contains_text_check,4,1);
-  content_layout->addWidget (_contains_text_edit,4,2,1,3);
+  content_layout->addWidget (m_contains_text_check,4,1);
+  content_layout->addWidget (m_contains_text_edit,4,2,1,3);
   content_layout->setColumnStretch (2,1);
-  content_layout->addWidget (_content_case_check,5,1);
+  content_layout->addWidget (m_content_case_check,5,1);
 
   QGridLayout *main_layout = new QGridLayout;
   main_layout->setSizeConstraint (QLayout::SetFixedSize);
   main_layout->addWidget (name_group, 0, 0);
   main_layout->addWidget (content_group, 1, 0);
   main_layout->addWidget (button_box, 0, 1,3,1);
-  main_layout->addWidget (_file_list,2,0);
+  main_layout->addWidget (m_file_list,2,0);
   main_layout->setRowStretch (2,1);
-  main_layout->addWidget (_status_bar,3,0,1,-1);
+  main_layout->addWidget (m_status_bar,3,0,1,-1);
 
   setLayout (main_layout);
 
   connect (this, SIGNAL (finished (int)), this, SLOT (handle_done (int)));
 }
 
+find_files_dialog::~find_files_dialog (void)
+{
+  delete m_dir_iterator;
+}
+
 void
 find_files_dialog::save_settings (void)
 {
   QSettings *settings = resource_manager::get_settings ();
 
   if (! settings)
     return;
 
-  int sort_column = _file_list->horizontalHeader ()->sortIndicatorSection ();
+  int sort_column = m_file_list->horizontalHeader ()->sortIndicatorSection ();
   Qt::SortOrder sort_order
-    = _file_list->horizontalHeader ()->sortIndicatorOrder ();
+    = m_file_list->horizontalHeader ()->sortIndicatorOrder ();
   settings->setValue ("findfiles/sort_files_by_column", sort_column);
   settings->setValue ("findfiles/sort_files_by_order", sort_order);
   settings->setValue ("findfiles/column_state",
-                      _file_list->horizontalHeader ()->saveState ());
+                      m_file_list->horizontalHeader ()->saveState ());
 
-  settings->setValue ("findfiles/file_name", _file_name_edit->text ());
+  settings->setValue ("findfiles/file_name", m_file_name_edit->text ());
 
-  settings->setValue ("findfiles/start_dir", _start_dir_edit->text ());
+  settings->setValue ("findfiles/start_dir", m_start_dir_edit->text ());
 
-  settings->setValue ("findfiles/recurse_dirs", _recurse_dirs_check->text ());
-  settings->setValue ("findfiles/include_dirs", _include_dirs_check->text ());
-  settings->setValue ("findfiles/name_case", _name_case_check->text ());
+  settings->setValue ("findfiles/recurse_dirs", m_recurse_dirs_check->text ());
+  settings->setValue ("findfiles/include_dirs", m_include_dirs_check->text ());
+  settings->setValue ("findfiles/name_case", m_name_case_check->text ());
 
-  settings->setValue ("findfiles/contains_text", _contains_text_edit->text ());
+  settings->setValue ("findfiles/contains_text", m_contains_text_edit->text ());
   settings->setValue ("findfiles/check_text",
-                      _contains_text_check->isChecked ());
+                      m_contains_text_check->isChecked ());
   settings->setValue ("findfiles/content_case",
-                      _content_case_check->isChecked ());
+                      m_content_case_check->isChecked ());
 
   settings->sync ();
 }
 
-find_files_dialog::~find_files_dialog ()
-{
-  if (_dir_iterator)
-    delete _dir_iterator;
-}
-
-void find_files_dialog::handle_done (int)
-{
-  // make sure we stopped processing
-  stop_find ();
-}
-
 void find_files_dialog::set_search_dir (const QString& dir)
 {
   stop_find ();
-  _start_dir_edit->setText (dir);
+  m_start_dir_edit->setText (dir);
 }
 
 void
-find_files_dialog::start_find ()
+find_files_dialog::start_find (void)
 {
   stop_find ();
 
-  find_files_model *m = static_cast<find_files_model *> (_file_list->model ());
+  find_files_model *m = static_cast<find_files_model *> (m_file_list->model ());
   m->clear ();
 
   QDirIterator::IteratorFlags flags = QDirIterator::NoIteratorFlags;
-  if (_recurse_dirs_check->isChecked ())
+  if (m_recurse_dirs_check->isChecked ())
     flags |= QDirIterator::Subdirectories;
 
   QDir::Filters filters = QDir::Dirs | QDir::NoDotAndDotDot | QDir::Files;
-  if (! _name_case_check->isChecked ())
+  if (! m_name_case_check->isChecked ())
     filters |= QDir::CaseSensitive;
 
   QStringList nameFilters;
-  nameFilters.append (_file_name_edit->text ());
+  nameFilters.append (m_file_name_edit->text ());
 
-  if (_dir_iterator) delete _dir_iterator;
+  if (m_dir_iterator)
+    delete m_dir_iterator;
 
-  _dir_iterator = new QDirIterator (_start_dir_edit->text (), nameFilters,
-                                    filters, flags);
+  m_dir_iterator = new QDirIterator (m_start_dir_edit->text (), nameFilters,
+                                     filters, flags);
 
   // enable/disable widgets
-  _find_button->setEnabled (false);
-  _stop_button->setEnabled (true);
-  _close_button->setEnabled (false);
-  _browse_button->setEnabled (false);
-  _start_dir_edit->setEnabled (false);
-  _file_name_edit->setEnabled (false);
-  _recurse_dirs_check->setEnabled (false);
-  _include_dirs_check->setEnabled (false);
-  _name_case_check->setEnabled (false);
-  _contains_text_check->setEnabled (false);
-  _content_case_check->setEnabled (false);
-  _contains_text_edit->setEnabled (false);
+  m_find_button->setEnabled (false);
+  m_stop_button->setEnabled (true);
+  m_close_button->setEnabled (false);
+  m_browse_button->setEnabled (false);
+  m_start_dir_edit->setEnabled (false);
+  m_file_name_edit->setEnabled (false);
+  m_recurse_dirs_check->setEnabled (false);
+  m_include_dirs_check->setEnabled (false);
+  m_name_case_check->setEnabled (false);
+  m_contains_text_check->setEnabled (false);
+  m_content_case_check->setEnabled (false);
+  m_contains_text_edit->setEnabled (false);
 
-  _status_bar->showMessage (tr ("Searching..."));
-  _timer->start (0);
+  m_status_bar->showMessage (tr ("Searching..."));
+  m_timer->start (0);
 }
 
 void
-find_files_dialog::stop_find ()
+find_files_dialog::stop_find (void)
 {
-  _timer->stop ();
+  m_timer->stop ();
 
-  _find_button->setEnabled (true);
-  _stop_button->setEnabled (false);
-  _close_button->setEnabled (true);
-  _browse_button->setEnabled (true);
-  _start_dir_edit->setEnabled (true);
-  _file_name_edit->setEnabled (true);
-  _recurse_dirs_check->setEnabled (true);
-  _include_dirs_check->setEnabled (true);
-  _name_case_check->setEnabled (true);
-  _contains_text_check->setEnabled (true);
-  _content_case_check->setEnabled (true);
-  _contains_text_edit->setEnabled (true);
+  m_find_button->setEnabled (true);
+  m_stop_button->setEnabled (false);
+  m_close_button->setEnabled (true);
+  m_browse_button->setEnabled (true);
+  m_start_dir_edit->setEnabled (true);
+  m_file_name_edit->setEnabled (true);
+  m_recurse_dirs_check->setEnabled (true);
+  m_include_dirs_check->setEnabled (true);
+  m_name_case_check->setEnabled (true);
+  m_contains_text_check->setEnabled (true);
+  m_content_case_check->setEnabled (true);
+  m_contains_text_edit->setEnabled (true);
 
-  find_files_model *m = static_cast<find_files_model *> (_file_list->model ());
+  find_files_model *m = static_cast<find_files_model *> (m_file_list->model ());
   QString res_str = QString (tr ("%1 match (es)")).arg (m->rowCount ());
 
-  _status_bar->showMessage (res_str);
+  m_status_bar->showMessage (res_str);
 }
 
 void
-find_files_dialog::browse_folders ()
+find_files_dialog::browse_folders (void)
 {
   QString dir =
     QFileDialog::getExistingDirectory (this, tr ("Set search directory"),
-                                       _start_dir_edit->text ());
+                                       m_start_dir_edit->text ());
 
   if (! dir.isEmpty ())
-    {
-      _start_dir_edit->setText (dir);
-    }
+    m_start_dir_edit->setText (dir);
 }
 
 void
 find_files_dialog::item_double_clicked (const QModelIndex& idx)
 {
-  find_files_model *m = static_cast<find_files_model *> (_file_list->model ());
+  find_files_model *m = static_cast<find_files_model *> (m_file_list->model ());
 
   QFileInfo info = m->fileInfo (idx);
 
   if (idx.column () == 1)
     {
       // clicked in directory part
       emit dir_selected (info.absolutePath ());
     }
@@ -350,59 +341,67 @@ find_files_dialog::item_double_clicked (
       if (info.isDir ())
         emit dir_selected (info.absoluteFilePath ());
       else
         emit file_selected (info.absoluteFilePath ());
     }
 }
 
 void
-find_files_dialog::look_for_files ()
+find_files_dialog::look_for_files (void)
 {
-  if (_dir_iterator && _dir_iterator->hasNext ())
+  if (m_dir_iterator && m_dir_iterator->hasNext ())
     {
-      QFileInfo info (_dir_iterator->next ());
+      QFileInfo info (m_dir_iterator->next ());
 
       find_files_model *m
-        = static_cast<find_files_model *> (_file_list->model ());
+        = static_cast<find_files_model *> (m_file_list->model ());
 
       if (is_match (info))
         m->addFile (info);
     }
   else
     {
       stop_find ();
     }
 }
 
-bool find_files_dialog::is_match (const QFileInfo& info)
+void
+find_files_dialog::handle_done (int)
+{
+  // make sure we stopped processing
+  stop_find ();
+}
+
+bool
+find_files_dialog::is_match (const QFileInfo& info)
 {
   bool match = true;
   if (info.isDir ())
     {
-      if (! _include_dirs_check->isChecked ()) match = false;
-      if (_contains_text_check->isChecked ()) match = false;
+      if (! m_include_dirs_check->isChecked ()) match = false;
+      if (m_contains_text_check->isChecked ()) match = false;
     }
   else
     {
       // a file
-      if (_contains_text_check->isChecked ())
+      if (m_contains_text_check->isChecked ())
         {
           match = false;
 
           QFile file (info.absoluteFilePath ());
           if (file.open (QIODevice::ReadOnly))
             {
               QTextStream stream (&file);
 
               QString line;
-              QString match_str = _contains_text_edit->text ();
+              QString match_str = m_contains_text_edit->text ();
 
-              Qt::CaseSensitivity cs = _content_case_check->isChecked () ?
-                                       Qt::CaseInsensitive : Qt::CaseSensitive;
+              Qt::CaseSensitivity cs = m_content_case_check->isChecked () ?
+                Qt::CaseInsensitive : Qt::CaseSensitive;
 
               do
                 {
                   line = stream.readLine ();
                   match = line.contains (match_str, cs);
                 }
               while (! line.isNull () && match == false);
             }
diff --git a/libgui/src/find-files-dialog.h b/libgui/src/find-files-dialog.h
--- a/libgui/src/find-files-dialog.h
+++ b/libgui/src/find-files-dialog.h
@@ -32,48 +32,58 @@ class QTableView;
 class QTimer;
 class QDirIterator;
 class QCheckBox;
 class QStatusBar;
 
 class find_files_dialog : public QDialog
 {
   Q_OBJECT
+
 public:
+
   find_files_dialog (QWidget *parent = nullptr);
-  virtual ~find_files_dialog ();
+
+  virtual ~find_files_dialog (void);
+
   void save_settings (void);
 
 signals:
+
   void file_selected (const QString& fileName);
   void dir_selected (const QString& fileName);
 
 public slots:
+
   void set_search_dir (const QString& dir);
 
 private slots:
-  void start_find ();
-  void stop_find ();
-  void browse_folders ();
-  void look_for_files ();
+
+  void start_find (void);
+  void stop_find (void);
+  void browse_folders (void);
+  void look_for_files (void);
   void item_double_clicked (const QModelIndex&);
   void handle_done (int);
+
 private:
+
   bool is_match (const QFileInfo& info);
-  QLineEdit   *_start_dir_edit;
-  QLineEdit   *_file_name_edit;
-  QPushButton *_stop_button;
-  QPushButton *_find_button;
-  QPushButton *_close_button;
-  QPushButton *_browse_button;
-  QTableView  *_file_list;
-  QTimer      *_timer;
-  QCheckBox   *_recurse_dirs_check;
-  QCheckBox   *_include_dirs_check;
-  QCheckBox   *_name_case_check;
-  QCheckBox   *_contains_text_check;
-  QCheckBox   *_content_case_check;
-  QLineEdit   *_contains_text_edit;
-  QDirIterator *_dir_iterator;
-  QStatusBar  *_status_bar;
+
+  QLineEdit *m_start_dir_edit;
+  QLineEdit *m_file_name_edit;
+  QPushButton *m_stop_button;
+  QPushButton *m_find_button;
+  QPushButton *m_close_button;
+  QPushButton *m_browse_button;
+  QTableView *m_file_list;
+  QTimer *m_timer;
+  QCheckBox *m_recurse_dirs_check;
+  QCheckBox *m_include_dirs_check;
+  QCheckBox *m_name_case_check;
+  QCheckBox *m_contains_text_check;
+  QCheckBox *m_content_case_check;
+  QLineEdit *m_contains_text_edit;
+  QDirIterator *m_dir_iterator;
+  QStatusBar *m_status_bar;
 };
 
 #endif
diff --git a/libgui/src/find-files-model.cc b/libgui/src/find-files-model.cc
--- a/libgui/src/find-files-model.cc
+++ b/libgui/src/find-files-model.cc
@@ -27,193 +27,189 @@ along with Octave; see the file COPYING.
 #include <QFileIconProvider>
 #include <QtAlgorithms>
 
 #include "find-files-model.h"
 
 class find_file_less_than
 {
 public:
-  find_file_less_than (int ord)
-  {
-    _sortorder = ord;
-  }
+
+  find_file_less_than (int ord) { m_sortorder = ord; }
+
   QVariant getValue (const QFileInfo& f) const
   {
     QVariant val;
-    int col = (_sortorder > 0) ? _sortorder : -_sortorder;
+
+    int col = (m_sortorder > 0) ? m_sortorder : -m_sortorder;
 
     switch (col-1)
       {
       case 0:
         val = QVariant (f.fileName ());
         break;
 
       case 1:
         val = QVariant (f.absolutePath ());
         break;
 
       default:
         break;
       }
+
     return val;
   }
+
   bool lessThan (const QVariant& left, const QVariant& right) const
   {
     return
       left.toString ().compare (right.toString (), Qt::CaseInsensitive) < 0;
   }
+
   bool operator () (const QFileInfo& left, const QFileInfo& right) const
   {
     QVariant leftval = getValue (left);
     QVariant rightval = getValue (right);
 
-    if (_sortorder > 0)
+    if (m_sortorder > 0)
       return lessThan (leftval, rightval);
     else
       return ! lessThan (leftval, rightval);
   }
 
 private:
-  int _sortorder;
 
+  int m_sortorder;
 };
 
 find_files_model::find_files_model (QObject *p)
   : QAbstractListModel (p)
 {
-  _columnNames.append (tr ("Filename"));
-  _columnNames.append (tr ("Directory"));
-  _sortorder = 0;
+  m_columnNames.append (tr ("Filename"));
+  m_columnNames.append (tr ("Directory"));
+  m_sortorder = 0;
 }
 
-find_files_model::~find_files_model ()
-{ }
-
 void
-find_files_model::clear ()
+find_files_model::clear (void)
 {
   beginResetModel ();
 
-  _files.clear ();
+  m_files.clear ();
 
   endResetModel ();
 }
 
 void
 find_files_model::addFile (const QFileInfo& info)
 {
-  beginInsertRows (QModelIndex (), _files.size (), _files.size ());
+  beginInsertRows (QModelIndex (), m_files.size (), m_files.size ());
 
   QList<QFileInfo>::Iterator it;
-  find_file_less_than less_than (_sortorder);
+  find_file_less_than less_than (m_sortorder);
 
-  for (it=_files.begin (); it!=_files.end (); it++)
+  for (it = m_files.begin (); it != m_files.end (); it++)
     {
-      if (less_than (info, *it)) break;
+      if (less_than (info, *it))
+        break;
     }
 
-  _files.insert (it, info);
+  m_files.insert (it, info);
 
   endInsertRows ();
 }
 
 int
 find_files_model::rowCount (const QModelIndex &) const
 {
-  return _files.size ();
+  return m_files.size ();
 }
 
 int
 find_files_model::columnCount (const QModelIndex &) const
 {
-  return _columnNames.size ();
+  return m_columnNames.size ();
 }
 
 QVariant
 find_files_model::data (const QModelIndex& idx, int role) const
 {
   QVariant retval;
 
   if (idx.isValid ())
     {
       if (role == Qt::DisplayRole)
         {
           switch (idx.column ())
             {
             case 0:
-              retval = QVariant (_files[idx.row ()].fileName ());
+              retval = QVariant (m_files[idx.row ()].fileName ());
               break;
 
             case 1:
-              retval = QVariant (_files[idx.row ()].absolutePath ());
+              retval = QVariant (m_files[idx.row ()].absolutePath ());
               break;
 
             default:
               break;
             }
         }
       else if (role == Qt:: DecorationRole)
         {
           switch (idx.column ())
             {
             case 0:
               retval = fileIcon (idx);
+
             default:
               break;
             }
         }
     }
 
   return retval;
 }
 
 QVariant
 find_files_model::headerData (int section, Qt::Orientation orientation,
                               int role) const
 {
-  if (orientation == Qt::Horizontal && role == Qt::DisplayRole)
-    return _columnNames[section];
-  else
-    return QVariant ();
+  return ((orientation == Qt::Horizontal && role == Qt::DisplayRole)
+          ? m_columnNames[section] : QVariant ());
 }
 
 void
 find_files_model::sort (int column, Qt::SortOrder order)
 {
   if (column >= 0)
     {
       if (order == Qt::DescendingOrder)
-        _sortorder = -(column+1);
+        m_sortorder = -(column+1);
       else
-        _sortorder = column+1;
+        m_sortorder = column+1;
     }
   else
-    _sortorder = 0;
+    m_sortorder = 0;
 
-  if (_sortorder != 0)
+  if (m_sortorder != 0)
     {
       beginResetModel ();
-      qSort (_files.begin (), _files.end (), find_file_less_than (_sortorder));
+
+      qSort (m_files.begin (), m_files.end (),
+             find_file_less_than (m_sortorder));
+
       endResetModel ();
     }
 }
 
 QFileInfo
 find_files_model::fileInfo (const QModelIndex & p) const
 {
-  if (p.isValid ())
-    {
-      return _files[p.row ()];
-    }
-  return QFileInfo ();
+  return p.isValid () ? m_files[p.row ()] : QFileInfo ();
 }
 
 QIcon
 find_files_model::fileIcon (const QModelIndex& p) const
 {
   QFileIconProvider icon_provider;
-  if (p.isValid ())
-    {
-      return icon_provider.icon (_files[p.row ()]);
-    }
-  return QIcon ();
+
+  return p.isValid () ? icon_provider.icon (m_files[p.row ()]) : QIcon ();
 }
diff --git a/libgui/src/find-files-model.h b/libgui/src/find-files-model.h
--- a/libgui/src/find-files-model.h
+++ b/libgui/src/find-files-model.h
@@ -29,35 +29,40 @@ along with Octave; see the file COPYING.
 #include <QIcon>
 
 
 class find_files_model : public QAbstractListModel
 {
   Q_OBJECT
 
 public:
+
   find_files_model (QObject *p = nullptr);
-  ~find_files_model ();
 
-  void clear ();
+  ~find_files_model (void) = default;
+
+  void clear (void);
 
   void addFile (const QFileInfo& info);
 
   int rowCount (const QModelIndex& p = QModelIndex ()) const;
 
   int columnCount (const QModelIndex& p = QModelIndex ()) const;
 
   QVariant data (const QModelIndex& idx, int role) const;
 
   QVariant headerData (int section, Qt::Orientation orientation,
                        int role = Qt::DisplayRole) const;
 
   void sort (int column, Qt::SortOrder order = Qt::AscendingOrder);
 
   QFileInfo fileInfo (const QModelIndex& p) const;
-  QIcon     fileIcon (const QModelIndex& p) const;
+
+  QIcon fileIcon (const QModelIndex& p) const;
+
 private:
-  QList<QFileInfo> _files;
-  QStringList _columnNames;
-  int _sortorder;
+
+  QList<QFileInfo> m_files;
+  QStringList m_columnNames;
+  int m_sortorder;
 };
 
 #endif
diff --git a/libgui/src/history-dock-widget.cc b/libgui/src/history-dock-widget.cc
--- a/libgui/src/history-dock-widget.cc
+++ b/libgui/src/history-dock-widget.cc
@@ -54,178 +54,130 @@ history_dock_widget::history_dock_widget
 
   connect (this, SIGNAL (command_double_clicked (const QString&)),
            p, SLOT (execute_command_in_terminal (const QString&)));
 
   construct ();
 }
 
 void
-history_dock_widget::construct ()
+history_dock_widget::set_history (const QStringList& hist)
 {
-  _history_model = new QStringListModel ();
-  _sort_filter_proxy_model.setSourceModel (_history_model);
-  _history_list_view = new QListView (this);
-  _history_list_view->setModel (&_sort_filter_proxy_model);
-  _history_list_view->setAlternatingRowColors (true);
-  _history_list_view->setEditTriggers (QAbstractItemView::NoEditTriggers);
-  _history_list_view->setStatusTip (
-    tr ("Double-click a command to transfer it to the terminal."));
-  _history_list_view->setSelectionMode (QAbstractItemView::ExtendedSelection);
-  _history_list_view->setContextMenuPolicy (Qt::CustomContextMenu);
-  connect (_history_list_view,
-           SIGNAL (customContextMenuRequested (const QPoint &)), this,
-           SLOT (ctxMenu (const QPoint &)));
+  m_history_model->setStringList (hist);
+  m_history_list_view->scrollToBottom ();
+}
 
-  _filter = new QComboBox (this);
-  _filter->setToolTip (tr ("Enter text to filter the command history"));
-  _filter->setEditable (true);
-  _filter->setMaxCount (MaxFilterHistory);
-  _filter->setInsertPolicy (QComboBox::NoInsert);
-  _filter->setSizeAdjustPolicy (
-            QComboBox::AdjustToMinimumContentsLengthWithIcon);
-  QSizePolicy sizePol (QSizePolicy::Expanding, QSizePolicy::Preferred);
-  _filter->setSizePolicy (sizePol);
-  _filter->completer ()->setCaseSensitivity (Qt::CaseSensitive);
+void
+history_dock_widget::append_history (const QString& hist_entry)
+{
+  QStringList lst = m_history_model->stringList ();
+  lst.append (hist_entry);
 
-  QLabel *filter_label = new QLabel (tr ("Filter"));
-
-  _filter_checkbox = new QCheckBox ();
-
-  setWindowIcon (QIcon (":/actions/icons/logo.png"));
-  set_title (tr ("Command History"));
-  setWidget (new QWidget ());
+  QScrollBar *scroll_bar = m_history_list_view->verticalScrollBar ();
 
-  _filter_widget = new QWidget (this);
-  QHBoxLayout *filter_layout = new QHBoxLayout ();
-  filter_layout->addWidget (filter_label);
-  filter_layout->addWidget (_filter_checkbox);
-  filter_layout->addWidget (_filter);
-  filter_layout->setMargin(0);
-  _filter_widget->setLayout (filter_layout);
-
-  QVBoxLayout *hist_layout = new QVBoxLayout ();
-  hist_layout->addWidget (_filter_widget);
-  hist_layout->addWidget (_history_list_view);
+  bool at_bottom = scroll_bar->maximum () - scroll_bar->value () < 1;
 
-  hist_layout->setMargin (2);
-  widget ()->setLayout (hist_layout);
-
-  // Init state of the filter
-  QSettings *settings = resource_manager::get_settings ();
-
-  _filter_shown
-    = settings->value ("history_dock_widget/filter_shown",true).toBool ();
-  _filter_widget->setVisible (_filter_shown);
-
-  _filter->addItems (settings->value ("history_dock_widget/mru_list").toStringList ());
+  m_history_model->setStringList (lst);
 
-  bool filter_state
-    = settings->value ("history_dock_widget/filter_active", false).toBool ();
-  _filter_checkbox->setChecked (filter_state);
-  filter_activate (filter_state);
+  // Scroll if slider position at bottom.
+  if (at_bottom)
+    m_history_list_view->scrollToBottom ();
+}
 
-  // Connect signals and slots
-  connect (_filter, SIGNAL (editTextChanged (const QString&)),
-           &_sort_filter_proxy_model,
-           SLOT (setFilterWildcard (const QString&)));
-  connect (_filter_checkbox, SIGNAL (toggled (bool)),
-           this, SLOT (filter_activate (bool)));
-  connect (_filter->lineEdit (), SIGNAL (editingFinished ()),
-           this, SLOT (update_filter_history ()));
-
-  connect (_history_list_view, SIGNAL (doubleClicked (QModelIndex)),
-           this, SLOT (handle_double_click (QModelIndex)));
-
-  // shrink max. displayed entry size to desktop width
-  QSize screen = QDesktopWidget ().screenGeometry ().size ();
-  int w = screen.width ();
-  QFontMetrics fm = _history_list_view->fontMetrics ();
-  int h = fm.height ();
-  _history_list_view->setGridSize (QSize (w,h));
-  _history_list_view->setTextElideMode (Qt::ElideRight);
+void
+history_dock_widget::clear_history (void)
+{
+  m_history_model->setStringList (QStringList ());
 }
 
 void
 history_dock_widget::save_settings (void)
 {
   QSettings *settings = resource_manager::get_settings ();
 
   if (! settings)
     return;
 
   settings->setValue ("history_dock_widget/filter_active",
-                      _filter_checkbox->isChecked ());
-  settings->setValue ("history_dock_widget/filter_shown", _filter_shown);
+                      m_filter_checkbox->isChecked ());
+  settings->setValue ("history_dock_widget/filter_shown", m_filter_shown);
 
   QStringList mru;
-  for (int i = 0; i < _filter->count (); i++)
-    mru.append (_filter->itemText (i));
+  for (int i = 0; i < m_filter->count (); i++)
+    mru.append (m_filter->itemText (i));
   settings->setValue ("history_dock_widget/mru_list", mru);
 
   settings->sync ();
 
   octave_dock_widget::save_settings ();
 }
 
 void
-history_dock_widget::filter_activate (bool state)
+history_dock_widget::update_filter_history (void)
 {
-  _filter->setEnabled (state);
-  _sort_filter_proxy_model.setDynamicSortFilter (state);
+  QString text = m_filter->currentText ();   // get current text
+  int index = m_filter->findText (text);     // and its actual index
 
-  if (state)
-    _sort_filter_proxy_model.setFilterWildcard (_filter->currentText ());
-  else
-    _sort_filter_proxy_model.setFilterWildcard (QString ());
+  if (index > -1)
+    m_filter->removeItem (index);    // remove if already existing
+
+  m_filter->insertItem (0, text);    // (re)insert at beginning
+  m_filter->setCurrentIndex (0);
 }
 
 void
-history_dock_widget::update_filter_history ()
+history_dock_widget::filter_activate (bool state)
 {
-  QString text = _filter->currentText ();   // get current text
-  int index = _filter->findText (text);     // and its actual index
+  m_filter->setEnabled (state);
+  m_sort_filter_proxy_model.setDynamicSortFilter (state);
 
-  if (index > -1)
-    _filter->removeItem (index);    // remove if already existing
-
-  _filter->insertItem (0, text);    // (re)insert at beginning
-  _filter->setCurrentIndex (0);
+  if (state)
+    m_sort_filter_proxy_model.setFilterWildcard (m_filter->currentText ());
+  else
+    m_sort_filter_proxy_model.setFilterWildcard (QString ());
 }
 
-void history_dock_widget::ctxMenu (const QPoint& xpos)
+void
+history_dock_widget::ctxMenu (const QPoint& xpos)
 {
   QMenu menu (this);
 
-  QModelIndex index = _history_list_view->indexAt (xpos);
+  QModelIndex index = m_history_list_view->indexAt (xpos);
 
   if (index.isValid () && index.column () == 0)
     {
       menu.addAction (resource_manager::icon ("edit-copy"),
                       tr ("Copy"), this, SLOT (handle_contextmenu_copy (bool)));
       menu.addAction (tr ("Evaluate"), this,
                       SLOT (handle_contextmenu_evaluate (bool)));
       menu.addAction (resource_manager::icon ("document-new"),
                       tr ("Create script"), this,
                       SLOT (handle_contextmenu_create_script (bool)));
     }
-  if (_filter_shown)
+  if (m_filter_shown)
     menu.addAction (tr ("Hide filter"), this,
                     SLOT (handle_contextmenu_filter ()));
   else
     menu.addAction (tr ("Show filter"), this,
                     SLOT (handle_contextmenu_filter ()));
 
-  menu.exec (_history_list_view->mapToGlobal (xpos));
+  menu.exec (m_history_list_view->mapToGlobal (xpos));
 }
 
-void history_dock_widget::handle_contextmenu_copy (bool)
+void
+history_dock_widget::handle_double_click (QModelIndex modelIndex)
+{
+  emit command_double_clicked (modelIndex.data ().toString ());
+}
+
+void
+history_dock_widget::handle_contextmenu_copy (bool)
 {
   QString text;
-  QItemSelectionModel *selectionModel = _history_list_view->selectionModel ();
+  QItemSelectionModel *selectionModel = m_history_list_view->selectionModel ();
   QModelIndexList rows = selectionModel->selectedRows ();
   QModelIndexList::iterator it;
   bool prev_valid_row = false;
   for (it = rows.begin (); it != rows.end (); it++)
     {
       if ((*it).isValid ())
         {
           if (prev_valid_row)
@@ -234,31 +186,31 @@ void history_dock_widget::handle_context
           prev_valid_row = true;
         }
     }
   QApplication::clipboard ()->setText (text);
 }
 
 void history_dock_widget::handle_contextmenu_evaluate (bool)
 {
-  QItemSelectionModel *selectionModel = _history_list_view->selectionModel ();
+  QItemSelectionModel *selectionModel = m_history_list_view->selectionModel ();
   QModelIndexList rows = selectionModel->selectedRows ();
   QModelIndexList::iterator it;
   for (it = rows.begin () ; it != rows.end (); it++)
     {
       if ((*it).isValid ())
         emit command_double_clicked ((*it).data ().toString ());
     }
 }
 
 void
 history_dock_widget::handle_contextmenu_create_script (bool)
 {
   QString text;
-  QItemSelectionModel *selectionModel = _history_list_view->selectionModel ();
+  QItemSelectionModel *selectionModel = m_history_list_view->selectionModel ();
   QModelIndexList rows = selectionModel->selectedRows ();
 
   bool prev_valid_row = false;
   for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     {
       if ((*it).isValid ())
         {
           if (prev_valid_row)
@@ -270,96 +222,144 @@ history_dock_widget::handle_contextmenu_
 
   if (text.length () > 0)
     emit command_create_script (text);
 }
 
 void
 history_dock_widget::handle_contextmenu_filter (void)
 {
-  _filter_shown = not _filter_shown;
-  _filter_widget->setVisible (_filter_shown);
-}
-
-void
-history_dock_widget::handle_double_click (QModelIndex modelIndex)
-{
-  emit command_double_clicked (modelIndex.data ().toString ());
-}
-
-void
-history_dock_widget::set_history (const QStringList& hist)
-{
-  _history_model->setStringList (hist);
-  _history_list_view->scrollToBottom ();
+  m_filter_shown = ! m_filter_shown;
+  m_filter_widget->setVisible (m_filter_shown);
 }
 
 void
-history_dock_widget::append_history (const QString& hist_entry)
+history_dock_widget::copyClipboard (void)
 {
-  QStringList lst = _history_model->stringList ();
-  lst.append (hist_entry);
-
-  QScrollBar *scroll_bar = _history_list_view->verticalScrollBar ();
-
-  bool at_bottom = scroll_bar->maximum () - scroll_bar->value () < 1;
-
-  _history_model->setStringList (lst);
-
-  // Scroll if slider position at bottom.
-  if (at_bottom)
-    _history_list_view->scrollToBottom ();
-}
-
-void
-history_dock_widget::clear_history (void)
-{
-  _history_model->setStringList (QStringList ());
-}
-
-void
-history_dock_widget::copyClipboard ()
-{
-  if (_history_list_view->hasFocus ())
+  if (m_history_list_view->hasFocus ())
     handle_contextmenu_copy (true);
-  if (_filter->lineEdit ()->hasFocus ()
-      && _filter->lineEdit ()->hasSelectedText ())
+  if (m_filter->lineEdit ()->hasFocus ()
+      && m_filter->lineEdit ()->hasSelectedText ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
-      clipboard->setText (_filter->lineEdit ()->selectedText ());
+      clipboard->setText (m_filter->lineEdit ()->selectedText ());
     }
 }
 
 void
-history_dock_widget::pasteClipboard ()
+history_dock_widget::pasteClipboard (void)
 {
-  if (_filter->lineEdit ()->hasFocus ())
+  if (m_filter->lineEdit ()->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
       QString str = clipboard->text ();
       if (str.length () > 0)
-        _filter->lineEdit ()->insert (str);
+        m_filter->lineEdit ()->insert (str);
     }
 }
 
 void
-history_dock_widget::selectAll ()
+history_dock_widget::selectAll (void)
 {
-  if (_filter->lineEdit ()->hasFocus ())
-    {
-      _filter->lineEdit ()->selectAll ();
-    }
-  if (_history_list_view->hasFocus ())
-    {
-      _history_list_view->selectAll ();
-    }
+  if (m_filter->lineEdit ()->hasFocus ())
+    m_filter->lineEdit ()->selectAll ();
+
+  if (m_history_list_view->hasFocus ())
+    m_history_list_view->selectAll ();
 }
 
-void history_dock_widget::handle_visibility (bool visible)
+void
+history_dock_widget::handle_visibility (bool visible)
 {
   octave_dock_widget::handle_visibility (visible);
 
   if (visible)
     {
-      int filter_state = _filter_checkbox->isChecked ();
+      int filter_state = m_filter_checkbox->isChecked ();
       filter_activate (filter_state);
     }
 }
+
+void
+history_dock_widget::construct (void)
+{
+  m_history_model = new QStringListModel ();
+  m_sort_filter_proxy_model.setSourceModel (m_history_model);
+  m_history_list_view = new QListView (this);
+  m_history_list_view->setModel (&m_sort_filter_proxy_model);
+  m_history_list_view->setAlternatingRowColors (true);
+  m_history_list_view->setEditTriggers (QAbstractItemView::NoEditTriggers);
+  m_history_list_view->setStatusTip (
+    tr ("Double-click a command to transfer it to the terminal."));
+  m_history_list_view->setSelectionMode (QAbstractItemView::ExtendedSelection);
+  m_history_list_view->setContextMenuPolicy (Qt::CustomContextMenu);
+  connect (m_history_list_view,
+           SIGNAL (customContextMenuRequested (const QPoint &)), this,
+           SLOT (ctxMenu (const QPoint &)));
+
+  m_filter = new QComboBox (this);
+  m_filter->setToolTip (tr ("Enter text to filter the command history"));
+  m_filter->setEditable (true);
+  m_filter->setMaxCount (MaxFilterHistory);
+  m_filter->setInsertPolicy (QComboBox::NoInsert);
+  m_filter->setSizeAdjustPolicy (
+            QComboBox::AdjustToMinimumContentsLengthWithIcon);
+  QSizePolicy sizePol (QSizePolicy::Expanding, QSizePolicy::Preferred);
+  m_filter->setSizePolicy (sizePol);
+  m_filter->completer ()->setCaseSensitivity (Qt::CaseSensitive);
+
+  QLabel *filter_label = new QLabel (tr ("Filter"));
+
+  m_filter_checkbox = new QCheckBox ();
+
+  setWindowIcon (QIcon (":/actions/icons/logo.png"));
+  set_title (tr ("Command History"));
+  setWidget (new QWidget ());
+
+  m_filter_widget = new QWidget (this);
+  QHBoxLayout *filter_layout = new QHBoxLayout ();
+  filter_layout->addWidget (filter_label);
+  filter_layout->addWidget (m_filter_checkbox);
+  filter_layout->addWidget (m_filter);
+  filter_layout->setMargin(0);
+  m_filter_widget->setLayout (filter_layout);
+
+  QVBoxLayout *hist_layout = new QVBoxLayout ();
+  hist_layout->addWidget (m_filter_widget);
+  hist_layout->addWidget (m_history_list_view);
+
+  hist_layout->setMargin (2);
+  widget ()->setLayout (hist_layout);
+
+  // Init state of the filter
+  QSettings *settings = resource_manager::get_settings ();
+
+  m_filter_shown
+    = settings->value ("history_dock_widget/filter_shown",true).toBool ();
+  m_filter_widget->setVisible (m_filter_shown);
+
+  m_filter->addItems (settings->value ("history_dock_widget/mru_list").toStringList ());
+
+  bool filter_state
+    = settings->value ("history_dock_widget/filter_active", false).toBool ();
+  m_filter_checkbox->setChecked (filter_state);
+  filter_activate (filter_state);
+
+  // Connect signals and slots
+  connect (m_filter, SIGNAL (editTextChanged (const QString&)),
+           &m_sort_filter_proxy_model,
+           SLOT (setFilterWildcard (const QString&)));
+  connect (m_filter_checkbox, SIGNAL (toggled (bool)),
+           this, SLOT (filter_activate (bool)));
+  connect (m_filter->lineEdit (), SIGNAL (editingFinished (void)),
+           this, SLOT (updatem_filter_history (void)));
+
+  connect (m_history_list_view, SIGNAL (doubleClicked (QModelIndex)),
+           this, SLOT (handle_double_click (QModelIndex)));
+
+  // shrink max. displayed entry size to desktop width
+  QSize screen = QDesktopWidget ().screenGeometry ().size ();
+  int w = screen.width ();
+  QFontMetrics fm = m_history_list_view->fontMetrics ();
+  int h = fm.height ();
+  m_history_list_view->setGridSize (QSize (w,h));
+  m_history_list_view->setTextElideMode (Qt::ElideRight);
+}
diff --git a/libgui/src/history-dock-widget.h b/libgui/src/history-dock-widget.h
--- a/libgui/src/history-dock-widget.h
+++ b/libgui/src/history-dock-widget.h
@@ -34,16 +34,17 @@ along with Octave; see the file COPYING.
 
 class history_dock_widget : public octave_dock_widget
 {
   Q_OBJECT
 
 public:
 
   history_dock_widget (QWidget *parent = nullptr);
+
   ~history_dock_widget (void) = default;
 
 public slots:
 
   void set_history (const QStringList& hist);
   void append_history (const QString& hist_entry);
   void clear_history (void);
   void save_settings (void);
@@ -56,41 +57,43 @@ signals:
   void command_double_clicked (const QString& command);
 
   /** Emitted whenever the user selects command and chooses Create
       script from popupmenu. */
   void command_create_script (const QString& commands);
 
 private slots:
 
-  void update_filter_history ();
+  void update_filter_history (void);
   void filter_activate (bool enable);
 
+  void ctxMenu (const QPoint& pos);
   void handle_double_click (QModelIndex modelIndex);
   void handle_contextmenu_copy (bool flag);
   void handle_contextmenu_evaluate (bool flag);
   void handle_contextmenu_create_script (bool flag);
   void handle_contextmenu_filter (void);
-  void ctxMenu (const QPoint& pos);
 
-  void copyClipboard ();
-  void pasteClipboard ();
-  void selectAll ();
+  void copyClipboard (void);
+  void pasteClipboard (void);
+  void selectAll (void);
 
   virtual void handle_visibility (bool visible);
 
 private:
 
-  void construct ();
-  QListView *_history_list_view;
-  QSortFilterProxyModel _sort_filter_proxy_model;
+  void construct (void);
+
+  QListView *m_history_list_view;
+  QSortFilterProxyModel m_sort_filter_proxy_model;
 
   /** Stores the current history_model. */
-  QStringListModel *_history_model;
+  QStringListModel *m_history_model;
 
-  QCheckBox *_filter_checkbox;
-  QComboBox *_filter;
-  QWidget *_filter_widget;
-  bool _filter_shown;
+  QCheckBox *m_filter_checkbox;
+  QComboBox *m_filter;
+  QWidget *m_filter_widget;
+  bool m_filter_shown;
+
   enum { MaxFilterHistory = 10 };
 };
 
 #endif
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -15,16 +15,20 @@ MERCHANTABILITY or FITNESS FOR A PARTICU
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
+// Programming Note: this file has many lines longer than 80 characters
+// due to long function, variable, and property names.  Please don't
+// break those lines as it tends to make this code even harder to read.
+
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "resource-manager.h"
 #include "shortcut-manager.h"
 #include "variable-editor.h"
 #include "workspace-model.h"
@@ -73,139 +77,136 @@ get_valid_lexer_styles (QsciLexer *lexer
       if ((lexer->description (actual_style)) != "")  // valid style
         styles[max_style++] = actual_style;
       actual_style++;
     }
   return max_style;
 }
 
 static void
-read_lexer_settings (Ui::settings_dialog *ui, QsciLexer *lexer,
-                     QSettings *settings)
+read_lexer_settings (Ui::settings_dialog *ui, QsciLexer *lexer, QSettings *settings)
 {
   lexer->readSettings (*settings);
   int styles[MaxLexerStyles];  // array for saving valid styles
                                // (enum is not continuous)
   int max_style = get_valid_lexer_styles (lexer, styles);
   QGridLayout *style_grid = new QGridLayout ();
   QVector<QLabel*> description (max_style);
   QVector<QFontComboBox*> select_font (max_style);
   QVector<QSpinBox*> font_size (max_style);
   QVector<QCheckBox*> attrib_font (3 * max_style);
   QVector<color_picker*> color (max_style);
   QVector<color_picker*> bg_color (max_style);
   int default_size = 10;
   QFont default_font = QFont ();
   int label_width;
   QColor default_color = QColor ();
-  QColor dummy_color = QColor (255,0,255);
+  QColor dummy_color = QColor (255, 0, 255);
 
   for (int i = 0; i < max_style; i++)  // create dialog elements for all styles
     {
       QString actual_name = lexer->description (styles[i]);
       QFont   actual_font = lexer->font (styles[i]);
       description[i] = new QLabel (actual_name);
       description[i]->setWordWrap (true);
       label_width = 24*description[i]->fontMetrics ().averageCharWidth ();
-      description[i]->setMaximumSize (label_width,QWIDGETSIZE_MAX);
-      description[i]->setMinimumSize (label_width,1);
+      description[i]->setMaximumSize (label_width, QWIDGETSIZE_MAX);
+      description[i]->setMinimumSize (label_width, 1);
       select_font[i] = new QFontComboBox ();
-      select_font[i]->setObjectName (actual_name+"_font");
-      select_font[i]->setMaximumSize (label_width,QWIDGETSIZE_MAX);
-      select_font[i]->setMinimumSize (label_width,1);
+      select_font[i]->setObjectName (actual_name + "_font");
+      select_font[i]->setMaximumSize (label_width, QWIDGETSIZE_MAX);
+      select_font[i]->setMinimumSize (label_width, 1);
       font_size[i] = new QSpinBox ();
-      font_size[i]->setObjectName (actual_name+"_size");
+      font_size[i]->setObjectName (actual_name + "_size");
       if (styles[i] == 0) // the default
         {
           select_font[i]->setCurrentFont (actual_font);
           default_font = actual_font;
-          font_size[i]->setRange (6,24);
+          font_size[i]->setRange (6, 24);
           default_size = actual_font.pointSize ();
           font_size[i]->setValue (default_size);
           default_color = lexer->defaultPaper ();
           bg_color[i] = new color_picker (default_color);
         }
       else   // other styles
         {
           select_font[i]->setCurrentFont (actual_font);
           if (actual_font.family () == default_font.family ())
             select_font[i]->setEditText (lexer->description (0));
-          font_size[i]->setRange (-4,4);
+          font_size[i]->setRange (-4, 4);
           font_size[i]->setValue (actual_font.pointSize ()-default_size);
           font_size[i]->setToolTip (QObject::tr ("Difference to the default size"));
           if (lexer->paper (styles[i]) == default_color)
             bg_color[i] = new color_picker (dummy_color);
           else
             bg_color[i] = new color_picker (lexer->paper (styles[i]));
           bg_color[i]->setToolTip
-            (QObject::tr ("Background color, pink (255,0,255) means default"));
+            (QObject::tr ("Background color, pink (255, 0, 255) means default"));
         }
       attrib_font[0+3*i] = new QCheckBox (QObject::tr ("b", "short form for bold"));
       attrib_font[1+3*i] = new QCheckBox (QObject::tr ("i", "short form for italic"));
       attrib_font[2+3*i] = new QCheckBox (QObject::tr ("u", "short form for underlined"));
       attrib_font[0+3*i]->setChecked (actual_font.bold ());
-      attrib_font[0+3*i]->setObjectName (actual_name+"_bold");
+      attrib_font[0+3*i]->setObjectName (actual_name + "_bold");
       attrib_font[1+3*i]->setChecked (actual_font.italic ());
-      attrib_font[1+3*i]->setObjectName (actual_name+"_italic");
+      attrib_font[1+3*i]->setObjectName (actual_name + "_italic");
       attrib_font[2+3*i]->setChecked (actual_font.underline ());
-      attrib_font[2+3*i]->setObjectName (actual_name+"_underline");
+      attrib_font[2+3*i]->setObjectName (actual_name + "_underline");
       color[i] = new color_picker (lexer->color (styles[i]));
-      color[i]->setObjectName (actual_name+"_color");
-      bg_color[i]->setObjectName (actual_name+"_bg_color");
+      color[i]->setObjectName (actual_name + "_color");
+      bg_color[i]->setObjectName (actual_name + "_bg_color");
       int column = 1;
-      style_grid->addWidget (description[i],     i, column++);
-      style_grid->addWidget (select_font[i],     i, column++);
-      style_grid->addWidget (font_size[i],       i, column++);
+      style_grid->addWidget (description[i], i, column++);
+      style_grid->addWidget (select_font[i], i, column++);
+      style_grid->addWidget (font_size[i], i, column++);
       style_grid->addWidget (attrib_font[0+3*i], i, column++);
       style_grid->addWidget (attrib_font[1+3*i], i, column++);
       style_grid->addWidget (attrib_font[2+3*i], i, column++);
-      style_grid->addWidget (color[i],           i, column++);
-      style_grid->addWidget (bg_color[i],        i, column++);
+      style_grid->addWidget (color[i], i, column++);
+      style_grid->addWidget (bg_color[i], i, column++);
     }
   // place grid with elements into the tab
   QScrollArea *scroll_area = new QScrollArea ();
   QWidget *scroll_area_contents = new QWidget ();
-  scroll_area_contents->setObjectName (QString (lexer->language ())+"_styles");
+  scroll_area_contents->setObjectName (QString (lexer->language ()) + "_styles");
   scroll_area_contents->setLayout (style_grid);
   scroll_area->setWidget (scroll_area_contents);
-  ui->tabs_editor_lexers->addTab (scroll_area,lexer->language ());
+  ui->tabs_editor_lexers->addTab (scroll_area, lexer->language ());
 
-  ui->tabs_editor_lexers->setCurrentIndex (
-    settings->value ("settings/last_editor_styles_tab",0).toInt ());
+  ui->tabs_editor_lexers->setCurrentIndex (settings->value ("settings/last_editor_styles_tab", 0).toInt ());
 }
 
 static void
-write_lexer_settings (Ui::settings_dialog *ui, QsciLexer *lexer,
-                      QSettings *settings)
+write_lexer_settings (Ui::settings_dialog *ui, QsciLexer *lexer, QSettings *settings)
 {
   QWidget *tab = ui->tabs_editor_lexers->
-                 findChild <QWidget *>(QString (lexer->language ())+"_styles");
+    findChild <QWidget *> (QString (lexer->language ()) + "_styles");
   int styles[MaxLexerStyles];  // array for saving valid styles
                                // (enum is not continuous)
   int max_style = get_valid_lexer_styles (lexer, styles);
   QFontComboBox *select_font;
   QSpinBox *font_size;
   QCheckBox *attrib_font[3];
   color_picker *color;
   color_picker *bg_color;
   int default_size = 10;
-  QFont default_font = QFont ("Courier New",10,-1,0);
+  QFont default_font = QFont ("Courier New", 10, -1, 0);
   QColor default_color = QColor ();
-  QColor dummy_color = QColor (255,0,255);
+  QColor dummy_color = QColor (255, 0, 255);
 
   for (int i = 0; i < max_style; i++)  // get dialog elements and their contents
     {
       QString actual_name = lexer->description (styles[i]);
-      select_font    = tab->findChild <QFontComboBox *>(actual_name+"_font");
-      font_size      = tab->findChild <QSpinBox *>(actual_name+"_size");
-      attrib_font[0] = tab->findChild <QCheckBox *>(actual_name+"_bold");
-      attrib_font[1] = tab->findChild <QCheckBox *>(actual_name+"_italic");
-      attrib_font[2] = tab->findChild <QCheckBox *>(actual_name+"_underline");
-      color          = tab->findChild <color_picker *>(actual_name+"_color");
-      bg_color       = tab->findChild <color_picker *>(actual_name+"_bg_color");
+      select_font = tab->findChild <QFontComboBox *> (actual_name + "_font");
+      font_size = tab->findChild <QSpinBox *> (actual_name + "_size");
+      attrib_font[0] = tab->findChild <QCheckBox *> (actual_name + "_bold");
+      attrib_font[1] = tab->findChild <QCheckBox *> (actual_name + "_italic");
+      attrib_font[2] = tab->findChild <QCheckBox *> (actual_name + "_underline");
+      color = tab->findChild <color_picker *> (actual_name + "_color");
+      bg_color = tab->findChild <color_picker *> (actual_name + "_bg_color");
       QFont new_font = default_font;
       if (select_font)
         {
           new_font = select_font->currentFont ();
           if (styles[i] == 0)
             default_font = new_font;
           else if (select_font->currentText () == lexer->description (0))
             new_font = default_font;
@@ -221,77 +222,77 @@ write_lexer_settings (Ui::settings_dialo
             new_font.setPointSize (font_size->value ()+default_size);
         }
       if (attrib_font[0])
         new_font.setBold (attrib_font[0]->isChecked ());
       if (attrib_font[1])
         new_font.setItalic (attrib_font[1]->isChecked ());
       if (attrib_font[2])
         new_font.setUnderline (attrib_font[2]->isChecked ());
-      lexer->setFont (new_font,styles[i]);
+      lexer->setFont (new_font, styles[i]);
       if (styles[i] == 0)
         lexer->setDefaultFont (new_font);
       if (color)
-        lexer->setColor (color->color (),styles[i]);
+        lexer->setColor (color->color (), styles[i]);
       if (bg_color)
         {
           if (styles[i] == 0)
             {
               default_color = bg_color->color ();
-              lexer->setPaper (default_color,styles[i]);
+              lexer->setPaper (default_color, styles[i]);
               lexer->setDefaultPaper (default_color);
             }
           else
             {
               if (bg_color->color () == dummy_color)
-                lexer->setPaper (default_color,styles[i]);
+                lexer->setPaper (default_color, styles[i]);
               else
-                lexer->setPaper (bg_color->color (),styles[i]);
+                lexer->setPaper (bg_color->color (), styles[i]);
             }
         }
     }
 
   lexer->writeSettings (*settings);
 
-  settings->setValue (
-    "settings/last_editor_styles_tab",ui->tabs_editor_lexers->currentIndex ());
+  settings->setValue ("settings/last_editor_styles_tab", ui->tabs_editor_lexers->currentIndex ());
   settings->sync ();
 }
 
 #endif
 
 settings_dialog::settings_dialog (QWidget *p, const QString& desired_tab):
   QDialog (p), ui (new Ui::settings_dialog)
 {
   ui->setupUi (this);
 
   QSettings *settings = resource_manager::get_settings ();
 
   if (! settings)
     {
-      QMessageBox msgBox (QMessageBox::Warning, tr ("Octave Settings"),
-                          tr ("Unable to save settings.  Missing settings "
-                              "file or unknown directory."));
+      QMessageBox msgBox
+        (QMessageBox::Warning, tr ("Octave Settings"),
+         tr ("Unable to save settings.  Missing settings file or unknown directory."));
+
       msgBox.exec ();
+
       return;
     }
 
   // restore last geometry
   restoreGeometry (settings->value ("settings/geometry").toByteArray ());
 
   // look for available language files and the actual settings
   QString qm_dir_name = resource_manager::get_gui_translation_dir ();
   QDir qm_dir (qm_dir_name);
-  QFileInfoList qm_files = qm_dir.entryInfoList (QStringList ("*.qm"),
-                                                 QDir::Files | QDir::Readable,
-                                                 QDir::Name);
+  QFileInfoList qm_files = qm_dir.entryInfoList (QStringList ("*.qm"), QDir::Files | QDir::Readable, QDir::Name);
+
   for (int i = 0; i < qm_files.length (); i++)   // insert available languages
     ui->comboBox_language->addItem (qm_files.at (i).baseName ());
   // System at beginning
-  ui->comboBox_language->insertItem (0,tr ("System setting"));
+  ui->comboBox_language->insertItem (0, tr ("System setting"));
   ui->comboBox_language->insertSeparator (1);    // separator after System
   QString language = settings->value ("language", "SYSTEM").toString ();
   if (language == "SYSTEM")
     language = tr ("System setting");
   int selected = ui->comboBox_language->findText (language);
   if (selected >= 0)
     ui->comboBox_language->setCurrentIndex (selected);
   else
@@ -309,235 +310,178 @@ settings_dialog::settings_dialog (QWidge
 
   // which icon has to be selected
   QButtonGroup *icon_group = new QButtonGroup (this);
   icon_group->addButton (ui->general_icon_octave);
   icon_group->addButton (ui->general_icon_graphic);
   icon_group->addButton (ui->general_icon_letter);
   QString widget_icon_set =
     settings->value ("DockWidgets/widget_icon_set", "NONE").toString ();
-  ui->general_icon_octave-> setChecked (true);  // the default (if invalid set)
-  ui->general_icon_octave-> setChecked (widget_icon_set == "NONE");
-  ui->general_icon_graphic-> setChecked (widget_icon_set == "GRAPHIC");
-  ui->general_icon_letter-> setChecked (widget_icon_set == "LETTER");
+  ui->general_icon_octave->setChecked (true);  // the default (if invalid set)
+  ui->general_icon_octave->setChecked (widget_icon_set == "NONE");
+  ui->general_icon_graphic->setChecked (widget_icon_set == "GRAPHIC");
+  ui->general_icon_letter->setChecked (widget_icon_set == "LETTER");
 
   // custom title bar of dock widget
-  QVariant default_var = QColor (255,255,255);
-  QColor bg_color = settings->value ("Dockwidgets/title_bg_color",
-                                     default_var).value<QColor> ();
-  _widget_title_bg_color = new color_picker (bg_color);
-  _widget_title_bg_color->setEnabled (false);
-  ui->layout_widget_bgtitle->addWidget (_widget_title_bg_color,0);
+  QVariant default_var = QColor (255, 255, 255);
+  QColor bg_color = settings->value ("Dockwidgets/title_bg_color", default_var).value<QColor> ();
+  m_widget_title_bg_color = new color_picker (bg_color);
+  m_widget_title_bg_color->setEnabled (false);
+  ui->layout_widget_bgtitle->addWidget (m_widget_title_bg_color, 0);
+
   connect (ui->cb_widget_custom_style, SIGNAL (toggled (bool)),
-           _widget_title_bg_color, SLOT (setEnabled (bool)));
+           m_widget_title_bg_color, SLOT (setEnabled (bool)));
 
-  default_var = QColor (192,192,192);
-  QColor bg_color_active = settings->value ("Dockwidgets/title_bg_color_active",
-                                            default_var).value<QColor> ();
-  _widget_title_bg_color_active = new color_picker (bg_color_active);
-  _widget_title_bg_color_active->setEnabled (false);
-  ui->layout_widget_bgtitle_active->addWidget (_widget_title_bg_color_active,0);
+  default_var = QColor (192, 192, 192);
+  QColor bg_color_active = settings->value ("Dockwidgets/title_bg_color_active", default_var).value<QColor> ();
+  m_widget_title_bg_color_active = new color_picker (bg_color_active);
+  m_widget_title_bg_color_active->setEnabled (false);
+  ui->layout_widget_bgtitle_active->addWidget (m_widget_title_bg_color_active, 0);
+
   connect (ui->cb_widget_custom_style, SIGNAL (toggled (bool)),
-           _widget_title_bg_color_active, SLOT (setEnabled (bool)));
+           m_widget_title_bg_color_active, SLOT (setEnabled (bool)));
 
-  default_var = QColor (0,0,0);
-  QColor fg_color = settings->value ("Dockwidgets/title_fg_color",
-                                     default_var).value<QColor> ();
-  _widget_title_fg_color = new color_picker (fg_color);
-  _widget_title_fg_color->setEnabled (false);
-  ui->layout_widget_fgtitle->addWidget (_widget_title_fg_color,0);
+  default_var = QColor (0, 0, 0);
+  QColor fg_color = settings->value ("Dockwidgets/title_fg_color", default_var).value<QColor> ();
+  m_widget_title_fg_color = new color_picker (fg_color);
+  m_widget_title_fg_color->setEnabled (false);
+  ui->layout_widget_fgtitle->addWidget (m_widget_title_fg_color, 0);
+
   connect (ui->cb_widget_custom_style, SIGNAL (toggled (bool)),
-           _widget_title_fg_color, SLOT (setEnabled (bool)));
+           m_widget_title_fg_color, SLOT (setEnabled (bool)));
 
-  default_var = QColor (0,0,0);
-  QColor fg_color_active = settings->value ("Dockwidgets/title_fg_color_active",
-                                            default_var).value<QColor> ();
-  _widget_title_fg_color_active = new color_picker (fg_color_active);
-  _widget_title_fg_color_active->setEnabled (false);
-  ui->layout_widget_fgtitle_active->addWidget (_widget_title_fg_color_active,0);
+  default_var = QColor (0, 0, 0);
+  QColor fg_color_active = settings->value ("Dockwidgets/title_fg_color_active", default_var).value<QColor> ();
+  m_widget_title_fg_color_active = new color_picker (fg_color_active);
+  m_widget_title_fg_color_active->setEnabled (false);
+  ui->layout_widget_fgtitle_active->addWidget (m_widget_title_fg_color_active, 0);
+
   connect (ui->cb_widget_custom_style, SIGNAL (toggled (bool)),
-           _widget_title_fg_color_active, SLOT (setEnabled (bool)));
+           m_widget_title_fg_color_active, SLOT (setEnabled (bool)));
 
-  ui->sb_3d_title->setValue (
-    settings->value ("DockWidgets/widget_title_3d", 50).toInt ());
-  ui->cb_widget_custom_style->setChecked (
-    settings->value ("DockWidgets/widget_title_custom_style",false).toBool ());
+  ui->sb_3d_title->setValue (settings->value ("DockWidgets/widget_title_3d", 50).toInt ());
+  ui->cb_widget_custom_style->setChecked (settings->value ("DockWidgets/widget_title_custom_style", false).toBool ());
 
   // Cursor blinking: consider old terminal related setting if not yet set
   // TODO: This pref. can be deprecated / removed if Qt adds support for
   //       getting the cursor blink preferences from all OS environments
   if (settings->contains ("cursor_blinking"))
     {
       // Preference exists, read its value
-      ui->cb_cursor_blinking->setChecked (
-        settings->value ("cursor_blinking",true).toBool ());
+      ui->cb_cursor_blinking->setChecked (settings->value ("cursor_blinking", true).toBool ());
     }
   else
     {
       // Pref. does not exist, so take old terminal related pref.
-      ui->cb_cursor_blinking->setChecked (
-        settings->value ("terminal/cursorBlinking",true).toBool ());
+      ui->cb_cursor_blinking->setChecked (settings->value ("terminal/cursorBlinking", true).toBool ());
     }
 
   // prompt on exit
-  ui->cb_prompt_to_exit->setChecked (
-    settings->value ("prompt_to_exit",false).toBool ());
+  ui->cb_prompt_to_exit->setChecked (settings->value ("prompt_to_exit", false).toBool ());
 
   // Main status bar
-  ui->cb_status_bar->setChecked (
-    settings->value ("show_status_bar",true).toBool ());
+  ui->cb_status_bar->setChecked (settings->value ("show_status_bar", true).toBool ());
 
   // Octave startup
-  ui->cb_restore_octave_dir->setChecked (
-    settings->value ("restore_octave_dir",false).toBool ());
-  ui->le_octave_dir->setText (
-    settings->value ("octave_startup_dir").toString ());
-  connect (ui->pb_octave_dir, SIGNAL (pressed ()),
-           this, SLOT (get_octave_dir ()));
+  ui->cb_restore_octave_dir->setChecked (settings->value ("restore_octave_dir", false).toBool ());
+  ui->le_octave_dir->setText (settings->value ("octave_startup_dir").toString ());
+
+  connect (ui->pb_octave_dir, SIGNAL (pressed (void)),
+           this, SLOT (get_octave_dir (void)));
 
   //
   // editor
   //
-  ui->useCustomFileEditor->setChecked (settings->value ("useCustomFileEditor",
-                                                        false).toBool ());
-  ui->customFileEditor->setText (
-    settings->value ("customFileEditor").toString ());
-  ui->editor_showLineNumbers->setChecked (
-    settings->value ("editor/showLineNumbers",true).toBool ());
-  ui->editor_linenr_size->setValue (
-      settings->value ("editor/line_numbers_size",0).toInt ());
+  ui->useCustomFileEditor->setChecked (settings->value ("useCustomFileEditor", false).toBool ());
+  ui->customFileEditor->setText (settings->value ("customFileEditor").toString ());
+  ui->editor_showLineNumbers->setChecked (settings->value ("editor/showLineNumbers", true).toBool ());
+  ui->editor_linenr_size->setValue (settings->value ("editor/line_numbers_size", 0).toInt ());
 
   resource_manager::combo_encoding (ui->editor_combo_encoding);
 
   default_var = QColor (240, 240, 240);
-  QColor setting_color = settings->value ("editor/highlight_current_line_color",
-                                          default_var).value<QColor> ();
-  _editor_current_line_color = new color_picker (setting_color);
-  ui->editor_grid_current_line->addWidget (_editor_current_line_color,0,3);
-  _editor_current_line_color->setMinimumSize (20,10);
-  _editor_current_line_color->setEnabled (false);
+  QColor setting_color = settings->value ("editor/highlight_current_line_color", default_var).value<QColor> ();
+  m_editor_current_line_color = new color_picker (setting_color);
+  ui->editor_grid_current_line->addWidget (m_editor_current_line_color, 0, 3);
+  m_editor_current_line_color->setMinimumSize (20, 10);
+  m_editor_current_line_color->setEnabled (false);
+
   connect (ui->editor_highlightCurrentLine, SIGNAL (toggled (bool)),
-           _editor_current_line_color, SLOT (setEnabled (bool)));
-  ui->editor_highlightCurrentLine->setChecked (
-    settings->value ("editor/highlightCurrentLine",true).toBool ());
-  ui->editor_long_line_marker->setChecked (
-            settings->value ("editor/long_line_marker",true).toBool ());
+           m_editor_current_line_color, SLOT (setEnabled (bool)));
+
+  ui->editor_highlightCurrentLine->setChecked (settings->value ("editor/highlightCurrentLine", true).toBool ());
+  ui->editor_long_line_marker->setChecked (settings->value ("editor/long_line_marker", true).toBool ());
   bool long_line =
-        settings->value ("editor/long_line_marker_line",true).toBool ();
+    settings->value ("editor/long_line_marker_line", true).toBool ();
   ui->editor_long_line_marker_line->setChecked (long_line);
   bool long_back =
-        settings->value ("editor/long_line_marker_background",false).toBool ();
+    settings->value ("editor/long_line_marker_background", false).toBool ();
   ui->editor_long_line_marker_background->setChecked (long_back);
   if (! (long_line || long_back))
     ui->editor_long_line_marker_line->setChecked (true);
-  ui->editor_long_line_column->setValue (
-    settings->value ("editor/long_line_column",80).toInt ());
-  ui->editor_break_checkbox->setChecked (
-    settings->value ("editor/break_lines",false).toBool ());
-  ui->editor_break_checkbox->setChecked (
-    settings->value ("editor/break_lines_comments",false).toBool ());
-  ui->editor_wrap_checkbox->setChecked (
-    settings->value ("editor/wrap_lines",false).toBool ());
-  ui->cb_edit_status_bar->setChecked (
-    settings->value ("editor/show_edit_status_bar",true).toBool ());
-  ui->cb_edit_tool_bar->setChecked (
-    settings->value ("editor/show_toolbar",true).toBool ());
-  ui->cb_code_folding->setChecked (
-    settings->value ("editor/code_folding",true).toBool ());
-  ui->editor_highlight_all_occurrences->setChecked (
-    settings->value ("editor/highlight_all_occurrences",true).toBool ());
+  ui->editor_long_line_column->setValue (settings->value ("editor/long_line_column", 80).toInt ());
+  ui->editor_break_checkbox->setChecked (settings->value ("editor/break_lines", false).toBool ());
+  ui->editor_break_checkbox->setChecked (settings->value ("editor/break_lines_comments", false).toBool ());
+  ui->editor_wrap_checkbox->setChecked (settings->value ("editor/wrap_lines", false).toBool ());
+  ui->cb_edit_status_bar->setChecked (settings->value ("editor/show_edit_status_bar", true).toBool ());
+  ui->cb_edit_tool_bar->setChecked (settings->value ("editor/show_toolbar", true).toBool ());
+  ui->cb_code_folding->setChecked (settings->value ("editor/code_folding", true).toBool ());
+  ui->editor_highlight_all_occurrences->setChecked (settings->value ("editor/highlight_all_occurrences", true).toBool ());
 
-  ui->editor_auto_endif->setCurrentIndex (
-    settings->value ("editor/auto_endif", 1).toInt () );
-  ui->editor_codeCompletion->setChecked (
-    settings->value ("editor/codeCompletion", true).toBool ());
-  ui->editor_spinbox_ac_threshold->setValue (
-    settings->value ("editor/codeCompletion_threshold",2).toInt ());
-  ui->editor_checkbox_ac_keywords->setChecked (
-    settings->value ("editor/codeCompletion_keywords",true).toBool ());
-  ui->editor_checkbox_ac_builtins->setEnabled (
-    ui->editor_checkbox_ac_keywords->isChecked ());
-  ui->editor_checkbox_ac_functions->setEnabled (
-    ui->editor_checkbox_ac_keywords->isChecked ());
-  ui->editor_checkbox_ac_builtins->setChecked (
-    settings->value ("editor/codeCompletion_octave_builtins",true).toBool ());
-  ui->editor_checkbox_ac_functions->setChecked (
-    settings->value ("editor/codeCompletion_octave_functions",true).toBool ());
-  ui->editor_checkbox_ac_document->setChecked (
-    settings->value ("editor/codeCompletion_document",false).toBool ());
-  ui->editor_checkbox_ac_case->setChecked (
-    settings->value ("editor/codeCompletion_case",true).toBool ());
-  ui->editor_checkbox_ac_replace->setChecked (
-    settings->value ("editor/codeCompletion_replace",false).toBool ());
-  ui->editor_ws_checkbox->setChecked (
-    settings->value ("editor/show_white_space", false).toBool ());
-  ui->editor_ws_indent_checkbox->setChecked (
-    settings->value ("editor/show_white_space_indent",false).toBool ());
-  ui->cb_show_eol->setChecked (
-    settings->value ("editor/show_eol_chars",false).toBool ());
-  ui->cb_show_hscrollbar->setChecked (
-    settings->value ("editor/show_hscroll_bar",true).toBool ());
-  ui->combo_oct_comment_str->setCurrentIndex (
-    settings->value ("editor/octave_comment_string", 0).toInt ());
+  ui->editor_auto_endif->setCurrentIndex (settings->value ("editor/auto_endif", 1).toInt () );
+  ui->editor_codeCompletion->setChecked (settings->value ("editor/codeCompletion", true).toBool ());
+  ui->editor_spinbox_ac_threshold->setValue (settings->value ("editor/codeCompletion_threshold", 2).toInt ());
+  ui->editor_checkbox_ac_keywords->setChecked (settings->value ("editor/codeCompletion_keywords", true).toBool ());
+  ui->editor_checkbox_ac_builtins->setEnabled (ui->editor_checkbox_ac_keywords->isChecked ());
+  ui->editor_checkbox_ac_functions->setEnabled (ui->editor_checkbox_ac_keywords->isChecked ());
+  ui->editor_checkbox_ac_builtins->setChecked (settings->value ("editor/codeCompletion_octave_builtins", true).toBool ());
+  ui->editor_checkbox_ac_functions->setChecked (settings->value ("editor/codeCompletion_octave_functions", true).toBool ());
+  ui->editor_checkbox_ac_document->setChecked (settings->value ("editor/codeCompletion_document", false).toBool ());
+  ui->editor_checkbox_ac_case->setChecked (settings->value ("editor/codeCompletion_case", true).toBool ());
+  ui->editor_checkbox_ac_replace->setChecked (settings->value ("editor/codeCompletion_replace", false).toBool ());
+  ui->editor_ws_checkbox->setChecked (settings->value ("editor/show_white_space", false).toBool ());
+  ui->editor_ws_indent_checkbox->setChecked (settings->value ("editor/show_white_space_indent", false).toBool ());
+  ui->cb_show_eol->setChecked (settings->value ("editor/show_eol_chars", false).toBool ());
+  ui->cb_show_hscrollbar->setChecked (settings->value ("editor/show_hscroll_bar", true).toBool ());
+  ui->combo_oct_comment_str->setCurrentIndex (settings->value ("editor/octave_comment_string", 0).toInt ());
 
 #if defined (HAVE_QSCINTILLA)
 #  if defined (Q_OS_WIN32)
   int eol_mode = QsciScintilla::EolWindows;
 #elif defined (Q_OS_MAC)
   int eol_mode = QsciScintilla::EolMac;
 #else
   int eol_mode = QsciScintilla::EolUnix;
 #endif
 #else
   int eol_mode = 2;
 #endif
-  ui->combo_eol_mode->setCurrentIndex (
-    settings->value ("editor/default_eol_mode",eol_mode).toInt ());
-  ui->editor_auto_ind_checkbox->setChecked (
-    settings->value ("editor/auto_indent", true).toBool ());
-  ui->editor_tab_ind_checkbox->setChecked (
-    settings->value ("editor/tab_indents_line",false).toBool ());
-  ui->editor_bs_unind_checkbox->setChecked (
-    settings->value ("editor/backspace_unindents_line",false).toBool ());
-  ui->editor_ind_guides_checkbox->setChecked (
-    settings->value ("editor/show_indent_guides",false).toBool ());
-  ui->editor_ind_width_spinbox->setValue (
-    settings->value ("editor/indent_width", 2).toInt ());
-  ui->editor_ind_uses_tabs_checkbox->setChecked (
-    settings->value ("editor/indent_uses_tabs", false).toBool ());
-  ui->editor_tab_width_spinbox->setValue (
-    settings->value ("editor/tab_width", 2).toInt ());
-  ui->editor_longWindowTitle->setChecked (
-    settings->value ("editor/longWindowTitle",false).toBool ());
-  ui->editor_notebook_tab_width_min->setValue (
-    settings->value ("editor/notebook_tab_width_min", 160).toInt ());
-  ui->editor_notebook_tab_width_max->setValue (
-    settings->value ("editor/notebook_tab_width_max", 300).toInt ());
-  ui->editor_restoreSession->setChecked (
-    settings->value ("editor/restoreSession", true).toBool ());
-  ui->editor_create_new_file->setChecked (
-    settings->value ("editor/create_new_file",false).toBool ());
-  ui->editor_reload_changed_files->setChecked (
-    settings->value ("editor/always_reload_changed_files",false).toBool ());
-  ui->editor_hiding_closes_files->setChecked (
-    settings->value ("editor/hiding_closes_files",false).toBool ());
+  ui->combo_eol_mode->setCurrentIndex (settings->value ("editor/default_eol_mode", eol_mode).toInt ());
+  ui->editor_auto_ind_checkbox->setChecked (settings->value ("editor/auto_indent", true).toBool ());
+  ui->editor_tab_ind_checkbox->setChecked (settings->value ("editor/tab_indents_line", false).toBool ());
+  ui->editor_bs_unind_checkbox->setChecked (settings->value ("editor/backspace_unindents_line", false).toBool ());
+  ui->editor_ind_guides_checkbox->setChecked (settings->value ("editor/show_indent_guides", false).toBool ());
+  ui->editor_ind_width_spinbox->setValue (settings->value ("editor/indent_width", 2).toInt ());
+  ui->editor_ind_uses_tabs_checkbox->setChecked (settings->value ("editor/indent_uses_tabs", false).toBool ());
+  ui->editor_tab_width_spinbox->setValue (settings->value ("editor/tab_width", 2).toInt ());
+  ui->editor_longWindowTitle->setChecked (settings->value ("editor/longWindowTitle", false).toBool ());
+  ui->editor_notebook_tab_width_min->setValue (settings->value ("editor/notebook_tab_width_min", 160).toInt ());
+  ui->editor_notebook_tab_width_max->setValue (settings->value ("editor/notebook_tab_width_max", 300).toInt ());
+  ui->editor_restoreSession->setChecked (settings->value ("editor/restoreSession", true).toBool ());
+  ui->editor_create_new_file->setChecked (settings->value ("editor/create_new_file", false).toBool ());
+  ui->editor_reload_changed_files->setChecked (settings->value ("editor/always_reload_changed_files", false).toBool ());
+  ui->editor_hiding_closes_files->setChecked (settings->value ("editor/hiding_closes_files", false).toBool ());
 
   // terminal
-  ui->terminal_fontName->setCurrentFont (QFont (
-      settings->value ("terminal/fontName", "Courier New").toString ()));
-  ui->terminal_fontSize->setValue (
-    settings->value ("terminal/fontSize", 10).toInt ());
-  ui->terminal_history_buffer->setValue (
-    settings->value ("terminal/history_buffer",1000).toInt ());
-  ui->terminal_cursorUseForegroundColor->setChecked (
-    settings->value ("terminal/cursorUseForegroundColor",true).toBool ());
-  ui->terminal_focus_command->setChecked (
-    settings->value ("terminal/focus_after_command",false).toBool ());
-  ui->terminal_print_dbg_location->setChecked (
-    settings->value ("terminal/print_debug_location",false).toBool ());
+  ui->terminal_fontName->setCurrentFont (QFont (settings->value ("terminal/fontName", "Courier New").toString ()));
+  ui->terminal_fontSize->setValue (settings->value ("terminal/fontSize", 10).toInt ());
+  ui->terminal_history_buffer->setValue (settings->value ("terminal/history_buffer", 1000).toInt ());
+  ui->terminal_cursorUseForegroundColor->setChecked (settings->value ("terminal/cursorUseForegroundColor", true).toBool ());
+  ui->terminal_focus_command->setChecked (settings->value ("terminal/focus_after_command", false).toBool ());
+  ui->terminal_print_dbg_location->setChecked (settings->value ("terminal/print_debug_location", false).toBool ());
 
   QString cursorType
     = settings->value ("terminal/cursorType", "ibeam").toString ();
 
   QStringList items;
   items << QString ("0") << QString ("1") << QString ("2");
   ui->terminal_cursorType->addItems (items);
   ui->terminal_cursorType->setItemText (0, tr ("IBeam Cursor"));
@@ -549,32 +493,28 @@ settings_dialog::settings_dialog (QWidge
   else if (cursorType == "block")
     ui->terminal_cursorType->setCurrentIndex (1);
   else if (cursorType == "underline")
     ui->terminal_cursorType->setCurrentIndex (2);
 
   // file browser
   connect (ui->sync_octave_directory, SIGNAL (toggled (bool)),
            this, SLOT (set_disabled_pref_file_browser_dir (bool)));
-  ui->sync_octave_directory->setChecked (
-    settings->value ("filesdockwidget/sync_octave_directory",true).toBool ());
-  ui->cb_restore_file_browser_dir->setChecked (
-    settings->value ("filesdockwidget/restore_last_dir",false).toBool ());
-  ui->le_file_browser_dir->setText (
-    settings->value ("filesdockwidget/startup_dir").toString ());
-  connect (ui->pb_file_browser_dir, SIGNAL (pressed ()),
-           this, SLOT (get_file_browser_dir ()));
-  ui->le_file_browser_extensions->setText (
-    settings->value ("filesdockwidget/txt_file_extensions", "m;c;cc;cpp;h;txt")
-    .toString ());
+
+  ui->sync_octave_directory->setChecked (settings->value ("filesdockwidget/sync_octave_directory", true).toBool ());
+  ui->cb_restore_file_browser_dir->setChecked (settings->value ("filesdockwidget/restore_last_dir", false).toBool ());
+  ui->le_file_browser_dir->setText (settings->value ("filesdockwidget/startup_dir").toString ());
 
-  ui->checkbox_allow_web_connect->setChecked (
-    settings->value ("news/allow_web_connection",false).toBool ());
-  ui->useProxyServer->setChecked (
-    settings->value ("useProxyServer", false).toBool ());
+  connect (ui->pb_file_browser_dir, SIGNAL (pressed (void)),
+           this, SLOT (get_file_browser_dir (void)));
+
+  ui->le_file_browser_extensions->setText (settings->value ("filesdockwidget/txt_file_extensions", "m;c;cc;cpp;h;txt").toString ());
+
+  ui->checkbox_allow_web_connect->setChecked (settings->value ("news/allow_web_connection", false).toBool ());
+  ui->useProxyServer->setChecked (settings->value ("useProxyServer", false).toBool ());
   ui->proxyHostName->setText (settings->value ("proxyHostName").toString ());
 
   int currentIndex = 0;
   QString proxyTypeString = settings->value ("proxyType").toString ();
   while ((currentIndex < ui->proxyType->count ())
          && (ui->proxyType->currentText () != proxyTypeString))
     {
       currentIndex++;
@@ -584,117 +524,404 @@ settings_dialog::settings_dialog (QWidge
   ui->proxyPort->setText (settings->value ("proxyPort").toString ());
   ui->proxyUserName->setText (settings->value ("proxyUserName").toString ());
   ui->proxyPassword->setText (settings->value ("proxyPassword").toString ());
 
   // Workspace
   // colors
   read_workspace_colors (settings);
   // hide tool tips
-  ui->cb_hide_tool_tips->setChecked (
-    settings->value ("workspaceview/hide_tool_tips",false).toBool ());
+  ui->cb_hide_tool_tips->setChecked (settings->value ("workspaceview/hide_tool_tips", false).toBool ());
 
   // terminal colors
   read_terminal_colors (settings);
 
   // variable editor
-  ui->varedit_columnWidth->setText(settings->value("variable_editor/column_width","100").toString());
-  ui->varedit_autoFitColumnWidth->setChecked(settings->value("variable_editor/autofit_column_width",false).toBool());
-  ui->varedit_autofitType->setCurrentIndex(settings->value("autofit_type",0).toInt());
-  ui->varedit_rowHeight->setText(settings->value("variable_editor/row_height","2").toString());
-  ui->varedit_rowAutofit->setChecked(settings->value("variable_editor/autofit_row_height",true).toBool());
-  ui->varedit_font->setFont(QFont(settings->value("variable_editor/font",settings->value("terminal/FontName","Courier New")).toString()));
-  ui->varedit_fontSize->setValue(settings->value("variable_editor/font_size",QVariant(10)).toInt());
-  ui->varedit_useTerminalFont->setChecked(settings->value("variable_editor/use_terminal_font",false).toBool());
-  ui->varedit_alternate->setChecked(settings->value("variable_editor/alternate_rows",QVariant(false)).toBool());
+  ui->varedit_columnWidth->setText (settings->value ("variable_editor/column_width", "100").toString ());
+  ui->varedit_autoFitColumnWidth->setChecked (settings->value ("variable_editor/autofit_column_width", false).toBool ());
+  ui->varedit_autofitType->setCurrentIndex (settings->value ("autofit_type", 0).toInt ());
+  ui->varedit_rowHeight->setText (settings->value ("variable_editor/row_height", "2").toString ());
+  ui->varedit_rowAutofit->setChecked (settings->value ("variable_editor/autofit_row_height", true).toBool ());
+  ui->varedit_font->setFont (QFont (settings->value ("variable_editor/font", settings->value ("terminal/FontName", "Courier New")).toString ()));
+  ui->varedit_fontSize->setValue (settings->value ("variable_editor/font_size", QVariant (10)).toInt ());
+  ui->varedit_useTerminalFont->setChecked (settings->value ("variable_editor/use_terminal_font", false).toBool ());
+  ui->varedit_alternate->setChecked (settings->value ("variable_editor/alternate_rows", QVariant (false)).toBool ());
 
   // variable editor colors
-  read_varedit_colors(settings);
+  read_varedit_colors (settings);
 
   // shortcuts
 
-  ui->cb_prevent_readline_conflicts->setChecked (
-    settings->value ("shortcuts/prevent_readline_conflicts", true).toBool ());
+  ui->cb_prevent_readline_conflicts->setChecked (settings->value ("shortcuts/prevent_readline_conflicts", true).toBool ());
 
   // initialize the tree view with all shortcut data
   shortcut_manager::fill_treewidget (ui->shortcuts_treewidget);
 
   // connect the buttons for import/export of the shortcut sets
-  connect (ui->btn_import_shortcut_set, SIGNAL (clicked ()),
-           this, SLOT (import_shortcut_set ()));
-  connect (ui->btn_export_shortcut_set, SIGNAL (clicked ()),
-           this, SLOT (export_shortcut_set ()));
-  connect (ui->btn_default_shortcut_set, SIGNAL (clicked ()),
-           this, SLOT (default_shortcut_set ()));
+  connect (ui->btn_import_shortcut_set, SIGNAL (clicked (void)),
+           this, SLOT (import_shortcut_set (void)));
+
+  connect (ui->btn_export_shortcut_set, SIGNAL (clicked (void)),
+           this, SLOT (export_shortcut_set (void)));
+
+  connect (ui->btn_default_shortcut_set, SIGNAL (clicked (void)),
+           this, SLOT (default_shortcut_set (void)));
 
 #if defined (HAVE_QSCINTILLA)
+
   // editor styles: create lexer, read settings, and create dialog elements
   QsciLexer *lexer;
+
 #if defined (HAVE_LEXER_OCTAVE)
+
   lexer = new QsciLexerOctave ();
   read_lexer_settings (ui, lexer, settings);
   delete lexer;
+
 #elif defined (HAVE_LEXER_MATLAB)
+
   lexer = new QsciLexerMatlab ();
   read_lexer_settings (ui, lexer, settings);
   delete lexer;
+
 #endif
+
   lexer = new QsciLexerCPP ();
   read_lexer_settings (ui, lexer, settings);
   delete lexer;
+
   lexer = new QsciLexerPerl ();
   read_lexer_settings (ui, lexer, settings);
   delete lexer;
+
   lexer = new QsciLexerBatch ();
   read_lexer_settings (ui, lexer, settings);
   delete lexer;
+
   lexer = new QsciLexerDiff ();
   read_lexer_settings (ui, lexer, settings);
   delete lexer;
+
   lexer = new QsciLexerBash ();
   read_lexer_settings (ui, lexer, settings);
   delete lexer;
+
   lexer = new octave_txt_lexer ();
   read_lexer_settings (ui, lexer, settings);
   delete lexer;
+
 #endif
 
   // which tab is the desired one?
   show_tab (desired_tab);
 
   // connect button box signal
   connect (ui->button_box, SIGNAL (clicked (QAbstractButton *)),
-           this,           SLOT (button_clicked (QAbstractButton *)));
+           this, SLOT (button_clicked (QAbstractButton *)));
 }
 
-settings_dialog::~settings_dialog ()
+settings_dialog::~settings_dialog (void)
 {
   delete ui;
 }
 
 void
 settings_dialog::show_tab (const QString& tab)
 {
   if (tab.isEmpty ())
     {
       QSettings *settings = resource_manager::get_settings ();
       if (settings)
-        ui->tabWidget->setCurrentIndex (settings->value ("settings/last_tab",
-                                        0).toInt ());
+        ui->tabWidget->setCurrentIndex (settings->value ("settings/last_tab", 0).toInt ());
     }
   else
     {
       QHash <QString, QWidget*> tab_hash;
       tab_hash["editor"] = ui->tab_editor;
       tab_hash["editor_styles"] = ui->tab_editor_styles;
-      ui->tabWidget->setCurrentIndex (
-        ui->tabWidget->indexOf (tab_hash.value (tab)));
+      ui->tabWidget->setCurrentIndex (ui->tabWidget->indexOf (tab_hash.value (tab)));
+    }
+}
+
+void
+settings_dialog::get_octave_dir (void)
+{
+  get_dir (ui->le_octave_dir, tr ("Set Octave Startup Directory"));
+}
+
+void
+settings_dialog::get_file_browser_dir (void)
+{
+  get_dir (ui->le_file_browser_dir, tr ("Set File Browser Startup Directory"));
+}
+
+void
+settings_dialog::get_dir (QLineEdit *line_edit, const QString& title)
+{
+  QString dir = QFileDialog::getExistingDirectory
+    (this, title, line_edit->text (), QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
+
+  line_edit->setText (dir);
+}
+
+void
+settings_dialog::button_clicked (QAbstractButton *button)
+{
+  QDialogButtonBox::ButtonRole button_role = ui->button_box->buttonRole (button);
+
+  if (button_role == QDialogButtonBox::ApplyRole
+      || button_role == QDialogButtonBox::AcceptRole)
+    {
+      write_changed_settings (button_role == QDialogButtonBox::AcceptRole);
+      emit apply_new_settings ();
+    }
+
+  if (button_role == QDialogButtonBox::RejectRole
+      || button_role == QDialogButtonBox::AcceptRole)
+    close ();
+}
+
+void
+settings_dialog::set_disabled_pref_file_browser_dir (bool disable)
+{
+  ui->cb_restore_file_browser_dir->setDisabled (disable);
+
+  if (! disable)
+    {
+      ui->le_file_browser_dir->setDisabled (ui->cb_restore_file_browser_dir->isChecked ());
+      ui->pb_file_browser_dir->setDisabled (ui->cb_restore_file_browser_dir->isChecked ());
+    }
+  else
+    {
+      ui->le_file_browser_dir->setDisabled (disable);
+      ui->pb_file_browser_dir->setDisabled (disable);
     }
 }
 
+// slots for import/export of shortcut sets
+void
+settings_dialog::import_shortcut_set (void)
+{
+  shortcut_manager::import_export (shortcut_manager::OSC_IMPORT);
+}
+
+void
+settings_dialog::export_shortcut_set (void)
+{
+  shortcut_manager::import_export (shortcut_manager::OSC_EXPORT);
+}
+
+void
+settings_dialog::default_shortcut_set (void)
+{
+  shortcut_manager::import_export (shortcut_manager::OSC_DEFAULT);
+}
+
+void
+settings_dialog::write_changed_settings (bool closing)
+{
+  QSettings *settings = resource_manager::get_settings ();
+
+  // the icon set
+  QString widget_icon_set = "NONE";
+  if (ui->general_icon_letter->isChecked ())
+    widget_icon_set = "LETTER";
+  else if (ui->general_icon_graphic->isChecked ())
+    widget_icon_set = "GRAPHIC";
+  settings->setValue ("DockWidgets/widget_icon_set", widget_icon_set);
+
+  // language
+  QString language = ui->comboBox_language->currentText ();
+  if (language == tr ("System setting"))
+    language = "SYSTEM";
+  settings->setValue ("language", language);
+
+  // dock widget title bar
+  settings->setValue ("DockWidgets/widget_title_custom_style", ui->cb_widget_custom_style->isChecked ());
+  settings->setValue ("DockWidgets/widget_title_3d", ui->sb_3d_title->value ());
+  settings->setValue ("Dockwidgets/title_bg_color", m_widget_title_bg_color->color ());
+  settings->setValue ("Dockwidgets/title_bg_color_active", m_widget_title_bg_color_active->color ());
+  settings->setValue ("Dockwidgets/title_fg_color", m_widget_title_fg_color->color ());
+  settings->setValue ("Dockwidgets/title_fg_color_active", m_widget_title_fg_color_active->color ());
+
+  // icon size
+  int icon_size = 0;
+  if (ui->icon_size_small->isChecked ())
+    icon_size = -1;
+  else if (ui->icon_size_large->isChecked ())
+    icon_size = 1;
+  settings->setValue ("toolbar_icon_size", icon_size);
+
+  // cursor blinking
+  settings->setValue ("cursor_blinking", ui->cb_cursor_blinking->isChecked ());
+
+  // promp to exit
+  settings->setValue ("prompt_to_exit", ui->cb_prompt_to_exit->isChecked ());
+
+  // status bar
+  settings->setValue ("show_status_bar", ui->cb_status_bar->isChecked ());
+
+  // Octave startup
+  settings->setValue ("restore_octave_dir", ui->cb_restore_octave_dir->isChecked ());
+  settings->setValue ("octave_startup_dir", ui->le_octave_dir->text ());
+
+  //editor
+  settings->setValue ("useCustomFileEditor", ui->useCustomFileEditor->isChecked ());
+  settings->setValue ("customFileEditor", ui->customFileEditor->text ());
+  settings->setValue ("editor/showLineNumbers", ui->editor_showLineNumbers->isChecked ());
+  settings->setValue ("editor/line_numbers_size", ui->editor_linenr_size->value ());
+  settings->setValue ("editor/highlightCurrentLine", ui->editor_highlightCurrentLine->isChecked ());
+  settings->setValue ("editor/highlight_current_line_color", m_editor_current_line_color->color ());
+  settings->setValue ("editor/long_line_marker", ui->editor_long_line_marker->isChecked ());
+  settings->setValue ("editor/long_line_marker_line", ui->editor_long_line_marker_line->isChecked ());
+  settings->setValue ("editor/long_line_marker_background", ui->editor_long_line_marker_background->isChecked ());
+  settings->setValue ("editor/long_line_column", ui->editor_long_line_column->value ());
+  settings->setValue ("editor/break_lines", ui->editor_break_checkbox->isChecked ());
+  settings->setValue ("editor/break_lines_comments", ui->editor_break_comments_checkbox->isChecked ());
+  settings->setValue ("editor/wrap_lines", ui->editor_wrap_checkbox->isChecked ());
+  settings->setValue ("editor/code_folding", ui->cb_code_folding->isChecked ());
+  settings->setValue ("editor/show_edit_status_bar", ui->cb_edit_status_bar->isChecked ());
+  settings->setValue ("editor/show_toolbar", ui->cb_edit_tool_bar->isChecked ());
+  settings->setValue ("editor/highlight_all_occurrences", ui->editor_highlight_all_occurrences->isChecked ());
+  settings->setValue ("editor/codeCompletion", ui->editor_codeCompletion->isChecked ());
+  settings->setValue ("editor/codeCompletion_threshold", ui->editor_spinbox_ac_threshold->value ());
+  settings->setValue ("editor/codeCompletion_keywords", ui->editor_checkbox_ac_keywords->isChecked ());
+  settings->setValue ("editor/codeCompletion_octave_builtins", ui->editor_checkbox_ac_builtins->isChecked ());
+  settings->setValue ("editor/codeCompletion_octave_functions", ui->editor_checkbox_ac_functions->isChecked ());
+  settings->setValue ("editor/codeCompletion_document", ui->editor_checkbox_ac_document->isChecked ());
+  settings->setValue ("editor/codeCompletion_case", ui->editor_checkbox_ac_case->isChecked ());
+  settings->setValue ("editor/codeCompletion_replace", ui->editor_checkbox_ac_replace->isChecked ());
+  settings->setValue ("editor/auto_endif", ui->editor_auto_endif->currentIndex ());
+  settings->setValue ("editor/show_white_space", ui->editor_ws_checkbox->isChecked ());
+  settings->setValue ("editor/show_white_space_indent", ui->editor_ws_indent_checkbox->isChecked ());
+  settings->setValue ("editor/show_eol_chars", ui->cb_show_eol->isChecked ());
+  settings->setValue ("editor/show_hscroll_bar", ui->cb_show_hscrollbar->isChecked ());
+  settings->setValue ("editor/default_eol_mode", ui->combo_eol_mode->currentIndex ());
+  settings->setValue ("editor/octave_comment_string", ui->combo_oct_comment_str->currentIndex ());
+  settings->setValue ("editor/default_encoding", ui->editor_combo_encoding->currentText ());
+  settings->setValue ("editor/auto_indent", ui->editor_auto_ind_checkbox->isChecked ());
+  settings->setValue ("editor/tab_indents_line", ui->editor_tab_ind_checkbox->isChecked ());
+  settings->setValue ("editor/backspace_unindents_line", ui->editor_bs_unind_checkbox->isChecked ());
+  settings->setValue ("editor/show_indent_guides", ui->editor_ind_guides_checkbox->isChecked ());
+  settings->setValue ("editor/indent_width", ui->editor_ind_width_spinbox->value ());
+  settings->setValue ("editor/indent_uses_tabs", ui->editor_ind_uses_tabs_checkbox->isChecked ());
+  settings->setValue ("editor/tab_width", ui->editor_tab_width_spinbox->value ());
+  settings->setValue ("editor/longWindowTitle", ui->editor_longWindowTitle->isChecked ());
+  settings->setValue ("editor/notebook_tab_width_min", ui->editor_notebook_tab_width_min->value ());
+  settings->setValue ("editor/notebook_tab_width_max", ui->editor_notebook_tab_width_max->value ());
+  settings->setValue ("editor/restoreSession", ui->editor_restoreSession->isChecked ());
+  settings->setValue ("editor/create_new_file", ui->editor_create_new_file->isChecked ());
+  settings->setValue ("editor/hiding_closes_files", ui->editor_hiding_closes_files->isChecked ());
+  settings->setValue ("editor/always_reload_changed_files", ui->editor_reload_changed_files->isChecked ());
+  settings->setValue ("terminal/fontSize", ui->terminal_fontSize->value ());
+  settings->setValue ("terminal/fontName", ui->terminal_fontName->currentFont ().family ());
+
+  // file browser
+  settings->setValue ("filesdockwidget/sync_octave_directory", ui->sync_octave_directory->isChecked ());
+  settings->setValue ("filesdockwidget/restore_last_dir", ui->cb_restore_file_browser_dir->isChecked ());
+  settings->setValue ("filesdockwidget/startup_dir", ui->le_file_browser_dir->text ());
+  settings->setValue ("filesdockwidget/txt_file_extensions", ui->le_file_browser_extensions->text ());
+
+  settings->setValue ("news/allow_web_connection", ui->checkbox_allow_web_connect->isChecked ());
+  settings->setValue ("useProxyServer", ui->useProxyServer->isChecked ());
+  settings->setValue ("proxyType", ui->proxyType->currentText ());
+  settings->setValue ("proxyHostName", ui->proxyHostName->text ());
+  settings->setValue ("proxyPort", ui->proxyPort->text ());
+  settings->setValue ("proxyUserName", ui->proxyUserName->text ());
+  settings->setValue ("proxyPassword", ui->proxyPassword->text ());
+  settings->setValue ("terminal/cursorUseForegroundColor", ui->terminal_cursorUseForegroundColor->isChecked ());
+  settings->setValue ("terminal/focus_after_command", ui->terminal_focus_command->isChecked ());
+  settings->setValue ("terminal/print_debug_location", ui->terminal_print_dbg_location->isChecked ());
+  settings->setValue ("terminal/history_buffer", ui->terminal_history_buffer->value ());
+
+  // the cursor
+  QString cursorType;
+  switch (ui->terminal_cursorType->currentIndex ())
+    {
+    case 0: cursorType = "ibeam"; break;
+    case 1: cursorType = "block"; break;
+    case 2: cursorType = "underline";  break;
+    }
+  settings->setValue ("terminal/cursorType", cursorType);
+
+#if defined (HAVE_QSCINTILLA)
+  // editor styles: create lexer, get dialog contents, and write settings
+  QsciLexer *lexer;
+
+#if defined (HAVE_LEXER_OCTAVE)
+
+  lexer = new QsciLexerOctave ();
+  write_lexer_settings (ui, lexer, settings);
+  delete lexer;
+
+#elif defined (HAVE_LEXER_MATLAB)
+
+  lexer = new QsciLexerMatlab ();
+  write_lexer_settings (ui, lexer, settings);
+  delete lexer;
+
+#endif
+
+  lexer = new QsciLexerCPP ();
+  write_lexer_settings (ui, lexer, settings);
+  delete lexer;
+
+  lexer = new QsciLexerPerl ();
+  write_lexer_settings (ui, lexer, settings);
+  delete lexer;
+
+  lexer = new QsciLexerBatch ();
+  write_lexer_settings (ui, lexer, settings);
+  delete lexer;
+
+  lexer = new QsciLexerDiff ();
+  write_lexer_settings (ui, lexer, settings);
+  delete lexer;
+
+  lexer = new QsciLexerBash ();
+  write_lexer_settings (ui, lexer, settings);
+  delete lexer;
+
+  lexer = new octave_txt_lexer ();
+  write_lexer_settings (ui, lexer, settings);
+  delete lexer;
+
+#endif
+
+  // Workspace
+  write_workspace_colors (settings);
+  // hide tool tips
+  settings->setValue ("workspaceview/hide_tool_tips", ui->cb_hide_tool_tips->isChecked ());
+
+  // Terminal
+  write_terminal_colors (settings);
+
+  // Variable editor
+  settings->setValue ("variable_editor/autofit_column_width", ui->varedit_autoFitColumnWidth->isChecked ());
+  settings->setValue ("variable_editor/autofit_type", ui->varedit_autofitType->currentIndex ());
+  settings->setValue ("variable_editor/column_width", ui->varedit_columnWidth->text ());
+  settings->setValue ("variable_editor/row_height", ui->varedit_rowHeight->text ());
+  settings->setValue ("variable_editor/autofit_row_height", ui->varedit_rowAutofit->isChecked ());
+  settings->setValue ("variable_editor/use_terminal_font", ui->varedit_useTerminalFont->isChecked ());
+  settings->setValue ("variable_editor/alternate_rows", ui->varedit_alternate->isChecked ());
+  settings->setValue ("variable_editor/font_name", ui->varedit_font->currentFont ().family ());
+  settings->setValue ("variable_editor/font_size", ui->varedit_fontSize->value ());
+  write_varedit_colors (settings);
+
+  // shortcuts
+  settings->setValue ("shortcuts/prevent_readline_conflicts", ui->cb_prevent_readline_conflicts->isChecked ());
+  shortcut_manager::write_shortcuts (settings, closing);
+
+  // settings dialog's geometry
+  settings->setValue ("settings/last_tab", ui->tabWidget->currentIndex ());
+  settings->setValue ("settings/geometry", saveGeometry ());
+
+  settings->sync ();
+}
+
 void
 settings_dialog::read_workspace_colors (QSettings *settings)
 {
 
   QList<QColor> default_colors =
     resource_manager::storage_class_default_colors ();
   QStringList class_names = resource_manager::storage_class_names ();
   QString class_chars = resource_manager::storage_class_chars ();
@@ -706,37 +933,51 @@ settings_dialog::read_workspace_colors (
 
   int column = 0;
   int row = 0;
   for (int i = 0; i < nr_of_classes; i++)
     {
       description[i] = new QLabel ("    " + class_names.at (i));
       description[i]->setAlignment (Qt::AlignRight);
       QVariant default_var = default_colors.at (i);
-      QColor setting_color = settings->value ("workspaceview/color_"
-                                              + class_chars.mid (i,1),
-                                              default_var).value<QColor> ();
+      QColor setting_color = settings->value ("workspaceview/color_" + class_chars.mid (i, 1), default_var).value<QColor> ();
       color[i] = new color_picker (setting_color);
-      color[i]->setObjectName ("color_"+class_chars.mid (i, 1));
+      color[i]->setObjectName ("color_" + class_chars.mid (i, 1));
       color[i]->setMinimumSize (30, 10);
       style_grid->addWidget (description[i], row, 3*column);
-      style_grid->addWidget (color[i],       row, 3*column+1);
+      style_grid->addWidget (color[i], row, 3*column+1);
       if (++column == 3)
         {
           style_grid->setColumnStretch (4*column, 10);
           row++;
           column = 0;
         }
     }
 
   // place grid with elements into the tab
   ui->workspace_colors_box->setLayout (style_grid);
 }
 
 void
+settings_dialog::write_workspace_colors (QSettings *settings)
+{
+
+  QString class_chars = resource_manager::storage_class_chars ();
+  color_picker *color;
+
+  for (int i = 0; i < class_chars.length (); i++)
+    {
+      color = ui->workspace_colors_box->findChild <color_picker *> ("color_" + class_chars.mid (i, 1));
+      if (color)
+        settings->setValue ("workspaceview/color_" + class_chars.mid (i, 1), color->color ());
+    }
+  settings->sync ();
+}
+
+void
 settings_dialog::read_terminal_colors (QSettings *settings)
 {
 
   QList<QColor> default_colors = resource_manager::terminal_default_colors ();
   QStringList class_names = resource_manager::terminal_color_names ();
   QString class_chars = resource_manager::terminal_color_chars ();
   int nr_of_classes = class_chars.length ();
 
@@ -746,54 +987,50 @@ settings_dialog::read_terminal_colors (Q
 
   int column = 0;
   int row = 0;
   for (int i = 0; i < nr_of_classes; i++)
     {
       description[i] = new QLabel ("    " + class_names.at (i));
       description[i]->setAlignment (Qt::AlignRight);
       QVariant default_var = default_colors.at (i);
-      QColor setting_color = settings->value ("terminal/color_"
-                                              + class_chars.mid (i,1),
-                                              default_var).value<QColor> ();
+      QColor setting_color = settings->value ("terminal/color_" + class_chars.mid (i, 1), default_var).value<QColor> ();
       color[i] = new color_picker (setting_color);
-      color[i]->setObjectName ("terminal_color_"+class_chars.mid (i, 1));
+      color[i]->setObjectName ("terminal_color_" + class_chars.mid (i, 1));
       color[i]->setMinimumSize (30, 10);
       style_grid->addWidget (description[i], row, 2*column);
-      style_grid->addWidget (color[i],       row, 2*column+1);
+      style_grid->addWidget (color[i], row, 2*column+1);
       if (++column == 2)
         {
           style_grid->setColumnStretch (3*column, 10);
           row++;
           column = 0;
         }
     }
 
   // place grid with elements into the tab
   ui->terminal_colors_box->setLayout (style_grid);
 }
 
 void
-settings_dialog::write_varedit_colors (QSettings *settings)
+settings_dialog::write_terminal_colors (QSettings *settings)
 {
-    QString class_chars = resource_manager::varedit_color_chars ();
-    color_picker *color;
+  QString class_chars = resource_manager::terminal_color_chars ();
+  color_picker *color;
 
-    for (int i = 0; i < class_chars.length (); i++)
-      {
-        color = ui->varedit_colors_box->findChild <color_picker *>(
-                  "varedit_color_"+class_chars.mid (i,1));
-        if (color)
-          settings->setValue ("variable_editor/color_"+class_chars.mid (i,1),
-                              color->color ());
-      }
-    settings->sync ();
+  for (int i = 0; i < class_chars.length (); i++)
+    {
+      color = ui->terminal_colors_box->findChild <color_picker *> ("terminal_color_" + class_chars.mid (i, 1));
+      if (color)
+        settings->setValue ("terminal/color_" + class_chars.mid (i, 1), color->color ());
+    }
+
+  settings->sync ();
 }
 
-
 void
 settings_dialog::read_varedit_colors (QSettings *settings)
 {
   QList<QColor> default_colors = variable_editor::default_colors ();
   QStringList class_names = variable_editor::color_names ();
   QString class_chars = resource_manager::varedit_color_chars ();
   int nr_of_classes = class_chars.length ();
 
@@ -803,396 +1040,41 @@ settings_dialog::read_varedit_colors (QS
 
   int column = 0;
   int row = 0;
   for (int i = 0; i < nr_of_classes; i++)
     {
       description[i] = new QLabel ("    " + class_names.at (i));
       description[i]->setAlignment (Qt::AlignRight);
       QVariant default_var = default_colors.at (i);
-      QColor setting_color = settings->value ("variable_editor/color_"
-                                              + class_chars.mid (i,1),
-                                              default_var).value<QColor> ();
+      QColor setting_color = settings->value ("variable_editor/color_" + class_chars.mid (i, 1), default_var).value<QColor> ();
       color[i] = new color_picker (setting_color);
-      color[i]->setObjectName ("varedit_color_"+class_chars.mid (i, 1));
+      color[i]->setObjectName ("varedit_color_" + class_chars.mid (i, 1));
       color[i]->setMinimumSize (30, 10);
       style_grid->addWidget (description[i], row, 2*column);
-      style_grid->addWidget (color[i],       row, 2*column+1);
+      style_grid->addWidget (color[i], row, 2*column+1);
       if (++column == 2)
         {
           style_grid->setColumnStretch (3*column, 10);
           row++;
           column = 0;
         }
     }
 
   // place grid with elements into the tab
   ui->varedit_colors_box->setLayout (style_grid);
-
 }
 
 void
-settings_dialog::write_changed_settings (bool closing)
+settings_dialog::write_varedit_colors (QSettings *settings)
 {
-  QSettings *settings = resource_manager::get_settings ();
-
-  // the icon set
-  QString widget_icon_set = "NONE";
-  if (ui->general_icon_letter->isChecked ())
-    widget_icon_set = "LETTER";
-  else if (ui->general_icon_graphic->isChecked ())
-    widget_icon_set = "GRAPHIC";
-  settings->setValue ("DockWidgets/widget_icon_set",widget_icon_set);
-
-  // language
-  QString language = ui->comboBox_language->currentText ();
-  if (language == tr ("System setting"))
-    language = "SYSTEM";
-  settings->setValue ("language", language);
-
-  // dock widget title bar
-  settings->setValue ("DockWidgets/widget_title_custom_style",
-                      ui->cb_widget_custom_style->isChecked ());
-  settings->setValue ("DockWidgets/widget_title_3d",
-                      ui->sb_3d_title->value ());
-  settings->setValue ("Dockwidgets/title_bg_color",
-                      _widget_title_bg_color->color ());
-  settings->setValue ("Dockwidgets/title_bg_color_active",
-                      _widget_title_bg_color_active->color ());
-  settings->setValue ("Dockwidgets/title_fg_color",
-                      _widget_title_fg_color->color ());
-  settings->setValue ("Dockwidgets/title_fg_color_active",
-                      _widget_title_fg_color_active->color ());
-
-  // icon size
-  int icon_size = 0;
-  if (ui->icon_size_small->isChecked ())
-    icon_size = -1;
-  else if (ui->icon_size_large->isChecked ())
-    icon_size = 1;
-  settings->setValue ("toolbar_icon_size", icon_size);
-
-  // cursor blinking
-  settings->setValue ("cursor_blinking", ui->cb_cursor_blinking->isChecked ());
-
-  // promp to exit
-  settings->setValue ("prompt_to_exit", ui->cb_prompt_to_exit->isChecked ());
-
-  // status bar
-  settings->setValue ("show_status_bar", ui->cb_status_bar->isChecked ());
-
-  // Octave startup
-  settings->setValue ("restore_octave_dir",
-                      ui->cb_restore_octave_dir->isChecked ());
-  settings->setValue ("octave_startup_dir", ui->le_octave_dir->text ());
-
-  //editor
-  settings->setValue ("useCustomFileEditor",
-                      ui->useCustomFileEditor->isChecked ());
-  settings->setValue ("customFileEditor", ui->customFileEditor->text ());
-  settings->setValue ("editor/showLineNumbers",
-                      ui->editor_showLineNumbers->isChecked ());
-  settings->setValue ("editor/line_numbers_size",
-                      ui->editor_linenr_size->value ());
-  settings->setValue ("editor/highlightCurrentLine",
-                      ui->editor_highlightCurrentLine->isChecked ());
-  settings->setValue ("editor/highlight_current_line_color",
-                      _editor_current_line_color->color ());
-  settings->setValue ("editor/long_line_marker",
-                      ui->editor_long_line_marker->isChecked ());
-  settings->setValue ("editor/long_line_marker_line",
-                      ui->editor_long_line_marker_line->isChecked ());
-  settings->setValue ("editor/long_line_marker_background",
-                      ui->editor_long_line_marker_background->isChecked ());
-  settings->setValue ("editor/long_line_column",
-                      ui->editor_long_line_column->value ());
-  settings->setValue ("editor/break_lines",
-                      ui->editor_break_checkbox->isChecked ());
-  settings->setValue ("editor/break_lines_comments",
-                      ui->editor_break_comments_checkbox->isChecked ());
-  settings->setValue ("editor/wrap_lines",
-                      ui->editor_wrap_checkbox->isChecked ());
-  settings->setValue ("editor/code_folding",
-                      ui->cb_code_folding->isChecked ());
-  settings->setValue ("editor/show_edit_status_bar",
-                      ui->cb_edit_status_bar->isChecked ());
-  settings->setValue ("editor/show_toolbar",
-                      ui->cb_edit_tool_bar->isChecked ());
-  settings->setValue ("editor/highlight_all_occurrences",
-                      ui->editor_highlight_all_occurrences->isChecked ());
-  settings->setValue ("editor/codeCompletion",
-                      ui->editor_codeCompletion->isChecked ());
-  settings->setValue ("editor/codeCompletion_threshold",
-                      ui->editor_spinbox_ac_threshold->value ());
-  settings->setValue ("editor/codeCompletion_keywords",
-                      ui->editor_checkbox_ac_keywords->isChecked ());
-  settings->setValue ("editor/codeCompletion_octave_builtins",
-                      ui->editor_checkbox_ac_builtins->isChecked ());
-  settings->setValue ("editor/codeCompletion_octave_functions",
-                      ui->editor_checkbox_ac_functions->isChecked ());
-  settings->setValue ("editor/codeCompletion_document",
-                      ui->editor_checkbox_ac_document->isChecked ());
-  settings->setValue ("editor/codeCompletion_case",
-                      ui->editor_checkbox_ac_case->isChecked ());
-  settings->setValue ("editor/codeCompletion_replace",
-                      ui->editor_checkbox_ac_replace->isChecked ());
-  settings->setValue ("editor/auto_endif",
-                      ui->editor_auto_endif->currentIndex ());
-  settings->setValue ("editor/show_white_space",
-                      ui->editor_ws_checkbox->isChecked ());
-  settings->setValue ("editor/show_white_space_indent",
-                      ui->editor_ws_indent_checkbox->isChecked ());
-  settings->setValue ("editor/show_eol_chars",
-                      ui->cb_show_eol->isChecked ());
-  settings->setValue ("editor/show_hscroll_bar",
-                      ui->cb_show_hscrollbar->isChecked ());
-  settings->setValue ("editor/default_eol_mode",
-                      ui->combo_eol_mode->currentIndex ());
-  settings->setValue ("editor/octave_comment_string",
-                      ui->combo_oct_comment_str->currentIndex ());
-  settings->setValue ("editor/default_encoding",
-                      ui->editor_combo_encoding->currentText ());
-  settings->setValue ("editor/auto_indent",
-                      ui->editor_auto_ind_checkbox->isChecked ());
-  settings->setValue ("editor/tab_indents_line",
-                      ui->editor_tab_ind_checkbox->isChecked ());
-  settings->setValue ("editor/backspace_unindents_line",
-                      ui->editor_bs_unind_checkbox->isChecked ());
-  settings->setValue ("editor/show_indent_guides",
-                      ui->editor_ind_guides_checkbox->isChecked ());
-  settings->setValue ("editor/indent_width",
-                      ui->editor_ind_width_spinbox->value ());
-  settings->setValue ("editor/indent_uses_tabs",
-                      ui->editor_ind_uses_tabs_checkbox->isChecked ());
-  settings->setValue ("editor/tab_width",
-                      ui->editor_tab_width_spinbox->value ());
-  settings->setValue ("editor/longWindowTitle",
-                      ui->editor_longWindowTitle->isChecked ());
-  settings->setValue ("editor/notebook_tab_width_min",
-                      ui->editor_notebook_tab_width_min->value ());
-  settings->setValue ("editor/notebook_tab_width_max",
-                      ui->editor_notebook_tab_width_max->value ());
-  settings->setValue ("editor/restoreSession",
-                      ui->editor_restoreSession->isChecked ());
-  settings->setValue ("editor/create_new_file",
-                      ui->editor_create_new_file->isChecked ());
-  settings->setValue ("editor/hiding_closes_files",
-                      ui->editor_hiding_closes_files->isChecked ());
-  settings->setValue ("editor/always_reload_changed_files",
-                      ui->editor_reload_changed_files->isChecked ());
-  settings->setValue ("terminal/fontSize", ui->terminal_fontSize->value ());
-  settings->setValue ("terminal/fontName",
-                      ui->terminal_fontName->currentFont ().family ());
-
-  // file browser
-  settings->setValue ("filesdockwidget/sync_octave_directory",
-                      ui->sync_octave_directory->isChecked ());
-  settings->setValue ("filesdockwidget/restore_last_dir",
-                      ui->cb_restore_file_browser_dir->isChecked ());
-  settings->setValue ("filesdockwidget/startup_dir",
-                      ui->le_file_browser_dir->text ());
-  settings->setValue ("filesdockwidget/txt_file_extensions",
-                      ui->le_file_browser_extensions->text ());
-
-  settings->setValue ("news/allow_web_connection",
-                      ui->checkbox_allow_web_connect->isChecked ());
-  settings->setValue ("useProxyServer", ui->useProxyServer->isChecked ());
-  settings->setValue ("proxyType", ui->proxyType->currentText ());
-  settings->setValue ("proxyHostName", ui->proxyHostName->text ());
-  settings->setValue ("proxyPort", ui->proxyPort->text ());
-  settings->setValue ("proxyUserName", ui->proxyUserName->text ());
-  settings->setValue ("proxyPassword", ui->proxyPassword->text ());
-  settings->setValue ("terminal/cursorUseForegroundColor",
-                      ui->terminal_cursorUseForegroundColor->isChecked ());
-  settings->setValue ("terminal/focus_after_command",
-                      ui->terminal_focus_command->isChecked ());
-  settings->setValue ("terminal/print_debug_location",
-                      ui->terminal_print_dbg_location->isChecked ());
-  settings->setValue ("terminal/history_buffer",
-                      ui->terminal_history_buffer->value ());
-
-  // the cursor
-  QString cursorType;
-  switch (ui->terminal_cursorType->currentIndex ())
-    {
-    case 0: cursorType = "ibeam"; break;
-    case 1: cursorType = "block"; break;
-    case 2: cursorType = "underline";  break;
-    }
-  settings->setValue ("terminal/cursorType", cursorType);
-
-#if defined (HAVE_QSCINTILLA)
-  // editor styles: create lexer, get dialog contents, and write settings
-  QsciLexer *lexer;
-#if defined (HAVE_LEXER_OCTAVE)
-  lexer = new QsciLexerOctave ();
-  write_lexer_settings (ui, lexer, settings);
-  delete lexer;
-#elif defined (HAVE_LEXER_MATLAB)
-  lexer = new QsciLexerMatlab ();
-  write_lexer_settings (ui, lexer, settings);
-  delete lexer;
-#endif
-  lexer = new QsciLexerCPP ();
-  write_lexer_settings (ui, lexer, settings);
-  delete lexer;
-  lexer = new QsciLexerPerl ();
-  write_lexer_settings (ui, lexer, settings);
-  delete lexer;
-  lexer = new QsciLexerBatch ();
-  write_lexer_settings (ui, lexer, settings);
-  delete lexer;
-  lexer = new QsciLexerDiff ();
-  write_lexer_settings (ui, lexer, settings);
-  delete lexer;
-  lexer = new QsciLexerBash ();
-  write_lexer_settings (ui, lexer, settings);
-  delete lexer;
-  lexer = new octave_txt_lexer ();
-  write_lexer_settings (ui, lexer, settings);
-  delete lexer;
-#endif
-
-  // Workspace
-  write_workspace_colors (settings);
-  // hide tool tips
-  settings->setValue ("workspaceview/hide_tool_tips",
-                      ui->cb_hide_tool_tips->isChecked ());
-
-  // Terminal
-  write_terminal_colors (settings);
-
-  // Variable editor
-  settings->setValue("variable_editor/autofit_column_width",ui->varedit_autoFitColumnWidth->isChecked());
-  settings->setValue("variable_editor/autofit_type",ui->varedit_autofitType->currentIndex());
-  settings->setValue("variable_editor/column_width",ui->varedit_columnWidth->text());
-  settings->setValue("variable_editor/row_height", ui->varedit_rowHeight->text());
-  settings->setValue("variable_editor/autofit_row_height",ui->varedit_rowAutofit->isChecked());
-  settings->setValue("variable_editor/use_terminal_font",ui->varedit_useTerminalFont->isChecked());
-  settings->setValue("variable_editor/alternate_rows",ui->varedit_alternate->isChecked());
-  settings->setValue("variable_editor/font_name",ui->varedit_font->currentFont().family());
-  settings->setValue("variable_editor/font_size",ui->varedit_fontSize->value());
-  write_varedit_colors(settings);
-
-  // shortcuts
-  settings->setValue ("shortcuts/prevent_readline_conflicts",
-                      ui->cb_prevent_readline_conflicts->isChecked ());
-  shortcut_manager::write_shortcuts (settings, closing);
-
-  // settings dialog's geometry
-  settings->setValue ("settings/last_tab",ui->tabWidget->currentIndex ());
-  settings->setValue ("settings/geometry",saveGeometry ());
-
-  settings->sync ();
-}
-
-void
-settings_dialog::write_workspace_colors (QSettings *settings)
-{
-
-  QString class_chars = resource_manager::storage_class_chars ();
+  QString class_chars = resource_manager::varedit_color_chars ();
   color_picker *color;
 
   for (int i = 0; i < class_chars.length (); i++)
     {
-      color = ui->workspace_colors_box->findChild <color_picker *>(
-                "color_"+class_chars.mid (i,1));
+      color = ui->varedit_colors_box->findChild <color_picker *> ("varedit_color_" + class_chars.mid (i, 1));
       if (color)
-        settings->setValue ("workspaceview/color_"+class_chars.mid (i,1),
-                            color->color ());
-    }
-  settings->sync ();
-}
-
-void
-settings_dialog::write_terminal_colors (QSettings *settings)
-{
-  QString class_chars = resource_manager::terminal_color_chars ();
-  color_picker *color;
-
-  for (int i = 0; i < class_chars.length (); i++)
-    {
-      color = ui->terminal_colors_box->findChild <color_picker *>(
-                "terminal_color_"+class_chars.mid (i,1));
-      if (color)
-        settings->setValue ("terminal/color_"+class_chars.mid (i,1),
-                            color->color ());
-    }
-  settings->sync ();
-}
-
-// internal slots
-
-void
-settings_dialog::button_clicked (QAbstractButton *button)
-{
-  QDialogButtonBox::ButtonRole button_role = ui->button_box->buttonRole (button);
-
-  if (button_role == QDialogButtonBox::ApplyRole ||
-      button_role == QDialogButtonBox::AcceptRole)
-    {
-      write_changed_settings (button_role == QDialogButtonBox::AcceptRole);
-      emit apply_new_settings ();
+        settings->setValue ("variable_editor/color_" + class_chars.mid (i, 1), color->color ());
     }
 
-  if (button_role == QDialogButtonBox::RejectRole ||
-      button_role == QDialogButtonBox::AcceptRole)
-    close ();
-}
-
-void
-settings_dialog::get_dir (QLineEdit *line_edit, const QString& title)
-{
-  QString dir = QFileDialog::getExistingDirectory (this,
-                title, line_edit->text (),
-                QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
-  line_edit->setText (dir);
-}
-
-void
-settings_dialog::get_octave_dir ()
-{
-  get_dir (ui->le_octave_dir, tr ("Set Octave Startup Directory"));
-}
-
-void
-settings_dialog::get_file_browser_dir ()
-{
-  get_dir (ui->le_file_browser_dir, tr ("Set File Browser Startup Directory"));
+  settings->sync ();
 }
-
-void
-settings_dialog::set_disabled_pref_file_browser_dir (bool disable)
-{
-  ui->cb_restore_file_browser_dir->setDisabled (disable);
-
-  if (! disable)
-    {
-      ui->le_file_browser_dir->setDisabled (
-        ui->cb_restore_file_browser_dir->isChecked ());
-      ui->pb_file_browser_dir->setDisabled (
-        ui->cb_restore_file_browser_dir->isChecked ());
-    }
-  else
-    {
-      ui->le_file_browser_dir->setDisabled (disable);
-      ui->pb_file_browser_dir->setDisabled (disable);
-    }
-}
-
-// slots for import/export of shortcut sets
-void
-settings_dialog::import_shortcut_set ()
-{
-  shortcut_manager::import_export (shortcut_manager::OSC_IMPORT);
-}
-
-void
-settings_dialog::export_shortcut_set ()
-{
-  shortcut_manager::import_export (shortcut_manager::OSC_EXPORT);
-}
-
-void
-settings_dialog::default_shortcut_set ()
-{
-  shortcut_manager::import_export (shortcut_manager::OSC_DEFAULT);
-}
diff --git a/libgui/src/settings-dialog.h b/libgui/src/settings-dialog.h
--- a/libgui/src/settings-dialog.h
+++ b/libgui/src/settings-dialog.h
@@ -32,52 +32,57 @@ along with Octave; see the file COPYING.
 namespace Ui
 {
   class settings_dialog;
 }
 
 class settings_dialog:public QDialog
 {
   Q_OBJECT public:
+
   explicit settings_dialog (QWidget *parent,
                             const QString& desired_tab = QString ());
-  ~settings_dialog ();
+  ~settings_dialog (void);
+
   void show_tab (const QString&);
 
 signals:
-  void apply_new_settings ();
+
+  void apply_new_settings (void);
 
 private slots:
-  void get_octave_dir ();
-  void get_file_browser_dir ();
+
+  void get_octave_dir (void);
+  void get_file_browser_dir (void);
   void get_dir (QLineEdit*, const QString&);
   void set_disabled_pref_file_browser_dir (bool disable);
 
   // slots for dialog's buttons
   void button_clicked (QAbstractButton *button);
 
   // slots for import/export-buttons of shortcut sets
-  void import_shortcut_set ();
-  void export_shortcut_set ();
-  void default_shortcut_set ();
+  void import_shortcut_set (void);
+  void export_shortcut_set (void);
+  void default_shortcut_set (void);
 
 private:
+
   Ui::settings_dialog *ui;
 
   void write_changed_settings (bool closing);
 
   void read_workspace_colors (QSettings *settings);
   void write_workspace_colors (QSettings *settings);
 
   void read_terminal_colors (QSettings *settings);
   void write_terminal_colors (QSettings *settings);
 
   void read_varedit_colors (QSettings *settings);
   void write_varedit_colors (QSettings *settings);
 
-  color_picker *_widget_title_bg_color;
-  color_picker *_widget_title_bg_color_active;
-  color_picker *_widget_title_fg_color;
-  color_picker *_widget_title_fg_color_active;
-  color_picker *_editor_current_line_color;
+  color_picker *m_widget_title_bg_color;
+  color_picker *m_widget_title_bg_color_active;
+  color_picker *m_widget_title_fg_color;
+  color_picker *m_widget_title_fg_color_active;
+  color_picker *m_editor_current_line_color;
 };
 
 #endif
diff --git a/libgui/src/terminal-dock-widget.cc b/libgui/src/terminal-dock-widget.cc
--- a/libgui/src/terminal-dock-widget.cc
+++ b/libgui/src/terminal-dock-widget.cc
@@ -36,23 +36,28 @@ terminal_dock_widget::terminal_dock_widg
   setObjectName ("TerminalDockWidget");
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("Command Window"));
 
   setWidget (terminal);
   setFocusProxy (terminal);
 
   connect (terminal, SIGNAL (interrupt_signal (void)),
-           this, SLOT (terminal_interrupt ()));
+           this, SLOT (terminal_interrupt (void)));
 
   // Connect the visibility signal to the terminal for dis-/enabling timers
   connect (this, SIGNAL (visibilityChanged (bool)),
            terminal, SLOT (handle_visibility_changed (bool)));
 }
 
+terminal_dock_widget::~terminal_dock_widget (void)
+{
+  delete terminal;
+}
+
 bool
 terminal_dock_widget::has_focus (void) const
 {
   QWidget *w = widget ();
 
   return w->hasFocus ();
 }
 
@@ -68,13 +73,8 @@ terminal_dock_widget::focus (void)
   w->raise ();
 }
 
 void
 terminal_dock_widget::terminal_interrupt (void)
 {
   emit interrupt_signal ();
 }
-
-terminal_dock_widget::~terminal_dock_widget (void)
-{
-  delete terminal;
-}
diff --git a/libgui/src/thread-manager.cc b/libgui/src/thread-manager.cc
--- a/libgui/src/thread-manager.cc
+++ b/libgui/src/thread-manager.cc
@@ -52,28 +52,28 @@ public:
 
 #else
 
 class pthread_thread_manager : public octave_base_thread_manager
 {
 public:
 
   pthread_thread_manager (void)
-    : octave_base_thread_manager (), my_thread (), initialized (false)
+    : octave_base_thread_manager (), m_my_thread (), m_initialized (false)
   { }
 
   void register_current_thread (void)
   {
-    my_thread = pthread_self ();
-    initialized = true;
+    m_my_thread = pthread_self ();
+    m_initialized = true;
   }
 
   void interrupt (void)
   {
-    if (initialized)
+    if (m_initialized)
       {
         // Send SIGINT to all other processes in our process group.
         // This is needed to interrupt calls to system (), for example.
 
         // FIXME: What happens if some code inside a
         // {BEGIN,END}_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE block starts
         // additional threads and one of those happens to catch this signal?
         // Would the interrupt handler and the subsequent longjmp and exception
@@ -84,25 +84,25 @@ public:
         octave_get_sig_number ("SIGINT", &sigint);
 
         octave_kill_wrapper (0, sigint);
       }
   }
 
 private:
 
-  pthread_t my_thread;
+  pthread_t m_my_thread;
 
-  bool initialized;
+  bool m_initialized;
 };
 
 #endif
 
 octave_thread_manager::octave_thread_manager (void)
-  : rep (octave_thread_manager::create_rep ())
+  : m_rep (octave_thread_manager::create_rep ())
 { }
 
 void
 octave_thread_manager::block_interrupt_signal (void)
 {
   octave_block_interrupt_signal ();
 }
 
diff --git a/libgui/src/thread-manager.h b/libgui/src/thread-manager.h
--- a/libgui/src/thread-manager.h
+++ b/libgui/src/thread-manager.h
@@ -28,69 +28,69 @@ along with Octave; see the file COPYING.
 #include "oct-refcount.h"
 
 class octave_base_thread_manager
 {
 public:
 
   friend class octave_thread_manager;
 
-  octave_base_thread_manager (void) : count (1) { }
+  octave_base_thread_manager (void) : m_count (1) { }
 
   octave_base_thread_manager (const octave_base_thread_manager&)
-    : count (1)
+    : m_count (1)
   { }
 
   virtual ~octave_base_thread_manager (void) = default;
 
   virtual void register_current_thread (void) = 0;
 
   virtual void interrupt (void) = 0;
 
 protected:
 
-  octave::refcount<int> count;
+  octave::refcount<int> m_count;
 };
 
 class octave_thread_manager
 {
 public:
 
   octave_thread_manager (void);
 
   ~octave_thread_manager (void)
   {
-    if (--rep->count == 0)
-      delete rep;
+    if (--m_rep->m_count == 0)
+      delete m_rep;
   }
 
-  octave_thread_manager (const octave_thread_manager& tm) : rep (tm.rep) { }
+  octave_thread_manager (const octave_thread_manager& tm) : m_rep (tm.m_rep) { }
 
   octave_thread_manager& operator = (const octave_thread_manager& tm)
   {
-    if (rep != tm.rep)
+    if (m_rep != tm.m_rep)
       {
-        if (--rep->count == 0)
-          delete rep;
+        if (--m_rep->m_count == 0)
+          delete m_rep;
 
-        rep = tm.rep;
-        rep->count++;
+        m_rep = tm.m_rep;
+        m_rep->m_count++;
       }
 
     return *this;
   }
 
-  void register_current_thread (void) { rep->register_current_thread (); }
+  void register_current_thread (void) { m_rep->register_current_thread (); }
 
-  void interrupt (void) { rep->interrupt (); }
+  void interrupt (void) { m_rep->interrupt (); }
 
   static void block_interrupt_signal (void);
 
   static void unblock_interrupt_signal (void);
 
 private:
 
-  octave_base_thread_manager *rep;
+  octave_base_thread_manager *m_rep;
 
   static octave_base_thread_manager * create_rep (void);
 };
 
 #endif
