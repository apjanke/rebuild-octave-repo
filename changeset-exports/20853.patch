# HG changeset patch
# User Rik <rik@octave.org>
# Date 1449934803 28800
#      Sat Dec 12 07:40:03 2015 -0800
# Node ID 1142cf6abc0d604680f4e8440607d8d39fa5b8c4
# Parent  516bb87ea72e5a961d058c28bcdfc1690e15cc36
2015 Code Sprint: remove class of function from docstring for all C++ files.

diff --git a/libinterp/corefcn/__contourc__.cc b/libinterp/corefcn/__contourc__.cc
--- a/libinterp/corefcn/__contourc__.cc
+++ b/libinterp/corefcn/__contourc__.cc
@@ -295,17 +295,17 @@ cntr (const RowVector& X, const RowVecto
   for (unsigned int r = 0; r < nr - 1; r++)
     for (unsigned int c = 0; c < nc - 1; c++)
       if (mark (r, c) > 0)
         drawcn (X, Y, Z, lvl, r, c, 0.0, 0.0, 255, true, mark);
 }
 
 DEFUN (__contourc__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __contourc__ (@var{x}, @var{y}, @var{z}, @var{levels})\n\
+@deftypefn {} {} __contourc__ (@var{x}, @var{y}, @var{z}, @var{levels})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   if (args.length () != 4)
     print_usage ();
 
   RowVector X = args(0).row_vector_value ();
   RowVector Y = args(1).row_vector_value ();
diff --git a/libinterp/corefcn/__dsearchn__.cc b/libinterp/corefcn/__dsearchn__.cc
--- a/libinterp/corefcn/__dsearchn__.cc
+++ b/libinterp/corefcn/__dsearchn__.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "lo-math.h"
 
 #include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 DEFUN (__dsearchn__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{idx}, @var{d}] =} dsearch (@var{x}, @var{xi})\n\
+@deftypefn {} {[@var{idx}, @var{d}] =} dsearch (@var{x}, @var{xi})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () != 2)
     print_usage ();
 
diff --git a/libinterp/corefcn/__ichol__.cc b/libinterp/corefcn/__ichol__.cc
--- a/libinterp/corefcn/__ichol__.cc
+++ b/libinterp/corefcn/__ichol__.cc
@@ -175,18 +175,18 @@ void ichol_0 (octave_matrix_t& sm, const
               Llist[jjrow] = k;
             }
         }
     }
 }
 
 DEFUN (__ichol0__, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{L} =} __ichol0__ (@var{A})\n\
-@deftypefnx {Built-in Function} {@var{L} =} __ichol0__ (@var{A}, @var{michol})\n\
+@deftypefn  {} {@var{L} =} __ichol0__ (@var{A})\n\
+@deftypefnx {} {@var{L} =} __ichol0__ (@var{A}, @var{michol})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 
 {
   octave_value_list retval;
 
   int nargin = args.length ();
   std::string michol = "off";
@@ -421,19 +421,19 @@ void ichol_t (const octave_matrix_t& sm,
     {
       L.ridx (i) = ridx_l[i];
       L.data (i) = data_l[i];
     }
 }
 
 DEFUN (__icholt__, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{L} =} __icholt__ (@var{A})\n\
-@deftypefnx {Built-in Function} {@var{L} =} __icholt__ (@var{A}, @var{droptol})\n\
-@deftypefnx {Built-in Function} {@var{L} =} __icholt__ (@var{A}, @var{droptol}, @var{michol})\n\
+@deftypefn  {} {@var{L} =} __icholt__ (@var{A})\n\
+@deftypefnx {} {@var{L} =} __icholt__ (@var{A}, @var{droptol})\n\
+@deftypefnx {} {@var{L} =} __icholt__ (@var{A}, @var{droptol}, @var{michol})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   // Default values of parameters
   std::string michol = "off";
   double droptol = 0;
diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -123,19 +123,19 @@ void ilu_0 (octave_matrix_t& sm, const s
         iw[ridx[i]] = -1;
     }
   if (opt == ROW)
     sm = sm.transpose ();
 }
 
 DEFUN (__ilu0__, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} __ilu0__ (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}] =} __ilu0__ (@var{A}, @var{milu})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} __ilu0__ (@var{A}, @dots{})\n\
+@deftypefn  {} {[@var{L}, @var{U}] =} __ilu0__ (@var{A})\n\
+@deftypefnx {} {[@var{L}, @var{U}] =} __ilu0__ (@var{A}, @var{milu})\n\
+@deftypefnx {} {[@var{L}, @var{U}, @var{P}] =} __ilu0__ (@var{A}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
   std::string milu;
 
@@ -459,20 +459,20 @@ void ilu_crout (octave_matrix_t& sm_l, o
       U.data (i) = data_u[i];
     }
 
   U = U.transpose ();
 }
 
 DEFUN (__iluc__, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} __iluc__ (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}] =} __iluc__ (@var{A}, @var{droptol})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}] =} __iluc__ (@var{A}, @var{droptol}, @var{milu})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} __iluc__ (@var{A}, @dots{})\n\
+@deftypefn  {} {[@var{L}, @var{U}] =} __iluc__ (@var{A})\n\
+@deftypefnx {} {[@var{L}, @var{U}] =} __iluc__ (@var{A}, @var{droptol})\n\
+@deftypefnx {} {[@var{L}, @var{U}] =} __iluc__ (@var{A}, @var{droptol}, @var{milu})\n\
+@deftypefnx {} {[@var{L}, @var{U}, @var{P}] =} __iluc__ (@var{A}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   std::string milu = "off";
   double droptol = 0;
 
@@ -930,22 +930,22 @@ void ilu_tp (octave_matrix_t& sm, octave
       // The diagonal, conveniently permuted is added to U
       U += diag.index (idx_vector::colon, perm_vec);
       L = L.transpose ();
     }
 }
 
 DEFUN (__ilutp__, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} __ilutp__ (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol}, @var{thresh})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol}, @var{thresh}, @var{milu})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol}, @var{thresh}, @var{milu}, @var{udiag})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} __ilutp__ (@var{A}, @dots{})\n\
+@deftypefn  {} {[@var{L}, @var{U}] =} __ilutp__ (@var{A})\n\
+@deftypefnx {} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol})\n\
+@deftypefnx {} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol}, @var{thresh})\n\
+@deftypefnx {} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol}, @var{thresh}, @var{milu})\n\
+@deftypefnx {} {[@var{L}, @var{U}] =} __ilutp__ (@var{A}, @var{droptol}, @var{thresh}, @var{milu}, @var{udiag})\n\
+@deftypefnx {} {[@var{L}, @var{U}, @var{P}] =} __ilutp__ (@var{A}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
   std::string milu = "";
   double droptol = 0;
diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -256,17 +256,17 @@ lin_interpn (int n, M *X, const M V, M *
 // or vectors.  The parameters @var{y1}, @var{y2}, @dots{}, @var{yn} are
 // all @var{n}-dimensional arrays of the same size and represent the
 // points at which the array @var{vi} is interpolated.
 //
 //This function only performs linear interpolation.
 
 DEFUN (__lin_interpn__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{vi} =} __lin_interpn__ (@var{x1}, @var{x2}, @dots{}, @var{xn}, @var{v}, @var{y1}, @var{y2}, @dots{}, @var{yn})\n\
+@deftypefn {} {@var{vi} =} __lin_interpn__ (@var{x1}, @var{x2}, @dots{}, @var{xn}, @var{v}, @var{y1}, @var{y2}, @dots{}, @var{yn})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin % 2 == 0)
diff --git a/libinterp/corefcn/__pchip_deriv__.cc b/libinterp/corefcn/__pchip_deriv__.cc
--- a/libinterp/corefcn/__pchip_deriv__.cc
+++ b/libinterp/corefcn/__pchip_deriv__.cc
@@ -47,17 +47,17 @@ extern "C"
                            octave_idx_type *ierr);
 }
 
 // Wrapper for SLATEC/PCHIP function DPCHIM to calculate the derivates
 // for piecewise polynomials.
 
 DEFUN (__pchip_deriv__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __pchip_deriv__ (@var{x}, @var{y}, @var{dim})\n\
+@deftypefn {} {} __pchip_deriv__ (@var{x}, @var{y}, @var{dim})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
   const int nargin = args.length ();
 
   bool rows = (nargin == 3 && args(2).uint_value () == 2);
 
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -482,17 +482,17 @@ qp (const Matrix& H, const ColumnVector&
         }
     }
 
   return info;
 }
 
 DEFUN (__qp__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{x}, @var{lambda}, @var{info}, @var{iter}] =} __qp__ (@var{x0}, @var{H}, @var{q}, @var{Aeq}, @var{beq}, @var{Ain}, @var{bin}, @var{maxit})\n\
+@deftypefn {} {[@var{x}, @var{lambda}, @var{info}, @var{iter}] =} __qp__ (@var{x0}, @var{H}, @var{q}, @var{Aeq}, @var{beq}, @var{Ain}, @var{bin}, @var{maxit})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () != 8)
     print_usage ();
 
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -43,21 +43,21 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "f77-fcn.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (balance, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{AA} =} balance (@var{A})\n\
-@deftypefnx {Built-in Function} {@var{AA} =} balance (@var{A}, @var{opt})\n\
-@deftypefnx {Built-in Function} {[@var{DD}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
-@deftypefnx {Built-in Function} {[@var{D}, @var{P}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
-@deftypefnx {Built-in Function} {[@var{CC}, @var{DD}, @var{AA}, @var{BB}] =} balance (@var{A}, @var{B}, @var{opt})\n\
+@deftypefn  {} {@var{AA} =} balance (@var{A})\n\
+@deftypefnx {} {@var{AA} =} balance (@var{A}, @var{opt})\n\
+@deftypefnx {} {[@var{DD}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
+@deftypefnx {} {[@var{D}, @var{P}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
+@deftypefnx {} {[@var{CC}, @var{DD}, @var{AA}, @var{BB}] =} balance (@var{A}, @var{B}, @var{opt})\n\
 \n\
 Balance the matrix @var{A} to reduce numerical errors in future\n\
 calculations.\n\
 \n\
 Compute @code{@var{AA} = @var{DD} \\ @var{A} * @var{DD}} in which @var{AA}\n\
 is a matrix whose row and column norms are roughly equal in magnitude, and\n\
 @code{@var{DD} = @var{P} * @var{D}}, in which @var{P} is a permutation\n\
 matrix and @var{D} is a diagonal matrix of powers of two.  This allows the\n\
diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -306,21 +306,21 @@ do_bessel (enum bessel_type type, const 
         }
     }
 
   return retval;
 }
 
 DEFUN (besselj, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})\n\
-@deftypefnx {Built-in Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
-@deftypefnx {Built-in Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
-@deftypefnx {Built-in Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
-@deftypefnx {Built-in Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
+@deftypefn  {} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefnx {} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefnx {} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefnx {} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefnx {} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 Compute Bessel or Hankel functions of various kinds:\n\
 \n\
 @table @code\n\
 @item besselj\n\
 Bessel functions of the first kind.  If the argument @var{opt} is 1 or true,\n\
 the result is multiplied by @w{@code{exp (-abs (imag (@var{x})))}}.\n\
 \n\
 @item bessely\n\
@@ -380,44 +380,44 @@ return @code{NaN}.\n\
 @end enumerate\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_J, "besselj", args, nargout);
 }
 
 DEFUN (bessely, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefn {} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_Y, "bessely", args, nargout);
 }
 
 DEFUN (besseli, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefn {} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_I, "besseli", args, nargout);
 }
 
 DEFUN (besselk, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefn {} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_K, "besselk", args, nargout);
 }
 
 DEFUN (besselh, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
+@deftypefn {} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 4)
@@ -447,17 +447,17 @@ See besselj.\n\
         error ("besselh: K must be 1 or 2");
     }
 
   return retval;
 }
 
 DEFUN (airy, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
+@deftypefn {} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
 Compute Airy functions of the first and second kind, and their derivatives.\n\
 \n\
 @example\n\
 @group\n\
  K   Function   Scale factor (if \"opt\" is supplied)\n\
 ---  --------   ---------------------------------------\n\
  0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))\n\
  1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))\n\
diff --git a/libinterp/corefcn/betainc.cc b/libinterp/corefcn/betainc.cc
--- a/libinterp/corefcn/betainc.cc
+++ b/libinterp/corefcn/betainc.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 
 DEFUN (betainc, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} betainc (@var{x}, @var{a}, @var{b})\n\
+@deftypefn {} {} betainc (@var{x}, @var{a}, @var{b})\n\
 Compute the regularized incomplete Beta function.\n\
 \n\
 The regularized incomplete Beta function is defined by\n\
 @tex\n\
 $$\n\
  I (x, a, b) = {1 \\over {B (a, b)}} \\int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.\n\
 $$\n\
 @end tex\n\
@@ -282,17 +282,17 @@ compatible dimensions.\n\
 %!error betainc ()
 %!error betainc (1)
 %!error betainc (1,2)
 %!error betainc (1,2,3,4)
 */
 
 DEFUN (betaincinv, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} betaincinv (@var{y}, @var{a}, @var{b})\n\
+@deftypefn {} {} betaincinv (@var{y}, @var{a}, @var{b})\n\
 Compute the inverse of the incomplete Beta function.\n\
 \n\
 The inverse is the value @var{x} such that\n\
 \n\
 @example\n\
 @var{y} == betainc (@var{x}, @var{a}, @var{b})\n\
 @end example\n\
 @seealso{betainc, beta, betaln}\n\
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -356,40 +356,40 @@ bitop (const std::string& fname, const o
   else
     error ("%s: must have matching operand types", fname.c_str ());
 
   return retval;
 }
 
 DEFUN (bitand, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} bitand (@var{x}, @var{y})\n\
+@deftypefn {} {} bitand (@var{x}, @var{y})\n\
 Return the bitwise AND of non-negative integers.\n\
 \n\
 @var{x}, @var{y} must be in the range [0,intmax]\n\
 @seealso{bitor, bitxor, bitset, bitget, bitcmp, bitshift, intmax, flintmax}\n\
 @end deftypefn")
 {
   return bitop ("bitand", args);
 }
 
 DEFUN (bitor, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} bitor (@var{x}, @var{y})\n\
+@deftypefn {} {} bitor (@var{x}, @var{y})\n\
 Return the bitwise OR of non-negative integers @var{x} and @var{y}.\n\
 \n\
 @seealso{bitor, bitxor, bitset, bitget, bitcmp, bitshift, intmax, flintmax}\n\
 @end deftypefn")
 {
   return bitop ("bitor", args);
 }
 
 DEFUN (bitxor, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} bitxor (@var{x}, @var{y})\n\
+@deftypefn {} {} bitxor (@var{x}, @var{y})\n\
 Return the bitwise XOR of non-negative integers @var{x} and @var{y}.\n\
 \n\
 @seealso{bitand, bitor, bitset, bitget, bitcmp, bitshift, intmax, flintmax}\n\
 @end deftypefn")
 {
   return bitop ("bitxor", args);
 }
 
@@ -526,18 +526,18 @@ bitshift (float a, int n, int64_t mask)
         mask = 0; \
       mask = mask | octave_ ## T :: min (); /* FIXME: 2's complement only? */ \
       DO_BITSHIFT (T); \
     } \
   while (0)
 
 DEFUN (bitshift, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} bitshift (@var{a}, @var{k})\n\
-@deftypefnx {Built-in Function} {} bitshift (@var{a}, @var{k}, @var{n})\n\
+@deftypefn  {} {} bitshift (@var{a}, @var{k})\n\
+@deftypefnx {} {} bitshift (@var{a}, @var{k}, @var{n})\n\
 Return a @var{k} bit shift of @var{n}-digit unsigned integers in @var{a}.\n\
 \n\
 A positive @var{k} leads to a left shift; A negative value to a right shift.\n\
 \n\
 If @var{n} is omitted it defaults to 64.\n\
 @var{n} must be in the range [1,64].\n\
 \n\
 @example\n\
@@ -654,19 +654,19 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
 %!error <K must be a scalar or array of integers> bitshift (16, 1.5)
 %!error bitshift (16, {1})
 %!error <N must be a scalar integer> bitshift (10, [-2 -1 0 1 2], [1 1 1 1 1])
 %!error <N must be positive> bitshift (10, [-2 -1 0 1 2], -1)
 */
 
 DEFUN (flintmax, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} flintmax ()\n\
-@deftypefnx {Built-in Function} {} flintmax (\"double\")\n\
-@deftypefnx {Built-in Function} {} flintmax (\"single\")\n\
+@deftypefn  {} {} flintmax ()\n\
+@deftypefnx {} {} flintmax (\"double\")\n\
+@deftypefnx {} {} flintmax (\"single\")\n\
 Return the largest integer that can be represented consecutively in a\n\
 floating point value.\n\
 \n\
 The default class is @qcode{\"double\"}, but @qcode{\"single\"} is a valid\n\
 option.  On IEEE 754 compatible systems, @code{flintmax} is @w{@math{2^{53}}}\n\
 for @qcode{\"double\"} and @w{@math{2^{24}}} for @qcode{\"single\"}.\n\
 @seealso{intmax, realmax, realmin}\n\
 @end deftypefn")
@@ -690,17 +690,17 @@ for @qcode{\"double\"} and @w{@math{2^{2
   else
     error ("flintmax: not defined for class '%s'", cname.c_str ());
 
   return retval;
 }
 
 DEFUN (intmax, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} intmax (@var{type})\n\
+@deftypefn {} {} intmax (@var{type})\n\
 Return the largest integer that can be represented in an integer type.\n\
 \n\
 The variable @var{type} can be\n\
 \n\
 @table @code\n\
 @item int8\n\
 signed 8-bit integer.\n\
 \n\
@@ -761,17 +761,17 @@ The default for @var{type} is @code{int3
   else
     error ("intmax: not defined for '%s' objects", cname.c_str ());
 
   return retval;
 }
 
 DEFUN (intmin, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} intmin (@var{type})\n\
+@deftypefn {} {} intmin (@var{type})\n\
 Return the smallest integer that can be represented in an integer type.\n\
 \n\
 The variable @var{type} can be\n\
 \n\
 @table @code\n\
 @item int8\n\
 signed 8-bit integer.\n\
 \n\
@@ -832,17 +832,17 @@ The default for @var{type} is @code{int3
   else
     error ("intmin: not defined for '%s' objects", cname.c_str ());
 
   return retval;
 }
 
 DEFUN (sizemax, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} sizemax ()\n\
+@deftypefn {} {} sizemax ()\n\
 Return the largest value allowed for the size of an array.\n\
 \n\
 If Octave is compiled with 64-bit indexing, the result is of class int64,\n\
 otherwise it is of class int32.  The maximum array size is slightly\n\
 smaller than the maximum value allowable for the relevant class as reported\n\
 by @code{intmax}.\n\
 @seealso{intmax}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -313,17 +313,17 @@ update_index (Array<int>& idx, const dim
     {
       idx(j) = i % dv(j);
       i /= dv(j);
     }
 }
 
 DEFUN (bsxfun, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
+@deftypefn {} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
 The binary singleton expansion function performs broadcasting,\n\
 that is, it applies a binary function @var{f} element-by-element to two\n\
 array arguments @var{A} and @var{B}, and expands as necessary\n\
 singleton dimensions in either input argument.\n\
 \n\
 @var{f} is a function handle, inline function, or string containing the name\n\
 of the function to evaluate.  The function @var{f} must be capable of\n\
 accepting two column-vector arguments of equal length, or one column vector\n\
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -260,24 +260,24 @@ get_mapper_fun_options (const octave_val
       nargin -= 2;
     }
 
   nargin -= 1;
 }
 
 DEFUN (cellfun, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} cellfun (@var{name}, @var{C})\n\
-@deftypefnx {Built-in Function} {} cellfun (\"size\", @var{C}, @var{k})\n\
-@deftypefnx {Built-in Function} {} cellfun (\"isclass\", @var{C}, @var{class})\n\
-@deftypefnx {Built-in Function} {} cellfun (@var{func}, @var{C})\n\
-@deftypefnx {Built-in Function} {} cellfun (@var{func}, @var{C}, @var{D})\n\
-@deftypefnx {Built-in Function} {[@var{a}, @dots{}] =} cellfun (@dots{})\n\
-@deftypefnx {Built-in Function} {} cellfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
-@deftypefnx {Built-in Function} {} cellfun (@dots{}, \"UniformOutput\", @var{val})\n\
+@deftypefn  {} {} cellfun (@var{name}, @var{C})\n\
+@deftypefnx {} {} cellfun (\"size\", @var{C}, @var{k})\n\
+@deftypefnx {} {} cellfun (\"isclass\", @var{C}, @var{class})\n\
+@deftypefnx {} {} cellfun (@var{func}, @var{C})\n\
+@deftypefnx {} {} cellfun (@var{func}, @var{C}, @var{D})\n\
+@deftypefnx {} {[@var{a}, @dots{}] =} cellfun (@dots{})\n\
+@deftypefnx {} {} cellfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
+@deftypefnx {} {} cellfun (@dots{}, \"UniformOutput\", @var{val})\n\
 \n\
 Evaluate the function named @var{name} on the elements of the cell array\n\
 @var{C}.\n\
 \n\
 Elements in @var{C} are passed on to the named function individually.  The\n\
 function @var{name} can be one of the functions\n\
 \n\
 @table @code\n\
@@ -1008,22 +1008,22 @@ v = cellfun (@@det, a); # faster\n\
 */
 
 // Arrayfun was originally a .m file written by Bill Denney and Jaroslav
 // Hajek.  It was converted to C++ by jwe so that it could properly
 // handle the nargout = 0 case.
 
 DEFUN (arrayfun, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Function File} {} arrayfun (@var{func}, @var{A})\n\
-@deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{A})\n\
-@deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{A}, @var{b}, @dots{})\n\
-@deftypefnx {Function File} {[@var{x}, @var{y}, @dots{}] =} arrayfun (@var{func}, @var{A}, @dots{})\n\
-@deftypefnx {Function File} {} arrayfun (@dots{}, \"UniformOutput\", @var{val})\n\
-@deftypefnx {Function File} {} arrayfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
+@deftypefn  {} {} arrayfun (@var{func}, @var{A})\n\
+@deftypefnx {} {@var{x} =} arrayfun (@var{func}, @var{A})\n\
+@deftypefnx {} {@var{x} =} arrayfun (@var{func}, @var{A}, @var{b}, @dots{})\n\
+@deftypefnx {} {[@var{x}, @var{y}, @dots{}] =} arrayfun (@var{func}, @var{A}, @dots{})\n\
+@deftypefnx {} {} arrayfun (@dots{}, \"UniformOutput\", @var{val})\n\
+@deftypefnx {} {} arrayfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
 \n\
 Execute a function on each element of an array.\n\
 \n\
 This is useful for functions that do not accept array arguments.  If the\n\
 function does accept array arguments it is better to call the function\n\
 directly.\n\
 \n\
 The first input argument @var{func} can be a string, a function\n\
@@ -1768,18 +1768,18 @@ do_object2cell (const octave_value& obj,
   else
     error ("num2cell (A, dim) not implemented for class objects");
 
   return retval;
 }
 
 DEFUN (num2cell, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{C} =} num2cell (@var{A})\n\
-@deftypefnx {Built-in Function} {@var{C} =} num2cell (@var{A}, @var{dim})\n\
+@deftypefn  {} {@var{C} =} num2cell (@var{A})\n\
+@deftypefnx {} {@var{C} =} num2cell (@var{A}, @var{dim})\n\
 Convert the numeric matrix @var{A} to a cell array.\n\
 \n\
 If @var{dim} is defined, the value @var{C} is of dimension 1 in this\n\
 dimension and the elements of @var{A} are placed into @var{C} in slices.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
@@ -2090,19 +2090,19 @@ do_mat2cell (octave_value& a, const Arra
       rdv.increment_index (ridx);
     }
 
   return retval;
 }
 
 DEFUN (mat2cell, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{C} =} mat2cell (@var{A}, @var{m}, @var{n})\n\
-@deftypefnx {Built-in Function} {@var{C} =} mat2cell (@var{A}, @var{d1}, @var{d2}, @dots{})\n\
-@deftypefnx {Built-in Function} {@var{C} =} mat2cell (@var{A}, @var{r})\n\
+@deftypefn  {} {@var{C} =} mat2cell (@var{A}, @var{m}, @var{n})\n\
+@deftypefnx {} {@var{C} =} mat2cell (@var{A}, @var{d1}, @var{d2}, @dots{})\n\
+@deftypefnx {} {@var{C} =} mat2cell (@var{A}, @var{r})\n\
 Convert the matrix @var{A} to a cell array.\n\
 \n\
 If @var{A} is 2-D, then it is required that\n\
 @code{sum (@var{m}) == size (@var{A}, 1)} and\n\
 @code{sum (@var{n}) == size (@var{A}, 2)}.  Similarly, if @var{A} is\n\
 multi-dimensional and the number of dimensional arguments is equal to the\n\
 dimensions of @var{A}, then it is required that\n\
 @code{sum (@var{di}) == size (@var{A}, i)}.\n\
@@ -2260,17 +2260,17 @@ do_cellslices_nda (const NDA& array,
         }
     }
 
   return retval;
 }
 
 DEFUN (cellslices, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{sl} =} cellslices (@var{x}, @var{lb}, @var{ub}, @var{dim})\n\
+@deftypefn {} {@var{sl} =} cellslices (@var{x}, @var{lb}, @var{ub}, @var{dim})\n\
 Given an array @var{x}, this function produces a cell array of slices from\n\
 the array determined by the index vectors @var{lb}, @var{ub}, for lower and\n\
 upper bounds, respectively.\n\
 \n\
 In other words, it is equivalent to the following code:\n\
 \n\
 @example\n\
 @group\n\
@@ -2387,17 +2387,17 @@ slicing is done along the first non-sing
 %!test
 %! m = [1, 2, 3, 4; 5, 6, 7, 8; 9, 10, 11, 12];
 %! c = cellslices (m, [1, 2], [2, 3], 2);
 %! assert (c, {[1, 2; 5, 6; 9, 10], [2, 3; 6, 7; 10, 11]});
 */
 
 DEFUN (cellindexmat, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{y} =} cellindexmat (@var{x}, @var{varargin})\n\
+@deftypefn {} {@var{y} =} cellindexmat (@var{x}, @var{varargin})\n\
 Perform indexing of matrices in a cell array.\n\
 \n\
 Given a cell array of matrices @var{x}, this function computes\n\
 \n\
 @example\n\
 @group\n\
 Y = cell (size (X));\n\
 for i = 1:numel (X)\n\
diff --git a/libinterp/corefcn/colloc.cc b/libinterp/corefcn/colloc.cc
--- a/libinterp/corefcn/colloc.cc
+++ b/libinterp/corefcn/colloc.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 
 #include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (colloc, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{r}, @var{amat}, @var{bmat}, @var{q}] =} colloc (@var{n}, \"left\", \"right\")\n\
+@deftypefn {} {[@var{r}, @var{amat}, @var{bmat}, @var{q}] =} colloc (@var{n}, \"left\", \"right\")\n\
 Compute derivative and integral weight matrices for orthogonal collocation.\n\
 \n\
 Reference: @nospell{J. Villadsen}, @nospell{M. L. Michelsen},\n\
 @cite{Solution of Differential Equation Models by Polynomial Approximation}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -31,19 +31,19 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 enum Shape { SHAPE_FULL, SHAPE_SAME, SHAPE_VALID };
 
 DEFUN (conv2, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} conv2 (@var{A}, @var{B})\n\
-@deftypefnx {Built-in Function} {} conv2 (@var{v1}, @var{v2}, @var{m})\n\
-@deftypefnx {Built-in Function} {} conv2 (@dots{}, @var{shape})\n\
+@deftypefn  {} {} conv2 (@var{A}, @var{B})\n\
+@deftypefnx {} {} conv2 (@var{v1}, @var{v2}, @var{m})\n\
+@deftypefnx {} {} conv2 (@dots{}, @var{shape})\n\
 Return the 2-D convolution of @var{A} and @var{B}.\n\
 \n\
 The size of the result is determined by the optional @var{shape} argument\n\
 which takes the following values\n\
 \n\
 @table @asis\n\
 @item @var{shape} = @qcode{\"full\"}\n\
 Return the full convolution.  (default)\n\
@@ -276,18 +276,18 @@ When the third argument is a matrix, ret
 %!error <SHAPE type not valid> conv2 (1,2, "NOT_A_SHAPE")
 %% Test alternate calling form which should be 2 vectors and a matrix
 %!error conv2 (ones (2), 1, 1)
 %!error conv2 (1, ones (2), 1)
 */
 
 DEFUN (convn, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{C} =} convn (@var{A}, @var{B})\n\
-@deftypefnx {Built-in Function} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})\n\
+@deftypefn  {} {@var{C} =} convn (@var{A}, @var{B})\n\
+@deftypefnx {} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})\n\
 Return the n-D convolution of @var{A} and @var{B}.\n\
 \n\
 The size of the result is determined by the optional @var{shape} argument\n\
 which takes the following values\n\
 \n\
 @table @asis\n\
 @item @var{shape} = @qcode{\"full\"}\n\
 Return the full convolution.  (default)\n\
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -173,17 +173,17 @@ daspk_user_jacobian (const ColumnVector&
     { \
       error ("daspk: " fmt, arg); \
       DASPK_ABORT (); \
     } \
   while (0)
 
 DEFUN (daspk, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} daspk (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefn {} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} daspk (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -212,20 +212,20 @@ dasrt_user_j (const ColumnVector& x, con
     { \
       error ("dasrt: " fmt, arg); \
       DASRT_ABORT; \
     } \
   while (0)
 
 DEFUN (dasrt, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t})\n\
-@deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t})\n\
-@deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
-@deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefn  {} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t})\n\
+@deftypefnx {} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t})\n\
+@deftypefnx {} {@dots{} =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefnx {} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -173,17 +173,17 @@ dassl_user_jacobian (const ColumnVector&
     { \
       error ("dassl: " fmt, arg); \
       DASSL_ABORT (); \
     } \
   while (0)
 
 DEFUN (dassl, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefn {} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -103,18 +103,18 @@ index_error (const char *fmt, const std:
     retval = args(0).FCN (dim); \
   else \
     error (#FCN ": invalid dimension argument = %d", dim + 1); \
  \
   return retval
 
 DEFUN (all, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} all (@var{x})\n\
-@deftypefnx {Built-in Function} {} all (@var{x}, @var{dim})\n\
+@deftypefn  {} {} all (@var{x})\n\
+@deftypefnx {} {} all (@var{x}, @var{dim})\n\
 For a vector argument, return true (logical 1) if all elements of the vector\n\
 are nonzero.\n\
 \n\
 For a matrix argument, return a row vector of logical ones and\n\
 zeros with each element indicating whether all of the elements of the\n\
 corresponding column of the matrix are nonzero.  For example:\n\
 \n\
 @example\n\
@@ -150,18 +150,18 @@ If the optional argument @var{dim} is su
 %! assert (all (x, 2) == [0; 1; 1]);
 
 %!error all ()
 %!error all (1, 2, 3)
 */
 
 DEFUN (any, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} any (@var{x})\n\
-@deftypefnx {Built-in Function} {} any (@var{x}, @var{dim})\n\
+@deftypefn  {} {} any (@var{x})\n\
+@deftypefnx {} {} any (@var{x}, @var{dim})\n\
 For a vector argument, return true (logical 1) if any element of the vector\n\
 is nonzero.\n\
 \n\
 For a matrix argument, return a row vector of logical ones and\n\
 zeros with each element indicating whether any of the elements of the\n\
 corresponding column of the matrix are nonzero.  For example:\n\
 \n\
 @example\n\
@@ -206,17 +206,17 @@ any (eye (2, 4), 2)\n\
 %!error any ()
 %!error any (1, 2, 3)
 */
 
 // These mapping functions may also be useful in other places, eh?
 
 DEFUN (atan2, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} atan2 (@var{y}, @var{x})\n\
+@deftypefn {} {} atan2 (@var{y}, @var{x})\n\
 Compute atan (@var{y} / @var{x}) for corresponding elements of @var{y}\n\
 and @var{x}.\n\
 \n\
 @var{y} and @var{x} must match in size and orientation.\n\
 @seealso{tan, tand, tanh, atanh}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -372,18 +372,18 @@ do_hypot (const octave_value& x, const o
         }
     }
 
   return retval;
 }
 
 DEFUN (hypot, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} hypot (@var{x}, @var{y})\n\
-@deftypefnx {Built-in Function} {} hypot (@var{x}, @var{y}, @var{z}, @dots{})\n\
+@deftypefn  {} {} hypot (@var{x}, @var{y})\n\
+@deftypefnx {} {} hypot (@var{x}, @var{y}, @var{z}, @dots{})\n\
 Compute the element-by-element square root of the sum of the squares of\n\
 @var{x} and @var{y}.\n\
 \n\
 This is equivalent to\n\
 @code{sqrt (@var{x}.^2 + @var{y}.^2)}, but is calculated in a manner that\n\
 avoids overflows for large values of @var{x} or @var{y}.\n\
 \n\
 @code{hypot} can also be called with more than 2 arguments; in this case,\n\
@@ -467,18 +467,18 @@ map_2_xlog2 (const Array<T>& x, Array<T>
       int exp;
       f.xelem (i) = xlog2 (x(i), exp);
       e.xelem (i) = exp;
     }
 }
 
 DEFUN (log2, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Mapping Function} {} log2 (@var{x})\n\
-@deftypefnx {Mapping Function} {[@var{f}, @var{e}] =} log2 (@var{x})\n\
+@deftypefn  {} {} log2 (@var{x})\n\
+@deftypefnx {} {[@var{f}, @var{e}] =} log2 (@var{x})\n\
 Compute the base-2 logarithm of each element of @var{x}.\n\
 \n\
 If called with two output arguments, split @var{x} into\n\
 binary mantissa and exponent so that\n\
 @tex\n\
 ${1 \\over 2} \\le \\left| f \\right| < 1$\n\
 @end tex\n\
 @ifnottex\n\
@@ -568,17 +568,17 @@ and @var{e} is an integer.  If\n\
 %! assert (e(1:2,:), [0,1; 2,3]);
 
 # bug #42583
 %!assert (all (log2 (pow2 (-1074:1023)) == -1074:1023))
 */
 
 DEFUN (rem, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} rem (@var{x}, @var{y})\n\
+@deftypefn {} {} rem (@var{x}, @var{y})\n\
 Return the remainder of the division @code{@var{x} / @var{y}}.\n\
 \n\
 The remainder is computed using the expression\n\
 \n\
 @example\n\
 x - y .* fix (x ./ y)\n\
 @end example\n\
 \n\
@@ -745,17 +745,17 @@ periodic, @code{mod} is a better choice.
 %!error rem ()
 %!error rem (1, 2, 3)
 %!error rem ([1, 2], [3, 4, 5])
 %!error rem (i, 1)
 */
 
 DEFUN (mod, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} mod (@var{x}, @var{y})\n\
+@deftypefn {} {} mod (@var{x}, @var{y})\n\
 Compute the modulo of @var{x} and @var{y}.\n\
 \n\
 Conceptually this is given by\n\
 \n\
 @example\n\
 x - y .* floor (x ./ y)\n\
 @end example\n\
 \n\
@@ -1146,18 +1146,18 @@ negative numbers or when the values are 
     } \
   else \
     error (#FCN ": invalid dimension argument = %d", dim + 1); \
  \
   return retval
 
 DEFUN (cumprod, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} cumprod (@var{x})\n\
-@deftypefnx {Built-in Function} {} cumprod (@var{x}, @var{dim})\n\
+@deftypefn  {} {} cumprod (@var{x})\n\
+@deftypefnx {} {} cumprod (@var{x}, @var{dim})\n\
 Cumulative product of elements along dimension @var{dim}.\n\
 \n\
 If @var{dim} is omitted, it defaults to the first non-singleton dimension.\n\
 @seealso{prod, cumsum}\n\
 @end deftypefn")
 {
   DATA_REDUCTION (cumprod);
 }
@@ -1179,21 +1179,21 @@ If @var{dim} is omitted, it defaults to 
 %!assert (cumprod (single ([2, 3; 4, 5]), 1), single ([2, 3; 8, 15]))
 %!assert (cumprod (single ([2, 3; 4, 5]), 2), single ([2, 6; 4, 20]))
 
 %!error cumprod ()
 */
 
 DEFUN (cumsum, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} cumsum (@var{x})\n\
-@deftypefnx {Built-in Function} {} cumsum (@var{x}, @var{dim})\n\
-@deftypefnx {Built-in Function} {} cumsum (@dots{}, \"native\")\n\
-@deftypefnx {Built-in Function} {} cumsum (@dots{}, \"double\")\n\
-@deftypefnx {Built-in Function} {} cumsum (@dots{}, \"extra\")\n\
+@deftypefn  {} {} cumsum (@var{x})\n\
+@deftypefnx {} {} cumsum (@var{x}, @var{dim})\n\
+@deftypefnx {} {} cumsum (@dots{}, \"native\")\n\
+@deftypefnx {} {} cumsum (@dots{}, \"double\")\n\
+@deftypefnx {} {} cumsum (@dots{}, \"extra\")\n\
 Cumulative sum of elements along dimension @var{dim}.\n\
 \n\
 If @var{dim} is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
 See @code{sum} for an explanation of the optional parameters\n\
 @qcode{\"native\"}, @qcode{\"double\"}, and @qcode{\"extra\"}.\n\
 @seealso{sum, cumprod}\n\
 @end deftypefn")
@@ -1320,21 +1320,21 @@ See @code{sum} for an explanation of the
 %!assert (cumsum (single ([1, 2; 3, 4]), 1), single ([1, 2; 4, 6]))
 %!assert (cumsum (single ([1, 2; 3, 4]), 2), single ([1, 3; 3, 7]))
 
 %!error cumsum ()
 */
 
 DEFUN (diag, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{M} =} diag (@var{v})\n\
-@deftypefnx {Built-in Function} {@var{M} =} diag (@var{v}, @var{k})\n\
-@deftypefnx {Built-in Function} {@var{M} =} diag (@var{v}, @var{m}, @var{n})\n\
-@deftypefnx {Built-in Function} {@var{v} =} diag (@var{M})\n\
-@deftypefnx {Built-in Function} {@var{v} =} diag (@var{M}, @var{k})\n\
+@deftypefn  {} {@var{M} =} diag (@var{v})\n\
+@deftypefnx {} {@var{M} =} diag (@var{v}, @var{k})\n\
+@deftypefnx {} {@var{M} =} diag (@var{v}, @var{m}, @var{n})\n\
+@deftypefnx {} {@var{v} =} diag (@var{M})\n\
+@deftypefnx {} {@var{v} =} diag (@var{M}, @var{k})\n\
 Return a diagonal matrix with vector @var{v} on diagonal @var{k}.\n\
 \n\
 The second argument is optional.  If it is positive, the vector is placed on\n\
 the @var{k}-th superdiagonal.  If it is negative, it is placed on the\n\
 @var{-k}-th subdiagonal.  The default value of @var{k} is 0, and the vector\n\
 is placed on the main diagonal.  For example:\n\
 \n\
 @example\n\
@@ -1452,20 +1452,20 @@ Given a matrix argument, instead of a ve
 %!assert (diag ([1, 2], 3, 3), diag ([1, 2, 0]))
 %!assert (diag ([1, 2]*i, 3, 3), diag ([1, 2, 0]*i))
 %!assert (diag (single ([1, 2]), 3, 3), diag (single ([1, 2, 0])))
 %!assert (diag (single ([1, 2]*i), 3, 3), diag (single ([1, 2, 0]*i)))
 */
 
 DEFUN (prod, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} prod (@var{x})\n\
-@deftypefnx {Built-in Function} {} prod (@var{x}, @var{dim})\n\
-@deftypefnx {Built-in Function} {} prod (@dots{}, \"native\")\n\
-@deftypefnx {Built-in Function} {} prod (@dots{}, \"double\")\n\
+@deftypefn  {} {} prod (@var{x})\n\
+@deftypefnx {} {} prod (@var{x}, @var{dim})\n\
+@deftypefnx {} {} prod (@dots{}, \"native\")\n\
+@deftypefnx {} {} prod (@dots{}, \"double\")\n\
 Product of elements along dimension @var{dim}.\n\
 \n\
 If @var{dim} is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
 The optional @qcode{\"type\"} input determines the class of the variable\n\
 used for calculations.  If the argument @qcode{\"native\"} is given, then\n\
 the operation is performed in the same type as the original argument, rather\n\
 than the default double type.\n\
@@ -2116,17 +2116,17 @@ do_cat (const octave_value_list& xargs, 
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (horzcat, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} horzcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
+@deftypefn {} {} horzcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the horizontal concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 2.\n\
 \n\
 Arrays may also be concatenated horizontally using the syntax for creating\n\
 new matrices.  For example:\n\
 \n\
 @example\n\
 @var{hcat} = [ @var{array1}, @var{array2}, @dots{} ]\n\
@@ -2326,17 +2326,17 @@ new matrices.  For example:\n\
 
 %!assert (class (horzcat (cell (1), struct ("foo", "bar"))), "cell")
 
 %!error horzcat (struct ("foo", "bar"), cell (1))
 */
 
 DEFUN (vertcat, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
+@deftypefn {} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the vertical concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 1.\n\
 \n\
 Arrays may also be concatenated vertically using the syntax for creating\n\
 new matrices.  For example:\n\
 \n\
 @example\n\
 @var{vcat} = [ @var{array1}; @var{array2}; @dots{} ]\n\
@@ -2350,17 +2350,17 @@ new matrices.  For example:\n\
 /*
 %!test
 %! c = {"foo"; "bar"; "bazoloa"};
 %! assert (vertcat (c, "a", "bc", "def"), {"foo"; "bar"; "bazoloa"; "a"; "bc"; "def"});
 */
 
 DEFUN (cat, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} cat (@var{dim}, @var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
+@deftypefn {} {} cat (@var{dim}, @var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension @var{dim}.\n\
 \n\
 @example\n\
 @group\n\
 A = ones (2, 2);\n\
 B = zeros (2, 2);\n\
 cat (2, A, B)\n\
@@ -2569,17 +2569,17 @@ do_permute (const octave_value_list& arg
   for (int i = 0; i < n; i++)
     vec(i)--;
 
   return octave_value (args(0).permute (vec, inv));
 }
 
 DEFUN (permute, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} permute (@var{A}, @var{perm})\n\
+@deftypefn {} {} permute (@var{A}, @var{perm})\n\
 Return the generalized transpose for an N-D array object @var{A}.\n\
 \n\
 The permutation vector @var{perm} must contain the elements\n\
 @w{@code{1:ndims (A)}} (in any order, but each element must appear only\n\
 once).  The @var{N}th dimension of @var{A} gets remapped to dimension\n\
 @code{@var{PERM}(@var{N})}.  For example:\n\
 \n\
 @example\n\
@@ -2602,17 +2602,17 @@ size (permute (@var{x}, [1, 2, 3, 4]))\n
 @seealso{ipermute}\n\
 @end deftypefn")
 {
   return do_permute (args, false);
 }
 
 DEFUN (ipermute, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ipermute (@var{A}, @var{iperm})\n\
+@deftypefn {} {} ipermute (@var{A}, @var{iperm})\n\
 The inverse of the @code{permute} function.\n\
 \n\
 The expression\n\
 \n\
 @example\n\
 ipermute (permute (A, perm), perm)\n\
 @end example\n\
 \n\
@@ -2621,17 +2621,17 @@ returns the original array @var{A}.\n\
 @seealso{permute}\n\
 @end deftypefn")
 {
   return do_permute (args, true);
 }
 
 DEFUN (length, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} length (@var{a})\n\
+@deftypefn {} {} length (@var{a})\n\
 Return the length of the object @var{a}.\n\
 \n\
 The length is 0 for empty objects, 1 for scalars, and the number of elements\n\
 for vectors.  For matrix or N-dimensional objects, the length is the number\n\
 of elements along the largest dimension\n\
 (equivalent to @w{@code{max (size (@var{a}))}}).\n\
 @seealso{numel, size}\n\
 @end deftypefn")
@@ -2639,17 +2639,17 @@ of elements along the largest dimension\
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).length ());
 }
 
 DEFUN (ndims, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ndims (@var{a})\n\
+@deftypefn {} {} ndims (@var{a})\n\
 Return the number of dimensions of @var{a}.\n\
 \n\
 For any array, the result will always be greater than or equal to 2.\n\
 Trailing singleton dimensions are not counted.\n\
 \n\
 @example\n\
 @group\n\
 ndims (ones (4, 1, 2, 1))\n\
@@ -2662,18 +2662,18 @@ ndims (ones (4, 1, 2, 1))\n\
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).ndims ());
 }
 
 DEFUN (numel, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} numel (@var{a})\n\
-@deftypefnx {Built-in Function} {} numel (@var{a}, @var{idx1}, @var{idx2}, @dots{})\n\
+@deftypefn  {} {} numel (@var{a})\n\
+@deftypefnx {} {} numel (@var{a}, @var{idx1}, @var{idx2}, @dots{})\n\
 Return the number of elements in the object @var{a}.\n\
 \n\
 Optionally, if indices @var{idx1}, @var{idx2}, @dots{} are supplied,\n\
 return the number of elements that would result from the indexing\n\
 \n\
 @example\n\
 @var{a}(@var{idx1}, @var{idx2}, @dots{})\n\
 @end example\n\
@@ -2724,18 +2724,18 @@ indexing, i.e., @code{object@{@dots{}@}}
       retval = dims_to_numel (args(0).dims (), args.slice (1, nargin-1));
     }
 
   return retval;
 }
 
 DEFUN (size, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} size (@var{a})\n\
-@deftypefnx {Built-in Function} {} size (@var{a}, @var{dim})\n\
+@deftypefn  {} {} size (@var{a})\n\
+@deftypefnx {} {} size (@var{a}, @var{dim})\n\
 Return the number of rows and columns of @var{a}.\n\
 \n\
 With one input argument and one output argument, the result is returned\n\
 in a row vector.  If there are multiple output arguments, the number of\n\
 rows is assigned to the first, and the number of columns to the second,\n\
 etc.  For example:\n\
 \n\
 @example\n\
@@ -2810,17 +2810,17 @@ returns the number of columns in the giv
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (size_equal, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} size_equal (@var{a}, @var{b}, @dots{})\n\
+@deftypefn {} {} size_equal (@var{a}, @var{b}, @dots{})\n\
 Return true if the dimensions of all arguments agree.\n\
 \n\
 Trailing singleton dimensions are ignored.\n\
 When called with a single or no argument @code{size_equal} returns true.\n\
 @seealso{size, numel, ndims}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -2845,47 +2845,47 @@ When called with a single or no argument
         }
     }
 
   return retval;
 }
 
 DEFUN (nnz, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{n} =} nnz (@var{a})\n\
+@deftypefn {} {@var{n} =} nnz (@var{a})\n\
 Return the number of nonzero elements in @var{a}.\n\
 @seealso{nzmax, nonzeros, find}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).nnz ());
 }
 
 DEFUN (nzmax, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{n} =} nzmax (@var{SM})\n\
+@deftypefn {} {@var{n} =} nzmax (@var{SM})\n\
 Return the amount of storage allocated to the sparse matrix @var{SM}.\n\
 \n\
 Note that Octave tends to crop unused memory at the first opportunity\n\
 for sparse objects.  Thus, in general the value of @code{nzmax} will be the\n\
 same as @code{nnz} except for some cases of user-created sparse objects.\n\
 @seealso{nnz, spalloc, sparse}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).nzmax ());
 }
 
 DEFUN (rows, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} rows (@var{a})\n\
+@deftypefn {} {} rows (@var{a})\n\
 Return the number of rows of @var{a}.\n\
 @seealso{columns, size, length, numel, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).rows ());
@@ -2915,34 +2915,34 @@ Return the number of rows of @var{a}.\n\
 
 ## Test input validation
 %!error rows ()
 %!error rows (1,2)
 */
 
 DEFUN (columns, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} columns (@var{a})\n\
+@deftypefn {} {} columns (@var{a})\n\
 Return the number of columns of @var{a}.\n\
 @seealso{rows, size, length, numel, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).columns ());
 }
 
 DEFUN (sum, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} sum (@var{x})\n\
-@deftypefnx {Built-in Function} {} sum (@var{x}, @var{dim})\n\
-@deftypefnx {Built-in Function} {} sum (@dots{}, \"native\")\n\
-@deftypefnx {Built-in Function} {} sum (@dots{}, \"double\")\n\
-@deftypefnx {Built-in Function} {} sum (@dots{}, \"extra\")\n\
+@deftypefn  {} {} sum (@var{x})\n\
+@deftypefnx {} {} sum (@var{x}, @var{dim})\n\
+@deftypefnx {} {} sum (@dots{}, \"native\")\n\
+@deftypefnx {} {} sum (@dots{}, \"double\")\n\
+@deftypefnx {} {} sum (@dots{}, \"extra\")\n\
 Sum of elements along dimension @var{dim}.\n\
 \n\
 If @var{dim} is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
 The optional @qcode{\"type\"} input determines the class of the variable\n\
 used for calculations.  If the argument @qcode{\"native\"} is given, then\n\
 the operation is performed in the same type as the original argument, rather\n\
 than the default double type.\n\
@@ -3156,18 +3156,18 @@ inputs, @qcode{\"extra\"} is the same as
 
 %!error sum ()
 %!error sum (1,2,3)
 %!error <unrecognized type argument 'foobar'> sum (1, "foobar")
 */
 
 DEFUN (sumsq, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} sumsq (@var{x})\n\
-@deftypefnx {Built-in Function} {} sumsq (@var{x}, @var{dim})\n\
+@deftypefn  {} {} sumsq (@var{x})\n\
+@deftypefnx {} {} sumsq (@var{x}, @var{dim})\n\
 Sum of squares of elements along dimension @var{dim}.\n\
 \n\
 If @var{dim} is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
 This function is conceptually equivalent to computing\n\
 \n\
 @example\n\
 sum (x .* conj (x), dim)\n\
@@ -3196,18 +3196,18 @@ but it uses less memory and avoids calli
 %!assert (sumsq (single ([1, 2; 3, 4]), 1), single ([10, 20]))
 %!assert (sumsq (single ([1, 2; 3, 4]), 2), single ([5; 25]))
 
 %!error sumsq ()
 */
 
 DEFUN (islogical, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} islogical (@var{x})\n\
-@deftypefnx {Built-in Function} {} isbool (@var{x})\n\
+@deftypefn  {} {} islogical (@var{x})\n\
+@deftypefnx {} {} isbool (@var{x})\n\
 Return true if @var{x} is a logical object.\n\
 @seealso{isfloat, isinteger, ischar, isnumeric, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_bool_type ());
@@ -3226,46 +3226,46 @@ DEFALIAS (isbool, islogical);
 %!assert (islogical (single (1i)), false)
 %!assert (islogical (single ([1,1])), false)
 %!assert (islogical (sparse ([true, false])), true)
 %!assert (islogical (sparse ([1, 0])), false)
 */
 
 DEFUN (isinteger, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isinteger (@var{x})\n\
+@deftypefn {} {} isinteger (@var{x})\n\
 Return true if @var{x} is an integer object (int8, uint8, int16, etc.).\n\
 \n\
 Note that @w{@code{isinteger (14)}} is false because numeric constants in\n\
 Octave are double precision floating point values.\n\
 @seealso{isfloat, ischar, islogical, isnumeric, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_integer_type ());
 }
 
 DEFUN (iscomplex, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} iscomplex (@var{x})\n\
+@deftypefn {} {} iscomplex (@var{x})\n\
 Return true if @var{x} is a complex-valued numeric object.\n\
 @seealso{isreal, isnumeric, islogical, ischar, isfloat, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_complex_type ());
 }
 
 DEFUN (isfloat, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isfloat (@var{x})\n\
+@deftypefn {} {} isfloat (@var{x})\n\
 Return true if @var{x} is a floating-point numeric object.\n\
 \n\
 Objects of class double or single are floating-point objects.\n\
 @seealso{isinteger, ischar, islogical, isnumeric, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
@@ -3273,18 +3273,18 @@ Objects of class double or single are fl
   return octave_value (args(0).is_float_type ());
 }
 
 // FIXME: perhaps this should be implemented with an
 // octave_value member function?
 
 DEFUN (complex, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} complex (@var{x})\n\
-@deftypefnx {Built-in Function} {} complex (@var{re}, @var{im})\n\
+@deftypefn  {} {} complex (@var{x})\n\
+@deftypefnx {} {} complex (@var{re}, @var{im})\n\
 Return a complex value from real arguments.\n\
 \n\
 With 1 real argument @var{x}, return the complex result\n\
 @w{@code{@var{x} + 0i}}.\n\
 \n\
 With 2 real arguments, return the complex result\n\
 @w{@code{@var{re} + @var{im}}}.\n\
 @code{complex} can often be more convenient than expressions such as\n\
@@ -3545,33 +3545,33 @@ complex ([1, 2], [3, 4])\n\
         }
     }
 
   return retval;
 }
 
 DEFUN (isreal, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isreal (@var{x})\n\
+@deftypefn {} {} isreal (@var{x})\n\
 Return true if @var{x} is a non-complex matrix or scalar.\n\
 \n\
 For compatibility with @sc{matlab}, this includes logical and character\n\
 matrices.\n\
 @seealso{iscomplex, isnumeric, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_real_type ());
 }
 
 DEFUN (isempty, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isempty (@var{a})\n\
+@deftypefn {} {} isempty (@var{a})\n\
 Return true if @var{a} is an empty matrix (any one of its dimensions is\n\
 zero).\n\
 @seealso{isnull, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
@@ -3580,17 +3580,17 @@ zero).\n\
 
 /*
 %% Debian bug #706376
 %!assert (isempty (speye(2^16)), false)
 */
 
 DEFUN (isnumeric, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isnumeric (@var{x})\n\
+@deftypefn {} {} isnumeric (@var{x})\n\
 Return true if @var{x} is a numeric object, i.e., an integer, real, or\n\
 complex array.\n\
 \n\
 Logical and character arrays are not considered to be numeric.\n\
 @seealso{isinteger, isfloat, isreal, iscomplex, islogical, ischar, iscell, isstruct, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
@@ -3612,17 +3612,17 @@ Logical and character arrays are not con
 %!assert (isnumeric (true), false)
 %!assert (isnumeric (false), false)
 %!assert (isnumeric ([true, false]), false)
 %!assert (isnumeric (sparse ([true, false])), false)
 */
 
 DEFUN (isscalar, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isscalar (@var{x})\n\
+@deftypefn {} {} isscalar (@var{x})\n\
 Return true if @var{x} is a scalar.\n\
 @seealso{isvector, ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).numel () == 1);
@@ -3644,17 +3644,17 @@ Return true if @var{x} is a scalar.\n\
 
 %% Test input validation
 %!error isscalar ()
 %!error isscalar (1, 2)
 */
 
 DEFUN (isvector, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {} isvector (@var{x})\n\
+@deftypefn {} {} isvector (@var{x})\n\
 Return true if @var{x} is a vector.\n\
 \n\
 A vector is a 2-D array where one of the dimensions is equal to 1.  As a\n\
 consequence a 1x1 array, or scalar, is also a vector.\n\
 @seealso{isscalar, ismatrix, size, rows, columns, length}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
@@ -3682,17 +3682,17 @@ consequence a 1x1 array, or scalar, is a
 
 %% Test input validation
 %!error isvector ()
 %!error isvector ([1, 2], 2)
 */
 
 DEFUN (isrow, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {} isrow (@var{x})\n\
+@deftypefn {} {} isrow (@var{x})\n\
 Return true if @var{x} is a row vector 1xN with non-negative N.\n\
 @seealso{iscolumn, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
@@ -3727,17 +3727,17 @@ Return true if @var{x} is a row vector 1
 
 %% Test input validation
 %!error isrow ()
 %!error isrow ([1, 2], 2)
 */
 
 DEFUN (iscolumn, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {} iscolumn (@var{x})\n\
+@deftypefn {} {} iscolumn (@var{x})\n\
 Return true if @var{x} is a column vector Nx1 with non-negative N.\n\
 @seealso{isrow, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
@@ -3771,17 +3771,17 @@ Return true if @var{x} is a column vecto
 
 %% Test input validation
 %!error iscolumn ()
 %!error iscolumn ([1, 2], 2)
 */
 
 DEFUN (ismatrix, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ismatrix (@var{a})\n\
+@deftypefn {} {} ismatrix (@var{a})\n\
 Return true if @var{a} is a 2-D array.\n\
 @seealso{isscalar, isvector, iscell, isstruct, issparse, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
@@ -3814,17 +3814,17 @@ Return true if @var{a} is a 2-D array.\n
 %! assert (ismatrix (s), true);
 
 %!error ismatrix ()
 %!error ismatrix ([1, 2; 3, 4], 2)
 */
 
 DEFUN (issquare, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {} issquare (@var{x})\n\
+@deftypefn {} {} issquare (@var{x})\n\
 Return true if @var{x} is a square matrix.\n\
 @seealso{isscalar, isvector, ismatrix, size}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
@@ -4195,21 +4195,21 @@ fill_matrix (const octave_value_list& ar
 
   retval = boolNDArray (dims, val);
 
   return retval;
 }
 
 DEFUN (ones, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} ones (@var{n})\n\
-@deftypefnx {Built-in Function} {} ones (@var{m}, @var{n})\n\
-@deftypefnx {Built-in Function} {} ones (@var{m}, @var{n}, @var{k}, @dots{})\n\
-@deftypefnx {Built-in Function} {} ones ([@var{m} @var{n} @dots{}])\n\
-@deftypefnx {Built-in Function} {} ones (@dots{}, @var{class})\n\
+@deftypefn  {} {} ones (@var{n})\n\
+@deftypefnx {} {} ones (@var{m}, @var{n})\n\
+@deftypefnx {} {} ones (@var{m}, @var{n}, @var{k}, @dots{})\n\
+@deftypefnx {} {} ones ([@var{m} @var{n} @dots{}])\n\
+@deftypefnx {} {} ones (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all 1.\n\
 \n\
 If invoked with a single scalar integer argument @var{n}, return a square\n\
 @nospell{NxN} matrix.\n\
 \n\
 If invoked with two or more scalar integer arguments, or a vector of integer\n\
 values, return an array with the given dimensions.\n\
 \n\
@@ -4246,21 +4246,21 @@ val = ones (m,n, \"uint8\")\n\
 %!assert (ones (3, "int8"), int8 ([1, 1, 1; 1, 1, 1; 1, 1, 1]))
 %!assert (ones (2, 3, "int8"), int8 ([1, 1, 1; 1, 1, 1]))
 %!assert (ones (3, 2, "int8"), int8 ([1, 1; 1, 1; 1, 1]))
 %!assert (size (ones (3, 4, 5, "int8")), [3, 4, 5])
 */
 
 DEFUN (zeros, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} zeros (@var{n})\n\
-@deftypefnx {Built-in Function} {} zeros (@var{m}, @var{n})\n\
-@deftypefnx {Built-in Function} {} zeros (@var{m}, @var{n}, @var{k}, @dots{})\n\
-@deftypefnx {Built-in Function} {} zeros ([@var{m} @var{n} @dots{}])\n\
-@deftypefnx {Built-in Function} {} zeros (@dots{}, @var{class})\n\
+@deftypefn  {} {} zeros (@var{n})\n\
+@deftypefnx {} {} zeros (@var{m}, @var{n})\n\
+@deftypefnx {} {} zeros (@var{m}, @var{n}, @var{k}, @dots{})\n\
+@deftypefnx {} {} zeros ([@var{m} @var{n} @dots{}])\n\
+@deftypefnx {} {} zeros (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all 0.\n\
 \n\
 If invoked with a single scalar integer argument, return a square\n\
 @nospell{NxN} matrix.\n\
 \n\
 If invoked with two or more scalar integer arguments, or a vector of integer\n\
 values, return an array with the given dimensions.\n\
 \n\
@@ -4293,21 +4293,21 @@ val = zeros (m,n, \"uint8\")\n\
 %!assert (size (zeros (3, 4, 5, "int8")), [3, 4, 5])
 */
 
 DEFUN (Inf, args, ,
        "-*- texinfo -*-\n\
 @c List other form of function in documentation index\n\
 @findex inf\n\
 \n\
-@deftypefn  {Built-in Function} {} Inf\n\
-@deftypefnx {Built-in Function} {} Inf (@var{n})\n\
-@deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m}, @var{k}, @dots{})\n\
-@deftypefnx {Built-in Function} {} Inf (@dots{}, @var{class})\n\
+@deftypefn  {} {} Inf\n\
+@deftypefnx {} {} Inf (@var{n})\n\
+@deftypefnx {} {} Inf (@var{n}, @var{m})\n\
+@deftypefnx {} {} Inf (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefnx {} {} Inf (@dots{}, @var{class})\n\
 Return a scalar, matrix or N-dimensional array whose elements are all equal\n\
 to the IEEE representation for positive infinity.\n\
 \n\
 Infinity is produced when results are too large to be represented using the\n\
 IEEE floating point format for numbers.  Two common examples which produce\n\
 infinity are division by zero and overflow.\n\
 \n\
 @example\n\
@@ -4354,21 +4354,21 @@ DEFALIAS (inf, Inf);
 %!error (inf (3, 4, 5, "int8"))
 */
 
 DEFUN (NaN, args, ,
        "-*- texinfo -*-\n\
 @c List other form of function in documentation index\n\
 @findex nan\n\
 \n\
-@deftypefn  {Built-in Function} {} NaN\n\
-@deftypefnx {Built-in Function} {} NaN (@var{n})\n\
-@deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m}, @var{k}, @dots{})\n\
-@deftypefnx {Built-in Function} {} NaN (@dots{}, @var{class})\n\
+@deftypefn  {} {} NaN\n\
+@deftypefnx {} {} NaN (@var{n})\n\
+@deftypefnx {} {} NaN (@var{n}, @var{m})\n\
+@deftypefnx {} {} NaN (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefnx {} {} NaN (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the IEEE symbol NaN (Not a Number).\n\
 \n\
 NaN is the result of operations which do not produce a well defined numerical\n\
 result.  Common operations which produce a NaN are arithmetic with infinity\n\
 @tex\n\
 ($\\infty - \\infty$), zero divided by zero ($0/0$),\n\
 @end tex\n\
@@ -4416,21 +4416,21 @@ DEFALIAS (nan, NaN);
 %!error (NaN (3, "int8"))
 %!error (NaN (2, 3, "int8"))
 %!error (NaN (3, 2, "int8"))
 %!error (NaN (3, 4, 5, "int8"))
 */
 
 DEFUN (e, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} e\n\
-@deftypefnx {Built-in Function} {} e (@var{n})\n\
-@deftypefnx {Built-in Function} {} e (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} e (@var{n}, @var{m}, @var{k}, @dots{})\n\
-@deftypefnx {Built-in Function} {} e (@dots{}, @var{class})\n\
+@deftypefn  {} {} e\n\
+@deftypefnx {} {} e (@var{n})\n\
+@deftypefnx {} {} e (@var{n}, @var{m})\n\
+@deftypefnx {} {} e (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefnx {} {} e (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the base of natural logarithms.\n\
 \n\
 The constant\n\
 @tex\n\
 $e$ satisfies the equation $\\log (e) = 1$.\n\
 @end tex\n\
 @ifnottex\n\
@@ -4457,21 +4457,21 @@ either @qcode{\"double\"} or @qcode{\"si
   double e_val = exp (1.0);
 #endif
 
   return fill_matrix (args, e_val, "e");
 }
 
 DEFUN (eps, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} eps\n\
-@deftypefnx {Built-in Function} {} eps (@var{x})\n\
-@deftypefnx {Built-in Function} {} eps (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} eps (@var{n}, @var{m}, @var{k}, @dots{})\n\
-@deftypefnx {Built-in Function} {} eps (@dots{}, @var{class})\n\
+@deftypefn  {} {} eps\n\
+@deftypefnx {} {} eps (@var{x})\n\
+@deftypefnx {} {} eps (@var{n}, @var{m})\n\
+@deftypefnx {} {} eps (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefnx {} {} eps (@dots{}, @var{class})\n\
 Return a scalar, matrix or N-dimensional array whose elements are all eps,\n\
 the machine precision.\n\
 \n\
 More precisely, @code{eps} is the relative spacing between any two adjacent\n\
 numbers in the machine's floating point system.  This number is obviously\n\
 system dependent.  On machines that support IEEE floating point arithmetic,\n\
 @code{eps} is approximately\n\
 @tex\n\
@@ -4578,21 +4578,21 @@ type and may be either @qcode{\"double\"
 %!assert (eps (single (NaN)), single (NaN))
 %!assert (eps (single ([1/2 1 2 realmax("single") 0 realmin("single")/2 realmin("single")/16 Inf NaN])),
 %!             single ([2^(-24) 2^(-23) 2^(-22) 2^104 2^(-149) 2^(-149) 2^(-149) NaN NaN]))
 
 */
 
 DEFUN (pi, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} pi\n\
-@deftypefnx {Built-in Function} {} pi (@var{n})\n\
-@deftypefnx {Built-in Function} {} pi (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} pi (@var{n}, @var{m}, @var{k}, @dots{})\n\
-@deftypefnx {Built-in Function} {} pi (@dots{}, @var{class})\n\
+@deftypefn  {} {} pi\n\
+@deftypefnx {} {} pi (@var{n})\n\
+@deftypefnx {} {} pi (@var{n}, @var{m})\n\
+@deftypefnx {} {} pi (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefnx {} {} pi (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the ratio of the circumference of a circle to its\n\
 @tex\n\
 diameter($\\pi$).\n\
 @end tex\n\
 @ifnottex\n\
 diameter.\n\
 @end ifnottex\n\
@@ -4625,21 +4625,21 @@ either @qcode{\"double\"} or @qcode{\"si
   double pi_val = 4.0 * atan (1.0);
 #endif
 
   return fill_matrix (args, pi_val, "pi");
 }
 
 DEFUN (realmax, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} realmax\n\
-@deftypefnx {Built-in Function} {} realmax (@var{n})\n\
-@deftypefnx {Built-in Function} {} realmax (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} realmax (@var{n}, @var{m}, @var{k}, @dots{})\n\
-@deftypefnx {Built-in Function} {} realmax (@dots{}, @var{class})\n\
+@deftypefn  {} {} realmax\n\
+@deftypefnx {} {} realmax (@var{n})\n\
+@deftypefnx {} {} realmax (@var{n}, @var{m})\n\
+@deftypefnx {} {} realmax (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefnx {} {} realmax (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the largest floating point number that is representable.\n\
 \n\
 The actual value is system dependent.  On machines that support IEEE\n\
 floating point arithmetic, @code{realmax} is approximately\n\
 @tex\n\
 $1.7977\\times10^{308}$ for double precision and $3.4028\\times10^{38}$\n\
 @end tex\n\
@@ -4664,21 +4664,21 @@ either @qcode{\"double\"} or @qcode{\"si
 @end deftypefn")
 {
   return fill_matrix (args, std::numeric_limits<double>::max (),
                       std::numeric_limits<float>::max (), "realmax");
 }
 
 DEFUN (realmin, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} realmin\n\
-@deftypefnx {Built-in Function} {} realmin (@var{n})\n\
-@deftypefnx {Built-in Function} {} realmin (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} realmin (@var{n}, @var{m}, @var{k}, @dots{})\n\
-@deftypefnx {Built-in Function} {} realmin (@dots{}, @var{class})\n\
+@deftypefn  {} {} realmin\n\
+@deftypefnx {} {} realmin (@var{n})\n\
+@deftypefnx {} {} realmin (@var{n}, @var{m})\n\
+@deftypefnx {} {} realmin (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefnx {} {} realmin (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the smallest normalized floating point number that is representable.\n\
 \n\
 The actual value is system dependent.  On machines that support\n\
 IEEE floating point arithmetic, @code{realmin} is approximately\n\
 @tex\n\
 $2.2251\\times10^{-308}$ for double precision and $1.1755\\times10^{-38}$\n\
 @end tex\n\
@@ -4708,21 +4708,21 @@ either @qcode{\"double\"} or @qcode{\"si
 
 DEFUN (I, args, ,
        "-*- texinfo -*-\n\
 @c List other forms of function in documentation index\n\
 @findex i\n\
 @findex j\n\
 @findex J\n\
 \n\
-@deftypefn  {Built-in Function} {} I\n\
-@deftypefnx {Built-in Function} {} I (@var{n})\n\
-@deftypefnx {Built-in Function} {} I (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} I (@var{n}, @var{m}, @var{k}, @dots{})\n\
-@deftypefnx {Built-in Function} {} I (@dots{}, @var{class})\n\
+@deftypefn  {} {} I\n\
+@deftypefnx {} {} I (@var{n})\n\
+@deftypefnx {} {} I (@var{n}, @var{m})\n\
+@deftypefnx {} {} I (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefnx {} {} I (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the pure imaginary unit, defined as\n\
 @tex\n\
 $\\sqrt{-1}$.\n\
 @end tex\n\
 @ifnottex\n\
 @w{@code{sqrt (-1)}}.\n\
 @end ifnottex\n\
@@ -4748,21 +4748,21 @@ either @qcode{\"double\"} or @qcode{\"si
 }
 
 DEFALIAS (i, I);
 DEFALIAS (J, I);
 DEFALIAS (j, I);
 
 DEFUN (NA, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} NA\n\
-@deftypefnx {Built-in Function} {} NA (@var{n})\n\
-@deftypefnx {Built-in Function} {} NA (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} NA (@var{n}, @var{m}, @var{k}, @dots{})\n\
-@deftypefnx {Built-in Function} {} NA (@dots{}, @var{class})\n\
+@deftypefn  {} {} NA\n\
+@deftypefnx {} {} NA (@var{n})\n\
+@deftypefnx {} {} NA (@var{n}, @var{m})\n\
+@deftypefnx {} {} NA (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefnx {} {} NA (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the special constant used to designate missing values.\n\
 \n\
 Note that NA always compares not equal to NA (NA != NA).\n\
 To find NA values, use the @code{isna} function.\n\
 \n\
 When called with no arguments, return a scalar with the value @samp{NA}.\n\
 \n\
@@ -4784,37 +4784,37 @@ either @qcode{\"double\"} or @qcode{\"si
 
 /*
 %!assert (single (NA ("double")), NA ("single"))
 %!assert (double (NA ("single")), NA ("double"))
 */
 
 DEFUN (false, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} false (@var{x})\n\
-@deftypefnx {Built-in Function} {} false (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} false (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefn  {} {} false (@var{x})\n\
+@deftypefnx {} {} false (@var{n}, @var{m})\n\
+@deftypefnx {} {} false (@var{n}, @var{m}, @var{k}, @dots{})\n\
 Return a matrix or N-dimensional array whose elements are all logical 0.\n\
 \n\
 If invoked with a single scalar integer argument, return a square\n\
 matrix of the specified size.\n\
 \n\
 If invoked with two or more scalar integer arguments, or a vector of integer\n\
 values, return an array with given dimensions.\n\
 @seealso{true}\n\
 @end deftypefn")
 {
   return fill_matrix (args, false, "false");
 }
 
 DEFUN (true, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} true (@var{x})\n\
-@deftypefnx {Built-in Function} {} true (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} true (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefn  {} {} true (@var{x})\n\
+@deftypefnx {} {} true (@var{n}, @var{m})\n\
+@deftypefnx {} {} true (@var{n}, @var{m}, @var{k}, @dots{})\n\
 Return a matrix or N-dimensional array whose elements are all logical 1.\n\
 \n\
 If invoked with a single scalar integer argument, return a square\n\
 matrix of the specified size.\n\
 \n\
 If invoked with two or more scalar integer arguments, or a vector of integer\n\
 values, return an array with given dimensions.\n\
 @seealso{false}\n\
@@ -4932,20 +4932,20 @@ identity_matrix (int nr, int nc, oct_dat
 
   return retval;
 }
 
 #undef INT_EYE_MATRIX
 
 DEFUN (eye, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} eye (@var{n})\n\
-@deftypefnx {Built-in Function} {} eye (@var{m}, @var{n})\n\
-@deftypefnx {Built-in Function} {} eye ([@var{m} @var{n}])\n\
-@deftypefnx {Built-in Function} {} eye (@dots{}, @var{class})\n\
+@deftypefn  {} {} eye (@var{n})\n\
+@deftypefnx {} {} eye (@var{m}, @var{n})\n\
+@deftypefnx {} {} eye ([@var{m} @var{n}])\n\
+@deftypefnx {} {} eye (@dots{}, @var{class})\n\
 Return an identity matrix.\n\
 \n\
 If invoked with a single scalar argument @var{n}, return a square\n\
 @nospell{NxN} identity matrix.\n\
 \n\
 If supplied two scalar arguments (@var{m}, @var{n}), @code{eye} takes them\n\
 to be the number of rows and columns.  If given a vector with two elements,\n\
 @code{eye} uses the values of the elements as the number of rows and\n\
@@ -5078,18 +5078,18 @@ do_linspace (const octave_value& base, c
         }
     }
 
   return retval;
 }
 
 DEFUN (linspace, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} linspace (@var{base}, @var{limit})\n\
-@deftypefnx {Built-in Function} {} linspace (@var{base}, @var{limit}, @var{n})\n\
+@deftypefn  {} {} linspace (@var{base}, @var{limit})\n\
+@deftypefnx {} {} linspace (@var{base}, @var{limit}, @var{n})\n\
 Return a row vector with @var{n} linearly spaced elements between\n\
 @var{base} and @var{limit}.\n\
 \n\
 If the number of elements is greater than one, then the endpoints @var{base}\n\
 and @var{limit} are always included in the range.  If @var{base} is greater\n\
 than @var{limit}, the elements are stored in decreasing order.  If the\n\
 number of points is not specified, a value of 100 is used.\n\
 \n\
@@ -5212,19 +5212,19 @@ if fewer than two values are requested.\
 %!error <must be scalars or vectors> linspace (1, [], 3)
 */
 
 // FIXME: should accept dimensions as separate args for N-D
 // arrays as well as 1-D and 2-D arrays.
 
 DEFUN (resize, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} resize (@var{x}, @var{m})\n\
-@deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n}, @dots{})\n\
-@deftypefnx {Built-in Function} {} resize (@var{x}, [@var{m} @var{n} @dots{}])\n\
+@deftypefn  {} {} resize (@var{x}, @var{m})\n\
+@deftypefnx {} {} resize (@var{x}, @var{m}, @var{n}, @dots{})\n\
+@deftypefnx {} {} resize (@var{x}, [@var{m} @var{n} @dots{}])\n\
 Resize @var{x} cutting off elements as necessary.\n\
 \n\
 In the result, element with certain indices is equal to the corresponding\n\
 element of @var{x} if the indices are within the bounds of @var{x};\n\
 otherwise, the element is set to zero.\n\
 \n\
 In other words, the statement\n\
 \n\
@@ -5302,20 +5302,20 @@ Resizing an object to fewer dimensions i
 
   return retval;
 }
 
 // FIXME: should use octave_idx_type for dimensions.
 
 DEFUN (reshape, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} reshape (@var{A}, @var{m}, @var{n}, @dots{})\n\
-@deftypefnx {Built-in Function} {} reshape (@var{A}, [@var{m} @var{n} @dots{}])\n\
-@deftypefnx {Built-in Function} {} reshape (@var{A}, @dots{}, [], @dots{})\n\
-@deftypefnx {Built-in Function} {} reshape (@var{A}, @var{size})\n\
+@deftypefn  {} {} reshape (@var{A}, @var{m}, @var{n}, @dots{})\n\
+@deftypefnx {} {} reshape (@var{A}, [@var{m} @var{n} @dots{}])\n\
+@deftypefnx {} {} reshape (@var{A}, @dots{}, [], @dots{})\n\
+@deftypefnx {} {} reshape (@var{A}, @var{size})\n\
 Return a matrix with the specified dimensions (@var{m}, @var{n}, @dots{})\n\
 whose elements are taken from the matrix @var{A}.\n\
 \n\
 The elements of the matrix are accessed in column-major order (like Fortran\n\
 arrays are stored).\n\
 \n\
 The following code demonstrates reshaping a 1x4 row vector into a 2x2 square\n\
 matrix.\n\
@@ -5449,18 +5449,18 @@ the unspecified dimension.\n\
 %!error <SIZE must be non-negative> reshape (1:3, [3 -1])
 %!error <only a single dimension can be unknown> reshape (1:3, 1,[],[],3)
 %!error <SIZE must be non-negative> reshape (1:3, 3, -1)
 %!error <SIZE is not divisible> reshape (1:3, 3, [], 2)
 */
 
 DEFUN (vec, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{v} =} vec (@var{x})\n\
-@deftypefnx {Built-in Function} {@var{v} =} vec (@var{x}, @var{dim})\n\
+@deftypefn  {} {@var{v} =} vec (@var{x})\n\
+@deftypefnx {} {@var{v} =} vec (@var{x}, @var{dim})\n\
 Return the vector obtained by stacking the columns of the matrix @var{x}\n\
 one above the other.\n\
 \n\
 Without @var{dim} this is equivalent to @code{@var{x}(:)}.\n\
 \n\
 If @var{dim} is supplied, the dimensions of @var{v} are set to @var{dim}\n\
 with all elements along the last dimension.  This is equivalent to\n\
 @code{shiftdim (@var{x}(:), 1-@var{dim})}.\n\
@@ -5515,51 +5515,51 @@ with all elements along the last dimensi
 
 %!error vec ()
 %!error vec (1, 2, 3)
 %!error vec ([1, 2; 3, 4], 0)
 */
 
 DEFUN (squeeze, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} squeeze (@var{x})\n\
+@deftypefn {} {} squeeze (@var{x})\n\
 Remove singleton dimensions from @var{x} and return the result.\n\
 \n\
 Note that for compatibility with @sc{matlab}, all objects have\n\
 a minimum of two dimensions and row vectors are left unchanged.\n\
 @seealso{reshape}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).squeeze ());
 }
 
 DEFUN (full, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{FM} =} full (@var{SM})\n\
+@deftypefn {} {@var{FM} =} full (@var{SM})\n\
 Return a full storage matrix from a sparse, diagonal, or permutation matrix,\n\
 or a range.\n\
 @seealso{sparse, issparse}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).full_value ());
 }
 
 // Compute various norms of the vector X.
 
 DEFUN (norm, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} norm (@var{A})\n\
-@deftypefnx {Built-in Function} {} norm (@var{A}, @var{p})\n\
-@deftypefnx {Built-in Function} {} norm (@var{A}, @var{p}, @var{opt})\n\
+@deftypefn  {} {} norm (@var{A})\n\
+@deftypefnx {} {} norm (@var{A}, @var{p})\n\
+@deftypefnx {} {} norm (@var{A}, @var{p}, @var{opt})\n\
 Compute the p-norm of the matrix @var{A}.\n\
 \n\
 If the second argument is missing, @w{@code{p = 2}} is assumed.\n\
 \n\
 If @var{A} is a matrix (or sparse matrix):\n\
 \n\
 @table @asis\n\
 @item @var{p} = @code{1}\n\
@@ -5769,49 +5769,49 @@ unary_op_defun_body (octave_value::unary
   if (args.length () != 1)
     print_usage ();
 
   return do_unary_op (op, args(0));
 }
 
 DEFUN (not, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{z} =} not (@var{x})\n\
+@deftypefn {} {@var{z} =} not (@var{x})\n\
 Return the logical NOT of @var{x}.\n\
 \n\
 This function is equivalent to the operator syntax @w{@code{! x}}.\n\
 @seealso{and, or, xor}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_not, args);
 }
 
 DEFUN (uplus, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} uplus (@var{x})\n\
+@deftypefn {} {} uplus (@var{x})\n\
 This function and @w{@tcode{+ x}} are equivalent.\n\
 @seealso{uminus, plus, minus}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_uplus, args);
 }
 
 DEFUN (uminus, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} uminus (@var{x})\n\
+@deftypefn {} {} uminus (@var{x})\n\
 This function and @w{@tcode{- x}} are equivalent.\n\
 @seealso{uplus, minus}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_uminus, args);
 }
 
 DEFUN (transpose, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} transpose (@var{x})\n\
+@deftypefn {} {} transpose (@var{x})\n\
 Return the transpose of @var{x}.\n\
 \n\
 This function and @tcode{x.'} are equivalent.\n\
 @seealso{ctranspose}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_transpose, args);
 }
@@ -5833,17 +5833,17 @@ This function and @tcode{x.'} are equiva
 %!assert (single ([1,2;3,4]).', single ([1,3;2,4]))
 %!assert (single ([1,2i;3,4]).', single ([1,3;2i,4]))
 
 %!assert (transpose (single ([1,2;3,4])), single ([1,3;2,4]))
 */
 
 DEFUN (ctranspose, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ctranspose (@var{x})\n\
+@deftypefn {} {} ctranspose (@var{x})\n\
 Return the complex conjugate transpose of @var{x}.\n\
 \n\
 This function and @tcode{x'} are equivalent.\n\
 @seealso{transpose}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_hermitian, args);
 }
@@ -5902,18 +5902,18 @@ binary_assoc_op_defun_body (octave_value
         retval.assign (aop, args(i));
     }
 
   return retval;
 }
 
 DEFUN (plus, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} plus (@var{x}, @var{y})\n\
-@deftypefnx {Built-in Function} {} plus (@var{x1}, @var{x2}, @dots{})\n\
+@deftypefn  {} {} plus (@var{x}, @var{y})\n\
+@deftypefnx {} {} plus (@var{x1}, @var{x2}, @dots{})\n\
 This function and @w{@tcode{x + y}} are equivalent.\n\
 \n\
 If more arguments are given, the summation is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
 (@dots{}((x1 + x2) + x3) + @dots{})\n\
 @end example\n\
@@ -5923,28 +5923,28 @@ At least one argument is required.\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_add,
                                      octave_value::op_add_eq, args);
 }
 
 DEFUN (minus, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} minus (@var{x}, @var{y})\n\
+@deftypefn {} {} minus (@var{x}, @var{y})\n\
 This function and @w{@tcode{x - y}} are equivalent.\n\
 @seealso{plus, uminus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_sub, args);
 }
 
 DEFUN (mtimes, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} mtimes (@var{x}, @var{y})\n\
-@deftypefnx {Built-in Function} {} mtimes (@var{x1}, @var{x2}, @dots{})\n\
+@deftypefn  {} {} mtimes (@var{x}, @var{y})\n\
+@deftypefnx {} {} mtimes (@var{x1}, @var{x2}, @dots{})\n\
 Return the matrix multiplication product of inputs.\n\
 \n\
 This function and @w{@tcode{x * y}} are equivalent.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
 (@dots{}((x1 * x2) * x3) * @dots{})\n\
@@ -5955,118 +5955,118 @@ At least one argument is required.\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_mul,
                                      octave_value::op_mul_eq, args);
 }
 
 DEFUN (mrdivide, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} mrdivide (@var{x}, @var{y})\n\
+@deftypefn {} {} mrdivide (@var{x}, @var{y})\n\
 Return the matrix right division of @var{x} and @var{y}.\n\
 \n\
 This function and @w{@tcode{x / y}} are equivalent.\n\
 @seealso{mldivide, rdivide, plus, minus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_div, args);
 }
 
 DEFUN (mpower, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} mpower (@var{x}, @var{y})\n\
+@deftypefn {} {} mpower (@var{x}, @var{y})\n\
 Return the matrix power operation of @var{x} raised to the @var{y} power.\n\
 \n\
 This function and @w{@tcode{x ^ y}} are equivalent.\n\
 @seealso{power, mtimes, plus, minus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_pow, args);
 }
 
 DEFUN (mldivide, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} mldivide (@var{x}, @var{y})\n\
+@deftypefn {} {} mldivide (@var{x}, @var{y})\n\
 Return the matrix left division of @var{x} and @var{y}.\n\
 \n\
 This function and @w{@tcode{x @xbackslashchar{} y}} are equivalent.\n\
 @seealso{mrdivide, ldivide, rdivide}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ldiv, args);
 }
 
 DEFUN (lt, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} lt (@var{x}, @var{y})\n\
+@deftypefn {} {} lt (@var{x}, @var{y})\n\
 This function is equivalent to @w{@code{x < y}}.\n\
 @seealso{le, eq, ge, gt, ne}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_lt, args);
 }
 
 DEFUN (le, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} le (@var{x}, @var{y})\n\
+@deftypefn {} {} le (@var{x}, @var{y})\n\
 This function is equivalent to @w{@code{x <= y}}.\n\
 @seealso{eq, ge, gt, ne, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_le, args);
 }
 
 DEFUN (eq, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} eq (@var{x}, @var{y})\n\
+@deftypefn {} {} eq (@var{x}, @var{y})\n\
 Return true if the two inputs are equal.\n\
 \n\
 This function is equivalent to @w{@code{x == y}}.\n\
 @seealso{ne, isequal, le, ge, gt, ne, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_eq, args);
 }
 
 DEFUN (ge, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ge (@var{x}, @var{y})\n\
+@deftypefn {} {} ge (@var{x}, @var{y})\n\
 This function is equivalent to @w{@code{x >= y}}.\n\
 @seealso{le, eq, gt, ne, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ge, args);
 }
 
 DEFUN (gt, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} gt (@var{x}, @var{y})\n\
+@deftypefn {} {} gt (@var{x}, @var{y})\n\
 This function is equivalent to @w{@code{x > y}}.\n\
 @seealso{le, eq, ge, ne, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_gt, args);
 }
 
 DEFUN (ne, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ne (@var{x}, @var{y})\n\
+@deftypefn {} {} ne (@var{x}, @var{y})\n\
 Return true if the two inputs are not equal.\n\
 \n\
 This function is equivalent to @w{@code{x != y}}.\n\
 @seealso{eq, isequal, le, ge, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ne, args);
 }
 
 DEFUN (times, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} times (@var{x}, @var{y})\n\
-@deftypefnx {Built-in Function} {} times (@var{x1}, @var{x2}, @dots{})\n\
+@deftypefn  {} {} times (@var{x}, @var{y})\n\
+@deftypefnx {} {} times (@var{x1}, @var{x2}, @dots{})\n\
 Return the element-by-element multiplication product of inputs.\n\
 \n\
 This function and @w{@tcode{x .* y}} are equivalent.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
 (@dots{}((x1 .* x2) .* x3) .* @dots{})\n\
@@ -6077,29 +6077,29 @@ At least one argument is required.\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_mul,
                                      octave_value::op_el_mul_eq, args);
 }
 
 DEFUN (rdivide, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} rdivide (@var{x}, @var{y})\n\
+@deftypefn {} {} rdivide (@var{x}, @var{y})\n\
 Return the element-by-element right division of @var{x} and @var{y}.\n\
 \n\
 This function and @w{@tcode{x ./ y}} are equivalent.\n\
 @seealso{ldivide, mrdivide, times, plus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_div, args);
 }
 
 DEFUN (power, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} power (@var{x}, @var{y})\n\
+@deftypefn {} {} power (@var{x}, @var{y})\n\
 Return the element-by-element operation of @var{x} raised to the\n\
 @var{y} power.\n\
 \n\
 This function and @w{@tcode{x .^ y}} are equivalent.\n\
 \n\
 If several complex results are possible, returns the one with smallest\n\
 non-negative argument (angle).  Use @code{realpow}, @code{realsqrt},\n\
 @code{cbrt}, or @code{nthroot} if a real result is preferred.\n\
@@ -6107,30 +6107,30 @@ non-negative argument (angle).  Use @cod
 @seealso{mpower, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_pow, args);
 }
 
 DEFUN (ldivide, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ldivide (@var{x}, @var{y})\n\
+@deftypefn {} {} ldivide (@var{x}, @var{y})\n\
 Return the element-by-element left division of @var{x} and @var{y}.\n\
 \n\
 This function and @w{@tcode{x .@xbackslashchar{} y}} are equivalent.\n\
 @seealso{rdivide, mldivide, times, plus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_ldiv, args);
 }
 
 DEFUN (and, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{z} =} and (@var{x}, @var{y})\n\
-@deftypefnx {Built-in Function} {@var{z} =} and (@var{x1}, @var{x2}, @dots{})\n\
+@deftypefn  {} {@var{z} =} and (@var{x}, @var{y})\n\
+@deftypefnx {} {@var{z} =} and (@var{x1}, @var{x2}, @dots{})\n\
 Return the logical AND of @var{x} and @var{y}.\n\
 \n\
 This function is equivalent to the operator syntax @w{@code{x & y}}.  If\n\
 more than two arguments are given, the logical AND is applied cumulatively\n\
 from left to right:\n\
 \n\
 @example\n\
 (@dots{}((x1 & x2) & x3) & @dots{})\n\
@@ -6141,18 +6141,18 @@ At least one argument is required.\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_and,
                                      octave_value::op_el_and_eq, args);
 }
 
 DEFUN (or, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{z} =} or (@var{x}, @var{y})\n\
-@deftypefnx {Built-in Function} {@var{z} =} or (@var{x1}, @var{x2}, @dots{})\n\
+@deftypefn  {} {@var{z} =} or (@var{x}, @var{y})\n\
+@deftypefnx {} {@var{z} =} or (@var{x1}, @var{x2}, @dots{})\n\
 Return the logical OR of @var{x} and @var{y}.\n\
 \n\
 This function is equivalent to the operator syntax @w{@code{x | y}}.  If\n\
 more than two arguments are given, the logical OR is applied cumulatively\n\
 from left to right:\n\
 \n\
 @example\n\
 (@dots{}((x1 | x2) | x3) | @dots{})\n\
@@ -6163,18 +6163,18 @@ At least one argument is required.\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_or,
                                      octave_value::op_el_or_eq, args);
 }
 
 DEFUN (colon, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{r} =} colon (@var{base}, @var{limit})\n\
-@deftypefnx {Built-in Function} {@var{r} =} colon (@var{base}, @var{increment}, @var{limit})\n\
+@deftypefn  {} {@var{r} =} colon (@var{base}, @var{limit})\n\
+@deftypefnx {} {@var{r} =} colon (@var{base}, @var{increment}, @var{limit})\n\
 Return the result of the colon expression corresponding to @var{base},\n\
 @var{limit}, and optionally, @var{increment}.\n\
 \n\
 This function is equivalent to the operator syntax @w{@code{base : limit}}\n\
 or @w{@code{base : increment : limit}}.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
@@ -6186,21 +6186,21 @@ or @w{@code{base : increment : limit}}.\
     ? do_colon_op (args(0), args(1))
     : do_colon_op (args(0), args(1), args (2));
 }
 
 static double tic_toc_timestamp = -1.0;
 
 DEFUN (tic, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} tic ()\n\
-@deftypefnx {Built-in Function} {@var{id} =} tic ()\n\
-@deftypefnx {Built-in Function} {} toc ()\n\
-@deftypefnx {Built-in Function} {} toc (@var{id})\n\
-@deftypefnx {Built-in Function} {@var{val} =} toc (@dots{})\n\
+@deftypefn  {} {} tic ()\n\
+@deftypefnx {} {@var{id} =} tic ()\n\
+@deftypefnx {} {} toc ()\n\
+@deftypefnx {} {} toc (@var{id})\n\
+@deftypefnx {} {@var{val} =} toc (@dots{})\n\
 Set or check a wall-clock timer.\n\
 \n\
 Calling @code{tic} without an output argument sets the internal timer state.\n\
 Subsequent calls to @code{toc} return the number of seconds since the timer\n\
 was set.\n\
 For example,\n\
 \n\
 @example\n\
@@ -6255,19 +6255,19 @@ doing nothing at all.\n\
   else
     tic_toc_timestamp = tmp;
 
   return retval;
 }
 
 DEFUN (toc, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} toc ()\n\
-@deftypefnx {Built-in Function} {} toc (@var{id})\n\
-@deftypefnx {Built-in Function} {@var{val} =} toc (@dots{})\n\
+@deftypefn  {} {} toc ()\n\
+@deftypefnx {} {} toc (@var{id})\n\
+@deftypefnx {} {@var{val} =} toc (@dots{})\n\
 @seealso{tic, cputime}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   double start_time = tic_toc_timestamp;
@@ -6311,17 +6311,17 @@ DEFUN (toc, args, nargout,
 %!shared id
 %! id = tic ();
 %!assert (isa (id, "uint64"))
 %!assert (isa (toc (id), "double"))
 */
 
 DEFUN (cputime, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{total}, @var{user}, @var{system}] =} cputime ();\n\
+@deftypefn {} {[@var{total}, @var{user}, @var{system}] =} cputime ();\n\
 Return the CPU time used by your Octave session.\n\
 \n\
 The first output is the total time spent executing your process and is equal\n\
 to the sum of second and third outputs, which are the number of CPU seconds\n\
 spent executing in user mode and the number of CPU seconds spent executing\n\
 in system mode, respectively.\n\
 \n\
 If your system does not have a way to report CPU time usage, @code{cputime}\n\
@@ -6382,20 +6382,20 @@ CPU time used is nonzero.\n\
   retval(1) = usr;
   retval(0) = sys + usr;
 
   return retval;
 }
 
 DEFUN (sort, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{s}, @var{i}] =} sort (@var{x})\n\
-@deftypefnx {Built-in Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim})\n\
-@deftypefnx {Built-in Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{mode})\n\
-@deftypefnx {Built-in Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim}, @var{mode})\n\
+@deftypefn  {} {[@var{s}, @var{i}] =} sort (@var{x})\n\
+@deftypefnx {} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim})\n\
+@deftypefnx {} {[@var{s}, @var{i}] =} sort (@var{x}, @var{mode})\n\
+@deftypefnx {} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim}, @var{mode})\n\
 Return a copy of @var{x} with the elements arranged in increasing order.\n\
 \n\
 For matrices, @code{sort} orders the elements within columns\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
@@ -6704,17 +6704,17 @@ ordered lists.\n\
 // Sort the rows of the matrix @var{a} according to the order
 // specified by @var{mode}, which can either be 'ascend' or 'descend'
 // and return the index vector corresponding to the sort order.
 //
 // This function does not yet support sparse matrices.
 
 DEFUN (__sort_rows_idx__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __sort_rows_idx__ (@var{a}, @var{mode})\n\
+@deftypefn {} {} __sort_rows_idx__ (@var{a}, @var{mode})\n\
 Undocumented internal function.\n\
 @end deftypefn\n")
 {
   octave_value retval;
 
   int nargin = args.length ();
   sortmode smode = ASCENDING;
 
@@ -6773,19 +6773,19 @@ get_sort_mode_option (const octave_value
   else
     error ("issorted: MODE must be \"ascending\", \"descending\", or \"either\"");
 
   return smode;
 }
 
 DEFUN (issorted, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} issorted (@var{a})\n\
-@deftypefnx {Built-in Function} {} issorted (@var{a}, @var{mode})\n\
-@deftypefnx {Built-in Function} {} issorted (@var{a}, \"rows\", @var{mode})\n\
+@deftypefn  {} {} issorted (@var{a})\n\
+@deftypefnx {} {} issorted (@var{a}, @var{mode})\n\
+@deftypefnx {} {} issorted (@var{a}, \"rows\", @var{mode})\n\
 Return true if the array is sorted according to @var{mode}, which\n\
 may be either @qcode{\"ascending\"}, @qcode{\"descending\"}, or\n\
 @qcode{\"either\"}.\n\
 \n\
 By default,  @var{mode} is @qcode{\"ascending\"}.  NaNs are treated in the\n\
 same manner as @code{sort}.\n\
 \n\
 If the optional argument @qcode{\"rows\"} is supplied, check whether\n\
@@ -6886,18 +6886,18 @@ This function does not support sparse ma
 %!error <second argument must be a string> issorted (1, {"rows"})
 %!error <sparse matrices not yet supported> issorted (sparse ([1 2 3]), "rows")
 %!error <A must be a 2-dimensional object> issorted (rand (2,2,2), "rows")
 %!error <needs a vector> issorted (ones (2,2))
 */
 
 DEFUN (nth_element, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} nth_element (@var{x}, @var{n})\n\
-@deftypefnx {Built-in Function} {} nth_element (@var{x}, @var{n}, @var{dim})\n\
+@deftypefn  {} {} nth_element (@var{x}, @var{n})\n\
+@deftypefnx {} {} nth_element (@var{x}, @var{n}, @var{dim})\n\
 Select the n-th smallest element of a vector, using the ordering defined by\n\
 @code{sort}.\n\
 \n\
 The result is equivalent to @code{sort(@var{x})(@var{n})}.\n\
 \n\
 @var{n} can also be a contiguous range, either ascending @code{l:u}\n\
 or descending @code{u:-1:l}, in which case a range of elements is returned.\n\
 \n\
@@ -7000,17 +7000,17 @@ do_accumarray_sum (const idx_vector& idx
   else
     error ("accumarray: dimensions mismatch");
 
   return retval;
 }
 
 DEFUN (__accumarray_sum__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __accumarray_sum__ (@var{idx}, @var{vals}, @var{n})\n\
+@deftypefn {} {} __accumarray_sum__ (@var{idx}, @var{vals}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 && nargin > 3)
@@ -7174,26 +7174,26 @@ do_accumarray_minmax_fun (const octave_v
                    e.idx (), e.details ());
     }
 
   return retval;
 }
 
 DEFUN (__accumarray_min__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __accumarray_min__ (@var{idx}, @var{vals}, @var{zero}, @var{n})\n\
+@deftypefn {} {} __accumarray_min__ (@var{idx}, @var{vals}, @var{zero}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return do_accumarray_minmax_fun (args, true);
 }
 
 DEFUN (__accumarray_max__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __accumarray_max__ (@var{idx}, @var{vals}, @var{zero}, @var{n})\n\
+@deftypefn {} {} __accumarray_max__ (@var{idx}, @var{vals}, @var{zero}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return do_accumarray_minmax_fun (args, false);
 }
 
 template <class NDT>
 static NDT
@@ -7223,17 +7223,17 @@ do_accumdim_sum (const idx_vector& idx, 
 
   retval.idx_add_nd (idx, vals, dim);
 
   return retval;
 }
 
 DEFUN (__accumdim_sum__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __accumdim_sum__ (@var{idx}, @var{vals}, @var{dim}, @var{n})\n\
+@deftypefn {} {} __accumdim_sum__ (@var{idx}, @var{vals}, @var{dim}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 && nargin > 4)
@@ -7349,18 +7349,18 @@ do_merge (const Array<bool>& mask,
     { \
       retval = do_merge (mask, \
                          tval.INTX ## _array_value (), \
                          fval.INTX ## _array_value ()); \
     }
 
 DEFUN (merge, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} merge (@var{mask}, @var{tval}, @var{fval})\n\
-@deftypefnx {Built-in Function} {} ifelse (@var{mask}, @var{tval}, @var{fval})\n\
+@deftypefn  {} {} merge (@var{mask}, @var{tval}, @var{fval})\n\
+@deftypefnx {} {} ifelse (@var{mask}, @var{tval}, @var{fval})\n\
 Merge elements of @var{true_val} and @var{false_val}, depending on the\n\
 value of @var{mask}.\n\
 \n\
 If @var{mask} is a logical scalar, the other two arguments can be arbitrary\n\
 values.  Otherwise, @var{mask} must be a logical array, and @var{tval},\n\
 @var{fval} should be arrays of matching class, or cell arrays.  In the\n\
 scalar mask case, @var{tval} is returned if @var{mask} is true, otherwise\n\
 @var{fval} is returned.\n\
@@ -7580,19 +7580,19 @@ do_diff (const octave_value& array, octa
         retval = array.array_value ().diff (order, dim);
     }
 
   return retval;
 }
 
 DEFUN (diff, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} diff (@var{x})\n\
-@deftypefnx {Built-in Function} {} diff (@var{x}, @var{k})\n\
-@deftypefnx {Built-in Function} {} diff (@var{x}, @var{k}, @var{dim})\n\
+@deftypefn  {} {} diff (@var{x})\n\
+@deftypefnx {} {} diff (@var{x}, @var{k})\n\
+@deftypefnx {} {} diff (@var{x}, @var{k}, @var{dim})\n\
 If @var{x} is a vector of length @math{n}, @w{@code{diff (@var{x})}} is the\n\
 vector of first differences\n\
 @tex\n\
  $x_2 - x_1, \\ldots{}, x_n - x_{n-1}$.\n\
 @end tex\n\
 @ifnottex\n\
  @var{x}(2) - @var{x}(1), @dots{}, @var{x}(n) - @var{x}(n-1).\n\
 @end ifnottex\n\
@@ -7696,17 +7696,17 @@ do_repelems (const Array<T>& src, const 
       dest += k;
     }
 
   return retval;
 }
 
 DEFUN (repelems, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} repelems (@var{x}, @var{r})\n\
+@deftypefn {} {} repelems (@var{x}, @var{r})\n\
 Construct a vector of repeated elements from @var{x}.\n\
 \n\
 @var{r} is a 2x@var{N} integer matrix specifying which elements to repeat and\n\
 how often to repeat each element.  Entries in the first row, @var{r}(1,j),\n\
 select an element to repeat.  The corresponding entry in the second row,\n\
 @var{r}(2,j), specifies the repeat count.  If @var{x} is a matrix then the\n\
 columns of @var{x} are imagined to be stacked on top of each other for\n\
 purposes of the selection index.  A row vector is always returned.\n\
@@ -7783,17 +7783,17 @@ endfor\n\
         }
     }
 
   return retval;
 }
 
 DEFUN (base64_encode, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{s} =} base64_encode (@var{x})\n\
+@deftypefn {} {@var{s} =} base64_encode (@var{x})\n\
 Encode a double matrix or array @var{x} into the base64 format string\n\
 @var{s}.\n\
 \n\
 @seealso{base64_decode}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -7881,18 +7881,18 @@ Encode a double matrix or array @var{x} 
 %!error base64_encode (1,2)
 %!error base64_encode ("A string")
 %!error base64_encode ({"A cell array"})
 %!error base64_encode (struct ())
 */
 
 DEFUN (base64_decode, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{x} =} base64_decode (@var{s})\n\
-@deftypefnx {Built-in Function} {@var{x} =} base64_decode (@var{s}, @var{dims})\n\
+@deftypefn  {} {@var{x} =} base64_decode (@var{s})\n\
+@deftypefnx {} {@var{x} =} base64_decode (@var{s}, @var{dims})\n\
 Decode the double matrix or array @var{x} from the base64 encoded string\n\
 @var{s}.\n\
 \n\
 The optional input parameter @var{dims} should be a vector containing the\n\
 dimensions of the decoded array.\n\
 @seealso{base64_encode}\n\
 @end deftypefn")
 {
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -583,25 +583,25 @@ intmap_to_ov (const bp_table::intmap& li
 
   retval.resize (dim_vector (1, idx));
 
   return retval;
 }
 
 DEFUN (dbstop, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} dbstop @var{func}\n\
-@deftypefnx {Command} {} dbstop @var{func} @var{line}\n\
-@deftypefnx {Command} {} dbstop @var{func} @var{line1} @var{line2} @dots{}\n\
-@deftypefnx {Command} {} dbstop @var{line} @dots{}\n\
-@deftypefnx {Built-in Function} {@var{rline} =} dbstop (\"@var{func}\")\n\
-@deftypefnx {Built-in Function} {@var{rline} =} dbstop (\"@var{func}\", @var{line})\n\
-@deftypefnx {Built-in Function} {@var{rline} =} dbstop (\"@var{func}\", @var{line1}, @var{line2}, @dots{})\n\
-@deftypefnx {Built-in Function} {} dbstop (\"@var{func}\", [@var{line1}, @dots{}])\n\
-@deftypefnx {Built-in Function} {} dbstop (@var{line}, @dots{})\n\
+@deftypefn  {} {} dbstop @var{func}\n\
+@deftypefnx {} {} dbstop @var{func} @var{line}\n\
+@deftypefnx {} {} dbstop @var{func} @var{line1} @var{line2} @dots{}\n\
+@deftypefnx {} {} dbstop @var{line} @dots{}\n\
+@deftypefnx {} {@var{rline} =} dbstop (\"@var{func}\")\n\
+@deftypefnx {} {@var{rline} =} dbstop (\"@var{func}\", @var{line})\n\
+@deftypefnx {} {@var{rline} =} dbstop (\"@var{func}\", @var{line1}, @var{line2}, @dots{})\n\
+@deftypefnx {} {} dbstop (\"@var{func}\", [@var{line1}, @dots{}])\n\
+@deftypefnx {} {} dbstop (@var{line}, @dots{})\n\
 Set a breakpoint at line number @var{line} in function @var{func}.\n\
 \n\
 Arguments are\n\
 \n\
 @table @var\n\
 @item func\n\
 Function name as a string variable.  When already in debug mode this argument\n\
 can be omitted and the current function will be used.\n\
@@ -632,27 +632,27 @@ Octave will set the real breakpoint at t
 
   retval = bp_table::add_breakpoint (symbol_name, lines);
 
   return intmap_to_ov (retval);
 }
 
 DEFUN (dbclear, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} dbclear @var{func}\n\
-@deftypefnx {Command} {} dbclear @var{func} @var{line}\n\
-@deftypefnx {Command} {} dbclear @var{func} @var{line1} @var{line2} @dots{}\n\
-@deftypefnx {Command} {} dbclear @var{line} @dots{}\n\
-@deftypefnx {Command} {} dbclear all\n\
-@deftypefnx {Built-in Function} {} dbclear (\"@var{func}\")\n\
-@deftypefnx {Built-in Function} {} dbclear (\"@var{func}\", @var{line})\n\
-@deftypefnx {Built-in Function} {} dbclear (\"@var{func}\", @var{line1}, @var{line2}, @dots{})\n\
-@deftypefnx {Built-in Function} {} dbclear (\"@var{func}\", [@var{line1}, @dots{}])\n\
-@deftypefnx {Built-in Function} {} dbclear (@var{line}, @dots{})\n\
-@deftypefnx {Built-in Function} {} dbclear (\"all\")\n\
+@deftypefn  {} {} dbclear @var{func}\n\
+@deftypefnx {} {} dbclear @var{func} @var{line}\n\
+@deftypefnx {} {} dbclear @var{func} @var{line1} @var{line2} @dots{}\n\
+@deftypefnx {} {} dbclear @var{line} @dots{}\n\
+@deftypefnx {} {} dbclear all\n\
+@deftypefnx {} {} dbclear (\"@var{func}\")\n\
+@deftypefnx {} {} dbclear (\"@var{func}\", @var{line})\n\
+@deftypefnx {} {} dbclear (\"@var{func}\", @var{line1}, @var{line2}, @dots{})\n\
+@deftypefnx {} {} dbclear (\"@var{func}\", [@var{line1}, @dots{}])\n\
+@deftypefnx {} {} dbclear (@var{line}, @dots{})\n\
+@deftypefnx {} {} dbclear (\"all\")\n\
 Delete a breakpoint at line number @var{line} in the function @var{func}.\n\
 \n\
 Arguments are\n\
 \n\
 @table @var\n\
 @item func\n\
 Function name as a string variable.  When already in debug mode this argument\n\
 can be omitted and the current function will be used.\n\
@@ -683,19 +683,19 @@ files.\n\
   else
     bp_table::remove_breakpoint (symbol_name, lines);
 
   return retval;
 }
 
 DEFUN (dbstatus, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} dbstatus ()\n\
-@deftypefnx {Built-in Function} {@var{brk_list} =} dbstatus ()\n\
-@deftypefnx {Built-in Function} {@var{brk_list} =} dbstatus (\"@var{func}\")\n\
+@deftypefn  {} {} dbstatus ()\n\
+@deftypefnx {} {@var{brk_list} =} dbstatus ()\n\
+@deftypefnx {} {@var{brk_list} =} dbstatus (\"@var{func}\")\n\
 Report the location of active breakpoints.\n\
 \n\
 When called with no input or output arguments, print the list of all\n\
 functions with breakpoints and the line numbers where those breakpoints are\n\
 set.\n\
 \n\
 If a function name @var{func} is specified then only report breakpoints\n\
 for the named function.\n\
@@ -803,17 +803,17 @@ current function.\n\
       retval.assign ("line", line);
 
       return octave_value (retval);
     }
 }
 
 DEFUN (dbwhere, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Command} {} dbwhere\n\
+@deftypefn {} {} dbwhere\n\
 In debugging mode, report the current file and line number where execution\n\
 is stopped.\n\
 @seealso{dbstatus, dbcont, dbstep, dbup}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_user_code *dbg_fcn = get_user_code ();
@@ -884,24 +884,24 @@ do_dbtype (std::ostream& os, const std::
   else
     os << "dbtype: unknown function " << name << "\n";
 
   os.flush ();
 }
 
 DEFUN (dbtype, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} dbtype\n\
-@deftypefnx {Command} {} dbtype @var{lineno}\n\
-@deftypefnx {Command} {} dbtype @var{startl:endl}\n\
-@deftypefnx {Command} {} dbtype @var{startl:end}\n\
-@deftypefnx {Command} {} dbtype @var{func}\n\
-@deftypefnx {Command} {} dbtype @var{func} @var{lineno}\n\
-@deftypefnx {Command} {} dbtype @var{func} @var{startl:endl}\n\
-@deftypefnx {Command} {} dbtype @var{func} @var{startl:end}\n\
+@deftypefn  {} {} dbtype\n\
+@deftypefnx {} {} dbtype @var{lineno}\n\
+@deftypefnx {} {} dbtype @var{startl:endl}\n\
+@deftypefnx {} {} dbtype @var{startl:end}\n\
+@deftypefnx {} {} dbtype @var{func}\n\
+@deftypefnx {} {} dbtype @var{func} @var{lineno}\n\
+@deftypefnx {} {} dbtype @var{func} @var{startl:endl}\n\
+@deftypefnx {} {} dbtype @var{func} @var{startl:end}\n\
 Display a script file with line numbers.\n\
 \n\
 When called with no arguments in debugging mode, display the script file\n\
 currently being debugged.\n\
 \n\
 An optional range specification can be used to list only a portion of the\n\
 file.  The special keyword @qcode{\"end\"} is a valid line number\n\
 specification for the last line of the file.\n\
@@ -1034,18 +1034,18 @@ numbers.\n\
       error ("dbtype: expecting zero, one, or two arguments\n");
     }
 
   return retval;
 }
 
 DEFUN (dblist, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} dblist\n\
-@deftypefnx {Command} {} dblist @var{n}\n\
+@deftypefn  {} {} dblist\n\
+@deftypefnx {} {} dblist @var{n}\n\
 In debugging mode, list @var{n} lines of the function being debugged\n\
 centered around the current line to be executed.\n\
 \n\
 If unspecified @var{n} defaults to 10 (+/- 5 lines)\n\
 @seealso{dbwhere, dbtype}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1227,20 +1227,20 @@ do_dbstack (const octave_value_list& arg
 void
 show_octave_dbstack (void)
 {
   do_dbstack (octave_value_list (), 0, std::cerr);
 }
 
 DEFUN (dbstack, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} dbstack\n\
-@deftypefnx {Command} {} dbstack @var{n}\n\
-@deftypefnx {Command} {} dbstack @var{-completenames}\n\
-@deftypefnx {Built-in Function} {[@var{stack}, @var{idx}] =} dbstack (@dots{})\n\
+@deftypefn  {} {} dbstack\n\
+@deftypefnx {} {} dbstack @var{n}\n\
+@deftypefnx {} {} dbstack @var{-completenames}\n\
+@deftypefnx {} {[@var{stack}, @var{idx}] =} dbstack (@dots{})\n\
 Display or return current debugging function stack information.\n\
 \n\
 With optional argument @var{n}, omit the @var{n} innermost stack frames.\n\
 \n\
 Although accepted, the argument @var{-completenames} is silently ignored.\n\
 Octave always returns absolute filenames.\n\
 \n\
 The arguments @var{n} and @var{-completenames} can be both specified in any\n\
@@ -1300,55 +1300,55 @@ do_dbupdown (const octave_value_list& ar
     n = -n;
 
   if (! octave_call_stack::goto_frame_relative (n, true))
     error ("%s: invalid stack frame", who.c_str ());
 }
 
 DEFUN (dbup, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} dbup\n\
-@deftypefnx {Command} {} dbup @var{n}\n\
+@deftypefn  {} {} dbup\n\
+@deftypefnx {} {} dbup @var{n}\n\
 In debugging mode, move up the execution stack @var{n} frames.\n\
 \n\
 If @var{n} is omitted, move up one frame.\n\
 @seealso{dbstack, dbdown}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   do_dbupdown (args, "dbup");
 
   return retval;
 }
 
 DEFUN (dbdown, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} dbdown\n\
-@deftypefnx {Command} {} dbdown @var{n}\n\
+@deftypefn  {} {} dbdown\n\
+@deftypefnx {} {} dbdown @var{n}\n\
 In debugging mode, move down the execution stack @var{n} frames.\n\
 \n\
 If @var{n} is omitted, move down one frame.\n\
 @seealso{dbstack, dbup}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   do_dbupdown (args, "dbdown");
 
   return retval;
 }
 
 DEFUN (dbstep, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} dbstep\n\
-@deftypefnx {Command} {} dbstep @var{n}\n\
-@deftypefnx {Command} {} dbstep in\n\
-@deftypefnx {Command} {} dbstep out\n\
-@deftypefnx {Command} {} dbnext @dots{}\n\
+@deftypefn  {} {} dbstep\n\
+@deftypefnx {} {} dbstep @var{n}\n\
+@deftypefnx {} {} dbstep in\n\
+@deftypefnx {} {} dbstep out\n\
+@deftypefnx {} {} dbnext @dots{}\n\
 In debugging mode, execute the next @var{n} lines of code.\n\
 \n\
 If @var{n} is omitted, execute the next single line of code.  If the next\n\
 line of code is itself defined in terms of an m-file remain in the existing\n\
 function.\n\
 \n\
 Using @code{dbstep in} will cause execution of the next line to step into\n\
 any m-files defined on the next line.\n\
@@ -1409,17 +1409,17 @@ function returns.\n\
 
   return octave_value_list ();
 }
 
 DEFALIAS (dbnext, dbstep);
 
 DEFUN (dbcont, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Command} {} dbcont\n\
+@deftypefn {} {} dbcont\n\
 Leave command-line debugging mode and continue code execution normally.\n\
 @seealso{dbstep, dbquit}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       if (args.length () != 0)
         print_usage ();
@@ -1431,17 +1431,17 @@ Leave command-line debugging mode and co
   else
     error ("dbcont: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (dbquit, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Command} {} dbquit\n\
+@deftypefn {} {} dbquit\n\
 Quit debugging mode immediately without further code execution and return to\n\
 the Octave prompt.\n\
 @seealso{dbcont, dbstep}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       if (args.length () != 0)
@@ -1456,31 +1456,31 @@ the Octave prompt.\n\
   else
     error ("dbquit: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (isdebugmode, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isdebugmode ()\n\
+@deftypefn {} {} isdebugmode ()\n\
 Return true if in debugging mode, otherwise false.\n\
 @seealso{dbwhere, dbstack, dbstatus}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
   return octave_value (Vdebugging);
 }
 
 DEFUN (__db_next_breakpoint_quiet__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} __db_next_breakpoint_quiet__ ()\n\
-@deftypefnx {Built-in Function} {} __db_next_breakpoint_quiet__ (@var{flag})\n\
+@deftypefn  {} {} __db_next_breakpoint_quiet__ ()\n\
+@deftypefnx {} {} __db_next_breakpoint_quiet__ (@var{flag})\n\
 Disable line info printing at the next breakpoint.\n\
 \n\
 With a logical argument @var{flag}, set the state on or off.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -471,19 +471,19 @@ install_defaults (void)
 
   set_site_defaults_file ();
 
   set_built_in_docstrings_file ();
 }
 
 DEFUN (EDITOR, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} EDITOR ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} EDITOR (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} EDITOR (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} EDITOR ()\n\
+@deftypefnx {} {@var{old_val} =} EDITOR (@var{new_val})\n\
+@deftypefnx {} {} EDITOR (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the default text editor.\n\
 \n\
 The default value is taken from the environment variable @w{@env{EDITOR}}\n\
 when Octave starts.  If the environment variable is not initialized,\n\
 @w{@env{EDITOR}} will be set to @qcode{\"emacs\"}.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
@@ -504,19 +504,19 @@ The original variable value is restored 
 %! EDITOR (orig_val);
 %! assert (EDITOR (), orig_val);
 
 %!error (EDITOR (1, 2))
 */
 
 DEFUN (EXEC_PATH, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} EXEC_PATH ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} EXEC_PATH (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} EXEC_PATH (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} EXEC_PATH ()\n\
+@deftypefnx {} {@var{old_val} =} EXEC_PATH (@var{new_val})\n\
+@deftypefnx {} {} EXEC_PATH (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories to append to the shell PATH when executing external\n\
 programs.\n\
 \n\
 The initial value of is taken from the environment variable\n\
 @w{@env{OCTAVE_EXEC_PATH}}, but that value can be overridden by the command\n\
 line argument @option{--exec-path PATH}.\n\
 \n\
@@ -544,19 +544,19 @@ The original variable value is restored 
 %! EXEC_PATH (orig_val);
 %! assert (EXEC_PATH (), orig_val);
 
 %!error (EXEC_PATH (1, 2))
 */
 
 DEFUN (IMAGE_PATH, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} IMAGE_PATH ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} IMAGE_PATH (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} IMAGE_PATH (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} IMAGE_PATH ()\n\
+@deftypefnx {} {@var{old_val} =} IMAGE_PATH (@var{new_val})\n\
+@deftypefnx {} {} IMAGE_PATH (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories in which to search for image files.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 \n\
 @seealso{EXEC_PATH, OCTAVE_HOME}\n\
@@ -574,17 +574,17 @@ The original variable value is restored 
 %! IMAGE_PATH (orig_val);
 %! assert (IMAGE_PATH (), orig_val);
 
 %!error (IMAGE_PATH (1, 2))
 */
 
 DEFUN (OCTAVE_HOME, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} OCTAVE_HOME ()\n\
+@deftypefn {} {} OCTAVE_HOME ()\n\
 Return the name of the top-level Octave installation directory.\n\
 @seealso{EXEC_PATH, IMAGE_PATH}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
   return octave_value (Voctave_home);
@@ -592,17 +592,17 @@ Return the name of the top-level Octave 
 
 /*
 %!assert (ischar (OCTAVE_HOME ()))
 %!error OCTAVE_HOME (1)
 */
 
 DEFUNX ("OCTAVE_VERSION", FOCTAVE_VERSION, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} OCTAVE_VERSION ()\n\
+@deftypefn {} {} OCTAVE_VERSION ()\n\
 Return the version number of Octave as a string.\n\
 @seealso{ver, version}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
   return octave_value (OCTAVE_VERSION);
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -44,18 +44,18 @@ along with Octave; see the file COPYING.
 #include "ov-perm.h"
 
 #define MAYBE_CAST(VAR, CLASS) \
   const CLASS *VAR = arg.type_id () == CLASS::static_type_id () ? \
    dynamic_cast<const CLASS *> (&arg.get_rep ()) : 0
 
 DEFUN (det, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} det (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{d}, @var{rcond}] =} det (@var{A})\n\
+@deftypefn  {} {} det (@var{A})\n\
+@deftypefnx {} {[@var{d}, @var{rcond}] =} det (@var{A})\n\
 Compute the determinant of @var{A}.\n\
 \n\
 Return an estimate of the reciprocal condition number if requested.\n\
 \n\
 Programming Notes: Routines from @sc{lapack} are used for full matrices and\n\
 code from @sc{umfpack} is used for sparse matrices.\n\
 \n\
 The determinant should not be used to check a matrix for singularity.\n\
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -89,20 +89,20 @@ octave_change_to_directory (const std::s
   else
     error ("%s: %s", newdir.c_str (), gnulib::strerror (errno));
 
   return cd_ok;
 }
 
 DEFUN (cd, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} cd @var{dir}\n\
-@deftypefnx {Command} {} cd\n\
-@deftypefnx {Built-in Function} {@var{old_dir} =} cd (@var{dir})\n\
-@deftypefnx {Command} {} chdir @dots{}\n\
+@deftypefn  {} {} cd @var{dir}\n\
+@deftypefnx {} {} cd\n\
+@deftypefnx {} {@var{old_dir} =} cd (@var{dir})\n\
+@deftypefnx {} {} chdir @dots{}\n\
 Change the current working directory to @var{dir}.\n\
 \n\
 If @var{dir} is omitted, the current directory is changed to the user's home\n\
 directory (@qcode{\"~\"}).\n\
 \n\
 For example,\n\
 \n\
 @example\n\
@@ -149,29 +149,29 @@ present working directory rather than ch
 
   return retval;
 }
 
 DEFALIAS (chdir, cd);
 
 DEFUN (pwd, , ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} pwd ()\n\
-@deftypefnx {Built-in Function} {@var{dir} =} pwd ()\n\
+@deftypefn  {} {} pwd ()\n\
+@deftypefnx {} {@var{dir} =} pwd ()\n\
 Return the current working directory.\n\
 @seealso{cd, dir, ls, mkdir, rmdir}\n\
 @end deftypefn")
 {
   return octave_value (octave_env::get_current_directory ());
 }
 
 DEFUN (readdir, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{files} =} readdir (@var{dir})\n\
-@deftypefnx {Built-in Function} {[@var{files}, @var{err}, @var{msg}] =} readdir (@var{dir})\n\
+@deftypefn  {} {@var{files} =} readdir (@var{dir})\n\
+@deftypefnx {} {[@var{files}, @var{err}, @var{msg}] =} readdir (@var{dir})\n\
 Return the names of files in the directory @var{dir} as a cell array of\n\
 strings.\n\
 \n\
 If an error occurs, return an empty cell array in @var{files}.\n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{ls, dir, glob, what}\n\
@@ -202,19 +202,19 @@ error message.\n\
   return retval;
 }
 
 // FIXME: should maybe also allow second arg to specify mode?
 //        OTOH, that might cause trouble with compatibility later...
 
 DEFUNX ("mkdir", Fmkdir, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} mkdir @var{dir}\n\
-@deftypefnx {Built-in Function} {} mkdir (@var{parent}, @var{dir})\n\
-@deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@dots{})\n\
+@deftypefn  {} {} mkdir @var{dir}\n\
+@deftypefnx {} {} mkdir (@var{parent}, @var{dir})\n\
+@deftypefnx {} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@dots{})\n\
 Create a directory named @var{dir} in the directory @var{parent}.\n\
 \n\
 If no @var{parent} directory is specified the present working directory is\n\
 used.\n\
 \n\
 If successful, @var{status} is 1, and @var{msg}, @var{msgid} are empty\n\
 character strings ("").  Otherwise, @var{status} is 0, @var{msg} contains a\n\
 system-dependent error message, and @var{msgid} contains a unique message\n\
@@ -276,19 +276,19 @@ When creating a directory permissions wi
         retval(0) = true;
     }
 
   return retval;
 }
 
 DEFUNX ("rmdir", Frmdir, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} rmdir @var{dir}\n\
-@deftypefnx {Built-in Function} {} rmdir (@var{dir}, \"s\")\n\
-@deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@dots{})\n\
+@deftypefn  {} {} rmdir @var{dir}\n\
+@deftypefnx {} {} rmdir (@var{dir}, \"s\")\n\
+@deftypefnx {} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@dots{})\n\
 Remove the directory named @var{dir}.\n\
 \n\
 If the optional second parameter is supplied with value @qcode{\"s\"},\n\
 recursively remove all subdirectories as well.\n\
 \n\
 If successful, @var{status} is 1, and @var{msg}, @var{msgid} are empty\n\
 character strings ("").  Otherwise, @var{status} is 0, @var{msg} contains a\n\
 system-dependent error message, and @var{msgid} contains a unique message\n\
@@ -346,18 +346,18 @@ identifier.\n\
   else
     retval(0) = true;
 
   return retval;
 }
 
 DEFUNX ("link", Flink, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} link @var{old} @var{new}\n\
-@deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} link (@var{old}, @var{new})\n\
+@deftypefn  {} {} link @var{old} @var{new}\n\
+@deftypefnx {} {[@var{err}, @var{msg}] =} link (@var{old}, @var{new})\n\
 Create a new link (also known as a hard link) to an existing file.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{symlink, unlink, readlink, lstat}\n\
 @end deftypefn")
 {
@@ -381,18 +381,18 @@ error message.\n\
 
   retval(0) = status;
 
   return retval;
 }
 
 DEFUNX ("symlink", Fsymlink, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} symlink @var{old} @var{new}\n\
-@deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} symlink (@var{old}, @var{new})\n\
+@deftypefn  {} {} symlink @var{old} @var{new}\n\
+@deftypefnx {} {[@var{err}, @var{msg}] =} symlink (@var{old}, @var{new})\n\
 Create a symbolic link @var{new} which contains the string @var{old}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{link, unlink, readlink, lstat}\n\
 @end deftypefn")
 {
@@ -416,18 +416,18 @@ error message.\n\
 
   retval(0) = status;
 
   return retval;
 }
 
 DEFUNX ("readlink", Freadlink, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} readlink @var{symlink}\n\
-@deftypefnx {Built-in Function} {[@var{result}, @var{err}, @var{msg}] =} readlink (@var{symlink})\n\
+@deftypefn  {} {} readlink @var{symlink}\n\
+@deftypefnx {} {[@var{result}, @var{err}, @var{msg}] =} readlink (@var{symlink})\n\
 Read the value of the symbolic link @var{symlink}.\n\
 \n\
 If successful, @var{result} contains the contents of the symbolic link\n\
 @var{symlink}, @var{err} is 0, and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{lstat, symlink, link, unlink, delete}\n\
 @end deftypefn")
@@ -454,18 +454,18 @@ error message.\n\
   retval(1) = status;
   retval(0) = result;
 
   return retval;
 }
 
 DEFUNX ("rename", Frename, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} rename @var{old} @var{new}\n\
-@deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} rename (@var{old}, @var{new})\n\
+@deftypefn  {} {} rename @var{old} @var{new}\n\
+@deftypefnx {} {[@var{err}, @var{msg}] =} rename (@var{old}, @var{new})\n\
 Change the name of file @var{old} to @var{new}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{movefile, copyfile, ls, dir}\n\
 @end deftypefn")
 {
@@ -489,17 +489,17 @@ error message.\n\
 
   retval(0) = status;
 
   return retval;
 }
 
 DEFUN (glob, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} glob (@var{pattern})\n\
+@deftypefn {} {} glob (@var{pattern})\n\
 Given an array of pattern strings (as a char array or a cell array) in\n\
 @var{pattern}, return a cell array of filenames that match any of\n\
 them, or an empty cell array if no patterns match.\n\
 \n\
 The pattern strings are interpreted as filename globbing patterns (as they\n\
 are used by Unix shells).\n\
 \n\
 Within a pattern\n\
@@ -582,17 +582,17 @@ glob (\"file[12]\")\n\
 %! rmdir (tmpdir);
 %! assert (result1, {"file1"; "myfile1"});
 %! assert (result2, {"myfile1"});
 %! assert (result3, {"file1"; "file2"});
 */
 
 DEFUN (__fnmatch__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} fnmatch (@var{pattern}, @var{string})\n\
+@deftypefn {} {} fnmatch (@var{pattern}, @var{string})\n\
 Return true or false for each element of @var{string} that matches any of\n\
 the elements of the string array @var{pattern}, using the rules of\n\
 \n\
 filename pattern matching.  For example:\n\
 \n\
 @example\n\
 @group\n\
 fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \"xyzab\"@})\n\
@@ -612,18 +612,18 @@ fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \
 
   glob_match pattern (file_ops::tilde_expand (pat));
 
   return octave_value (pattern.match (str));
 }
 
 DEFUN (filesep, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} filesep ()\n\
-@deftypefnx {Built-in Function} {} filesep (\"all\")\n\
+@deftypefn  {} {} filesep ()\n\
+@deftypefnx {} {} filesep (\"all\")\n\
 Return the system-dependent character used to separate directory names.\n\
 \n\
 If @qcode{\"all\"} is given, the function returns all valid file separators\n\
 in the form of a string.  The list of file separators is system-dependent.\n\
 It is @samp{/} (forward slash) under UNIX or @w{Mac OS X}, @samp{/} and\n\
 @samp{\\} (forward and backward slashes) under Windows.\n\
 @seealso{pathsep}\n\
 @end deftypefn")
@@ -645,18 +645,18 @@ It is @samp{/} (forward slash) under UNI
         error ("filesep: argument must be \"all\"");
     }
 
   return retval;
 }
 
 DEFUN (pathsep, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} pathsep ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} pathsep (@var{new_val})\n\
+@deftypefn  {} {@var{val} =} pathsep ()\n\
+@deftypefnx {} {@var{old_val} =} pathsep (@var{new_val})\n\
 Query or set the character used to separate directories in a path.\n\
 @seealso{filesep}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -686,19 +686,19 @@ Query or set the character used to separ
         }
     }
 
   return retval;
 }
 
 DEFUN (confirm_recursive_rmdir, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} confirm_recursive_rmdir ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} confirm_recursive_rmdir (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} confirm_recursive_rmdir (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} confirm_recursive_rmdir ()\n\
+@deftypefnx {} {@var{old_val} =} confirm_recursive_rmdir (@var{new_val})\n\
+@deftypefnx {} {} confirm_recursive_rmdir (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave\n\
 will ask for confirmation before recursively removing a directory tree.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{rmdir}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -153,21 +153,21 @@ parse_range_spec (const octave_value& ra
   else
     stat = false;
 
   return stat;
 }
 
 DEFUN (dlmread, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{data} =} dlmread (@var{file})\n\
-@deftypefnx {Built-in Function} {@var{data} =} dlmread (@var{file}, @var{sep})\n\
-@deftypefnx {Built-in Function} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{r0}, @var{c0})\n\
-@deftypefnx {Built-in Function} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{range})\n\
-@deftypefnx {Built-in Function} {@var{data} =} dlmread (@dots{}, \"emptyvalue\", @var{EMPTYVAL})\n\
+@deftypefn  {} {@var{data} =} dlmread (@var{file})\n\
+@deftypefnx {} {@var{data} =} dlmread (@var{file}, @var{sep})\n\
+@deftypefnx {} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{r0}, @var{c0})\n\
+@deftypefnx {} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{range})\n\
+@deftypefnx {} {@var{data} =} dlmread (@dots{}, \"emptyvalue\", @var{EMPTYVAL})\n\
 Read the matrix @var{data} from a text file which uses the delimiter\n\
 @var{sep} between data values.\n\
 \n\
 If @var{sep} is not defined the separator between fields is determined from\n\
 the file itself.\n\
 \n\
 Given two scalar arguments @var{r0} and @var{c0}, these define the starting\n\
 row and column of the data to be read.  These values are indexed from zero,\n\
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -100,17 +100,17 @@ get_red_dims (const dim_vector& x, const
           k = x(i);
           z(i) = 1;
         }
     }
 }
 
 DEFUN (dot, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} dot (@var{x}, @var{y}, @var{dim})\n\
+@deftypefn {} {} dot (@var{x}, @var{y}, @var{dim})\n\
 Compute the dot product of two vectors.\n\
 \n\
 If @var{x} and @var{y} are matrices, calculate the dot products along the\n\
 first non-singleton dimension.\n\
 \n\
 If the optional argument @var{dim} is given, calculate the dot products\n\
 along this dimension.\n\
 \n\
@@ -271,17 +271,17 @@ but avoids forming a temporary array and
 %!error <sizes of X and Y must match> dot ([1 2], [1 2 3])
 %!error <sizes of X and Y must match> dot ([1 2]', [1 2 3]')
 %!error <sizes of X and Y must match> dot (ones (2,2), ones (2,3))
 %!error <DIM must be a valid dimension> dot ([1 2], [1 2], 0)
 */
 
 DEFUN (blkmm, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} blkmm (@var{A}, @var{B})\n\
+@deftypefn {} {} blkmm (@var{A}, @var{B})\n\
 Compute products of matrix blocks.\n\
 \n\
 The blocks are given as 2-dimensional subarrays of the arrays @var{A},\n\
 @var{B}.  The size of @var{A} must have the form @code{[m,k,@dots{}]} and\n\
 size of @var{B} must be @code{[k,n,@dots{}]}.  The result is then of size\n\
 @code{[m,n,@dots{}]} and is computed as follows:\n\
 \n\
 @example\n\
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -30,20 +30,20 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (eig, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{lambda} =} eig (@var{A})\n\
-@deftypefnx {Built-in Function} {@var{lambda} =} eig (@var{A}, @var{B})\n\
-@deftypefnx {Built-in Function} {[@var{V}, @var{lambda}] =} eig (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{V}, @var{lambda}] =} eig (@var{A}, @var{B})\n\
+@deftypefn  {} {@var{lambda} =} eig (@var{A})\n\
+@deftypefnx {} {@var{lambda} =} eig (@var{A}, @var{B})\n\
+@deftypefnx {} {[@var{V}, @var{lambda}] =} eig (@var{A})\n\
+@deftypefnx {} {[@var{V}, @var{lambda}] =} eig (@var{A}, @var{B})\n\
 Compute the eigenvalues (and optionally the eigenvectors) of a matrix\n\
 or a pair of matrices\n\
 \n\
 The algorithm used depends on whether there are one or two input\n\
 matrices, if they are real or complex, and if they are symmetric\n\
 (Hermitian if complex) or non-symmetric.\n\
 \n\
 The eigenvalues returned by @code{eig} are not ordered.\n\
diff --git a/libinterp/corefcn/ellipj.cc b/libinterp/corefcn/ellipj.cc
--- a/libinterp/corefcn/ellipj.cc
+++ b/libinterp/corefcn/ellipj.cc
@@ -25,18 +25,18 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "defun.h"
 #include "error.h"
 #include "lo-specfun.h"
 
 DEFUN (ellipj, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{sn}, @var{cn}, @var{dn}, @var{err}] =} ellipj (@var{u}, @var{m})\n\
-@deftypefnx {Built-in Function} {[@var{sn}, @var{cn}, @var{dn}, @var{err}] =} ellipj (@var{u}, @var{m}, @var{tol})\n\
+@deftypefn  {} {[@var{sn}, @var{cn}, @var{dn}, @var{err}] =} ellipj (@var{u}, @var{m})\n\
+@deftypefnx {} {[@var{sn}, @var{cn}, @var{dn}, @var{err}] =} ellipj (@var{u}, @var{m}, @var{tol})\n\
 Compute the Jacobi elliptic functions @var{sn}, @var{cn}, and @var{dn}\n\
 of complex argument @var{u} and real parameter @var{m}.\n\
 \n\
 If @var{m} is a scalar, the results are the same size as @var{u}.\n\
 If @var{u} is a scalar, the results are the same size as @var{m}.\n\
 If @var{u} is a column vector and @var{m} is a row vector, the\n\
 results are matrices with @code{length (@var{u})} rows and\n\
 @code{length (@var{m})} columns.  Otherwise, @var{u} and\n\
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -889,17 +889,17 @@ handle_message (error_fun f, const char 
         }
     }
 
   return retval;
 }
 
 DEFUN (rethrow, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} rethrow (@var{err})\n\
+@deftypefn {} {} rethrow (@var{err})\n\
 Reissue a previous error as defined by @var{err}.\n\
 \n\
 @var{err} is a structure that must contain at least the @qcode{\"message\"}\n\
 and @qcode{\"identifier\"} fields.  @var{err} can also contain a field\n\
 @qcode{\"stack\"} that gives information on the assumed location of the\n\
 error.  Typically @var{err} is returned from @code{lasterror}.\n\
 @seealso{lasterror, lasterr, error}\n\
 @end deftypefn")
@@ -1077,18 +1077,18 @@ maybe_extract_message_id (const std::str
         }
     }
 
   return have_fmt;
 }
 
 DEFUN (error, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} error (@var{template}, @dots{})\n\
-@deftypefnx {Built-in Function} {} error (@var{id}, @var{template}, @dots{})\n\
+@deftypefn  {} {} error (@var{template}, @dots{})\n\
+@deftypefnx {} {} error (@var{id}, @var{template}, @dots{})\n\
 Display an error message and stop m-file execution.\n\
 \n\
 Format the optional arguments under the control of the template string\n\
 @var{template} using the same rules as the @code{printf} family of\n\
 functions (@pxref{Formatted Output}) and print the resulting message\n\
 on the @code{stderr} stream.  The message is prefixed by the character\n\
 string @samp{error: }.\n\
 \n\
@@ -1399,24 +1399,24 @@ set_warning_option (const std::string& s
   warning_options.clear ();
 
   warning_options.assign ("identifier", tid);
   warning_options.assign ("state", tst);
 }
 
 DEFUN (warning, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} warning (@var{template}, @dots{})\n\
-@deftypefnx {Built-in Function} {} warning (@var{id}, @var{template}, @dots{})\n\
-@deftypefnx {Built-in Function} {} warning (\"on\", @var{id})\n\
-@deftypefnx {Built-in Function} {} warning (\"off\", @var{id})\n\
-@deftypefnx {Built-in Function} {} warning (\"query\", @var{id})\n\
-@deftypefnx {Built-in Function} {} warning (\"error\", @var{id})\n\
-@deftypefnx {Built-in Function} {} warning (@var{state}, \"backtrace\")\n\
-@deftypefnx {Built-in Function} {} warning (@var{state}, @var{id}, \"local\")\n\
+@deftypefn  {} {} warning (@var{template}, @dots{})\n\
+@deftypefnx {} {} warning (@var{id}, @var{template}, @dots{})\n\
+@deftypefnx {} {} warning (\"on\", @var{id})\n\
+@deftypefnx {} {} warning (\"off\", @var{id})\n\
+@deftypefnx {} {} warning (\"query\", @var{id})\n\
+@deftypefnx {} {} warning (\"error\", @var{id})\n\
+@deftypefnx {} {} warning (@var{state}, \"backtrace\")\n\
+@deftypefnx {} {} warning (@var{state}, @var{id}, \"local\")\n\
 Display a warning message or control the behavior of Octave's warning system.\n\
 \n\
 Format the optional arguments under the control of the template string\n\
 @var{template} using the same rules as the @code{printf} family of\n\
 functions (@pxref{Formatted Output}) and print the resulting message\n\
 on the @code{stderr} stream.  The message is prefixed by the character\n\
 string @samp{warning: }.\n\
 You should use this function when you want to notify the user\n\
@@ -1792,19 +1792,19 @@ initialize_default_warning_state (void)
   disable_warning ("Octave:single-quote-string");
   disable_warning ("Octave:str-to-num");
   disable_warning ("Octave:mixed-string-concat");
   disable_warning ("Octave:variable-switch-label");
 }
 
 DEFUN (lasterror, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{lasterr} =} lasterror ()\n\
-@deftypefnx {Built-in Function} {} lasterror (@var{err})\n\
-@deftypefnx {Built-in Function} {} lasterror (\"reset\")\n\
+@deftypefn  {} {@var{lasterr} =} lasterror ()\n\
+@deftypefnx {} {} lasterror (@var{err})\n\
+@deftypefnx {} {} lasterror (\"reset\")\n\
 Query or set the last error message structure.\n\
 \n\
 When called without arguments, return a structure containing the last error\n\
 message and other information related to this error.  The elements of the\n\
 structure are:\n\
 \n\
 @table @code\n\
 @item message\n\
@@ -1951,19 +1951,19 @@ fields are set to their default values.\
         error ("lasterror: argument must be a structure or a string");
     }
 
   return octave_value (err);
 }
 
 DEFUN (lasterr, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{msg}, @var{msgid}] =} lasterr ()\n\
-@deftypefnx {Built-in Function} {} lasterr (@var{msg})\n\
-@deftypefnx {Built-in Function} {} lasterr (@var{msg}, @var{msgid})\n\
+@deftypefn  {} {[@var{msg}, @var{msgid}] =} lasterr ()\n\
+@deftypefnx {} {} lasterr (@var{msg})\n\
+@deftypefnx {} {} lasterr (@var{msg}, @var{msgid})\n\
 Query or set the last error message.\n\
 \n\
 When called without input arguments, return the last error message and\n\
 message identifier.\n\
 \n\
 With one argument, set the last error message to @var{msg}.\n\
 \n\
 With two arguments, also set the last message identifier.\n\
@@ -1994,19 +1994,19 @@ With two arguments, also set the last me
   if (nargin == 0 || nargout > 0)
     return ovl (prev_error_message, prev_error_id);
   else
     return octave_value_list ();
 }
 
 DEFUN (lastwarn, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{msg}, @var{msgid}] =} lastwarn ()\n\
-@deftypefnx {Built-in Function} {} lastwarn (@var{msg})\n\
-@deftypefnx {Built-in Function} {} lastwarn (@var{msg}, @var{msgid})\n\
+@deftypefn  {} {[@var{msg}, @var{msgid}] =} lastwarn ()\n\
+@deftypefnx {} {} lastwarn (@var{msg})\n\
+@deftypefnx {} {} lastwarn (@var{msg}, @var{msgid})\n\
 Query or set the last warning message.\n\
 \n\
 When called without input arguments, return the last warning message and\n\
 message identifier.\n\
 \n\
 With one argument, set the last warning message to @var{msg}.\n\
 \n\
 With two arguments, also set the last message identifier.\n\
@@ -2038,17 +2038,17 @@ With two arguments, also set the last me
     return ovl (prev_warning_message, prev_warning_id);
   else
     return octave_value_list ();
 }
 
 /* FIXME: Deprecated in 4.0 and scheduled for removal in 4.4 */
 DEFUN (__usage__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} usage (@var{msg})\n\
+@deftypefn {} {} usage (@var{msg})\n\
 Print the message @var{msg}, prefixed by the string @samp{usage: }, and\n\
 set Octave's internal error state such that control will return to the\n\
 top level without evaluating any more commands.  This is useful for\n\
 aborting from functions.\n\
 \n\
 After @code{usage} is evaluated, Octave will print a traceback of all\n\
 the function calls leading to the usage message.\n\
 \n\
@@ -2072,35 +2072,35 @@ to check for the proper number of argume
 {
   octave_value_list retval;
   handle_message (usage_with_id, "", "unknown", args, true);
   return retval;
 }
 
 DEFUN (beep_on_error, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} beep_on_error ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} beep_on_error (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} beep_on_error (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} beep_on_error ()\n\
+@deftypefnx {} {@var{old_val} =} beep_on_error (@var{new_val})\n\
+@deftypefnx {} {} beep_on_error (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to ring the terminal bell before printing an error message.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (beep_on_error);
 }
 
 DEFUN (debug_on_error, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} debug_on_error ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} debug_on_error (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} debug_on_error (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} debug_on_error ()\n\
+@deftypefnx {} {@var{old_val} =} debug_on_error (@var{new_val})\n\
+@deftypefnx {} {} debug_on_error (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when an error is encountered.\n\
 \n\
 This will also inhibit printing of the normal traceback message (you will\n\
 only see the top-level error message).\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
@@ -2108,19 +2108,19 @@ The original variable value is restored 
 @seealso{debug_on_warning, debug_on_interrupt}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_error);
 }
 
 DEFUN (debug_on_warning, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} debug_on_warning ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} debug_on_warning (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} debug_on_warning (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} debug_on_warning ()\n\
+@deftypefnx {} {@var{old_val} =} debug_on_warning (@var{new_val})\n\
+@deftypefnx {} {} debug_on_warning (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when a warning is encountered.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{debug_on_error, debug_on_interrupt}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -173,19 +173,19 @@ do_fft (const octave_value_list &args, c
 %!assert (fft (eye (2,2,"single")), single ([1,1; 1,-1]))
 
 %!error (fft ())
 */
 
 
 DEFUN (fft, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} fft (@var{x})\n\
-@deftypefnx {Built-in Function} {} fft (@var{x}, @var{n})\n\
-@deftypefnx {Built-in Function} {} fft (@var{x}, @var{n}, @var{dim})\n\
+@deftypefn  {} {} fft (@var{x})\n\
+@deftypefnx {} {} fft (@var{x}, @var{n})\n\
+@deftypefnx {} {} fft (@var{x}, @var{n}, @var{dim})\n\
 Compute the discrete Fourier transform of @var{A} using\n\
 a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The FFT is calculated along the first non-singleton dimension of the\n\
 array.  Thus if @var{x} is a matrix, @code{fft (@var{x})} computes the\n\
 FFT for each column of @var{x}.\n\
 \n\
 If called with two arguments, @var{n} is expected to be an integer\n\
@@ -202,19 +202,19 @@ dimension of the matrix along which the 
 @end deftypefn")
 {
   return do_fft (args, "fft", 0);
 }
 
 
 DEFUN (ifft, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} ifft (@var{x})\n\
-@deftypefnx {Built-in Function} {} ifft (@var{x}, @var{n})\n\
-@deftypefnx {Built-in Function} {} ifft (@var{x}, @var{n}, @var{dim})\n\
+@deftypefn  {} {} ifft (@var{x})\n\
+@deftypefnx {} {} ifft (@var{x}, @var{n})\n\
+@deftypefnx {} {} ifft (@var{x}, @var{n}, @var{dim})\n\
 Compute the inverse discrete Fourier transform of @var{A}\n\
 using a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The inverse FFT is calculated along the first non-singleton dimension\n\
 of the array.  Thus if @var{x} is a matrix, @code{fft (@var{x})} computes\n\
 the inverse FFT for each column of @var{x}.\n\
 \n\
 If called with two arguments, @var{n} is expected to be an integer\n\
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -141,18 +141,18 @@ do_fft2 (const octave_value_list &args, 
         gripe_wrong_type_arg (fcn, arg);
     }
 
   return retval;
 }
 
 DEFUN (fft2, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} fft2 (@var{A})\n\
-@deftypefnx {Built-in Function} {} fft2 (@var{A}, @var{m}, @var{n})\n\
+@deftypefn  {} {} fft2 (@var{A})\n\
+@deftypefnx {} {} fft2 (@var{A}, @var{m}, @var{n})\n\
 Compute the two-dimensional discrete Fourier transform of @var{A} using\n\
 a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional arguments @var{m} and @var{n} may be used specify the number of\n\
 rows and columns of @var{A} to use.  If either of these is larger than the\n\
 size of @var{A}, @var{A} is resized and padded with zeros.\n\
 \n\
 If @var{A} is a multi-dimensional matrix, each two-dimensional sub-matrix\n\
@@ -161,18 +161,18 @@ of @var{A} is treated separately.\n\
 @end deftypefn")
 {
   return do_fft2 (args, "fft2", 0);
 }
 
 
 DEFUN (ifft2, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} ifft2 (@var{A})\n\
-@deftypefnx {Built-in Function} {} ifft2 (@var{A}, @var{m}, @var{n})\n\
+@deftypefn  {} {} ifft2 (@var{A})\n\
+@deftypefnx {} {} ifft2 (@var{A}, @var{m}, @var{n})\n\
 Compute the inverse two-dimensional discrete Fourier transform of @var{A}\n\
 using a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional arguments @var{m} and @var{n} may be used specify the number of\n\
 rows and columns of @var{A} to use.  If either of these is larger than the\n\
 size of @var{A}, @var{A} is resized and padded with zeros.\n\
 \n\
 If @var{A} is a multi-dimensional matrix, each two-dimensional sub-matrix\n\
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -128,18 +128,18 @@ do_fftn (const octave_value_list &args, 
         gripe_wrong_type_arg (fcn, arg);
     }
 
   return retval;
 }
 
 DEFUN (fftn, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} fftn (@var{A})\n\
-@deftypefnx {Built-in Function} {} fftn (@var{A}, @var{size})\n\
+@deftypefn  {} {} fftn (@var{A})\n\
+@deftypefnx {} {} fftn (@var{A}, @var{size})\n\
 Compute the N-dimensional discrete Fourier transform of @var{A} using\n\
 a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional vector argument @var{size} may be used specify the dimensions\n\
 of the array to be used.  If an element of @var{size} is smaller than the\n\
 corresponding dimension of @var{A}, then the dimension of @var{A} is\n\
 truncated prior to performing the FFT@.  Otherwise, if an element of\n\
 @var{size} is larger than the corresponding dimension then @var{A} is\n\
@@ -147,18 +147,18 @@ resized and padded with zeros.\n\
 @seealso{ifftn, fft, fft2, fftw}\n\
 @end deftypefn")
 {
   return do_fftn (args, "fftn", 0);
 }
 
 DEFUN (ifftn, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} ifftn (@var{A})\n\
-@deftypefnx {Built-in Function} {} ifftn (@var{A}, @var{size})\n\
+@deftypefn  {} {} ifftn (@var{A})\n\
+@deftypefnx {} {} ifftn (@var{A}, @var{size})\n\
 Compute the inverse N-dimensional discrete Fourier transform of @var{A}\n\
 using a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional vector argument @var{size} may be used specify the dimensions\n\
 of the array to be used.  If an element of @var{size} is smaller than the\n\
 corresponding dimension of @var{A}, then the dimension of @var{A} is\n\
 truncated prior to performing the inverse FFT@.  Otherwise, if an element of\n\
 @var{size} is larger than the corresponding dimension then @var{A} is\n\
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -227,19 +227,19 @@ fopen_mode_to_ios_mode (const std::strin
   else
     error ("invalid mode specified");
 
   return retval;
 }
 
 DEFUN (fclose, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} fclose (@var{fid})\n\
-@deftypefnx {Built-in Function} {} fclose (\"all\")\n\
-@deftypefnx {Built-in Function} {@var{status} =} fclose (\"all\")\n\
+@deftypefn  {} {} fclose (@var{fid})\n\
+@deftypefnx {} {} fclose (\"all\")\n\
+@deftypefnx {} {@var{status} =} fclose (\"all\")\n\
 Close the file specified by the file descriptor @var{fid}.\n\
 \n\
 If successful, @code{fclose} returns 0, otherwise, it returns -1.  The\n\
 second form of the @code{fclose} call closes all open files except\n\
 @code{stdin}, @code{stdout}, @code{stderr}, and any FIDs associated\n\
 with gnuplot.\n\
 @seealso{fopen, fflush, freport}\n\
 @end deftypefn")
@@ -247,17 +247,17 @@ with gnuplot.\n\
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (octave_stream_list::remove (args(0), "fclose"));
 }
 
 DEFUN (fclear, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} fclear (@var{fid})\n\
+@deftypefn {} {} fclear (@var{fid})\n\
 Clear the stream state for the file specified by the file descriptor\n\
 @var{fid}.\n\
 @seealso{ferror, fopen}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
@@ -269,17 +269,17 @@ Clear the stream state for the file spec
 
   os.clearerr ();
 
   return retval;
 }
 
 DEFUN (fflush, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} fflush (@var{fid})\n\
+@deftypefn {} {} fflush (@var{fid})\n\
 Flush output to file descriptor @var{fid}.\n\
 \n\
 @code{fflush} returns 0 on success and an OS dependent error value\n\
 (@minus{}1 on Unix) on error.\n\
 \n\
 Programming Note: Flushing is useful for ensuring that all pending output\n\
 makes it to the screen before some other event occurs.  For example, it is\n\
 always a good idea to flush the standard output stream before calling\n\
@@ -309,18 +309,18 @@ always a good idea to flush the standard
       retval = os.flush ();
     }
 
   return retval;
 }
 
 DEFUN (fgetl, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{str} =} fgetl (@var{fid})\n\
-@deftypefnx {Built-in Function} {@var{str} =} fgetl (@var{fid}, @var{len})\n\
+@deftypefn  {} {@var{str} =} fgetl (@var{fid})\n\
+@deftypefnx {} {@var{str} =} fgetl (@var{fid}, @var{len})\n\
 Read characters from a file, stopping after a newline, or EOF,\n\
 or @var{len} characters have been read.\n\
 \n\
 The characters read, excluding the possible trailing newline, are returned\n\
 as a string.\n\
 \n\
 If @var{len} is omitted, @code{fgetl} reads until the next newline character.\n\
 \n\
@@ -356,18 +356,18 @@ To read a line and return the terminatin
       retval(0) = tmp;
     }
 
   return retval;
 }
 
 DEFUN (fgets, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{str} =} fgets (@var{fid})\n\
-@deftypefnx {Built-in Function} {@var{str} =} fgets (@var{fid}, @var{len})\n\
+@deftypefn  {} {@var{str} =} fgets (@var{fid})\n\
+@deftypefnx {} {@var{str} =} fgets (@var{fid}, @var{len})\n\
 Read characters from a file, stopping after a newline, or EOF,\n\
 or @var{len} characters have been read.\n\
 \n\
 The characters read, including the possible trailing newline, are returned\n\
 as a string.\n\
 \n\
 If @var{len} is omitted, @code{fgets} reads until the next newline character.\n\
 \n\
@@ -403,19 +403,19 @@ To read a line and discard the terminati
       retval(0) = tmp;
     }
 
   return retval;
 }
 
 DEFUN (fskipl, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{nlines} =} fskipl (@var{fid})\n\
-@deftypefnx {Built-in Function} {@var{nlines} =} fskipl (@var{fid}, @var{count})\n\
-@deftypefnx {Built-in Function} {@var{nlines} =} fskipl (@var{fid}, Inf)\n\
+@deftypefn  {} {@var{nlines} =} fskipl (@var{fid})\n\
+@deftypefnx {} {@var{nlines} =} fskipl (@var{fid}, @var{count})\n\
+@deftypefnx {} {@var{nlines} =} fskipl (@var{fid}, Inf)\n\
 Read and skip @var{count} lines from the file specified by the file\n\
 descriptor @var{fid}.\n\
 \n\
 @code{fskipl} discards characters until an end-of-line is encountered exactly\n\
 @var{count}-times, or until the end-of-file marker is found.\n\
 \n\
 If @var{count} is omitted, it defaults to 1.  @var{count} may also be\n\
 @code{Inf}, in which case lines are skipped until the end of the file.\n\
@@ -521,22 +521,22 @@ do_stream_open (const octave_value& tc_n
 
   retval = do_stream_open (name, mode, arch, fid);
 
   return retval;
 }
 
 DEFUN (fopen, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{fid} =} fopen (@var{name})\n\
-@deftypefnx {Built-in Function} {@var{fid} =} fopen (@var{name}, @var{mode})\n\
-@deftypefnx {Built-in Function} {@var{fid} =} fopen (@var{name}, @var{mode}, @var{arch})\n\
-@deftypefnx {Built-in Function} {[@var{fid}, @var{msg}] =} fopen (@dots{})\n\
-@deftypefnx {Built-in Function} {@var{fid_list} =} fopen (\"all\")\n\
-@deftypefnx {Built-in Function} {[@var{file}, @var{mode}, @var{arch}] =} fopen (@var{fid})\n\
+@deftypefn  {} {@var{fid} =} fopen (@var{name})\n\
+@deftypefnx {} {@var{fid} =} fopen (@var{name}, @var{mode})\n\
+@deftypefnx {} {@var{fid} =} fopen (@var{name}, @var{mode}, @var{arch})\n\
+@deftypefnx {} {[@var{fid}, @var{msg}] =} fopen (@dots{})\n\
+@deftypefnx {} {@var{fid_list} =} fopen (\"all\")\n\
+@deftypefnx {} {[@var{file}, @var{mode}, @var{arch}] =} fopen (@var{fid})\n\
 Open a file for low-level I/O or query open files and file descriptors.\n\
 \n\
 The first form of the @code{fopen} function opens the named file with\n\
 the specified mode (read-write, read-only, etc.) and architecture\n\
 interpretation (IEEE big endian, IEEE little endian, etc.), and returns\n\
 an integer value that may be used to refer to the file later.  If an\n\
 error occurs, @var{fid} is set to @minus{}1 and @var{msg} contains the\n\
 corresponding system error message.  The @var{mode} is a one or two\n\
@@ -681,17 +681,17 @@ When opening a new file that does not ye
       retval(0) = -1.0;
     }
 
   return retval;
 }
 
 DEFUN (freport, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} freport ()\n\
+@deftypefn {} {} freport ()\n\
 Print a list of which files have been opened, and whether they are open\n\
 for reading, writing, or both.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 freport ()\n\
@@ -714,18 +714,18 @@ freport ()\n\
 
   octave_stdout << octave_stream_list::list_open_files ();
 
   return retval;
 }
 
 DEFUN (frewind, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} frewind (@var{fid})\n\
-@deftypefnx {Built-in Function} {@var{status} =} frewind (@var{fid})\n\
+@deftypefn  {} {} frewind (@var{fid})\n\
+@deftypefnx {} {@var{status} =} frewind (@var{fid})\n\
 Move the file pointer to the beginning of the file specified by file\n\
 descriptor @var{fid}.\n\
 \n\
 @code{frewind} returns 0 for success, and -1 if an error is encountered.  It\n\
 is equivalent to @code{fseek (@var{fid}, 0, SEEK_SET)}.\n\
 @seealso{fseek, ftell, fopen}\n\
 @end deftypefn")
 {
@@ -743,19 +743,19 @@ is equivalent to @code{fseek (@var{fid},
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (fseek, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} fseek (@var{fid}, @var{offset})\n\
-@deftypefnx {Built-in Function} {} fseek (@var{fid}, @var{offset}, @var{origin})\n\
-@deftypefnx {Built-in Function} {@var{status} =} fseek (@dots{})\n\
+@deftypefn  {} {} fseek (@var{fid}, @var{offset})\n\
+@deftypefnx {} {} fseek (@var{fid}, @var{offset}, @var{origin})\n\
+@deftypefnx {} {@var{status} =} fseek (@dots{})\n\
 Set the file pointer to the location @var{offset} within the file @var{fid}.\n\
 \n\
 The pointer is positioned @var{offset} characters from the @var{origin},\n\
 which may be one of the predefined variables @w{@code{SEEK_CUR}} (current\n\
 position), @w{@code{SEEK_SET}} (beginning), or @w{@code{SEEK_END}} (end of\n\
 file) or strings @qcode{\"cof\"}, @qcode{\"bof\"} or @qcode{\"eof\"}.  If\n\
 @var{origin} is omitted, @w{@code{SEEK_SET}} is assumed.  @var{offset} may\n\
 be positive, negative, or zero but not all combinations of @var{origin} and\n\
@@ -779,17 +779,17 @@ be positive, negative, or zero but not a
 
   retval = os.seek (args(1), origin_arg);
 
   return retval;
 }
 
 DEFUN (ftell, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{pos} =} ftell (@var{fid})\n\
+@deftypefn {} {@var{pos} =} ftell (@var{fid})\n\
 Return the position of the file pointer as the number of characters from the\n\
 beginning of the file specified by file descriptor @var{fid}.\n\
 @seealso{fseek, frewind, feof, fopen}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   if (args.length () != 1)
@@ -799,19 +799,19 @@ beginning of the file specified by file 
 
   retval = os.tell ();
 
   return retval;
 }
 
 DEFUN (fprintf, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} fprintf (@var{fid}, @var{template}, @dots{})\n\
-@deftypefnx {Built-in Function} {} fprintf (@var{template}, @dots{})\n\
-@deftypefnx {Built-in Function} {@var{numbytes} =} fprintf (@dots{})\n\
+@deftypefn  {} {} fprintf (@var{fid}, @var{template}, @dots{})\n\
+@deftypefnx {} {} fprintf (@var{template}, @dots{})\n\
+@deftypefnx {} {@var{numbytes} =} fprintf (@dots{})\n\
 This function is equivalent to @code{printf}, except that the output is\n\
 written to the file descriptor @var{fid} instead of @code{stdout}.\n\
 \n\
 If @var{fid} is omitted, the output is written to @code{stdout} making the\n\
 function exactly equivalent to @code{printf}.\n\
 \n\
 The optional output returns the number of bytes written to the file.\n\
 \n\
@@ -865,17 +865,17 @@ expanded even when the template string i
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (printf, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} printf (@var{template}, @dots{})\n\
+@deftypefn {} {} printf (@var{template}, @dots{})\n\
 Print optional arguments under the control of the template string\n\
 @var{template} to the stream @code{stdout} and return the number of\n\
 characters printed.\n\
 @ifclear OCTAVE_MANUAL\n\
 \n\
 See the Formatted Output section of the GNU Octave manual for a\n\
 complete description of the syntax of the template string.\n\
 @end ifclear\n\
@@ -917,18 +917,18 @@ expanded even when the template string i
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (fputs, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} fputs (@var{fid}, @var{string})\n\
-@deftypefnx {Built-in Function} {@var{status} =} fputs (@var{fid}, @var{string})\n\
+@deftypefn  {} {} fputs (@var{fid}, @var{string})\n\
+@deftypefnx {} {@var{status} =} fputs (@var{fid}, @var{string})\n\
 Write the string @var{string} to the file with file descriptor @var{fid}.\n\
 \n\
 The string is written to the file with no additional formatting.  Use\n\
 @code{fdisp} instead to automatically append a newline character appropriate\n\
 for the local machine.\n\
 \n\
 Return a non-negative number on success or EOF on error.\n\
 @seealso{fdisp, fprintf, fwrite, fopen}\n\
@@ -941,18 +941,18 @@ Return a non-negative number on success 
 
   octave_stream os = octave_stream_list::lookup (args(0), who);
 
   return octave_value (os.puts (args(1), who));
 }
 
 DEFUN (puts, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} puts (@var{string})\n\
-@deftypefnx {Built-in Function} {@var{status} =} puts (@var{string})\n\
+@deftypefn  {} {} puts (@var{string})\n\
+@deftypefnx {} {@var{status} =} puts (@var{string})\n\
 Write a string to the standard output with no formatting.\n\
 \n\
 The string is written verbatim to the standard output.  Use @code{disp} to\n\
 automatically append a newline character appropriate for the local machine.\n\
 \n\
 Return a non-negative number on success and EOF on error.\n\
 @seealso{fputs, disp}\n\
 @end deftypefn")
@@ -962,17 +962,17 @@ Return a non-negative number on success 
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (stdout_stream.puts (args(0), who));
 }
 
 DEFUN (sprintf, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} sprintf (@var{template}, @dots{})\n\
+@deftypefn {} {} sprintf (@var{template}, @dots{})\n\
 This is like @code{printf}, except that the output is returned as a\n\
 string.\n\
 \n\
 Unlike the C library function, which requires you to provide a suitably\n\
 sized string as an argument, Octave's @code{sprintf} function returns the\n\
 string, automatically sized to hold all of the items converted.\n\
 \n\
 Implementation Note: For compatibility with @sc{matlab}, escape sequences in\n\
@@ -1030,18 +1030,18 @@ expanded even when the template string i
   else
     error ("%s: unable to create output buffer", who.c_str ());
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, @var{size})\n\
-@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, \"C\")\n\
+@deftypefn  {} {[@var{val}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, @var{size})\n\
+@deftypefnx {} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, \"C\")\n\
 In the first form, read from @var{fid} according to @var{template},\n\
 returning the result in the matrix @var{val}.\n\
 \n\
 The optional argument @var{size} specifies the amount of data to read\n\
 and may be one of\n\
 \n\
 @table @code\n\
 @item Inf\n\
@@ -1145,18 +1145,18 @@ get_sscanf_data (const octave_value& val
   else
     error ("sscanf: argument STRING must be a string");
 
   return retval;
 }
 
 DEFUN (sscanf, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}, @var{pos}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
-@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} sscanf (@var{string}, @var{template}, \"C\")\n\
+@deftypefn  {} {[@var{val}, @var{count}, @var{errmsg}, @var{pos}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
+@deftypefnx {} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} sscanf (@var{string}, @var{template}, \"C\")\n\
 This is like @code{fscanf}, except that the characters are taken from the\n\
 string @var{string} instead of from a stream.\n\
 \n\
 Reaching the end of the string is treated as an end-of-file condition.  In\n\
 addition to the values returned by @code{fscanf}, the index of the next\n\
 character to be read is returned in @var{pos}.\n\
 @seealso{fscanf, scanf, sprintf}\n\
 @end deftypefn")
@@ -1229,18 +1229,18 @@ character to be read is returned in @var
                who.c_str  ());
     }
 
   return retval;
 }
 
 DEFUN (scanf, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} scanf (@var{template}, @var{size})\n\
-@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}]] =} scanf (@var{template}, \"C\")\n\
+@deftypefn  {} {[@var{val}, @var{count}, @var{errmsg}] =} scanf (@var{template}, @var{size})\n\
+@deftypefnx {} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}]] =} scanf (@var{template}, \"C\")\n\
 This is equivalent to calling @code{fscanf} with @var{fid} = @code{stdin}.\n\
 \n\
 It is currently not useful to call @code{scanf} in interactive programs.\n\
 @seealso{fscanf, sscanf, printf}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
@@ -1295,22 +1295,22 @@ do_fread (octave_stream& os, const octav
     = oct_mach_info::string_to_float_format (arch);
 
   return os.read (size, block_size, input_type, output_type, skip,
                   flt_fmt, count);
 }
 
 DEFUN (fread, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} fread (@var{fid})\n\
-@deftypefnx {Built-in Function} {@var{val} =} fread (@var{fid}, @var{size})\n\
-@deftypefnx {Built-in Function} {@var{val} =} fread (@var{fid}, @var{size}, @var{precision})\n\
-@deftypefnx {Built-in Function} {@var{val} =} fread (@var{fid}, @var{size}, @var{precision}, @var{skip})\n\
-@deftypefnx {Built-in Function} {@var{val} =} fread (@var{fid}, @var{size}, @var{precision}, @var{skip}, @var{arch})\n\
-@deftypefnx {Built-in Function} {[@var{val}, @var{count}] =} fread (@dots{})\n\
+@deftypefn  {} {@var{val} =} fread (@var{fid})\n\
+@deftypefnx {} {@var{val} =} fread (@var{fid}, @var{size})\n\
+@deftypefnx {} {@var{val} =} fread (@var{fid}, @var{size}, @var{precision})\n\
+@deftypefnx {} {@var{val} =} fread (@var{fid}, @var{size}, @var{precision}, @var{skip})\n\
+@deftypefnx {} {@var{val} =} fread (@var{fid}, @var{size}, @var{precision}, @var{skip}, @var{arch})\n\
+@deftypefnx {} {[@var{val}, @var{count}] =} fread (@dots{})\n\
 Read binary data from the file specified by the file descriptor @var{fid}.\n\
 \n\
 The optional argument @var{size} specifies the amount of data to read\n\
 and may be one of\n\
 \n\
 @table @code\n\
 @item Inf\n\
 Read as much as possible, returning a column vector.\n\
@@ -1550,21 +1550,21 @@ do_fwrite (octave_stream& os, const octa
   oct_mach_info::float_format flt_fmt
     = oct_mach_info::string_to_float_format (arch);
 
   return os.write (data, block_size, output_type, skip, flt_fmt);
 }
 
 DEFUN (fwrite, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} fwrite (@var{fid}, @var{data})\n\
-@deftypefnx {Built-in Function} {} fwrite (@var{fid}, @var{data}, @var{precision})\n\
-@deftypefnx {Built-in Function} {} fwrite (@var{fid}, @var{data}, @var{precision}, @var{skip})\n\
-@deftypefnx {Built-in Function} {} fwrite (@var{fid}, @var{data}, @var{precision}, @var{skip}, @var{arch})\n\
-@deftypefnx {Built-in Function} {@var{count} =} fwrite (@dots{})\n\
+@deftypefn  {} {} fwrite (@var{fid}, @var{data})\n\
+@deftypefnx {} {} fwrite (@var{fid}, @var{data}, @var{precision})\n\
+@deftypefnx {} {} fwrite (@var{fid}, @var{data}, @var{precision}, @var{skip})\n\
+@deftypefnx {} {} fwrite (@var{fid}, @var{data}, @var{precision}, @var{skip}, @var{arch})\n\
+@deftypefnx {} {@var{count} =} fwrite (@dots{})\n\
 Write data in binary form to the file specified by the file descriptor\n\
 @var{fid}, returning the number of values @var{count} successfully written\n\
 to the file.\n\
 \n\
 The argument @var{data} is a matrix of values that are to be written to\n\
 the file.  The values are extracted in column-major order.\n\
 \n\
 The remaining arguments @var{precision}, @var{skip}, and @var{arch} are\n\
@@ -1604,17 +1604,17 @@ are too large to fit in the specified pr
       skip = 0;
     }
 
   return octave_value (do_fwrite (os, data, prec, skip, arch));
 }
 
 DEFUNX ("feof", Ffeof, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{status} =} feof (@var{fid})\n\
+@deftypefn {} {@var{status} =} feof (@var{fid})\n\
 Return 1 if an end-of-file condition has been encountered for the file\n\
 specified by file descriptor @var{fid} and 0 otherwise.\n\
 \n\
 Note that @code{feof} will only return 1 if the end of the file has already\n\
 been encountered, not if the next read operation will result in an\n\
 end-of-file condition.\n\
 @seealso{fread, frewind, fseek, fclear, fopen}\n\
 @end deftypefn")
@@ -1624,19 +1624,19 @@ end-of-file condition.\n\
 
   octave_stream os = octave_stream_list::lookup (args(0), "feof");
 
   return octave_value (os.eof () ? 1.0 : 0.0);
 }
 
 DEFUNX ("ferror", Fferror, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{msg} =} ferror (@var{fid})\n\
-@deftypefnx {Built-in Function} {[@var{msg}, @var{err}] =} ferror (@var{fid})\n\
-@deftypefnx {Built-in Function} {[@var{dots}] =} ferror (@var{fid}, \"clear\")\n\
+@deftypefn  {} {@var{msg} =} ferror (@var{fid})\n\
+@deftypefnx {} {[@var{msg}, @var{err}] =} ferror (@var{fid})\n\
+@deftypefnx {} {[@var{dots}] =} ferror (@var{fid}, \"clear\")\n\
 Query the error status of the stream specified by file descriptor @var{fid}\n\
 \n\
 If an error condition exists then return a string @var{msg} describing the\n\
 error.  Otherwise, return an empty string @qcode{\"\"}.\n\
 \n\
 The second input @qcode{\"clear\"} is optional.  If supplied, the error\n\
 state on the stream will be cleared.\n\
 \n\
@@ -1673,17 +1673,17 @@ whether the next operation will result i
   retval(1) = error_number;
   retval(0) = error_message;
 
   return retval;
 }
 
 DEFUNX ("popen", Fpopen, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{fid} =} popen (@var{command}, @var{mode})\n\
+@deftypefn {} {@var{fid} =} popen (@var{command}, @var{mode})\n\
 Start a process and create a pipe.\n\
 \n\
 The name of the command to run is given by @var{command}.  The argument\n\
 @var{mode} may be\n\
 \n\
 @table @code\n\
 @item @qcode{\"r\"}\n\
 The pipe will be connected to the standard output of the process, and\n\
@@ -1737,34 +1737,34 @@ endwhile\n\
   else
     error ("popen: invalid MODE specified");
 
   return retval;
 }
 
 DEFUNX ("pclose", Fpclose, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} pclose (@var{fid})\n\
+@deftypefn {} {} pclose (@var{fid})\n\
 Close a file identifier that was opened by @code{popen}.\n\
 \n\
 The function @code{fclose} may also be used for the same purpose.\n\
 @seealso{fclose, popen}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (octave_stream_list::remove (args(0), "pclose"));
 }
 
 DEFUN (tempname, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{fname} =} tempname ()\n\
-@deftypefnx {Built-in Function} {@var{fname} =} tempname (@var{dir})\n\
-@deftypefnx {Built-in Function} {@var{fname} =} tempname (@var{dir}, @var{prefix})\n\
+@deftypefn  {} {@var{fname} =} tempname ()\n\
+@deftypefnx {} {@var{fname} =} tempname (@var{dir})\n\
+@deftypefnx {} {@var{fname} =} tempname (@var{dir}, @var{prefix})\n\
 Return a unique temporary filename as a string.\n\
 \n\
 If @var{prefix} is omitted, a value of @qcode{\"oct-\"} is used.\n\
 \n\
 If @var{dir} is also omitted, the default directory for temporary files\n\
 (@code{P_tmpdir}) is used.  If @var{dir} is provided, it must exist,\n\
 otherwise the default directory for temporary files is used.\n\
 \n\
@@ -1840,17 +1840,17 @@ see @code{tmpfile}.\n\
 %!   else
 %!     setenv (envname, envdir);
 %!   endif
 %! end_unwind_protect
 */
 
 DEFUN (tmpfile, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{fid}, @var{msg}] =} tmpfile ()\n\
+@deftypefn {} {[@var{fid}, @var{msg}] =} tmpfile ()\n\
 Return the file ID corresponding to a new temporary file with a unique\n\
 name.\n\
 \n\
 The file is opened in binary read/write (@qcode{\"w+b\"}) mode and will be\n\
 deleted automatically when it is closed or when Octave exits.\n\
 \n\
 If successful, @var{fid} is a valid file ID and @var{msg} is an empty\n\
 string.  Otherwise, @var{fid} is -1 and @var{msg} contains a\n\
@@ -1888,18 +1888,18 @@ system-dependent error message.\n\
       retval(0) = -1;
     }
 
   return retval;
 }
 
 DEFUN (mkstemp, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (\"@var{template}\")\n\
-@deftypefnx {Built-in Function} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (\"@var{template}\", @var{delete})\n\
+@deftypefn  {} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (\"@var{template}\")\n\
+@deftypefnx {} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (\"@var{template}\", @var{delete})\n\
 Return the file descriptor @var{fid} corresponding to a new temporary file\n\
 with a unique name created from @var{template}.\n\
 \n\
 The last six characters of @var{template} must be @qcode{\"XXXXXX\"} and\n\
 these are replaced with a string that makes the filename unique.  The file\n\
 is then created with mode read/write and permissions that are system\n\
 dependent (on GNU/Linux systems, the permissions will be 0600 for versions of\n\
 glibc 2.0.7 and later).  The file is opened in binary mode and with the\n\
@@ -2000,17 +2000,17 @@ convert (int x, int ibase, int obase)
         }
     }
 
   return retval;
 }
 
 DEFUNX ("umask", Fumask, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} umask (@var{mask})\n\
+@deftypefn {} {} umask (@var{mask})\n\
 Set the permission mask for file creation.\n\
 \n\
 The parameter @var{mask} is an integer, interpreted as an octal number.\n\
 \n\
 If successful, returns the previous value of the mask (as an integer to be\n\
 interpreted as an octal number); otherwise an error message is printed.\n\
 \n\
 The permission mask is a UNIX concept used when creating new objects on a\n\
@@ -2054,17 +2054,17 @@ const_value (const char *, const octave_
   if (args.length () != 0)
     print_usage ();
 
   return octave_value (val);
 }
 
 DEFUNX ("P_tmpdir", FP_tmpdir, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} P_tmpdir ()\n\
+@deftypefn {} {} P_tmpdir ()\n\
 Return the name of the host system's @strong{default} directory for\n\
 temporary files.\n\
 \n\
 Programming Note: The value returned by @code{P_tmpdir} is always the\n\
 default location.  This value may not agree with that returned from\n\
 @code{tempdir} if the user has overridden the default with the @env{TMPDIR}\n\
 environment variable.\n\
 @seealso{tempdir, tempname, mkstemp, tmpfile}\n\
@@ -2076,19 +2076,19 @@ environment variable.\n\
   return octave_value (get_P_tmpdir ());
 }
 
 // NOTE: the values of SEEK_SET, SEEK_CUR, and SEEK_END have to be
 // this way for Matlab compatibility.
 
 DEFUNX ("SEEK_SET", FSEEK_SET, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} SEEK_SET ()\n\
-@deftypefnx {Built-in Function} {} SEEK_CUR ()\n\
-@deftypefnx {Built-in Function} {} SEEK_END ()\n\
+@deftypefn  {} {} SEEK_SET ()\n\
+@deftypefnx {} {} SEEK_CUR ()\n\
+@deftypefnx {} {} SEEK_END ()\n\
 Return the numerical value to pass to @code{fseek} to perform one of the\n\
 following actions:\n\
 \n\
 @table @code\n\
 @item SEEK_SET\n\
 Position file relative to the beginning.\n\
 \n\
 @item SEEK_CUR\n\
@@ -2100,28 +2100,28 @@ Position file relative to the end.\n\
 @seealso{fseek}\n\
 @end deftypefn")
 {
   return const_value ("SEEK_SET", args, -1);
 }
 
 DEFUNX ("SEEK_CUR", FSEEK_CUR, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} SEEK_CUR ()\n\
+@deftypefn {} {} SEEK_CUR ()\n\
 Return the numerical value to pass to @code{fseek} to\n\
 position the file pointer relative to the current position.\n\
 @seealso{SEEK_SET, SEEK_END}\n\
 @end deftypefn")
 {
   return const_value ("SEEK_CUR", args, 0);
 }
 
 DEFUNX ("SEEK_END", FSEEK_END, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} SEEK_END ()\n\
+@deftypefn {} {} SEEK_END ()\n\
 Return the numerical value to pass to @code{fseek} to\n\
 position the file pointer relative to the end of the file.\n\
 @seealso{SEEK_SET, SEEK_CUR}\n\
 @end deftypefn")
 {
   return const_value ("SEEK_END", args, 1);
 }
 
@@ -2132,42 +2132,42 @@ const_value (const char *, const octave_
   if (args.length () != 0)
     print_usage ();
 
   return octave_value (val);
 }
 
 DEFUNX ("stdin", Fstdin, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} stdin ()\n\
+@deftypefn {} {} stdin ()\n\
 Return the numeric value corresponding to the standard input stream.\n\
 \n\
 When Octave is used interactively, stdin is filtered through the command\n\
 line editing functions.\n\
 @seealso{stdout, stderr}\n\
 @end deftypefn")
 {
   return const_value ("stdin", args, stdin_file);
 }
 
 DEFUNX ("stdout", Fstdout, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} stdout ()\n\
+@deftypefn {} {} stdout ()\n\
 Return the numeric value corresponding to the standard output stream.\n\
 \n\
 Data written to the standard output is normally filtered through the pager.\n\
 @seealso{stdin, stderr}\n\
 @end deftypefn")
 {
   return const_value ("stdout", args, stdout_file);
 }
 
 DEFUNX ("stderr", Fstderr, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} stderr ()\n\
+@deftypefn {} {} stderr ()\n\
 Return the numeric value corresponding to the standard error stream.\n\
 \n\
 Even if paging is turned on, the standard error is not sent to the pager.\n\
 It is useful for error messages and prompts.\n\
 @seealso{stdin, stdout}\n\
 @end deftypefn")
 {
   return const_value ("stderr", args, stderr_file);
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -265,20 +265,20 @@ filter (MArray<T>& b, MArray<T>& a, MArr
 
   MArray<T> si (si_dims, T (0.0));
 
   return filter (b, a, x, si, dim);
 }
 
 DEFUN (filter, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{y} =} filter (@var{b}, @var{a}, @var{x})\n\
-@deftypefnx {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})\n\
-@deftypefnx {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, [], @var{dim})\n\
-@deftypefnx {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si}, @var{dim})\n\
+@deftypefn  {} {@var{y} =} filter (@var{b}, @var{a}, @var{x})\n\
+@deftypefnx {} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})\n\
+@deftypefnx {} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, [], @var{dim})\n\
+@deftypefnx {} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si}, @var{dim})\n\
 Apply a 1-D digital filter to the data @var{x}.\n\
 \n\
 @code{filter} returns the solution to the following linear, time-invariant\n\
 difference equation:\n\
 @tex\n\
 $$\n\
 \\sum_{k=0}^N a_{k+1} y_{n-k} = \\sum_{k=0}^M b_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -314,21 +314,21 @@ find_nonzero_elem_idx (const PermMatrix&
       retval(0) = i_idx;
     }
 
   return retval;
 }
 
 DEFUN (find, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{idx} =} find (@var{x})\n\
-@deftypefnx {Built-in Function} {@var{idx} =} find (@var{x}, @var{n})\n\
-@deftypefnx {Built-in Function} {@var{idx} =} find (@var{x}, @var{n}, @var{direction})\n\
-@deftypefnx {Built-in Function} {[i, j] =} find (@dots{})\n\
-@deftypefnx {Built-in Function} {[i, j, v] =} find (@dots{})\n\
+@deftypefn  {} {@var{idx} =} find (@var{x})\n\
+@deftypefnx {} {@var{idx} =} find (@var{x}, @var{n})\n\
+@deftypefnx {} {@var{idx} =} find (@var{x}, @var{n}, @var{direction})\n\
+@deftypefnx {} {[i, j] =} find (@dots{})\n\
+@deftypefnx {} {[i, j, v] =} find (@dots{})\n\
 Return a vector of indices of nonzero elements of a matrix, as a row if\n\
 @var{x} is a row vector or as a column otherwise.\n\
 \n\
 To obtain a single index for each matrix element, Octave pretends that the\n\
 columns of a matrix form one long vector (like Fortran arrays are stored).\n\
 For example:\n\
 \n\
 @example\n\
diff --git a/libinterp/corefcn/gammainc.cc b/libinterp/corefcn/gammainc.cc
--- a/libinterp/corefcn/gammainc.cc
+++ b/libinterp/corefcn/gammainc.cc
@@ -29,19 +29,19 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (gammainc, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Mapping Function} {} gammainc (@var{x}, @var{a})\n\
-@deftypefnx {Mapping Function} {} gammainc (@var{x}, @var{a}, \"lower\")\n\
-@deftypefnx {Mapping Function} {} gammainc (@var{x}, @var{a}, \"upper\")\n\
+@deftypefn  {} {} gammainc (@var{x}, @var{a})\n\
+@deftypefnx {} {} gammainc (@var{x}, @var{a}, \"lower\")\n\
+@deftypefnx {} {} gammainc (@var{x}, @var{a}, \"upper\")\n\
 Compute the normalized incomplete gamma function.\n\
 \n\
 This is defined as\n\
 @tex\n\
 $$\n\
  \\gamma (x, a) = {1 \\over {\\Gamma (a)}}\\displaystyle{\\int_0^x t^{a-1} e^{-t} dt}\n\
 $$\n\
 @end tex\n\
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -430,18 +430,18 @@ do_extended_gcd (const octave_value& a, 
       y = y.float_array_value ();
     }
 
   return retval;
 }
 
 DEFUN (gcd, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{g} =} gcd (@var{a1}, @var{a2}, @dots{})\n\
-@deftypefnx {Built-in Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @var{a2}, @dots{})\n\
+@deftypefn  {} {@var{g} =} gcd (@var{a1}, @var{a2}, @dots{})\n\
+@deftypefnx {} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @var{a2}, @dots{})\n\
 Compute the greatest common divisor of @var{a1}, @var{a2}, @dots{}.\n\
 \n\
 If more than one argument is given then all arguments must be the same size\n\
 or scalar.  In this case the greatest common divisor is calculated for each\n\
 element individually.  All elements must be ordinary or Gaussian (complex)\n\
 integers.  Note that for Gaussian integers, the gcd is only unique up to a\n\
 phase factor (multiplication by 1, -1, i, or -i), so an arbitrary greatest\n\
 common divisor among the four possible is returned.\n\
diff --git a/libinterp/corefcn/getgrent.cc b/libinterp/corefcn/getgrent.cc
--- a/libinterp/corefcn/getgrent.cc
+++ b/libinterp/corefcn/getgrent.cc
@@ -59,17 +59,17 @@ mk_gr_map (const octave_group& gr)
   else
     retval = 0;
 
   return retval;
 }
 
 DEFUN (getgrent, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{grp_struct} =} getgrent ()\n\
+@deftypefn {} {@var{grp_struct} =} getgrent ()\n\
 Return an entry from the group database, opening it if necessary.\n\
 \n\
 Once the end of data has been reached, @code{getgrent} returns 0.\n\
 @seealso{setgrent, endgrent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -84,17 +84,17 @@ Once the end of data has been reached, @
   retval(1) = msg;
   retval(0) = val;
 
   return retval;
 }
 
 DEFUN (getgrgid, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
+@deftypefn {} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
 Return the first entry from the group database with the group ID\n\
 @var{gid}.\n\
 \n\
 If the group ID does not exist in the database, @code{getgrgid} returns 0.\n\
 @seealso{getgrnam}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -120,17 +120,17 @@ If the group ID does not exist in the da
   else
     error ("getgrgid: GID must be an integer");
 
   return retval;
 }
 
 DEFUN (getgrnam, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{grp_struct} =} getgrnam (@var{name})\n\
+@deftypefn {} {@var{grp_struct} =} getgrnam (@var{name})\n\
 Return the first entry from the group database with the group name\n\
 @var{name}.\n\
 \n\
 If the group name does not exist in the database, @code{getgrnam} returns 0.\n\
 @seealso{getgrgid}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -148,17 +148,17 @@ If the group name does not exist in the 
   retval(1) = msg;
   retval(0) = val;
 
   return retval;
 }
 
 DEFUN (setgrent, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} setgrent ()\n\
+@deftypefn {} {} setgrent ()\n\
 Return the internal pointer to the beginning of the group database.\n\
 @seealso{getgrent, endgrent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () != 0)
     print_usage ();
@@ -171,17 +171,17 @@ Return the internal pointer to the begin
   retval(1) = msg;
   retval(0) = static_cast<double> (status);
 
   return retval;
 }
 
 DEFUN (endgrent, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} endgrent ()\n\
+@deftypefn {} {} endgrent ()\n\
 Close the group database.\n\
 @seealso{getgrent, setgrent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () != 0)
     print_usage ();
diff --git a/libinterp/corefcn/getpwent.cc b/libinterp/corefcn/getpwent.cc
--- a/libinterp/corefcn/getpwent.cc
+++ b/libinterp/corefcn/getpwent.cc
@@ -62,17 +62,17 @@ mk_pw_map (const octave_passwd& pw)
   else
     retval = 0;
 
   return retval;
 }
 
 DEFUN (getpwent, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{pw_struct} =} getpwent ()\n\
+@deftypefn {} {@var{pw_struct} =} getpwent ()\n\
 Return a structure containing an entry from the password database,\n\
 opening it if necessary.\n\
 \n\
 Once the end of the data has been reached, @code{getpwent} returns 0.\n\
 @seealso{setpwent, endpwent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -88,17 +88,17 @@ Once the end of the data has been reache
   retval(1) = msg;
   retval(0) = val;
 
   return retval;
 }
 
 DEFUN (getpwuid, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{pw_struct} =} getpwuid (@var{uid}).\n\
+@deftypefn {} {@var{pw_struct} =} getpwuid (@var{uid}).\n\
 Return a structure containing the first entry from the password database\n\
 with the user ID @var{uid}.\n\
 \n\
 If the user ID does not exist in the database, @code{getpwuid} returns 0.\n\
 @seealso{getpwnam}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -123,17 +123,17 @@ If the user ID does not exist in the dat
   else
     error ("getpwuid: UID must be an integer");
 
   return retval;
 }
 
 DEFUN (getpwnam, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{pw_struct} =} getpwnam (@var{name})\n\
+@deftypefn {} {@var{pw_struct} =} getpwnam (@var{name})\n\
 Return a structure containing the first entry from the password database\n\
 with the user name @var{name}.\n\
 \n\
 If the user name does not exist in the database, @code{getpwname} returns 0.\n\
 @seealso{getpwuid}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -151,17 +151,17 @@ If the user name does not exist in the d
   retval(1) = msg;
   retval(0) = val;
 
   return retval;
 }
 
 DEFUN (setpwent, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} setpwent ()\n\
+@deftypefn {} {} setpwent ()\n\
 Return the internal pointer to the beginning of the password database.\n\
 @seealso{getpwent, endpwent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () != 0)
     print_usage ();
@@ -174,17 +174,17 @@ Return the internal pointer to the begin
   retval(1) = msg;
   retval(0) = static_cast<double> (status);
 
   return retval;
 }
 
 DEFUN (endpwent, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} endpwent ()\n\
+@deftypefn {} {} endpwent ()\n\
 Close the password database.\n\
 @seealso{getpwent, setpwent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () != 0)
     print_usage ();
diff --git a/libinterp/corefcn/getrusage.cc b/libinterp/corefcn/getrusage.cc
--- a/libinterp/corefcn/getrusage.cc
+++ b/libinterp/corefcn/getrusage.cc
@@ -56,17 +56,17 @@ along with Octave; see the file COPYING.
 #ifndef RUSAGE_SELF
 #define RUSAGE_SELF 0
 #endif
 
 // System resource functions.
 
 DEFUN (getrusage, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} getrusage ()\n\
+@deftypefn {} {} getrusage ()\n\
 Return a structure containing a number of statistics about the current\n\
 Octave process.\n\
 \n\
 Not all fields are available on all systems.  If it is not possible to get\n\
 CPU time statistics, the CPU time slots are set to zero.  Other missing data\n\
 are replaced by NaN@.  The list of possible fields is:\n\
 \n\
 @table @code\n\
diff --git a/libinterp/corefcn/givens.cc b/libinterp/corefcn/givens.cc
--- a/libinterp/corefcn/givens.cc
+++ b/libinterp/corefcn/givens.cc
@@ -27,18 +27,18 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 DEFUN (givens, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{G} =} givens (@var{x}, @var{y})\n\
-@deftypefnx {Built-in Function} {[@var{c}, @var{s}] =} givens (@var{x}, @var{y})\n\
+@deftypefn  {} {@var{G} =} givens (@var{x}, @var{y})\n\
+@deftypefnx {} {[@var{c}, @var{s}] =} givens (@var{x}, @var{y})\n\
 Compute the Givens rotation matrix @var{G}.\n\
 \n\
 @tex\n\
 The Givens matrix is a $2\\times 2$ orthogonal matrix\n\
 $$\n\
  G = \\left[\\matrix{c & s\\cr -s'& c\\cr}\\right]\n\
 $$\n\
 such that\n\
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -9572,17 +9572,17 @@ root_figure::init_factory_properties (vo
 
   return plist_map;
 }
 
 // ---------------------------------------------------------------------
 
 DEFUN (ishandle, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ishandle (@var{h})\n\
+@deftypefn {} {} ishandle (@var{h})\n\
 Return true if @var{h} is a graphics handle and false otherwise.\n\
 \n\
 @var{h} may also be a matrix of handles in which case a logical array is\n\
 returned that is true where the elements of @var{h} are graphics handles and\n\
 false where they are not.\n\
 @seealso{isaxes, isfigure}\n\
 @end deftypefn")
 {
@@ -9625,29 +9625,29 @@ is_handle_visible (const octave_value& v
       retval = result;
     }
 
   return retval;
 }
 
 DEFUN (__is_handle_visible__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __is_handle_visible__ (@var{h})\n\
+@deftypefn {} {} __is_handle_visible__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (is_handle_visible (args(0)));
 }
 
 DEFUN (reset, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} reset (@var{h})\n\
+@deftypefn {} {} reset (@var{h})\n\
 Reset the properties of the graphic object @var{h} to their default values.\n\
 \n\
 For figures, the properties @qcode{\"position\"}, @qcode{\"units\"},\n\
 @qcode{\"windowstyle\"}, and @qcode{\"paperunits\"} are not affected.\n\
 For axes, the properties @qcode{\"position\"} and @qcode{\"units\"} are\n\
 not affected.\n\
 \n\
 The input @var{h} may also be a vector of graphic handles in which case\n\
@@ -9790,21 +9790,21 @@ each individual object will be reset.\n\
 %!   close (hf);
 %!   set (0, "defaultfigurevisible", "remove");
 %! end_unwind_protect
 
 */
 
 DEFUN (set, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} set (@var{h}, @var{property}, @var{value}, @dots{})\n\
-@deftypefnx {Built-in Function} {} set (@var{h}, @var{properties}, @var{values})\n\
-@deftypefnx {Built-in Function} {} set (@var{h}, @var{pv})\n\
-@deftypefnx {Built-in Function} {@var{value_list} =} set (@var{h}, @var{property})\n\
-@deftypefnx {Built-in Function} {@var{all_value_list} =} set (@var{h})\n\
+@deftypefn  {} {} set (@var{h}, @var{property}, @var{value}, @dots{})\n\
+@deftypefnx {} {} set (@var{h}, @var{properties}, @var{values})\n\
+@deftypefnx {} {} set (@var{h}, @var{pv})\n\
+@deftypefnx {} {@var{value_list} =} set (@var{h}, @var{property})\n\
+@deftypefnx {} {@var{all_value_list} =} set (@var{h})\n\
 Set named property values for the graphics handle (or vector of graphics\n\
 handles) @var{h}.\n\
 \n\
 There are three ways to give the property names and values:\n\
 \n\
 @itemize\n\
 @item as a comma separated list of @var{property}, @var{value} pairs\n\
 \n\
@@ -9977,18 +9977,18 @@ get_graphics_object_type (double val)
   else
     error ("get: invalid handle (= %g)", val);
 
   return retval;
 }
 
 DEFUN (get, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} get (@var{h})\n\
-@deftypefnx {Built-in Function} {@var{val} =} get (@var{h}, @var{p})\n\
+@deftypefn  {} {@var{val} =} get (@var{h})\n\
+@deftypefnx {} {@var{val} =} get (@var{h}, @var{p})\n\
 Return the value of the named property @var{p} from the graphics handle\n\
 @var{h}.\n\
 \n\
 If @var{p} is omitted, return the complete property list for @var{h}.\n\
 \n\
 If @var{h} is a vector, return a cell array including the property values or\n\
 lists respectively.\n\
 @seealso{set}\n\
@@ -10122,17 +10122,17 @@ lists respectively.\n\
 */
 
 // Return all properties from the graphics handle @var{h}.
 // If @var{h} is a vector, return a cell array including the
 // property values or lists respectively.
 
 DEFUN (__get__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __get__ (@var{h})\n\
+@deftypefn {} {} __get__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   Cell vals;
@@ -10233,17 +10233,17 @@ make_graphics_object (const std::string&
   else
     error ("__go_%s__: invalid parent", go_name.c_str ());
 
   return retval;
 }
 
 DEFUN (__go_figure__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_figure__ (@var{fignum})\n\
+@deftypefn {} {} __go_figure__ (@var{fignum})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () == 0)
@@ -10364,17 +10364,17 @@ calc_dimensions (const graphics_object& 
         }
     }
 
   return nd;
 }
 
 DEFUN (__calc_dimensions__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __calc_dimensions__ (@var{axes})\n\
+@deftypefn {} {} __calc_dimensions__ (@var{axes})\n\
 Internal function.\n\
 \n\
 Determine the number of dimensions in a graphics object, either 2 or 3.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   if (args.length () != 1)
@@ -10382,143 +10382,143 @@ Determine the number of dimensions in a 
 
   double h = args(0).xdouble_value ("__calc_dimensions__: first argument must be a graphics handle");
 
   return octave_value (calc_dimensions (gh_manager::get_object (h)));
 }
 
 DEFUN (__go_axes__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_axes__ (@var{parent})\n\
+@deftypefn {} {} __go_axes__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (axes);
 }
 
 DEFUN (__go_line__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_line__ (@var{parent})\n\
+@deftypefn {} {} __go_line__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (line);
 }
 
 DEFUN (__go_text__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_text__ (@var{parent})\n\
+@deftypefn {} {} __go_text__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (text);
 }
 
 DEFUN (__go_image__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_image__ (@var{parent})\n\
+@deftypefn {} {} __go_image__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (image);
 }
 
 DEFUN (__go_surface__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_surface__ (@var{parent})\n\
+@deftypefn {} {} __go_surface__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (surface);
 }
 
 DEFUN (__go_patch__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_patch__ (@var{parent})\n\
+@deftypefn {} {} __go_patch__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (patch);
 }
 
 DEFUN (__go_hggroup__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_hggroup__ (@var{parent})\n\
+@deftypefn {} {} __go_hggroup__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (hggroup);
 }
 
 DEFUN (__go_uimenu__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_uimenu__ (@var{parent})\n\
+@deftypefn {} {} __go_uimenu__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uimenu);
 }
 
 DEFUN (__go_uicontrol__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_uicontrol__ (@var{parent})\n\
+@deftypefn {} {} __go_uicontrol__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uicontrol);
 }
 
 DEFUN (__go_uipanel__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_uipanel__ (@var{parent})\n\
+@deftypefn {} {} __go_uipanel__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uipanel);
 }
 
 DEFUN (__go_uicontextmenu__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_uicontextmenu__ (@var{parent})\n\
+@deftypefn {} {} __go_uicontextmenu__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uicontextmenu);
 }
 
 DEFUN (__go_uitoolbar__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_uitoolbar__ (@var{parent})\n\
+@deftypefn {} {} __go_uitoolbar__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uitoolbar);
 }
 
 DEFUN (__go_uipushtool__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_uipushtool__ (@var{parent})\n\
+@deftypefn {} {} __go_uipushtool__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uipushtool);
 }
 
 DEFUN (__go_uitoggletool__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_uitoggletool__ (@var{parent})\n\
+@deftypefn {} {} __go_uitoggletool__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uitoggletool);
 }
 
 DEFUN (__go_delete__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_delete__ (@var{h})\n\
+@deftypefn {} {} __go_delete__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value_list retval;
 
   if (args.length () != 1)
@@ -10543,17 +10543,17 @@ Undocumented internal function.\n\
 
   delete_graphics_objects (vals);
 
   return retval;
 }
 
 DEFUN (__go_axes_init__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_axes_init__ (@var{h}, @var{mode})\n\
+@deftypefn {} {} __go_axes_init__ (@var{h}, @var{mode})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   int nargin = args.length ();
@@ -10586,50 +10586,50 @@ Undocumented internal function.\n\
   else
     error ("__go_axes_init__: invalid graphics object (= %g)", val);
 
   return retval;
 }
 
 DEFUN (__go_handles__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_handles__ (@var{show_hidden})\n\
+@deftypefn {} {} __go_handles__ (@var{show_hidden})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   bool show_hidden = false;
 
   if (args.length () > 0)
     show_hidden = args(0).bool_value ();
 
   return octave_value (gh_manager::handle_list (show_hidden));
 }
 
 DEFUN (__go_figure_handles__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_figure_handles__ (@var{show_hidden})\n\
+@deftypefn {} {} __go_figure_handles__ (@var{show_hidden})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   bool show_hidden = false;
 
   if (args.length () > 0)
     show_hidden = args(0).bool_value ();
 
   return octave_value (gh_manager::figure_handle_list (show_hidden));
 }
 
 DEFUN (__go_execute_callback__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} __go_execute_callback__ (@var{h}, @var{name})\n\
-@deftypefnx {Built-in Function} {} __go_execute_callback__ (@var{h}, @var{name}, @var{param})\n\
+@deftypefn  {} {} __go_execute_callback__ (@var{h}, @var{name})\n\
+@deftypefnx {} {} __go_execute_callback__ (@var{h}, @var{name}, @var{param})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
@@ -10651,17 +10651,17 @@ Undocumented internal function.\n\
   else
     error ("__go_execute_callback__: invalid graphics object (= %g)", val);
 
   return retval;
 }
 
 DEFUN (__image_pixel_size__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{px}, @var{py}} __image_pixel_size__ (@var{h})\n\
+@deftypefn {} {@var{px}, @var{py}} __image_pixel_size__ (@var{h})\n\
 Internal function: returns the pixel size of the image in normalized units.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     print_usage ();
 
@@ -10771,29 +10771,29 @@ gtk_manager::do_unregister_toolkit (cons
                 dtk = tk_name;
             }
         }
     }
 }
 
 DEFUN (available_graphics_toolkits, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} available_graphics_toolkits ()\n\
+@deftypefn {} {} available_graphics_toolkits ()\n\
 Return a cell array of registered graphics toolkits.\n\
 @seealso{graphics_toolkit, register_graphics_toolkit}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   return octave_value (gtk_manager::available_toolkits_list ());
 }
 
 DEFUN (register_graphics_toolkit, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} register_graphics_toolkit (@var{toolkit})\n\
+@deftypefn {} {} register_graphics_toolkit (@var{toolkit})\n\
 List @var{toolkit} as an available graphics toolkit.\n\
 @seealso{available_graphics_toolkits}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   gh_manager::auto_lock guard;
 
@@ -10804,31 +10804,31 @@ List @var{toolkit} as an available graph
 
   gtk_manager::register_toolkit (name);
 
   return retval;
 }
 
 DEFUN (loaded_graphics_toolkits, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} loaded_graphics_toolkits ()\n\
+@deftypefn {} {} loaded_graphics_toolkits ()\n\
 Return a cell array of the currently loaded graphics toolkits.\n\
 @seealso{available_graphics_toolkits}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   return octave_value (gtk_manager::loaded_toolkits_list ());
 }
 
 DEFUN (drawnow, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} drawnow ()\n\
-@deftypefnx {Built-in Function} {} drawnow (\"expose\")\n\
-@deftypefnx {Built-in Function} {} drawnow (@var{term}, @var{file}, @var{mono}, @var{debug_file})\n\
+@deftypefn  {} {} drawnow ()\n\
+@deftypefnx {} {} drawnow (\"expose\")\n\
+@deftypefnx {} {} drawnow (@var{term}, @var{file}, @var{mono}, @var{debug_file})\n\
 Update figure windows and their children.\n\
 \n\
 The event queue is flushed and any callbacks generated are executed.\n\
 \n\
 With the optional argument @qcode{\"expose\"}, only graphic objects are\n\
 updated and no other events or callbacks are processed.\n\
 \n\
 The third calling form of @code{drawnow} is for debugging and is\n\
@@ -10997,17 +10997,17 @@ undocumented.\n\
 
   gh_manager::unlock ();
 
   return retval;
 }
 
 DEFUN (addlistener, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} addlistener (@var{h}, @var{prop}, @var{fcn})\n\
+@deftypefn {} {} addlistener (@var{h}, @var{prop}, @var{fcn})\n\
 Register @var{fcn} as listener for the property @var{prop} of the graphics\n\
 object @var{h}.\n\
 \n\
 Property listeners are executed (in order of registration) when the property\n\
 is set.  The new value is already available when the listeners are executed.\n\
 \n\
 @var{prop} must be a string naming a valid property in @var{h}.\n\
 \n\
@@ -11064,17 +11064,17 @@ addlistener (gcf, \"position\", @{@@my_l
   else
     error ("addlistener: invalid graphics object (= %g)", h);
 
   return retval;
 }
 
 DEFUN (dellistener, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} dellistener (@var{h}, @var{prop}, @var{fcn})\n\
+@deftypefn {} {} dellistener (@var{h}, @var{prop}, @var{fcn})\n\
 Remove the registration of @var{fcn} as a listener for the property\n\
 @var{prop} of the graphics object @var{h}.\n\
 \n\
 The function @var{fcn} must be the same variable (not just the same value),\n\
 as was passed to the original call to @code{addlistener}.\n\
 \n\
 If @var{fcn} is not defined then all listener functions of @var{prop}\n\
 are removed.\n\
@@ -11131,18 +11131,18 @@ dellistener (gcf, \"position\", c);\n\
   else
     error ("dellistener: invalid graphics object (= %g)", h);
 
   return retval;
 }
 
 DEFUN (addproperty, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} addproperty (@var{name}, @var{h}, @var{type})\n\
-@deftypefnx {Built-in Function} {} addproperty (@var{name}, @var{h}, @var{type}, @var{arg}, @dots{})\n\
+@deftypefn  {} {} addproperty (@var{name}, @var{h}, @var{type})\n\
+@deftypefnx {} {} addproperty (@var{name}, @var{h}, @var{type}, @var{arg}, @dots{})\n\
 Create a new property named @var{name} in graphics object @var{h}.\n\
 \n\
 @var{type} determines the type of the property to create.  @var{args}\n\
 usually contains the default value of the property, but additional\n\
 arguments might be given, depending on the type of the property.\n\
 \n\
 The supported property types are:\n\
 \n\
@@ -11387,20 +11387,20 @@ waitfor_del_listener (const octave_value
       waitfor_results[id] = true;
     }
 
   return octave_value_list ();
 }
 
 DEFUN (waitfor, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} waitfor (@var{h})\n\
-@deftypefnx {Built-in Function} {} waitfor (@var{h}, @var{prop})\n\
-@deftypefnx {Built-in Function} {} waitfor (@var{h}, @var{prop}, @var{value})\n\
-@deftypefnx {Built-in Function} {} waitfor (@dots{}, \"timeout\", @var{timeout})\n\
+@deftypefn  {} {} waitfor (@var{h})\n\
+@deftypefnx {} {} waitfor (@var{h}, @var{prop})\n\
+@deftypefnx {} {} waitfor (@var{h}, @var{prop}, @var{value})\n\
+@deftypefnx {} {} waitfor (@dots{}, \"timeout\", @var{timeout})\n\
 Suspend the execution of the current program until a condition is\n\
 satisfied on the graphics handle @var{h}.\n\
 \n\
 While the program is suspended graphics events are still processed normally,\n\
 allowing callbacks to modify the state of graphics objects.  This function\n\
 is reentrant and can be called from a callback, while another @code{waitfor}\n\
 call is pending at the top-level.\n\
 \n\
@@ -11628,19 +11628,19 @@ In all cases, typing CTRL-C stops progra
         }
     }
 
   return octave_value ();
 }
 
 DEFUN (__zoom__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} __zoom__ (@var{axes}, @var{mode}, @var{factor})\n\
-@deftypefnx {Built-in Function} {} __zoom__ (@var{axes}, \"out\")\n\
-@deftypefnx {Built-in Function} {} __zoom__ (@var{axes}, \"reset\")\n\
+@deftypefn  {} {} __zoom__ (@var{axes}, @var{mode}, @var{factor})\n\
+@deftypefnx {} {} __zoom__ (@var{axes}, \"out\")\n\
+@deftypefnx {} {} __zoom__ (@var{axes}, \"reset\")\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 2 && nargin != 3)
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -104,526 +104,526 @@ size (T const (&)[z])
 {
   return z;
 }
 
 const static pair_type operators[] =
 {
   pair_type ("!",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} !\n\
+@deftypefn {} {} !\n\
 Logical 'not' operator.\n\
 @seealso{~, not}\n\
 @end deftypefn"),
 
   pair_type ("~",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} ~\n\
+@deftypefn {} {} ~\n\
 Logical 'not' operator.\n\
 @seealso{!, not}\n\
 @end deftypefn"),
 
   pair_type ("!=",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} !=\n\
+@deftypefn {} {} !=\n\
 Logical 'not equals' operator.\n\
 @seealso{~=, ne}\n\
 @end deftypefn"),
 
   pair_type ("~=",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} ~=\n\
+@deftypefn {} {} ~=\n\
 Logical 'not equals' operator.\n\
 @seealso{!=, ne}\n\
 @end deftypefn"),
 
   pair_type ("\"",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} \"\n\
+@deftypefn {} {} \"\n\
 String delimiter.\n\
 @end deftypefn"),
 
   pair_type ("#",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} #\n\
+@deftypefn {} {} #\n\
 Begin comment character.\n\
 @seealso{%, #@\\{}\n\
 @end deftypefn"),
 
   pair_type ("%",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} %\n\
+@deftypefn {} {} %\n\
 Begin comment character.\n\
 @seealso{#, %@\\{}\n\
 @end deftypefn"),
 
   pair_type ("#{",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} #@{\n\
+@deftypefn {} {} #@{\n\
 Begin block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{#@{}.\n\
 It is possible to nest block comments.\n\
 @seealso{%@\\{, #@\\}, #}\n\
 @end deftypefn"),
 
   pair_type ("%{",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} %@{\n\
+@deftypefn {} {} %@{\n\
 Begin block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{%@{}.\n\
 It is possible to nest block comments.\n\
 @seealso{#@\\{, %@\\}, %}\n\
 @end deftypefn"),
 
   pair_type ("#}",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} #@}\n\
+@deftypefn {} {} #@}\n\
 Close block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{#@}}.\n\
 It is possible to nest block comments.\n\
 @seealso{%@\\}, #@\\{, #}\n\
 @end deftypefn"),
 
   pair_type ("%}",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} %@}\n\
+@deftypefn {} {} %@}\n\
 Close block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{%@}}.\n\
 It is possible to nest block comments.\n\
 @seealso{#@\\}, %@\\{, %}\n\
 @end deftypefn"),
 
   pair_type ("...",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} ...\n\
+@deftypefn {} {} ...\n\
 Continuation marker.  Joins current line with following line.\n\
 @end deftypefn"),
 
   pair_type ("&",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} &\n\
+@deftypefn {} {} &\n\
 Element by element logical 'and' operator.\n\
 @seealso{&&, and}\n\
 @end deftypefn"),
 
   pair_type ("&&",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} &&\n\
+@deftypefn {} {} &&\n\
 Logical 'and' operator (with short-circuit evaluation).\n\
 @seealso{&, and}\n\
 @end deftypefn"),
 
   pair_type ("'",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} '\n\
+@deftypefn {} {} '\n\
 Matrix transpose operator.  For complex matrices, computes the\n\
 complex conjugate (Hermitian) transpose.\n\
 \n\
 The single quote character may also be used to delimit strings, but\n\
 it is better to use the double quote character, since that is never\n\
 ambiguous.\n\
 @seealso{.', transpose}\n\
 @end deftypefn"),
 
   pair_type ("(",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} (\n\
+@deftypefn {} {} (\n\
 Array index or function argument delimiter.\n\
 @end deftypefn"),
 
   pair_type (")",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {})\n\
+@deftypefn {} {})\n\
 Array index or function argument delimiter.\n\
 @end deftypefn"),
 
   pair_type ("*",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} *\n\
+@deftypefn {} {} *\n\
 Multiplication operator.\n\
 @seealso{.*, times}\n\
 @end deftypefn"),
 
   pair_type ("**",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} **\n\
+@deftypefn {} {} **\n\
 Power operator.  This may return complex results for real inputs.  Use\n\
 @code{realsqrt}, @code{cbrt}, @code{nthroot}, or @code{realroot} to obtain\n\
 real results when possible.\n\
 @seealso{power, ^, .**, .^, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("^",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} ^\n\
+@deftypefn {} {} ^\n\
 Power operator.  This may return complex results for real inputs.  Use\n\
 @code{realsqrt}, @code{cbrt}, @code{nthroot}, or @code{realroot} to obtain\n\
 real results when possible.\n\
 @seealso{power, **, .^, .**, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("+",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} +\n\
+@deftypefn {} {} +\n\
 Addition operator.\n\
 @seealso{plus}\n\
 @end deftypefn"),
 
   pair_type ("++",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} ++\n\
+@deftypefn {} {} ++\n\
 Increment operator.  As in C, may be applied as a prefix or postfix\n\
 operator.\n\
 @seealso{--}\n\
 @end deftypefn"),
 
   pair_type (",",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} ,\n\
+@deftypefn {} {} ,\n\
 Array index, function argument, or command separator.\n\
 @end deftypefn"),
 
   pair_type ("-",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} -\n\
+@deftypefn {} {} -\n\
 Subtraction or unary negation operator.\n\
 @seealso{minus}\n\
 @end deftypefn"),
 
   pair_type ("--",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} --\n\
+@deftypefn {} {} --\n\
 Decrement operator.  As in C, may be applied as a prefix or postfix\n\
 operator.\n\
 @seealso{++}\n\
 @end deftypefn"),
 
   pair_type (".'",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} .'\n\
+@deftypefn {} {} .'\n\
 Matrix transpose operator.  For complex matrices, computes the\n\
 transpose, @emph{not} the complex conjugate transpose.\n\
 @seealso{', transpose}\n\
 @end deftypefn"),
 
   pair_type (".*",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} .*\n\
+@deftypefn {} {} .*\n\
 Element by element multiplication operator.\n\
 @seealso{*, times}\n\
 @end deftypefn"),
 
   pair_type (".**",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} .*\n\
+@deftypefn {} {} .*\n\
 Element by element power operator.  If several complex results are possible,\n\
 returns the one with smallest non-negative argument (angle).  Use\n\
 @code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
 real result is preferred.\n\
 @seealso{**, ^, .^, power, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type (".^",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} .^\n\
+@deftypefn {} {} .^\n\
 Element by element power operator.  If several complex results are possible,\n\
 returns the one with smallest non-negative argument (angle).  Use\n\
 @code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
 real result is preferred.\n\
 @seealso{.**, ^, **, power, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("./",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} ./\n\
+@deftypefn {} {} ./\n\
 Element by element right division operator.\n\
 @seealso{/, .\\, rdivide, mrdivide}\n\
 @end deftypefn"),
 
   pair_type ("/",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} /\n\
+@deftypefn {} {} /\n\
 Right division operator.\n\
 @seealso{./, \\, rdivide, mrdivide}\n\
 @end deftypefn"),
 
   pair_type (".\\",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} .\\\n\
+@deftypefn {} {} .\\\n\
 Element by element left division operator.\n\
 @seealso{\\, ./, rdivide, mrdivide}\n\
 @end deftypefn"),
 
   pair_type ("\\",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} \\\n\
+@deftypefn {} {} \\\n\
 Left division operator.\n\
 @seealso{.\\, /, ldivide, mldivide}\n\
 @end deftypefn"),
 
   pair_type (":",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} :\n\
+@deftypefn {} {} :\n\
 Select entire rows or columns of matrices.\n\
 @end deftypefn"),
 
   pair_type (";",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} ;\n\
+@deftypefn {} {} ;\n\
 Array row or command separator.\n\
 @seealso{,}\n\
 @end deftypefn"),
 
   pair_type ("<",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} <\n\
+@deftypefn {} {} <\n\
 'Less than' operator.\n\
 @seealso{lt}\n\
 @end deftypefn"),
 
   pair_type ("<=",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} <=\n\
+@deftypefn {} {} <=\n\
 'Less than' or 'equals' operator.\n\
 @seealso{le}\n\
 @end deftypefn"),
 
   pair_type ("=",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} =\n\
+@deftypefn {} {} =\n\
 Assignment operator.\n\
 @end deftypefn"),
 
   pair_type ("==",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} ==\n\
+@deftypefn {} {} ==\n\
 Equality test operator.\n\
 @seealso{eq}\n\
 @end deftypefn"),
 
   pair_type (">",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} >\n\
+@deftypefn {} {} >\n\
 'Greater than' operator.\n\
 @seealso{gt}\n\
 @end deftypefn"),
 
   pair_type (">=",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} >=\n\
+@deftypefn {} {} >=\n\
 'Greater than' or 'equals' operator.\n\
 @seealso{ge}\n\
 @end deftypefn"),
 
   pair_type ("[",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} [\n\
+@deftypefn {} {} [\n\
 Return list delimiter.\n\
 @seealso{]}\n\
 @end deftypefn"),
 
   pair_type ("]",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} ]\n\
+@deftypefn {} {} ]\n\
 Return list delimiter.\n\
 @seealso{[}\n\
 @end deftypefn"),
 
   pair_type ("|",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} |\n\
+@deftypefn {} {} |\n\
 Element by element logical 'or' operator.\n\
 @seealso{||, or}\n\
 @end deftypefn"),
 
   pair_type ("||",
   "-*- texinfo -*-\n\
-@deftypefn {Operator} {} ||\n\
+@deftypefn {} {} ||\n\
 Logical 'or' (with short-circuit evaluation) operator.\n\
 @seealso{|, or}\n\
 @end deftypefn"),
 };
 
 const static pair_type keywords[] =
 {
   pair_type ("break",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} break\n\
+@deftypefn {} {} break\n\
 Exit the innermost enclosing do, while or for loop.\n\
 @seealso{do, while, for, parfor, continue}\n\
 @end deftypefn"),
 
   pair_type ("case",
   "-*- texinfo -*-\n\
-@deftypefn  {Keyword} {} case @var{value}\n\
-@deftypefnx {Keyword} {} case @{@var{value}, @dots{}@}\n\
+@deftypefn  {} {} case @var{value}\n\
+@deftypefnx {} {} case @{@var{value}, @dots{}@}\n\
 A case statement in a switch.  Octave cases are exclusive and do not\n\
 fall-through as do C-language cases.  A switch statement must have at least\n\
 one case.  See @code{switch} for an example.\n\
 @seealso{switch}\n\
 @end deftypefn"),
 
   pair_type ("catch",
   "-*- texinfo -*-\n\
-@deftypefn  {Keyword} {} catch\n\
-@deftypefnx {Keyword} {} catch @var{value}\n\
+@deftypefn  {} {} catch\n\
+@deftypefnx {} {} catch @var{value}\n\
 Begin the cleanup part of a try-catch block.\n\
 @seealso{try}\n\
 @end deftypefn"),
 
   pair_type ("continue",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} continue\n\
+@deftypefn {} {} continue\n\
 Jump to the end of the innermost enclosing do, while or for loop.\n\
 @seealso{do, while, for, parfor, break}\n\
 @end deftypefn"),
 
   pair_type ("do",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} do\n\
+@deftypefn {} {} do\n\
 Begin a do-until loop.  This differs from a do-while loop in that the\n\
 body of the loop is executed at least once.\n\
 \n\
 @example\n\
 @group\n\
 i = 0;\n\
 do\n\
   i++\n\
 until (i == 10)\n\
 @end group\n\
 @end example\n\
 @seealso{for, until, while}\n\
 @end deftypefn"),
 
   pair_type ("else",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} else\n\
+@deftypefn {} {} else\n\
 Alternate action for an if block.  See @code{if} for an example.\n\
 @seealso{if}\n\
 @end deftypefn"),
 
   pair_type ("elseif",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} elseif (@var{condition})\n\
+@deftypefn {} {} elseif (@var{condition})\n\
 Alternate conditional test for an if block.  See @code{if} for an example.\n\
 @seealso{if}\n\
 @end deftypefn"),
 
   pair_type ("end",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} end\n\
+@deftypefn {} {} end\n\
 Mark the end of any @code{for}, @code{parfor}, @code{if}, @code{do},\n\
 @code{while}, @code{function}, @code{switch}, @code{try}, or\n\
 @code{unwind_protect} block.\n\
 @seealso{for, parfor, if, do, while, function, switch, try, unwind_protect}\n\
 @end deftypefn"),
 
   pair_type ("end_try_catch",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} end_try_catch\n\
+@deftypefn {} {} end_try_catch\n\
 Mark the end of an @code{try-catch} block.\n\
 @seealso{try, catch}\n\
 @end deftypefn"),
 
   pair_type ("end_unwind_protect",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} end_unwind_protect\n\
+@deftypefn {} {} end_unwind_protect\n\
 Mark the end of an unwind_protect block.\n\
 @seealso{unwind_protect}\n\
 @end deftypefn"),
 
   pair_type ("endfor",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} endfor\n\
+@deftypefn {} {} endfor\n\
 Mark the end of a for loop.  See @code{for} for an example.\n\
 @seealso{for}\n\
 @end deftypefn"),
 
   pair_type ("endfunction",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} endfunction\n\
+@deftypefn {} {} endfunction\n\
 Mark the end of a function.\n\
 @seealso{function}\n\
 @end deftypefn"),
 
   pair_type ("endif",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} endif\n\
+@deftypefn {} {} endif\n\
 Mark the end of an if block.  See @code{if} for an example.\n\
 @seealso{if}\n\
 @end deftypefn"),
 
   pair_type ("endparfor",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} endparfor\n\
+@deftypefn {} {} endparfor\n\
 Mark the end of a parfor loop.  See @code{parfor} for an example.\n\
 @seealso{parfor}\n\
 @end deftypefn"),
 
   pair_type ("endswitch",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} endswitch\n\
+@deftypefn {} {} endswitch\n\
 Mark the end of a switch block.  See @code{switch} for an example.\n\
 @seealso{switch}\n\
 @end deftypefn"),
 
   pair_type ("endwhile",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} endwhile\n\
+@deftypefn {} {} endwhile\n\
 Mark the end of a while loop.  See @code{while} for an example.\n\
 @seealso{do, while}\n\
 @end deftypefn"),
 
   pair_type ("for",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} for @var{i} = @var{range}\n\
+@deftypefn {} {} for @var{i} = @var{range}\n\
 Begin a for loop.\n\
 \n\
 @example\n\
 @group\n\
 for i = 1:10\n\
   i\n\
 endfor\n\
 @end group\n\
 @end example\n\
 @seealso{do, parfor, while}\n\
 @end deftypefn"),
 
   pair_type ("function",
   "-*- texinfo -*-\n\
-@deftypefn  {Keyword} {} function @var{outputs} = function (@var{input}, @dots{})\n\
-@deftypefnx {Keyword} {} function {} function (@var{input}, @dots{})\n\
-@deftypefnx {Keyword} {} function @var{outputs} = function\n\
+@deftypefn  {} {} function @var{outputs} = function (@var{input}, @dots{})\n\
+@deftypefnx {} {} function {} function (@var{input}, @dots{})\n\
+@deftypefnx {} {} function @var{outputs} = function\n\
 Begin a function body with @var{outputs} as results and @var{inputs} as\n\
 parameters.\n\
 @seealso{return}\n\
 @end deftypefn"),
 
   pair_type ("global",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} global @var{var}\n\
+@deftypefn {} {} global @var{var}\n\
 Declare variables to have global scope.\n\
 \n\
 @example\n\
 @group\n\
 global @var{x};\n\
 if (isempty (@var{x}))\n\
   x = 1;\n\
 endif\n\
 @end group\n\
 @end example\n\
 @seealso{persistent}\n\
 @end deftypefn"),
 
   pair_type ("if",
   "-*- texinfo -*-\n\
-@deftypefn  {Keyword} {} if (@var{cond}) @dots{} endif\n\
-@deftypefnx {Keyword} {} if (@var{cond}) @dots{} else @dots{} endif\n\
-@deftypefnx {Keyword} {} if (@var{cond}) @dots{} elseif (@var{cond}) @dots{} endif\n\
-@deftypefnx {Keyword} {} if (@var{cond}) @dots{} elseif (@var{cond}) @dots{} else @dots{} endif\n\
+@deftypefn  {} {} if (@var{cond}) @dots{} endif\n\
+@deftypefnx {} {} if (@var{cond}) @dots{} else @dots{} endif\n\
+@deftypefnx {} {} if (@var{cond}) @dots{} elseif (@var{cond}) @dots{} endif\n\
+@deftypefnx {} {} if (@var{cond}) @dots{} elseif (@var{cond}) @dots{} else @dots{} endif\n\
 Begin an if block.\n\
 \n\
 @example\n\
 @group\n\
 x = 1;\n\
 if (x == 1)\n\
   disp (\"one\");\n\
 elseif (x == 2)\n\
@@ -633,65 +633,65 @@ else\n\
 endif\n\
 @end group\n\
 @end example\n\
 @seealso{switch}\n\
 @end deftypefn"),
 
   pair_type ("otherwise",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} otherwise\n\
+@deftypefn {} {} otherwise\n\
 The default statement in a switch block (similar to else in an if block).\n\
 @seealso{switch}\n\
 @end deftypefn"),
 
   pair_type ("parfor",
   "-*- texinfo -*-\n\
-@deftypefn  {Keyword} {} parfor @var{i} = @var{range}\n\
-@deftypefnx {Keyword} {} parfor (@var{i} = @var{range}, @var{maxproc})\n\
+@deftypefn  {} {} parfor @var{i} = @var{range}\n\
+@deftypefnx {} {} parfor (@var{i} = @var{range}, @var{maxproc})\n\
 Begin a for loop that may execute in parallel.\n\
 \n\
 @example\n\
 @group\n\
 parfor i = 1:10\n\
   i\n\
 endparfor\n\
 @end group\n\
 @end example\n\
 @seealso{for, do, while}\n\
 @end deftypefn"),
 
   pair_type ("persistent",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} persistent @var{var}\n\
+@deftypefn {} {} persistent @var{var}\n\
 Declare variables as persistent.  A variable that has been declared\n\
 persistent within a function will retain its contents in memory between\n\
 subsequent calls to the same function.  The difference between persistent\n\
 variables and global variables is that persistent variables are local in\n\
 scope to a particular function and are not visible elsewhere.\n\
 @seealso{global}\n\
 @end deftypefn"),
 
   pair_type ("return",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} return\n\
+@deftypefn {} {} return\n\
 Return from a function.\n\
 @seealso{function}\n\
 @end deftypefn"),
 
   pair_type ("static",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} static\n\
+@deftypefn {} {} static\n\
 This statement has been deprecated in favor of @code{persistent}.\n\
 @seealso{persistent}\n\
 @end deftypefn"),
 
   pair_type ("switch",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} switch @var{statement}\n\
+@deftypefn {} {} switch @var{statement}\n\
 Begin a switch block.\n\
 \n\
 @example\n\
 @group\n\
 yesno = \"yes\"\n\
 \n\
 switch yesno\n\
   case @{\"Yes\" \"yes\" \"YES\" \"y\" \"Y\"@}\n\
@@ -703,71 +703,71 @@ switch yesno\n\
 endswitch\n\
 @end group\n\
 @end example\n\
 @seealso{if, case, otherwise}\n\
 @end deftypefn"),
 
   pair_type ("try",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} try\n\
+@deftypefn {} {} try\n\
 Begin a try-catch block.\n\
 \n\
 If an error occurs within a try block, then the catch code will be run and\n\
 execution will proceed after the catch block (though it is often\n\
 recommended to use the lasterr function to re-throw the error after cleanup\n\
 is completed).\n\
 @seealso{catch, unwind_protect}\n\
 @end deftypefn"),
 
   pair_type ("until",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} until (@var{cond})\n\
+@deftypefn {} {} until (@var{cond})\n\
 End a do-until loop.  See @code{do} for an example.\n\
 @seealso{do}\n\
 @end deftypefn"),
 
   pair_type ("unwind_protect",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} unwind_protect\n\
+@deftypefn {} {} unwind_protect\n\
 Begin an unwind_protect block.\n\
 \n\
 If an error occurs within the first part of an unwind_protect block\n\
 the commands within the unwind_protect_cleanup block are executed before\n\
 the error is thrown.  If an error is not thrown, then the\n\
 unwind_protect_cleanup block is still executed (in other words, the\n\
 unwind_protect_cleanup will be run with or without an error in the\n\
 unwind_protect block).\n\
 @seealso{unwind_protect_cleanup, try}\n\
 @end deftypefn"),
 
   pair_type ("unwind_protect_cleanup",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} unwind_protect_cleanup\n\
+@deftypefn {} {} unwind_protect_cleanup\n\
 Begin the cleanup section of an unwind_protect block.\n\
 @seealso{unwind_protect}\n\
 @end deftypefn"),
 
   pair_type ("varargin",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} varargin\n\
+@deftypefn {} {} varargin\n\
 Pass an arbitrary number of arguments into a function.\n\
 @seealso{varargout, nargin, isargout, nargout, nthargout}\n\
 @end deftypefn"),
 
   pair_type ("varargout",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} varargout\n\
+@deftypefn {} {} varargout\n\
 Pass an arbitrary number of arguments out of a function.\n\
 @seealso{varargin, nargin, isargout, nargout, nthargout}\n\
 @end deftypefn"),
 
   pair_type ("while",
   "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} while\n\
+@deftypefn {} {} while\n\
 Begin a while loop.\n\
 \n\
 @example\n\
 @group\n\
 i = 0;\n\
 while (i < 10)\n\
   i++\n\
 endwhile\n\
@@ -949,19 +949,19 @@ raw_help (const std::string& nm, bool& s
         }
     }
 
   return h;
 }
 
 DEFUN (built_in_docstrings_file, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} built_in_docstrings_file ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} built_in_docstrings_file (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} built_in_docstrings_file (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} built_in_docstrings_file ()\n\
+@deftypefnx {} {@var{old_val} =} built_in_docstrings_file (@var{new_val})\n\
+@deftypefnx {} {} built_in_docstrings_file (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 file containing docstrings for built-in Octave functions.\n\
 \n\
 The default value is\n\
 @file{@var{octave-home}/share/octave/@var{version}/etc/built-in-docstrings},\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
 and @var{version} is the Octave version number.  The default value may be\n\
 overridden by the environment variable\n\
@@ -1075,17 +1075,17 @@ do_get_help_text (const std::string& nam
       else
         {
           format = "plain text";
         }
     }
 }
 
 DEFUN (get_help_text, args, , "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{text}, @var{format}] =} get_help_text (@var{name})\n\
+@deftypefn {} {[@var{text}, @var{format}] =} get_help_text (@var{name})\n\
 Return the raw help text of function @var{name}.\n\
 \n\
 The raw help text is returned in @var{text} and the format in @var{format}\n\
 The format is a string which is one of @qcode{\"texinfo\"},\n\
 @qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @seealso{get_help_text_from_file}\n\
 @end deftypefn")
 {
@@ -1138,17 +1138,17 @@ do_get_help_text_from_file (const std::s
         {
           format = "plain text";
         }
     }
 }
 
 DEFUN (get_help_text_from_file, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{text}, @var{format}] =} get_help_text_from_file (@var{fname})\n\
+@deftypefn {} {[@var{text}, @var{format}] =} get_help_text_from_file (@var{fname})\n\
 Return the raw help text from the file @var{fname}.\n\
 \n\
 The raw help text is returned in @var{text} and the format in @var{format}\n\
 The format is a string which is one of @qcode{\"texinfo\"},\n\
 @qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @seealso{get_help_text}\n\
 @end deftypefn")
 {
@@ -1170,41 +1170,41 @@ The format is a string which is one of @
   return retval;
 }
 
 // Return a cell array of strings containing the names of all
 // operators.
 
 DEFUN (__operators__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {} __operators__ ()\n\
+@deftypefn {} {} __operators__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return octave_value (Cell (names (operators_map)));
 }
 
 // Return a cell array of strings containing the names of all
 // keywords.
 
 DEFUN (__keywords__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {} __keywords__ ()\n\
+@deftypefn {} {} __keywords__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return octave_value (Cell (names (keywords_map)));
 }
 
 // Return a cell array of strings containing the names of all builtin
 // functions.
 
 DEFUN (__builtins__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {} __builtins__ ()\n\
+@deftypefn {} {} __builtins__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   const string_vector bif = symbol_table::built_in_function_names ();
 
   return octave_value (Cell (bif));
 }
 
@@ -1275,17 +1275,17 @@ do_which (const std::string& name)
 
   retval = do_which (name, type);
 
   return retval;
 }
 
 DEFUN (__which__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __which__ (@var{name}, @dots{})\n\
+@deftypefn {} {} __which__ (@var{name}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   string_vector argv = args.make_argv ("which");
 
   int argc = argv.numel ();
 
   if (argc < 2)
@@ -1340,18 +1340,18 @@ file_is_in_dir (const std::string filena
 }
 
 // Return a cell array of strings containing the names of all
 // functions available in DIRECTORY.  If no directory is given, search
 // the current path.
 
 DEFUN (__list_functions__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Function File} {@var{retval} =} __list_functions__ ()\n\
-@deftypefnx {Function File} {@var{retval} =} __list_functions__ (@var{directory})\n\
+@deftypefn  {} {@var{retval} =} __list_functions__ ()\n\
+@deftypefnx {} {@var{retval} =} __list_functions__ (@var{directory})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   // Get list of functions
   string_vector ffl = load_path::fcn_names ();
   string_vector afl = autoloaded_functions ();
@@ -1372,19 +1372,19 @@ Undocumented internal function.\n\
       retval = Cell (fl);
     }
 
   return retval;
 }
 
 DEFUN (doc_cache_file, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} doc_cache_file ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} doc_cache_file (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} doc_cache_file (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} doc_cache_file ()\n\
+@deftypefnx {} {@var{old_val} =} doc_cache_file (@var{new_val})\n\
+@deftypefnx {} {} doc_cache_file (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 Octave documentation cache file.\n\
 \n\
 A cache file significantly improves the performance of the @code{lookfor}\n\
 command.  The default value is\n\
 @file{@var{octave-home}/share/octave/@var{version}/etc/doc-cache},\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
 and @var{version} is the Octave version number.\n\
@@ -1399,19 +1399,19 @@ The original variable value is restored 
 @seealso{lookfor}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (doc_cache_file);
 }
 
 DEFUN (texi_macros_file, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} texi_macros_file ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} texi_macros_file (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} texi_macros_file (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} texi_macros_file ()\n\
+@deftypefnx {} {@var{old_val} =} texi_macros_file (@var{new_val})\n\
+@deftypefnx {} {} texi_macros_file (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 file containing Texinfo macros that are prepended to documentation strings\n\
 before they are passed to makeinfo.\n\
 \n\
 The default value is\n\
 @file{@var{octave-home}/share/octave/@var{version}/etc/macros.texi},\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
 and @var{version} is the Octave version number.\n\
@@ -1425,19 +1425,19 @@ The original variable value is restored 
 @seealso{makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (texi_macros_file);
 }
 
 DEFUN (info_file, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} info_file ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} info_file (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} info_file (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} info_file ()\n\
+@deftypefnx {} {@var{old_val} =} info_file (@var{new_val})\n\
+@deftypefnx {} {} info_file (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 Octave info file.\n\
 \n\
 The default value is\n\
 @file{@var{octave-home}/info/octave.info}, in\n\
 which @var{octave-home} is the root directory of the Octave installation.\n\
 The default value may be overridden by the environment variable\n\
 @w{@env{OCTAVE_INFO_FILE}}, or the command line argument\n\
@@ -1449,19 +1449,19 @@ The original variable value is restored 
 @seealso{info_program, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_file);
 }
 
 DEFUN (info_program, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} info_program ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} info_program (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} info_program (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} info_program ()\n\
+@deftypefnx {} {@var{old_val} =} info_program (@var{new_val})\n\
+@deftypefnx {} {} info_program (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 info program to run.\n\
 \n\
 The default value is\n\
 @file{@var{octave-home}/libexec/octave/@var{version}/exec/@var{arch}/info}\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
 @var{version} is the Octave version number, and @var{arch} is the system\n\
 type (for example, @code{i686-pc-linux-gnu}).  The default value may be\n\
@@ -1475,19 +1475,19 @@ The original variable value is restored 
 @seealso{info_file, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_program);
 }
 
 DEFUN (makeinfo_program, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} makeinfo_program ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} makeinfo_program (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} makeinfo_program (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} makeinfo_program ()\n\
+@deftypefnx {} {@var{old_val} =} makeinfo_program (@var{new_val})\n\
+@deftypefnx {} {} makeinfo_program (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 program that Octave runs to format help text containing\n\
 Texinfo markup commands.\n\
 \n\
 The default value is @code{makeinfo}.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
@@ -1495,19 +1495,19 @@ The original variable value is restored 
 @seealso{texi_macros_file, info_file, info_program, doc, help}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (makeinfo_program);
 }
 
 DEFUN (suppress_verbose_help_message, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} suppress_verbose_help_message ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} suppress_verbose_help_message (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} suppress_verbose_help_message (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} suppress_verbose_help_message ()\n\
+@deftypefnx {} {@var{old_val} =} suppress_verbose_help_message (@var{new_val})\n\
+@deftypefnx {} {} suppress_verbose_help_message (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave\n\
 will add additional help information to the end of the output from\n\
 the @code{help} command and usage messages for built-in commands.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -32,18 +32,18 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (hess, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{H} =} hess (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{P}, @var{H}] =} hess (@var{A})\n\
+@deftypefn  {} {@var{H} =} hess (@var{A})\n\
+@deftypefnx {} {[@var{P}, @var{H}] =} hess (@var{A})\n\
 @cindex Hessenberg decomposition\n\
 Compute the Hessenberg decomposition of the matrix @var{A}.\n\
 \n\
 The Hessenberg decomposition is\n\
 @tex\n\
 $$\n\
 A = PHP^T\n\
 $$\n\
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -29,18 +29,18 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (hex2num, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{n} =} hex2num (@var{s})\n\
-@deftypefnx {Built-in Function} {@var{n} =} hex2num (@var{s}, @var{class})\n\
+@deftypefn  {} {@var{n} =} hex2num (@var{s})\n\
+@deftypefnx {} {@var{n} =} hex2num (@var{s}, @var{class})\n\
 Typecast the 16 character hexadecimal character string to an IEEE 754\n\
 double precision number.\n\
 \n\
 If fewer than 16 characters are given the strings are right padded with\n\
 @qcode{'0'} characters.\n\
 \n\
 Given a string matrix, @code{hex2num} treats each row as a separate number.\n\
 \n\
@@ -184,17 +184,17 @@ hex2num ([\"402df854\"; \"41200000\"], \
 
 /*
 %!assert (hex2num (["c00";"bff";"000";"3ff";"400"]), [-2:2]')
 %!assert (hex2num (["c00";"bf8";"000";"3f8";"400"], "single"), single([-2:2])')
 */
 
 DEFUN (num2hex, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{s} =} num2hex (@var{n})\n\
+@deftypefn {} {@var{s} =} num2hex (@var{n})\n\
 Typecast a double or single precision number or vector to a 8 or 16\n\
 character hexadecimal string of the IEEE 754 representation of the number.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 num2hex ([-1, 1, e, Inf])\n\
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -760,18 +760,18 @@ get_user_input (const octave_value_list&
   else
     error ("input: reading user-input failed!");
 
   return retval;
 }
 
 DEFUN (input, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{ans} =} input (@var{prompt})\n\
-@deftypefnx {Built-in Function} {@var{ans} =} input (@var{prompt}, \"s\")\n\
+@deftypefn  {} {@var{ans} =} input (@var{prompt})\n\
+@deftypefnx {} {@var{ans} =} input (@var{prompt}, \"s\")\n\
 Print @var{prompt} and wait for user input.\n\
 \n\
 For example,\n\
 \n\
 @example\n\
 input (\"Pick a number, any number! \")\n\
 @end example\n\
 \n\
@@ -827,17 +827,17 @@ octave_yes_or_no (const std::string& pro
         return false;
       else
         message (0, "Please answer yes or no.");
     }
 }
 
 DEFUN (yes_or_no, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{ans} =} yes_or_no (\"@var{prompt}\")\n\
+@deftypefn {} {@var{ans} =} yes_or_no (\"@var{prompt}\")\n\
 Ask the user a yes-or-no question.\n\
 \n\
 Return logical true if the answer is yes or false if the answer is no.\n\
 \n\
 Takes one argument, @var{prompt}, which is the string to display when asking\n\
 the question.  @var{prompt} should end in a space; @code{yes-or-no} adds the\n\
 string @samp{(yes or no) } to it.  The user must confirm the answer with\n\
 @key{RET} and can edit it until it has been confirmed.\n\
@@ -892,18 +892,18 @@ do_keyboard (const octave_value_list& ar
 
   get_debug_input (prompt);
 
   return retval;
 }
 
 DEFUN (keyboard, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} keyboard ()\n\
-@deftypefnx {Built-in Function} {} keyboard (\"@var{prompt}\")\n\
+@deftypefn  {} {} keyboard ()\n\
+@deftypefnx {} {} keyboard (\"@var{prompt}\")\n\
 Stop m-file execution and enter debug mode.\n\
 \n\
 When the @code{keyboard} function is executed, Octave prints a prompt and\n\
 waits for user input.  The input strings are then evaluated and the results\n\
 are printed.  This makes it possible to examine the values of variables\n\
 within a function, and to assign new values if necessary.  To leave the\n\
 prompt and return to normal execution type @samp{return} or @samp{dbcont}.\n\
 The @code{keyboard} function does not return an exit status.\n\
@@ -933,21 +933,21 @@ If @code{keyboard} is invoked without ar
 
   do_keyboard (args);
 
   return retval;
 }
 
 DEFUN (echo, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} echo\n\
-@deftypefnx {Command} {} echo on\n\
-@deftypefnx {Command} {} echo off\n\
-@deftypefnx {Command} {} echo on all\n\
-@deftypefnx {Command} {} echo off all\n\
+@deftypefn  {} {} echo\n\
+@deftypefnx {} {} echo on\n\
+@deftypefnx {} {} echo off\n\
+@deftypefnx {} {} echo on all\n\
+@deftypefnx {} {} echo off all\n\
 Control whether commands are displayed as they are executed.\n\
 \n\
 Valid options are:\n\
 \n\
 @table @code\n\
 @item on\n\
 Enable echoing of commands as they are executed in script files.\n\
 \n\
@@ -1064,26 +1064,26 @@ With no arguments, @code{echo} toggles t
 %!error echo ("Octave")
 %!error echo ("off", "invalid")
 %!error echo ("on", "invalid")
 %!error echo ("on", "all", "all")
 */
 
 DEFUN (__echostate__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{state} =} __echostate__ ()\n\
+@deftypefn {} {@var{state} =} __echostate__ ()\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   return ovl (Vecho_executing_commands == ECHO_SCRIPTS);
 }
 
 DEFUN (completion_matches, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} completion_matches (@var{hint})\n\
+@deftypefn {} {} completion_matches (@var{hint})\n\
 Generate possible completions given @var{hint}.\n\
 \n\
 This function is provided for the benefit of programs like Emacs which\n\
 might be controlling Octave and handling user input.  The current\n\
 command number is not incremented when this function is called.  This is\n\
 a feature, not a bug.\n\
 @end deftypefn")
 {
@@ -1157,17 +1157,17 @@ a feature, not a bug.\n\
 %!assert (! any (strcmp ("abs", deblank (cellstr (completion_matches ("absa"))))))
 
 %!error completion_matches ()
 %!error completion_matches (1, 2)
 */
 
 DEFUN (readline_read_init_file, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} readline_read_init_file (@var{file})\n\
+@deftypefn {} {} readline_read_init_file (@var{file})\n\
 Read the readline library initialization file @var{file}.\n\
 \n\
 If @var{file} is omitted, read the default initialization file\n\
 (normally @file{~/.inputrc}).\n\
 \n\
 @xref{Readline Init File, , , readline, GNU Readline Library},\n\
 for details.\n\
 @seealso{readline_re_read_init_file}\n\
@@ -1189,17 +1189,17 @@ for details.\n\
       command_editor::read_init_file (file);
     }
 
   return retval;
 }
 
 DEFUN (readline_re_read_init_file, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} readline_re_read_init_file ()\n\
+@deftypefn {} {} readline_re_read_init_file ()\n\
 Re-read the last readline library initialization file that was read.\n\
 \n\
 @xref{Readline Init File, , , readline, GNU Readline Library},\n\
 for details.\n\
 @seealso{readline_read_init_file}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -1220,18 +1220,18 @@ internal_input_event_hook_fcn (void)
   if (input_event_hook_functions.empty ())
     command_editor::remove_event_hook (internal_input_event_hook_fcn);
 
   return 0;
 }
 
 DEFUN (add_input_event_hook, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{id} =} add_input_event_hook (@var{fcn})\n\
-@deftypefnx {Built-in Function} {@var{id} =} add_input_event_hook (@var{fcn}, @var{data})\n\
+@deftypefn  {} {@var{id} =} add_input_event_hook (@var{fcn})\n\
+@deftypefnx {} {@var{id} =} add_input_event_hook (@var{fcn}, @var{data})\n\
 Add the named function or function handle @var{fcn} to the list of functions\n\
 to call periodically when Octave is waiting for input.\n\
 \n\
 The function should have the form\n\
 \n\
 @example\n\
 @var{fcn} (@var{data})\n\
 @end example\n\
@@ -1260,18 +1260,18 @@ list of input hook functions.\n\
 
   input_event_hook_functions.insert (hook_fcn.id (), hook_fcn);
 
   return octave_value (hook_fcn.id ());
 }
 
 DEFUN (remove_input_event_hook, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} remove_input_event_hook (@var{name})\n\
-@deftypefnx {Built-in Function} {} remove_input_event_hook (@var{fcn_id})\n\
+@deftypefn  {} {} remove_input_event_hook (@var{name})\n\
+@deftypefnx {} {} remove_input_event_hook (@var{fcn_id})\n\
 Remove the named function or function handle with the given identifier\n\
 from the list of functions to call periodically when Octave is waiting\n\
 for input.\n\
 @seealso{add_input_event_hook}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -1296,19 +1296,19 @@ for input.\n\
   if (input_event_hook_functions.empty ())
     command_editor::remove_event_hook (internal_input_event_hook_fcn);
 
   return retval;
 }
 
 DEFUN (PS1, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} PS1 ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} PS1 (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} PS1 (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} PS1 ()\n\
+@deftypefnx {} {@var{old_val} =} PS1 (@var{new_val})\n\
+@deftypefnx {} {} PS1 (@var{new_val}, \"local\")\n\
 Query or set the primary prompt string.\n\
 \n\
 When executing interactively, Octave displays the primary prompt when it is\n\
 ready to read a command.\n\
 \n\
 The default value of the primary prompt string is @qcode{\"octave:\\#> \"}.\n\
 To change it, use a command like\n\
 \n\
@@ -1338,19 +1338,19 @@ The original variable value is restored 
 @seealso{PS2, PS4}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS1);
 }
 
 DEFUN (PS2, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} PS2 ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} PS2 (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} PS2 (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} PS2 ()\n\
+@deftypefnx {} {@var{old_val} =} PS2 (@var{new_val})\n\
+@deftypefnx {} {} PS2 (@var{new_val}, \"local\")\n\
 Query or set the secondary prompt string.\n\
 \n\
 The secondary prompt is printed when Octave is expecting additional input to\n\
 complete a command.  For example, if you are typing a @code{for} loop that\n\
 spans several lines, Octave will print the secondary prompt at the beginning\n\
 of each line after the first.  The default value of the secondary prompt\n\
 string is @qcode{\"> \"}.\n\
 \n\
@@ -1360,19 +1360,19 @@ The original variable value is restored 
 @seealso{PS1, PS4}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS2);
 }
 
 DEFUN (PS4, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} PS4 ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} PS4 (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} PS4 (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} PS4 ()\n\
+@deftypefnx {} {@var{old_val} =} PS4 (@var{new_val})\n\
+@deftypefnx {} {} PS4 (@var{new_val}, \"local\")\n\
 Query or set the character string used to prefix output produced\n\
 when echoing commands is enabled.\n\
 \n\
 The default value is @qcode{\"+ \"}.\n\
 @xref{Diary and Echo Commands}, for a description of echoing commands.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
@@ -1380,37 +1380,37 @@ The original variable value is restored 
 @seealso{echo, echo_executing_commands, PS1, PS2}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS4);
 }
 
 DEFUN (completion_append_char, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} completion_append_char ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} completion_append_char (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} completion_append_char (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} completion_append_char ()\n\
+@deftypefnx {} {@var{old_val} =} completion_append_char (@var{new_val})\n\
+@deftypefnx {} {} completion_append_char (@var{new_val}, \"local\")\n\
 Query or set the internal character variable that is appended to\n\
 successful command-line completion attempts.\n\
 \n\
 The default value is @qcode{\" \"} (a single space).\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (completion_append_char);
 }
 
 DEFUN (echo_executing_commands, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} echo_executing_commands ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} echo_executing_commands (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} echo_executing_commands (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} echo_executing_commands ()\n\
+@deftypefnx {} {@var{old_val} =} echo_executing_commands (@var{new_val})\n\
+@deftypefnx {} {} echo_executing_commands (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls the echo state.\n\
 \n\
 It may be the sum of the following values:\n\
 \n\
 @table @asis\n\
 @item 1\n\
 Echo commands read from script files.\n\
 \n\
@@ -1432,18 +1432,18 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (echo_executing_commands);
 }
 
 DEFUN (__request_drawnow__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} __request_drawnow__ ()\n\
-@deftypefnx {Built-in Function} {} __request_drawnow__ (@var{flag})\n\
+@deftypefn  {} {} __request_drawnow__ ()\n\
+@deftypefnx {} {} __request_drawnow__ (@var{flag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
@@ -1454,17 +1454,17 @@ Undocumented internal function.\n\
   else
     Vdrawnow_requested = args(0).bool_value ();
 
   return retval;
 }
 
 DEFUN (__gud_mode__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __gud_mode__ ()\n\
+@deftypefn {} {} __gud_mode__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
@@ -1475,19 +1475,19 @@ Undocumented internal function.\n\
   else
     Vgud_mode = args(0).bool_value ();
 
   return retval;
 }
 
 DEFUN (filemarker, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} filemarker ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} filemarker (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} filemarker (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} filemarker ()\n\
+@deftypefnx {} {@var{old_val} =} filemarker (@var{new_val})\n\
+@deftypefnx {} {} filemarker (@var{new_val}, \"local\")\n\
 Query or set the character used to separate the filename from the subfunction\n\
 names contained within the file.\n\
 \n\
 By default this is the character @samp{>}.\n\
 This can be used in a generic manner to interact with subfunctions.\n\
 For example,\n\
 \n\
 @example\n\
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -33,18 +33,18 @@ along with Octave; see the file COPYING.
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 #include "utils.h"
 
 DEFUN (inv, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{x} =} inv (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{x}, @var{rcond}] =} inv (@var{A})\n\
+@deftypefn  {} {@var{x} =} inv (@var{A})\n\
+@deftypefnx {} {[@var{x}, @var{rcond}] =} inv (@var{A})\n\
 Compute the inverse of the square matrix @var{A}.\n\
 \n\
 Return an estimate of the reciprocal condition number if requested,\n\
 otherwise warn of an ill-conditioned matrix if the reciprocal condition\n\
 number is small.\n\
 \n\
 In general it is best to avoid calculating the inverse of a matrix directly.\n\
 For example, it is both faster and more accurate to solve systems of\n\
@@ -235,18 +235,18 @@ sparse matrix if possible.\n\
 */
 
 // FIXME: this should really be done with an alias, but
 // alias_builtin() won't do the right thing if we are actually using
 // dynamic linking.
 
 DEFUN (inverse, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{x} =} inverse (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{x}, @var{rcond}] =} inverse (@var{A})\n\
+@deftypefn  {} {@var{x} =} inverse (@var{A})\n\
+@deftypefnx {} {[@var{x}, @var{rcond}] =} inverse (@var{A})\n\
 Compute the inverse of the square matrix @var{A}.\n\
 \n\
 This is an alias for @code{inv}.\n\
 @seealso{inv}\n\
 @end deftypefn")
 {
   return Finv (args, nargout);
 }
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -227,18 +227,18 @@ dispatch_kron (const octave_value& a, co
       else
         retval = do_kron<Matrix, Matrix> (a, b);
     }
   return retval;
 }
 
 
 DEFUN (kron, args, , "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} kron (@var{A}, @var{B})\n\
-@deftypefnx {Built-in Function} {} kron (@var{A1}, @var{A2}, @dots{})\n\
+@deftypefn  {} {} kron (@var{A}, @var{B})\n\
+@deftypefnx {} {} kron (@var{A1}, @var{A2}, @dots{})\n\
 Form the Kronecker product of two or more matrices.\n\
 \n\
 This is defined block by block as\n\
 \n\
 @example\n\
 x = [ a(i,j)*b ]\n\
 @end example\n\
 \n\
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -2228,18 +2228,18 @@ execute_pkg_add (const std::string& dir)
 void
 execute_pkg_del (const std::string& dir)
 {
   execute_pkg_add_or_del (dir, "PKG_DEL");
 }
 
 DEFUN (genpath, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} genpath (@var{dir})\n\
-@deftypefnx {Built-in Function} {} genpath (@var{dir}, @var{skip}, @dots{})\n\
+@deftypefn  {} {} genpath (@var{dir})\n\
+@deftypefnx {} {} genpath (@var{dir}, @var{skip}, @dots{})\n\
 Return a path constructed from @var{dir} and all its subdirectories.\n\
 \n\
 If additional string parameters are given, the resulting path will exclude\n\
 directories with those names.\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -2278,41 +2278,41 @@ rehash_internal (void)
   // used for more than keeping track of the prompt time.
 
   // This will force updated functions to be found.
   Vlast_prompt_time.stamp ();
 }
 
 DEFUN (rehash, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} rehash ()\n\
+@deftypefn {} {} rehash ()\n\
 Reinitialize Octave's load path directory cache.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   rehash_internal ();
 
   return retval;
 }
 
 DEFUN (command_line_path, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} command_line_path (@dots{})\n\
+@deftypefn {} {} command_line_path (@dots{})\n\
 Return the command line path variable.\n\
 \n\
 @seealso{path, addpath, rmpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
   return octave_value (load_path::get_command_line_path ());
 }
 
 DEFUN (restoredefaultpath, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} restoredefaultpath (@dots{})\n\
+@deftypefn {} {} restoredefaultpath (@dots{})\n\
 Restore Octave's path to its initial state at startup.\n\
 \n\
 @seealso{path, addpath, rmpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
   load_path::initialize (true);
 
   return octave_value (load_path::system_path ());
@@ -2320,28 +2320,28 @@ Restore Octave's path to its initial sta
 
 // Return Octave's original default list of directories in which to
 // search for function files.  This corresponds to the path that
 // exists prior to running the system's octaverc file or the user's
 // ~/.octaverc file
 
 DEFUN (__pathorig__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} __pathorig__ ()\n\
+@deftypefn {} {@var{val} =} __pathorig__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return octave_value (load_path::system_path ());
 }
 
 DEFUN (path, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} path ()\n\
-@deftypefnx {Built-in Function} {@var{str} =} path ()\n\
-@deftypefnx {Built-in Function} {@var{str} =} path (@var{path1}, @dots{})\n\
+@deftypefn  {} {} path ()\n\
+@deftypefnx {} {@var{str} =} path ()\n\
+@deftypefnx {} {@var{str} =} path (@var{path1}, @dots{})\n\
 Modify or display Octave's load path.\n\
 \n\
 If @var{nargin} and @var{nargout} are zero, display the elements of\n\
 Octave's load path in an easy to read format.\n\
 \n\
 If @var{nargin} is zero and nargout is greater than zero, return the\n\
 current load path.\n\
 \n\
@@ -2383,18 +2383,18 @@ No checks are made for duplicate element
       octave_stdout << "\n";
     }
 
   return octave_value ();
 }
 
 DEFUN (addpath, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} addpath (@var{dir1}, @dots{})\n\
-@deftypefnx {Built-in Function} {} addpath (@var{dir1}, @dots{}, @var{option})\n\
+@deftypefn  {} {} addpath (@var{dir1}, @dots{})\n\
+@deftypefnx {} {} addpath (@var{dir1}, @dots{}, @var{option})\n\
 Add named directories to the function search path.\n\
 \n\
 If @var{option} is @qcode{\"-begin\"} or 0 (the default), prepend the\n\
 directory name to the current path.  If @var{option} is @qcode{\"-end\"}\n\
 or 1, append the directory name to the current path.\n\
 Directories added to the path must exist.\n\
 \n\
 In addition to accepting individual directory arguments, lists of\n\
@@ -2482,17 +2482,17 @@ addpath (\"dir1:/dir2:~/dir3\")\n\
   if (need_to_update)
     rehash_internal ();
 
   return retval;
 }
 
 DEFUN (rmpath, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} rmpath (@var{dir1}, @dots{})\n\
+@deftypefn {} {} rmpath (@var{dir1}, @dots{})\n\
 Remove @var{dir1}, @dots{} from the current function search path.\n\
 \n\
 In addition to accepting individual directory arguments, lists of\n\
 directory names separated by @code{pathsep} are also accepted.  For example:\n\
 \n\
 @example\n\
 rmpath (\"dir1:/dir2:~/dir3\")\n\
 @end example\n\
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -527,23 +527,23 @@ bool
 is_octave_data_file (const std::string& fname)
 {
   bool use_zlib = false;
   return get_file_format (fname, fname, use_zlib, true) != LS_UNKNOWN;
 }
 
 DEFUN (load, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} load file\n\
-@deftypefnx {Command} {} load options file\n\
-@deftypefnx {Command} {} load options file v1 v2 @dots{}\n\
-@deftypefnx {Command} {S =} load (\"options\", \"file\", \"v1\", \"v2\", @dots{})\n\
-@deftypefnx {Command} {} load file options\n\
-@deftypefnx {Command} {} load file options v1 v2 @dots{}\n\
-@deftypefnx {Command} {S =} load (\"file\", \"options\", \"v1\", \"v2\", @dots{})\n\
+@deftypefn  {} {} load file\n\
+@deftypefnx {} {} load options file\n\
+@deftypefnx {} {} load options file v1 v2 @dots{}\n\
+@deftypefnx {} {S =} load (\"options\", \"file\", \"v1\", \"v2\", @dots{})\n\
+@deftypefnx {} {} load file options\n\
+@deftypefnx {} {} load file options v1 v2 @dots{}\n\
+@deftypefnx {} {S =} load (\"file\", \"options\", \"v1\", \"v2\", @dots{})\n\
 Load the named variables @var{v1}, @var{v2}, @dots{}, from the file\n\
 @var{file}.\n\
 \n\
 If no variables are specified then all variables found in the\n\
 file will be loaded.  As with @code{save}, the list of variables to extract\n\
 can be full names or use a pattern syntax.  The format of the file is\n\
 automatically detected but may be overridden by supplying the appropriate\n\
 option.\n\
@@ -1448,22 +1448,22 @@ dump_octave_core (void)
                          fname);
             }
         }
     }
 }
 
 DEFUN (save, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} save file\n\
-@deftypefnx {Command} {} save options file\n\
-@deftypefnx {Command} {} save options file @var{v1} @var{v2} @dots{}\n\
-@deftypefnx {Command} {} save options file -struct @var{STRUCT} @var{f1} @var{f2} @dots{}\n\
-@deftypefnx {Command} {} save @code{\"-\"} @var{v1} @var{v2} @dots{}\n\
-@deftypefnx {Built-in Function} {@var{s} =} save (@code{\"-\"} @var{v1} @var{v2} @dots{})\n\
+@deftypefn  {} {} save file\n\
+@deftypefnx {} {} save options file\n\
+@deftypefnx {} {} save options file @var{v1} @var{v2} @dots{}\n\
+@deftypefnx {} {} save options file -struct @var{STRUCT} @var{f1} @var{f2} @dots{}\n\
+@deftypefnx {} {} save @code{\"-\"} @var{v1} @var{v2} @dots{}\n\
+@deftypefnx {} {@var{s} =} save (@code{\"-\"} @var{v1} @var{v2} @dots{})\n\
 Save the named variables @var{v1}, @var{v2}, @dots{}, in the file\n\
 @var{file}.\n\
 \n\
 The special filename @samp{-} may be used to return the\n\
 content of the variables as a string.  If no variable names are listed,\n\
 Octave saves all the variables in the current scope.  Otherwise, full\n\
 variable names or pattern syntax can be used to specify the variables to\n\
 save.  If the @option{-struct} modifier is used, fields @var{f1} @var{f2}\n\
@@ -1738,37 +1738,37 @@ the file @file{data} in Octave's binary 
         }
     }
 
   return retval;
 }
 
 DEFUN (crash_dumps_octave_core, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} crash_dumps_octave_core ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} crash_dumps_octave_core (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} crash_dumps_octave_core (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} crash_dumps_octave_core ()\n\
+@deftypefnx {} {@var{old_val} =} crash_dumps_octave_core (@var{new_val})\n\
+@deftypefnx {} {} crash_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file @file{octave-workspace} if it\n\
 crashes or receives a hangup, terminate or similar signal.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{octave_core_file_limit, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (crash_dumps_octave_core);
 }
 
 DEFUN (save_default_options, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} save_default_options ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} save_default_options (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} save_default_options (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} save_default_options ()\n\
+@deftypefnx {} {@var{old_val} =} save_default_options (@var{new_val})\n\
+@deftypefnx {} {} save_default_options (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the default options\n\
 for the @code{save} command, and defines the default format.\n\
 \n\
 Typical values include @qcode{\"-ascii\"}, @qcode{\"-text -zip\"}.\n\
 The default value is @option{-text}.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
@@ -1776,19 +1776,19 @@ The original variable value is restored 
 @seealso{save}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (save_default_options);
 }
 
 DEFUN (octave_core_file_limit, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} octave_core_file_limit ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_limit (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} octave_core_file_limit (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} octave_core_file_limit ()\n\
+@deftypefnx {} {@var{old_val} =} octave_core_file_limit (@var{new_val})\n\
+@deftypefnx {} {} octave_core_file_limit (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the maximum amount\n\
 of memory (in kilobytes) of the top-level workspace that Octave will\n\
 attempt to save when writing data to the crash dump file (the name of\n\
 the file is specified by @var{octave_core_file_name}).\n\
 \n\
 If @var{octave_core_file_options} flags specify a binary format,\n\
 then @var{octave_core_file_limit} will be approximately the maximum\n\
 size of the file.  If a text file format is used, then the file could\n\
@@ -1800,38 +1800,38 @@ The original variable value is restored 
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (octave_core_file_limit);
 }
 
 DEFUN (octave_core_file_name, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} octave_core_file_name ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_name (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} octave_core_file_name (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} octave_core_file_name ()\n\
+@deftypefnx {} {@var{old_val} =} octave_core_file_name (@var{new_val})\n\
+@deftypefnx {} {} octave_core_file_name (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the file\n\
 used for saving data from the top-level workspace if Octave aborts.\n\
 \n\
 The default value is @qcode{\"octave-workspace\"}\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (octave_core_file_name);
 }
 
 DEFUN (octave_core_file_options, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} octave_core_file_options ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_options (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} octave_core_file_options (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} octave_core_file_options ()\n\
+@deftypefnx {} {@var{old_val} =} octave_core_file_options (@var{new_val})\n\
+@deftypefnx {} {} octave_core_file_options (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the options used for\n\
 saving the workspace data if Octave aborts.\n\
 \n\
 The value of @code{octave_core_file_options} should follow the same format\n\
 as the options for the @code{save} function.  The default value is Octave's\n\
 binary format.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
@@ -1840,19 +1840,19 @@ The original variable value is restored 
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_limit}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (octave_core_file_options);
 }
 
 DEFUN (save_header_format_string, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} save_header_format_string ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} save_header_format_string (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} save_header_format_string (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} save_header_format_string ()\n\
+@deftypefnx {} {@var{old_val} =} save_header_format_string (@var{new_val})\n\
+@deftypefnx {} {} save_header_format_string (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the format\n\
 string used for the comment line written at the beginning of\n\
 text-format data files saved by Octave.\n\
 \n\
 The format string is passed to @code{strftime} and should begin with the\n\
 character @samp{#} and contain no newline characters.  If the value of\n\
 @code{save_header_format_string} is the empty string, the header comment is\n\
 omitted from text-format data files.  The default value is\n\
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -184,18 +184,18 @@ do_numeric_lookup (const ArrayT& array, 
   else
     retval = idx;
 
   return retval;
 }
 
 DEFUN (lookup, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{idx} =} lookup (@var{table}, @var{y})\n\
-@deftypefnx {Built-in Function} {@var{idx} =} lookup (@var{table}, @var{y}, @var{opt})\n\
+@deftypefn  {} {@var{idx} =} lookup (@var{table}, @var{y})\n\
+@deftypefnx {} {@var{idx} =} lookup (@var{table}, @var{y}, @var{opt})\n\
 Lookup values in a sorted table.\n\
 \n\
 This function is usually used as a prelude to interpolation.\n\
 \n\
 If table is increasing and @code{idx = lookup (table, y)}, then\n\
 @code{table(idx(i)) <= y(i) < table(idx(i+1))} for all @code{y(i)} within\n\
 the table.  If @code{y(i) < table(1)} then @code{idx(i)} is 0.  If\n\
 @code{y(i) >= table(end)} or @code{isnan (y(i))} then @code{idx(i)} is\n\
diff --git a/libinterp/corefcn/ls-oct-text.cc b/libinterp/corefcn/ls-oct-text.cc
--- a/libinterp/corefcn/ls-oct-text.cc
+++ b/libinterp/corefcn/ls-oct-text.cc
@@ -399,19 +399,19 @@ save_three_d (std::ostream& os, const oc
   else
     error ("for now, I can only save real matrices in 3-D format");
 
   return (os && ! fail);
 }
 
 DEFUN (save_precision, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} save_precision ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} save_precision (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} save_precision (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} save_precision ()\n\
+@deftypefnx {} {@var{old_val} =} save_precision (@var{new_val})\n\
+@deftypefnx {} {} save_precision (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the number of digits to\n\
 keep when saving data in text format.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -140,18 +140,18 @@ lsode_user_jacobian (const ColumnVector&
         gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
 DEFUN (lsode, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t})\n\
-@deftypefnx {Built-in Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t}, @var{t_crit})\n\
+@deftypefn  {} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t})\n\
+@deftypefnx {} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t}, @var{t_crit})\n\
 Ordinary Differential Equation (ODE) solver.\n\
 \n\
 The set of differential equations to solve is\n\
 @tex\n\
 $$ {dx \\over dt} = f (x, t) $$\n\
 with\n\
 $$ x(t_0) = x_0 $$\n\
 @end tex\n\
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -58,23 +58,23 @@ get_lu_u (const base_lu<MT>& fact)
   if (U.is_square () && fact.regular ())
     return octave_value (U, MatrixType (MatrixType::Upper));
   else
     return U;
 }
 
 DEFUN (lu, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} lu (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} lu (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} lu (@var{S})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}, @var{R}] =} lu (@var{S})\n\
-@deftypefnx {Built-in Function} {[@dots{}] =} lu (@var{S}, @var{thres})\n\
-@deftypefnx {Built-in Function} {@var{y} =} lu (@dots{})\n\
-@deftypefnx {Built-in Function} {[@dots{}] =} lu (@dots{}, \"vector\")\n\
+@deftypefn  {} {[@var{L}, @var{U}] =} lu (@var{A})\n\
+@deftypefnx {} {[@var{L}, @var{U}, @var{P}] =} lu (@var{A})\n\
+@deftypefnx {} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} lu (@var{S})\n\
+@deftypefnx {} {[@var{L}, @var{U}, @var{P}, @var{Q}, @var{R}] =} lu (@var{S})\n\
+@deftypefnx {} {[@dots{}] =} lu (@var{S}, @var{thres})\n\
+@deftypefnx {} {@var{y} =} lu (@dots{})\n\
+@deftypefnx {} {[@dots{}] =} lu (@dots{}, \"vector\")\n\
 @cindex LU decomposition\n\
 Compute the LU@tie{}decomposition of @var{A}.\n\
 \n\
 If @var{A} is full subroutines from @sc{lapack} are used and if @var{A} is\n\
 sparse then @sc{umfpack} is used.\n\
 \n\
 The result is returned in a permuted form, according to the optional return\n\
 value @var{P}.  For example, given the matrix @code{a = [1, 2; 3, 4]},\n\
@@ -578,18 +578,18 @@ bool check_lu_dims (const octave_value& 
   octave_idx_type n = u.columns ();
   return ((l.ndims () == 2 && u.ndims () == 2 && k == l.columns ())
           && k == std::min (m, n)
           && (p.is_undefined () || p.rows () == m));
 }
 
 DEFUN (luupdate, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} luupdate (@var{L}, @var{U}, @var{x}, @var{y})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} luupdate (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
+@deftypefn  {} {[@var{L}, @var{U}] =} luupdate (@var{L}, @var{U}, @var{x}, @var{y})\n\
+@deftypefnx {} {[@var{L}, @var{U}, @var{P}] =} luupdate (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
 Given an LU@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{L}*@var{U}}, @var{L}@tie{}lower unit trapezoidal and\n\
 @var{U}@tie{}upper trapezoidal, return the LU@tie{}factorization\n\
 of @w{@var{A} + @var{x}*@var{y}.'}, where @var{x} and @var{y} are\n\
 column vectors (rank-1 update) or matrices with equal number of columns\n\
 (rank-k update).\n\
 \n\
 Optionally, row-pivoted updating can be used by supplying a row permutation\n\
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -35,19 +35,19 @@ along with Octave; see the file COPYING.
 #include "SparseCmplxLU.h"
 #include "SparsedbleLU.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 // FIXME: Deprecated in 4.0 and should be removed in 4.4.
 DEFUN (__luinc__, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, '0')\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{droptol})\n\
-@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{opts})\n\
+@deftypefn  {} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, '0')\n\
+@deftypefnx {} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{droptol})\n\
+@deftypefnx {} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{opts})\n\
 @cindex LU decomposition\n\
 Produce the incomplete LU@tie{}factorization of the sparse matrix @var{A}.\n\
 \n\
 Two types of incomplete factorization are possible, and the type\n\
 is determined by the second argument to @code{luinc}.\n\
 \n\
 Called with a second argument of @qcode{'0'}, the zero-level incomplete\n\
 LU@tie{}factorization is produced.  This creates a factorization of @var{A}\n\
diff --git a/libinterp/corefcn/mappers.cc b/libinterp/corefcn/mappers.cc
--- a/libinterp/corefcn/mappers.cc
+++ b/libinterp/corefcn/mappers.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
 #include "variables.h"
 
 DEFUN (abs, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} abs (@var{z})\n\
+@deftypefn {} {} abs (@var{z})\n\
 Compute the magnitude of @var{z}.\n\
 \n\
 The magnitude is defined as\n\
 @tex\n\
 $|z| = \\sqrt{x^2 + y^2}$.\n\
 @end tex\n\
 @ifnottex\n\
 |@var{z}| = @code{sqrt (x^2 + y^2)}.\n\
@@ -80,17 +80,17 @@ abs (3 + 4i)\n\
 %!assert (abs (single ([1.1, 3i; 3+4i, -3-4i])), single ([1.1, 3; 5, 5]))
 
 %!error abs ()
 %!error abs (1, 2)
 */
 
 DEFUN (acos, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} acos (@var{x})\n\
+@deftypefn {} {} acos (@var{x})\n\
 Compute the inverse cosine in radians for each element of @var{x}.\n\
 @seealso{cos, acosd}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).acos ());
@@ -126,17 +126,17 @@ Compute the inverse cosine in radians fo
 %! assert (acos ([2 0i]), [ival*i, pi/2], 2*eps);
 
 %!error acos ()
 %!error acos (1, 2)
 */
 
 DEFUN (acosh, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} acosh (@var{x})\n\
+@deftypefn {} {} acosh (@var{x})\n\
 Compute the inverse hyperbolic cosine for each element of @var{x}.\n\
 @seealso{cosh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).acosh ());
@@ -165,31 +165,31 @@ Compute the inverse hyperbolic cosine fo
 %! assert (acosh (single (-10i)), re - i*im, 5*eps ("single"));
 
 %!error acosh ()
 %!error acosh (1, 2)
 */
 
 DEFUN (angle, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} angle (@var{z})\n\
+@deftypefn {} {} angle (@var{z})\n\
 See @code{arg}.\n\
 @seealso{arg}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).arg ());
 }
 
 DEFUN (arg, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Mapping Function} {} arg (@var{z})\n\
-@deftypefnx {Mapping Function} {} angle (@var{z})\n\
+@deftypefn  {} {} arg (@var{z})\n\
+@deftypefnx {} {} angle (@var{z})\n\
 Compute the argument, i.e., angle of @var{z}.\n\
 \n\
 This is defined as,\n\
 @tex\n\
 $\\theta = atan2 (y, x),$\n\
 @end tex\n\
 @ifnottex\n\
 @var{theta} = @code{atan2 (@var{y}, @var{x})},\n\
@@ -233,17 +233,17 @@ arg (3 + 4i)\n\
 %!assert (arg (single ([1, i; -1, -i])), single ([0, pi/2; pi, -pi/2]), 2e1*eps ("single"))
 
 %!error arg ()
 %!error arg (1, 2)
 */
 
 DEFUN (asin, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} asin (@var{x})\n\
+@deftypefn {} {} asin (@var{x})\n\
 Compute the inverse sine in radians for each element of @var{x}.\n\
 @seealso{sin, asind}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).asin ());
@@ -278,17 +278,17 @@ Compute the inverse sine in radians for 
 %! assert (asin ([2 0i]), [rval - ival*i, 0], 2*eps);
 
 %!error asin ()
 %!error asin (1, 2)
 */
 
 DEFUN (asinh, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} asinh (@var{x})\n\
+@deftypefn {} {} asinh (@var{x})\n\
 Compute the inverse hyperbolic sine for each element of @var{x}.\n\
 @seealso{sinh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).asinh ());
@@ -306,17 +306,17 @@ Compute the inverse hyperbolic sine for 
 %! assert (asinh (x), v,  sqrt (eps ("single")));
 
 %!error asinh ()
 %!error asinh (1, 2)
 */
 
 DEFUN (atan, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} atan (@var{x})\n\
+@deftypefn {} {} atan (@var{x})\n\
 Compute the inverse tangent in radians for each element of @var{x}.\n\
 @seealso{tan, atand}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).atan ());
@@ -338,17 +338,17 @@ Compute the inverse tangent in radians f
 %! assert (atan (x), v, sqrt (eps ("single")));
 
 %!error atan ()
 %!error atan (1, 2)
 */
 
 DEFUN (atanh, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} atanh (@var{x})\n\
+@deftypefn {} {} atanh (@var{x})\n\
 Compute the inverse hyperbolic tangent for each element of @var{x}.\n\
 @seealso{tanh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).atanh ());
@@ -366,17 +366,17 @@ Compute the inverse hyperbolic tangent f
 %! assert (atanh (x), v, sqrt (eps ("single")));
 
 %!error atanh ()
 %!error atanh (1, 2)
 */
 
 DEFUN (cbrt, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} cbrt (@var{x})\n\
+@deftypefn {} {} cbrt (@var{x})\n\
 Compute the real cube root of each element of @var{x}.\n\
 \n\
 Unlike @code{@var{x}^(1/3)}, the result will be negative if @var{x} is\n\
 negative.\n\
 @seealso{nthroot}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
@@ -396,17 +396,17 @@ negative.\n\
 %!assert (cbrt (125*2^300), 5*2^100)
 
 %!error cbrt ()
 %!error cbrt (1, 2)
 */
 
 DEFUN (ceil, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} ceil (@var{x})\n\
+@deftypefn {} {} ceil (@var{x})\n\
 Return the smallest integer not less than @var{x}.\n\
 \n\
 This is equivalent to rounding towards positive infinity.\n\
 \n\
 If @var{x} is complex, return\n\
 @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
 \n\
 @example\n\
@@ -438,17 +438,17 @@ ceil ([-2.7, 2.7])\n\
 %!assert (ceil (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single ([2+2i, 2+2i, -1-i, -1-i]))
 
 %!error ceil ()
 %!error ceil (1, 2)
 */
 
 DEFUN (conj, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} conj (@var{z})\n\
+@deftypefn {} {} conj (@var{z})\n\
 Return the complex conjugate of @var{z}.\n\
 \n\
 The complex conjugate is defined as\n\
 @tex\n\
 $\\bar{z} = x - iy$.\n\
 @end tex\n\
 @ifnottex\n\
 @code{conj (@var{z})} = @var{x} - @var{i}@var{y}.\n\
@@ -476,17 +476,17 @@ The complex conjugate is defined as\n\
 %!assert (conj (single ([-1, -i; -1+i, -1-i])), single ([-1, i; -1-i, -1+i]))
 
 %!error conj ()
 %!error conj (1, 2)
 */
 
 DEFUN (cos, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} cos (@var{x})\n\
+@deftypefn {} {} cos (@var{x})\n\
 Compute the cosine for each element of @var{x} in radians.\n\
 @seealso{acos, cosd, cosh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).cos ());
@@ -510,17 +510,17 @@ Compute the cosine for each element of @
 %! assert (cos (x), v, sqrt (eps ("single")));
 
 %!error cos ()
 %!error cos (1, 2)
 */
 
 DEFUN (cosh, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} cosh (@var{x})\n\
+@deftypefn {} {} cosh (@var{x})\n\
 Compute the hyperbolic cosine for each element of @var{x}.\n\
 @seealso{acosh, sinh, tanh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).cosh ());
@@ -538,17 +538,17 @@ Compute the hyperbolic cosine for each e
 %! assert (cosh (x), v, sqrt (eps ("single")));
 
 %!error cosh ()
 %!error cosh (1, 2)
 */
 
 DEFUN (erf, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} erf (@var{z})\n\
+@deftypefn {} {} erf (@var{z})\n\
 Compute the error function.\n\
 \n\
 The error function is defined as\n\
 @tex\n\
 $$\n\
  {\\rm erf} (z) = {2 \\over \\sqrt{\\pi}}\\int_0^z e^{-t^2} dt\n\
 $$\n\
 @end tex\n\
@@ -607,17 +607,17 @@ erf (z) = --------- *  | e^(-t^2) dt\n\
 %! assert (erfc (x), 1-v, -1.e-10);
 
 %!error erf ()
 %!error erf (1, 2)
 */
 
 DEFUN (erfinv, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} erfinv (@var{x})\n\
+@deftypefn {} {} erfinv (@var{x})\n\
 Compute the inverse error function.\n\
 \n\
 The inverse error function is defined such that\n\
 \n\
 @example\n\
 erf (@var{y}) == @var{x}\n\
 @end example\n\
 @seealso{erf, erfc, erfcx, erfi, dawson, erfcinv}\n\
@@ -644,17 +644,17 @@ erf (@var{y}) == @var{x}\n\
 %!error erfinv (1+2i)
 
 %!error erfinv ()
 %!error erfinv (1, 2)
 */
 
 DEFUN (erfcinv, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} erfcinv (@var{x})\n\
+@deftypefn {} {} erfcinv (@var{x})\n\
 Compute the inverse complementary error function.\n\
 \n\
 The inverse complementary error function is defined such that\n\
 \n\
 @example\n\
 erfc (@var{y}) == @var{x}\n\
 @end example\n\
 @seealso{erfc, erf, erfcx, erfi, dawson, erfinv}\n\
@@ -681,17 +681,17 @@ erfc (@var{y}) == @var{x}\n\
 %!error erfcinv (1+2i)
 
 %!error erfcinv ()
 %!error erfcinv (1, 2)
 */
 
 DEFUN (erfc, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} erfc (@var{z})\n\
+@deftypefn {} {} erfc (@var{z})\n\
 Compute the complementary error function.\n\
 \n\
 The complementary error function is defined as\n\
 @tex\n\
 $1 - {\\rm erf} (z)$.\n\
 @end tex\n\
 @ifnottex\n\
 @w{@code{1 - erf (@var{z})}}.\n\
@@ -711,17 +711,17 @@ The complementary error function is defi
 %! assert (erfc (a), erfc (real (a)));
 
 %!error erfc ()
 %!error erfc (1, 2)
 */
 
 DEFUN (erfcx, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} erfcx (@var{z})\n\
+@deftypefn {} {} erfcx (@var{z})\n\
 Compute the scaled complementary error function.\n\
 \n\
 The scaled complementary error function is defined as\n\
 @tex\n\
 $$\n\
  e^{z^2} {\\rm erfc} (z) \\equiv e^{z^2} (1 - {\\rm erf} (z))\n\
 $$\n\
 @end tex\n\
@@ -753,17 +753,17 @@ exp (z^2) * erfc (z)\n\
 %! assert (erfcx (x), v, -1.e-10);
 
 %!error erfcx ()
 %!error erfcx (1, 2)
 */
 
 DEFUN (erfi, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} erfi (@var{z})\n\
+@deftypefn {} {} erfi (@var{z})\n\
 Compute the imaginary error function.\n\
 \n\
 The imaginary error function is defined as\n\
 @tex\n\
 $$\n\
  -i {\\rm erf} (iz)\n\
 $$\n\
 @end tex\n\
@@ -790,17 +790,17 @@ The imaginary error function is defined 
 %! assert (erfi (x), -i * erf(i*x), -1.e-10);
 
 %!error erfi ()
 %!error erfi (1, 2)
 */
 
 DEFUN (dawson, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} dawson (@var{z})\n\
+@deftypefn {} {} dawson (@var{z})\n\
 Compute the Dawson (scaled imaginary error) function.\n\
 \n\
 The Dawson function is defined as\n\
 @tex\n\
 $$\n\
  {\\sqrt{\\pi} \\over 2} e^{-z^2} {\\rm erfi} (z) \\equiv -i {\\sqrt{\\pi} \\over 2} e^{-z^2} {\\rm erf} (iz)\n\
 $$\n\
 @end tex\n\
@@ -829,17 +829,17 @@ The Dawson function is defined as\n\
 %! assert (dawson (-x), -v, -1.e-10);
 
 %!error dawson ()
 %!error dawson (1, 2)
 */
 
 DEFUN (exp, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} exp (@var{x})\n\
+@deftypefn {} {} exp (@var{x})\n\
 Compute\n\
 @tex\n\
 $e^{x}$\n\
 @end tex\n\
 @ifnottex\n\
 @code{e^x}\n\
 @end ifnottex\n\
 for each element of @var{x}.\n\
@@ -864,17 +864,17 @@ To compute the matrix exponential, see @
 %!assert (exp (single ([Inf, -Inf, NaN])), single ([Inf 0 NaN]))
 
 %!error exp ()
 %!error exp (1, 2)
 */
 
 DEFUN (expm1, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} expm1 (@var{x})\n\
+@deftypefn {} {} expm1 (@var{x})\n\
 Compute\n\
 @tex\n\
 $ e^{x} - 1 $\n\
 @end tex\n\
 @ifnottex\n\
 @code{exp (@var{x}) - 1}\n\
 @end ifnottex\n\
 accurately in the neighborhood of zero.\n\
@@ -894,17 +894,17 @@ accurately in the neighborhood of zero.\
 %!assert (expm1 (single ([Inf, -Inf, NaN])), single ([Inf -1 NaN]))
 
 %!error expm1 ()
 %!error expm1 (1, 2)
 */
 
 DEFUN (isfinite, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isfinite (@var{x})\n\
+@deftypefn {} {} isfinite (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 finite values and false where they are not.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 isfinite ([13, Inf, NA, NaN])\n\
@@ -930,17 +930,17 @@ isfinite ([13, Inf, NA, NaN])\n\
 %!assert (isfinite (single (rand (1,10))))
 
 %!error isfinite ()
 %!error isfinite (1, 2)
 */
 
 DEFUN (fix, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} fix (@var{x})\n\
+@deftypefn {} {} fix (@var{x})\n\
 Truncate fractional portion of @var{x} and return the integer portion.\n\
 \n\
 This is equivalent to rounding towards zero.  If @var{x} is complex, return\n\
 @code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.\n\
 \n\
 @example\n\
 @group\n\
 fix ([-2.7, 2.7])\n\
@@ -963,17 +963,17 @@ fix ([-2.7, 2.7])\n\
 %!assert (fix (single ([1.1+1.1i, 1+i, -1.1-1.1i, -1-i])), single ([1+i, 1+i, -1-i, -1-i]))
 
 %!error fix ()
 %!error fix (1, 2)
 */
 
 DEFUN (floor, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} floor (@var{x})\n\
+@deftypefn {} {} floor (@var{x})\n\
 Return the largest integer not greater than @var{x}.\n\
 \n\
 This is equivalent to rounding towards negative infinity.  If @var{x} is\n\
 complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.\n\
 \n\
 @example\n\
 @group\n\
 floor ([-2.7, 2.7])\n\
@@ -996,17 +996,17 @@ floor ([-2.7, 2.7])\n\
 %!assert (floor (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single ([2+2i, 1+i, -2-2i, -1-i]))
 
 %!error floor ()
 %!error floor (1, 2)
 */
 
 DEFUN (gamma, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} gamma (@var{z})\n\
+@deftypefn {} {} gamma (@var{z})\n\
 Compute the Gamma function.\n\
 \n\
 The Gamma function is defined as\n\
 @tex\n\
 $$\n\
  \\Gamma (z) = \\int_0^\\infty t^{z-1} e^{-t} dt.\n\
 $$\n\
 @end tex\n\
@@ -1065,17 +1065,17 @@ loss of precision.  The final result is 
 %! assert (gamma (single (x)), single (v));
 
 %!error gamma ()
 %!error gamma (1, 2)
 */
 
 DEFUN (imag, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} imag (@var{z})\n\
+@deftypefn {} {} imag (@var{z})\n\
 Return the imaginary part of @var{z} as a real number.\n\
 @seealso{real, conj}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).imag ());
@@ -1093,17 +1093,17 @@ Return the imaginary part of @var{z} as 
 %!assert (imag (single ([i, 1; 1, i])), full (eye (2,"single")))
 
 %!error imag ()
 %!error imag (1, 2)
 */
 
 DEFUNX ("isalnum", Fisalnum, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isalnum (@var{s})\n\
+@deftypefn {} {} isalnum (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 letters or digits and false where they are not.\n\
 \n\
 This is equivalent to (@code{isalpha (@var{s}) | isdigit (@var{s})}).\n\
 @seealso{isalpha, isdigit, ispunct, isspace, iscntrl}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
@@ -1122,17 +1122,17 @@ This is equivalent to (@code{isalpha (@v
 %! assert (isalnum (charset), result);
 
 %!error isalnum ()
 %!error isalnum (1, 2)
 */
 
 DEFUNX ("isalpha", Fisalpha, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isalpha (@var{s})\n\
+@deftypefn {} {} isalpha (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 letters and false where they are not.\n\
 \n\
 This is equivalent to (@code{islower (@var{s}) | isupper (@var{s})}).\n\
 @seealso{isdigit, ispunct, isspace, iscntrl, isalnum, islower, isupper}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
@@ -1150,17 +1150,17 @@ This is equivalent to (@code{islower (@v
 %! assert (isalpha (charset), result);
 
 %!error isalpha ()
 %!error isalpha (1, 2)
 */
 
 DEFUNX ("isascii", Fisascii, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isascii (@var{s})\n\
+@deftypefn {} {} isascii (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 ASCII characters (in the range 0 to 127 decimal) and false where they are\n\
 not.\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
@@ -1174,17 +1174,17 @@ not.\n\
 %! assert (isascii (charset), result);
 
 %!error isascii ()
 %!error isascii (1, 2)
 */
 
 DEFUNX ("iscntrl", Fiscntrl, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} iscntrl (@var{s})\n\
+@deftypefn {} {} iscntrl (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 control characters and false where they are not.\n\
 @seealso{ispunct, isspace, isalpha, isdigit}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
@@ -1200,17 +1200,17 @@ control characters and false where they 
 %! assert (iscntrl (charset), result);
 
 %!error iscntrl ()
 %!error iscntrl (1, 2)
 */
 
 DEFUNX ("isdigit", Fisdigit, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isdigit (@var{s})\n\
+@deftypefn {} {} isdigit (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 decimal digits (0-9) and false where they are not.\n\
 @seealso{isxdigit, isalpha, isletter, ispunct, isspace, iscntrl}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
@@ -1225,17 +1225,17 @@ decimal digits (0-9) and false where the
 %! assert (isdigit (charset), result);
 
 %!error isdigit ()
 %!error isdigit (1, 2)
 */
 
 DEFUN (isinf, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isinf (@var{x})\n\
+@deftypefn {} {} isinf (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 infinite and false where they are not.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 isinf ([13, Inf, NA, NaN])\n\
@@ -1265,17 +1265,17 @@ isinf ([13, Inf, NA, NaN])\n\
 %!assert (isinf (single ([NaN -Inf -1 0 1 Inf NA])), [false, true, false, false, false, true, false])
 
 %!error isinf ()
 %!error isinf (1, 2)
 */
 
 DEFUNX ("isgraph", Fisgraph, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isgraph (@var{s})\n\
+@deftypefn {} {} isgraph (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 printable characters (but not the space character) and false where they are\n\
 not.\n\
 @seealso{isprint}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
@@ -1291,17 +1291,17 @@ not.\n\
 %! assert (isgraph (charset), result);
 
 %!error isgraph ()
 %!error isgraph (1, 2)
 */
 
 DEFUNX ("islower", Fislower, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} islower (@var{s})\n\
+@deftypefn {} {} islower (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 lowercase letters and false where they are not.\n\
 @seealso{isupper, isalpha, isletter, isalnum}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
@@ -1316,17 +1316,17 @@ lowercase letters and false where they a
 %! assert (islower (charset), result);
 
 %!error islower ()
 %!error islower (1, 2)
 */
 
 DEFUN (isna, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isna (@var{x})\n\
+@deftypefn {} {} isna (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 NA (missing) values and false where they are not.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 isna ([13, Inf, NA, NaN])\n\
@@ -1356,17 +1356,17 @@ isna ([13, Inf, NA, NaN])\n\
 %!assert (isna (single ([NaN -Inf -1 0 1 Inf NA])), [false, false, false, false, false, false, true])
 
 %!error isna ()
 %!error isna (1, 2)
 */
 
 DEFUN (isnan, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isnan (@var{x})\n\
+@deftypefn {} {} isnan (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 NaN values and false where they are not.\n\
 \n\
 NA values are also considered NaN values.  For example:\n\
 \n\
 @example\n\
 @group\n\
 isnan ([13, Inf, NA, NaN])\n\
@@ -1396,17 +1396,17 @@ isnan ([13, Inf, NA, NaN])\n\
 %!assert (isnan (single ([NaN -Inf -1 0 1 Inf NA])), [true, false, false, false, false, false, true])
 
 %!error isnan ()
 %!error isnan (1, 2)
 */
 
 DEFUNX ("isprint", Fisprint, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isprint (@var{s})\n\
+@deftypefn {} {} isprint (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 printable characters (including the space character) and false where they\n\
 are not.\n\
 @seealso{isgraph}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
@@ -1422,17 +1422,17 @@ are not.\n\
 %! assert (isprint (charset), result);
 
 %!error isprint ()
 %!error isprint (1, 2)
 */
 
 DEFUNX ("ispunct", Fispunct, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} ispunct (@var{s})\n\
+@deftypefn {} {} ispunct (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 punctuation characters and false where they are not.\n\
 @seealso{isalpha, isdigit, isspace, iscntrl}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
@@ -1450,17 +1450,17 @@ punctuation characters and false where t
 %! assert (ispunct (charset), result);
 
 %!error ispunct ()
 %!error ispunct (1, 2)
 */
 
 DEFUNX ("isspace", Fisspace, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isspace (@var{s})\n\
+@deftypefn {} {} isspace (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 whitespace characters (space, formfeed, newline, carriage return, tab, and\n\
 vertical tab) and false where they are not.\n\
 @seealso{iscntrl, ispunct, isalpha, isdigit}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
@@ -1476,17 +1476,17 @@ vertical tab) and false where they are n
 %! assert (isspace (charset), result);
 
 %!error isspace ()
 %!error isspace (1, 2)
 */
 
 DEFUNX ("isupper", Fisupper, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isupper (@var{s})\n\
+@deftypefn {} {} isupper (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 uppercase letters and false where they are not.\n\
 @seealso{islower, isalpha, isletter, isalnum}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
@@ -1501,17 +1501,17 @@ uppercase letters and false where they a
 %! assert (isupper (charset), result);
 
 %!error isupper ()
 %!error isupper (1, 2)
 */
 
 DEFUNX ("isxdigit", Fisxdigit, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} isxdigit (@var{s})\n\
+@deftypefn {} {} isxdigit (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 hexadecimal digits (0-9 and @nospell{a-fA-F}).\n\
 @seealso{isdigit}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
@@ -1528,18 +1528,18 @@ hexadecimal digits (0-9 and @nospell{a-f
 %! assert (isxdigit (charset), result);
 
 %!error isxdigit ()
 %!error isxdigit (1, 2)
 */
 
 DEFUN (lgamma, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Mapping Function} {} gammaln (@var{x})\n\
-@deftypefnx {Mapping Function} {} lgamma (@var{x})\n\
+@deftypefn  {} {} gammaln (@var{x})\n\
+@deftypefnx {} {} lgamma (@var{x})\n\
 Return the natural logarithm of the gamma function of @var{x}.\n\
 @seealso{gamma, gammainc}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).lgamma ());
@@ -1571,17 +1571,17 @@ Return the natural logarithm of the gamm
 %! assert (gammaln (single (x)), single (v));
 
 %!error gammaln ()
 %!error gammaln (1,2)
 */
 
 DEFUN (log, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} log (@var{x})\n\
+@deftypefn {} {} log (@var{x})\n\
 Compute the natural logarithm,\n\
 @tex\n\
 $\\ln{(x)},$\n\
 @end tex\n\
 @ifnottex\n\
 @code{ln (@var{x})},\n\
 @end ifnottex\n\
 for each element of @var{x}.\n\
@@ -1604,17 +1604,17 @@ To compute the matrix logarithm, see @re
 %!assert (log (single ([-0.5, -1.5, -2.5])), single (log ([0.5, 1.5, 2.5]) + pi*1i), 4*eps ("single"))
 
 %!error log ()
 %!error log (1, 2)
 */
 
 DEFUN (log10, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} log10 (@var{x})\n\
+@deftypefn {} {} log10 (@var{x})\n\
 Compute the base-10 logarithm of each element of @var{x}.\n\
 @seealso{log, log2, logspace, exp}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).log10 ());
@@ -1625,17 +1625,17 @@ Compute the base-10 logarithm of each el
 %!assert (log10 (single ([0.01, 0.1, 1, 10, 100])), single ([-2, -1, 0, 1, 2]), sqrt (eps ("single")))
 
 %!error log10 ()
 %!error log10 (1, 2)
 */
 
 DEFUN (log1p, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} log1p (@var{x})\n\
+@deftypefn {} {} log1p (@var{x})\n\
 Compute\n\
 @tex\n\
 $\\ln{(1 + x)}$\n\
 @end tex\n\
 @ifnottex\n\
 @code{log (1 + @var{x})}\n\
 @end ifnottex\n\
 accurately in the neighborhood of zero.\n\
@@ -1653,17 +1653,17 @@ accurately in the neighborhood of zero.\
 %!assert (log1p (single ([0, 2*eps, -2*eps])), single ([0, 2*eps, -2*eps]), 1e-29)
 
 %!error log1p ()
 %!error log1p (1, 2)
 */
 
 DEFUN (real, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} real (@var{z})\n\
+@deftypefn {} {} real (@var{z})\n\
 Return the real part of @var{z}.\n\
 @seealso{imag, conj}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).real ());
@@ -1681,17 +1681,17 @@ Return the real part of @var{z}.\n\
 %!assert (real (single ([1, i; i, 1])), full (eye (2,"single")))
 
 %!error real ()
 %!error real (1, 2)
 */
 
 DEFUN (round, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} round (@var{x})\n\
+@deftypefn {} {} round (@var{x})\n\
 Return the integer nearest to @var{x}.\n\
 \n\
 If @var{x} is complex, return\n\
 @code{round (real (@var{x})) + round (imag (@var{x})) * I}.  If there\n\
 are two nearest integers, return the one further away from zero.\n\
 \n\
 @example\n\
 @group\n\
@@ -1726,17 +1726,17 @@ round ([-2.7, 2.7])\n\
 %!assert (round (single ([1.1, -2.4; -3.7, 7.1])), single ([1, -2; -4, 7]))
 
 %!error round ()
 %!error round (1, 2)
 */
 
 DEFUN (roundb, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} roundb (@var{x})\n\
+@deftypefn {} {} roundb (@var{x})\n\
 Return the integer nearest to @var{x}.  If there are two nearest\n\
 integers, return the even one (banker's rounding).\n\
 \n\
 If @var{x} is complex,\n\
 return @code{roundb (real (@var{x})) + roundb (imag (@var{x})) * I}.\n\
 @seealso{round}\n\
 @end deftypefn")
 {
@@ -1766,17 +1766,17 @@ return @code{roundb (real (@var{x})) + r
 %!assert (roundb (single ([1.1, -2.4; -3.7, 7.1])), single ([1, -2; -4, 7]))
 
 %!error roundb ()
 %!error roundb (1, 2)
 */
 
 DEFUN (sign, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} sign (@var{x})\n\
+@deftypefn {} {} sign (@var{x})\n\
 Compute the @dfn{signum} function.\n\
 \n\
 This is defined as\n\
 @tex\n\
 $$\n\
 {\\rm sign} (@var{x}) = \\cases{1,&$x>0$;\\cr 0,&$x=0$;\\cr -1,&$x<0$.\\cr}\n\
 $$\n\
 @end tex\n\
@@ -1818,17 +1818,17 @@ whether zero is signed, use the @code{si
 %!assert (sign (single ([1, -pi; e, 0])), single ([1, -1; 1, 0]))
 
 %!error sign ()
 %!error sign (1, 2)
 */
 
 DEFUNX ("signbit", Fsignbit, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} signbit (@var{x})\n\
+@deftypefn {} {} signbit (@var{x})\n\
 Return logical true if the value of @var{x} has its sign bit set and false\n\
 otherwise.\n\
 \n\
 This behavior is consistent with the other logical functions.\n\
 See @ref{Logical Values}.  The behavior differs from the C language function\n\
 which returns nonzero if the sign bit is set.\n\
 \n\
 This is not the same as @code{x < 0.0}, because IEEE 754 floating point\n\
@@ -1857,17 +1857,17 @@ but @code{signbit (-0.0)} will return a 
 %!assert (signbit (single (-0)) != 0)
 
 %!error sign ()
 %!error sign (1, 2)
 */
 
 DEFUN (sin, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} sin (@var{x})\n\
+@deftypefn {} {} sin (@var{x})\n\
 Compute the sine for each element of @var{x} in radians.\n\
 @seealso{asin, sind, sinh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).sin ());
@@ -1889,17 +1889,17 @@ Compute the sine for each element of @va
 %! assert (sin (x), v, sqrt (eps ("single")));
 
 %!error sin ()
 %!error sin (1, 2)
 */
 
 DEFUN (sinh, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} sinh (@var{x})\n\
+@deftypefn {} {} sinh (@var{x})\n\
 Compute the hyperbolic sine for each element of @var{x}.\n\
 @seealso{asinh, cosh, tanh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).sinh ());
@@ -1917,17 +1917,17 @@ Compute the hyperbolic sine for each ele
 %! assert (sinh (x), v, sqrt (eps ("single")));
 
 %!error sinh ()
 %!error sinh (1, 2)
 */
 
 DEFUN (sqrt, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} sqrt (@var{x})\n\
+@deftypefn {} {} sqrt (@var{x})\n\
 Compute the square root of each element of @var{x}.\n\
 \n\
 If @var{x} is negative, a complex result is returned.\n\
 \n\
 To compute the matrix square root, see @ref{Linear Algebra}.\n\
 @seealso{realsqrt, nthroot}\n\
 @end deftypefn")
 {
@@ -1949,17 +1949,17 @@ To compute the matrix square root, see @
 %!assert (sqrt (single ([4, -4; i, 1-i])), single ([2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))]), sqrt (eps ("single")))
 
 %!error sqrt ()
 %!error sqrt (1, 2)
 */
 
 DEFUN (tan, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} tan (@var{z})\n\
+@deftypefn {} {} tan (@var{z})\n\
 Compute the tangent for each element of @var{x} in radians.\n\
 @seealso{atan, tand, tanh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).tan ());
@@ -1981,17 +1981,17 @@ Compute the tangent for each element of 
 %! assert (tan (x), v,  sqrt (eps ("single")));
 
 %!error tan ()
 %!error tan (1, 2)
 */
 
 DEFUN (tanh, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} tanh (@var{x})\n\
+@deftypefn {} {} tanh (@var{x})\n\
 Compute hyperbolic tangent for each element of @var{x}.\n\
 @seealso{atanh, sinh, cosh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
   
   return octave_value (args(0).tanh ());
@@ -2009,17 +2009,17 @@ Compute hyperbolic tangent for each elem
 %! assert (tanh (x), v, sqrt (eps ("single")));
 
 %!error tanh ()
 %!error tanh (1, 2)
 */
 
 DEFUNX ("toascii", Ftoascii, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} toascii (@var{s})\n\
+@deftypefn {} {} toascii (@var{s})\n\
 Return ASCII representation of @var{s} in a matrix.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 toascii (\"ASCII\")\n\
      @result{} [ 65, 83, 67, 73, 73 ]\n\
@@ -2044,18 +2044,18 @@ toascii (\"ASCII\")\n\
 %!assert (toascii ("{":"~"), 123:126)
 
 %!error toascii ()
 %!error toascii (1, 2)
 */
 
 DEFUNX ("tolower", Ftolower, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Mapping Function} {} tolower (@var{s})\n\
-@deftypefnx {Mapping Function} {} lower (@var{s})\n\
+@deftypefn  {} {} tolower (@var{s})\n\
+@deftypefnx {} {} lower (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each uppercase\n\
 character replaced by the corresponding lowercase one; non-alphabetic\n\
 characters are left unchanged.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
@@ -2103,18 +2103,18 @@ DEFALIAS (lower, tolower);
 
 %!error <Invalid call to tolower> lower ()
 %!error <Invalid call to tolower> tolower ()
 %!error tolower (1, 2)
 */
 
 DEFUNX ("toupper", Ftoupper, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Mapping Function} {} toupper (@var{s})\n\
-@deftypefnx {Mapping Function} {} upper (@var{s})\n\
+@deftypefn  {} {} toupper (@var{s})\n\
+@deftypefnx {} {} upper (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each lowercase\n\
 character replaced by the corresponding uppercase one; non-alphabetic\n\
 characters are left unchanged.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -33,22 +33,22 @@ along with Octave; see the file COPYING.
 #include "ov-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "MatrixType.h"
 #include "oct-locbuf.h"
 
 DEFUN (matrix_type, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{type} =} matrix_type (@var{A})\n\
-@deftypefnx {Built-in Function} {@var{type} =} matrix_type (@var{A}, \"nocompute\")\n\
-@deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, @var{type})\n\
-@deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"upper\", @var{perm})\n\
-@deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"lower\", @var{perm})\n\
-@deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"banded\", @var{nl}, @var{nu})\n\
+@deftypefn  {} {@var{type} =} matrix_type (@var{A})\n\
+@deftypefnx {} {@var{type} =} matrix_type (@var{A}, \"nocompute\")\n\
+@deftypefnx {} {@var{A} =} matrix_type (@var{A}, @var{type})\n\
+@deftypefnx {} {@var{A} =} matrix_type (@var{A}, \"upper\", @var{perm})\n\
+@deftypefnx {} {@var{A} =} matrix_type (@var{A}, \"lower\", @var{perm})\n\
+@deftypefnx {} {@var{A} =} matrix_type (@var{A}, \"banded\", @var{nl}, @var{nu})\n\
 Identify the matrix type or mark a matrix as a particular type.\n\
 \n\
 This allows more rapid solutions of linear equations involving @var{A} to be\n\
 performed.\n\
 \n\
 Called with a single argument, @code{matrix_type} returns the type of the\n\
 matrix and caches it for future use.\n\
 \n\
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -423,20 +423,20 @@ do_minmax_body (const octave_value_list&
 
     }
 
   return retval;
 }
 
 DEFUN (min, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} min (@var{x})\n\
-@deftypefnx {Built-in Function} {} min (@var{x}, [], @var{dim})\n\
-@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} min (@var{x})\n\
-@deftypefnx {Built-in Function} {} min (@var{x}, @var{y})\n\
+@deftypefn  {} {} min (@var{x})\n\
+@deftypefnx {} {} min (@var{x}, [], @var{dim})\n\
+@deftypefnx {} {[@var{w}, @var{iw}] =} min (@var{x})\n\
+@deftypefnx {} {} min (@var{x}, @var{y})\n\
 Find minimum values in the array @var{x}.\n\
 \n\
 For a vector argument, return the minimum value.  For a matrix argument,\n\
 return a row vector with the minimum value of each column.  For a\n\
 multi-dimensional array, @code{min} operates along the first non-singleton\n\
 dimension.\n\
 \n\
 If the optional third argument @var{dim} is present then operate along\n\
@@ -644,20 +644,20 @@ the first index of the minimum value(s).
 %!error <DIM must be a valid dimension> min ([1 2; 3 4], [], -3)
 %!warning <second argument is ignored> min ([1 2 3 4], 2, 2);
 %!error <wrong type argument 'cell'> min ({1 2 3 4})
 %!error <cannot compute min \(cell, scalar\)> min ({1, 2, 3}, 2)
 */
 
 DEFUN (max, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} max (@var{x})\n\
-@deftypefnx {Built-in Function} {} max (@var{x}, [], @var{dim})\n\
-@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} max (@var{x})\n\
-@deftypefnx {Built-in Function} {} max (@var{x}, @var{y})\n\
+@deftypefn  {} {} max (@var{x})\n\
+@deftypefnx {} {} max (@var{x}, [], @var{dim})\n\
+@deftypefnx {} {[@var{w}, @var{iw}] =} max (@var{x})\n\
+@deftypefnx {} {} max (@var{x}, @var{y})\n\
 Find maximum values in the array @var{x}.\n\
 \n\
 For a vector argument, return the maximum value.  For a matrix argument,\n\
 return a row vector with the maximum value of each column.  For a\n\
 multi-dimensional array, @code{max} operates along the first non-singleton\n\
 dimension.\n\
 \n\
 If the optional third argument @var{dim} is present then operate along\n\
@@ -974,19 +974,19 @@ do_cumminmax_body (const octave_value_li
       gripe_wrong_type_arg (func, arg);
     }
 
   return retval;
 }
 
 DEFUN (cummin, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} cummin (@var{x})\n\
-@deftypefnx {Built-in Function} {} cummin (@var{x}, @var{dim})\n\
-@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
+@deftypefn  {} {} cummin (@var{x})\n\
+@deftypefnx {} {} cummin (@var{x}, @var{dim})\n\
+@deftypefnx {} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
 Return the cumulative minimum values along dimension @var{dim}.\n\
 \n\
 If @var{dim} is unspecified it defaults to column-wise operation.  For\n\
 example:\n\
 \n\
 @example\n\
 @group\n\
 cummin ([5 4 6 2 3 1])\n\
@@ -1030,19 +1030,19 @@ iw = 1  2  2  4  4  6\n\
 
 
 %!error cummin ()
 %!error cummin (1, 2, 3)
 */
 
 DEFUN (cummax, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} cummax (@var{x})\n\
-@deftypefnx {Built-in Function} {} cummax (@var{x}, @var{dim})\n\
-@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} cummax (@dots{})\n\
+@deftypefn  {} {} cummax (@var{x})\n\
+@deftypefnx {} {} cummax (@var{x}, @var{dim})\n\
+@deftypefnx {} {[@var{w}, @var{iw}] =} cummax (@dots{})\n\
 Return the cumulative maximum values along dimension @var{dim}.\n\
 \n\
 If @var{dim} is unspecified it defaults to column-wise operation.  For\n\
 example:\n\
 \n\
 @example\n\
 @group\n\
 cummax ([1 3 2 6 4 5])\n\
diff --git a/libinterp/corefcn/md5sum.cc b/libinterp/corefcn/md5sum.cc
--- a/libinterp/corefcn/md5sum.cc
+++ b/libinterp/corefcn/md5sum.cc
@@ -33,18 +33,18 @@ along with Octave; see the file COPYING.
 #include "file-ops.h"
 #include "load-path.h"
 #include "oct-env.h"
 #include "oct-md5.h"
 #include "utils.h"
 
 DEFUN (md5sum, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} md5sum (@var{file})\n\
-@deftypefnx {Built-in Function} {} md5sum (@var{str}, @var{opt})\n\
+@deftypefn  {} {} md5sum (@var{file})\n\
+@deftypefnx {} {} md5sum (@var{str}, @var{opt})\n\
 Calculate the MD5 sum of the file @var{file}.\n\
 \n\
 If the second parameter @var{opt} exists and is true, then calculate the MD5\n\
 sum of the string @var{str}.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -45,17 +45,17 @@ do_mgorth (ColumnVector& x, const Matrix
 
   h(Vc) = xnorm (x);
   if (real (h(Vc)) > 0)
     x /= h(Vc);
 }
 
 DEFUN (mgorth, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{y}, @var{h}] =} mgorth (@var{x}, @var{v})\n\
+@deftypefn {} {[@var{y}, @var{h}] =} mgorth (@var{x}, @var{v})\n\
 Orthogonalize a given column vector @var{x} with respect to a set of\n\
 orthonormal vectors comprising the columns of @var{v} using the modified\n\
 Gram-Schmidt method.\n\
 \n\
 On exit, @var{y} is a unit vector such that:\n\
 \n\
 @example\n\
 @group\n\
diff --git a/libinterp/corefcn/nproc.cc b/libinterp/corefcn/nproc.cc
--- a/libinterp/corefcn/nproc.cc
+++ b/libinterp/corefcn/nproc.cc
@@ -24,18 +24,18 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "nproc.h"
 
 DEFUN (nproc, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} nproc ()\n\
-@deftypefnx {Built-in Function} {} nproc (@var{query})\n\
+@deftypefn  {} {} nproc ()\n\
+@deftypefnx {} {} nproc (@var{query})\n\
 Return the current number of available processors.\n\
 \n\
 If called with the optional argument @var{query}, modify how processors\n\
 are counted as follows:\n\
 \n\
 @table @code\n\
 @item all\n\
 total number of processors.\n\
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -567,19 +567,19 @@ octave_history_write_timestamp (void)
 
   if (! timestamp.empty ())
     if (command_history::add (timestamp))
       octave_link::append_history (timestamp);
 }
 
 DEFUN (edit_history, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} edit_history\n\
-@deftypefnx {Command} {} edit_history @var{cmd_number}\n\
-@deftypefnx {Command} {} edit_history @var{first} @var{last}\n\
+@deftypefn  {} {} edit_history\n\
+@deftypefnx {} {} edit_history @var{cmd_number}\n\
+@deftypefnx {} {} edit_history @var{first} @var{last}\n\
 Edit the history list using the editor named by the variable @env{EDITOR}.\n\
 \n\
 The commands to be edited are first copied to a temporary file.  When you\n\
 exit the editor, Octave executes the commands that remain in the file.  It\n\
 is often more convenient to use @code{edit_history} to define functions\n\
 rather than attempting to enter them directly on the command line.\n\
 The block of commands is executed as soon as you exit the editor.\n\
 To avoid executing any commands, simply delete all the lines from the buffer\n\
@@ -609,20 +609,20 @@ buffer to be edited.\n\
 
   do_edit_history (args);
 
   return retval;
 }
 
 DEFUN (history, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} history\n\
-@deftypefnx {Command} {} history @var{opt1} @dots{}\n\
-@deftypefnx {Built-in Function} {@var{h} =} history ()\n\
-@deftypefnx {Built-in Function} {@var{h} =} history (@var{opt1}, @dots{})\n\
+@deftypefn  {} {} history\n\
+@deftypefnx {} {} history @var{opt1} @dots{}\n\
+@deftypefnx {} {@var{h} =} history ()\n\
+@deftypefnx {} {@var{h} =} history (@var{opt1}, @dots{})\n\
 If invoked with no arguments, @code{history} displays a list of commands\n\
 that you have executed.\n\
 \n\
 Valid options are:\n\
 \n\
 @table @code\n\
 @item   @var{n}\n\
 @itemx -@var{n}\n\
@@ -661,19 +661,19 @@ argument as a cell string and will not b
   if (nargout > 0)
     retval = Cell (hlist);
 
   return retval;
 }
 
 DEFUN (run_history, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} run_history\n\
-@deftypefnx {Command} {} run_history @var{cmd_number}\n\
-@deftypefnx {Command} {} run_history @var{first} @var{last}\n\
+@deftypefn  {} {} run_history\n\
+@deftypefnx {} {} run_history @var{cmd_number}\n\
+@deftypefnx {} {} run_history @var{first} @var{last}\n\
 Run commands from the history list.\n\
 \n\
 When invoked with no arguments, run the previously executed command;\n\
 \n\
 With one argument, run the specified command @var{cmd_number};\n\
 \n\
 With two arguments, run the list of commands between @var{first} and\n\
 @var{last}.  Command number specifiers may also be negative where -1\n\
@@ -720,18 +720,18 @@ run_history -1 -2\n\
 
   do_run_history (args);
 
   return retval;
 }
 
 DEFUN (history_control, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} history_control ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} history_control (@var{new_val})\n\
+@deftypefn  {} {@var{val} =} history_control ()\n\
+@deftypefnx {} {@var{old_val} =} history_control (@var{new_val})\n\
 Query or set the internal variable that specifies how commands are saved\n\
 to the history list.\n\
 \n\
 The default value is an empty character string, but may be overridden by the\n\
 environment variable @w{@env{OCTAVE_HISTCONTROL}}.\n\
 \n\
 The value of @code{history_control} is a colon-separated list of values\n\
 controlling how commands are saved on the history list.  If the list\n\
@@ -758,18 +758,18 @@ the history list, subject to the value o
   if (tmp != old_history_control)
     command_history::process_histcontrol (tmp);
 
   return retval;
 }
 
 DEFUN (history_size, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} history_size ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} history_size (@var{new_val})\n\
+@deftypefn  {} {@var{val} =} history_size ()\n\
+@deftypefnx {} {@var{old_val} =} history_size (@var{new_val})\n\
 Query or set the internal variable that specifies how many entries\n\
 to store in the history file.\n\
 \n\
 The default value is @code{1000}, but may be overridden by the environment\n\
 variable @w{@env{OCTAVE_HISTSIZE}}.\n\
 @seealso{history_file, history_timestamp_format_string, history_save}\n\
 @end deftypefn")
 {
@@ -786,18 +786,18 @@ variable @w{@env{OCTAVE_HISTSIZE}}.\n\
   if (tmp != old_history_size)
     command_history::set_size (tmp);
 
   return retval;
 }
 
 DEFUN (history_file, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} history_file ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} history_file (@var{new_val})\n\
+@deftypefn  {} {@var{val} =} history_file ()\n\
+@deftypefnx {} {@var{old_val} =} history_file (@var{new_val})\n\
 Query or set the internal variable that specifies the name of the\n\
 file used to store command history.\n\
 \n\
 The default value is @file{~/.octave_hist}, but may be overridden by the\n\
 environment variable @w{@env{OCTAVE_HISTFILE}}.\n\
 @seealso{history_size, history_save, history_timestamp_format_string}\n\
 @end deftypefn")
 {
@@ -812,19 +812,19 @@ environment variable @w{@env{OCTAVE_HIST
   if (tmp != old_history_file)
     command_history::set_file (tmp);
 
   return retval;
 }
 
 DEFUN (history_timestamp_format_string, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} history_timestamp_format_string ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} history_timestamp_format_string (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} history_timestamp_format_string (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} history_timestamp_format_string ()\n\
+@deftypefnx {} {@var{old_val} =} history_timestamp_format_string (@var{new_val})\n\
+@deftypefnx {} {} history_timestamp_format_string (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the format string\n\
 for the comment line that is written to the history file when Octave\n\
 exits.\n\
 \n\
 The format string is passed to @code{strftime}.  The default value is\n\
 \n\
 @example\n\
 \"# Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@@HOST>\"\n\
@@ -836,19 +836,19 @@ The original variable value is restored 
 @seealso{strftime, history_file, history_size, history_save}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (history_timestamp_format_string);
 }
 
 DEFUN (history_save, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} history_save ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} history_save (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} history_save (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} history_save ()\n\
+@deftypefnx {} {@var{old_val} =} history_save (@var{new_val})\n\
+@deftypefnx {} {} history_save (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether commands entered\n\
 on the command line are saved in the history file.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{history_control, history_file, history_size, history_timestamp_format_string}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -100,26 +100,26 @@ octave_link::do_discard_events (void)
 
   gui_event_queue.discard ();
 
   event_queue_mutex->unlock ();
 }
 
 DEFUN (__octave_link_enabled__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __octave_link_enabled__ ()\n\
+@deftypefn {} {} __octave_link_enabled__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return octave_value (octave_link::enabled ());
 }
 
 DEFUN (__octave_link_edit_file__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __octave_link_edit_file__ (@var{file})\n\
+@deftypefn {} {} __octave_link_edit_file__ (@var{file})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       std::string file = args(0).xstring_value ("first argument must be filename");
@@ -137,17 +137,17 @@ Undocumented internal function.\n\
       retval = octave_link::prompt_new_edit_file (file);
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_message_dialog__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __octave_link_message_dialog__ (@var{dlg}, @var{msg}, @var{title})\n\
+@deftypefn {} {} __octave_link_message_dialog__ (@var{dlg}, @var{msg}, @var{title})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 3)
     {
       std::string dlg = args(0).xstring_value ("invalid arguments");
@@ -159,17 +159,17 @@ Undocumented internal function.\n\
       retval = octave_link::message_dialog (dlg, msg, title);
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_question_dialog__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __octave_link_question_dialog__ (@var{msg}, @var{title}, @var{btn1}, @var{btn2}, @var{btn3}, @var{default})\n\
+@deftypefn {} {} __octave_link_question_dialog__ (@var{msg}, @var{title}, @var{btn1}, @var{btn2}, @var{btn3}, @var{default})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 6)
     {
       std::string msg = args(0).xstring_value ("invalid arguments");
@@ -185,17 +185,17 @@ Undocumented internal function.\n\
                                              btndef);
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_file_dialog__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __octave_link_file_dialog__ (@var{filterlist}, @var{title}, @var{filename}, @var{size} @var{multiselect}, @var{pathname})\n\
+@deftypefn {} {} __octave_link_file_dialog__ (@var{filterlist}, @var{title}, @var{filename}, @var{size} @var{multiselect}, @var{pathname})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 6)
     {
 
@@ -260,17 +260,17 @@ Undocumented internal function.\n\
         }
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_list_dialog__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __octave_link_list_dialog__ (@var{list}, @var{mode}, @var{size}, @var{intial}, @var{name}, @var{prompt}, @var{ok_string}, @var{cancel_string})\n\
+@deftypefn {} {} __octave_link_list_dialog__ (@var{list}, @var{mode}, @var{size}, @var{intial}, @var{name}, @var{prompt}, @var{ok_string}, @var{cancel_string})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 8)
     {
       Cell list = args(0).cell_value ();
@@ -323,17 +323,17 @@ Undocumented internal function.\n\
       retval(0) = items;
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_input_dialog__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __octave_link_input_dialog__ (@var{prompt}, @var{title}, @var{rowscols}, @var{defaults})\n\
+@deftypefn {} {} __octave_link_input_dialog__ (@var{prompt}, @var{title}, @var{rowscols}, @var{defaults})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 4)
     {
       Cell prompt = args(0).cell_value ();
@@ -380,30 +380,30 @@ Undocumented internal function.\n\
       retval = items;
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_show_preferences__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __octave_link_show_preferences__ ()\n\
+@deftypefn {} {} __octave_link_show_preferences__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   retval = octave_link::show_preferences ();
 
   return retval;
 }
 
 DEFUN (__octave_link_show_doc__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __octave_link_show_doc__ (@var{filename})\n\
+@deftypefn {} {} __octave_link_show_doc__ (@var{filename})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string file;
 
   if (args.length () >= 1)
     file = args(0).string_value();
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -59,17 +59,17 @@ extern "C"
                              const octave_idx_type*, const octave_idx_type&,
                              FloatComplex*, const octave_idx_type&, FloatComplex*, const octave_idx_type&,
                              FloatComplex*, octave_idx_type&, float&, float&, FloatComplex*,
                              const octave_idx_type&, octave_idx_type &);
 }
 
 DEFUN (ordschur, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{UR}, @var{SR}] =} ordschur (@var{U}, @var{S}, @var{select})\n\
+@deftypefn {} {[@var{UR}, @var{SR}] =} ordschur (@var{U}, @var{S}, @var{select})\n\
 Reorders the real Schur factorization (@var{U},@var{S}) obtained with the\n\
 @code{schur} function, so that selected eigenvalues appear in the upper left\n\
 diagonal blocks of the quasi triangular Schur matrix.\n\
 \n\
 The logical vector @var{select} specifies the selected eigenvalues as they\n\
 appear along @var{S}'s diagonal.\n\
 \n\
 For example, given the matrix @code{@var{A} = [1, 2; 3, 4]}, and its Schur\n\
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -509,20 +509,20 @@ open_diary_file (void)
   external_diary_file.open (diary_file.c_str (), std::ios::app);
 
   if (! external_diary_file)
     error ("diary: can't open diary file '%s'", diary_file.c_str ());
 }
 
 DEFUN (diary, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} diary\n\
-@deftypefnx {Command} {} diary on\n\
-@deftypefnx {Command} {} diary off\n\
-@deftypefnx {Command} {} diary @var{filename}\n\
+@deftypefn  {} {} diary\n\
+@deftypefnx {} {} diary on\n\
+@deftypefnx {} {} diary off\n\
+@deftypefnx {} {} diary @var{filename}\n\
 Record a list of all commands @emph{and} the output they produce, mixed\n\
 together just as they appear on the terminal.\n\
 \n\
 Valid options are:\n\
 \n\
 @table @asis\n\
 @item on\n\
 Start recording a session in a file called @file{diary} in the\n\
@@ -574,37 +574,37 @@ With no arguments, @code{diary} toggles 
         }
     }
 
   return octave_value ();
 }
 
 DEFUN (__diaryfile__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{fname} =} __diaryfile__ ()\n\
+@deftypefn {} {@var{fname} =} __diaryfile__ ()\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   return ovl (diary_file);
 }
 
 DEFUN (__diarystate__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{state} =} __diarystate__ ()\n\
+@deftypefn {} {@var{state} =} __diarystate__ ()\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   return ovl (write_to_diary_file);
 }
 
 DEFUN (more, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} more\n\
-@deftypefnx {Command} {} more on\n\
-@deftypefnx {Command} {} more off\n\
+@deftypefn  {} {} more\n\
+@deftypefnx {} {} more on\n\
+@deftypefnx {} {} more off\n\
 Turn output pagination on or off.\n\
 \n\
 Without an argument, @code{more} toggles the current state.\n\
 \n\
 The current state can be determined via @code{page_screen_output}.\n\
 @seealso{page_screen_output, page_output_immediately, PAGER, PAGER_FLAGS}\n\
 @end deftypefn")
 {
@@ -631,35 +631,35 @@ The current state can be determined via 
   else
     Vpage_screen_output = ! Vpage_screen_output;
 
   return retval;
 }
 
 DEFUN (terminal_size, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} terminal_size ()\n\
+@deftypefn {} {} terminal_size ()\n\
 Return a two-element row vector containing the current size of the terminal\n\
 window in characters (rows and columns).\n\
 @seealso{list_in_columns}\n\
 @end deftypefn")
 {
   RowVector size (2, 0.0);
 
   size(0) = command_editor::terminal_rows ();
   size(1) = command_editor::terminal_cols ();
 
   return octave_value (size);
 }
 
 DEFUN (page_output_immediately, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} page_output_immediately ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} page_output_immediately (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} page_output_immediately (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} page_output_immediately ()\n\
+@deftypefnx {} {@var{old_val} =} page_output_immediately (@var{new_val})\n\
+@deftypefnx {} {} page_output_immediately (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave sends\n\
 output to the pager as soon as it is available.\n\
 \n\
 Otherwise, Octave buffers its output and waits until just before the prompt\n\
 is printed to flush it to the pager.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
@@ -667,19 +667,19 @@ The original variable value is restored 
 @seealso{page_screen_output, more, PAGER, PAGER_FLAGS}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (page_output_immediately);
 }
 
 DEFUN (page_screen_output, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} page_screen_output ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} page_screen_output (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} page_screen_output (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} page_screen_output ()\n\
+@deftypefnx {} {@var{old_val} =} page_screen_output (@var{new_val})\n\
+@deftypefnx {} {} page_screen_output (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether output intended\n\
 for the terminal window that is longer than one page is sent through a\n\
 pager.\n\
 \n\
 This allows you to view one screenful at a time.  Some pagers\n\
 (such as @code{less}---see @ref{Installation}) are also capable of moving\n\
 backward on the output.\n\
 \n\
@@ -689,19 +689,19 @@ The original variable value is restored 
 @seealso{more, page_output_immediately, PAGER, PAGER_FLAGS}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (page_screen_output);
 }
 
 DEFUN (PAGER, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} PAGER ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} PAGER (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} PAGER (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} PAGER ()\n\
+@deftypefnx {} {@var{old_val} =} PAGER (@var{new_val})\n\
+@deftypefnx {} {} PAGER (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the program to use\n\
 to display terminal output on your system.\n\
 \n\
 The default value is normally @qcode{\"less\"}, @qcode{\"more\"}, or\n\
 @qcode{\"pg\"}, depending on what programs are installed on your system.\n\
 @xref{Installation}.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
@@ -710,19 +710,19 @@ The original variable value is restored 
 @seealso{PAGER_FLAGS, page_output_immediately, more, page_screen_output}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (PAGER);
 }
 
 DEFUN (PAGER_FLAGS, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} PAGER_FLAGS ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} PAGER_FLAGS (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} PAGER_FLAGS (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} PAGER_FLAGS ()\n\
+@deftypefnx {} {@var{old_val} =} PAGER_FLAGS (@var{new_val})\n\
+@deftypefnx {} {} PAGER_FLAGS (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the options to pass\n\
 to the pager.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{PAGER, more, page_screen_output, page_output_immediately}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -33,18 +33,18 @@ along with Octave; see the file COPYING.
 #include "ov-re-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 
 DEFUN (pinv, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} pinv (@var{x})\n\
-@deftypefnx {Built-in Function} {} pinv (@var{x}, @var{tol})\n\
+@deftypefn  {} {} pinv (@var{x})\n\
+@deftypefnx {} {} pinv (@var{x}, @var{tol})\n\
 Return the pseudoinverse of @var{x}.\n\
 \n\
 Singular values less than @var{tol} are ignored.\n\
 \n\
 If the second argument is omitted, it is taken to be\n\
 \n\
 @example\n\
 tol = max (size (@var{x})) * sigma_max (@var{x}) * eps,\n\
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3400,17 +3400,17 @@ octave_print_internal (std::ostream&, co
 void
 octave_print_internal (std::ostream&, const octave_value&, bool)
 {
   panic_impossible ();
 }
 
 DEFUN (rats, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} rats (@var{x}, @var{len})\n\
+@deftypefn {} {} rats (@var{x}, @var{len})\n\
 Convert @var{x} into a rational approximation represented as a string.\n\
 \n\
 The string can be converted back into a matrix as follows:\n\
 \n\
 @example\n\
 @group\n\
 r = rats (hilb (4));\n\
 x = str2num (r)\n\
@@ -3479,17 +3479,17 @@ If the length of the smallest possible r
   else
     error ("rats: X must be numeric");
 
   return retval;
 }
 
 DEFUN (disp, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} disp (@var{x})\n\
+@deftypefn {} {} disp (@var{x})\n\
 Display the value of @var{x}.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 disp (\"The value of pi is:\"), disp (pi)\n\
 \n\
@@ -3522,17 +3522,17 @@ formatted output in a string.\n\
       retval = octave_value (buf.str (), arg.is_dq_string () ? '"' : '\'');
     }
 
   return retval;
 }
 
 DEFUN (fdisp, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} fdisp (@var{fid}, @var{x})\n\
+@deftypefn {} {} fdisp (@var{fid}, @var{x})\n\
 Display the value of @var{x} on the stream @var{fid}.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 fdisp (stdout, \"The value of pi is:\"), fdisp (stdout, pi)\n\
 \n\
@@ -3857,18 +3857,18 @@ set_format_style (int argc, const string
     }
 
   format_string = format;
 }
 
 
 DEFUN (format, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} format\n\
-@deftypefnx {Command} {} format options\n\
+@deftypefn  {} {} format\n\
+@deftypefnx {} {} format options\n\
 Reset or specify the format of the output produced by @code{disp} and\n\
 Octave's normal echoing mechanism.\n\
 \n\
 This command only affects the display of numbers but not how they are stored\n\
 or computed.  To change the internal representation from the default double\n\
 use one of the conversion functions such as @code{single}, @code{uint8},\n\
 @code{int64}, etc.\n\
 \n\
@@ -4041,38 +4041,38 @@ to produce a more readable output with l
 
   set_format_style (argc, argv);
 
   return retval;
 }
 
 DEFUN (__compactformat__, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} __compactformat__ ()\n\
-@deftypefnx {Built-in Function} {} __compactformat__ (@var{TRUE|FALSE})\n\
+@deftypefn  {} {@var{val} =} __compactformat__ ()\n\
+@deftypefnx {} {} __compactformat__ (@var{TRUE|FALSE})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (compact_format);
 }
 
 DEFUN (__formatstring__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} __formatstring__ ()\n\
+@deftypefn {} {@var{val} =} __formatstring__ ()\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   return ovl (format_string);
 }
 
 DEFUN (fixed_point_format, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} fixed_point_format ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} fixed_point_format (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} fixed_point_format (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} fixed_point_format ()\n\
+@deftypefnx {} {@var{old_val} =} fixed_point_format (@var{new_val})\n\
+@deftypefnx {} {} fixed_point_format (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
 use a scaled format to print matrix values.\n\
 \n\
 The scaled format prints a scaling factor on the first line of output chosen\n\
 such that the largest matrix element can be written with a single leading\n\
 digit.  For example:\n\
 \n\
 @example\n\
@@ -4101,19 +4101,19 @@ The original variable value is restored 
 @seealso{format, output_max_field_width, output_precision}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (fixed_point_format);
 }
 
 DEFUN (print_empty_dimensions, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} print_empty_dimensions ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} print_empty_dimensions (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} print_empty_dimensions (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} print_empty_dimensions ()\n\
+@deftypefnx {} {@var{old_val} =} print_empty_dimensions (@var{new_val})\n\
+@deftypefnx {} {} print_empty_dimensions (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether the dimensions of\n\
 empty matrices are printed along with the empty matrix symbol, @samp{[]}.\n\
 \n\
 For example, the expression\n\
 \n\
 @example\n\
 zeros (3, 0)\n\
 @end example\n\
@@ -4131,19 +4131,19 @@ The original variable value is restored 
 @seealso{format}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (print_empty_dimensions);
 }
 
 DEFUN (split_long_rows, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} split_long_rows ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} split_long_rows (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} split_long_rows (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} split_long_rows ()\n\
+@deftypefnx {} {@var{old_val} =} split_long_rows (@var{new_val})\n\
+@deftypefnx {} {} split_long_rows (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether rows of a matrix\n\
 may be split when displayed to a terminal window.\n\
 \n\
 If the rows are split, Octave will display the matrix in a series of smaller\n\
 pieces, each of which can fit within the limits of your terminal width and\n\
 each set of rows is labeled so that you can easily see which columns are\n\
 currently being displayed.  For example:\n\
 \n\
@@ -4170,37 +4170,37 @@ The original variable value is restored 
 @seealso{format}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (split_long_rows);
 }
 
 DEFUN (output_max_field_width, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} output_max_field_width ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} output_max_field_width (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} output_max_field_width (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} output_max_field_width ()\n\
+@deftypefnx {} {@var{old_val} =} output_max_field_width (@var{new_val})\n\
+@deftypefnx {} {} output_max_field_width (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the maximum width\n\
 of a numeric output field.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{format, fixed_point_format, output_precision}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_max_field_width, 0,
                                             std::numeric_limits<int>::max ());
 }
 
 DEFUN (output_precision, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} output_precision ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} output_precision (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} output_precision (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} output_precision ()\n\
+@deftypefnx {} {@var{old_val} =} output_precision (@var{new_val})\n\
+@deftypefnx {} {} output_precision (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the minimum number of\n\
 significant figures to display for numeric output.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{format, fixed_point_format, output_max_field_width}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/profiler.cc b/libinterp/corefcn/profiler.cc
--- a/libinterp/corefcn/profiler.cc
+++ b/libinterp/corefcn/profiler.cc
@@ -389,17 +389,17 @@ profile_data_accumulator::add_current_ti
   active_fcn->add_time (t - last_time);
 }
 
 profile_data_accumulator profiler;
 
 // Enable or disable the profiler data collection.
 DEFUN (__profiler_enable__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {} __profiler_enable__ ()\n\
+@deftypefn {} {} __profiler_enable__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
@@ -407,34 +407,34 @@ Undocumented internal function.\n\
     profiler.set_active (args(0).bool_value ());
 
   return octave_value (profiler.is_active ());
 }
 
 // Clear all collected profiling data.
 DEFUN (__profiler_reset__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {} __profiler_reset__ ()\n\
+@deftypefn {} {} __profiler_reset__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () > 0)
     warning ("profiler_reset: ignoring extra arguments");
 
   profiler.reset ();
 
   return retval;
 }
 
 // Query the timings collected by the profiler.
 DEFUN (__profiler_data__, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {} __profiler_data__ ()\n\
+@deftypefn {} {} __profiler_data__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () > 0)
     warning ("profiler_data: ignoring extra arguments");
 
diff --git a/libinterp/corefcn/psi.cc b/libinterp/corefcn/psi.cc
--- a/libinterp/corefcn/psi.cc
+++ b/libinterp/corefcn/psi.cc
@@ -29,18 +29,18 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "dNDArray.h"
 #include "fNDArray.h"
 
 #include "lo-specfun.h"
 
 DEFUN (psi, args, ,
 "-*- texinfo -*-\n\
-@deftypefn  {Function File} {} psi (@var{z})\n\
-@deftypefnx {Function File} {} psi (@var{k}, @var{z})\n\
+@deftypefn  {} {} psi (@var{z})\n\
+@deftypefnx {} {} psi (@var{k}, @var{z})\n\
 Compute the psi (polygamma) function.\n\
 \n\
 The polygamma functions are the @var{k}th derivative of the logarithm\n\
 of the gamma function.  If unspecified, @var{k} defaults to zero.  A value\n\
 of zero computes the digamma function, a value of 1, the trigamma function,\n\
 and so on.\n\
 \n\
 The digamma function is defined:\n\
diff --git a/libinterp/corefcn/pt-jit.cc b/libinterp/corefcn/pt-jit.cc
--- a/libinterp/corefcn/pt-jit.cc
+++ b/libinterp/corefcn/pt-jit.cc
@@ -2512,19 +2512,19 @@ jit_info::find (const vmap& extra_vars, 
 #define UNUSED_WITHOUT_LLVM(x) x
 #else
 #define UNUSED_WITHOUT_LLVM(x) x GCC_ATTR_UNUSED
 #endif
 
 DEFUN (jit_failcnt, UNUSED_WITHOUT_LLVM (args),
        UNUSED_WITHOUT_LLVM (nargout),
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} jit_failcnt ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} jit_failcnt (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} jit_failcnt (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} jit_failcnt ()\n\
+@deftypefnx {} {@var{old_val} =} jit_failcnt (@var{new_val})\n\
+@deftypefnx {} {} jit_failcnt (@var{new_val}, \"local\")\n\
 Query or set the internal variable that counts the number of JIT fail\n\
 exceptions for Octave's JIT compiler.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{jit_enable, jit_startcnt, debug_jit}\n\
 @end deftypefn")
@@ -2535,19 +2535,19 @@ The original variable value is restored 
   warning ("jit_failcnt: JIT compiling not available in this version of Octave");
   return octave_value ();
 #endif
 }
 
 DEFUN (debug_jit, UNUSED_WITHOUT_LLVM (args),
        UNUSED_WITHOUT_LLVM (nargout),
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} debug_jit ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} debug_jit (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} debug_jit (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} debug_jit ()\n\
+@deftypefnx {} {@var{old_val} =} debug_jit (@var{new_val})\n\
+@deftypefnx {} {} debug_jit (@var{new_val}, \"local\")\n\
 Query or set the internal variable that determines whether\n\
 debugging/tracing is enabled for Octave's JIT compiler.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{jit_enable, jit_startcnt}\n\
 @end deftypefn")
@@ -2558,19 +2558,19 @@ The original variable value is restored 
   warning ("debug_jit: JIT compiling not available in this version of Octave");
   return octave_value ();
 #endif
 }
 
 DEFUN (jit_enable, UNUSED_WITHOUT_LLVM (args),
        UNUSED_WITHOUT_LLVM (nargout),
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} jit_enable ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} jit_enable (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} jit_enable (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} jit_enable ()\n\
+@deftypefnx {} {@var{old_val} =} jit_enable (@var{new_val})\n\
+@deftypefnx {} {} jit_enable (@var{new_val}, \"local\")\n\
 Query or set the internal variable that enables Octave's JIT compiler.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{jit_startcnt, debug_jit}\n\
 @end deftypefn")
 {
@@ -2580,19 +2580,19 @@ The original variable value is restored 
   warning ("jit_enable: JIT compiling not available in this version of Octave");
   return octave_value ();
 #endif
 }
 
 DEFUN (jit_startcnt, UNUSED_WITHOUT_LLVM (args),
        UNUSED_WITHOUT_LLVM (nargout),
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} jit_startcnt ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} jit_startcnt (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} jit_startcnt (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} jit_startcnt ()\n\
+@deftypefnx {} {@var{old_val} =} jit_startcnt (@var{new_val})\n\
+@deftypefnx {} {} jit_startcnt (@var{new_val}, \"local\")\n\
 Query or set the internal variable that determines whether JIT compilation\n\
 will take place for a specific loop.\n\
 \n\
 Because compilation is a costly operation it does not make sense to employ\n\
 JIT when the loop count is low.  By default only loops with greater than\n\
 1000 iterations will be accelerated.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -131,20 +131,20 @@ quad_float_user_function (float x)
         gripe_user_supplied_eval ("quad");
     }
 
   return retval;
 }
 
 DEFUN (quad, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b})\n\
-@deftypefnx {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol})\n\
-@deftypefnx {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
-@deftypefnx {Built-in Function} {[@var{q}, @var{ier}, @var{nfun}, @var{err}] =} quad (@dots{})\n\
+@deftypefn  {} {@var{q} =} quad (@var{f}, @var{a}, @var{b})\n\
+@deftypefnx {} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol})\n\
+@deftypefnx {} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
+@deftypefnx {} {[@var{q}, @var{ier}, @var{nfun}, @var{err}] =} quad (@dots{})\n\
 Numerically evaluate the integral of @var{f} from @var{a} to @var{b} using\n\
 Fortran routines from @w{@sc{quadpack}}.\n\
 \n\
 @var{f} is a function handle, inline function, or a string containing the\n\
 name of the function to evaluate.  The function must have the form @code{y =\n\
 f (x)} where @var{y} and @var{x} are scalars.\n\
 \n\
 @var{a} and @var{b} are the lower and upper limits of integration.  Either\n\
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1482,20 +1482,20 @@ downdate (double *c, int n, int d, int *
 
 }
 
 
 /* The actual integration routine.  */
 
 DEFUN (quadcc, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b})\n\
-@deftypefnx {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol})\n\
-@deftypefnx {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
-@deftypefnx {Function File} {[@var{q}, @var{err}, @var{nr_points}] =} quadcc (@dots{})\n\
+@deftypefn  {} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b})\n\
+@deftypefnx {} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol})\n\
+@deftypefnx {} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
+@deftypefnx {} {[@var{q}, @var{err}, @var{nr_points}] =} quadcc (@dots{})\n\
 Numerically evaluate the integral of @var{f} from @var{a} to @var{b}\n\
 using doubly-adaptive @nospell{Clenshaw-Curtis} quadrature.\n\
 \n\
 @var{f} is a function handle, inline function, or string containing the name\n\
 of the function to evaluate.  The function @var{f} must be vectorized and\n\
 must return a vector of output values if given a vector of input values.\n\
 For example,\n\
 \n\
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -288,18 +288,18 @@ fout (const octave_idx_type& lsize, cons
     return (fabs (p) >= 1 ? 1 : -1);
 }
 
 
 //FIXME: Matlab does not produce lambda as the first output argument.
 //       Compatibility problem?
 DEFUN (qz, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{lambda} =} qz (@var{A}, @var{B})\n\
-@deftypefnx {Built-in Function} {@var{lambda} =} qz (@var{A}, @var{B}, @var{opt})\n\
+@deftypefn  {} {@var{lambda} =} qz (@var{A}, @var{B})\n\
+@deftypefnx {} {@var{lambda} =} qz (@var{A}, @var{B}, @var{opt})\n\
 QZ@tie{}decomposition of the generalized eigenvalue problem\n\
 (@math{A x = s B x}).\n\
 \n\
 There are three ways to call this function:\n\
 @enumerate\n\
 @item @code{@var{lambda} = qz (@var{A}, @var{B})}\n\
 \n\
 Computes the generalized eigenvalues\n\
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -343,27 +343,27 @@ gen_matrix:
         }
       else
         return octave_rand::nd_array (dims);
     }
 }
 
 DEFUN (rand, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} rand (@var{n})\n\
-@deftypefnx {Built-in Function} {} rand (@var{m}, @var{n}, @dots{})\n\
-@deftypefnx {Built-in Function} {} rand ([@var{m} @var{n} @dots{}])\n\
-@deftypefnx {Built-in Function} {@var{v} =} rand (\"state\")\n\
-@deftypefnx {Built-in Function} {} rand (\"state\", @var{v})\n\
-@deftypefnx {Built-in Function} {} rand (\"state\", \"reset\")\n\
-@deftypefnx {Built-in Function} {@var{v} =} rand (\"seed\")\n\
-@deftypefnx {Built-in Function} {} rand (\"seed\", @var{v})\n\
-@deftypefnx {Built-in Function} {} rand (\"seed\", \"reset\")\n\
-@deftypefnx {Built-in Function} {} rand (@dots{}, \"single\")\n\
-@deftypefnx {Built-in Function} {} rand (@dots{}, \"double\")\n\
+@deftypefn  {} {} rand (@var{n})\n\
+@deftypefnx {} {} rand (@var{m}, @var{n}, @dots{})\n\
+@deftypefnx {} {} rand ([@var{m} @var{n} @dots{}])\n\
+@deftypefnx {} {@var{v} =} rand (\"state\")\n\
+@deftypefnx {} {} rand (\"state\", @var{v})\n\
+@deftypefnx {} {} rand (\"state\", \"reset\")\n\
+@deftypefnx {} {@var{v} =} rand (\"seed\")\n\
+@deftypefnx {} {} rand (\"seed\", @var{v})\n\
+@deftypefnx {} {} rand (\"seed\", \"reset\")\n\
+@deftypefnx {} {} rand (@dots{}, \"single\")\n\
+@deftypefnx {} {} rand (@dots{}, \"double\")\n\
 Return a matrix with random elements uniformly distributed on the\n\
 interval (0, 1).\n\
 \n\
 The arguments are handled the same as the arguments for @code{eye}.\n\
 \n\
 You can query the state of the random number generator using the form\n\
 \n\
 @example\n\
@@ -528,27 +528,27 @@ classes.\n\
 %!assert (__rand_sample__ (Inf), __rand_sample__ (NaN))
 %!assert (! isequal (__rand_sample__ (-1), __rand_sample__ (-2)))
 */
 
 static std::string current_distribution = octave_rand::distribution ();
 
 DEFUN (randn, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} randn (@var{n})\n\
-@deftypefnx {Built-in Function} {} randn (@var{m}, @var{n}, @dots{})\n\
-@deftypefnx {Built-in Function} {} randn ([@var{m} @var{n} @dots{}])\n\
-@deftypefnx {Built-in Function} {@var{v} =} randn (\"state\")\n\
-@deftypefnx {Built-in Function} {} randn (\"state\", @var{v})\n\
-@deftypefnx {Built-in Function} {} randn (\"state\", \"reset\")\n\
-@deftypefnx {Built-in Function} {@var{v} =} randn (\"seed\")\n\
-@deftypefnx {Built-in Function} {} randn (\"seed\", @var{v})\n\
-@deftypefnx {Built-in Function} {} randn (\"seed\", \"reset\")\n\
-@deftypefnx {Built-in Function} {} randn (@dots{}, \"single\")\n\
-@deftypefnx {Built-in Function} {} randn (@dots{}, \"double\")\n\
+@deftypefn  {} {} randn (@var{n})\n\
+@deftypefnx {} {} randn (@var{m}, @var{n}, @dots{})\n\
+@deftypefnx {} {} randn ([@var{m} @var{n} @dots{}])\n\
+@deftypefnx {} {@var{v} =} randn (\"state\")\n\
+@deftypefnx {} {} randn (\"state\", @var{v})\n\
+@deftypefnx {} {} randn (\"state\", \"reset\")\n\
+@deftypefnx {} {@var{v} =} randn (\"seed\")\n\
+@deftypefnx {} {} randn (\"seed\", @var{v})\n\
+@deftypefnx {} {} randn (\"seed\", \"reset\")\n\
+@deftypefnx {} {} randn (@dots{}, \"single\")\n\
+@deftypefnx {} {} randn (@dots{}, \"double\")\n\
 Return a matrix with normally distributed random elements having zero mean\n\
 and variance one.\n\
 \n\
 The arguments are handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the @nospell{Marsaglia and Tsang}\n\
 ``Ziggurat technique'' to transform from a uniform to a normal distribution.\n\
 \n\
@@ -601,27 +601,27 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert (var (x), 1, 0.02);
 %!   assert (skewness (x), 0, 0.02);
 %!   assert (kurtosis (x), 0, 0.04);
 %! endif
 */
 
 DEFUN (rande, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} rande (@var{n})\n\
-@deftypefnx {Built-in Function} {} rande (@var{m}, @var{n}, @dots{})\n\
-@deftypefnx {Built-in Function} {} rande ([@var{m} @var{n} @dots{}])\n\
-@deftypefnx {Built-in Function} {@var{v} =} rande (\"state\")\n\
-@deftypefnx {Built-in Function} {} rande (\"state\", @var{v})\n\
-@deftypefnx {Built-in Function} {} rande (\"state\", \"reset\")\n\
-@deftypefnx {Built-in Function} {@var{v} =} rande (\"seed\")\n\
-@deftypefnx {Built-in Function} {} rande (\"seed\", @var{v})\n\
-@deftypefnx {Built-in Function} {} rande (\"seed\", \"reset\")\n\
-@deftypefnx {Built-in Function} {} rande (@dots{}, \"single\")\n\
-@deftypefnx {Built-in Function} {} rande (@dots{}, \"double\")\n\
+@deftypefn  {} {} rande (@var{n})\n\
+@deftypefnx {} {} rande (@var{m}, @var{n}, @dots{})\n\
+@deftypefnx {} {} rande ([@var{m} @var{n} @dots{}])\n\
+@deftypefnx {} {@var{v} =} rande (\"state\")\n\
+@deftypefnx {} {} rande (\"state\", @var{v})\n\
+@deftypefnx {} {} rande (\"state\", \"reset\")\n\
+@deftypefnx {} {@var{v} =} rande (\"seed\")\n\
+@deftypefnx {} {} rande (\"seed\", @var{v})\n\
+@deftypefnx {} {} rande (\"seed\", \"reset\")\n\
+@deftypefnx {} {} rande (@dots{}, \"single\")\n\
+@deftypefnx {} {} rande (@dots{}, \"double\")\n\
 Return a matrix with exponentially distributed random elements.\n\
 \n\
 The arguments are handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the @nospell{Marsaglia and Tsang}\n\
 ``Ziggurat technique'' to transform from a uniform to a normal distribution.\n\
 \n\
 The class of the value returned can be controlled by a trailing\n\
@@ -675,27 +675,27 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert (var (x), 1, 0.03);
 %!   assert (skewness (x), 2, 0.06);
 %!   assert (kurtosis (x), 6, 0.7);
 %! endif
 */
 
 DEFUN (randg, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} randg (@var{n})\n\
-@deftypefnx {Built-in Function} {} randg (@var{m}, @var{n}, @dots{})\n\
-@deftypefnx {Built-in Function} {} randg ([@var{m} @var{n} @dots{}])\n\
-@deftypefnx {Built-in Function} {@var{v} =} randg (\"state\")\n\
-@deftypefnx {Built-in Function} {} randg (\"state\", @var{v})\n\
-@deftypefnx {Built-in Function} {} randg (\"state\", \"reset\")\n\
-@deftypefnx {Built-in Function} {@var{v} =} randg (\"seed\")\n\
-@deftypefnx {Built-in Function} {} randg (\"seed\", @var{v})\n\
-@deftypefnx {Built-in Function} {} randg (\"seed\", \"reset\")\n\
-@deftypefnx {Built-in Function} {} randg (@dots{}, \"single\")\n\
-@deftypefnx {Built-in Function} {} randg (@dots{}, \"double\")\n\
+@deftypefn  {} {} randg (@var{n})\n\
+@deftypefnx {} {} randg (@var{m}, @var{n}, @dots{})\n\
+@deftypefnx {} {} randg ([@var{m} @var{n} @dots{}])\n\
+@deftypefnx {} {@var{v} =} randg (\"state\")\n\
+@deftypefnx {} {} randg (\"state\", @var{v})\n\
+@deftypefnx {} {} randg (\"state\", \"reset\")\n\
+@deftypefnx {} {@var{v} =} randg (\"seed\")\n\
+@deftypefnx {} {} randg (\"seed\", @var{v})\n\
+@deftypefnx {} {} randg (\"seed\", \"reset\")\n\
+@deftypefnx {} {} randg (@dots{}, \"single\")\n\
+@deftypefnx {} {} randg (@dots{}, \"double\")\n\
 Return a matrix with @code{gamma (@var{a},1)} distributed random elements.\n\
 \n\
 The arguments are handled the same as the arguments for @code{rand}, except\n\
 for the argument @var{a}.\n\
 \n\
 This can be used to generate many distributions:\n\
 \n\
 @table @asis\n\
@@ -953,27 +953,27 @@ classes.\n\
 %!   assert (var (x),      a,          2);
 %!   assert (skewness (x), 2/sqrt (a), 0.05);
 %!   assert (kurtosis (x), 6/a,        0.2);
 %! endif
 */
 
 DEFUN (randp, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} randp (@var{l}, @var{n})\n\
-@deftypefnx {Built-in Function} {} randp (@var{l}, @var{m}, @var{n}, @dots{})\n\
-@deftypefnx {Built-in Function} {} randp (@var{l}, [@var{m} @var{n} @dots{}])\n\
-@deftypefnx {Built-in Function} {@var{v} =} randp (\"state\")\n\
-@deftypefnx {Built-in Function} {} randp (\"state\", @var{v})\n\
-@deftypefnx {Built-in Function} {} randp (\"state\", \"reset\")\n\
-@deftypefnx {Built-in Function} {@var{v} =} randp (\"seed\")\n\
-@deftypefnx {Built-in Function} {} randp (\"seed\", @var{v})\n\
-@deftypefnx {Built-in Function} {} randp (\"seed\", \"reset\")\n\
-@deftypefnx {Built-in Function} {} randp (@dots{}, \"single\")\n\
-@deftypefnx {Built-in Function} {} randp (@dots{}, \"double\")\n\
+@deftypefn  {} {} randp (@var{l}, @var{n})\n\
+@deftypefnx {} {} randp (@var{l}, @var{m}, @var{n}, @dots{})\n\
+@deftypefnx {} {} randp (@var{l}, [@var{m} @var{n} @dots{}])\n\
+@deftypefnx {} {@var{v} =} randp (\"state\")\n\
+@deftypefnx {} {} randp (\"state\", @var{v})\n\
+@deftypefnx {} {} randp (\"state\", \"reset\")\n\
+@deftypefnx {} {@var{v} =} randp (\"seed\")\n\
+@deftypefnx {} {} randp (\"seed\", @var{v})\n\
+@deftypefnx {} {} randp (\"seed\", \"reset\")\n\
+@deftypefnx {} {} randp (@dots{}, \"single\")\n\
+@deftypefnx {} {} randp (@dots{}, \"double\")\n\
 Return a matrix with Poisson distributed random elements with mean value\n\
 parameter given by the first argument, @var{l}.\n\
 \n\
 The arguments are handled the same as the arguments for @code{rand}, except\n\
 for the argument @var{l}.\n\
 \n\
 Five different algorithms are used depending on the range of @var{l} and\n\
 whether or not @var{l} is a scalar or a matrix.\n\
@@ -1102,18 +1102,18 @@ classes.\n\
 %!     assert (skewness (x), 1/sqrt (a(1)), a(3));
 %!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 */
 
 DEFUN (randperm, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} randperm (@var{n})\n\
-@deftypefnx {Built-in Function} {} randperm (@var{n}, @var{m})\n\
+@deftypefn  {} {} randperm (@var{n})\n\
+@deftypefnx {} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 \n\
 If @var{m} is supplied, return @var{m} unique entries, sampled without\n\
 replacement from @code{1:@var{n}}.\n\
 \n\
 The complexity is O(@var{n}) in memory and O(@var{m}) in time, unless\n\
 @var{m} < @var{n}/5, in which case O(@var{m}) memory is used as well.  The\n\
 randomization is performed using rand().  All permutations are equally\n\
diff --git a/libinterp/corefcn/rcond.cc b/libinterp/corefcn/rcond.cc
--- a/libinterp/corefcn/rcond.cc
+++ b/libinterp/corefcn/rcond.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (rcond, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{c} =} rcond (@var{A})\n\
+@deftypefn {} {@var{c} =} rcond (@var{A})\n\
 Compute the 1-norm estimate of the reciprocal condition number as returned\n\
 by @sc{lapack}.\n\
 \n\
 If the matrix is well-conditioned then @var{c} will be near 1 and if the\n\
 matrix is poorly conditioned it will be close to 0.\n\
 \n\
 The matrix @var{A} must not be sparse.  If the matrix is sparse then\n\
 @code{condest (@var{A})} or @code{rcond (full (@var{A}))} should be used\n\
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -644,18 +644,18 @@ octcellregexp (const octave_value_list &
     retval = octregexp (args, nargout, who, case_insensitive);
 
   return retval;
 
 }
 
 DEFUN (regexp, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexp (@var{str}, @var{pat})\n\
-@deftypefnx {Built-in Function} {[@dots{}] =} regexp (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
+@deftypefn  {} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexp (@var{str}, @var{pat})\n\
+@deftypefnx {} {[@dots{}] =} regexp (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
 Regular expression string matching.\n\
 \n\
 Search for @var{pat} in @var{str} and return the positions and substrings of\n\
 any matches, or empty values if there are none.\n\
 \n\
 The matched pattern @var{pat} can include any of the standard regex\n\
 operators, including:\n\
 \n\
@@ -1131,18 +1131,18 @@ are zero or more @qcode{'b'} characters 
 %! assert (regexprep ('s', 's', 'x\.y'), 'x.y');
 %! assert (regexprep ('s', '(s)', 'x\$1y'), 'x$1y');
 %! assert (regexprep ('s', '(s)', 'x\\$1y'), 'x\sy');
 
 */
 
 DEFUN (regexpi, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexpi (@var{str}, @var{pat})\n\
-@deftypefnx {Built-in Function} {[@dots{}] =} regexpi (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
+@deftypefn  {} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexpi (@var{str}, @var{pat})\n\
+@deftypefnx {} {[@dots{}] =} regexpi (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
 \n\
 Case insensitive regular expression string matching.\n\
 \n\
 Search for @var{pat} in @var{str} and return the positions and substrings of\n\
 any matches, or empty values if there are none.  @xref{XREFregexp,,regexp},\n\
 for details on the syntax of the search pattern.\n\
 @seealso{regexp}\n\
 @end deftypefn")
@@ -1337,18 +1337,18 @@ octregexprep (const octave_value_list &a
   bool extra_args = false;
   parse_options (options, regexpargs, who, 0, extra_args);
 
   return regexp_replace (pattern, buffer, replacement, options, who);
 }
 
 DEFUN (regexprep, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr})\n\
-@deftypefnx {Built-in Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr}, \"@var{opt1}\", @dots{})\n\
+@deftypefn  {} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr})\n\
+@deftypefnx {} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr}, \"@var{opt1}\", @dots{})\n\
 Replace occurrences of pattern @var{pat} in @var{string} with @var{repstr}.\n\
 \n\
 The pattern is a regular expression as documented for @code{regexp}.\n\
 @xref{XREFregexp,,regexp}.\n\
 \n\
 The replacement string may contain @code{$i}, which substitutes for the ith\n\
 set of parentheses in the match string.  For example,\n\
 \n\
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -54,21 +54,21 @@ mark_upper_triangular (const Matrix& a)
 
   retval.matrix_type (MatrixType::Upper);
 
   return retval;
 }
 
 DEFUN (schur, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{S} =} schur (@var{A})\n\
-@deftypefnx {Built-in Function} {@var{S} =} schur (@var{A}, \"real\")\n\
-@deftypefnx {Built-in Function} {@var{S} =} schur (@var{A}, \"complex\")\n\
-@deftypefnx {Built-in Function} {@var{S} =} schur (@var{A}, @var{opt})\n\
-@deftypefnx {Built-in Function} {[@var{U}, @var{S}] =} schur (@dots{})\n\
+@deftypefn  {} {@var{S} =} schur (@var{A})\n\
+@deftypefnx {} {@var{S} =} schur (@var{A}, \"real\")\n\
+@deftypefnx {} {@var{S} =} schur (@var{A}, \"complex\")\n\
+@deftypefnx {} {@var{S} =} schur (@var{A}, @var{opt})\n\
+@deftypefnx {} {[@var{U}, @var{S}] =} schur (@dots{})\n\
 @cindex Schur decomposition\n\
 Compute the Schur@tie{}decomposition of @var{A}.\n\
 \n\
 The Schur@tie{}decomposition is defined as\n\
 @tex\n\
 $$\n\
  S = U^T A U\n\
 $$\n\
@@ -268,17 +268,17 @@ in control (see @code{are} and @code{dar
 %!error <argument must be a square matrix> schur ([1, 2, 3; 4, 5, 6])
 %!error <wrong type argument 'cell'> schur ({1})
 %!warning <incorrect ordered schur argument> schur ([1, 2; 3, 4], "bad_opt");
 
 */
 
 DEFUN (rsf2csf, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {[@var{U}, @var{T}] =} rsf2csf (@var{UR}, @var{TR})\n\
+@deftypefn {} {[@var{U}, @var{T}] =} rsf2csf (@var{UR}, @var{TR})\n\
 Convert a real, upper quasi-triangular Schur@tie{}form @var{TR} to a complex,\n\
 upper triangular Schur@tie{}form @var{T}.\n\
 \n\
 Note that the following relations hold:\n\
 \n\
 @tex\n\
 $UR \\cdot TR \\cdot {UR}^T = U T U^{\\dagger}$ and\n\
 $U^{\\dagger} U$ is the identity matrix I.\n\
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -1043,17 +1043,17 @@ OCL_REP::wait (void)
         }
     }
 
   return retval;
 }
 
 DEFUN (SIG, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} SIG ()\n\
+@deftypefn {} {} SIG ()\n\
 Return a structure containing Unix signal names and their defined values.\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
   static octave_scalar_map m = make_sig_struct ();
 
@@ -1064,19 +1064,19 @@ Return a structure containing Unix signa
 %!assert (isstruct (SIG ()))
 %!assert (! isempty (SIG ()))
 
 %!error SIG (1)
 */
 
 DEFUN (debug_on_interrupt, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} debug_on_interrupt ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} debug_on_interrupt (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} debug_on_interrupt (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} debug_on_interrupt ()\n\
+@deftypefnx {} {@var{old_val} =} debug_on_interrupt (@var{new_val})\n\
+@deftypefnx {} {} debug_on_interrupt (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter debugging mode when it receives an interrupt signal (typically\n\
 generated with @kbd{C-c}).\n\
 \n\
 If a second interrupt signal is received before reaching the debugging mode,\n\
 a normal interrupt will occur.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
@@ -1097,19 +1097,19 @@ The original variable value is restored 
 %! debug_on_interrupt (orig_val);
 %! assert (debug_on_interrupt (), orig_val);
 
 %!error (debug_on_interrupt (1, 2))
 */
 
 DEFUN (sighup_dumps_octave_core, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} sighup_dumps_octave_core ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} sighup_dumps_octave_core (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} sighup_dumps_octave_core (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} sighup_dumps_octave_core ()\n\
+@deftypefnx {} {@var{old_val} =} sighup_dumps_octave_core (@var{new_val})\n\
+@deftypefnx {} {} sighup_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file @file{octave-workspace} if it\n\
 receives a hangup signal.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
@@ -1126,19 +1126,19 @@ The original variable value is restored 
 %! sighup_dumps_octave_core (orig_val);
 %! assert (sighup_dumps_octave_core (), orig_val);
 
 %!error (sighup_dumps_octave_core (1, 2))
 */
 
 DEFUN (sigterm_dumps_octave_core, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} sigterm_dumps_octave_core ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} sigterm_dumps_octave_core (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} sigterm_dumps_octave_core (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} sigterm_dumps_octave_core ()\n\
+@deftypefnx {} {@var{old_val} =} sigterm_dumps_octave_core (@var{new_val})\n\
+@deftypefnx {} {} sigterm_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file @file{octave-workspace} if it\n\
 receives a terminate signal.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -38,35 +38,35 @@ along with Octave; see the file COPYING.
 #include "unwind-prot.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "ov-bool-sparse.h"
 
 DEFUN (issparse, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} issparse (@var{x})\n\
+@deftypefn {} {} issparse (@var{x})\n\
 Return true if @var{x} is a sparse matrix.\n\
 @seealso{ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_sparse_type ());
 }
 
 DEFUN (sparse, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{s} =} sparse (@var{a})\n\
-@deftypefnx {Built-in Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n})\n\
-@deftypefnx {Built-in Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv})\n\
-@deftypefnx {Built-in Function} {@var{s} =} sparse (@var{m}, @var{n})\n\
-@deftypefnx {Built-in Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{s}, @var{m}, @var{n}, \"unique\")\n\
-@deftypefnx {Built-in Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n}, @var{nzmax})\n\
+@deftypefn  {} {@var{s} =} sparse (@var{a})\n\
+@deftypefnx {} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n})\n\
+@deftypefnx {} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv})\n\
+@deftypefnx {} {@var{s} =} sparse (@var{m}, @var{n})\n\
+@deftypefnx {} {@var{s} =} sparse (@var{i}, @var{j}, @var{s}, @var{m}, @var{n}, \"unique\")\n\
+@deftypefnx {} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n}, @var{nzmax})\n\
 Create a sparse matrix from a full matrix, or row, column, value triplets.\n\
 \n\
 If @var{a} is a full matrix, convert it to a sparse matrix representation,\n\
 removing all zero values in the process.\n\
 \n\
 Given the integer index vectors @var{i} and @var{j}, and a 1-by-@code{nnz}\n\
 vector of real or complex values @var{sv}, construct the sparse matrix\n\
 @code{S(@var{i}(@var{k}),@var{j}(@var{k})) = @var{sv}(@var{k})} with overall\n\
@@ -216,17 +216,17 @@ Compressed Column Sparse (rows = 3, cols
         }
     }
 
   return retval;
 }
 
 DEFUN (spalloc, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{s} =} spalloc (@var{m}, @var{n}, @var{nz})\n\
+@deftypefn {} {@var{s} =} spalloc (@var{m}, @var{n}, @var{nz})\n\
 Create an @var{m}-by-@var{n} sparse matrix with pre-allocated space for at\n\
 most @var{nz} nonzero elements.\n\
 \n\
 This is useful for building a matrix incrementally by a sequence of indexed\n\
 assignments.  Subsequent indexed assignments after @code{spalloc} will reuse\n\
 the pre-allocated memory, provided they are of one of the simple forms\n\
 \n\
 @itemize\n\
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -30,24 +30,24 @@ along with Octave; see the file COPYING.
 #include "pager.h"
 #include "error.h"
 #include "gripes.h"
 
 #include "oct-spparms.h"
 
 DEFUN (spparms, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} { } spparms ()\n\
-@deftypefnx {Built-in Function} {@var{vals} =} spparms ()\n\
-@deftypefnx {Built-in Function} {[@var{keys}, @var{vals}] =} spparms ()\n\
-@deftypefnx {Built-in Function} {@var{val} =} spparms (@var{key})\n\
-@deftypefnx {Built-in Function} { } spparms (@var{vals})\n\
-@deftypefnx {Built-in Function} { } spparms (\"default\")\n\
-@deftypefnx {Built-in Function} { } spparms (\"tight\")\n\
-@deftypefnx {Built-in Function} { } spparms (@var{key}, @var{val})\n\
+@deftypefn  {} { } spparms ()\n\
+@deftypefnx {} {@var{vals} =} spparms ()\n\
+@deftypefnx {} {[@var{keys}, @var{vals}] =} spparms ()\n\
+@deftypefnx {} {@var{val} =} spparms (@var{key})\n\
+@deftypefnx {} { } spparms (@var{vals})\n\
+@deftypefnx {} { } spparms (\"default\")\n\
+@deftypefnx {} { } spparms (\"tight\")\n\
+@deftypefnx {} { } spparms (@var{key}, @var{val})\n\
 Query or set the parameters used by the sparse solvers and factorization\n\
 functions.\n\
 \n\
 The first four calls above get information about the current settings, while\n\
 the others change the current settings.  The parameters are stored as pairs\n\
 of keys and values, where the values are all floats and the keys are one of\n\
 the following strings:\n\
 \n\
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -197,18 +197,18 @@ do_sqrtm (const octave_value& arg)
         }
     }
 
   return retval;
 }
 
 DEFUN (sqrtm, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{s} =} sqrtm (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{s}, @var{error_estimate}] =} sqrtm (@var{A})\n\
+@deftypefn  {} {@var{s} =} sqrtm (@var{A})\n\
+@deftypefnx {} {[@var{s}, @var{error_estimate}] =} sqrtm (@var{A})\n\
 Compute the matrix square root of the square matrix @var{A}.\n\
 \n\
 Ref: @nospell{N.J. Higham}.  @cite{A New sqrtm for @sc{matlab}}.  Numerical\n\
 Analysis Report No. 336, Manchester @nospell{Centre} for Computational\n\
 Mathematics, Manchester, England, January 1999.\n\
 @seealso{expm, logm}\n\
 @end deftypefn")
 {
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -291,17 +291,17 @@ str2double1 (const std::string& str_arg)
         }
     }
 
   return val;
 }
 
 DEFUN (str2double, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} str2double (@var{s})\n\
+@deftypefn {} {} str2double (@var{s})\n\
 Convert a string to a real or complex number.\n\
 \n\
 The string must be in one of the following formats where a and b are real\n\
 numbers and the complex unit is @qcode{'i'} or @qcode{'j'}:\n\
 \n\
 @itemize\n\
 @item a + bi\n\
 \n\
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -145,19 +145,19 @@ qs_search (const Array<char>& needle,
       result.xelem (k++) = *iter;
     }
 
   return result;
 }
 
 DEFUN (strfind, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{idx} =} strfind (@var{str}, @var{pattern})\n\
-@deftypefnx {Built-in Function} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})\n\
-@deftypefnx {Built-in Function} {@var{idx} =} strfind (@dots{}, \"overlaps\", @var{val})\n\
+@deftypefn  {} {@var{idx} =} strfind (@var{str}, @var{pattern})\n\
+@deftypefnx {} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})\n\
+@deftypefnx {} {@var{idx} =} strfind (@dots{}, \"overlaps\", @var{val})\n\
 Search for @var{pattern} in the string @var{str} and return the starting\n\
 index of every such occurrence in the vector @var{idx}.\n\
 \n\
 If there is no such occurrence, or if @var{pattern} is longer than\n\
 @var{str}, or if @var{pattern} itself is empty, then @var{idx} is the empty\n\
 array @code{[]}.\n\
 \n\
 The optional argument @qcode{\"overlaps\"} determines whether the pattern\n\
@@ -353,19 +353,19 @@ qs_replace (const Array<char>& str, cons
         }
     }
 
   return ret;
 }
 
 DEFUN (strrep, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{newstr} =} strrep (@var{str}, @var{ptn}, @var{rep})\n\
-@deftypefnx {Built-in Function} {@var{newstr} =} strrep (@var{cellstr}, @var{ptn}, @var{rep})\n\
-@deftypefnx {Built-in Function} {@var{newstr} =} strrep (@dots{}, \"overlaps\", @var{val})\n\
+@deftypefn  {} {@var{newstr} =} strrep (@var{str}, @var{ptn}, @var{rep})\n\
+@deftypefnx {} {@var{newstr} =} strrep (@var{cellstr}, @var{ptn}, @var{rep})\n\
+@deftypefnx {} {@var{newstr} =} strrep (@dots{}, \"overlaps\", @var{val})\n\
 Replace all occurrences of the pattern @var{ptn} in the string @var{str}\n\
 with the string @var{rep} and return the result.\n\
 \n\
 The optional argument @qcode{\"overlaps\"} determines whether the pattern\n\
 can match at every position in @var{str} (true), or only for unique\n\
 occurrences of the complete pattern (false).  The default is true.\n\
 \n\
 @var{s} may also be a cell array of strings, in which case the replacement is\n\
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -37,20 +37,20 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "ov.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
 DEFUN (char, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} char (@var{x})\n\
-@deftypefnx {Built-in Function} {} char (@var{x}, @dots{})\n\
-@deftypefnx {Built-in Function} {} char (@var{s1}, @var{s2}, @dots{})\n\
-@deftypefnx {Built-in Function} {} char (@var{cell_array})\n\
+@deftypefn  {} {} char (@var{x})\n\
+@deftypefnx {} {} char (@var{x}, @dots{})\n\
+@deftypefnx {} {} char (@var{s1}, @var{s2}, @dots{})\n\
+@deftypefnx {} {} char (@var{cell_array})\n\
 Create a string array from one or more numeric matrices, character\n\
 matrices, or cell arrays.\n\
 \n\
 Arguments are concatenated vertically.  The returned values are padded with\n\
 blanks as needed to make each row of the string array have the same length.\n\
 Empty input strings are significant and will concatenated in the output.\n\
 \n\
 For numerical input, each element is converted to the corresponding ASCII\n\
@@ -162,20 +162,20 @@ char ([97, 98, 99], \"\", @{\"98\", \"99
 %! x = char ("foo", "bar", "foobar");
 %! assert (x(1,:), "foo   ");
 %! assert (x(2,:), "bar   ");
 %! assert (x(3,:), "foobar");
 */
 
 DEFUN (strvcat, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} strvcat (@var{x})\n\
-@deftypefnx {Built-in Function} {} strvcat (@var{x}, @dots{})\n\
-@deftypefnx {Built-in Function} {} strvcat (@var{s1}, @var{s2}, @dots{})\n\
-@deftypefnx {Built-in Function} {} strvcat (@var{cell_array})\n\
+@deftypefn  {} {} strvcat (@var{x})\n\
+@deftypefnx {} {} strvcat (@var{x}, @dots{})\n\
+@deftypefnx {} {} strvcat (@var{s1}, @var{s2}, @dots{})\n\
+@deftypefnx {} {} strvcat (@var{cell_array})\n\
 Create a character array from one or more numeric matrices, character\n\
 matrices, or cell arrays.\n\
 \n\
 Arguments are concatenated vertically.  The returned values are padded with\n\
 blanks as needed to make each row of the string array have the same length.\n\
 Unlike @code{char}, empty strings are removed and will not appear in the\n\
 output.\n\
 \n\
@@ -279,17 +279,17 @@ strvcat ([97, 98, 99], \"\", @{\"98\", \
 %!assert (strvcat (["a";"be"], {"c", 100}), ["a";"be";"c";"d"])
 %!assert (strvcat ("a", "bb", "ccc"), ["a  "; "bb "; "ccc"])
 %!assert (strvcat (), "")
 */
 
 
 DEFUN (ischar, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ischar (@var{x})\n\
+@deftypefn {} {} ischar (@var{x})\n\
 Return true if @var{x} is a character array.\n\
 @seealso{isfloat, isinteger, islogical, isnumeric, iscellstr, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_string ());
@@ -531,17 +531,17 @@ static bool
 strcmp_str_op (const std::string& s1, const std::string& s2,
                octave_idx_type)
 {
   return s1 == s2;
 }
 
 DEFUN (strcmp, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} strcmp (@var{s1}, @var{s2})\n\
+@deftypefn {} {} strcmp (@var{s1}, @var{s2})\n\
 Return 1 if the character strings @var{s1} and @var{s2} are the same,\n\
 and 0 otherwise.\n\
 \n\
 If either @var{s1} or @var{s2} is a cell array of strings, then an array\n\
 of the same size is returned, containing the values described above for\n\
 every member of the cell array.  The other argument may also be a cell\n\
 array of strings (of the same size or with only one element), char matrix\n\
 or character string.\n\
@@ -627,17 +627,17 @@ strncmp_str_op (const std::string& s1, c
   octave_idx_type l1 = s1.length ();
   octave_idx_type l2 = s2.length ();
   return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data ()));
 }
 
 DEFUN (strncmp, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} strncmp (@var{s1}, @var{s2}, @var{n})\n\
+@deftypefn {} {} strncmp (@var{s1}, @var{s2}, @var{n})\n\
 Return 1 if the first @var{n} characters of strings @var{s1} and @var{s2} are\n\
 the same, and 0 otherwise.\n\
 \n\
 @example\n\
 @group\n\
 strncmp (\"abce\", \"abcd\", 3)\n\
       @result{} 1\n\
 @end group\n\
@@ -716,17 +716,17 @@ strcmpi_str_op (const std::string& s1, c
 {
   return (s1.size () == s2.size ()
           && std::equal (s1.data (), s1.data () + s1.size (), s2.data (),
                          icmp_char_eq ()));
 }
 
 DEFUNX ("strcmpi", Fstrcmpi, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} strcmpi (@var{s1}, @var{s2})\n\
+@deftypefn {} {} strcmpi (@var{s1}, @var{s2})\n\
 Return 1 if the character strings @var{s1} and @var{s2} are the same,\n\
 disregarding case of alphabetic characters, and 0 otherwise.\n\
 \n\
 If either @var{s1} or @var{s2} is a cell array of strings, then an array\n\
 of the same size is returned, containing the values described above for\n\
 every member of the cell array.  The other argument may also be a cell\n\
 array of strings (of the same size or with only one element), char matrix\n\
 or character string.\n\
@@ -773,17 +773,17 @@ strncmpi_str_op (const std::string& s1, 
   octave_idx_type l2 = s2.length ();
   return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data (),
                          icmp_char_eq ()));
 }
 
 DEFUNX ("strncmpi", Fstrncmpi, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} strncmpi (@var{s1}, @var{s2}, @var{n})\n\
+@deftypefn {} {} strncmpi (@var{s1}, @var{s2}, @var{n})\n\
 Return 1 if the first @var{n} character of @var{s1} and @var{s2} are the\n\
 same, disregarding case of alphabetic characters, and 0 otherwise.\n\
 \n\
 If either @var{s1} or @var{s2} is a cell array of strings, then an array\n\
 of the same size is returned, containing the values described above for\n\
 every member of the cell array.  The other argument may also be a cell\n\
 array of strings (of the same size or with only one element), char matrix\n\
 or character string.\n\
@@ -813,17 +813,17 @@ This is just the opposite of the corresp
 }
 
 /*
 %!assert (strncmpi ("abc123", "ABC456", 3), true)
 */
 
 DEFUN (list_in_columns, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} list_in_columns (@var{arg}, @var{width}, @var{prefix})\n\
+@deftypefn {} {} list_in_columns (@var{arg}, @var{width}, @var{prefix})\n\
 Return a string containing the elements of @var{arg} listed in columns with\n\
 an overall maximum width of @var{width} and optional prefix @var{prefix}.\n\
 \n\
 The argument @var{arg} must be a cell array of character strings or a\n\
 character array.\n\
 \n\
 If @var{width} is not specified or is an empty matrix, or less than or equal\n\
 to zero, the width of the terminal screen is used.  Newline characters are\n\
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -60,18 +60,18 @@ get_dim_vector (const octave_value& val,
         }
     }
 
   return dv;
 }
 
 DEFUN (sub2ind, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{i}, @var{j})\n\
-@deftypefnx {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{s1}, @var{s2}, @dots{}, @var{sN})\n\
+@deftypefn  {} {@var{ind} =} sub2ind (@var{dims}, @var{i}, @var{j})\n\
+@deftypefnx {} {@var{ind} =} sub2ind (@var{dims}, @var{s1}, @var{s2}, @dots{}, @var{sN})\n\
 Convert subscripts to a linear index.\n\
 \n\
 The following example shows how to convert the two-dimensional index\n\
 @code{(2,3)} of a 3-by-3 matrix to a linear index.  The matrix is linearly\n\
 indexed moving from one column to next, filling up all rows in each column.\n\
 \n\
 @example\n\
 @group\n\
@@ -159,17 +159,17 @@ linear_index = sub2ind ([3, 3], 2, 3)\n\
 ## Test input validation
 %!error <dimension vector> sub2ind ([10 10.5], 1, 1)
 %!error <index \(1.5,_\)> sub2ind ([10 10], 1.5, 1)
 %!error <index \(_,1.5\)> sub2ind ([10 10], 1, 1.5)
 */
 
 DEFUN (ind2sub, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {[@var{s1}, @var{s2}, @dots{}, @var{sN}] =} ind2sub (@var{dims}, @var{ind})\n\
+@deftypefn {} {[@var{s1}, @var{s2}, @dots{}, @var{sN}] =} ind2sub (@var{dims}, @var{ind})\n\
 Convert a linear index to subscripts.\n\
 \n\
 The following example shows how to convert the linear index @code{8}\n\
 in a 3-by-3 matrix into a subscript.  The matrix is linearly indexed\n\
 moving from one column to next, filling up all rows in each column.\n\
 \n\
 @example\n\
 @group\n\
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -36,19 +36,19 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "utils.h"
 #include "variables.h"
 
 static int Vsvd_driver = SVD::GESVD;
 
 DEFUN (svd, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{s} =} svd (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A})\n\
-@deftypefnx {Built-in Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A}, @var{econ})\n\
+@deftypefn  {} {@var{s} =} svd (@var{A})\n\
+@deftypefnx {} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A})\n\
+@deftypefnx {} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A}, @var{econ})\n\
 @cindex singular value decomposition\n\
 Compute the singular value decomposition of @var{A}\n\
 @tex\n\
 $$\n\
  A = U S V^{\\dagger}\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -362,19 +362,19 @@ decomposition, eliminating the unnecessa
 
 %!error svd ()
 %!error svd ([1, 2; 4, 5], 2, 3)
 %!error [u, v] = svd ([1, 2; 3, 4])
 */
 
 DEFUN (svd_driver, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} svd_driver ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} svd_driver (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} svd_driver (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} svd_driver ()\n\
+@deftypefnx {} {@var{old_val} =} svd_driver (@var{new_val})\n\
+@deftypefnx {} {} svd_driver (@var{new_val}, \"local\")\n\
 Query or set the underlying @sc{lapack} driver used by @code{svd}.\n\
 \n\
 Currently recognized values are @qcode{\"gesvd\"} and @qcode{\"gesdd\"}.\n\
 The default is @qcode{\"gesvd\"}.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
diff --git a/libinterp/corefcn/sylvester.cc b/libinterp/corefcn/sylvester.cc
--- a/libinterp/corefcn/sylvester.cc
+++ b/libinterp/corefcn/sylvester.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (sylvester, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{X} =} syl (@var{A}, @var{B}, @var{C})\n\
+@deftypefn {} {@var{X} =} syl (@var{A}, @var{B}, @var{C})\n\
 Solve the Sylvester equation\n\
 @tex\n\
 $$\n\
  A X + X B = C\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1642,18 +1642,18 @@ symbol_table::do_update_nest (void)
 
   for (std::vector<symbol_table*>::iterator iter = nest_children.begin ();
        iter != nest_children.end (); ++iter)
     (*iter)->do_update_nest ();
 }
 
 DEFUN (ignore_function_time_stamp, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} ignore_function_time_stamp ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})\n\
+@deftypefn  {} {@var{val} =} ignore_function_time_stamp ()\n\
+@deftypefnx {} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave checks\n\
 the time stamp on files each time it looks up functions defined in\n\
 function files.\n\
 \n\
 If the internal variable is set to @qcode{\"system\"}, Octave will not\n\
 automatically recompile function files in subdirectories of\n\
 @file{@var{octave-home}/lib/@var{version}} if they have changed since they were last compiled, but will recompile other function files in the search path if they change.\n\
 \n\
@@ -1721,35 +1721,35 @@ determine whether functions defined in f
 ## Test input validation
 %!error (ignore_function_time_stamp ("all", "all"))
 %!error (ignore_function_time_stamp ("UNKNOWN_VALUE"))
 %!error (ignore_function_time_stamp (42))
 */
 
 DEFUN (__current_scope__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{scope}, @var{context}]} __current_scope__ ()\n\
+@deftypefn {} {[@var{scope}, @var{context}]} __current_scope__ ()\n\
 Return the current scope and context as integers.\n\
 @seealso{__dump_symtab_info__}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = symbol_table::current_context ();
   retval(0) = symbol_table::current_scope ();
 
   return retval;
 }
 
 DEFUN (__dump_symtab_info__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} __dump_symtab_info__ ()\n\
-@deftypefnx {Built-in Function} {} __dump_symtab_info__ (@var{scope})\n\
-@deftypefnx {Built-in Function} {} __dump_symtab_info__ (\"scopes\")\n\
-@deftypefnx {Built-in Function} {} __dump_symtab_info__ (\"functions\")\n\
+@deftypefn  {} {} __dump_symtab_info__ ()\n\
+@deftypefnx {} {} __dump_symtab_info__ (@var{scope})\n\
+@deftypefnx {} {} __dump_symtab_info__ (\"scopes\")\n\
+@deftypefnx {} {} __dump_symtab_info__ (\"functions\")\n\
 Undocumented internal function.\n\
 @seealso{__current_scope__}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -1805,17 +1805,17 @@ Undocumented internal function.\n\
         }
     }
 
   return retval;
 }
 
 DEFUN (__get_cmdline_fcn_txt__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __get_cmdline_fcn_txt__ (@var{name})\n\
+@deftypefn {} {} __get_cmdline_fcn_txt__ (@var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     print_usage ();
 
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -106,17 +106,17 @@ mk_stat_result (const base_file_stat& fs
       retval(0) = Matrix ();
     }
 
   return retval;
 }
 
 DEFUNX ("dup2", Fdup2, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{fid}, @var{msg}] =} dup2 (@var{old}, @var{new})\n\
+@deftypefn {} {[@var{fid}, @var{msg}] =} dup2 (@var{old}, @var{new})\n\
 Duplicate a file descriptor.\n\
 \n\
 If successful, @var{fid} is greater than zero and contains the new file ID@.\n\
 Otherwise, @var{fid} is negative and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{fopen, fclose, fcntl}\n\
 @end deftypefn")
 {
@@ -147,17 +147,17 @@ error message.\n\
       retval(0) = status;
     }
 
   return retval;
 }
 
 DEFUNX ("exec", Fexec, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} exec (@var{file}, @var{args})\n\
+@deftypefn {} {[@var{err}, @var{msg}] =} exec (@var{file}, @var{args})\n\
 Replace current process with a new process.\n\
 \n\
 Calling @code{exec} without first calling @code{fork} will terminate your\n\
 current Octave process and replace it with the program named by @var{file}.\n\
 For example,\n\
 \n\
 @example\n\
 exec (\"ls\" \"-l\")\n\
@@ -217,17 +217,17 @@ error message.\n\
   retval(1) = msg;
   retval(0) = status;
 
   return retval;
 }
 
 DEFUNX ("popen2", Fpopen2, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{in}, @var{out}, @var{pid}] =} popen2 (@var{command}, @var{args})\n\
+@deftypefn {} {[@var{in}, @var{out}, @var{pid}] =} popen2 (@var{command}, @var{args})\n\
 Start a subprocess with two-way communication.\n\
 \n\
 The name of the process is given by @var{command}, and @var{args} is an\n\
 array of strings containing options for the command.\n\
 \n\
 The file identifiers for the input and output streams of the subprocess are\n\
 returned in @var{in} and @var{out}.  If execution of the command is\n\
 successful, @var{pid} contains the process ID of the subprocess.  Otherwise,\n\
@@ -402,17 +402,17 @@ exit status, it will linger until Octave
 %!   waitpid (pid);
 %!   assert (str, {"these\r\n","strings\r\n","some\r\n","are\r\n"});
 %! endif
 
 */
 
 DEFUNX ("fcntl", Ffcntl, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} fcntl (@var{fid}, @var{request}, @var{arg})\n\
+@deftypefn {} {[@var{err}, @var{msg}] =} fcntl (@var{fid}, @var{request}, @var{arg})\n\
 Change the properties of the open file @var{fid}.\n\
 \n\
 The following values may be passed as @var{request}:\n\
 \n\
 @vtable @code\n\
 @item F_DUPFD\n\
 Return a duplicate file descriptor.\n\
 \n\
@@ -494,17 +494,17 @@ message.\n\
       retval(0) = status;
     }
 
   return retval;
 }
 
 DEFUNX ("fork", Ffork, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{pid}, @var{msg}] =} fork ()\n\
+@deftypefn {} {[@var{pid}, @var{msg}] =} fork ()\n\
 Create a copy of the current process.\n\
 \n\
 Fork can return one of the following values:\n\
 \n\
 @table @asis\n\
 @item > 0\n\
 You are in the parent process.  The value returned from @code{fork} is the\n\
 process id of the child process.  You should probably arrange to wait for\n\
@@ -537,17 +537,17 @@ action.  A system dependent error messag
   retval(1) = msg;
   retval(0) = pid;
 
   return retval;
 }
 
 DEFUNX ("getpgrp", Fgetpgrp, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {pgid =} getpgrp ()\n\
+@deftypefn {} {pgid =} getpgrp ()\n\
 Return the process group id of the current process.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1;
 
@@ -561,77 +561,77 @@ Return the process group id of the curre
   retval(1) = msg;
   retval(0) = octave_syscalls::getpgrp (msg);
 
   return retval;
 }
 
 DEFUNX ("getpid", Fgetpid, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {pid =} getpid ()\n\
+@deftypefn {} {pid =} getpid ()\n\
 Return the process id of the current process.\n\
 @seealso{getppid}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
   if (nargin != 0)
     print_usage ();
 
   return octave_value (octave_syscalls::getpid ());
 }
 
 DEFUNX ("getppid", Fgetppid, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {pid =} getppid ()\n\
+@deftypefn {} {pid =} getppid ()\n\
 Return the process id of the parent process.\n\
 @seealso{getpid}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
   if (nargin != 0)
     print_usage ();
 
   return octave_value (octave_syscalls::getppid ());
 }
 
 DEFUNX ("getegid", Fgetegid, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {egid =} getegid ()\n\
+@deftypefn {} {egid =} getegid ()\n\
 Return the effective group id of the current process.\n\
 @seealso{getgid}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
   if (nargin != 0)
     print_usage ();
 
   return octave_value (octave_syscalls::getegid ());
 }
 
 DEFUNX ("getgid", Fgetgid, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {gid =} getgid ()\n\
+@deftypefn {} {gid =} getgid ()\n\
 Return the real group id of the current process.\n\
 @seealso{getegid}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
   if (nargin != 0)
     print_usage ();
 
   return octave_value (octave_syscalls::getgid ());
 }
 
 DEFUNX ("geteuid", Fgeteuid, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {euid =} geteuid ()\n\
+@deftypefn {} {euid =} geteuid ()\n\
 Return the effective user id of the current process.\n\
 @seealso{getuid}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
@@ -640,17 +640,17 @@ Return the effective user id of the curr
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("getuid", Fgetuid, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {uid =} getuid ()\n\
+@deftypefn {} {uid =} getuid ()\n\
 Return the real user id of the current process.\n\
 @seealso{geteuid}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
@@ -659,17 +659,17 @@ Return the real user id of the current p
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("kill", Fkill, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} kill (@var{pid}, @var{sig})\n\
+@deftypefn {} {[@var{err}, @var{msg}] =} kill (@var{pid}, @var{sig})\n\
 Send signal @var{sig} to process @var{pid}.\n\
 \n\
 If @var{pid} is positive, then signal @var{sig} is sent to @var{pid}.\n\
 \n\
 If @var{pid} is 0, then signal @var{sig} is sent to every process\n\
 in the process group of the current process.\n\
 \n\
 If @var{pid} is -1, then signal @var{sig} is sent to every process\n\
@@ -705,18 +705,18 @@ Return 0 if successful, otherwise return
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("lstat", Flstat, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{info} =} lstat (@var{symlink})\n\
-@deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{symlink})\n\
+@deftypefn  {} {@var{info} =} lstat (@var{symlink})\n\
+@deftypefnx {} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{symlink})\n\
 Return a structure @var{info} containing information about the symbolic link\n\
 @var{symlink}.\n\
 \n\
 The function outputs are described in the documentation for @code{stat}.\n\
 @seealso{stat, symlink}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -763,18 +763,18 @@ convert (int x, int ibase, int obase)
         }
     }
 
   return retval;
 }
 
 DEFUNX ("mkfifo", Fmkfifo, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{err} =} mkfifo (@var{name}, @var{mode})\n\
-@deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} mkfifo (@var{name}, @var{mode})\n\
+@deftypefn  {} {@var{err} =} mkfifo (@var{name}, @var{mode})\n\
+@deftypefnx {} {[@var{err}, @var{msg}] =} mkfifo (@var{name}, @var{mode})\n\
 Create a FIFO special file named @var{name} with file mode @var{mode}.\n\
 \n\
 @var{mode} is interpreted as an octal number and is subject to umask\n\
 processing.  The final calculated mode is @code{@var{mode} - @var{umask}}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
@@ -826,17 +826,17 @@ error message.\n\
 ## FIXME: These tests should work, but lasterr is not being set correctly.
 #%!error <MODE must be an integer> mkfifo ("abc", {456})
 #%!error <MODE must be a positive integer value> mkfifo ("abc", -1)
 
 */
 
 DEFUNX ("pipe", Fpipe, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{read_fd}, @var{write_fd}, @var{err}, @var{msg}] =} pipe ()\n\
+@deftypefn {} {[@var{read_fd}, @var{write_fd}, @var{err}, @var{msg}] =} pipe ()\n\
 Create a pipe and return the reading and writing ends of the pipe into\n\
 @var{read_fd} and @var{write_fd} respectively.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{mkfifo}\n\
 @end deftypefn")
@@ -879,20 +879,20 @@ error message.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("stat", Fstat, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} stat (@var{file})\n\
-@deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} stat (@var{fid})\n\
-@deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{file})\n\
-@deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{fid})\n\
+@deftypefn  {} {[@var{info}, @var{err}, @var{msg}] =} stat (@var{file})\n\
+@deftypefnx {} {[@var{info}, @var{err}, @var{msg}] =} stat (@var{fid})\n\
+@deftypefnx {} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{file})\n\
+@deftypefnx {} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{fid})\n\
 Return a structure @var{info} containing the following information about\n\
 @var{file} or file identifier @var{fid}.\n\
 \n\
 @table @code\n\
 @item dev\n\
 ID of device containing a directory entry for this file.\n\
 \n\
 @item ino\n\
@@ -1002,17 +1002,17 @@ For example:\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISREG", FS_ISREG, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} S_ISREG (@var{mode})\n\
+@deftypefn {} {} S_ISREG (@var{mode})\n\
 Return true if @var{mode} corresponds to a regular file.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -1025,17 +1025,17 @@ The value of @var{mode} is assumed to be
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISDIR", FS_ISDIR, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} S_ISDIR (@var{mode})\n\
+@deftypefn {} {} S_ISDIR (@var{mode})\n\
 Return true if @var{mode} corresponds to a directory.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -1048,17 +1048,17 @@ The value of @var{mode} is assumed to be
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISCHR", FS_ISCHR, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} S_ISCHR (@var{mode})\n\
+@deftypefn {} {} S_ISCHR (@var{mode})\n\
 Return true if @var{mode} corresponds to a character device.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -1071,17 +1071,17 @@ The value of @var{mode} is assumed to be
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISBLK", FS_ISBLK, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} S_ISBLK (@var{mode})\n\
+@deftypefn {} {} S_ISBLK (@var{mode})\n\
 Return true if @var{mode} corresponds to a block device.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -1094,17 +1094,17 @@ The value of @var{mode} is assumed to be
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISFIFO", FS_ISFIFO, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} S_ISFIFO (@var{mode})\n\
+@deftypefn {} {} S_ISFIFO (@var{mode})\n\
 Return true if @var{mode} corresponds to a fifo.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -1117,17 +1117,17 @@ The value of @var{mode} is assumed to be
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISLNK", FS_ISLNK, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} S_ISLNK (@var{mode})\n\
+@deftypefn {} {} S_ISLNK (@var{mode})\n\
 Return true if @var{mode} corresponds to a symbolic link.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -1140,17 +1140,17 @@ The value of @var{mode} is assumed to be
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISSOCK", FS_ISSOCK, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} S_ISSOCK (@var{mode})\n\
+@deftypefn {} {} S_ISSOCK (@var{mode})\n\
 Return true if @var{mode} corresponds to a socket.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -1163,33 +1163,33 @@ The value of @var{mode} is assumed to be
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (gethostname, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} gethostname ()\n\
+@deftypefn {} {} gethostname ()\n\
 Return the hostname of the system where Octave is running.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = octave_env::get_host_name ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (uname, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{uts}, @var{err}, @var{msg}] =} uname ()\n\
+@deftypefn {} {[@var{uts}, @var{err}, @var{msg}] =} uname ()\n\
 Return system information in the structure.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 uname ()\n\
    @result{} @{\n\
@@ -1228,17 +1228,17 @@ system-dependent error message.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("unlink", Funlink, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} unlink (@var{file})\n\
+@deftypefn {} {[@var{err}, @var{msg}] =} unlink (@var{file})\n\
 Delete the file named @var{file}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{delete, rmdir}\n\
 @end deftypefn")
 {
@@ -1263,17 +1263,17 @@ error message.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("waitpid", Fwaitpid, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{pid}, @var{status}, @var{msg}] =} waitpid (@var{pid}, @var{options})\n\
+@deftypefn {} {[@var{pid}, @var{status}, @var{msg}] =} waitpid (@var{pid}, @var{options})\n\
 Wait for process @var{pid} to terminate.\n\
 \n\
 The @var{pid} argument can be:\n\
 \n\
 @table @asis\n\
 @item @minus{}1\n\
 Wait for any child process.\n\
 \n\
@@ -1344,17 +1344,17 @@ about the subprocess that exited.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WIFEXITED", FWIFEXITED, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} WIFEXITED (@var{status})\n\
+@deftypefn {} {} WIFEXITED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 true if the child terminated normally.\n\
 @seealso{waitpid, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
@@ -1366,17 +1366,17 @@ true if the child terminated normally.\n
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WEXITSTATUS", FWEXITSTATUS, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} WEXITSTATUS (@var{status})\n\
+@deftypefn {} {} WEXITSTATUS (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 the exit status of the child.\n\
 \n\
 This function should only be employed if @code{WIFEXITED} returned true.\n\
 @seealso{waitpid, WIFEXITED, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = 0;
@@ -1388,17 +1388,17 @@ This function should only be employed if
       retval = octave_wait::exitstatus (status);
     }
 
   return retval;
 }
 
 DEFUNX ("WIFSIGNALED", FWIFSIGNALED, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} WIFSIGNALED (@var{status})\n\
+@deftypefn {} {} WIFSIGNALED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 true if the child process was terminated by a signal.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
@@ -1410,17 +1410,17 @@ true if the child process was terminated
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WTERMSIG", FWTERMSIG, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} WTERMSIG (@var{status})\n\
+@deftypefn {} {} WTERMSIG (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 the number of the signal that caused the child process to terminate.\n\
 \n\
 This function should only be employed if @code{WIFSIGNALED} returned true.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = 0;
@@ -1434,17 +1434,17 @@ This function should only be employed if
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WCOREDUMP", FWCOREDUMP, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} WCOREDUMP (@var{status})\n\
+@deftypefn {} {} WCOREDUMP (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 true if the child produced a core dump.\n\
 \n\
 This function should only be employed if @code{WIFSIGNALED} returned true.\n\
 The macro used to implement this function is not specified in POSIX.1-2001\n\
 and is not available on some Unix implementations (e.g., AIX, SunOS).\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
@@ -1460,17 +1460,17 @@ and is not available on some Unix implem
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WIFSTOPPED", FWIFSTOPPED, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} WIFSTOPPED (@var{status})\n\
+@deftypefn {} {} WIFSTOPPED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 true if the child process was stopped by delivery of a signal.\n\
 \n\
 This is only possible if the call was done using @code{WUNTRACED} or when\n\
 the child is being traced (see ptrace(2)).\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
@@ -1485,17 +1485,17 @@ the child is being traced (see ptrace(2)
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WSTOPSIG", FWSTOPSIG, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} WSTOPSIG (@var{status})\n\
+@deftypefn {} {} WSTOPSIG (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 the number of the signal which caused the child to stop.\n\
 \n\
 This function should only be employed if @code{WIFSTOPPED} returned true.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = 0;
@@ -1509,17 +1509,17 @@ This function should only be employed if
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WIFCONTINUED", FWIFCONTINUED, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} WIFCONTINUED (@var{status})\n\
+@deftypefn {} {} WIFCONTINUED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 true if the child process was resumed by delivery of @code{SIGCONT}.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
@@ -1531,17 +1531,17 @@ true if the child process was resumed by
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("canonicalize_file_name", Fcanonicalize_file_name, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{cname}, @var{status}, @var{msg}] =} canonicalize_file_name (@var{fname})\n\
+@deftypefn {} {[@var{cname}, @var{status}, @var{msg}] =} canonicalize_file_name (@var{fname})\n\
 Return the canonical name of file @var{fname}.\n\
 \n\
 If the file does not exist the empty string (\"\") is returned.\n\
 @seealso{make_absolute_filename, is_absolute_filename, is_rooted_relative_filename}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -1578,246 +1578,246 @@ const_value (const octave_value_list& ar
 }
 
 #if ! defined (O_NONBLOCK) && defined (O_NDELAY)
 #define O_NONBLOCK O_NDELAY
 #endif
 
 DEFUNX ("F_DUPFD", FF_DUPFD, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} F_DUPFD ()\n\
+@deftypefn {} {} F_DUPFD ()\n\
 Return the numerical value to pass to @code{fcntl} to return\n\
 a duplicate file descriptor.\n\
 @seealso{fcntl, F_GETFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_DUPFD)
   return const_value (args, F_DUPFD);
 #else
   error ("F_DUPFD: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("F_GETFD", FF_GETFD, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} F_GETFD ()\n\
+@deftypefn {} {} F_GETFD ()\n\
 Return the numerical value to pass to @code{fcntl} to return\n\
 the file descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_GETFD)
   return const_value (args, F_GETFD);
 #else
   error ("F_GETFD: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("F_GETFL", FF_GETFL, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} F_GETFL ()\n\
+@deftypefn {} {} F_GETFL ()\n\
 Return the numerical value to pass to @code{fcntl} to return\n\
 the file status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_GETFL)
   return const_value (args, F_GETFL);
 #else
   error ("F_GETFL: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("F_SETFD", FF_SETFD, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} F_SETFD ()\n\
+@deftypefn {} {} F_SETFD ()\n\
 Return the numerical value to pass to @code{fcntl} to set the file\n\
 descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_SETFD)
   return const_value (args, F_SETFD);
 #else
   error ("F_SETFD: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("F_SETFL", FF_SETFL, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} F_SETFL ()\n\
+@deftypefn {} {} F_SETFL ()\n\
 Return the numerical value to pass to @code{fcntl} to set the file\n\
 status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFD}\n\
 @end deftypefn")
 {
 #if defined (F_SETFL)
   return const_value (args, F_SETFL);
 #else
   error ("F_SETFL: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_APPEND", FO_APPEND, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} O_APPEND ()\n\
+@deftypefn {} {} O_APPEND ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate each write operation appends,\n\
 or that may be passed to @code{fcntl} to set the write mode to append.\n\
 @seealso{fcntl, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_APPEND)
   return const_value (args, O_APPEND);
 #else
   error ("O_APPEND: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_ASYNC", FO_ASYNC, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} O_ASYNC ()\n\
+@deftypefn {} {} O_ASYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate asynchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_ASYNC)
   return const_value (args, O_ASYNC);
 #else
   error ("O_ASYNC: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_CREAT", FO_CREAT, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} O_CREAT ()\n\
+@deftypefn {} {} O_CREAT ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file should be created if it\n\
 does not exist.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_CREAT)
   return const_value (args, O_CREAT);
 #else
   error ("O_CREAT: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_EXCL", FO_EXCL, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} O_EXCL ()\n\
+@deftypefn {} {} O_EXCL ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that file locking is used.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_EXCL)
   return const_value (args, O_EXCL);
 #else
   error ("O_EXCL: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_NONBLOCK", FO_NONBLOCK, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} O_NONBLOCK ()\n\
+@deftypefn {} {} O_NONBLOCK ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that non-blocking I/O is in use,\n\
 or that may be passsed to @code{fcntl} to set non-blocking I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_NONBLOCK)
   return const_value (args, O_NONBLOCK);
 #else
   error ("O_NONBLOCK: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_RDONLY", FO_RDONLY, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} O_RDONLY ()\n\
+@deftypefn {} {} O_RDONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for reading only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_RDONLY)
   return const_value (args, O_RDONLY);
 #else
   error ("O_RDONLY: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_RDWR", FO_RDWR, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} O_RDWR ()\n\
+@deftypefn {} {} O_RDWR ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for both reading\n\
 and writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_RDWR)
   return const_value (args, O_RDWR);
 #else
   error ("O_RDWR: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_SYNC", FO_SYNC, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} O_SYNC ()\n\
+@deftypefn {} {} O_SYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for synchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_SYNC)
   return const_value (args, O_SYNC);
 #else
   error ("O_SYNC: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_TRUNC", FO_TRUNC, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} O_TRUNC ()\n\
+@deftypefn {} {} O_TRUNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that if file exists, it should be\n\
 truncated when writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_TRUNC)
   return const_value (args, O_TRUNC);
 #else
   error ("O_TRUNC: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_WRONLY", FO_WRONLY, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} O_WRONLY ()\n\
+@deftypefn {} {} O_WRONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for writing only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC}\n\
 @end deftypefn")
 {
 #if defined (O_WRONLY)
   return const_value (args, O_WRONLY);
 #else
@@ -1827,49 +1827,49 @@ returned by @code{fcntl} to indicate tha
 }
 
 #if ! defined (WNOHANG)
 #define WNOHANG 0
 #endif
 
 DEFUNX ("WNOHANG", FWNOHANG, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} WNOHANG ()\n\
+@deftypefn {} {} WNOHANG ()\n\
 Return the numerical value of the option argument that may be\n\
 passed to @code{waitpid} to indicate that it should return its status\n\
 immediately instead of waiting for a process to exit.\n\
 @seealso{waitpid, WUNTRACED, WCONTINUE}\n\
 @end deftypefn")
 {
   return const_value (args, WNOHANG);
 }
 
 #if ! defined (WUNTRACED)
 #define WUNTRACED 0
 #endif
 
 DEFUNX ("WUNTRACED", FWUNTRACED, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} WUNTRACED ()\n\
+@deftypefn {} {} WUNTRACED ()\n\
 Return the numerical value of the option argument that may be\n\
 passed to @code{waitpid} to indicate that it should also return if the child\n\
 process has stopped but is not traced via the @code{ptrace} system call\n\
 @seealso{waitpid, WNOHANG, WCONTINUE}\n\
 @end deftypefn")
 {
   return const_value (args, WUNTRACED);
 }
 
 #if ! defined (WCONTINUE)
 #define WCONTINUE 0
 #endif
 
 DEFUNX ("WCONTINUE", FWCONTINUE, args, ,
         "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} WCONTINUE ()\n\
+@deftypefn {} {} WCONTINUE ()\n\
 Return the numerical value of the option argument that may be\n\
 passed to @code{waitpid} to indicate that it should also return if a stopped\n\
 child has been resumed by delivery of a @code{SIGCONT} signal.\n\
 @seealso{waitpid, WNOHANG, WUNTRACED}\n\
 @end deftypefn")
 {
   return const_value (args, WCONTINUE);
 }
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -182,17 +182,17 @@ w32_init (void)
 static bool
 w32_shell_execute (const std::string& file)
 {
 }
 #endif
 
 DEFUN (__open_with_system_app__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __open_with_system_app__ (@var{file})\n\
+@deftypefn {} {} __open_with_system_app__ (@var{file})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     print_usage ();
 
@@ -576,33 +576,33 @@ get_P_tmpdir (void)
 
   return "/tmp";
 
 #endif
 }
 
 DEFUN (clc, , ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} clc ()\n\
-@deftypefnx {Built-in Function} {} home ()\n\
+@deftypefn  {} {} clc ()\n\
+@deftypefnx {} {} home ()\n\
 Clear the terminal screen and move the cursor to the upper left corner.\n\
 @end deftypefn")
 {
   bool skip_redisplay = true;
 
   command_editor::clear_screen (skip_redisplay);
 
   return octave_value_list ();
 }
 
 DEFALIAS (home, clc);
 
 DEFUN (getenv, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} getenv (@var{var})\n\
+@deftypefn {} {} getenv (@var{var})\n\
 Return the value of the environment variable @var{var}.\n\
 \n\
 For example,\n\
 \n\
 @example\n\
 getenv (\"PATH\")\n\
 @end example\n\
 \n\
@@ -620,19 +620,19 @@ returns a string containing the value of
 }
 
 /*
 %!assert (ischar (getenv ("OCTAVE_HOME")))
 */
 
 DEFUN (setenv, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} setenv (@var{var}, @var{value})\n\
-@deftypefnx {Built-in Function} {} setenv (@var{var})\n\
-@deftypefnx {Built-in Function} {} putenv (@dots{})\n\
+@deftypefn  {} {} setenv (@var{var}, @var{value})\n\
+@deftypefnx {} {} setenv (@var{var})\n\
+@deftypefnx {} {} putenv (@dots{})\n\
 Set the value of the environment variable @var{var} to @var{value}.\n\
 \n\
 If no @var{value} is specified then the variable will be assigned the null\n\
 string.\n\
 @seealso{unsetenv, getenv}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -660,17 +660,17 @@ DEFALIAS (putenv, setenv);
 %! setenv ("dummy_variable_that_cannot_matter", "foobar");
 %! assert (getenv ("dummy_variable_that_cannot_matter"), "foobar");
 %! unsetenv ("dummy_variable_that_cannot_matter");
 %! assert (getenv ("dummy_variable_that_cannot_matter"), "");
 */
 
 DEFUN (unsetenv, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{status} =} unsetenv (@var{var})\n\
+@deftypefn {} {@var{status} =} unsetenv (@var{var})\n\
 Delete the environment variable @var{var}.\n\
 \n\
 Return 0 if the variable was deleted, or did not exist, and -1 if an error\n\
 occurred.\n\
 @seealso{setenv, getenv}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
@@ -684,18 +684,18 @@ occurred.\n\
 /*
 ## Test for unsetenv is in setenv test
 */
 
 // FIXME: perhaps kbhit should also be able to print a prompt?
 
 DEFUN (kbhit, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} kbhit ()\n\
-@deftypefnx {Built-in Function} {} kbhit (1)\n\
+@deftypefn  {} {} kbhit ()\n\
+@deftypefnx {} {} kbhit (1)\n\
 Read a single keystroke from the keyboard.\n\
 \n\
 If called with an argument, don't wait for a keypress.\n\
 \n\
 For example,\n\
 \n\
 @example\n\
 x = kbhit ();\n\
@@ -733,18 +733,18 @@ returning the empty string if no key is 
       retval = s;
     }
 
   return retval;
 }
 
 DEFUN (pause, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} pause ()\n\
-@deftypefnx {Built-in Function} {} pause (@var{n})\n\
+@deftypefn  {} {} pause ()\n\
+@deftypefnx {} {} pause (@var{n})\n\
 Suspend the execution of the program for @var{n} seconds.\n\
 \n\
 @var{n} is a positive real value and may be a fraction of a second.\n\
 \n\
 If invoked without an input arguments then the program is suspended until a\n\
 character is typed.\n\
 \n\
 The following example prints a message and then waits 5 seconds before\n\
@@ -800,17 +800,17 @@ clc;\n\
 %!test
 %! pause (1);
 
 %!error (pause (1, 2))
 */
 
 DEFUN (sleep, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} sleep (@var{seconds})\n\
+@deftypefn {} {} sleep (@var{seconds})\n\
 Suspend the execution of the program for the given number of seconds.\n\
 @seealso{usleep, pause}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () != 1)
     print_usage ();
@@ -833,17 +833,17 @@ Suspend the execution of the program for
 %! sleep (1);
 
 %!error (sleep ())
 %!error (sleep (1, 2))
 */
 
 DEFUN (usleep, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} usleep (@var{microseconds})\n\
+@deftypefn {} {} usleep (@var{microseconds})\n\
 Suspend the execution of the program for the given number of\n\
 microseconds.\n\
 \n\
 On systems where it is not possible to sleep for periods of time less than\n\
 one second, @code{usleep} will pause the execution for @code{round\n\
 (@var{microseconds} / 1e6)} seconds.\n\
 @seealso{sleep, pause}\n\
 @end deftypefn")
@@ -878,17 +878,17 @@ one second, @code{usleep} will pause the
 %!error (usleep (1, 2))
 */
 
 // FIXME: maybe this should only return 1 if IEEE floating
 // point functions really work.
 
 DEFUN (isieee, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isieee ()\n\
+@deftypefn {} {} isieee ()\n\
 Return true if your computer @emph{claims} to conform to the IEEE standard\n\
 for floating point calculations.\n\
 \n\
 No actual tests are performed.\n\
 @end deftypefn")
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
@@ -897,33 +897,33 @@ No actual tests are performed.\n\
 }
 
 /*
 %!assert (islogical (isieee ()))
 */
 
 DEFUN (native_float_format, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} native_float_format ()\n\
+@deftypefn {} {} native_float_format ()\n\
 Return the native floating point format as a string.\n\
 @end deftypefn")
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
   return octave_value (oct_mach_info::float_format_as_string (flt_fmt));
 }
 
 /*
 %!assert (ischar (native_float_format ()))
 */
 
 DEFUN (tilde_expand, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} tilde_expand (@var{string})\n\
-@deftypefnx {Built-in Function} {} tilde_expand (@var{cellstr})\n\
+@deftypefn  {} {} tilde_expand (@var{string})\n\
+@deftypefnx {} {} tilde_expand (@var{cellstr})\n\
 Perform tilde expansion on @var{string}.\n\
 \n\
 If @var{string} begins with a tilde character, (@samp{~}), all of the\n\
 characters preceding the first slash (or all characters, if there is no\n\
 slash) are treated as a possible user name, and the tilde and the following\n\
 characters up to the slash are replaced by the home directory of the named\n\
 user.  If the tilde is followed immediately by a slash, the tilde is\n\
 replaced by the home directory of the user running Octave.\n\
@@ -967,17 +967,17 @@ tilde_expand (\"~/bin\")\n\
 %! home = get_home_directory ();
 %! assert (tilde_expand ("~/foobar"), [home "/foobar"]);
 %! assert (tilde_expand ("/foo/bar"), "/foo/bar");
 %! assert (tilde_expand ("foo/bar"), "foo/bar");
 */
 
 DEFUN (get_home_directory, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{homedir} =} get_home_directory ()\n\
+@deftypefn {} {@var{homedir} =} get_home_directory ()\n\
 Return the current home directory.\n\
 \n\
 On most systems, this is equivalent to @code{getenv (\"HOME\")}.  On Windows\n\
 systems, if the environment variable @env{HOME} is not set then it is\n\
 equivalent to\n\
 @code{fullfile (getenv (\"HOMEDRIVE\"), getenv (\"HOMEPATH\"))}\n\
 @seealso{getenv}\n\
 @end deftypefn")
@@ -993,16 +993,16 @@ equivalent to\n\
 */
 
 // This function really belongs in display.cc, but including defun.h in
 // that file results in conflicts with symbols from headers that are
 // needed for X11 and Carbon functions.
 
 DEFUN (have_window_system, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} have_window_system ()\n\
+@deftypefn {} {} have_window_system ()\n\
 Return true if a window system is available (X11, Windows, or Apple OS X)\n\
 and false otherwise.\n\
 @seealso{isguirunning}\n\
 @end deftypefn")
 {
   return octave_value (display_info::display_available ());
 }
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -100,17 +100,17 @@ extract_tm (const octave_scalar_map& m, 
   tm.gmtoff (intfield (m, "gmtoff", who));
   tm.zone (stringfield (m, "zone", who));
 
   return tm;
 }
 
 DEFUN (time, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{seconds} =} time ()\n\
+@deftypefn {} {@var{seconds} =} time ()\n\
 Return the current time as the number of seconds since the epoch.\n\
 \n\
 The epoch is referenced to 00:00:00 CUT (Coordinated Universal Time) 1 Jan\n\
 1970.  For example, on Monday February 17, 1997 at 07:15:06 CUT, the value\n\
 returned by @code{time} was 856163706.\n\
 @seealso{strftime, strptime, localtime, gmtime, mktime, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
@@ -123,17 +123,17 @@ returned by @code{time} was 856163706.\n
 /*
 %!assert (time () > 0)
 
 %!error time (1)
 */
 
 DEFUN (gmtime, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{tm_struct} =} gmtime (@var{t})\n\
+@deftypefn {} {@var{tm_struct} =} gmtime (@var{t})\n\
 Given a value returned from @code{time}, or any non-negative integer,\n\
 return a time structure corresponding to CUT (Coordinated Universal Time).\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 gmtime (time ())\n\
@@ -180,17 +180,17 @@ gmtime (time ())\n\
 %! assert (isfield (ts, "yday"));
 
 %!error gmtime ()
 %!error gmtime (1, 2)
 */
 
 DEFUN (localtime, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{tm_struct} =} localtime (@var{t})\n\
+@deftypefn {} {@var{tm_struct} =} localtime (@var{t})\n\
 Given a value returned from @code{time}, or any non-negative integer,\n\
 return a time structure corresponding to the local time zone.\n\
 \n\
 @example\n\
 @group\n\
 localtime (time ())\n\
      @result{} @{\n\
            usec = 0\n\
@@ -235,17 +235,17 @@ localtime (time ())\n\
 %! assert (isfield (ts, "yday"));
 
 %!error localtime ()
 %!error localtime (1, 2)
 */
 
 DEFUN (mktime, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{seconds} =} mktime (@var{tm_struct})\n\
+@deftypefn {} {@var{seconds} =} mktime (@var{tm_struct})\n\
 Convert a time structure corresponding to the local time to the number of\n\
 seconds since the epoch.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 mktime (localtime (time ()))\n\
@@ -279,17 +279,17 @@ mktime (localtime (time ()))\n\
 %!error mktime ()
 %!error mktime (1)
 %!error mktime (1, 2, 3)
 %!error mktime (struct ("year", "foo"))
 */
 
 DEFUN (strftime, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} strftime (@var{fmt}, @var{tm_struct})\n\
+@deftypefn {} {} strftime (@var{fmt}, @var{tm_struct})\n\
 Format the time structure @var{tm_struct} in a flexible way using the format\n\
 string @var{fmt} that contains @samp{%} substitutions similar to those in\n\
 @code{printf}.\n\
 \n\
 Except where noted, substituted fields have a fixed size; numeric fields are\n\
 padded if necessary.  Padding is with zeros by default; for fields that\n\
 display a single number, padding can be changed or inhibited by following\n\
 the @samp{%} with one of the modifiers described below.  Unknown field\n\
@@ -464,17 +464,17 @@ Year (1970-).\n\
 %!error strftime ()
 %!error strftime ("foo", 1)
 %!error strftime ("foo", struct ("year", "foo"))
 %!error strftime ("foo", localtime (time ()), 1)
 */
 
 DEFUN (strptime, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{tm_struct}, @var{nchars}] =} strptime (@var{str}, @var{fmt})\n\
+@deftypefn {} {[@var{tm_struct}, @var{nchars}] =} strptime (@var{str}, @var{fmt})\n\
 Convert the string @var{str} to the time structure @var{tm_struct} under\n\
 the control of the format string @var{fmt}.\n\
 \n\
 If @var{fmt} fails to match, @var{nchars} is 0; otherwise, it is set to the\n\
 position of last matched character plus 1. Always check for this unless\n\
 you're absolutely sure the date string will be parsed correctly.\n\
 @seealso{strftime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -807,20 +807,20 @@ clean_up_and_exit (int status, bool safe
     {
       if (octave_exit)
         (*octave_exit) (status);
     }
 }
 
 DEFUN (quit, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} exit\n\
-@deftypefnx {Built-in Function} {} exit (@var{status})\n\
-@deftypefnx {Built-in Function} {} quit\n\
-@deftypefnx {Built-in Function} {} quit (@var{status})\n\
+@deftypefn  {} {} exit\n\
+@deftypefnx {} {} exit (@var{status})\n\
+@deftypefnx {} {} quit\n\
+@deftypefnx {} {} quit (@var{status})\n\
 Exit the current Octave session.\n\
 \n\
 If the optional integer value @var{status} is supplied, pass that value to\n\
 the operating system as Octave's exit status.  The default value is zero.\n\
 \n\
 When exiting, Octave will attempt to run the m-file @file{finish.m} if it\n\
 exists.  User commands to save the workspace or clean up temporary files\n\
 may be placed in that file.  Alternatively, another m-file may be scheduled\n\
@@ -862,17 +862,17 @@ to run using @code{atexit}.\n\
 
   return retval;
 }
 
 DEFALIAS (exit, quit);
 
 DEFUN (warranty, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} warranty ()\n\
+@deftypefn {} {} warranty ()\n\
 Describe the conditions for copying and distributing Octave.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   octave_stdout << "\n" << octave_name_version_and_copyright () << "\n\
 \n\
 GNU Octave is free software; you can redistribute it and/or modify\n\
@@ -968,20 +968,20 @@ run_command_and_return_output (const std
 
   return retval;
 }
 
 enum system_exec_type { et_sync, et_async };
 
 DEFUN (system, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} system (\"@var{string}\")\n\
-@deftypefnx {Built-in Function} {} system (\"@var{string}\", @var{return_output})\n\
-@deftypefnx {Built-in Function} {} system (\"@var{string}\", @var{return_output}, @var{type})\n\
-@deftypefnx {Built-in Function} {[@var{status}, @var{output}] =} system (@dots{})\n\
+@deftypefn  {} {} system (\"@var{string}\")\n\
+@deftypefnx {} {} system (\"@var{string}\", @var{return_output})\n\
+@deftypefnx {} {} system (\"@var{string}\", @var{return_output}, @var{type})\n\
+@deftypefnx {} {[@var{status}, @var{output}] =} system (@dots{})\n\
 Execute a shell command specified by @var{string}.\n\
 \n\
 If the optional argument @var{type} is @qcode{\"async\"}, the process is\n\
 started in the background and the process ID of the child process is\n\
 returned immediately.  Otherwise, the child process is started and Octave\n\
 waits until it exits.  If the @var{type} argument is omitted, it defaults to\n\
 the value @qcode{\"sync\"}.\n\
 \n\
@@ -1166,18 +1166,18 @@ octave_remove_atexit_function (const std
     }
 
   return found;
 }
 
 
 DEFUN (atexit, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} atexit (@var{fcn})\n\
-@deftypefnx {Built-in Function} {} atexit (@var{fcn}, @var{flag})\n\
+@deftypefn  {} {} atexit (@var{fcn})\n\
+@deftypefnx {} {} atexit (@var{fcn}, @var{flag})\n\
 Register a function to be called when Octave exits.\n\
 \n\
 For example,\n\
 \n\
 @example\n\
 @group\n\
 function last_words ()\n\
   disp (\"Bye bye\");\n\
@@ -1232,18 +1232,18 @@ from the list, so if a function was plac
         retval(0) = found;
     }
 
   return retval;
 }
 
 DEFUN (octave_config_info, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} octave_config_info ()\n\
-@deftypefnx {Built-in Function} {} octave_config_info (@var{option})\n\
+@deftypefn  {} {} octave_config_info ()\n\
+@deftypefnx {} {} octave_config_info (@var{option})\n\
 Return a structure containing configuration and installation information for\n\
 Octave.\n\
 \n\
 If @var{option} is a string, return the configuration information for the\n\
 specified option.\n\
 \n\
 @seealso{computer}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -328,22 +328,22 @@ do_trilu (const std::string& name,
         }
     }
 
   return retval;
 }
 
 DEFUN (tril, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Function File} {} tril (@var{A})\n\
-@deftypefnx {Function File} {} tril (@var{A}, @var{k})\n\
-@deftypefnx {Function File} {} tril (@var{A}, @var{k}, @var{pack})\n\
-@deftypefnx {Function File} {} triu (@var{A})\n\
-@deftypefnx {Function File} {} triu (@var{A}, @var{k})\n\
-@deftypefnx {Function File} {} triu (@var{A}, @var{k}, @var{pack})\n\
+@deftypefn  {} {} tril (@var{A})\n\
+@deftypefnx {} {} tril (@var{A}, @var{k})\n\
+@deftypefnx {} {} tril (@var{A}, @var{k}, @var{pack})\n\
+@deftypefnx {} {} triu (@var{A})\n\
+@deftypefnx {} {} triu (@var{A}, @var{k})\n\
+@deftypefnx {} {} triu (@var{A}, @var{k}, @var{pack})\n\
 Return a new matrix formed by extracting the lower (@code{tril})\n\
 or upper (@code{triu}) triangular part of the matrix @var{A}, and\n\
 setting all other elements to zero.\n\
 \n\
 The second argument is optional, and specifies how many diagonals above or\n\
 below the main diagonal should also be set to zero.\n\
 \n\
 The default value of @var{k} is zero, so that @code{triu} and @code{tril}\n\
@@ -385,19 +385,19 @@ above other.\n\
 @seealso{diag}\n\
 @end deftypefn")
 {
   return do_trilu ("tril", args);
 }
 
 DEFUN (triu, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Function File} {} triu (@var{A})\n\
-@deftypefnx {Function File} {} triu (@var{A}, @var{k})\n\
-@deftypefnx {Function File} {} triu (@var{A}, @var{k}, @var{pack})\n\
+@deftypefn  {} {} triu (@var{A})\n\
+@deftypefnx {} {} triu (@var{A}, @var{k})\n\
+@deftypefnx {} {} triu (@var{A}, @var{k}, @var{pack})\n\
 See the documentation for the @code{tril} function (@pxref{tril}).\n\
 @seealso{tril}\n\
 @end deftypefn")
 {
   return do_trilu ("triu", args);
 }
 
 /*
diff --git a/libinterp/corefcn/tsearch.cc b/libinterp/corefcn/tsearch.cc
--- a/libinterp/corefcn/tsearch.cc
+++ b/libinterp/corefcn/tsearch.cc
@@ -56,17 +56,17 @@ inline double min (double a, double b, d
 // to cut down the time needed to decide which triangle contains the
 // given point
 
 // e.g., build up a neighbouring triangle structure and use a simplex-like
 // method to traverse it
 
 DEFUN (tsearch, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{idx} =} tsearch (@var{x}, @var{y}, @var{t}, @var{xi}, @var{yi})\n\
+@deftypefn {} {@var{idx} =} tsearch (@var{x}, @var{y}, @var{t}, @var{xi}, @var{yi})\n\
 Search for the enclosing Delaunay convex hull.\n\
 \n\
 For @code{@var{t} = delaunay (@var{x}, @var{y})}, finds the index in @var{t}\n\
 containing the points @code{(@var{xi}, @var{yi})}.  For points outside the\n\
 convex hull, @var{idx} is NaN.\n\
 @seealso{delaunay, delaunayn}\n\
 @end deftypefn")
 {
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -84,17 +84,17 @@ reinterpret_copy (const void *data, octa
     error ("typecast: incorrect number of input values to make output value");
 
   return ArrayType ();
 }
 
 
 DEFUN (typecast, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{y} =} typecast (@var{x}, \"@var{class}\")\n\
+@deftypefn {} {@var{y} =} typecast (@var{x}, \"@var{class}\")\n\
 Return a new array @var{y} resulting from interpreting the data of @var{x}\n\
 in memory as data of the numeric class @var{class}.\n\
 \n\
 Both the class of @var{x} and @var{class} must be one of the built-in\n\
 numeric classes:\n\
 \n\
 @example\n\
 @group\n\
@@ -292,17 +292,17 @@ do_bitpack (const boolNDArray& bitp)
   else
     error ("bitpack: incorrect number of bits to make up output value");
 
   return ArrayType ();
 }
 
 DEFUN (bitpack, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
+@deftypefn {} {@var{y} =} bitpack (@var{x}, @var{class})\n\
 Return a new array @var{y} resulting from interpreting the logical array\n\
 @var{x} as raw bit patterns for data of the numeric class @var{class}.\n\
 \n\
 @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
 \"double\"\n\
@@ -408,17 +408,17 @@ do_bitunpack (const ArrayType& array)
       bits += std::numeric_limits<unsigned char>::digits;
     }
 
   return retval;
 }
 
 DEFUN (bitunpack, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{y} =} bitunpack (@var{x})\n\
+@deftypefn {} {@var{y} =} bitunpack (@var{x})\n\
 Return a logical array @var{y} corresponding to the raw bit patterns of\n\
 @var{x}.\n\
 \n\
 @var{x} must belong to one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
 \"double\"\n\
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -276,20 +276,20 @@ ch_manager::do_free (const curl_handle& 
         error ("ch_manager::free: invalid object %g", h.value ());
     }
 }
 
 ch_manager *ch_manager::instance = 0;
 
 DEFUN (urlwrite, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} urlwrite (@var{url}, @var{localfile})\n\
-@deftypefnx {Loadable Function} {@var{f} =} urlwrite (@var{url}, @var{localfile})\n\
-@deftypefnx {Loadable Function} {[@var{f}, @var{success}] =} urlwrite (@var{url}, @var{localfile})\n\
-@deftypefnx {Loadable Function} {[@var{f}, @var{success}, @var{message}] =} urlwrite (@var{url}, @var{localfile})\n\
+@deftypefn  {} {} urlwrite (@var{url}, @var{localfile})\n\
+@deftypefnx {} {@var{f} =} urlwrite (@var{url}, @var{localfile})\n\
+@deftypefnx {} {[@var{f}, @var{success}] =} urlwrite (@var{url}, @var{localfile})\n\
+@deftypefnx {} {[@var{f}, @var{success}, @var{message}] =} urlwrite (@var{url}, @var{localfile})\n\
 Download a remote file specified by its @var{url} and save it as\n\
 @var{localfile}.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 urlwrite (\"ftp://ftp.octave.org/pub/README\",\n\
@@ -407,20 +407,20 @@ urlwrite (\"http://www.google.com/search
   else
     error ("support for URL transfers was disabled when Octave was built");
 
   return retval;
 }
 
 DEFUN (urlread, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{s} =} urlread (@var{url})\n\
-@deftypefnx {Loadable Function} {[@var{s}, @var{success}] =} urlread (@var{url})\n\
-@deftypefnx {Loadable Function} {[@var{s}, @var{success}, @var{message}] =} urlread (@var{url})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} urlread (@var{url}, @var{method}, @var{param})\n\
+@deftypefn  {} {@var{s} =} urlread (@var{url})\n\
+@deftypefnx {} {[@var{s}, @var{success}] =} urlread (@var{url})\n\
+@deftypefnx {} {[@var{s}, @var{success}, @var{message}] =} urlread (@var{url})\n\
+@deftypefnx {} {[@dots{}] =} urlread (@var{url}, @var{method}, @var{param})\n\
 Download a remote file specified by its @var{url} and return its content\n\
 in string @var{s}.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 s = urlread (\"ftp://ftp.octave.org/pub/README\");\n\
 @end example\n\
@@ -503,18 +503,18 @@ s = urlread (\"http://www.google.com/sea
   else
     error ("support for URL transfers was disabled when Octave was built");
 
   return retval;
 }
 
 DEFUN (__ftp__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{handle} =} __ftp__ (@var{host})\n\
-@deftypefnx {Loadable Function} {@var{handle} =} __ftp__ (@var{host}, @var{username}, @var{password})\n\
+@deftypefn  {} {@var{handle} =} __ftp__ (@var{host})\n\
+@deftypefnx {} {@var{handle} =} __ftp__ (@var{host}, @var{username}, @var{password})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
@@ -531,17 +531,17 @@ Undocumented internal function\n\
   curl_handle ch
     = ch_manager::make_curl_handle (host, user, passwd, octave_stdout);
 
   return octave_value (ch.value ());
 }
 
 DEFUN (__ftp_pwd__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp_pwd__ (@var{handle})\n\
+@deftypefn {} {} __ftp_pwd__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     error ("__ftp_pwd__: incorrect number of arguments");
   else
@@ -554,17 +554,17 @@ Undocumented internal function\n\
         error ("__ftp_pwd__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_cwd__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp_cwd__ (@var{handle}, @var{path})\n\
+@deftypefn {} {} __ftp_cwd__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2)
@@ -586,17 +586,17 @@ Undocumented internal function\n\
         error ("__ftp_cwd__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_dir__, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp_dir__ (@var{handle})\n\
+@deftypefn {} {} __ftp_dir__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     error ("__ftp_dir__: incorrect number of arguments");
   else
@@ -662,17 +662,17 @@ Undocumented internal function\n\
         error ("__ftp_dir__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_ascii__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp_ascii__ (@var{handle})\n\
+@deftypefn {} {} __ftp_ascii__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     error ("__ftp_ascii__: incorrect number of arguments");
   else
@@ -685,17 +685,17 @@ Undocumented internal function\n\
         error ("__ftp_ascii__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_binary__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp_binary__ (@var{handle})\n\
+@deftypefn {} {} __ftp_binary__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     error ("__ftp_binary__: incorrect number of arguments");
   else
@@ -708,17 +708,17 @@ Undocumented internal function\n\
         error ("__ftp_binary__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_close__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp_close__ (@var{handle})\n\
+@deftypefn {} {} __ftp_close__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     error ("__ftp_close__: incorrect number of arguments");
   else
@@ -731,17 +731,17 @@ Undocumented internal function\n\
         error ("__ftp_close__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_mode__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp_mode__ (@var{handle})\n\
+@deftypefn {} {} __ftp_mode__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     error ("__ftp_mode__: incorrect number of arguments");
   else
@@ -754,17 +754,17 @@ Undocumented internal function\n\
         error ("__ftp_binary__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_delete__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp_delete__ (@var{handle}, @var{path})\n\
+@deftypefn {} {} __ftp_delete__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 2)
     error ("__ftp_delete__: incorrect number of arguments");
   else
@@ -781,17 +781,17 @@ Undocumented internal function\n\
         error ("__ftp_delete__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_rmdir__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp_rmdir__ (@var{handle}, @var{path})\n\
+@deftypefn {} {} __ftp_rmdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 2)
     error ("__ftp_rmdir__: incorrect number of arguments");
   else
@@ -808,17 +808,17 @@ Undocumented internal function\n\
         error ("__ftp_rmdir__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_mkdir__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp_mkdir__ (@var{handle}, @var{path})\n\
+@deftypefn {} {} __ftp_mkdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 2)
     error ("__ftp_mkdir__: incorrect number of arguments");
   else
@@ -835,17 +835,17 @@ Undocumented internal function\n\
         error ("__ftp_mkdir__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_rename__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp_rename__ (@var{handle}, @var{path})\n\
+@deftypefn {} {} __ftp_rename__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 3)
     error ("__ftp_rename__: incorrect number of arguments");
   else
@@ -863,17 +863,17 @@ Undocumented internal function\n\
         error ("__ftp_rename__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_mput__, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __ftp_mput__ (@var{handle}, @var{files})\n\
+@deftypefn {} {} __ftp_mput__ (@var{handle}, @var{files})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 2)
     error ("__ftp_mput__: incorrect number of arguments");
   else
@@ -932,18 +932,18 @@ Undocumented internal function\n\
         error ("__ftp_mput__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_mget__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} __ftp_mget__ (@var{handle}, @var{pattern})\n\
-@deftypefnx {Loadable Function} {} __ftp_mget__ (@var{handle}, @var{pattern}, @var{target})\n\
+@deftypefn  {} {} __ftp_mget__ (@var{handle}, @var{pattern})\n\
+@deftypefnx {} {} __ftp_mget__ (@var{handle}, @var{pattern}, @var{target})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 2 && nargin != 3)
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -89,17 +89,17 @@ valid_identifier (const char *s)
 bool
 valid_identifier (const std::string& s)
 {
   return valid_identifier (s.c_str ());
 }
 
 DEFUN (isvarname, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isvarname (@var{name})\n\
+@deftypefn {} {} isvarname (@var{name})\n\
 Return true if @var{name} is a valid variable name.\n\
 @seealso{iskeyword, exist, who}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () != 1)
     print_usage ();
@@ -285,18 +285,18 @@ make_absolute (const string_vector& sv)
   for (octave_idx_type i = 0; i < len; i++)
     retval[i] = octave_env::make_absolute (sv[i]);
 
   return retval;
 }
 
 DEFUN (file_in_loadpath, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} file_in_loadpath (@var{file})\n\
-@deftypefnx {Built-in Function} {} file_in_loadpath (@var{file}, \"all\")\n\
+@deftypefn  {} {} file_in_loadpath (@var{file})\n\
+@deftypefnx {} {} file_in_loadpath (@var{file}, \"all\")\n\
 \n\
 Return the absolute name of @var{file} if it can be found in\n\
 the list of directories specified by @code{path}.\n\
 \n\
 If no file is found, return an empty character string.\n\
 \n\
 If the first argument is a cell array of strings, search each directory of\n\
 the loadpath for element of the cell array and return the first that\n\
@@ -356,18 +356,18 @@ If no files are found, return an empty c
 %!error file_in_loadpath ()
 %!error file_in_loadpath ("foo", "bar", 1)
 %!error file_in_loadpath ([])
 %!error file_in_loadpath ("plot.m", "bar")
 */
 
 DEFUN (file_in_path, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} file_in_path (@var{path}, @var{file})\n\
-@deftypefnx {Built-in Function} {} file_in_path (@var{path}, @var{file}, \"all\")\n\
+@deftypefn  {} {} file_in_path (@var{path}, @var{file})\n\
+@deftypefnx {} {} file_in_path (@var{path}, @var{file}, \"all\")\n\
 Return the absolute name of @var{file} if it can be found in @var{path}.\n\
 \n\
 The value of @var{path} should be a colon-separated list of directories in\n\
 the format described for @code{path}.  If no file is found, return an empty\n\
 character string.  For example:\n\
 \n\
 @example\n\
 @group\n\
@@ -732,17 +732,17 @@ do_string_escapes (const std::string& s)
 
   retval.resize (i);
 
   return retval;
 }
 
 DEFUN (do_string_escapes, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} do_string_escapes (@var{string})\n\
+@deftypefn {} {} do_string_escapes (@var{string})\n\
 Convert escape sequences in @var{string} to the characters they represent.\n\
 \n\
 Escape sequences begin with a leading backslash\n\
 (@qcode{'@xbackslashchar{}'}) followed by 1--3 characters\n\
 (.e.g., @qcode{\"@xbackslashchar{}n\"} => newline).\n\
 @seealso{undo_string_escapes}\n\
 @end deftypefn")
 {
@@ -847,17 +847,17 @@ undo_string_escapes (const std::string& 
   for (size_t i = 0; i < s.length (); i++)
     retval.append (undo_string_escape (s[i]));
 
   return retval;
 }
 
 DEFUN (undo_string_escapes, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} undo_string_escapes (@var{s})\n\
+@deftypefn {} {} undo_string_escapes (@var{s})\n\
 Convert special characters in strings back to their escaped forms.\n\
 \n\
 For example, the expression\n\
 \n\
 @example\n\
 bell = \"\\a\";\n\
 @end example\n\
 \n\
@@ -908,17 +908,17 @@ replaces the unprintable alert character
 
 %!error undo_string_escapes ()
 %!error undo_string_escapes ("foo", "bar")
 %!error undo_string_escapes (3)
 */
 
 DEFUN (is_absolute_filename, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} is_absolute_filename (@var{file})\n\
+@deftypefn {} {} is_absolute_filename (@var{file})\n\
 Return true if @var{file} is an absolute filename.\n\
 @seealso{is_rooted_relative_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () != 1)
     print_usage ();
@@ -933,17 +933,17 @@ Return true if @var{file} is an absolute
 ## FIXME: We need system-dependent tests here.
 
 %!error is_absolute_filename ()
 %!error is_absolute_filename ("foo", "bar")
 */
 
 DEFUN (is_rooted_relative_filename, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} is_rooted_relative_filename (@var{file})\n\
+@deftypefn {} {} is_rooted_relative_filename (@var{file})\n\
 Return true if @var{file} is a rooted-relative filename.\n\
 @seealso{is_absolute_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () != 1)
     print_usage ();
@@ -958,17 +958,17 @@ Return true if @var{file} is a rooted-re
 ## FIXME: We need system-dependent tests here.
 
 %!error is_rooted_relative_filename ()
 %!error is_rooted_relative_filename ("foo", "bar")
 */
 
 DEFUN (make_absolute_filename, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} make_absolute_filename (@var{file})\n\
+@deftypefn {} {} make_absolute_filename (@var{file})\n\
 Return the full name of @var{file} beginning from the root of the file\n\
 system.\n\
 \n\
 No check is done for the existence of @var{file}.\n\
 @seealso{canonicalize_file_name, is_absolute_filename, is_rooted_relative_filename, isdir}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
@@ -983,18 +983,18 @@ No check is done for the existence of @v
 ## FIXME: We need system-dependent tests here.
 
 %!error make_absolute_filename ()
 %!error make_absolute_filename ("foo", "bar")
 */
 
 DEFUN (dir_in_loadpath, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} dir_in_loadpath (@var{dir})\n\
-@deftypefnx {Built-in Function} {} dir_in_loadpath (@var{dir}, \"all\")\n\
+@deftypefn  {} {} dir_in_loadpath (@var{dir})\n\
+@deftypefnx {} {} dir_in_loadpath (@var{dir}, \"all\")\n\
 Return the full name of the path element matching @var{dir}.\n\
 \n\
 The match is performed at the end of each path element.  For example, if\n\
 @var{dir} is @qcode{\"foo/bar\"}, it matches the path element\n\
 @nospell{@qcode{\"/some/dir/foo/bar\"}}, but not\n\
 @nospell{@qcode{\"/some/dir/foo/bar/baz\"}}\n\
 @nospell{@qcode{\"/some/dir/allfoo/bar\"}}.\n\
 \n\
@@ -1037,19 +1037,19 @@ all name matches rather than just the fi
 %! assert (lst, {});
 
 %!error dir_in_loadpath ()
 %!error dir_in_loadpath ("foo", "bar", 1)
 */
 
 DEFUNX ("errno", Ferrno, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{err} =} errno ()\n\
-@deftypefnx {Built-in Function} {@var{err} =} errno (@var{val})\n\
-@deftypefnx {Built-in Function} {@var{err} =} errno (@var{name})\n\
+@deftypefn  {} {@var{err} =} errno ()\n\
+@deftypefnx {} {@var{err} =} errno (@var{val})\n\
+@deftypefnx {} {@var{err} =} errno (@var{name})\n\
 Return the current value of the system-dependent variable errno,\n\
 set its value to @var{val} and return the previous value, or return\n\
 the named error code given @var{name} as a character string, or -1\n\
 if @var{name} is not found.\n\
 @seealso{errno_list}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1092,17 +1092,17 @@ if @var{name} is not found.\n\
 %! newval = errno ();
 %! assert (oldval, newval);
 
 %!error errno ("foo", 1)
 */
 
 DEFUN (errno_list, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} errno_list ()\n\
+@deftypefn {} {} errno_list ()\n\
 Return a structure containing the system-dependent errno values.\n\
 @seealso{errno}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
   return octave_value (octave_errno::list ());
@@ -1373,18 +1373,18 @@ octave_sleep (double seconds)
       octave_usleep (usec);
 
       octave_quit ();
     }
 }
 
 DEFUN (isindex, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} isindex (@var{ind})\n\
-@deftypefnx {Built-in Function} {} isindex (@var{ind}, @var{n})\n\
+@deftypefn  {} {} isindex (@var{ind})\n\
+@deftypefnx {} {} isindex (@var{ind}, @var{n})\n\
 Return true if @var{ind} is a valid index.\n\
 \n\
 Valid indices are either positive integers (although possibly of real data\n\
 type), or logical arrays.\n\
 \n\
 If present, @var{n} specifies the maximum extent of the dimension to be\n\
 indexed.  When possible the internal result is cached so that subsequent\n\
 indexing using @var{ind} will not perform the check again.\n\
@@ -1524,17 +1524,17 @@ octave_preserve_stream_state::~octave_pr
   stream.flags (oflags);
   stream.precision (oprecision);
   stream.width (owidth);
   stream.fill (ofill);
 }
 
 DEFUN (isstudent, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isstudent ()\n\
+@deftypefn {} {} isstudent ()\n\
 Return true if running in the student edition of @sc{matlab}.\n\
 \n\
 @code{isstudent} always returns false in Octave.\n\
 @seealso{false}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -333,17 +333,17 @@ do_isglobal (const octave_value_list& ar
 
   std::string name = args(0).string_value ();
 
   return symbol_table::is_global (name);
 }
 
 DEFUN (isglobal, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isglobal (@var{name})\n\
+@deftypefn {} {} isglobal (@var{name})\n\
 Return true if @var{name} is a globally visible variable.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 global x\n\
 isglobal (\"x\")\n\
@@ -506,18 +506,18 @@ unique_symbol_name (const std::string& b
   while (symbol_exist (nm, "any"))
     nm.insert (pos++, 1, alpha[GET_IDX (len)]);
 
   return nm;
 }
 
 DEFUN (exist, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{c} =} exist (@var{name})\n\
-@deftypefnx {Built-in Function} {@var{c} =} exist (@var{name}, @var{type})\n\
+@deftypefn  {} {@var{c} =} exist (@var{name})\n\
+@deftypefnx {} {@var{c} =} exist (@var{name}, @var{type})\n\
 Check for the existence of @var{name} as a variable, function, file,\n\
 directory, or class.\n\
 \n\
 The return code @var{c} is one of\n\
 \n\
 @table @asis\n\
 @item 1\n\
 @var{name} is a variable.\n\
@@ -1782,20 +1782,20 @@ do_who (int argc, const string_vector& a
       octave_stdout << "\n";
     }
 
   return retval;
 }
 
 DEFUN (who, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} who\n\
-@deftypefnx {Command} {} who pattern @dots{}\n\
-@deftypefnx {Command} {} who option pattern @dots{}\n\
-@deftypefnx {Command} {C =} who (\"pattern\", @dots{})\n\
+@deftypefn  {} {} who\n\
+@deftypefnx {} {} who pattern @dots{}\n\
+@deftypefnx {} {} who option pattern @dots{}\n\
+@deftypefnx {} {C =} who (\"pattern\", @dots{})\n\
 List currently defined variables matching the given patterns.\n\
 \n\
 Valid pattern syntax is the same as described for the @code{clear} command.\n\
 If no patterns are supplied, all variables are listed.\n\
 \n\
 By default, only variables visible in the local scope are displayed.\n\
 \n\
 The following are valid options, but may not be combined.\n\
@@ -1829,20 +1829,20 @@ matching the given patterns.\n\
 
   string_vector argv = args.make_argv ("who");
 
   return do_who (argc, argv, nargout == 1);
 }
 
 DEFUN (whos, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Command} {} whos\n\
-@deftypefnx {Command} {} whos pattern @dots{}\n\
-@deftypefnx {Command} {} whos option pattern @dots{}\n\
-@deftypefnx {Built-in Function} {S =} whos (\"pattern\", @dots{})\n\
+@deftypefn  {} {} whos\n\
+@deftypefnx {} {} whos pattern @dots{}\n\
+@deftypefnx {} {} whos option pattern @dots{}\n\
+@deftypefnx {} {S =} whos (\"pattern\", @dots{})\n\
 Provide detailed information on currently defined variables matching the\n\
 given patterns.\n\
 \n\
 Options and pattern syntax are the same as for the @code{who} command.\n\
 \n\
 Extended information about each variable is summarized in a table with the\n\
 following default entries.\n\
 \n\
@@ -1984,17 +1984,17 @@ mislocked (const std::string& nm)
         retval = fcn->islocked ();
     }
 
   return retval;
 }
 
 DEFUN (mlock, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} mlock ()\n\
+@deftypefn {} {} mlock ()\n\
 Lock the current function into memory so that it can't be cleared.\n\
 @seealso{munlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () != 0)
     print_usage ();
@@ -2006,18 +2006,18 @@ Lock the current function into memory so
   else
     error ("mlock: invalid use outside a function");
 
   return retval;
 }
 
 DEFUN (munlock, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} munlock ()\n\
-@deftypefnx {Built-in Function} {} munlock (@var{fcn})\n\
+@deftypefn  {} {} munlock ()\n\
+@deftypefnx {} {} munlock (@var{fcn})\n\
 Unlock the named function @var{fcn}.\n\
 \n\
 If no function is named then unlock the current function.\n\
 @seealso{mlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -2043,18 +2043,18 @@ If no function is named then unlock the 
     }
 
   return retval;
 }
 
 
 DEFUN (mislocked, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} mislocked ()\n\
-@deftypefnx {Built-in Function} {} mislocked (@var{fcn})\n\
+@deftypefn  {} {} mislocked ()\n\
+@deftypefnx {} {} mislocked (@var{fcn})\n\
 Return true if the named function @var{fcn} is locked.\n\
 \n\
 If no function is named then return true if the current function is locked.\n\
 @seealso{mlock, munlock, persistent}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -2299,17 +2299,17 @@ do_matlab_compatible_clear (const string
     { \
       if (cond) \
         print_usage (); \
     } \
   while (0)
 
 DEFUN (clear, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Command} {} clear [options] pattern @dots{}\n\
+@deftypefn {} {} clear [options] pattern @dots{}\n\
 Delete the names matching the given patterns from the symbol table.\n\
 \n\
 The pattern may contain the following special characters:\n\
 \n\
 @table @code\n\
 @item ?\n\
 Match any single character.\n\
 \n\
@@ -2505,19 +2505,19 @@ without the dash as well.\n\
         }
     }
 
   return retval;
 }
 
 DEFUN (whos_line_format, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} whos_line_format ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} whos_line_format (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} whos_line_format (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} whos_line_format ()\n\
+@deftypefnx {} {@var{old_val} =} whos_line_format (@var{new_val})\n\
+@deftypefnx {} {} whos_line_format (@var{new_val}, \"local\")\n\
 Query or set the format string used by the command @code{whos}.\n\
 \n\
 A full format string is:\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 %[modifier]<command>[:width[:left-min[:balance]]];\n\
 @end smallexample\n\
@@ -2584,19 +2584,19 @@ The original variable value is restored 
 {
   return SET_INTERNAL_VARIABLE (whos_line_format);
 }
 
 static std::string Vmissing_function_hook = "__unimplemented__";
 
 DEFUN (missing_function_hook, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} missing_function_hook ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} missing_function_hook (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} missing_function_hook (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} missing_function_hook ()\n\
+@deftypefnx {} {@var{old_val} =} missing_function_hook (@var{new_val})\n\
+@deftypefnx {} {} missing_function_hook (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the function to call when\n\
 an unknown identifier is requested.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{missing_component_hook}\n\
 @end deftypefn")
@@ -2624,35 +2624,35 @@ void maybe_missing_function_hook (const 
           // Call.
           feval (func_name, octave_value (name));
         }
     }
 }
 
 DEFUN (__varval__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __varval__ (@var{name})\n\
+@deftypefn {} {} __varval__ (@var{name})\n\
 Return the value of the variable @var{name} directly from the symbol table.\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).xstring_value ("__varval__: first argument must be a variable name");
 
   return symbol_table::varval (args(0).string_value ());
 }
 
 static std::string Vmissing_component_hook;
 
 DEFUN (missing_component_hook, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} missing_component_hook ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} missing_component_hook (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} missing_component_hook (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} missing_component_hook ()\n\
+@deftypefnx {} {@var{old_val} =} missing_component_hook (@var{new_val})\n\
+@deftypefnx {} {} missing_component_hook (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the function to call when\n\
 a component of Octave is missing.\n\
 \n\
 This can be useful for packagers that may split the Octave installation into\n\
 multiple sub-packages, for example, to provide a hint to users for how to\n\
 install the missing components.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -80,18 +80,18 @@ octave_qhull_dims_ok (octave_idx_type di
         }
     }
 
   return true;
 }
 
 DEFUN_DLD (__delaunayn__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{T} =} __delaunayn__ (@var{pts})\n\
-@deftypefnx {Loadable Function} {@var{T} =} __delaunayn__ (@var{pts}, @var{options})\n\
+@deftypefn  {} {@var{T} =} __delaunayn__ (@var{pts})\n\
+@deftypefnx {} {@var{T} =} __delaunayn__ (@var{pts}, @var{options})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 
 {
   octave_value_list retval;
 
 #if defined (HAVE_QHULL)
 
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -118,36 +118,36 @@ eigs_complex_func (const ComplexColumnVe
         }
     }
 
   return retval;
 }
 
 DEFUN_DLD (__eigs__, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{d} =} __eigs__ (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{k})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{k}, @var{sigma})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{k}, @var{sigma}, @var{opts})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k}, @var{sigma})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k}, @var{sigma}, @var{opts})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{k})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B}, @var{k})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{k}, @var{sigma})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{k}, @var{sigma}, @var{opts})\n\
-@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma}, @var{opts})\n\
-@deftypefnx {Loadable Function} {[@var{V}, @var{d}] =} __eigs__ (@var{A}, @dots{})\n\
-@deftypefnx {Loadable Function} {[@var{V}, @var{d}] =} __eigs__ (@var{af}, @var{n}, @dots{})\n\
-@deftypefnx {Loadable Function} {[@var{V}, @var{d}, @var{flag}] =} __eigs__ (@var{A}, @dots{})\n\
-@deftypefnx {Loadable Function} {[@var{V}, @var{d}, @var{flag}] =} __eigs__ (@var{af}, @var{n}, @dots{})\n\
+@deftypefn  {} {@var{d} =} __eigs__ (@var{A})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{A}, @var{k})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{A}, @var{k}, @var{sigma})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{A}, @var{k}, @var{sigma}, @var{opts})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{A}, @var{B})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k}, @var{sigma})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k}, @var{sigma}, @var{opts})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{af}, @var{n})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{k})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B}, @var{k})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{k}, @var{sigma})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{k}, @var{sigma}, @var{opts})\n\
+@deftypefnx {} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma}, @var{opts})\n\
+@deftypefnx {} {[@var{V}, @var{d}] =} __eigs__ (@var{A}, @dots{})\n\
+@deftypefnx {} {[@var{V}, @var{d}] =} __eigs__ (@var{af}, @var{n}, @dots{})\n\
+@deftypefnx {} {[@var{V}, @var{d}, @var{flag}] =} __eigs__ (@var{A}, @dots{})\n\
+@deftypefnx {} {[@var{V}, @var{d}, @var{flag}] =} __eigs__ (@var{af}, @var{n}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 #ifdef HAVE_ARPACK
   int nargin = args.length ();
   std::string fcn_name;
   octave_idx_type n = 0;
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -326,17 +326,17 @@ glpk (int sense, int n, int m, double *c
           else \
             error ("glpk: invalid value in PARAM" NAME); \
         } \
     } \
   while (0)
 
 DEFUN_DLD (__glpk__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{values}] =} __glpk__ (@var{args})\n\
+@deftypefn {} {[@var{values}] =} __glpk__ (@var{args})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #if defined (HAVE_GLPK)
 
   // FIXME: Should we even need checking for an internal function?
diff --git a/libinterp/dldfcn/__init_gnuplot__.cc b/libinterp/dldfcn/__init_gnuplot__.cc
--- a/libinterp/dldfcn/__init_gnuplot__.cc
+++ b/libinterp/dldfcn/__init_gnuplot__.cc
@@ -211,17 +211,17 @@ DEFUN_DLD (__init_gnuplot__, , , "")
       toolkit_loaded = true;
     }
 
   return retval;
 }
 
 DEFUN_DLD (__have_gnuplot__, , ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{gnuplot_available} =} __have_gnuplot__ ()\n\
+@deftypefn {} {@var{gnuplot_available} =} __have_gnuplot__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   retval = have_gnuplot_binary ();
 
   return retval;
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -738,17 +738,17 @@ maybe_initialize_magick (void)
 
       initialized = true;
     }
 }
 #endif
 
 DEFUN_DLD (__magick_read__, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{img}, @var{map}, @var{alpha}] =} __magick_read__ (@var{fname}, @var{options})\n\
+@deftypefn {} {[@var{img}, @var{map}, @var{alpha}] =} __magick_read__ (@var{fname}, @var{options})\n\
 Read image with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.\n\
 Use @code{imread} instead.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
@@ -1375,17 +1375,17 @@ write_file (const std::string& filename,
       error ("Magick++ exception: %s", e.what ());
     }
 }
 
 #endif
 
 DEFUN_DLD (__magick_write__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img}, @var{map}, @var{options})\n\
+@deftypefn {} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img}, @var{map}, @var{options})\n\
 Write image with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.\n\
 Use @code{imwrite} instead.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
@@ -1551,17 +1551,17 @@ Use @code{imwrite} instead.\n\
 */
 
 // Gets the minimum information from images such as its size and format. Much
 // faster than using imfinfo, which slows down a lot since. Note than without
 // this, we need to read the image once for imfinfo to set defaults (which is
 // done in Octave language), and then again for the actual reading.
 DEFUN_DLD (__magick_ping__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __magick_ping__ (@var{fname}, @var{idx})\n\
+@deftypefn {} {} __magick_ping__ (@var{fname}, @var{idx})\n\
 Ping image information with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.\n\
 \n\
 @seealso{imfinfo}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1770,17 +1770,17 @@ fill_exif_floats (octave_scalar_map& map
     }
   return;
 }
 
 #endif
 
 DEFUN_DLD (__magick_finfo__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __magick_finfo__ (@var{fname})\n\
+@deftypefn {} {} __magick_finfo__ (@var{fname})\n\
 Read image information with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.\n\
 Use @code{imfinfo} instead.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
@@ -2220,17 +2220,17 @@ Use @code{imfinfo} instead.\n\
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
 DEFUN_DLD (__magick_formats__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __magick_imformats__ (@var{formats})\n\
+@deftypefn {} {} __magick_imformats__ (@var{formats})\n\
 Fill formats info with GraphicsMagick CoderInfo.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifndef HAVE_MAGICK
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -53,18 +53,18 @@ static void
 reset_visibility (figure::properties *fp)
 {
   fp->set_visible ("on");
 }
 #endif
 
 DEFUN_DLD(__osmesa_print__, args, ,
           "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} __osmesa_print__ (@var{h}, @var{file}, @var{term})\n\
-@deftypefnx {Loadable Function} {@var{img} =} __osmesa_print__ (@var{h})\n\
+@deftypefn  {} {} __osmesa_print__ (@var{h}, @var{file}, @var{term})\n\
+@deftypefnx {} {@var{img} =} __osmesa_print__ (@var{h})\n\
 Print figure @var{h} using OSMesa and gl2ps for vector formats.\n\
 \n\
 This is a private internal function.\n\
 \n\
 The first method calls gl2ps with the appropriate @var{term} and writes\n\
 the output of gl2ps to @var{file}.  If the first character of @var{file}\n\
 is @qcode{|}, then a process is started and the output of gl2ps is piped\n\
 to it.\n\
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -71,19 +71,19 @@ octave_qhull_dims_ok (octave_idx_type di
         error ("%s: dimension too large for Qhull", who);
     }
 
   return true;
 }
 
 DEFUN_DLD (__voronoi__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts})\n\
-@deftypefnx {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts}, @var{options})\n\
-@deftypefnx {Loadable Function} {@var{C}, @var{F}, @var{Inf_Pts} =} __voronoi__ (@dots{})\n\
+@deftypefn  {} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts})\n\
+@deftypefnx {} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts}, @var{options})\n\
+@deftypefnx {} {@var{C}, @var{F}, @var{Inf_Pts} =} __voronoi__ (@dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   std::string caller = args(0).xstring_value ("__voronoi__: CALLER must be a string");
 
 #if defined (HAVE_QHULL)
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -47,18 +47,18 @@ along with Octave; see the file COPYING.
 #ifdef USE_64_BIT_IDX_T
 #define AMD_NAME(name) amd_l ## name
 #else
 #define AMD_NAME(name) amd ## name
 #endif
 
 DEFUN_DLD (amd, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} amd (@var{S})\n\
-@deftypefnx {Loadable Function} {@var{p} =} amd (@var{S}, @var{opts})\n\
+@deftypefn  {} {@var{p} =} amd (@var{S})\n\
+@deftypefnx {} {@var{p} =} amd (@var{S}, @var{opts})\n\
 \n\
 Return the approximate minimum degree permutation of a matrix.\n\
 \n\
 This is a permutation such that the Cholesky@tie{}factorization of\n\
 @code{@var{S} (@var{p}, @var{p})} tends to be sparser than the\n\
 Cholesky@tie{}factorization of @var{S} itself.  @code{amd} is typically\n\
 faster than @code{symamd} but serves a similar purpose.\n\
 \n\
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -63,24 +63,24 @@ bits_to_format (int bits)
   else
     return 0;
 }
 
 #endif
 
 DEFUN_DLD (audiodevinfo, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{devinfo} =} audiodevinfo ()\n\
+@deftypefn {} {@var{devinfo} =} audiodevinfo ()\n\
 \n\
-@deftypefnx {Loadable Function} {@var{devs} =} audiodevinfo (@var{io})\n\
-@deftypefnx {Loadable Function} {@var{name} =} audiodevinfo (@var{io}, @var{id})\n\
-@deftypefnx {Loadable Function} {@var{id} =} audiodevinfo (@var{io}, @var{name})\n\
-@deftypefnx {Loadable Function} {@var{id} =} audiodevinfo (@var{io}, @var{rate}, @var{bits}, @var{chans})\n\
+@deftypefnx {} {@var{devs} =} audiodevinfo (@var{io})\n\
+@deftypefnx {} {@var{name} =} audiodevinfo (@var{io}, @var{id})\n\
+@deftypefnx {} {@var{id} =} audiodevinfo (@var{io}, @var{name})\n\
+@deftypefnx {} {@var{id} =} audiodevinfo (@var{io}, @var{rate}, @var{bits}, @var{chans})\n\
 \n\
-@deftypefnx {Loadable Function} {@var{supports} =} audiodevinfo (@var{io}, @var{id}, @var{rate}, @var{bits}, @var{chans})\n\
+@deftypefnx {} {@var{supports} =} audiodevinfo (@var{io}, @var{id}, @var{rate}, @var{bits}, @var{chans})\n\
 \n\
 Return a structure describing the available audio input and output devices.\n\
 \n\
 The @var{devinfo} structure has two fields @qcode{\"input\"} and\n\
 @qcode{\"output\"}.  The value of each field is a structure array with fields\n\
 @qcode{\"Name\"}, @nospell{\"DriverVersion\"} and @qcode{\"ID\"} describing\n\
 an audio device.\n\
 \n\
@@ -1797,19 +1797,19 @@ audiorecorder::get_stream (void)
 {
   return stream;
 }
 
 #endif
 
 DEFUN_DLD (__recorder_audiorecorder__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{recorder} =} __recorder_audiorecorder__ (@var{fs}, @var{nbits}, @var{channels})\n\
-@deftypefnx {Loadable Function} {@var{recorder} =} __recorder_audiorecorder__ (@var{fs}, @var{nbits}, @var{channels}, @var{id})\n\
-@deftypefnx {Loadable Function} {@var{recorder} =} __recorder_audiorecorder__ (@var{fcn}, @dots{})\n\
+@deftypefn  {} {@var{recorder} =} __recorder_audiorecorder__ (@var{fs}, @var{nbits}, @var{channels})\n\
+@deftypefnx {} {@var{recorder} =} __recorder_audiorecorder__ (@var{fs}, @var{nbits}, @var{channels}, @var{id})\n\
+@deftypefnx {} {@var{recorder} =} __recorder_audiorecorder__ (@var{fcn}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   int nargin = args.length ();
@@ -1867,17 +1867,17 @@ get_recorder (const octave_value& ov)
 
   return dynamic_cast<audiorecorder *> (ncrep);
 }
 
 #endif
 
 DEFUN_DLD (__recorder_getaudiodata__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{data}} __recorder_getaudiodata__ (@var{recorder})\n\
+@deftypefn {} {@var{data}} __recorder_getaudiodata__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   audiorecorder *recorder = get_recorder (args(0));
@@ -1893,17 +1893,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_channels__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{n} =} __recorder_get_channels__ (@var{recorder})\n\
+@deftypefn {} {@var{n} =} __recorder_get_channels__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -1922,17 +1922,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_fs__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{fs} =} __recorder_get_fs__ (@var{recorder})\n\
+@deftypefn {} {@var{fs} =} __recorder_get_fs__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -1951,17 +1951,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_id__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{id} =} __recorder_get_id__ (@var{recorder})\n\
+@deftypefn {} {@var{id} =} __recorder_get_id__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -1980,17 +1980,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_nbits__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{nbits} =} __recorder_get_nbits__ (@var{recorder})\n\
+@deftypefn {} {@var{nbits} =} __recorder_get_nbits__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2009,17 +2009,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_sample_number__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{n} =} __recorder_get_sample_number__ (@var{recorder})\n\
+@deftypefn {} {@var{n} =} __recorder_get_sample_number__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2038,17 +2038,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_tag__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{tag} =} __recorder_get_tag__ (@var{recorder})\n\
+@deftypefn {} {@var{tag} =} __recorder_get_tag__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2067,17 +2067,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_total_samples__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{n} =} __recorder_get_total_samples__ (@var{recorder})\n\
+@deftypefn {} {@var{n} =} __recorder_get_total_samples__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2096,17 +2096,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_userdata__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{data} =} __recorder_get_userdata__ (@var{recorder})\n\
+@deftypefn {} {@var{data} =} __recorder_get_userdata__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2125,17 +2125,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_isrecording__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __recorder_isrecording__ (@var{recorder})\n\
+@deftypefn {} {} __recorder_isrecording__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2154,17 +2154,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_pause__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __recorder_pause__ (@var{recorder})\n\
+@deftypefn {} {} __recorder_pause__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2183,17 +2183,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_recordblocking__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __recorder_recordblocking__ (@var{recorder}, @var{seconds})\n\
+@deftypefn {} {} __recorder_recordblocking__ (@var{recorder}, @var{seconds})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   audiorecorder *recorder = get_recorder (args(0));
@@ -2209,18 +2209,18 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_record__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} __recorder_record__ (@var{recorder})\n\
-@deftypefnx {Loadable Function} {} __recorder_record__ (@var{recorder}, @var{seconds})\n\
+@deftypefn  {} {} __recorder_record__ (@var{recorder})\n\
+@deftypefnx {} {} __recorder_record__ (@var{recorder}, @var{seconds})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   audiorecorder *recorder = get_recorder (args(0));
@@ -2244,17 +2244,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_resume__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __recorder_resume__ (@var{recorder})\n\
+@deftypefn {} {} __recorder_resume__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2273,17 +2273,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_set_fs__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __recorder_set_fs__ (@var{recorder}, @var{fs})\n\
+@deftypefn {} {} __recorder_set_fs__ (@var{recorder}, @var{fs})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 2)
@@ -2302,17 +2302,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_set_tag__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __recorder_set_tag__ (@var{recorder}, @var{tag})\n\
+@deftypefn {} {} __recorder_set_tag__ (@var{recorder}, @var{tag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 2)
@@ -2331,17 +2331,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_set_userdata__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __recorder_set_userdata__ (@var{recorder}, @var{data})\n\
+@deftypefn {} {} __recorder_set_userdata__ (@var{recorder}, @var{data})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 2)
@@ -2360,17 +2360,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__recorder_stop__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __recorder_stop__ (@var{recorder})\n\
+@deftypefn {} {} __recorder_stop__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   audiorecorder *recorder = get_recorder (args(0));
@@ -2386,19 +2386,19 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_audioplayer__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs})\n\
-@deftypefnx {Loadable Function} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs}, @var{nbits})\n\
-@deftypefnx {Loadable Function} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs}, @var{nbits}, @var{id})\n\
+@deftypefn  {} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs})\n\
+@deftypefnx {} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs}, @var{nbits})\n\
+@deftypefnx {} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs}, @var{nbits}, @var{id})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   int nargin = args.length ();
@@ -2460,17 +2460,17 @@ get_player (const octave_value& ov)
 
   return dynamic_cast<audioplayer *> (ncrep);
 }
 
 #endif
 
 DEFUN_DLD (__player_get_channels__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{n} =} __player_get_channels__ (@var{player})\n\
+@deftypefn {} {@var{n} =} __player_get_channels__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2489,17 +2489,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_get_fs__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{fs} =} __player_get_fs__ (@var{player})\n\
+@deftypefn {} {@var{fs} =} __player_get_fs__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2518,17 +2518,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_get_id__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{id} =} __player_get_id__ (@var{player})\n\
+@deftypefn {} {@var{id} =} __player_get_id__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2547,17 +2547,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_get_nbits__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{nbits} =} __player_get_nbits__ (@var{player})\n\
+@deftypefn {} {@var{nbits} =} __player_get_nbits__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2576,17 +2576,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_get_sample_number__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{n} =} __player_get_sample_number__ (@var{player})\n\
+@deftypefn {} {@var{n} =} __player_get_sample_number__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2605,17 +2605,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_get_tag__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{tag} =} __player_get_tag__ (@var{player})\n\
+@deftypefn {} {@var{tag} =} __player_get_tag__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2634,17 +2634,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_get_total_samples__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{n} =} __player_get_total_samples__ (@var{player})\n\
+@deftypefn {} {@var{n} =} __player_get_total_samples__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2663,17 +2663,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_get_userdata__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{data} =} __player_get_userdata__ (@var{player})\n\
+@deftypefn {} {@var{data} =} __player_get_userdata__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2692,17 +2692,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_isplaying__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __player_isplaying__ (@var{player})\n\
+@deftypefn {} {} __player_isplaying__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2721,17 +2721,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_pause__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __player_pause__ (@var{player})\n\
+@deftypefn {} {} __player_pause__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2750,19 +2750,19 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_playblocking__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} __player_playblocking__ (@var{player})\n\
-@deftypefnx {Loadable Function} {} __player_playblocking__ (@var{player}, @var{start})\n\
-@deftypefnx {Loadable Function} {} __player_playblocking__ (@var{player}, [@var{start}, @var{end}])\n\
+@deftypefn  {} {} __player_playblocking__ (@var{player})\n\
+@deftypefnx {} {} __player_playblocking__ (@var{player}, @var{start})\n\
+@deftypefnx {} {} __player_playblocking__ (@var{player}, [@var{start}, @var{end}])\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   audioplayer *player = get_player (args(0));
@@ -2807,19 +2807,19 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_play__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} __player_play__ (@var{player})\n\
-@deftypefnx {Loadable Function} {} __player_play__ (@var{player}, @var{start})\n\
-@deftypefnx {Loadable Function} {} __player_play__ (@var{player}, [@var{start}, @var{end}])\n\
+@deftypefn  {} {} __player_play__ (@var{player})\n\
+@deftypefnx {} {} __player_play__ (@var{player}, @var{start})\n\
+@deftypefnx {} {} __player_play__ (@var{player}, [@var{start}, @var{end}])\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2868,17 +2868,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_resume__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __player_resume__ (@var{player})\n\
+@deftypefn {} {} __player_resume__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
@@ -2897,17 +2897,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_set_fs__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __player_set_fs__ (@var{player}, @var{fs})\n\
+@deftypefn {} {} __player_set_fs__ (@var{player}, @var{fs})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 2)
@@ -2926,17 +2926,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_set_tag__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __player_set_tag__ (@var{player}, @var{tag})\n\
+@deftypefn {} {} __player_set_tag__ (@var{player}, @var{tag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 2)
@@ -2955,17 +2955,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_set_userdata__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __player_set_userdata__ (@var{player}, @var{data})\n\
+@deftypefn {} {} __player_set_userdata__ (@var{player}, @var{data})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 2)
@@ -2984,17 +2984,17 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (__player_stop__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __player_stop__ (@var{player})\n\
+@deftypefn {} {} __player_stop__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   if (args.length () == 1)
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -46,21 +46,21 @@ static void
 safe_close (SNDFILE *file)
 {
   sf_close (file);
 }
 #endif
 
 DEFUN_DLD (audioread, args, ,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{y}, @var{fs}] =} audioread (@var{filename})\n\
-@deftypefnx {Loadable Function} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{samples})\n\
+@deftypefn  {} {[@var{y}, @var{fs}] =} audioread (@var{filename})\n\
+@deftypefnx {} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{samples})\n\
 \n\
-@deftypefnx {Loadable Function} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{datatype})\n\
-@deftypefnx {Loadable Function} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{samples}, @var{datatype})\n\
+@deftypefnx {} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{datatype})\n\
+@deftypefnx {} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{samples}, @var{datatype})\n\
 Read the audio file @var{filename} and return the audio data @var{y} and\n\
 sampling rate @var{fs}.\n\
 \n\
 The audio data is stored as matrix with rows corresponding to audio frames\n\
 and columns corresponding to channels.\n\
 \n\
 The optional two-element vector argument @var{samples} specifies starting\n\
 and ending frames.\n\
@@ -227,18 +227,18 @@ extension_to_format (const std::string& 
 
   return (it != table.end ()) ? it->second : 0;
 }
 
 #endif
 
 DEFUN_DLD (audiowrite, args, ,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} audiowrite (@var{filename}, @var{y}, @var{fs})\n\
-@deftypefnx {Loadable Function} {} audiowrite (@var{filename}, @var{y}, @var{fs}, @var{name}, @var{value}, @dots{})\n\
+@deftypefn  {} {} audiowrite (@var{filename}, @var{y}, @var{fs})\n\
+@deftypefnx {} {} audiowrite (@var{filename}, @var{y}, @var{fs}, @var{name}, @var{value}, @dots{})\n\
 \n\
 Write audio data from the matrix @var{y} to @var{filename} at sampling rate\n\
 @var{fs} with the file format determined by the file extension.\n\
 \n\
 Additional name/value argument pairs may be used to specify the\n\
 following options:\n\
 \n\
 @table @samp\n\
@@ -432,17 +432,17 @@ Comment.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (audioinfo, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{info} =} audioinfo (@var{filename})\n\
+@deftypefn {} {@var{info} =} audioinfo (@var{filename})\n\
 Return information about an audio file specified by @var{filename}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_SNDFILE
 
   if (args.length () != 1)
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -48,20 +48,20 @@ along with Octave; see the file COPYING.
 #define CSYMAMD_NAME(name) csymamd_l ## name
 #else
 #define CCOLAMD_NAME(name) ccolamd ## name
 #define CSYMAMD_NAME(name) csymamd ## name
 #endif
 
 DEFUN_DLD (ccolamd, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} ccolamd (@var{S})\n\
-@deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{S}, @var{knobs})\n\
-@deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{S}, @var{knobs}, @var{cmember})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} ccolamd (@dots{})\n\
+@deftypefn  {} {@var{p} =} ccolamd (@var{S})\n\
+@deftypefnx {} {@var{p} =} ccolamd (@var{S}, @var{knobs})\n\
+@deftypefnx {} {@var{p} =} ccolamd (@var{S}, @var{knobs}, @var{cmember})\n\
+@deftypefnx {} {[@var{p}, @var{stats}] =} ccolamd (@dots{})\n\
 \n\
 Constrained column approximate minimum degree permutation.\n\
 \n\
 @code{@var{p} = ccolamd (@var{S})} returns the column approximate minimum\n\
 degree permutation vector for the sparse matrix @var{S}.  For a non-symmetric\n\
 matrix @var{S}, @code{@var{S}(:, @var{p})} tends to have sparser\n\
 LU@tie{}factors than @var{S}.\n\
 @code{chol (@var{S}(:, @var{p})' * @var{S}(:, @var{p}))} also tends to be\n\
@@ -335,20 +335,20 @@ ccolamd, csymamd, amd, colamd, symamd, a
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (csymamd, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} csymamd (@var{S})\n\
-@deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{S}, @var{knobs})\n\
-@deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{S}, @var{knobs}, @var{cmember})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} csymamd (@dots{})\n\
+@deftypefn  {} {@var{p} =} csymamd (@var{S})\n\
+@deftypefnx {} {@var{p} =} csymamd (@var{S}, @var{knobs})\n\
+@deftypefnx {} {@var{p} =} csymamd (@var{S}, @var{knobs}, @var{cmember})\n\
+@deftypefnx {} {[@var{p}, @var{stats}] =} csymamd (@dots{})\n\
 \n\
 For a symmetric positive definite matrix @var{S}, return the permutation\n\
 vector @var{p} such that @code{@var{S}(@var{p},@var{p})} tends to have a\n\
 sparser Cholesky@tie{}factor than @var{S}.\n\
 \n\
 Sometimes @code{csymamd} works well for symmetric indefinite matrices too. \n\
 The matrix @var{S} is assumed to be symmetric; only the strictly lower\n\
 triangular part is referenced.  @var{S} must be square.  The ordering is\n\
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -64,22 +64,22 @@ static octave_value
 get_chol_l (const CHOLT& fact)
 {
   return octave_value (fact.chol_matrix ().transpose (),
                        MatrixType (MatrixType::Lower));
 }
 
 DEFUN_DLD (chol, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{R} =} chol (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{R}, @var{p}] =} chol (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S})\n\
-@deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S}, \"vector\")\n\
-@deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, \"lower\")\n\
-@deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, \"upper\")\n\
+@deftypefn  {} {@var{R} =} chol (@var{A})\n\
+@deftypefnx {} {[@var{R}, @var{p}] =} chol (@var{A})\n\
+@deftypefnx {} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S})\n\
+@deftypefnx {} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S}, \"vector\")\n\
+@deftypefnx {} {[@var{L}, @dots{}] =} chol (@dots{}, \"lower\")\n\
+@deftypefnx {} {[@var{L}, @dots{}] =} chol (@dots{}, \"upper\")\n\
 @cindex Cholesky factorization\n\
 Compute the Cholesky@tie{}factor, @var{R}, of the symmetric positive definite\n\
 matrix @var{A}.\n\
 \n\
 The Cholesky@tie{}factor is defined by\n\
 @tex\n\
 $ R^T R = A $.\n\
 @end tex\n\
@@ -337,17 +337,17 @@ sparse matrices.\n\
 %!error <matrix must be positive definite> chol ([1, 2; 3, 4])
 %!error <requires square matrix> chol ([1, 2; 3, 4; 5, 6])
 %!error <optional arguments must be strings> chol (1, 2)
 %!error <optional argument must be one of "vector", "lower"> chol (1, "foobar")
 */
 
 DEFUN_DLD (cholinv, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} cholinv (@var{A})\n\
+@deftypefn {} {} cholinv (@var{A})\n\
 Compute the inverse of the symmetric positive definite matrix @var{A} using\n\
 the Cholesky@tie{}factorization.\n\
 @seealso{chol, chol2inv, inv}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
@@ -462,17 +462,17 @@ the Cholesky@tie{}factorization.\n\
 %! assert (norm (Ainv-Ainv2), 0, 1e-10);
 %!testif HAVE_CHOLMOD
 %! Ainv3 = cholinv (sparse (A));
 %! assert (norm (Ainv-Ainv3), 0, 1e-10);
 */
 
 DEFUN_DLD (chol2inv, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} chol2inv (@var{U})\n\
+@deftypefn {} {} chol2inv (@var{U})\n\
 Invert a symmetric, positive definite square matrix from its Cholesky\n\
 decomposition, @var{U}.\n\
 \n\
 Note that @var{U} should be an upper-triangular matrix with positive\n\
 diagonal elements.  @code{chol2inv (@var{U})} provides\n\
 @code{inv (@var{U}'*@var{U})} but it is much faster than using @code{inv}.\n\
 @seealso{chol, cholinv, inv}\n\
 @end deftypefn")
@@ -545,17 +545,17 @@ diagonal elements.  @code{chol2inv (@var
         }
     }
 
   return retval;
 }
 
 DEFUN_DLD (cholupdate, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholupdate (@var{R}, @var{u}, @var{op})\n\
+@deftypefn {} {[@var{R1}, @var{info}] =} cholupdate (@var{R}, @var{u}, @var{op})\n\
 Update or downdate a Cholesky@tie{}factorization.\n\
 \n\
 Given an upper triangular matrix @var{R} and a column vector @var{u},\n\
 attempt to determine another upper triangular matrix @var{R1} such that\n\
 \n\
 @itemize @bullet\n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} + @var{u}*@var{u}'\n\
@@ -750,18 +750,18 @@ If @var{info} is not present, an error m
 %!
 %! R1 = cholupdate (R1, single (uc), "-");
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (R1 - R, Inf) < 2e1*eps ("single"));
 */
 
 DEFUN_DLD (cholinsert, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{R1} =} cholinsert (@var{R}, @var{j}, @var{u})\n\
-@deftypefnx {Loadable Function} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
+@deftypefn  {} {@var{R1} =} cholinsert (@var{R}, @var{j}, @var{u})\n\
+@deftypefnx {} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of\n\
 @var{A1}, where @w{A1(p,p) = A}, @w{A1(:,j) = A1(j,:)' = u} and\n\
 @w{p = [1:j-1,j+1:n+1]}.  @w{u(j)} should be positive.\n\
 \n\
 On return, @var{info} is set to\n\
 \n\
@@ -1007,17 +1007,17 @@ If @var{info} is not present, an error m
 %! assert (cca, ccal',  16*eps);
 %! assert (cca, ccau,   16*eps);
 %! assert (cca, ccal2', 16*eps);
 %! assert (cca, ccau2,  16*eps);
 */
 
 DEFUN_DLD (choldelete, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{R1} =} choldelete (@var{R}, @var{j})\n\
+@deftypefn {} {@var{R1} =} choldelete (@var{R}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of @w{A(p,p)}, where\n\
 @w{p = [1:j-1,j+1:n+1]}.\n\
 @seealso{chol, cholupdate, cholinsert, cholshift}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -1133,17 +1133,17 @@ triangular, return the Cholesky@tie{}fac
 %! R1 = choldelete (R,j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (R1'*R1 - single (Ac(p,p)), Inf) < 1e1*eps ("single"));
 */
 
 DEFUN_DLD (cholshift, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})\n\
+@deftypefn {} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of\n\
 @w{@var{A}(p,p)}, where @w{p} is the permutation @*\n\
 @code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*\n\
  or @*\n\
 @code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*\n\
 \n\
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -206,20 +206,20 @@ coletree (const octave_idx_type *ridx, c
               root[cset] = col;
             }
         }
     }
 }
 
 DEFUN_DLD (colamd, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} colamd (@var{S})\n\
-@deftypefnx {Loadable Function} {@var{p} =} colamd (@var{S}, @var{knobs})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{S})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{S}, @var{knobs})\n\
+@deftypefn  {} {@var{p} =} colamd (@var{S})\n\
+@deftypefnx {} {@var{p} =} colamd (@var{S}, @var{knobs})\n\
+@deftypefnx {} {[@var{p}, @var{stats}] =} colamd (@var{S})\n\
+@deftypefnx {} {[@var{p}, @var{stats}] =} colamd (@var{S}, @var{knobs})\n\
 \n\
 Compute the column approximate minimum degree permutation.\n\
 \n\
 @code{@var{p} = colamd (@var{S})} returns the column approximate minimum\n\
 degree permutation vector for the sparse matrix @var{S}.  For a\n\
 non-symmetric matrix @var{S}, @code{@var{S}(:,@var{p})} tends to have\n\
 sparser LU@tie{}factors than @var{S}.  The Cholesky@tie{}factorization of\n\
 @code{@var{S}(:,@var{p})' * @var{S}(:,@var{p})} also tends to be sparser\n\
@@ -445,20 +445,20 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (symamd, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} symamd (@var{S})\n\
-@deftypefnx {Loadable Function} {@var{p} =} symamd (@var{S}, @var{knobs})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{S})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{S}, @var{knobs})\n\
+@deftypefn  {} {@var{p} =} symamd (@var{S})\n\
+@deftypefnx {} {@var{p} =} symamd (@var{S}, @var{knobs})\n\
+@deftypefnx {} {[@var{p}, @var{stats}] =} symamd (@var{S})\n\
+@deftypefnx {} {[@var{p}, @var{stats}] =} symamd (@var{S}, @var{knobs})\n\
 \n\
 For a symmetric positive definite matrix @var{S}, returns the permutation\n\
 vector p such that @code{@var{S}(@var{p}, @var{p})} tends to have a\n\
 sparser Cholesky@tie{}factor than @var{S}.\n\
 \n\
 Sometimes @code{symamd} works well for symmetric indefinite matrices too. \n\
 The matrix @var{S} is assumed to be symmetric; only the strictly lower\n\
 triangular part is referenced.  @var{S} must be square.\n\
@@ -635,19 +635,19 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (etree, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} etree (@var{S})\n\
-@deftypefnx {Loadable Function} {@var{p} =} etree (@var{S}, @var{typ})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{S}, @var{typ})\n\
+@deftypefn  {} {@var{p} =} etree (@var{S})\n\
+@deftypefnx {} {@var{p} =} etree (@var{S}, @var{typ})\n\
+@deftypefnx {} {[@var{p}, @var{q}] =} etree (@var{S}, @var{typ})\n\
 \n\
 Return the elimination tree for the matrix @var{S}.\n\
 \n\
 By default @var{S} is assumed to be symmetric and the symmetric elimination\n\
 tree is returned.  The argument @var{typ} controls whether a symmetric or\n\
 column elimination tree is returned.  Valid values of @var{typ} are\n\
 @qcode{\"sym\"} or @qcode{\"col\"}, for symmetric or column elimination tree\n\
 respectively.\n\
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -66,19 +66,19 @@ octave_qhull_dims_ok (octave_idx_type di
         error ("%s: dimension too large for Qhull", who);
     }
 
   return true;
 }
 
 DEFUN_DLD (convhulln, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{h} =} convhulln (@var{pts})\n\
-@deftypefnx {Loadable Function} {@var{h} =} convhulln (@var{pts}, @var{options})\n\
-@deftypefnx {Loadable Function} {[@var{h}, @var{v}] =} convhulln (@dots{})\n\
+@deftypefn  {} {@var{h} =} convhulln (@var{pts})\n\
+@deftypefnx {} {@var{h} =} convhulln (@var{pts}, @var{options})\n\
+@deftypefnx {} {[@var{h}, @var{v}] =} convhulln (@dots{})\n\
 Compute the convex hull of the set of points @var{pts}.\n\
 \n\
 @var{pts} is a matrix of size [n, dim] containing n points in a space of\n\
 dimension dim.\n\
 \n\
 The hull @var{h} is an index vector into the set of points and specifies\n\
 which points form the enclosing hull.\n\
 \n\
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -126,18 +126,18 @@ dmperm_internal (bool rank, const octave
     }
 
   return retval;
 }
 #endif
 
 DEFUN_DLD (dmperm, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} dmperm (@var{S})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{q}, @var{r}, @var{S}] =} dmperm (@var{S})\n\
+@deftypefn  {} {@var{p} =} dmperm (@var{S})\n\
+@deftypefnx {} {[@var{p}, @var{q}, @var{r}, @var{S}] =} dmperm (@var{S})\n\
 \n\
 @cindex @nospell{Dulmage-Mendelsohn} decomposition\n\
 Perform a @nospell{Dulmage-Mendelsohn} permutation of the sparse matrix\n\
 @var{S}.\n\
 \n\
 With a single output argument @code{dmperm} performs the row permutations\n\
 @var{p} such that @code{@var{S}(@var{p},:)} has no zero elements on the\n\
 diagonal.\n\
@@ -180,17 +180,17 @@ ACM Trans. Math. Software, 16(4):303-324
 %! a = tril (sprandn (n,n,d), -1) + speye (n,n);
 %! a = a(randperm (n), randperm (n));
 %! [p,q,r,s] = dmperm (a);
 %! assert (tril (a(p,q), -1), sparse (n, n));
 */
 
 DEFUN_DLD (sprank, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{p} =} sprank (@var{S})\n\
+@deftypefn {} {@var{p} =} sprank (@var{S})\n\
 @cindex structural rank\n\
 \n\
 Calculate the structural rank of the sparse matrix @var{S}.\n\
 \n\
 Note that only the structure of the matrix is used in this calculation based\n\
 on a @nospell{Dulmage-Mendelsohn} permutation to block triangular form.  As\n\
 such the numerical rank of the matrix @var{S} is bounded by\n\
 @code{sprank (@var{S}) >= rank (@var{S})}.  Ignoring floating point errors\n\
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -31,22 +31,22 @@ along with Octave; see the file COPYING.
 #include "defun-dld.h"
 #include "error.h"
 #include "ov.h"
 
 #include "gripes.h"
 
 DEFUN_DLD (fftw, args, ,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{method} =} fftw (\"planner\")\n\
-@deftypefnx {Loadable Function} {} fftw (\"planner\", @var{method})\n\
-@deftypefnx {Loadable Function} {@var{wisdom} =} fftw (\"dwisdom\")\n\
-@deftypefnx {Loadable Function} {} fftw (\"dwisdom\", @var{wisdom})\n\
-@deftypefnx {Loadable Function} {} fftw (\"threads\", @var{nthreads})\n\
-@deftypefnx {Loadable Function} {@var{nthreads} =} fftw (\"threads\")\n\
+@deftypefn  {} {@var{method} =} fftw (\"planner\")\n\
+@deftypefnx {} {} fftw (\"planner\", @var{method})\n\
+@deftypefnx {} {@var{wisdom} =} fftw (\"dwisdom\")\n\
+@deftypefnx {} {} fftw (\"dwisdom\", @var{wisdom})\n\
+@deftypefnx {} {} fftw (\"threads\", @var{nthreads})\n\
+@deftypefnx {} {@var{nthreads} =} fftw (\"threads\")\n\
 \n\
 Manage @sc{fftw} wisdom data.\n\
 \n\
 Wisdom data can be used to significantly accelerate the calculation of the\n\
 FFTs, but implies an initial cost in its calculation.  When the @sc{fftw}\n\
 libraries are initialized, they read a system wide wisdom file (typically in\n\
 @file{/etc/fftw/wisdom}), allowing wisdom to be shared between applications\n\
 other than Octave.  Alternatively, the @code{fftw} function can be used to\n\
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -69,20 +69,20 @@ get_qr_r (const base_qr<MT>& fact)
 // [Q, R, P] = qr (X, 0): form the economy decomposition with
 //                        permutation vector P such that Q * R = X (:, P)
 //
 // qr (X) alone returns the output of the LAPACK routine dgeqrf, such
 // that R = triu (qr (X))
 
 DEFUN_DLD (qr, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{Q}, @var{R}, @var{P}] =} qr (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{Q}, @var{R}, @var{P}] =} qr (@var{A}, '0')\n\
-@deftypefnx {Loadable Function} {[@var{C}, @var{R}] =} qr (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {[@var{C}, @var{R}] =} qr (@var{A}, @var{B}, '0')\n\
+@deftypefn  {} {[@var{Q}, @var{R}, @var{P}] =} qr (@var{A})\n\
+@deftypefnx {} {[@var{Q}, @var{R}, @var{P}] =} qr (@var{A}, '0')\n\
+@deftypefnx {} {[@var{C}, @var{R}] =} qr (@var{A}, @var{B})\n\
+@deftypefnx {} {[@var{C}, @var{R}] =} qr (@var{A}, @var{B}, '0')\n\
 @cindex QR factorization\n\
 Compute the QR@tie{}factorization of @var{A}, using standard @sc{lapack}\n\
 subroutines.\n\
 \n\
 For example, given the matrix @code{@var{A} = [1, 2; 3, 4]},\n\
 \n\
 @example\n\
 [@var{Q}, @var{R}] = qr (@var{A})\n\
@@ -735,17 +735,17 @@ static
 bool check_index (const octave_value& i, bool vector_allowed = false)
 {
   return ((i.is_real_type () || i.is_integer_type ())
           && (i.is_scalar_type () || vector_allowed));
 }
 
 DEFUN_DLD (qrupdate, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrupdate (@var{Q}, @var{R}, @var{u}, @var{v})\n\
+@deftypefn {} {[@var{Q1}, @var{R1}] =} qrupdate (@var{Q}, @var{R}, @var{u}, @var{v})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
 @w{@var{A} + @var{u}*@var{v}'}, where @var{u} and @var{v} are column vectors\n\
 (rank-1 update) or matrices with equal number of columns\n\
 (rank-k update).  Notice that the latter case is done as a sequence of rank-1\n\
 updates; thus, for k large enough, it will be both faster and more accurate\n\
 to recompute the factorization from scratch.\n\
@@ -909,17 +909,17 @@ economized (R is square).\n\
 %! [Q,R] = qrupdate (Q, R, single (uc), single (vc));
 %! assert (norm (vec (Q'*Q - eye (5,"single")), Inf) < 1e1*eps ("single"));
 %! assert (norm (vec (triu (R)-R), Inf) == 0);
 %! assert (norm (vec (Q*R - single (Ac) - single (uc)*single (vc)'), Inf) < norm (single (Ac))*1e1*eps ("single"));
 */
 
 DEFUN_DLD (qrinsert, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrinsert (@var{Q}, @var{R}, @var{j}, @var{x}, @var{orient})\n\
+@deftypefn {} {[@var{Q1}, @var{R1}] =} qrinsert (@var{Q}, @var{R}, @var{j}, @var{x}, @var{orient})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
 @w{[A(:,1:j-1) x A(:,j:n)]}, where @var{u} is a column vector to be inserted\n\
 into @var{A} (if @var{orient} is @qcode{\"col\"}), or the\n\
 QR@tie{}factorization of @w{[A(1:j-1,:);x;A(:,j:n)]}, where @var{x} is a row\n\
 vector to be inserted into @var{A} (if @var{orient} is @qcode{\"row\"}).\n\
 \n\
@@ -1124,17 +1124,17 @@ If @var{orient} is @qcode{\"row\"}, full
 %! [Q,R] = qrinsert (Q, R, 3, x, "row");
 %! assert (norm (vec (Q'*Q - eye (6,"single")), Inf) < 1e1*eps ("single"));
 %! assert (norm (vec (triu (R) - R), Inf) == 0);
 %! assert (norm (vec (Q*R - single ([Ac(1:2,:);x;Ac(3:5,:)])), Inf) < norm (single (Ac))*1e1*eps ("single"));
 */
 
 DEFUN_DLD (qrdelete, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrdelete (@var{Q}, @var{R}, @var{j}, @var{orient})\n\
+@deftypefn {} {[@var{Q1}, @var{R1}] =} qrdelete (@var{Q}, @var{R}, @var{j}, @var{orient})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
 @w{[A(:,1:j-1) A(:,j+1:n)]}, i.e., @var{A} with one column deleted\n\
 (if @var{orient} is @qcode{\"col\"}), or the QR@tie{}factorization of\n\
 @w{[A(1:j-1,:);A(j+1:n,:)]}, i.e., @var{A} with one row deleted (if\n\
 @var{orient} is @qcode{\"row\"}).\n\
 \n\
@@ -1383,17 +1383,17 @@ If @var{orient} is @qcode{\"row\"}, full
 %! [Q,R] = qrdelete (Q, R, 3, "row");
 %! assert (norm (vec (Q'*Q - eye (4,"single")), Inf) < 1e1*eps ("single"));
 %! assert (norm (vec (triu (R) - R), Inf) == 0);
 %! assert (norm (vec (Q*R - [AA(1:2,:);AA(4:5,:)]), Inf) < norm (AA)*1e1*eps ("single"));
 */
 
 DEFUN_DLD (qrshift, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrshift (@var{Q}, @var{R}, @var{i}, @var{j})\n\
+@deftypefn {} {[@var{Q1}, @var{R1}] =} qrshift (@var{Q}, @var{R}, @var{i}, @var{j})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization\n\
 of @w{@var{A}(:,p)}, where @w{p} is the permutation @*\n\
 @code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*\n\
  or @*\n\
 @code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*\n\
 \n\
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -36,19 +36,19 @@ along with Octave; see the file COPYING.
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (symbfact, args, nargout,
            "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{count}, @var{h}, @var{parent}, @var{post}, @var{r}] =} symbfact (@var{S})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} symbfact (@var{S}, @var{typ})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} symbfact (@var{S}, @var{typ}, @var{mode})\n\
+@deftypefn  {} {[@var{count}, @var{h}, @var{parent}, @var{post}, @var{r}] =} symbfact (@var{S})\n\
+@deftypefnx {} {[@dots{}] =} symbfact (@var{S}, @var{typ})\n\
+@deftypefnx {} {[@dots{}] =} symbfact (@var{S}, @var{typ}, @var{mode})\n\
 \n\
 Perform a symbolic factorization analysis on the sparse matrix @var{S}.\n\
 \n\
 The input variables are\n\
 \n\
 @table @var\n\
 @item S\n\
 @var{S} is a complex or real sparse matrix.\n\
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -408,17 +408,17 @@ transpose (octave_idx_type N, const octa
         octave_idx_type q = w[ridx[k]]++;
         ridx2[q] = j;
       }
 }
 
 // An implementation of the Cuthill-McKee algorithm.
 DEFUN_DLD (symrcm, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{p} =} symrcm (@var{S})\n\
+@deftypefn {} {@var{p} =} symrcm (@var{S})\n\
 Return the symmetric reverse @nospell{Cuthill-McKee} permutation of @var{S}.\n\
 \n\
 @var{p} is a permutation vector such that\n\
 @code{@var{S}(@var{p}, @var{p})} tends to have its diagonal elements closer\n\
 to the diagonal than @var{S}.  This is a good preordering for LU or\n\
 Cholesky@tie{}factorization of matrices that come from ``long, skinny''\n\
 problems.  It works for both symmetric and asymmetric @var{S}.\n\
 \n\
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1684,19 +1684,19 @@ install_base_type_conversions (void)
   INSTALL_WIDENOP (octave_base_value, octave_complex_matrix,
                    complex_matrix_conv);
   INSTALL_WIDENOP (octave_base_value, octave_char_matrix_str, string_conv);
   INSTALL_WIDENOP (octave_base_value, octave_cell, cell_conv);
 }
 
 DEFUN (sparse_auto_mutate, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} sparse_auto_mutate ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} sparse_auto_mutate (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} sparse_auto_mutate (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} sparse_auto_mutate ()\n\
+@deftypefnx {} {@var{old_val} =} sparse_auto_mutate (@var{new_val})\n\
+@deftypefnx {} {} sparse_auto_mutate (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
 automatically mutate sparse matrices to full matrices to save memory.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 s = speye (3);\n\
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -553,17 +553,17 @@ octave_bool_matrix::as_mxArray (void) co
   for (mwIndex i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
 DEFUN (logical, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} logical (@var{x})\n\
+@deftypefn {} {} logical (@var{x})\n\
 Convert the numeric object @var{x} to logical type.\n\
 \n\
 Any nonzero values will be converted to true (1) while zero values will be\n\
 converted to false (0).  The non-numeric value NaN cannot be converted and\n\
 will produce an error.\n\
 \n\
 Compatibility Note: Octave accepts complex values as input, whereas\n\
 @sc{matlab} issues an error.\n\
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1227,33 +1227,33 @@ octave_cell::load_hdf5 (octave_hdf5_id l
   gripe_load ("hdf5");
 #endif
 
   return retval;
 }
 
 DEFUN (iscell, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} iscell (@var{x})\n\
+@deftypefn {} {} iscell (@var{x})\n\
 Return true if @var{x} is a cell array object.\n\
 @seealso{ismatrix, isstruct, iscellstr, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_cell ());
 }
 
 DEFUN (cell, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} cell (@var{n})\n\
-@deftypefnx {Built-in Function} {} cell (@var{m}, @var{n})\n\
-@deftypefnx {Built-in Function} {} cell (@var{m}, @var{n}, @var{k}, @dots{})\n\
-@deftypefnx {Built-in Function} {} cell ([@var{m} @var{n} @dots{}])\n\
+@deftypefn  {} {} cell (@var{n})\n\
+@deftypefnx {} {} cell (@var{m}, @var{n})\n\
+@deftypefnx {} {} cell (@var{m}, @var{n}, @var{k}, @dots{})\n\
+@deftypefnx {} {} cell ([@var{m} @var{n} @dots{}])\n\
 Create a new cell array object.\n\
 \n\
 If invoked with a single scalar integer argument, return a square\n\
 @nospell{NxN} cell array.  If invoked with two or more scalar integer\n\
 arguments, or a vector of integer values, return an array with the given\n\
 dimensions.\n\
 @seealso{cellstr, mat2cell, num2cell, struct2cell}\n\
 @end deftypefn")
@@ -1291,17 +1291,17 @@ dimensions.\n\
 
   retval = Cell (dims, Matrix ());
 
   return retval;
 }
 
 DEFUN (iscellstr, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} iscellstr (@var{cell})\n\
+@deftypefn {} {} iscellstr (@var{cell})\n\
 Return true if every element of the cell array @var{cell} is a character\n\
 string.\n\
 @seealso{ischar}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
@@ -1310,17 +1310,17 @@ string.\n\
 
 // Note that since Fcellstr calls Fiscellstr, we need to have
 // Fiscellstr defined first (to provide a declaration) and also we
 // should keep it in the same file (so we don't have to provide a
 // declaration) and so we don't have to use feval to call it.
 
 DEFUN (cellstr, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{cstr} =} cellstr (@var{strmat})\n\
+@deftypefn {} {@var{cstr} =} cellstr (@var{strmat})\n\
 Create a new cell array object from the elements of the string array\n\
 @var{strmat}.\n\
 \n\
 Each row of @var{strmat} becomes an element of @var{cstr}.  Any trailing\n\
 spaces in a row are deleted before conversion.\n\
 \n\
 To convert back from a cellstr to a character array use @code{char}.\n\
 @seealso{cell, char}\n\
@@ -1344,17 +1344,17 @@ To convert back from a cellstr to a char
                 : Cell (s, true));
     }
 
   return retval;
 }
 
 DEFUN (struct2cell, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{c} =} struct2cell (@var{s})\n\
+@deftypefn {} {@var{c} =} struct2cell (@var{s})\n\
 Create a new cell array from the objects stored in the struct object.\n\
 \n\
 If @var{f} is the number of fields in the structure, the resulting cell\n\
 array will have a dimension vector corresponding to\n\
 @code{[@var{f} size(@var{s})]}.  For example:\n\
 \n\
 @example\n\
 @group\n\
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1754,19 +1754,19 @@ octave_class::exemplar_info::compare (co
       error ("invalid comparison of class exemplar to non-class object");
     }
 
   return retval;
 }
 
 DEFUN (class, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Function File} {@var{classname} =} class (@var{obj})\n\
-@deftypefnx {Function File} {} class (@var{s}, @var{id})\n\
-@deftypefnx {Function File} {} class (@var{s}, @var{id}, @var{p}, @dots{})\n\
+@deftypefn  {} {@var{classname} =} class (@var{obj})\n\
+@deftypefnx {} {} class (@var{s}, @var{id})\n\
+@deftypefnx {} {} class (@var{s}, @var{id}, @var{p}, @dots{})\n\
 Return the class of the object @var{obj}, or create a class with\n\
 fields from structure @var{s} and name (string) @var{id}.\n\
 \n\
 Additional arguments name a list of parent classes from which the new class\n\
 is derived.\n\
 @seealso{typeinfo, isa}\n\
 @end deftypefn")
 {
@@ -1835,17 +1835,17 @@ is derived.\n\
 %! assert (class (jobj), "java.lang.StringBuffer");
 
 %% Test Input Validation
 %!error class ()
 */
 
 DEFUN (isa, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Function File} {} isa (@var{obj}, @var{classname})\n\
+@deftypefn {} {} isa (@var{obj}, @var{classname})\n\
 Return true if @var{obj} is an object from the class @var{classname}.\n\
 \n\
 @var{classname} may also be one of the following class categories:\n\
 \n\
 @table @asis\n\
 @item @qcode{\"float\"}\n\
 Floating point value comprising classes @qcode{\"double\"} and\n\
 @qcode{\"single\"}.\n\
@@ -1944,17 +1944,17 @@ belongs to.\n\
 
 %!test
 %! a.b = 1;
 %! assert (isa (a, "struct"));
 */
 
 DEFUN (__parent_classes__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __parent_classes__ (@var{x})\n\
+@deftypefn {} {} __parent_classes__ (@var{x})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval = Cell ();
 
   if (args.length () != 1)
     print_usage ();
 
@@ -1963,31 +1963,31 @@ Undocumented internal function.\n\
   if (arg.is_object ())
     retval = Cell (arg.parent_class_names ());
 
   return retval;
 }
 
 DEFUN (isobject, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isobject (@var{x})\n\
+@deftypefn {} {} isobject (@var{x})\n\
 Return true if @var{x} is a class object.\n\
 @seealso{class, typeinfo, isa, ismethod, isprop}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_object ());
 }
 
 DEFUN (ismethod, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} ismethod (@var{obj}, @var{method})\n\
-@deftypefnx {Built-in Function} {} ismethod (@var{clsname}, @var{method})\n\
+@deftypefn  {} {} ismethod (@var{obj}, @var{method})\n\
+@deftypefnx {} {} ismethod (@var{clsname}, @var{method})\n\
 Return true if the string @var{method} is a valid method of the object\n\
 @var{obj} or of the class @var{clsname}.\n\
 @seealso{isprop, isobject}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 2)
@@ -2011,18 +2011,18 @@ Return true if the string @var{method} i
   else
     retval = false;
 
   return retval;
 }
 
 DEFUN (__methods__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} __methods__ (@var{x})\n\
-@deftypefnx {Built-in Function} {} __methods__ (\"classname\")\n\
+@deftypefn  {} {} __methods__ (@var{x})\n\
+@deftypefnx {} {} __methods__ (\"classname\")\n\
 Internal function.\n\
 \n\
 Implements @code{methods} for Octave class objects and classnames.\n\
 @seealso{methods}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -2066,17 +2066,17 @@ is_built_in_class (const std::string& cn
       built_in_class_names.insert ("uint64");
     }
 
   return built_in_class_names.find (cn) != built_in_class_names.end ();
 }
 
 DEFUN (superiorto, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} superiorto (@var{class_name}, @dots{})\n\
+@deftypefn {} {} superiorto (@var{class_name}, @dots{})\n\
 When called from a class constructor, mark the object currently\n\
 constructed as having a higher precedence than @var{class_name}.\n\
 \n\
 More that one such class can be specified in a single call.\n\
 This function may only be called from a class constructor.\n\
 @seealso{inferiorto}\n\
 @end deftypefn")
 {
@@ -2107,17 +2107,17 @@ This function may only be called from a 
         }
     }
 
   return retval;
 }
 
 DEFUN (inferiorto, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} inferiorto (@var{class_name}, @dots{})\n\
+@deftypefn {} {} inferiorto (@var{class_name}, @dots{})\n\
 When called from a class constructor, mark the object currently\n\
 constructed as having a lower precedence than @var{class_name}.\n\
 \n\
 More that one such class can be specified in a single call.\n\
 This function may only be called from a class constructor.\n\
 @seealso{superiorto}\n\
 @end deftypefn")
 {
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -3813,26 +3813,26 @@ DEFUN (__meta_get_package__, args, , "")
 
   std::string cname = args(0).xstring_value ("PACKAGE_NAME must be a string");
 
   return to_ov (lookup_package (cname));
 }
 
 DEFUN (__superclass_reference__, args, /* nargout */,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __superclass_reference__ ()\n\
+@deftypefn {} {} __superclass_reference__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return octave_value (new octave_classdef_superclass_ref (args));
 }
 
 DEFUN (__meta_class_query__, args, /* nargout */,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __meta_class_query__ ()\n\
+@deftypefn {} {} __meta_class_query__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #if DEBUG_TRACE
   std::cerr << "__meta_class_query__ ("
             << args(0).string_value () << ")"
@@ -3844,17 +3844,17 @@ Undocumented internal function.\n\
 
   std::string cls = args(0).xstring_value ("CLASS_NAME must be a string");
 
   return to_ov (lookup_class (cls));
 }
 
 DEFUN (metaclass, args, /* nargout */,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} metaclass (obj)\n\
+@deftypefn {} {} metaclass (obj)\n\
 Returns the meta.class object corresponding to the class of @var{obj}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     print_usage ();
 
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1664,17 +1664,17 @@ make_fcn_handle (const std::string& nm, 
 %!      "|", "or"};
 %! for i = 1:rows (x)
 %!   assert (functions (str2func (x{i,1})).function, x{i,2});
 %! endfor
 */
 
 DEFUN (functions, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{s} =} functions (@var{fcn_handle})\n\
+@deftypefn {} {@var{s} =} functions (@var{fcn_handle})\n\
 Return a structure containing information about the function handle\n\
 @var{fcn_handle}.\n\
 \n\
 The structure @var{s} always contains these three fields:\n\
 \n\
 @table @asis\n\
 @item function\n\
 The function name.  For an anonymous function (no name) this will be the\n\
@@ -1795,17 +1795,17 @@ particular output.\n\
   else
     error ("functions: FCN_HANDLE is not a valid function handle object");
 
   return retval;
 }
 
 DEFUN (func2str, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} func2str (@var{fcn_handle})\n\
+@deftypefn {} {} func2str (@var{fcn_handle})\n\
 Return a string containing the name of the function referenced by the\n\
 function handle @var{fcn_handle}.\n\
 @seealso{str2func, functions}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
@@ -1831,18 +1831,18 @@ function handle @var{fcn_handle}.\n\
   else
     error ("func2str: FCN_HANDLE must be a valid function handle");
 
   return retval;
 }
 
 DEFUN (str2func, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} str2func (@var{fcn_name})\n\
-@deftypefnx {Built-in Function} {} str2func (@var{fcn_name}, \"global\")\n\
+@deftypefn  {} {} str2func (@var{fcn_name})\n\
+@deftypefnx {} {} str2func (@var{fcn_name}, \"global\")\n\
 Return a function handle constructed from the string @var{fcn_name}.\n\
 \n\
 If the optional @qcode{\"global\"} argument is passed, locally visible\n\
 functions are ignored in the lookup.\n\
 @seealso{func2str, inline}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1898,17 +1898,17 @@ functions are ignored in the lookup.\n\
 %!  endif
 %!endfunction
 %!
 %!assert (__testrecursionfunc (@(x) x, 1), 8)
 */
 
 DEFUN (is_function_handle, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} is_function_handle (@var{x})\n\
+@deftypefn {} {} is_function_handle (@var{x})\n\
 Return true if @var{x} is a function handle.\n\
 @seealso{isa, typeinfo, class, functions}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_function_handle ());
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -644,19 +644,19 @@ octave_fcn_inline::print_raw (std::ostre
 octave_value
 octave_fcn_inline::convert_to_str_internal (bool, bool, char type) const
 {
   return octave_value (fcn_text (), type);
 }
 
 DEFUNX ("inline", Finline, args, ,
         "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} inline (@var{str})\n\
-@deftypefnx {Built-in Function} {} inline (@var{str}, @var{arg1}, @dots{})\n\
-@deftypefnx {Built-in Function} {} inline (@var{str}, @var{n})\n\
+@deftypefn  {} {} inline (@var{str})\n\
+@deftypefnx {} {} inline (@var{str}, @var{arg1}, @dots{})\n\
+@deftypefnx {} {} inline (@var{str}, @var{n})\n\
 Create an inline function from the character string @var{str}.\n\
 \n\
 If called with a single argument, the arguments of the generated function\n\
 are extracted from the function itself.  The generated function arguments\n\
 will then be in alphabetical order.  It should be noted that i and j are\n\
 ignored as arguments due to the ambiguity between their use as a variable or\n\
 their use as an built-in constant.  All arguments followed by a parenthesis\n\
 are considered to be functions.  If no arguments are found, a function\n\
@@ -834,17 +834,17 @@ functions from strings is through the us
 %!error <STR argument must be a string> inline (1)
 %!error <N must be an integer> inline ("2", ones (2,2))
 %!error <N must be a positive integer> inline ("2", -1)
 %!error <additional arguments must be strings> inline ("2", "x", -1, "y")
 */
 
 DEFUN (formula, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} formula (@var{fun})\n\
+@deftypefn {} {} formula (@var{fun})\n\
 Return a character string representing the inline function @var{fun}.\n\
 \n\
 Note that @code{char (@var{fun})} is equivalent to\n\
 @code{formula (@var{fun})}.\n\
 @seealso{char, argnames, inline, vectorize}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -869,17 +869,17 @@ Note that @code{char (@var{fun})} is equ
 ## Test input validation
 %!error formula ()
 %!error formula (1, 2)
 %!error <FUN must be an inline function> formula (1)
 */
 
 DEFUN (argnames, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} argnames (@var{fun})\n\
+@deftypefn {} {} argnames (@var{fun})\n\
 Return a cell array of character strings containing the names of the\n\
 arguments of the inline function @var{fun}.\n\
 @seealso{inline, formula, vectorize}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
@@ -912,17 +912,17 @@ arguments of the inline function @var{fu
 ## Test input validation
 %!error argnames ()
 %!error argnames (1, 2)
 %!error <FUN must be an inline function> argnames (1)
 */
 
 DEFUN (vectorize, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} vectorize (@var{fun})\n\
+@deftypefn {} {} vectorize (@var{fun})\n\
 Create a vectorized version of the inline function @var{fun} by replacing\n\
 all occurrences of @code{*}, @code{/}, etc., with @code{.*}, @code{./}, etc.\n\
 \n\
 This may be useful, for example, when using inline functions with numerical\n\
 integration or optimization where a vector-valued function is expected.\n\
 \n\
 @example\n\
 @group\n\
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -850,17 +850,17 @@ octave_float_matrix::map (unary_mapper_t
 
     default:
       return octave_base_value::map (umap);
     }
 }
 
 DEFUN (single, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} single (@var{x})\n\
+@deftypefn {} {} single (@var{x})\n\
 Convert @var{x} to single precision type.\n\
 @seealso{double}\n\
 @end deftypefn")
 {
   // The OCTAVE_TYPE_CONV_BODY3 macro declares retval, so they go
   // inside their own scopes, and we don't declare retval here to
   // avoid a shadowed declaration warning.
 
diff --git a/libinterp/octave-value/ov-int16.cc b/libinterp/octave-value/ov-int16.cc
--- a/libinterp/octave-value/ov-int16.cc
+++ b/libinterp/octave-value/ov-int16.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_int16>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int16_scalar,
                                      "int16 scalar", "int16");
 
 DEFUN (int16, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} int16 (@var{x})\n\
+@deftypefn {} {} int16 (@var{x})\n\
 Convert @var{x} to 16-bit integer type.\n\
 @seealso{int8, uint8, uint16, int32, uint32, int64, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int16);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-int32.cc b/libinterp/octave-value/ov-int32.cc
--- a/libinterp/octave-value/ov-int32.cc
+++ b/libinterp/octave-value/ov-int32.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_int32>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int32_scalar,
                                      "int32 scalar", "int32");
 
 DEFUN (int32, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} int32 (@var{x})\n\
+@deftypefn {} {} int32 (@var{x})\n\
 Convert @var{x} to 32-bit integer type.\n\
 @seealso{int8, uint8, int16, uint16, uint32, int64, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int32);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-int64.cc b/libinterp/octave-value/ov-int64.cc
--- a/libinterp/octave-value/ov-int64.cc
+++ b/libinterp/octave-value/ov-int64.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_int64>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int64_scalar,
                                      "int64 scalar", "int64");
 
 DEFUN (int64, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} int64 (@var{x})\n\
+@deftypefn {} {} int64 (@var{x})\n\
 Convert @var{x} to 64-bit integer type.\n\
 @seealso{int8, uint8, int16, uint16, int32, uint32, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int64);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-int8.cc b/libinterp/octave-value/ov-int8.cc
--- a/libinterp/octave-value/ov-int8.cc
+++ b/libinterp/octave-value/ov-int8.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_int8>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int8_scalar,
                                      "int8 scalar", "int8");
 
 DEFUN (int8, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} int8 (@var{x})\n\
+@deftypefn {} {} int8 (@var{x})\n\
 Convert @var{x} to 8-bit integer type.\n\
 @seealso{uint8, int16, uint16, int32, uint32, int64, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int8);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -2065,17 +2065,17 @@ octave_java::do_java_set (JNIEnv* jni_en
 
 #endif  // endif on HAVE_JAVA
 
 // DEFUN blocks below must be outside of HAVE_JAVA block so that
 // documentation strings are always available, even when functions are not.
 
 DEFUN (__java_init__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __java_init__ ()\n\
+@deftypefn {} {} __java_init__ ()\n\
 Internal function used @strong{only} when debugging Java interface.\n\
 \n\
 Function will directly call initialize_java() to create an instance of a JVM.\n\
 @end deftypefn")
 {
 
 #ifdef HAVE_JAVA
   octave_value retval;
@@ -2090,17 +2090,17 @@ Function will directly call initialize_j
 #else
   error ("__java_init__: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
 DEFUN (__java_exit__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __java_exit__ ()\n\
+@deftypefn {} {} __java_exit__ ()\n\
 Internal function used @strong{only} when debugging Java interface.\n\
 \n\
 Function will directly call terminate_jvm() to destroy the current JVM\n\
 instance.\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   terminate_jvm ();
@@ -2108,18 +2108,18 @@ instance.\n\
   error ("__java_init__: Octave was not compiled with Java interface");
 #endif
 
   return octave_value ();
 }
 
 DEFUN (javaObject, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{jobj} =} javaObject (@var{classname})\n\
-@deftypefnx {Built-in Function} {@var{jobj} =} javaObject (@var{classname}, @var{arg1}, @dots{})\n\
+@deftypefn  {} {@var{jobj} =} javaObject (@var{classname})\n\
+@deftypefnx {} {@var{jobj} =} javaObject (@var{classname}, @var{arg1}, @dots{})\n\
 Create a Java object of class @var{classsname}, by calling the class\n\
 constructor with the arguments @var{arg1}, @dots{}\n\
 \n\
 The first example below creates an uninitialized object, while the second\n\
 example supplies an initial argument to the constructor.\n\
 \n\
 @example\n\
 @group\n\
@@ -2168,18 +2168,18 @@ x = javaObject (\"java.lang.StringBuffer
 ## properly, i.e., creates the right values, is a matter of Java itself.
 ## Create a Short and check if it really is a short, i.e., whether it overflows.
 %!testif HAVE_JAVA
 %! assert (javaObject ("java.lang.Short", 40000).doubleValue < 0);
 */
 
 DEFUN (javaMethod, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{ret} =} javaMethod (@var{methodname}, @var{obj})\n\
-@deftypefnx {Built-in Function} {@var{ret} =} javaMethod (@var{methodname}, @var{obj}, @var{arg1}, @dots{})\n\
+@deftypefn  {} {@var{ret} =} javaMethod (@var{methodname}, @var{obj})\n\
+@deftypefnx {} {@var{ret} =} javaMethod (@var{methodname}, @var{obj}, @var{arg1}, @dots{})\n\
 Invoke the method @var{methodname} on the Java object @var{obj} with the\n\
 arguments @var{arg1}, @dots{}.\n\
 \n\
 For static methods, @var{obj} can be a string representing the fully\n\
 qualified name of the corresponding class.\n\
 \n\
 When @var{obj} is a regular Java object, structure-like indexing can be\n\
 used as a shortcut syntax.  For instance, the two following statements are\n\
@@ -2245,17 +2245,17 @@ equivalent\n\
 %!testif HAVE_JAVA
 %! ## Check for valid first two Java version numbers
 %! jver = strsplit (javaMethod ("getProperty", "java.lang.System", "java.version"), ".");
 %! assert (isfinite (str2double (jver{1})) && isfinite (str2double (jver{2})));
 */
 
 DEFUN (__java_get__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{val} =} __java_get__ (@var{obj}, @var{name})\n\
+@deftypefn {} {@var{val} =} __java_get__ (@var{obj}, @var{name})\n\
 Get the value of the field @var{name} of the Java object @var{obj}.\n\
 \n\
 For static fields, @var{obj} can be a string representing the fully qualified\n\
 name of the corresponding class.\n\
 \n\
 When @var{obj} is a regular Java object, structure-like indexing can be used\n\
 as a shortcut syntax.  For instance, the two following statements are\n\
 equivalent\n\
@@ -2307,17 +2307,17 @@ equivalent\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN (__java_set__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{obj} =} __java_set__ (@var{obj}, @var{name}, @var{val})\n\
+@deftypefn {} {@var{obj} =} __java_set__ (@var{obj}, @var{name}, @var{val})\n\
 Set the value of the field @var{name} of the Java object @var{obj} to\n\
 @var{val}.\n\
 \n\
 For static fields, @var{obj} can be a string representing the fully\n\
 qualified named of the corresponding Java class.\n\
 \n\
 When @var{obj} is a regular Java object, structure-like indexing can be\n\
 used as a shortcut syntax.  For instance, the two following statements are\n\
@@ -2370,17 +2370,17 @@ equivalent\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN (java2mat, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} java2mat (@var{javaobj})\n\
+@deftypefn {} {} java2mat (@var{javaobj})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_JAVA
 
   initialize_java ();
@@ -2404,19 +2404,19 @@ Undocumented internal function.\n\
 
 #endif
 
   return retval;
 }
 
 DEFUN (java_matrix_autoconversion, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} java_matrix_autoconversion ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} java_matrix_autoconversion (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} java_matrix_autoconversion (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} java_matrix_autoconversion ()\n\
+@deftypefnx {} {@var{old_val} =} java_matrix_autoconversion (@var{new_val})\n\
+@deftypefnx {} {} java_matrix_autoconversion (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Java arrays are\n\
 automatically converted to Octave matrices.\n\
 \n\
 The default value is false.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
@@ -2434,19 +2434,19 @@ The original variable value is restored 
 
 #endif
 
   return retval;
 }
 
 DEFUN (java_unsigned_autoconversion, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} java_unsigned_autoconversion ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} java_unsigned_autoconversion (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} java_unsigned_autoconversion (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} java_unsigned_autoconversion ()\n\
+@deftypefnx {} {@var{old_val} =} java_unsigned_autoconversion (@var{new_val})\n\
+@deftypefnx {} {} java_unsigned_autoconversion (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls how integer classes are\n\
 converted when @code{java_matrix_autoconversion} is enabled.\n\
 \n\
 When enabled, Java arrays of class Byte or Integer are converted to matrices\n\
 of class uint8 or uint32 respectively.  The default value is true.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
@@ -2459,19 +2459,19 @@ The original variable value is restored 
 #else
   error ("java_unsigned_autoconversion: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
 DEFUN (debug_java, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} debug_java ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} debug_java (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} debug_java (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} debug_java ()\n\
+@deftypefnx {} {@var{old_val} =} debug_java (@var{new_val})\n\
+@deftypefnx {} {} debug_java (@var{new_val}, \"local\")\n\
 Query or set the internal variable that determines whether extra debugging\n\
 information regarding the initialization of the JVM and any Java exceptions\n\
 is printed.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{java_matrix_autoconversion, java_unsigned_autoconversion}\n\
@@ -2484,17 +2484,17 @@ The original variable value is restored 
   return octave_value ();
 #endif
 }
 
 // Outside of #ifdef HAVE_JAVA because it is desirable to be able to
 // test for the presence of a Java object without having Java installed.
 DEFUN (isjava, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isjava (@var{x})\n\
+@deftypefn {} {} isjava (@var{x})\n\
 Return true if @var{x} is a Java object.\n\
 @seealso{class, typeinfo, isa, javaObject}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_java ());
diff --git a/libinterp/octave-value/ov-null-mat.cc b/libinterp/octave-value/ov-null-mat.cc
--- a/libinterp/octave-value/ov-null-mat.cc
+++ b/libinterp/octave-value/ov-null-mat.cc
@@ -90,17 +90,17 @@ octave_null_sq_str::numeric_conversion_f
 {
   return octave_base_value::type_conv_info
            (default_null_sq_str_numeric_conversion_function,
             octave_char_matrix_sq_str::static_type_id ());
 }
 
 DEFUN (isnull, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isnull (@var{x})\n\
+@deftypefn {} {} isnull (@var{x})\n\
 Return true if @var{x} is a special null matrix, string, or single quoted\n\
 string.\n\
 \n\
 Indexed assignment with such a value on the right-hand side should delete\n\
 array elements.  This function should be used when overloading indexed\n\
 assignment for user-defined classes instead of @code{isempty}, to\n\
 distinguish the cases:\n\
 \n\
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -171,17 +171,17 @@ octave_oncleanup::print_raw (std::ostrea
   os << "onCleanup (";
   if (fcn.is_defined ())
     fcn.print_raw (os, pr_as_read_syntax);
   os << ")";
 }
 
 DEFUN (onCleanup, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{obj} =} onCleanup (@var{function})\n\
+@deftypefn {} {@var{obj} =} onCleanup (@var{function})\n\
 Create a special object that executes a given function upon destruction.\n\
 \n\
 If the object is copied to multiple variables (or cell or struct array\n\
 elements) or returned from a function, @var{function} will be executed after\n\
 clearing the last copy of the object.  Note that if multiple local onCleanup\n\
 variables are created, the order in which they are called is unspecified.\n\
 For similar functionality @xref{The unwind_protect Statement}.\n\
 @end deftypefn")
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -703,19 +703,19 @@ octave_value
 octave_range::fast_elem_extract (octave_idx_type n) const
 {
   return (n < range.numel ()) ? octave_value (range.elem (n))
                               : octave_value ();
 }
 
 DEFUN (allow_noninteger_range_as_index, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} allow_noninteger_range_as_index ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} allow_noninteger_range_as_index (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} allow_noninteger_range_as_index (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} allow_noninteger_range_as_index ()\n\
+@deftypefnx {} {@var{old_val} =} allow_noninteger_range_as_index (@var{new_val})\n\
+@deftypefnx {} {} allow_noninteger_range_as_index (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether non-integer\n\
 ranges are allowed as indices.\n\
 \n\
 This might be useful for @sc{matlab} compatibility; however, it is still not\n\
 entirely compatible because @sc{matlab} treats the range expression\n\
 differently in different contexts.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -973,17 +973,17 @@ octave_matrix::map (unary_mapper_t umap)
 
     default:
       return octave_base_value::map (umap);
     }
 }
 
 DEFUN (double, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} double (@var{x})\n\
+@deftypefn {} {} double (@var{x})\n\
 Convert @var{x} to double precision type.\n\
 @seealso{single}\n\
 @end deftypefn")
 {
   // The OCTAVE_TYPE_CONV_BODY3 macro declares retval, so they go
   // inside their own scopes, and we don't declare retval here to
   // avoid a shadowed declaration warning.
 
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -1651,19 +1651,19 @@ octave_scalar_struct::fast_elem_insert_s
       return true;
     }
   else
     return false;
 }
 
 DEFUN (struct, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{s} =} struct ()\n\
-@deftypefnx {Built-in Function} {@var{s} =} struct (@var{field1}, @var{value1}, @var{field2}, @var{value2}, @dots{})\n\
-@deftypefnx {Built-in Function} {@var{s} =} struct (@var{obj})\n\
+@deftypefn  {} {@var{s} =} struct ()\n\
+@deftypefnx {} {@var{s} =} struct (@var{field1}, @var{value1}, @var{field2}, @var{value2}, @dots{})\n\
+@deftypefnx {} {@var{s} =} struct (@var{obj})\n\
 \n\
 Create a scalar or array structure and initialize its values.\n\
 \n\
 The @var{field1}, @var{field2}, @dots{} variables are strings specifying the\n\
 names of the fields and the @var{value1}, @var{value2}, @dots{} variables\n\
 can be of any type.\n\
 \n\
 If the values are cell arrays, create a structure array and initialize its\n\
@@ -1841,31 +1841,31 @@ produces a struct @strong{array}.\n\
 %!assert (isempty (fieldnames (x)))
 %!fail ('struct ("a",{1,2},"b",{1,2,3})', 'dimensions of parameter 2 do not match those of parameter 4')
 %!error <arguments must occur as "field", VALUE pairs> struct (1,2,3,4)
 %!fail ('struct ("1",2,"3")', 'struct: additional arguments must occur as "field", VALUE pairs')
 */
 
 DEFUN (isstruct, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isstruct (@var{x})\n\
+@deftypefn {} {} isstruct (@var{x})\n\
 Return true if @var{x} is a structure or a structure array.\n\
 @seealso{ismatrix, iscell, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_map ());
 }
 
 DEFUN (__fieldnames__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} __fieldnames__ (@var{struct})\n\
-@deftypefnx {Built-in Function} {} __fieldnames__ (@var{obj})\n\
+@deftypefn  {} {} __fieldnames__ (@var{struct})\n\
+@deftypefnx {} {} __fieldnames__ (@var{obj})\n\
 Internal function.\n\
 \n\
 Implements @code{fieldnames()} for structures and Octave objects.\n\
 @seealso{fieldnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -1881,18 +1881,18 @@ Implements @code{fieldnames()} for struc
   else
     retval = Cell (keys);
 
   return retval;
 }
 
 DEFUN (isfield, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} isfield (@var{x}, \"@var{name}\")\n\
-@deftypefnx {Built-in Function} {} isfield (@var{x}, @var{name})\n\
+@deftypefn  {} {} isfield (@var{x}, \"@var{name}\")\n\
+@deftypefnx {} {} isfield (@var{x}, @var{name})\n\
 Return true if the @var{x} is a structure and it includes an element named\n\
 @var{name}.\n\
 \n\
 If @var{name} is a cell array of strings then a logical array of equal\n\
 dimension is returned.\n\
 @seealso{fieldnames}\n\
 @end deftypefn")
 {
@@ -1938,17 +1938,17 @@ dimension is returned.\n\
         }
     }
 
   return retval;
 }
 
 DEFUN (numfields, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} numfields (@var{s})\n\
+@deftypefn {} {} numfields (@var{s})\n\
 Return the number of fields of the structure @var{s}.\n\
 @seealso{fieldnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     print_usage ();
@@ -1970,18 +1970,18 @@ Return the number of fields of the struc
 %!assert (isfield ({1}, "c"), false)
 %!assert (isfield (struct ("a", "1"), 10), false)
 %!assert (isfield (struct ("a", "b"), "a "), false)
 %!assert (isfield (struct ("a", 1, "b", 2), {"a", "c"}), [true, false])
 */
 
 DEFUN (cell2struct, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} cell2struct (@var{cell}, @var{fields})\n\
-@deftypefnx {Built-in Function} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
+@deftypefn  {} {} cell2struct (@var{cell}, @var{fields})\n\
+@deftypefnx {} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
 Convert @var{cell} to a structure.\n\
 \n\
 The number of fields in @var{fields} must match the number of elements in\n\
 @var{cell} along dimension @var{dim}, that is\n\
 @code{numel (@var{fields}) == size (@var{cell}, @var{dim})}.  If @var{dim}\n\
 is omitted, a value of 1 is assumed.\n\
 \n\
 @example\n\
@@ -2102,18 +2102,18 @@ A(1)\n\
 
 // FIXME: we should be including builtin-defun-decls.h but doing that
 // currently exposes a problem with dependencies in the the build system.
 extern OCTINTERP_API octave_value_list
 Fcellstr (const octave_value_list& = octave_value_list (), int = 0);
 
 DEFUN (rmfield, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{sout} =} rmfield (@var{s}, \"@var{f}\")\n\
-@deftypefnx {Built-in Function} {@var{sout} =} rmfield (@var{s}, @var{f})\n\
+@deftypefn  {} {@var{sout} =} rmfield (@var{s}, \"@var{f}\")\n\
+@deftypefnx {} {@var{sout} =} rmfield (@var{s}, @var{f})\n\
 Return a @emph{copy} of the structure (array) @var{s} with the field @var{f}\n\
 removed.\n\
 \n\
 If @var{f} is a cell array of strings or a character array, remove each of\n\
 the named fields.\n\
 @seealso{orderfields, fieldnames, isfield}\n\
 @end deftypefn")
 {
@@ -2155,37 +2155,37 @@ the named fields.\n\
 %!test
 %! y = rmfield (x, {"a", "f"});
 %! assert (fieldnames (y), {"d"; "b"; "c"});
 %! assert (size (y), [1, 6]);
 */
 
 DEFUN (struct_levels_to_print, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} struct_levels_to_print ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} struct_levels_to_print (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} struct_levels_to_print (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} struct_levels_to_print ()\n\
+@deftypefnx {} {@var{old_val} =} struct_levels_to_print (@var{new_val})\n\
+@deftypefnx {} {} struct_levels_to_print (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the number of\n\
 structure levels to display.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{print_struct_array_contents}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (struct_levels_to_print, -1,
                                             std::numeric_limits<int>::max ());
 }
 
 DEFUN (print_struct_array_contents, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} print_struct_array_contents ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} print_struct_array_contents (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} print_struct_array_contents (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} print_struct_array_contents ()\n\
+@deftypefnx {} {@var{old_val} =} print_struct_array_contents (@var{new_val})\n\
+@deftypefnx {} {} print_struct_array_contents (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies whether to print struct\n\
 array contents.\n\
 \n\
 If true, values of struct array elements are printed.  This variable does\n\
 not affect scalar structures whose elements are always printed.  In both\n\
 cases, however, printing will be limited to the number of levels specified\n\
 by @var{struct_levels_to_print}.\n\
 \n\
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -606,18 +606,18 @@ octave_value_typeinfo::do_installed_type
   for (int i = 0; i < num_types; i++)
     retval(i) = types(i);
 
   return retval;
 }
 
 DEFUN (typeinfo, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} typeinfo ()\n\
-@deftypefnx {Built-in Function} {} typeinfo (@var{expr})\n\
+@deftypefn  {} {} typeinfo ()\n\
+@deftypefnx {} {} typeinfo (@var{expr})\n\
 \n\
 Return the type of the expression @var{expr}, as a string.\n\
 \n\
 If @var{expr} is omitted, return a cell array of strings containing all the\n\
 currently installed data types.\n\
 @seealso{class, isa}\n\
 @end deftypefn")
 {
diff --git a/libinterp/octave-value/ov-uint16.cc b/libinterp/octave-value/ov-uint16.cc
--- a/libinterp/octave-value/ov-uint16.cc
+++ b/libinterp/octave-value/ov-uint16.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_uint16>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint16_scalar,
                                      "uint16 scalar", "uint16");
 
 DEFUN (uint16, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} uint16 (@var{x})\n\
+@deftypefn {} {} uint16 (@var{x})\n\
 Convert @var{x} to unsigned 16-bit integer type.\n\
 @seealso{int8, uint8, int16, int32, uint32, int64, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint16);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-uint32.cc b/libinterp/octave-value/ov-uint32.cc
--- a/libinterp/octave-value/ov-uint32.cc
+++ b/libinterp/octave-value/ov-uint32.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_uint32>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint32_scalar,
                                      "uint32 scalar", "uint32");
 
 DEFUN (uint32, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} uint32 (@var{x})\n\
+@deftypefn {} {} uint32 (@var{x})\n\
 Convert @var{x} to unsigned 32-bit integer type.\n\
 @seealso{int8, uint8, int16, uint16, int32, int64, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint32);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-uint64.cc b/libinterp/octave-value/ov-uint64.cc
--- a/libinterp/octave-value/ov-uint64.cc
+++ b/libinterp/octave-value/ov-uint64.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_uint64>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint64_scalar,
                                      "uint64 scalar", "uint64");
 
 DEFUN (uint64, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} uint64 (@var{x})\n\
+@deftypefn {} {} uint64 (@var{x})\n\
 Convert @var{x} to unsigned 64-bit integer type.\n\
 @seealso{int8, uint8, int16, uint16, int32, uint32, int64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint64);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-uint8.cc b/libinterp/octave-value/ov-uint8.cc
--- a/libinterp/octave-value/ov-uint8.cc
+++ b/libinterp/octave-value/ov-uint8.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_uint8>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint8_scalar,
                                      "uint8 scalar", "uint8");
 
 DEFUN (uint8, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} uint8 (@var{x})\n\
+@deftypefn {} {} uint8 (@var{x})\n\
 Convert @var{x} to unsigned 8-bit integer type.\n\
 @seealso{int8, int16, uint16, int32, uint32, int64, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint8);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -791,18 +791,18 @@ octave_user_function::restore_warning_st
 
       for (octave_idx_type i = 0; i < m.numel (); i++)
         Fwarning (ovl (states(i), ids(i)));
     }
 }
 
 DEFUN (nargin, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} nargin ()\n\
-@deftypefnx {Built-in Function} {} nargin (@var{fcn})\n\
+@deftypefn  {} {} nargin ()\n\
+@deftypefnx {} {} nargin (@var{fcn})\n\
 Report the number of input arguments to a function.\n\
 \n\
 Called from within a function, return the number of arguments passed to the\n\
 function.  At the top level, return the number of command line arguments\n\
 passed to Octave.\n\
 \n\
 If called with the optional argument @var{fcn}---a function name or handle---\n\
 return the declared number of arguments that the function can accept.\n\
@@ -878,18 +878,18 @@ Programming Note: @code{nargin} does not
         retval = 0;
     }
 
   return retval;
 }
 
 DEFUN (nargout, args, ,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} nargout ()\n\
-@deftypefnx {Built-in Function} {} nargout (@var{fcn})\n\
+@deftypefn  {} {} nargout ()\n\
+@deftypefnx {} {} nargout (@var{fcn})\n\
 Report the number of output arguments from a function.\n\
 \n\
 Called from within a function, return the number of values the caller expects\n\
 to receive.  At the top level, @code{nargout} with no argument is undefined\n\
 and will produce an error.\n\
 \n\
 If called with the optional argument @var{fcn}---a function name or\n\
 handle---return the number of declared output values that the function can\n\
@@ -1015,19 +1015,19 @@ returns -1 for all anonymous functions.\
         error ("nargout: invalid call at top level");
     }
 
   return retval;
 }
 
 DEFUN (optimize_subsasgn_calls, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} optimize_subsasgn_calls ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} optimize_subsasgn_calls (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} optimize_subsasgn_calls (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} optimize_subsasgn_calls ()\n\
+@deftypefnx {} {@var{old_val} =} optimize_subsasgn_calls (@var{new_val})\n\
+@deftypefnx {} {} optimize_subsasgn_calls (@var{new_val}, \"local\")\n\
 Query or set the internal flag for subsasgn method call optimizations.\n\
 \n\
 If true, Octave will attempt to eliminate the redundant copying when calling\n\
 the subsasgn method of a user-defined class.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
@@ -1053,17 +1053,17 @@ static bool isargout1 (int nargout, cons
       return false;
     }
   else
     return (k == 1 || k <= nargout) && ! val_in_table (ignored, k);
 }
 
 DEFUN (isargout, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isargout (@var{k})\n\
+@deftypefn {} {} isargout (@var{k})\n\
 Within a function, return a logical value indicating whether the argument\n\
 @var{k} will be assigned to a variable on output.\n\
 \n\
 If the result is false, the argument has been ignored during the function\n\
 call through the use of the tilde (~) special output argument.  Functions\n\
 can use @code{isargout} to avoid performing unnecessary calculations for\n\
 outputs which are unwanted.\n\
 \n\
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2917,17 +2917,17 @@ install_types (void)
   octave_oncleanup::register_type ();
 #ifdef HAVE_JAVA
   octave_java::register_type ();
 #endif
 }
 
 DEFUN (sizeof, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} sizeof (@var{val})\n\
+@deftypefn {} {} sizeof (@var{val})\n\
 Return the size of @var{val} in bytes.\n\
 @seealso{whos}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).byte_size ());
@@ -3003,17 +3003,17 @@ decode_subscripts (const char* name, con
     }
   else
     error ("%s: second argument must be a structure with fields 'type' and 'subs'",
            name);
 }
 
 DEFUN (subsref, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} subsref (@var{val}, @var{idx})\n\
+@deftypefn {} {} subsref (@var{val}, @var{idx})\n\
 Perform the subscripted element selection operation according to the\n\
 subscript specified by @var{idx}.\n\
 \n\
 The subscript @var{idx} is expected to be a structure array with fields\n\
 @samp{type} and @samp{subs}.  Valid values for @samp{type} are\n\
 @samp{\"()\"}, @samp{\"@{@}\"}, and @samp{\".\"}.  The @samp{subs} field may\n\
 be either @samp{\":\"} or a cell array of index values.\n\
 \n\
@@ -3059,17 +3059,17 @@ If @var{idx} is an empty structure array
   else
     retval = arg0.subsref (type, idx, nargout);
 
   return retval;
 }
 
 DEFUN (subsasgn, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} subsasgn (@var{val}, @var{idx}, @var{rhs})\n\
+@deftypefn {} {} subsasgn (@var{val}, @var{idx}, @var{rhs})\n\
 Perform the subscripted assignment operation according to the subscript\n\
 specified by @var{idx}.\n\
 \n\
 The subscript @var{idx} is expected to be a structure array with fields\n\
 @samp{type} and @samp{subs}.  Valid values for @samp{type} are\n\
 @samp{\"()\"}, @samp{\"@{@}\"}, and @samp{\".\"}.  The @samp{subs} field may\n\
 be either @samp{\":\"} or a cell array of index values.\n\
 \n\
@@ -3187,17 +3187,17 @@ If @var{idx} is an empty structure array
 %! t.a = "Hello";
 %! t.b = "There";
 %! t.c = 163;
 %! assert (s, t);
 */
 
 DEFUN (is_sq_string, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} is_sq_string (@var{x})\n\
+@deftypefn {} {} is_sq_string (@var{x})\n\
 Return true if @var{x} is a single-quoted character string.\n\
 @seealso{is_dq_string, ischar}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_sq_string ());
@@ -3210,17 +3210,17 @@ Return true if @var{x} is a single-quote
 %!assert (is_sq_string ({2.0}), false)
 
 %!error is_sq_string ()
 %!error is_sq_string ('foo', 2)
 */
 
 DEFUN (is_dq_string, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} is_dq_string (@var{x})\n\
+@deftypefn {} {} is_dq_string (@var{x})\n\
 Return true if @var{x} is a double-quoted character string.\n\
 @seealso{is_sq_string, ischar}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return octave_value (args(0).is_dq_string ());
@@ -3233,19 +3233,19 @@ Return true if @var{x} is a double-quote
 %!assert (is_dq_string ({2.0}), false)
 
 %!error is_dq_string ()
 %!error is_dq_string ("foo", 2)
 */
 
 DEFUN (disable_permutation_matrix, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} disable_permutation_matrix ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} disable_permutation_matrix (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} disable_permutation_matrix (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} disable_permutation_matrix ()\n\
+@deftypefnx {} {@var{old_val} =} disable_permutation_matrix (@var{new_val})\n\
+@deftypefnx {} {} disable_permutation_matrix (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether permutation\n\
 matrices are stored in a special space-efficient format.\n\
 \n\
 The default value is true.  If this option is disabled Octave will store\n\
 permutation matrices as full matrices.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
@@ -3263,19 +3263,19 @@ The original variable value is restored 
 %!endfunction
 
 %!assert (typeinfo (__test_dpm__ (false)), "permutation matrix");
 %!assert (typeinfo (__test_dpm__ (true)), "matrix");
 */
 
 DEFUN (disable_diagonal_matrix, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} disable_diagonal_matrix ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} disable_diagonal_matrix (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} disable_diagonal_matrix (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} disable_diagonal_matrix ()\n\
+@deftypefnx {} {@var{old_val} =} disable_diagonal_matrix (@var{new_val})\n\
+@deftypefnx {} {} disable_diagonal_matrix (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether diagonal\n\
 matrices are stored in a special space-efficient format.\n\
 \n\
 The default value is true.  If this option is disabled Octave will store\n\
 diagonal matrices as full matrices.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
@@ -3307,19 +3307,19 @@ The original variable value is restored 
 %!assert (typeinfo (x), "matrix");
 %!assert (typeinfo (xi), "complex matrix");
 %!assert (typeinfo (fx), "float matrix");
 %!assert (typeinfo (fxi), "float complex matrix");
 */
 
 DEFUN (disable_range, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} disable_range ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} disable_range (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} disable_range (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} disable_range ()\n\
+@deftypefnx {} {@var{old_val} =} disable_range (@var{new_val})\n\
+@deftypefnx {} {} disable_range (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether ranges are stored\n\
 in a special space-efficient format.\n\
 \n\
 The default value is true.  If this option is disabled Octave will store\n\
 ranges as full matrices.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -196,17 +196,17 @@ intern_argv (int argc, char **argv)
       int i = argc;
       while (--i > 0)
         octave_argv[i-1] = *(argv+i);
     }
 }
 
 DEFUN (__version_info__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {retval =} __version_info__ (@var{name}, @var{version}, @var{release}, @var{date})\n\
+@deftypefn {} {retval =} __version_info__ (@var{name}, @var{version}, @var{release}, @var{date})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   static octave_map vinfo;
 
   int nargin = args.length ();
@@ -1005,17 +1005,17 @@ int
 octave_starting_gui (void)
 {
   start_gui = check_starting_gui ();
   return start_gui;
 }
 
 DEFUN (isguirunning, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isguirunning ()\n\
+@deftypefn {} {} isguirunning ()\n\
 Return true if Octave is running in GUI mode and false otherwise.\n\
 @seealso{have_window_system}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 0)
     print_usage ();
@@ -1027,17 +1027,17 @@ Return true if Octave is running in GUI 
 
 /*
 %!assert (islogical (isguirunning ()))
 %!error isguirunning (1)
 */
 
 DEFUN (argv, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} argv ()\n\
+@deftypefn {} {} argv ()\n\
 Return the command line arguments passed to Octave.\n\
 \n\
 For example, if you invoked Octave using the command\n\
 \n\
 @example\n\
 octave --no-line-editing --silent\n\
 @end example\n\
 \n\
@@ -1062,17 +1062,17 @@ an example of how to create an executabl
 
 /*
 %!assert (iscellstr (argv ()))
 %!error argv (1)
 */
 
 DEFUN (program_invocation_name, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} program_invocation_name ()\n\
+@deftypefn {} {} program_invocation_name ()\n\
 Return the name that was typed at the shell prompt to run Octave.\n\
 \n\
 If executing a script from the command line (e.g., @code{octave foo.m})\n\
 or using an executable Octave script, the program name is set to the\n\
 name of the script.  @xref{Executable Octave Programs}, for an example of\n\
 how to create an executable Octave script.\n\
 @seealso{program_name}\n\
 @end deftypefn")
@@ -1089,17 +1089,17 @@ how to create an executable Octave scrip
 
 /*
 %!assert (ischar (program_invocation_name ()))
 %!error program_invocation_name (1)
 */
 
 DEFUN (program_name, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} program_name ()\n\
+@deftypefn {} {} program_name ()\n\
 Return the last component of the value returned by\n\
 @code{program_invocation_name}.\n\
 @seealso{program_invocation_name}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 0)
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -123,17 +123,17 @@ tree_argument_list::is_valid_lvalue_list
 }
 
 static const octave_value *indexed_object = 0;
 static int index_position = 0;
 static int num_indices = 0;
 
 DEFCONSTFUN (end, , ,
              "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} end\n\
+@deftypefn {} {} end\n\
 The magic index @qcode{\"end\"} refers to the last valid entry in an indexing\n\
 operation.\n\
 \n\
 Example:\n\
 \n\
 @example\n\
 @group\n\
 @var{x} = [ 1 2 3\n\
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -264,19 +264,19 @@ tree_boolean_expression::dup (symbol_tab
 
   new_be->copy_base (*this);
 
   return new_be;
 }
 
 DEFUN (do_braindead_shortcircuit_evaluation, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} do_braindead_shortcircuit_evaluation ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} do_braindead_shortcircuit_evaluation (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} do_braindead_shortcircuit_evaluation (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} do_braindead_shortcircuit_evaluation ()\n\
+@deftypefnx {} {@var{old_val} =} do_braindead_shortcircuit_evaluation (@var{new_val})\n\
+@deftypefnx {} {} do_braindead_shortcircuit_evaluation (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
 do short-circuit evaluation of @samp{|} and @samp{&} operators inside the\n\
 conditions of if or while statements.\n\
 \n\
 This feature is only provided for compatibility with @sc{matlab} and should\n\
 not be used unless you are porting old code that relies on this feature.\n\
 \n\
 To obtain short-circuit behavior for logical expressions in new programs,\n\
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -1188,19 +1188,19 @@ tree_evaluator::do_breakpoint (bool is_b
 octave_value
 tree_evaluator::do_keyboard (const octave_value_list& args) const
 {
   return ::do_keyboard (args);
 }
 
 DEFUN (max_recursion_depth, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} max_recursion_depth ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} max_recursion_depth (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} max_recursion_depth (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} max_recursion_depth ()\n\
+@deftypefnx {} {@var{old_val} =} max_recursion_depth (@var{new_val})\n\
+@deftypefnx {} {} max_recursion_depth (@var{new_val}, \"local\")\n\
 Query or set the internal limit on the number of times a function may\n\
 be called recursively.\n\
 \n\
 If the limit is exceeded, an error message is printed and control returns to\n\
 the top level.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
@@ -1219,19 +1219,19 @@ The original variable value is restored 
 %! max_recursion_depth (orig_val);
 %! assert (max_recursion_depth (), orig_val);
 
 %!error (max_recursion_depth (1, 2))
 */
 
 DEFUN (silent_functions, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} silent_functions ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} silent_functions (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} silent_functions (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} silent_functions ()\n\
+@deftypefnx {} {@var{old_val} =} silent_functions (@var{new_val})\n\
+@deftypefnx {} {} silent_functions (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether internal\n\
 output from a function is suppressed.\n\
 \n\
 If this option is disabled, Octave will display the results produced by\n\
 evaluating expressions within a function body that are not terminated with\n\
 a semicolon.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -1341,19 +1341,19 @@ tree_matrix::accept (tree_walker& tw)
 %!assert (isnull ([;]))
 %!assert (isnull ([;;]))
 %!assert (isnull ([;,;]))
 %!assert (isnull ([,;,;,]))
 */
 
 DEFUN (string_fill_char, args, nargout,
        "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{val} =} string_fill_char ()\n\
-@deftypefnx {Built-in Function} {@var{old_val} =} string_fill_char (@var{new_val})\n\
-@deftypefnx {Built-in Function} {} string_fill_char (@var{new_val}, \"local\")\n\
+@deftypefn  {} {@var{val} =} string_fill_char ()\n\
+@deftypefnx {} {@var{old_val} =} string_fill_char (@var{new_val})\n\
+@deftypefnx {} {} string_fill_char (@var{new_val}, \"local\")\n\
 Query or set the internal variable used to pad all rows of a character\n\
 matrix to the same length.\n\
 \n\
 The value must be a single character and the default is @qcode{\" \"} (a\n\
 single space).  For example:\n\
 \n\
 @example\n\
 @group\n\
