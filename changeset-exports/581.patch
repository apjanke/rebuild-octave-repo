# HG changeset patch
# User jwe
# Date 776221335 0
#      Sun Aug 07 01:02:15 1994 +0000
# Node ID bc813f5eb025f8612ed4764663f1ca01c3ba4887
# Parent  b0204e676508394c726f60852be8148cc6f59c81
[project @ 1994-08-07 01:02:15 by jwe]

diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -20,39 +20,47 @@ along with Octave; see the file COPYING.
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
-#include <stdio.h>
-#include <stdlib.h>
+#include <strstream.h>
 #include <stdarg.h>
 
 #include "utils.h"
 #include "error.h"
 #include "pager.h"
 #include "oct-obj.h"
 #include "tree-const.h"
 #include "defun.h"
 
 // Current error state.
 int error_state;
 
 static void
 verror (const char *name, const char *fmt, va_list args)
 {
-  if (name)
-    fprintf (stderr, "%s: ", name);
+  cerr << name << ": ";
+  cerr.vform (fmt, args);
+  cerr << endl;
+
+  ostrstream output_buf;
 
-  vfprintf (stderr, fmt, args);
-  fprintf (stderr, "\n");
-  fflush (stderr);
+  output_buf << name << ": ";
+  output_buf.vform (fmt, args);
+  output_buf << endl;
+
+  char *msg = output_buf.str ();
+
+  maybe_write_to_diary_file (msg);
+
+  delete [] msg;
 }
 
 void
 message (const char *name, const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   verror (name, fmt, args);
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -25,17 +25,18 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "config.h"
 #endif
 
 #include <signal.h>
 #include <stdlib.h>
 #include <iostream.h>
 #include <strstream.h>
 
-#include "tree.h"
+#include "tree-expr.h"
+#include "tree-const.h"
 #include "sighandlers.h"
 #include "user-prefs.h"
 #include "tree-expr.h"
 #include "variables.h"
 #include "oct-obj.h"
 #include "symtab.h"
 #include "octave.h"
 #include "dirfns.h"
@@ -244,19 +245,18 @@ static help_list keywords[] =
     "Return from a function.\n", },
 
   { "while",
     "Begin a while loop.\n", },
 
   { 0, 0, },
 };
 
-/*
- * Return a copy of the operator or keyword names.
- */
+// Return a copy of the operator or keyword names.
+
 char **
 names (help_list *lst, int& count)
 {
   count = 0;
   help_list *ptr = lst;
   while (ptr->name)
     {
       count++;
@@ -551,94 +551,245 @@ print cryptic yet witty messages")
 		  signal (SIGINT, old_sigint_handler);
 		}
 	    }
 	}
       else
 	{
 	  ostrstream output_buf;
 
-	  char *fcn_file_name = 0;
-	  symbol_record *sym_rec;
 	  help_list *op_help_list = operator_help ();
 	  help_list *kw_help_list = keyword_help ();
 
 	  while (--argc > 0)
 	    {
 	      argv++;
 
 	      if (! *argv || ! **argv)
 		continue;
 
 	      if (help_from_list (output_buf, op_help_list, *argv, 0))
 		continue;
 
 	      if (help_from_list (output_buf, kw_help_list, *argv, 0))
 		continue;
 
-	      sym_rec = curr_sym_tab->lookup (*argv, 0, 0);
+	      symbol_record *sym_rec = lookup_by_name (*argv);
+
 	      if (sym_rec)
 		{
 		  char *h = sym_rec->help ();
 		  if (h && *h)
 		    {
 		      output_buf << "\n*** " << *argv << ":\n\n"
 				 << h << "\n";
 		      continue;
 		    }
 		}
 
-	      sym_rec = global_sym_tab->lookup (*argv, 0, 0);
-	      if (sym_rec && ! symbol_out_of_date (sym_rec))
-		{
-		  char *h = sym_rec->help ();
-		  if (h && *h)
-		    {
-		      output_buf << "\n*** " << *argv << ":\n\n"
-				 << h << "\n";
-		      continue;
-		    }
-		}
-
-// Try harder to find function files that might not be defined yet, or
-// that appear to be out of date.  Don\'t execute commands from the
-// file if it turns out to be a script file.
-
-	      fcn_file_name = fcn_file_in_path (*argv);
-	      if (fcn_file_name)
-		{
-		  sym_rec = global_sym_tab->lookup (*argv, 1, 0);
-		  if (sym_rec)
-		    {
-		      tree_identifier tmp (sym_rec);
-		      tmp.load_fcn_from_file (0);
-		      char *h = sym_rec->help ();
-		      if (h && *h)
-			{
-			  output_buf << "\n*** " << *argv << ":\n\n"
-				     << h << "\n"; 
-			  continue;
-			}
-		    }
-		}
-	      delete [] fcn_file_name;
-
 	      output_buf << "\nhelp: sorry, `" << *argv
-			 << "' is not documented\n"; 
+		<< "' is not documented\n"; 
 	    }
 
 	  additional_help_message (output_buf);
 	  output_buf << ends;
 	  maybe_page_output (output_buf);
 	}
     }
 
   DELETE_ARGV;
 
   return retval;
 }
 
+DEFUN_TEXT ("type", Ftype, Stype, -1, 1,
+  "type NAME ...]\n\
+\n\
+display the definition of each NAME that refers to a function")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("type");
+
+  if (argc > 1)
+    {
+// XXX FIXME XXX -- we should really use getopt ()
+      int quiet = 0;
+      if (argv[1] && strcmp (argv[1], "-q") == 0)
+	{
+	  quiet = 1;
+	  argc--;
+	  argv++;
+	}
+
+      ostrstream output_buf;
+
+      while (--argc > 0)
+	{
+	  argv++;
+
+	  if (! *argv || ! **argv)
+	    continue;
+
+	  symbol_record *sym_rec = lookup_by_name (*argv);
+
+	  if (sym_rec)
+	    {
+	      if (sym_rec->is_user_function ())
+		{
+		  tree_fvc *defn = sym_rec->def ();
+
+		  if (nargout == 0 && ! quiet)
+		    output_buf << *argv << " is a user-defined function\n";
+
+		  defn->print_code (output_buf);
+		}
+
+// XXX FIXME XXX -- this code should be shared with Fwhich
+
+	      else if (sym_rec->is_text_function ())
+		output_buf << *argv << " is a builtin text-function\n";
+	      else if (sym_rec->is_builtin_function ())
+		output_buf << *argv << " is a builtin function\n";
+	      else if (sym_rec->is_user_variable ())
+		output_buf << *argv << " is a user-defined variable\n";
+	      else if (sym_rec->is_builtin_variable ())
+		output_buf << *argv << " is a builtin variable\n";
+	      else
+		output_buf << "type: `" << *argv << "' has unknown type!\n";
+	    }
+	  else
+	    output_buf << "type: `" << *argv << "' undefined\n";
+	}
+
+      output_buf << ends;
+
+      if (nargout == 0)
+	maybe_page_output (output_buf);
+      else
+	{
+	  char *s = output_buf.str ();
+	  retval = s;
+	  delete s;
+	}
+    }
+  else
+    print_usage ("type");
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
+DEFUN_TEXT ("which", Fwhich, Swhich, -1, 1,
+  "which NAME ...]\n\
+\n\
+display the type of each NAME.  If NAME is defined from an function\n\
+file, print the full name of the file.")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("which");
+
+  if (argc > 1)
+    {
+      if (nargout > 0)
+	retval.resize (argc-1, Matrix ());
+
+      ostrstream output_buf;
+
+      for (int i = 0; i < argc-1; i++)
+	{
+	  argv++;
+
+	  if (! *argv || ! **argv)
+	    continue;
+
+	  symbol_record *sym_rec = lookup_by_name (*argv);
+
+	  if (sym_rec)
+	    {
+	      if (sym_rec->is_user_function ())
+		{
+		  tree_fvc *defn = sym_rec->def ();
+		  char *fn = defn->fcn_file_name ();
+		  if (fn)
+		    {
+		      char *ff = fcn_file_in_path (fn);
+		      ff = ff ? ff : fn;
+
+		      if (nargout == 0)
+			output_buf << *argv
+			  << " is the function defined from:\n"
+			    << ff << "\n";
+		      else
+			retval(i) = ff;
+		    }
+		  else
+		    {
+		      if (nargout == 0)
+			output_buf << *argv << " is a user-defined function\n";
+		      else
+			retval(i) = "user-defined function";
+		    }
+		}
+	      else if (sym_rec->is_text_function ())
+		{
+		  if (nargout == 0)
+		    output_buf << *argv << " is a builtin text-function\n";
+		  else
+		    retval(i) = "builtin text-function";
+		}
+	      else if (sym_rec->is_builtin_function ())
+		{
+		  if (nargout == 0)
+		    output_buf << *argv << " is a builtin function\n";
+		  else
+		    retval(i) = "builtin function";
+		}
+	      else if (sym_rec->is_user_variable ())
+		{
+		  if (nargout == 0)
+		    output_buf << *argv << " is a user-defined variable\n";
+		  else
+		    retval(i) = "user-defined variable";
+		}
+	      else if (sym_rec->is_builtin_variable ())
+		{
+		  if (nargout == 0)
+		    output_buf << *argv << " is a builtin variable\n";
+		  else
+		    retval(i) = "builtin variable";
+		}
+	      else
+		{
+		  if (nargout == 0)
+		    output_buf << "which: `" << *argv
+		      << "' has unknown type\n";
+		  else
+		    retval(i) = "unknown type";
+		}
+	    }
+	  else
+	    {
+	      if (nargout == 0)
+		output_buf << "which: `" << *argv << "' is undefined\n";
+	      else
+		retval(i) = "undefined";
+	    }
+	}
+      output_buf << ends;
+      maybe_page_output (output_buf);
+    }
+  else
+    print_usage ("which");
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -43,20 +43,19 @@ extern "C"
 {
 #include "readline/readline.h"
 #include "readline/history.h"
 
 extern void free_undo_list ();
 
 extern char *xmalloc ();
 
-/*
- * Yes, this sucks, but it avoids a conflict with another readline
- * function declared in iostream.h.
- */
+// Yes, this sucks, but it avoids a conflict with another readline
+// function declared in iostream.h.
+
 #if 0
 #define LINE_SIZE 8192
 static int no_line_editing = 0;
 #endif
 
 char *
 gnu_readline (char *s)
 {
@@ -147,22 +146,21 @@ int promptflag = 1;
 char *current_input_line = 0;
 
 // A line of input from readline.
 static char *octave_gets_line = 0;
 
 extern tree_constant eval_string (const char *string, int print,
 				  int ans_assign, int& parse_status);
 
-/*
- * Append SOURCE to TARGET at INDEX.  SIZE is the current amount of
- * space allocated to TARGET.  SOURCE can be NULL, in which case
- * nothing happens.  Gets rid of SOURCE by free ()ing it.  Returns
- * TARGET in case the location has changed.
- */
+// Append SOURCE to TARGET at INDEX.  SIZE is the current amount of
+// space allocated to TARGET.  SOURCE can be NULL, in which case
+// nothing happens.  Gets rid of SOURCE by free ()ing it.  Returns
+// TARGET in case the location has changed.
+
 static char *
 sub_append_string (char *source, char *target, int *index, int *size)
 {
   if (source)
     {
       while ((int)strlen (source) >= (int)(*size - *index))
 	{
 	  char *tmp = new char [*size += DEFAULT_ARRAY_SIZE];
@@ -174,20 +172,19 @@ sub_append_string (char *source, char *t
       strcat (target, source);
       *index += strlen (source);
 
       delete [] source;
     }
   return target;
 }
 
-/*
- * Return the octal number parsed from STRING, or -1 to indicate that
- * the string contained a bad number.
- */
+// Return the octal number parsed from STRING, or -1 to indicate that
+// the string contained a bad number.
+
 int
 read_octal (const char *string)
 {
   int result = 0;
   int digits = 0;
 
   while (*string && *string >= '0' && *string < '8')
     {
@@ -196,34 +193,33 @@ read_octal (const char *string)
     }
 
   if (! digits || result > 0777 || *string)
     result = -1;
 
   return result;
 }
 
-/*
- * Return a string which will be printed as a prompt.  The string may
- * contain special characters which are decoded as follows: 
- *   
- *	\t	the time
- *	\d	the date
- *	\n	CRLF
- *	\s	the name of the shell (program)
- *	\w	the current working directory
- *	\W	the last element of PWD
- *	\u	your username
- *	\h	the hostname
- *	\#	the command number of this command
- *	\!	the history number of this command
- *	\$	a $ or a # if you are root
- *	\<octal> character code in octal
- *	\\	a backslash
- */
+// Return a string which will be printed as a prompt.  The string may
+// contain special characters which are decoded as follows: 
+//   
+//	\t	the time
+//	\d	the date
+//	\n	CRLF
+//	\s	the name of the shell (program)
+//	\w	the current working directory
+//	\W	the last element of PWD
+//	\u	your username
+//	\h	the hostname
+//	\#	the command number of this command
+//	\!	the history number of this command
+//	\$	a $ or a # if you are root
+//	\<octal> character code in octal
+//	\\	a backslash
+
 static char *
 decode_prompt_string (const char *string)
 {
   int result_size = PROMPT_GROWTH;
   int result_index = 0;
   char *result = new char [PROMPT_GROWTH];
   int c;
   char *temp = 0;
@@ -380,17 +376,17 @@ decode_prompt_string (const char *string
 	      temp[1] = c;
 
 	    add_string:
 	      if (c)
 		string++;
 	      result =
 		(char *)sub_append_string (temp, result,
 					   &result_index, &result_size);
-	      temp = 0; /* Free ()'ed in sub_append_string (). */
+	      temp = 0; // Free ()'ed in sub_append_string ().
 	      result[result_index] = '\0';
 	      break;
 	    }
 	}
       else
 	{
 	  while (3 + result_index > result_size)
 	    {
@@ -400,35 +396,35 @@ decode_prompt_string (const char *string
 	      result = tmp;
 	    }
 	  result[result_index++] = c;
 	  result[result_index] = '\0';
 	}
     }
 
 #if 0
-  /* I don't really think that this is a good idea.  Do you? */
+// I don't really think that this is a good idea.  Do you?
   if (! find_variable ("NO_PROMPT_VARS"))
     {
       WORD_LIST *expand_string (), *list;
       char *string_list ();
 
       list = expand_string (result, 1);
       free (result);
       result = string_list (list);
       dispose_words (list);
     }
 #endif
 
   return result;
 }
-/*
- * Use GNU readline to get an input line and store it in the history
- * list.
- */
+
+// Use GNU readline to get an input line and store it in the history
+// list.
+
 static char *
 octave_gets (void)
 {
   if (octave_gets_line)
     {
       free (octave_gets_line);
       octave_gets_line = 0;
     }
@@ -439,42 +435,49 @@ octave_gets (void)
       char *prompt = decode_prompt_string (ps);
 
       if (interactive)
 	{
 	  pipe_handler_error_count = 0;
 	  flush_output_to_pager ();
 	}
 
+      maybe_write_to_diary_file (prompt);
+
       octave_gets_line = gnu_readline (prompt);
+
       delete [] prompt;
     }
   else
     octave_gets_line = gnu_readline ("");
 
   current_input_line = octave_gets_line;
 
   if (octave_gets_line && *octave_gets_line)
     {
       maybe_save_history (octave_gets_line);
 
+      maybe_write_to_diary_file (octave_gets_line);
+
       if (echo_input)
 	{
 	  if (! forced_interactive)
 	    cout << "+ ";
 
 	  cout << octave_gets_line << "\n";
 	}
     }
+
+  maybe_write_to_diary_file ("\n");
+  
   return octave_gets_line;
 }
 
-/*
- * Read a line from the input stream.
- */
+// Read a line from the input stream.
+
 int
 octave_read (char *buf, int max_size)
 {
   int status = 0;
 
   static char *stashed_line = 0;
 
   if (get_input_from_eval_string)
@@ -556,20 +559,19 @@ octave_read (char *buf, int max_size)
 
 	  cout << current_input_line << "\n";
 	}
     }
   input_line_number++;
   return status;
 }
 
-/*
- * Fix things up so that input can come from file `name', printing a
- * warning if the file doesn't exist.
- */
+// Fix things up so that input can come from file `name', printing a
+// warning if the file doesn't exist.
+
 FILE *
 get_input_from_file (char *name, int warn)
 {
   FILE *instream = 0;
 
   if (name && *name)
     instream = fopen (name, "r");
 
@@ -579,21 +581,20 @@ get_input_from_file (char *name, int war
   if (reading_fcn_file || reading_script_file)
     ff_instream = instream;
   else
     rl_instream = instream;
 
   return instream;
 }
 
-/*
- * Fix things up so that input can come from the standard input.  This
- * may need to become much more complicated, which is why it's in a
- * separate function.
- */
+// Fix things up so that input can come from the standard input.  This
+// may need to become much more complicated, which is why it's in a
+// separate function.
+
 FILE *
 get_input_from_stdin (void)
 {
   rl_instream = stdin;
   return rl_instream;
 }
 
 static char *
@@ -638,21 +639,19 @@ command_generator (char *text, int state
 static char **
 command_completer (char *text, int start, int end)
 {
   char **matches = 0;
   matches = completion_matches (text, command_generator);
   return matches;
 }
 
-/*
- * The next two functions implement the equivalent of the K*rn shell
- * C-o operate-and-get-next-history-line editing command.  Stolen from
- * the GNU Bourne Again SHell.
- */
+// The next two functions implement the equivalent of the K*rn shell
+// C-o operate-and-get-next-history-line editing command.  Stolen from
+// the GNU Bourne Again SHell.
 
 // ??
 static int saved_history_line_to_use = 0;
 
 // ??
 static Function *old_rl_startup_hook = 0;
 
 static void
@@ -686,20 +685,20 @@ set_saved_history (void)
 }
 
 static void
 operate_and_get_next (int count, int c)
 {
   int where;
   extern int history_stifled, history_length, max_input_history;
 
-  /* Accept the current line. */
+// Accept the current line.
   rl_newline ();
 
-  /* Find the current line, and find the next line to use. */
+// Find the current line, and find the next line to use.
   where = where_history ();
 
   if (history_stifled && (history_length >= max_input_history))
     saved_history_line_to_use = where;
   else
     saved_history_line_to_use = where + 1;
 
   old_rl_startup_hook = rl_startup_hook;
@@ -731,16 +730,18 @@ match_sans_spaces (const char *standard,
   while (*ep == ' ' || *ep == '\t')
     ep--;
 
   int len = ep - tp + 1;
 
   return (strncmp (standard, tp, len) == 0);
 }
 
+// If the user simply hits return, this will produce an empty matrix.
+
 static Octave_object
 get_user_input (const Octave_object& args, int nargout, int debug = 0)
 {
   tree_constant retval;
 
   int nargin = args.length ();
 
   int read_as_string = 0;
@@ -785,18 +786,23 @@ get_user_input (const Octave_object& arg
 	  || match_sans_spaces ("return", input_buf))
 	return tree_constant ();
       else if (read_as_string)
 	retval = input_buf;
       else
 	{
 	  int parse_status = 0;
 	  retval = eval_string (input_buf, 0, 0, parse_status);
-	  if (debug && retval.is_defined ())
-	    retval.eval (1);
+	  if (retval.is_defined ())
+	    {
+	      if (debug)
+		retval.eval (1);
+	    }
+	  else
+	    retval = tree_constant (Matrix ());
 	}
     }
   else
     error ("input: reading user-input failed!");
 
   if (debug)
     goto again;
 
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -418,17 +418,17 @@ EXPON	([DdEe][+-]?{D}+)
 			  double value;
 			  int nread = sscanf (yytext, "%lf", &value);
 			  assert (nread == 1);
 			  quote_is_transpose = 1;
 			  cant_be_identifier = 1;
 			  convert_spaces_to_comma = 1;
 			  if (plotting && ! in_plot_range)
 			    past_plot_range = 1;
-			  yylval.tok_val = new token (value,
+			  yylval.tok_val = new token (value, yytext,
 						      input_line_number,
 						      current_input_column);
 			  token_stack.push (yylval.tok_val);
 			  current_input_column += yyleng;
 			  do_comma_insert_check ();
 			  return IMAG_NUM;
 			}
 
@@ -439,17 +439,17 @@ EXPON	([DdEe][+-]?{D}+)
 			  double value;
 			  int nread = sscanf (yytext, "%lf", &value);
 			  assert (nread == 1);
 			  quote_is_transpose = 1;
 			  cant_be_identifier = 1;
 			  convert_spaces_to_comma = 1;
 			  if (plotting && ! in_plot_range)
 			    past_plot_range = 1;
-			  yylval.tok_val = new token (value,
+			  yylval.tok_val = new token (value, yytext,
 						      input_line_number,
 						      current_input_column);
 			  token_stack.push (yylval.tok_val);
 			  current_input_column += yyleng;
 			  do_comma_insert_check ();
 			  return NUM;
 			}
 
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -33,26 +33,26 @@ Software Foundation, Inc.
 #endif
 
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <fcntl.h>
 #include <stdlib.h>
-#include <stdio.h>
 #include <string.h>
 #include <signal.h>
 #include <fstream.h>
 #include <strstream.h>
 
 #include "statdefs.h"
 #include "utils.h"
 #include "error.h"
 #include "input.h"
+#include "pager.h"
 #include "octave.h"
 #include "oct-obj.h"
 #include "user-prefs.h"
 #include "unwind-prot.h"
 #include "octave-hist.h"
 #include "sighandlers.h"
 #include "defun.h"
 
@@ -74,20 +74,19 @@ static int octave_hist_size = 1024;
 static char *octave_hist_file;
 
 // The number of hisory lines we read from the history file.
 static int history_lines_in_file = 0;
 
 // The number of history lines we've saved so far.
 static int history_lines_this_session = 0;
 
-/*
- * Get some default values, possibly reading them from the
- * environment.
- */
+// Get some default values, possibly reading them from the
+// environment.
+
 static int
 default_history_size (void)
 {
   int size = 1024;
   char *env_size = getenv ("OCTAVE_HISTSIZE");
   if (env_size)
     {
       int val;
@@ -114,19 +113,18 @@ default_history_file (void)
     }
 
   if (! file && home_directory)
     file = strconcat (home_directory, "/.octave_hist");
 
   return file;
 }
 
-/*
- * Prime the history list.
- */
+// Prime the history list.
+
 void
 initialize_history (void)
 {
   octave_hist_file = default_history_file ();
   octave_hist_size = default_history_size ();
 
   read_history (octave_hist_file);
   using_history ();
@@ -145,23 +143,22 @@ maybe_save_history (char *s)
 {
   if (saving_history)
     {
       add_history (s);
       history_lines_this_session++;
     }
 }
 
-/*
- * Display, save, or load history.  Stolen and modified from bash.
- *
- * Arg of -w FILENAME means write file, arg of -r FILENAME
- * means read file, arg of -q means don't number lines.  Arg of N
- * means only display that many items. 
- */
+// Display, save, or load history.  Stolen and modified from bash.
+//
+// Arg of -w FILENAME means write file, arg of -r FILENAME
+// means read file, arg of -q means don't number lines.  Arg of N
+// means only display that many items. 
+
 void
 do_history (int argc, char **argv)
 {
   HIST_ENTRY **hlist;
 
   int numbered_output = 1;
 
   while (--argc > 0)
@@ -266,33 +263,38 @@ do_history (int argc, char **argv)
 	limit = -limit;
 
       if (!limited)
 	i = 0;
       else
 	if ((i -= limit) < 0)
 	  i = 0;
 
+      ostrstream output_buf;
+
       while (hlist[i])
 	{
 //	  QUIT;  // in bash: (interrupt_state) throw_to_top_level ();
 
 	  if (numbered_output)
-	    cerr.form ("%5d%c", i + history_base, hlist[i]->data ? '*' : ' ');
-	  cerr << hlist[i]->line << "\n";
+	    output_buf.form ("%5d%c", i + history_base,
+			     hlist[i]->data ? '*' : ' '); 
+	  output_buf << hlist[i]->line << "\n";
 	  i++;
 	}
+
+      output_buf << ends;
+      maybe_page_output (output_buf);
     }
 }
 
-/*
- * Read the edited history lines from STREAM and return them
- * one at a time.  This can read unlimited length lines.  The
- *  caller should free the storage.
- */
+// Read the edited history lines from STREAM and return them
+// one at a time.  This can read unlimited length lines.  The
+//  caller should free the storage.
+
 static char *
 edit_history_readline (fstream& stream)
 {
   char c;
   int line_len = 128;
   int lindex = 0;
   char *line = new char [line_len];
   line[0] = '\0';
@@ -338,40 +340,38 @@ edit_history_readline (fstream& stream)
   return line;
 }
 
 extern "C"
 {
   HIST_ENTRY *history_get ();
 }
 
-/*
- * Use `command' to replace the last entry in the history list, which,
- * by this time, is `run_history blah...'.  The intent is that the
- * new command become the history entry, and that `fc' should never
- * appear in the history list.  This way you can do `run_history' to
- * your heart's content.
- */ 
+// Use `command' to replace the last entry in the history list, which,
+// by this time, is `run_history blah...'.  The intent is that the
+// new command become the history entry, and that `fc' should never
+// appear in the history list.  This way you can do `run_history' to
+// your heart's content.
+
 static void
 edit_history_repl_hist (char *command)
 {
   if (! command || ! *command)
     return;
 
   HIST_ENTRY **hlist = history_list ();
 
   if (! hlist)
     return;
 
   for (int i = 0; hlist[i]; i++)
     ; // Count 'em.
   i--;
 
-  /* History_get () takes a parameter that should be
-     offset by history_base. */
+// History_get () takes a parameter that should be offset by history_base.
 
 // Don't free this.
   HIST_ENTRY *histent = history_get (history_base + i);
   if (! histent)
     return;
 
   char *data = 0;
   if (histent->data)
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -166,19 +166,18 @@ static struct option long_opts[] =
     { "norc", 0, 0, 'f' },
     { "path", 1, 0, 'p' },
     { "quiet", 0, 0, 'q' },
     { "version", 0, 0, 'v' },
     { "echo-commands", 0, 0, 'x' },
     { 0, 0, 0, 0 }
   };
 
-/*
- * Initialize some global variables for later use.
- */
+// Initialize some global variables for later use.
+
 static void
 initialize_globals (char *name)
 {
   struct passwd *entry = getpwuid (getuid ());
   if (entry)
     user_name = strsave (entry->pw_name);
   else
     user_name = strsave ("I have no name!");
@@ -276,19 +275,18 @@ parse_and_execute (char *s, int print, i
 
       if (verbose)
 	cout << "done." << endl;
     }
 
   run_unwind_frame ("parse_and_execute_2");
 }
 
-/*
- * Initialize by reading startup files.
- */
+// Initialize by reading startup files.
+
 static void
 execute_startup_files (void)
 {
   begin_unwind_frame ("execute_startup_files");
 
   unwind_protect_int (input_from_startup_file);
   input_from_startup_file = 1;
 
@@ -319,19 +317,18 @@ execute_startup_files (void)
   stat ("./.octaverc", &dot_rc_statbuf);
 
   if (home_rc_statbuf.st_ino != dot_rc_statbuf.st_ino)
     parse_and_execute ("./.octaverc", 0, verbose);
 
   run_unwind_frame ("execute_startup_files");
 }
 
-/*
- * Usage message with extra help.
- */
+// Usage message with extra help.
+
 static void
 verbose_usage (void)
 {
   cout << "\n"
        << "  Octave, version " << version_string
        << ".  Copyright (C) 1992, 1993, 1994 John W. Eaton.\n"
        << "  This is free software with ABSOLUTELY NO WARRANTY.\n"
        << "\n"
@@ -346,38 +343,38 @@ verbose_usage (void)
        << "     x : echo commands as they are executed\n"
        << "\n"
        << "  file : execute commands from named file\n"
        << "\n";
 
   exit (1);
 }
 
-/*
- * Terse usage messsage.
- */
+// Terse usage messsage.
+
 static void
 usage (void)
 {
   cerr << "usage: " << usage_string << "\n";
   exit (1);
 }
 
-/*
- * Fix up things before exiting.
- */
+// Fix up things before exiting.
+
 void
 clean_up_and_exit (int retval)
 {
   raw_mode (0);
 
   clean_up_history ();
 
   close_plot_stream ();
 
+  close_diary_file ();
+
   close_files ();
 
   cleanup_tmp_files ();
 
   if (!quitting_gracefully && (interactive || forced_interactive))
     cout << "\n";
 
   if (retval == EOF)
@@ -393,19 +390,18 @@ clean_up_and_exit (int retval)
 
 static void
 print_version_and_exit (void)
 {
   cout << "octave, version " << version_string << "\n";
   exit (0);
 }
 
-/*
- * You guessed it.
- */
+// You guessed it.
+
 int
 main (int argc, char **argv)
 {
 // Allow for system dependent initialization.  See sysdep.cc for more
 // details.
   sysdep_init ();
 
 // This is not really the right place to do this...
@@ -461,28 +457,28 @@ main (int argc, char **argv)
 
 #if defined (HAVE_ATEXIT) || (HAVE_ON_EXIT)
 // Make sure we clean up when we exit.  If we don't have atexit or
 // on_exit, we're going to leave some junk files around if we exit
 // abnormally.
   atexit (cleanup_tmp_files);
 #endif
 
+  initialize_pager ();
+
   initialize_history ();
 
   initialize_file_io ();
 
-  initialize_symbol_tables ();
+  initialize_symbol_tables ();  
 
   install_builtins ();
 
   initialize_readline ();
 
-  initialize_pager ();
-
   install_signal_handlers ();
 
   if (! inhibit_startup_message)
     cout << "Octave, version " << version_string
 	 << ".  Copyright (C) 1992, 1993, 1994 John W. Eaton.\n"
 	 << "This is free software with ABSOLUTELY NO WARRANTY.\n"
 	 << "For details, type `warranty'.\n" << endl;
 
@@ -763,19 +759,18 @@ DEFUN ("eval", Feval, Seval, 2, 1,
       retval = eval_string (args(1), parse_status);
     }
   else
     print_usage ("eval");
 
   return retval;
 }
 
-/*
- * Execute a shell command.
- */
+// Execute a shell command.
+
 DEFUN ("shell_cmd", Fshell_cmd, Sshell_cmd, 2, 1,
   "shell_cmd (string [, return_output]): execute shell commands")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 && args(1).is_string_type ())
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -22,48 +22,62 @@ Software Foundation, 675 Mass Ave, Cambr
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include <iostream.h>
 #include <strstream.h>
+#include <fstream.h>
 #include <stdlib.h>
 
 #include "procstream.h"
 
 #include "user-prefs.h"
+#include "oct-obj.h"
+#include "error.h"
+#include "defun.h"
 #include "input.h"
 #include "pager.h"
+#include "utils.h"
+#include "help.h"
 
 // Where we stash output headed for the screen.
 static ostrstream *pager_buf = 0;
 
+// Nonzero means we write to the diary file.
+static int write_to_diary_file = 0;
+
+// The name of the current diary file.
+static char *diary_file = "diary";
+
+// The diary file.
+static ofstream diary_stream;
+
 static int
 line_count (char *s)
 {
   int count = 0;
   if (s)
     {
       char c;
       while ((c = *s++) != '\0')
 	if (c == '\n')
 	  count++;
     }
   return count;
 }
 
-/*
- * For now, use the variables from readline.  It already handles
- * SIGWINCH, so these values have a good chance of being correct even
- * if the window changes size (they will be wrong if, for example, the
- * luser changes the window size while the pager is running, and the
- * signal is handled by the pager instead of us.
- */
+// For now, use the variables from readline.  It already handles
+// SIGWINCH, so these values have a good chance of being correct even
+// if the window changes size (they will be wrong if, for example, the
+// luser changes the window size while the pager is running, and the
+// signal is handled by the pager instead of us.
+
 int
 terminal_columns (void)
 {
   extern int screenwidth;
   return screenwidth > 0 ? screenwidth : 80;
 }
 
 int
@@ -111,16 +125,18 @@ flush_output_to_pager (void)
 
   if (! message || ! *message)
     {
       delete [] message;
       initialize_pager ();
       return;
     }
 
+  maybe_write_to_diary_file (message);
+
   int nlines = line_count (message);
 
   if (nlines > terminal_rows () - 2)
     {
       char *pgr = user_pref.pager_binary;
       if (pgr)
 	{
 	  oprocstream pager_stream (pgr);
@@ -137,14 +153,84 @@ flush_output_to_pager (void)
     }
 
   cout << message;
   cout.flush ();
   delete [] message;
   initialize_pager ();
 }
 
+static void
+open_diary_file (void)
+{
+  if (diary_stream.is_open ())
+    diary_stream.close ();
+
+  diary_stream.open (diary_file, ios::app);
+
+  if (! diary_stream)
+    error ("diary: can't open diary file `%s'", diary_file);
+}
+
+void
+close_diary_file (void)
+{
+  if (diary_stream)
+    diary_stream.close ();
+}
+
+void
+maybe_write_to_diary_file (const char *s)
+{
+  if (write_to_diary_file && diary_stream)
+    diary_stream << s;
+}
+
+DEFUN_TEXT ("diary", Fdiary, Sdiary, -1, 1,
+  "diary [on|off]\n\
+diary [file]\n\
+\n\
+redirect all input and screen output to a file.")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("diary");
+
+  switch (argc)
+    {
+    case 1:
+      write_to_diary_file = ! write_to_diary_file;
+      open_diary_file ();
+      break;
+    case 2:
+      {
+	char *arg = argv[1];
+	if (strcmp (arg, "on") == 0)
+	  {
+	    write_to_diary_file = 1;
+	    open_diary_file ();
+	  }	
+	else if (strcmp (arg, "off") == 0)
+	  write_to_diary_file = 0;
+	else
+	  {
+	    delete [] diary_file;
+	    diary_file = strsave (arg);
+	    open_diary_file ();
+	  }
+      }
+      break;
+    default:
+      print_usage ("diary");
+      break;
+    }
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/pager.h b/src/pager.h
--- a/src/pager.h
+++ b/src/pager.h
@@ -28,16 +28,19 @@ class ostrstream;
 
 extern char *get_pager (void);
 extern int terminal_columns (void);
 extern int terminal_rows (void);
 extern void initialize_pager (void);
 extern void maybe_page_output (ostrstream& msg_buf);
 extern void flush_output_to_pager (void);
 
+extern void close_diary_file (void);
+extern void maybe_write_to_diary_file (const char *s);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -27,35 +27,38 @@ Software Foundation, 675 Mass Ave, Cambr
  */
 %{
 #define YYDEBUG 1
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
+#include <strstream.h>
+
 #include "SLStack.h"
 
 #include "Matrix.h"
 
-#include "error.h"
-#include "octave.h"
-#include "variables.h"
 #include "octave-hist.h"
 #include "user-prefs.h"
+#include "tree-const.h"
+#include "tree-misc.h"
+#include "variables.h"
+#include "tree-plot.h"
+#include "octave.h"
+#include "symtab.h"
+#include "parse.h"
+#include "token.h"
+#include "error.h"
+#include "pager.h"
 #include "input.h"
 #include "utils.h"
 #include "tree.h"
-#include "tree-misc.h"
-#include "tree-plot.h"
-#include "tree-const.h"
-#include "symtab.h"
-#include "parse.h"
 #include "lex.h"
-#include "token.h"
 
 // Nonzero means we're in the middle of defining a function.
 int defining_func = 0;
 
 // Nonzero means we're in the middle of defining a loop.
 int looping = 0;
 
 // Nonzero means we're in the middle of defining a conditional expression.
@@ -558,17 +561,17 @@ global_decl1	: global_decl2
 		  { $1->append ($3); }
 
 global_decl2	: identifier
 		  { $$ = new tree_global ($1); }
 		| identifier '=' expression
 		  {
 		    tree_simple_assignment_expression *tmp_ass;
 		    tmp_ass = new tree_simple_assignment_expression
-		      ($1, $3, 0, $2->line (), $2->column ());
+		      ($1, $3, 0, 0, $2->line (), $2->column ());
 		    $$ = new tree_global (tmp_ass);
 		  }
 		;
 
 optcomma	: // empty
 		| ','
 		  {
 		    if (user_pref.warn_comma_in_global_decl)
@@ -688,17 +691,17 @@ sep		: ','
 		;
 
 screwed_again	: // empty
 		  { maybe_screwed_again++; }
 		;
 
 expression	: variable '=' expression
 		  { $$ = new tree_simple_assignment_expression
-		      ($1, $3, 0, $2->line (), $2->column ()); }
+		      ($1, $3, 0, 0, $2->line (), $2->column ()); }
 		| '[' screwed_again matrix_row SCREW_TWO '=' expression
 		  {
 
 // Will need a way to convert the matrix list to a list of
 // identifiers.	 If that fails, we can abort here, without losing
 // anything -- no other possible syntax is valid if we've seen the
 // equals sign as the next token after the `]'.
 
@@ -779,25 +782,33 @@ simple_expr	: simple_expr1
 		  { $$ = make_binary_op (EXPR_OR_OR, $1, $2, $3); }
 		| simple_expr EXPR_AND simple_expr
 		  { $$ = make_binary_op (EXPR_AND, $1, $2, $3); }
 		| simple_expr EXPR_OR simple_expr
 		  { $$ = make_binary_op (EXPR_OR, $1, $2, $3); }
 		;
 
 simple_expr1	: NUM
-		  { $$ = new tree_constant ($1->number ()); }
+		  {
+		    tree_constant *tmp = new tree_constant ($1->number ());
+		    tmp->stash_original_text ($1->text_rep ());
+		    $$ = tmp;
+		  }
 		| IMAG_NUM
-		  { $$ = new tree_constant (Complex (0.0, $1->number ())); }
+		  {
+		    Complex c (0.0, $1->number ());
+		    tree_constant *tmp = new tree_constant (c);
+		    tmp->stash_original_text ($1->text_rep ());
+		    $$ = tmp;
+		  }
 		| TEXT
 		  { $$ = new tree_constant ($1->string ()); }
 		| '(' expression ')'
 		  {
-		    if ($2->is_assignment_expression ())
-		      ((tree_assignment_expression *) $2) -> in_parens++;
+		    $2->in_parens++;
 		    $$ = $2;
 		  }
 		| word_list_cmd
 		  { $$ = $1; }
 		| variable
 		  { $$ = $1; }
 		| matrix
 		  { $$ = $1; }
@@ -1124,40 +1135,45 @@ matrix_row	: expression		// First elemen
 static void
 yyerror (char *s)
 {
   char *line = current_input_line;
   int err_col = current_input_column - 1;
   if (err_col == 0 && line)
     err_col = strlen (line) + 1;
 
-// Print a message like `parse error'.
-  fprintf (stderr, "\n%s", s);
+// Print a message like `parse error', maybe printing the line number
+// and file name.
+
+  ostrstream output_buf;
 
-// Maybe print the line number and file name.
+  output_buf.form ("\n%s", s);
+
   if (reading_fcn_file || reading_script_file)
-    fprintf (stderr, " near line %d of file %s.m", input_line_number,
-	     curr_fcn_file_name);
+    output_buf.form (" near line %d of file %s.m", input_line_number,
+		     curr_fcn_file_name);
 
   if (line)
     {
       int len = strlen (line);
       if (line[len-1] == '\n')
         {
           len--;
           line[len] = '\0';
         }
 // Print the line, maybe with a pointer near the error token.
       if (err_col > len)
-        fprintf (stderr, ":\n\n  %s\n\n", line);
+        output_buf.form (":\n\n  %s\n\n", line);
       else
-        fprintf (stderr, ":\n\n  %s\n  %*s\n\n", line, err_col, "^");
+        output_buf.form (":\n\n  %s\n  %*s\n\n", line, err_col, "^");
     }
   else
-    fprintf (stderr, "\n\n");
+    output_buf << "\n\n";
+
+  maybe_page_output (output_buf);
 }
 
 static void
 end_error (char *type, token::end_tok_type ettype, int l, int c)
 {
   static char *fmt = "%s command matched by `%s' near line %d column %d";
 
   switch (ettype)
@@ -1247,26 +1263,26 @@ maybe_convert_to_ans_assign (tree_expres
   else
     {
       symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
 
       assert (sr);
       
       tree_identifier *ans = new tree_identifier (sr);
 
-      return new tree_simple_assignment_expression (ans, expr);
+      return new tree_simple_assignment_expression (ans, expr, 0, 1);
     }
 }
 
 static void
 maybe_warn_assign_as_truth_value (tree_expression *expr)
 {
   if (user_pref.warn_assign_as_truth_value
       && expr->is_assignment_expression ()
-      && ((tree_assignment_expression *) expr) -> in_parens < 2)
+      && expr->in_parens < 2)
     {
       warning ("suggest parenthesis around assignment used as truth value");
     }
 }
 
 static tree_expression *
 make_binary_op (int op, tree_expression *op1, token *tok_val,
 		tree_expression *op2)
diff --git a/src/pt-base.h b/src/pt-base.h
--- a/src/pt-base.h
+++ b/src/pt-base.h
@@ -19,36 +19,65 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (octave_tree_base_h)
 #define octave_tree_base_h 1
 
-class tree_constant;
+class ostream;
+
+// How to print the code that the trees represent.
+
+class
+tree_print_code
+{
+public:
+  virtual ~tree_print_code (void) { }
+
+  virtual void print_code (ostream& os) = 0;
+
+  void reset_indent_level (void)
+    { curr_print_indent_level = 0; }
+
+  void increment_indent_level (void)
+    { curr_print_indent_level += 2; }
 
-/*
- * Base class for the parse tree.
- */
+  void decrement_indent_level (void)
+    { curr_print_indent_level -= 2; }
+
+  void print_code_new_line (ostream& os);
+
+  void print_code_indent (ostream& os);
+
+  void print_code_reset (void);
+
+private:
+  static int curr_print_indent_level;
+  static int beginning_of_line;
+};
+
+// Base class for the parse tree.
+
 class
-tree
+tree : public tree_print_code
 {
 public:
   tree (int l = -1, int c = -1)
     {
       line_num = l;
       column_num = c;
     }
 
-  virtual ~tree (void) { }
+  virtual int line (void) const
+    { return line_num; }
 
-  virtual int line (void) const { return line_num; }
-
-  virtual int column (void) const { return column_num; }
+  virtual int column (void) const
+    { return column_num; }
 
 private:
   int line_num;
   int column_num;
 };
 
 #endif
 
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -109,16 +109,27 @@ tree_global_command::eval (void)
   if (init_list)
     init_list->eval ();
 
   if (error_state > 0)
     ::error ("evaluating global command near line %d, column %d",
 	     line (), column ());
 }
 
+void
+tree_global_command::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  os << "global ";
+
+  if (init_list)
+    init_list->print_code (os);
+}
+
 // While.
 
 tree_while_command::~tree_while_command (void)
 {
   delete expr;
   delete list;
 }
 
@@ -190,16 +201,40 @@ tree_while_command::eval (void)
 void
 tree_while_command::eval_error (void)
 {
   if (error_state > 0)
     ::error ("evaluating while command near line %d, column %d",
 	     line (), column ());
 }
 
+void
+tree_while_command::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  os << "while ";
+
+  if (expr)
+    expr->print_code (os);
+
+  print_code_new_line (os);
+
+  if (list)
+    {
+      increment_indent_level ();
+      list->print_code (os);
+      decrement_indent_level ();
+    }
+
+  print_code_indent (os);
+
+  os << "endwhile";
+}
+
 // For.
 
 tree_for_command::~tree_for_command (void)
 {
   delete id;
   delete expr;
   delete list;
 }
@@ -337,16 +372,45 @@ tree_for_command::do_for_loop_once (tree
 	  quit = 1;
 	  return;
 	}
     }
 
   quit = quit_loop_now ();
 }
 
+void
+tree_for_command::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  os << "for ";
+
+  if (id)
+    id->print_code (os);
+
+  os << " = ";
+
+  if (expr)
+    expr->print_code (os);
+
+  print_code_new_line (os);
+
+  if (list)
+    {
+      increment_indent_level ();
+      list->print_code (os);
+      decrement_indent_level ();
+    }
+
+  print_code_indent (os);
+
+  os << "endfor";
+}
+
 // If.
 
 tree_if_command::~tree_if_command (void)
 {
   delete list;
 }
 
 void
@@ -355,41 +419,80 @@ tree_if_command::eval (void)
   if (list)
     list->eval ();
 
   if (error_state > 0)
     ::error ("evaluating if command near line %d, column %d",
 	     line (), column ());
 }
 
+void
+tree_if_command::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  os << "if ";
+
+  if (list)
+    list->print_code (os);
+
+  print_code_indent (os);
+
+  os << "endif";
+}
+
 // Break.
 
 void
 tree_break_command::eval (void)
 {
   if (! error_state)
     breaking = 1;
 }
 
+void
+tree_break_command::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  os << "break";
+}
+
 // Continue.
 
 void
 tree_continue_command::eval (void)
 {
   if (! error_state)
     continuing = 1;
 }
 
+void
+tree_continue_command::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  os << "continue";
+}
+
 // Return.
 
 void
 tree_return_command::eval (void)
 {
   if (! error_state)
     returning = 1;
 }
 
+void
+tree_return_command::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  os << "return";
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/pt-cmd.h b/src/pt-cmd.h
--- a/src/pt-cmd.h
+++ b/src/pt-cmd.h
@@ -23,16 +23,18 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (octave_tree_cmd_h)
 #define octave_tree_cmd_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
+#include <iostream.h>
+
 class tree_statement_list;
 class tree_global_init_list;
 class tree_if_command_list;
 class tree_expression;
 class tree_index_expression;
 class tree_constant;
 class symbol_record;
 
@@ -68,16 +70,18 @@ tree_global_command : public tree_comman
   tree_global_command (tree_global_init_list *t, int l = -1, int c = -1)
     : tree_command (l, c)
       { init_list = t; }
 
   ~tree_global_command (void);
 
   void eval (void);
 
+  void print_code (ostream& os);
+
 private:
   tree_global_init_list *init_list;
 };
 
 // While.
 
 class
 tree_while_command : public tree_command
@@ -105,16 +109,18 @@ tree_while_command : public tree_command
       }
 
   ~tree_while_command (void);
 
   void eval (void);
 
   void eval_error (void);
 
+  void print_code (ostream& os);
+
  private:
   tree_expression *expr;	// Expression to test.
   tree_statement_list *list;	// List of commands to execute.
 };
 
 // For.
 
 class
@@ -138,16 +144,18 @@ tree_for_command : public tree_command
       }
 
   ~tree_for_command (void);
 
   void eval (void);
 
   void eval_error (void);
 
+  void print_code (ostream& os);
+
  private:
   void do_for_loop_once (tree_constant *rhs, int& quit);
 
   tree_index_expression *id;	// Identifier to modify.
   tree_expression *expr;	// Expression to evaluate.
   tree_statement_list *list;	// List of commands to execute.
 };
 
@@ -165,57 +173,65 @@ tree_if_command : public tree_command
       { list = lst; }
 
   ~tree_if_command (void);
 
   void eval (void);
 
   void eval_error (void);
 
+  void print_code (ostream& os);
+
  private:
   tree_if_command_list *list;
 };
 
 // Break.
 
 class
 tree_break_command : public tree_command
 {
  public:
   tree_break_command (int l = -1, int c = -1) : tree_command (l, c) { }
 
   ~tree_break_command (void) { }
 
   void eval (void);
+
+  void print_code (ostream& os);
 };
 
 // Continue.
 
 class
 tree_continue_command : public tree_command
 {
  public:
   tree_continue_command (int l = -1, int c = -1) : tree_command (l, c) { }
 
   ~tree_continue_command (void) { }
 
   void eval (void);
+
+  void print_code (ostream& os);
 };
 
 // Return.
 
 class
 tree_return_command : public tree_command
 {
 public:
   tree_return_command (int l = -1, int c = -1) : tree_command (l, c) { }
 
   ~tree_return_command (void) { }
 
   void eval (void);
+
+  void print_code (ostream& os);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -24,16 +24,18 @@ Software Foundation, 675 Mass Ave, Cambr
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
+#include <iostream.h>
+
 #include "tree-const.h"
 #include "error.h"
 #include "gripes.h"
 #include "user-prefs.h"
 
 tree_constant::~tree_constant (void)
 {
 #if defined (MDEBUG)
@@ -60,20 +62,19 @@ tree_constant::operator new (size_t size
 void
 tree_constant::operator delete (void *p, size_t size)
 {
   cerr << "tree_constant::delete(): " << p << "\n";
   ::delete p;
 }
 #endif
 
-/*
- * Construct return vector of empty matrices.  Return empty matrices
- * and/or gripe when appropriate.
- */
+// Construct return vector of empty matrices.  Return empty matrices
+// and/or gripe when appropriate.
+
 Octave_object
 vector_of_empties (int nargout, const char *fcn_name)
 {
   Octave_object retval;
 
 // Got an empty argument, check if should gripe/return empty values.
 
   int flag = user_pref.propagate_empty_matrices;
@@ -88,14 +89,29 @@ vector_of_empties (int nargout, const ch
 	retval(i) = m;
     }
   else
     gripe_empty_arg (fcn_name, 1);
 
   return retval;
 }
 
+void
+tree_constant::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  if (in_parens)
+    os << "(";
+
+  if (rep)
+    rep->print_code (os);
+
+  if (in_parens)
+    os << ")";
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -23,79 +23,78 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (octave_tree_const_h)
 #define octave_tree_const_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
+#include <iostream.h>
+
 #include <stdlib.h>
 
 #include "mx-base.h"
 #include "Range.h"
 
 #include "tree-base.h"
 #include "tree-expr.h"
 #include "tc-rep.h"
 #include "oct-obj.h"
 
 class idx_vector;
 
 struct Mapper_fcn;
 
-/*
- * Constants.
- */
+// Constants.
+
 class
 tree_constant : public tree_fvc
 {
 friend class tree_constant_rep;
 
 public:
-  tree_constant (void)
+  tree_constant (void) : tree_fvc ()
     { rep = new tree_constant_rep (); rep->count = 1; }
 
-  tree_constant (double d)
+  tree_constant (double d) : tree_fvc ()
     { rep = new tree_constant_rep (d); rep->count = 1; }
-  tree_constant (const Matrix& m)
+  tree_constant (const Matrix& m) : tree_fvc ()
     { rep = new tree_constant_rep (m); rep->count = 1; }
-  tree_constant (const DiagMatrix& d)
+  tree_constant (const DiagMatrix& d) : tree_fvc ()
     { rep = new tree_constant_rep (d); rep->count = 1; }
-  tree_constant (const RowVector& v, int pcv = -1)
+  tree_constant (const RowVector& v, int pcv = -1) : tree_fvc ()
     { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
-  tree_constant (const ColumnVector& v, int pcv = -1)
+  tree_constant (const ColumnVector& v, int pcv = -1) : tree_fvc ()
     { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
 
-  tree_constant (const Complex& c)
+  tree_constant (const Complex& c) : tree_fvc ()
     { rep = new tree_constant_rep (c); rep->count = 1; }
-  tree_constant (const ComplexMatrix& m)
+  tree_constant (const ComplexMatrix& m) : tree_fvc ()
     { rep = new tree_constant_rep (m); rep->count = 1; }
-  tree_constant (const ComplexDiagMatrix& d)
+  tree_constant (const ComplexDiagMatrix& d) : tree_fvc ()
     { rep = new tree_constant_rep (d); rep->count = 1; }
-  tree_constant (const ComplexRowVector& v, int pcv = -1)
-    { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
-  tree_constant (const ComplexColumnVector& v, int pcv = -1)
-    { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
+  tree_constant (const ComplexRowVector& v, int pcv = -1) : tree_fvc ()
+      { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
+  tree_constant (const ComplexColumnVector& v, int pcv = -1) : tree_fvc () 
+      { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
 
-  tree_constant (const char *s)
+  tree_constant (const char *s) : tree_fvc ()
     { rep = new tree_constant_rep (s); rep->count = 1; }
 
-  tree_constant (double base, double limit, double inc)
+  tree_constant (double base, double limit, double inc) : tree_fvc ()
     { rep = new tree_constant_rep (base, limit, inc); rep->count = 1; }
-  tree_constant (const Range& r)
+  tree_constant (const Range& r) : tree_fvc ()
     { rep = new tree_constant_rep (r); rep->count = 1; }
 
-  tree_constant (tree_constant_rep::constant_type t)
+  tree_constant (tree_constant_rep::constant_type t) : tree_fvc ()
     { rep = new tree_constant_rep (t); rep->count = 1; }
 
-  tree_constant (const tree_constant& a)
+  tree_constant (const tree_constant& a) : tree_fvc ()
     { rep = a.rep; rep->count++; }
-  tree_constant (tree_constant_rep& r)
-    { rep = &r; rep->count++; }
 
   ~tree_constant (void);
 
 #if defined (MDEBUG)
   void *operator new (size_t size);
   void operator delete (void *p, size_t size);
 #endif
 
@@ -129,16 +128,19 @@ public:
 
   int is_defined (void) const { return rep->is_defined (); }
   int is_undefined (void) const { return rep->is_undefined (); }
 
   double to_scalar (void) const { return rep->to_scalar (); }
   ColumnVector to_vector (void) const { return rep->to_vector (); }
   Matrix to_matrix (void) const { return rep->to_matrix (); }
 
+  void stash_original_text (char *s)
+    { rep->stash_original_text (s); }
+
   tree_constant_rep::constant_type force_numeric (int force_str_conv = 0)
     { return rep->force_numeric (force_str_conv); }
 
   tree_constant make_numeric (int force_str_conv = 0) const
     {
       if (is_numeric_type ())
 	return *this;
       else
@@ -278,16 +280,18 @@ public:
       else
 	retval(0) = *this;
 
       if (retval(0).is_defined ())
 	retval(0).eval (print);
       return retval;
     }
 
+  void print_code (ostream& os);
+
 private:
   tree_constant_rep *rep;
 };
 
 // XXX FIXME XXX -- this is not used very much now.  Perhaps it can be
 // eliminated.
 extern Octave_object vector_of_empties (int nargout, const char *fcn_name);
 
diff --git a/src/pt-exp-base.cc b/src/pt-exp-base.cc
--- a/src/pt-exp-base.cc
+++ b/src/pt-exp-base.cc
@@ -54,21 +54,16 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "utils.h"
 #include "octave.h"
 #include "octave-hist.h"
 #include "unwind-prot.h"
 #include "parse.h"
 #include "lex.h"
 #include "defun.h"
 
-extern "C"
-{
-#include <readline/readline.h>
-}
-
 // Nonzero means we're returning from a function.
 extern int returning;
 
 // But first, some extra functions used by the tree classes.
 
 // We seem to have no use for this now.  Maybe it will be needed at
 // some future date, so here it is.
 #if 0
@@ -131,19 +126,31 @@ any_arg_is_magic_colon (const Octave_obj
   while (--nargin > 0)
     {
       if (args(nargin).const_type () == tree_constant_rep::magic_colon)
 	return 1;
     }
   return 0;
 }
 
-// NOTE: functions for the tree_constant_rep and tree_constant classes
-// are now defined in tree-const.cc.  This should help speed up
-// compilation when working only on the tree_constant class.
+// Expressions.
+
+tree_constant
+tree_expression::eval (int print)
+{
+  panic ("invalid evaluation of generic expression");
+  return tree_constant ();
+}
+
+Octave_object
+tree_expression::eval (int print, int nargout, const Octave_object& args)
+{
+  panic ("invalid evaluation of generic expression");
+  return Octave_object ();
+}
 
 // General matrices.  This list type is much more work to handle than
 // constant matrices, but it allows us to construct matrices from
 // other matrices, variables, and functions.
 
 tree_matrix::~tree_matrix (void)
 {
   delete element;
@@ -229,17 +236,17 @@ tree_matrix::to_return_list (void)
 
   return retval;
 }
 
 // Just about as ugly as it gets.
 
 struct const_matrix_list
 {
-  tree_matrix::dir dir_next;
+  tree_matrix::dir direction;
   tree_constant elem;
   int nr;
   int nc;
 };
 
 // Less ugly than before, anyway.
 
 tree_constant
@@ -302,27 +309,28 @@ tree_matrix::eval (int print)
     {
       tree_expression *elem = ptr->element;
       if (! elem)
 	{
 	  retval = tree_constant (Matrix ());
 	  goto done;
 	}
 
-      tree_constant tmp = elem->eval (0);
+      Octave_object otmp = elem->eval (0);
+      tree_constant tmp = otmp(0);
       if (error_state || tmp.is_undefined ())
 	{
 	  retval = tree_constant ();
 	  goto done;
 	}
 
       int nr = tmp.rows ();
       int nc = tmp.columns ();
 
-      dir direct = ptr->dir_next;
+      dir direct = ptr->direction;
 
       if (nr == 0 || nc == 0)
 	{
 	  if (empties_ok < 0)
 	    warning ("empty matrix found in matrix list");
 	  else if (empties_ok == 0)
 	    {
 	      ::error ("empty matrix found in matrix list");
@@ -334,20 +342,20 @@ tree_matrix::eval (int print)
 	    found_new_row_in_empties = 1;
 
 	  goto next;
 	}
 
       if (found_new_row_in_empties)
 	{
 	  found_new_row_in_empties = 0;
-	  list[len].dir_next = md_down;
+	  list[len].direction = md_down;
 	}
       else
-	list[len].dir_next = direct;
+	list[len].direction = direct;
 
       list[len].elem = tmp;
       list[len].nr = nr;
       list[len].nc = nc;
 
       if (all_strings && ! tmp.is_string_type ())
 	all_strings = 0;
 
@@ -364,17 +372,17 @@ tree_matrix::eval (int print)
 //  if (all_strings)
 //    cerr << "all strings\n";
 
 // Compute size of result matrix, and check to see that the dimensions
 // of all the elements will match up properly.
 
   for (i = 0; i < len; i++)
     {
-      dir direct = list[i].dir_next;
+      dir direct = list[i].direction;
 
       int nr = list[i].nr;
       int nc = list[i].nc;
 
       if (i == 0)
 	{
 	  row_total = nr;
 	  col_total = nc;
@@ -455,17 +463,17 @@ tree_matrix::eval (int print)
 
       if (i == 0)
 	{
 	  put_row = 0;
 	  put_col = 0;
 	}
       else
 	{
-	  switch (list[i].dir_next)
+	  switch (list[i].direction)
 	    {
 	    case md_right:
 	      put_col += prev_nc;
 	      break;
 	    case md_down:
 	      put_row += prev_nr;
 	      put_col = 0;
 	      break;
@@ -560,152 +568,85 @@ tree_matrix::eval (int print)
     retval = tree_constant (m);
 
  done:
   delete [] list;
 
   return retval;
 }
 
+void
+tree_matrix::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  if (in_parens)
+    os << "(";
+
+  os << "[";
+
+  tree_matrix *list = this;
+
+  while (list)
+    {
+      list->element->print_code (os);
+
+      list = list->next;
+
+      if (list)
+	{
+	  switch (list->direction)
+	    {
+	    case md_right:
+	      os << ", ";
+	      break;
+	    case md_down:
+	      os << "; ";
+	      break;
+	    default:
+	      break;
+	    }
+	}
+    }
+
+  os << "]";
+
+  if (in_parens)
+    os << ")";
+}
+
+// A base class for objects that can be evaluated with argument lists.
+
 tree_constant
 tree_fvc::assign (tree_constant& t, const Octave_object& args)
 {
   panic_impossible ();
   return tree_constant ();
 }
 
-// Builtin functions.
-
-tree_builtin::tree_builtin (const char *nm)
-{
-  nargin_max = -1;
-  nargout_max = -1;
-  is_mapper = 0;
-  fcn = 0;
-  if (nm)
-    my_name = strsave (nm);
-}
-
-tree_builtin::tree_builtin (int i_max, int o_max, Mapper_fcn& m_fcn,
-			    const char *nm)
-{
-  nargin_max = i_max;
-  nargout_max = o_max;
-  mapper_fcn = m_fcn;
-  is_mapper = 1;
-  fcn = 0;
-  if (nm)
-    my_name = strsave (nm);
-}
-
-tree_builtin::tree_builtin (int i_max, int o_max, Octave_builtin_fcn g_fcn,
-			    const char *nm)
-{
-  nargin_max = i_max;
-  nargout_max = o_max;
-  is_mapper = 0;
-  fcn = g_fcn;
-  if (nm)
-    my_name = strsave (nm);
-}
-
-
-tree_constant
-tree_builtin::eval (int print)
-{
-  tree_constant retval;
-
-  if (error_state)
-    return retval;
-
-  if (fcn)
-    {
-      Octave_object args;
-      args(0) = tree_constant (my_name);
-      Octave_object tmp = (*fcn) (args, 1);
-      if (tmp.length () > 0)
-	retval = tmp(0);
-    }
-  else // Assume mapper function
-    ::error ("%s: argument expected", my_name);
-
-  return retval;
-}
-
-Octave_object
-tree_builtin::eval (int print, int nargout, const Octave_object& args)
-{
-  Octave_object retval;
-
-  if (error_state)
-    return retval;
-
-  int nargin = args.length ();
-
-  if (fcn)
-    {
-      if (any_arg_is_magic_colon (args))
-	::error ("invalid use of colon in function argument list");
-      else
-	retval = (*fcn) (args, nargout);
-    }
-  else if (is_mapper)
-    {
-      if (nargin > nargin_max)
-	::error ("%s: too many arguments", my_name);
-      else if (nargin > 0 && args.length () > 0 && args(1).is_defined ())
-	{
-	  tree_constant tmp = args(1).mapper (mapper_fcn, 0);
-	  retval.resize (1);
-	  retval(0) = tmp;
-	}	
-    }
-  else
-    panic_impossible ();
-
-  return retval;
-}
-
-int
-tree_builtin::max_expected_args (void)
-{
-  int ea = nargin_max;
-  if (nargin_max < 0)
-    ea = INT_MAX;
-  else
-    ea = nargin_max;
-  return ea;
-}
-
 // Symbols from the symbol table.
 
 char *
 tree_identifier::name (void) const
 {
-  return sym->name ();
+  return sym ? sym->name () : 0;
 }
 
 tree_identifier *
 tree_identifier::define (tree_constant *t)
 {
   int status = sym->define (t);
-  if (status)
-    return this;
-  else
-    return 0;
+  return status ? this : 0;
 }
 
 tree_identifier *
 tree_identifier::define (tree_function *t)
 {
   int status = sym->define (t);
-  if (status)
-    return this;
-  else
-    return 0;
+  return status ? this : 0;
 }
 
 void
 tree_identifier::document (char *s)
 {
   if (sym && s)
     {
       char *tmp = strsave (s);
@@ -801,198 +742,24 @@ tree_identifier::bump_value (tree_expres
   if (sym)
     {
       tree_fvc *tmp = sym->def ();
       if (tmp)
 	tmp->bump_value (etype);
     }
 }
 
-static void
-gobble_leading_white_space (FILE *ffile)
-{
-  int in_comment = 0;
-  int c;
-  while ((c = getc (ffile)) != EOF)
-    {
-      if (in_comment)
-	{
-	  if (c == '\n')
-	    in_comment = 0;
-	}
-      else
-	{
-	  if (c == ' ' || c == '\t' || c == '\n')
-	    continue;
-	  else if (c == '%' || c == '#')
-	    in_comment = 1;
-	  else
-	    {
-	      ungetc (c, ffile);
-	      break;
-	    }
-	}
-    }
-}
-
-static int
-is_function_file (FILE *ffile)
-{
-  int status = 0;
-
-  gobble_leading_white_space (ffile);
-
-  long pos = ftell (ffile);
-
-  char buf [10];
-  fgets (buf, 10, ffile);
-  int len = strlen (buf);
-  if (len > 8 && strncmp (buf, "function", 8) == 0
-      && ! (isalnum (buf[8]) || buf[8] == '_'))
-    status = 1;
-
-  fseek (ffile, pos, SEEK_SET);
-
-  return status;
-}
-
-int
-tree_identifier::load_fcn_from_file (int exec_script)
-{
-  int script_file_executed = 0;
-
-  curr_fcn_file_name = name ();
-
-  char *oct_file = oct_file_in_path (curr_fcn_file_name);
-
-  int loaded_oct_file = 0;
-
-  if (oct_file)
-    {
-      cerr << "found: " << oct_file << "\n";
-
-      delete [] oct_file;
-
-// XXX FIXME XXX -- this is where we try to link to an external
-// object...
-      loaded_oct_file = 1;
-    }
-
-  if (! loaded_oct_file)
-    {
-      char *ff = fcn_file_in_path (curr_fcn_file_name);
-
-      if (ff)
-	{
-	  script_file_executed = parse_fcn_file (exec_script, ff);
-	  delete [] ff;
-	}
-
-      if (! (error_state || script_file_executed))
-	{
-	  char *foo = name ();
-	  force_link_to_function (foo);
-	}
-    }
-
-  return script_file_executed;
-}
-
-int
-tree_identifier::parse_fcn_file (int exec_script, char *ff)
-{
-  begin_unwind_frame ("parse_fcn_file");
-
-  int script_file_executed = 0;
-
-  assert (ff);
-
-// Open function file and parse.
-
-  int old_reading_fcn_file_state = reading_fcn_file;
-
-  unwind_protect_ptr (rl_instream);
-  unwind_protect_ptr (ff_instream);
-
-  unwind_protect_int (using_readline);
-  unwind_protect_int (input_line_number);
-  unwind_protect_int (current_input_column);
-  unwind_protect_int (reading_fcn_file);
-
-  using_readline = 0;
-  reading_fcn_file = 1;
-  input_line_number = 0;
-  current_input_column = 1;
-
-  FILE *ffile = get_input_from_file (ff, 0);
-
-  if (ffile)
-    {
-// Check to see if this file defines a function or is just a list of
-// commands.
-
-      if (is_function_file (ffile))
-	{
-	  unwind_protect_int (echo_input);
-	  unwind_protect_int (saving_history);
-	  unwind_protect_int (reading_fcn_file);
-
-	  echo_input = 0;
-	  saving_history = 0;
-	  reading_fcn_file = 1;
-
-	  YY_BUFFER_STATE old_buf = current_buffer ();
-	  YY_BUFFER_STATE new_buf = create_buffer (ffile);
-
-	  add_unwind_protect (restore_input_buffer, (void *) old_buf);
-	  add_unwind_protect (delete_input_buffer, (void *) new_buf);
-
-	  switch_to_buffer (new_buf);
-
-	  unwind_protect_ptr (curr_sym_tab);
-
-	  reset_parser ();
-
-	  int status = yyparse ();
-
-	  if (status != 0)
-	    {
-	      ::error ("parse error while reading function file %s", ff);
-	      global_sym_tab->clear (curr_fcn_file_name);
-	    }
-	}
-      else if (exec_script)
-	{
-// The value of `reading_fcn_file' will be restored to the proper value
-// when we unwind from this frame.
-	  reading_fcn_file = old_reading_fcn_file_state;
-
-	  unwind_protect_int (reading_script_file);
-	  reading_script_file = 1;
-
-	  parse_and_execute (ffile, 1);
-
-	  script_file_executed = 1;
-	}
-      fclose (ffile);
-    }
-
-  run_unwind_frame ("parse_fcn_file");
-
-  return script_file_executed;
-}
-
 void
 tree_identifier::eval_undefined_error (void)
 {
   char *nm = sym->name ();
   int l = line ();
   int c = column ();
   if (l == -1 && c == -1)
-    ::error ("`%s' undefined");
+    ::error ("`%s' undefined", nm);
   else
     ::error ("`%s' undefined near line %d column %d", nm, l, c);
 }
 
 // Try to find a definition for an identifier.  Here's how:
 //
 //   * If the identifier is already defined and is a function defined
 //     in an function file that has been modified since the last time 
@@ -1007,39 +774,17 @@ tree_identifier::eval_undefined_error (v
 //   * On systems that support dynamic linking, we prefer .oct files
 //     over .m files.
 
 tree_fvc *
 tree_identifier::do_lookup (int& script_file_executed)
 {
   script_file_executed = 0;
 
-  if (! sym->is_linked_to_global ())
-    {
-      if (sym->is_defined ())
-	{
-	  if (sym->is_function () && symbol_out_of_date (sym))
-	    {
-	      script_file_executed = load_fcn_from_file ();
-	    }
-	}
-      else if (! sym->is_formal_parameter ())
-	{
-	  link_to_builtin_or_function (sym);
-	  
-	  if (! sym->is_defined ())
-	    {
-	      script_file_executed = load_fcn_from_file ();
-	    }
-	  else if (sym->is_function () && symbol_out_of_date (sym))
-	    {
-	      script_file_executed = load_fcn_from_file ();
-	    }
-	}
-    }
+  int script_file_executed = lookup (sym);
 
   tree_fvc *ans = 0;
 
   if (! script_file_executed)
     ans = sym->def ();
 
   return ans;
 }
@@ -1080,25 +825,29 @@ tree_identifier::eval (int print)
       else
 	eval_undefined_error ();
     }
 
   if (! error_state && retval.is_defined ())
     {
       if (maybe_do_ans_assign && ! ans->is_constant ())
 	{
+
+// XXX FIXME XXX -- need a procedure to do this, probably in
+// variables.cc, to isolate the code that does lookups...
+
 	  symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
 
 	  assert (sr);
 
 	  tree_identifier *ans_id = new tree_identifier (sr);
 
 	  tree_constant *tmp = new tree_constant (retval);
 
-	  tree_simple_assignment_expression tmp_ass (ans_id, tmp);
+	  tree_simple_assignment_expression tmp_ass (ans_id, tmp, 0, 1);
 
 	  tmp_ass.eval (print);
 
 	  delete ans_id;  // XXX FIXME XXX
 	}
       else
 	{
 	  if (print)
@@ -1159,41 +908,1157 @@ tree_identifier::eval (int print, int na
 // Don't count the output arguments that we create automatically.
 
 	      nargout = 0;
 
 	      retval = ans->eval (0, nargout, args);
 
 	      if (retval.length () > 0 && retval(0).is_defined ())
 		{
+
+// XXX FIXME XXX -- need a procedure to do this, probably in
+// variables.cc, to isolate the code that does lookups...
+
 		  symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
 
 		  assert (sr);
       
 		  tree_identifier *ans_id = new tree_identifier (sr);
 
 		  tree_constant *tmp = new tree_constant (retval(0));
 
-		  tree_simple_assignment_expression tmp_ass (ans_id, tmp);
+		  tree_simple_assignment_expression tmp_ass (ans_id,
+							     tmp, 0, 1);
 
 		  tmp_ass.eval (print);
 
 		  delete ans_id;  // XXX FIXME XXX
 		}
 	    }
 	  else
 	    retval = ans->eval (print, nargout, args);
 	}
       else
 	eval_undefined_error ();
     }
 
   return retval;
 }
 
+void
+tree_identifier::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  if (in_parens)
+    os << "(";
+
+  char *nm = name ();
+  os << (nm) ? nm : "(null)";
+
+  if (in_parens)
+    os << ")";
+}
+
+// Index expressions.
+
+tree_index_expression::~tree_index_expression (void)
+{
+  delete id;
+  delete list;
+}
+
+tree_constant
+tree_index_expression::eval (int print)
+{
+  tree_constant retval;
+
+  if (error_state)
+    return retval;
+
+  if (list)
+    {
+// Extract the arguments into a simple vector.
+      Octave_object args = list->convert_to_const_vector ();
+// Don't pass null arguments.
+      int nargin = args.length ();
+      if (error_state)
+	eval_error ();
+      else if (nargin > 1 && all_args_defined (args))
+	{
+	  Octave_object tmp = id->eval (print, 1, args);
+
+	  if (error_state)
+	    eval_error ();
+
+	  if (tmp.length () > 0)
+	    retval = tmp(0);
+	}
+    }
+  else
+    {
+      retval = id->eval (print);
+      if (error_state)
+	eval_error ();
+    }
+
+  return retval;
+}
+
+Octave_object
+tree_index_expression::eval (int print, int nargout, const Octave_object& args)
+{
+  Octave_object retval;
+
+  if (error_state)
+    return retval;
+
+  if (list)
+    {
+// Extract the arguments into a simple vector.
+      Octave_object args = list->convert_to_const_vector ();
+// Don't pass null arguments.
+      if (error_state)
+	eval_error ();
+      else if (args.length () > 1 && all_args_defined (args))
+	{
+	  retval = id->eval (print, nargout, args);
+	  if (error_state)
+	    eval_error ();
+	}
+    }
+  else
+    {
+      Octave_object tmp_args;
+      retval = id->eval (print, nargout, tmp_args);
+      if (error_state)
+	eval_error ();
+    }
+
+  return retval;
+}
+
+void
+tree_index_expression::eval_error (void)
+{
+  if (error_state > 0)
+    {
+      int l = line ();
+      int c = column ();
+      char *fmt;
+      if (l != -1 && c != -1)
+	{
+	  if (list)
+	    fmt = "evaluating index expression near line %d, column %d";
+	  else
+	    fmt = "evaluating expression near line %d, column %d";
+
+	  ::error (fmt, l, c);
+	}
+      else
+	{
+	  if (list)
+	    ::error ("evaluating index expression");
+	  else
+	    ::error ("evaluating expression");
+	}
+    }
+}
+
+void
+tree_index_expression::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  if (in_parens)
+    os << "(";
+
+  if (id)
+    id->print_code (os);
+
+  if (list)
+    {
+      os << " (";
+      list->print_code (os);
+      os << ")";
+    }
+
+  if (in_parens)
+    os << ")";
+}
+
+// Prefix expressions.
+
+tree_constant
+tree_prefix_expression::eval (int print)
+{
+  tree_constant retval;
+
+  if (error_state)
+    return retval;
+
+  if (id)
+    {
+      id->bump_value (etype);
+      retval = id->eval (print);
+      if (error_state)
+	{
+	  retval = tree_constant ();
+	  if (error_state)
+	    eval_error ();
+	}
+    }
+  return retval;
+}
+
+char *
+tree_prefix_expression::oper (void) const
+{
+  static char *op;
+  switch (etype)
+    {
+    case tree_expression::increment: op = "++";      break;
+    case tree_expression::decrement: op = "--";      break;
+    default:                         op = "unknown"; break;
+    }
+  return op;
+}
+
+void
+tree_prefix_expression::eval_error (void)
+{
+  if (error_state > 0)
+    {
+      char *op = oper ();
+
+      ::error ("evaluating prefix operator `%s' near line %d, column %d",
+	       op, line (), column ());
+    }
+}
+
+void
+tree_prefix_expression::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  if (in_parens)
+    os << "(";
+
+  os << oper ();
+
+  if (id)
+    id->print_code (os);
+
+  if (in_parens)
+    os << ")";
+}
+
+// Postfix expressions.
+
+tree_constant
+tree_postfix_expression::eval (int print)
+{
+  tree_constant retval;
+
+  if (error_state)
+    return retval;
+
+  if (id)
+    {
+      retval = id->eval (print);
+      id->bump_value (etype);
+      if (error_state)
+	{
+	  retval = tree_constant ();
+	  if (error_state)
+	    eval_error ();
+	}
+    }
+  return retval;
+}
+
+char *
+tree_postfix_expression::oper (void) const
+{
+  static char *op;
+  switch (etype)
+    {
+    case tree_expression::increment: op = "++";      break;
+    case tree_expression::decrement: op = "--";      break;
+    default:                         op = "unknown"; break;
+    }
+  return op;
+}
+
+void
+tree_postfix_expression::eval_error (void)
+{
+  if (error_state > 0)
+    {
+      char *op = oper ();
+
+      ::error ("evaluating postfix operator `%s' near line %d, column %d",
+	       op, line (), column ());
+    }
+}
+
+void
+tree_postfix_expression::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  if (in_parens)
+    os << "(";
+
+  if (id)
+    id->print_code (os);
+
+  os << oper ();
+
+  if (in_parens)
+    os << ")";
+}
+
+// Unary expressions.
+
+tree_constant
+tree_unary_expression::eval (int print)
+{
+  if (error_state)
+    return tree_constant ();
+
+  tree_constant ans;
+
+  switch (etype)
+    {
+    case tree_expression::not:
+    case tree_expression::uminus:
+    case tree_expression::hermitian:
+    case tree_expression::transpose:
+      if (op)
+	{
+	  Octave_object tmp =  op->eval (0);
+	  tree_constant u = tmp(0);
+	  if (error_state)
+	    eval_error ();
+	  else if (u.is_defined ())
+	    {
+	      ans = do_unary_op (u, etype);
+	      if (error_state)
+		{
+		  ans = tree_constant ();
+		  if (error_state)
+		    eval_error ();
+		}
+	    }
+	}
+      break;
+    default:
+      ::error ("unary operator %d not implemented", etype);
+      break;
+    }
+
+  return ans;
+}
+
+char *
+tree_unary_expression::oper (void) const
+{
+  static char *op;
+  switch (etype)
+    {
+    case tree_expression::not:        op = "!";       break;
+    case tree_expression::uminus:     op = "-";       break;
+    case tree_expression::hermitian:  op = "'";       break;
+    case tree_expression::transpose:  op = ".'";      break;
+    default:                          op = "unknown"; break;
+    }
+  return op;
+}
+
+void
+tree_unary_expression::eval_error (void)
+{
+  if (error_state > 0)
+    {
+      char *op = oper ();
+
+      ::error ("evaluating unary operator `%s' near line %d, column %d",
+	       op, line (), column ());
+    }
+}
+
+void
+tree_unary_expression::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  if (in_parens)
+    os << "(";
+
+  switch (etype)
+    {
+    case tree_expression::not:
+    case tree_expression::uminus:
+      os << oper ();
+      if (op)
+	op->print_code (os);
+      break;
+    case tree_expression::hermitian:
+    case tree_expression::transpose:
+      if (op)
+	op->print_code (os);
+      os << oper ();
+      break;
+    default:
+      panic_impossible ();
+      break;
+    }
+
+  if (in_parens)
+    os << ")";
+}
+
+// Binary expressions.
+ 
+tree_constant
+tree_binary_expression::eval (int print)
+{
+  if (error_state)
+    return tree_constant ();
+
+  tree_constant ans;
+  switch (etype)
+    {
+    case tree_expression::add:
+    case tree_expression::subtract:
+    case tree_expression::multiply:
+    case tree_expression::el_mul:
+    case tree_expression::divide:
+    case tree_expression::el_div:
+    case tree_expression::leftdiv:
+    case tree_expression::el_leftdiv:
+    case tree_expression::power:
+    case tree_expression::elem_pow:
+    case tree_expression::cmp_lt:
+    case tree_expression::cmp_le:
+    case tree_expression::cmp_eq:
+    case tree_expression::cmp_ge:
+    case tree_expression::cmp_gt:
+    case tree_expression::cmp_ne:
+    case tree_expression::and:
+    case tree_expression::or:
+      if (op1)
+	{
+	  Octave_object tmp = op1->eval (0);
+	  tree_constant a = tmp(0);
+	  if (error_state)
+	    eval_error ();
+	  else if (a.is_defined () && op2)
+	    {
+	      tmp = op2->eval (0);
+	      tree_constant b = tmp (0);
+	      if (error_state)
+		eval_error ();
+	      else if (b.is_defined ())
+		{
+		  ans = do_binary_op (a, b, etype);
+		  if (error_state)
+		    {
+		      ans = tree_constant ();
+		      if (error_state)
+			eval_error ();
+		    }
+		}
+	    }
+	}
+      break;
+    case tree_expression::and_and:
+    case tree_expression::or_or:
+      {
+	int result = 0;
+	if (op1)
+	  {
+	    Octave_object tmp = op1->eval (0);
+	    tree_constant a = tmp(0);
+	    if (error_state)
+	      {
+		eval_error ();
+		break;
+	      }
+
+	    int a_true = a.is_true ();
+	    if (error_state)
+	      {
+		eval_error ();
+		break;
+	      }
+
+	    if (a_true)
+	      {
+		if (etype == tree_expression::or_or)
+		  {
+		    result = 1;
+		    goto done;
+		  }
+	      }
+	    else
+	      {
+		if (etype == tree_expression::and_and)
+		  {
+		    result = 0;
+		    goto done;
+		  }
+	      }
+
+	    if (op2)
+	      {
+		tmp = op2->eval (0);
+		tree_constant b = tmp(0);
+		if (error_state)
+		  {
+		    eval_error ();
+		    break;
+		  }
+
+		result = b.is_true ();
+		if (error_state)
+		  {
+		    eval_error ();
+		    break;
+		  }
+	      }
+	  }
+      done:
+	ans = tree_constant ((double) result);
+      }
+      break;
+    default:
+      ::error ("binary operator %d not implemented", etype);
+      break;
+    }
+
+  return ans;
+}
+
+char *
+tree_binary_expression::oper (void) const
+{
+  static char *op;
+  switch (etype)
+    {
+    case tree_expression::add:        op = "+";       break;
+    case tree_expression::subtract:   op = "-";       break;
+    case tree_expression::multiply:   op = "*";       break;
+    case tree_expression::el_mul:     op = ".*";      break;
+    case tree_expression::divide:     op = "/";       break;
+    case tree_expression::el_div:     op = "./";      break;
+    case tree_expression::leftdiv:    op = "\\";      break;
+    case tree_expression::el_leftdiv: op = ".\\";     break;
+    case tree_expression::power:      op = "^";       break;
+    case tree_expression::elem_pow:   op = ".^";      break;
+    case tree_expression::cmp_lt:     op = "<";       break;
+    case tree_expression::cmp_le:     op = "<=";      break;
+    case tree_expression::cmp_eq:     op = "==";      break;
+    case tree_expression::cmp_ge:     op = ">=";      break;
+    case tree_expression::cmp_gt:     op = ">";       break;
+    case tree_expression::cmp_ne:     op = "!=";      break;
+    case tree_expression::and_and:    op = "&&";      break;
+    case tree_expression::or_or:      op = "||";      break;
+    case tree_expression::and:        op = "&";       break;
+    case tree_expression::or:         op = "|";       break;
+    default:                          op = "unknown"; break;
+    }
+  return op;
+}
+
+void
+tree_binary_expression::eval_error (void)
+{
+  if (error_state > 0)
+    {
+      char *op = oper ();
+
+      ::error ("evaluating binary operator `%s' near line %d, column %d",
+	     op, line (), column ());
+    }
+}
+
+void
+tree_binary_expression::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  if (in_parens)
+    os << "(";
+
+  if (op1)
+    op1->print_code (os);
+
+  os << " " << oper () << " ";
+
+  if (op2)
+    op2->print_code (os);
+
+  if (in_parens)
+    os << ")";
+}
+
+// Assignment expressions.
+
+tree_constant
+tree_assignment_expression::eval (int print)
+{
+  panic ("invalid evaluation of generic expression");
+  return tree_constant ();
+}
+
+// Simple assignment expressions.
+
+tree_simple_assignment_expression::~tree_simple_assignment_expression (void)
+{
+  if (! preserve)
+    {
+      delete lhs;
+      delete index;
+    }
+  delete rhs;
+}
+
+tree_constant
+tree_simple_assignment_expression::eval (int print)
+{
+  assert (etype == tree_expression::assignment);
+
+  tree_constant ans;
+  tree_constant retval;
+
+  if (error_state)
+    return retval;
+
+  if (rhs)
+    {
+      Octave_object tmp = rhs->eval (0);
+      tree_constant rhs_val = tmp(0);
+      if (error_state)
+	{
+	  if (error_state)
+	    eval_error ();
+	}
+      else if (! index)
+	{
+	  ans = lhs->assign (rhs_val);
+	  if (error_state)
+	    eval_error ();
+	}
+      else
+	{
+// Extract the arguments into a simple vector.
+	  Octave_object args = index->convert_to_const_vector ();
+
+	  int nargin = args.length ();
+
+	  if (error_state)
+	    eval_error ();
+	  else if (nargin > 1)
+	    {
+	      ans = lhs->assign (rhs_val, args);
+	      if (error_state)
+		eval_error ();
+	    }
+	}
+    }
+
+  if (! error_state && ans.is_defined ())
+    {
+      int pad_after = 0;
+      if (print && user_pref.print_answer_id_name)
+	{
+	  if (print_as_scalar (ans))
+	    {
+	      ostrstream output_buf;
+	      output_buf << lhs->name () << " = " << ends;
+	      maybe_page_output (output_buf);
+	    }
+	  else
+	    {
+	      pad_after = 1;
+	      ostrstream output_buf;
+	      output_buf << lhs->name () << " =\n\n" << ends;
+	      maybe_page_output (output_buf);
+	    }
+	}
+
+      retval = ans.eval (print);
+
+      if (print && pad_after)
+	{
+	  ostrstream output_buf;
+	  output_buf << "\n" << ends;
+	  maybe_page_output (output_buf);
+	}
+    }
+
+  return retval;
+}
+
+void
+tree_simple_assignment_expression::eval_error (void)
+{
+  if (error_state > 0)
+    {
+      int l = line ();
+      int c = column ();
+      if (l != -1 && c != -1)
+	::error ("evaluating assignment expression near line %d, column %d",
+		 l, c);
+//      else
+//	error ("evaluating assignment expression");
+    }
+}
+
+void
+tree_simple_assignment_expression::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  if (in_parens)
+    os << "(";
+
+  if (! is_ans_assign ())
+    {
+      if (lhs)
+	lhs->print_code (os);
+
+      if (index)
+	{
+	  os << " (";
+	  index->print_code (os);
+	  os << ")";
+	}
+
+      os << " = ";
+    }
+
+  if (rhs)
+    rhs->print_code (os);
+
+  if (in_parens)
+    os << ")";
+}
+
+// Multi-valued assignmnt expressions.
+
+tree_multi_assignment_expression::~tree_multi_assignment_expression (void)
+{
+  delete lhs;
+  delete rhs;
+}
+
+tree_constant
+tree_multi_assignment_expression::eval (int print)
+{
+  tree_constant retval;
+
+  if (error_state)
+    return retval;
+
+  Octave_object tmp_args;
+  Octave_object result = eval (print, 1, tmp_args);
+
+  if (result.length () > 0)
+    retval = result(0);
+
+  return retval;
+}
+
+Octave_object
+tree_multi_assignment_expression::eval (int print, int nargout,
+					const Octave_object& args)
+{
+  assert (etype == tree_expression::multi_assignment);
+
+  if (error_state || ! rhs)
+    return Octave_object ();
+
+  nargout = lhs->length ();
+  Octave_object tmp_args;
+  Octave_object results = rhs->eval (0, nargout, tmp_args);
+
+  if (error_state)
+    eval_error ();
+
+  int ma_line = line ();
+  int ma_column = column ();
+
+  if (results.length () > 0)
+    {
+      int i = 0;
+      int pad_after = 0;
+      int last_was_scalar_type = 0;
+      for (Pix p = lhs->first (); p != 0; lhs->next (p))
+	{
+	  tree_index_expression *lhs_expr = (*lhs) (p);
+
+	  if (i < nargout)
+	    {
+// XXX FIXME? XXX -- this is apparently the way Matlab works, but
+// maybe we should have the option of skipping the assignment instead.
+
+	      tree_constant *tmp = 0;
+	      if (results(i).is_undefined ())
+		{
+		  Matrix m;
+		  tmp = new tree_constant (m);
+		}
+	      else
+		tmp = new tree_constant (results(i));
+
+	      tree_simple_assignment_expression tmp_expr
+		(lhs_expr, tmp, 1, 0, ma_line, ma_column);
+
+	      results(i) = tmp_expr.eval (0); // May change
+
+	      if (error_state)
+		break;
+
+	      if (print && pad_after)
+		{
+		  ostrstream output_buf;
+		  output_buf << "\n" << '\0';
+		  maybe_page_output (output_buf);
+		}
+
+	      if (print && user_pref.print_answer_id_name)
+		{
+		  tree_identifier *tmp_id = lhs_expr->ident ();
+		  char *tmp_nm = tmp_id->name ();
+		  
+		  if (print_as_scalar (results(i)))
+		    {
+		      ostrstream output_buf;
+		      output_buf << tmp_nm << " = " << '\0';
+		      maybe_page_output (output_buf);
+		      last_was_scalar_type = 1;
+		    }
+		  else
+		    {
+		      ostrstream output_buf;
+		      output_buf << tmp_nm << " =\n\n" << '\0';
+		      maybe_page_output (output_buf);
+		      last_was_scalar_type = 0;
+		    }
+		}
+
+	      results(i).eval (print);
+
+	      pad_after++;
+	      i++;
+	    }
+	  else
+	    {
+	      tree_simple_assignment_expression tmp_expr
+		(lhs_expr, 0, 1, 0, ma_line, ma_column);
+
+	      tmp_expr.eval (0);
+
+	      if (error_state)
+		break;
+
+	      if (last_was_scalar_type && i == 1)
+		pad_after = 0;
+
+	      break;
+	    }
+	}
+
+      if (print && pad_after)
+	{
+	  ostrstream output_buf;
+	  output_buf << "\n" << '\0';
+	  maybe_page_output (output_buf);
+	}
+    }
+
+  return results;
+}
+
+void
+tree_multi_assignment_expression::eval_error (void)
+{
+  if (error_state > 0)
+    ::error ("evaluating assignment expression near line %d, column %d",
+	     line (), column ());
+}
+
+void
+tree_multi_assignment_expression::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  if (in_parens)
+    os << "(";
+
+  if (lhs)
+    {
+      int len = lhs->length ();
+
+      if (len > 1)
+	os << "[";
+
+      lhs->print_code (os);
+
+      if (len > 1)
+	os << "]";
+    }
+
+  os << " = ";
+
+  if (rhs)
+    rhs->print_code (os);
+
+  if (in_parens)
+    os << ")";
+}
+
+// Colon expressions.
+
+tree_colon_expression *
+tree_colon_expression::chain (tree_expression *t)
+{
+  tree_colon_expression *retval = 0;
+  if (! op1 || op3)
+    ::error ("invalid colon expression");
+  else
+    {
+      op3 = op2;	// Stupid syntax.
+      op2 = t;
+
+      retval = this;
+    }
+  return retval;
+}
+
+tree_constant
+tree_colon_expression::eval (int print)
+{
+  tree_constant retval;
+
+  if (error_state || ! op1 || ! op2)
+    return retval;
+
+  Octave_object otmp = op1->eval (0);
+  tree_constant tmp = otmp(0);
+
+  if (tmp.is_undefined ())
+    {
+      eval_error ("invalid null value in colon expression");
+      return retval;
+    }
+
+  tmp = tmp.make_numeric ();
+  if (tmp.const_type () != tree_constant_rep::scalar_constant
+      && tmp.const_type () != tree_constant_rep::complex_scalar_constant)
+    {
+      eval_error ("base for colon expression must be a scalar");
+      return retval;
+    }
+  double base = tmp.double_value ();
+
+  otmp = op2->eval (0);
+  tmp = otmp(0);
+
+  if (tmp.is_undefined ())
+    {
+      eval_error ("invalid null value in colon expression");
+      return retval;
+    }
+
+  tmp = tmp.make_numeric ();
+  if (tmp.const_type () != tree_constant_rep::scalar_constant
+      && tmp.const_type () != tree_constant_rep::complex_scalar_constant)
+    {
+      eval_error ("limit for colon expression must be a scalar");
+      return retval;
+    }
+  double limit = tmp.double_value ();
+
+  double inc = 1.0;
+  if (op3)
+    {
+      otmp = op3->eval (0);
+      tmp = otmp(0);
+
+      if (tmp.is_undefined ())
+	{
+	  eval_error ("invalid null value in colon expression");
+	  return retval;
+	}
+
+      tmp = tmp.make_numeric ();
+      if (tmp.const_type () != tree_constant_rep::scalar_constant
+	  && tmp.const_type () != tree_constant_rep::complex_scalar_constant)
+	{
+	  eval_error ("increment for colon expression must be a scalar");
+	  return retval;
+	}
+      else
+	inc = tmp.double_value ();
+    }
+
+  retval = tree_constant (base, limit, inc);
+
+  if (error_state)
+    {
+      if (error_state)
+	eval_error ("evaluating colon expression");
+      return tree_constant ();
+    }
+
+  return retval;
+}
+
+void
+tree_colon_expression::eval_error (const char *s)
+{
+  if (error_state > 0)
+    ::error ("%s near line %d column %d", s, line (), column ());
+}
+
+void
+tree_colon_expression::print_code (ostream& os)
+{
+  print_code_indent (os);
+
+  if (in_parens)
+    os << "(";
+
+  if (op1)
+    op1->print_code (os);
+
+// Stupid syntax.
+
+  if (op3)
+    {
+      os << ":";
+      op3->print_code (os);
+    }
+
+  if (op2)
+    {
+      os << ":";
+      op2->print_code (os);
+    }
+
+  if (in_parens)
+    os << ")";
+}
+
+// Builtin functions.
+
+tree_builtin::tree_builtin (const char *nm)
+{
+  nargin_max = -1;
+  nargout_max = -1;
+  is_mapper = 0;
+  fcn = 0;
+  if (nm)
+    my_name = strsave (nm);
+}
+
+tree_builtin::tree_builtin (int i_max, int o_max, Mapper_fcn& m_fcn,
+			    const char *nm)
+{
+  nargin_max = i_max;
+  nargout_max = o_max;
+  mapper_fcn = m_fcn;
+  is_mapper = 1;
+  fcn = 0;
+  if (nm)
+    my_name = strsave (nm);
+}
+
+tree_builtin::tree_builtin (int i_max, int o_max, Octave_builtin_fcn g_fcn,
+			    const char *nm)
+{
+  nargin_max = i_max;
+  nargout_max = o_max;
+  is_mapper = 0;
+  fcn = g_fcn;
+  if (nm)
+    my_name = strsave (nm);
+}
+
+tree_constant
+tree_builtin::eval (int print)
+{
+  tree_constant retval;
+
+  if (error_state)
+    return retval;
+
+  if (fcn)
+    {
+      Octave_object args;
+      args(0) = tree_constant (my_name);
+      Octave_object tmp = (*fcn) (args, 1);
+      if (tmp.length () > 0)
+	retval = tmp(0);
+    }
+  else // Assume mapper function
+    ::error ("%s: argument expected", my_name);
+
+  return retval;
+}
+
+Octave_object
+tree_builtin::eval (int print, int nargout, const Octave_object& args)
+{
+  Octave_object retval;
+
+  if (error_state)
+    return retval;
+
+  int nargin = args.length ();
+
+  if (fcn)
+    {
+      if (any_arg_is_magic_colon (args))
+	::error ("invalid use of colon in function argument list");
+      else
+	retval = (*fcn) (args, nargout);
+    }
+  else if (is_mapper)
+    {
+      if (nargin > nargin_max)
+	::error ("%s: too many arguments", my_name);
+      else if (nargin > 0 && args.length () > 0 && args(1).is_defined ())
+	{
+	  tree_constant tmp = args(1).mapper (mapper_fcn, 0);
+	  retval.resize (1);
+	  retval(0) = tmp;
+	}	
+    }
+  else
+    panic_impossible ();
+
+  return retval;
+}
+
+int
+tree_builtin::max_expected_args (void)
+{
+  int ea = nargin_max;
+  if (nargin_max < 0)
+    ea = INT_MAX;
+  else
+    ea = nargin_max;
+  return ea;
+}
+
 // User defined functions.
 
 #if 0
 tree_function *
 tree_function::define (tree statement_list *t)
 {
   cmd_list = t;
   return this;
@@ -1442,19 +2307,76 @@ tree_function::traceback_error (void)
     {
       if (file_name)
 	::error ("called from file `%s'", file_name);
       else
 	::error ("called from `?unknown?'");
     }
 }
 
+void
+tree_function::print_code (ostream& os)
+{
+  print_code_reset ();
+
+  print_code_indent (os);
+
+  os << "function ";
+
+  if (ret_list)
+    {
+      int len = ret_list->length ();
+
+      if (len > 1)
+	os << "[";
+
+      ret_list->print_code (os);
+
+      if (len > 1)
+	os << "]";
+
+      os << " = ";
+    }
+
+  os << (fcn_name ? fcn_name : "(null)") << " ";
+
+  if (param_list)
+    {
+      int len = param_list->length ();
+      if (len > 0)
+	os << "(";
+
+      param_list->print_code (os);
+
+      if (len > 0)
+	{
+	  os << ")";
+	  print_code_new_line (os);
+	}
+    }
+  else
+    {
+      os << "()";
+      print_code_new_line (os);
+    }
+
+  if (cmd_list)
+    {
+      increment_indent_level ();
+      cmd_list->print_code (os);
+    }
+
+  os << "endfunction";
+
+  print_code_new_line (os);
+}
+
 DEFUN ("va_arg", Fva_arg, Sva_arg, 1, 1,
   "va_arg (): return next argument in a function that takes a\n\
-varible number of parameters")
+variable number of parameters")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (curr_function)
@@ -1500,793 +2422,14 @@ to the beginning")
 	error ("va_start only valid within function body");
     }
   else
     print_usage ("va_start");
 
   return retval;
 }
 
-// Expressions.
-
-tree_constant
-tree_expression::eval (int print)
-{
-  panic ("invalid evaluation of generic expression");
-  return tree_constant ();
-}
-
-Octave_object
-tree_expression::eval (int print, int nargout, const Octave_object& args)
-{
-  panic ("invalid evaluation of generic expression");
-  return Octave_object ();
-}
-
-// Prefix expressions.
-
-tree_constant
-tree_prefix_expression::eval (int print)
-{
-  tree_constant retval;
-
-  if (error_state)
-    return retval;
-
-  if (id)
-    {
-      id->bump_value (etype);
-      retval = id->eval (print);
-      if (error_state)
-	{
-	  retval = tree_constant ();
-	  if (error_state)
-	    eval_error ();
-	}
-    }
-  return retval;
-}
-
-void
-tree_prefix_expression::eval_error (void)
-{
-  if (error_state > 0)
-    {
-      char *op;
-      switch (etype)
-	{
-	case tree_expression::increment: op = "++";      break;
-	case tree_expression::decrement: op = "--";      break;
-	default:                         op = "unknown"; break;
-	}
-
-      ::error ("evaluating prefix operator `%s' near line %d, column %d",
-	       op, line (), column ());
-    }
-}
-
-// Postfix expressions.
-
-tree_constant
-tree_postfix_expression::eval (int print)
-{
-  tree_constant retval;
-
-  if (error_state)
-    return retval;
-
-  if (id)
-    {
-      retval = id->eval (print);
-      id->bump_value (etype);
-      if (error_state)
-	{
-	  retval = tree_constant ();
-	  if (error_state)
-	    eval_error ();
-	}
-    }
-  return retval;
-}
-
-void
-tree_postfix_expression::eval_error (void)
-{
-  if (error_state > 0)
-    {
-      char *op;
-      switch (etype)
-	{
-	case tree_expression::increment: op = "++";      break;
-	case tree_expression::decrement: op = "--";      break;
-	default:                         op = "unknown"; break;
-	}
-
-      ::error ("evaluating postfix operator `%s' near line %d, column %d",
-	       op, line (), column ());
-    }
-}
-
-// Unary expressions.
-
-tree_constant
-tree_unary_expression::eval (int print)
-{
-  if (error_state)
-    return tree_constant ();
-
-  tree_constant ans;
-
-  switch (etype)
-    {
-    case tree_expression::not:
-    case tree_expression::uminus:
-    case tree_expression::hermitian:
-    case tree_expression::transpose:
-      if (op)
-	{
-	  tree_constant u = op->eval (0);
-	  if (error_state)
-	    eval_error ();
-	  else if (u.is_defined ())
-	    {
-	      ans = do_unary_op (u, etype);
-	      if (error_state)
-		{
-		  ans = tree_constant ();
-		  if (error_state)
-		    eval_error ();
-		}
-	    }
-	}
-      break;
-    default:
-      ::error ("unary operator %d not implemented", etype);
-      break;
-    }
-
-  return ans;
-}
-
-void
-tree_unary_expression::eval_error (void)
-{
-  if (error_state > 0)
-    {
-      char *op;
-      switch (etype)
-	{
-	case tree_expression::not:        op = "!";       break;
-	case tree_expression::uminus:     op = "-";       break;
-	case tree_expression::hermitian:  op = "'";       break;
-	case tree_expression::transpose:  op = ".'";      break;
-	default:                          op = "unknown"; break;
-	}
-
-      ::error ("evaluating unary operator `%s' near line %d, column %d",
-	       op, line (), column ());
-    }
-}
-
-// Binary expressions.
- 
-tree_constant
-tree_binary_expression::eval (int print)
-{
-  if (error_state)
-    return tree_constant ();
-
-  tree_constant ans;
-  switch (etype)
-    {
-    case tree_expression::add:
-    case tree_expression::subtract:
-    case tree_expression::multiply:
-    case tree_expression::el_mul:
-    case tree_expression::divide:
-    case tree_expression::el_div:
-    case tree_expression::leftdiv:
-    case tree_expression::el_leftdiv:
-    case tree_expression::power:
-    case tree_expression::elem_pow:
-    case tree_expression::cmp_lt:
-    case tree_expression::cmp_le:
-    case tree_expression::cmp_eq:
-    case tree_expression::cmp_ge:
-    case tree_expression::cmp_gt:
-    case tree_expression::cmp_ne:
-    case tree_expression::and:
-    case tree_expression::or:
-      if (op1)
-	{
-	  tree_constant a = op1->eval (0);
-	  if (error_state)
-	    eval_error ();
-	  else if (a.is_defined () && op2)
-	    {
-	      tree_constant b = op2->eval (0);
-	      if (error_state)
-		eval_error ();
-	      else if (b.is_defined ())
-		{
-		  ans = do_binary_op (a, b, etype);
-		  if (error_state)
-		    {
-		      ans = tree_constant ();
-		      if (error_state)
-			eval_error ();
-		    }
-		}
-	    }
-	}
-      break;
-    case tree_expression::and_and:
-    case tree_expression::or_or:
-      {
-	int result = 0;
-	if (op1)
-	  {
-	    tree_constant a = op1->eval (0);
-	    if (error_state)
-	      {
-		eval_error ();
-		break;
-	      }
-
-	    int a_true = a.is_true ();
-	    if (error_state)
-	      {
-		eval_error ();
-		break;
-	      }
-
-	    if (a_true)
-	      {
-		if (etype == tree_expression::or_or)
-		  {
-		    result = 1;
-		    goto done;
-		  }
-	      }
-	    else
-	      {
-		if (etype == tree_expression::and_and)
-		  {
-		    result = 0;
-		    goto done;
-		  }
-	      }
-
-	    if (op2)
-	      {
-		tree_constant b = op2->eval (0);
-		if (error_state)
-		  {
-		    eval_error ();
-		    break;
-		  }
-
-		result = b.is_true ();
-		if (error_state)
-		  {
-		    eval_error ();
-		    break;
-		  }
-	      }
-	  }
-      done:
-	ans = tree_constant ((double) result);
-      }
-      break;
-    default:
-      ::error ("binary operator %d not implemented", etype);
-      break;
-    }
-
-  return ans;
-}
-
-void
-tree_binary_expression::eval_error (void)
-{
-  if (error_state > 0)
-    {
-      char *op;
-      switch (etype)
-	{
-	case tree_expression::add:        op = "+";       break;
-	case tree_expression::subtract:   op = "-";       break;
-	case tree_expression::multiply:   op = "*";       break;
-	case tree_expression::el_mul:     op = ".*";      break;
-	case tree_expression::divide:     op = "/";       break;
-	case tree_expression::el_div:     op = "./";      break;
-	case tree_expression::leftdiv:    op = "\\";      break;
-	case tree_expression::el_leftdiv: op = ".\\";     break;
-	case tree_expression::power:      op = "^";       break;
-	case tree_expression::elem_pow:   op = ".^";      break;
-	case tree_expression::cmp_lt:     op = "<";       break;
-	case tree_expression::cmp_le:     op = "<=";      break;
-	case tree_expression::cmp_eq:     op = "==";      break;
-	case tree_expression::cmp_ge:     op = ">=";      break;
-	case tree_expression::cmp_gt:     op = ">";       break;
-	case tree_expression::cmp_ne:     op = "!=";      break;
-	case tree_expression::and_and:    op = "&&";      break;
-	case tree_expression::or_or:      op = "||";      break;
-	case tree_expression::and:        op = "&";       break;
-	case tree_expression::or:         op = "|";       break;
-	default:                          op = "unknown"; break;
-	}
-
-      ::error ("evaluating binary operator `%s' near line %d, column %d",
-	     op, line (), column ());
-    }
-}
-
-// Assignment expressions.
-
-tree_constant
-tree_assignment_expression::eval (int print)
-{
-  panic ("invalid evaluation of generic expression");
-  return tree_constant ();
-}
-
-// Simple assignment expressions.
-
-tree_simple_assignment_expression::~tree_simple_assignment_expression (void)
-{
-  if (! preserve)
-    {
-      delete lhs;
-      delete index;
-    }
-  delete rhs;
-}
-
-tree_constant
-tree_simple_assignment_expression::eval (int print)
-{
-  assert (etype == tree_expression::assignment);
-
-  tree_constant ans;
-  tree_constant retval;
-
-  if (error_state)
-    return retval;
-
-  if (rhs)
-    {
-      tree_constant rhs_val = rhs->eval (0);
-      if (error_state)
-	{
-	  if (error_state)
-	    eval_error ();
-	}
-      else if (! index)
-	{
-	  ans = lhs->assign (rhs_val);
-	  if (error_state)
-	    eval_error ();
-	}
-      else
-	{
-// Extract the arguments into a simple vector.
-	  Octave_object args = index->convert_to_const_vector ();
-
-	  int nargin = args.length ();
-
-	  if (error_state)
-	    eval_error ();
-	  else if (nargin > 1)
-	    {
-	      ans = lhs->assign (rhs_val, args);
-	      if (error_state)
-		eval_error ();
-	    }
-	}
-    }
-
-  if (! error_state && ans.is_defined ())
-    {
-      int pad_after = 0;
-      if (print && user_pref.print_answer_id_name)
-	{
-	  if (print_as_scalar (ans))
-	    {
-	      ostrstream output_buf;
-	      output_buf << lhs->name () << " = " << ends;
-	      maybe_page_output (output_buf);
-	    }
-	  else
-	    {
-	      pad_after = 1;
-	      ostrstream output_buf;
-	      output_buf << lhs->name () << " =\n\n" << ends;
-	      maybe_page_output (output_buf);
-	    }
-	}
-
-      retval = ans.eval (print);
-
-      if (print && pad_after)
-	{
-	  ostrstream output_buf;
-	  output_buf << "\n" << ends;
-	  maybe_page_output (output_buf);
-	}
-    }
-
-  return retval;
-}
-
-void
-tree_simple_assignment_expression::eval_error (void)
-{
-  if (error_state > 0)
-    {
-      int l = line ();
-      int c = column ();
-      if (l != -1 && c != -1)
-	::error ("evaluating assignment expression near line %d, column %d",
-		 l, c);
-//      else
-//	error ("evaluating assignment expression");
-    }
-}
-
-// Multi-valued assignmnt expressions.
-
-tree_multi_assignment_expression::~tree_multi_assignment_expression (void)
-{
-  delete lhs;
-  delete rhs;
-}
-
-tree_constant
-tree_multi_assignment_expression::eval (int print)
-{
-  tree_constant retval;
-
-  if (error_state)
-    return retval;
-
-  Octave_object tmp_args;
-  Octave_object result = eval (print, 1, tmp_args);
-
-  if (result.length () > 0)
-    retval = result(0);
-
-  return retval;
-}
-
-Octave_object
-tree_multi_assignment_expression::eval (int print, int nargout,
-					const Octave_object& args)
-{
-  assert (etype == tree_expression::multi_assignment);
-
-  if (error_state || ! rhs)
-    return Octave_object ();
-
-  nargout = lhs->length ();
-  Octave_object tmp_args;
-  Octave_object results = rhs->eval (0, nargout, tmp_args);
-
-  if (error_state)
-    eval_error ();
-
-  int ma_line = line ();
-  int ma_column = column ();
-
-  if (results.length () > 0)
-    {
-      int i = 0;
-      int pad_after = 0;
-      int last_was_scalar_type = 0;
-      for (Pix p = lhs->first (); p != 0; lhs->next (p))
-	{
-	  tree_index_expression *lhs_expr = (*lhs) (p);
-
-	  if (i < nargout)
-	    {
-// XXX FIXME? XXX -- this is apparently the way Matlab works, but
-// maybe we should have the option of skipping the assignment instead.
-
-	      tree_constant *tmp = 0;
-	      if (results(i).is_undefined ())
-		{
-		  Matrix m;
-		  tmp = new tree_constant (m);
-		}
-	      else
-		tmp = new tree_constant (results(i));
-
-	      tree_simple_assignment_expression tmp_expr
-		(lhs_expr, tmp, 1, ma_line, ma_column);
-
-	      results(i) = tmp_expr.eval (0); // May change
-
-	      if (error_state)
-		break;
-
-	      if (print && pad_after)
-		{
-		  ostrstream output_buf;
-		  output_buf << "\n" << '\0';
-		  maybe_page_output (output_buf);
-		}
-
-	      if (print && user_pref.print_answer_id_name)
-		{
-		  tree_identifier *tmp_id = lhs_expr->ident ();
-		  char *tmp_nm = tmp_id->name ();
-		  
-		  if (print_as_scalar (results(i)))
-		    {
-		      ostrstream output_buf;
-		      output_buf << tmp_nm << " = " << '\0';
-		      maybe_page_output (output_buf);
-		      last_was_scalar_type = 1;
-		    }
-		  else
-		    {
-		      ostrstream output_buf;
-		      output_buf << tmp_nm << " =\n\n" << '\0';
-		      maybe_page_output (output_buf);
-		      last_was_scalar_type = 0;
-		    }
-		}
-
-	      results(i).eval (print);
-
-	      pad_after++;
-	      i++;
-	    }
-	  else
-	    {
-	      tree_simple_assignment_expression tmp_expr
-		(lhs_expr, 0, 1, ma_line, ma_column);
-
-	      tmp_expr.eval (0);
-
-	      if (error_state)
-		break;
-
-	      if (last_was_scalar_type && i == 1)
-		pad_after = 0;
-
-	      break;
-	    }
-	}
-
-      if (print && pad_after)
-	{
-	  ostrstream output_buf;
-	  output_buf << "\n" << '\0';
-	  maybe_page_output (output_buf);
-	}
-    }
-
-  return results;
-}
-
-void
-tree_multi_assignment_expression::eval_error (void)
-{
-  if (error_state > 0)
-    ::error ("evaluating assignment expression near line %d, column %d",
-	     line (), column ());
-}
-
-// Colon expressions.
-
-tree_colon_expression *
-tree_colon_expression::chain (tree_expression *t)
-{
-  tree_colon_expression *retval = 0;
-  if (! op1 || op3)
-    ::error ("invalid colon expression");
-  else
-    {
-      op3 = op2;	// Stupid syntax.
-      op2 = t;
-
-      retval = this;
-    }
-  return retval;
-}
-
-tree_constant
-tree_colon_expression::eval (int print)
-{
-  tree_constant retval;
-
-  if (error_state || ! op1 || ! op2)
-    return retval;
-
-  tree_constant tmp;
-
-  tmp = op1->eval (0);
-
-  if (tmp.is_undefined ())
-    {
-      eval_error ("invalid null value in colon expression");
-      return retval;
-    }
-
-  tmp = tmp.make_numeric ();
-  if (tmp.const_type () != tree_constant_rep::scalar_constant
-      && tmp.const_type () != tree_constant_rep::complex_scalar_constant)
-    {
-      eval_error ("base for colon expression must be a scalar");
-      return retval;
-    }
-  double base = tmp.double_value ();
-
-  tmp = op2->eval (0);
-
-  if (tmp.is_undefined ())
-    {
-      eval_error ("invalid null value in colon expression");
-      return retval;
-    }
-
-  tmp = tmp.make_numeric ();
-  if (tmp.const_type () != tree_constant_rep::scalar_constant
-      && tmp.const_type () != tree_constant_rep::complex_scalar_constant)
-    {
-      eval_error ("limit for colon expression must be a scalar");
-      return retval;
-    }
-  double limit = tmp.double_value ();
-
-  double inc = 1.0;
-  if (op3)
-    {
-      tmp = op3->eval (0);
-
-      if (tmp.is_undefined ())
-	{
-	  eval_error ("invalid null value in colon expression");
-	  return retval;
-	}
-
-      tmp = tmp.make_numeric ();
-      if (tmp.const_type () != tree_constant_rep::scalar_constant
-	  && tmp.const_type () != tree_constant_rep::complex_scalar_constant)
-	{
-	  eval_error ("increment for colon expression must be a scalar");
-	  return retval;
-	}
-      else
-	inc = tmp.double_value ();
-    }
-
-  retval = tree_constant (base, limit, inc);
-
-  if (error_state)
-    {
-      if (error_state)
-	eval_error ("evaluating colon expression");
-      return tree_constant ();
-    }
-
-  return retval;
-}
-
-void
-tree_colon_expression::eval_error (const char *s)
-{
-  if (error_state > 0)
-    ::error ("%s near line %d column %d", s, line (), column ());
-}
-
-// Index expressions.
-
-tree_index_expression::~tree_index_expression (void)
-{
-  delete id;
-  delete list;
-}
-
-tree_constant
-tree_index_expression::eval (int print)
-{
-  tree_constant retval;
-
-  if (error_state)
-    return retval;
-
-  if (list)
-    {
-// Extract the arguments into a simple vector.
-      Octave_object args = list->convert_to_const_vector ();
-// Don't pass null arguments.
-      int nargin = args.length ();
-      if (error_state)
-	eval_error ();
-      else if (nargin > 1 && all_args_defined (args))
-	{
-	  Octave_object tmp = id->eval (print, 1, args);
-
-	  if (error_state)
-	    eval_error ();
-
-	  if (tmp.length () > 0)
-	    retval = tmp(0);
-	}
-    }
-  else
-    {
-      retval = id->eval (print);
-      if (error_state)
-	eval_error ();
-    }
-
-  return retval;
-}
-
-Octave_object
-tree_index_expression::eval (int print, int nargout, const Octave_object& args)
-{
-  Octave_object retval;
-
-  if (error_state)
-    return retval;
-
-  if (list)
-    {
-// Extract the arguments into a simple vector.
-      Octave_object args = list->convert_to_const_vector ();
-// Don't pass null arguments.
-      if (error_state)
-	eval_error ();
-      else if (args.length () > 1 && all_args_defined (args))
-	{
-	  retval = id->eval (print, nargout, args);
-	  if (error_state)
-	    eval_error ();
-	}
-    }
-  else
-    {
-      Octave_object tmp_args;
-      retval = id->eval (print, nargout, tmp_args);
-      if (error_state)
-	eval_error ();
-    }
-
-  return retval;
-}
-
-void
-tree_index_expression::eval_error (void)
-{
-  if (error_state > 0)
-    {
-      int l = line ();
-      int c = column ();
-      char *fmt;
-      if (l != -1 && c != -1)
-	{
-	  if (list)
-	    fmt = "evaluating index expression near line %d, column %d";
-	  else
-	    fmt = "evaluating expression near line %d, column %d";
-
-	  ::error (fmt, l, c);
-	}
-      else
-	{
-	  if (list)
-	    ::error ("evaluating index expression");
-	  else
-	    ::error ("evaluating expression");
-	}
-    }
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/pt-exp-base.h b/src/pt-exp-base.h
--- a/src/pt-exp-base.h
+++ b/src/pt-exp-base.h
@@ -25,16 +25,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #define octave_tree_expr_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include <time.h>
 #include <stdio.h>
+#include <iostream.h>
 
 #include "variables.h"
 #include "mappers.h"
 #include "error.h"
 #include "oct-obj.h"
 
 class tree_constant;
 class tree_statement_list;
@@ -62,16 +63,18 @@ class tree_index_expression;
 #include "tree-base.h"
 
 // A base class for expressions.
 
 class
 tree_expression : public tree
 {
 public:
+  int in_parens;
+
   enum type
     {
       unknown,
       assignment,
       simple_assignment,
       multi_assignment,
       add,
       subtract,
@@ -100,17 +103,20 @@ public:
       transpose,
       colon,
       index,
       increment,
       decrement,
    };
 
   tree_expression (int l = -1, int c = -1) : tree (l, c)
-    { etype = unknown; }
+    {
+      in_parens = 0;
+      etype = unknown;
+    }
 
   ~tree_expression (void) { }
 
   virtual int is_identifier (void) const
     { return 0; }
 
   virtual int is_index_expression (void) const
     { return 0; }
@@ -144,40 +150,42 @@ public:
     {
       md_none,
       md_right,
       md_down,
     };
 
   tree_matrix (void)
     {
-      dir_next = tree_matrix::md_none;
+      direction = tree_matrix::md_none;
       element = 0;
       next = 0;
     }
 
   tree_matrix (tree_expression *e, tree_matrix::dir d)
     {
-      dir_next = d;
+      direction = d;
       element = e;
       next = 0;
     }
 
   ~tree_matrix (void);
 
   tree_matrix *chain (tree_expression *e, tree_matrix::dir d);
   tree_matrix *reverse (void);
   int length (void);
 
   tree_return_list *to_return_list (void);
 
   tree_constant eval (int print);
 
+  void print_code (ostream& os);
+
 private:
-  tree_matrix::dir dir_next; // Direction to the next element.
+  tree_matrix::dir direction; // Direction from the previous element.
   tree_expression *element;
   tree_matrix *next;
 };
 
 // A base class for objects that can be evaluated with argument lists.
 
 class
 tree_fvc : public tree_expression
@@ -219,23 +227,23 @@ public:
 // Symbols from the symbol table.
 
 class
 tree_identifier : public tree_fvc
 {
   friend class tree_index_expression;
 
 public:
-  tree_identifier (int l = -1, int c = -1)
+  tree_identifier (int l = -1, int c = -1) : tree_fvc (l, c)
     {
       sym = 0;
       maybe_do_ans_assign = 0;
     }
 
-  tree_identifier (symbol_record *s, int l = -1, int c = -1)
+  tree_identifier (symbol_record *s, int l = -1, int c = -1) : tree_fvc (l, c)
     {
       sym = s;
       maybe_do_ans_assign = 0;
     }
 
   ~tree_identifier (void) { }
 
   int is_identifier (void) const
@@ -250,20 +258,16 @@ public:
 
   tree_constant assign (tree_constant& t);
   tree_constant assign (tree_constant& t, const Octave_object& args);
 
   int is_defined (void);
 
   void bump_value (tree_expression::type);
 
-  int load_fcn_from_file (int exec_script = 1);
-
-  int parse_fcn_file (int exec_script = 1, char *ff = 0);
-
   tree_fvc *do_lookup (int& script_file_executed);
 
   void link_to_global (void)
     {
       if (sym)
 	::link_to_global_variable (sym);
     }
 
@@ -273,16 +277,18 @@ public:
     { maybe_do_ans_assign = 1; }
 
   tree_constant eval (int print);
 
   Octave_object eval (int print, int nargout, const Octave_object& args);
 
   void eval_undefined_error (void);
 
+  void print_code (ostream& os);
+
 private:
   symbol_record *sym;
   int maybe_do_ans_assign;
 };
 
 // Index expressions.
 
 class
@@ -328,16 +334,18 @@ tree_index_expression : public tree_expr
     }
 
   tree_constant eval (int print);
 
   Octave_object eval (int print, int nargout, const Octave_object& args);
 
   void eval_error (void);
 
+  void print_code (ostream& os);
+
  private:
   tree_identifier *id;
   tree_argument_list *list;
 };
 
 // Prefix expressions.
 
 class
@@ -363,16 +371,20 @@ tree_prefix_expression : public tree_exp
 
   tree_constant eval (int print);
 
   void eval_error (void);
 
   int is_prefix_expression (void) const
     { return 1; }
 
+  char *oper (void) const;
+
+  void print_code (ostream& os);
+
  private:
   tree_identifier *id;
 };
 
 // Postfix expressions.
 
 class
 tree_postfix_expression : public tree_expression
@@ -394,16 +406,20 @@ tree_postfix_expression : public tree_ex
 
   ~tree_postfix_expression (void)
     { delete id; }
 
   tree_constant eval (int print);
 
   void eval_error (void);
 
+  char *oper (void) const;
+
+  void print_code (ostream& os);
+
  private:
   tree_identifier *id;
 };
 
 // Unary expressions.
 
 class
 tree_unary_expression : public tree_expression
@@ -425,16 +441,20 @@ tree_unary_expression : public tree_expr
 
   ~tree_unary_expression (void)
     { delete op; }
 
   tree_constant eval (int print);
 
   void eval_error (void);
 
+  char *oper (void) const;
+
+  void print_code (ostream& os);
+
  private:
   tree_expression *op;
 };
 
 // Binary expressions.
 
 class
 tree_binary_expression : public tree_expression
@@ -461,98 +481,107 @@ tree_binary_expression : public tree_exp
       delete op1;
       delete op2;
     }
 
   tree_constant eval (int print);
 
   void eval_error (void);
 
+  char *oper (void) const;
+
+  void print_code (ostream& os);
+
  private:
   tree_expression *op1;
   tree_expression *op2;
 };
 
 // Assignment expressions.
 
 class
 tree_assignment_expression : public tree_expression
 {
 public:
-  int in_parens;
-
   tree_assignment_expression (int l = -1, int c = -1)
     : tree_expression (l, c)
-    {
-      in_parens = 0;
-      etype = tree_expression::assignment;
-    }
+    { etype = tree_expression::assignment; }
 
   ~tree_assignment_expression (void) { }
 
   tree_constant eval (int print);
 
   int is_assignment_expression (void) const
     { return 1; }
 };
 
 // Simple assignment expressions.
 
 class
 tree_simple_assignment_expression : public tree_assignment_expression
 {
  public:
-  tree_simple_assignment_expression (int plhs = 0, int l = -1, int c = -1)
+  void init (int plhs, int ans_assign)
+    {
+      etype = tree_expression::assignment;
+      lhs = 0;
+      index = 0;
+      rhs = 0;
+      preserve = plhs;
+      ans_ass = ans_assign;
+    }
+
+  tree_simple_assignment_expression (int plhs = 0, int ans_assign = 0,
+				     int l = -1, int c = -1)
     : tree_assignment_expression (l, c)
-      {
-	etype = tree_expression::assignment;
-	lhs = 0;
-	index = 0;
-	rhs = 0;
-	preserve = plhs;
-      }
+      { init (plhs, ans_assign); }
 
   tree_simple_assignment_expression (tree_identifier *i,
 				     tree_expression *r,
-				     int plhs = 0, int l = -1, int c = -1)
+				     int plhs = 0, int ans_assign = 0,
+				     int l = -1, int c = -1)
     : tree_assignment_expression (l, c)
       {
-	etype = tree_expression::assignment;
+	init (plhs, ans_assign);
 	lhs = i;
-	index = 0;
 	rhs = r;
-	preserve = plhs;
       }
 
   tree_simple_assignment_expression (tree_index_expression *idx_expr,
 				     tree_expression *r,
-				     int plhs = 0, int l = -1, int c = -1)
+				     int plhs = 0, int ans_assign = 0,
+				     int l = -1, int c = -1)
     : tree_assignment_expression (l, c)
       {
-	etype = tree_expression::assignment;
+	init (plhs, ans_assign);
 	lhs = idx_expr->ident ();
 	index = idx_expr->arg_list ();
 	rhs = r;
-	preserve = plhs;
       }
 
   ~tree_simple_assignment_expression (void);
 
   tree_identifier *left_hand_side (void)
     { return lhs; }
 
+  int is_ans_assign (void)
+    { return ans_ass; }
+
   tree_constant eval (int print);
 
   void eval_error (void);
 
+  void print_code (ostream& os);
+
  private:
   tree_identifier *lhs;
   tree_argument_list *index;
   tree_expression *rhs;
   int preserve;
+  int ans_ass;
 };
 
 // Multi-valued assignment expressions.
 
 class
 tree_multi_assignment_expression : public tree_assignment_expression
 {
  public:
@@ -577,16 +606,18 @@ tree_multi_assignment_expression : publi
   ~tree_multi_assignment_expression (void);
 
   tree_constant eval (int print);
 
   Octave_object eval (int print, int nargout, const Octave_object& args);
 
   void eval_error (void);
 
+  void print_code (ostream& os);
+
  private:
   tree_return_list *lhs;
   tree_expression *rhs;
 };
 
 // Colon expressions.
 
 class
@@ -619,16 +650,18 @@ tree_colon_expression : public tree_expr
     }
 
   tree_colon_expression *chain (tree_expression *t);
 
   tree_constant eval (int print);
 
   void eval_error (const char *s);
 
+  void print_code (ostream& os);
+
  private:
   tree_expression *op1;
   tree_expression *op2;
   tree_expression *op3;
 };
 
 // Builtin functions.
 
@@ -655,16 +688,21 @@ public:
 
   Octave_object eval (int print, int nargout, const Octave_object& args);
 
   char *name (void) const
     { return my_name; }
 
   int max_expected_args (void);
 
+  void print_code (ostream& os)
+    {
+      os << my_name << " can't be printed because it is a builtin function\n";
+    }
+
 private:
   int nargin_max;
   int nargout_max;
   int is_mapper;
   Mapper_fcn mapper_fcn;
   Octave_builtin_fcn fcn;
   char *my_name;
 };
@@ -740,16 +778,18 @@ public:
   tree_constant eval (int print);
 
   Octave_object eval (int print, int nargout, const Octave_object& args);
 
   int max_expected_args (void);
 
   void traceback_error (void);
 
+  void print_code (ostream& os);
+
 private:
   int call_depth;
   tree_parameter_list *param_list;
   tree_parameter_list *ret_list;
   symbol_table *sym_tab;
   tree_statement_list *cmd_list;
   char *file_name;
   char *fcn_name;
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -29,16 +29,18 @@ Software Foundation, 675 Mass Ave, Cambr
 #pragma implementation
 #endif
 
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
+#include <iostream.h>
+
 #include "error.h"
 #include "tree.h"
 #include "tree-misc.h"
 #include "tree-expr.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "oct-obj.h"
 
@@ -54,16 +56,41 @@ extern int returning;
 // A list of commands to be executed.
 
 tree_statement::~tree_statement (void)
 {
   delete command;
   delete expression;
 }
 
+void
+tree_statement::print_code (ostream& os)
+{
+  if (command)
+    {
+      command->print_code (os);
+
+      if (! print_flag)
+	os << ";";
+
+      command->print_code_new_line (os);
+    }
+  else if (expression)
+    {
+      expression->print_code (os);
+
+      if (! print_flag)
+	os << ";";
+
+      expression->print_code_new_line (os);
+    }
+
+
+}
+
 tree_constant
 tree_statement_list::eval (int print)
 {
   int pf;
   tree_constant retval;
 
   if (error_state)
     return retval;
@@ -97,16 +124,28 @@ tree_statement_list::eval (int print)
 	    break;
 	}
       else
 	retval = tree_constant ();
     }
   return retval;
 }
 
+void
+tree_statement_list::print_code (ostream& os)
+{
+  for (Pix p = first (); p != 0; next (p))
+    {
+      tree_statement *elt = this->operator () (p);
+
+      if (elt)
+	elt->print_code (os);
+    }
+}
+
 Octave_object
 tree_argument_list::convert_to_const_vector (void)
 {
   int len = length () + 1;
 
   Octave_object args;
   args.resize (len);
 
@@ -130,16 +169,37 @@ tree_argument_list::convert_to_const_vec
 	{
 	  args(k) = tree_constant ();
 	  break;
 	}
     }
   return args;
 }
 
+void
+tree_argument_list::print_code (ostream& os)
+{
+  Pix p = first ();
+
+  while (p)
+    {
+      tree_expression *elt = this->operator () (p);
+
+      next (p);
+
+      if (elt)
+	{
+	  elt->print_code (os);
+
+	  if (p)
+	    os << ", ";
+	}
+    }
+}
+
 // Parameter lists.
 
 void
 tree_parameter_list::mark_as_formal_parameters (void)
 {
   for (Pix p = first (); p != 0; next (p))
     {
       tree_identifier *elt = this->operator () (p);
@@ -220,16 +280,62 @@ tree_parameter_list::is_defined (void)
 	  break;
 	}
     }
 
   return status;
 }
 
 void
+tree_parameter_list::print_code (ostream& os)
+{
+  Pix p = first ();
+
+  while (p)
+    {
+      tree_identifier *elt = this->operator () (p);
+
+      next (p);
+
+      if (elt)
+	{
+	  elt->print_code (os);
+
+	  if (p)
+	    os << ", ";
+	}
+    }
+}
+
+// Return lists.
+
+void
+tree_return_list::print_code (ostream& os)
+{
+  Pix p = first ();
+
+  while (p)
+    {
+      tree_index_expression *elt = this->operator () (p);
+
+      next (p);
+
+      if (elt)
+	{
+	  elt->print_code (os);
+
+	  if (p)
+	    os << ", ";
+	}
+    }
+}
+
+// Global.
+
+void
 tree_global::eval (void)
 {
   if (ident)
     {
       ident->link_to_global ();
     }
   else if (assign_expr)
     {
@@ -238,25 +344,60 @@ tree_global::eval (void)
       if (id)
 	id->link_to_global ();
 
       assign_expr->eval (0);
     }
 }
 
 void
+tree_global::print_code (ostream& os)
+{
+  if (ident)
+    ident->print_code (os);
+
+  if (assign_expr)
+    assign_expr->print_code (os);
+}
+
+// Global initializer lists.
+
+void
 tree_global_init_list::eval (void)
 {
   for (Pix p = first (); p != 0; next (p))
     {
       tree_global *t = this->operator () (p);
       t->eval ();
     }
 }
 
+void
+tree_global_init_list::print_code (ostream& os)
+{
+  Pix p = first ();
+
+  while (p)
+    {
+      tree_global *elt = this->operator () (p);
+
+      next (p);
+
+      if (elt)
+	{
+	  elt->print_code (os);
+
+	  if (p)
+	    os << ", ";
+	}
+    }
+}
+
+// If.
+
 int
 tree_if_clause::eval (void)
 {
   if (expr)
     {
       tree_constant t1 = expr->eval (0);
 
       if (error_state || t1.is_undefined ())
@@ -304,25 +445,86 @@ tree_if_clause::eval (void)
 
       return 1;
     }
 
   return 0;
 }
 
 void
+tree_if_clause::print_code (ostream& os)
+{
+  if (expr)
+    {
+      expr->print_code (os);
+
+      print_code_new_line (os);
+
+      increment_indent_level ();
+    }
+  else
+    {
+      print_code_indent (os);
+
+      os << "else";
+
+      print_code_new_line (os);
+
+      increment_indent_level ();
+    }
+
+  if (list)
+    {
+      list->print_code (os);
+
+      decrement_indent_level ();
+    }
+}
+
+// List of if commands.
+
+void
 tree_if_command_list::eval (void)
 {
   for (Pix p = first (); p != 0; next (p))
     {
       tree_if_clause *t = this->operator () (p);
 
       if (t->eval () || error_state)
 	break;
     }
 }
 
+void
+tree_if_command_list::print_code (ostream& os)
+{
+  Pix p = first ();
+
+  int first_elt = 1;
+
+  while (p)
+    {
+      tree_if_clause *elt = this->operator () (p);
+
+      next (p);
+
+      if (elt)
+	{
+	  if (p && ! first_elt)
+	    {
+	      print_code_indent (os);
+
+	      os << "elseif ";
+	    }
+
+	  elt->print_code (os);
+	}
+
+      first_elt = 0;
+    }
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/pt-misc.h b/src/pt-misc.h
--- a/src/pt-misc.h
+++ b/src/pt-misc.h
@@ -23,16 +23,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (octave_tree_misc_h)
 #define octave_tree_misc_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
+class ostream;
 class Octave_object;
 class tree_constant;
 class tree_command;
 class tree_expression;
 class tree_simple_assignment_expression;
 class tree_identifier;
 class symbol_record;
 class symbol_table;
@@ -49,17 +50,17 @@ class tree_global_init_list;
 
 #include "tree-base.h"
 #include "tree-expr.h"
 #include "tree-cmd.h"
 
 // A list of expressions and commands to be executed.
 
 class
-tree_statement
+tree_statement : public tree_print_code
 {
 friend class tree_statement_list;
 
 public:
   tree_statement (void)
     {
       command = 0;
       expression = 0;
@@ -80,71 +81,77 @@ public:
       print_flag = 1;
     }
 
   ~tree_statement (void);
 
   void set_print_flag (int print)
     { print_flag = print; }
 
+  void print_code (ostream& os);
+
 private:
   tree_command *command;	// Command to execute.
   tree_expression *expression;	// Command to execute.
   int print_flag;		// Print result of eval for this command?
 };
 
 class
-tree_statement_list : public SLList<tree_statement *>
+tree_statement_list : public SLList<tree_statement *>, public tree_print_code
 {
 public:
   tree_statement_list (void) : SLList<tree_statement *> () { }
   tree_statement_list (tree_statement *s) : SLList<tree_statement *> ()
     { append (s); }
 
   ~tree_statement_list (void)
     {
       while (! empty ())
 	{
 	  tree_statement *t = remove_front ();
 	  delete t;
 	}
     }
 
   tree_constant eval (int print);
+
+  void print_code (ostream& os);
 };
 
 // Argument lists.  Used to hold the list of expressions that are the
 // arguments in a function call or index expression.
 
 class
-tree_argument_list : public SLList<tree_expression *>
+tree_argument_list : public SLList<tree_expression *>, public tree_print_code
 {
 public:
   tree_argument_list (void) : SLList<tree_expression *> () { }
   tree_argument_list (tree_expression *t) : SLList<tree_expression *> ()
     { append (t); }
 
   ~tree_argument_list (void)
     {
       while (! empty ())
 	{
 	  tree_expression *t = remove_front ();
 	  delete t;
 	}
     }
 
   Octave_object convert_to_const_vector (void);
+
+  void print_code (ostream& os);
 };
 
 // Parameter lists.  Used to hold the list of input and output
 // parameters in a function definition.  Elements are identifiers
 // only.
 
 class
-tree_parameter_list : public SLList<tree_identifier *>
+tree_parameter_list : public SLList<tree_identifier *>, public tree_print_code
 {
 public:
   tree_parameter_list (void) : SLList<tree_identifier *> () { }
   tree_parameter_list (tree_identifier *t) : SLList<tree_identifier *> ()
     { append (t); }
 
   ~tree_parameter_list (void)
     {
@@ -172,46 +179,51 @@ public:
     { return (marked_for_varargs < 0); }
 
   void define_from_arg_vector (const Octave_object& args);
 
   int is_defined (void);
 
   Octave_object convert_to_const_vector (void);
 
+  void print_code (ostream& os);
+
 private:
   int marked_for_varargs;
 };
 
 // Return lists.  Used to hold the right hand sides of multiple
 // assignment expressions.
 
 class
-tree_return_list : public SLList<tree_index_expression *>
+tree_return_list : public SLList<tree_index_expression *>,
+  public tree_print_code 
 {
 public:
   tree_return_list (void) : SLList<tree_index_expression *> () { }
   tree_return_list (tree_index_expression *t)
     : SLList<tree_index_expression *> ()
       { append (t); }
 
   ~tree_return_list (void)
     {
       while (! empty ())
 	{
 	  tree_index_expression *t = remove_front ();
 	  delete t;
 	}
     }
+
+  void print_code (ostream& os);
 };
 
 // List of expressions that make up a global statement.
 
 class
-tree_global
+tree_global : public tree_print_code
 {
 public:
   tree_global (void)
     {
       ident = 0;
       assign_expr = 0;
     }
 
@@ -230,43 +242,47 @@ public:
   ~tree_global (void)
     {
       delete ident;
       delete assign_expr;
     }
 
   void eval (void);
 
+  void print_code (ostream& os);
+
 private:
   tree_identifier *ident;
   tree_simple_assignment_expression *assign_expr;
 };
 
 class
-tree_global_init_list : public SLList<tree_global *>
+tree_global_init_list : public SLList<tree_global *>, public tree_print_code
 {
 public:
   tree_global_init_list (void) : SLList<tree_global *> () { }
   tree_global_init_list (tree_global *t) : SLList<tree_global *> ()
     { append (t); }
 
   ~tree_global_init_list (void)
     {
       while (! empty ())
 	{
 	  tree_global *t = remove_front ();
 	  delete t;
 	}
     }
 
   void eval (void);
+
+  void print_code (ostream& os);
 };
 
 class
-tree_if_clause
+tree_if_clause : public tree_print_code
 {
 public:
   tree_if_clause (void)
     {
       expr = 0;
       list = 0;
     }
 
@@ -285,39 +301,43 @@ public:
   ~tree_if_clause (void)
     {
       delete expr;
       delete list;
     }
 
   int eval (void);
 
+  void print_code (ostream& os);
+
 private:
   tree_expression *expr;
   tree_statement_list *list;
 };
 
 class
-tree_if_command_list : public SLList<tree_if_clause *>
+tree_if_command_list : public SLList<tree_if_clause *>, public tree_print_code
 {
 public:
   tree_if_command_list (void) : SLList<tree_if_clause *> () { }
   tree_if_command_list (tree_if_clause *t) : SLList<tree_if_clause *> ()
     { append (t); }
 
   ~tree_if_command_list (void)
     {
       while (! empty ())
 	{
 	  tree_if_clause *t = remove_front ();
 	  delete t;
 	}
     }
 
   void eval (void);
+
+  void print_code (ostream& os);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -46,17 +46,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "help.h"
 #include "error.h"
 #include "utils.h"
 #include "tree.h"
 #include "defun.h"
 
 extern "C"
 {
-  char *tilde_expand (char *s); /* From readline's tilde.c */
+#include <readline/tilde.h>
 }
 
 // The number of lines we\'ve plotted so far.
 int plot_line_count;
 
 // Is this a parametric plot?  Makes a difference for 3D plotting.
 int parametric_plot = 0;
 
@@ -64,36 +64,36 @@ int parametric_plot = 0;
 int clear_before_plotting = 1;
 
 // List of files to delete when we exit or crash.
 static SLStack <char *> tmp_files;
 
 // Pipe to gnuplot.
 static oprocstream plot_stream;
 
-/*
- * Plotting, eh?
- */
+// Plotting, eh?
 
-tree_plot_command::tree_plot_command (void)
+tree_plot_command::tree_plot_command (void) : tree_command ()
 {
   range = 0;
   plot_list = 0;
   ndim = 0;
 }
 
 tree_plot_command::tree_plot_command (subplot_list *plt, int nd)
+  : tree_command ()
 {
   range = 0;
   plot_list = plt;
   ndim = nd;
 }
 
 tree_plot_command::tree_plot_command (subplot_list *plt,
 				      plot_limits *rng, int nd)
+  : tree_command ()
 {
   range = rng;
   plot_list = plt;
   ndim = nd;
 }
 
 tree_plot_command::~tree_plot_command (void)
 {
@@ -766,19 +766,16 @@ set plotting options")
 
   delete [] plot_command;
 
   DELETE_ARGV;
 
   return retval;
 }
 
-/*
- * Set plotting options.
- */
 DEFUN_TEXT ("show", Fshow, Sshow, -1, 1,
   "show [options]\n\
 \n\
 show plotting options")
 {
   Octave_object retval;
 
   DEFINE_ARGV("show");
diff --git a/src/pt-plot.h b/src/pt-plot.h
--- a/src/pt-plot.h
+++ b/src/pt-plot.h
@@ -23,43 +23,48 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (octave_tree_plot_h)
 #define octave_tree_plot_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
+#include <iostream.h>
+
 class tree_command;
 class tree_plot_command;
 class plot_limits;
 class plot_range;
 class subplot_using;
 class subplot_style;
 class subplot;
 class subplot_list;
 
-class ostream;
-
 #include <SLList.h>
 
 #include "tree.h"
 
 class
 tree_plot_command : public tree_command
 {
  public:
   tree_plot_command (void);
   tree_plot_command (subplot_list *plt, int nd);
   tree_plot_command (subplot_list *plt, plot_limits *rng, int nd);
 
   ~tree_plot_command (void);
 
   void eval (void);
 
+  void print_code (ostream& os)
+    {
+      os << "<plot command printing not implemented yet>";
+    }
+
  private:
   int ndim;
   plot_limits *range;
   subplot_list *plot_list;
 };
 
 class
 plot_limits
diff --git a/src/tc-inlines.h b/src/tc-inlines.h
--- a/src/tc-inlines.h
+++ b/src/tc-inlines.h
@@ -134,26 +134,14 @@ fortran_column (int i, int nr)
 {
   int c;
   int r;
   r = fortran_row (i, nr);
   c = (i - r) / nr + 1;
   return c;
 }
 
-static inline int
-valid_scalar_indices (const Octave_object& args)
-{
-  int nargin = args.length ();
-  int valid = ((nargin == 3
-		&& args(2).valid_as_scalar_index ()
-		&& args(1).valid_as_scalar_index ())
-	       || (nargin == 2 && args(1).valid_as_scalar_index ()));
-
-  return valid;
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/tc-rep.cc b/src/tc-rep.cc
--- a/src/tc-rep.cc
+++ b/src/tc-rep.cc
@@ -46,40 +46,36 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "utils.h"
 #include "pager.h"
 #include "pr-output.h"
 #include "tree-const.h"
 #include "idx-vector.h"
 
 #include "tc-inlines.cc"
 
-/*
- * How about a few macros?
- */
+// How about a few macros?
 
 #ifndef MAX
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
 #endif
 
 #ifndef MIN
 #define MIN(a,b) ((a) < (b) ? (a) : (b))
 #endif
 
 #ifndef ABS
 #define ABS(x) (((x) < 0) ? (-x) : (x))
 #endif
 
-/*
- * The following are used by some of the functions in the
- * tree_constant_rep class that must deal with real and complex
- * matrices.  This was not done with overloaded or virtual functions
- * from the Matrix class because there is no clean way to do that --
- * the necessary functions (like elem) need to return values of
- * different types...
- */
+// The following are used by some of the functions in the
+// tree_constant_rep class that must deal with real and complex
+// matrices.  This was not done with overloaded or virtual functions
+// from the Matrix class because there is no clean way to do that --
+// the necessary functions (like elem) need to return values of
+// different types...
 
 // Given a tree_constant, and the names to be used for the real and
 // complex matrix and their dimensions, declare a real or complex
 // matrix, and initialize it from the tree_constant.  Note that m, cm,
 // nr, and nc must not be previously declared, and they must not be
 // expressions.  Since only one of the matrices will be defined after
 // this macro is used, only one set of dimesions is declared.
 
@@ -226,58 +222,73 @@ any_element_is_complex (const ComplexMat
   int nc = a.columns ();
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       if (imag (a.elem (i, j)) != 0.0)
 	return 1;
   return 0;
 }
 
+static int
+valid_scalar_indices (const Octave_object& args)
+{
+  int nargin = args.length ();
+
+  return ((nargin == 3
+	   && args(2).valid_as_scalar_index ()
+	   && args(1).valid_as_scalar_index ())
+	  || (nargin == 2
+	      && args(1).valid_as_scalar_index ()));
+}
+
 // Now, the classes.
 
-/*
- * The real representation of constants.
- */
+// The real representation of constants.
+
 tree_constant_rep::tree_constant_rep (void)
 {
   type_tag = unknown_constant;
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (double d)
 {
   scalar = d;
   type_tag = scalar_constant;
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (const Matrix& m)
 {
   if (m.rows () == 1 && m.columns () == 1)
     {
       scalar = m.elem (0, 0);
       type_tag = scalar_constant;
     }
   else
     {
       matrix = new Matrix (m);
       type_tag = matrix_constant;
     }
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (const DiagMatrix& d)
 {
   if (d.rows () == 1 && d.columns () == 1)
     {
       scalar = d.elem (0, 0);
       type_tag = scalar_constant;
     }
   else
     {
       matrix = new Matrix (d);
       type_tag = matrix_constant;
     }
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (const RowVector& v, int
 				      prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
@@ -302,16 +313,17 @@ tree_constant_rep::tree_constant_rep (co
 	{
 	  Matrix m (1, len);
 	  for (int i = 0; i < len; i++)
 	    m.elem (0, i) = v.elem (i);
 	  matrix = new Matrix (m);
 	  type_tag = matrix_constant;
 	}
     }
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (const ColumnVector& v,
 				      int prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
@@ -336,50 +348,54 @@ tree_constant_rep::tree_constant_rep (co
 	{
 	  Matrix m (1, len);
 	  for (int i = 0; i < len; i++)
 	    m.elem (0, i) = v.elem (i);
 	  matrix = new Matrix (m);
 	  type_tag = matrix_constant;
 	}
     }
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (const Complex& c)
 {
   complex_scalar = new Complex (c);
   type_tag = complex_scalar_constant;
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (const ComplexMatrix& m)
 {
   if (m.rows () == 1 && m.columns () == 1)
     {
       complex_scalar = new Complex (m.elem (0, 0));
       type_tag = complex_scalar_constant;
     }
   else
     {
       complex_matrix = new ComplexMatrix (m);
       type_tag = complex_matrix_constant;
     }
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (const ComplexDiagMatrix& d)
 {
   if (d.rows () == 1 && d.columns () == 1)
     {
       complex_scalar = new Complex (d.elem (0, 0));
       type_tag = complex_scalar_constant;
     }
   else
     {
       complex_matrix = new ComplexMatrix (d);
       type_tag = complex_matrix_constant;
     }
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (const ComplexRowVector& v,
 				      int prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
@@ -404,16 +420,17 @@ tree_constant_rep::tree_constant_rep (co
 	{
 	  ComplexMatrix m (1, len);
 	  for (int i = 0; i < len; i++)
 	    m.elem (0, i) = v.elem (i);
 	  complex_matrix = new ComplexMatrix (m);
 	  type_tag = complex_matrix_constant;
 	}
     }
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (const ComplexColumnVector& v,
 				      int prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
@@ -438,22 +455,24 @@ tree_constant_rep::tree_constant_rep (co
 	{
 	  ComplexMatrix m (1, len);
 	  for (int i = 0; i < len; i++)
 	    m.elem (0, i) = v.elem (i);
 	  complex_matrix = new ComplexMatrix (m);
 	  type_tag = complex_matrix_constant;
 	}
     }
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (const char *s)
 {
   string = strsave (s);
   type_tag = string_constant;
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (double b, double l, double i)
 {
   range = new Range (b, l, i);
   int nel = range->nelem ();
   if (nel < 0)
     {
@@ -477,16 +496,17 @@ tree_constant_rep::tree_constant_rep (do
       else if (nel == 0)
 	{
 	  matrix = new Matrix ();
 	  type_tag = matrix_constant;
 	}
       else
 	panic_impossible ();
     }
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (const Range& r)
 {
   if (r.nelem () > 1)
     {
       range = new Range (r);
       type_tag = range_constant;
@@ -498,23 +518,25 @@ tree_constant_rep::tree_constant_rep (co
     }
   else if (r.nelem () == 0)
     {
       matrix = new Matrix ();
       type_tag = matrix_constant;
     }
   else
     panic_impossible ();
+
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (tree_constant_rep::constant_type t)
 {
   assert (t == magic_colon);
-
   type_tag = magic_colon;
+  orig_text = 0;
 }
 
 tree_constant_rep::tree_constant_rep (const tree_constant_rep& t)
 {
   type_tag = t.type_tag;
 
   switch (t.type_tag)
     {
@@ -539,16 +561,18 @@ tree_constant_rep::tree_constant_rep (co
       range = new Range (*(t.range));
       break;
     case magic_colon:
       break;
     default:
       panic_impossible ();
       break;
     }
+
+  orig_text = strsave (t.orig_text);
 }
 
 tree_constant_rep::~tree_constant_rep (void)
 {
   switch (type_tag)
     {
     case unknown_constant:
       break;
@@ -570,16 +594,18 @@ tree_constant_rep::~tree_constant_rep (v
       delete range;
       break;
     case magic_colon:
       break;
     default:
       panic_impossible ();
       break;
     }
+
+  delete [] orig_text;
 }
 
 #if defined (MDEBUG)
 void *
 tree_constant_rep::operator new (size_t size)
 {
   tree_constant_rep *p = ::new tree_constant_rep;
   cerr << "tree_constant_rep::new(): " << p << "\n";
@@ -810,16 +836,22 @@ tree_constant_rep::to_matrix (void) cons
       retval = tmp.matrix_value ();
       break;
     default:
       break;
     }
   return retval;
 }
 
+void
+tree_constant_rep::stash_original_text (char *s)
+{
+  orig_text = strsave (s);
+}
+
 tree_constant_rep::constant_type
 tree_constant_rep::force_numeric (int force_str_conv)
 {
   switch (type_tag)
     {
     case scalar_constant:
     case matrix_constant:
     case complex_scalar_constant:
@@ -1310,16 +1342,137 @@ tree_constant_rep::print (void)
 	  break;
 	}
 
       output_buf << ends;
       maybe_page_output (output_buf);
     }
 }
 
+static char *
+undo_string_escapes (char c)
+{
+  static char retval[2];
+  retval[1] = '\0';
+
+  if (! c)
+    return 0;
+
+  switch (c)
+    {
+    case '\a':
+      return "\\a";
+    case '\b': // backspace
+      return "\\b";
+    case '\f': // formfeed
+      return "\\f";
+    case '\n': // newline
+      return "\\n";
+    case '\r': // carriage return
+      return "\\r";
+    case '\t': // horizontal tab
+      return "\\t";
+    case '\v': // vertical tab
+      return "\\v";
+    case '\\': // backslash
+      return "\\\\";
+    case '"': // double quote
+      return "\\\"";
+    default:
+      retval[0] = c;
+      return retval;
+    }
+}
+
+void
+tree_constant_rep::print_code (ostream& os)
+{
+  int nr = rows ();
+  int nc = columns ();
+
+  switch (type_tag)
+    {
+    case scalar_constant:
+      if (orig_text)
+	os << orig_text;
+      else
+	os << scalar;
+      break;
+    case matrix_constant:
+      if (nr == 0 || nc == 0)
+	os << "[]";
+      else
+	panic_impossible ();
+      break;
+    case complex_scalar_constant:
+     {
+	double re = complex_scalar->real ();
+	double im = complex_scalar->imag ();
+
+// We don't collapse Re +/- Im into a complex number yet, so if we get
+// here, we had better have a pure imaginary number that's positive...
+
+	assert (re == 0.0 && im > 0.0);
+
+	if (orig_text)
+	  os << orig_text;
+	else
+	  os << im;
+
+#if 0
+	int sign_printed = 0;
+
+	if (re != 0.0)
+	  {
+	    os << re;
+
+	    if (im > 0.0)
+	      {
+		os << " + ";
+		sign_printed = 1;
+	      }
+	    else if (im < 0.0)
+	      {
+		os << " - ";
+		sign_printed = 1;
+	      }
+	  }
+
+	if (im != 0.0)
+	  os << (sign_printed ? (im < 0.0 ? -im : im) : im);
+#endif
+      }
+      break;
+    case complex_matrix_constant:
+      if (nr == 0 || nc == 0)
+	os << "[]";
+      else
+	panic_impossible ();
+      break;
+    case string_constant:
+      {
+	os << "\"";
+	char *s, *t = string;
+	while (s = undo_string_escapes (*t++))
+	  os << s;
+	os << "\"";
+      }
+      break;
+    case range_constant:
+      panic_impossible ();
+      break;
+    case magic_colon:
+      os << ":";
+      break;
+    default:
+      panic_impossible ();
+      break;
+    }
+}
+
 tree_constant
 tree_constant_rep::do_index (const Octave_object& args)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
@@ -1963,17 +2116,17 @@ tree_constant_rep::convert_to_str (void)
 // Warn about out of range conversions?
 	    s[i] = (char) ival;
 	  }
 	retval = tree_constant (s);
 	delete [] s;
       }
       break;
     case string_constant:
-      retval = tree_constant (*this);
+      retval = string;
       break;
     case magic_colon:
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
@@ -2648,21 +2801,20 @@ tree_constant_rep::mapper (Mapper_fcn& m
     case magic_colon:
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
-/*
- * Top-level tree-constant function that handles assignments.  Only
- * decide if the left-hand side is currently a scalar or a matrix and
- * hand off to other functions to do the real work.
- */
+// Top-level tree-constant function that handles assignments.  Only
+// decide if the left-hand side is currently a scalar or a matrix and
+// hand off to other functions to do the real work.
+
 void
 tree_constant_rep::assign (const tree_constant& rhs, const Octave_object& args)
 {
   tree_constant rhs_tmp = rhs.make_numeric ();
 
 // This is easier than actually handling assignments to strings.
 // An assignment to a range will normally require a conversion to a
 // vector since it will normally destroy the equally-spaced property
@@ -2688,20 +2840,19 @@ tree_constant_rep::assign (const tree_co
     case range_constant:
     case magic_colon:
     default:
       panic_impossible ();
       break;
     }
 }
 
-/*
- * Assignments to scalars.  If resize_on_range_error is true,
- * this can convert the left-hand side to a matrix.
- */
+// Assignments to scalars.  If resize_on_range_error is true,
+// this can convert the left-hand side to a matrix.
+
 void
 tree_constant_rep::do_scalar_assignment (const tree_constant& rhs,
 					 const Octave_object& args)
 {
   assert (type_tag == unknown_constant
 	  || type_tag == scalar_constant
 	  || type_tag == complex_scalar_constant);
 
@@ -2793,22 +2944,21 @@ tree_constant_rep::do_scalar_assignment 
 	}
     }
   else if (nargin > 3 || nargin < 2)
     ::error ("invalid index expression for scalar type");
   else
     ::error ("index invalid or out of range for scalar type");
 }
 
-/*
- * Assignments to matrices (and vectors).
- *
- * For compatibility with Matlab, we allow assignment of an empty
- * matrix to an expression with empty indices to do nothing.
- */
+// Assignments to matrices (and vectors).
+//
+// For compatibility with Matlab, we allow assignment of an empty
+// matrix to an expression with empty indices to do nothing.
+
 void
 tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
 					 const Octave_object& args)
 {
   assert (type_tag == unknown_constant
 	  || type_tag == matrix_constant
 	  || type_tag == complex_matrix_constant);
 
@@ -2869,19 +3019,18 @@ tree_constant_rep::do_matrix_assignment 
 	do_matrix_assignment (rhs, args(1), args(2));
       break;
     default:
       ::error ("too many indices for matrix expression");
       break;
     }
 }
 
-/*
- * Matrix assignments indexed by a single value.
- */
+// Matrix assignments indexed by a single value.
+
 void
 tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
 					 const tree_constant& i_arg)
 {
   int nr = rows ();
   int nc = columns ();
 
   if (user_pref.do_fortran_indexing || nr <= 1 || nc <= 1)
@@ -2913,21 +3062,20 @@ tree_constant_rep::do_matrix_assignment 
 	vector_assignment (rhs, i_arg);
       else
 	panic_impossible ();
     }
   else
     ::error ("single index only valid for row or column vector");
 }
 
-/*
- * Fortran-style assignments.  Matrices are assumed to be stored in
- * column-major order and it is ok to use a single index for
- * multi-dimensional matrices.
- */
+// Fortran-style assignments.  Matrices are assumed to be stored in
+// column-major order and it is ok to use a single index for
+// multi-dimensional matrices.
+
 void
 tree_constant_rep::fortran_style_matrix_assignment (const tree_constant& rhs,
 						    const tree_constant& i_arg)
 {
   tree_constant tmp_i = i_arg.make_numeric_or_magic ();
 
   tree_constant_rep::constant_type itype = tmp_i.const_type ();
 
@@ -3078,19 +3226,18 @@ tree_constant_rep::fortran_style_matrix_
 	fortran_style_matrix_assignment (rhs, magic_colon);
       break;
     default:
       panic_impossible ();
       break;
     }
 }
 
-/*
- * Fortran-style assignment for vector index.
- */
+// Fortran-style assignment for vector index.
+
 void
 tree_constant_rep::fortran_style_matrix_assignment (const tree_constant& rhs,
 						    idx_vector& i)
 {
   assert (rhs.is_matrix_type ());
 
   int ilen = i.capacity ();
 
@@ -3123,19 +3270,18 @@ tree_constant_rep::fortran_style_matrix_
 	      complex_matrix->elem (ii, jj) = *cop_out++;
 	    }
 	}
     }
   else
     ::error ("number of rows and columns must match for indexed assignment");
 }
 
-/*
- * Fortran-style assignment for colon index.
- */
+// Fortran-style assignment for colon index.
+
 void
 tree_constant_rep::fortran_style_matrix_assignment
   (const tree_constant& rhs, tree_constant_rep::constant_type mci)
 {
   assert (rhs.is_matrix_type () && mci == tree_constant_rep::magic_colon);
 
   int nr = rows ();
   int nc = columns ();
@@ -3171,21 +3317,20 @@ tree_constant_rep::fortran_style_matrix_
     {
       Complex *cop_out = rhs_cm.fortran_vec ();
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  complex_matrix->elem (i, j) = *cop_out++;
     }
 }
 
-/*
- * Assignments to vectors.  Hand off to other functions once we know
- * what kind of index we have.  For a colon, it is the same as
- * assignment to a matrix indexed by two colons.
- */
+// Assignments to vectors.  Hand off to other functions once we know
+// what kind of index we have.  For a colon, it is the same as
+// assignment to a matrix indexed by two colons.
+
 void
 tree_constant_rep::vector_assignment (const tree_constant& rhs,
 				      const tree_constant& i_arg)
 {
   int nr = rows ();
   int nc = columns ();
 
   assert ((nr == 1 || nc == 1 || (nr == 0 && nc == 0))
@@ -3255,19 +3400,18 @@ tree_constant_rep::vector_assignment (co
       }
       break;
     default:
       panic_impossible ();
       break;
     }
 }
 
-/*
- * Check whether an indexed assignment to a vector is valid.
- */
+// Check whether an indexed assignment to a vector is valid.
+
 void
 tree_constant_rep::check_vector_assign (int rhs_nr, int rhs_nc,
 					int ilen, const char *rm)
 {
   int nr = rows ();
   int nc = columns ();
 
   if ((nr == 1 && nc == 1) || nr == 0 || nc == 0)  // No orientation.
@@ -3293,19 +3437,18 @@ tree_constant_rep::check_vector_assign (
 	  ::error ("A(%s) = X: where A is a column vector, X must also be", rm);
 	  ::error ("a column vector with the same number of elements as %s", rm);
 	}
     }
   else
     panic_impossible ();
 }
 
-/*
- * Assignment to a vector with an integer index.
- */
+// Assignment to a vector with an integer index.
+
 void
 tree_constant_rep::do_vector_assign (const tree_constant& rhs, int i)
 {
   int rhs_nr = rhs.rows ();
   int rhs_nc = rhs.columns ();
 
   if (indexed_assign_conforms (1, 1, rhs_nr, rhs_nc))
     {
@@ -3351,19 +3494,18 @@ tree_constant_rep::do_vector_assign (con
     }
   else
     {
       ::error ("for A(int) = X: X must be a scalar");
       return;
     }
 }
 
-/*
- * Assignment to a vector with a vector index.
- */
+// Assignment to a vector with a vector index.
+
 void
 tree_constant_rep::do_vector_assign (const tree_constant& rhs,
 				     idx_vector& iv)
 {
   if (rhs.is_zero_by_zero ())
     {
       int nr = rows ();
       int nc = columns ();
@@ -3457,19 +3599,18 @@ tree_constant_rep::do_vector_assign (con
 	}
       else
 	panic_impossible ();
     }
   else
     panic_impossible ();
 }
 
-/*
- * Assignment to a vector with a range index.
- */
+// Assignment to a vector with a range index.
+
 void
 tree_constant_rep::do_vector_assign (const tree_constant& rhs,
 				     Range& ri)
 {
   if (rhs.is_zero_by_zero ())
     {
       int nr = rows ();
       int nc = columns ();
@@ -3556,30 +3697,29 @@ tree_constant_rep::do_vector_assign (con
 	}
       else
 	panic_impossible ();
     }
   else
     panic_impossible ();
 }
 
-/*
- * Matrix assignment indexed by two values.  This function determines
- * the type of the first arugment, checks as much as possible, and
- * then calls one of a set of functions to handle the specific cases:
- *
- *   M (integer, arg2) = RHS  (MA1)
- *   M (vector,  arg2) = RHS  (MA2)
- *   M (range,   arg2) = RHS  (MA3)
- *   M (colon,   arg2) = RHS  (MA4)
- *
- * Each of those functions determines the type of the second argument
- * and calls another function to handle the real work of doing the
- * assignment.
- */
+// Matrix assignment indexed by two values.  This function determines
+// the type of the first arugment, checks as much as possible, and
+// then calls one of a set of functions to handle the specific cases:
+//
+//   M (integer, arg2) = RHS  (MA1)
+//   M (vector,  arg2) = RHS  (MA2)
+//   M (range,   arg2) = RHS  (MA3)
+//   M (colon,   arg2) = RHS  (MA4)
+//
+// Each of those functions determines the type of the second argument
+// and calls another function to handle the real work of doing the
+// assignment.
+
 void
 tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
 					 const tree_constant& i_arg,
 					 const tree_constant& j_arg)
 {
   tree_constant tmp_i = i_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type itype = tmp_i.const_type ();
@@ -4207,33 +4347,31 @@ tree_constant_rep::do_matrix_assignment 
       do_matrix_assignment (rhs, magic_colon, magic_colon);
       break;
     default:
       panic_impossible ();
       break;
     }
 }
 
-/*
- * Functions that actually handle assignment to a matrix using two
- * index values.
- *
- *                   idx2
- *            +---+---+----+----+
- *   idx1     | i | v |  r | c  |
- *   ---------+---+---+----+----+
- *   integer  | 1 | 5 |  9 | 13 |
- *   ---------+---+---+----+----+
- *   vector   | 2 | 6 | 10 | 14 |
- *   ---------+---+---+----+----+
- *   range    | 3 | 7 | 11 | 15 |
- *   ---------+---+---+----+----+
- *   colon    | 4 | 8 | 12 | 16 |
- *   ---------+---+---+----+----+
- */
+// Functions that actually handle assignment to a matrix using two
+// index values.
+//
+//                   idx2
+//            +---+---+----+----+
+//   idx1     | i | v |  r | c  |
+//   ---------+---+---+----+----+
+//   integer  | 1 | 5 |  9 | 13 |
+//   ---------+---+---+----+----+
+//   vector   | 2 | 6 | 10 | 14 |
+//   ---------+---+---+----+----+
+//   range    | 3 | 7 | 11 | 15 |
+//   ---------+---+---+----+----+
+//   colon    | 4 | 8 | 12 | 16 |
+//   ---------+---+---+----+----+
 
 /* 1 */
 void
 tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
 					 int i, int j)
 {
   REP_ELEM_ASSIGN (i, j, rhs.double_value (), rhs.complex_value (),
 		   rhs.is_real_type ());
@@ -4643,22 +4781,21 @@ tree_constant_rep::do_matrix_assignment 
       break;
     case magic_colon:
     default:
       panic_impossible ();
       break;
     }
 }
 
-/*
- * Functions for deleting rows or columns of a matrix.  These are used
- * to handle statements like
- *
- *   M (i, j) = []
- */
+// Functions for deleting rows or columns of a matrix.  These are used
+// to handle statements like
+//
+//   M (i, j) = []
+
 void
 tree_constant_rep::delete_row (int idx)
 {
   if (type_tag == matrix_constant)
     {
       int nr = matrix->rows ();
       int nc = matrix->columns ();
       Matrix *new_matrix = new Matrix (nr-1, nc);
@@ -5001,41 +5138,42 @@ tree_constant_rep::delete_columns (Range
 	}
       delete complex_matrix;
       complex_matrix = new_matrix;
     }
   else
     panic_impossible ();
 }
 
-/*
- * Indexing functions.
- */
+// Indexing functions.
+
 int
 tree_constant_rep::valid_as_scalar_index (void) const
 {
-  int valid = type_tag == magic_colon
-    || (type_tag == scalar_constant && NINT (scalar) == 1)
-    || (type_tag == range_constant
-	&& range->nelem () == 1 && NINT (range->base ()) == 1);
-
-  return valid;
+  return (type_tag == magic_colon
+	  || (type_tag == scalar_constant && NINT (scalar) == 1)
+	  || (type_tag == range_constant
+	      && range->nelem () == 1 && NINT (range->base ()) == 1));
 }
 
 tree_constant
 tree_constant_rep::do_scalar_index (const Octave_object& args) const
 {
+  tree_constant retval;
+
   if (valid_scalar_indices (args))
     {
       if (type_tag == scalar_constant)
-	return tree_constant (scalar);
+	retval = scalar;
       else if (type_tag == complex_scalar_constant)
-	return tree_constant (*complex_scalar);
+	retval = *complex_scalar;
       else
 	panic_impossible ();
+
+      return retval;
     }
   else
     {
       int rows = 0;
       int cols = 0;
 
       int nargin = args.length ();
 
@@ -5044,17 +5182,17 @@ tree_constant_rep::do_scalar_index (cons
 	case 3:
 	  {
 	    if (args(2).is_matrix_type ())
 	      {
 		Matrix mj = args(2).matrix_value ();
 
 		idx_vector j (mj, user_pref.do_fortran_indexing, "");
 		if (! j)
-		  return tree_constant ();
+		  return retval;
 
 		int len = j.length ();
 		if (len == j.ones_count ())
 		  cols = len;
 	      }
 	    else if (args(2).const_type () == magic_colon
 		     || (args(2).is_scalar_type ()
 			 && NINT (args(2).double_value ()) == 1))
@@ -5068,33 +5206,32 @@ tree_constant_rep::do_scalar_index (cons
 	case 2:
 	  {
 	    if (args(1).is_matrix_type ())
 	      {
 		Matrix mi = args(1).matrix_value ();
 
 		idx_vector i (mi, user_pref.do_fortran_indexing, "");
 		if (! i)
-		  return tree_constant ();
+		  return retval;
 
 		int len = i.length ();
 		if (len == i.ones_count ())
 		  rows = len;
 	      }
 	    else if (args(1).const_type () == magic_colon
 		     || (args(1).is_scalar_type ()
 			 && NINT (args(1).double_value ()) == 1))
 	      {
 		rows = 1;
 	      }
 	    else if (args(1).is_scalar_type ()
 		     && NINT (args(1).double_value ()) == 0)
 	      {
-		Matrix m (0, 0);
-		return tree_constant (m);
+		return Matrix ();
 	      }
 	    else
 	      break;
 
 	    if (cols == 0)
 	      {
 		if (user_pref.prefer_column_vectors)
 		  cols = 1;
@@ -5102,23 +5239,21 @@ tree_constant_rep::do_scalar_index (cons
 		  {
 		    cols = rows;
 		    rows = 1;
 		  }
 	      }
 
 	    if (type_tag == scalar_constant)
 	      {
-		Matrix m (rows, cols, scalar);
-		return tree_constant (m);
+		return Matrix (rows, cols, scalar);
 	      }
 	    else if (type_tag == complex_scalar_constant)
 	      {
-		ComplexMatrix cm (rows, cols, *complex_scalar);
-		return tree_constant (cm);
+		return ComplexMatrix (rows, cols, *complex_scalar);
 	      }
 	    else
 	      panic_impossible ();
 	  }
 	  break;
 	default:
 	  ::error ("invalid number of arguments for scalar type");
 	  return tree_constant ();
@@ -6234,18 +6369,45 @@ tree_constant_rep::do_matrix_index (tree
   return retval;
 }
 
 tree_constant
 tree_constant_rep::do_matrix_index (tree_constant_rep::constant_type mci,
 				    tree_constant_rep::constant_type mcj) const
 {
   tree_constant retval;
+
   assert (mci == magic_colon && mcj == magic_colon);
-  retval = tree_constant (*this);
+
+  switch (type_tag)
+    {
+    case complex_scalar_constant:
+      retval = *complex_scalar;
+      break;
+    case scalar_constant:
+      retval = scalar;
+      break;
+    case complex_matrix_constant:
+      retval = *complex_matrix;
+      break;
+    case matrix_constant:
+      retval = *matrix;
+      break;
+    case range_constant:
+      retval = *range;
+      break;
+    case string_constant:
+      retval = string;
+      break;
+    case magic_colon:
+    default:
+      panic_impossible ();
+      break;
+    }
+
   return retval;
 }
 
 tree_constant
 tree_constant_rep::do_matrix_index
   (tree_constant_rep::constant_type mci) const
 {
   assert (mci == magic_colon);
diff --git a/src/tc-rep.h b/src/tc-rep.h
--- a/src/tc-rep.h
+++ b/src/tc-rep.h
@@ -34,50 +34,49 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "mx-base.h"
 #include "Range.h"
 
 class idx_vector;
 
 struct Mapper_fcn;
 
-/*
- * Forward class declarations.
- */
+// Forward class declarations.
+
 class tree;
 class tree_constant;
 
-/*
- * The actual representation of the tree_constant.
- */
+// The actual representation of the tree_constant.
+
 class
 tree_constant_rep
 {
 friend class tree_constant;
 
-  enum force_orient
-    {
-      no_orient,
-      row_orient,
-      column_orient,
-    };
-
 public:
   enum constant_type
     {
       unknown_constant,
       scalar_constant,
       matrix_constant,
       complex_scalar_constant,
       complex_matrix_constant,
       string_constant,
       range_constant,
       magic_colon,
     };
 
+  enum force_orient
+    {
+      no_orient,
+      row_orient,
+      column_orient,
+    };
+
+private:
   tree_constant_rep (void);
 
   tree_constant_rep (double d);
   tree_constant_rep (const Matrix& m);
   tree_constant_rep (const DiagMatrix& d);
   tree_constant_rep (const RowVector& v, int pcv);
   tree_constant_rep (const ColumnVector& v, int pcv);
 
@@ -150,16 +149,18 @@ public:
 	     || type_tag == complex_matrix_constant
              || type_tag == complex_scalar_constant
 	     || type_tag == range_constant; }
 
   double to_scalar (void) const;
   ColumnVector to_vector (void) const;
   Matrix to_matrix (void) const;
 
+  void stash_original_text (char *s);
+
   tree_constant_rep::constant_type force_numeric (int force_str_conv = 0);
   tree_constant make_numeric (int force_str_conv = 0) const;
 
   void assign (const tree_constant& rhs, const Octave_object& args);
 
   void do_scalar_assignment (const tree_constant& rhs,
 			     const Octave_object& args);
 
@@ -240,16 +241,18 @@ public:
   void delete_columns (idx_vector& j);
   void delete_columns (Range& j);
 
   void bump_value (tree_expression::type);
 
   void maybe_mutate (void);
   void print (void);
 
+  void print_code (ostream& os);
+
   tree_constant do_index (const Octave_object& args);
 
   tree_constant do_scalar_index (const Octave_object& args) const;
 
   tree_constant do_matrix_index (const Octave_object& args) const;
 
   tree_constant do_matrix_index (const tree_constant& i_arg) const;
 
@@ -325,28 +328,28 @@ public:
 
   tree_constant diag (void) const;
   tree_constant diag (const tree_constant& a) const;
 
   constant_type const_type (void) const { return type_tag; }
 
   tree_constant mapper (Mapper_fcn& m_fcn, int print) const;
 
-private:
   int count;
   constant_type type_tag;
   union
     {
       double scalar;			// A real scalar constant.
       Matrix *matrix;			// A real matrix constant.
       Complex *complex_scalar;		// A real scalar constant.
       ComplexMatrix *complex_matrix;	// A real matrix constant.
       char *string;			// A character string constant.
       Range *range;			// A set of evenly spaced values.
     };
+  char *orig_text;
 };
 
 extern tree_constant do_binary_op (tree_constant& a, tree_constant& b,
 				   tree_expression::type t);
 
 extern tree_constant do_unary_op (tree_constant& a,
 				  tree_expression::type t);
 
diff --git a/src/token.cc b/src/token.cc
--- a/src/token.cc
+++ b/src/token.cc
@@ -35,62 +35,69 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "utils.h"
 #include "symtab.h"
 
 token::token (int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = generic_token;
+  orig_text = 0;
 }
 
 token::token (char *s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = string_token;
   str = strsave (s);
+  orig_text = 0;
 }
 
-token::token (double d, int l, int c)
+token::token (double d, char *s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = double_token;
   num = d;
+  orig_text = strsave (s);
 }
 
 token::token (end_tok_type t, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = ettype_token;
   et = t;
+  orig_text = 0;
 }
 
 token::token (plot_tok_type t, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = pttype_token;
   pt = t;
+  orig_text = 0;
 }
 
 token::token (symbol_record *s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = sym_rec_token;
   sr = s;
+  orig_text = 0;
 }
 
 token::~token (void)
 {
   if (type_tag == string_token)
     delete [] str;
+  delete [] orig_text;
 }
 
 int
 token::line (void)
 {
   return line_num;
 }
 
@@ -130,14 +137,20 @@ token::pttype (void)
 
 symbol_record *
 token::sym_rec (void)
 {
   assert (type_tag == sym_rec_token);
   return sr;
 }
 
+char *
+token::text_rep (void)
+{
+  return orig_text;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/token.h b/src/token.h
--- a/src/token.h
+++ b/src/token.h
@@ -57,44 +57,47 @@ public:
     {
       replot = 1,
       two_dee = 2,
       three_dee = 3,
     };
 
   token (int l = -1, int c = -1);
   token (char *s, int l = -1, int c = -1);
-  token (double d, int l = -1, int c = -1);
+  token (double d, char *s = 0, int l = -1, int c = -1);
   token (end_tok_type t, int l = -1, int c = -1);
   token (plot_tok_type t, int l = -1, int c = -1);
   token (symbol_record *s, int l = -1, int c = -1);
 
  ~token (void);
 
   int line (void);
   int column (void);
 
   char *string (void);
   double number (void);
   end_tok_type ettype (void);
   plot_tok_type pttype (void);
   symbol_record *sym_rec (void);
 
+  char *text_rep (void);
+
 private:
   int line_num;
   int column_num;
   token_type type_tag;
   union
     {
       char *str;
       double num;
       end_tok_type et;
       plot_tok_type pt;
       symbol_record *sr;
     };
+  char *orig_text;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -42,18 +42,16 @@ Free Software Foundation, Inc.
 
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/param.h>
 #include <setjmp.h>
 #include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
 #include <limits.h>
 #include <iostream.h>
 #include <strstream.h>
 #include <fstream.h>
 
 #include <Complex.h>
 
 #ifndef HAVE_STRNCASECMP
@@ -70,17 +68,17 @@ extern "C"
 #elif defined (HAVE_TERMIO_H)
 #include <termio.h>
 #elif defined (HAVE_SGTTY_H)
 #include <sgtty.h>
 #else
 LOSE! LOSE!
 #endif
 
-char *tilde_expand (char *s); /* From readline's tilde.c */
+#include <readline/tilde.h>
 }
 
 // This mess suggested by the autoconf manual.
 // unistd.h defines _POSIX_VERSION on POSIX.1 systems.
 #if defined(DIRENT) || defined(_POSIX_VERSION)
 #include <dirent.h>
 #define NLENGTH(dirent) (strlen((dirent)->d_name))
 #else /* not (DIRENT or _POSIX_VERSION) */
@@ -113,46 +111,43 @@ char *tilde_expand (char *s); /* From re
 #include "version.h"
 #include "tree-const.h"
 #include "unwind-prot.h"
 #include "octave-hist.h"
 
 // Top level context (?)
 extern jmp_buf toplevel;
 
-/*
- * Save a string.
- */
+// Save a string.
+
 char *
 strsave (const char *s)
 {
   if (! s)
     return 0;
 
   int len = strlen (s);
   char *tmp = new char [len+1];
   tmp = strcpy (tmp, s);
   return tmp;
 }
 
-/*
- * Concatenate two strings.
- */
+// Concatenate two strings.
+
 char *
 strconcat (const char *s, const char *t)
 {
   int len = strlen (s) + strlen (t);
   char *tmp = new char [len+1];
   strcpy (tmp, s);
   return strcat (tmp, t);
 }
 
-/*
- * Throw away input until a given character is read.
- */
+// Throw away input until a given character is read.
+
 void
 discard_until (istream& stream, char character)
 {
   int c;
   for (;;)
     {
       stream >> c;
       if (c == EOF || c == character)
@@ -206,19 +201,18 @@ pathstring_to_vector (char *pathstring)
 	}
 
       delete [] tmp_path;
     }
 
   return path;
 }
 
-/*
- * Return to the main command loop in octave.cc.
- */
+// Return to the main command loop in octave.cc.
+
 void
 jump_to_top_level (void)
 {
   run_all_unwind_protects ();
 
   longjmp (toplevel, 1);
 }
 
@@ -231,19 +225,18 @@ almost_match (const char *std, const cha
 
   return (slen <= stdlen
 	  && slen >= min_match_len
 	  && (case_sens
 	      ? (strncmp (std, s, slen) == 0)
 	      : (strncasecmp (std, s, slen) == 0)));
 }
 
-/*
- * Ugh.
- */
+// Ugh.
+
 int
 keyword_almost_match (const char **std, int *min_len, const char *s,
 		      int min_toks_to_match, int max_toks)
 {
   int status = 0;
   int tok_count = 0;
   int toks_matched = 0;
 
@@ -468,20 +461,19 @@ make_argv (const Octave_object& args, co
 	argv[i] = strsave (args(i).string_value ());
     }
   else
     error ("%s: expecting all arguments to be strings", fcn_name);
 
   return argv;
 }
 
-/*
- * Format a list in neat columns.  Mostly stolen from GNU ls.  This
- * should maybe be in utils.cc.
- */
+// Format a list in neat columns.  Mostly stolen from GNU ls.  This
+// should maybe be in utils.cc.
+
 ostrstream&
 list_in_columns (ostrstream& os, char **list)
 {
 // Compute the maximum name length.
 
   int max_name_length = 0;
   int total_names = 0;
   for (char **names = list; *names; names++)
@@ -536,19 +528,18 @@ list_in_columns (ostrstream& os, char **
 	  pos += max_name_length;
 	}
       os << "\n";
     }
 
   return os;
 }
 
-/*
- * See if the given file is in the path.
- */
+// See if the given file is in the path.
+
 char *
 file_in_path (const char *name, const char *suffix)
 {
   char *retval = 0;
 
   char *nm = strconcat ("/", name);
   if (suffix)
     {
@@ -582,30 +573,28 @@ file_in_path (const char *name, const ch
 	}
     }
 
  done:
   delete [] nm;
   return retval;
 }
 
-/*
- * See if there is an function file in the path.  If so, return the
- * full path to the file.
- */
+// See if there is an function file in the path.  If so, return the
+// full path to the file.
+
 char *
 fcn_file_in_path (const char *name)
 {
   return file_in_path (name, ".m");
 }
 
-/*
- * See if there is an octave file in the path.  If so, return the
- * full path to the file.
- */
+// See if there is an octave file in the path.  If so, return the
+// full path to the file.
+
 char *
 oct_file_in_path (const char *name)
 {
   return file_in_path (name, ".oct");
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -31,65 +31,72 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 #include <ctype.h>
 #include <float.h>
 #include <string.h>
 #include <fstream.h>
 #include <iostream.h>
 #include <strstream.h>
 
-#include "statdefs.h"
+#include "octave-hist.h"
+#include "unwind-prot.h"
+#include "user-prefs.h"
 #include "tree-const.h"
 #include "variables.h"
-#include "mappers.h"
-#include "user-prefs.h"
+#include "statdefs.h"
+#include "defaults.h"
 #include "version.h"
-#include "symtab.h"
-#include "defaults.h"
+#include "mappers.h"
+#include "oct-obj.h"
+#include "sysdep.h"
 #include "dirfns.h"
-#include "pager.h"
-#include "sysdep.h"
+#include "symtab.h"
 #include "octave.h"
-#include "oct-obj.h"
 #include "error.h"
+#include "pager.h"
 #include "utils.h"
+#include "defun.h"
+#include "input.h"
+#include "parse.h"
 #include "tree.h"
 #include "help.h"
-#include "defun.h"
+#include "lex.h"
 
 extern "C"
 {
+#include <readline/readline.h>
 #include <readline/tilde.h>
 
 #include "fnmatch.h"
 }
 
 // Symbol table for symbols at the top level.
-symbol_table *top_level_sym_tab;
+symbol_table *top_level_sym_tab = 0;
 
 // Symbol table for the current scope.
-symbol_table *curr_sym_tab;
+symbol_table *curr_sym_tab = 0;
 
 // Symbol table for global symbols.
-symbol_table *global_sym_tab;
+symbol_table *global_sym_tab = 0;
 
 void
 initialize_symbol_tables (void)
 {
-  global_sym_tab = new symbol_table ();
+  if (! global_sym_tab)
+    global_sym_tab = new symbol_table ();
 
-  top_level_sym_tab = new symbol_table ();
+  if (! top_level_sym_tab)
+    top_level_sym_tab = new symbol_table ();
 
   curr_sym_tab = top_level_sym_tab;
 }
 
-/*
- * Is there a corresponding function file that is newer than the
- * symbol definition?
- */
+// Is there a corresponding function file that is newer than the
+// symbol definition?
+
 int
 symbol_out_of_date (symbol_record *sr)
 {
   int ignore = user_pref.ignore_function_time_stamp;
 
   if (ignore == 2)
     return 0;
 
@@ -108,16 +115,237 @@ symbol_out_of_date (symbol_record *sr)
 	      if (status > 0)
 		return 1;
 	    }
 	}
     }
   return 0;
 }
 
+static void
+gobble_leading_white_space (FILE *ffile)
+{
+  int in_comment = 0;
+  int c;
+  while ((c = getc (ffile)) != EOF)
+    {
+      if (in_comment)
+	{
+	  if (c == '\n')
+	    in_comment = 0;
+	}
+      else
+	{
+	  if (c == ' ' || c == '\t' || c == '\n')
+	    continue;
+	  else if (c == '%' || c == '#')
+	    in_comment = 1;
+	  else
+	    {
+	      ungetc (c, ffile);
+	      break;
+	    }
+	}
+    }
+}
+
+static int
+is_function_file (FILE *ffile)
+{
+  int status = 0;
+
+  gobble_leading_white_space (ffile);
+
+  long pos = ftell (ffile);
+
+  char buf [10];
+  fgets (buf, 10, ffile);
+  int len = strlen (buf);
+  if (len > 8 && strncmp (buf, "function", 8) == 0
+      && ! (isalnum (buf[8]) || buf[8] == '_'))
+    status = 1;
+
+  fseek (ffile, pos, SEEK_SET);
+
+  return status;
+}
+
+static int
+parse_fcn_file (int exec_script, char *ff)
+{
+  begin_unwind_frame ("parse_fcn_file");
+
+  int script_file_executed = 0;
+
+  assert (ff);
+
+// Open function file and parse.
+
+  int old_reading_fcn_file_state = reading_fcn_file;
+
+  unwind_protect_ptr (rl_instream);
+  unwind_protect_ptr (ff_instream);
+
+  unwind_protect_int (using_readline);
+  unwind_protect_int (input_line_number);
+  unwind_protect_int (current_input_column);
+  unwind_protect_int (reading_fcn_file);
+
+  using_readline = 0;
+  reading_fcn_file = 1;
+  input_line_number = 0;
+  current_input_column = 1;
+
+  FILE *ffile = get_input_from_file (ff, 0);
+
+  if (ffile)
+    {
+// Check to see if this file defines a function or is just a list of
+// commands.
+
+      if (is_function_file (ffile))
+	{
+	  unwind_protect_int (echo_input);
+	  unwind_protect_int (saving_history);
+	  unwind_protect_int (reading_fcn_file);
+
+	  echo_input = 0;
+	  saving_history = 0;
+	  reading_fcn_file = 1;
+
+	  YY_BUFFER_STATE old_buf = current_buffer ();
+	  YY_BUFFER_STATE new_buf = create_buffer (ffile);
+
+	  add_unwind_protect (restore_input_buffer, (void *) old_buf);
+	  add_unwind_protect (delete_input_buffer, (void *) new_buf);
+
+	  switch_to_buffer (new_buf);
+
+	  unwind_protect_ptr (curr_sym_tab);
+
+	  reset_parser ();
+
+	  int status = yyparse ();
+
+	  if (status != 0)
+	    {
+	      error ("parse error while reading function file %s", ff);
+	      global_sym_tab->clear (curr_fcn_file_name);
+	    }
+	}
+      else if (exec_script)
+	{
+// The value of `reading_fcn_file' will be restored to the proper value
+// when we unwind from this frame.
+	  reading_fcn_file = old_reading_fcn_file_state;
+
+	  unwind_protect_int (reading_script_file);
+	  reading_script_file = 1;
+
+	  parse_and_execute (ffile, 1);
+
+	  script_file_executed = 1;
+	}
+      fclose (ffile);
+    }
+
+  run_unwind_frame ("parse_fcn_file");
+
+  return script_file_executed;
+}
+
+int
+load_fcn_from_file (symbol_record *sym_rec, int exec_script)
+{
+  int script_file_executed = 0;
+
+  char *nm = sym_rec->name ();
+
+  curr_fcn_file_name = nm;
+
+  char *oct_file = oct_file_in_path (curr_fcn_file_name);
+
+  int loaded_oct_file = 0;
+
+  if (oct_file)
+    {
+      cerr << "found: " << oct_file << "\n";
+
+      delete [] oct_file;
+
+// XXX FIXME XXX -- this is where we try to link to an external
+// object...
+      loaded_oct_file = 1;
+    }
+
+  if (! loaded_oct_file)
+    {
+      char *ff = fcn_file_in_path (curr_fcn_file_name);
+
+      if (ff)
+	{
+	  script_file_executed = parse_fcn_file (exec_script, ff);
+	  delete [] ff;
+	}
+
+      if (! (error_state || script_file_executed))
+	force_link_to_function (nm);
+    }
+
+  return script_file_executed;
+}
+
+int
+lookup (symbol_record *sym_rec, int exec_script)
+{
+  int script_file_executed = 0;
+
+  if (! sym_rec->is_linked_to_global ())
+    {
+      if (sym_rec->is_defined ())
+	{
+	  if (sym_rec->is_function () && symbol_out_of_date (sym_rec))
+	    {
+	      script_file_executed = load_fcn_from_file (sym_rec, exec_script);
+	    }
+	}
+      else if (! sym_rec->is_formal_parameter ())
+	{
+	  link_to_builtin_or_function (sym_rec);
+	  
+	  if (! sym_rec->is_defined ())
+	    {
+	      script_file_executed = load_fcn_from_file (sym_rec, exec_script);
+	    }
+	  else if (sym_rec->is_function () && symbol_out_of_date (sym_rec))
+	    {
+	      script_file_executed = load_fcn_from_file (sym_rec, exec_script);
+	    }
+	}
+    }
+
+  return script_file_executed;
+}
+
+// Get the symbol record for the given name that is visible in the
+// current scope.  Reread any function definitions that appear to be
+// out of date.  If a function is available in a file but is not
+// currently loaded, this will load it and insert the name in the
+// current symbol table.
+
+symbol_record *
+lookup_by_name (const char *nm, int exec_script)
+{
+  symbol_record *sym_rec = curr_sym_tab->lookup (nm, 1, 0);
+
+  lookup (sym_rec, exec_script);
+
+  return sym_rec;
+}
+
 void
 document_symbol (const char *name, const char *help)
 {
   if (is_builtin_variable (name))
     {
       error ("sorry, can't redefine help for builtin variables");
     }
   else
@@ -232,20 +460,19 @@ bind_nargin_and_nargout (symbol_table *s
 
   sr = sym_tab->lookup ("nargout", 1, 0);
   sr->unprotect ();
   tmp = new tree_constant (nargout);
   sr->define (tmp);
   sr->protect ();
 }
 
-/*
- * Give a global variable a definition.  This will insert the symbol
- * in the global table if necessary.
- */
+// Give a global variable a definition.  This will insert the symbol
+// in the global table if necessary.
+
 void
 bind_builtin_variable (const char *varname, tree_constant *val,
 		       int protect, int eternal, sv_Function sv_fcn,
 		       const char *help)
 {
   symbol_record *sr = global_sym_tab->lookup (varname, 1, 0);
 
 // It is a programming error for a builtin symbol to be missing.
@@ -269,20 +496,19 @@ bind_builtin_variable (const char *varna
 
   if (eternal)
     sr->make_eternal ();
 
   if (help)
     sr->document (help);    
 }
 
-/*
- * Look for the given name in the global symbol table.  If it refers
- * to a string, return a new copy.  If not, return 0;
- */
+// Look for the given name in the global symbol table.  If it refers
+// to a string, return a new copy.  If not, return 0;
+
 char *
 builtin_string_variable (const char *name)
 {
   symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
 
 // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
@@ -301,21 +527,20 @@ builtin_string_variable (const char *nam
 	  if (s)
 	    retval = strsave (s);
 	}
     }
 
   return retval;
 }
 
-/*
- * Look for the given name in the global symbol table.  If it refers
- * to a real scalar, place the value in d and return 0.  Otherwise,
- * return -1. 
- */
+// Look for the given name in the global symbol table.  If it refers
+// to a real scalar, place the value in d and return 0.  Otherwise,
+// return -1. 
+
 int
 builtin_real_scalar_variable (const char *name, double& d)
 {
   int status = -1;
   symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
 
 // It is a prorgramming error to look for builtins that aren't.
 
@@ -333,21 +558,20 @@ builtin_real_scalar_variable (const char
 	  d = val.double_value ();
 	  status = 0;
 	}
     }
 
   return status;
 }
 
-/*
- * Make the definition of the symbol record sr be the same as the
- * definition of the global variable of the same name, creating it if
- * it doesn't already exist. 
- */
+// Make the definition of the symbol record sr be the same as the
+// definition of the global variable of the same name, creating it if
+// it doesn't already exist. 
+
 void
 link_to_global_variable (symbol_record *sr)
 {
   if (sr->is_linked_to_global ())
     return;
 
   symbol_record *gsr = global_sym_tab->lookup (sr->name (), 1, 0);
 
@@ -377,55 +601,52 @@ link_to_global_variable (symbol_record *
 
   if (gsr->is_function ())
     gsr->define ((tree_constant *) 0);
 
   sr->alias (gsr, 1);
   sr->mark_as_linked_to_global ();
 }
 
-/*
- * Make the definition of the symbol record sr be the same as the
- * definition of the builtin variable of the same name.
- */
+// Make the definition of the symbol record sr be the same as the
+// definition of the builtin variable of the same name.
+
 void
 link_to_builtin_variable (symbol_record *sr)
 {
   symbol_record *tmp_sym = global_sym_tab->lookup (sr->name (), 0, 0);
 
   if (tmp_sym && tmp_sym->is_builtin_variable ())
     sr->alias (tmp_sym);
 }
 
-/*
- * Make the definition of the symbol record sr be the same as the
- * definition of the builtin variable or function, or user function of
- * the same name, provided that the name has not been used as a formal
- * parameter.
- */
+// Make the definition of the symbol record sr be the same as the
+// definition of the builtin variable or function, or user function of
+// the same name, provided that the name has not been used as a formal
+// parameter.
+
 void
 link_to_builtin_or_function (symbol_record *sr)
 {
   symbol_record *tmp_sym = global_sym_tab->lookup (sr->name (), 0, 0);
 
   if (tmp_sym
       && (tmp_sym->is_builtin_variable () || tmp_sym->is_function ())
       && ! tmp_sym->is_formal_parameter ())
     sr->alias (tmp_sym);
 }
 
-/*
- * Force a link to a function in the current symbol table.  This is
- * used just after defining a function to avoid different behavior
- * depending on whether or not the function has been evaluated after
- * being defined.
- *
- * Return without doing anything if there isn't a function with the
- * given name defined in the global symbol table.
- */
+// Force a link to a function in the current symbol table.  This is
+// used just after defining a function to avoid different behavior
+// depending on whether or not the function has been evaluated after
+// being defined.
+//
+// Return without doing anything if there isn't a function with the
+// given name defined in the global symbol table.
+
 void
 force_link_to_function (const char *id_name)
 {
   symbol_record *gsr = global_sym_tab->lookup (id_name, 1, 0);
   if (gsr->is_function ())
     {
       curr_sym_tab->clear (id_name);
       symbol_record *csr = curr_sym_tab->lookup (id_name, 1, 0);
@@ -451,25 +672,24 @@ otherwise, return 0.")
 
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
 
   retval = (double) (sr && sr->is_linked_to_global ());
 
   return retval;
 }
 
-/*
- * Extract a keyword and its value from a file.  Input should look
- * something like:
- *
- *  #[ \t]*keyword[ \t]*:[ \t]*string-value\n
- *
- * Returns a pointer to new storage.  The caller is responsible for
- * deleting it.
- */
+// Extract a keyword and its value from a file.  Input should look
+// something like:
+//
+//  #[ \t]*keyword[ \t]*:[ \t]*string-value\n
+//
+// Returns a pointer to new storage.  The caller is responsible for
+// deleting it.
+
 char *
 extract_keyword (istream& is, char *keyword)
 {
   ostrstream buf;
 
   char *retval = 0;
 
   char c;
@@ -553,19 +773,18 @@ extract_keyword (istream& is, char *keyw
 		; // Skip to beginning of next line;
 	      break;
 	    }
 	}
     }
   return status;
 }
 
-/*
- * Skip trailing white space and
- */
+// Skip trailing white space and
+
 void
 skip_comments (istream& is)
 {
   char c = '\0';
   while (is.get (c))
     {
       if (c == ' ' || c == '\t' || c == '\n')
 	; // Skip whitespace on way to beginning of next line.
@@ -578,19 +797,18 @@ skip_comments (istream& is)
       if (is && c == '#')
 	while (is.get (c) && c != '\n')
 	  ; // Skip to beginning of next line, ignoring everything.
       else
 	break;
     }
 }
 
-/*
- * Is `s' a valid identifier?
- */
+// Is `s' a valid identifier?
+
 int
 valid_identifier (char *s)
 {
   if (! s || ! (isalnum (*s) || *s == '_'))
      return 0;
 
   while (*++s != '\0')
     if (! (isalnum (*s) || *s == '_'))
@@ -641,71 +859,64 @@ a function.")
 	  if (stat (name, &buf) == 0 && S_ISREG (buf.st_mode))
 	    retval = 2.0;
 	}
     }
 
   return retval;
 }
 
-/*
- * Is this variable a builtin?
- */
+// Is this variable a builtin?
+
 int
 is_builtin_variable (const char *name)
 {
   symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
   return (sr && sr->is_builtin_variable ());
 }
 
-/*
- * Is this tree_constant a valid function?
- */
+// Is this tree_constant a valid function?
+
 tree_fvc *
 is_valid_function (const tree_constant& arg, char *warn_for, int warn)
 {
   tree_fvc *ans = 0;
 
   if (! arg.is_string_type ())
     {
       if (warn)
 	error ("%s: expecting function name as argument", warn_for);
       return ans;
     }
 
   char *fcn_name = arg.string_value ();
   symbol_record *sr = global_sym_tab->lookup (fcn_name, 0, 0);
 
   if (sr && symbol_out_of_date (sr))
-    {
-      tree_identifier tmp (sr);
-      tmp.load_fcn_from_file (0);
-    }
+    load_fcn_from_file (sr, 0);
   else
     {
       sr = global_sym_tab->lookup (fcn_name, 1, 0);
-      tree_identifier tmp (sr);
-      tmp.load_fcn_from_file (0);
+      load_fcn_from_file (sr, 0);
     }
 
   ans = sr->def ();
   if (! ans || ! sr->is_function ())
     {
       if (warn)
 	error ("%s: the symbol `%s' is not valid as a function",
 	       warn_for, fcn_name);
       ans = 0;
     }
 
   return ans;
 }
 
-/*
- * Does this function take the right number of arguments?
- */
+// Does this function take the right number of arguments?
+
 int
 takes_correct_nargs (tree_fvc *fcn, int expected_nargin, char *warn_for,
 		     int warn)
 {
   int nargin = fcn->max_expected_args () - 1;
   int e_nargin = expected_nargin - 1;
   if (nargin != e_nargin)
     {
@@ -967,19 +1178,18 @@ install_builtin_variables (void)
 	  "true", 0, 0, 1, warn_comma_in_global_decl,
     "produce warning for commas in global declarations");
 
   DEFVAR ("warn_divide_by_zero", SBV_warn_divide_by_zero, "true", 0, 0,
 	  1, warn_divide_by_zero,
     "on IEEE machines, allow divide by zero errors to be suppressed");
 }
 
-/*
- * List variable names.
- */
+// List variable names.
+
 static void
 print_symbol_info_line (ostrstream& output_buf, const symbol_record_info& s)
 {
   output_buf << (s.is_read_only () ? " -" : " w");
   output_buf << (s.is_eternal () ? "- " : "d ");
 #if 0
   output_buf << (s.hides_fcn () ? "f" : (s.hides_builtin () ? "F" : "-"));
 #endif
@@ -1370,19 +1580,18 @@ load variables from a file")
   if (file);
     file.close ();
 
   DELETE_ARGV;
 
   return retval;
 }
 
-/*
- * Return nonzero if PATTERN has any special globbing chars in it.
- */
+// Return nonzero if PATTERN has any special globbing chars in it.
+
 static int
 glob_pattern_p (char *pattern)
 {
   char *p = pattern;
   char c;
   int open = 0;
 
   while ((c = *p++) != '\0')
@@ -1525,26 +1734,21 @@ save variables in a file")
   if (file);
     file.close ();
 
   DELETE_ARGV;
 
   return retval;
 }
 
-DEFUN_TEXT ("who", Fwho, Swho, -1, 1,
-  "who [-all] [-builtins] [-functions] [-long] [-variables]\n\
-\n\
-List currently defined symbol(s).  Options may be shortened to one\n\
-character, but may not be combined.")
+static Octave_object
+do_who (int argc, char **argv, int nargout)
 {
   Octave_object retval;
 
-  DEFINE_ARGV("who");
-
   int show_builtins = 0;
   int show_functions = (curr_sym_tab == top_level_sym_tab);
   int show_variables = 1;
   int show_verbose = 0;
 
   if (argc > 1)
     {
       show_functions = 0;
@@ -1623,21 +1827,62 @@ character, but may not be combined.")
     }
 
   if (pad_after)
     output_buf << "\n";
 
   output_buf << ends;
   maybe_page_output (output_buf);
 
+  return retval;
+}
+
+DEFUN_TEXT ("who", Fwho, Swho, -1, 1,
+  "who [-all] [-builtins] [-functions] [-long] [-variables]\n\
+\n\
+List currently defined symbol(s).  Options may be shortened to one\n\
+character, but may not be combined.")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("who");
+
+  retval = do_who (argc, argv, nargout);
+
   DELETE_ARGV;
 
   return retval;
 }
 
+DEFUN_TEXT ("whos", Fwhos, Swhos, -1, 1,
+  "whos [-all] [-builtins] [-functions] [-long] [-variables]\n\
+\n\
+List currently defined symbol(s).  Options may be shortened to one\n\
+character, but may not be combined.")
+{
+  Octave_object retval;
+
+  Octave_object tmp_args = args;
+  tmp_args(args.length ()) = "-long";
+
+  int argc = tmp_args.length ();
+  char **argv = make_argv (tmp_args, "whos");
+
+  if (error_state)
+    return retval;
+
+  retval = do_who (argc, argv, nargout);
+
+  while (--argc >= 0)
+    delete [] argv[argc];
+  delete [] argv;
+
+  return retval;
+}
+
 // XXX FIXME XXX -- should these really be here?
 
 char *
 octave_home (void)
 {
 #ifdef RUN_IN_PLACE
   static char *home = OCTAVE_HOME;
   return home;
@@ -1680,25 +1925,24 @@ octave_info_dir (void)
   static char *oi = 0;
   delete [] oi;
   char *oh = octave_home ();
   oi = strconcat (oh, "/info/");
   return oi;
 #endif
 }
 
-/*
- * Handle OCTAVE_PATH from the environment like TeX handles TEXINPUTS.
- * If the path starts with `:', prepend the standard path.  If it ends
- * with `:' append the standard path.  If it begins and ends with
- * `:', do both (which is useless, but the luser asked for it...).
- *
- * This function may eventually be called more than once, so be
- * careful not to create memory leaks. 
- */
+// Handle OCTAVE_PATH from the environment like TeX handles TEXINPUTS.
+// If the path starts with `:', prepend the standard path.  If it ends
+// with `:' append the standard path.  If it begins and ends with
+// `:', do both (which is useless, but the luser asked for it...).
+//
+// This function may eventually be called more than once, so be
+// careful not to create memory leaks. 
+
 char *
 default_path (void)
 {
   static char *pathstring = 0;
   delete [] pathstring;
 
   static char *std_path = 0;
   delete [] std_path;
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -61,16 +61,22 @@ struct builtin_function
   Octave_builtin_fcn fcn;
   char *help_string;
 };
 
 extern void initialize_symbol_tables (void);
 
 extern int symbol_out_of_date (symbol_record *sr);
 
+extern int load_fcn_from_file (symbol_record *s, int exec_script = 1);
+
+extern int lookup (symbol_record *s, int exec_script = 1);
+
+extern symbol_record *lookup_by_name (const char *nm, int exec_script = 1);
+
 extern void document_symbol (const char *name, const char *help);
 
 extern void install_builtin_mapper (builtin_mapper_function *mf);
 
 extern void install_builtin_function (builtin_function *gf);
 
 extern void install_builtin_variable (builtin_variable *v);
 
