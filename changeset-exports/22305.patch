# HG changeset patch
# User Barbara Locsi <locsi.barbara@gmail.com>
# Date 1471309678 -3600
#      Tue Aug 16 02:07:58 2016 +0100
# Node ID 510886d03ef2e0a9db03e80dbc522ff38471424d
# Parent  c0cdf1c92086db3e9c2e9aad15fe19df66f5c109
eig: new options for choice of algorithm, balancing, and output (patch #8960)

* libinterp/corefcn/eig.cc: add preliminary balancing option, computation of
left eigenvectors as a third output, choosing among generalized eigenvalue
algorithms (chol or qz), and choosing among return value formats of the
eigenvalues (vector or matrix).  Expand documentation for new options and
add several new tests (and remove duplicated code in existing tests).
* liboctave/numeric/EIG.cc, liboctave/numeric/fEIG.cc: change dgeev, zgeev,
sgeev, and cgeev, to dgeevx, zgeevx, sgeevx, and cgeevx respectively which
allow for more control over thr solution process.  Add new flags to the
functions to support the new options added to the interpreter's eig.
* liboctave/numeric/EIG.h, liboctave/numeric/fEIG.h: fix function declaration
to include the new options.

diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -143,17 +143,17 @@ qp (const Matrix& H, const ColumnVector&
       eigH = EIG (H);
     }
   catch (octave_execution_exception& e)
     {
       error (e, "qp: failed to compute eigenvalues of H");
     }
 
   ColumnVector eigenvalH = real (eigH.eigenvalues ());
-  Matrix eigenvecH = real (eigH.eigenvectors ());
+  Matrix eigenvecH = real (eigH.right_eigenvectors ());
   double minReal = eigenvalH.min ();
   octave_idx_type indminR = 0;
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (minReal == eigenvalH(i))
         {
           indminR = i;
           break;
@@ -291,17 +291,17 @@ qp (const Matrix& H, const ColumnVector&
                   eigrH = EIG (rH);
                 }
               catch (octave_execution_exception& e)
                 {
                   error (e, "qp: failed to compute eigenvalues of rH");
                 }
 
               ColumnVector eigenvalrH = real (eigrH.eigenvalues ());
-              Matrix eigenvecrH = real (eigrH.eigenvectors ());
+              Matrix eigenvecrH = real (eigrH.right_eigenvectors ());
               double mRrH = eigenvalrH.min ();
               indminR = 0;
               for (octave_idx_type i = 0; i < n; i++)
                 {
                   if (mRrH == eigenvalH(i))
                     {
                       indminR = i;
                       break;
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -1,11 +1,12 @@
 /*
 
 Copyright (C) 1996-2015 John W. Eaton
+Copyright (C) 2016 Barbara Lócsi
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -19,279 +20,624 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "EIG.h"
-#include "fEIG.h"
-
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
-#include "utils.h"
+
+#include "EIG.h"
+#include "fEIG.h"
+#include "oct-string.h"
 
 DEFUN (eig, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{lambda} =} eig (@var{A})
 @deftypefnx {} {@var{lambda} =} eig (@var{A}, @var{B})
 @deftypefnx {} {[@var{V}, @var{lambda}] =} eig (@var{A})
 @deftypefnx {} {[@var{V}, @var{lambda}] =} eig (@var{A}, @var{B})
-Compute the eigenvalues (and optionally the eigenvectors) of a matrix
-or a pair of matrices
+@deftypefnx {} {[@var{V}, @var{lambda}, @var{W}] =} eig (@var{A})
+@deftypefnx {} {[@var{V}, @var{lambda}, @var{W}] =} eig (@var{A}, @var{B})
+@deftypefnx {} {[@dots{}] =} eig (@var{A}, @var{balanceOption})
+@deftypefnx {} {[@dots{}] =} eig (@var{A}, @var{B}, @var{algorithm})
+@deftypefnx {} {[@dots{}] =} eig (@dots{}, @var{eigvalOption})
+Compute the right eigenvalues(V) and optionally the eigenvectors(lambda) and
+the left eigenvalues(W) of a matrix or a pair of matrices.
+
+The flag @var{balanceOption} can be one of:
+
+@table @asis
+@item @qcode{"balance"}
+Preliminary balancing is on. (default)
+
+@item @qcode{"nobalance"}
+Disables preliminary balancing.
+@end table
+
+The flag @var{eigvalOption} can be one of:
+
+@table @asis
+@item @qcode{"matrix"}
+Return the eigenvalues in a diagonal matrix. (default if 2 or 3 outputs
+are specified)
 
-The algorithm used depends on whether there are one or two input
-matrices, if they are real or complex, and if they are symmetric
-(Hermitian if complex) or non-symmetric.
+@item @qcode{"vector"}
+Return the eigenvalues in a column vector. (default if 1 output is
+specified, e.g. @var{lambda} = eig (@var{A}))
+@end table
+
+The flag @var{algorithm} can be one of:
+
+@table @asis
+@item @qcode{"chol"}
+Uses the Cholesky factorization of B. (default if A is symmetric (Hermitian)
+and B is symmetric (Hermitian) positive definite)
+
+@item @qcode{"qz"}
+Uses the QZ algorithm. (When A or B are not symmetric always the
+QZ algorithm will be used)
+@end table
+
+@multitable @columnfractions .31 .23 .23 .23
+@headitem @tab no flag @tab chol @tab qz
+@item both are symmetric
+@tab @qcode{"chol"}
+@tab @qcode{"chol"}
+@tab @qcode{"qz"}
+@item at least one is not symmetric
+@tab @qcode{"qz"}
+@tab @qcode{"qz"}
+@tab @qcode{"qz"}
+@end multitable
 
 The eigenvalues returned by @code{eig} are not ordered.
 @seealso{eigs, svd}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
-  if (nargin > 2 || nargin == 0)
+  if (nargin > 4 || nargin == 0)
     print_usage ();
 
   octave_value_list retval;
 
   octave_value arg_a, arg_b;
 
-  octave_idx_type nr_a, nr_b, nc_a, nc_b;
-  nr_a = nr_b = nc_a = nc_b = 0;
+  arg_a = args(0);
 
-  arg_a = args(0);
-  nr_a = arg_a.rows ();
-  nc_a = arg_a.columns ();
-
-  int arg_is_empty = empty_arg ("eig", nr_a, nc_a);
-  if (arg_is_empty < 0)
-    return retval;
-  else if (arg_is_empty > 0)
+  if (arg_a.is_empty ())
     return octave_value_list (2, Matrix ());
 
-  if (! arg_a.is_double_type () && ! arg_a.is_single_type ())
+  if (! arg_a.is_float_type ())
     err_wrong_type_arg ("eig", arg_a);
 
-  if (nargin == 2)
-    {
-      arg_b = args(1);
-      nr_b = arg_b.rows ();
-      nc_b = arg_b.columns ();
+  if (arg_a.rows () != arg_a.columns ())
+    err_square_matrix_required ("eig", "A");
+
+  // determine if it's AEP or GEP
+  bool AEPcase = nargin == 1 || args(1).is_string ();
+
+  if (! AEPcase)
+  {
+    arg_b = args(1);
+
+    if (arg_b.is_empty ())
+      return octave_value_list (2, Matrix ());
+
+    if (! arg_b.is_float_type ())
+      err_wrong_type_arg ("eig", arg_b);
+
+    if (arg_b.rows () != arg_b.columns ())
+      err_square_matrix_required ("eig", "B");
+  }
 
-      arg_is_empty = empty_arg ("eig", nr_b, nc_b);
-      if (arg_is_empty < 0)
-        return retval;
-      else if (arg_is_empty > 0)
-        return ovl (2, Matrix ());
+  bool qz_flag = false;
+  bool chol_flag = false;
+  bool balance_flag = false;
+  bool no_balance_flag = false;
+  bool matrix_flag = false;
+  bool vector_flag = false;
+
+  for (int i = (AEPcase ? 1 : 2); i < args.length (); ++i)
+    {
+      if (! args(i).is_string ())
+        err_wrong_type_arg ("eig", args(i));
 
-      if (! arg_b.is_single_type () && ! arg_b.is_double_type ())
-        err_wrong_type_arg ("eig", arg_b);
+      std::string arg_i = args(i).string_value ();
+      if (octave::string::strcmpi (arg_i, "qz"))
+        qz_flag = true;
+      else if (octave::string::strcmpi (arg_i, "chol"))
+        chol_flag = true;
+      else if (octave::string::strcmpi (arg_i, "balance"))
+        balance_flag = true;
+      else if (octave::string::strcmpi (arg_i, "nobalance"))
+        no_balance_flag = true;
+      else if (octave::string::strcmpi (arg_i, "matrix"))
+        matrix_flag = true;
+      else if (octave::string::strcmpi (arg_i, "vector"))
+        vector_flag = true;
+      else
+        error ("eig: invalid option \"%s\"", arg_i.c_str ());
     }
 
-  if (nr_a != nc_a)
-    err_square_matrix_required ("eig", "A");
+  if (balance_flag && no_balance_flag)
+    error ("eig: \"balance\" and \"nobalance\" options are mutually exclusive");
+  if (vector_flag && matrix_flag)
+    error ("eig: \"vector\" and \"matrix\" options are mutually exclusive");
+  if (qz_flag && chol_flag)
+    error ("eig: \"qz\" and \"chol\" options are mutually exclusive");
 
-  if (nargin == 2 && nr_b != nc_b)
-    err_square_matrix_required ("eig", "B");
+  if (AEPcase)
+    {
+      if (qz_flag)
+        error ("eig: invalid \"qz\" option for algebraic eigenvalue problem");
+      if (chol_flag)
+        error ("eig: invalid \"chol\" option for algebraic eigenvalue problem");
+    }
+  else
+    {
+      if (balance_flag)
+        error ("eig: invalid \"balance\" option for generalized eigenvalue problem");
+      if (no_balance_flag)
+        error ("eig: invalid \"nobalance\" option for generalized eigenvalue problem");
+    }
+
+  // Default is to balance
+  const bool balance = no_balance_flag ? false : true;
+  const bool force_qz = qz_flag;
+
 
   Matrix tmp_a, tmp_b;
   ComplexMatrix ctmp_a, ctmp_b;
   FloatMatrix ftmp_a, ftmp_b;
   FloatComplexMatrix fctmp_a, fctmp_b;
 
   if (arg_a.is_single_type ())
     {
       FloatEIG result;
-
-      if (nargin == 1)
+      if (AEPcase)
         {
           if (arg_a.is_real_type ())
             {
               ftmp_a = arg_a.float_matrix_value ();
 
-              result = FloatEIG (ftmp_a, nargout > 1);
+              result = FloatEIG (ftmp_a, nargout > 1, nargout > 2, balance);
             }
           else
             {
               fctmp_a = arg_a.float_complex_matrix_value ();
 
-              result = FloatEIG (fctmp_a, nargout > 1);
+              result = FloatEIG (fctmp_a, nargout > 1, nargout > 2, balance);
             }
         }
-      else if (nargin == 2)
+      else
         {
           if (arg_a.is_real_type () && arg_b.is_real_type ())
             {
               ftmp_a = arg_a.float_matrix_value ();
               ftmp_b = arg_b.float_matrix_value ();
 
-              result = FloatEIG (ftmp_a, ftmp_b, nargout > 1);
+              result = FloatEIG (ftmp_a, ftmp_b, nargout > 1, nargout > 2,
+                                 force_qz);
             }
           else
             {
               fctmp_a = arg_a.float_complex_matrix_value ();
               fctmp_b = arg_b.float_complex_matrix_value ();
 
-              result = FloatEIG (fctmp_a, fctmp_b, nargout > 1);
+              result = FloatEIG (fctmp_a, fctmp_b, nargout > 1, nargout > 2,
+                                 force_qz);
             }
         }
 
       if (nargout == 0 || nargout == 1)
         {
-          retval = ovl (result.eigenvalues ());
+          if (matrix_flag)
+            retval = ovl (FloatComplexDiagMatrix (result.eigenvalues ()));
+          else
+            retval = ovl (result.eigenvalues ());
+        }
+      else if (nargout == 2)
+        {
+          if (vector_flag)
+            retval = ovl (result.right_eigenvectors (), result.eigenvalues ());
+          else
+            retval = ovl (result.right_eigenvectors (),
+                          FloatComplexDiagMatrix (result.eigenvalues ()));
         }
       else
         {
-          // Blame it on Matlab.
-          FloatComplexDiagMatrix d (result.eigenvalues ());
-
-          retval = ovl (result.eigenvectors (), d);
+          if (vector_flag)
+            retval = ovl (result.right_eigenvectors (),
+                          result.eigenvalues (),
+                          result.left_eigenvectors ());
+          else
+            retval = ovl (result.right_eigenvectors (),
+                          FloatComplexDiagMatrix (result.eigenvalues ()),
+                          result.left_eigenvectors ());
         }
     }
   else
     {
       EIG result;
 
-      if (nargin == 1)
+      if (AEPcase)
         {
           if (arg_a.is_real_type ())
             {
               tmp_a = arg_a.matrix_value ();
 
-              result = EIG (tmp_a, nargout > 1);
+              result = EIG (tmp_a, nargout > 1, nargout > 2, balance);
             }
           else
             {
               ctmp_a = arg_a.complex_matrix_value ();
 
-              result = EIG (ctmp_a, nargout > 1);
+              result = EIG (ctmp_a, nargout > 1, nargout > 2, balance);
             }
         }
-      else if (nargin == 2)
+      else
         {
           if (arg_a.is_real_type () && arg_b.is_real_type ())
             {
               tmp_a = arg_a.matrix_value ();
               tmp_b = arg_b.matrix_value ();
 
-              result = EIG (tmp_a, tmp_b, nargout > 1);
+              result = EIG (tmp_a, tmp_b, nargout > 1, nargout > 2, force_qz);
             }
           else
             {
               ctmp_a = arg_a.complex_matrix_value ();
               ctmp_b = arg_b.complex_matrix_value ();
 
-              result = EIG (ctmp_a, ctmp_b, nargout > 1);
+              result = EIG (ctmp_a, ctmp_b, nargout > 1, nargout > 2, force_qz);
             }
         }
 
       if (nargout == 0 || nargout == 1)
         {
-          retval = ovl (result.eigenvalues ());
+          if (matrix_flag)
+            retval = ovl (ComplexDiagMatrix (result.eigenvalues ()));
+          else
+            retval = ovl (result.eigenvalues ());
+        }
+      else if (nargout == 2)
+        {
+          if (vector_flag)
+            retval = ovl (result.right_eigenvectors (), result.eigenvalues ());
+          else
+            retval = ovl (result.right_eigenvectors (),
+                          ComplexDiagMatrix (result.eigenvalues ()));
         }
       else
         {
-          // Blame it on Matlab.
-          ComplexDiagMatrix d (result.eigenvalues ());
-
-          retval = ovl (result.eigenvectors (), d);
+          if (vector_flag)
+            retval = ovl (result.right_eigenvectors (),
+                          result.eigenvalues (),
+                          result.left_eigenvectors ());
+          else
+            retval = ovl (result.right_eigenvectors (),
+                          ComplexDiagMatrix (result.eigenvalues ()),
+                          result.left_eigenvectors ());
         }
     }
 
   return retval;
 }
 
 /*
 %!assert (eig ([1, 2; 2, 1]), [-1; 3], sqrt (eps))
 
 %!test
 %! [v, d] = eig ([1, 2; 2, 1]);
 %! x = 1 / sqrt (2);
-%! assert (d, [-1, 0; 0, 3], sqrt (eps));
-%! assert (v, [-x, x; x, x], sqrt (eps));
+%! assert (d, [-1, 0; 0, 3], sqrt (eps))
+%! assert (v, [-x, x; x, x], sqrt (eps))
+
+%!test
+%! [v, d, w] = eig ([1, 2; 2, 1]);
+%! x = 1 / sqrt (2);
+%! assert (w, [-x, x; x, x], sqrt (eps))
+
+%!test
+%! [v, d] = eig ([1, 2; 2, 1], "balance");
+%! x = 1 / sqrt (2);
+%! assert (d, [-1, 0; 0, 3], sqrt (eps))
+%! assert (v, [-x, x; x, x], sqrt (eps))
+
+%!test
+%! [v, d, w] = eig ([1, 2; 2, 1], "balance");
+%! x = 1 / sqrt (2);
+%! assert (w, [-x, x; x, x], sqrt (eps));
 
 %!assert (eig (single ([1, 2; 2, 1])), single ([-1; 3]), sqrt (eps ("single")))
 
+%!assert (eig (single ([1, 2; 2, 1]), "balance"),
+%!        single ([-1; 3]), sqrt (eps ("single")))
+
 %!test
 %! [v, d] = eig (single ([1, 2; 2, 1]));
 %! x = single (1 / sqrt (2));
-%! assert (d, single ([-1, 0; 0, 3]), sqrt (eps ("single")));
-%! assert (v, [-x, x; x, x], sqrt (eps ("single")));
-
-%!test
-%! A = [1, 2; -1, 1];  B = [3, 3; 1, 2];
-%! [v, d] = eig (A, B);
-%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
-%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
-
-%!test
-%! A = single ([1, 2; -1, 1]);  B = single ([3, 3; 1, 2]);
-%! [v, d] = eig (A, B);
-%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps ("single")));
-%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps ("single")));
+%! assert (d, single ([-1, 0; 0, 3]), sqrt (eps ("single")))
+%! assert (v, [-x, x; x, x], sqrt (eps ("single")))
 
 %!test
-%! A = [1, 2; 2, 1];  B = [3, -2; -2, 3];
-%! [v, d] = eig (A, B);
-%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
-%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
+%! [v, d, w] = eig (single ([1, 2; 2, 1]));
+%! x = single (1 / sqrt (2));
+%! assert (w, [-x, x; x, x], sqrt (eps ("single")))
 
 %!test
-%! A = single ([1, 2; 2, 1]);  B = single ([3, -2; -2, 3]);
-%! [v, d] = eig (A, B);
-%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps ("single")));
-%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps ("single")));
-
-%!test
-%! A = [1+3i, 2+i; 2-i, 1+3i];  B = [5+9i, 2+i; 2-i, 5+9i];
-%! [v, d] = eig (A, B);
-%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
-%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
+%! [v, d] = eig (single ([1, 2; 2, 1]), "balance");
+%! x = single (1 / sqrt (2));
+%! assert (d, single ([-1, 0; 0, 3]), sqrt (eps ("single")));
+%! assert (v, [-x, x; x, x], sqrt (eps ("single")))
 
 %!test
-%! A = single ([1+3i, 2+i; 2-i, 1+3i]);  B = single ([5+9i, 2+i; 2-i, 5+9i]);
-%! [v, d] = eig (A, B);
-%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps ("single")));
-%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps ("single")));
+%! [v, d, w] = eig (single ([1, 2; 2, 1]), "balance");
+%! x = single (1 / sqrt (2));
+%! assert (w, [-x, x; x, x], sqrt (eps ("single")))
+
+
+## If (at least one of) the matrices are non-symmetric,
+## regardless the algorithm flag the qz algorithm should be used.
+## So the results without algorithm flag, with "qz" and with "chol"
+## should be the same.
+%!function nonsym_chol_2_output (A, B, res = sqrt (eps))
+%!  [v, d] = eig (A, B);
+%!  [v2, d2] = eig (A, B, "qz");
+%!  [v3, d3] = eig (A, B, "chol");
+%!  assert (A * v(:, 1), d(1, 1) * B * v(:, 1), res)
+%!  assert (A * v(:, 2), d(2, 2) * B * v(:, 2), res)
+%!  assert (v, v2)
+%!  assert (v, v3)
+%!  assert (d, d2)
+%!  assert (d, d3)
+%!endfunction
+
+%!test nonsym_chol_2_output ([1, 2; -1, 1], [3, 3; 1, 2])
+%!test nonsym_chol_2_output ([1+3i, 2+3i; 3-8i, 8+3i], [8+i, 3+i; 4-9i, 3+i])
+%!test nonsym_chol_2_output ([1, 2; 3, 8], [8, 3; 4, 3])
+
+%!test nonsym_chol_2_output (single ([1, 2; -1, 1]),
+%!                           single ([3, 3; 1, 2]), sqrt (eps ("single")))
+%!test nonsym_chol_2_output (single ([1+3i, 2+3i; 3-8i, 8+3i]),
+%!                           single ([8+i, 3+i; 4-9i, 3+i]),
+%!                           sqrt (eps ("single")))
+
+%!function nonsym_chol_3_output (A, B, res = sqrt (eps))
+%!  [v, d, w] = eig (A, B);
+%!  [v2, d2, w2] = eig (A, B, "qz");
+%!  [v3, d3, w3] = eig (A, B, "chol");
+%!  wt = w';
+%!  assert (wt(1, :)* A, d(1, 1) * wt(1, :) * B, res)
+%!  assert (wt(2, :)* A, d(2, 2) * wt(2, :) * B, res)
+%!  assert (v, v2)
+%!  assert (v, v3)
+%!  assert (d, d2)
+%!  assert (d, d3)
+%!  assert (w, w2)
+%!  assert (w, w3)
+%!endfunction
+
+%!test nonsym_chol_3_output ([1, 2; -1, 1], [3, 3; 1, 2])
+%!test nonsym_chol_3_output ([1+3i, 2+3i; 3-8i, 8+3i], [8+i, 3+i; 4-9i, 3+i])
+%!test nonsym_chol_3_output ([1, 2; 3, 8], [8, 3; 4, 3])
 
+%!test nonsym_chol_3_output (single ([1, 2; -1, 1]),
+%!                           single ([3, 3; 1, 2]), sqrt (eps ("single")))
+%!test nonsym_chol_3_output (single ([1+3i, 2+3i; 3-8i, 8+3i]),
+%!                           single ([8+i, 3+i; 4-9i, 3+i]),
+%!                           sqrt (eps ("single")))
+
+## If the matrices are symmetric,
+## then the chol method is default.
+## So the results without algorithm flag and with "chol" should be the same.
+%!function sym_chol_2_input (A, B, res = sqrt (eps))
+%!  [v, d] = eig (A, B);
+%!  [v2, d2] = eig (A, B, "chol");
+%!  assert (A * v(:, 1), d(1, 1) * B * v(:, 1), res)
+%!  assert (A * v(:, 2), d(2, 2) * B * v(:, 2), res)
+%!  assert (v, v2)
+%!  assert (d, d2)
+%!endfunction
+
+%!test sym_chol_2_input ([1, 2; 2, 1], [3, -2; -2, 3])
+%!test sym_chol_2_input ([1+3i, 2+i; 2-i, 1+3i], [5+9i, 2+i; 2-i, 5+9i])
+%!test sym_chol_2_input ([1, 1+i; 1-i, 1], [2, 0; 0, 2])
+
+%!test sym_chol_2_input (single ([1, 2; 2, 1]), single ([3, -2; -2, 3]),
+%!                       sqrt (eps ("single")))
+%!test sym_chol_2_input (single ([1+3i, 2+i; 2-i, 1+3i]),
+%!                       single ([5+9i, 2+i; 2-i, 5+9i]), sqrt (eps ("single")))
+%!test sym_chol_2_input (single ([1, 1+i; 1-i, 1]), single ([2, 0; 0, 2]),
+%!                       sqrt (eps ("single")))
+
+%!function sym_chol_3_input (A, B, res = sqrt (eps))
+%!  [v, d, w] = eig (A, B);
+%!  [v2, d2, w2] = eig (A, B, "chol");
+%!  wt = w';
+%!  assert (wt(1, :)* A, d(1, 1) * wt(1, :) * B, res)
+%!  assert (wt(2, :)* A, d(2, 2) * wt(2, :) * B, res)
+%!  assert (v, v2)
+%!  assert (d, d2)
+%!  assert (w, w2)
+%!endfunction
+
+%!test sym_chol_3_input ([1, 2; 2, 1], [3, -2; -2, 3])
+%!test sym_chol_3_input ([1+3i, 2+i; 2-i, 1+3i], [5+9i, 2+i; 2-i, 5+9i])
+%!test sym_chol_3_input ([1, 1+i; 1-i, 1], [2, 0; 0, 2])
+
+%!test sym_chol_3_input (single ([1, 2; 2, 1]), single ([3, -2; -2, 3]),
+%!                       sqrt (eps ("single")))
+%!test sym_chol_3_input (single ([1+3i, 2+i; 2-i, 1+3i]),
+%!                       single ([5+9i, 2+i; 2-i, 5+9i]), sqrt (eps ("single")))
+%!test sym_chol_3_input (single ([1, 1+i; 1-i, 1]), single ([2, 0; 0, 2]),
+%!                       sqrt (eps ("single")))
+
+## "balance" is always default
+## so the results with and without "balance" should be the same
+## while in this case "nobalance" should produce different result
 %!test
-%! A = [1+3i, 2+3i; 3-8i, 8+3i];  B = [8+i, 3+i; 4-9i, 3+i];
-%! [v, d] = eig (A, B);
-%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
-%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
+%! A = [3 -2 -0.9 0; -2 4 1 -0; -0 0 -1 0; -0.5 -0.5 0.1 1];
+%! [V1, D1] = eig (A);
+%! [V2, D2] = eig (A, "balance");
+%! [V3, D3] = eig (A, "nobalance");
+%! assert (V1, V2)
+%! assert (D1, D2)
+%! assert (isequal (V2, V3), false)
+
+## Testing the flags in all combination.
+## If 2 flags are on, than the result should be the same regardless
+## of the flags order.
+## option1 represents the first order while option2 represents the other order.
+## d and d2 should be a diagonal matrix if "matrix" flag is on while
+## these should be column vectors if the "vector" flag is on.
+%!function test_eig_args (args, options1, options2, testd = @() true)
+%!  [v, d, w] = eig (args{:}, options1{:});
+%!  [v2, d2, w2] = eig (args{:}, options2{:});
+%!  assert (testd (d))
+%!  assert (testd (d2))
+%!  assert (v, v2)
+%!  assert (d, d2)
+%!  assert (w, w2)
+%!endfunction
+
+%!function qz_chol_with_shapes (A, B)
+%!  for shapes = struct ("name", {"vector", "matrix"},
+%!                       "test", {@isvector, @isdiag})
+%!    test_eig_args ({A, B}, {"qz", shapes.name},
+%!                   {shapes.name, "qz"}, shapes.test);
+%!    test_eig_args ({A, B}, {"chol", shapes.name},
+%!                   {shapes.name, "chol"}, shapes.test);
+%!  endfor
+%!endfunction
+
+%!function balance_nobalance_with_shapes (A)
+%!  for shapes = struct ("name", {"vector", "matrix"},
+%!                       "test", {@isvector, @isdiag})
+%!    test_eig_args ({A}, {"balance", shapes.name},
+%!                   {shapes.name, "balance"}, shapes.test);
+%!    test_eig_args ({A}, {"nobalance", shapes.name},
+%!                   {shapes.name, "nobalance"}, shapes.test);
+%!  endfor
+%!endfunction
 
-%!test
-%! A = single ([1+3i, 2+3i; 3-8i, 8+3i]);  B = single ([8+i, 3+i; 4-9i, 3+i]);
-%! [v, d] = eig (A, B);
-%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps ("single")));
-%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps ("single")));
+## Default return format:
+## diagonal matrix if 2 or 3 outputs are specified
+## column vector if 1 output is specified
+%!function test_shapes (args)
+%!  d = eig (args{:});
+%!  assert (isvector(d))
+%!  d2 = eig (args{:}, "vector");
+%!  assert (isvector(d2))
+%!  [v, d3] = eig (args{:});
+%!  assert (isdiag(d3))
+%!  d4 = eig (args{:}, "matrix");
+%!  assert (isdiag(d4))
+%!  [v, d5, w] = eig (args{:});
+%!  assert (isdiag(d5))
+%!  d6 = eig (args{:}, "matrix");
+%!  assert (isdiag(d6))
+%!  assert (d, d2)
+%!  assert (d3, d4)
+%!  assert (d5, d6)
+%!  assert (d, diag(d3))
+%!  assert (d, diag(d5))
+%!endfunction
+
+%!function shapes_AEP (A)
+%!  test_shapes({A});
+%!endfunction
+
+%!function shapes_GEP (A, B)
+%!  test_shapes({A, B});
+%!endfunction
+
+%!test balance_nobalance_with_shapes ([1, 2; 2, 1]);
+%!test balance_nobalance_with_shapes (single ([1, 2; 2, 1]));
+
+%!test shapes_AEP ([1, 2; 2, 1]);
+%!test shapes_AEP (single ([1, 2; 2, 1]));
+
+%!test qz_chol_with_shapes ([1, 1+i; 1-i, 1], [2, 0; 0, 2]);
+%!test qz_chol_with_shapes ([1, 2; 3, 8], [8, 3; 4, 3]);
+%!test qz_chol_with_shapes ([1, 2; -1, 1], [3, 3; 1, 2]);
+
+%!test qz_chol_with_shapes (single ([1, 1+i; 1-i, 1]),  single ([2, 0; 0, 2]));
+%!test qz_chol_with_shapes (single ([1, 2; 3, 8]),  single ([8, 3; 4, 3]));
+%!test qz_chol_with_shapes (single ([1, 2; -1, 1]),  single ([3, 3; 1, 2]));
+
+%!test shapes_GEP ([1, 1+i; 1-i, 1], [2, 0; 0, 2]);
+%!test shapes_GEP ([1, 2; 3, 8], [8, 3; 4, 3]);
+%!test shapes_GEP ([1, 2; -1, 1], [3, 3; 1, 2]);
+
+%!test shapes_GEP (single ([1, 1+i; 1-i, 1]),  single ([2, 0; 0, 2]));
+%!test shapes_GEP (single ([1, 2; 3, 8]),  single ([8, 3; 4, 3]));
+%!test shapes_GEP (single ([1, 2; -1, 1]),  single ([3, 3; 1, 2]));
+
+%!function chol_qz_accuracy (A, B, is_qz_accurate, is_chol_accurate)
+%!  [V1,D1] = eig (A,B, 'qz');
+%!  [V2,D2] = eig (A,B); #default is chol
+%!  assert (isequal (A*V1,A*V1*D1), is_qz_accurate)
+%!  assert (isequal (A*V2, A*V2*D2), is_chol_accurate)
+%!endfunction
 
 %!test
-%! A = [1, 2; 3, 8];  B = [8, 3; 4, 3];
-%! [v, d] = eig (A, B);
-%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
-%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
+%! minij_100 = gallery('minij',100);
+%! chol_qz_accuracy (minij_100, minij_100, false, true);
 
 %!test
-%! A = [1, 1+i; 1-i, 1];  B = [2, 0; 0, 2];
-%! [v, d] = eig (A, B);
-%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps));
-%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps));
+%! moler_100 = gallery('moler',100);
+%! chol_qz_accuracy (moler_100, moler_100, false, true);
 
 %!test
-%! A = single ([1, 1+i; 1-i, 1]);  B = single ([2, 0; 0, 2]);
-%! [v, d] = eig (A, B);
-%! assert (A * v(:, 1), d(1, 1) * B * v(:, 1), sqrt (eps ("single")));
-%! assert (A * v(:, 2), d(2, 2) * B * v(:, 2), sqrt (eps ("single")));
+%! A = diag([10^-16, 10^-15]);
+%! chol_qz_accuracy (A, A, true, false);
 
 %!error eig ()
+%!error eig (false)
 %!error eig ([1, 2; 3, 4], [4, 3; 2, 1], 1)
-%!error <EIG requires same size matrices> eig ([1, 2; 3, 4], 2)
-%!error <must be a square matrix> eig ([1, 2; 3, 4; 5, 6])
-%!error <wrong type argument> eig ("abcd")
-%!error <wrong type argument> eig ([1 2 ; 2 3], "abcd")
-%!error <wrong type argument> eig (false, [1 2 ; 2 3])
+
+%!error <EIG requires same size matrices>
+%!  eig ([1, 2; 3, 4], 2)
+%!error <must be a square matrix>
+%! eig ([1, 2; 3, 4; 5, 6])
+%!error <wrong type argument>
+%!  eig ("abcd")
+%!error <invalid option "abcd">
+%!  eig ([1 2 ; 2 3], "abcd")
+%!error <invalid "chol" option for algebraic eigenvalue problem>
+%!  eig ([1 2 ; 2 3], "chol")
+%!error <invalid "qz" option for algebraic eigenvalue problem>
+%!  eig ([1 2 ; 2 3], "qz")
+%!error <wrong type argument>
+%!  eig (false, [1 2 ; 2 3])
+%!error <invalid option "abcd">
+%!  eig ([1 2 ; 2 3], [1 2 ; 2 3], "abcd")
+%!error <invalid "qz" option for algebraic eigenvalue problem>
+%!  eig ([1 2 ; 2 3], "balance", "qz")
+%!error <invalid option "abcd">
+%!  eig ([1 2 ; 2 3], [1 2 ; 2 3], "vector", "abcd")
+%!error <invalid option "abcd">
+%!  eig ([1 2 ; 2 3], "balance", "matrix", "abcd")
+%!error <"balance" and "nobalance" options are mutually exclusive>
+%!  eig ([1 2 ; 2 3], "balance", "nobalance")
+%!error <"balance" and "nobalance" options are mutually exclusive>
+%!  eig ([1 2 ; 2 3], "nobalance", "balance")
+%!error <"vector" and "matrix" options are mutually exclusive>
+%!  eig ([1 2 ; 2 3], "matrix", "vector")
+%!error <"vector" and "matrix" options are mutually exclusive>
+%!  eig ([1 2 ; 2 3], "vector", "matrix")
+%!error <"vector" and "matrix" options are mutually exclusive>
+%!  eig ([1 2 ; 2 3], [1 2 ; 2 3], "matrix", "vector")
+%!error <"vector" and "matrix" options are mutually exclusive>
+%!  eig ([1 2 ; 2 3], [1 2 ; 2 3], "vector", "matrix")
+%!error <wrong type argument>
+%!  eig ([1 2 ; 2 3], [1 2 ; 2 3], false)
+%!error <wrong type argument>
+%!  eig ([1 2 ; 2 3], [1 2 ; 2 3], [1 2 ; 2 3])
 */
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -118,17 +118,17 @@ xpow (double a, const Matrix& b)
   if (nr == 0 || nc == 0 || nr != nc)
     err_nonsquare_matrix ();
 
   try
     {
       EIG b_eig (b);
 
       ComplexColumnVector lambda (b_eig.eigenvalues ());
-      ComplexMatrix Q (b_eig.eigenvectors ());
+      ComplexMatrix Q (b_eig.right_eigenvectors ());
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           Complex elt = lambda(i);
           if (std::imag (elt) == 0.0)
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
@@ -169,17 +169,17 @@ xpow (double a, const ComplexMatrix& b)
   if (nr == 0 || nc == 0 || nr != nc)
     err_nonsquare_matrix ();
 
   EIG b_eig (b);
 
   try
     {
       ComplexColumnVector lambda (b_eig.eigenvalues ());
-      ComplexMatrix Q (b_eig.eigenvectors ());
+      ComplexMatrix Q (b_eig.right_eigenvectors ());
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           Complex elt = lambda(i);
           if (std::imag (elt) == 0.0)
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
@@ -257,17 +257,17 @@ xpow (const Matrix& a, double b)
     }
   else
     {
       EIG a_eig (a);
 
       try
         {
           ComplexColumnVector lambda (a_eig.eigenvalues ());
-          ComplexMatrix Q (a_eig.eigenvectors ());
+          ComplexMatrix Q (a_eig.right_eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             lambda(i) = std::pow (lambda(i), b);
 
           ComplexDiagMatrix D (lambda);
 
           retval = ComplexMatrix (Q * D * Q.inverse ());
         }
@@ -333,17 +333,17 @@ xpow (const Matrix& a, const Complex& b)
   if (nr == 0 || nc == 0 || nr != nc)
     err_nonsquare_matrix ();
 
   EIG a_eig (a);
 
   try
     {
       ComplexColumnVector lambda (a_eig.eigenvalues ());
-      ComplexMatrix Q (a_eig.eigenvectors ());
+      ComplexMatrix Q (a_eig.right_eigenvectors ());
 
       for (octave_idx_type i = 0; i < nr; i++)
         lambda(i) = std::pow (lambda(i), b);
 
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
@@ -381,17 +381,17 @@ xpow (const Complex& a, const Matrix& b)
   if (nr == 0 || nc == 0 || nr != nc)
     err_nonsquare_matrix ();
 
   EIG b_eig (b);
 
   try
     {
       ComplexColumnVector lambda (b_eig.eigenvalues ());
-      ComplexMatrix Q (b_eig.eigenvectors ());
+      ComplexMatrix Q (b_eig.right_eigenvectors ());
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           Complex elt = lambda(i);
           if (std::imag (elt) == 0.0)
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
@@ -429,17 +429,17 @@ xpow (const Complex& a, const ComplexMat
   if (nr == 0 || nc == 0 || nr != nc)
     err_nonsquare_matrix ();
 
   EIG b_eig (b);
 
   try
     {
       ComplexColumnVector lambda (b_eig.eigenvalues ());
-      ComplexMatrix Q (b_eig.eigenvectors ());
+      ComplexMatrix Q (b_eig.right_eigenvectors ());
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           Complex elt = lambda(i);
           if (std::imag (elt) == 0.0)
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
@@ -517,17 +517,17 @@ xpow (const ComplexMatrix& a, double b)
     }
   else
     {
       EIG a_eig (a);
 
       try
         {
           ComplexColumnVector lambda (a_eig.eigenvalues ());
-          ComplexMatrix Q (a_eig.eigenvectors ());
+          ComplexMatrix Q (a_eig.right_eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             lambda(i) = std::pow (lambda(i), b);
 
           ComplexDiagMatrix D (lambda);
 
           retval = ComplexMatrix (Q * D * Q.inverse ());
         }
@@ -552,17 +552,17 @@ xpow (const ComplexMatrix& a, const Comp
   if (nr == 0 || nc == 0 || nr != nc)
     err_nonsquare_matrix ();
 
   EIG a_eig (a);
 
   try
     {
       ComplexColumnVector lambda (a_eig.eigenvalues ());
-      ComplexMatrix Q (a_eig.eigenvectors ());
+      ComplexMatrix Q (a_eig.right_eigenvectors ());
 
       for (octave_idx_type i = 0; i < nr; i++)
         lambda(i) = std::pow (lambda(i), b);
 
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
@@ -1522,17 +1522,17 @@ xpow (float a, const FloatMatrix& b)
   if (nr == 0 || nc == 0 || nr != nc)
     err_nonsquare_matrix ();
 
   FloatEIG b_eig (b);
 
   try
     {
       FloatComplexColumnVector lambda (b_eig.eigenvalues ());
-      FloatComplexMatrix Q (b_eig.eigenvectors ());
+      FloatComplexMatrix Q (b_eig.right_eigenvectors ());
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           FloatComplex elt = lambda(i);
           if (std::imag (elt) == 0.0)
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
@@ -1574,17 +1574,17 @@ xpow (float a, const FloatComplexMatrix&
   if (nr == 0 || nc == 0 || nr != nc)
     err_nonsquare_matrix ();
 
   FloatEIG b_eig (b);
 
   try
     {
       FloatComplexColumnVector lambda (b_eig.eigenvalues ());
-      FloatComplexMatrix Q (b_eig.eigenvectors ());
+      FloatComplexMatrix Q (b_eig.right_eigenvectors ());
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           FloatComplex elt = lambda(i);
           if (std::imag (elt) == 0.0)
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
@@ -1662,17 +1662,17 @@ xpow (const FloatMatrix& a, float b)
     }
   else
     {
       FloatEIG a_eig (a);
 
       try
         {
           FloatComplexColumnVector lambda (a_eig.eigenvalues ());
-          FloatComplexMatrix Q (a_eig.eigenvectors ());
+          FloatComplexMatrix Q (a_eig.right_eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             lambda(i) = std::pow (lambda(i), b);
 
           FloatComplexDiagMatrix D (lambda);
 
           retval = FloatComplexMatrix (Q * D * Q.inverse ());
         }
@@ -1728,17 +1728,17 @@ xpow (const FloatMatrix& a, const FloatC
   if (nr == 0 || nc == 0 || nr != nc)
     err_nonsquare_matrix ();
 
   FloatEIG a_eig (a);
 
   try
     {
       FloatComplexColumnVector lambda (a_eig.eigenvalues ());
-      FloatComplexMatrix Q (a_eig.eigenvectors ());
+      FloatComplexMatrix Q (a_eig.right_eigenvectors ());
 
       for (octave_idx_type i = 0; i < nr; i++)
         lambda(i) = std::pow (lambda(i), b);
 
       FloatComplexDiagMatrix D (lambda);
 
       retval = FloatComplexMatrix (Q * D * Q.inverse ());
     }
@@ -1776,17 +1776,17 @@ xpow (const FloatComplex& a, const Float
   if (nr == 0 || nc == 0 || nr != nc)
     err_nonsquare_matrix ();
 
   FloatEIG b_eig (b);
 
   try
     {
       FloatComplexColumnVector lambda (b_eig.eigenvalues ());
-      FloatComplexMatrix Q (b_eig.eigenvectors ());
+      FloatComplexMatrix Q (b_eig.right_eigenvectors ());
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           FloatComplex elt = lambda(i);
           if (std::imag (elt) == 0.0)
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
@@ -1824,17 +1824,17 @@ xpow (const FloatComplex& a, const Float
   if (nr == 0 || nc == 0 || nr != nc)
     err_nonsquare_matrix ();
 
   FloatEIG b_eig (b);
 
   try
     {
       FloatComplexColumnVector lambda (b_eig.eigenvalues ());
-      FloatComplexMatrix Q (b_eig.eigenvectors ());
+      FloatComplexMatrix Q (b_eig.right_eigenvectors ());
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           FloatComplex elt = lambda(i);
           if (std::imag (elt) == 0.0)
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
@@ -1912,17 +1912,17 @@ xpow (const FloatComplexMatrix& a, float
     }
   else
     {
       FloatEIG a_eig (a);
 
       try
         {
           FloatComplexColumnVector lambda (a_eig.eigenvalues ());
-          FloatComplexMatrix Q (a_eig.eigenvectors ());
+          FloatComplexMatrix Q (a_eig.right_eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             lambda(i) = std::pow (lambda(i), b);
 
           FloatComplexDiagMatrix D (lambda);
 
           retval = FloatComplexMatrix (Q * D * Q.inverse ());
         }
@@ -1947,17 +1947,17 @@ xpow (const FloatComplexMatrix& a, const
   if (nr == 0 || nc == 0 || nr != nc)
     err_nonsquare_matrix ();
 
   FloatEIG a_eig (a);
 
   try
     {
       FloatComplexColumnVector lambda (a_eig.eigenvalues ());
-      FloatComplexMatrix Q (a_eig.eigenvectors ());
+      FloatComplexMatrix Q (a_eig.right_eigenvectors ());
 
       for (octave_idx_type i = 0; i < nr; i++)
         lambda(i) = std::pow (lambda(i), b);
 
       FloatComplexDiagMatrix D (lambda);
 
       retval = FloatComplexMatrix (Q * D * Q.inverse ());
     }
diff --git a/liboctave/numeric/EIG.cc b/liboctave/numeric/EIG.cc
--- a/liboctave/numeric/EIG.cc
+++ b/liboctave/numeric/EIG.cc
@@ -1,11 +1,12 @@
 /*
 
 Copyright (C) 1994-2015 John W. Eaton
+Copyright (C) 2016 Barbara Lócsi
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -27,36 +28,50 @@ along with Octave; see the file COPYING.
 #include "EIG.h"
 #include "dColVector.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (dgeev, DGEEV) (F77_CONST_CHAR_ARG_DECL,
-                           F77_CONST_CHAR_ARG_DECL,
-                           const F77_INT&, F77_DBLE*,
-                           const F77_INT&, F77_DBLE*, F77_DBLE*,
-                           F77_DBLE*, const F77_INT&, F77_DBLE*,
-                           const F77_INT&, F77_DBLE*,
-                           const F77_INT&, F77_INT&
-                           F77_CHAR_ARG_LEN_DECL
-                           F77_CHAR_ARG_LEN_DECL);
+  F77_FUNC (dgeevx, DGEEVX) (F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             const F77_INT&, F77_DBLE*,
+                             const F77_INT&, F77_DBLE*, F77_DBLE*,
+                             F77_DBLE*, const F77_INT&, F77_DBLE*,
+                             const F77_INT&, F77_INT&,
+                             F77_INT&, F77_DBLE*, F77_DBLE&,
+                             F77_DBLE*, F77_DBLE*, F77_DBLE*,
+                             const F77_INT&, F77_INT*,
+                             F77_INT&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zgeev, ZGEEV) (F77_CONST_CHAR_ARG_DECL,
-                           F77_CONST_CHAR_ARG_DECL,
-                           const F77_INT&, F77_DBLE_CMPLX*,
-                           const F77_INT&, F77_DBLE_CMPLX*,
-                           F77_DBLE_CMPLX*, const F77_INT&, F77_DBLE_CMPLX*,
-                           const F77_INT&, F77_DBLE_CMPLX*,
-                           const F77_INT&, F77_DBLE*, F77_INT&
-                           F77_CHAR_ARG_LEN_DECL
-                           F77_CHAR_ARG_LEN_DECL);
+  F77_FUNC (zgeevx, ZGEEVX) (F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             const F77_INT&, F77_DBLE_CMPLX*,
+                             const F77_INT&, F77_DBLE_CMPLX*,
+                             F77_DBLE_CMPLX*, const F77_INT&, F77_DBLE_CMPLX*,
+                             const F77_INT&, F77_INT&,
+                             F77_INT&, F77_DBLE*, F77_DBLE&,
+                             F77_DBLE*, F77_DBLE*, F77_DBLE_CMPLX*,
+                             const F77_INT&, F77_DBLE*,
+                             F77_INT&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dsyev, DSYEV) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const F77_INT&, F77_DBLE*,
                            const F77_INT&, F77_DBLE*, F77_DBLE*,
                            const F77_INT&, F77_INT&
                            F77_CHAR_ARG_LEN_DECL
@@ -130,24 +145,24 @@ extern "C"
                            const F77_INT&, F77_DBLE_CMPLX*,
                            const F77_INT&, F77_DBLE*, F77_DBLE_CMPLX*,
                            const F77_INT&, F77_DBLE*, F77_INT&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 }
 
 octave_idx_type
-EIG::init (const Matrix& a, bool calc_ev)
+EIG::init (const Matrix& a, bool calc_rev, bool calc_lev, bool balance)
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_symmetric ())
-    return symmetric_init (a, calc_ev);
+    return symmetric_init (a, calc_rev, calc_lev);
 
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
@@ -155,89 +170,131 @@ EIG::init (const Matrix& a, bool calc_ev
   double *tmp_data = atmp.fortran_vec ();
 
   Array<double> wr (dim_vector (n, 1));
   double *pwr = wr.fortran_vec ();
 
   Array<double> wi (dim_vector (n, 1));
   double *pwi = wi.fortran_vec ();
 
-  octave_idx_type tnvr = calc_ev ? n : 0;
+  octave_idx_type tnvr = calc_rev ? n : 0;
   Matrix vr (tnvr, tnvr);
   double *pvr = vr.fortran_vec ();
 
+  octave_idx_type tnvl = calc_lev ? n : 0;
+  Matrix vl (tnvl, tnvl);
+  double *pvl = vl.fortran_vec ();
+
   octave_idx_type lwork = -1;
   double dummy_work;
 
-  double *dummy = 0;
-  octave_idx_type idummy = 1;
+  octave_idx_type ilo;
+  octave_idx_type ihi;
+
+  Array<double> scale (dim_vector (n, 1));
+  double *pscale = scale.fortran_vec ();
+
+  double abnrm;
+
+  Array<double> rconde (dim_vector (n, 1));
+  double *prconde = rconde.fortran_vec ();
+
+  Array<double> rcondv (dim_vector (n, 1));
+  double *prcondv = rcondv.fortran_vec ();
 
-  F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, tmp_data, n, pwr, pwi, dummy,
-                           idummy, pvr, n, &dummy_work, lwork, info
-                           F77_CHAR_ARG_LEN (1)
-                           F77_CHAR_ARG_LEN (1)));
+  octave_idx_type dummy_iwork;
+
+  F77_XFCN (dgeevx, DGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             n, tmp_data, n, pwr, pwi, pvl,
+                             n, pvr, n, ilo, ihi, pscale,
+                             abnrm, prconde, prcondv, &dummy_work,
+                             lwork, &dummy_iwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
-    (*current_liboctave_error_handler) ("dgeev workspace query failed");
+    (*current_liboctave_error_handler) ("dgeevx workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work);
   Array<double> work (dim_vector (lwork, 1));
   double *pwork = work.fortran_vec ();
 
-  F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, tmp_data, n, pwr, pwi, dummy,
-                           idummy, pvr, n, pwork, lwork, info
-                           F77_CHAR_ARG_LEN (1)
-                           F77_CHAR_ARG_LEN (1)));
+  F77_XFCN (dgeevx, DGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             n, tmp_data, n, pwr, pwi, pvl,
+                             n, pvr, n, ilo, ihi, pscale,
+                             abnrm, prconde, prcondv, pwork,
+                             lwork, &dummy_iwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
-    (*current_liboctave_error_handler) ("unrecoverable error in dgeev");
+    (*current_liboctave_error_handler) ("unrecoverable error in dgeevx");
 
   if (info > 0)
-    (*current_liboctave_error_handler) ("dgeev failed to converge");
+    (*current_liboctave_error_handler) ("dgeevx failed to converge");
 
   lambda.resize (n);
-  octave_idx_type nvr = calc_ev ? n : 0;
+  octave_idx_type nvr = calc_rev ? n : 0;
   v.resize (nvr, nvr);
+  octave_idx_type nvl = calc_lev ? n : 0;
+  w.resize (nvl, nvl);
 
   for (octave_idx_type j = 0; j < n; j++)
     {
       if (wi.elem (j) == 0.0)
         {
           lambda.elem (j) = Complex (wr.elem (j));
           for (octave_idx_type i = 0; i < nvr; i++)
             v.elem (i, j) = vr.elem (i, j);
+
+          for (octave_idx_type i = 0; i < nvl; i++)
+            w.elem (i, j) = vl.elem (i, j);
         }
       else
         {
           if (j+1 >= n)
             (*current_liboctave_error_handler) ("EIG: internal error");
 
           lambda.elem (j) = Complex (wr.elem (j), wi.elem (j));
           lambda.elem (j+1) = Complex (wr.elem (j+1), wi.elem (j+1));
 
           for (octave_idx_type i = 0; i < nvr; i++)
             {
               double real_part = vr.elem (i, j);
               double imag_part = vr.elem (i, j+1);
               v.elem (i, j) = Complex (real_part, imag_part);
               v.elem (i, j+1) = Complex (real_part, -imag_part);
             }
+
+          for (octave_idx_type i = 0; i < nvl; i++)
+            {
+              double real_part = vl.elem (i, j);
+              double imag_part = vl.elem (i, j+1);
+              w.elem (i, j) = Complex (real_part, imag_part);
+              w.elem (i, j+1) = Complex (real_part, -imag_part);
+            }
           j++;
         }
     }
 
   return info;
 }
 
 octave_idx_type
-EIG::symmetric_init (const Matrix& a, bool calc_ev)
+EIG::symmetric_init (const Matrix& a, bool calc_rev, bool calc_lev)
 {
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
@@ -245,119 +302,150 @@ EIG::symmetric_init (const Matrix& a, bo
   double *tmp_data = atmp.fortran_vec ();
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   double dummy_work;
 
-  F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("dsyev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work);
   Array<double> work (dim_vector (lwork, 1));
   double *pwork = work.fortran_vec ();
 
-  F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, pwork, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in dsyev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("dsyev failed to converge");
 
   lambda = ComplexColumnVector (wr);
-  v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
+  v = calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ();
+  w = calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ();
 
   return info;
 }
 
 octave_idx_type
-EIG::init (const ComplexMatrix& a, bool calc_ev)
+EIG::init (const ComplexMatrix& a, bool calc_rev, bool calc_lev, bool balance)
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_hermitian ())
-    return hermitian_init (a, calc_ev);
+    return hermitian_init (a, calc_rev, calc_lev);
 
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
 
-  ComplexColumnVector w (n);
-  Complex *pw = w.fortran_vec ();
+  ComplexColumnVector wr (n);
+  Complex *pw = wr.fortran_vec ();
 
-  octave_idx_type nvr = calc_ev ? n : 0;
-  ComplexMatrix vtmp (nvr, nvr);
-  Complex *pv = vtmp.fortran_vec ();
+  octave_idx_type nvr = calc_rev ? n : 0;
+  ComplexMatrix vrtmp (nvr, nvr);
+  Complex *pvr = vrtmp.fortran_vec ();
+
+  octave_idx_type nvl = calc_lev ? n : 0;
+  ComplexMatrix vltmp (nvl, nvl);
+  Complex *pvl = vltmp.fortran_vec ();
 
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 2*n;
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
-  Complex *dummy = 0;
-  octave_idx_type idummy = 1;
+  octave_idx_type ilo;
+  octave_idx_type ihi;
+
+  Array<double> scale (dim_vector (n, 1));
+  double *pscale = scale.fortran_vec ();
+
+  double abnrm;
+
+  Array<double> rconde (dim_vector (n, 1));
+  double *prconde = rconde.fortran_vec ();
+
+  Array<double> rcondv (dim_vector (n, 1));
+  double *prcondv = rcondv.fortran_vec ();
 
-  F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, F77_DBLE_CMPLX_ARG (tmp_data), n, F77_DBLE_CMPLX_ARG (pw), F77_DBLE_CMPLX_ARG (dummy), idummy,
-                           F77_DBLE_CMPLX_ARG (pv), n, F77_DBLE_CMPLX_ARG (&dummy_work), lwork, prwork, info
-                           F77_CHAR_ARG_LEN (1)
-                           F77_CHAR_ARG_LEN (1)));
+  F77_XFCN (zgeevx, ZGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             n, F77_DBLE_CMPLX_ARG (tmp_data), n,
+                             F77_DBLE_CMPLX_ARG (pw), F77_DBLE_CMPLX_ARG (pvl), n,
+                             F77_DBLE_CMPLX_ARG (pvr), n, ilo, ihi, pscale, abnrm,
+                             prconde, prcondv,
+                             F77_DBLE_CMPLX_ARG (&dummy_work), lwork, prwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
-    (*current_liboctave_error_handler) ("zgeev workspace query failed");
+    (*current_liboctave_error_handler) ("zgeevx workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
-  F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, F77_DBLE_CMPLX_ARG (tmp_data), n, F77_DBLE_CMPLX_ARG (pw), F77_DBLE_CMPLX_ARG (dummy), idummy,
-                           F77_DBLE_CMPLX_ARG (pv), n, F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
-                           F77_CHAR_ARG_LEN (1)
-                           F77_CHAR_ARG_LEN (1)));
+  F77_XFCN (zgeevx, ZGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             n, F77_DBLE_CMPLX_ARG (tmp_data), n,
+                             F77_DBLE_CMPLX_ARG (pw), F77_DBLE_CMPLX_ARG (pvl), n,
+                             F77_DBLE_CMPLX_ARG (pvr), n, ilo, ihi, pscale, abnrm,
+                             prconde, prcondv,
+                             F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
-    (*current_liboctave_error_handler) ("unrecoverable error in zgeev");
+    (*current_liboctave_error_handler) ("unrecoverable error in zgeevx");
 
   if (info > 0)
-    (*current_liboctave_error_handler) ("zgeev failed to converge");
+    (*current_liboctave_error_handler) ("zgeevx failed to converge");
 
-  lambda = w;
-  v = vtmp;
+  lambda = wr;
+  v = vrtmp;
+  w = vltmp;
 
   return info;
 }
 
 octave_idx_type
-EIG::hermitian_init (const ComplexMatrix& a, bool calc_ev)
+EIG::hermitian_init (const ComplexMatrix& a, bool calc_rev, bool calc_lev)
 {
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
@@ -369,50 +457,54 @@ EIG::hermitian_init (const ComplexMatrix
 
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
-  F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, F77_DBLE_CMPLX_ARG (tmp_data), n, pwr, F77_DBLE_CMPLX_ARG (&dummy_work), lwork,
+                           n, F77_DBLE_CMPLX_ARG (tmp_data), n, pwr,
+                           F77_DBLE_CMPLX_ARG (&dummy_work), lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zheev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
-  F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, F77_DBLE_CMPLX_ARG (tmp_data), n, pwr, F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
+                           n, F77_DBLE_CMPLX_ARG (tmp_data), n, pwr,
+                           F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zheev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zheev failed to converge");
 
   lambda = ComplexColumnVector (wr);
-  v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
+  v = calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ();
+  w = calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ();
 
   return info;
 }
 
 octave_idx_type
-EIG::init (const Matrix& a, const Matrix& b, bool calc_ev)
+EIG::init (const Matrix& a, const Matrix& b, bool calc_rev, bool calc_lev,
+           bool force_qz)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
@@ -422,91 +514,100 @@ EIG::init (const Matrix& a, const Matrix
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   Matrix tmp = b;
   double *tmp_data = tmp.fortran_vec ();
 
-  F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-                             n, tmp_data, n,
-                             info
-                             F77_CHAR_ARG_LEN (1)));
+  if (! force_qz)
+    {
+      F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
+                                 n, tmp_data, n,
+                                 info
+                                 F77_CHAR_ARG_LEN (1)));
 
-  if (a.is_symmetric () && b.is_symmetric () && info == 0)
-    return symmetric_init (a, b, calc_ev);
+      if (a.is_symmetric () && b.is_symmetric () && info == 0)
+        return symmetric_init (a, b, calc_rev, calc_lev);
+    }
 
   Matrix atmp = a;
   double *atmp_data = atmp.fortran_vec ();
 
   Matrix btmp = b;
   double *btmp_data = btmp.fortran_vec ();
 
   Array<double> ar (dim_vector (n, 1));
   double *par = ar.fortran_vec ();
 
   Array<double> ai (dim_vector (n, 1));
   double *pai = ai.fortran_vec ();
 
   Array<double> beta (dim_vector (n, 1));
   double *pbeta = beta.fortran_vec ();
 
-  octave_idx_type tnvr = calc_ev ? n : 0;
+  octave_idx_type tnvr = calc_rev ? n : 0;
   Matrix vr (tnvr, tnvr);
   double *pvr = vr.fortran_vec ();
 
+  octave_idx_type tnvl = calc_lev ? n : 0;
+  Matrix vl (tnvl, tnvl);
+  double *pvl = vl.fortran_vec ();
+
   octave_idx_type lwork = -1;
   double dummy_work;
 
-  double *dummy = 0;
-  octave_idx_type idummy = 1;
-
-  F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n,
                            par, pai, pbeta,
-                           dummy, idummy, pvr, n,
+                           pvl, n, pvr, n,
                            &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("dggev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work);
   Array<double> work (dim_vector (lwork, 1));
   double *pwork = work.fortran_vec ();
 
-  F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n,
                            par, pai, pbeta,
-                           dummy, idummy, pvr, n,
+                           pvl, n, pvr, n,
                            pwork, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in dggev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("dggev failed to converge");
 
   lambda.resize (n);
-  octave_idx_type nvr = calc_ev ? n : 0;
+  octave_idx_type nvr = calc_rev ? n : 0;
   v.resize (nvr, nvr);
 
+  octave_idx_type nvl = calc_lev ? n : 0;
+  w.resize (nvl, nvl);
+
   for (octave_idx_type j = 0; j < n; j++)
     {
       if (ai.elem (j) == 0.0)
         {
           lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j));
           for (octave_idx_type i = 0; i < nvr; i++)
             v.elem (i, j) = vr.elem (i, j);
+          for (octave_idx_type i = 0; i < nvl; i++)
+            w.elem (i, j) = vl.elem (i, j);
         }
       else
         {
           if (j+1 >= n)
             (*current_liboctave_error_handler) ("EIG: internal error");
 
           lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j),
                                      ai.elem (j) / beta.elem (j));
@@ -515,25 +616,33 @@ EIG::init (const Matrix& a, const Matrix
 
           for (octave_idx_type i = 0; i < nvr; i++)
             {
               double real_part = vr.elem (i, j);
               double imag_part = vr.elem (i, j+1);
               v.elem (i, j) = Complex (real_part, imag_part);
               v.elem (i, j+1) = Complex (real_part, -imag_part);
             }
+          for (octave_idx_type i = 0; i < nvl; i++)
+            {
+              double real_part = vl.elem (i, j);
+              double imag_part = vl.elem (i, j+1);
+              w.elem (i, j) = Complex (real_part, imag_part);
+              w.elem (i, j+1) = Complex (real_part, -imag_part);
+            }
           j++;
         }
     }
 
   return info;
 }
 
 octave_idx_type
-EIG::symmetric_init (const Matrix& a, const Matrix& b, bool calc_ev)
+EIG::symmetric_init (const Matrix& a, const Matrix& b, bool calc_rev,
+                     bool calc_lev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
@@ -548,53 +657,55 @@ EIG::symmetric_init (const Matrix& a, co
   double *btmp_data = btmp.fortran_vec ();
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   double dummy_work;
 
-  F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n,
                            btmp_data, n,
                            pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("dsygv workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work);
   Array<double> work (dim_vector (lwork, 1));
   double *pwork = work.fortran_vec ();
 
-  F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n,
                            btmp_data, n,
                            pwr, pwork, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in dsygv");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("dsygv failed to converge");
 
   lambda = ComplexColumnVector (wr);
-  v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
+  v = calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ();
+  w = calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ();
 
   return info;
 }
 
 octave_idx_type
-EIG::init (const ComplexMatrix& a, const ComplexMatrix& b, bool calc_ev)
+EIG::init (const ComplexMatrix& a, const ComplexMatrix& b, bool calc_rev,
+           bool calc_lev, bool force_qz)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
@@ -604,92 +715,105 @@ EIG::init (const ComplexMatrix& a, const
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   ComplexMatrix tmp = b;
   Complex*tmp_data = tmp.fortran_vec ();
 
-  F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-                             n, F77_DBLE_CMPLX_ARG (tmp_data), n,
-                             info
-                             F77_CHAR_ARG_LEN (1)));
+  if (! force_qz)
+    {
+      F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
+                                 n, F77_DBLE_CMPLX_ARG (tmp_data), n,
+                                 info
+                                 F77_CHAR_ARG_LEN (1)));
 
-  if (a.is_hermitian () && b.is_hermitian () && info == 0)
-    return hermitian_init (a, b, calc_ev);
+      if (a.is_hermitian () && b.is_hermitian () && info == 0)
+        return hermitian_init (a, b, calc_rev, calc_lev);
+    }
 
   ComplexMatrix atmp = a;
   Complex *atmp_data = atmp.fortran_vec ();
 
   ComplexMatrix btmp = b;
   Complex *btmp_data = btmp.fortran_vec ();
 
   ComplexColumnVector alpha (n);
   Complex *palpha = alpha.fortran_vec ();
 
   ComplexColumnVector beta (n);
   Complex *pbeta = beta.fortran_vec ();
 
-  octave_idx_type nvr = calc_ev ? n : 0;
-  ComplexMatrix vtmp (nvr, nvr);
-  Complex *pv = vtmp.fortran_vec ();
+  octave_idx_type nvr = calc_rev ? n : 0;
+  ComplexMatrix vrtmp (nvr, nvr);
+  Complex *pvr = vrtmp.fortran_vec ();
+
+  octave_idx_type nvl = calc_lev ? n : 0;
+  ComplexMatrix vltmp (nvl, nvl);
+  Complex *pvl = vltmp.fortran_vec ();
 
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 8*n;
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
-  Complex *dummy = 0;
-  octave_idx_type idummy = 1;
-
   F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, F77_DBLE_CMPLX_ARG (atmp_data), n, F77_DBLE_CMPLX_ARG (btmp_data), n,
-                           F77_DBLE_CMPLX_ARG (palpha), F77_DBLE_CMPLX_ARG (pbeta), F77_DBLE_CMPLX_ARG (dummy), idummy,
-                           F77_DBLE_CMPLX_ARG (pv), n, F77_DBLE_CMPLX_ARG (&dummy_work), lwork, prwork, info
+                           F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
+                           n, F77_DBLE_CMPLX_ARG (atmp_data), n,
+                           F77_DBLE_CMPLX_ARG (btmp_data), n,
+                           F77_DBLE_CMPLX_ARG (palpha),
+                           F77_DBLE_CMPLX_ARG (pbeta),
+                           F77_DBLE_CMPLX_ARG (pvl), n,
+                           F77_DBLE_CMPLX_ARG (pvr), n,
+                           F77_DBLE_CMPLX_ARG (&dummy_work), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zggev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, F77_DBLE_CMPLX_ARG (atmp_data), n, F77_DBLE_CMPLX_ARG (btmp_data), n,
-                           F77_DBLE_CMPLX_ARG (palpha), F77_DBLE_CMPLX_ARG (pbeta), F77_DBLE_CMPLX_ARG (dummy), idummy,
-                           F77_DBLE_CMPLX_ARG (pv), n, F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
+                           F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
+                           n,  F77_DBLE_CMPLX_ARG (atmp_data), n,
+                           F77_DBLE_CMPLX_ARG (btmp_data), n,
+                           F77_DBLE_CMPLX_ARG (palpha),
+                           F77_DBLE_CMPLX_ARG (pbeta),
+                           F77_DBLE_CMPLX_ARG (pvl), n,
+                           F77_DBLE_CMPLX_ARG (pvr), n,
+                           F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zggev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zggev failed to converge");
 
   lambda.resize (n);
 
   for (octave_idx_type j = 0; j < n; j++)
     lambda.elem (j) = alpha.elem (j) / beta.elem (j);
 
-  v = vtmp;
+  v = vrtmp;
+  w = vltmp;
 
   return info;
 }
 
 octave_idx_type
 EIG::hermitian_init (const ComplexMatrix& a, const ComplexMatrix& b,
-                     bool calc_ev)
+                     bool calc_rev, bool calc_lev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
@@ -708,43 +832,44 @@ EIG::hermitian_init (const ComplexMatrix
 
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
-  F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, F77_DBLE_CMPLX_ARG (atmp_data), n,
                            F77_DBLE_CMPLX_ARG (btmp_data), n,
                            pwr, F77_DBLE_CMPLX_ARG (&dummy_work), lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zhegv workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
-  F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, F77_DBLE_CMPLX_ARG (atmp_data), n,
                            F77_DBLE_CMPLX_ARG (btmp_data), n,
                            pwr, F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zhegv failed to converge");
 
   lambda = ComplexColumnVector (wr);
-  v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
+  v = calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ();
+  w = calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ();
 
   return info;
 }
diff --git a/liboctave/numeric/EIG.h b/liboctave/numeric/EIG.h
--- a/liboctave/numeric/EIG.h
+++ b/liboctave/numeric/EIG.h
@@ -35,113 +35,122 @@ class
 OCTAVE_API
 EIG
 {
   friend class Matrix;
   friend class ComplexMatrix;
 
 public:
 
-  EIG (void) : lambda (), v () { }
+  EIG (void) : lambda (), v (), w () { }
 
-  EIG (const Matrix& a, bool calc_eigenvectors = true)
-    : lambda (), v ()
+  EIG (const Matrix& a, bool calc_rev = true,
+       bool calc_lev = true, bool balance = true)
+    : lambda (), v (), w ()
   {
-    init (a, calc_eigenvectors);
+    init (a, calc_rev, calc_lev, balance);
   }
 
-  EIG (const Matrix& a, octave_idx_type& info, bool calc_eigenvectors = true)
-    : lambda (), v ()
+  EIG (const Matrix& a, octave_idx_type& info,
+       bool calc_rev = true, bool calc_lev = true, bool balance = true)
+    : lambda (), v (), w ()
   {
-    info = init (a, calc_eigenvectors);
+    info = init (a, calc_rev, calc_lev, balance);
   }
 
-  EIG (const Matrix& a, const Matrix& b, bool calc_eigenvectors = true)
-    : lambda (), v ()
+  EIG (const Matrix& a, const Matrix& b,
+       bool calc_rev = true, bool calc_lev = true, bool force_qz = false)
+    : lambda (), v (), w ()
   {
-    init (a, b, calc_eigenvectors);
+    init (a, b, calc_rev, calc_lev, force_qz);
   }
 
   EIG (const Matrix& a, const Matrix& b, octave_idx_type& info,
-       bool calc_eigenvectors = true)
-    : lambda (), v ()
+       bool calc_rev = true, bool calc_lev = true, bool force_qz = false)
+    : lambda (), v (), w ()
   {
-    info = init (a, b, calc_eigenvectors);
+    info = init (a, b, calc_rev, calc_lev, force_qz);
   }
 
-  EIG (const ComplexMatrix& a, bool calc_eigenvectors = true)
-    : lambda (), v ()
+  EIG (const ComplexMatrix& a, bool calc_rev = true,
+       bool calc_lev = true, bool balance = true)
+    : lambda (), v (), w ()
   {
-    init (a, calc_eigenvectors);
+    init (a, calc_rev, calc_lev, balance);
   }
 
   EIG (const ComplexMatrix& a, octave_idx_type& info,
-       bool calc_eigenvectors = true)
-    : lambda (), v ()
+       bool calc_rev = true, bool calc_lev = true, bool balance = true)
+    : lambda (), v (), w ()
   {
-    info = init (a, calc_eigenvectors);
+    info = init (a, calc_rev, calc_lev, balance);
   }
 
   EIG (const ComplexMatrix& a, const ComplexMatrix& b,
-       bool calc_eigenvectors = true)
-    : lambda (), v ()
+       bool calc_rev = true, bool calc_lev = true, bool force_qz = false)
+    : lambda (), v (), w ()
   {
-    init (a, b, calc_eigenvectors);
+    init (a, b, calc_rev, calc_lev, force_qz);
   }
 
   EIG (const ComplexMatrix& a, const ComplexMatrix& b,
-       octave_idx_type& info, bool calc_eigenvectors = true)
-    : lambda (), v ()
+       octave_idx_type& info, bool calc_rev = true, bool calc_lev = true,
+       bool force_qz = false)
+    : lambda (), v (), w ()
   {
-    info = init (a, b, calc_eigenvectors);
+    info = init (a, b, calc_rev, calc_lev, force_qz);
   }
 
-  EIG (const EIG& a)
-    : lambda (a.lambda), v (a.v) { }
+  EIG (const EIG& a) : lambda (a.lambda), v (a.v), w (a.w) { }
 
   EIG& operator = (const EIG& a)
   {
     if (this != &a)
       {
         lambda = a.lambda;
         v = a.v;
+        w = a.w;
       }
     return *this;
   }
 
   ~EIG (void) { }
 
   ComplexColumnVector eigenvalues (void) const { return lambda; }
-
-  ComplexMatrix eigenvectors (void) const { return v; }
+  ComplexMatrix right_eigenvectors (void) const { return v; }
+  ComplexMatrix left_eigenvectors (void) const { return w; }
 
   friend std::ostream&  operator << (std::ostream& os, const EIG& a);
 
 private:
 
   ComplexColumnVector lambda;
   ComplexMatrix v;
+  ComplexMatrix w;
 
-  octave_idx_type init (const Matrix& a, bool calc_eigenvectors);
+  octave_idx_type init (const Matrix& a, bool calc_rev, bool calc_lev,
+                        bool balance);
 
   octave_idx_type init (const Matrix& a, const Matrix& b,
-                        bool calc_eigenvectors);
+                        bool calc_rev, bool calc_lev, bool force_qz);
 
-  octave_idx_type init (const ComplexMatrix& a, bool calc_eigenvectors);
+  octave_idx_type init (const ComplexMatrix& a, bool calc_rev,
+                        bool calc_lev, bool balance);
 
   octave_idx_type init (const ComplexMatrix& a, const ComplexMatrix& b,
-                        bool calc_eigenvectors);
+                        bool calc_rev, bool calc_lev, bool force_qz);
 
-  octave_idx_type symmetric_init (const Matrix& a, bool calc_eigenvectors);
+  octave_idx_type symmetric_init (const Matrix& a, bool calc_rev,
+                                  bool calc_lev);
 
   octave_idx_type symmetric_init (const Matrix& a, const Matrix& b,
-                                  bool calc_eigenvectors);
+                                  bool calc_rev, bool calc_lev);
 
   octave_idx_type hermitian_init (const ComplexMatrix& a,
-                                  bool calc_eigenvectors);
+                                  bool calc_rev, bool calc_lev);
 
   octave_idx_type hermitian_init (const ComplexMatrix& a,
                                   const ComplexMatrix& b,
-                                  bool calc_eigenvectors);
+                                  bool calc_rev, bool calc_lev);
 
 };
 
 #endif
diff --git a/liboctave/numeric/fEIG.cc b/liboctave/numeric/fEIG.cc
--- a/liboctave/numeric/fEIG.cc
+++ b/liboctave/numeric/fEIG.cc
@@ -1,11 +1,12 @@
 /*
 
 Copyright (C) 1994-2015 John W. Eaton
+Copyright (C) 2016 Barbara Lócsi
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -27,36 +28,48 @@ along with Octave; see the file COPYING.
 #include "fEIG.h"
 #include "fColVector.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (sgeev, SGEEV) (F77_CONST_CHAR_ARG_DECL,
-                           F77_CONST_CHAR_ARG_DECL,
-                           const F77_INT&, F77_REAL*,
-                           const F77_INT&, F77_REAL*, F77_REAL*, F77_REAL*,
-                           const F77_INT&, F77_REAL*,
-                           const F77_INT&, F77_REAL*,
-                           const F77_INT&, F77_INT&
-                           F77_CHAR_ARG_LEN_DECL
-                           F77_CHAR_ARG_LEN_DECL);
+  F77_FUNC (sgeevx, SGEEVX) (F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             const F77_INT&, F77_REAL*,
+                             const F77_INT&, F77_REAL*, F77_REAL*, F77_REAL*,
+                             const F77_INT&, F77_REAL*,
+                             const F77_INT&, F77_INT&,
+                             F77_INT&, F77_REAL*, F77_REAL&, F77_REAL*,
+                             F77_REAL*, F77_REAL*, const F77_INT&,
+                             F77_INT*, F77_INT&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (cgeev, CGEEV) (F77_CONST_CHAR_ARG_DECL,
-                           F77_CONST_CHAR_ARG_DECL,
-                           const F77_INT&, F77_CMPLX*,
-                           const F77_INT&, F77_CMPLX*, F77_CMPLX*,
-                           const F77_INT&, F77_CMPLX*,
-                           const F77_INT&, F77_CMPLX*,
-                           const F77_INT&, F77_REAL*, F77_INT&
-                           F77_CHAR_ARG_LEN_DECL
-                           F77_CHAR_ARG_LEN_DECL);
+  F77_FUNC (cgeevx, CGEEVX) (F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             F77_CONST_CHAR_ARG_DECL,
+                             const F77_INT&, F77_CMPLX*,
+                             const F77_INT&, F77_CMPLX*, F77_CMPLX*,
+                             const F77_INT&, F77_CMPLX*,
+                             const F77_INT&, F77_INT&,
+                             F77_INT&, F77_REAL*, F77_REAL&, F77_REAL*,
+                             F77_REAL*, F77_CMPLX*, const F77_INT&,
+                             F77_REAL*, F77_INT&
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ssyev, SSYEV) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const F77_INT&, F77_REAL*,
                            const F77_INT&, F77_REAL*, F77_REAL*,
                            const F77_INT&, F77_INT&
                            F77_CHAR_ARG_LEN_DECL
@@ -127,24 +140,24 @@ extern "C"
                            const F77_INT&, F77_CMPLX*,
                            const F77_INT&, F77_REAL*, F77_CMPLX*,
                            const F77_INT&, F77_REAL*, F77_INT&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 }
 
 octave_idx_type
-FloatEIG::init (const FloatMatrix& a, bool calc_ev)
+FloatEIG::init (const FloatMatrix& a, bool calc_rev, bool calc_lev, bool balance)
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_symmetric ())
-    return symmetric_init (a, calc_ev);
+    return symmetric_init (a, calc_rev, calc_lev);
 
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
@@ -152,88 +165,128 @@ FloatEIG::init (const FloatMatrix& a, bo
   float *tmp_data = atmp.fortran_vec ();
 
   Array<float> wr (dim_vector (n, 1));
   float *pwr = wr.fortran_vec ();
 
   Array<float> wi (dim_vector (n, 1));
   float *pwi = wi.fortran_vec ();
 
-  volatile octave_idx_type nvr = calc_ev ? n : 0;
+  volatile octave_idx_type nvr = calc_rev ? n : 0;
   FloatMatrix vr (nvr, nvr);
   float *pvr = vr.fortran_vec ();
 
+  volatile octave_idx_type nvl = calc_lev ? n : 0;
+  FloatMatrix vl (nvl, nvl);
+  float *pvl = vl.fortran_vec ();
+
   octave_idx_type lwork = -1;
   float dummy_work;
 
-  float *dummy = 0;
-  octave_idx_type idummy = 1;
+  octave_idx_type ilo;
+  octave_idx_type ihi;
+
+  Array<float> scale (dim_vector (n, 1));
+  float *pscale = scale.fortran_vec ();
+
+  float abnrm;
+
+  Array<float> rconde (dim_vector (n, 1));
+  float *prconde = rconde.fortran_vec ();
+
+  Array<float> rcondv (dim_vector (n, 1));
+  float *prcondv = rcondv.fortran_vec ();
 
-  F77_XFCN (sgeev, SGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, tmp_data, n, pwr, pwi, dummy,
-                           idummy, pvr, n, &dummy_work, lwork, info
-                           F77_CHAR_ARG_LEN (1)
-                           F77_CHAR_ARG_LEN (1)));
+  octave_idx_type dummy_iwork;
+
+  F77_XFCN (sgeevx, SGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             n, tmp_data, n, pwr, pwi,
+                             pvl, n, pvr, n,
+                             ilo, ihi, pscale, abnrm, prconde, prcondv,
+                             &dummy_work, lwork, &dummy_iwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
-    (*current_liboctave_error_handler) ("sgeev workspace query failed");
+    (*current_liboctave_error_handler) ("sgeevx workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work);
   Array<float> work (dim_vector (lwork, 1));
   float *pwork = work.fortran_vec ();
 
-  F77_XFCN (sgeev, SGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, tmp_data, n, pwr, pwi, dummy,
-                           idummy, pvr, n, pwork, lwork, info
-                           F77_CHAR_ARG_LEN (1)
-                           F77_CHAR_ARG_LEN (1)));
+  F77_XFCN (sgeevx, SGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             n, tmp_data, n, pwr, pwi,
+                             pvl, n, pvr, n,
+                             ilo, ihi, pscale, abnrm, prconde, prcondv,
+                             pwork, lwork, &dummy_iwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
-    (*current_liboctave_error_handler) ("unrecoverable error in sgeev");
+    (*current_liboctave_error_handler) ("unrecoverable error in sgeevx");
 
   if (info > 0)
-    (*current_liboctave_error_handler) ("sgeev failed to converge");
+    (*current_liboctave_error_handler) ("sgeevx failed to converge");
 
   lambda.resize (n);
   v.resize (nvr, nvr);
+  w.resize (nvl, nvl);
 
   for (octave_idx_type j = 0; j < n; j++)
     {
       if (wi.elem (j) == 0.0)
         {
           lambda.elem (j) = FloatComplex (wr.elem (j));
           for (octave_idx_type i = 0; i < nvr; i++)
             v.elem (i, j) = vr.elem (i, j);
+
+          for (octave_idx_type i = 0; i < nvl; i++)
+            w.elem (i, j) = vl.elem (i, j);
         }
       else
         {
           if (j+1 >= n)
             (*current_liboctave_error_handler) ("EIG: internal error");
 
           lambda.elem (j) = FloatComplex (wr.elem (j), wi.elem (j));
           lambda.elem (j+1) = FloatComplex (wr.elem (j+1), wi.elem (j+1));
 
           for (octave_idx_type i = 0; i < nvr; i++)
             {
               float real_part = vr.elem (i, j);
               float imag_part = vr.elem (i, j+1);
               v.elem (i, j) = FloatComplex (real_part, imag_part);
               v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
             }
+          for (octave_idx_type i = 0; i < nvl; i++)
+            {
+              float real_part = vl.elem (i, j);
+              float imag_part = vl.elem (i, j+1);
+              w.elem (i, j) = FloatComplex (real_part, imag_part);
+              w.elem (i, j+1) = FloatComplex (real_part, -imag_part);
+            }
           j++;
         }
     }
 
   return info;
 }
 
 octave_idx_type
-FloatEIG::symmetric_init (const FloatMatrix& a, bool calc_ev)
+FloatEIG::symmetric_init (const FloatMatrix& a, bool calc_rev, bool calc_lev)
 {
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
@@ -241,119 +294,150 @@ FloatEIG::symmetric_init (const FloatMat
   float *tmp_data = atmp.fortran_vec ();
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   float dummy_work;
 
-  F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("ssyev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work);
   Array<float> work (dim_vector (lwork, 1));
   float *pwork = work.fortran_vec ();
 
-  F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, pwork, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in ssyev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("ssyev failed to converge");
 
   lambda = FloatComplexColumnVector (wr);
-  v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
+  v = calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
+  w = calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
 
   return info;
 }
 
 octave_idx_type
-FloatEIG::init (const FloatComplexMatrix& a, bool calc_ev)
+FloatEIG::init (const FloatComplexMatrix& a, bool calc_rev, bool calc_lev,
+                bool balance)
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_hermitian ())
-    return hermitian_init (a, calc_ev);
+    return hermitian_init (a, calc_rev, calc_lev);
 
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix atmp = a;
   FloatComplex *tmp_data = atmp.fortran_vec ();
 
-  FloatComplexColumnVector w (n);
-  FloatComplex *pw = w.fortran_vec ();
+  FloatComplexColumnVector wr (n);
+  FloatComplex *pw = wr.fortran_vec ();
 
-  octave_idx_type nvr = calc_ev ? n : 0;
-  FloatComplexMatrix vtmp (nvr, nvr);
-  FloatComplex *pv = vtmp.fortran_vec ();
+  octave_idx_type nvr = calc_rev ? n : 0;
+  FloatComplexMatrix vrtmp (nvr, nvr);
+  FloatComplex *pvr = vrtmp.fortran_vec ();
+
+  octave_idx_type nvl = calc_lev ? n : 0;
+  FloatComplexMatrix vltmp (nvl, nvl);
+  FloatComplex *pvl = vltmp.fortran_vec ();
 
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 2*n;
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
-  FloatComplex *dummy = 0;
-  octave_idx_type idummy = 1;
+  octave_idx_type ilo;
+  octave_idx_type ihi;
+
+  Array<float> scale (dim_vector (n, 1));
+  float *pscale = scale.fortran_vec ();
+
+  float abnrm;
+
+  Array<float> rconde (dim_vector (n, 1));
+  float *prconde = rconde.fortran_vec ();
 
-  F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, F77_CMPLX_ARG (tmp_data), n, F77_CMPLX_ARG (pw), F77_CMPLX_ARG (dummy), idummy,
-                           F77_CMPLX_ARG (pv), n, F77_CMPLX_ARG (&dummy_work), lwork, prwork, info
-                           F77_CHAR_ARG_LEN (1)
-                           F77_CHAR_ARG_LEN (1)));
+  Array<float> rcondv (dim_vector (n, 1));
+  float *prcondv = rcondv.fortran_vec ();
+
+  F77_XFCN (cgeevx, CGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             n, F77_CMPLX_ARG (tmp_data), n, F77_CMPLX_ARG (pw),
+                             F77_CMPLX_ARG (pvl), n, F77_CMPLX_ARG (pvr), n,
+                             ilo, ihi, pscale, abnrm, prconde, prcondv,
+                             F77_CMPLX_ARG (&dummy_work), lwork, prwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
-    (*current_liboctave_error_handler) ("cgeev workspace query failed");
+    (*current_liboctave_error_handler) ("cgeevx workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
-  F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, F77_CMPLX_ARG (tmp_data), n, F77_CMPLX_ARG (pw), F77_CMPLX_ARG (dummy), idummy,
-                           F77_CMPLX_ARG (pv), n, F77_CMPLX_ARG (pwork), lwork, prwork, info
-                           F77_CHAR_ARG_LEN (1)
-                           F77_CHAR_ARG_LEN (1)));
+  F77_XFCN (cgeevx, CGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
+                             F77_CONST_CHAR_ARG2 ("N", 1),
+                             n, F77_CMPLX_ARG (tmp_data), n, F77_CMPLX_ARG (pw),
+                             F77_CMPLX_ARG (pvl), n, F77_CMPLX_ARG (pvr), n,
+                             ilo, ihi, pscale, abnrm, prconde, prcondv,
+                             F77_CMPLX_ARG (pwork), lwork, prwork, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
-    (*current_liboctave_error_handler) ("unrecoverable error in cgeev");
+    (*current_liboctave_error_handler) ("unrecoverable error in cgeevx");
 
   if (info > 0)
-    (*current_liboctave_error_handler) ("cgeev failed to converge");
+    (*current_liboctave_error_handler) ("cgeevx failed to converge");
 
-  lambda = w;
-  v = vtmp;
+  lambda = wr;
+  v = vrtmp;
+  w = vltmp;
 
   return info;
 }
 
 octave_idx_type
-FloatEIG::hermitian_init (const FloatComplexMatrix& a, bool calc_ev)
+FloatEIG::hermitian_init (const FloatComplexMatrix& a, bool calc_rev,
+                          bool calc_lev)
 {
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
@@ -365,50 +449,54 @@ FloatEIG::hermitian_init (const FloatCom
 
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
-  F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, F77_CMPLX_ARG (tmp_data), n, pwr, F77_CMPLX_ARG (&dummy_work), lwork,
+                           n, F77_CMPLX_ARG (tmp_data), n, pwr,
+                           F77_CMPLX_ARG (&dummy_work), lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("cheev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
-  F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, F77_CMPLX_ARG (tmp_data), n, pwr, F77_CMPLX_ARG (pwork), lwork, prwork, info
+                           n, F77_CMPLX_ARG (tmp_data), n, pwr,
+                           F77_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in cheev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("cheev failed to converge");
 
   lambda = FloatComplexColumnVector (wr);
-  v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
+  v = calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
+  w = calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
 
   return info;
 }
 
 octave_idx_type
-FloatEIG::init (const FloatMatrix& a, const FloatMatrix& b, bool calc_ev)
+FloatEIG::init (const FloatMatrix& a, const FloatMatrix& b, bool calc_rev,
+                bool calc_lev, bool force_qz)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
@@ -417,91 +505,99 @@ FloatEIG::init (const FloatMatrix& a, co
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   FloatMatrix tmp = b;
   float *tmp_data = tmp.fortran_vec ();
+  if (! force_qz)
+    {
+      F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
+                                 n, tmp_data, n,
+                                 info
+                                 F77_CHAR_ARG_LEN (1)));
 
-  F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-                             n, tmp_data, n,
-                             info
-                             F77_CHAR_ARG_LEN (1)));
-
-  if (a.is_symmetric () && b.is_symmetric () && info == 0)
-    return symmetric_init (a, b, calc_ev);
+      if (a.is_symmetric () && b.is_symmetric () && info == 0)
+        return symmetric_init (a, b, calc_rev, calc_lev);
+    }
 
   FloatMatrix atmp = a;
   float *atmp_data = atmp.fortran_vec ();
 
   FloatMatrix btmp = b;
   float *btmp_data = btmp.fortran_vec ();
 
   Array<float> ar (dim_vector (n, 1));
   float *par = ar.fortran_vec ();
 
   Array<float> ai (dim_vector (n, 1));
   float *pai = ai.fortran_vec ();
 
   Array<float> beta (dim_vector (n, 1));
   float *pbeta = beta.fortran_vec ();
 
-  volatile octave_idx_type nvr = calc_ev ? n : 0;
+  volatile octave_idx_type nvr = calc_rev ? n : 0;
   FloatMatrix vr (nvr, nvr);
   float *pvr = vr.fortran_vec ();
 
+  volatile octave_idx_type nvl = calc_lev ? n : 0;
+  FloatMatrix vl (nvl, nvl);
+  float *pvl = vl.fortran_vec ();
+
   octave_idx_type lwork = -1;
   float dummy_work;
 
-  float *dummy = 0;
-  octave_idx_type idummy = 1;
-
-  F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n,
                            par, pai, pbeta,
-                           dummy, idummy, pvr, n,
+                           pvl, n, pvr, n,
                            &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("sggev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work);
   Array<float> work (dim_vector (lwork, 1));
   float *pwork = work.fortran_vec ();
 
-  F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n,
                            par, pai, pbeta,
-                           dummy, idummy, pvr, n,
+                           pvl, n, pvr, n,
                            pwork, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in sggev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("sggev failed to converge");
 
   lambda.resize (n);
   v.resize (nvr, nvr);
+  w.resize (nvl, nvl);
+
 
   for (octave_idx_type j = 0; j < n; j++)
     {
       if (ai.elem (j) == 0.0)
         {
           lambda.elem (j) = FloatComplex (ar.elem (j) / beta.elem (j));
           for (octave_idx_type i = 0; i < nvr; i++)
             v.elem (i, j) = vr.elem (i, j);
+
+          for (octave_idx_type i = 0; i < nvl; i++)
+            w.elem (i, j) = vl.elem (i, j);
         }
       else
         {
           if (j+1 >= n)
             (*current_liboctave_error_handler) ("EIG: internal error");
 
           lambda.elem (j) = FloatComplex (ar.elem (j) / beta.elem (j),
                                           ai.elem (j) / beta.elem (j));
@@ -510,26 +606,33 @@ FloatEIG::init (const FloatMatrix& a, co
 
           for (octave_idx_type i = 0; i < nvr; i++)
             {
               float real_part = vr.elem (i, j);
               float imag_part = vr.elem (i, j+1);
               v.elem (i, j) = FloatComplex (real_part, imag_part);
               v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
             }
+          for (octave_idx_type i = 0; i < nvl; i++)
+            {
+              float real_part = vl.elem (i, j);
+              float imag_part = vl.elem (i, j+1);
+              w.elem (i, j) = FloatComplex (real_part, imag_part);
+              w.elem (i, j+1) = FloatComplex (real_part, -imag_part);
+            }
           j++;
         }
     }
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::symmetric_init (const FloatMatrix& a, const FloatMatrix& b,
-                          bool calc_ev)
+                          bool calc_rev, bool calc_lev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
@@ -544,54 +647,55 @@ FloatEIG::symmetric_init (const FloatMat
   float *btmp_data = btmp.fortran_vec ();
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   float dummy_work;
 
-  F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n,
                            btmp_data, n,
                            pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("ssygv workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work);
   Array<float> work (dim_vector (lwork, 1));
   float *pwork = work.fortran_vec ();
 
-  F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n,
                            btmp_data, n,
                            pwr, pwork, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in ssygv");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("ssygv failed to converge");
 
   lambda = FloatComplexColumnVector (wr);
-  v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
+  v = calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
+  w = calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::init (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
-                bool calc_ev)
+                bool calc_rev, bool calc_lev, bool force_qz)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
@@ -601,92 +705,102 @@ FloatEIG::init (const FloatComplexMatrix
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix tmp = b;
   FloatComplex *tmp_data = tmp.fortran_vec ();
 
-  F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-                             n, F77_CMPLX_ARG (tmp_data), n,
-                             info
-                             F77_CHAR_ARG_LEN (1)));
+  if (! force_qz)
+    {
+      F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
+                                 n, F77_CMPLX_ARG (tmp_data), n,
+                                 info
+                                 F77_CHAR_ARG_LEN (1)));
 
-  if (a.is_hermitian () && b.is_hermitian () && info == 0)
-    return hermitian_init (a, b, calc_ev);
+      if (a.is_hermitian () && b.is_hermitian () && info == 0)
+        return hermitian_init (a, b, calc_rev, calc_lev);
+    }
 
   FloatComplexMatrix atmp = a;
   FloatComplex *atmp_data = atmp.fortran_vec ();
 
   FloatComplexMatrix btmp = b;
   FloatComplex *btmp_data = btmp.fortran_vec ();
 
   FloatComplexColumnVector alpha (n);
   FloatComplex *palpha = alpha.fortran_vec ();
 
   FloatComplexColumnVector beta (n);
   FloatComplex *pbeta = beta.fortran_vec ();
 
-  octave_idx_type nvr = calc_ev ? n : 0;
-  FloatComplexMatrix vtmp (nvr, nvr);
-  FloatComplex *pv = vtmp.fortran_vec ();
+  octave_idx_type nvr = calc_rev ? n : 0;
+  FloatComplexMatrix vrtmp (nvr, nvr);
+  FloatComplex *pvr = vrtmp.fortran_vec ();
+
+  octave_idx_type nvl = calc_lev ? n : 0;
+  FloatComplexMatrix vltmp (nvl, nvl);
+  FloatComplex *pvl = vltmp.fortran_vec ();
 
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 8*n;
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
-  FloatComplex *dummy = 0;
-  octave_idx_type idummy = 1;
-
-  F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, F77_CMPLX_ARG (atmp_data), n, F77_CMPLX_ARG (btmp_data), n,
-                           F77_CMPLX_ARG (palpha), F77_CMPLX_ARG (pbeta), F77_CMPLX_ARG (dummy), idummy,
-                           F77_CMPLX_ARG (pv), n, F77_CMPLX_ARG (&dummy_work), lwork, prwork, info
+  F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
+                           n, F77_CMPLX_ARG (atmp_data), n,
+                           F77_CMPLX_ARG (btmp_data), n,
+                           F77_CMPLX_ARG (palpha), F77_CMPLX_ARG (pbeta),
+                           F77_CMPLX_ARG (pvl), n, F77_CMPLX_ARG (pvr), n,
+                           F77_CMPLX_ARG (&dummy_work), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("cggev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
-  F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, F77_CMPLX_ARG (atmp_data), n, F77_CMPLX_ARG (btmp_data), n,
-                           F77_CMPLX_ARG (palpha), F77_CMPLX_ARG (pbeta), F77_CMPLX_ARG (dummy), idummy,
-                           F77_CMPLX_ARG (pv), n, F77_CMPLX_ARG (pwork), lwork, prwork, info
+  F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
+                           n, F77_CMPLX_ARG (atmp_data), n,
+                           F77_CMPLX_ARG (btmp_data), n,
+                           F77_CMPLX_ARG (palpha), F77_CMPLX_ARG (pbeta),
+                           F77_CMPLX_ARG (pvl), n, F77_CMPLX_ARG (pvr), n,
+                           F77_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in cggev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("cggev failed to converge");
 
   lambda.resize (n);
 
   for (octave_idx_type j = 0; j < n; j++)
     lambda.elem (j) = alpha.elem (j) / beta.elem (j);
 
-  v = vtmp;
+  v = vrtmp;
+  w = vltmp;
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::hermitian_init (const FloatComplexMatrix& a,
-                          const FloatComplexMatrix& b, bool calc_ev)
+                          const FloatComplexMatrix& b,
+                          bool calc_rev, bool calc_lev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
@@ -705,43 +819,44 @@ FloatEIG::hermitian_init (const FloatCom
 
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
-  F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, F77_CMPLX_ARG (atmp_data), n,
                            F77_CMPLX_ARG (btmp_data), n,
                            pwr, F77_CMPLX_ARG (&dummy_work), lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zhegv workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
-  F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+  F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, F77_CMPLX_ARG (atmp_data), n,
                            F77_CMPLX_ARG (btmp_data), n,
                            pwr, F77_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zhegv failed to converge");
 
   lambda = FloatComplexColumnVector (wr);
-  v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
+  v = calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
+  w = calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
 
   return info;
 }
diff --git a/liboctave/numeric/fEIG.h b/liboctave/numeric/fEIG.h
--- a/liboctave/numeric/fEIG.h
+++ b/liboctave/numeric/fEIG.h
@@ -35,108 +35,123 @@ class
 OCTAVE_API
 FloatEIG
 {
   friend class FloatMatrix;
   friend class FloatComplexMatrix;
 
 public:
 
-  FloatEIG (void)
-    : lambda (), v () { }
+  FloatEIG (void) : lambda (), v (), w () { }
 
-  FloatEIG (const FloatMatrix& a, bool calc_eigenvectors = true)
-    : lambda (), v ()
+  FloatEIG (const FloatMatrix& a, bool calc_rev = true,
+            bool calc_lev = true, bool balance = true)
+    : lambda (), v (), w ()
   {
-    init (a, calc_eigenvectors);
+    init (a, calc_rev, calc_lev, balance);
   }
 
   FloatEIG (const FloatMatrix& a, octave_idx_type& info,
-            bool calc_eigenvectors = true)
-    : lambda (), v ()
+            bool calc_rev = true, bool calc_lev = true, bool balance = true)
+    : lambda (), v (), w ()
   {
-    info = init (a, calc_eigenvectors);
+    info = init (a, calc_rev, calc_lev, balance);
   }
 
   FloatEIG (const FloatMatrix& a, const FloatMatrix& b,
-            bool calc_eigenvectors = true)
-    : lambda (), v ()
+            bool calc_rev = true, bool calc_lev = true, bool force_qz = false)
+    : lambda (), v (), w ()
   {
-    init (a, b, calc_eigenvectors);
+    init (a, b, calc_rev, calc_lev, force_qz);
   }
 
   FloatEIG (const FloatMatrix& a, const FloatMatrix& b, octave_idx_type& info,
-            bool calc_eigenvectors = true)
-    : lambda (), v ()
+            bool calc_rev = true, bool calc_lev = true, bool force_qz = false)
+    : lambda (), v (), w ()
   {
-    info = init (a, b, calc_eigenvectors);
+    info = init (a, b, calc_rev, calc_lev, force_qz);
   }
 
-  FloatEIG (const FloatComplexMatrix& a, bool calc_eigenvectors = true)
-    : lambda (), v ()
+  FloatEIG (const FloatComplexMatrix& a, bool calc_rev = true,
+            bool calc_lev = true, bool balance = true)
+    : lambda (), v (), w ()
   {
-    init (a, calc_eigenvectors);
+    init (a, calc_rev, calc_lev, balance);
   }
 
   FloatEIG (const FloatComplexMatrix& a, octave_idx_type& info,
-            bool calc_eigenvectors = true)
-    : lambda (), v ()
+            bool calc_rev = true, bool calc_lev = true, bool balance = true)
+    : lambda (), v (), w ()
   {
-    info = init (a, calc_eigenvectors);
+    info = init (a, calc_rev, calc_lev, balance);
   }
 
   FloatEIG (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
-            bool calc_eigenvectors = true)
-    : lambda (), v ()
+            bool calc_rev = true, bool calc_lev = true, bool force_qz = false)
+    : lambda (), v (), w ()
   {
-    init (a, b, calc_eigenvectors);
+    init (a, b, calc_rev, calc_lev, force_qz);
   }
 
   FloatEIG (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
-            octave_idx_type& info, bool calc_eigenvectors = true)
-    : lambda (), v ()
+            octave_idx_type& info, bool calc_rev = true, bool calc_lev = true,
+            bool force_qz = false)
+    : lambda (), v (), w ()
   {
-    info = init (a, b, calc_eigenvectors);
+    info = init (a, b, calc_rev, calc_lev, force_qz);
   }
 
-  FloatEIG (const FloatEIG& a) : lambda (a.lambda), v (a.v) { }
+  FloatEIG (const FloatEIG& a) : lambda (a.lambda), v (a.v), w (a.w) { }
 
   FloatEIG& operator = (const FloatEIG& a)
   {
     if (this != &a)
       {
         lambda = a.lambda;
         v = a.v;
+        w = a.w;
       }
     return *this;
   }
 
   ~FloatEIG (void) { }
 
   FloatComplexColumnVector eigenvalues (void) const { return lambda; }
-
-  FloatComplexMatrix eigenvectors (void) const { return v; }
+  FloatComplexMatrix right_eigenvectors (void) const { return v; }
+  FloatComplexMatrix left_eigenvectors (void) const { return w; }
 
   friend std::ostream&  operator << (std::ostream& os, const FloatEIG& a);
 
 private:
 
   FloatComplexColumnVector lambda;
   FloatComplexMatrix v;
+  FloatComplexMatrix w;
 
-  octave_idx_type init (const FloatMatrix& a, bool calc_eigenvectors);
+  octave_idx_type init (const FloatMatrix& a, bool calc_rev, bool calc_lev,
+                        bool balance);
+
   octave_idx_type init (const FloatMatrix& a, const FloatMatrix& b,
-                        bool calc_eigenvectors);
-  octave_idx_type init (const FloatComplexMatrix& a, bool calc_eigenvectors);
+                        bool calc_rev, bool calc_lev, bool force_qz);
+
+  octave_idx_type init (const FloatComplexMatrix& a, bool calc_rev,
+                        bool calc_lev, bool balance);
+
   octave_idx_type init (const FloatComplexMatrix& a,
-                        const FloatComplexMatrix& b, bool calc_eigenvectors);
+                        const FloatComplexMatrix& b,
+                        bool calc_rev, bool calc_lev, bool force_qz);
 
-  octave_idx_type symmetric_init (const FloatMatrix& a, bool calc_eigenvectors);
+  octave_idx_type symmetric_init (const FloatMatrix& a, bool calc_rev,
+                                  bool calc_lev);
+
   octave_idx_type symmetric_init (const FloatMatrix& a, const FloatMatrix& b,
-                                  bool calc_eigenvectors);
+                                  bool calc_rev, bool calc_lev);
+
   octave_idx_type hermitian_init (const FloatComplexMatrix& a,
-                                  bool calc_eigenvectors);
+                                  bool calc_rev, bool calc_lev);
+
   octave_idx_type hermitian_init (const FloatComplexMatrix& a,
                                   const FloatComplexMatrix& b,
-                                  bool calc_eigenvectors);
+                                  bool calc_rev, bool calc_lev);
+
 };
 
 #endif
