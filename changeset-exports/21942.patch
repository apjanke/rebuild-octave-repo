# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1466185504 14400
#      Fri Jun 17 13:45:04 2016 -0400
# Node ID aab79a1885cc251c82bc94119397147c25ce6f7d
# Parent  1d23b75cbcd16f5bb3d339755c7e960c9d68be46
limit gnulib headers to liboctave/wrappers directory

* libinterp/module.mk, liboctave/module.mk, src/module.mk,
libgui/src/module.mk: Don't include libgnu directory in lists of
include directories.

* c-file-ptr-stream.cc, data.cc, dirfns.cc, file-io.cc,
ft-text-renderer.cc, gcd.cc, gl2ps-print.cc, graphics.cc, mex.cc,
oct-fstrm.cc, oct-procbuf.cc, oct-tex-lexer.in.ll,
oct-tex-parser.in.yy, pr-output.cc, quadcc.cc, rand.cc, toplev.cc,
utils.cc, __delaunayn__.cc, __init_fltk__.cc, __voronoi__.cc,
convhulln.cc, ov-cell.cc, ov-float.cc, ov-scalar.cc, lex.ll,
oct-parse.in.yy, Range.cc, idx-vector.cc, Faddeeva/Faddeeva.cc,
lo-mappers.cc, lo-specfun.cc, randgamma.cc, randmtzig.cc,
randpoisson.cc, dir-ops.cc, file-ops.cc, file-stat.cc, oct-env.cc,
oct-syscalls.cc, oct-time.cc, oct-uname.cc, cmd-edit.cc, cmd-hist.cc,
lo-utils.cc, oct-inttypes.cc, oct-shlib.cc, sparse-util.cc,
mkoctfile.in.cc: Use std:: instead of gnulib:: namespace.

* oct-conf-post.in.h: Don't define GNULIB_NAMESPACE.

diff --git a/libgui/src/module.mk b/libgui/src/module.mk
--- a/libgui/src/module.mk
+++ b/libgui/src/module.mk
@@ -209,17 +209,16 @@ libgui_src_libgui_src_la_CPPFLAGS = \
   -Iliboctave/numeric -I$(srcdir)/liboctave/numeric \
   -Iliboctave/operators -I$(srcdir)/liboctave/operators \
   -I$(srcdir)/liboctave/system \
   -I$(srcdir)/liboctave/util \
   -Ilibinterp -I$(srcdir)/libinterp \
   -Ilibinterp/parse-tree -I$(srcdir)/libinterp/parse-tree \
   -Ilibinterp/corefcn -I$(srcdir)/libinterp/corefcn \
   -I$(srcdir)/libinterp/octave-value \
-  -Ilibgnu -I$(srcdir)/libgnu \
   -I$(srcdir)/liboctave/wrappers
 
 libgui_src_libgui_src_la_CFLAGS = $(AM_CFLAGS) $(WARN_CFLAGS)
 
 libgui_src_libgui_src_la_CXXFLAGS = $(AM_CXXFLAGS) $(WARN_CXXFLAGS)
 
 noinst_LTLIBRARIES += libgui/src/libgui-src.la
 
diff --git a/libinterp/corefcn/c-file-ptr-stream.cc b/libinterp/corefcn/c-file-ptr-stream.cc
--- a/libinterp/corefcn/c-file-ptr-stream.cc
+++ b/libinterp/corefcn/c-file-ptr-stream.cc
@@ -48,27 +48,27 @@ c_file_ptr_buf::~c_file_ptr_buf (void)
 }
 
 // FIXME: I'm sure there is room for improvement here...
 
 c_file_ptr_buf::int_type
 c_file_ptr_buf::overflow (int_type c)
 {
   if (f)
-    return (c != traits_type::eof ()) ? gnulib::fputc (c, f) : flush ();
+    return (c != traits_type::eof ()) ? std::fputc (c, f) : flush ();
   else
     return traits_type::not_eof (c);
 }
 
 c_file_ptr_buf::int_type
 c_file_ptr_buf::underflow_common (bool bump)
 {
   if (f)
     {
-      int_type c = gnulib::fgetc (f);
+      int_type c = std::fgetc (f);
 
       if (! bump && c != traits_type::eof ())
         ungetc (c, f);
 
       return c;
     }
   else
     return traits_type::eof ();
@@ -80,26 +80,26 @@ c_file_ptr_buf::pbackfail (int_type c)
   return ((c != traits_type::eof () && f)
           ? ungetc (c, f) : traits_type::not_eof (c));
 }
 
 std::streamsize
 c_file_ptr_buf::xsputn (const char* s, std::streamsize n)
 {
   if (f)
-    return gnulib::fwrite (s, 1, n, f);
+    return std::fwrite (s, 1, n, f);
   else
     return 0;
 }
 
 std::streamsize
 c_file_ptr_buf::xsgetn (char *s, std::streamsize n)
 {
   if (f)
-    return gnulib::fread (s, 1, n, f);
+    return std::fread (s, 1, n, f);
   else
     return 0;
 }
 
 static inline int
 seekdir_to_whence (std::ios::seekdir dir)
 {
   return (dir == std::ios::beg
@@ -142,17 +142,17 @@ c_file_ptr_buf::sync (void)
   flush ();
 
   return 0;
 }
 
 int
 c_file_ptr_buf::flush (void)
 {
-  return f ? gnulib::fflush (f) : traits_type::eof ();
+  return f ? std::fflush (f) : traits_type::eof ();
 }
 
 int
 c_file_ptr_buf::buf_close (void)
 {
   int retval = -1;
 
   flush ();
@@ -176,17 +176,17 @@ off_t
 c_file_ptr_buf::tell (void)
 {
   return f ? octave_ftello_wrapper (f) : -1;
 }
 
 int
 c_file_ptr_buf::file_close (FILE *f)
 {
-  return gnulib::fclose (f);
+  return std::fclose (f);
 }
 
 #if defined (HAVE_ZLIB)
 
 c_zfile_ptr_buf::~c_zfile_ptr_buf (void)
 {
   buf_close ();
 }
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -4529,17 +4529,17 @@ type and may be either @qcode{\"double\"
               float val = ::fabsf (x(i));
               if (octave::math::isnan (val) || octave::math::isinf (val))
                 epsval(i) = lo_ieee_nan_value ();
               else if (val < std::numeric_limits<float>::min ())
                 epsval(i) = powf (2.0, -149e0);
               else
                 {
                   int expon;
-                  gnulib::frexpf (val, &expon);
+                  std::frexp (val, &expon);
                   epsval(i) = std::pow (2.0f,
                                         static_cast<float> (expon - 24));
                 }
             }
 
           retval = epsval;
         }
       else
@@ -4553,17 +4553,17 @@ type and may be either @qcode{\"double\"
               double val = ::fabs (x(i));
               if (octave::math::isnan (val) || octave::math::isinf (val))
                 epsval(i) = lo_ieee_nan_value ();
               else if (val < std::numeric_limits<double>::min ())
                 epsval(i) = pow (2.0, -1074e0);
               else
                 {
                   int expon;
-                  gnulib::frexp (val, &expon);
+                  std::frexp (val, &expon);
                   epsval(i) = std::pow (2.0,
                                         static_cast<double> (expon - 53));
                 }
 
               retval = epsval;
             }
         }
     }
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -68,17 +68,17 @@ octave::sys::time Vlast_chdir_time = 0.0
 static int
 octave_change_to_directory (const std::string& newdir)
 {
   std::string xdir = octave::sys::file_ops::tilde_expand (newdir);
 
   int cd_ok = octave::sys::env::chdir (xdir);
 
   if (! cd_ok)
-    error ("%s: %s", newdir.c_str (), gnulib::strerror (errno));
+    error ("%s: %s", newdir.c_str (), std::strerror (errno));
 
   Vlast_chdir_time.stamp ();
 
   // FIXME: should these actions be handled as a list of functions
   // to call so users can add their own chdir handlers?
 
   load_path::update ();
 
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -455,38 +455,38 @@ do_stream_open (const std::string& name,
   if (! (md & std::ios::out))
     fname = find_data_file_in_load_path ("fopen", fname);
 
   if (! fs.is_dir ())
     {
 #if defined (HAVE_ZLIB)
       if (use_zlib)
         {
-          FILE *fptr = gnulib::fopen (fname.c_str (), mode.c_str ());
+          FILE *fptr = std::fopen (fname.c_str (), mode.c_str ());
 
           int fd = fileno (fptr);
 
           gzFile gzf = ::gzdopen (fd, mode.c_str ());
 
           if (fptr)
             retval = octave_zstdiostream::create (fname, gzf, fd,
                                                   md, flt_fmt);
           else
-            retval.error (gnulib::strerror (errno));
+            retval.error (std::strerror (errno));
         }
       else
 #endif
         {
-          FILE *fptr = gnulib::fopen (fname.c_str (), mode.c_str ());
+          FILE *fptr = std::fopen (fname.c_str (), mode.c_str ());
 
           retval = octave_stdiostream::create (fname, fptr, md,
                                                flt_fmt);
 
           if (! fptr)
-            retval.error (gnulib::strerror (errno));
+            retval.error (std::strerror (errno));
         }
 
     }
 
   return retval;
 }
 
 static octave_stream
@@ -2834,34 +2834,34 @@ system-dependent error message.\n\
 @seealso{tempname, mkstemp, tempdir, P_tmpdir}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
   octave_value_list retval;
 
-  FILE *fid = gnulib::tmpfile ();
+  FILE *fid = std::tmpfile ();
 
   if (fid)
     {
       std::string nm;
 
       std::ios::openmode md = fopen_mode_to_ios_mode ("w+b");
 
       octave_stream s = octave_stdiostream::create (nm, fid, md);
 
       if (! s)
         error ("tmpfile: failed to create octave_stdiostream object");
 
       retval = ovl (octave_stream_list::insert (s), "");
     }
   else
     {
-      retval = ovl (-1, gnulib::strerror (errno));
+      retval = ovl (-1, std::strerror (errno));
     }
 
   return retval;
 }
 
 DEFUN (mkstemp, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (\"@var{template}\")\n\
@@ -2898,28 +2898,28 @@ message.\n\
   OCTAVE_LOCAL_BUFFER (char, tmp, tmpl8.size () + 1);
   strcpy (tmp, tmpl8.c_str ());
 
   int fd = octave_mkostemp_wrapper (tmp);
 
   if (fd < 0)
     {
       retval(0) = fd;
-      retval(2) = gnulib::strerror (errno);
+      retval(2) = std::strerror (errno);
     }
   else
     {
       const char *fopen_mode = "w+b";
 
       FILE *fid = fdopen (fd, fopen_mode);
 
       if (! fid)
         {
           retval(0) = -1;
-          retval(2) = gnulib::strerror (errno);
+          retval(2) = std::strerror (errno);
         }
       else
         {
           std::string nm = tmp;
 
           std::ios::openmode md = fopen_mode_to_ios_mode (fopen_mode);
 
           octave_stream s = octave_stdiostream::create (nm, fid, md);
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -846,17 +846,17 @@ ft_text_renderer::visit (text_element_st
       mbstate_t ps;
       memset (&ps, 0, sizeof (ps));  // Initialize state to 0.
       wchar_t wc;
 
       text_renderer::string fs (str, font, xoffset, yoffset);
 
       while (n > 0)
         {
-          size_t r = gnulib::mbrtowc (&wc, str.data () + curr, n, &ps);
+          size_t r = std::mbrtowc (&wc, str.data () + curr, n, &ps);
 
           if (r > 0
               && r != static_cast<size_t> (-1)
               && r != static_cast<size_t> (-2))
             {
               n -= r;
               curr += r;
 
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -58,18 +58,18 @@ simple_gcd (double a, double b)
 // Don't use the Complex and FloatComplex typedefs because we need to
 // refer to the actual float precision FP in the body (and when gcc
 // implements template aliases from C++0x, can do a small fix here).
 template <typename FP>
 static void
 divide (const std::complex<FP>& a, const std::complex<FP>& b,
         std::complex<FP>& q, std::complex<FP>& r)
 {
-  FP qr = gnulib::floor ((a/b).real () + 0.5);
-  FP qi = gnulib::floor ((a/b).imag () + 0.5);
+  FP qr = std::floor ((a/b).real () + 0.5);
+  FP qi = std::floor ((a/b).imag () + 0.5);
 
   q = std::complex<FP> (qr, qi);
 
   r = a - q*b;
 }
 
 template <typename FP>
 static std::complex<FP>
@@ -123,17 +123,17 @@ extended_gcd (double a, double b, double
   double bb = fabs (b);
 
   double xx, lx, yy, ly;
   xx = 0, lx = 1;
   yy = 1, ly = 0;
 
   while (bb != 0)
     {
-      double qq = gnulib::floor (aa / bb);
+      double qq = std::floor (aa / bb);
       double tt = fmod (aa, bb);
 
       aa = bb;
       bb = tt;
 
       double tx = lx - qq*xx;
       lx = xx;
       xx = tx;
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -192,29 +192,29 @@ gl2ps_renderer::draw (const graphics_obj
       // Default sort order optimizes for 3D plots
       GLint gl2ps_sort = GL2PS_BSP_SORT;
 
       // For 2D plots we can use a simpler Z-depth sorting algorithm
       if (term.find ("is2D") != std::string::npos)
         gl2ps_sort = GL2PS_SIMPLE_SORT;
 
       // Use a temporary file in case an overflow happens
-      FILE* tmpf = gnulib::tmpfile ();
+      FILE* tmpf = std::tmpfile ();
 
       if (! tmpf)
         error ("gl2ps_renderer::draw: couldn't open temporary file for printing");
 
       GLint buffsize = 2*1024*1024;
       buffer_overflow = true;
 
       while (buffer_overflow)
         {
           buffer_overflow = false;
           buffsize *= 2;
-          gnulib::fseek (tmpf, 0, SEEK_SET);
+          std::fseek (tmpf, 0, SEEK_SET);
           octave_ftruncate_wrapper (fileno (tmpf), 0);
 
           // For LaTeX output the fltk print process uses 2 drawnow() commands.
           // The first one is for the pdf/ps/eps graph to be included.  The
           // print_cmd is saved as old_print_cmd.  Then the second drawnow()
           // outputs the tex-file and the graphic filename to be included is
           // extracted from old_print_cmd.
 
@@ -263,26 +263,26 @@ gl2ps_renderer::draw (const graphics_obj
 
           // Don't check return value of gl2psEndPage, it is not meaningful.
           // Errors and warnings are checked after gl2psEndViewport in
           // gl2ps_renderer::draw_axes instead.
           gl2psEndPage ();
         }
 
       // Copy temporary file to pipe
-      gnulib::fseek (tmpf, 0, SEEK_SET);
+      std::fseek (tmpf, 0, SEEK_SET);
       char str[256];
       size_t nread, nwrite;
       nread = 1;
       while (! feof (tmpf) && nread)
         {
-          nread = gnulib::fread (str, 1, 256, tmpf);
+          nread = std::fread (str, 1, 256, tmpf);
           if (nread)
             {
-              nwrite = gnulib::fwrite (str, 1, nread, fp);
+              nwrite = std::fwrite (str, 1, nread, fp);
               if (nwrite != nread)
                 {
                   octave_signal_handler ();   // Clear SIGPIPE signal
                   error ("gl2ps_renderer::draw: internal pipe error");
                 }
             }
         }
     }
@@ -764,17 +764,17 @@ safe_pclose (FILE *f)
   if (f)
     octave_pclose (f);
 }
 
 static void
 safe_fclose (FILE *f)
 {
   if (f)
-    gnulib::fclose (f);
+    std::fclose (f);
 }
 
 #endif
 
 // If the name of the stream begins with '|', open a pipe to the command
 // named by the rest of the string.  Otherwise, write to the named file.
 
 void
@@ -804,17 +804,17 @@ gl2ps_print (const graphics_object& fig,
         error ("print: failed to open pipe \"%s\"", stream.c_str ());
 
       frame.add_fcn (safe_pclose, fp);
     }
   else
     {
       // Write gl2ps output directly to file.
 
-      fp = gnulib::fopen (stream.c_str (), "w");
+      fp = std::fopen (stream.c_str (), "w");
 
       if (! fp)
         error ("gl2ps_print: failed to create file \"%s\"", stream.c_str ());
 
       frame.add_fcn (safe_fclose, fp);
     }
 
   gl2ps_renderer rend (fp, term);
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -6665,17 +6665,17 @@ magform (double x, double& a, int& b)
 {
   if (x == 0)
     {
       a = 0;
       b = 0;
     }
   else
     {
-      b = static_cast<int> (gnulib::floor (std::log10 (std::abs (x))));
+      b = static_cast<int> (std::floor (std::log10 (std::abs (x))));
       a = x / std::pow (10.0, b);
     }
 }
 
 // A translation from Tom Holoryd's python code at
 // http://kurage.nimh.nih.gov/tomh/tics.py
 // FIXME: add log ticks
 
@@ -6761,24 +6761,24 @@ axes::properties::get_axis_limits (doubl
                 {
                   min_val *= 1.1;
                   max_val *= 0.9;
                 }
             }
           if (min_val > 0)
             {
               // Log plots with all positive data
-              min_val = pow (10, gnulib::floor (log10 (min_val)));
+              min_val = pow (10, std::floor (log10 (min_val)));
               max_val = pow (10, std::ceil (log10 (max_val)));
             }
           else
             {
               // Log plots with all negative data
               min_val = -pow (10, std::ceil (log10 (-min_val)));
-              max_val = -pow (10, gnulib::floor (log10 (-max_val)));
+              max_val = -pow (10, std::floor (log10 (-max_val)));
             }
         }
       else
         {
           if (min_val == 0 && max_val == 0)
             {
               min_val = -1;
               max_val = 1;
@@ -6787,17 +6787,17 @@ axes::properties::get_axis_limits (doubl
           else if (std::abs (min_val - max_val)
                    < sqrt (std::numeric_limits<double>::epsilon ()))
             {
               min_val -= 0.1 * std::abs (min_val);
               max_val += 0.1 * std::abs (max_val);
             }
 
           double tick_sep = calc_tick_sep (min_val, max_val);
-          double min_tick = gnulib::floor (min_val / tick_sep);
+          double min_tick = std::floor (min_val / tick_sep);
           double max_tick = std::ceil (max_val / tick_sep);
           // Prevent round-off from cropping ticks
           min_val = std::min (min_val, tick_sep * min_tick);
           max_val = std::max (max_val, tick_sep * max_tick);
         }
     }
 
   retval.resize (1, 2);
@@ -6849,17 +6849,17 @@ axes::properties::calc_ticks_and_lims (a
       if (! (octave::math::isinf (hi) || octave::math::isinf (lo)))
         tick_sep = 1;  // Tick is every order of magnitude (bug #39449)
       else
         tick_sep = 0;
     }
   else
     tick_sep = calc_tick_sep (lo, hi);
 
-  int i1 = static_cast<int> (gnulib::floor (lo / tick_sep));
+  int i1 = static_cast<int> (std::floor (lo / tick_sep));
   int i2 = static_cast<int> (std::ceil (hi / tick_sep));
 
   if (limmode_is_auto)
     {
       // Adjust limits to include min and max ticks
       Matrix tmp_lims (1,2);
       tmp_lims(0) = std::min (tick_sep * i1, lo);
       tmp_lims(1) = std::max (tick_sep * i2, hi);
@@ -6951,19 +6951,19 @@ axes::properties::calc_ticklabels (const
         {
           exp_max = std::max (exp_max, std::log10 (values(i)));
           exp_min = std::max (exp_min, std::log10 (values(i)));
         }
 
       for (int i = 0; i < values.numel (); i++)
         {
           if (values(i) < 0.0)
-            exponent = gnulib::floor (std::log10 (-values(i)));
+            exponent = std::floor (std::log10 (-values(i)));
           else
-            exponent = gnulib::floor (std::log10 (values(i)));
+            exponent = std::floor (std::log10 (values(i)));
           significand = values(i) * std::pow (10., -exponent);
 
           os.str ("");
           if ((std::abs (significand) - 1) >
               std::numeric_limits<double>::epsilon())
             os << significand << ".";
           else if (significand < 0)
             os << "-";
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -2028,17 +2028,17 @@ public:
       }
 
     return fname;
   }
 
   // Allocate memory.
   void *malloc_unmarked (size_t n)
   {
-    void *ptr = gnulib::malloc (n);
+    void *ptr = std::malloc (n);
 
     if (! ptr)
       {
         // FIXME: could use "octave_new_handler();" instead
         error ("%s: failed to allocate %d bytes of memory",
                function_name (), n);
       }
 
@@ -2081,17 +2081,17 @@ public:
   // If the pointer is NULL, allocate using malloc.
   // We don't need an "unmarked" version of this.
   void *realloc (void *ptr, size_t n)
   {
     void *v;
 
     if (ptr)
       {
-        v = gnulib::realloc (ptr, n);
+        v = std::realloc (ptr, n);
 
         std::set<void *>::iterator p = memlist.find (ptr);
 
         if (v && p != memlist.end ())
           {
             memlist.erase (p);
             memlist.insert (v);
           }
@@ -2296,17 +2296,17 @@ private:
 std::set<void *> mex::global_memlist;
 
 // Current context.
 mex *mex_context = 0;
 
 void *
 mxArray::malloc (size_t n)
 {
-  return mex_context ? mex_context->malloc_unmarked (n) : gnulib::malloc (n);
+  return mex_context ? mex_context->malloc_unmarked (n) : std::malloc (n);
 }
 
 void *
 mxArray::calloc (size_t n, size_t t)
 {
   return mex_context ? mex_context->calloc_unmarked (n, t) : ::calloc (n, t);
 }
 
@@ -2398,24 +2398,24 @@ void *
 mxCalloc (size_t n, size_t size)
 {
   return mex_context ? mex_context->calloc (n, size) : ::calloc (n, size);
 }
 
 void *
 mxMalloc (size_t n)
 {
-  return mex_context ? mex_context->malloc (n) : gnulib::malloc (n);
+  return mex_context ? mex_context->malloc (n) : std::malloc (n);
 }
 
 void *
 mxRealloc (void *ptr, size_t size)
 {
   return mex_context ? mex_context->realloc (ptr, size)
-                     : gnulib::realloc (ptr, size);
+                     : std::realloc (ptr, size);
 }
 
 void
 mxFree (void *ptr)
 {
   if (mex_context)
     mex_context->free (ptr);
   else
diff --git a/libinterp/corefcn/oct-fstrm.cc b/libinterp/corefcn/oct-fstrm.cc
--- a/libinterp/corefcn/oct-fstrm.cc
+++ b/libinterp/corefcn/oct-fstrm.cc
@@ -41,17 +41,17 @@ octave_fstream::octave_fstream (const st
                                 std::ios::openmode arg_md,
                                 octave::mach_info::float_format ff)
   : octave_base_stream (arg_md, ff), nm (nm_arg)
 {
   fs.open (nm.c_str (), arg_md);
 
   if (! fs)
     // Note: error is inherited from octave_base_stream, not ::error.
-    error (gnulib::strerror (errno));
+    error (std::strerror (errno));
 }
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
 octave_fstream::seek (off_t, int)
 {
   // Note: error is inherited from octave_base_stream, not ::error.
diff --git a/libinterp/corefcn/oct-procbuf.cc b/libinterp/corefcn/oct-procbuf.cc
--- a/libinterp/corefcn/oct-procbuf.cc
+++ b/libinterp/corefcn/oct-procbuf.cc
@@ -115,17 +115,17 @@ octave_procbuf::open (const char *comman
         }
 
       while (octave_procbuf_list)
         {
           FILE *fp = octave_procbuf_list->f;
 
           if (fp)
             {
-              gnulib::fclose (fp);
+              std::fclose (fp);
               fp = 0;
             }
 
           octave_procbuf_list = octave_procbuf_list->next;
         }
 
       execl (SHELL_PATH, "sh", "-c", command, static_cast<void *> (0));
 
@@ -189,17 +189,17 @@ octave_procbuf::close (void)
           if (*ptr == this)
             {
               *ptr = (*ptr)->next;
               status = 0;
               break;
             }
         }
 
-      if (status == 0 && gnulib::fclose (f) == 0)
+      if (status == 0 && std::fclose (f) == 0)
         {
           using namespace std;
 
           do
             {
               wait_pid = octave::sys::waitpid (proc_pid, &wstatus, 0);
             }
           while (wait_pid == -1 && errno == EINTR);
diff --git a/libinterp/corefcn/oct-tex-lexer.in.ll b/libinterp/corefcn/oct-tex-lexer.in.ll
--- a/libinterp/corefcn/oct-tex-lexer.in.ll
+++ b/libinterp/corefcn/oct-tex-lexer.in.ll
@@ -72,28 +72,16 @@ along with Octave; see the file COPYING.
 
 #if defined (OCTAVE_TEX_STYPE_IS_DECLARED) && ! defined YYSTYPE
 #  define YYSTYPE OCTAVE_TEX_STYPE
 #endif
 
 #define YY_NO_UNISTD_H 1
 #define isatty octave_isatty_wrapper
 
-#if defined (GNULIB_NAMESPACE)
-// Calls to the following functions appear in the generated output
-// from flex without the namespace tag.  Redefine them so we will use
-// them via the gnulib namespace.
-#  define fprintf GNULIB_NAMESPACE::fprintf
-#  define fread GNULIB_NAMESPACE::fread
-#  define fwrite GNULIB_NAMESPACE::fwrite
-#  define getc GNULIB_NAMESPACE::getc
-#  define malloc GNULIB_NAMESPACE::malloc
-#  define realloc GNULIB_NAMESPACE::realloc
-#endif
-
 %}
 
 D   [0-9]
 NUM (({D}+\.?{D}*)|(\.{D}+))
 
 %%
 
 %{
diff --git a/libinterp/corefcn/oct-tex-parser.in.yy b/libinterp/corefcn/oct-tex-parser.in.yy
--- a/libinterp/corefcn/oct-tex-parser.in.yy
+++ b/libinterp/corefcn/oct-tex-parser.in.yy
@@ -29,25 +29,16 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "txt-eng.h"
 #include "oct-tex-parser.h"
 
 extern int octave_tex_lex (YYSTYPE *, void *);
 static void yyerror (text_parser_tex& parser, const char *s);
 
-#if defined (GNULIB_NAMESPACE)
-// Calls to the following functions appear in the generated output
-// from Bison without the namespace tag.  Redefine them so we will use
-// them via the gnulib namespace.
-#  define fclose GNULIB_NAMESPACE::fclose
-#  define fprintf GNULIB_NAMESPACE::fprintf
-#  define malloc GNULIB_NAMESPACE::malloc
-#endif
-
 #define scanner parser.get_scanner ()
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 // Disable this warning for code that is generated by Bison, including
 // grammar rules.  Push the current state so we can restore the warning
 // state prior to functions we define at the bottom of the file.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wold-style-cast"
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -237,33 +237,33 @@ calc_scale_exp (const int& x)
 
 static int
 engineering_exponent (const double& x)
 {
   int ex = 0;
   if (x != 0)
     {
       double absval = (x < 0.0 ? -x : x);
-      int logabsval = static_cast<int> (gnulib::floor (log10 (absval)));
+      int logabsval = static_cast<int> (std::floor (log10 (absval)));
       // Avoid using modulo function with negative arguments for
       // portability.  See extended comment at calc_scale_exp
       if (logabsval < 0.0)
         ex = logabsval - 2 + ((-logabsval + 2) % 3);
       else
         ex = logabsval - (logabsval % 3);
     }
   return ex;
 }
 
 static int
 num_digits (const double& x)
 {
   return 1 + (print_eng
               ? engineering_exponent (x)
-              : static_cast<int> (gnulib::floor (log10 (x))));
+              : static_cast<int> (std::floor (log10 (x))));
 }
 
 class
 pr_engineering_float
 {
 public:
 
   const float_format& f;
@@ -3257,17 +3257,17 @@ octave_print_internal_template (std::ost
         {
           bool isneg = false;
           int digits = 0;
 
           for (octave_idx_type i = 0; i < dims.numel (); i++)
             {
               int new_digits
                 = static_cast<int>
-                  (gnulib::floor (log10 (double (abs (nda(i).value ()))) + 1.0));
+                  (std::floor (log10 (double (abs (nda(i).value ()))) + 1.0));
 
               if (new_digits > digits)
                 digits = new_digits;
 
               if (! isneg)
                 isneg = (abs (nda(i).value ()) != nda(i).value ());
             }
 
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1639,17 +1639,17 @@ Mathematical Software, Vol. 37, Issue 3,
     }
 
   // If a or b are +/-Inf, transform the integral.
   if (octave::math::isinf (a) || octave::math::isinf (b))
     {
       wrap = true;
       for (i = 0; i < nivals + 1; i++)
         if (octave::math::isinf (iivals[i]))
-          iivals[i] = gnulib::copysign (1.0, iivals[i]);
+          iivals[i] = std::copysign (1.0, iivals[i]);
         else
           iivals[i] = 2.0 * atan (iivals[i]) / M_PI;
     }
 
   // Initialize the heaps.
   for (i = 0; i < cquad_heapsize; i++)
     heap[i] = i;
 
@@ -1977,17 +1977,17 @@ Mathematical Software, Vol. 37, Issue 3,
             }
           ncdiff = sqrt (ncdiff);
           ivl->err = ncdiff * h;
           // Check for divergence.
           ivl->ndiv = iv->ndiv + (fabs (iv->c[0]) > 0
                                   && ivl->c[0] / iv->c[0] > 2);
           if (ivl->ndiv > ndiv_max && 2 * ivl->ndiv > ivl->rdepth)
             {
-              igral = gnulib::copysign (octave::numeric_limits<double>::Inf (), igral);
+              igral = std::copysign (octave::numeric_limits<double>::Inf (), igral);
               warning ("quadcc: divergent integral detected");
               break;
             }
 
           // Compute the local integral.
           ivl->igral = h * w * ivl->c[0];
 
           // Generate the interval on the right.
@@ -2068,17 +2068,17 @@ Mathematical Software, Vol. 37, Issue 3,
             }
           ncdiff = sqrt (ncdiff);
           ivr->err = ncdiff * h;
           // Check for divergence.
           ivr->ndiv = iv->ndiv + (fabs (iv->c[0]) > 0
                                   && ivr->c[0] / iv->c[0] > 2);
           if (ivr->ndiv > ndiv_max && 2 * ivr->ndiv > ivr->rdepth)
             {
-              igral = gnulib::copysign (octave::numeric_limits<double>::Inf (), igral);
+              igral = std::copysign (octave::numeric_limits<double>::Inf (), igral);
               warning ("quadcc: divergent integral detected");
               break;
             }
 
           // Compute the local integral.
           ivr->igral = h * w * ivr->c[0];
 
           // Fix-up the heap: we now have one interval on top that we
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -1130,17 +1130,17 @@ using std::unordered_map;
     {
       unordered_map<octave_idx_type, octave_idx_type> map (m);
 
       // Perform the Knuth shuffle only keeping track of moved
       // entries in the map
       for (octave_idx_type i = 0; i < m; i++)
         {
           octave_idx_type k = i +
-            gnulib::floor (rvec[i] * (n - i));
+            std::floor (rvec[i] * (n - i));
 
           // For shuffling first m entries, no need to use extra
           // storage
           if (k < m)
             {
               std::swap (ivec[i], ivec[k]);
             }
           else
@@ -1153,17 +1153,17 @@ using std::unordered_map;
         }
     }
   else
     {
       // Perform the Knuth shuffle of the first m entries
       for (octave_idx_type i = 0; i < m; i++)
         {
           octave_idx_type k = i +
-            gnulib::floor (rvec[i] * (n - i));
+            std::floor (rvec[i] * (n - i));
           std::swap (ivec[i], ivec[k]);
         }
     }
 
   // Convert to doubles, reusing r.
   for (octave_idx_type i = 0; i < m; i++)
     rvec[i] = ivec[i] + 1;
 
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1710,21 +1710,21 @@ extern vfp __new_handler;
 void *
 __builtin_new (size_t sz)
 {
   void *p;
 
   // malloc (0) is unpredictable; avoid it.
   if (sz == 0)
     sz = 1;
-  p = gnulib::malloc (sz);
+  p = std::malloc (sz);
   while (p == 0)
     {
       (*__new_handler) ();
-      p = gnulib::malloc (sz);
+      p = std::malloc (sz);
     }
 
   if (debug_new_delete)
     std::cerr << "__builtin_new: " << p << std::endl;
 
   return p;
 }
 
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1316,17 +1316,17 @@ octave_asprintf (const char *fmt, ...)
 
 void
 octave_sleep (double seconds)
 {
   if (seconds <= 0)
     return;
 
   double fraction = std::modf (seconds, &seconds);
-  fraction = gnulib::floor (fraction * 1000000000); // nanoseconds
+  fraction = std::floor (fraction * 1000000000); // nanoseconds
 
   time_t sec = ((seconds > std::numeric_limits<time_t>::max ())
                 ? std::numeric_limits<time_t>::max ()
                 : static_cast<time_t> (seconds));
 
   struct timespec delay = { sec, static_cast<long> (fraction) };
   struct timespec remaining;
   octave_nanosleep_wrapper (&delay, &remaining);
diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -60,17 +60,17 @@ along with Octave; see the file COPYING.
 
 #  if defined (NEED_QHULL_VERSION)
 char qh_version[] = "__delaunayn__.oct 2007-08-21";
 #  endif
 
 static void
 close_fcn (FILE *f)
 {
-  gnulib::fclose (f);
+  std::fclose (f);
 }
 
 static bool
 octave_qhull_dims_ok (octave_idx_type dim, octave_idx_type n, const char *who)
 {
   if (sizeof (octave_idx_type) > sizeof (int))
     {
       int maxval = std::numeric_limits<int>::max ();
@@ -145,19 +145,19 @@ Undocumented internal function.\n\
       OCTAVE_LOCAL_BUFFER (char, flags, 9 + options.length ());
 
       sprintf (flags, "qhull d %s", options.c_str ());
 
       octave::unwind_protect frame;
 
       // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
-      FILE *outfile = gnulib::fopen ("NUL", "w");
+      FILE *outfile = std::fopen ("NUL", "w");
 #else
-      FILE *outfile = gnulib::fopen ("/dev/null", "w");
+      FILE *outfile = std::fopen ("/dev/null", "w");
 #endif
       FILE *errfile = stderr;
 
       if (! outfile)
         error ("__delaunayn__: unable to create temporary file for output");
 
       frame.add_fcn (close_fcn, outfile);
 
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -491,19 +491,19 @@ public:
     if (! fltk_label.empty ())
       {
         Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
                                fltk_label.c_str ()));
         if (item)
           {
             Matrix rgb = uimenup.get_foregroundcolor_rgb ();
 
-            uchar r = static_cast<uchar> (gnulib::floor (rgb (0) * 255));
-            uchar g = static_cast<uchar> (gnulib::floor (rgb (1) * 255));
-            uchar b = static_cast<uchar> (gnulib::floor (rgb (2) * 255));
+            uchar r = static_cast<uchar> (std::floor (rgb (0) * 255));
+            uchar g = static_cast<uchar> (std::floor (rgb (1) * 255));
+            uchar b = static_cast<uchar> (std::floor (rgb (2) * 255));
 
             item->labelcolor (fl_rgb_color (r, g, b));
           }
       }
   }
 
   void update_seperator (const uimenu::properties& uimenup)
   {
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -54,17 +54,17 @@ qhull command
 
 #  if defined (NEED_QHULL_VERSION)
 char qh_version[] = "__voronoi__.oct 2007-07-24";
 #  endif
 
 static void
 close_fcn (FILE *f)
 {
-  gnulib::fclose (f);
+  std::fclose (f);
 }
 
 static bool
 octave_qhull_dims_ok (octave_idx_type dim, octave_idx_type n, const char *who)
 {
   if (sizeof (octave_idx_type) > sizeof (int))
     {
       int maxval = std::numeric_limits<int>::max ();
@@ -136,19 +136,19 @@ Undocumented internal function.\n\
     }
 
   boolT ismalloc = false;
 
   octave::unwind_protect frame;
 
   // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
-  FILE *outfile = gnulib::fopen ("NUL", "w");
+  FILE *outfile = std::fopen ("NUL", "w");
 #else
-  FILE *outfile = gnulib::fopen ("/dev/null", "w");
+  FILE *outfile = std::fopen ("/dev/null", "w");
 #endif
   FILE *errfile = stderr;
 
   if (! outfile)
     error ("__voronoi__: unable to create temporary file for output");
 
   frame.add_fcn (close_fcn, outfile);
 
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -49,17 +49,17 @@ 2006-05-01 Tom Holroyd
 
 #  if defined (NEED_QHULL_VERSION)
 char qh_version[] = "convhulln.oct 2007-07-24";
 #  endif
 
 static void
 close_fcn (FILE *f)
 {
-  gnulib::fclose (f);
+  std::fclose (f);
 }
 
 static bool
 octave_qhull_dims_ok (octave_idx_type dim, octave_idx_type n, const char *who)
 {
   if (sizeof (octave_idx_type) > sizeof (int))
     {
       int maxval = std::numeric_limits<int>::max ();
@@ -153,19 +153,19 @@ convex hull is calculated.\n\n\
     }
 
   boolT ismalloc = false;
 
   octave::unwind_protect frame;
 
   // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
-  FILE *outfile = gnulib::fopen ("NUL", "w");
+  FILE *outfile = std::fopen ("NUL", "w");
 #else
-  FILE *outfile = gnulib::fopen ("/dev/null", "w");
+  FILE *outfile = std::fopen ("/dev/null", "w");
 #endif
   FILE *errfile = stderr;
 
   if (! outfile)
     error ("convhulln: unable to create temporary file for output");
 
   frame.add_fcn (close_fcn, outfile);
 
diff --git a/libinterp/module.mk b/libinterp/module.mk
--- a/libinterp/module.mk
+++ b/libinterp/module.mk
@@ -14,17 +14,16 @@ libinterp_liboctinterp_la_CPPFLAGS = \
   -Iliboctave/operators -I$(srcdir)/liboctave/operators \
   -I$(srcdir)/liboctave/system \
   -I$(srcdir)/liboctave/util \
   -I$(srcdir)/libinterp/octave-value \
   -Ilibinterp -I$(srcdir)/libinterp \
   -I$(srcdir)/libinterp/operators \
   -Ilibinterp/parse-tree -I$(srcdir)/libinterp/parse-tree \
   -Ilibinterp/corefcn -I$(srcdir)/libinterp/corefcn \
-  -Ilibgnu -I$(srcdir)/libgnu \
   -I$(srcdir)/liboctave/wrappers \
   $(HDF5_CPPFLAGS) \
   $(MAGICK_CPPFLAGS)
 
 libinterp_liboctinterp_la_CFLAGS = $(AM_CFLAGS) $(WARN_CFLAGS)
 
 libinterp_liboctinterp_la_CXXFLAGS = $(AM_CXXFLAGS) $(WARN_CXXFLAGS)
 
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1032,17 +1032,17 @@ octave_cell::save_hdf5 (octave_hdf5_id l
 
   Cell tmp = cell_value ();
 
   octave_idx_type nel = dv.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       std::ostringstream buf;
-      int digits = static_cast<int> (gnulib::floor (::log10 (static_cast<double>
+      int digits = static_cast<int> (std::floor (::log10 (static_cast<double>
                                      (nel)) + 1.0));
       buf << "_" << std::setw (digits) << std::setfill ('0') << i;
       std::string s = buf.str ();
 
       if (! add_hdf5_data (data_hid, tmp.elem (i), s.c_str (), "", false,
                            save_as_floats))
         {
           H5Gclose (data_hid);
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -316,17 +316,17 @@ octave_float_scalar::map (unary_mapper_t
       SCALAR_MAPPER (lgamma, octave::math::rc_lgamma);
       SCALAR_MAPPER (cbrt, octave::math::cbrt);
       SCALAR_MAPPER (ceil, ::ceilf);
       SCALAR_MAPPER (cos, ::cosf);
       SCALAR_MAPPER (cosh, ::coshf);
       SCALAR_MAPPER (exp, ::expf);
       SCALAR_MAPPER (expm1, octave::math::expm1);
       SCALAR_MAPPER (fix, octave::math::fix);
-      SCALAR_MAPPER (floor, gnulib::floorf);
+      SCALAR_MAPPER (floor, std::floor);
       SCALAR_MAPPER (log, octave::math::rc_log);
       SCALAR_MAPPER (log2, octave::math::rc_log2);
       SCALAR_MAPPER (log10, octave::math::rc_log10);
       SCALAR_MAPPER (log1p, octave::math::rc_log1p);
       SCALAR_MAPPER (round, octave::math::round);
       SCALAR_MAPPER (roundb, octave::math::roundb);
       SCALAR_MAPPER (signum, octave::math::signum);
       SCALAR_MAPPER (sin, ::sinf);
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -339,17 +339,17 @@ octave_scalar::map (unary_mapper_t umap)
       SCALAR_MAPPER (lgamma, octave::math::rc_lgamma);
       SCALAR_MAPPER (cbrt, octave::math::cbrt);
       SCALAR_MAPPER (ceil, ::ceil);
       SCALAR_MAPPER (cos, ::cos);
       SCALAR_MAPPER (cosh, ::cosh);
       SCALAR_MAPPER (exp, ::exp);
       SCALAR_MAPPER (expm1, octave::math::expm1);
       SCALAR_MAPPER (fix, octave::math::fix);
-      SCALAR_MAPPER (floor, gnulib::floor);
+      SCALAR_MAPPER (floor, std::floor);
       SCALAR_MAPPER (log, octave::math::rc_log);
       SCALAR_MAPPER (log2, octave::math::rc_log2);
       SCALAR_MAPPER (log10, octave::math::rc_log10);
       SCALAR_MAPPER (log1p, octave::math::rc_log1p);
       SCALAR_MAPPER (round, octave::math::round);
       SCALAR_MAPPER (roundb, octave::math::roundb);
       SCALAR_MAPPER (signum, octave::math::signum);
       SCALAR_MAPPER (sin, ::sin);
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -126,26 +126,16 @@ object) relevant global values before an
 
 #if defined (OCTAVE_STYPE_IS_DECLARED) && ! defined YYSTYPE
 #  define YYSTYPE OCTAVE_STYPE
 #endif
 
 #define YY_NO_UNISTD_H 1
 #define isatty octave_isatty_wrapper
 
-#if defined (GNULIB_NAMESPACE)
-// Calls to the following functions appear in the generated output from
-// flex without the namespace tag.  Redefine them so we will use them
-// via the gnulib namespace.
-#  define fprintf GNULIB_NAMESPACE::fprintf
-#  define fwrite GNULIB_NAMESPACE::fwrite
-#  define malloc GNULIB_NAMESPACE::malloc
-#  define realloc GNULIB_NAMESPACE::realloc
-#endif
-
 #if ! (defined (FLEX_SCANNER) \
        && defined (YY_FLEX_MAJOR_VERSION) && YY_FLEX_MAJOR_VERSION >= 2 \
        && defined (YY_FLEX_MINOR_VERSION) && YY_FLEX_MINOR_VERSION >= 5)
 #error lex.l requires flex version 2.5.4 or later
 #endif
 
 #define YY_EXTRA_TYPE octave_base_lexer *
 #define curr_lexer yyextra
@@ -1801,29 +1791,29 @@ ANY_INCLUDING_NL (.|{NL})
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 // Restore prevailing warning state for remainder of the file.
 #pragma GCC diagnostic pop
 #endif
 
 void *
 octave_alloc (yy_size_t size, yyscan_t)
 {
-  return malloc (size);
+  return std::malloc (size);
 }
 
 void *
 octave_realloc (void *ptr, yy_size_t size, yyscan_t)
 {
-  return realloc (ptr, size);
+  return std::realloc (ptr, size);
 }
 
 void
 octave_free (void *ptr, yyscan_t)
 {
-  free (ptr);
+  std::free (ptr);
 }
 
 static void
 display_character (char c)
 {
   if (isgraph (c))
     std::cerr << c;
   else
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -84,25 +84,16 @@ along with Octave; see the file COPYING.
 #include <oct-parse.h>
 
 extern int octave_lex (YYSTYPE *, void *);
 
 // Global access to currently active lexer.
 // FIXME: to be removed after more parser+lexer refactoring.
 octave_base_lexer *LEXER = 0;
 
-#if defined (GNULIB_NAMESPACE)
-// Calls to the following functions appear in the generated output from
-// Bison without the namespace tag.  Redefine them so we will use them
-// via the gnulib namespace.
-#  define fclose GNULIB_NAMESPACE::fclose
-#  define fprintf GNULIB_NAMESPACE::fprintf
-#  define malloc GNULIB_NAMESPACE::malloc
-#endif
-
 // TRUE means we printed messages about reading startup files.
 bool reading_startup_message_printed = false;
 
 // List of autoloads (function -> file mapping).
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
@@ -4156,17 +4147,17 @@ parse_fcn_file (const std::string& full_
   frame.add_fcn (octave::command_history::ignore_entries,
                  octave::command_history::ignoring_entries ());
 
   octave::command_history::ignore_entries ();
 
   FILE *ffile = 0;
 
   if (! full_file.empty ())
-    ffile = gnulib::fopen (full_file.c_str (), "rb");
+    ffile = std::fopen (full_file.c_str (), "rb");
 
   if (ffile)
     {
       frame.add_fcn (safe_fclose, ffile);
 
       // octave_base_parser constructor sets this for us.
       frame.protect_var (LEXER);
 
diff --git a/liboctave/array/Range.cc b/liboctave/array/Range.cc
--- a/liboctave/array/Range.cc
+++ b/liboctave/array/Range.cc
@@ -482,21 +482,21 @@ tfloor (double x, double ct)
 
   double q = 1.0;
 
   if (x < 0.0)
     q = 1.0 - ct;
 
   double rmax = q / (2.0 - ct);
 
-  double t1 = 1.0 + gnulib::floor (x);
+  double t1 = 1.0 + std::floor (x);
   t1 = (ct / q) * (t1 < 0.0 ? -t1 : t1);
   t1 = rmax < t1 ? rmax : t1;
   t1 = ct > t1 ? ct : t1;
-  t1 = gnulib::floor (x + t1);
+  t1 = std::floor (x + t1);
 
   if (x <= 0.0 || (t1 - x) < rmax)
     return t1;
   else
     return t1 - 1.0;
 }
 
 static inline double
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -144,17 +144,17 @@ idx_vector::idx_range_rep::idx_range_rep
           if (step < 0 && start + (len - 1)*step < 0)
             err_invalid_index (start + (len - 1)*step);
         }
       else
         {
           // find first non-integer, then gripe about it
           double b = r.base ();
           double inc = r.inc ();
-          err_invalid_index (b != gnulib::floor (b) ? b : b + inc);
+          err_invalid_index (b != std::floor (b) ? b : b + inc);
         }
     }
 }
 
 octave_idx_type
 idx_vector::idx_range_rep::checkelem (octave_idx_type i) const
 {
   if (i < 0 || i >= len)
diff --git a/liboctave/cruft/Faddeeva/Faddeeva.cc b/liboctave/cruft/Faddeeva/Faddeeva.cc
--- a/liboctave/cruft/Faddeeva/Faddeeva.cc
+++ b/liboctave/cruft/Faddeeva/Faddeeva.cc
@@ -195,34 +195,21 @@ static inline bool my_isinf(double x) { 
 // g++ gets confused between the C and C++ isnan/isinf functions
 #    define isnan std::isnan
 #    define isinf std::isinf
 #  endif
 
 // copysign was introduced in C++11 (and is also in POSIX and C99)
 #  if defined(_WIN32) || defined(__WIN32__)
 #    define copysign _copysign // of course MS had to be different
-#  elif defined(GNULIB_NAMESPACE) // we are using using gnulib <cmath>
-#    define copysign GNULIB_NAMESPACE::copysign
 #  elif (__cplusplus < 201103L) && !defined(HAVE_COPYSIGN) && !defined(__linux__) && !(defined(__APPLE__) && defined(__MACH__)) && !defined(_AIX)
 static inline double my_copysign(double x, double y) { return y<0 ? -x : x; }
 #    define copysign my_copysign
 #  endif
 
-// If we are using the gnulib <cmath> (e.g., in the GNU Octave sources),
-// gnulib generates a link warning if we use ::floor instead of gnulib::floor.
-// This warning is completely innocuous because the only difference between
-// gnulib::floor and the system ::floor (and only on ancient OSF systems)
-// has to do with floor(-0), which doesn't occur in the usage below, but
-// the Octave developers prefer that we silence the warning.
-#  if defined (GNULIB_NAMESPACE)
-#    define floor GNULIB_NAMESPACE::floor
-#    define log GNULIB_NAMESPACE::log
-#  endif
-
 #else // !__cplusplus, i.e., pure C (requires C99 features)
 
 #  include "Faddeeva.h"
 
 #  define _GNU_SOURCE // enable GNU libc NAN extension if possible
 
 #  include <float.h>
 #  include <math.h>
diff --git a/liboctave/module.mk b/liboctave/module.mk
--- a/liboctave/module.mk
+++ b/liboctave/module.mk
@@ -11,17 +11,16 @@ liboctave_liboctave_la_CPPFLAGS = \
   @CRUFT_DLL_DEFS@ \
   -Iliboctave -I$(srcdir)/liboctave \
   -I$(srcdir)/liboctave/array \
   -I$(srcdir)/liboctave/cruft/misc \
   -Iliboctave/numeric -I$(srcdir)/liboctave/numeric \
   -Iliboctave/operators -I$(srcdir)/liboctave/operators \
   -I$(srcdir)/liboctave/system \
   -I$(srcdir)/liboctave/util \
-  -Ilibgnu -I$(srcdir)/libgnu \
   -I$(srcdir)/liboctave/wrappers
 
 liboctave_liboctave_la_CFLAGS = $(AM_CFLAGS) $(WARN_CFLAGS)
 
 liboctave_liboctave_la_CXXFLAGS = $(AM_CXXFLAGS) $(WARN_CXXFLAGS)
 
 octlib_LTLIBRARIES += liboctave/liboctave.la
 
diff --git a/liboctave/numeric/lo-mappers.cc b/liboctave/numeric/lo-mappers.cc
--- a/liboctave/numeric/lo-mappers.cc
+++ b/liboctave/numeric/lo-mappers.cc
@@ -32,18 +32,23 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "lo-math.h"
 #include "lo-specfun.h"
 #include "lo-utils.h"
 #include "oct-cmplx.h"
 
 #include "f77-fcn.h"
 
-// Functions that forward to gnulib belong here so we can keep gnulib:: out of
-// lo-mappers.h.
+// FIXME: We used to have this situation:
+//
+//   Functions that forward to gnulib belong here so we can keep
+//   gnulib:: out of lo-mappers.h.
+//
+// but now we just use std:: and explicit wrappers in C++ code so maybe
+// some of the forwarding functions can be defined inline here.
 
 namespace octave
 {
   namespace math
   {
     bool
     is_NA (double x)
     {
@@ -175,26 +180,26 @@ namespace octave
     FloatComplex
     atan (const FloatComplex& x)
     {
       static FloatComplex i (0, 1);
 
       return i * log ((i + x) / (i - x)) / 2.0f;
     }
 
-    double log2 (double x) { return gnulib::log2 (x); }
-    float log2 (float x) { return gnulib::log2f (x); }
+    double log2 (double x) { return std::log2 (x); }
+    float log2 (float x) { return std::log2 (x); }
 
     Complex
     log2 (const Complex& x)
     {
 #if defined (M_LN2)
       static double ln2 = M_LN2;
 #else
-      static double ln2 = gnulib::log (2.0);
+      static double ln2 = std::log (2.0);
 #endif
       return std::log (x) / ln2;
     }
 
     FloatComplex
     log2 (const FloatComplex& x)
     {
 #if defined (M_LN2)
@@ -203,23 +208,23 @@ namespace octave
       static float ln2 = log (2.0f);
 #endif
       return std::log (x) / ln2;
     }
 
     double
     log2 (double x, int& exp)
     {
-      return gnulib::frexp (x, &exp);
+      return std::frexp (x, &exp);
     }
 
     float
     log2 (float x, int& exp)
     {
-      return gnulib::frexpf (x, &exp);
+      return std::frexp (x, &exp);
     }
 
     Complex
     log2 (const Complex& x, int& exp)
     {
       double ax = std::abs (x);
       double lax = log2 (ax, exp);
       return (ax != lax) ? (x / ax) * lax : x;
@@ -237,17 +242,17 @@ namespace octave
     exp2 (double x)
     {
 #if defined (HAVE_EXP2)
       return ::exp2 (x);
 #else
 #  if defined (M_LN2)
       static double ln2 = M_LN2;
 #  else
-      static double ln2 = gnulib::log (2.0);
+      static double ln2 = std::log (2.0);
 #  endif
       return exp (x * ln2);
 #endif
     }
 
     float
     exp2 (float x)
     {
@@ -260,33 +265,33 @@ namespace octave
       static float ln2 = M_LN2;
 #  else
       static float ln2 = log2 (2.0f);
 #  endif
       return exp (x * ln2);
 #endif
     }
 
-    double copysign (double x, double y) { return gnulib::copysign (x, y); }
-    float copysign (float x, float y) { return gnulib::copysignf (x, y); }
+    double copysign (double x, double y) { return std::copysign (x, y); }
+    float copysign (float x, float y) { return std::copysign (x, y); }
 
-    double signbit (double x) { return ::signbit (x); }
-    float signbit (float x) { return ::signbit (x); }
+    double signbit (double x) { return std::signbit (x); }
+    float signbit (float x) { return std::signbit (x); }
 
     bool negative_sign (double x) { return __lo_ieee_signbit (x); }
     bool negative_sign (float x) { return __lo_ieee_float_signbit (x); }
 
-    double trunc (double x) { return gnulib::trunc (x); }
-    float trunc (float x) { return gnulib::truncf (x); }
+    double trunc (double x) { return std::trunc (x); }
+    float trunc (float x) { return std::trunc (x); }
 
-    double floor (double x) { return gnulib::floor (x); }
-    float floor (float x) { return gnulib::floor (x); }
+    double floor (double x) { return std::floor (x); }
+    float floor (float x) { return std::floor (x); }
 
-    double round (double x) { return gnulib::round (x); }
-    float round (float x) { return gnulib::roundf (x); }
+    double round (double x) { return std::round (x); }
+    float round (float x) { return std::round (x); }
 
     bool
     isnan (double x)
     {
 #if defined (HAVE_CMATH_ISNAN)
       return std::isnan (x);
 #else
       return lo_ieee_isnan (x);
@@ -436,24 +441,24 @@ namespace octave
     {
       return fabsf (x) > 1.0f ? atanh (FloatComplex (x)) : FloatComplex (atanh (x));
     }
 
     Complex
     rc_log (double x)
     {
       const double pi = 3.14159265358979323846;
-      return x < 0.0 ? Complex (gnulib::log (-x), pi) : Complex (gnulib::log (x));
+      return x < 0.0 ? Complex (std::log (-x), pi) : Complex (std::log (x));
     }
 
     FloatComplex
     rc_log (float x)
     {
       const float pi = 3.14159265358979323846f;
-      return x < 0.0f ? FloatComplex (gnulib::logf (-x), pi) : FloatComplex (gnulib::logf (x));
+      return x < 0.0f ? FloatComplex (std::log (-x), pi) : FloatComplex (std::log (x));
     }
 
     Complex
     rc_log2 (double x)
     {
       const double pil2 = 4.53236014182719380962; // = pi / log(2)
       return x < 0.0 ? Complex (log2 (-x), pil2) : Complex (log2 (x));
     }
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -719,17 +719,17 @@ namespace octave
           // approximation log (1+x) ~ 2*sum ((x/(2+x)).^ii ./ ii), ii = 1:2:2n+1
           double u = x / (2 + x), t = 1, s = 0;
           for (int i = 2; i < 12; i += 2)
             s += (t *= u*u) / (i+1);
 
           retval = 2 * (s + 1) * u;
         }
       else
-        retval = gnulib::log (1 + x);
+        retval = std::log (1 + x);
 
       return retval;
 #endif
     }
 
     Complex
     log1p (const Complex& x)
     {
@@ -790,17 +790,17 @@ namespace octave
           // approximation log (1+x) ~ 2*sum ((x/(2+x)).^ii ./ ii), ii = 1:2:2n+1
           float u = x / (2 + x), t = 1.0f, s = 0;
           for (int i = 2; i < 12; i += 2)
             s += (t *= u*u) / (i+1);
 
           retval = 2 * (s + 1.0f) * u;
         }
       else
-        retval = gnulib::logf (1.0f + x);
+        retval = std::log (1.0f + x);
 
       return retval;
 #endif
     }
 
     FloatComplex
     log1p (const FloatComplex& x)
     {
@@ -2984,25 +2984,25 @@ namespace octave
       return retval;
     }
 
 
     Complex rc_log1p (double x)
     {
       const double pi = 3.14159265358979323846;
       return (x < -1.0
-              ? Complex (gnulib::log (-(1.0 + x)), pi)
+              ? Complex (std::log (-(1.0 + x)), pi)
               : Complex (log1p (x)));
     }
 
     FloatComplex rc_log1p (float x)
     {
       const float pi = 3.14159265358979323846f;
       return (x < -1.0f
-              ? FloatComplex (gnulib::logf (-(1.0f + x)), pi)
+              ? FloatComplex (std::log (-(1.0f + x)), pi)
               : FloatComplex (log1p (x)));
     }
 
     // This algorithm is due to P. J. Acklam.
     //
     // See http://home.online.no/~pjacklam/notes/invnorm/
     //
     // The rational approximation has relative accuracy 1.15e-9 in the whole
@@ -3048,17 +3048,17 @@ namespace octave
           const double q = 0.5 * x, r = q*q;
           const double yn = (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5])*q;
           const double yd = ((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1.0;
           y = yn / yd;
         }
       else if (ax < 1.0)
         {
           // Tail region.
-          const double q = sqrt (-2*gnulib::log (0.5*(1-ax)));
+          const double q = sqrt (-2*std::log (0.5*(1-ax)));
           const double yn = ((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5];
           const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
           y = yn / yd * octave::math::signum (-x);
         }
       else if (ax == 1.0)
         return octave::numeric_limits<double>::Inf () * octave::math::signum (x);
       else
         return octave::numeric_limits<double>::NaN ();
@@ -3128,18 +3128,18 @@ namespace octave
           const double yn = (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5])*q;
           const double yd = ((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1.0;
           y = yn / yd;
         }
       else if (x > 0.0 && x < 2.0)
         {
           // Tail region.
           const double q = (x < 1
-                            ? sqrt (-2*gnulib::log (0.5*x))
-                            : sqrt (-2*gnulib::log (0.5*(2-x))));
+                            ? sqrt (-2*std::log (0.5*x))
+                            : sqrt (-2*std::log (0.5*(2-x))));
 
           const double yn = ((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5];
 
           const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
 
           y = yn / yd;
 
           if (x < pbreak_lo)
@@ -3252,18 +3252,18 @@ namespace octave
       for ( ; ; )
         {
           term *= temp * rx / (pp + ai);
           value += term;
           temp = fabs (term);
 
           if (temp <= acu && temp <= acu * value)
             {
-              value *= exp (pp * gnulib::log (xx)
-                            + (qq - 1.0) * gnulib::log (cx) - beta) / pp;
+              value *= exp (pp * std::log (xx)
+                            + (qq - 1.0) * std::log (cx) - beta) / pp;
 
               if (indx)
                 {
                   value = 1.0 - value;
                 }
               break;
             }
 
@@ -3342,17 +3342,17 @@ namespace octave
           a = y;
           pp = p;
           qq = q;
           indx = false;
         }
 
       //  Calculate the initial approximation.
 
-      r = sqrt (- gnulib::log (a * a));
+      r = sqrt (- std::log (a * a));
 
       ycur = r - (2.30753 + 0.27061 * r) / (1.0 + (0.99229 + 0.04481 * r) * r);
 
       if (1.0 < pp && 1.0 < qq)
         {
           r = (ycur * ycur - 3.0) / 6.0;
           s = 1.0 / (pp + pp - 1.0);
           t = 1.0 / (qq + qq - 1.0);
@@ -3363,25 +3363,25 @@ namespace octave
       else
         {
           r = qq + qq;
           t = 1.0 / (9.0 * qq);
           t = r * pow (1.0 - t + ycur * sqrt (t), 3);
 
           if (t <= 0.0)
             {
-              value = 1.0 - exp ((gnulib::log ((1.0 - a) * qq) + beta) / qq);
+              value = 1.0 - exp ((std::log ((1.0 - a) * qq) + beta) / qq);
             }
           else
             {
               t = (4.0 * pp + r - 2.0) / t;
 
               if (t <= 1.0)
                 {
-                  value = exp ((gnulib::log (a * pp) + beta) / pp);
+                  value = exp ((std::log (a * pp) + beta) / pp);
                 }
               else
                 {
                   value = 1.0 - 2.0 / (t + 1.0);
                 }
             }
         }
 
@@ -3413,18 +3413,18 @@ namespace octave
           ycur = betain (value, pp, qq, beta, err);
 
           if (err)
             {
               return value;
             }
 
           xin = value;
-          ycur = (ycur - a) * exp (beta + r * gnulib::log (xin)
-                                   + t * gnulib::log (1.0 - xin));
+          ycur = (ycur - a) * exp (beta + r * std::log (xin)
+                                   + t * std::log (1.0 - xin));
 
           if (ycur * yprev <= 0.0)
             {
               prev = std::max (sq, fpu);
             }
 
           g = 1.0;
 
@@ -3730,24 +3730,24 @@ namespace octave
     {
       return log (x);
     }
 
     template <>
     inline double
     xlog (const double& x)
     {
-      return gnulib::log (x);
+      return std::log (x);
     }
 
     template <>
     inline float
     xlog (const float& x)
     {
-      return gnulib::logf (x);
+      return std::log (x);
     }
 
     template <typename T>
     static T
     lanczos_approximation_psi (const T zc)
     {
       // Coefficients for C.Lanczos expansion of psi function from XLiFE++
       // gammaFunctions psi_coef[k] = - (2k+1) * lg_coef[k] (see melina++
@@ -3797,17 +3797,17 @@ namespace octave
             p += 1.0 / k;
         }
       else if (octave::math::floor (z + 0.5) == z + 0.5)
         {
           // Abramowitz and Stegun, page 258, eq 6.3.3 and 6.3.4
           for (octave_idx_type k = z; k > 0; k--)
             p += 1.0 / (2 * k - 1);
 
-          p = - euler_mascheroni - 2 * gnulib::log (2) + 2 * (p);
+          p = - euler_mascheroni - 2 * std::log (2) + 2 * (p);
         }
       else
         {
           // adapted from XLiFE++ gammaFunctions
 
           T zc = z;
           // Use formula for derivative of LogGamma(z)
           if (z < 10)
diff --git a/liboctave/numeric/randgamma.cc b/liboctave/numeric/randgamma.cc
--- a/liboctave/numeric/randgamma.cc
+++ b/liboctave/numeric/randgamma.cc
@@ -113,17 +113,17 @@ oct_fill_randg (double a, octave_idx_typ
     restart:
       x = RNOR;
       v = (1+c*x);
       v *= v*v;
       if (v <= 0)
         goto restart; /* rare, so don't bother moving up */
       u = RUNI;
       xsq = x*x;
-      if (u >= 1.-0.0331*xsq*xsq && gnulib::log (u) >= 0.5*xsq + d*(1-v+gnulib::log (v)))
+      if (u >= 1.-0.0331*xsq*xsq && std::log (u) >= 0.5*xsq + d*(1-v+std::log (v)))
         goto restart;
       r[i] = d*v;
     }
   if (a < 1)
     {
       /* Use gamma(a) = gamma(1+a)*U^(1/a) */
       /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
       for (i = 0; i < n; i++)
@@ -168,17 +168,17 @@ oct_fill_float_randg (float a, octave_id
     frestart:
       x = RNOR;
       v = (1+c*x);
       v *= v*v;
       if (v <= 0)
         goto frestart; /* rare, so don't bother moving up */
       u = RUNI;
       xsq = x*x;
-      if (u >= 1.-0.0331*xsq*xsq && gnulib::log (u) >= 0.5*xsq + d*(1-v+gnulib::log (v)))
+      if (u >= 1.-0.0331*xsq*xsq && std::log (u) >= 0.5*xsq + d*(1-v+std::log (v)))
         goto frestart;
       r[i] = d*v;
     }
   if (a < 1)
     {
       /* Use gamma(a) = gamma(1+a)*U^(1/a) */
       /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
       for (i = 0; i < n; i++)
diff --git a/liboctave/numeric/randmtzig.cc b/liboctave/numeric/randmtzig.cc
--- a/liboctave/numeric/randmtzig.cc
+++ b/liboctave/numeric/randmtzig.cc
@@ -252,27 +252,27 @@ oct_init_by_array (uint32_t *init_key, i
 
 void
 oct_init_by_entropy (void)
 {
   uint32_t entropy[MT_N];
   int n = 0;
 
   /* Look for entropy in /dev/urandom */
-  FILE* urandom = gnulib::fopen ("/dev/urandom", "rb");
+  FILE* urandom = std::fopen ("/dev/urandom", "rb");
   if (urandom)
     {
       while (n < MT_N)
         {
           unsigned char word[4];
-          if (gnulib::fread (word, 4, 1, urandom) != 1)
+          if (std::fread (word, 4, 1, urandom) != 1)
             break;
           entropy[n++] = word[0]+(word[1]<<8)+(word[2]<<16)+(static_cast<uint32_t>(word[3])<<24);
         }
-      gnulib::fclose (urandom);
+      std::fclose (urandom);
     }
 
   /* If there isn't enough entropy, gather some from various sources */
 
   octave::sys::time now;
 
   if (n < MT_N)
     entropy[n++] = now.unix_time (); /* Current time in seconds */
@@ -498,17 +498,17 @@ create_ziggurat_tables (void)
   wi[0] = NOR_SECTION_AREA / fi[255] / NMANTISSA;
   fi[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
        * need inverse operator of y = exp(-0.5*x*x) -> x = sqrt(-2*ln(y))
        */
-      x = sqrt (-2. * gnulib::log (NOR_SECTION_AREA / x1 + fi[i+1]));
+      x = sqrt (-2. * std::log (NOR_SECTION_AREA / x1 + fi[i+1]));
       ki[i+1] = static_cast<ZIGINT> (x / x1 * NMANTISSA);
       wi[i] = x / NMANTISSA;
       fi[i] = exp (-0.5 * x * x);
       x1 = x;
     }
 
   ki[1] = 0;
 
@@ -526,17 +526,17 @@ create_ziggurat_tables (void)
   we[0] = EXP_SECTION_AREA / fe[255] / EMANTISSA;
   fe[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
        * need inverse operator of y = exp(-x) -> x = -ln(y)
        */
-      x = - gnulib::log (EXP_SECTION_AREA / x1 + fe[i+1]);
+      x = - std::log (EXP_SECTION_AREA / x1 + fe[i+1]);
       ke[i+1] = static_cast<ZIGINT> (x / x1 * EMANTISSA);
       we[i] = x / EMANTISSA;
       fe[i] = exp (-x);
       x1 = x;
     }
   ke[1] = 0;
 
   initt = 0;
@@ -606,18 +606,18 @@ oct_randn (void)
            * tail!!!! Any thing random might be used to determine the
            * sign, but as we already have r we might as well use it
            *
            * [PAK] but not the bottom 8 bits, since they are all 0 here!
            */
           double xx, yy;
           do
             {
-              xx = - ZIGGURAT_NOR_INV_R * gnulib::log (RANDU);
-              yy = - gnulib::log (RANDU);
+              xx = - ZIGGURAT_NOR_INV_R * std::log (RANDU);
+              yy = - std::log (RANDU);
             }
           while ( yy+yy <= xx*xx);
           return ((rabs & 0x100) ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
         }
       else if ((fi[idx-1] - fi[idx]) * RANDU + fi[idx] < exp (-0.5*x*x))
         return x;
     }
 }
@@ -637,17 +637,17 @@ oct_rande (void)
         return x;               /* 98.9% of the time we return here 1st try */
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
            *
            * For the exponential tail, the method of Marsaglia[5] provides:
            * x = r - ln(U);
            */
-          return ZIGGURAT_EXP_R - gnulib::log (RANDU);
+          return ZIGGURAT_EXP_R - std::log (RANDU);
         }
       else if ((fe[idx-1] - fe[idx]) * RANDU + fe[idx] < exp (-x))
         return x;
     }
 }
 
 #undef ZIGINT
 #undef EMANTISSA
@@ -689,17 +689,17 @@ create_ziggurat_float_tables (void)
   fwi[0] = NOR_SECTION_AREA / ffi[255] / NMANTISSA;
   ffi[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
        * need inverse operator of y = exp(-0.5*x*x) -> x = sqrt(-2*ln(y))
        */
-      x = sqrt (-2. * gnulib::log (NOR_SECTION_AREA / x1 + ffi[i+1]));
+      x = sqrt (-2. * std::log (NOR_SECTION_AREA / x1 + ffi[i+1]));
       fki[i+1] = static_cast<ZIGINT> (x / x1 * NMANTISSA);
       fwi[i] = x / NMANTISSA;
       ffi[i] = exp (-0.5 * x * x);
       x1 = x;
     }
 
   fki[1] = 0;
 
@@ -717,17 +717,17 @@ create_ziggurat_float_tables (void)
   fwe[0] = EXP_SECTION_AREA / ffe[255] / EMANTISSA;
   ffe[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
        * need inverse operator of y = exp(-x) -> x = -ln(y)
        */
-      x = - gnulib::log (EXP_SECTION_AREA / x1 + ffe[i+1]);
+      x = - std::log (EXP_SECTION_AREA / x1 + ffe[i+1]);
       fke[i+1] = static_cast<ZIGINT> (x / x1 * EMANTISSA);
       fwe[i] = x / EMANTISSA;
       ffe[i] = exp (-x);
       x1 = x;
     }
   fke[1] = 0;
 
   inittf = 0;
@@ -773,18 +773,18 @@ oct_float_randn (void)
            * tail!!!! Any thing random might be used to determine the
            * sign, but as we already have r we might as well use it
            *
            * [PAK] but not the bottom 8 bits, since they are all 0 here!
            */
           float xx, yy;
           do
             {
-              xx = - ZIGGURAT_NOR_INV_R * gnulib::log (RANDU);
-              yy = - gnulib::log (RANDU);
+              xx = - ZIGGURAT_NOR_INV_R * std::log (RANDU);
+              yy = - std::log (RANDU);
             }
           while ( yy+yy <= xx*xx);
           return ((rabs & 0x100) ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
         }
       else if ((ffi[idx-1] - ffi[idx]) * RANDU + ffi[idx] < exp (-0.5*x*x))
         return x;
     }
 }
@@ -804,17 +804,17 @@ oct_float_rande (void)
         return x;               /* 98.9% of the time we return here 1st try */
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
            *
            * For the exponential tail, the method of Marsaglia[5] provides:
            * x = r - ln(U);
            */
-          return ZIGGURAT_EXP_R - gnulib::log (RANDU);
+          return ZIGGURAT_EXP_R - std::log (RANDU);
         }
       else if ((ffe[idx-1] - ffe[idx]) * RANDU + ffe[idx] < exp (-x))
         return x;
     }
 }
 
 /* Array generators */
 void
diff --git a/liboctave/numeric/randpoisson.cc b/liboctave/numeric/randpoisson.cc
--- a/liboctave/numeric/randpoisson.cc
+++ b/liboctave/numeric/randpoisson.cc
@@ -97,17 +97,17 @@ flogfak (double k)
   };
 
   double r, rr;
 
   if (k >= 30.0)
     {
       r  = 1.0 / k;
       rr = r * r;
-      return ((k + 0.5)*gnulib::log (k) - k + C0 + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
+      return ((k + 0.5)*std::log (k) - k + C0 + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
     }
   else
     return (logfak[static_cast<int> (k)]);
 }
 
 
 /******************************************************************
  *                                                                *
@@ -159,38 +159,38 @@ pprsc (double my)
   if (my != my_last)
     {                               /* set-up           */
       my_last = my;
       /* approximate deviation of reflection points k2, k4 from my - 1/2 */
       Ds = sqrt (my + 0.25);
 
       /* mode m, reflection points k2 and k4, and points k1 and k5,      */
       /* which delimit the centre region of h(x)                         */
-      m  = gnulib::floor (my);
+      m  = std::floor (my);
       k2 = ceil (my - 0.5 - Ds);
-      k4 = gnulib::floor (my - 0.5 + Ds);
+      k4 = std::floor (my - 0.5 + Ds);
       k1 = k2 + k2 - m + 1L;
       k5 = k4 + k4 - m;
 
       /* range width of the critical left and right centre region        */
       dl = (k2 - k1);
       dr = (k5 - k4);
 
       /* recurrence constants r(k)=p(k)/p(k-1) at k = k1, k2, k4+1, k5+1 */
       r1 = my / k1;
       r2 = my / k2;
       r4 = my / (k4 + 1.0);
       r5 = my / (k5 + 1.0);
 
       /* reciprocal values of the scale parameters of exp. tail envelope */
-      ll =  gnulib::log (r1);                        /* expon. tail left */
-      lr = -gnulib::log (r5);                        /* expon. tail right*/
+      ll =  std::log (r1);                        /* expon. tail left */
+      lr = -std::log (r5);                        /* expon. tail right*/
 
       /* Poisson constants, necessary for computing function values f(k) */
-      l_my = gnulib::log (my);
+      l_my = std::log (my);
       c_pm = m * l_my - flogfak (m);
 
       /* function values f(k) = p(k)/p(m) at k = k2, k4, k1, k5          */
       f2 = f (k2, l_my, c_pm);
       f4 = f (k4, l_my, c_pm);
       f1 = f (k1, l_my, c_pm);
       f5 = f (k5, l_my, c_pm);
 
@@ -208,24 +208,24 @@ pprsc (double my)
     {
       /* generate uniform number U -- U(0, p6)                           */
       /* case distinction corresponding to U                             */
       if ((U = RUNI * p6) < p2)
         {                                            /* centre left      */
 
           /* immediate acceptance region
              R2 = [k2, m) *[0, f2),  X = k2, ... m -1 */
-          if ((V = U - p1) < 0.0)  return (k2 + gnulib::floor (U/f2));
+          if ((V = U - p1) < 0.0)  return (k2 + std::floor (U/f2));
           /* immediate acceptance region
              R1 = [k1, k2)*[0, f1),  X = k1, ... k2-1 */
-          if ((W = V / dl) < f1 )  return (k1 + gnulib::floor (V/f1));
+          if ((W = V / dl) < f1 )  return (k1 + std::floor (V/f1));
 
           /* computation of candidate X < k2, and its counterpart Y > k2 */
           /* either squeeze-acceptance of X or acceptance-rejection of Y */
-          Dk = gnulib::floor (dl * RUNI) + 1.0;
+          Dk = std::floor (dl * RUNI) + 1.0;
           if (W <= f2 - Dk * (f2 - f2/r2))
             {                                        /* quick accept of  */
               return (k2 - Dk);                      /* X = k2 - Dk      */
             }
           if ((V = f2 + f2 - W) < 1.0)
             {                                        /* quick reject of Y*/
               Y = k2 + Dk;
               if (V <= f2 + Dk * (1.0 - f2)/(dl + 1.0))
@@ -235,24 +235,24 @@ pprsc (double my)
               if (V <= f (Y, l_my, c_pm))  return (Y); /* final accept of Y*/
             }
           X = k2 - Dk;
         }
       else if (U < p4)
         {                                            /* centre right     */
           /*  immediate acceptance region
               R3 = [m, k4+1)*[0, f4), X = m, ... k4    */
-          if ((V = U - p3) < 0.0)  return (k4 - gnulib::floor ((U - p2)/f4));
+          if ((V = U - p3) < 0.0)  return (k4 - std::floor ((U - p2)/f4));
           /* immediate acceptance region
              R4 = [k4+1, k5+1)*[0, f5)                */
-          if ((W = V / dr) < f5 )  return (k5 - gnulib::floor (V/f5));
+          if ((W = V / dr) < f5 )  return (k5 - std::floor (V/f5));
 
           /* computation of candidate X > k4, and its counterpart Y < k4 */
           /* either squeeze-acceptance of X or acceptance-rejection of Y */
-          Dk = gnulib::floor (dr * RUNI) + 1.0;
+          Dk = std::floor (dr * RUNI) + 1.0;
           if (W <= f4 - Dk * (f4 - f4*r4))
             {                                        /* quick accept of  */
               return (k4 + Dk);                      /* X = k4 + Dk      */
             }
           if ((V = f4 + f4 - W) < 1.0)
             {                                        /* quick reject of Y*/
               Y = k4 - Dk;
               if (V <= f4 + Dk * (1.0 - f4)/ dr)
@@ -263,36 +263,36 @@ pprsc (double my)
             }
           X = k4 + Dk;
         }
       else
         {
           W = RUNI;
           if (U < p5)
             {                                        /* expon. tail left */
-              Dk = gnulib::floor (1.0 - gnulib::log (W)/ll);
+              Dk = std::floor (1.0 - std::log (W)/ll);
               if ((X = k1 - Dk) < 0L)  continue;     /* 0 <= X <= k1 - 1 */
               W *= (U - p4) * ll;                    /* W -- U(0, h(x))  */
               if (W <= f1 - Dk * (f1 - f1/r1))
                 return (X);                          /* quick accept of X*/
             }
           else
             {                                        /* expon. tail right*/
-              Dk = gnulib::floor (1.0 - gnulib::log (W)/lr);
+              Dk = std::floor (1.0 - std::log (W)/lr);
               X  = k5 + Dk;                          /* X >= k5 + 1      */
               W *= (U - p5) * lr;                    /* W -- U(0, h(x))  */
               if (W <= f5 - Dk * (f5 - f5*r5))
                 return (X);                          /* quick accept of X*/
             }
         }
 
       /* acceptance-rejection test of candidate X from the original area */
       /* test, whether  W <= f(k),    with  W = U*h(x)  and  U -- U(0, 1)*/
       /* log f(X) = (X - m)*log(my) - log X! + log m!                    */
-      if (gnulib::log (W) <= X * l_my - flogfak (X) - c_pm)  return (X);
+      if (std::log (W) <= X * l_my - flogfak (X) - c_pm)  return (X);
     }
 }
 /* ---- pprsc.c end ------ */
 
 
 /* The remainder of the file is by Paul Kienzle */
 
 /* Given uniform u, find x such that CDF(L,x)==u.  Return x. */
@@ -308,17 +308,17 @@ poisson_cdf_lookup (double lambda, doubl
    * in the range [0,1], then for lambda==10 we need a table
    * size of 46 instead.  For long doubles, the table size
    * will need to be longer still.  */
 #define TABLESIZE 46
   double t[TABLESIZE];
 
   /* Precompute the table for the u up to and including 0.458.
    * We will almost certainly need it. */
-  int intlambda = static_cast<int> (gnulib::floor (lambda));
+  int intlambda = static_cast<int> (std::floor (lambda));
   double P;
   int tableidx;
   size_t i = n;
 
   t[0] = P = exp (-lambda);
   for (tableidx = 1; tableidx <= intlambda; tableidx++)
     {
       P = P*lambda/static_cast<double> (tableidx);
@@ -371,17 +371,17 @@ poisson_cdf_lookup (double lambda, doubl
 
 static void
 poisson_cdf_lookup_float (double lambda, float *p, size_t n)
 {
   double t[TABLESIZE];
 
   /* Precompute the table for the u up to and including 0.458.
    * We will almost certainly need it. */
-  int intlambda = static_cast<int> (gnulib::floor (lambda));
+  int intlambda = static_cast<int> (std::floor (lambda));
   double P;
   int tableidx;
   size_t i = n;
 
   t[0] = P = exp (-lambda);
   for (tableidx = 1; tableidx <= intlambda; tableidx++)
     {
       P = P*lambda/static_cast<double> (tableidx);
@@ -414,57 +414,57 @@ poisson_cdf_lookup_float (double lambda,
     }
 }
 
 /* From Press, et al., Numerical Recipes */
 static void
 poisson_rejection (double lambda, double *p, size_t n)
 {
   double sq = sqrt (2.0*lambda);
-  double alxm = gnulib::log (lambda);
+  double alxm = std::log (lambda);
   double g = lambda*alxm - LGAMMA(lambda+1.0);
   size_t i;
 
   for (i = 0; i < n; i++)
     {
       double y, em, t;
       do
         {
           do
             {
               y = tan (M_PI*RUNI);
               em = sq * y + lambda;
             } while (em < 0.0);
-          em = gnulib::floor (em);
+          em = std::floor (em);
           t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
         } while (RUNI > t);
       p[i] = em;
     }
 }
 
 /* From Press, et al., Numerical Recipes */
 static void
 poisson_rejection_float (double lambda, float *p, size_t n)
 {
   double sq = sqrt (2.0*lambda);
-  double alxm = gnulib::log (lambda);
+  double alxm = std::log (lambda);
   double g = lambda*alxm - LGAMMA(lambda+1.0);
   size_t i;
 
   for (i = 0; i < n; i++)
     {
       double y, em, t;
       do
         {
           do
             {
               y = tan (M_PI*RUNI);
               em = sq * y + lambda;
             } while (em < 0.0);
-          em = gnulib::floor (em);
+          em = std::floor (em);
           t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
         } while (RUNI > t);
       p[i] = em;
     }
 }
 
 /* The cutoff of L <= 1e8 in the following two functions before using
  * the normal approximation is based on:
@@ -495,17 +495,17 @@ oct_fill_randp (double L, octave_idx_typ
         p[i] = pprsc (L);
     }
   else
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
       const double sqrtL = sqrt (L);
       for (i = 0; i < n; i++)
         {
-          p[i] = gnulib::floor (RNOR*sqrtL + L + 0.5);
+          p[i] = std::floor (RNOR*sqrtL + L + 0.5);
           if (p[i] < 0.0)
             p[i] = 0.0; /* will probably never happen */
         }
     }
 }
 
 /* Generate one poisson variate */
 double
@@ -535,17 +535,17 @@ oct_randp (double L)
     {
       /* FIXME: R uses NaN, but the normal approximation suggests that
        * limit should be Inf.  Which is correct? */
       ret = octave::numeric_limits<double>::NaN ();
     }
   else
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-      ret = gnulib::floor (RNOR*sqrt (L) + L + 0.5);
+      ret = std::floor (RNOR*sqrt (L) + L + 0.5);
       if (ret < 0.0) ret = 0.0; /* will probably never happen */
     }
   return ret;
 }
 
 /* Generate a set of poisson numbers with the same distribution */
 void
 oct_fill_float_randp (float FL, octave_idx_type n, float *p)
@@ -567,17 +567,17 @@ oct_fill_float_randp (float FL, octave_i
         p[i] = pprsc (L);
     }
   else
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
       const double sqrtL = sqrt (L);
       for (i = 0; i < n; i++)
         {
-          p[i] = gnulib::floor (RNOR*sqrtL + L + 0.5);
+          p[i] = std::floor (RNOR*sqrtL + L + 0.5);
           if (p[i] < 0.0)
             p[i] = 0.0; /* will probably never happen */
         }
     }
 }
 
 /* Generate one poisson variate */
 float
@@ -608,13 +608,13 @@ oct_float_randp (float FL)
     {
       /* FIXME: R uses NaN, but the normal approximation suggests that
        * limit should be Inf. Which is correct? */
       ret = octave::numeric_limits<float>::NaN ();
     }
   else
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-      ret = gnulib::floor (RNOR*sqrt (L) + L + 0.5);
+      ret = std::floor (RNOR*sqrt (L) + L + 0.5);
       if (ret < 0.0) ret = 0.0; /* will probably never happen */
     }
   return ret;
 }
diff --git a/liboctave/system/dir-ops.cc b/liboctave/system/dir-ops.cc
--- a/liboctave/system/dir-ops.cc
+++ b/liboctave/system/dir-ops.cc
@@ -53,17 +53,17 @@ namespace octave
         {
           close ();
 
           std::string fullname = octave::sys::file_ops::tilde_expand (name);
 
           dir = octave_opendir_wrapper (fullname.c_str ());
 
           if (! dir)
-            errmsg = gnulib::strerror (errno);
+            errmsg = std::strerror (errno);
         }
       else
         errmsg = "dir_entry::open: empty filename";
 
       return dir != 0;
     }
 
     string_vector
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -409,17 +409,17 @@ namespace octave
     int
     mkdir (const std::string& name, mode_t mode, std::string& msg)
     {
       msg = "";
 
       int status = octave_mkdir_wrapper (name.c_str (), mode);
 
       if (status < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return status;
     }
 
     int
     mkfifo (const std::string& nm, mode_t md)
     {
       std::string msg;
@@ -429,17 +429,17 @@ namespace octave
     int
     mkfifo (const std::string& name, mode_t mode, std::string& msg)
     {
       msg = "";
 
       int status = octave_mkfifo_wrapper (name.c_str (), mode);
 
       if (status < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return status;
     }
 
     int
     link (const std::string& old_name, const std::string& new_name)
     {
       std::string msg;
@@ -452,17 +452,17 @@ namespace octave
     {
       msg = "";
 
       int status = -1;
 
       status = octave_link_wrapper (old_name.c_str (), new_name.c_str ());
 
       if (status < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return status;
     }
 
     int
     symlink (const std::string& old_name, const std::string& new_name)
     {
       std::string msg;
@@ -475,17 +475,17 @@ namespace octave
     {
       msg = "";
 
       int status = -1;
 
       status = octave_symlink_wrapper (old_name.c_str (), new_name.c_str ());
 
       if (status < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return status;
     }
 
     int
     readlink (const std::string& path, std::string& result)
     {
       std::string msg;
@@ -497,17 +497,17 @@ namespace octave
     {
       int status = -1;
 
       msg = "";
 
       char *buf = octave_areadlink_wrapper (path.c_str ());
 
       if (! buf)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
       else
         {
           result = buf;
           ::free (buf);
           status = 0;
         }
 
       return status;
@@ -522,20 +522,20 @@ namespace octave
 
     int
     rename (const std::string& from, const std::string& to, std::string& msg)
     {
       int status = -1;
 
       msg = "";
 
-      status = gnulib::rename (from.c_str (), to.c_str ());
+      status = std::rename (from.c_str (), to.c_str ());
 
       if (status < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return status;
     }
 
     int
     rmdir (const std::string& name)
     {
       std::string msg;
@@ -547,17 +547,17 @@ namespace octave
     {
       msg = "";
 
       int status = -1;
 
       status = octave_rmdir_wrapper (name.c_str ());
 
       if (status < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return status;
     }
 
     // And a version that works recursively.
 
     int
     recursive_rmdir (const std::string& name)
@@ -652,17 +652,17 @@ namespace octave
     {
       msg = "";
 
       int status = -1;
 
       status = octave_unlink_wrapper (name.c_str ());
 
       if (status < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return status;
     }
 
     std::string
     tempnam (const std::string& dir, const std::string& pfx)
     {
       std::string msg;
@@ -699,17 +699,17 @@ namespace octave
       templatename += "XXXXXX";
 
       // create and copy template to char array for call to gen_tempname
       char tname [templatename.length () + 1];
 
       strcpy (tname, templatename.c_str ());
 
       if (octave_gen_tempname_wrapper (tname) == -1)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
       else
         retval = tname;
 
       return retval;
     }
 
     std::string
     canonicalize_file_name (const std::string& name)
@@ -734,14 +734,14 @@ namespace octave
         }
 
 #if (defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM))
       // Canonical Windows file separator is backslash.
       std::replace (retval.begin (), retval.end (), '/', '\\');
 #endif
 
       if (retval.empty ())
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return retval;
     }
   }
 }
diff --git a/liboctave/system/file-stat.cc b/liboctave/system/file-stat.cc
--- a/liboctave/system/file-stat.cc
+++ b/liboctave/system/file-stat.cc
@@ -197,17 +197,17 @@ namespace octave
                : octave_lstat_wrapper (cname, &m_mode, &m_ino, &m_dev,
                                        &m_nlink, &m_uid, &m_gid, &m_size,
                                        &sys_atime, &sys_mtime, &sys_ctime,
                                        &m_rdev, &m_blksize, &m_blocks));
 
           if (status < 0)
             {
               fail = true;
-              errmsg = gnulib::strerror (errno);
+              errmsg = std::strerror (errno);
             }
           else
             {
               m_atime = octave::sys::time (sys_atime);
               m_mtime = octave::sys::time (sys_mtime);
               m_ctime = octave::sys::time (sys_ctime);
             }
 
@@ -229,17 +229,17 @@ namespace octave
             = octave_fstat_wrapper (fid, &m_mode, &m_ino, &m_dev,
                                     &m_nlink, &m_uid, &m_gid, &m_size,
                                     &sys_atime, &sys_mtime, &sys_ctime,
                                     &m_rdev, &m_blksize, &m_blocks);
 
           if (status < 0)
             {
               fail = true;
-              errmsg = gnulib::strerror (errno);
+              errmsg = std::strerror (errno);
             }
           else
             {
               m_atime = octave::sys::time (sys_atime);
               m_mtime = octave::sys::time (sys_mtime);
               m_ctime = octave::sys::time (sys_ctime);
             }
 
diff --git a/liboctave/system/oct-env.cc b/liboctave/system/oct-env.cc
--- a/liboctave/system/oct-env.cc
+++ b/liboctave/system/oct-env.cc
@@ -589,17 +589,17 @@ namespace octave
         }
 
       path.resize (i);
     }
 
     void
     env::error (int err_num) const
     {
-      (*current_liboctave_error_handler) ("%s", gnulib::strerror (err_num));
+      (*current_liboctave_error_handler) ("%s", std::strerror (err_num));
     }
 
     void
     env::error (const std::string& s) const
     {
       (*current_liboctave_error_handler) ("%s", s.c_str ());
     }
   }
diff --git a/liboctave/system/oct-syscalls.cc b/liboctave/system/oct-syscalls.cc
--- a/liboctave/system/oct-syscalls.cc
+++ b/liboctave/system/oct-syscalls.cc
@@ -57,17 +57,17 @@ namespace octave
     {
       msg = "";
 
       int status = -1;
 
       status = octave_dup2_wrapper (old_fd, new_fd);
 
       if (status < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return status;
     }
 
     int
     execvp (const std::string& file, const string_vector& argv)
     {
       std::string msg;
@@ -82,32 +82,32 @@ namespace octave
 
       char **argv = args.c_str_vec ();
 
       int status = octave_execvp_wrapper (file.c_str (), argv);
 
       string_vector::delete_c_str_vec (argv);
 
       if (status < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return status;
     }
 
     pid_t
     fork (std::string& msg)
     {
       pid_t status = -1;
 
       if (octave_have_fork ())
         {
           status = octave_fork_wrapper ();
 
           if (status < 0)
-            msg = gnulib::strerror (errno);
+            msg = std::strerror (errno);
         }
       else
         msg = NOT_SUPPORTED ("fork");
 
       return status;
     }
 
     pid_t
@@ -118,31 +118,31 @@ namespace octave
       if (octave_have_vfork () || octave_have_fork ())
         {
           if (octave_have_vfork ())
             status = octave_vfork_wrapper ();
           else
             status = octave_fork_wrapper ();
 
           if (status < 0)
-            msg = gnulib::strerror (errno);
+            msg = std::strerror (errno);
         }
       else
         msg = NOT_SUPPORTED ("vfork");
 
       return status;
     }
 
     pid_t
     getpgrp (std::string& msg)
     {
       pid_t status = octave_getpgrp_wrapper ();
 
       if (status < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return status;
     }
 
     pid_t
     getpid (void)
     {
       return octave_getpid_wrapper ();
@@ -190,17 +190,17 @@ namespace octave
     {
       msg = "";
 
       int status = -1;
 
       status = octave_pipe_wrapper (fildes);
 
       if (status < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return status;
     }
 
     pid_t
     waitpid (pid_t pid, int *status, int options)
     {
       std::string msg;
@@ -212,17 +212,17 @@ namespace octave
              std::string& msg)
     {
       pid_t retval = -1;
       msg = "";
 
       retval = octave_waitpid_wrapper (pid, status, options);
 
       if (retval < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return retval;
     }
 
     int
     wcontinue (void)
     {
       return octave_wcontinue_wrapper ();
@@ -302,17 +302,17 @@ namespace octave
 
       int status = -1;
 
       if (octave_have_kill ())
         {
           status = octave_kill_wrapper (pid, sig);
 
           if (status < 0)
-            msg = gnulib::strerror (errno);
+            msg = std::strerror (errno);
         }
       else
         msg = NOT_SUPPORTED ("kill");
 
       return status;
     }
 
     pid_t
@@ -347,17 +347,17 @@ namespace octave
 #else
       char **argv = args.c_str_vec ();
 
       pid_t pid = octave_popen2 (cmd.c_str (), argv, sync_mode, fildes);
 
       string_vector::delete_c_str_vec (argv);
 
       if (pid < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return pid;
 #endif
     }
 
     int
     fcntl (int fd, int cmd, long arg)
     {
@@ -370,14 +370,14 @@ namespace octave
     {
       msg = "";
 
       int status = -1;
 
       status = octave_fcntl_wrapper (fd, cmd, arg);
 
       if (status < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
 
       return status;
     }
   }
 }
diff --git a/liboctave/system/oct-time.cc b/liboctave/system/oct-time.cc
--- a/liboctave/system/oct-time.cc
+++ b/liboctave/system/oct-time.cc
@@ -68,17 +68,17 @@ namespace octave
 #endif
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
       std::string s = tm.zone ();
       char *ps = strsave (s.c_str ());
       t.tm_zone = ps;
 #endif
 
-      ot_unix_time = gnulib::mktime (&t);
+      ot_unix_time = std::mktime (&t);
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
       delete [] ps;
 #endif
 
       ot_usec = tm.usec ();
     }
 
@@ -234,27 +234,27 @@ namespace octave
 
     void
     localtime::init (const time& ot)
     {
       m_usec = ot.usec ();
 
       time_t t = ot.unix_time ();
 
-      base_tm::init (gnulib::localtime (&t));
+      base_tm::init (std::localtime (&t));
     }
 
     void
     gmtime::init (const time& ot)
     {
       m_usec = ot.usec ();
 
       time_t t = ot.unix_time ();
 
-      base_tm::init (gnulib::gmtime (&t));
+      base_tm::init (std::gmtime (&t));
     }
 
     void
     strptime::init (const std::string& str, const std::string& fmt)
     {
       struct ::tm t;
 
       t.tm_sec = 0;
@@ -281,17 +281,17 @@ namespace octave
       char *q = octave_strptime_wrapper (p, fmt.c_str (), &t);
 
       // Fill in wday and yday, but only if mday is valid and the mon and year
       // are filled in, avoiding issues with mktime and invalid dates.
       if (t.tm_mday != 0 && t.tm_mon >= 0
           && t.tm_year != std::numeric_limits<int>::min ())
         {
           t.tm_isdst = -1;
-          gnulib::mktime (&t);
+          std::mktime (&t);
         }
 
       if (t.tm_mon < 0)
         t.tm_mon = 0;
 
       if (t.tm_year == std::numeric_limits<int>::min ())
         t.tm_year = 0;
 
diff --git a/liboctave/system/oct-uname.cc b/liboctave/system/oct-uname.cc
--- a/liboctave/system/oct-uname.cc
+++ b/liboctave/system/oct-uname.cc
@@ -38,17 +38,17 @@ namespace octave
     uname::init (void)
     {
       char *sysname, *nodename, *release, *version, *machine;
 
       err = octave_uname_wrapper (&sysname, &nodename, &release,
                                   &version, &machine);
 
       if (err < 0)
-        msg = gnulib::strerror (errno);
+        msg = std::strerror (errno);
       else
         {
           m_sysname = sysname;
           m_nodename = nodename;
           m_release = release;
           m_version = version;
           m_machine = machine;
         }
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -814,17 +814,17 @@ namespace octave
     completion_fcn f = command_editor::get_completion_function ();
 
     std::string tmp = f (text, state);
 
     size_t len = tmp.length ();
 
     if (len > 0)
       {
-        retval = static_cast<char *> (gnulib::malloc (len+1));
+        retval = static_cast<char *> (std::malloc (len+1));
 
         strcpy (retval, tmp.c_str ());
       }
 
     return retval;
   }
 
   char *
@@ -835,17 +835,17 @@ namespace octave
     quoting_fcn f = command_editor::get_quoting_function ();
 
     std::string tmp = f (text, matches, *qcp);
 
     size_t len = tmp.length ();
 
     if (len > 0)
       {
-        retval = static_cast<char *> (gnulib::malloc (len+1));
+        retval = static_cast<char *> (std::malloc (len+1));
 
         strcpy (retval, tmp.c_str ());
       }
 
     return retval;
   }
 
   char *
@@ -856,17 +856,17 @@ namespace octave
     dequoting_fcn f = command_editor::get_dequoting_function ();
 
     std::string tmp = f (text, quote);
 
     size_t len = tmp.length ();
 
     if (len > 0)
       {
-        retval = static_cast<char *> (gnulib::malloc (len+1));
+        retval = static_cast<char *> (std::malloc (len+1));
 
         strcpy (retval, tmp.c_str ());
       }
 
     return retval;
   }
 
   int
@@ -948,18 +948,18 @@ namespace octave
     default_command_editor (const default_command_editor&);
 
     default_command_editor& operator = (const default_command_editor&);
   };
 
   std::string
   default_command_editor::do_readline (const std::string& prompt, bool& eof)
   {
-    gnulib::fputs (prompt.c_str (), output_stream);
-    gnulib::fflush (output_stream);
+    std::fputs (prompt.c_str (), output_stream);
+    std::fflush (output_stream);
 
     return octave_fgetl (input_stream, eof);
   }
 
   void
   default_command_editor::do_set_input_stream (FILE *f)
   {
     input_stream = f;
@@ -1897,17 +1897,17 @@ namespace octave
       result = -1;
 
     return result;
   }
 
   void
   command_editor::error (int err_num)
   {
-    (*current_liboctave_error_handler) ("%s", gnulib::strerror (err_num));
+    (*current_liboctave_error_handler) ("%s", std::strerror (err_num));
   }
 
   void
   command_editor::error (const std::string& s)
   {
     (*current_liboctave_error_handler) ("%s", s.c_str ());
   }
 }
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -1008,20 +1008,20 @@ namespace octave
           error ("command_history::clean_up_and_save: missing filename");
       }
   }
 
   void
   command_history::error (int err_num, const std::string& msg) const
   {
     if (msg.empty ())
-      (*current_liboctave_error_handler) ("%s", gnulib::strerror (err_num));
+      (*current_liboctave_error_handler) ("%s", std::strerror (err_num));
     else
       (*current_liboctave_error_handler) ("%s: %s", msg.c_str (),
-                                          gnulib::strerror (err_num));
+                                          std::strerror (err_num));
   }
 
   void
   command_history::error (const std::string& s) const
   {
     (*current_liboctave_error_handler) ("%s", s.c_str ());
   }
 }
diff --git a/liboctave/util/lo-utils.cc b/liboctave/util/lo-utils.cc
--- a/liboctave/util/lo-utils.cc
+++ b/liboctave/util/lo-utils.cc
@@ -93,17 +93,17 @@ strsave (const char *s)
 void
 octave_putenv (const std::string& name, const std::string& value)
 {
   int new_len = name.length () + value.length () + 2;
 
   // FIXME: This leaks memory, but so would a call to setenv.
   // Short of extreme measures to track memory, altering the environment
   // always leaks memory, but the saving grace is that the leaks are small.
-  char *new_item = static_cast<char*> (gnulib::malloc (new_len));
+  char *new_item = static_cast<char*> (std::malloc (new_len));
 
   sprintf (new_item, "%s=%s", name.c_str (), value.c_str ());
 
   // As far as I can see there's no way to distinguish between the
   // various errors; putenv doesn't have errno values.
 
   if (octave_putenv_wrapper (new_item) < 0)
     (*current_liboctave_error_handler) ("putenv (%s) failed", new_item);
@@ -121,32 +121,32 @@ octave_fgets (FILE *f, bool& eof)
 {
   eof = false;
 
   std::string retval;
 
   int grow_size = 1024;
   int max_size = grow_size;
 
-  char *buf = static_cast<char *> (gnulib::malloc (max_size));
+  char *buf = static_cast<char *> (std::malloc (max_size));
   char *bufptr = buf;
   int len = 0;
 
   do
     {
-      if (gnulib::fgets (bufptr, grow_size, f))
+      if (std::fgets (bufptr, grow_size, f))
         {
           len = strlen (bufptr);
 
           if (len == grow_size - 1)
             {
               int tmp = bufptr - buf + grow_size - 1;
               grow_size *= 2;
               max_size += grow_size;
-              buf = static_cast<char *> (gnulib::realloc (buf, max_size));
+              buf = static_cast<char *> (std::realloc (buf, max_size));
               bufptr = buf + tmp;
 
               if (*(bufptr-1) == '\n')
                 {
                   *bufptr = '\0';
                   retval = buf;
                 }
             }
diff --git a/liboctave/util/oct-inttypes.cc b/liboctave/util/oct-inttypes.cc
--- a/liboctave/util/oct-inttypes.cc
+++ b/liboctave/util/oct-inttypes.cc
@@ -573,17 +573,17 @@ umul128 (uint64_t x, uint64_t y, uint32_
   w[3] = a;
 }
 
 // Splits a double into bool sign, unsigned 64-bit mantissa and int exponent
 static void
 dblesplit (double x, bool& sign, uint64_t& mtis, int& exp)
 {
   sign = x < 0; x = fabs (x);
-  x = gnulib::frexp (x, &exp);
+  x = std::frexp (x, &exp);
   exp -= 52;
   mtis = static_cast<uint64_t> (ldexp (x, 52));
 }
 
 // Gets a double number from a
 // 32-bit unsigned integer mantissa, exponent, and sign.
 static double
 dbleget (bool sign, uint32_t mtis, int exp)
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -276,17 +276,17 @@ namespace octave
   {
     file = f;
 
     library = shl_load (file.c_str (), BIND_IMMEDIATE, 0L);
 
     if (! library)
       {
         using namespace std;  // FIXME: Why have this line?
-        (*current_liboctave_error_handler) ("%s", gnulib::strerror (errno));
+        (*current_liboctave_error_handler) ("%s", std::strerror (errno));
       }
   }
 
   octave_shl_load_shlib::~octave_shl_load_shlib (void)
   {
     if (library)
       shl_unload (library);
   }
diff --git a/liboctave/util/sparse-util.cc b/liboctave/util/sparse-util.cc
--- a/liboctave/util/sparse-util.cc
+++ b/liboctave/util/sparse-util.cc
@@ -69,18 +69,18 @@ SparseCholError (int status, const char 
   sparse_chol_error_internal (status, file, line, message);
 }
 
 int
 SparseCholPrint (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
-  int ret = gnulib::vfprintf (stderr, fmt, args);
-  gnulib::fflush (stderr);
+  int ret = std::vfprintf (stderr, fmt, args);
+  std::fflush (stderr);
   va_end (args);
   return ret;
 }
 
 bool
 sparse_indices_ok (octave_idx_type *r, octave_idx_type *c,
                    octave_idx_type nrows, octave_idx_type ncols,
                    octave_idx_type nnz)
diff --git a/oct-conf-post.in.h b/oct-conf-post.in.h
--- a/oct-conf-post.in.h
+++ b/oct-conf-post.in.h
@@ -15,20 +15,16 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-#if ! defined (GNULIB_NAMESPACE)
-#  define GNULIB_NAMESPACE gnulib
-#endif
-
 /* The C++ standard is evolving to allow attribute hints in a
    compiler-independent manner.  In C++ 2011 support for noreturn was
    added.  In C++ 2014 support for deprecated was added.  The Octave
    code base has been future-proofed by using macros of the form
    OCTAVE_ATTRIBUTE_NAME in place of vendor specific attribute
    mechanisms.  As compilers evolve, the underlying implementation can
    be changed with the macro definitions below.  FIXME: Update macros
    to use C++ standard attribute syntax when Octave moves to C++ 2011
diff --git a/src/mkoctfile.in.cc b/src/mkoctfile.in.cc
--- a/src/mkoctfile.in.cc
+++ b/src/mkoctfile.in.cc
@@ -54,17 +54,17 @@ static std::string
 get_line (FILE *fp)
 {
   static std::vector<char> buf (100);
   unsigned int idx = 0;
   int c;
 
   while (true)
     {
-      c = gnulib::fgetc (fp);
+      c = std::fgetc (fp);
       if (c == '\n' || c == EOF)
         break;
       if (buf.size () <= idx)
         buf.resize (buf.size () + 100);
       buf[idx++] = c;
     }
   if (idx == 0)
     return std::string ("");
diff --git a/src/module.mk b/src/module.mk
--- a/src/module.mk
+++ b/src/module.mk
@@ -11,18 +11,17 @@ SRC_DIR_CPPFLAGS = \
   -I$(srcdir)/liboctave/array \
   -I$(srcdir)/liboctave/cruft/misc \
   -I$(srcdir)/liboctave/numeric \
   -I$(srcdir)/liboctave/system \
   -I$(srcdir)/liboctave/util \
   -Iliboctave/wrappers -I$(srcdir)/liboctave/wrappers \
   -Ilibinterp -I$(srcdir)/libinterp \
   -Ilibinterp/corefcn -I$(srcdir)/libinterp/corefcn \
-  -I$(srcdir)/src \
-  -Ilibgnu -I$(srcdir)/libgnu
+  -I$(srcdir)/src
 
 EXTRA_DIST += \
   src/main.in.cc \
   src/mkoctfile.in.cc \
   src/octave-build-info.in.cc \
   src/octave-config.in.cc
 
 DISTCLEANFILES += \
