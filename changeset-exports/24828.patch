# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1520023051 18000
#      Fri Mar 02 15:37:31 2018 -0500
# Node ID 0f6a261ab144d7f6b2cc04aed0968122d8d05daa
# Parent  1e0718c1867ce3518433d046cce11dd937c3f818
move some GUI classes inside octave namespace

* octave-dock-widget.cc, octave-dock-widget.h,
variable-editor-model.cc, variable-editor-model.h, variable-editor.cc,
variable-editor.h: Move classes inside octave namespace.
* settings-dialog.cc: Tag variable_editor with octave:: namespace.

diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -31,422 +31,424 @@ along with Octave; see the file COPYING.
 #include <QHBoxLayout>
 #include <QLabel>
 #include <QSettings>
 #include <QStyle>
 
 #include "resource-manager.h"
 #include "octave-dock-widget.h"
 
-
-label_dock_widget::label_dock_widget (QWidget *p)
-  : QDockWidget (p)
+namespace octave
 {
-  QStyle *st = style ();
-  m_icon_size = 0.75*st->pixelMetric (QStyle::PM_SmallIconSize);
+  label_dock_widget::label_dock_widget (QWidget *p)
+    : QDockWidget (p)
+  {
+    QStyle *st = style ();
+    m_icon_size = 0.75*st->pixelMetric (QStyle::PM_SmallIconSize);
 
-  // the custom (extra) title bar of the widget
-  m_dock_action = new QAction
-                   (QIcon (":/actions/icons/widget-undock.png"), "", this);
-  m_dock_action->setToolTip (tr ("Undock widget"));
-  m_dock_button = new QToolButton (this);
-  m_dock_button->setDefaultAction (m_dock_action);
-  m_dock_button->setFocusPolicy (Qt::NoFocus);
-  m_dock_button->setIconSize (QSize (m_icon_size,m_icon_size));
+    // the custom (extra) title bar of the widget
+    m_dock_action = new QAction
+      (QIcon (":/actions/icons/widget-undock.png"), "", this);
+    m_dock_action->setToolTip (tr ("Undock widget"));
+    m_dock_button = new QToolButton (this);
+    m_dock_button->setDefaultAction (m_dock_action);
+    m_dock_button->setFocusPolicy (Qt::NoFocus);
+    m_dock_button->setIconSize (QSize (m_icon_size,m_icon_size));
 
-  m_close_action = new QAction
-                   (QIcon (":/actions/icons/widget-close.png"), "", this);
-  m_close_action->setToolTip (tr ("Close widget"));
-  m_close_button = new QToolButton (this);
-  m_close_button->setDefaultAction (m_close_action);
-  m_close_button->setFocusPolicy (Qt::NoFocus);
-  m_close_button->setIconSize (QSize (m_icon_size,m_icon_size));
+    m_close_action = new QAction
+      (QIcon (":/actions/icons/widget-close.png"), "", this);
+    m_close_action->setToolTip (tr ("Close widget"));
+    m_close_button = new QToolButton (this);
+    m_close_button->setDefaultAction (m_close_action);
+    m_close_button->setFocusPolicy (Qt::NoFocus);
+    m_close_button->setIconSize (QSize (m_icon_size,m_icon_size));
 
-  QString css_button = QString ("QToolButton {background: transparent; border: 0px;}");
-  m_dock_button->setStyleSheet (css_button);
-  m_close_button->setStyleSheet (css_button);
+    QString css_button = QString ("QToolButton {background: transparent; border: 0px;}");
+    m_dock_button->setStyleSheet (css_button);
+    m_close_button->setStyleSheet (css_button);
 
-  QHBoxLayout *h_layout = new QHBoxLayout ();
-  h_layout->addStretch (100);
-  h_layout->addWidget (m_dock_button);
-  h_layout->addWidget (m_close_button);
-  h_layout->setSpacing (0);
-  h_layout->setContentsMargins (5,2,2,2);
+    QHBoxLayout *h_layout = new QHBoxLayout ();
+    h_layout->addStretch (100);
+    h_layout->addWidget (m_dock_button);
+    h_layout->addWidget (m_close_button);
+    h_layout->setSpacing (0);
+    h_layout->setContentsMargins (5,2,2,2);
 
-  m_title_widget = new QWidget ();
-  m_title_widget->setLayout (h_layout);
-  setTitleBarWidget (m_title_widget);
+    m_title_widget = new QWidget ();
+    m_title_widget->setLayout (h_layout);
+    setTitleBarWidget (m_title_widget);
 
-  // copy & paste handling
-  connect (p, SIGNAL (copyClipboard_signal ()),
-           this, SLOT (copyClipboard ()));
-  connect (p, SIGNAL (pasteClipboard_signal ()),
-           this, SLOT (pasteClipboard ()));
-  connect (p, SIGNAL (selectAll_signal ()),
-           this, SLOT (selectAll ()));
-  // undo handling
-  connect (p, SIGNAL (undo_signal ()), this, SLOT (do_undo ()));
-}
+    // copy & paste handling
+    connect (p, SIGNAL (copyClipboard_signal ()),
+             this, SLOT (copyClipboard ()));
+    connect (p, SIGNAL (pasteClipboard_signal ()),
+             this, SLOT (pasteClipboard ()));
+    connect (p, SIGNAL (selectAll_signal ()),
+             this, SLOT (selectAll ()));
+    // undo handling
+    connect (p, SIGNAL (undo_signal ()), this, SLOT (do_undo ()));
+  }
 
-// set the title in the dockwidgets title bar
-void
-label_dock_widget::set_title (const QString& title)
-{
-  QHBoxLayout *h_layout
-    = static_cast<QHBoxLayout *> (titleBarWidget ()->layout ());
-  QLabel *label = new QLabel (title);
-  label->setStyleSheet ("background: transparent;");
-  h_layout->insertWidget (0,label);
-  setWindowTitle (title);
-}
+  // set the title in the dockwidgets title bar
+  void
+  label_dock_widget::set_title (const QString& title)
+  {
+    QHBoxLayout *h_layout
+      = static_cast<QHBoxLayout *> (titleBarWidget ()->layout ());
+    QLabel *label = new QLabel (title);
+    label->setStyleSheet ("background: transparent;");
+    h_layout->insertWidget (0,label);
+    setWindowTitle (title);
+  }
 
 
-octave_dock_widget::octave_dock_widget (QWidget *p)
-  : label_dock_widget (p)
-{
-  m_parent = static_cast<QMainWindow *> (p);     // store main window
-  m_floating = false;
-  m_predecessor_widget = nullptr;
+  octave_dock_widget::octave_dock_widget (QWidget *p)
+    : label_dock_widget (p)
+  {
+    m_parent = static_cast<QMainWindow *> (p);     // store main window
+    m_floating = false;
+    m_predecessor_widget = nullptr;
 
-  connect (this, SIGNAL (visibilityChanged (bool)),
-           this, SLOT (handle_visibility_changed (bool)));
+    connect (this, SIGNAL (visibilityChanged (bool)),
+             this, SLOT (handle_visibility_changed (bool)));
 
-  connect (p, SIGNAL (settings_changed (const QSettings*)),
-           this, SLOT (handle_settings (const QSettings*)));
+    connect (p, SIGNAL (settings_changed (const QSettings*)),
+             this, SLOT (handle_settings (const QSettings*)));
 
-  connect (p, SIGNAL (active_dock_changed (octave_dock_widget*,
-                                           octave_dock_widget*)),
-           this, SLOT (handle_active_dock_changed (octave_dock_widget*,
-                                                   octave_dock_widget*)));
+    connect (p, SIGNAL (active_dock_changed (octave_dock_widget*,
+                                             octave_dock_widget*)),
+             this, SLOT (handle_active_dock_changed (octave_dock_widget*,
+                                                     octave_dock_widget*)));
 
-  setFeatures (QDockWidget::DockWidgetMovable); // not floatable or closeable
+    setFeatures (QDockWidget::DockWidgetMovable); // not floatable or closeable
 
-  connect (m_dock_action, SIGNAL (triggered (bool)),
-           this, SLOT (change_floating (bool)));
-  connect (m_close_action, SIGNAL (triggered (bool)),
-           this, SLOT (change_visibility (bool)));
+    connect (m_dock_action, SIGNAL (triggered (bool)),
+             this, SLOT (change_floating (bool)));
+    connect (m_close_action, SIGNAL (triggered (bool)),
+             this, SLOT (change_visibility (bool)));
 
-  m_close_action->setToolTip (tr ("Hide widget"));
+    m_close_action->setToolTip (tr ("Hide widget"));
 
-  m_icon_color = "";
-  m_title_3d = 50;
+    m_icon_color = "";
+    m_title_3d = 50;
 
-  installEventFilter (this);
+    installEventFilter (this);
 
-  setFocusPolicy (Qt::StrongFocus);
-}
+    setFocusPolicy (Qt::StrongFocus);
+  }
 
-// connect signal visibility changed to related slot (called from main-window)
-void
-octave_dock_widget::connect_visibility_changed (void)
-{
-  connect (this, SIGNAL (visibilityChanged (bool)),
-           this, SLOT (handle_visibility (bool)));
-  emit active_changed (isVisible ());  // emit once for init of window menu
-}
+  // connect signal visibility changed to related slot (called from main-window)
+  void
+  octave_dock_widget::connect_visibility_changed (void)
+  {
+    connect (this, SIGNAL (visibilityChanged (bool)),
+             this, SLOT (handle_visibility (bool)));
+    emit active_changed (isVisible ());  // emit once for init of window menu
+  }
 
-// make the widget floating
-void
-octave_dock_widget::make_window (void)
-{
-  // the widget has to be reparented (parent = 0)
+  // make the widget floating
+  void
+  octave_dock_widget::make_window (void)
+  {
+    // the widget has to be reparented (parent = 0)
 
-  QSettings *settings = resource_manager::get_settings ();
+    QSettings *settings = resource_manager::get_settings ();
 
-  // save the docking area and geometry for later redocking
-  // FIXME: dockWidgetArea always returns 2
-  settings->setValue ("DockWidgets/" + objectName () + "_dock_area",
-                      m_parent->dockWidgetArea (this));
-  settings->setValue ("DockWidgets/" + objectName (), saveGeometry ());
-  settings->sync ();
+    // save the docking area and geometry for later redocking
+    // FIXME: dockWidgetArea always returns 2
+    settings->setValue ("DockWidgets/" + objectName () + "_dock_area",
+                        m_parent->dockWidgetArea (this));
+    settings->setValue ("DockWidgets/" + objectName (), saveGeometry ());
+    settings->sync ();
 
-  // remove parent and adjust the (un)dock icon
-  setTitleBarWidget (0);
-  setParent (0, Qt::Window | Qt::CustomizeWindowHint | Qt::WindowTitleHint |
-                Qt::WindowMinimizeButtonHint | Qt::WindowCloseButtonHint);
-  setTitleBarWidget (m_title_widget);
-  setParent (0, Qt::Window | Qt::CustomizeWindowHint | Qt::WindowTitleHint |
-                Qt::WindowMinimizeButtonHint | Qt::WindowCloseButtonHint);
+    // remove parent and adjust the (un)dock icon
+    setTitleBarWidget (0);
+    setParent (0, Qt::Window | Qt::CustomizeWindowHint | Qt::WindowTitleHint |
+               Qt::WindowMinimizeButtonHint | Qt::WindowCloseButtonHint);
+    setTitleBarWidget (m_title_widget);
+    setParent (0, Qt::Window | Qt::CustomizeWindowHint | Qt::WindowTitleHint |
+               Qt::WindowMinimizeButtonHint | Qt::WindowCloseButtonHint);
 
-  m_dock_action->setIcon (QIcon (":/actions/icons/widget-dock"
-                                + m_icon_color + ".png"));
-  m_dock_action->setToolTip (tr ("Dock widget"));
+    m_dock_action->setIcon (QIcon (":/actions/icons/widget-dock"
+                                   + m_icon_color + ".png"));
+    m_dock_action->setToolTip (tr ("Dock widget"));
 
-  // restore the last geometry when floating
-  setGeometry (settings->value ("DockWidgets/" + objectName ()
-                                + "_floating_geometry",
-                                QRect (50,100,480,480)).toRect ());
+    // restore the last geometry when floating
+    setGeometry (settings->value ("DockWidgets/" + objectName ()
+                                  + "_floating_geometry",
+                                  QRect (50,100,480,480)).toRect ());
 
-  m_floating = true;
+    m_floating = true;
 
-  set_focus_predecessor ();  // set focus previously active widget if tabbed
-}
+    set_focus_predecessor ();  // set focus previously active widget if tabbed
+  }
 
-// dock the widget
-void
-octave_dock_widget::make_widget (bool dock)
-{
-  // Since floating widget has no parent, we have to read it
+  // dock the widget
+  void
+  octave_dock_widget::make_widget (bool dock)
+  {
+    // Since floating widget has no parent, we have to read it
 
-  QSettings *settings = resource_manager::get_settings ();
+    QSettings *settings = resource_manager::get_settings ();
 
-  // save last floating geometry if widget really was floating
-  if (m_floating)
-    settings->setValue ("DockWidgets/" + objectName () + "_floating_geometry",
-                        geometry ());
-  settings->sync ();
+    // save last floating geometry if widget really was floating
+    if (m_floating)
+      settings->setValue ("DockWidgets/" + objectName () + "_floating_geometry",
+                          geometry ());
+    settings->sync ();
 
-  if (dock)
-    {
-      settings->setValue ("MainWindow/windowState", m_parent->saveState ());
-      m_parent->addDockWidget (Qt::TopDockWidgetArea, this);
-      // recover old window states, hide and re-show new added widget
-      m_parent->restoreState (settings->value ("MainWindow/windowState").toByteArray ());
-      focus ();
-      QApplication::setActiveWindow (this);
-    }
-  else  // only reparent, no docking
-    setParent (m_parent);
+    if (dock)
+      {
+        settings->setValue ("MainWindow/windowState", m_parent->saveState ());
+        m_parent->addDockWidget (Qt::TopDockWidgetArea, this);
+        // recover old window states, hide and re-show new added widget
+        m_parent->restoreState (settings->value ("MainWindow/windowState").toByteArray ());
+        focus ();
+        QApplication::setActiveWindow (this);
+      }
+    else  // only reparent, no docking
+      setParent (m_parent);
 
-  // adjust the (un)dock icon
-  m_dock_action->setIcon (QIcon (":/actions/icons/widget-undock"
-                                + m_icon_color + ".png"));
-  m_dock_action->setToolTip (tr ("Undock widget"));
+    // adjust the (un)dock icon
+    m_dock_action->setIcon (QIcon (":/actions/icons/widget-undock"
+                                   + m_icon_color + ".png"));
+    m_dock_action->setToolTip (tr ("Undock widget"));
 
-  m_floating = false;
-}
+    m_floating = false;
+  }
 
-// set the widget which previously had focus when tabified
-void
-octave_dock_widget::set_predecessor_widget (octave_dock_widget *prev_widget)
-{
-  m_predecessor_widget = prev_widget;
-}
+  // set the widget which previously had focus when tabified
+  void
+  octave_dock_widget::set_predecessor_widget (octave_dock_widget *prev_widget)
+  {
+    m_predecessor_widget = prev_widget;
+  }
 
-// close event
-void
-octave_dock_widget::closeEvent (QCloseEvent *e)
-{
-  emit active_changed (false);
-  set_focus_predecessor ();
-  QDockWidget::closeEvent (e);
-}
+  // close event
+  void
+  octave_dock_widget::closeEvent (QCloseEvent *e)
+  {
+    emit active_changed (false);
+    set_focus_predecessor ();
+    QDockWidget::closeEvent (e);
+  }
 
-// get focus widget
-QWidget *
-octave_dock_widget::focusWidget (void)
-{
-  QWidget *w = QApplication::focusWidget ();
-  if (w && w->focusProxy ()) w = w->focusProxy ();
-  return w;
-}
+  // get focus widget
+  QWidget *
+  octave_dock_widget::focusWidget (void)
+  {
+    QWidget *w = QApplication::focusWidget ();
+    if (w && w->focusProxy ()) w = w->focusProxy ();
+    return w;
+  }
 
-void
-octave_dock_widget::handle_settings (const QSettings *settings)
-{
-  m_custom_style
-    = settings->value ("DockWidgets/widget_title_custom_style",false).toBool ();
+  void
+  octave_dock_widget::handle_settings (const QSettings *settings)
+  {
+    m_custom_style
+      = settings->value ("DockWidgets/widget_title_custom_style",false).toBool ();
 
-  m_title_3d
-    = settings->value ("DockWidgets/widget_title_3d",50).toInt ();
+    m_title_3d
+      = settings->value ("DockWidgets/widget_title_3d",50).toInt ();
 
-  QColor default_var = QColor (0,0,0);
-  m_fg_color = settings->value ("DockWidgets/title_fg_color",
-                               default_var).value<QColor> ();
-  default_var = QColor (0,0,0);
-  m_fg_color_active = settings->value ("DockWidgets/title_fg_color_active",
-                                      default_var).value<QColor> ();
+    QColor default_var = QColor (0,0,0);
+    m_fg_color = settings->value ("DockWidgets/title_fg_color",
+                                  default_var).value<QColor> ();
+    default_var = QColor (0,0,0);
+    m_fg_color_active = settings->value ("DockWidgets/title_fg_color_active",
+                                         default_var).value<QColor> ();
 
-  default_var = QColor (255,255,255);
-  m_bg_color = settings->value ("DockWidgets/title_bg_color",
-                               default_var).value<QColor> ();
-  default_var = QColor (192,192,192);
-  m_bg_color_active = settings->value ("DockWidgets/title_bg_color_active",
-                                      default_var).value<QColor> ();
+    default_var = QColor (255,255,255);
+    m_bg_color = settings->value ("DockWidgets/title_bg_color",
+                                  default_var).value<QColor> ();
+    default_var = QColor (192,192,192);
+    m_bg_color_active = settings->value ("DockWidgets/title_bg_color_active",
+                                         default_var).value<QColor> ();
 
-  int r, g, b;
-  m_bg_color.getRgb (&r, &g, &b);
-  if (r+g+b < 400)
-    m_icon_color = "-light";
-  else
-    m_icon_color = "";
+    int r, g, b;
+    m_bg_color.getRgb (&r, &g, &b);
+    if (r+g+b < 400)
+      m_icon_color = "-light";
+    else
+      m_icon_color = "";
 
-  m_bg_color_active.getRgb (&r, &g, &b);
-  if (r+g+b < 400)
-    m_icon_color_active = "-light";
-  else
-    m_icon_color_active = "";
+    m_bg_color_active.getRgb (&r, &g, &b);
+    if (r+g+b < 400)
+      m_icon_color_active = "-light";
+    else
+      m_icon_color_active = "";
 
-  notice_settings (settings);  // call individual handler
+    notice_settings (settings);  // call individual handler
 
-  set_style (false);
-}
+    set_style (false);
+  }
 
-void
-octave_dock_widget::handle_active_dock_changed (octave_dock_widget *w_old,
-                                                octave_dock_widget *w_new)
-{
-  if (m_custom_style && this == w_old)
-    {
-      set_style (false);
-      update ();
-    }
+  void
+  octave_dock_widget::handle_active_dock_changed (octave_dock_widget *w_old,
+                                                  octave_dock_widget *w_new)
+  {
+    if (m_custom_style && this == w_old)
+      {
+        set_style (false);
+        update ();
+      }
 
-  if (m_custom_style && this == w_new)
-    {
-      set_style (true);
-      update ();
-    }
-}
+    if (m_custom_style && this == w_new)
+      {
+        set_style (true);
+        update ();
+      }
+  }
 
-void
-octave_dock_widget::save_settings (void)
-{
-  // save state of this dock-widget
-  QString name = objectName ();
-  QSettings *settings = resource_manager::get_settings ();
+  void
+  octave_dock_widget::save_settings (void)
+  {
+    // save state of this dock-widget
+    QString name = objectName ();
+    QSettings *settings = resource_manager::get_settings ();
 
-  if (! settings)
-    return;
+    if (! settings)
+      return;
 
-  settings->beginGroup ("DockWidgets");
+    settings->beginGroup ("DockWidgets");
 
-  if (m_floating) // widget is floating (windows), save actual floating geometry
-    settings->setValue (name+"_floating_geometry", geometry ());
-  else           // not floating save docked (normal) geometry
-  settings->setValue (name, saveGeometry ());
+    if (m_floating) // widget is floating (windows), save actual floating geometry
+      settings->setValue (name+"_floating_geometry", geometry ());
+    else           // not floating save docked (normal) geometry
+      settings->setValue (name, saveGeometry ());
 
-  settings->setValue (name+"Visible", isVisible ()); // store visibility
-  settings->setValue (name+"Floating", m_floating);    // store visibility
-  settings->setValue (name+"_minimized", isMinimized ()); // store minimized
+    settings->setValue (name+"Visible", isVisible ()); // store visibility
+    settings->setValue (name+"Floating", m_floating);    // store visibility
+    settings->setValue (name+"_minimized", isMinimized ()); // store minimized
 
-  settings->endGroup ();
-  settings->sync ();
-}
+    settings->endGroup ();
+    settings->sync ();
+  }
 
-bool octave_dock_widget::eventFilter (QObject *obj, QEvent *e)
-{
-  if (e->type () == QEvent::NonClientAreaMouseButtonDblClick)
-    {
-      e->ignore (); // ignore double clicks into window decoration elements
-      return true;
-    }
+  bool octave_dock_widget::eventFilter (QObject *obj, QEvent *e)
+  {
+    if (e->type () == QEvent::NonClientAreaMouseButtonDblClick)
+      {
+        e->ignore (); // ignore double clicks into window decoration elements
+        return true;
+      }
 
-  return QDockWidget::eventFilter (obj,e);
-}
+    return QDockWidget::eventFilter (obj,e);
+  }
 
-// slot for (un)dock action
-void
-octave_dock_widget::change_floating (bool)
-{
-  if (m_floating)
-    make_widget ();
-  else
-    {
-      make_window ();
-      focus ();
-    }
-}
+  // slot for (un)dock action
+  void
+  octave_dock_widget::change_floating (bool)
+  {
+    if (m_floating)
+      make_widget ();
+    else
+      {
+        make_window ();
+        focus ();
+      }
+  }
 
-// slot for hiding the widget
-void
-octave_dock_widget::change_visibility (bool)
-{
-  setVisible (false);
-  emit active_changed (false);
-}
+  // slot for hiding the widget
+  void
+  octave_dock_widget::change_visibility (bool)
+  {
+    setVisible (false);
+    emit active_changed (false);
+  }
 
-void
-octave_dock_widget::set_style (bool active)
-{
-  QString css;
-  QString css_button;
-  QString dock_icon;
+  void
+  octave_dock_widget::set_style (bool active)
+  {
+    QString css;
+    QString css_button;
+    QString dock_icon;
 
-  QString icon_col = m_icon_color;
+    QString icon_col = m_icon_color;
 
-  if (m_floating)
-    dock_icon = "widget-dock";
-  else
-    dock_icon = "widget-undock";
+    if (m_floating)
+      dock_icon = "widget-dock";
+    else
+      dock_icon = "widget-undock";
 
 #if defined (Q_OS_MAC)
-  QString alignment = "center";
+    QString alignment = "center";
 #else
-  QString alignment = "center left";
+    QString alignment = "center left";
 #endif
-  if (m_custom_style)
-    {
+    if (m_custom_style)
+      {
 
-      QColor bg_col, fg_col;
+        QColor bg_col, fg_col;
 
-      if (active)
-        {
-          bg_col = m_bg_color_active;
-          fg_col = m_fg_color_active;
-          icon_col = m_icon_color_active;
-        }
-      else
-        {
-          bg_col = m_bg_color;
-          fg_col = m_fg_color;
-          icon_col = m_icon_color;
-        }
+        if (active)
+          {
+            bg_col = m_bg_color_active;
+            fg_col = m_fg_color_active;
+            icon_col = m_icon_color_active;
+          }
+        else
+          {
+            bg_col = m_bg_color;
+            fg_col = m_fg_color;
+            icon_col = m_icon_color;
+          }
 
-      QColor bg_col_top, bg_col_bottom;
-      if (m_title_3d > 0)
-        {
-          bg_col_top = bg_col.lighter (100 + m_title_3d);
-          bg_col_bottom = bg_col.darker (100 + m_title_3d);
-        }
-      else
-        {
-          bg_col_top = bg_col.darker (100 - m_title_3d);
-          bg_col_bottom = bg_col.lighter (100 - m_title_3d);
-        }
+        QColor bg_col_top, bg_col_bottom;
+        if (m_title_3d > 0)
+          {
+            bg_col_top = bg_col.lighter (100 + m_title_3d);
+            bg_col_bottom = bg_col.darker (100 + m_title_3d);
+          }
+        else
+          {
+            bg_col_top = bg_col.darker (100 - m_title_3d);
+            bg_col_bottom = bg_col.lighter (100 - m_title_3d);
+          }
 
-      QString background =
-        QString ("background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,"
-                 "            stop: 0 %1, stop: 0.60 %2, stop: 0.95 %2 stop: 1.0 %3);").
-        arg (bg_col_top.name ()).
-        arg (bg_col.name ()).
-        arg (bg_col_bottom.name ());
+        QString background =
+          QString ("background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,"
+                   "            stop: 0 %1, stop: 0.60 %2, stop: 0.95 %2 stop: 1.0 %3);").
+          arg (bg_col_top.name ()).
+          arg (bg_col.name ()).
+          arg (bg_col_bottom.name ());
 
-      css = background + QString (" color: %1 ;").arg (fg_col.name ());
-    }
-  else
-    {
-      css = QString ("");
-    }
+        css = background + QString (" color: %1 ;").arg (fg_col.name ());
+      }
+    else
+      {
+        css = QString ("");
+      }
 
-  m_title_widget->setStyleSheet (css);
-  css_button = QString ("QToolButton {background: transparent; border: 0px;}");
-  m_dock_button->setStyleSheet (css_button);
-  m_close_button->setStyleSheet (css_button);
-  m_dock_action->setIcon (QIcon (":/actions/icons/" + dock_icon + icon_col +
-                                ".png"));
-  m_close_action->setIcon (QIcon (":/actions/icons/widget-close" + icon_col +
-                                 ".png"));
-}
+    m_title_widget->setStyleSheet (css);
+    css_button = QString ("QToolButton {background: transparent; border: 0px;}");
+    m_dock_button->setStyleSheet (css_button);
+    m_close_button->setStyleSheet (css_button);
+    m_dock_action->setIcon (QIcon (":/actions/icons/" + dock_icon + icon_col +
+                                   ".png"));
+    m_close_action->setIcon (QIcon (":/actions/icons/widget-close" + icon_col +
+                                    ".png"));
+  }
 
-// set focus to previously active widget in tabbed widget stack
-void
-octave_dock_widget::set_focus_predecessor (void)
-{
-  if (m_predecessor_widget)    // only != 0 if widget was tabbed
-    m_predecessor_widget->focus ();
+  // set focus to previously active widget in tabbed widget stack
+  void
+  octave_dock_widget::set_focus_predecessor (void)
+  {
+    if (m_predecessor_widget)    // only != 0 if widget was tabbed
+      m_predecessor_widget->focus ();
 
-  m_predecessor_widget = nullptr;
-  // FIXME: Until cset bda0c5b38bda, the wrong keys "Dockwidget/..." were used
-  // here.  This had no effect in Qt4, but does in Qt5.  In the following, the
-  // four incorrect keys are updated if still present in the settings files.
-  // The keys are also used in the settings dialog, but
-  // octave_dock_widget::handle_settings is already called at program start.
-  // These tests can be removed in a future version of Octave (version 4.8).
-  resource_manager::update_settings_key ("Dockwidgets/title_bg_color",
-                                         "DockWidgets/title_bg_color");
-  resource_manager::update_settings_key ("Dockwidgets/title_bg_color_active",
-                                         "DockWidgets/title_bg_color_active");
-  resource_manager::update_settings_key ("Dockwidgets/title_fg_color",
-                                         "DockWidgets/title_fg_color");
-  resource_manager::update_settings_key ("Dockwidgets/title_fg_color_active",
-                                         "DockWidgets/title_fg_color_active");
+    m_predecessor_widget = nullptr;
+    // FIXME: Until cset bda0c5b38bda, the wrong keys "Dockwidget/..." were used
+    // here.  This had no effect in Qt4, but does in Qt5.  In the following, the
+    // four incorrect keys are updated if still present in the settings files.
+    // The keys are also used in the settings dialog, but
+    // octave_dock_widget::handle_settings is already called at program start.
+    // These tests can be removed in a future version of Octave (version 4.8).
+    resource_manager::update_settings_key ("Dockwidgets/title_bg_color",
+                                           "DockWidgets/title_bg_color");
+    resource_manager::update_settings_key ("Dockwidgets/title_bg_color_active",
+                                           "DockWidgets/title_bg_color_active");
+    resource_manager::update_settings_key ("Dockwidgets/title_fg_color",
+                                           "DockWidgets/title_fg_color");
+    resource_manager::update_settings_key ("Dockwidgets/title_fg_color_active",
+                                           "DockWidgets/title_fg_color_active");
+  }
 }
diff --git a/libgui/src/octave-dock-widget.h b/libgui/src/octave-dock-widget.h
--- a/libgui/src/octave-dock-widget.h
+++ b/libgui/src/octave-dock-widget.h
@@ -25,141 +25,146 @@ along with Octave; see the file COPYING.
 
 #include <QDockWidget>
 #include <QSettings>
 #include <QIcon>
 #include <QMainWindow>
 #include <QToolButton>
 #include <QMouseEvent>
 
-// The few decoration items common to both main window and variable editor.
-class label_dock_widget : public QDockWidget
+namespace octave
 {
-  Q_OBJECT
+
+  // The few decoration items common to both main window and variable editor.
 
-public:
-
-  label_dock_widget (QWidget *p = nullptr);
+  class label_dock_widget : public QDockWidget
+  {
+    Q_OBJECT
 
-  void set_title (const QString&);
+  public:
 
-protected slots:
+    label_dock_widget (QWidget *p = nullptr);
+
+    void set_title (const QString&);
 
-  //! Slots to handle copy & paste.
-  //!@{
-  virtual void copyClipboard (void) {  }
-  virtual void pasteClipboard (void) {  }
-  virtual void selectAll (void) {  }
-  //!@}
+  protected slots:
 
-  //! Slot to handle undo.
+    //! Slots to handle copy & paste.
+    //!@{
+    virtual void copyClipboard (void) { }
+    virtual void pasteClipboard (void) { }
+    virtual void selectAll (void) { }
+    //!@}
 
-  virtual void do_undo (void) {  }
+    //! Slot to handle undo.
 
-protected:
+    virtual void do_undo (void) { }
+
+  protected:
 
-  int m_icon_size;
-  QWidget *m_title_widget;
-  QToolButton *m_dock_button;
-  QToolButton *m_close_button;
-  QAction *m_dock_action;
-  QAction *m_close_action;
-};
+    int m_icon_size;
+    QWidget *m_title_widget;
+    QToolButton *m_dock_button;
+    QToolButton *m_close_button;
+    QAction *m_dock_action;
+    QAction *m_close_action;
+  };
 
-class octave_dock_widget : public label_dock_widget
-{
-  Q_OBJECT
+  class octave_dock_widget : public label_dock_widget
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  octave_dock_widget (QWidget *p = nullptr);
+    octave_dock_widget (QWidget *p = nullptr);
 
-  virtual ~octave_dock_widget (void) = default;
+    virtual ~octave_dock_widget (void) = default;
 
-  virtual void connect_visibility_changed (void);
+    virtual void connect_visibility_changed (void);
 
-  void make_window (void);
-  void make_widget (bool dock=true);
-  void set_predecessor_widget (octave_dock_widget *prev_widget);
+    void make_window (void);
+    void make_widget (bool dock=true);
+    void set_predecessor_widget (octave_dock_widget *prev_widget);
 
-signals:
+  signals:
 
-  //! Custom signal that tells whether a user has clicked away that dock
-  //! widget, i.e the active dock widget has changed.
+    //! Custom signal that tells whether a user has clicked away that dock
+    //! widget, i.e the active dock widget has changed.
 
-  void active_changed (bool active);
+    void active_changed (bool active);
 
-protected:
-
-  virtual void closeEvent (QCloseEvent *e);
+  protected:
 
-  QWidget * focusWidget (void);
+    virtual void closeEvent (QCloseEvent *e);
 
-public slots:
+    QWidget * focusWidget (void);
 
-  virtual void focus (void)
-  {
-    if (! isVisible ())
-      setVisible (true);
+  public slots:
 
-    setFocus ();
-    activateWindow ();
-    raise ();
-  }
+    virtual void focus (void)
+    {
+      if (! isVisible ())
+        setVisible (true);
+
+      setFocus ();
+      activateWindow ();
+      raise ();
+    }
 
-  virtual void handle_visibility (bool visible)
-  {
-    if (visible && ! isFloating ())
-      focus ();
-  }
+    virtual void handle_visibility (bool visible)
+    {
+      if (visible && ! isFloating ())
+        focus ();
+    }
 
-  virtual void notice_settings (const QSettings*) { }
+    virtual void notice_settings (const QSettings*) { }
 
-  void handle_settings (const QSettings*);
+    void handle_settings (const QSettings*);
 
-  void handle_active_dock_changed (octave_dock_widget*, octave_dock_widget*);
+    void handle_active_dock_changed (octave_dock_widget*, octave_dock_widget*);
 
-  QMainWindow * main_win (void) { return m_parent; }
+    QMainWindow * main_win (void) { return m_parent; }
 
-  void save_settings (void);
+    void save_settings (void);
 
-protected slots:
+  protected slots:
 
-  //! Slot to steer changing visibility from outside.
+    //! Slot to steer changing visibility from outside.
 
-  virtual void handle_visibility_changed (bool visible)
-  {
-    if (visible)
-      emit active_changed (true);
-  }
+    virtual void handle_visibility_changed (bool visible)
+    {
+      if (visible)
+        emit active_changed (true);
+    }
 
-  //! Event filter for double clicks into the window decoration elements.
+    //! Event filter for double clicks into the window decoration elements.
 
-  bool eventFilter (QObject *obj, QEvent *e);
+    bool eventFilter (QObject *obj, QEvent *e);
 
-private slots:
+  private slots:
 
-  void change_floating (bool);
-  void change_visibility (bool);
+    void change_floating (bool);
+    void change_visibility (bool);
 
-private:
+  private:
 
-  void set_style (bool active);
-  void set_focus_predecessor (void);
+    void set_style (bool active);
+    void set_focus_predecessor (void);
 
-  //! Stores the parent, since we are reparenting to 0.
+    //! Stores the parent, since we are reparenting to 0.
 
-  QMainWindow *m_parent;
+    QMainWindow *m_parent;
 
-  bool m_floating;
-  bool m_custom_style;
-  int m_title_3d;
-  QColor m_bg_color;
-  QColor m_bg_color_active;
-  QColor m_fg_color;
-  QColor m_fg_color_active;
-  QString m_icon_color;
-  QString m_icon_color_active;
-  octave_dock_widget *m_predecessor_widget;
+    bool m_floating;
+    bool m_custom_style;
+    int m_title_3d;
+    QColor m_bg_color;
+    QColor m_bg_color_active;
+    QColor m_fg_color;
+    QColor m_fg_color_active;
+    QString m_icon_color;
+    QString m_icon_color_active;
+    octave_dock_widget *m_predecessor_widget;
 
-};
+  };
+}
 
 #endif
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -1088,18 +1088,18 @@ settings_dialog::write_terminal_colors (
     }
 
   settings->sync ();
 }
 
 void
 settings_dialog::read_varedit_colors (QSettings *settings)
 {
-  QList<QColor> default_colors = variable_editor::default_colors ();
-  QStringList class_names = variable_editor::color_names ();
+  QList<QColor> default_colors = octave::variable_editor::default_colors ();
+  QStringList class_names = octave::variable_editor::color_names ();
   QString class_chars = resource_manager::varedit_color_chars ();
   int nr_of_classes = class_chars.length ();
 
   QGridLayout *style_grid = new QGridLayout ();
   QVector<QLabel*> description (nr_of_classes);
   QVector<color_picker*> color (nr_of_classes);
 
   int column = 0;
diff --git a/libgui/src/variable-editor-model.cc b/libgui/src/variable-editor-model.cc
--- a/libgui/src/variable-editor-model.cc
+++ b/libgui/src/variable-editor-model.cc
@@ -79,1310 +79,1313 @@ get_edit_display_format (const octave_va
 
 static bool
 do_requires_sub_editor_sub (const octave_value& elt)
 {
   return (! ((elt.numel () == 1 && (elt.isnumeric () || elt.islogical ()))
              || (elt.is_string () && (elt.rows () == 1 || elt.isempty ()))));
 }
 
-base_ve_model::base_ve_model (const QString& expr, const octave_value& val)
-  : m_name (expr.toStdString ()),
-    m_value (val),
-    m_data_rows (m_value.rows ()),
-    m_data_cols (m_value.columns ()),
-    m_display_rows (m_data_rows),
-    m_display_cols (m_data_cols),
-    m_update_pending (),
-    m_valid (m_value.is_defined ()),
-    m_display_fmt (get_edit_display_format (m_value))
-{ }
-
-std::string
-base_ve_model::name (void) const
-{
-  return m_name;
-}
-
-bool
-base_ve_model::index_ok (const QModelIndex& idx, int& row, int& col) const
-{
-  row = 0;
-  col = 0;
-
-  if (! idx.isValid ())
-    return false;
-
-  row = idx.row ();
-  col = idx.column ();
-
-  return (row < data_rows () && col < data_columns ());
-}
-
-int
-base_ve_model::column_width (void) const
+namespace octave
 {
-  int width = 0;
-
-  float_format r_fmt = m_display_fmt.real_format ();
-  float_format i_fmt = m_display_fmt.imag_format ();
-
-  int rw = r_fmt.fw;
-  int iw = i_fmt.fw;
-
-  if (rw > 0)
-    {
-      if (m_value.iscomplex ())
-        {
-          if (iw > 0)
-            width = rw + iw + 5;
-        }
-      else
-        width = rw + 2;
-    }
-
-  return width;
-}
-
-int
-base_ve_model::rowCount (const QModelIndex&) const
-{
-  return m_valid ? m_display_rows : 1;
-}
-
-int
-base_ve_model::columnCount (const QModelIndex&) const
-{
-  return m_valid ? m_display_cols : 1;
-}
-
-QString
-base_ve_model::edit_display_sub (const octave_value& elt, int role) const
-{
-  std::string str;
-
-  if (cell_is_editable (elt))
-    {
-      float_display_format fmt;
-
-      if (role == Qt::DisplayRole)
-        fmt = get_edit_display_format (elt);
-      else
-        fmt.set_precision (elt.is_single_type () ? 8 : 16);
-
-      str = elt.edit_display (fmt, 0, 0);
-    }
-  else
-    {
-      dim_vector dv = elt.dims ();
-      str = "[" + dv.str () + " " + elt.class_name () + "]";
-    }
-
-  return QString::fromStdString (str);
-}
-
-QVariant
-base_ve_model::edit_display (const QModelIndex& idx, int role) const
-{
-  int row;
-  int col;
-
-  if (! index_ok (idx, row, col))
-    return QVariant ();
-
-  float_display_format fmt;
-  if (role == Qt::DisplayRole)
-    fmt = m_display_fmt;
-  else
-    fmt.set_precision (m_value.is_single_type () ? 8 : 16);
-
-  std::string str = m_value.edit_display (fmt, row, col);
-
-  return QString::fromStdString (str);
-}
-
-QVariant
-base_ve_model::data (const QModelIndex& idx, int role) const
-{
-  if (idx.isValid () && role == Qt::DisplayRole && update_pending (idx))
-    return QVariant (update_pending_data (idx));
+  base_ve_model::base_ve_model (const QString& expr, const octave_value& val)
+    : m_name (expr.toStdString ()),
+      m_value (val),
+      m_data_rows (m_value.rows ()),
+      m_data_cols (m_value.columns ()),
+      m_display_rows (m_data_rows),
+      m_display_cols (m_data_cols),
+      m_update_pending (),
+      m_valid (m_value.is_defined ()),
+      m_display_fmt (get_edit_display_format (m_value))
+  { }
 
-  if (! m_valid)
-    {
-      if (role == Qt::DisplayRole)
-        return QVariant (QString ("Variable %1 not found")
-                         .arg (QString::fromStdString (m_name)));
-
-      return QVariant (QString ("x"));
-    }
-
-  switch (role)
-    {
-    case Qt::DisplayRole:
-    case Qt::EditRole:
-      return edit_display (idx, role);
-      return edit_display (idx, role);
-
-#if 0
-    case Qt::StatusTipRole:
-      return elem (idx).m_status_tip;
-
-    case Qt::ToolTipRole:
-      return elem (idx).m_tool_tip;
-
-    case Qt::BackgroundRole:
-      return elem (idx).m_background;
-#endif
-    }
-
-  // Invalid.
-  return QVariant ();
-}
-
-bool
-base_ve_model::requires_sub_editor (const QModelIndex&) const
-{
-  return false;
-}
-
-void
-base_ve_model::set_update_pending (const QModelIndex& idx, const QString& str)
-{
-  m_update_pending[idx] = str;
-}
-
-bool
-base_ve_model::update_pending (const QModelIndex& idx) const
-{
-  return m_update_pending.contains (idx);
-}
-
-QString
-base_ve_model::update_pending_data (const QModelIndex& idx) const
-{
-  return m_update_pending[idx];
-}
-
-void
-base_ve_model::clear_update_pending (void)
-{
-  return m_update_pending.clear ();
-}
+  std::string
+  base_ve_model::name (void) const
+  {
+    return m_name;
+  }
 
-char
-base_ve_model::quote_char (const QModelIndex&) const
-{
-  return 0;
-}
-
-QVariant
-base_ve_model::header_data (int section, Qt::Orientation, int role) const
-{
-
-  if (role != Qt::DisplayRole)
-    return QVariant ();
-
-  return QString::number (section+1);
-}
-
-QString
-base_ve_model::subscript_expression (const QModelIndex&) const
-{
-  return "";
-}
-
-QString
-base_ve_model::make_description_text (void) const
-{
-  QString lbl_txt = QString::fromStdString (m_name);
-
-  if (m_value.is_defined ())
-    {
-      if (! lbl_txt.isEmpty ())
-        lbl_txt += " ";
+  bool
+  base_ve_model::index_ok (const QModelIndex& idx, int& row, int& col) const
+  {
+    row = 0;
+    col = 0;
 
-      dim_vector dv = m_value.dims ();
-
-      lbl_txt += ("["
-                  + QString::fromStdString (dv.str ())
-                  + " "
-                  + QString::fromStdString (m_value.class_name ())
-                  + "]");
-    }
-  else
-    lbl_txt += " [undefined]";
-
-  return lbl_txt;
-}
-
-// Private slots.
+    if (! idx.isValid ())
+      return false;
 
-octave_value
-base_ve_model::value_at (const QModelIndex&) const
-{
-  return octave_value ();
-}
+    row = idx.row ();
+    col = idx.column ();
 
-class numeric_model : public base_ve_model
-{
-public:
-
-  numeric_model (const QString& expr, const octave_value& val)
-    : base_ve_model (expr, val)
-  {
-    // FIXME: should fill the window and expand on scrolling or
-    // resizing.
-
-    maybe_resize_rows (m_data_rows + 16);
-    maybe_resize_columns (m_data_cols + 16);
+    return (row < data_rows () && col < data_columns ());
   }
 
-  ~numeric_model (void) = default;
+  int
+  base_ve_model::column_width (void) const
+  {
+    int width = 0;
 
-  // No copying!
+    float_format r_fmt = m_display_fmt.real_format ();
+    float_format i_fmt = m_display_fmt.imag_format ();
 
-  numeric_model (const numeric_model&) = delete;
+    int rw = r_fmt.fw;
+    int iw = i_fmt.fw;
 
-  numeric_model& operator = (const numeric_model&) = delete;
+    if (rw > 0)
+      {
+        if (m_value.iscomplex ())
+          {
+            if (iw > 0)
+              width = rw + iw + 5;
+          }
+        else
+          width = rw + 2;
+      }
 
-  void maybe_resize_rows (int rows)
-  {
-    if (rows > m_display_rows)
-      m_display_rows = rows;
+    return width;
   }
 
-  void maybe_resize_columns (int cols)
+  int
+  base_ve_model::rowCount (const QModelIndex&) const
   {
-    if (cols > m_display_cols)
-      m_display_cols = cols;
+    return m_valid ? m_display_rows : 1;
+  }
+
+  int
+  base_ve_model::columnCount (const QModelIndex&) const
+  {
+    return m_valid ? m_display_cols : 1;
   }
 
-  QVariant edit_display (const QModelIndex& idx, int role) const
+  QString
+  base_ve_model::edit_display_sub (const octave_value& elt, int role) const
   {
-    int row;
-    int col;
+    std::string str;
 
-    if (! index_ok (idx, row, col))
-      return QVariant ();
+    if (cell_is_editable (elt))
+      {
+        float_display_format fmt;
 
-  float_display_format fmt;
-  if (role == Qt::DisplayRole)
-    fmt = m_display_fmt;
-  else
-    fmt.set_precision (m_value.is_single_type () ? 8 : 16);
+        if (role == Qt::DisplayRole)
+          fmt = get_edit_display_format (elt);
+        else
+          fmt.set_precision (elt.is_single_type () ? 8 : 16);
 
-  std::string str = m_value.edit_display (fmt, row, col);
+        str = elt.edit_display (fmt, 0, 0);
+      }
+    else
+      {
+        dim_vector dv = elt.dims ();
+        str = "[" + dv.str () + " " + elt.class_name () + "]";
+      }
 
     return QString::fromStdString (str);
   }
 
-  QString subscript_expression (const QModelIndex& idx) const
-  {
-    if (! idx.isValid ())
-      return "";
-
-    return (QString ("(%1,%2)")
-            .arg (idx.row () + 1)
-            .arg (idx.column () + 1));
-  }
-};
-
-class string_model : public base_ve_model
-{
-public:
-
-  string_model (const QString& expr, const octave_value& val)
-    : base_ve_model (expr, val)
-  {
-    m_data_rows = 1;
-    m_data_cols = 1;
-
-    m_display_rows = 1;
-    m_display_cols = 1;
-  }
-
-  ~string_model (void) = default;
-
-  // No copying!
-
-  string_model (const string_model&) = delete;
-
-  string_model& operator = (const string_model&) = delete;
-
-  QVariant edit_display (const QModelIndex&, int) const
-  {
-    // There isn't really a format for strings...
-
-    std::string str = m_value.edit_display (float_display_format (), 0, 0);
-
-    return QString::fromStdString (str);
-  }
-
-  char quote_char (const QModelIndex&) const
-  {
-    return get_quote_char (m_value);
-  }
-};
-
-class cell_model : public base_ve_model
-{
-public:
-
-  cell_model (const QString& expr, const octave_value& val)
-    : base_ve_model (expr, val)
-  {
-    // FIXME: should fill the window and expand on scrolling or
-    // resizing.
-
-    maybe_resize_rows (m_data_rows + 16);
-    maybe_resize_columns (m_data_cols + 16);
-  }
-
-  ~cell_model (void) = default;
-
-  // No copying!
-
-  cell_model (const cell_model&) = delete;
-
-  cell_model& operator = (const cell_model&) = delete;
-
-  void maybe_resize_rows (int rows)
-  {
-    if (rows > m_display_rows)
-      m_display_rows = rows;
-  }
-
-  void maybe_resize_columns (int cols)
-  {
-    if (cols > m_display_cols)
-      m_display_cols = cols;
-  }
-
-  QVariant edit_display (const QModelIndex& idx, int role) const
-  {
-    int row;
-    int col;
-
-    if (! index_ok (idx, row, col))
-      return QVariant ();
-
-    Cell cval = m_value.cell_value ();
-
-    return edit_display_sub (cval(row,col), role);
-  }
-
-  bool requires_sub_editor (const QModelIndex& idx) const
-  {
-    int row;
-    int col;
-
-    if (! index_ok (idx, row, col))
-      return false;
-
-    Cell cval = m_value.cell_value ();
-
-    return do_requires_sub_editor_sub (cval(row,col));
-  }
-
-  char quote_char (const QModelIndex& idx) const
-  {
-    octave_value ov = value_at (idx);
-
-    if (ov.is_string ())
-      return get_quote_char (ov);
-
-    return 0;
-  }
-
-  QString subscript_expression (const QModelIndex& idx) const
-  {
-    if (! idx.isValid ())
-      return "";
-
-    return (QString ("{%1,%2}")
-            .arg (idx.row () + 1)
-            .arg (idx.column () + 1));
-  }
-
-  octave_value value_at (const QModelIndex& idx) const
-  {
-    int row;
-    int col;
-
-    if (! index_ok (idx, row, col))
-      return octave_value ();
-
-    Cell cval = m_value.cell_value ();
-
-    return cval(row,col);
-  }
-};
-
-// Scalar struct.  Rows are fields, single column for values.
-
-class scalar_struct_model : public base_ve_model
-{
-public:
-
-  scalar_struct_model (const QString& expr, const octave_value& val)
-    : base_ve_model (expr, val)
-  {
-    // No extra cells.  We currently don't allow new fields or
-    // additional values to be inserted.  If we allow additional values,
-    // then the object becomes a vector structure and the display flips
-    // (see the vector struct model below).  Do we want that?
-
-    m_data_rows = val.nfields ();
-    m_data_cols = 1;
-
-    m_display_rows = m_data_rows;
-    m_display_cols = 1;
-  }
-
-  ~scalar_struct_model (void) = default;
-
-  // No copying!
-
-  scalar_struct_model (const scalar_struct_model&) = delete;
-
-  scalar_struct_model& operator = (const scalar_struct_model&) = delete;
-
-  QVariant edit_display (const QModelIndex& idx, int role) const
-  {
-    int row;
-    int col;
-
-    if (! index_ok (idx, row, col))
-      return QVariant ();
-
-    octave_scalar_map m = m_value.scalar_map_value ();
-
-    return edit_display_sub (m.contents (row), role);
-  }
-
-  bool requires_sub_editor (const QModelIndex& idx) const
-  {
-    int row;
-    int col;
-
-    if (! index_ok (idx, row, col))
-      return false;
-
-    octave_scalar_map m = m_value.scalar_map_value ();
-
-    return do_requires_sub_editor_sub (m.contents (row));
-  }
-
-  char quote_char (const QModelIndex& idx) const
-  {
-    octave_value ov = value_at (idx);
-
-    if (ov.is_string ())
-      return get_quote_char (ov);
-
-    return 0;
-  }
-
-  QVariant header_data (int section, Qt::Orientation orientation,
-                        int role) const
-  {
-    if (role != Qt::DisplayRole)
-      return QVariant ();
-
-    switch (orientation)
-      {
-      case Qt::Horizontal:
-        if (section < data_columns ())
-          return QString ("Values");
-        else
-          break;
-
-      case Qt::Vertical:
-        if (section < data_rows ())
-          {
-            octave_scalar_map m = m_value.scalar_map_value ();
-
-            string_vector fields = m.fieldnames ();
-
-            return QString::fromStdString (fields(section));
-          }
-        else
-          break;
-
-      default:
-        break;
-      }
-
-    return QVariant ();
-  }
-
-  QString subscript_expression (const QModelIndex& idx) const
-  {
-    // Display size and data size match, so all valid indices should
-    // also be valid indices for the existing struct.
-
-    int row;
-    int col;
-
-    if (! index_ok (idx, row, col))
-      return "";
-
-    octave_scalar_map m = m_value.scalar_map_value ();
-
-    string_vector fields = m.fieldnames ();
-
-    return QString (".%1").arg (QString::fromStdString (fields(row)));
-  }
-
-  octave_value value_at (const QModelIndex& idx) const
-  {
-    int row;
-    int col;
-
-    if (! index_ok (idx, row, col))
-      return octave_value ();
-
-    octave_scalar_map m = m_value.scalar_map_value ();
-
-    return m.contents (row);
-  }
-};
-
-class display_only_model : public base_ve_model
-{
-public:
-
-  display_only_model (const QString& expr, const octave_value& val)
-    : base_ve_model (expr, val)
-  {
-    m_data_rows = 1;
-    m_data_cols = 1;
-
-    m_display_rows = m_data_rows;
-    m_display_cols = m_data_cols;
-  }
-
-  ~display_only_model (void) = default;
-
-  // No copying!
-
-  display_only_model (const display_only_model&) = delete;
-
-  display_only_model& operator = (const display_only_model&) = delete;
-
-  bool is_editable (void) const { return false; }
-
-  QVariant edit_display (const QModelIndex&, int) const
-  {
-    if (m_value.is_undefined ())
-      return QVariant ();
-
-    std::ostringstream buf;
-
-    octave_value tval = m_value;
-
-    tval.print_with_name (buf, m_name);
-
-    return QString::fromStdString (buf.str ());
-  }
-
-  QString make_description_text (void) const
-  {
-    return (QString ("unable to edit %1")
-            .arg (base_ve_model::make_description_text ()));
-  }
-};
-
-// Vector struct.  Columns are fields, rows are values.
-
-class vector_struct_model : public base_ve_model
-{
-public:
-
-  vector_struct_model (const QString& expr, const octave_value& val)
-    : base_ve_model (expr, val)
-  {
-    // FIXME: should fill the window vertically and expand on scrolling
-    // or resizing.  No extra cells horizontally.  New fields must be
-    // added specially.
-
-    m_data_rows = val.numel ();
-    m_data_cols = val.nfields ();
-
-    maybe_resize_rows (m_data_rows + 16);
-  }
-
-  ~vector_struct_model (void) = default;
-
-  // No copying!
-
-  vector_struct_model (const vector_struct_model&) = delete;
-
-  vector_struct_model& operator = (const vector_struct_model&) = delete;
-
-  void maybe_resize_rows (int rows)
-  {
-    if (rows > m_display_rows)
-      m_display_rows = rows;
-  }
-
-  QVariant edit_display (const QModelIndex& idx, int role) const
+  QVariant
+  base_ve_model::edit_display (const QModelIndex& idx, int role) const
   {
     int row;
     int col;
 
     if (! index_ok (idx, row, col))
       return QVariant ();
 
-    octave_map m = m_value.map_value ();
-
-    Cell cval = m.contents (col);
-
-    return edit_display_sub (cval(row), role);
-  }
+    float_display_format fmt;
+    if (role == Qt::DisplayRole)
+      fmt = m_display_fmt;
+    else
+      fmt.set_precision (m_value.is_single_type () ? 8 : 16);
 
-  bool requires_sub_editor (const QModelIndex& idx) const
-  {
-    int row;
-    int col;
+    std::string str = m_value.edit_display (fmt, row, col);
 
-    if (! index_ok (idx, row, col))
-      return false;
-
-    octave_map m = m_value.map_value ();
-
-    Cell cval = m.contents (col);
-
-    return do_requires_sub_editor_sub (cval(row));
+    return QString::fromStdString (str);
   }
 
-  char quote_char (const QModelIndex& idx) const
+  QVariant
+  base_ve_model::data (const QModelIndex& idx, int role) const
   {
-    octave_value ov = value_at (idx);
-
-    if (ov.is_string ())
-      return get_quote_char (ov);
+    if (idx.isValid () && role == Qt::DisplayRole && update_pending (idx))
+      return QVariant (update_pending_data (idx));
 
-    return 0;
-  }
-
-  QVariant header_data (int section, Qt::Orientation orientation,
-                        int role) const
-  {
-    if (role != Qt::DisplayRole)
-      return QVariant ();
-
-    switch (orientation)
+    if (! m_valid)
       {
-      case Qt::Horizontal:
-        if (section < data_columns ())
-          {
-            octave_map m = m_value.map_value ();
-
-            string_vector fields = m.fieldnames ();
+        if (role == Qt::DisplayRole)
+          return QVariant (QString ("Variable %1 not found")
+                           .arg (QString::fromStdString (m_name)));
 
-            return QString::fromStdString (fields(section));
-          }
-        else
-          break;
-
-      case Qt::Vertical:
-        if (section < data_rows ())
-          return QString::number (section+1);
-        else
-          break;
-
-      default:
-        break;
+        return QVariant (QString ("x"));
       }
 
+    switch (role)
+      {
+      case Qt::DisplayRole:
+      case Qt::EditRole:
+        return edit_display (idx, role);
+        return edit_display (idx, role);
+
+#if 0
+      case Qt::StatusTipRole:
+        return elem (idx).m_status_tip;
+
+      case Qt::ToolTipRole:
+        return elem (idx).m_tool_tip;
+
+      case Qt::BackgroundRole:
+        return elem (idx).m_background;
+#endif
+      }
+
+    // Invalid.
     return QVariant ();
   }
 
-  QString subscript_expression (const QModelIndex& idx) const
+  bool
+  base_ve_model::requires_sub_editor (const QModelIndex&) const
   {
-    if (! idx.isValid ())
-      return "";
-
-    octave_map m = m_value.map_value ();
-
-    string_vector fields = m.fieldnames ();
-
-    return (QString ("(%1).%2")
-            .arg (idx.row () + 1)
-            .arg (QString::fromStdString (fields(idx.column ()))));
+    return false;
   }
 
-  octave_value value_at (const QModelIndex& idx) const
+  void
+  base_ve_model::set_update_pending (const QModelIndex& idx, const QString& str)
   {
-    int row;
-    int col;
-
-    if (! index_ok (idx, row, col))
-      return octave_value ();
-
-    octave_map m = m_value.map_value ();
-
-    Cell cval = m.contents (col);
-
-    return cval(row);
-  }
-};
-
-// 2-d struct array.  Rows and columns index individual scalar structs.
-
-class struct_model : public base_ve_model
-{
-public:
-
-  struct_model (const QString& expr, const octave_value& val)
-    : base_ve_model (expr, val)
-  {
-    // FIXME: should fill the window and expand on scrolling or
-    // resizing.
-
-    maybe_resize_rows (m_data_rows + 16);
-    maybe_resize_columns (m_data_cols + 16);
+    m_update_pending[idx] = str;
   }
 
-  ~struct_model (void) = default;
-
-  // No copying!
-
-  struct_model (const struct_model&) = delete;
-
-  struct_model& operator = (const struct_model&) = delete;
-
-  void maybe_resize_rows (int rows)
+  bool
+  base_ve_model::update_pending (const QModelIndex& idx) const
   {
-    if (rows > m_display_rows)
-      m_display_rows = rows;
-  }
-
-  void maybe_resize_columns (int cols)
-  {
-    if (cols > m_display_cols)
-      m_display_cols = cols;
+    return m_update_pending.contains (idx);
   }
 
-  QVariant edit_display (const QModelIndex& idx, int) const
+  QString
+  base_ve_model::update_pending_data (const QModelIndex& idx) const
   {
-    int row;
-    int col;
-
-    if (! index_ok (idx, row, col))
-      return QVariant ();
-
-    std::string str = m_value.edit_display (m_display_fmt, row, col);
-    return QString::fromStdString (str);
+    return m_update_pending[idx];
   }
 
-  bool requires_sub_editor (const QModelIndex& idx) const
+  void
+  base_ve_model::clear_update_pending (void)
   {
-    int row;
-    int col;
-
-    if (! index_ok (idx, row, col))
-      return false;
-
-    octave_map m = m_value.map_value ();
-
-    return do_requires_sub_editor_sub (m(row,col));
+    return m_update_pending.clear ();
   }
 
-  char quote_char (const QModelIndex& idx) const
+  char
+  base_ve_model::quote_char (const QModelIndex&) const
   {
-    octave_value ov = value_at (idx);
-
-    if (ov.is_string ())
-      return get_quote_char (ov);
-
     return 0;
   }
 
-  QString subscript_expression (const QModelIndex& idx) const
+  QVariant
+  base_ve_model::header_data (int section, Qt::Orientation, int role) const
   {
-    int row;
-    int col;
+
+    if (role != Qt::DisplayRole)
+      return QVariant ();
+
+    return QString::number (section+1);
+  }
+
+  QString
+  base_ve_model::subscript_expression (const QModelIndex&) const
+  {
+    return "";
+  }
+
+  QString
+  base_ve_model::make_description_text (void) const
+  {
+    QString lbl_txt = QString::fromStdString (m_name);
 
-    if (! index_ok (idx, row, col))
-      return "";
+    if (m_value.is_defined ())
+      {
+        if (! lbl_txt.isEmpty ())
+          lbl_txt += " ";
+
+        dim_vector dv = m_value.dims ();
 
-    return (QString ("(%1,%2)")
-            .arg (row + 1)
-            .arg (col + 1));
+        lbl_txt += ("["
+                    + QString::fromStdString (dv.str ())
+                    + " "
+                    + QString::fromStdString (m_value.class_name ())
+                    + "]");
+      }
+    else
+      lbl_txt += " [undefined]";
+
+    return lbl_txt;
+  }
+
+  // Private slots.
+
+  octave_value
+  base_ve_model::value_at (const QModelIndex&) const
+  {
+    return octave_value ();
   }
 
-  octave_value value_at (const QModelIndex& idx) const
+  class numeric_model : public base_ve_model
   {
-    int row;
-    int col;
+  public:
+
+    numeric_model (const QString& expr, const octave_value& val)
+      : base_ve_model (expr, val)
+    {
+      // FIXME: should fill the window and expand on scrolling or
+      // resizing.
+
+      maybe_resize_rows (m_data_rows + 16);
+      maybe_resize_columns (m_data_cols + 16);
+    }
+
+    ~numeric_model (void) = default;
+
+    // No copying!
+
+    numeric_model (const numeric_model&) = delete;
+
+    numeric_model& operator = (const numeric_model&) = delete;
+
+    void maybe_resize_rows (int rows)
+    {
+      if (rows > m_display_rows)
+        m_display_rows = rows;
+    }
+
+    void maybe_resize_columns (int cols)
+    {
+      if (cols > m_display_cols)
+        m_display_cols = cols;
+    }
+
+    QVariant edit_display (const QModelIndex& idx, int role) const
+    {
+      int row;
+      int col;
+
+      if (! index_ok (idx, row, col))
+        return QVariant ();
+
+      float_display_format fmt;
+      if (role == Qt::DisplayRole)
+        fmt = m_display_fmt;
+      else
+        fmt.set_precision (m_value.is_single_type () ? 8 : 16);
+
+      std::string str = m_value.edit_display (fmt, row, col);
 
-    if (! index_ok (idx, row, col))
-      return octave_value ();
+      return QString::fromStdString (str);
+    }
+
+    QString subscript_expression (const QModelIndex& idx) const
+    {
+      if (! idx.isValid ())
+        return "";
+
+      return (QString ("(%1,%2)")
+              .arg (idx.row () + 1)
+              .arg (idx.column () + 1));
+    }
+  };
+
+  class string_model : public base_ve_model
+  {
+  public:
+
+    string_model (const QString& expr, const octave_value& val)
+      : base_ve_model (expr, val)
+    {
+      m_data_rows = 1;
+      m_data_cols = 1;
 
-    octave_map m = m_value.map_value ();
+      m_display_rows = 1;
+      m_display_cols = 1;
+    }
+
+    ~string_model (void) = default;
+
+    // No copying!
+
+    string_model (const string_model&) = delete;
+
+    string_model& operator = (const string_model&) = delete;
 
-    return m(row,col);
-  }
-};
+    QVariant edit_display (const QModelIndex&, int) const
+    {
+      // There isn't really a format for strings...
+
+      std::string str = m_value.edit_display (float_display_format (), 0, 0);
+
+      return QString::fromStdString (str);
+    }
+
+    char quote_char (const QModelIndex&) const
+    {
+      return get_quote_char (m_value);
+    }
+  };
+
+  class cell_model : public base_ve_model
+  {
+  public:
 
-base_ve_model *
-variable_editor_model::create (const QString& expr, const octave_value& val)
-{
-  // Choose specific model based on type of val.
+    cell_model (const QString& expr, const octave_value& val)
+      : base_ve_model (expr, val)
+    {
+      // FIXME: should fill the window and expand on scrolling or
+      // resizing.
+
+      maybe_resize_rows (m_data_rows + 16);
+      maybe_resize_columns (m_data_cols + 16);
+    }
+
+    ~cell_model (void) = default;
+
+    // No copying!
+
+    cell_model (const cell_model&) = delete;
+
+    cell_model& operator = (const cell_model&) = delete;
+
+    void maybe_resize_rows (int rows)
+    {
+      if (rows > m_display_rows)
+        m_display_rows = rows;
+    }
+
+    void maybe_resize_columns (int cols)
+    {
+      if (cols > m_display_cols)
+        m_display_cols = cols;
+    }
+
+    QVariant edit_display (const QModelIndex& idx, int role) const
+    {
+      int row;
+      int col;
+
+      if (! index_ok (idx, row, col))
+        return QVariant ();
+
+      Cell cval = m_value.cell_value ();
+
+      return edit_display_sub (cval(row,col), role);
+    }
+
+    bool requires_sub_editor (const QModelIndex& idx) const
+    {
+      int row;
+      int col;
+
+      if (! index_ok (idx, row, col))
+        return false;
+
+      Cell cval = m_value.cell_value ();
 
-  if ((val.isnumeric () || val.islogical ()) && val.ndims () == 2)
-    return new numeric_model (expr, val);
-  else if (val.is_string () && (val.rows () == 1 || val.is_zero_by_zero ()))
-    return new string_model (expr, val);
-  else if (val.iscell ())
-    return new cell_model (expr, val);
-  else if (val.isstruct ())
+      return do_requires_sub_editor_sub (cval(row,col));
+    }
+
+    char quote_char (const QModelIndex& idx) const
+    {
+      octave_value ov = value_at (idx);
+
+      if (ov.is_string ())
+        return get_quote_char (ov);
+
+      return 0;
+    }
+
+    QString subscript_expression (const QModelIndex& idx) const
+    {
+      if (! idx.isValid ())
+        return "";
+
+      return (QString ("{%1,%2}")
+              .arg (idx.row () + 1)
+              .arg (idx.column () + 1));
+    }
+
+    octave_value value_at (const QModelIndex& idx) const
     {
-      if (val.numel () == 1)
-        return new scalar_struct_model (expr, val);
-      else if (val.ndims () == 2)
-        {
-          if (val.rows () == 1 || val.columns () == 1)
-            return new vector_struct_model (expr, val);
-          else
-            return new struct_model (expr, val);
-        }
+      int row;
+      int col;
+
+      if (! index_ok (idx, row, col))
+        return octave_value ();
+
+      Cell cval = m_value.cell_value ();
+
+      return cval(row,col);
+    }
+  };
+
+  // Scalar struct.  Rows are fields, single column for values.
+
+  class scalar_struct_model : public base_ve_model
+  {
+  public:
+
+    scalar_struct_model (const QString& expr, const octave_value& val)
+      : base_ve_model (expr, val)
+    {
+      // No extra cells.  We currently don't allow new fields or
+      // additional values to be inserted.  If we allow additional values,
+      // then the object becomes a vector structure and the display flips
+      // (see the vector struct model below).  Do we want that?
+
+      m_data_rows = val.nfields ();
+      m_data_cols = 1;
+
+      m_display_rows = m_data_rows;
+      m_display_cols = 1;
     }
 
-  return new display_only_model (expr, val);
-}
+    ~scalar_struct_model (void) = default;
+
+    // No copying!
+
+    scalar_struct_model (const scalar_struct_model&) = delete;
 
-variable_editor_model::variable_editor_model (const QString& expr,
-                                              const octave_value& val,
-                                              QObject *parent)
-  : QAbstractTableModel (parent), rep (create (expr, val))
-{
-  update_description ();
+    scalar_struct_model& operator = (const scalar_struct_model&) = delete;
 
-  connect (this, SIGNAL (user_error_signal (const QString&, const QString&)),
-           this, SLOT (user_error (const QString&, const QString&)));
+    QVariant edit_display (const QModelIndex& idx, int role) const
+    {
+      int row;
+      int col;
 
-  connect (this, SIGNAL (update_data_signal (const octave_value&)),
-           this, SLOT (update_data (const octave_value&)));
+      if (! index_ok (idx, row, col))
+        return QVariant ();
+
+      octave_scalar_map m = m_value.scalar_map_value ();
 
-  connect (this, SIGNAL (data_error_signal (const QString&)),
-           this, SLOT (data_error (const QString&)));
+      return edit_display_sub (m.contents (row), role);
+    }
 
-  if (is_editable ())
+    bool requires_sub_editor (const QModelIndex& idx) const
     {
-      beginInsertRows (QModelIndex (), 0, display_rows () - 1);
-      endInsertRows ();
+      int row;
+      int col;
 
-      beginInsertColumns (QModelIndex (), 0, display_columns () - 1);
-      endInsertColumns ();
-    }
-}
+      if (! index_ok (idx, row, col))
+        return false;
 
-bool
-variable_editor_model::setData (const QModelIndex& idx,
-                                const QVariant& v_user_input, int role)
-{
-  if (role != Qt::EditRole || ! v_user_input.canConvert (QVariant::String)
-      || ! idx.isValid ())
-    return false;
+      octave_scalar_map m = m_value.scalar_map_value ();
+
+      return do_requires_sub_editor_sub (m.contents (row));
+    }
 
-  // Initially, set value to whatever the user entered.
+    char quote_char (const QModelIndex& idx) const
+    {
+      octave_value ov = value_at (idx);
 
-  QString user_input = v_user_input.toString ();
-
-  char qc = quote_char (idx);
+      if (ov.is_string ())
+        return get_quote_char (ov);
 
-  // FIXME: maybe we need a better way to ask whether empty input is
-  // valid than to rely on whether there is a quote character (meaning
-  // we are editing a character string)?
-  if (user_input.isEmpty () && ! qc)
-    return false;
-
-  set_update_pending (idx, user_input);
+      return 0;
+    }
 
-  std::ostringstream os;
-
-  std::string nm = name ();
-  os << nm;
+    QVariant header_data (int section, Qt::Orientation orientation,
+                          int role) const
+    {
+      if (role != Qt::DisplayRole)
+        return QVariant ();
 
-  QString tmp = subscript_expression (idx);
-  os << tmp.toStdString () << "=";
-
-  if (qc)
-    os << qc;
+      switch (orientation)
+        {
+        case Qt::Horizontal:
+          if (section < data_columns ())
+            return QString ("Values");
+          else
+            break;
 
-  os << user_input.toStdString ();
+        case Qt::Vertical:
+          if (section < data_rows ())
+            {
+              octave_scalar_map m = m_value.scalar_map_value ();
 
-  if (qc)
-    os << qc;
+              string_vector fields = m.fieldnames ();
 
-  std::string expr = os.str ();
+              return QString::fromStdString (fields(section));
+            }
+          else
+            break;
 
-  octave_link::post_event<variable_editor_model, std::string, std::string, QModelIndex>
-    (this, &variable_editor_model::set_data_oct, nm, expr, idx);
-
-  return true;
-}
+        default:
+          break;
+        }
 
-bool
-variable_editor_model::clear_content (const QModelIndex& idx)
-{
-  int row = idx.row ();
-  int col = idx.column ();
+      return QVariant ();
+    }
 
-  if (row < data_rows () && col < data_columns ())
-    return setData (idx, QVariant ("0"));
+    QString subscript_expression (const QModelIndex& idx) const
+    {
+      // Display size and data size match, so all valid indices should
+      // also be valid indices for the existing struct.
 
-  return false;
-}
+      int row;
+      int col;
 
-Qt::ItemFlags
-variable_editor_model::flags (const QModelIndex& idx) const
-{
-  if (! is_valid ())
-    return Qt::NoItemFlags;
+      if (! index_ok (idx, row, col))
+        return "";
+
+      octave_scalar_map m = m_value.scalar_map_value ();
 
-  Qt::ItemFlags retval = QAbstractTableModel::flags (idx);
+      string_vector fields = m.fieldnames ();
 
-  if (! requires_sub_editor (idx))
-    retval |= Qt::ItemIsEditable;
+      return QString (".%1").arg (QString::fromStdString (fields(row)));
+    }
 
-  return retval;
-}
+    octave_value value_at (const QModelIndex& idx) const
+    {
+      int row;
+      int col;
 
-bool
-variable_editor_model::insertRows (int row, int count, const QModelIndex&)
-{
-  // FIXME: cells?
+      if (! index_ok (idx, row, col))
+        return octave_value ();
+
+      octave_scalar_map m = m_value.scalar_map_value ();
 
-  octave_link::post_event <variable_editor_model, std::string, std::string>
-    (this, &variable_editor_model::eval_oct, name (),
-     QString ("%1 = [ %1(1:%2,:) ; zeros(%3, columns(%1)) ; %1(%2+%3:end,:) ]")
-     .arg (QString::fromStdString (name ()))
-     .arg (row)
-     .arg (count)
-     .toStdString ());
+      return m.contents (row);
+    }
+  };
+
+  class display_only_model : public base_ve_model
+  {
+  public:
 
-  return true;
-}
+    display_only_model (const QString& expr, const octave_value& val)
+      : base_ve_model (expr, val)
+    {
+      m_data_rows = 1;
+      m_data_cols = 1;
 
-bool
-variable_editor_model::removeRows (int row, int count, const QModelIndex&)
-{
-  if (row + count > data_rows ())
-    {
-      qDebug () << "Tried to remove too many rows "
-                << data_rows () << " "
-                << count << " (" << row << ")";
-      return false;
+      m_display_rows = m_data_rows;
+      m_display_cols = m_data_cols;
     }
 
-  octave_link::post_event <variable_editor_model, std::string, std::string>
-    (this, &variable_editor_model::eval_oct, name (),
-     QString ("%1(%2:%3, :) = []")
-     .arg (QString::fromStdString (name ()))
-     .arg (row)
-     .arg (row + count)
-     .toStdString ());
+    ~display_only_model (void) = default;
+
+    // No copying!
+
+    display_only_model (const display_only_model&) = delete;
+
+    display_only_model& operator = (const display_only_model&) = delete;
+
+    bool is_editable (void) const { return false; }
+
+    QVariant edit_display (const QModelIndex&, int) const
+    {
+      if (m_value.is_undefined ())
+        return QVariant ();
+
+      std::ostringstream buf;
+
+      octave_value tval = m_value;
+
+      tval.print_with_name (buf, m_name);
+
+      return QString::fromStdString (buf.str ());
+    }
+
+    QString make_description_text (void) const
+    {
+      return (QString ("unable to edit %1")
+              .arg (base_ve_model::make_description_text ()));
+    }
+  };
+
+  // Vector struct.  Columns are fields, rows are values.
+
+  class vector_struct_model : public base_ve_model
+  {
+  public:
 
-  return true;
-}
+    vector_struct_model (const QString& expr, const octave_value& val)
+      : base_ve_model (expr, val)
+    {
+      // FIXME: should fill the window vertically and expand on scrolling
+      // or resizing.  No extra cells horizontally.  New fields must be
+      // added specially.
+
+      m_data_rows = val.numel ();
+      m_data_cols = val.nfields ();
+
+      maybe_resize_rows (m_data_rows + 16);
+    }
+
+    ~vector_struct_model (void) = default;
+
+    // No copying!
+
+    vector_struct_model (const vector_struct_model&) = delete;
+
+    vector_struct_model& operator = (const vector_struct_model&) = delete;
+
+    void maybe_resize_rows (int rows)
+    {
+      if (rows > m_display_rows)
+        m_display_rows = rows;
+    }
+
+    QVariant edit_display (const QModelIndex& idx, int role) const
+    {
+      int row;
+      int col;
+
+      if (! index_ok (idx, row, col))
+        return QVariant ();
+
+      octave_map m = m_value.map_value ();
 
-bool
-variable_editor_model::insertColumns (int col, int count, const QModelIndex&)
-{
-  octave_link::post_event <variable_editor_model, std::string, std::string>
-    (this, &variable_editor_model::eval_oct, name (),
-     QString ("%1 = [ %1(:,1:%2) ; zeros(rows(%1), %3) %1(:,%2+%3:end) ]")
-     .arg (QString::fromStdString (name ()))
-     .arg (col)
-     .arg (count)
-     .toStdString ());
+      Cell cval = m.contents (col);
+
+      return edit_display_sub (cval(row), role);
+    }
+
+    bool requires_sub_editor (const QModelIndex& idx) const
+    {
+      int row;
+      int col;
+
+      if (! index_ok (idx, row, col))
+        return false;
+
+      octave_map m = m_value.map_value ();
+
+      Cell cval = m.contents (col);
+
+      return do_requires_sub_editor_sub (cval(row));
+    }
+
+    char quote_char (const QModelIndex& idx) const
+    {
+      octave_value ov = value_at (idx);
+
+      if (ov.is_string ())
+        return get_quote_char (ov);
+
+      return 0;
+    }
+
+    QVariant header_data (int section, Qt::Orientation orientation,
+                          int role) const
+    {
+      if (role != Qt::DisplayRole)
+        return QVariant ();
 
-  return true;
-}
+      switch (orientation)
+        {
+        case Qt::Horizontal:
+          if (section < data_columns ())
+            {
+              octave_map m = m_value.map_value ();
+
+              string_vector fields = m.fieldnames ();
+
+              return QString::fromStdString (fields(section));
+            }
+          else
+            break;
+
+        case Qt::Vertical:
+          if (section < data_rows ())
+            return QString::number (section+1);
+          else
+            break;
 
-bool
-variable_editor_model::removeColumns (int col, int count, const QModelIndex&)
-{
-  if (col + count > data_columns ())
+        default:
+          break;
+        }
+
+      return QVariant ();
+    }
+
+    QString subscript_expression (const QModelIndex& idx) const
     {
-      qDebug () << "Tried to remove too many cols "
-                << data_columns () << " "
-                << count << " (" << col << ")";
-      return false;
+      if (! idx.isValid ())
+        return "";
+
+      octave_map m = m_value.map_value ();
+
+      string_vector fields = m.fieldnames ();
+
+      return (QString ("(%1).%2")
+              .arg (idx.row () + 1)
+              .arg (QString::fromStdString (fields(idx.column ()))));
     }
 
-  octave_link::post_event <variable_editor_model, std::string, std::string>
-    (this, &variable_editor_model::eval_oct, name (),
-     QString ("%1(:, %2:%3) = []")
-     .arg (QString::fromStdString (name ()))
-     .arg (col)
-     .arg (col + count)
-     .toStdString ());
+    octave_value value_at (const QModelIndex& idx) const
+    {
+      int row;
+      int col;
 
-  return true;
-}
+      if (! index_ok (idx, row, col))
+        return octave_value ();
+
+      octave_map m = m_value.map_value ();
 
-void
-variable_editor_model::set_data_oct (const std::string& name,
-                                     const std::string& expr,
-                                     const QModelIndex& idx)
-{
-  // INTERPRETER THREAD
+      Cell cval = m.contents (col);
+
+      return cval(row);
+    }
+  };
 
-  try
-    {
-      int parse_status = 0;
+  // 2-d struct array.  Rows and columns index individual scalar structs.
 
-      octave::eval_string (expr, true, parse_status);
-
-      octave_value val = retrieve_variable (name);
+  class struct_model : public base_ve_model
+  {
+  public:
 
-      emit update_data_signal (val);
-    }
-  catch (octave::execution_exception&)
+    struct_model (const QString& expr, const octave_value& val)
+      : base_ve_model (expr, val)
     {
-      clear_update_pending ();
+      // FIXME: should fill the window and expand on scrolling or
+      // resizing.
 
-      evaluation_error (expr);
-
-      // This will cause the data in the cell to be reset
-      // from the cached octave_value object.
-
-      emit dataChanged (idx, idx);
+      maybe_resize_rows (m_data_rows + 16);
+      maybe_resize_columns (m_data_cols + 16);
     }
-}
+
+    ~struct_model (void) = default;
+
+    // No copying!
+
+    struct_model (const struct_model&) = delete;
 
-void
-variable_editor_model::init_from_oct (const std::string& name)
-{
-  // INTERPRETER THREAD
+    struct_model& operator = (const struct_model&) = delete;
 
-  try
+    void maybe_resize_rows (int rows)
     {
-      octave_value val = retrieve_variable (name);
-
-      emit update_data_signal (val);
+      if (rows > m_display_rows)
+        m_display_rows = rows;
     }
-  catch (octave::execution_exception&)
+
+    void maybe_resize_columns (int cols)
     {
-      QString msg = (QString ("variable '%1' is invalid or undefined")
-                     .arg (QString::fromStdString (name)));
-
-      emit data_error_signal (msg);
+      if (cols > m_display_cols)
+        m_display_cols = cols;
     }
-}
 
-void
-variable_editor_model::eval_oct (const std::string& name,
-                                 const std::string& expr)
-{
-  // INTERPRETER THREAD
-
-  try
+    QVariant edit_display (const QModelIndex& idx, int) const
     {
-      int parse_status = 0;
-
-      octave::eval_string (expr, true, parse_status);
+      int row;
+      int col;
 
-      init_from_oct (name);
-    }
-  catch  (octave::execution_exception&)
-    {
-      evaluation_error (expr);
+      if (! index_ok (idx, row, col))
+        return QVariant ();
+
+      std::string str = m_value.edit_display (m_display_fmt, row, col);
+      return QString::fromStdString (str);
     }
-}
+
+    bool requires_sub_editor (const QModelIndex& idx) const
+    {
+      int row;
+      int col;
+
+      if (! index_ok (idx, row, col))
+        return false;
 
-// If the variable exists, load it into the data model.  If it doesn't
-// exist, flag the data model as referring to a nonexistent variable.
-// This allows the variable to be opened before it is created.
+      octave_map m = m_value.map_value ();
 
-// This function should only be called within other functions that
-// execute in the interpreter thread.  It should also be called in a
-// try-catch block that catches execution exceptions.
+      return do_requires_sub_editor_sub (m(row,col));
+    }
+
+    char quote_char (const QModelIndex& idx) const
+    {
+      octave_value ov = value_at (idx);
 
-octave_value
-variable_editor_model::retrieve_variable (const std::string& x)
-{
-  // INTERPRETER THREAD
+      if (ov.is_string ())
+        return get_quote_char (ov);
 
-  std::string name = x;
-
-  name = name.substr (0, name.find ("."));
+      return 0;
+    }
 
-  if (name.back () == ')' || name.back () == '}')
-    name = name.substr (0, name.find (name.back () == ')' ? "(" : "{"));
+    QString subscript_expression (const QModelIndex& idx) const
+    {
+      int row;
+      int col;
 
-  if (symbol_exist (name, "var") > 0)
-    {
-      int parse_status = 0;
+      if (! index_ok (idx, row, col))
+        return "";
 
-      return octave::eval_string (x, true, parse_status);
+      return (QString ("(%1,%2)")
+              .arg (row + 1)
+              .arg (col + 1));
     }
 
-  return octave_value ();
-}
-
-void
-variable_editor_model::evaluation_error (const std::string& expr) const
-{
-  emit user_error_signal ("Evaluation failed",
-                          QString ("failed to evaluate expression: '%1'")
-                          .arg (QString::fromStdString (expr)));
-}
-
-void
-variable_editor_model::user_error (const QString& title, const QString& msg)
-{
-  QMessageBox::critical (nullptr, title, msg);
-}
-
-void
-variable_editor_model::update_data_cache (void)
-{
-  octave_link::post_event
-    (this, &variable_editor_model::init_from_oct, name ());
-}
-
-void
-variable_editor_model::update_data (const octave_value& val)
-{
-  if (val.is_undefined ())
-    {
-      QString msg = (QString ("variable '%1' is invalid or undefined")
-                     .arg (QString::fromStdString (name ())));
-
-      emit data_error_signal (msg);
-
-      return;
-    }
-
-  // Add or remove rows and columns when the size changes.
-
-  int old_rows = display_rows ();
-  int old_cols = display_columns ();
-
-  reset (val);
-
-  int new_rows = display_rows ();
-  int new_cols = display_columns ();
-
-  if (new_rows != old_rows || new_cols != old_cols)
-    change_display_size (old_rows, old_cols, new_rows, new_cols);
-
-  // Even if the size doesn't change, we still need to update here
-  // because the data may have changed.
-
-  emit dataChanged (QAbstractTableModel::index (0, 0),
-                    QAbstractTableModel::index (new_rows-1, new_cols-1));
-
-  clear_update_pending ();
-}
-
-void
-variable_editor_model::change_display_size (int old_rows, int old_cols,
-                                            int new_rows, int new_cols)
-{
-  if (new_rows < old_rows)
-    {
-      beginRemoveRows (QModelIndex (), new_rows, old_rows-1);
-      endRemoveRows ();
-    }
-  else if (new_rows > old_rows)
-    {
-      beginInsertRows (QModelIndex (), old_rows, new_rows-1);
-      endInsertRows ();
-    }
-
-  if (new_cols < old_cols)
-    {
-      beginRemoveColumns (QModelIndex (), new_cols, old_cols-1);
-      endRemoveColumns ();
-    }
-  else if (new_cols > old_cols)
+    octave_value value_at (const QModelIndex& idx) const
     {
-      beginInsertColumns (QModelIndex (), old_cols, new_cols-1);
-      endInsertColumns ();
+      int row;
+      int col;
+
+      if (! index_ok (idx, row, col))
+        return octave_value ();
+
+      octave_map m = m_value.map_value ();
+
+      return m(row,col);
     }
-}
+  };
+
+  base_ve_model *
+  variable_editor_model::create (const QString& expr, const octave_value& val)
+  {
+    // Choose specific model based on type of val.
+
+    if ((val.isnumeric () || val.islogical ()) && val.ndims () == 2)
+      return new numeric_model (expr, val);
+    else if (val.is_string () && (val.rows () == 1 || val.is_zero_by_zero ()))
+      return new string_model (expr, val);
+    else if (val.iscell ())
+      return new cell_model (expr, val);
+    else if (val.isstruct ())
+      {
+        if (val.numel () == 1)
+          return new scalar_struct_model (expr, val);
+        else if (val.ndims () == 2)
+          {
+            if (val.rows () == 1 || val.columns () == 1)
+              return new vector_struct_model (expr, val);
+            else
+              return new struct_model (expr, val);
+          }
+      }
+
+    return new display_only_model (expr, val);
+  }
+
+  variable_editor_model::variable_editor_model (const QString& expr,
+                                                const octave_value& val,
+                                                QObject *parent)
+    : QAbstractTableModel (parent), rep (create (expr, val))
+  {
+    update_description ();
+
+    connect (this, SIGNAL (user_error_signal (const QString&, const QString&)),
+             this, SLOT (user_error (const QString&, const QString&)));
+
+    connect (this, SIGNAL (update_data_signal (const octave_value&)),
+             this, SLOT (update_data (const octave_value&)));
+
+    connect (this, SIGNAL (data_error_signal (const QString&)),
+             this, SLOT (data_error (const QString&)));
+
+    if (is_editable ())
+      {
+        beginInsertRows (QModelIndex (), 0, display_rows () - 1);
+        endInsertRows ();
+
+        beginInsertColumns (QModelIndex (), 0, display_columns () - 1);
+        endInsertColumns ();
+      }
+  }
+
+  bool
+  variable_editor_model::setData (const QModelIndex& idx,
+                                  const QVariant& v_user_input, int role)
+  {
+    if (role != Qt::EditRole || ! v_user_input.canConvert (QVariant::String)
+        || ! idx.isValid ())
+      return false;
+
+    // Initially, set value to whatever the user entered.
+
+    QString user_input = v_user_input.toString ();
+
+    char qc = quote_char (idx);
+
+    // FIXME: maybe we need a better way to ask whether empty input is
+    // valid than to rely on whether there is a quote character (meaning
+    // we are editing a character string)?
+    if (user_input.isEmpty () && ! qc)
+      return false;
+
+    set_update_pending (idx, user_input);
+
+    std::ostringstream os;
+
+    std::string nm = name ();
+    os << nm;
+
+    QString tmp = subscript_expression (idx);
+    os << tmp.toStdString () << "=";
+
+    if (qc)
+      os << qc;
+
+    os << user_input.toStdString ();
+
+    if (qc)
+      os << qc;
+
+    std::string expr = os.str ();
+
+    octave_link::post_event<variable_editor_model, std::string, std::string, QModelIndex>
+      (this, &variable_editor_model::set_data_oct, nm, expr, idx);
+
+    return true;
+  }
+
+  bool
+  variable_editor_model::clear_content (const QModelIndex& idx)
+  {
+    int row = idx.row ();
+    int col = idx.column ();
 
-void
-variable_editor_model::maybe_resize_rows (int rows)
-{
-  int old_rows = display_rows ();
-  int old_cols = display_columns ();
+    if (row < data_rows () && col < data_columns ())
+      return setData (idx, QVariant ("0"));
+
+    return false;
+  }
+
+  Qt::ItemFlags
+  variable_editor_model::flags (const QModelIndex& idx) const
+  {
+    if (! is_valid ())
+      return Qt::NoItemFlags;
+
+    Qt::ItemFlags retval = QAbstractTableModel::flags (idx);
+
+    if (! requires_sub_editor (idx))
+      retval |= Qt::ItemIsEditable;
+
+    return retval;
+  }
+
+  bool
+  variable_editor_model::insertRows (int row, int count, const QModelIndex&)
+  {
+    // FIXME: cells?
+
+    octave_link::post_event <variable_editor_model, std::string, std::string>
+      (this, &variable_editor_model::eval_oct, name (),
+       QString ("%1 = [ %1(1:%2,:) ; zeros(%3, columns(%1)) ; %1(%2+%3:end,:) ]")
+       .arg (QString::fromStdString (name ()))
+       .arg (row)
+       .arg (count)
+       .toStdString ());
+
+    return true;
+  }
+
+  bool
+  variable_editor_model::removeRows (int row, int count, const QModelIndex&)
+  {
+    if (row + count > data_rows ())
+      {
+        qDebug () << "Tried to remove too many rows "
+                  << data_rows () << " "
+                  << count << " (" << row << ")";
+        return false;
+      }
+
+    octave_link::post_event <variable_editor_model, std::string, std::string>
+      (this, &variable_editor_model::eval_oct, name (),
+       QString ("%1(%2:%3, :) = []")
+       .arg (QString::fromStdString (name ()))
+       .arg (row)
+       .arg (row + count)
+       .toStdString ());
+
+    return true;
+  }
 
-  rep->maybe_resize_rows (rows);
+  bool
+  variable_editor_model::insertColumns (int col, int count, const QModelIndex&)
+  {
+    octave_link::post_event <variable_editor_model, std::string, std::string>
+      (this, &variable_editor_model::eval_oct, name (),
+       QString ("%1 = [ %1(:,1:%2) ; zeros(rows(%1), %3) %1(:,%2+%3:end) ]")
+       .arg (QString::fromStdString (name ()))
+       .arg (col)
+       .arg (count)
+       .toStdString ());
+
+    return true;
+  }
+
+  bool
+  variable_editor_model::removeColumns (int col, int count, const QModelIndex&)
+  {
+    if (col + count > data_columns ())
+      {
+        qDebug () << "Tried to remove too many cols "
+                  << data_columns () << " "
+                  << count << " (" << col << ")";
+        return false;
+      }
 
-  int new_rows = display_rows ();
-  int new_cols = display_columns ();
+    octave_link::post_event <variable_editor_model, std::string, std::string>
+      (this, &variable_editor_model::eval_oct, name (),
+       QString ("%1(:, %2:%3) = []")
+       .arg (QString::fromStdString (name ()))
+       .arg (col)
+       .arg (col + count)
+       .toStdString ());
+
+    return true;
+  }
+
+  void
+  variable_editor_model::set_data_oct (const std::string& name,
+                                       const std::string& expr,
+                                       const QModelIndex& idx)
+  {
+    // INTERPRETER THREAD
 
-  if (new_rows != old_rows)
-    change_display_size (old_rows, old_cols, new_rows, new_cols);
-}
+    try
+      {
+        int parse_status = 0;
+
+        eval_string (expr, true, parse_status);
+
+        octave_value val = retrieve_variable (name);
+
+        emit update_data_signal (val);
+      }
+    catch (execution_exception&)
+      {
+        clear_update_pending ();
+
+        evaluation_error (expr);
+
+        // This will cause the data in the cell to be reset
+        // from the cached octave_value object.
 
-void
-variable_editor_model::maybe_resize_columns (int cols)
-{
-  int old_rows = display_rows ();
-  int old_cols = display_columns ();
+        emit dataChanged (idx, idx);
+      }
+  }
+
+  void
+  variable_editor_model::init_from_oct (const std::string& name)
+  {
+    // INTERPRETER THREAD
+
+    try
+      {
+        octave_value val = retrieve_variable (name);
+
+        emit update_data_signal (val);
+      }
+    catch (execution_exception&)
+      {
+        QString msg = (QString ("variable '%1' is invalid or undefined")
+                       .arg (QString::fromStdString (name)));
+
+        emit data_error_signal (msg);
+      }
+  }
+
+  void
+  variable_editor_model::eval_oct (const std::string& name,
+                                   const std::string& expr)
+  {
+    // INTERPRETER THREAD
+
+    try
+      {
+        int parse_status = 0;
+
+        eval_string (expr, true, parse_status);
+
+        init_from_oct (name);
+      }
+    catch  (execution_exception&)
+      {
+        evaluation_error (expr);
+      }
+  }
+
+  // If the variable exists, load it into the data model.  If it doesn't
+  // exist, flag the data model as referring to a nonexistent variable.
+  // This allows the variable to be opened before it is created.
+
+  // This function should only be called within other functions that
+  // execute in the interpreter thread.  It should also be called in a
+  // try-catch block that catches execution exceptions.
+
+  octave_value
+  variable_editor_model::retrieve_variable (const std::string& x)
+  {
+    // INTERPRETER THREAD
+
+    std::string name = x;
 
-  rep->maybe_resize_columns (cols);
+    name = name.substr (0, name.find ("."));
+
+    if (name.back () == ')' || name.back () == '}')
+      name = name.substr (0, name.find (name.back () == ')' ? "(" : "{"));
+
+    if (symbol_exist (name, "var") > 0)
+      {
+        int parse_status = 0;
+
+        return eval_string (x, true, parse_status);
+      }
+
+    return octave_value ();
+  }
+
+  void
+  variable_editor_model::evaluation_error (const std::string& expr) const
+  {
+    emit user_error_signal ("Evaluation failed",
+                            QString ("failed to evaluate expression: '%1'")
+                            .arg (QString::fromStdString (expr)));
+  }
+
+  void
+  variable_editor_model::user_error (const QString& title, const QString& msg)
+  {
+    QMessageBox::critical (nullptr, title, msg);
+  }
 
-  int new_rows = display_rows ();
-  int new_cols = display_columns ();
+  void
+  variable_editor_model::update_data_cache (void)
+  {
+    octave_link::post_event
+      (this, &variable_editor_model::init_from_oct, name ());
+  }
+
+  void
+  variable_editor_model::update_data (const octave_value& val)
+  {
+    if (val.is_undefined ())
+      {
+        QString msg = (QString ("variable '%1' is invalid or undefined")
+                       .arg (QString::fromStdString (name ())));
+
+        emit data_error_signal (msg);
+
+        return;
+      }
+
+    // Add or remove rows and columns when the size changes.
+
+    int old_rows = display_rows ();
+    int old_cols = display_columns ();
+
+    reset (val);
+
+    int new_rows = display_rows ();
+    int new_cols = display_columns ();
 
-  if (new_cols != old_cols)
-    change_display_size (old_rows, old_cols, new_rows, new_cols);
-}
+    if (new_rows != old_rows || new_cols != old_cols)
+      change_display_size (old_rows, old_cols, new_rows, new_cols);
+
+    // Even if the size doesn't change, we still need to update here
+    // because the data may have changed.
+
+    emit dataChanged (QAbstractTableModel::index (0, 0),
+                      QAbstractTableModel::index (new_rows-1, new_cols-1));
+
+    clear_update_pending ();
+  }
+
+  void
+  variable_editor_model::change_display_size (int old_rows, int old_cols,
+                                              int new_rows, int new_cols)
+  {
+    if (new_rows < old_rows)
+      {
+        beginRemoveRows (QModelIndex (), new_rows, old_rows-1);
+        endRemoveRows ();
+      }
+    else if (new_rows > old_rows)
+      {
+        beginInsertRows (QModelIndex (), old_rows, new_rows-1);
+        endInsertRows ();
+      }
+
+    if (new_cols < old_cols)
+      {
+        beginRemoveColumns (QModelIndex (), new_cols, old_cols-1);
+        endRemoveColumns ();
+      }
+    else if (new_cols > old_cols)
+      {
+        beginInsertColumns (QModelIndex (), old_cols, new_cols-1);
+        endInsertColumns ();
+      }
+  }
+
+  void
+  variable_editor_model::maybe_resize_rows (int rows)
+  {
+    int old_rows = display_rows ();
+    int old_cols = display_columns ();
+
+    rep->maybe_resize_rows (rows);
+
+    int new_rows = display_rows ();
+    int new_cols = display_columns ();
+
+    if (new_rows != old_rows)
+      change_display_size (old_rows, old_cols, new_rows, new_cols);
+  }
 
-void
-variable_editor_model::data_error (const QString& msg)
-{
-  invalidate ();
+  void
+  variable_editor_model::maybe_resize_columns (int cols)
+  {
+    int old_rows = display_rows ();
+    int old_cols = display_columns ();
+
+    rep->maybe_resize_columns (cols);
+
+    int new_rows = display_rows ();
+    int new_cols = display_columns ();
+
+    if (new_cols != old_cols)
+      change_display_size (old_rows, old_cols, new_rows, new_cols);
+  }
+
+  void
+  variable_editor_model::data_error (const QString& msg)
+  {
+    invalidate ();
+
+    update_description (msg);
+  }
+
+  void
+  variable_editor_model::reset (const octave_value& val)
+  {
+    base_ve_model *old_rep = rep;
+
+    rep = create (QString::fromStdString (name ()), val);
+
+    delete old_rep;
 
-  update_description (msg);
+    update_description ();
+
+    emit set_editable_signal (is_editable ());
+  }
+
+  void
+  variable_editor_model::invalidate (void)
+  {
+    beginResetModel ();
+
+    reset (octave_value ());
+
+    endResetModel ();
+  }
+
+  void
+  variable_editor_model::update_description (const QString& description)
+  {
+    emit description_changed (description.isEmpty ()
+                              ? make_description_text () : description);
+  }
+
+  void
+  variable_editor_model::double_click (const QModelIndex& idx)
+  {
+    if (requires_sub_editor (idx))
+      {
+        QString name = QString::fromStdString(rep->name ());
+        emit edit_variable_signal (name + subscript_expression (idx),
+                                   value_at (idx));
+      }
+  }
 }
-
-void
-variable_editor_model::reset (const octave_value& val)
-{
-  base_ve_model *old_rep = rep;
-
-  rep = create (QString::fromStdString (name ()), val);
-
-  delete old_rep;
-
-  update_description ();
-
-  emit set_editable_signal (is_editable ());
-}
-
-void
-variable_editor_model::invalidate (void)
-{
-  beginResetModel ();
-
-  reset (octave_value ());
-
-  endResetModel ();
-}
-
-void
-variable_editor_model::update_description (const QString& description)
-{
-  emit description_changed (description.isEmpty ()
-                            ? make_description_text () : description);
-}
-
-void
-variable_editor_model::double_click (const QModelIndex& idx)
-{
-  if (requires_sub_editor (idx))
-    {
-      QString name = QString::fromStdString(rep->name ());
-      emit edit_variable_signal (name + subscript_expression (idx),
-                                 value_at (idx));
-    }
-}
diff --git a/libgui/src/variable-editor-model.h b/libgui/src/variable-editor-model.h
--- a/libgui/src/variable-editor-model.h
+++ b/libgui/src/variable-editor-model.h
@@ -27,317 +27,318 @@ along with Octave; see the file COPYING.
 
 #include <QAbstractTableModel>
 #include <QMap>
 #include <QString>
 
 #include "ov.h"
 #include "pr-flt-fmt.h"
 
-class
-base_ve_model
+namespace octave
 {
-public:
-
-  base_ve_model (const QString &expr, const octave_value& val);
+  class base_ve_model
+  {
+  public:
 
-  virtual ~base_ve_model (void) = default;
-
-  // No copying!
+    base_ve_model (const QString &expr, const octave_value& val);
 
-  base_ve_model (const base_ve_model&) = delete;
+    virtual ~base_ve_model (void) = default;
 
-  base_ve_model& operator = (const base_ve_model&) = delete;
-
-  virtual void maybe_resize_rows (int) { }
+    // No copying!
 
-  virtual void maybe_resize_columns (int) { }
-
-  std::string name (void) const;
+    base_ve_model (const base_ve_model&) = delete;
 
-  bool index_ok (const QModelIndex& idx, int& row, int& col) const;
+    base_ve_model& operator = (const base_ve_model&) = delete;
 
-  virtual bool is_editable (void) const { return true; }
-
-  virtual octave_value value_at (const QModelIndex& idx) const;
+    virtual void maybe_resize_rows (int) { }
 
-  int column_width (void) const;
-
-  int rowCount (const QModelIndex& = QModelIndex ()) const;
+    virtual void maybe_resize_columns (int) { }
 
-  int columnCount (const QModelIndex& = QModelIndex ()) const;
+    std::string name (void) const;
 
-  QString edit_display_sub (const octave_value& elt, int role) const;
-
-  virtual QVariant edit_display (const QModelIndex& idx, int role) const;
+    bool index_ok (const QModelIndex& idx, int& row, int& col) const;
 
-  QVariant data (const QModelIndex& idx, int role = Qt::DisplayRole) const;
-
-  virtual bool requires_sub_editor (const QModelIndex& idx) const;
+    virtual bool is_editable (void) const { return true; }
 
-  void set_update_pending (const QModelIndex& idx, const QString& str);
+    virtual octave_value value_at (const QModelIndex& idx) const;
 
-  bool update_pending (const QModelIndex& idx) const;
+    int column_width (void) const;
 
-  QString update_pending_data (const QModelIndex& idx) const;
-
-  void clear_update_pending (void);
+    int rowCount (const QModelIndex& = QModelIndex ()) const;
 
-  virtual char quote_char (const QModelIndex& idx) const;
+    int columnCount (const QModelIndex& = QModelIndex ()) const;
 
-  virtual QVariant
-  header_data (int section, Qt::Orientation orientation, int role) const;
+    QString edit_display_sub (const octave_value& elt, int role) const;
 
-  // Return a subscript expression as a string that can be used to
-  // access a sub-element of a data structure.  For example "{1,3}"
-  // for cell array element {1,3} or "(2,4)" for array element (2,4).
+    virtual QVariant edit_display (const QModelIndex& idx, int role) const;
 
-  virtual QString subscript_expression (const QModelIndex& idx) const;
+    QVariant data (const QModelIndex& idx, int role = Qt::DisplayRole) const;
 
-  bool is_valid (void) const { return m_valid; }
-
-  octave_idx_type data_rows (void) const { return m_data_rows; }
+    virtual bool requires_sub_editor (const QModelIndex& idx) const;
 
-  octave_idx_type data_columns (void) const { return m_data_cols; }
-
-  int display_rows (void) const { return m_display_rows; }
-
-  int display_columns (void) const { return m_display_cols; }
+    void set_update_pending (const QModelIndex& idx, const QString& str);
 
-  virtual QString make_description_text (void) const;
+    bool update_pending (const QModelIndex& idx) const;
 
-  void reset (const octave_value& val);
-
-protected:
+    QString update_pending_data (const QModelIndex& idx) const;
 
-  std::string m_name;
+    void clear_update_pending (void);
 
-  octave_value m_value;
-
-  octave_idx_type m_data_rows;
-  octave_idx_type m_data_cols;
+    virtual char quote_char (const QModelIndex& idx) const;
 
-  // Qt table widget limits the size to int.
-  int m_display_rows;
-  int m_display_cols;
+    virtual QVariant
+    header_data (int section, Qt::Orientation orientation, int role) const;
 
-  QMap<QModelIndex, QString> m_update_pending;
-
-  bool m_valid;
-
-  float_display_format m_display_fmt;
-};
+    // Return a subscript expression as a string that can be used to
+    // access a sub-element of a data structure.  For example "{1,3}"
+    // for cell array element {1,3} or "(2,4)" for array element (2,4).
 
-class
-variable_editor_model : public QAbstractTableModel
-{
-  Q_OBJECT
+    virtual QString subscript_expression (const QModelIndex& idx) const;
 
-private:
+    bool is_valid (void) const { return m_valid; }
 
-  static base_ve_model * create (const QString &expr, const octave_value& val);
+    octave_idx_type data_rows (void) const { return m_data_rows; }
 
-public:
-
-  variable_editor_model (const QString &expr, const octave_value& val,
-                         QObject *parent = nullptr);
+    octave_idx_type data_columns (void) const { return m_data_cols; }
 
-  ~variable_editor_model (void)
-  {
-    delete rep;
-  }
+    int display_rows (void) const { return m_display_rows; }
+
+    int display_columns (void) const { return m_display_cols; }
 
-  // No copying!
+    virtual QString make_description_text (void) const;
 
-  variable_editor_model (const variable_editor_model&) = delete;
+    void reset (const octave_value& val);
 
-  variable_editor_model& operator = (const variable_editor_model&) = delete;
+  protected:
 
-  std::string name (void) const
-  {
-    return rep->name ();
-  }
+    std::string m_name;
 
-  bool is_editable (void) const
-  {
-    return rep->is_editable ();
-  }
+    octave_value m_value;
+
+    octave_idx_type m_data_rows;
+    octave_idx_type m_data_cols;
 
-  octave_value value_at (const QModelIndex& idx) const
-  {
-    return rep->value_at (idx);
-  }
+    // Qt table widget limits the size to int.
+    int m_display_rows;
+    int m_display_cols;
 
-  int column_width (void) const
-  {
-    return rep->column_width ();
-  }
+    QMap<QModelIndex, QString> m_update_pending;
 
-  int rowCount (const QModelIndex& idx = QModelIndex ()) const
-  {
-    return rep->rowCount (idx);
-  }
+    bool m_valid;
 
-  int columnCount (const QModelIndex& idx = QModelIndex ()) const
-  {
-    return rep->columnCount (idx);
-  }
+    float_display_format m_display_fmt;
+  };
 
-  QVariant data (const QModelIndex& idx = QModelIndex (),
-                 int role = Qt::DisplayRole) const
+  class variable_editor_model : public QAbstractTableModel
   {
-    return rep->data (idx, role);
-  }
+    Q_OBJECT
+
+  private:
 
-  bool setData (const QModelIndex& idx, const QVariant& v,
-                int role = Qt::EditRole);
+    static base_ve_model * create (const QString &expr, const octave_value& val);
 
-  bool clear_content (const QModelIndex& idx);
+  public:
+
+    variable_editor_model (const QString &expr, const octave_value& val,
+                           QObject *parent = nullptr);
 
-  Qt::ItemFlags flags (const QModelIndex& idx) const;
+    ~variable_editor_model (void)
+    {
+      delete rep;
+    }
 
-  bool insertRows (int row, int count,
-                   const QModelIndex& parent = QModelIndex());
+    // No copying!
 
-  bool removeRows (int row, int count,
-                   const QModelIndex& parent = QModelIndex());
+    variable_editor_model (const variable_editor_model&) = delete;
+
+    variable_editor_model& operator = (const variable_editor_model&) = delete;
 
-  bool insertColumns (int column, int count,
-                      const QModelIndex& parent = QModelIndex());
+    std::string name (void) const
+    {
+      return rep->name ();
+    }
 
-  bool removeColumns (int column, int count,
-                      const QModelIndex& parent = QModelIndex());
+    bool is_editable (void) const
+    {
+      return rep->is_editable ();
+    }
 
-  // Is cell at idx complex enough to require a sub editor?
+    octave_value value_at (const QModelIndex& idx) const
+    {
+      return rep->value_at (idx);
+    }
 
-  bool requires_sub_editor (const QModelIndex& idx) const
-  {
-    return rep->requires_sub_editor (idx);
-  }
+    int column_width (void) const
+    {
+      return rep->column_width ();
+    }
 
-  void set_update_pending (const QModelIndex& idx, const QString& str)
-  {
-    rep->set_update_pending (idx, str);
-  }
+    int rowCount (const QModelIndex& idx = QModelIndex ()) const
+    {
+      return rep->rowCount (idx);
+    }
+
+    int columnCount (const QModelIndex& idx = QModelIndex ()) const
+    {
+      return rep->columnCount (idx);
+    }
 
-  bool update_pending (const QModelIndex& idx) const
-  {
-    return rep->update_pending (idx);
-  }
+    QVariant data (const QModelIndex& idx = QModelIndex (),
+                   int role = Qt::DisplayRole) const
+    {
+      return rep->data (idx, role);
+    }
 
-  QString update_pending_data (const QModelIndex& idx) const
-  {
-    return rep->update_pending_data (idx);
-  }
+    bool setData (const QModelIndex& idx, const QVariant& v,
+                  int role = Qt::EditRole);
+
+    bool clear_content (const QModelIndex& idx);
 
-  void clear_update_pending (void)
-  {
-    rep->clear_update_pending ();
-  }
+    Qt::ItemFlags flags (const QModelIndex& idx) const;
+
+    bool insertRows (int row, int count,
+                     const QModelIndex& parent = QModelIndex());
 
-  char quote_char (const QModelIndex& idx) const
-  {
-    return rep->quote_char (idx);
-  }
+    bool removeRows (int row, int count,
+                     const QModelIndex& parent = QModelIndex());
+
+    bool insertColumns (int column, int count,
+                        const QModelIndex& parent = QModelIndex());
+
+    bool removeColumns (int column, int count,
+                        const QModelIndex& parent = QModelIndex());
 
-  QVariant
-  headerData (int section, Qt::Orientation orientation, int role) const
-  {
-    return rep->header_data (section, orientation, role);
-  }
+    // Is cell at idx complex enough to require a sub editor?
 
-  // Return a subscript expression as a string that can be used to
-  // access a sub-element of a data structure.  For example "{1,3}"
-  // for cell array element {1,3} or "(2,4)" for array element (2,4).
+    bool requires_sub_editor (const QModelIndex& idx) const
+    {
+      return rep->requires_sub_editor (idx);
+    }
+
+    void set_update_pending (const QModelIndex& idx, const QString& str)
+    {
+      rep->set_update_pending (idx, str);
+    }
 
-  QString subscript_expression (const QModelIndex& idx) const
-  {
-    return rep->subscript_expression (idx);
-  }
+    bool update_pending (const QModelIndex& idx) const
+    {
+      return rep->update_pending (idx);
+    }
 
-  int display_rows (void) const
-  {
-    return rep->display_rows ();
-  }
+    QString update_pending_data (const QModelIndex& idx) const
+    {
+      return rep->update_pending_data (idx);
+    }
+
+    void clear_update_pending (void)
+    {
+      rep->clear_update_pending ();
+    }
 
-  int display_columns (void) const
-  {
-    return rep->display_columns ();
-  }
+    char quote_char (const QModelIndex& idx) const
+    {
+      return rep->quote_char (idx);
+    }
 
-  void maybe_resize_rows (int rows);
-
-  void maybe_resize_columns (int cols);
+    QVariant
+    headerData (int section, Qt::Orientation orientation, int role) const
+    {
+      return rep->header_data (section, orientation, role);
+    }
 
-signals:
-
-  void update_data_signal (const octave_value& val);
+    // Return a subscript expression as a string that can be used to
+    // access a sub-element of a data structure.  For example "{1,3}"
+    // for cell array element {1,3} or "(2,4)" for array element (2,4).
 
-  void data_error_signal (const QString& name) const;
+    QString subscript_expression (const QModelIndex& idx) const
+    {
+      return rep->subscript_expression (idx);
+    }
 
-  void user_error_signal (const QString& title, const QString& msg) const;
-
-  void set_editable_signal (bool);
+    int display_rows (void) const
+    {
+      return rep->display_rows ();
+    }
 
-  void description_changed (const QString& description);
-
-  void edit_variable_signal (const QString& name, const octave_value& val);
+    int display_columns (void) const
+    {
+      return rep->display_columns ();
+    }
 
-public slots:
+    void maybe_resize_rows (int rows);
+
+    void maybe_resize_columns (int cols);
 
-  void update_data (const octave_value& val);
+  signals:
 
-  void update_data_cache (void);
+    void update_data_signal (const octave_value& val);
 
-  void double_click (const QModelIndex& idx);
+    void data_error_signal (const QString& name) const;
+
+    void user_error_signal (const QString& title, const QString& msg) const;
 
-private slots:
+    void set_editable_signal (bool);
 
-  void data_error (const QString& msg);
+    void description_changed (const QString& description);
 
-  void user_error (const QString& title, const QString& msg);
+    void edit_variable_signal (const QString& name, const octave_value& val);
+
+  public slots:
 
-private:
+    void update_data (const octave_value& val);
 
-  base_ve_model *rep;
+    void update_data_cache (void);
 
-  void set_data_oct (const std::string& name, const std::string& expr,
-                     const QModelIndex&);
+    void double_click (const QModelIndex& idx);
+
+  private slots:
+
+    void data_error (const QString& msg);
 
-  void init_from_oct (const std::string& str);
+    void user_error (const QString& title, const QString& msg);
 
-  void eval_oct (const std::string& name, const std::string& expr);
+  private:
 
-  octave_value retrieve_variable (const std::string& name);
+    base_ve_model *rep;
 
-  bool is_valid (void) const
-  {
-    return rep->is_valid ();
-  }
+    void set_data_oct (const std::string& name, const std::string& expr,
+                       const QModelIndex&);
+
+    void init_from_oct (const std::string& str);
+
+    void eval_oct (const std::string& name, const std::string& expr);
 
-  octave_idx_type data_rows (void) const
-  {
-    return rep->data_rows ();
-  }
+    octave_value retrieve_variable (const std::string& name);
+
+    bool is_valid (void) const
+    {
+      return rep->is_valid ();
+    }
 
-  octave_idx_type data_columns (void) const
-  {
-    return rep->data_columns ();
-  }
+    octave_idx_type data_rows (void) const
+    {
+      return rep->data_rows ();
+    }
 
-  void change_display_size (int old_rows, int old_cols,
-                            int new_rows, int new_cols);
+    octave_idx_type data_columns (void) const
+    {
+      return rep->data_columns ();
+    }
+
+    void change_display_size (int old_rows, int old_cols,
+                              int new_rows, int new_cols);
 
-  QString make_description_text (void) const
-  {
-    return rep->make_description_text ();
-  }
+    QString make_description_text (void) const
+    {
+      return rep->make_description_text ();
+    }
 
-  void reset (const octave_value& val);
+    void reset (const octave_value& val);
 
-  void invalidate (void);
+    void invalidate (void);
+
+    void update_description (const QString& description = QString ());
 
-  void update_description (const QString& description = QString ());
-
-  void evaluation_error (const std::string& expr) const;
-};
+    void evaluation_error (const std::string& expr) const;
+  };
+}
 
 #endif
diff --git a/libgui/src/variable-editor.cc b/libgui/src/variable-editor.cc
--- a/libgui/src/variable-editor.cc
+++ b/libgui/src/variable-editor.cc
@@ -57,17 +57,17 @@ along with Octave; see the file COPYING.
 static QString
 idx_to_expr (int32_t from, int32_t to)
 {
   return (from == to
           ? QString ("%1").arg (from)
           : QString ("%1:%2").arg (from).arg (to));
 }
 
-QSignalMapper *
+static QSignalMapper *
 make_plot_mapper (QMenu *menu)
 {
   QList<QString> list;
   list << "plot" << "bar" << "stem" << "stairs" << "area" << "pie" << "hist";
 
   QSignalMapper *plot_mapper = new QSignalMapper (menu);
 
   for (int i = 0; i < list.size(); ++i)
@@ -75,1411 +75,1413 @@ make_plot_mapper (QMenu *menu)
       plot_mapper->setMapping
         (menu->addAction (list.at (i), plot_mapper, SLOT (map ())),
          "figure (); " + list.at (i) + " (%1); title (\"%1\");");
     }
 
   return plot_mapper;
 }
 
-
-// Variable dock widget
-
-variable_dock_widget::variable_dock_widget (QWidget *p)
-  : label_dock_widget (p), m_initial_float (true)
+namespace octave
 {
-  setFocusPolicy (Qt::StrongFocus);
-  // This controls whether the variable_dock_widgets are deleted
-  // or hidden when clicking the upper right X icon.  (Look for
-  // the checkmark of the variable_editor's context menu.)
-  // Could make this an option, or perhaps add a drop-down menu
-  // in place of X "close" icon.
+  // Variable dock widget
+
+  variable_dock_widget::variable_dock_widget (QWidget *p)
+    : label_dock_widget (p), m_initial_float (true)
+  {
+    setFocusPolicy (Qt::StrongFocus);
+    // This controls whether the variable_dock_widgets are deleted
+    // or hidden when clicking the upper right X icon.  (Look for
+    // the checkmark of the variable_editor's context menu.)
+    // Could make this an option, or perhaps add a drop-down menu
+    // in place of X "close" icon.
 #if 0
-  setAttribute (Qt::WA_DeleteOnClose);
+    setAttribute (Qt::WA_DeleteOnClose);
 #endif
 
-  connect (m_dock_action, SIGNAL (triggered (bool)),
-           this, SLOT (change_floating (bool)));
-  connect (m_close_action, SIGNAL (triggered (bool)),
-           this, SLOT (change_existence (bool)));
-  connect (this, SIGNAL (topLevelChanged(bool)),
-           this, SLOT (toplevel_change (bool)));
-}
+    connect (m_dock_action, SIGNAL (triggered (bool)),
+             this, SLOT (change_floating (bool)));
+    connect (m_close_action, SIGNAL (triggered (bool)),
+             this, SLOT (change_existence (bool)));
+    connect (this, SIGNAL (topLevelChanged(bool)),
+             this, SLOT (toplevel_change (bool)));
+  }
 
-// slot for (un)dock action
-void
-variable_dock_widget::change_floating (bool)
-{
-  setFloating (! isFloating ());
-}
+  // slot for (un)dock action
+  void
+  variable_dock_widget::change_floating (bool)
+  {
+    setFloating (! isFloating ());
+  }
 
-// slot for hiding the widget
-void
-variable_dock_widget::change_existence (bool)
-{
-  close ();
-}
+  // slot for hiding the widget
+  void
+  variable_dock_widget::change_existence (bool)
+  {
+    close ();
+  }
 
-void
-variable_dock_widget::toplevel_change (bool toplevel)
-{
-  if (toplevel)
-    {
-      m_dock_action->setIcon (QIcon (":/actions/icons/widget-dock.png"));
-      m_dock_action->setToolTip (tr ("Dock widget"));
+  void
+  variable_dock_widget::toplevel_change (bool toplevel)
+  {
+    if (toplevel)
+      {
+        m_dock_action->setIcon (QIcon (":/actions/icons/widget-dock.png"));
+        m_dock_action->setToolTip (tr ("Dock widget"));
 
-      // Make initial size expanded very large for "magnified" viewing
-      if (m_initial_float)
-        {
-          // This will be resolved based on user feedback and preference
-          // and will eventually work without QGuiApplication.  Perhaps
-          // a maximize button added to the label_dock_widget windows
-          // along with the dock/undock and close buttons is best.
+        // Make initial size expanded very large for "magnified" viewing
+        if (m_initial_float)
+          {
+            // This will be resolved based on user feedback and preference
+            // and will eventually work without QGuiApplication.  Perhaps
+            // a maximize button added to the label_dock_widget windows
+            // along with the dock/undock and close buttons is best.
 #if defined (HAVE_QGUIAPPLICATION)
-          QScreen *pscreen = QGuiApplication::primaryScreen ();
-          QRect rect (0, 0, 0, 0);
-          rect = pscreen->availableGeometry ();
-          rect = QRect (rect.x () + 5, rect.y () + 5,
-                        rect.width () - 10, rect.height () - 10);
-          setGeometry (rect);
-          m_initial_float = false;
+            QScreen *pscreen = QGuiApplication::primaryScreen ();
+            QRect rect (0, 0, 0, 0);
+            rect = pscreen->availableGeometry ();
+            rect = QRect (rect.x () + 5, rect.y () + 5,
+                          rect.width () - 10, rect.height () - 10);
+            setGeometry (rect);
+            m_initial_float = false;
 #endif
-        }
+          }
 
-      setFocus (Qt::OtherFocusReason);
-      activateWindow();
-    }
-  else
-    {
-      m_dock_action->setIcon (QIcon (":/actions/icons/widget-undock.png"));
-      m_dock_action->setToolTip (tr ("Undock widget"));
+        setFocus (Qt::OtherFocusReason);
+        activateWindow();
+      }
+    else
+      {
+        m_dock_action->setIcon (QIcon (":/actions/icons/widget-undock.png"));
+        m_dock_action->setToolTip (tr ("Undock widget"));
 
-      setFocus (Qt::OtherFocusReason);
-    }
-}
+        setFocus (Qt::OtherFocusReason);
+      }
+  }
 
-void
-variable_dock_widget::closeEvent (QCloseEvent *e)
-{
-  QDockWidget::closeEvent (e);
-}
+  void
+  variable_dock_widget::closeEvent (QCloseEvent *e)
+  {
+    QDockWidget::closeEvent (e);
+  }
 
-void
-variable_dock_widget::handle_focus_change (QWidget *old, QWidget *now)
-{
-  octave_unused_parameter (now);
+  void
+  variable_dock_widget::handle_focus_change (QWidget *old, QWidget *now)
+  {
+    octave_unused_parameter (now);
 
-  // The is a proxied test
-  if (hasFocus ())
-    {
-      QLabel *label = titleBarWidget ()->findChild<QLabel *> ();
-      if (label != nullptr)
-        label->setStyleSheet ("QLabel {background: skyblue;}");
+    // The is a proxied test
+    if (hasFocus ())
+      {
+        QLabel *label = titleBarWidget ()->findChild<QLabel *> ();
+        if (label != nullptr)
+          label->setStyleSheet ("QLabel {background: skyblue;}");
 
-      emit variable_focused_signal (objectName ());
-    }
-  else if (old == focusWidget())
-    {
-      QLabel *label = titleBarWidget ()->findChild<QLabel *> ();
-      if (label != NULL)
-        label->setStyleSheet ("QLabel {background: transparent;}");
-    }
-}
+        emit variable_focused_signal (objectName ());
+      }
+    else if (old == focusWidget())
+      {
+        QLabel *label = titleBarWidget ()->findChild<QLabel *> ();
+        if (label != NULL)
+          label->setStyleSheet ("QLabel {background: transparent;}");
+      }
+  }
 
 
-// Variable editor stack
+  // Variable editor stack
 
-variable_editor_stack::variable_editor_stack (QWidget *p)
-  : QStackedWidget (p), m_edit_view (new variable_editor_view (this))
-{
-  setFocusPolicy (Qt::StrongFocus);
+  variable_editor_stack::variable_editor_stack (QWidget *p)
+    : QStackedWidget (p), m_edit_view (new variable_editor_view (this))
+  {
+    setFocusPolicy (Qt::StrongFocus);
 
-  m_disp_view = make_disp_view (this);
+    m_disp_view = make_disp_view (this);
 
-  addWidget (m_edit_view);
-  addWidget (m_disp_view);
-}
+    addWidget (m_edit_view);
+    addWidget (m_disp_view);
+  }
 
-QTextEdit *
-variable_editor_stack::make_disp_view (QWidget *parent)
-{
-  QTextEdit *viewer = new QTextEdit (parent);
+  QTextEdit *
+  variable_editor_stack::make_disp_view (QWidget *parent)
+  {
+    QTextEdit *viewer = new QTextEdit (parent);
 
-  viewer->setLineWrapMode (QTextEdit::NoWrap);
-  viewer->setReadOnly (true);
+    viewer->setLineWrapMode (QTextEdit::NoWrap);
+    viewer->setReadOnly (true);
 
-  return viewer;
-}
+    return viewer;
+  }
 
-void
-variable_editor_stack::set_editable (bool editable)
-{
-  // The QTableView is for editable data models
-  // and the QTextEdit is for non-editable models.
+  void
+  variable_editor_stack::set_editable (bool editable)
+  {
+    // The QTableView is for editable data models
+    // and the QTextEdit is for non-editable models.
 
-  if (editable)
-    {
-      if (m_edit_view != nullptr)
-        {
-          setCurrentWidget (m_edit_view);
-          setFocusProxy (m_edit_view);
-          m_edit_view->setFocusPolicy (Qt::StrongFocus);
-        }
+    if (editable)
+      {
+        if (m_edit_view != nullptr)
+          {
+            setCurrentWidget (m_edit_view);
+            setFocusProxy (m_edit_view);
+            m_edit_view->setFocusPolicy (Qt::StrongFocus);
+          }
 
-      if (m_disp_view != nullptr)
-        m_disp_view->setFocusPolicy (Qt::NoFocus);
-    }
-  else
-    {
-      if (m_disp_view != nullptr)
-        {
-          setCurrentWidget (m_disp_view);
-          setFocusProxy (m_disp_view);
+        if (m_disp_view != nullptr)
+          m_disp_view->setFocusPolicy (Qt::NoFocus);
+      }
+    else
+      {
+        if (m_disp_view != nullptr)
+          {
+            setCurrentWidget (m_disp_view);
+            setFocusProxy (m_disp_view);
 
-          QAbstractTableModel *model = findChild<QAbstractTableModel *> ();
-          if (model != nullptr)
-            m_disp_view->setPlainText (model->data (QModelIndex ()).toString ());
-          else
-            m_disp_view->setPlainText ("");
-        }
+            QAbstractTableModel *model = findChild<QAbstractTableModel *> ();
+            if (model != nullptr)
+              m_disp_view->setPlainText (model->data (QModelIndex ()).toString ());
+            else
+              m_disp_view->setPlainText ("");
+          }
 
-      if (m_edit_view != nullptr)
-        m_edit_view->setFocusPolicy (Qt::NoFocus);
-    }
-}
+        if (m_edit_view != nullptr)
+          m_edit_view->setFocusPolicy (Qt::NoFocus);
+      }
+  }
 
-void
-variable_editor_stack::levelUp (void)
-{
-  if (! hasFocus ())
-    return;
+  void
+  variable_editor_stack::levelUp (void)
+  {
+    if (! hasFocus ())
+      return;
 
-  QString name = objectName ();
+    QString name = objectName ();
 
-  // FIXME: Is there a better way?
+    // FIXME: Is there a better way?
 
-  if (name.endsWith (')') || name.endsWith ('}'))
-    {
-      name.remove (QRegExp ("(\\(|\\{)[^({]*(\\)|\\})$"));
-      emit edit_variable_signal (name, octave_value ());
-    }
-}
+    if (name.endsWith (')') || name.endsWith ('}'))
+      {
+        name.remove (QRegExp ("(\\(|\\{)[^({]*(\\)|\\})$"));
+        emit edit_variable_signal (name, octave_value ());
+      }
+  }
 
-void
-variable_editor_stack::save (void)
-{
-  if (! hasFocus ())
-    return;
+  void
+  variable_editor_stack::save (void)
+  {
+    if (! hasFocus ())
+      return;
 
-  QString name = objectName ();
-  QString file
-    = QFileDialog::getSaveFileName (this,
-                                    tr ("Save Variable %1 As").arg (name),
-                                     /* Should determine extension from save_default_options */
-                                    tr ("./%1.txt").arg (name),
-                                    0, 0,
-                                    QFileDialog::DontUseNativeDialog);
+    QString name = objectName ();
+    QString file
+      = QFileDialog::getSaveFileName (this,
+                                      tr ("Save Variable %1 As").arg (name),
+                                      /* Should determine extension from save_default_options */
+                                      tr ("./%1.txt").arg (name),
+                                      0, 0,
+                                      QFileDialog::DontUseNativeDialog);
 
-  // FIXME: Type? binary, float-binary, ascii, text, hdf5, matlab format?
-  // FIXME: Call octave_value::save_* directly?
+    // FIXME: Type? binary, float-binary, ascii, text, hdf5, matlab format?
+    // FIXME: Call octave_value::save_* directly?
 
-  if (! file.isEmpty ())
-    emit command_signal (QString ("save (\"%1\", \"%2\");")
-                         .arg (file)
-                         .arg (name));
-}
+    if (! file.isEmpty ())
+      emit command_signal (QString ("save (\"%1\", \"%2\");")
+                           .arg (file)
+                           .arg (name));
+  }
 
 
-// Custom editable variable table view
+  // Custom editable variable table view
 
-variable_editor_view::variable_editor_view (QWidget *p)
-  : QTableView (p), m_var_model (nullptr)
-{
-  setWordWrap (false);
-  setContextMenuPolicy (Qt::CustomContextMenu);
-  setSelectionMode (QAbstractItemView::ContiguousSelection);
+  variable_editor_view::variable_editor_view (QWidget *p)
+    : QTableView (p), m_var_model (nullptr)
+  {
+    setWordWrap (false);
+    setContextMenuPolicy (Qt::CustomContextMenu);
+    setSelectionMode (QAbstractItemView::ContiguousSelection);
 
-  horizontalHeader ()->setContextMenuPolicy (Qt::CustomContextMenu);
-  verticalHeader ()->setContextMenuPolicy (Qt::CustomContextMenu);
+    horizontalHeader ()->setContextMenuPolicy (Qt::CustomContextMenu);
+    verticalHeader ()->setContextMenuPolicy (Qt::CustomContextMenu);
 
-  setHorizontalScrollMode (QAbstractItemView::ScrollPerPixel);
-  setVerticalScrollMode (QAbstractItemView::ScrollPerPixel);
+    setHorizontalScrollMode (QAbstractItemView::ScrollPerPixel);
+    setVerticalScrollMode (QAbstractItemView::ScrollPerPixel);
 
 #if defined (HAVE_QHEADERVIEW_SETSECTIONRESIZEMODE)
-  verticalHeader ()->setSectionResizeMode (QHeaderView::Interactive);
+    verticalHeader ()->setSectionResizeMode (QHeaderView::Interactive);
 #else
-  verticalHeader ()->setResizeMode (QHeaderView::Interactive);
+    verticalHeader ()->setResizeMode (QHeaderView::Interactive);
 #endif
-}
+  }
 
-void
-variable_editor_view::setModel (QAbstractItemModel *model)
-{
-  QTableView::setModel (model);
+  void
+  variable_editor_view::setModel (QAbstractItemModel *model)
+  {
+    QTableView::setModel (model);
 
 #if defined (HAVE_QHEADERVIEW_SETSECTIONRESIZEMODE)
-  horizontalHeader ()->setSectionResizeMode (QHeaderView::Interactive);
+    horizontalHeader ()->setSectionResizeMode (QHeaderView::Interactive);
 #else
-  horizontalHeader ()->setResizeMode (QHeaderView::Interactive);
+    horizontalHeader ()->setResizeMode (QHeaderView::Interactive);
 #endif
 
-  m_var_model = parent ()->findChild<variable_editor_model *> ();
+    m_var_model = parent ()->findChild<variable_editor_model *> ();
 
-  if (m_var_model != nullptr && m_var_model->column_width () > 0)
-    {
-      // col_width is in characters.  The font should be a fixed-width
-      // font, so any character will do.  If not, you lose!
+    if (m_var_model != nullptr && m_var_model->column_width () > 0)
+      {
+        // col_width is in characters.  The font should be a fixed-width
+        // font, so any character will do.  If not, you lose!
 
-      QFontMetrics fm (font ());
-      int w = m_var_model->column_width () * fm.width ('0');
-      horizontalHeader ()->setDefaultSectionSize (w);
-    }
-}
+        QFontMetrics fm (font ());
+        int w = m_var_model->column_width () * fm.width ('0');
+        horizontalHeader ()->setDefaultSectionSize (w);
+      }
+  }
 
-QList<int>
-variable_editor_view::range_selected (void)
-{
-  QItemSelectionModel *sel = selectionModel ();
+  QList<int>
+  variable_editor_view::range_selected (void)
+  {
+    QItemSelectionModel *sel = selectionModel ();
 
-  // Return early if nothing selected.
-  if (! sel->hasSelection ())
-    return QList<int> ();
+    // Return early if nothing selected.
+    if (! sel->hasSelection ())
+      return QList<int> ();
 
-  QList<QModelIndex> indices = sel->selectedIndexes ();
+    QList<QModelIndex> indices = sel->selectedIndexes ();
 
-  // FIXME: Shouldn't this be keyed to octave_idx_type?
+    // FIXME: Shouldn't this be keyed to octave_idx_type?
 
-  int32_t from_row = std::numeric_limits<int32_t>::max ();
-  int32_t to_row = 0;
-  int32_t from_col = std::numeric_limits<int32_t>::max ();
-  int32_t to_col = 0;
+    int32_t from_row = std::numeric_limits<int32_t>::max ();
+    int32_t to_row = 0;
+    int32_t from_col = std::numeric_limits<int32_t>::max ();
+    int32_t to_col = 0;
 
-  for (const auto& idx : indices)
-    {
-      from_row = std::min (from_row, idx.row ());
-      to_row = std::max (to_row, idx.row ());
-      from_col = std::min (from_col, idx.column ());
-      to_col = std::max (to_col, idx.column ());
-    }
+    for (const auto& idx : indices)
+      {
+        from_row = std::min (from_row, idx.row ());
+        to_row = std::max (to_row, idx.row ());
+        from_col = std::min (from_col, idx.column ());
+        to_col = std::max (to_col, idx.column ());
+      }
 
-  QVector<int> vect;
-  vect << from_row + 1 << to_row + 1 << from_col + 1 << to_col + 1;
-  QList<int> range = QList<int>::fromVector(vect);
+    QVector<int> vect;
+    vect << from_row + 1 << to_row + 1 << from_col + 1 << to_col + 1;
+    QList<int> range = QList<int>::fromVector(vect);
 
-  return range;
-}
+    return range;
+  }
 
-QString
-variable_editor_view::selected_to_octave (void)
-{
-  QList<int> range = range_selected ();
-  if (range.isEmpty ())
-    return objectName ();
+  QString
+  variable_editor_view::selected_to_octave (void)
+  {
+    QList<int> range = range_selected ();
+    if (range.isEmpty ())
+      return objectName ();
 
-  QString rows = idx_to_expr (range.at (0), range.at (1));
-  QString cols = idx_to_expr (range.at (2), range.at (3));
+    QString rows = idx_to_expr (range.at (0), range.at (1));
+    QString cols = idx_to_expr (range.at (2), range.at (3));
 
-  // FIXME: Does cell need separate handling?  Maybe use '{.,.}'?
+    // FIXME: Does cell need separate handling?  Maybe use '{.,.}'?
 
-  return QString ("%1(%2, %3)").arg (objectName ()).arg (rows).arg (cols);
-}
+    return QString ("%1(%2, %3)").arg (objectName ()).arg (rows).arg (cols);
+  }
 
-void
-variable_editor_view::selected_command_requested (const QString& cmd)
-{
-  if (! hasFocus ())
-    return;
+  void
+  variable_editor_view::selected_command_requested (const QString& cmd)
+  {
+    if (! hasFocus ())
+      return;
 
-  QString selarg = selected_to_octave ();
-  if (! selarg.isEmpty ())
-    emit command_signal (cmd.arg (selarg));
-}
+    QString selarg = selected_to_octave ();
+    if (! selarg.isEmpty ())
+      emit command_signal (cmd.arg (selarg));
+  }
 
-void
-variable_editor_view::add_edit_actions (QMenu *menu, const QString& qualifier_string)
-{
-  menu->addAction (resource_manager::icon ("edit-cut"),
-                   tr ("Cut") + qualifier_string,
-                   this, SLOT (cutClipboard ()));
+  void
+  variable_editor_view::add_edit_actions (QMenu *menu, const QString& qualifier_string)
+  {
+    menu->addAction (resource_manager::icon ("edit-cut"),
+                     tr ("Cut") + qualifier_string,
+                     this, SLOT (cutClipboard ()));
 
-  menu->addAction (resource_manager::icon ("edit-copy"),
-                   tr ("Copy") + qualifier_string,
-                   this, SLOT (copyClipboard ()));
+    menu->addAction (resource_manager::icon ("edit-copy"),
+                     tr ("Copy") + qualifier_string,
+                     this, SLOT (copyClipboard ()));
 
-  menu->addAction (resource_manager::icon ("edit-paste"),
-                   tr ("Paste"),
-                   this, SLOT (pasteClipboard ()));
+    menu->addAction (resource_manager::icon ("edit-paste"),
+                     tr ("Paste"),
+                     this, SLOT (pasteClipboard ()));
 
-  // FIXME: Different icon for Paste Table?
+    // FIXME: Different icon for Paste Table?
 
-  menu->addAction (resource_manager::icon ("edit-paste"),
-                   tr ("Paste Table"),
-                   this, SLOT (pasteTableClipboard ()));
+    menu->addAction (resource_manager::icon ("edit-paste"),
+                     tr ("Paste Table"),
+                     this, SLOT (pasteTableClipboard ()));
 
-  menu->addSeparator ();
+    menu->addSeparator ();
 
-  menu->addAction (resource_manager::icon ("edit-delete"),
-                   tr ("Clear") + qualifier_string,
-                   this, SLOT (clearContent ()));
+    menu->addAction (resource_manager::icon ("edit-delete"),
+                     tr ("Clear") + qualifier_string,
+                     this, SLOT (clearContent ()));
 
-  menu->addAction (resource_manager::icon ("edit-delete"),
-                   tr ("Delete") + qualifier_string,
-                   this, SLOT (delete_selected ()));
+    menu->addAction (resource_manager::icon ("edit-delete"),
+                     tr ("Delete") + qualifier_string,
+                     this, SLOT (delete_selected ()));
 
-  menu->addAction (resource_manager::icon ("document-new"),
-                   tr ("Variable from Selection"),
-                   this, SLOT (createVariable ()));
-}
+    menu->addAction (resource_manager::icon ("document-new"),
+                     tr ("Variable from Selection"),
+                     this, SLOT (createVariable ()));
+  }
 
-void
-variable_editor_view::createContextMenu (const QPoint& qpos)
-{
-  QModelIndex index = indexAt (qpos);
+  void
+  variable_editor_view::createContextMenu (const QPoint& qpos)
+  {
+    QModelIndex index = indexAt (qpos);
 
-  if (index.isValid ())
-    {
-      QMenu *menu = new QMenu (this);
+    if (index.isValid ())
+      {
+        QMenu *menu = new QMenu (this);
 
-      add_edit_actions (menu, tr (""));
+        add_edit_actions (menu, tr (""));
 
-      // FIXME: addAction for sort?
-      // FIXME: Add icon for transpose.
+        // FIXME: addAction for sort?
+        // FIXME: Add icon for transpose.
 
-      menu->addAction (tr ("Transpose"), this, SLOT (transposeContent ()));
+        menu->addAction (tr ("Transpose"), this, SLOT (transposeContent ()));
 
-      QItemSelectionModel *sel = selectionModel ();
+        QItemSelectionModel *sel = selectionModel ();
 
-      QList<QModelIndex> indices = sel->selectedIndexes ();
+        QList<QModelIndex> indices = sel->selectedIndexes ();
 
-      if (! indices.isEmpty ())
-        {
-          menu->addSeparator ();
+        if (! indices.isEmpty ())
+          {
+            menu->addSeparator ();
 
-          QSignalMapper *plot_mapper = make_plot_mapper (menu);
+            QSignalMapper *plot_mapper = make_plot_mapper (menu);
 
-          connect (plot_mapper, SIGNAL (mapped (const QString&)),
-                   this, SLOT (selected_command_requested (const QString&)));
-        }
+            connect (plot_mapper, SIGNAL (mapped (const QString&)),
+                     this, SLOT (selected_command_requested (const QString&)));
+          }
 
-      menu->exec (mapToGlobal (qpos));
-    }
-}
+        menu->exec (mapToGlobal (qpos));
+      }
+  }
 
-void
-variable_editor_view::createColumnMenu (const QPoint& pt)
-{
-  int index = horizontalHeader ()->logicalIndexAt (pt);
+  void
+  variable_editor_view::createColumnMenu (const QPoint& pt)
+  {
+    int index = horizontalHeader ()->logicalIndexAt (pt);
 
-  if (index < 0 || index > model ()->columnCount ())
-    return;
+    if (index < 0 || index > model ()->columnCount ())
+      return;
 
-  QList<int> coords = range_selected ();
+    QList<int> coords = range_selected ();
 
-  bool nothingSelected = coords.isEmpty ();
+    bool nothingSelected = coords.isEmpty ();
 
-  bool whole_columns_selected
-    =  (nothingSelected
-        ? false
-        : (coords[0] == 1 && coords[1] == model ()->rowCount ()));
+    bool whole_columns_selected
+      =  (nothingSelected
+          ? false
+          : (coords[0] == 1 && coords[1] == model ()->rowCount ()));
 
-  bool current_column_selected
-    = nothingSelected ? false : (coords[2] <= index+1 && coords[3] > index);
+    bool current_column_selected
+      = nothingSelected ? false : (coords[2] <= index+1 && coords[3] > index);
 
-  int column_selection_count
-    = nothingSelected ? 0 : (coords[3] - coords[2] + 1);
+    int column_selection_count
+      = nothingSelected ? 0 : (coords[3] - coords[2] + 1);
 
-  if (! whole_columns_selected || ! current_column_selected)
-    {
-      selectColumn (index);
-      column_selection_count = 1;
-      current_column_selected = true;
-      whole_columns_selected = true;
-    }
+    if (! whole_columns_selected || ! current_column_selected)
+      {
+        selectColumn (index);
+        column_selection_count = 1;
+        current_column_selected = true;
+        whole_columns_selected = true;
+      }
 
-  QString column_string
-    = tr (column_selection_count > 1 ? " columns" : " column");
+    QString column_string
+      = tr (column_selection_count > 1 ? " columns" : " column");
 
-  QMenu *menu = new QMenu (this);
+    QMenu *menu = new QMenu (this);
 
-  add_edit_actions (menu, column_string);
+    add_edit_actions (menu, column_string);
 
-  menu->addSeparator ();
+    menu->addSeparator ();
 
-  QSignalMapper *plot_mapper = make_plot_mapper (menu);
+    QSignalMapper *plot_mapper = make_plot_mapper (menu);
 
-  connect (plot_mapper, SIGNAL (mapped (const QString&)),
-           this, SLOT (selected_command_requested (const QString&)));
+    connect (plot_mapper, SIGNAL (mapped (const QString&)),
+             this, SLOT (selected_command_requested (const QString&)));
 
-  QPoint menupos = pt;
-  menupos.setY (horizontalHeader ()->height ());
+    QPoint menupos = pt;
+    menupos.setY (horizontalHeader ()->height ());
 
-  menu->exec (mapToGlobal (menupos));
-}
+    menu->exec (mapToGlobal (menupos));
+  }
 
-void
-variable_editor_view::createRowMenu (const QPoint& pt)
-{
-  int index = verticalHeader ()->logicalIndexAt (pt);
+  void
+  variable_editor_view::createRowMenu (const QPoint& pt)
+  {
+    int index = verticalHeader ()->logicalIndexAt (pt);
 
-  if (index < 0 || index > model ()->columnCount ())
-    return;
+    if (index < 0 || index > model ()->columnCount ())
+      return;
 
-  QList<int> coords = range_selected ();
+    QList<int> coords = range_selected ();
 
-  bool nothingSelected = coords.isEmpty ();
+    bool nothingSelected = coords.isEmpty ();
 
-  bool whole_rows_selected
-    = (nothingSelected
-       ? false
-       : (coords[2] == 1 && coords[3] == model ()->columnCount ()));
+    bool whole_rows_selected
+      = (nothingSelected
+         ? false
+         : (coords[2] == 1 && coords[3] == model ()->columnCount ()));
 
-  bool current_row_selected
-    = (nothingSelected ? false : (coords[0] <= index+1 && coords[1] > index));
+    bool current_row_selected
+      = (nothingSelected ? false : (coords[0] <= index+1 && coords[1] > index));
 
-  int rowselection_count = nothingSelected ? 0 : (coords[3] - coords[2] + 1);
+    int rowselection_count = nothingSelected ? 0 : (coords[3] - coords[2] + 1);
 
-  if (! whole_rows_selected || ! current_row_selected)
-    {
-      selectRow (index);
-      rowselection_count = 1;
-      current_row_selected = true;
-      whole_rows_selected = true;
-    }
+    if (! whole_rows_selected || ! current_row_selected)
+      {
+        selectRow (index);
+        rowselection_count = 1;
+        current_row_selected = true;
+        whole_rows_selected = true;
+      }
 
-  QString row_string = tr (rowselection_count > 1 ? " rows" : " row");
+    QString row_string = tr (rowselection_count > 1 ? " rows" : " row");
 
-  QMenu *menu = new QMenu (this);
+    QMenu *menu = new QMenu (this);
 
-  add_edit_actions (menu, row_string);
+    add_edit_actions (menu, row_string);
 
-  menu->addSeparator ();
+    menu->addSeparator ();
 
-  QSignalMapper *plot_mapper = make_plot_mapper (menu);
+    QSignalMapper *plot_mapper = make_plot_mapper (menu);
 
-  connect (plot_mapper, SIGNAL (mapped (const QString&)),
-           this, SLOT (selected_command_requested (const QString&)));
+    connect (plot_mapper, SIGNAL (mapped (const QString&)),
+             this, SLOT (selected_command_requested (const QString&)));
 
-  QPoint menupos = pt;
-  menupos.setX (verticalHeader ()->width ());
+    QPoint menupos = pt;
+    menupos.setX (verticalHeader ()->width ());
 
-  // FIXME: What was the intent here?
-  // setY (verticalHeader ()->sectionPosition (index+1) +
-  //       verticalHeader ()->sectionSize (index));
+    // FIXME: What was the intent here?
+    // setY (verticalHeader ()->sectionPosition (index+1) +
+    //       verticalHeader ()->sectionSize (index));
 
-  menu->exec (mapToGlobal (menupos));
-}
+    menu->exec (mapToGlobal (menupos));
+  }
 
-void
-variable_editor_view::createVariable (void)
-{
-  // FIXME: Create unnamed1..n if exist ('unnamed', 'var') is true.
+  void
+  variable_editor_view::createVariable (void)
+  {
+    // FIXME: Create unnamed1..n if exist ('unnamed', 'var') is true.
 
-  selected_command_requested ("unnamed = %1");
-}
+    selected_command_requested ("unnamed = %1");
+  }
 
-void
-variable_editor_view::transposeContent (void)
-{
-  if (! hasFocus ())
-    return;
+  void
+  variable_editor_view::transposeContent (void)
+  {
+    if (! hasFocus ())
+      return;
 
-  emit command_signal (QString ("%1 = %1';").arg (objectName ()));
-}
+    emit command_signal (QString ("%1 = %1';").arg (objectName ()));
+  }
 
-void
-variable_editor_view::delete_selected (void)
-{
-  if (! hasFocus ())
-    return;
-
-  QAbstractItemModel *mod = model ();
-  QList<int> coords = range_selected ();
+  void
+  variable_editor_view::delete_selected (void)
+  {
+    if (! hasFocus ())
+      return;
 
-  if (coords.isEmpty ())
-    return;
+    QAbstractItemModel *mod = model ();
+    QList<int> coords = range_selected ();
 
-  bool whole_columns_selected
-    = coords[0] == 1 && coords[1] == mod->rowCount ();
+    if (coords.isEmpty ())
+      return;
 
-  bool whole_rows_selected
-    = coords[2] == 1 && coords[3] == mod->columnCount ();
+    bool whole_columns_selected
+      = coords[0] == 1 && coords[1] == mod->rowCount ();
 
-  // Must be deleting whole columns or whole rows, and not the whole thing.
+    bool whole_rows_selected
+      = coords[2] == 1 && coords[3] == mod->columnCount ();
 
-  if (whole_columns_selected == whole_rows_selected)
-    return;
+    // Must be deleting whole columns or whole rows, and not the whole thing.
 
-  if (whole_rows_selected)
-    mod->removeRows (coords[0], coords[1] - coords[0]);
+    if (whole_columns_selected == whole_rows_selected)
+      return;
 
-  if (whole_columns_selected)
-    mod->removeColumns (coords[2], coords[3] - coords[2]);
-}
+    if (whole_rows_selected)
+      mod->removeRows (coords[0], coords[1] - coords[0]);
 
-void
-variable_editor_view::clearContent (void)
-{
-  if (! hasFocus ())
-    return;
-
-  if (m_var_model == nullptr)
-    return;
+    if (whole_columns_selected)
+      mod->removeColumns (coords[2], coords[3] - coords[2]);
+  }
 
-  QItemSelectionModel *sel = selectionModel ();
-  QList<QModelIndex> indices = sel->selectedIndexes ();
+  void
+  variable_editor_view::clearContent (void)
+  {
+    if (! hasFocus ())
+      return;
 
-  // FIXME: Use [] for empty cells?
+    if (m_var_model == nullptr)
+      return;
 
-  for (const auto& idx : indices)
-    m_var_model->clear_content (idx);
-}
+    QItemSelectionModel *sel = selectionModel ();
+    QList<QModelIndex> indices = sel->selectedIndexes ();
+
+    // FIXME: Use [] for empty cells?
 
-void
-variable_editor_view::cutClipboard (void)
-{
-  copyClipboard ();
+    for (const auto& idx : indices)
+      m_var_model->clear_content (idx);
+  }
 
-  clearContent ();
-}
+  void
+  variable_editor_view::cutClipboard (void)
+  {
+    copyClipboard ();
+
+    clearContent ();
+  }
 
-void
-variable_editor_view::copyClipboard (void)
-{
-  if (! hasFocus ())
-    return;
+  void
+  variable_editor_view::copyClipboard (void)
+  {
+    if (! hasFocus ())
+      return;
 
-  QItemSelectionModel *sel = selectionModel ();
-  QList<QModelIndex> indices = sel->selectedIndexes ();
-  qSort (indices);
+    QItemSelectionModel *sel = selectionModel ();
+    QList<QModelIndex> indices = sel->selectedIndexes ();
+    qSort (indices);
 
-  if (indices.isEmpty ())
-    return;
+    if (indices.isEmpty ())
+      return;
 
-  // Convert selected items into TSV format and copy that.
-  // Spreadsheet tools should understand that.
+    // Convert selected items into TSV format and copy that.
+    // Spreadsheet tools should understand that.
 
-  QAbstractItemModel *mod = model ();
-  QModelIndex previous = indices.first ();
-  QString copy = mod->data (previous).toString ();
-  indices.removeFirst ();
-  foreach (QModelIndex idx, indices)
-    {
-      copy.push_back (previous.row () != idx.row () ? '\n' : '\t');
-      copy.append (mod->data (idx).toString ());
-      previous = idx;
-    }
+    QAbstractItemModel *mod = model ();
+    QModelIndex previous = indices.first ();
+    QString copy = mod->data (previous).toString ();
+    indices.removeFirst ();
+    foreach (QModelIndex idx, indices)
+      {
+        copy.push_back (previous.row () != idx.row () ? '\n' : '\t');
+        copy.append (mod->data (idx).toString ());
+        previous = idx;
+      }
 
-  QClipboard *clipboard = QApplication::clipboard ();
-  clipboard->setText (copy);
-}
+    QClipboard *clipboard = QApplication::clipboard ();
+    clipboard->setText (copy);
+  }
 
-void
-variable_editor_view::pasteClipboard (void)
-{
-  if (! hasFocus ())
-    return;
-
-  QAbstractItemModel *mod = model ();
-  QItemSelectionModel *sel = selectionModel ();
-  QList<QModelIndex> indices = sel->selectedIndexes ();
+  void
+  variable_editor_view::pasteClipboard (void)
+  {
+    if (! hasFocus ())
+      return;
 
-  QClipboard *clipboard = QApplication::clipboard ();
-  QString text = clipboard->text ();
+    QAbstractItemModel *mod = model ();
+    QItemSelectionModel *sel = selectionModel ();
+    QList<QModelIndex> indices = sel->selectedIndexes ();
 
-  if (indices.isEmpty ())
-    {
-      if (size () == QSize (1,1))
-        mod->setData (mod->index (0,0), text.toDouble ());
-      else if (size () == QSize (0,0))
-        {
-          mod->insertColumn (0);
-          mod->insertRow (0);
+    QClipboard *clipboard = QApplication::clipboard ();
+    QString text = clipboard->text ();
+
+    if (indices.isEmpty ())
+      {
+        if (size () == QSize (1,1))
           mod->setData (mod->index (0,0), text.toDouble ());
-        }
-    }
-  else
-    {
-      QStringList cells = text.split(QRegExp("\n|\r\n|\r"));
-      int clen = cells.size ();
-      for (int i = 0; i < indices.size (); i++)
-        mod->setData (indices[i], cells.at (i % clen).toDouble ());
-    }
-}
+        else if (size () == QSize (0,0))
+          {
+            mod->insertColumn (0);
+            mod->insertRow (0);
+            mod->setData (mod->index (0,0), text.toDouble ());
+          }
+      }
+    else
+      {
+        QStringList cells = text.split(QRegExp("\n|\r\n|\r"));
+        int clen = cells.size ();
+        for (int i = 0; i < indices.size (); i++)
+          mod->setData (indices[i], cells.at (i % clen).toDouble ());
+      }
+  }
 
-void variable_editor_view::pasteTableClipboard (void)
-{
-  if (! hasFocus ())
-    return;
+  void variable_editor_view::pasteTableClipboard (void)
+  {
+    if (! hasFocus ())
+      return;
 
-  QAbstractItemModel *mod = model ();
-  QItemSelectionModel *sel = selectionModel ();
-  QList<QModelIndex> indices = sel->selectedIndexes ();
+    QAbstractItemModel *mod = model ();
+    QItemSelectionModel *sel = selectionModel ();
+    QList<QModelIndex> indices = sel->selectedIndexes ();
 
-  QClipboard *clipboard = QApplication::clipboard ();
-  QString text = clipboard->text ();
+    QClipboard *clipboard = QApplication::clipboard ();
+    QString text = clipboard->text ();
 
-  QPoint start, end;
+    QPoint start, end;
 
-  QPoint tabsize = QPoint (mod->rowCount (), mod->columnCount ());
+    QPoint tabsize = QPoint (mod->rowCount (), mod->columnCount ());
 
-  if (indices.isEmpty ())
-    {
-      start = QPoint (0,0);
-      end = tabsize;
-    }
-  else if (indices.size () == 1)
-    {
-      start = QPoint (indices[0].row (), indices[0].column ());
-      end = tabsize;
-    }
-  else
-    {
-      end = QPoint (0,0);
-      start = tabsize;
-
-      for (int i = 0; i < indices.size (); i++)
-        {
-          if (indices[i].column () < start.y ())
-            start.setY (indices[i].column ());
+    if (indices.isEmpty ())
+      {
+        start = QPoint (0,0);
+        end = tabsize;
+      }
+    else if (indices.size () == 1)
+      {
+        start = QPoint (indices[0].row (), indices[0].column ());
+        end = tabsize;
+      }
+    else
+      {
+        end = QPoint (0,0);
+        start = tabsize;
 
-          if (indices[i].column () > end.y ())
-            end.setY (indices[i].column ());
+        for (int i = 0; i < indices.size (); i++)
+          {
+            if (indices[i].column () < start.y ())
+              start.setY (indices[i].column ());
 
-          if (indices[i].row () < start.x ())
-            start.setX (indices[i].column ());
+            if (indices[i].column () > end.y ())
+              end.setY (indices[i].column ());
 
-          if (indices[i].row () > end.x ())
-            end.setX (indices[i].column ());
-        }
-    }
+            if (indices[i].row () < start.x ())
+              start.setX (indices[i].column ());
 
-  int rownum = 0;
-  int colnum = 0;
+            if (indices[i].row () > end.x ())
+              end.setX (indices[i].column ());
+          }
+      }
 
-  QStringList rows = text.split ('\n');
-  for (const auto& row : rows)
-    {
-      if (rownum > end.x () - start.x ())
-        continue;
+    int rownum = 0;
+    int colnum = 0;
 
-      QStringList cols = row.split ('\t');
-      if (cols.isEmpty ())
-        continue;
+    QStringList rows = text.split ('\n');
+    for (const auto& row : rows)
+      {
+        if (rownum > end.x () - start.x ())
+          continue;
 
-      for (const auto& col : cols)
-        {
-          if (col.isEmpty ())
-            continue;
-          if (colnum > end.y () - start.y () )
-            continue;
+        QStringList cols = row.split ('\t');
+        if (cols.isEmpty ())
+          continue;
 
-          mod->setData (mod->index (rownum + start.x (),
-                                    colnum + start.y ()),
-                        QVariant (col));
+        for (const auto& col : cols)
+          {
+            if (col.isEmpty ())
+              continue;
+            if (colnum > end.y () - start.y () )
+              continue;
 
-          colnum++;
-        }
+            mod->setData (mod->index (rownum + start.x (),
+                                      colnum + start.y ()),
+                          QVariant (col));
 
-      colnum = 0;
-      rownum++;
-    }
-}
+            colnum++;
+          }
+
+        colnum = 0;
+        rownum++;
+      }
+  }
 
-void
-variable_editor_view::handle_horizontal_scroll_action (int action)
-{
-  if (action == QAbstractSlider::SliderSingleStepAdd
-      || action == QAbstractSlider::SliderPageStepAdd
-      || action == QAbstractSlider::SliderToMaximum
-      || action == QAbstractSlider::SliderMove)
-    {
-      if (m_var_model != nullptr)
-        {
-          QScrollBar *sb = horizontalScrollBar ();
+  void
+  variable_editor_view::handle_horizontal_scroll_action (int action)
+  {
+    if (action == QAbstractSlider::SliderSingleStepAdd
+        || action == QAbstractSlider::SliderPageStepAdd
+        || action == QAbstractSlider::SliderToMaximum
+        || action == QAbstractSlider::SliderMove)
+      {
+        if (m_var_model != nullptr)
+          {
+            QScrollBar *sb = horizontalScrollBar ();
 
-          if (sb && sb->value () == sb->maximum ())
-            {
-              int new_cols = m_var_model->display_columns () + 16;
+            if (sb && sb->value () == sb->maximum ())
+              {
+                int new_cols = m_var_model->display_columns () + 16;
 
-              m_var_model->maybe_resize_columns (new_cols);
-            }
-        }
-    }
-}
+                m_var_model->maybe_resize_columns (new_cols);
+              }
+          }
+      }
+  }
 
-void
-variable_editor_view::handle_vertical_scroll_action (int action)
-{
-  if (action == QAbstractSlider::SliderSingleStepAdd
-      || action == QAbstractSlider::SliderPageStepAdd
-      || action == QAbstractSlider::SliderToMaximum
-      || action == QAbstractSlider::SliderMove)
-    {
-      if (m_var_model != nullptr)
-        {
-          QScrollBar *sb = verticalScrollBar ();
+  void
+  variable_editor_view::handle_vertical_scroll_action (int action)
+  {
+    if (action == QAbstractSlider::SliderSingleStepAdd
+        || action == QAbstractSlider::SliderPageStepAdd
+        || action == QAbstractSlider::SliderToMaximum
+        || action == QAbstractSlider::SliderMove)
+      {
+        if (m_var_model != nullptr)
+          {
+            QScrollBar *sb = verticalScrollBar ();
 
-          if (sb && sb->value () == sb->maximum ())
-            {
-              int new_rows = m_var_model->display_rows () + 16;
+            if (sb && sb->value () == sb->maximum ())
+              {
+                int new_rows = m_var_model->display_rows () + 16;
 
-              m_var_model->maybe_resize_rows (new_rows);
-            }
-        }
-    }
-}
+                m_var_model->maybe_resize_rows (new_rows);
+              }
+          }
+      }
+  }
 
 
-// Gadgets for focus restoration
+  // Gadgets for focus restoration
 
-HoverToolButton::HoverToolButton (QWidget *parent)
-  : QToolButton (parent)
-{
-  installEventFilter (this);
-}
+  HoverToolButton::HoverToolButton (QWidget *parent)
+    : QToolButton (parent)
+  {
+    installEventFilter (this);
+  }
 
-bool HoverToolButton::eventFilter (QObject *obj, QEvent *ev)
-{
-  if (ev->type () == QEvent::HoverEnter)
-    emit hovered_signal ();
-  else if (ev->type () == QEvent::MouseButtonPress ||
-           ev->type () == QEvent::MouseButtonPress)
-    emit popup_shown_signal ();
+  bool HoverToolButton::eventFilter (QObject *obj, QEvent *ev)
+  {
+    if (ev->type () == QEvent::HoverEnter)
+      emit hovered_signal ();
+    else if (ev->type () == QEvent::MouseButtonPress ||
+             ev->type () == QEvent::MouseButtonPress)
+      emit popup_shown_signal ();
 
-  return QToolButton::eventFilter (obj, ev);
-}
+    return QToolButton::eventFilter (obj, ev);
+  }
 
-ReturnFocusToolButton::ReturnFocusToolButton (QWidget *parent)
-  : HoverToolButton (parent)
-{
-  installEventFilter (this);
-}
+  ReturnFocusToolButton::ReturnFocusToolButton (QWidget *parent)
+    : HoverToolButton (parent)
+  {
+    installEventFilter (this);
+  }
 
-bool ReturnFocusToolButton::eventFilter (QObject *obj, QEvent *ev)
-{
+  bool ReturnFocusToolButton::eventFilter (QObject *obj, QEvent *ev)
+  {
 
-  if (ev->type () == QEvent::MouseButtonRelease && isDown ())
-    {
-      emit about_to_activate ();
+    if (ev->type () == QEvent::MouseButtonRelease && isDown ())
+      {
+        emit about_to_activate ();
 
-      setDown (false);
-      QAction *action = defaultAction ();
-      if (action != nullptr)
-        action->activate (QAction::Trigger);
+        setDown (false);
+        QAction *action = defaultAction ();
+        if (action != nullptr)
+          action->activate (QAction::Trigger);
 
-      return true;
-    }
+        return true;
+      }
 
-  return HoverToolButton::eventFilter (obj, ev);
-}
+    return HoverToolButton::eventFilter (obj, ev);
+  }
 
-ReturnFocusMenu::ReturnFocusMenu (QWidget *parent)
-  : QMenu (parent)
-{
-  installEventFilter (this);
-}
+  ReturnFocusMenu::ReturnFocusMenu (QWidget *parent)
+    : QMenu (parent)
+  {
+    installEventFilter (this);
+  }
 
-bool ReturnFocusMenu::eventFilter (QObject *obj, QEvent *ev)
-{
-  if (ev->type () == QEvent::MouseButtonRelease && underMouse ())
-    {
-      emit about_to_activate ();
-    }
+  bool ReturnFocusMenu::eventFilter (QObject *obj, QEvent *ev)
+  {
+    if (ev->type () == QEvent::MouseButtonRelease && underMouse ())
+      {
+        emit about_to_activate ();
+      }
 
-  return QMenu::eventFilter (obj, ev);
-}
+    return QMenu::eventFilter (obj, ev);
+  }
 
-// Variable editor.
+  // Variable editor.
 
-variable_editor::variable_editor (QWidget *p)
-  : octave_dock_widget (p),
-    m_main (new QMainWindow ()),
-    m_tool_bar (new QToolBar (m_main)),
-    m_default_width (30),
-    m_default_height (100),
-    m_add_font_height (0),
-    m_use_terminal_font (true),
-    m_alternate_rows (true),
-    m_stylesheet (""),
-    m_font (),
-    m_sel_font (),
-    m_table_colors (),
-    m_current_focus_vname (""),
-    m_hovered_focus_vname ("")
-{
-  setObjectName ("variable_editor");
-  set_title (tr ("Variable Editor"));
-  setStatusTip (tr ("Edit variables."));
-  setWindowIcon (QIcon (":/actions/icons/logo.png"));
-  setFocusPolicy (Qt::NoFocus);
-  setAttribute (Qt::WA_AlwaysShowToolTips);
+  variable_editor::variable_editor (QWidget *p)
+    : octave_dock_widget (p),
+      m_main (new QMainWindow ()),
+      m_tool_bar (new QToolBar (m_main)),
+      m_default_width (30),
+      m_default_height (100),
+      m_add_font_height (0),
+      m_use_terminal_font (true),
+      m_alternate_rows (true),
+      m_stylesheet (""),
+      m_font (),
+      m_sel_font (),
+      m_table_colors (),
+      m_current_focus_vname (""),
+      m_hovered_focus_vname ("")
+  {
+    setObjectName ("variable_editor");
+    set_title (tr ("Variable Editor"));
+    setStatusTip (tr ("Edit variables."));
+    setWindowIcon (QIcon (":/actions/icons/logo.png"));
+    setFocusPolicy (Qt::NoFocus);
+    setAttribute (Qt::WA_AlwaysShowToolTips);
 
-  // Tool Bar.
+    // Tool Bar.
 
-  construct_tool_bar ();
-  m_main->addToolBar (m_tool_bar);
-  m_main->setFocusPolicy (Qt::NoFocus);
-  setFocusPolicy (Qt::NoFocus);
+    construct_tool_bar ();
+    m_main->addToolBar (m_tool_bar);
+    m_main->setFocusPolicy (Qt::NoFocus);
+    setFocusPolicy (Qt::NoFocus);
 
-  // Colors.
+    // Colors.
 
-  for (int i = 0; i < resource_manager::varedit_color_chars ().length (); i++)
-    m_table_colors.append (QColor (Qt::white));
+    for (int i = 0; i < resource_manager::varedit_color_chars ().length (); i++)
+      m_table_colors.append (QColor (Qt::white));
 
-  // Use an MDI area that is shrunk to nothing as the central widget.
-  // Future feature might be to switch to MDI mode in which the dock
-  // area is shrunk to nothing and the widgets live in the MDI window.
+    // Use an MDI area that is shrunk to nothing as the central widget.
+    // Future feature might be to switch to MDI mode in which the dock
+    // area is shrunk to nothing and the widgets live in the MDI window.
 
-  QMdiArea *central_mdiarea = new QMdiArea (m_main);
-  central_mdiarea->setMinimumSize (QSize (0, 0));
-  central_mdiarea->setMaximumSize (QSize (0, 0));
-  central_mdiarea->resize (QSize (0, 0));
-  m_main->setCentralWidget (central_mdiarea);
+    QMdiArea *central_mdiarea = new QMdiArea (m_main);
+    central_mdiarea->setMinimumSize (QSize (0, 0));
+    central_mdiarea->setMaximumSize (QSize (0, 0));
+    central_mdiarea->resize (QSize (0, 0));
+    m_main->setCentralWidget (central_mdiarea);
 
-  m_main->setParent (this);
-  m_main->setDockOptions (QMainWindow::AllowNestedDocks |
-                          QMainWindow::VerticalTabs);
-  setWidget (m_main);
+    m_main->setParent (this);
+    m_main->setDockOptions (QMainWindow::AllowNestedDocks |
+                            QMainWindow::VerticalTabs);
+    setWidget (m_main);
 
-  connect (this, SIGNAL (command_signal (const QString&)),
-           p, SLOT (execute_command_in_terminal (const QString&)));
-}
+    connect (this, SIGNAL (command_signal (const QString&)),
+             p, SLOT (execute_command_in_terminal (const QString&)));
+  }
 
-// Add an action to a menu or the widget itself.
+  // Add an action to a menu or the widget itself.
 
-QAction*
-variable_editor::add_action (QMenu *menu, const QIcon& icon, const QString& text,
-                             const char *member)
-{
-  QAction *a;
+  QAction*
+  variable_editor::add_action (QMenu *menu, const QIcon& icon, const QString& text,
+                               const char *member)
+  {
+    QAction *a;
 
-  if (menu)
-    a = menu->addAction (icon, text, this, member);
-  else
-    {
-      a = new QAction (this);
-      connect (a, SIGNAL (triggered ()), this, member);
-    }
+    if (menu)
+      a = menu->addAction (icon, text, this, member);
+    else
+      {
+        a = new QAction (this);
+        connect (a, SIGNAL (triggered ()), this, member);
+      }
 
-  addAction (a);  // important for shortcut context
-  a->setShortcutContext (Qt::WidgetWithChildrenShortcut);
+    addAction (a);  // important for shortcut context
+    a->setShortcutContext (Qt::WidgetWithChildrenShortcut);
 
-  return a;
-}
+    return a;
+  }
 
-void
-variable_editor::edit_variable (const QString& name, const octave_value& val)
-{
-  if (m_stylesheet.isEmpty ())
-    {
-      QSettings *settings = resource_manager::get_settings ();
-      notice_settings (settings);
-    }
+  void
+  variable_editor::edit_variable (const QString& name, const octave_value& val)
+  {
+    if (m_stylesheet.isEmpty ())
+      {
+        QSettings *settings = resource_manager::get_settings ();
+        notice_settings (settings);
+      }
 
-  QDockWidget *existing_qdw = m_main->findChild<QDockWidget *> (name);
-  if (existing_qdw != NULL)
-    {
-      // Already open.
+    QDockWidget *existing_qdw = m_main->findChild<QDockWidget *> (name);
+    if (existing_qdw != NULL)
+      {
+        // Already open.
 
-      // Put current focused variable out of focus
-      QFocusEvent event (QEvent::FocusOut, Qt::OtherFocusReason);
-      QApplication::sendEvent (m_main->focusWidget (), &event);
+        // Put current focused variable out of focus
+        QFocusEvent event (QEvent::FocusOut, Qt::OtherFocusReason);
+        QApplication::sendEvent (m_main->focusWidget (), &event);
 
-      // Put existing variable in focus and raise
-      event = QFocusEvent (QEvent::FocusIn, Qt::OtherFocusReason);
-      QApplication::sendEvent (existing_qdw, &event);
-      existing_qdw->show ();
-      existing_qdw->raise ();
-      existing_qdw->setFocus ();
+        // Put existing variable in focus and raise
+        event = QFocusEvent (QEvent::FocusIn, Qt::OtherFocusReason);
+        QApplication::sendEvent (existing_qdw, &event);
+        existing_qdw->show ();
+        existing_qdw->raise ();
+        existing_qdw->setFocus ();
 
-      return;
-    }
+        return;
+      }
 
-  variable_dock_widget *page = new variable_dock_widget (this);
-  page->setObjectName (name);
-  page->setAllowedAreas(Qt::LeftDockWidgetArea |
-                        Qt::RightDockWidgetArea);
-  m_main->addDockWidget (Qt::LeftDockWidgetArea, page);
+    variable_dock_widget *page = new variable_dock_widget (this);
+    page->setObjectName (name);
+    page->setAllowedAreas(Qt::LeftDockWidgetArea |
+                          Qt::RightDockWidgetArea);
+    m_main->addDockWidget (Qt::LeftDockWidgetArea, page);
 
-  connect (QApplication::instance(), SIGNAL (focusChanged (QWidget *, QWidget *)),
-           page, SLOT (handle_focus_change (QWidget *, QWidget *)));
-  connect (page, SIGNAL (destroyed (QObject *)),
-           this, SLOT (variable_destroyed (QObject *)));
-  connect (page, SIGNAL (variable_focused_signal (const QString&)),
-           this, SLOT (variable_focused (const QString&)));
+    connect (QApplication::instance(), SIGNAL (focusChanged (QWidget *, QWidget *)),
+             page, SLOT (handle_focus_change (QWidget *, QWidget *)));
+    connect (page, SIGNAL (destroyed (QObject *)),
+             this, SLOT (variable_destroyed (QObject *)));
+    connect (page, SIGNAL (variable_focused_signal (const QString&)),
+             this, SLOT (variable_focused (const QString&)));
 
-  variable_editor_stack *stack = new variable_editor_stack (page);
-  stack->setObjectName (name);
-  page->setWidget (stack);
-  page->setFocusProxy (stack);
+    variable_editor_stack *stack = new variable_editor_stack (page);
+    stack->setObjectName (name);
+    page->setWidget (stack);
+    page->setFocusProxy (stack);
 
-  connect (stack, SIGNAL (command_signal (const QString&)),
-           this, SIGNAL (command_signal (const QString&)));
-  connect (stack, SIGNAL (edit_variable_signal (const QString&, const octave_value&)),
-           this, SLOT (edit_variable (const QString&, const octave_value&)));
-  connect (this, SIGNAL (level_up_signal ()),
-           stack, SLOT (levelUp ()));
-  connect (this, SIGNAL (save_signal ()),
-           stack, SLOT (save ()));
+    connect (stack, SIGNAL (command_signal (const QString&)),
+             this, SIGNAL (command_signal (const QString&)));
+    connect (stack, SIGNAL (edit_variable_signal (const QString&, const octave_value&)),
+             this, SLOT (edit_variable (const QString&, const octave_value&)));
+    connect (this, SIGNAL (level_up_signal ()),
+             stack, SLOT (levelUp ()));
+    connect (this, SIGNAL (save_signal ()),
+             stack, SLOT (save ()));
 
-  variable_editor_view *edit_view = stack->edit_view ();
+    variable_editor_view *edit_view = stack->edit_view ();
 
-  edit_view->setObjectName (name);
-  edit_view->setFont (m_font);
-  edit_view->setStyleSheet (m_stylesheet);
-  edit_view->setAlternatingRowColors (m_alternate_rows);
-  edit_view->verticalHeader ()->setDefaultSectionSize (m_default_height
-                                                       + m_add_font_height);
+    edit_view->setObjectName (name);
+    edit_view->setFont (m_font);
+    edit_view->setStyleSheet (m_stylesheet);
+    edit_view->setAlternatingRowColors (m_alternate_rows);
+    edit_view->verticalHeader ()->setDefaultSectionSize (m_default_height
+                                                         + m_add_font_height);
 
-  connect (edit_view, SIGNAL (command_signal (const QString&)),
-           this, SIGNAL (command_signal (const QString&)));
-  connect (this, SIGNAL (delete_selected_signal ()),
-           edit_view, SLOT (delete_selected ()));
-  connect (this, SIGNAL (clear_content_signal ()),
-           edit_view, SLOT (clearContent ()));
-  connect (this, SIGNAL (copy_clipboard_signal ()),
-           edit_view, SLOT (copyClipboard ()));
-  connect (this, SIGNAL (paste_clipboard_signal ()),
-           edit_view, SLOT (pasteClipboard ()));
-  connect (this, SIGNAL (paste_table_clipboard_signal ()),
-           edit_view, SLOT (pasteTableClipboard ()));
-  connect (this, SIGNAL (selected_command_signal (const QString&)),
-           edit_view, SLOT (selected_command_requested (const QString&)));
-  connect (edit_view->horizontalHeader (),
-           SIGNAL (customContextMenuRequested (const QPoint&)),
-           edit_view, SLOT (createColumnMenu (const QPoint&)));
-  connect (edit_view->verticalHeader (),
-           SIGNAL (customContextMenuRequested (const QPoint&)),
-           edit_view, SLOT (createRowMenu (const QPoint&)));
-  connect (edit_view, SIGNAL (customContextMenuRequested (const QPoint&)),
-           edit_view, SLOT (createContextMenu (const QPoint&)));
-  connect (edit_view->horizontalScrollBar (), SIGNAL (actionTriggered (int)),
-           edit_view, SLOT (handle_horizontal_scroll_action (int)));
-  connect (edit_view->verticalScrollBar (), SIGNAL (actionTriggered (int)),
-           edit_view, SLOT (handle_vertical_scroll_action (int)));
+    connect (edit_view, SIGNAL (command_signal (const QString&)),
+             this, SIGNAL (command_signal (const QString&)));
+    connect (this, SIGNAL (delete_selected_signal ()),
+             edit_view, SLOT (delete_selected ()));
+    connect (this, SIGNAL (clear_content_signal ()),
+             edit_view, SLOT (clearContent ()));
+    connect (this, SIGNAL (copy_clipboard_signal ()),
+             edit_view, SLOT (copyClipboard ()));
+    connect (this, SIGNAL (paste_clipboard_signal ()),
+             edit_view, SLOT (pasteClipboard ()));
+    connect (this, SIGNAL (paste_table_clipboard_signal ()),
+             edit_view, SLOT (pasteTableClipboard ()));
+    connect (this, SIGNAL (selected_command_signal (const QString&)),
+             edit_view, SLOT (selected_command_requested (const QString&)));
+    connect (edit_view->horizontalHeader (),
+             SIGNAL (customContextMenuRequested (const QPoint&)),
+             edit_view, SLOT (createColumnMenu (const QPoint&)));
+    connect (edit_view->verticalHeader (),
+             SIGNAL (customContextMenuRequested (const QPoint&)),
+             edit_view, SLOT (createRowMenu (const QPoint&)));
+    connect (edit_view, SIGNAL (customContextMenuRequested (const QPoint&)),
+             edit_view, SLOT (createContextMenu (const QPoint&)));
+    connect (edit_view->horizontalScrollBar (), SIGNAL (actionTriggered (int)),
+             edit_view, SLOT (handle_horizontal_scroll_action (int)));
+    connect (edit_view->verticalScrollBar (), SIGNAL (actionTriggered (int)),
+             edit_view, SLOT (handle_vertical_scroll_action (int)));
 
-  variable_editor_model *model =
-    new variable_editor_model (name, val, stack);
+    variable_editor_model *model =
+      new variable_editor_model (name, val, stack);
 
-  connect (model, SIGNAL (edit_variable_signal (const QString&, const octave_value&)),
-           this, SLOT (edit_variable (const QString&, const octave_value&)));
-  connect (model, SIGNAL (dataChanged (const QModelIndex&, const QModelIndex&)),
-           this, SLOT (callUpdate (const QModelIndex&, const QModelIndex&)));
-  connect (this, SIGNAL (refresh_signal ()),
-           model, SLOT (update_data_cache ()));
-  connect (model, SIGNAL (set_editable_signal (bool)),
-           stack, SLOT (set_editable (bool)));
+    connect (model, SIGNAL (edit_variable_signal (const QString&, const octave_value&)),
+             this, SLOT (edit_variable (const QString&, const octave_value&)));
+    connect (model, SIGNAL (dataChanged (const QModelIndex&, const QModelIndex&)),
+             this, SLOT (callUpdate (const QModelIndex&, const QModelIndex&)));
+    connect (this, SIGNAL (refresh_signal ()),
+             model, SLOT (update_data_cache ()));
+    connect (model, SIGNAL (set_editable_signal (bool)),
+             stack, SLOT (set_editable (bool)));
 
-  edit_view->setModel (model);
-  connect (edit_view, SIGNAL (doubleClicked (const QModelIndex&)),
-           model, SLOT (double_click (const QModelIndex&)));
+    edit_view->setModel (model);
+    connect (edit_view, SIGNAL (doubleClicked (const QModelIndex&)),
+             model, SLOT (double_click (const QModelIndex&)));
 
-  // Must supply a title for a QLabel to be created.  Calling set_title()
-  // more than once will add more QLabels.  Could change octave_dock_widget
-  // to always supply a QLabl (initially empty) and then simply update its
-  // contents.
-  page->set_title (name);
-  QLabel *existing_ql = page->titleBarWidget ()->findChild<QLabel *> ();
-  connect (model, SIGNAL (update_label_signal (const QString&)),
-           existing_ql, SLOT (setText (const QString&)));
+    // Must supply a title for a QLabel to be created.  Calling set_title()
+    // more than once will add more QLabels.  Could change octave_dock_widget
+    // to always supply a QLabl (initially empty) and then simply update its
+    // contents.
+    page->set_title (name);
+    QLabel *existing_ql = page->titleBarWidget ()->findChild<QLabel *> ();
+    connect (model, SIGNAL (update_label_signal (const QString&)),
+             existing_ql, SLOT (setText (const QString&)));
 
-  model->update_data (val);
+    model->update_data (val);
 
-  QList<QTableView *> viewlist = findChildren<QTableView *> ();
-  if (viewlist.size () == 1)
-    m_tool_bar->setEnabled (true);
-}
+    QList<QTableView *> viewlist = findChildren<QTableView *> ();
+    if (viewlist.size () == 1)
+      m_tool_bar->setEnabled (true);
+  }
 
-void
-variable_editor::refresh (void)
-{
-  emit refresh_signal ();
-}
+  void
+  variable_editor::refresh (void)
+  {
+    emit refresh_signal ();
+  }
 
-QList<QColor>
-variable_editor::default_colors (void)
-{
-  QList<QColor> colorlist;
+  QList<QColor>
+  variable_editor::default_colors (void)
+  {
+    QList<QColor> colorlist;
 
-  colorlist << qApp->palette ().color (QPalette::WindowText);
-  colorlist << qApp->palette ().color (QPalette::Base);
-  colorlist << qApp->palette ().color (QPalette::HighlightedText);
-  colorlist << qApp->palette ().color (QPalette::Highlight);
-  colorlist << qApp->palette ().color (QPalette::AlternateBase);
+    colorlist << qApp->palette ().color (QPalette::WindowText);
+    colorlist << qApp->palette ().color (QPalette::Base);
+    colorlist << qApp->palette ().color (QPalette::HighlightedText);
+    colorlist << qApp->palette ().color (QPalette::Highlight);
+    colorlist << qApp->palette ().color (QPalette::AlternateBase);
 
-  return colorlist;
-}
+    return colorlist;
+  }
 
-QStringList
-variable_editor::color_names (void)
-{
-  QStringList output;
+  QStringList
+  variable_editor::color_names (void)
+  {
+    QStringList output;
 
-  output << "Foreground";
-  output << "Background";
-  output << "Selected Foreground";
-  output << "Selected Background";
-  output << "Alternate Background";
+    output << "Foreground";
+    output << "Background";
+    output << "Selected Foreground";
+    output << "Selected Background";
+    output << "Alternate Background";
 
-  return output;
-}
+    return output;
+  }
 
-void
-variable_editor::callUpdate (const QModelIndex&, const QModelIndex&)
-{
-  emit updated ();
-}
+  void
+  variable_editor::callUpdate (const QModelIndex&, const QModelIndex&)
+  {
+    emit updated ();
+  }
 
-void
-variable_editor::notice_settings (const QSettings *settings)
-{
-  // FIXME: Why use object->tostring->toint?  Why not just 100?
+  void
+  variable_editor::notice_settings (const QSettings *settings)
+  {
+    // FIXME: Why use object->tostring->toint?  Why not just 100?
 
-  m_default_width = settings->value ("variable_editor/column_width",
-                                     100).toInt ();
+    m_default_width = settings->value ("variable_editor/column_width",
+                                       100).toInt ();
 
-  m_default_height = settings->value ("variable_editor/row_height",
-                                      10).toInt ();
+    m_default_height = settings->value ("variable_editor/row_height",
+                                        10).toInt ();
 
-  m_alternate_rows = settings->value ("variable_editor/alternate_rows",
-                                      false).toBool ();
+    m_alternate_rows = settings->value ("variable_editor/alternate_rows",
+                                        false).toBool ();
 
-  QList<QColor> default_colors = resource_manager::varedit_default_colors ();
+    QList<QColor> default_colors = resource_manager::varedit_default_colors ();
 
-  QString class_chars = resource_manager::varedit_color_chars ();
+    QString class_chars = resource_manager::varedit_color_chars ();
 
-  m_use_terminal_font = settings->value ("variable_editor/use_terminal_font",
-                                         true).toBool ();
+    m_use_terminal_font = settings->value ("variable_editor/use_terminal_font",
+                                           true).toBool ();
 
-  QString font_name;
-  int font_size;
+    QString font_name;
+    int font_size;
 
-  if (m_use_terminal_font)
-    {
-      font_name = settings->value ("terminal/fontName", "Courier New").toString ();
-      font_size = settings->value ("terminal/fontSize", 10).toInt ();
-    }
-  else
-    {
-      font_name = settings->value ("variable_editor/font_name",
-                                   settings->value ("terminal/fontName",
-                                                    "Courier New")).toString ();
+    if (m_use_terminal_font)
+      {
+        font_name = settings->value ("terminal/fontName", "Courier New").toString ();
+        font_size = settings->value ("terminal/fontSize", 10).toInt ();
+      }
+    else
+      {
+        font_name = settings->value ("variable_editor/font_name",
+                                     settings->value ("terminal/fontName",
+                                                      "Courier New")).toString ();
 
-      font_size = settings->value ("variable_editor/font_size", 10).toInt ();
-    }
+        font_size = settings->value ("variable_editor/font_size", 10).toInt ();
+      }
 
-  m_font = QFont (font_name, font_size);
+    m_font = QFont (font_name, font_size);
 
-  QFontMetrics fm (m_font);
+    QFontMetrics fm (m_font);
 
-  m_add_font_height = fm.height ();
+    m_add_font_height = fm.height ();
 
-  for (int i = 0; i < class_chars.length (); i++)
-    {
-      QVariant default_var;
-      if (i < default_colors.length ())
-        default_var = default_colors.at (i);
-      else
-        default_var = QColor ();
+    for (int i = 0; i < class_chars.length (); i++)
+      {
+        QVariant default_var;
+        if (i < default_colors.length ())
+          default_var = default_colors.at (i);
+        else
+          default_var = QColor ();
 
-      QColor setting_color = settings->value ("variable_editor/color_"
-                                              + class_chars.mid (i, 1),
-                                              default_var).value<QColor> ();
+        QColor setting_color = settings->value ("variable_editor/color_"
+                                                + class_chars.mid (i, 1),
+                                                default_var).value<QColor> ();
 
-      if (i < m_table_colors.length ())
-        m_table_colors.replace (i, setting_color);
-    }
+        if (i < m_table_colors.length ())
+          m_table_colors.replace (i, setting_color);
+      }
 
-  update_colors ();
+    update_colors ();
 
-  // Icon size in the toolbar.
+    // Icon size in the toolbar.
 
-  int icon_size_settings = settings->value ("toolbar_icon_size", 0).toInt ();
-  QStyle *st = style ();
-  int icon_size = st->pixelMetric (QStyle::PM_ToolBarIconSize);
+    int icon_size_settings = settings->value ("toolbar_icon_size", 0).toInt ();
+    QStyle *st = style ();
+    int icon_size = st->pixelMetric (QStyle::PM_ToolBarIconSize);
 
-  // FIXME: Magic numbers.  Use enum?
+    // FIXME: Magic numbers.  Use enum?
 
-  if (icon_size_settings == 1)
-    icon_size = st->pixelMetric (QStyle::PM_LargeIconSize);
-  else if (icon_size_settings == -1)
-    icon_size = st->pixelMetric (QStyle::PM_SmallIconSize);
+    if (icon_size_settings == 1)
+      icon_size = st->pixelMetric (QStyle::PM_LargeIconSize);
+    else if (icon_size_settings == -1)
+      icon_size = st->pixelMetric (QStyle::PM_SmallIconSize);
 
-  m_tool_bar->setIconSize (QSize (icon_size, icon_size));
-}
+    m_tool_bar->setIconSize (QSize (icon_size, icon_size));
+  }
 
-void
-variable_editor::closeEvent (QCloseEvent *e)
-{
-  emit finished ();
+  void
+  variable_editor::closeEvent (QCloseEvent *e)
+  {
+    emit finished ();
 
-  octave_dock_widget::closeEvent (e);
-}
+    octave_dock_widget::closeEvent (e);
+  }
 
-void
-variable_editor::variable_destroyed (QObject *)
-{
-  QList<variable_dock_widget *> vdwlist = findChildren<variable_dock_widget *> ();
-  if (vdwlist.isEmpty ())
-    m_tool_bar->setEnabled (false);
-}
+  void
+  variable_editor::variable_destroyed (QObject *)
+  {
+    QList<variable_dock_widget *> vdwlist = findChildren<variable_dock_widget *> ();
+    if (vdwlist.isEmpty ())
+      m_tool_bar->setEnabled (false);
+  }
 
-void
-variable_editor::variable_focused (const QString &name)
-{
-  m_current_focus_vname = name;
-}
+  void
+  variable_editor::variable_focused (const QString &name)
+  {
+    m_current_focus_vname = name;
+  }
 
-void
-variable_editor::record_hovered_focus_variable (void)
-{
-  m_hovered_focus_vname = m_current_focus_vname;
-}
+  void
+  variable_editor::record_hovered_focus_variable (void)
+  {
+    m_hovered_focus_vname = m_current_focus_vname;
+  }
 
-void
-variable_editor::restore_hovered_focus_variable (void)
-{
-  variable_dock_widget *tofocus = findChild<variable_dock_widget *> (m_hovered_focus_vname);
-  if (tofocus != nullptr)
-    {
-      // Note that this may be platform and window system dependent.
-      // On a particular Linux system, activateWindow() alone didn't
-      // immediately set the active window and there was a race
-      // between the window focus and action signal.  Setting the
-      // active window via the QApplication route did work.
-      QApplication::setActiveWindow(tofocus->window());
-      tofocus->activateWindow ();
-      tofocus->setFocus (Qt::OtherFocusReason);
-    }
-}
+  void
+  variable_editor::restore_hovered_focus_variable (void)
+  {
+    variable_dock_widget *tofocus = findChild<variable_dock_widget *> (m_hovered_focus_vname);
+    if (tofocus != nullptr)
+      {
+        // Note that this may be platform and window system dependent.
+        // On a particular Linux system, activateWindow() alone didn't
+        // immediately set the active window and there was a race
+        // between the window focus and action signal.  Setting the
+        // active window via the QApplication route did work.
+        QApplication::setActiveWindow(tofocus->window());
+        tofocus->activateWindow ();
+        tofocus->setFocus (Qt::OtherFocusReason);
+      }
+  }
 
-void
-variable_editor::save (void)
-{
-  emit save_signal ();
-}
+  void
+  variable_editor::save (void)
+  {
+    emit save_signal ();
+  }
 
-void
-variable_editor::cutClipboard (void)
-{
-  copyClipboard ();
+  void
+  variable_editor::cutClipboard (void)
+  {
+    copyClipboard ();
 
-  emit clear_content_signal ();
-}
+    emit clear_content_signal ();
+  }
 
-void
-variable_editor::copyClipboard (void)
-{
-  emit copy_clipboard_signal ();
-}
+  void
+  variable_editor::copyClipboard (void)
+  {
+    emit copy_clipboard_signal ();
+  }
 
-void
-variable_editor::pasteClipboard (void)
-{
-  emit paste_clipboard_signal ();
+  void
+  variable_editor::pasteClipboard (void)
+  {
+    emit paste_clipboard_signal ();
 
-  emit updated ();
-}
+    emit updated ();
+  }
 
-void
-variable_editor::pasteTableClipboard (void)
-{
-  emit paste_table_clipboard_signal ();
+  void
+  variable_editor::pasteTableClipboard (void)
+  {
+    emit paste_table_clipboard_signal ();
 
-  emit updated ();
-}
+    emit updated ();
+  }
 
-void
-variable_editor::levelUp (void)
-{
-  emit level_up_signal ();
-}
+  void
+  variable_editor::levelUp (void)
+  {
+    emit level_up_signal ();
+  }
 
-void
-variable_editor::relay_selected_command (const QString& cmd)
-{
-  emit selected_command_signal (cmd);
-}
+  void
+  variable_editor::relay_selected_command (const QString& cmd)
+  {
+    emit selected_command_signal (cmd);
+  }
 
-// Also updates the font.
+  // Also updates the font.
 
-void variable_editor::update_colors (void)
-{
-  m_stylesheet = "";
+  void variable_editor::update_colors (void)
+  {
+    m_stylesheet = "";
 
-  if (m_table_colors.length () > 0)
-    m_stylesheet += "QTableView::item{ foreground-color: "
-      + m_table_colors[0].name () +" }";
+    if (m_table_colors.length () > 0)
+      m_stylesheet += "QTableView::item{ foreground-color: "
+        + m_table_colors[0].name () +" }";
 
-  if (m_table_colors.length () > 1)
-    m_stylesheet += "QTableView::item{ background-color: "
-      + m_table_colors[1].name () +" }";
+    if (m_table_colors.length () > 1)
+      m_stylesheet += "QTableView::item{ background-color: "
+        + m_table_colors[1].name () +" }";
 
-  if (m_table_colors.length () > 2)
-    m_stylesheet += "QTableView::item{ selection-color: "
-      + m_table_colors[2].name () +" }";
+    if (m_table_colors.length () > 2)
+      m_stylesheet += "QTableView::item{ selection-color: "
+        + m_table_colors[2].name () +" }";
 
-  if (m_table_colors.length () > 3)
-    m_stylesheet += "QTableView::item:selected{ background-color: "
-      + m_table_colors[3].name () +" }";
+    if (m_table_colors.length () > 3)
+      m_stylesheet += "QTableView::item:selected{ background-color: "
+        + m_table_colors[3].name () +" }";
 
-  if (m_table_colors.length () > 4 && m_alternate_rows)
-    {
-      m_stylesheet
-        += "QTableView::item:alternate{ background-color: "
-        + m_table_colors[4].name () +" }";
+    if (m_table_colors.length () > 4 && m_alternate_rows)
+      {
+        m_stylesheet
+          += "QTableView::item:alternate{ background-color: "
+          + m_table_colors[4].name () +" }";
 
-      m_stylesheet
-        += "QTableView::item:alternate:selected{ background-color: "
-        + m_table_colors[3].name () +" }";
-    }
+        m_stylesheet
+          += "QTableView::item:alternate:selected{ background-color: "
+          + m_table_colors[3].name () +" }";
+      }
 
-  QList<QTableView *> viewlist = findChildren<QTableView *> ();
-  for (int i = 0; i < viewlist.size (); i++)
-    {
-      QTableView *view = viewlist.at (i);
+    QList<QTableView *> viewlist = findChildren<QTableView *> ();
+    for (int i = 0; i < viewlist.size (); i++)
+      {
+        QTableView *view = viewlist.at (i);
 
-      if (! view)
-        continue;
+        if (! view)
+          continue;
 
-      view->setAlternatingRowColors (m_alternate_rows);
-      view->setStyleSheet (m_stylesheet);
-      view->setFont (m_font);
-    }
+        view->setAlternatingRowColors (m_alternate_rows);
+        view->setStyleSheet (m_stylesheet);
+        view->setFont (m_font);
+      }
 
-}
+  }
 
-QAction *
-variable_editor::add_tool_bar_button (const QIcon &icon,
-                                      const QString &text,
-                                      const QObject *receiver,
-                                      const char *member)
-{
-  QAction *action = new QAction (icon, text, this);
-  connect(action, SIGNAL (triggered ()), receiver, member);
-  QToolButton *button = new ReturnFocusToolButton (m_tool_bar);
-  button->setDefaultAction (action);
-  button->setText (text);
-  button->setToolTip (text);
-  button->setIcon (icon);
-  m_tool_bar->addWidget (button);
+  QAction *
+  variable_editor::add_tool_bar_button (const QIcon &icon,
+                                        const QString &text,
+                                        const QObject *receiver,
+                                        const char *member)
+  {
+    QAction *action = new QAction (icon, text, this);
+    connect(action, SIGNAL (triggered ()), receiver, member);
+    QToolButton *button = new ReturnFocusToolButton (m_tool_bar);
+    button->setDefaultAction (action);
+    button->setText (text);
+    button->setToolTip (text);
+    button->setIcon (icon);
+    m_tool_bar->addWidget (button);
 
-  return action;
-}
+    return action;
+  }
 
-void
-variable_editor::construct_tool_bar (void)
-{
-  m_tool_bar->setAllowedAreas (Qt::TopToolBarArea);
+  void
+  variable_editor::construct_tool_bar (void)
+  {
+    m_tool_bar->setAllowedAreas (Qt::TopToolBarArea);
+
+    m_tool_bar->setObjectName ("VariableEditorToolBar");
+
+    m_tool_bar->setWindowTitle (tr ("Variable Editor Toolbar"));
 
-  m_tool_bar->setObjectName ("VariableEditorToolBar");
-
-  m_tool_bar->setWindowTitle (tr ("Variable Editor Toolbar"));
+    QAction *action;
+    action = add_tool_bar_button (resource_manager::icon ("document-save"),
+                                  tr ("Save"), this, SLOT (save ()));
+    action->setShortcuts (QKeySequence::Save);
+    action->setStatusTip(tr("Save variable to a file"));
 
-  QAction *action;
-  action = add_tool_bar_button (resource_manager::icon ("document-save"),
-                                tr ("Save"), this, SLOT (save ()));
-  action->setShortcuts (QKeySequence::Save);
-  action->setStatusTip(tr("Save variable to a file"));
+    m_tool_bar->addSeparator ();
 
-  m_tool_bar->addSeparator ();
+    action = add_tool_bar_button (resource_manager::icon ("edit-cut"),
+                                  tr ("Cut"), this, SLOT (cutClipboard ()));
+    action->setStatusTip(tr("Cut data to clipboard"));
 
-  action = add_tool_bar_button (resource_manager::icon ("edit-cut"),
-                                tr ("Cut"), this, SLOT (cutClipboard ()));
-  action->setStatusTip(tr("Cut data to clipboard"));
+    action = add_tool_bar_button (resource_manager::icon ("edit-copy"),
+                                  tr ("Copy"), this, SLOT (copyClipboard ()));
+    action->setStatusTip(tr("Copy data to clipboard"));
 
-  action = add_tool_bar_button (resource_manager::icon ("edit-copy"),
-                                tr ("Copy"), this, SLOT (copyClipboard ()));
-  action->setStatusTip(tr("Copy data to clipboard"));
+    action = add_tool_bar_button (resource_manager::icon ("edit-paste"),
+                                  tr ("Paste"), this, SLOT (pasteClipboard ()));
+    action->setStatusTip(tr("Paste clipboard into variable data"));
 
-  action = add_tool_bar_button (resource_manager::icon ("edit-paste"),
-                                tr ("Paste"), this, SLOT (pasteClipboard ()));
-  action->setStatusTip(tr("Paste clipboard into variable data"));
+    // FIXME: Different icon for Paste Table?
 
-  // FIXME: Different icon for Paste Table?
+    action = add_tool_bar_button (resource_manager::icon ("edit-paste"),
+                                  tr ("Paste Table"),
+                                  this, SLOT (pasteTableClipboard ()));
+    action->setStatusTip(tr("Another paste clipboard into variable data"));
 
-  action = add_tool_bar_button (resource_manager::icon ("edit-paste"),
-                                tr ("Paste Table"),
-                                this, SLOT (pasteTableClipboard ()));
-  action->setStatusTip(tr("Another paste clipboard into variable data"));
+    m_tool_bar->addSeparator ();
 
-  m_tool_bar->addSeparator ();
+    // FIXME: Add a print item?
+    // QAction *print_action; /icons/fileprint.png
+    // m_tool_bar->addSeparator ();
 
-  // FIXME: Add a print item?
-  // QAction *print_action; /icons/fileprint.png
-  // m_tool_bar->addSeparator ();
+    action = new QAction (resource_manager::icon ("plot-xy-curve"),
+                          tr ("Plot"), m_tool_bar);
+    action->setToolTip (tr ("Plot Selected Data"));
+    QToolButton *plot_tool_button = new HoverToolButton (m_tool_bar);
+    plot_tool_button->setDefaultAction (action);
 
-  action = new QAction (resource_manager::icon ("plot-xy-curve"),
-                        tr ("Plot"), m_tool_bar);
-  action->setToolTip (tr ("Plot Selected Data"));
-  QToolButton *plot_tool_button = new HoverToolButton (m_tool_bar);
-  plot_tool_button->setDefaultAction (action);
+    plot_tool_button->setText (tr ("Plot"));
+    plot_tool_button->setToolTip (tr ("Plot selected data"));
+    plot_tool_button->setIcon (resource_manager::icon ("plot-xy-curve"));
 
-  plot_tool_button->setText (tr ("Plot"));
-  plot_tool_button->setToolTip (tr ("Plot selected data"));
-  plot_tool_button->setIcon (resource_manager::icon ("plot-xy-curve"));
+    plot_tool_button->setPopupMode (QToolButton::InstantPopup);
 
-  plot_tool_button->setPopupMode (QToolButton::InstantPopup);
+    QMenu *plot_menu = new ReturnFocusMenu (plot_tool_button);
+    plot_menu->setTitle (tr ("Plot"));
+    plot_menu->setSeparatorsCollapsible (false);
 
-  QMenu *plot_menu = new ReturnFocusMenu (plot_tool_button);
-  plot_menu->setTitle (tr ("Plot"));
-  plot_menu->setSeparatorsCollapsible (false);
+    QSignalMapper *plot_mapper = make_plot_mapper (plot_menu);
 
-  QSignalMapper *plot_mapper = make_plot_mapper (plot_menu);
+    connect (plot_mapper, SIGNAL (mapped (const QString&)),
+             this, SLOT (relay_selected_command (const QString&)));
 
-  connect (plot_mapper, SIGNAL (mapped (const QString&)),
-           this, SLOT (relay_selected_command (const QString&)));
+    plot_tool_button->setMenu (plot_menu);
 
-  plot_tool_button->setMenu (plot_menu);
+    m_tool_bar->addWidget (plot_tool_button);
 
-  m_tool_bar->addWidget (plot_tool_button);
-
-  m_tool_bar->addSeparator ();
+    m_tool_bar->addSeparator ();
 
-  action = add_tool_bar_button (resource_manager::icon ("go-up"),
-                                tr ("Up"), this, SLOT (levelUp ()));
-  action->setStatusTip(tr("Go one level up in variable hierarchy"));
+    action = add_tool_bar_button (resource_manager::icon ("go-up"),
+                                  tr ("Up"), this, SLOT (levelUp ()));
+    action->setStatusTip(tr("Go one level up in variable hierarchy"));
 
-  // The QToolButton mouse-clicks change active window, so connect all
-  // HoverToolButton and RuternFocusToolButton objects to the mechanism
-  // that restores active window and focus before acting.
-  QList<HoverToolButton *> hbuttonlist
-    = m_tool_bar->findChildren<HoverToolButton *> (""
+    // The QToolButton mouse-clicks change active window, so connect all
+    // HoverToolButton and RuternFocusToolButton objects to the mechanism
+    // that restores active window and focus before acting.
+    QList<HoverToolButton *> hbuttonlist
+      = m_tool_bar->findChildren<HoverToolButton *> (""
 #if defined (QOBJECT_FINDCHILDREN_ACCEPTS_FINDCHILDOPTIONS)
-                                                   , Qt::FindDirectChildrenOnly
+                                                     , Qt::FindDirectChildrenOnly
 #endif
-                                                   );
-  for (int i = 0; i < hbuttonlist.size (); i++)
-    {
-      connect (hbuttonlist.at (i), SIGNAL (hovered_signal ()),
-               this, SLOT (record_hovered_focus_variable ()));
-      connect (hbuttonlist.at (i), SIGNAL (popup_shown_signal ()),
-               this, SLOT (restore_hovered_focus_variable ()));
-    }
+                                                     );
+    for (int i = 0; i < hbuttonlist.size (); i++)
+      {
+        connect (hbuttonlist.at (i), SIGNAL (hovered_signal ()),
+                 this, SLOT (record_hovered_focus_variable ()));
+        connect (hbuttonlist.at (i), SIGNAL (popup_shown_signal ()),
+                 this, SLOT (restore_hovered_focus_variable ()));
+      }
 
-  QList<ReturnFocusToolButton *> rfbuttonlist
-    = m_tool_bar->findChildren<ReturnFocusToolButton *> (""
+    QList<ReturnFocusToolButton *> rfbuttonlist
+      = m_tool_bar->findChildren<ReturnFocusToolButton *> (""
 #if defined (QOBJECT_FINDCHILDREN_ACCEPTS_FINDCHILDOPTIONS)
-                                                         , Qt::FindDirectChildrenOnly
+                                                           , Qt::FindDirectChildrenOnly
 #endif
-                                                         );
-  for (int i = 0; i < rfbuttonlist.size (); i++)
-    {
-      connect (rfbuttonlist.at (i), SIGNAL (about_to_activate ()),
-               this, SLOT (restore_hovered_focus_variable ()));
-    }
+                                                           );
+    for (int i = 0; i < rfbuttonlist.size (); i++)
+      {
+        connect (rfbuttonlist.at (i), SIGNAL (about_to_activate ()),
+                 this, SLOT (restore_hovered_focus_variable ()));
+      }
 
-  // Same for QMenu
-  QList<ReturnFocusMenu *> menulist
-    = m_tool_bar->findChildren<ReturnFocusMenu *> ();
-  for (int i = 0; i < menulist.size (); i++)
-    {
-      connect (menulist.at (i), SIGNAL (about_to_activate ()),
-               this, SLOT (restore_hovered_focus_variable ()));
-    }
+    // Same for QMenu
+    QList<ReturnFocusMenu *> menulist
+      = m_tool_bar->findChildren<ReturnFocusMenu *> ();
+    for (int i = 0; i < menulist.size (); i++)
+      {
+        connect (menulist.at (i), SIGNAL (about_to_activate ()),
+                 this, SLOT (restore_hovered_focus_variable ()));
+      }
 
-  m_tool_bar->setAttribute(Qt::WA_ShowWithoutActivating);
-  m_tool_bar->setFocusPolicy (Qt::NoFocus);
+    m_tool_bar->setAttribute(Qt::WA_ShowWithoutActivating);
+    m_tool_bar->setFocusPolicy (Qt::NoFocus);
 
-  // Disabled when no tab is present.
+    // Disabled when no tab is present.
 
-  m_tool_bar->setEnabled (false);
+    m_tool_bar->setEnabled (false);
+  }
 }
diff --git a/libgui/src/variable-editor.h b/libgui/src/variable-editor.h
--- a/libgui/src/variable-editor.h
+++ b/libgui/src/variable-editor.h
@@ -34,325 +34,328 @@ along with Octave; see the file COPYING.
 #include "tab-bar.h"
 
 class octave_value;
 
 class QModelIndex;
 class QTextEdit;
 class QToolBar;
 
-class variable_editor_model;
-class variable_editor_view;
-
-// The individual variable subwindow class
-
-class variable_dock_widget : public label_dock_widget
+namespace octave
 {
-  Q_OBJECT
+  class variable_editor_model;
+  class variable_editor_view;
 
-public:
+  // The individual variable subwindow class
 
-  variable_dock_widget (QWidget *p = nullptr);
+  class variable_dock_widget : public label_dock_widget
+  {
+    Q_OBJECT
 
-signals:
+  public:
 
-  void variable_focused_signal (const QString& name);
+    variable_dock_widget (QWidget *p = nullptr);
+
+  signals:
 
-protected:
+    void variable_focused_signal (const QString& name);
 
-  virtual void closeEvent (QCloseEvent *e);
+  protected:
 
-public slots:
+    virtual void closeEvent (QCloseEvent *e);
 
-  void handle_focus_change (QWidget *old, QWidget *now);
+  public slots:
+
+    void handle_focus_change (QWidget *old, QWidget *now);
 
-private slots:
+  private slots:
 
-  void change_floating (bool);
+    void change_floating (bool);
 
-  void change_existence (bool);
+    void change_existence (bool);
 
-  void toplevel_change (bool);
+    void toplevel_change (bool);
 
-protected:
+  protected:
 
-  bool m_initial_float;
-};
+    bool m_initial_float;
+  };
 
-class variable_editor_stack : public QStackedWidget
-{
-  Q_OBJECT
+  class variable_editor_stack : public QStackedWidget
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  variable_editor_stack (QWidget *p = nullptr);
+    variable_editor_stack (QWidget *p = nullptr);
 
-  variable_editor_view *edit_view (void) {return m_edit_view;};
+    variable_editor_view *edit_view (void) {return m_edit_view;};
 
-  QTextEdit *disp_view (void) {return m_disp_view;};
+    QTextEdit *disp_view (void) {return m_disp_view;};
 
-signals:
+  signals:
 
-  void command_signal (const QString& cmd);
+    void command_signal (const QString& cmd);
 
-  void edit_variable_signal (const QString& name, const octave_value& val);
+    void edit_variable_signal (const QString& name, const octave_value& val);
 
-public slots:
+  public slots:
 
-  void set_editable (bool editable);
+    void set_editable (bool editable);
 
-  void levelUp (void);
+    void levelUp (void);
 
-  void save (void);
+    void save (void);
 
-private:
+  private:
 
-  QTextEdit *make_disp_view (QWidget *parent);
+    QTextEdit *make_disp_view (QWidget *parent);
 
-  variable_editor_view *m_edit_view;
+    variable_editor_view *m_edit_view;
 
-  QTextEdit *m_disp_view;
-};
+    QTextEdit *m_disp_view;
+  };
 
 
-class variable_editor_view : public QTableView
-{
-  Q_OBJECT
+  class variable_editor_view : public QTableView
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  variable_editor_view (QWidget *p = nullptr);
+    variable_editor_view (QWidget *p = nullptr);
 
-  void setModel (QAbstractItemModel *model);
+    void setModel (QAbstractItemModel *model);
 
-signals:
+  signals:
 
-  void command_signal (const QString& cmd);
+    void command_signal (const QString& cmd);
 
-  void add_edit_actions_signal (QMenu *menu, const QString& qualifier_string);
+    void add_edit_actions_signal (QMenu *menu, const QString& qualifier_string);
 
-public slots:
+  public slots:
 
-  void createVariable (void);
+    void createVariable (void);
 
-  void transposeContent (void);
+    void transposeContent (void);
 
-  QList<int> range_selected (void);
+    QList<int> range_selected (void);
 
-  void delete_selected (void);
+    void delete_selected (void);
 
-  void clearContent (void);
+    void clearContent (void);
 
-  void cutClipboard (void);
+    void cutClipboard (void);
 
-  void copyClipboard (void);
+    void copyClipboard (void);
 
-  void pasteClipboard (void);
+    void pasteClipboard (void);
 
-  void pasteTableClipboard (void);
+    void pasteTableClipboard (void);
 
-  void handle_horizontal_scroll_action (int action);
+    void handle_horizontal_scroll_action (int action);
 
-  void handle_vertical_scroll_action (int action);
+    void handle_vertical_scroll_action (int action);
 
-  void createContextMenu (const QPoint& pt);
+    void createContextMenu (const QPoint& pt);
 
-  void createColumnMenu (const QPoint& pt);
+    void createColumnMenu (const QPoint& pt);
 
-  void createRowMenu (const QPoint& pt);
+    void createRowMenu (const QPoint& pt);
 
-  // Convert selection to an Octave expression.
-  QString selected_to_octave (void);
+    // Convert selection to an Octave expression.
+    QString selected_to_octave (void);
 
-  void selected_command_requested (const QString& cmd);
+    void selected_command_requested (const QString& cmd);
 
-private:
+  private:
 
-  void add_edit_actions (QMenu *menu, const QString& qualifier_string);
+    void add_edit_actions (QMenu *menu, const QString& qualifier_string);
 
-  variable_editor_model *m_var_model;
-};
+    variable_editor_model *m_var_model;
+  };
 
-// Gadgets to keep track and restore what variable window
-// was in focus just prior to selecting something on the
-// menu bar
+  // Gadgets to keep track and restore what variable window
+  // was in focus just prior to selecting something on the
+  // menu bar
 
-class HoverToolButton : public QToolButton
-{
-  Q_OBJECT
+  class HoverToolButton : public QToolButton
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  HoverToolButton (QWidget *parent = nullptr);
+    HoverToolButton (QWidget *parent = nullptr);
 
-signals:
+  signals:
 
-  void hovered_signal (void);
+    void hovered_signal (void);
 
-  void popup_shown_signal (void);
+    void popup_shown_signal (void);
 
-protected:
+  protected:
 
-  bool eventFilter (QObject *obj, QEvent *ev);
-};
+    bool eventFilter (QObject *obj, QEvent *ev);
+  };
 
-class ReturnFocusToolButton : public HoverToolButton
-{
-  Q_OBJECT
+  class ReturnFocusToolButton : public HoverToolButton
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  ReturnFocusToolButton (QWidget *parent = nullptr);
+    ReturnFocusToolButton (QWidget *parent = nullptr);
 
-signals:
+  signals:
 
-  void about_to_activate (void);
+    void about_to_activate (void);
 
-protected:
+  protected:
 
-  bool eventFilter (QObject *obj, QEvent *ev);
-};
+    bool eventFilter (QObject *obj, QEvent *ev);
+  };
 
-class ReturnFocusMenu : public QMenu
-{
-  Q_OBJECT
+  class ReturnFocusMenu : public QMenu
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  ReturnFocusMenu (QWidget *parent = nullptr);
+    ReturnFocusMenu (QWidget *parent = nullptr);
 
-signals:
+  signals:
 
-  void about_to_activate (void);
+    void about_to_activate (void);
 
-protected:
+  protected:
 
-  bool eventFilter (QObject *obj, QEvent *ev);
-};
+    bool eventFilter (QObject *obj, QEvent *ev);
+  };
 
-// The variable editor class
+  // The variable editor class
 
-class variable_editor : public octave_dock_widget
-{
-  Q_OBJECT
+  class variable_editor : public octave_dock_widget
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  variable_editor (QWidget *parent = nullptr);
+    variable_editor (QWidget *parent = nullptr);
 
-  ~variable_editor (void) = default;
+    ~variable_editor (void) = default;
 
-  // No copying!
+    // No copying!
 
-  variable_editor (const variable_editor&) = delete;
+    variable_editor (const variable_editor&) = delete;
 
-  variable_editor& operator = (const variable_editor&) = delete;
+    variable_editor& operator = (const variable_editor&) = delete;
 
-  void refresh (void);
+    void refresh (void);
 
-  static QList<QColor> default_colors (void);
+    static QList<QColor> default_colors (void);
 
-  static QStringList color_names (void);
+    static QStringList color_names (void);
 
-public slots:
+  public slots:
 
-  void callUpdate (const QModelIndex&, const QModelIndex&);
+    void callUpdate (const QModelIndex&, const QModelIndex&);
 
-  void notice_settings (const QSettings *);
+    void notice_settings (const QSettings *);
 
-  void edit_variable (const QString& name, const octave_value& val);
+    void edit_variable (const QString& name, const octave_value& val);
 
-  void variable_destroyed (QObject *obj);
+    void variable_destroyed (QObject *obj);
 
-  void variable_focused (const QString& name);
+    void variable_focused (const QString& name);
 
-  void record_hovered_focus_variable (void);
+    void record_hovered_focus_variable (void);
 
-  void restore_hovered_focus_variable (void);
+    void restore_hovered_focus_variable (void);
 
-protected slots:
+  protected slots:
 
-  void closeEvent (QCloseEvent *);
+    void closeEvent (QCloseEvent *);
 
-  void save (void);
+    void save (void);
 
-  void cutClipboard (void);
+    void cutClipboard (void);
 
-  void copyClipboard (void);
+    void copyClipboard (void);
 
-  void pasteClipboard (void);
+    void pasteClipboard (void);
 
-  void pasteTableClipboard (void);
+    void pasteTableClipboard (void);
 
-  void levelUp (void);
+    void levelUp (void);
 
-  // Send command to Octave interpreter.
-  // %1 in CMD is replaced with the value of selected_to_octave.
-  void relay_selected_command (const QString& cmd);
+    // Send command to Octave interpreter.
+    // %1 in CMD is replaced with the value of selected_to_octave.
+    void relay_selected_command (const QString& cmd);
 
-signals:
+  signals:
 
-  void updated (void);
+    void updated (void);
 
-  void finished (void);
+    void finished (void);
 
-  void command_signal (const QString& cmd);
+    void command_signal (const QString& cmd);
 
-  void refresh_signal (void);
+    void refresh_signal (void);
 
-  void clear_content_signal (void);
+    void clear_content_signal (void);
 
-  void copy_clipboard_signal (void);
+    void copy_clipboard_signal (void);
 
-  void paste_clipboard_signal (void);
+    void paste_clipboard_signal (void);
 
-  void paste_table_clipboard_signal (void);
+    void paste_table_clipboard_signal (void);
 
-  void level_up_signal (void);
+    void level_up_signal (void);
 
-  void save_signal (void);
+    void save_signal (void);
+
+    void delete_selected_signal (void);
 
-  void delete_selected_signal (void);
+    void selected_command_signal (const QString& cmd);
 
-  void selected_command_signal (const QString& cmd);
+  private:
 
-private:
+    QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
+                          const char *member);
 
-  QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
-                        const char *member);
+    QMainWindow *m_main;
 
-  QMainWindow *m_main;
+    QToolBar *m_tool_bar;
 
-  QToolBar *m_tool_bar;
+    int m_default_width;
 
-  int m_default_width;
+    int m_default_height;
 
-  int m_default_height;
+    int m_add_font_height;
 
-  int m_add_font_height;
+    bool m_use_terminal_font;
 
-  bool m_use_terminal_font;
-
-  bool m_alternate_rows;
+    bool m_alternate_rows;
 
-  QString m_stylesheet;
+    QString m_stylesheet;
 
-  QFont m_font;
+    QFont m_font;
 
-  // If use_terminal_font is true then this will be different since
-  // "font" will contain the terminal font.
-  QFont m_sel_font;
+    // If use_terminal_font is true then this will be different since
+    // "font" will contain the terminal font.
+    QFont m_sel_font;
 
-  QList<QColor> m_table_colors;
+    QList<QColor> m_table_colors;
 
-  void update_colors (void);
+    void update_colors (void);
 
-  QAction *add_tool_bar_button (const QIcon &icon, const QString &text,
-                                const QObject *receiver, const char *member);
+    QAction *add_tool_bar_button (const QIcon &icon, const QString &text,
+                                  const QObject *receiver, const char *member);
 
-  void construct_tool_bar (void);
+    void construct_tool_bar (void);
 
-  QString m_current_focus_vname;
+    QString m_current_focus_vname;
 
-  QString m_hovered_focus_vname;
-};
+    QString m_hovered_focus_vname;
+  };
+}
 
 #endif
