# HG changeset patch
# User Jordi Gutiérrez Hermoso <jordigh@octave.org>
# Date 1325444594 18000
#      Sun Jan 01 14:03:14 2012 -0500
# Node ID 42581c3b5cb462ca3d451683be940598b4dfda8c
# Parent  88029530ffbc8cc9f23c04e26d3e8255efcc4485
# Parent  6258e5cd0f5667df95cdfd52778e119815492ddb
Periodic merge of stable to default

diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -49,8 +49,9 @@ 229675bb7647f7e7e499bcb5acacc8eabe7f3697
 6c69a7c39039bccd5a2fe481fcc7f896c82b160b ss-3-3-53
 3cbc0d77db48aec32bcb202d09a036d2cb9cc3b9 ss-3-3-53
 bd2643f0ce57d070963bedd48857405f6924aa85 ss-3-3-54
 695141f1c05cf1b240592bdd18e7a1503bb2a539 ss-3-3-55
 901d466ee55ac902a875ec0ade6f1eccef0841dc release-3-4-1
 3666e8e6f96e6899b8306d6ea9614aadf0500d67 release-3-4-2
 b0e70a71647b671ebcfa7a79af1ae6d3c0f52065 release-3-4-3
 3781981be535e80d44c85373b8fdaa60ca5cd097 ss-3-5-90
+ff5588774680d4f54567311fc109c8e351950f1c ss-3-5-91
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,34 +1,54 @@
 Summary of important user-visible changes for version 3.6:
 ---------------------------------------------------------
 
  ** The PCRE library is now required to build Octave.
 
- ** The following binary elementwise operators and functions now perform
-    Numpy-like broadcasting (a.k.a. binary singleton expansion):
+ ** Many of Octave's binary operators (.*, .^, +, -, ...) now perform
+    automatic broadcasting for array operations that allows you to use
+    operator notation instead of calling bsxfun or expanding arrays (and
+    unnecessarily wasting memory) with repmat or similar idioms.  For
+    example, to scale the columns of a matrix by the elements of a row
+    vector, you may now write
 
-    plus      ldivide   rem    eq    gt     xor
-    minus     power     mod    ne    ge
-    times     max       atan2  lt    and
-    rdivide   min       hypot  le    or
+      rv .* M
+
+    In this expression, the number of elements of rv must match the
+    number of columns of M.  The following operators are affected:
 
-    +         .*        &
-    -         ./        |
-    .+        .\
-    .-        .^
+      plus      +  .+
+      minus     -  .-
+      times     .*
+      rdivide   ./
+      ldivide   .\
+      power     .^  .**
+      lt        <
+      le        <=
+      eq        ==
+      gt        >
+      ge        >=
+      ne        !=  ~=
+      and       &
+      or        |
+      atan2
+      hypot
+      max
+      min
+      mod
+      rem
+      xor
 
-    +=        .*=       &=
-    -=        ./=       |=
-    .+=       .\=
-    .-=       .^=
+    additionally, since the A op= B assginment operators are equivalent
+    to A = A op B, the following operators are also affected:
 
-    This makes the bsxfun function mostly redundant except for
-    user-defined functions.  A new section in the manual has been written
-    to explain and clarify this change.
+      +=  -=  .+=  .-=  .*=  ./=  .\=  .^=  .**=  &=  |=
+
+    See the "Broadcasting" section in the new "Vectorization and Faster
+    Code Execution" chapter of the manual for more details.
 
  ** Octave now features a profiler, thanks to the work of Daniel Kraft
     under the Google Summer of Code mentorship program.  The manual has
     been updated to reflect this addition.  The new user-visible
     functions are profexplore, profile, and profshow.
 
  ** Overhaul of statistical distribution functions
 
@@ -47,94 +67,114 @@ Summary of important user-visible change
     negative binomial function has been extended to real, non-integer inputs.
     discrete_inv() now returns v(1) for 0 instead of NaN.
     nbincdf() recoded to use closed form solution with betainc().
 
  ** strread, textscan, and textread have been completely revamped.
 
     They now support nearly all Matlab functionality including:
 
-    * ML-compatible whitespace and delimiter defaults
+      * Matlab-compatible whitespace and delimiter defaults
+
+      * Matlab-compatible options: 'whitespace', treatasempty', format
+        string repeat count, user-specified comment style, uneven-length
+        output arrays, %n and %u conversion specifiers (provisionally)
 
-    * ML-compatible options: 'whitespace', treatasempty',
-    format string repeat count, user-specified comment style, uneven-length
-    output arrays, %n and %u conversion specifiers (provisionally)
+ ** All .m string functions have been modified for better performance or
+    greater Matlab compatibility.  Performance gains of 15X-30X have
+    been demonstrated.  Operations on cell array of strings no longer pay
+    quite as high a penalty as those on 2-D character arrays.
 
- ** All .m string functions have been modified for better performance or greater
-    Matlab compatibility.  Performance gains of 15X-30X have been demonstrated.
-    Operations on cell array of strings no longer pay quite as high a penalty
-    as those on 2-D character arrays.
+      deblank:  Now requires character or cellstr input.
+
+      strtrim:  Now requires character or cellstr input.
+                No longer trims nulls ("\0") from string for Matlab
+                compatibility.
 
-    deblank:  Now requires character or cellstr input.
-    strtrim:  Now requires character or cellstr input.
-              No longer trims nulls ("\0") from string for ML compatibility.
-    strmatch: Follows documentation precisely and ignores trailing spaces
-              in pattern and in string.  Note that Matlab documents this 
-              behavior but the implementation does *not* always follow it.
-    substr:   Now possible to specify a negative LEN option which extracts
-              to within LEN of the end of the string.
-    strtok:   Now accepts cellstr input.
-    base2dec, bin2dec, hex2dec: Now accept cellstr inputs.
-    dec2base, dec2bin, dec2hex: Now accept cellstr inputs.
-    index, rindex: Now accept 2-D character array input.
-    strsplit: Now accepts 2-D character array input.
+      strmatch: Follows documentation precisely and ignores trailing spaces
+                in pattern and in string.  Note that this is documented
+                Matlab behavior but the implementation apparently does
+                not always follow it.
+
+      substr:   Now possible to specify a negative LEN option which
+                extracts to within LEN of the end of the string.
+
+      strtok:   Now accepts cellstr input.
+
+      base2dec, bin2dec, hex2dec:
+                Now accept cellstr inputs.
+
+      dec2base, dec2bin, dec2hex:
+                Now accept cellstr inputs.
+
+      index, rindex:
+                Now accept 2-D character array input.
+
+      strsplit: Now accepts 2-D character array input.
 
  ** Geometry functions derived from Qhull (convhull, delaunay, voronoi)
-    have been revamped.  The options passed to the underlying qhull command
-    have been changed for better results or for Matlab compatibility.
+    have been revamped.  The options passed to the underlying qhull
+    command have been changed for better results or for Matlab
+    compatibility.
+
+      convhull: Default options are "Qt" for 2D, 3D, 4D inputs
+                Default options are "Qt Qx" for 5D and higher
+
+      delaunay: Default options are "Qt Qbb Qc Qz" for 2D and 3D inputs
+                Default options are "Qt Qbb Qc Qx" for 4D and higher
 
-    convhull : Default options are "Qt" for 2D, 3D, 4D inputs
-               Default options are "Qt Qx" for 5D and higher
-    delaunay : Default options are "Qt Qbb Qc Qz" for 2D and 3D inputs
-               Default options are "Qt Qbb Qc Qx" for 4D and higher
-    voronoi  : No default arguments
+      voronoi:  No default arguments
+
+ ** Date/Time functions updated.  Millisecond support with FFF format
+    string now supported.
 
- ** Date/Time functions updated.
-    Millisecond support with FFF format string now supported.
+    datestr: Numerical formats 21, 22, 29 changed to match Matlab.
+             Now accepts cellstr inputs.
 
-    datestr : Numerical formats 21, 22, 29 changed to match Matlab.
-              Now accepts cellstr inputs.
+ ** The following warning IDs have been removed:
 
- ** Octave warning IDs updated
-    "associativity-change": removed
-    "complex-cmp-ops"     : removed
-    "empty-list-elements" : removed
-    "fortran-indexing"    : removed
-    "precedence-change"   : removed
-    "string-concat"       : renamed to "mixed-string-concat"
+      Octave:associativity-change
+      Octave:complex-cmp-ops
+      Octave:empty-list-elements
+      Octave:fortran-indexing
+      Octave:precedence-change
+      
+ ** The warning ID Octave:string-concat has been renamed to
+    Octave:mixed-string-concat.
 
- ** Matlab-compatible preference functions added:
+ ** Octave now includes the following Matlab-compatible preference
+    functions:
 
-    addpref  getpref  ispref  rmpref  setpref
+      addpref  getpref  ispref  rmpref  setpref
 
- ** Matlab-compatible handle graphics functions added:
+ ** The following Matlab-compatible handle graphics functions have been
+    added:
 
-    guidata         uipanel        uitoolbar
-    guihandles      uipushtool     uiwait
-    uicontextmenu   uiresume       waitfor
-    uicontrol       uitoggletool
+      guidata         uipanel        uitoolbar
+      guihandles      uipushtool     uiwait
+      uicontextmenu   uiresume       waitfor
+      uicontrol       uitoggletool
 
     The uiXXX functions above are experimental.
 
-    Except for uiwait and uiresume, the uiXXX functions are not supported on
-    the FLTK backend.
+    Except for uiwait and uiresume, the uiXXX functions are not
+    supported with the the FLTK+OpenGL graphics toolkit.
 
-    The gnuplot backend does not support any of the uiXXX functions nor
-    the waitfor function.
+    The gnuplot graphics toolkit does not support any of the uiXXX
+    functions nor the waitfor function.
 
- ** New keyword parfor
-
-    parfor (parallel for loop) is now recognized as a valid keyword.
-    Implementation, however, is still mapped to an ordinary for loop.
+ ** New keyword parfor (parallel for loop) is now recognized as a valid
+    keyword.  Implementation, however, is still mapped to an ordinary
+    for loop.
 
  ** Other new functions added in 3.6.0:
 
-    is_dq_string    nthargout    usejava     
-    is_sq_string    python       waitbar
-    narginchk       recycle      zscore            
+      is_dq_string    nthargout    usejava     
+      is_sq_string    python       waitbar
+      narginchk       recycle      zscore            
     
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.2 and have been
     removed from Octave 3.6.
                                            
       create_set          spcholinv    splu   
       dmult               spcumprod    spmax
@@ -473,17 +513,17 @@ Summary of important user-visible change
     important cases.
 
     Further, it is now possible to pre-allocate a sparse matrix and
     subsequently fill it by assignments, provided they meet certain
     conditions.  For more information, consult the `spalloc' function,
     which is no longer a mere dummy.  Consequently, nzmax and nnz are no
     longer always equal in Octave.  Octave may also produce a matrix
     with nnz < nzmax as a result of other operations, so you should
-    consistently use nnz unless you really want to use nzmax (i.e. the
+    consistently use nnz unless you really want to use nzmax (i.e., the
     space allocated for nonzero elements).
 
     Sparse concatenation is also affected, and concatenating sparse 
     matrices, especially larger collections, is now significantly more 
     efficient.  This applies to both the [] operator and the 
     cat/vertcat/horzcat functions.
 
  ** It is now possible to optionally employ the xGESDD LAPACK drivers
@@ -510,17 +550,17 @@ Summary of important user-visible change
     it calls.
 
  ** pkg now accepts a -forge option for downloading and installing
     packages from Octave Forge automatically.  For example, 
     
       pkg install -forge general
     
     will automatically download the latest release of the general
-    package and attempt to install it. No automatic resolving of
+    package and attempt to install it.  No automatic resolving of
     dependencies is provided.  Further,
 
       pkg list -forge
     
     can be used to list all available packages.
 
  ** The internal data representation of structs has been completely
     rewritten to make certain optimizations feasible.  The field data
@@ -883,17 +923,17 @@ Summary of important user-visible change
     function is now a built-in function performing a binary search,
     optimized for long runs of close elements.  Lookup also works with
     cell arrays of strings.
 
  ** Range arithmetics
 
     For some operations on ranges, Octave will attempt to keep the
     result as a range.  These include negation, adding a scalar,
-    subtracting a scalar, and multiplying by a scalar. Ranges with zero
+    subtracting a scalar, and multiplying by a scalar.  Ranges with zero
     increment are allowed and can be constructed using the built-in
     function `ones'.
 
  ** Various performance improvements.
 
     Performance of a number of other built-in operations and functions
     was improved, including:
 
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -22,23 +22,23 @@ dnl Copyright (C) 1993-2011 John W. Eato
 
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
-AC_INIT([GNU Octave], [3.5.90+], [http://octave.org/bugs.html], [octave])
+AC_INIT([GNU Octave], [3.5.91+], [http://octave.org/bugs.html], [octave])
 
 dnl PACKAGE_VERSION is set by the AC_INIT VERSION arg
 OCTAVE_VERSION="$PACKAGE_VERSION"
 OCTAVE_API_VERSION_NUMBER="46"
 OCTAVE_API_VERSION="api-v$OCTAVE_API_VERSION_NUMBER+"
-OCTAVE_RELEASE_DATE="2011-12-11"
+OCTAVE_RELEASE_DATE="2011-12-23"
 OCTAVE_COPYRIGHT="Copyright (C) 2011 John W. Eaton and others."
 AC_SUBST(OCTAVE_VERSION)
 AC_SUBST(OCTAVE_API_VERSION_NUMBER)
 AC_SUBST(OCTAVE_API_VERSION)
 AC_SUBST(OCTAVE_RELEASE_DATE)
 AC_SUBST(OCTAVE_COPYRIGHT)
 
 AC_REVISION($Revision: 1.603 $)
diff --git a/doc/interpreter/Makefile.am b/doc/interpreter/Makefile.am
--- a/doc/interpreter/Makefile.am
+++ b/doc/interpreter/Makefile.am
@@ -143,17 +143,18 @@ MUNGED_TEXI_SRC = \
   signal.texi \
   sparse.texi \
   stats.texi \
   stmt.texi \
   strings.texi \
   system.texi \
   testfun.texi \
   tips.texi \
-  var.texi
+  var.texi \
+  vectorize.texi
 
 TXI_SRC = $(MUNGED_TEXI_SRC:.texi=.txi)
 
 info_TEXINFOS = octave.texi
 
 octave_TEXINFOS = \
   contributors.texi \
   $(MUNGED_TEXI_SRC)
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -184,20 +184,16 @@ cos (pi/2)
 @DOCSTRING(prod)
 
 @DOCSTRING(cumsum)
 
 @DOCSTRING(cumprod)
 
 @DOCSTRING(sumsq)
 
-@DOCSTRING(accumarray)
-
-@DOCSTRING(accumdim)
-
 @node Utility Functions
 @section Utility Functions
 
 @DOCSTRING(ceil)
 
 @DOCSTRING(fix)
 
 @DOCSTRING(floor)
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -502,19 +502,17 @@ Other functions that can manipulate the 
 @DOCSTRING(substruct)
 
 @node Processing Data in Structures
 @subsection Processing Data in Structures
 
 The simplest way to process data in a structure is within a @code{for}
 loop (@pxref{Looping Over Structure Elements}).  A similar effect can be
 achieved with the @code{structfun} function, where a user defined
-function is applied to each field of the structure.
-
-@DOCSTRING(structfun)
+function is applied to each field of the structure.  @xref{doc-structfun}.
 
 Alternatively, to process the data in a structure, the structure might
 be converted to another type of container before being treated.
 
 @DOCSTRING(struct2cell)
 
 @node Cell Arrays
 @section Cell Arrays
@@ -882,19 +880,17 @@ cell array of strings.
 @node Processing Data in Cell Arrays
 @subsection Processing Data in Cell Arrays
 
 Data that is stored in a cell array can be processed in several ways
 depending on the actual data.  The simplest way to process that data
 is to iterate through it using one or more @code{for} loops.  The same
 idea can be implemented more easily through the use of the @code{cellfun}
 function that calls a user-specified function on all elements of a cell
-array.
-
-@DOCSTRING(cellfun)
+array.  @xref{doc-cellfun}.
 
 An alternative is to convert the data to a different container, such as
 a matrix or a data structure.  Depending on the data this is possible
 using the @code{cell2mat} and @code{cell2struct} functions.
 
 @DOCSTRING(cell2mat)
 
 @DOCSTRING(cell2struct)
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -38,16 +38,17 @@ Autoload
 autoloaded
 autoloading
 Autoloading
 autoregression
 autoregressions
 autoscaled
 AutoScaling
 AWK
+awt
 backend
 Backends
 backends
 bartlett
 Bateman
 BDF
 bdf
 betacdf
@@ -77,16 +78,17 @@ boxerrorbars
 boxoff
 boxon
 boxxyerrorbars
 bracketx
 brackety
 breakpoint
 Brenan
 Brockwell
+BSX
 builtin
 builtins
 ButtonDownFcn
 BV
 bz
 BZ
 bzip
 CallbackObject
@@ -156,16 +158,20 @@ courseware
 cov
 CPLEX
 CreateFcn
 CRLF
 csymamd
 ctranspose
 CTRL
 CTS
+cummax
+cummin
+cumprod
+cumsum
 cURL
 Cuthill
 cxsparse
 Cygwin
 DAE
 DAEs
 daspk
 dasrt
@@ -220,16 +226,17 @@ dx
 dy
 EastOutside
 EIDORS
 eigenpairs
 eigenvector
 eigenvectors
 eigs
 Ekerdt
+elementwise
 Elfers
 elseif
 emacs
 emptyvalue
 endfunction
 endian
 Endian
 endif
@@ -345,16 +352,17 @@ gplot
 grabdemo
 GradObj
 GraphicsMagick
 Graymap
 grayscale
 Graz
 griddata
 gswin
+GUIs
 gunzipped
 gz
 gzip
 gzipped
 Hackbusch
 Hadamard
 Haddad
 Hankel
@@ -390,16 +398,17 @@ Huhdanpaa
 hygecdf
 hygeinv
 hygepdf
 hygernd
 Hyndman
 Hypergeometric
 hypergeometric
 IEEE
+ifelse
 iff
 ifft
 ifftn
 ignorecase
 IIP
 ij
 Im
 imag
@@ -433,16 +442,17 @@ isvector
 ith
 iy
 Jacobian
 Jacobians
 ji
 jpeg
 JPEG
 jpg
+jvm
 keybindings
 keypress
 Kolmogorov
 kolmogorov
 Konrod
 Krishnamurthy
 kron
 kruskal
@@ -593,31 +603,33 @@ Ng
 ni
 Nishimura
 NLP
 nnls
 nnz
 nocompute
 nolabel
 noncommercially
+nonconformant
 nonsmooth
 nonzeros
 noperm
 normcdf
 normest
 norminv
 normpdf
 normrnd
 NorthOutside
 noscal
 noshare
 notin
 nthargout
 NTSC
 nul
+Numpy
 Nx
 nzmax
 oct
 octaverc
 ODEPACK
 OLS
 onCleanup
 online
@@ -728,16 +740,17 @@ readline
 recursing
 reentrant
 regex
 regressor
 reimported
 Reindent
 relicensing
 ren
+repelems
 repmat
 resampled
 resampling
 Resize
 resize
 resized
 resnorm
 resparsify
@@ -773,16 +786,17 @@ semidefinite
 Sep
 Shampine
 shiftdim
 si
 signum
 SIGNUM
 sim
 SIMAX
+SIMD
 simplechol
 simplecholperm
 simplematrix
 simplices
 sinetone
 sm
 smirnov
 Smirnov
@@ -856,16 +870,17 @@ Subscripted
 subscripted
 subscripting
 subseteq
 subsindex
 subsref
 substring
 substrings
 SuiteSparse
+sumsq
 SunOS
 superiorto
 supradiagonal
 supset
 supseteq
 SV
 SVD
 svd
@@ -973,16 +988,18 @@ vectorizing
 vee
 versa
 vertcat
 vertices
 Villadsen
 voronoi
 Voronoi
 Wa
+waitbar
+waitbars
 wallis
 wblcdf
 wblinv
 wblpdf
 wblrnd
 Weibull
 Welch
 welch
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -507,17 +507,18 @@ the recursion depth and prevents Octave 
 @cindex unary minus
 @cindex exponentiation
 @cindex transpose
 @cindex Hermitian operator
 @cindex transpose, complex-conjugate
 @cindex complex-conjugate transpose
 
 The following arithmetic operators are available, and work on scalars
-and matrices.
+and matrices.  The element-by-element operators and functions broadcast
+(@pxref{Broadcasting}).
 
 @table @asis
 @item @var{x} + @var{y}
 @opindex +
 Addition.  If both operands are matrices, the number of rows and columns
 must both agree.  If one operand is a scalar, its value is added to
 all the elements of the other operand.
 
@@ -710,29 +711,30 @@ useful in this case.
 @cindex equality, tests for
 
 @dfn{Comparison operators} compare numeric values for relationships
 such as equality.  They are written using
 @emph{relational operators}.
 
 All of Octave's comparison operators return a value of 1 if the
 comparison is true, or 0 if it is false.  For matrix values, they all
-work on an element-by-element basis.  For example:
+work on an element-by-element basis.  Broadcasting rules apply.
+@xref{Broadcasting}.  For example:
 
 @example
 @group
 [1, 2; 3, 4] == [1, 3; 2, 4]
      @result{}  1  0
          0  1
 @end group
 @end example
 
-If one operand is a scalar and the other is a matrix, the scalar is
-compared to each element of the matrix in turn, and the result is the
-same size as the matrix.
+According to broadcasting rules, if one operand is a scalar and the
+other is a matrix, the scalar is compared to each element of the matrix
+in turn, and the result is the same size as the matrix.
 
 @table @code
 @item @var{x} < @var{y}
 @opindex <
 True if @var{x} is less than @var{y}.
 
 @item @var{x} <= @var{y}
 @opindex <=
@@ -857,28 +859,28 @@ of @var{boolean1} or @var{boolean2} is t
 @item ! @var{boolean}
 @itemx ~ @var{boolean}
 @opindex ~
 @opindex !
 Each element of the result is true if the corresponding element of
 @var{boolean} is false.
 @end table
 
-For matrix operands, these operators work on an element-by-element
-basis.  For example, the expression
+These operators work on an element-by-element basis.  For example, the
+expression
 
 @example
 [1, 0; 0, 1] & [1, 0; 2, 3]
 @end example
 
 @noindent
 returns a two by two identity matrix.
 
-For the binary operators, the dimensions of the operands must conform if
-both are matrices.  If one of the operands is a scalar and the other a
+For the binary operators, broadcasting rules apply.  @xref{Broadcasting}.
+In particular, if one of the operands is a scalar and the other a
 matrix, the operator is applied to the scalar and each element of the
 matrix.
 
 For the binary element-by-element boolean operators, both subexpressions
 @var{boolean1} and @var{boolean2} are evaluated before computing the
 result.  This can make a difference when the expressions have side
 effects.  For example, in the expression
 
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -1220,18 +1220,16 @@ After this it is possible to evaluate @m
 writing @code{f(x)}.
 
 @DOCSTRING(inline)
 
 @DOCSTRING(argnames)
 
 @DOCSTRING(formula)
 
-@DOCSTRING(vectorize)
-
 @DOCSTRING(symvar)
 
 @node Commands
 @section Commands
 
 Commands are a special class of functions that only accept string
 input arguments.  A command can be called as an ordinary function, but
 it can also be called without the parentheses.  For example,
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -557,19 +557,19 @@ The description follows on succeeding li
 
 In a function description, the name of the function being described
 appears first.  It is followed on the same line by a list of parameters.
 The names used for the parameters are also used in the body of the
 description.
 
 Here is a description of an imaginary function @code{foo}:
 
-@deftypefn  {Function} {} foo (@var{x})
-@deftypefnx {Function} {} foo (@var{x}, @var{y})
-@deftypefnx {Function} {} foo (@var{x}, @var{y}, @dots{})
+@deftypefn  {Function File} {} foo (@var{x})
+@deftypefnx {Function File} {} foo (@var{x}, @var{y})
+@deftypefnx {Function File} {} foo (@var{x}, @var{y}, @dots{})
 The function @code{foo} subtracts @var{x} from @var{y}, then adds the
 remaining arguments to the result.  If @var{y} is not supplied, then the
 number 19 is used by default.
 
 @example
 @group
 foo (1, [3, 5], 3, 9)
      @result{} [ 14, 16 ]
diff --git a/doc/interpreter/matrix.txi b/doc/interpreter/matrix.txi
--- a/doc/interpreter/matrix.txi
+++ b/doc/interpreter/matrix.txi
@@ -24,17 +24,16 @@ elements of a matrix meet some condition
 elements of a matrix.  For example, Octave can easily tell you if all
 the elements of a matrix are finite, or are less than some specified
 value.  Octave can also rotate the elements, extract the upper- or
 lower-triangular parts, or sort the columns of a matrix.
 
 @menu
 * Finding Elements and Checking Conditions::  
 * Rearranging Matrices::        
-* Applying a Function to an Array::
 * Special Utility Matrices::    
 * Famous Matrices::             
 @end menu
 
 @node Finding Elements and Checking Conditions
 @section Finding Elements and Checking Conditions
 
 The functions @code{any} and @code{all} are useful for determining
@@ -135,23 +134,16 @@ its elements may have, consult @ref{Stat
 @DOCSTRING(prepad)
 
 @DOCSTRING(postpad)
 
 @DOCSTRING(diag)
 
 @DOCSTRING(blkdiag)
 
-@node Applying a Function to an Array
-@section Applying a Function to an Array
-
-@DOCSTRING(arrayfun)
-
-@DOCSTRING(bsxfun)
-
 @node Special Utility Matrices
 @section Special Utility Matrices
 
 @DOCSTRING(eye)
 
 @DOCSTRING(ones)
 
 @DOCSTRING(zeros)
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -192,18 +192,19 @@ It corresponds to GNU Octave version @va
 * Statements::                  Looping and program flow control.
 * Functions and Scripts::       
 * Errors and Warnings::              
 * Debugging::
 * Input and Output::            
 * Plotting::                    
 * Matrix Manipulation::         
 * Arithmetic::                  
-* Linear Algebra::              
-* Nonlinear Equations::         
+* Linear Algebra::
+* Vectorization and Faster Code Execution::
+* Nonlinear Equations::
 * Diagonal and Permutation Matrices::
 * Sparse Matrices::
 * Numerical Integration::                  
 * Differential Equations::      
 * Optimization::                
 * Statistics::                  
 * Sets::                        
 * Polynomial Manipulations::    
@@ -595,17 +596,16 @@ Object Groups
 Graphics Toolkits
 
 * Customizing Toolkit Behavior::
 
 Matrix Manipulation
 
 * Finding Elements and Checking Conditions::  
 * Rearranging Matrices::        
-* Applying a Function to an Array::
 * Special Utility Matrices::    
 * Famous Matrices::             
 
 Arithmetic
 
 * Exponents and Logarithms::
 * Complex Arithmetic::          
 * Trigonometry::                
@@ -619,16 +619,25 @@ Arithmetic
 Linear Algebra
 
 * Techniques Used for Linear Algebra::
 * Basic Matrix Functions::      
 * Matrix Factorizations::       
 * Functions of a Matrix::       
 * Specialized Solvers::
 
+Vectorization and Faster Code Execution
+
+* Basic Vectorization::
+* Broadcasting::
+* Function Application::
+* Accumulation::
+* Miscellaneous Techniques::
+* Examples::
+
 Nonlinear Equations
 
 * Solvers::
 * Minimizers::
 
 Diagonal and Permutation Matrices
 
 * Basic Usage::          Creation and Manipulation of Diagonal and Permutation Matrices
@@ -839,17 +848,16 @@ Mex-Files
 Test and Demo Functions
 
 * Test Functions::
 * Demonstration Functions::
 
 Tips and Standards
 
 * Style Tips::                  Writing clean and robust programs.
-* Coding Tips::                 Making code run faster.
 * Comment Tips::                Conventions for writing comments.
 * Function Headers::            Standard headers for functions.
 * Documentation Tips::          Writing readable documentation strings.
 
 Contributing Guidelines
 
 * How to Contribute::
 * General Guidelines::
@@ -905,16 +913,17 @@ Grammar and Parser
 @include func.texi
 @include errors.texi
 @include debug.texi
 @include io.texi
 @include plot.texi
 @include matrix.texi
 @include arith.texi
 @include linalg.texi
+@include vectorize.texi
 @include nonlin.texi
 @include diagperm.texi
 @include sparse.texi
 @include quad.texi
 @include diffeq.texi
 @include optim.texi
 @include stats.texi
 @include set.texi
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -49,28 +49,28 @@ functions.
 We use in the following text a polynomial class to demonstrate the use
 of object oriented programming within Octave.  This class was chosen as
 it is simple, and so doesn't distract unnecessarily from the
 discussion of the programming features of Octave.  However, even still
 a small understand of the polynomial class itself is necessary to
 fully grasp the techniques described.
 
 The polynomial class is used to represent polynomials of the form
+@tex
+$$
+a_0 + a_1 x + a_2 x^2 + \ldots a_n x^n
+$$
+@end tex
+@ifnottex
 
 @example
-@group
-@tex
-$a_0 + a_1 x + a_2 x^2 + \ldots a_n x^n$
-@end tex
-@ifnottex
 a0 + a1 * x + a2 * x^2 + @dots{} + an * x^n
-@end ifnottex
-@end group
 @end example
 
+@end ifnottex
 @noindent
 where
 @tex
 $a_0$, $a_1$, etc. are elements of $\Re$.
 @end tex
 @ifnottex
 a0, a1, etc. are real scalars.
 @end ifnottex
@@ -125,19 +125,19 @@ class.
 
 To check where a variable is a user class, the @code{isobject} and
 @code{isa} functions can be used.  For example:
 
 @example
 @group
 p = polynomial ([1, 0, 1]);
 isobject (p)
-@result{} 1
+  @result{} 1
 isa (p, "polynomial")
-@result{} 1
+  @result{} 1
 @end group
 @end example
 
 @DOCSTRING(isobject)
 
 @noindent
 The available methods of a class can be displayed with the
 @code{methods} function.
@@ -152,17 +152,17 @@ To inquire whether a particular method i
 
 @noindent
 For example:
 
 @example
 @group
 p = polynomial ([1, 0, 1]);
 ismethod (p, "roots")
-@result{} 1
+  @result{} 1
 @end group
 @end example
 
 @node Manipulating Classes
 @section Manipulating Classes
 
 There are a number of basic classes methods that can be defined to allow
 the contents of the classes to be queried and set.  The most basic of
@@ -314,17 +314,17 @@ look like
 which is a fairly generic @code{end} method that has a behavior similar to
 the @code{end} keyword for Octave Array classes.  It can then be used as 
 follows:
 
 @example
 @group
 p = polynomial([1,2,3,4]);
 p(end-1)
-@result{} 3
+  @result{} 3
 @end group
 @end example
 
 Objects can also be used as the index in a subscripted expression themselves
 and this is controlled with the @code{subsindex} function.
 
 @DOCSTRING(subsindex)
 
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -218,18 +218,16 @@ s = diag (sparse(randn(1,n)), -1);
 @noindent
 creates a sparse (@var{n}+1)-by-(@var{n}+1) sparse matrix with a single
 diagonal defined.
 
 @DOCSTRING(spdiags)
 
 @DOCSTRING(speye)
 
-@DOCSTRING(spfun)
-
 @DOCSTRING(spones)
 
 @DOCSTRING(sprand)
 
 @DOCSTRING(sprandn)
 
 @DOCSTRING(sprandsym)
 
diff --git a/doc/interpreter/stats.txi b/doc/interpreter/stats.txi
--- a/doc/interpreter/stats.txi
+++ b/doc/interpreter/stats.txi
@@ -298,19 +298,19 @@ alphabetical order).
   @tab @code{nbinpdf}
   @tab @code{nbincdf}
   @tab @code{nbininv}
 @item Poisson Distribution
   @tab @code{poisspdf}
   @tab @code{poisscdf}
   @tab @code{poissinv}
 @item Standard Normal Distribution
-  @tab @code{stdtormal_pdf}
-  @tab @code{stdtormal_cdf}
-  @tab @code{stdtormal_inv}
+  @tab @code{stdnormal_pdf}
+  @tab @code{stdnormal_cdf}
+  @tab @code{stdnormal_inv}
 @item t (Student) Distribution
   @tab @code{tpdf}
   @tab @code{tcdf}
   @tab @code{tinv}
 @item Univariate Discrete Distribution
   @tab @code{unidpdf}
   @tab @code{unidcdf}
   @tab @code{unidinv}
diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -307,30 +307,30 @@ shorthand for @code{%!test assert (x, y,
 You can also create test scripts for builtins and your own C++
 functions.  To do so put a file with the bare function name (no .m
 extension) in a directory in the load path and it will be discovered by
 the @code{test} function.  Alternatively, you can embed tests directly in your
 C++ code:
 
 @example
 @group
-#if 0
+/*
 %!test disp ("this is a test")
-#endif
+*/
 @end group
 @end example
 
 @noindent
 or
 
 @example
 @group
-/*
+#if 0
 %!test disp ("this is a test")
-*/
+#endif
 @end group
 @end example
 
 @noindent
 However, in this case the raw source code will need to be on the load
 path and the user will have to remember to type
 @code{test ("funcname.cc")}.
 
diff --git a/doc/interpreter/tips.txi b/doc/interpreter/tips.txi
--- a/doc/interpreter/tips.txi
+++ b/doc/interpreter/tips.txi
@@ -23,17 +23,16 @@
 @cindex coding standards
 
 This chapter describes no additional features of Octave.  Instead it
 gives advice on making effective use of the features described in the
 previous chapters.
 
 @menu
 * Style Tips::                  Writing clean and robust programs.
-* Coding Tips::                 Making code run faster.
 * Comment Tips::                Conventions for writing comments.
 * Function Headers::            Standard headers for functions.
 * Documentation Tips::          Writing readable documentation strings.
 @end menu
 
 @node Style Tips
 @section Writing Clean Octave Programs
 
@@ -70,213 +69,16 @@ return.
 
 @item
 Please put a copyright notice on the file if you give copies to anyone.
 Use the same lines that appear at the top of the function files
 distributed with Octave.  If you have not signed papers to assign the
 copyright to anyone else, then place your name in the copyright notice.
 @end itemize
 
-@node Coding Tips
-@section Tips for Making Code Run Faster.
-@cindex execution speed
-@cindex speedups
-
-Here are some ways of improving the execution speed of Octave programs.
-
-@itemize @bullet
-@item
-Vectorize loops.  For instance, rather than
-
-@example
-@group
-for i = 1:n-1
-  a(i) = b(i+1) - b(i);
-endfor
-@end group
-@end example
-
-@noindent
-write
-
-@example
-a = b(2:n) - b(1:n-1);
-@end example
-
-This is especially important for loops with "cheap" bodies.  Often it suffices
-to vectorize just the innermost loop to get acceptable performance.  A general
-rule of thumb is that the "order" of the vectorized body should be greater or
-equal to the "order" of the enclosing loop.
-
-@item
-Use built-in and library functions if possible.  Built-in and compiled functions
-are very fast.  Even with a m-file library function, chances are good that it is
-already optimized, or will be optimized more in a future release.
-
-For instance, even better than
-
-@example
-a = b(2:n) - b(1:n-1);
-@end example
-
-@noindent
-is
-
-@example
-a = diff (b);
-@end example
-
-
-@item
-Avoid computing costly intermediate results multiple times.  Octave currently
-does not eliminate common subexpressions.
-Also, certain internal computation results are cached for variables.
-For instance, if a matrix variable is used multiple times as an index,
-checking the indices (and internal conversion to integers) is only done once.
-
-@item
-Be aware of lazy copies (copy-on-write).  When a copy of an object
-is created, the data is not immediately copied, but rather shared.  The actual
-copying is postponed until the copied data needs to be modified.  For example:
-
-@example
-@group
-a = zeros (1000); # create a 1000x1000 matrix
-b = a; # no copying done here
-b(1) = 1; # copying done here
-@end group
-@end example
-
-Lazy copying applies to whole Octave objects such as matrices, cells, struct,
-and also individual cell or struct elements (not array elements).
-
-Additionally, index expressions also use lazy copying when Octave can determine
-that the indexed portion is contiguous in memory.  For example:
-
-@example
-@group
-a = zeros (1000); # create a 1000x1000 matrix
-b = a(:,10:100); # no copying done here
-b = a(10:100,:); # copying done here
-@end group
-@end example
-
-This applies to arrays (matrices), cell arrays, and structs indexed using ().
-Index expressions generating cs-lists can also benefit of shallow copying
-in some cases.  In particular, when @var{a} is a struct array, expressions like
-@code{@{a.x@}, @{a(:,2).x@}} will use lazy copying, so that data can be shared
-between a struct array and a cell array.
-
-Most indexing expressions do not live longer than their `parent' objects.
-In rare cases, however, a lazily copied slice outlasts its parent, in which
-case it becomes orphaned, still occupying unnecessarily more memory than needed.
-To provide a remedy working in most real cases,
-Octave checks for orphaned lazy slices at certain situations, when a value
-is stored into a "permanent" location, such as a named variable or cell or
-struct element, and possibly economizes them.  For example:
-
-@example
-@group
-a = zeros (1000); # create a 1000x1000 matrix
-b = a(:,10:100);  # lazy slice
-a = []; # the original a array is still allocated
-c@{1@} = b; # b is reallocated at this point
-@end group
-@end example
-
-@item
-Avoid deep recursion.  Function calls to m-file functions carry a relatively
-significant overhead, so rewriting a recursion as a loop often helps.  Also,
-note that the maximum level of recursion is limited.
-
-@item
-Avoid resizing matrices unnecessarily.  When building a single result
-matrix from a series of calculations, set the size of the result matrix
-first, then insert values into it.  Write
-
-@example
-@group
-result = zeros (big_n, big_m)
-for i = over:and_over
-  r1 = @dots{}
-  r2 = @dots{}
-  result (r1, r2) = new_value ();
-endfor
-@end group
-@end example
-
-@noindent
-instead of
-
-@example
-@group
-result = [];
-for i = ever:and_ever
-  result = [ result, new_value() ];
-endfor
-@end group
-@end example
-
-Sometimes the number of items can't be computed in advance, and stack-like
-operations are needed.  When elements are being repeatedly inserted at/removed
-from the end of an array, Octave detects it as stack usage and attempts to use a
-smarter memory management strategy pre-allocating the array in bigger chunks. 
-Likewise works for cell and struct arrays.
-
-@example
-@group
-a = [];
-while (condition)
-  @dots{}
-  a(end+1) = value; # "push" operation
-  @dots{}
-  a(end) = []; # "pop" operation
-  @dots{}
-endwhile
-@end group
-@end example
-
-@item
-Use @code{cellfun} intelligently.  The @code{cellfun} function is a useful tool
-for avoiding loops.  @xref{Processing Data in Cell Arrays}.
-@code{cellfun} is often used with anonymous function handles; however, calling
-an anonymous function involves an overhead quite comparable to the overhead
-of an m-file function.  Passing a handle to a built-in function is faster,
-because the interpreter is not involved in the internal loop.  For example:
-
-@example
-@group
-a = @{@dots{}@}
-v = cellfun (@@(x) det(x), a); # compute determinants
-v = cellfun (@@det, a); # faster
-@end group
-@end example
-
-@item
-Octave includes a number of other functions that can replace common types of
-loops, including @code{bsxfun}, @code{arrayfun}, @code{structfun},
-@code{accumarray}.  These functions can take an arbitrary function as a handle.
-Be sure to get familiar with them if you want to become an Octave expert.
-
-@item
-Avoid calling @code{eval} or @code{feval} excessively, because
-they require Octave to parse input or look up the name of a function in
-the symbol table.
-
-If you are using @code{eval} as an exception handling mechanism and not
-because you need to execute some arbitrary text, use the @code{try}
-statement instead.  @xref{The @code{try} Statement}.
-
-@item
-If you are calling lots of functions but none of them will need to
-change during your run, set the variable
-@code{ignore_function_time_stamp} to @code{"all"} so that Octave doesn't
-waste a lot of time checking to see if you have updated your function
-files.
-@end itemize
 
 @node Comment Tips
 @section Tips on Writing Comments
 
 Here are the conventions to follow when writing comments.
 
 @table @samp
 @item #
@@ -684,107 +486,184 @@ Help text in Texinfo format.
 
 Many complete examples of Texinfo documentation can be taken from the
 help strings for the Octave functions themselves.  A relatively complete
 example of which is the @code{nchoosek} function.  The Texinfo
 documentation string for @code{nchoosek} is
 
 @example
 -*- texinfo -*-
-@@deftypefn @{Function File@} @{@} nchoosek (@@var@{n@}, @@var@{k@})
+@@deftypefn  @{Function File@} @{@@var@{c@} =@} nchoosek (@@var@{n@}, @@var@{k@})
+@@deftypefnx @{Function File@} @{@@var@{c@} =@} nchoosek (@@var@{set@}, @@var@{k@})
 
-Compute the binomial coefficient or all combinations of 
-@@var@{n@}.  If @@var@{n@} is a scalar then, calculate the
-binomial coefficient of @@var@{n@} and @@var@{k@}, defined as
+Compute the binomial coefficient or all combinations of a set of items.
 
+If @@var@{n@} is a scalar then calculate the binomial coefficient
+of @@var@{n@} and @@var@{k@} which is defined as
 @@tex
 $$
  @{n \choose k@} = @{n (n-1) (n-2) \cdots (n-k+1) \over k!@}
+               = @{n! \over k! (n-k)!@}
 $$
 @@end tex
 @@ifnottex
 
 @@example
 @@group
  /   \
- | n |    n (n-1) (n-2) @dots{} (n-k+1)
- |   |  = -------------------------
- | k |               k!
+ | n |    n (n-1) (n-2) @@dots@{@} (n-k+1)       n!
+ |   |  = ------------------------- =  ---------
+ | k |               k!                k! (n-k)!
  \   /
 @@end group
 @@end example
+
 @@end ifnottex
+@@noindent
+This is the number of combinations of @@var@{n@} items taken in groups of
+size @@var@{k@}.
+
+If the first argument is a vector, @@var@{set@}, then generate all
+combinations of the elements of @@var@{set@}, taken @@var@{k@} at a time, with
+one row per combination.  The result @@var@{c@} has @@var@{k@} columns and
+@@w@{@@code@{nchoosek (length (@@var@{set@}), @@var@{k@})@}@} rows.
+
+For example:
+
+How many ways can three items be grouped into pairs?
 
-If @@var@{n@} is a vector, this generates all combinations
-of the elements of @@var@{n@}, taken @@var@{k@} at a time,
-one row per combination.  The resulting @@var@{c@} has size
-@@code@{[nchoosek (length (@@var@{n@}),@@var@{k@}), @@var@{k@}]@}.
+@@example
+@@group
+nchoosek (3, 2)
+   @@result@{@} 3
+@@end group
+@@end example
+
+What are the possible pairs?
 
-@@code@{nchoosek@} works only for non-negative integer arguments; use
-@@code@{bincoeff@} for non-integer scalar arguments and for using vector
-arguments to compute many coefficients at once.
+@@example
+@@group
+nchoosek (1:3, 2)
+   @@result@{@}  1   2
+       1   3
+       2   3
+@@end group
+@@end example
 
-@@seealso@{bincoeff@}
+@@code@{nchoosek@} works only for non-negative, integer arguments.  Use
+@@code@{bincoeff@} for non-integer and negative scalar arguments, or for
+computing many binomial coefficients at once with vector inputs
+for @@var@{n@} or @@var@{k@}.
+
+@@seealso@{bincoeff, perms@}
 @@end deftypefn
 @end example
-
+@noindent
 which demonstrates most of the concepts discussed above.
 @iftex
 This documentation string renders as
 
-@c Note actually use the output of info below rather than try and 
-@c reproduce it here to prevent it looking different than how it would
+@c Note: use the actual output of info below, rather than try and 
+@c reproduce it here to prevent it looking different from how it would
 @c appear with info.
 @example
-@group
  -- Function File: C = nchoosek (N, K)
-     Compute the binomial coefficient or all combinations
-     of N.  If N is a scalar then, calculate the binomial
-     coefficient of N and K, defined as
+ -- Function File: C = nchoosek (SET, K)
+     Compute the binomial coefficient or all combinations of a set of
+     items.
+
+     If N is a scalar then calculate the binomial coefficient of N and
+     K which is defined as
 
            /   \
-           | n |    n (n-1) (n-2) @dots{} (n-k+1)       n!
+           | n |    n (n-1) (n-2) ... (n-k+1)       n!
            |   |  = ------------------------- =  ---------
            | k |               k!                k! (n-k)!
            \   /
 
-     If N is a vector generate all combinations of the
-     elements of N, taken K at a time, one row per
-     combination.  The resulting C has size `[nchoosek
-     (length (N), K), K]'.
+     This is the number of combinations of N items taken in groups of
+     size K.
+
+     If the first argument is a vector, SET, then generate all
+     combinations of the elements of SET, taken K at a time, with one
+     row per combination.  The result C has K columns and
+     `nchoosek (length (SET), K)' rows.
 
-     `nchoosek' works only for non-negative integer
-     arguments; use `bincoeff' for non-integer scalar 
-     arguments and for using vector arguments to compute
-     many coefficients at once.
+     For example:
+
+     How many ways can three items be grouped into pairs?
+
+          nchoosek (3, 2)
+             => 3
+
+     What are the possible pairs?
 
-     See also: bincoeff.
-@end group
-@end example
+          nchoosek (1:3, 2)
+             =>  1   2
+                 1   3
+                 2   3
+
+     `nchoosek' works only for non-negative, integer arguments.  Use
+     `bincoeff' for non-integer and negative scalar arguments, or for
+     computing many binomial coefficients at once with vector inputs
+     for N or K.
 
-using info, whereas in a printed documentation using @TeX{} it will appear
-as
+     See also: bincoeff, perms
+@end example
+@noindent
+using info, whereas in a printed documentation using @TeX{} it will
+appear as
 
-@deftypefn {Function File} {@var{c} =} nchoosek (@var{n}, @var{k})
+@deftypefn  {Function File} {@var{c} =} nchoosek (@var{n}, @var{k})
+@deftypefnx {Function File} {@var{c} =} nchoosek (@var{set}, @var{k})
 
-Compute the binomial coefficient or all combinations of @var{n}.
-If @var{n} is a scalar then, calculate the binomial coefficient
-of @var{n} and @var{k}, defined as
+Compute the binomial coefficient or all combinations of a set of items.
+
+If @var{n} is a scalar then calculate the binomial coefficient
+of @var{n} and @var{k} which is defined as
 
 @tex
 $$
  {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
+               = {n! \over k! (n-k)!}
 $$
 @end tex
 
-If @var{n} is a vector generate all combinations of the elements
-of @var{n}, taken @var{k} at a time, one row per combination.  The 
-resulting @var{c} has size @code{[nchoosek (length (@var{n}), 
-@var{k}), @var{k}]}.
+@noindent
+This is the number of combinations of @var{n} items taken in groups of
+size @var{k}.
+
+If the first argument is a vector, @var{set}, then generate all
+combinations of the elements of @var{set}, taken @var{k} at a time, with
+one row per combination.  The result @var{c} has @var{k} columns and
+@w{@code{nchoosek (length (@var{set}), @var{k})}} rows.
+
+For example:
+
+How many ways can three items be grouped into pairs?
 
-@code{nchoosek} works only for non-negative integer arguments; use
-@code{bincoeff} for non-integer scalar arguments and for using vector
-arguments to compute many coefficients at once.
+@example
+@group
+nchoosek (3, 2)
+   @result{} 3
+@end group
+@end example
+
+What are the possible pairs?
 
-@seealso{bincoeff}
+@example
+@group
+nchoosek (1:3, 2)
+   @result{}  1   2
+       1   3
+       2   3
+@end group
+@end example
+
+@code{nchoosek} works only for non-negative, integer arguments.  Use
+@code{bincoeff} for non-integer and negative scalar arguments, or for
+computing many binomial coefficients at once with vector inputs for @var{n}
+or @var{k}.
+
+@seealso{bincoeff, perms}
 @end deftypefn
 
 @end iftex
diff --git a/doc/interpreter/vectorize.txi b/doc/interpreter/vectorize.txi
new file mode 100644
--- /dev/null
+++ b/doc/interpreter/vectorize.txi
@@ -0,0 +1,678 @@
+@c Copyright (C) 2011 Jordi Gutiérrez Hermoso
+@c
+@c This file is part of Octave.
+@c
+@c Octave is free software; you can redistribute it and/or modify it
+@c under the terms of the GNU General Public License as published by the
+@c Free Software Foundation; either version 3 of the License, or (at
+@c your option) any later version.
+@c
+@c Octave is distributed in the hope that it will be useful, but WITHOUT
+@c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+@c FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
+@c for more details.
+@c
+@c You should have received a copy of the GNU General Public License
+@c along with Octave; see the file COPYING. If not, see
+@c <http://www.gnu.org/licenses/>.
+
+@node Vectorization and Faster Code Execution
+@chapter Vectorization and Faster Code Execution
+@cindex vectorization
+@cindex vectorize
+
+Vectorization is a programming technique that uses vector operations
+instead of element-by-element loop-based operations.  Besides frequently
+producing more succinct Octave code, vectorization also allows for better
+optimization in the subsequent implementation.  The optimizations may occur
+either in Octave's own Fortran, C, or C++ internal implementation, or even at a
+lower level depending on the compiler and external numerical libraries used to
+build Octave.  The ultimate goal is to make use of your hardware's vector
+instructions if possible or to perform other optimizations in software.
+
+Vectorization is not a concept unique to Octave, but it is particularly
+important because Octave is a matrix-oriented language.  Vectorized
+Octave code will see a dramatic speed up (10X--100X) in most cases.
+
+This chapter discusses vectorization and other techniques for writing faster
+code.
+
+@menu
+* Basic Vectorization::        Basic techniques for code optimization
+* Broadcasting::               Broadcasting operations
+* Function Application::       Applying functions to arrays, cells, and structs
+* Accumulation::               Accumulation functions
+* Miscellaneous Techniques::   Other techniques for speeding up code
+* Examples::
+@end menu
+
+@node Basic Vectorization
+@section Basic Vectorization
+
+To a very good first approximation, the goal in vectorization is to
+write code that avoids loops and uses whole-array operations.  As a
+trivial example, consider
+
+@example
+@group
+for i = 1:n
+  for j = 1:m
+    c(i,j) = a(i,j) + b(i,j);
+  endfor
+endfor
+@end group
+@end example
+
+@noindent
+compared to the much simpler
+
+@example
+c = a + b;
+@end example
+
+@noindent
+This isn't merely easier to write; it is also internally much easier to
+optimize.  Octave delegates this operation to an underlying
+implementation which, among other optimizations, may use special vector
+hardware instructions or could conceivably even perform the additions in
+parallel.  In general, if the code is vectorized, the underlying
+implementation has more freedom about the assumptions it can make
+in order to achieve faster execution.
+
+This is especially important for loops with "cheap" bodies.  Often it
+suffices to vectorize just the innermost loop to get acceptable
+performance.  A general rule of thumb is that the "order" of the
+vectorized body should be greater or equal to the "order" of the
+enclosing loop.
+
+As a less trivial example, instead of
+
+@example
+@group
+for i = 1:n-1
+  a(i) = b(i+1) - b(i);
+endfor
+@end group
+@end example
+
+@noindent
+write
+
+@example
+a = b(2:n) - b(1:n-1);
+@end example
+
+This shows an important general concept about using arrays for indexing
+instead of looping over an index variable.  @xref{Index Expressions}.
+Also use boolean indexing generously.  If a condition needs to be tested,
+this condition can also be written as a boolean index.  For instance,
+instead of
+
+@example
+@group
+for i = 1:n
+  if a(i) > 5
+    a(i) -= 20
+  endif
+endfor
+@end group
+@end example
+
+@noindent
+write
+
+@example
+a(a>5) -= 20;
+@end example
+
+@noindent
+which exploits the fact that @code{a > 5} produces a boolean index.
+
+Use elementwise vector operators whenever possible to avoid looping
+(operators like @code{.*} and @code{.^}).  @xref{Arithmetic Ops}.  For
+simple inline functions, the @code{vectorize} function can do this
+automatically.
+
+@DOCSTRING(vectorize)
+
+Also exploit broadcasting in these elementwise operators both to avoid
+looping and unnecessary intermediate memory allocations.
+@xref{Broadcasting}.
+
+Use built-in and library functions if possible.  Built-in and compiled
+functions are very fast.  Even with an m-file library function, chances
+are good that it is already optimized, or will be optimized more in a
+future release.
+
+For instance, even better than
+
+@example
+a = b(2:n) - b(1:n-1);
+@end example
+
+@noindent
+is
+
+@example
+a = diff (b);
+@end example
+
+Most Octave functions are written with vector and array arguments in
+mind.  If you find yourself writing a loop with a very simple operation,
+chances are that such a function already exists.  The following functions
+occur frequently in vectorized code:
+
+@itemize @bullet
+@item
+Index manipulation
+
+@itemize
+@item
+find
+
+@item
+sub2ind
+
+@item
+ind2sub
+
+@item
+sort
+
+@item
+unique
+
+@item
+lookup
+
+@item
+ifelse / merge
+@end itemize
+
+@item
+Repetition
+@itemize
+@item
+repmat
+
+@item
+repelems
+@end itemize
+
+@item
+Vectorized arithmetic
+@itemize
+@item
+sum
+
+@item
+prod
+
+@item
+cumsum
+
+@item
+cumprod
+
+@item
+sumsq
+
+@item
+diff
+
+@item
+dot
+
+@item
+cummax
+
+@item
+cummin
+@end itemize
+
+@item
+Shape of higher dimensional arrays
+@itemize
+@item
+reshape
+
+@item
+resize
+
+@item
+permute
+
+@item
+squeeze
+
+@item
+deal
+@end itemize
+
+@end itemize
+
+@node Broadcasting
+@section Broadcasting
+@cindex broadcast
+@cindex broadcasting
+@cindex BSX
+@cindex recycling
+@cindex SIMD
+
+Broadcasting refers to how Octave binary operators and functions behave
+when their matrix or array operands or arguments differ in size.  Since
+version 3.6.0, Octave now automatically broadcasts vectors, matrices,
+and arrays when using elementwise binary operators and functions.
+Broadly speaking, smaller arrays are ``broadcast'' across the larger
+one, until they have a compatible shape.  The rule is that corresponding
+array dimensions must either
+
+@enumerate
+@item
+be equal, or
+
+@item
+one of them must be 1.
+@end enumerate
+
+@noindent
+In case all dimensions are equal, no broadcasting occurs and ordinary
+element-by-element arithmetic takes place.  For arrays of higher
+dimensions, if the number of dimensions isn't the same, then missing
+trailing dimensions are treated as 1.  When one of the dimensions is 1,
+the array with that singleton dimension gets copied along that dimension
+until it matches the dimension of the other array.  For example, consider
+
+@example
+@group
+x = [1 2 3;
+     4 5 6;
+     7 8 9];
+
+y = [10 20 30];
+
+x + y
+@end group
+@end example
+
+@noindent
+Without broadcasting, @code{x + y} would be an error because the dimensions
+do not agree.  However, with broadcasting it is as if the following
+operation were performed:
+
+@example
+@group
+x = [1 2 3
+     4 5 6
+     7 8 9];
+
+y = [10 20 30
+     10 20 30
+     10 20 30];
+
+x + y
+@result{}    11   22   33
+      14   25   36
+      17   28   39
+@end group
+@end example
+
+@noindent
+That is, the smaller array of size @code{[1 3]} gets copied along the
+singleton dimension (the number of rows) until it is @code{[3 3]}.  No
+actual copying takes place, however.  The internal implementation reuses
+elements along the necessary dimension in order to achieve the desired
+effect without copying in memory.
+
+Both arrays can be broadcast across each other, for example, all
+pairwise differences of the elements of a vector with itself:
+
+@example
+@group
+y - y'
+@result{}    0   10   20
+    -10    0   10
+    -20  -10    0
+@end group
+@end example
+
+@noindent
+Here the vectors of size @code{[1 3]} and @code{[3 1]} both get
+broadcast into matrices of size @code{[3 3]} before ordinary matrix
+subtraction takes place.
+
+A special case of broadcasting that may be familiar is when all
+dimensions of the array being broadcast are 1, i.e. the array is a
+scalar. Thus for example, operations like @code{x - 42} and @code{max
+(x, 2)} are basic examples of broadcasting.
+
+For a higher-dimensional example, suppose @code{img} is an RGB image of
+size @code{[m n 3]} and we wish to multiply each color by a different
+scalar.  The following code accomplishes this with broadcasting,
+
+@example
+img .*= permute ([0.8, 0.9, 1.2], [1, 3, 2]);
+@end example
+
+@noindent
+Note the usage of permute to match the dimensions of the
+@code{[0.8, 0.9, 1.2]} vector with @code{img}.
+
+For functions that are not written with broadcasting semantics,
+@code{bsxfun} can be useful for coercing them to broadcast.
+
+@DOCSTRING(bsxfun)
+
+Broadcasting is only applied if either of the two broadcasting
+conditions hold.  As usual, however, broadcasting does not apply when two
+dimensions differ and neither is 1:
+
+@example
+@group
+x = [1 2 3
+     4 5 6];
+y = [10 20
+     30 40];
+x + y
+@end group
+@end example
+
+@noindent
+This will produce an error about nonconformant arguments.
+
+Besides common arithmetic operations, several functions of two arguments
+also broadcast.  The full list of functions and operators that broadcast
+is
+
+@example
+      plus      +  .+
+      minus     -  .-
+      times     .*
+      rdivide   ./
+      ldivide   .\
+      power     .^  .**
+      lt        <
+      le        <=
+      eq        ==
+      gt        >
+      ge        >=
+      ne        !=  ~=
+      and       &
+      or        |
+      atan2
+      hypot
+      max
+      min
+      mod
+      rem
+      xor
+
+      +=  -=  .+=  .-=  .*=  ./=  .\=  .^=  .**=  &=  |=
+@end example
+
+Beware of resorting to broadcasting if a simpler operation will suffice.
+For matrices @var{a} and @var{b}, consider the following:
+
+@example
+@var{c} = sum (permute (@var{a}, [1, 3, 2]) .* permute (@var{b}, [3, 2, 1]), 3);
+@end example
+
+@noindent
+This operation broadcasts the two matrices with permuted dimensions
+across each other during elementwise multiplication in order to obtain a
+larger 3-D array, and this array is then summed along the third dimension.
+A moment of thought will prove that this operation is simply the much
+faster ordinary matrix multiplication, @code{@var{c} = @var{a}*@var{b};}.
+
+A note on terminology: ``broadcasting'' is the term popularized by the
+Numpy numerical environment in the Python programming language.  In other
+programming languages and environments, broadcasting may also be known
+as @emph{binary singleton expansion} (BSX, in @sc{matlab}, and the
+origin of the name of the @code{bsxfun} function), @emph{recycling} (R
+programming language), @emph{single-instruction multiple data} (SIMD),
+or @emph{replication}.
+
+@subsection Broadcasting and Legacy Code
+
+The new broadcasting semantics almost never affect code that worked
+in previous versions of Octave.  Consequently, all code inherited from
+@sc{matlab} that worked in previous versions of Octave should still work
+without change in Octave.  The only exception is code such as
+
+@example
+@group
+try
+  c = a.*b;
+catch
+  c = a.*a;
+end_try_catch
+@end group
+@end example
+
+@noindent
+that may have relied on matrices of different size producing an error.
+Due to how broadcasting changes semantics with older versions of Octave,
+by default Octave warns if a broadcasting operation is performed.  To
+disable this warning, refer to its ID (@pxref{doc-warning_ids}):
+
+@example
+warning ("off", "Octave:broadcast");
+@end example
+
+@noindent
+If you want to recover the old behavior and produce an error, turn this
+warning into an error:
+
+@example
+warning ("error", "Octave:broadcast");
+@end example
+
+@noindent
+For broadcasting on scalars that worked in previous versions of Octave,
+this warning will not be emitted.
+
+@node Function Application
+@section Function Application
+@cindex map
+@cindex apply
+@cindex function application
+
+As a general rule, functions should already be written with matrix
+arguments in mind and should consider whole matrix operations in a
+vectorized manner.  Sometimes, writing functions in this way appears
+difficult or impossible for various reasons.  For those situations,
+Octave provides facilities for applying a function to each element of an
+array, cell, or struct.
+
+@DOCSTRING(arrayfun)
+
+@DOCSTRING(spfun)
+
+@DOCSTRING(cellfun)
+
+@DOCSTRING(structfun)
+
+@node Accumulation
+@section Accumulation
+
+Whenever it's possible to categorize according to indices the elements
+of an array when performing a computation, accumulation functions can be
+useful.
+
+@DOCSTRING(accumarray)
+
+@DOCSTRING(accumdim)
+
+@node Miscellaneous Techniques
+@section Miscellaneous Techniques
+@cindex execution speed
+@cindex speedups
+@cindex optimization
+
+Here are some other ways of improving the execution speed of Octave
+programs.
+
+@itemize @bullet
+
+@item Avoid computing costly intermediate results multiple times.
+Octave currently does not eliminate common subexpressions.  Also, certain
+internal computation results are cached for variables.  For instance, if
+a matrix variable is used multiple times as an index, checking the
+indices (and internal conversion to integers) is only done once.
+
+@item Be aware of lazy copies (copy-on-write).  
+@cindex copy-on-write
+@cindex COW
+@cindex memory management
+When a copy of an object is created, the data is not immediately copied, but
+rather shared.  The actual copying is postponed until the copied data needs to
+be modified.  For example:
+
+@example
+@group
+a = zeros (1000); # create a 1000x1000 matrix
+b = a; # no copying done here
+b(1) = 1; # copying done here
+@end group
+@end example
+
+Lazy copying applies to whole Octave objects such as matrices, cells,
+struct, and also individual cell or struct elements (not array
+elements).
+
+Additionally, index expressions also use lazy copying when Octave can
+determine that the indexed portion is contiguous in memory.  For example:
+
+@example
+@group
+a = zeros (1000); # create a 1000x1000 matrix
+b = a(:,10:100);  # no copying done here
+b = a(10:100,:);  # copying done here
+@end group
+@end example
+
+This applies to arrays (matrices), cell arrays, and structs indexed
+using @samp{()}.  Index expressions generating comma-separated lists can also
+benefit from shallow copying in some cases.  In particular, when @var{a} is a
+struct array, expressions like @code{@{a.x@}, @{a(:,2).x@}} will use lazy
+copying, so that data can be shared between a struct array and a cell array.
+
+Most indexing expressions do not live longer than their parent
+objects.  In rare cases, however, a lazily copied slice outlasts its
+parent, in which case it becomes orphaned, still occupying unnecessarily
+more memory than needed.  To provide a remedy working in most real cases,
+Octave checks for orphaned lazy slices at certain situations, when a
+value is stored into a "permanent" location, such as a named variable or
+cell or struct element, and possibly economizes them.  For example:
+
+@example
+@group
+a = zeros (1000); # create a 1000x1000 matrix
+b = a(:,10:100);  # lazy slice
+a = []; # the original a array is still allocated
+c@{1@} = b; # b is reallocated at this point
+@end group
+@end example
+
+@item Avoid deep recursion.
+Function calls to m-file functions carry a relatively significant overhead, so
+rewriting a recursion as a loop often helps.  Also, note that the maximum level
+of recursion is limited.
+
+@item Avoid resizing matrices unnecessarily.
+When building a single result matrix from a series of calculations, set the
+size of the result matrix first, then insert values into it.  Write
+
+@example
+@group
+result = zeros (big_n, big_m)
+for i = over:and_over
+  ridx = @dots{}
+  cidx = @dots{}
+  result(ridx, cidx) = new_value ();
+endfor
+@end group
+@end example
+
+@noindent
+instead of
+
+@example
+@group
+result = [];
+for i = ever:and_ever
+  result = [ result, new_value() ];
+endfor
+@end group
+@end example
+
+Sometimes the number of items can not be computed in advance, and
+stack-like operations are needed.  When elements are being repeatedly
+inserted or removed from the end of an array, Octave detects it as stack
+usage and attempts to use a smarter memory management strategy by
+pre-allocating the array in bigger chunks.  This strategy is also applied
+to cell and struct arrays.
+
+@example
+@group
+a = [];
+while (condition)
+  @dots{}
+  a(end+1) = value; # "push" operation
+  @dots{}
+  a(end) = []; # "pop" operation
+  @dots{}
+endwhile
+@end group
+@end example
+
+@item Avoid calling @code{eval} or @code{feval} excessively.
+Parsing input or looking up the name of a function in the symbol table are
+relatively expensive operations.
+
+If you are using @code{eval} merely as an exception handling mechanism, and not
+because you need to execute some arbitrary text, use the @code{try}
+statement instead.  @xref{The @code{try} Statement}.
+
+@item Use @code{ignore_function_time_stamp} when appropriate.
+If you are calling lots of functions, and none of them will need to change
+during your run, set the variable @code{ignore_function_time_stamp} to
+@code{"all"}.  This will stop Octave from checking the time stamp of a function
+file to see if it has been updated while the program is being run.
+@end itemize
+
+@node Examples
+@section Examples
+
+The following are examples of vectorization questions asked by actual
+users of Octave and their solutions.
+
+@c FIXME: We need a lot more examples here.
+
+@itemize @bullet
+@item
+For a vector @code{A}, the following loop
+
+@example
+@group
+n = length (A);
+B = zeros (n, 2);
+for i = 1:length(A)
+  ## this will be two columns, the first is the difference and
+  ## the second the mean of the two elements used for the diff.
+  B(i,:) = [A(i+1)-A(i), (A(i+1) + A(i))/2)];
+endfor
+@end group
+@end example
+
+@noindent
+can be turned into the following one-liner:
+
+@example
+B = [diff(A)(:), 0.5*(A(1:end-1)+A(2:end))(:)]
+@end example
+
+Note the usage of colon indexing to flatten an intermediate result into
+a column vector.  This is a common vectorization trick.
+
+@end itemize
diff --git a/examples/@FIRfilter/FIRfilter.m b/examples/@FIRfilter/FIRfilter.m
--- a/examples/@FIRfilter/FIRfilter.m
+++ b/examples/@FIRfilter/FIRfilter.m
@@ -1,14 +1,12 @@
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} FIRfilter ()
+## @deftypefn  {Function File} {} FIRfilter ()
 ## @deftypefnx {Function File} {} FIRfilter (@var{p})
-## Creates an FIR filter with polynomial @var{p} as
-## coefficient vector.
-##
+## Create a FIR filter with polynomial @var{p} as coefficient vector.
 ## @end deftypefn
 
 function f = FIRfilter (p)
 
   f.polynomial = [];
   if (nargin == 0)
     p = @polynomial ([1]);
   elseif (nargin == 1)
diff --git a/examples/@FIRfilter/FIRfilter_aggregation.m b/examples/@FIRfilter/FIRfilter_aggregation.m
--- a/examples/@FIRfilter/FIRfilter_aggregation.m
+++ b/examples/@FIRfilter/FIRfilter_aggregation.m
@@ -1,14 +1,12 @@
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} FIRfilter ()
+## @deftypefn  {Function File} {} FIRfilter ()
 ## @deftypefnx {Function File} {} FIRfilter (@var{p})
-## Creates an FIR filter with polynomial @var{p} as
-## coefficient vector.
-##
+## Create a FIR filter with polynomial @var{p} as coefficient vector.
 ## @end deftypefn
 
 function f = FIRfilter (p)
 
   if (nargin == 0)
     f.polynomial = @polynomial ([1]);
   elseif (nargin == 1)
     if (isa (p, "polynomial"))
diff --git a/examples/@polynomial/polynomial.m b/examples/@polynomial/polynomial.m
--- a/examples/@polynomial/polynomial.m
+++ b/examples/@polynomial/polynomial.m
@@ -1,18 +1,19 @@
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} polynomial ()
+## @deftypefn  {Function File} {} polynomial ()
 ## @deftypefnx {Function File} {} polynomial (@var{a})
-## Creates a polynomial object representing the polynomial
+## Create a polynomial object representing the polynomial
 ##
 ## @example
 ## a0 + a1 * x + a2 * x^2 + @dots{} + an * x^n
 ## @end example
 ##
-## from a vector of coefficients [a0 a1 a2 ... an].
+## @noindent
+## from a vector of coefficients [a0 a1 a2 @dots{} an].
 ## @end deftypefn
 
 function p = polynomial (a)
   if (nargin == 0)
     p.poly = [0];
     p = class (p, "polynomial");
   elseif (nargin == 1)
     if (strcmp (class (a), "polynomial"))
diff --git a/examples/@polynomial/polynomial_superiorto.m b/examples/@polynomial/polynomial_superiorto.m
--- a/examples/@polynomial/polynomial_superiorto.m
+++ b/examples/@polynomial/polynomial_superiorto.m
@@ -1,18 +1,19 @@
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} polynomial ()
+## @deftypefn  {Function File} {} polynomial ()
 ## @deftypefnx {Function File} {} polynomial (@var{a})
-## Creates a polynomial object representing the polynomial
+## Create a polynomial object representing the polynomial
 ##
 ## @example
 ## a0 + a1 * x + a2 * x^2 + @dots{} + an * x^n
 ## @end example
 ##
-## from a vector of coefficients [a0 a1 a2 ... an].
+## @noindent
+## from a vector of coefficients [a0 a1 a2 @dots{} an].
 ## @end deftypefn
 
 function p = polynomial (a)
   if (nargin == 0)
     p.poly = [0];
     p = class (p, "polynomial");
   elseif (nargin == 1)
     if (strcmp (class (a), "polynomial"))
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -38,17 +38,17 @@ template <class T>
 class
 DiagArray2 : protected Array<T>
 {
 protected:
   octave_idx_type d1, d2;
 
 public:
 
-  using Array<T>::element_type;
+  using typename Array<T>::element_type;
 
   DiagArray2 (void)
     : Array<T> (), d1 (0), d2 (0) { }
 
   DiagArray2 (octave_idx_type r, octave_idx_type c)
     : Array<T> (dim_vector (std::min (r, c), 1)), d1 (r), d2 (c) { }
 
   DiagArray2 (octave_idx_type r, octave_idx_type c, const T& val)
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
--- a/liboctave/MatrixType.cc
+++ b/liboctave/MatrixType.cc
@@ -451,21 +451,21 @@ MatrixType::MatrixType (const SparseMatr
       // Disable lower under-determined and upper over-determined problems
       // as being detected, and force to treat as singular. As this seems
       // to cause issues
       if (((typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
            && nrows > ncols) ||
           ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
            && nrows < ncols))
         {
-          typ = MatrixType::Rectangular;
           if (typ == MatrixType::Permuted_Upper ||
               typ == MatrixType::Permuted_Lower)
             delete [] perm;
           nperm = 0;
+          typ = MatrixType::Rectangular;
         }
 
       if (typ == MatrixType::Full && ncols != nrows)
         typ = MatrixType::Rectangular;
 
       if (maybe_hermitian && (typ == MatrixType::Full ||
                               typ == MatrixType::Tridiagonal ||
                               typ == MatrixType::Banded))
@@ -772,21 +772,21 @@ MatrixType::MatrixType (const SparseComp
       // Disable lower under-determined and upper over-determined problems
       // as being detected, and force to treat as singular. As this seems
       // to cause issues
       if (((typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
            && nrows > ncols) ||
           ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
            && nrows < ncols))
         {
-          typ = MatrixType::Rectangular;
           if (typ == MatrixType::Permuted_Upper ||
               typ == MatrixType::Permuted_Lower)
             delete [] perm;
           nperm = 0;
+          typ = MatrixType::Rectangular;
         }
 
       if (typ == MatrixType::Full && ncols != nrows)
         typ = MatrixType::Rectangular;
 
       if (maybe_hermitian && (typ == MatrixType::Full ||
                               typ == MatrixType::Tridiagonal ||
                               typ == MatrixType::Banded))
diff --git a/liboctave/bsxfun.h b/liboctave/bsxfun.h
--- a/liboctave/bsxfun.h
+++ b/liboctave/bsxfun.h
@@ -37,17 +37,17 @@ is_valid_bsxfun (const std::string& name
     {
       octave_idx_type xk = dx(i), yk = dy(i);
       // Check the three conditions for valid bsxfun dims
       if (! ( (xk == yk) || (xk == 1 && yk > 1) || (xk > 1 && yk == 1)))
         return false;
     }
 
   (*current_liboctave_warning_with_id_handler)
-    ("Octave:auto-bsxfun", "%s: automatic broadcasting operation applied", name.c_str ());
+    ("Octave:broadcast", "%s: automatic broadcasting operation applied", name.c_str ());
 
   return true;
 }
 
 // since we can't change the size of the assigned-to matrix, we cannot
 // apply singleton expansion to it, so the conditions to check are
 // different here.
 inline
@@ -64,16 +64,16 @@ is_valid_inplace_bsxfun (const std::stri
       octave_idx_type rk = dr(i), xk = dx(i);
 
       // Only two valid canditions to check; can't stretch rk
       if (! ( (rk == xk) || (rk > 1 && xk == 1)))
         return false;
     }
 
   (*current_liboctave_warning_with_id_handler)
-    ("Octave:auto-bsxfun", "%s: automatic broadcasting operation applied", name.c_str ());
+    ("Octave:broadcast", "%s: automatic broadcasting operation applied", name.c_str ());
 
   return true;
 }
 
 #include "bsxfun-defs.cc"
 
 #endif
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -28,33 +28,33 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <string>
 
 #include "cmd-edit.h"
 #include "cmd-hist.h"
 #include "file-ops.h"
 #include "lo-error.h"
+#include "singleton-cleanup.h"
 #include "str-vec.h"
 
 command_history *command_history::instance = 0;
 
 #if defined (USE_READLINE)
 
 #include <cstdlib>
 
 #include <sys/types.h>
 #include <unistd.h>
 
 #include <fcntl.h>
 
 #include "oct-rl-hist.h"
 
 #include "file-stat.h"
-#include "singleton-cleanup.h"
 
 class
 gnu_history : public command_history
 {
 public:
 
   gnu_history (void)
     : command_history (), mark (0) { }
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -326,17 +326,20 @@ idx_vector::idx_vector_rep::idx_vector_r
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type[len];
       for (octave_idx_type i = 0; i < len; i++)
         d[i] = convert_index (nda.xelem (i), err, ext);
       data = d;
 
       if (err)
+      {
+        delete [] data;
         gripe_invalid_index ();
+      }
     }
 }
 
 // Note that this makes a shallow copy of the index array.
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<octave_idx_type>& inda)
   : data (inda.data ()), len (inda.numel ()), ext (0),
     aowner (new Array<octave_idx_type> (inda)), orig_dims (inda.dims ())
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 class NDArray;
 
 template <class T>
 class
 intNDArray : public MArray<T>
 {
 public:
 
-  using MArray<T>::element_type;
+  using typename MArray<T>::element_type;
 
   intNDArray (void) : MArray<T> () { }
 
   intNDArray (T val) : MArray<T> (dim_vector (1, 1), val) { }
 
   intNDArray (const dim_vector& dv) : MArray<T> (dv) { }
 
   intNDArray (const dim_vector& dv, T val)
diff --git a/liboctave/oct-fftw.cc b/liboctave/oct-fftw.cc
--- a/liboctave/oct-fftw.cc
+++ b/liboctave/oct-fftw.cc
@@ -32,49 +32,65 @@ along with Octave; see the file COPYING.
 #include "lo-error.h"
 #include "oct-fftw.h"
 #include "quit.h"
 #include "oct-locbuf.h"
 #include "singleton-cleanup.h"
 
 octave_fftw_planner *octave_fftw_planner::instance = 0;
 
-// Helper class to create and cache fftw plans for both 1d and
-// 2d. This implementation defaults to using FFTW_ESTIMATE to create
-// the plans, which in theory is suboptimal, but provides quit
-// reasonable performance.
+// Helper class to create and cache FFTW plans for both 1D and
+// 2D. This implementation defaults to using FFTW_ESTIMATE to create
+// the plans, which in theory is suboptimal, but provides quite
+// reasonable performance in practice.
 
-// Also note that if FFTW_ESTIMATE is not used the planner in FFTW3
-// destroys the input and output arrays. We must therefore create a
+// Also note that if FFTW_ESTIMATE is not used then the planner in FFTW3
+// will destroy the input and output arrays. We must, therefore, create a
 // temporary input array with the same size and 16-byte alignment as
-// the original array and use that for the planner. Note that we also
-// use any wisdom that is available, either in a FFTW3 system wide file
-//  or as supplied by the user.
+// the original array when using a different planner strategy.
+// Note that we also use any wisdom that is available, either in a
+// FFTW3 system wide file or as supplied by the user.
 
 // FIXME -- if we can ensure 16 byte alignment in Array<T>
 // (<T> *data) the FFTW3 can use SIMD instructions for further
 // acceleration.
 
-// Note that it is profitable to store the FFTW3 plans, for small
-// ffts.
+// Note that it is profitable to store the FFTW3 plans, for small FFTs.
 
 octave_fftw_planner::octave_fftw_planner (void)
   : meth (ESTIMATE), rplan (0), rd (0), rs (0), rr (0), rh (0), rn (),
     rsimd_align (false)
 {
   plan[0] = plan[1] = 0;
   d[0] = d[1] = s[0] = s[1] = r[0] = r[1] = h[0] = h[1] = 0;
   simd_align[0] = simd_align[1] = false;
   inplace[0] = inplace[1] = false;
   n[0] = n[1] = dim_vector ();
 
   // If we have a system wide wisdom file, import it.
   fftw_import_system_wisdom ();
 }
 
+octave_fftw_planner::~octave_fftw_planner (void)
+{
+  fftw_plan *plan_p;
+
+  plan_p = &rplan;
+  if (*plan_p)
+    fftw_destroy_plan (*plan_p);
+
+  plan_p = &plan[0];
+  if (*plan_p)
+    fftw_destroy_plan (*plan_p);
+
+  plan_p = &plan[1];
+  if (*plan_p)
+    fftw_destroy_plan (*plan_p);
+}
+
 bool
 octave_fftw_planner::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
     {
       instance = new octave_fftw_planner ();
@@ -378,16 +394,33 @@ octave_float_fftw_planner::octave_float_
   simd_align[0] = simd_align[1] = false;
   inplace[0] = inplace[1] = false;
   n[0] = n[1] = dim_vector ();
 
   // If we have a system wide wisdom file, import it.
   fftwf_import_system_wisdom ();
 }
 
+octave_float_fftw_planner::~octave_float_fftw_planner (void)
+{
+  fftwf_plan *plan_p;
+
+  plan_p = &rplan;
+  if (*plan_p)
+    fftwf_destroy_plan (*plan_p);
+
+  plan_p = &plan[0];
+  if (*plan_p)
+    fftwf_destroy_plan (*plan_p);
+
+  plan_p = &plan[1];
+  if (*plan_p)
+    fftwf_destroy_plan (*plan_p);
+}
+
 bool
 octave_float_fftw_planner::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
     {
       instance = new octave_float_fftw_planner ();
diff --git a/liboctave/oct-fftw.h b/liboctave/oct-fftw.h
--- a/liboctave/oct-fftw.h
+++ b/liboctave/oct-fftw.h
@@ -39,17 +39,17 @@ OCTAVE_API
 octave_fftw_planner
 {
 protected:
 
   octave_fftw_planner (void);
 
 public:
 
-  ~octave_fftw_planner (void) { }
+  ~octave_fftw_planner (void);
 
   enum FftwMethod
   {
     UNKNOWN = -1,
     ESTIMATE,
     MEASURE,
     PATIENT,
     EXHAUSTIVE,
@@ -176,17 +176,17 @@ OCTAVE_API
 octave_float_fftw_planner
 {
 protected:
 
   octave_float_fftw_planner (void);
 
 public:
 
-  ~octave_float_fftw_planner (void) { }
+  ~octave_float_fftw_planner (void);
 
   enum FftwMethod
   {
     UNKNOWN = -1,
     ESTIMATE,
     MEASURE,
     PATIENT,
     EXHAUSTIVE,
diff --git a/scripts/deprecated/module.mk b/scripts/deprecated/module.mk
--- a/scripts/deprecated/module.mk
+++ b/scripts/deprecated/module.mk
@@ -1,21 +1,23 @@
 FCN_FILE_DIRS += deprecated
 
 deprecated_FCN_FILES = \
+  deprecated/__error_text__.m \
   deprecated/autocor.m \
   deprecated/autocov.m \
   deprecated/betai.m \
   deprecated/cellidx.m \
   deprecated/clg.m \
   deprecated/cor.m \
   deprecated/corrcoef.m \
   deprecated/cquad.m \
   deprecated/cut.m \
   deprecated/dispatch.m \
+  deprecated/error_text.m \
   deprecated/fstat.m \
   deprecated/gammai.m \
   deprecated/glpkmex.m \
   deprecated/intwarning.m \
   deprecated/is_duplicate_entry.m \
   deprecated/is_global.m \
   deprecated/isstr.m \
   deprecated/krylovb.m \
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -21,24 +21,26 @@
 ## @deftypefn  {Function File} {} accumarray (@var{subs}, @var{vals}, @var{sz}, @var{func}, @var{fillval}, @var{issparse})
 ## @deftypefnx {Function File} {} accumarray (@var{subs}, @var{vals}, @dots{})
 ##
 ## Create an array by accumulating the elements of a vector into the
 ## positions defined by their subscripts.  The subscripts are defined by
 ## the rows of the matrix @var{subs} and the values by @var{vals}.  Each
 ## row of @var{subs} corresponds to one of the values in @var{vals}.  If
 ## @var{vals} is a scalar, it will be used for each of the row of
-## @var{subs}.
+## @var{subs}.  If @var{subs} is a cell array of vectors, all vectors
+## must be of the same length, and the subscripts in the @var{k}th
+## vector must correspond to the @var{k}th dimension of the result.
 ##
 ## The size of the matrix will be determined by the subscripts
 ## themselves.  However, if @var{sz} is defined it determines the matrix
 ## size.  The length of @var{sz} must correspond to the number of columns
 ## in @var{subs}.  An exception is if @var{subs} has only one column, in
-## which case @var{sz} may be the dimensions of a vector and the subscripts
-## of @var{subs} are taken as the indices into it.
+## which case @var{sz} may be the dimensions of a vector and the
+## subscripts of @var{subs} are taken as the indices into it.
 ##
 ## The default action of @code{accumarray} is to sum the elements with
 ## the same subscripts.  This behavior can be modified by defining the
 ## @var{func} function.  This should be a function or function handle
 ## that accepts a column vector and returns a scalar.  The result of the
 ## function should not depend on the order of the subscripts.
 ##
 ## The elements of the returned array that have no subscripts associated
@@ -58,19 +60,19 @@
 ## The following @code{accumarray} example constructs a frequency table
 ## that in the first column counts how many occurrences each number in
 ## the second column has, taken from the vector @var{x}.  Note the usage
 ## of @code{unique}  for assigning to all repeated elements of @var{x}
 ## the same index (@pxref{doc-unique}).
 ##
 ## @example
 ## @group
-## x = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
-## [u, ~, j] = unique (x);
-## [accumarray(j', 1), u']
+## @var{x} = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
+## [@var{u}, ~, @var{j}] = unique (@var{x});
+## [accumarray(@var{j}', 1), @var{u}']
 ## @result{} 2    89
 ##    3    90
 ##    2    91
 ##    2    92
 ##    3   100
 ## @end group
 ## @end example
 ##
@@ -84,55 +86,91 @@
 ##              2, 3, 2;
 ##              2, 1, 2;
 ##              2, 3, 2], 101:105)
 ## @result{} ans(:,:,1) = [101, 0, 0; 0, 0, 0]
 ##    ans(:,:,2) = [0, 0, 0; 206, 0, 208]
 ## @end group
 ## @end example
 ##
-## The complexity in the non-sparse case is generally O(M+N), where N is
-## the number of subscripts and M is the maximum subscript (linearized
-## in multi-dimensional case).  If @var{func} is one of @code{@@sum}
-## (default), @code{@@max}, @code{@@min} or @code{@@(x) @{x@}}, an
-## optimized code path is used.  Note that for general reduction function
-## the interpreter overhead can play a major part and it may be more
-## efficient to do multiple accumarray calls and compute the results in
-## a vectorized manner.
+## The sparse option can be used as an alternative to the @code{sparse}
+## constructor (@pxref{doc-sparse}). Thus
+##
+## @example
+## sparse (@var{i}, @var{j}, @var{sv})
+## @end example
+##
+## @noindent
+## can be written with @code{accumarray} as
+##
+## @example
+## accumarray ([@var{i}, @var{j}], @var{sv}', [], [], 0, true)
+## @end example
 ##
-## @seealso{accumdim, unique}
+## @noindent
+## For repeated indices, @code{sparse} adds the corresponding value. To
+## take the minimum instead, use @code{min} as an accumulator function:
+##
+## @example
+## accumarray ([@var{i}, @var{j}], @var{sv}', [], @@min, 0, true)
+## @end example
+##
+## The complexity of accumarray in general for the non-sparse case is
+## generally O(M+N), where N is the number of subscripts and M is the
+## maximum subscript (linearized in multi-dimensional case).  If
+## @var{func} is one of @code{@@sum} (default), @code{@@max},
+## @code{@@min} or @code{@@(x) @{x@}}, an optimized code path is used.
+## Note that for general reduction function the interpreter overhead can
+## play a major part and it may be more efficient to do multiple
+## accumarray calls and compute the results in a vectorized manner.
+##
+## @seealso{accumdim, unique, sparse}
 ## @end deftypefn
 
 function A = accumarray (subs, vals, sz = [], func = [], fillval = [], issparse = [])
 
   if (nargin < 2 || nargin > 6)
     print_usage ();
   endif
 
+  lenvals = length (vals);
+
   if (iscell (subs))
-    subs = cellfun ("vec", subs, "uniformoutput", false);
+    subs = cellfun (@vec, subs, "uniformoutput", false);
     ndims = numel (subs);
     if (ndims == 1)
       subs = subs{1};
     endif
+
+    lensubs = cellfun (@length, subs);
+
+    if (any (lensubs != lensubs(1)) || 
+        (lenvals > 1 && lenvals != lensubs(1)))
+      error ("accumarray: dimension mismatch");
+    endif
+
   else
     ndims = columns (subs);
+    if (lenvals > 1 && lenvals != rows (subs))
+      error ("accumarray: dimension mismatch")
+    endif
   endif
 
   if (isempty (fillval))
     fillval = 0;
   endif
 
   if (isempty (issparse))
     issparse = false;
   endif
 
   if (issparse)
 
-    ## Sparse case. Avoid linearizing the subscripts, because it could overflow.
+    ## Sparse case. Avoid linearizing the subscripts, because it could
+    ## overflow.
 
     if (fillval != 0)
       error ("accumarray: FILLVAL must be zero in the sparse case");
     endif
 
     ## Ensure subscripts are a two-column matrix.
     if (iscell (subs))
       subs = [subs{:}];
@@ -148,18 +186,18 @@ function A = accumarray (subs, vals, sz 
     if (isnumeric (vals) || islogical (vals))
       vals = double (vals);
     else
       error ("accumarray: in the sparse case, values must be numeric or logical");
     endif
 
     if (! (isempty (func) || func == @sum))
 
-      ## Reduce values. This is not needed if we're about to sum them, because
-      ## "sparse" can do that.
+      ## Reduce values. This is not needed if we're about to sum them,
+      ## because "sparse" can do that.
 
       ## Sort indices.
       [subs, idx] = sortrows (subs);
       n = rows (subs);
       ## Identify runs.
       jdx = find (any (diff (subs, 1, 1), 2));
       jdx = [jdx; n];
 
@@ -233,17 +271,18 @@ function A = accumarray (subs, vals, sz 
     elseif (func == @max)
       ## Fast maximization.
 
       if (isinteger (vals))
         zero = intmin (class (vals));
       elseif (islogical (vals))
         zero = false;
       elseif (fillval == 0 && all (vals(:) >= 0))
-        ## This is a common case - fillval is zero, all numbers nonegative.
+        ## This is a common case - fillval is zero, all numbers
+        ## nonegative.
         zero = 0;
       else
         zero = NaN; # Neutral value.
       endif
 
       if (isempty (sz))
         A = __accumarray_max__ (subs, vals, zero);
       else
@@ -259,17 +298,18 @@ function A = accumarray (subs, vals, sz 
     elseif (func == @min)
       ## Fast minimization.
 
       if (isinteger (vals))
         zero = intmax (class (vals));
       elseif (islogical (vals))
         zero = true;
       elseif (fillval == 0 && all (vals(:) <= 0))
-        ## This is a common case - fillval is zero, all numbers non-positive.
+        ## This is a common case - fillval is zero, all numbers
+        ## non-positive.
         zero = 0;
       else
         zero = NaN; # Neutral value.
       endif
 
       if (isempty (sz))
         A = __accumarray_min__ (subs, vals, zero);
       else
@@ -293,24 +333,31 @@ function A = accumarray (subs, vals, sz 
       endif
 
       ## Sort indices.
       [subs, idx] = sort (subs);
       ## Identify runs.
       jdx = find (subs(1:n-1) != subs(2:n));
       jdx = [jdx; n];
       vals = mat2cell (vals(idx), diff ([0; jdx]));
-      ## Optimize the case when function is @(x) {x}, i.e. we just want to
-      ## collect the values to cells.
+      ## Optimize the case when function is @(x) {x}, i.e. we just want
+      ## to collect the values to cells.
       persistent simple_cell_str = func2str (@(x) {x});
       if (! strcmp (func2str (func), simple_cell_str))
         vals = cellfun (func, vals);
       endif
       subs = subs(jdx);
 
+      if (isempty (sz))
+        sz = max (subs);
+        if (length (sz) == 1)
+          sz(2) = 1;
+        endif
+      endif
+
       ## Construct matrix of fillvals.
       if (iscell (vals))
         A = cell (sz);
       elseif (fillval == 0)
         A = zeros (sz, class (vals));
       else
         A = repmat (fillval, sz);
       endif
@@ -323,16 +370,17 @@ endfunction
 
 %!error (accumarray (1:5))
 %!error (accumarray ([1,2,3],1:2))
 %!assert (accumarray ([1;2;4;2;4],101:105), [101;206;0;208])
 %!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105),cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208]))
 %!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105,[],@(x)sin(sum(x))),sin(cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208])))
 %!assert (accumarray ({[1 3 3 2 3 1 2 2 3 3 1 2],[3 4 2 1 4 3 4 2 2 4 3 4],[1 1 2 2 1 1 2 1 1 1 2 2]},101:112),cat(3,[0,0,207,0;0,108,0,0;0,109,0,317],[0,0,111,0;104,0,0,219;0,103,0,0]))
 %!assert (accumarray ([1,1;2,1;2,3;2,1;2,3],101:105,[2,4],@max,NaN),[101,NaN,NaN,NaN;104,NaN,105,NaN])
+%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105, [], @prod), [101, 0, 0; 10608, 0, 10815])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2 4],@prod,0,true),sparse([1,2,2],[1,1,3],[101,10608,10815],2,4))
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],1,[2,4]), [1,0,0,0;2,0,2,0])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x)length(x)>1),[false,false,false,false;true,false,true,false])
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 0), [3; 4])
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 1), sparse ([3; 4]))
 %!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 0), [3, 4])
 %!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 1), sparse ([3, 4]))
 %!test
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -17,42 +17,47 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} accumdim (@var{subs}, @var{vals}, @var{dim}, @var{n}, @var{func}, @var{fillval})
 ## Create an array by accumulating the slices of an array into the
 ## positions defined by their subscripts along a specified dimension.
 ## The subscripts are defined by the index vector @var{subs}.
 ## The dimension is specified by @var{dim}.  If not given, it defaults
-## to the first non-singleton dimension.
+## to the first non-singleton dimension.  The length of @var{subs} must
+## be equal to @code{size (@var{vals}, @var{dim})}.
 ##
-## The extent of the result matrix in the working dimension will be determined
-## by the subscripts themselves.
-## However, if @var{n} is defined it determines this extent.
+## The extent of the result matrix in the working dimension will be
+## determined by the subscripts themselves.  However, if @var{n} is
+## defined it determines this extent.
 ##
 ## The default action of @code{accumdim} is to sum the subarrays with the
-## same subscripts.  This behavior can be modified by defining the @var{func}
-## function.  This should be a function or function handle that accepts an
-## array and a dimension, and reduces the array along this dimension.
-## As a special exception, the built-in @code{min} and @code{max} functions
-## can be used directly, and @code{accumdim} accounts for the middle empty
-## argument that is used in their calling.
+## same subscripts.  This behavior can be modified by defining the
+## @var{func} function.  This should be a function or function handle
+## that accepts an array and a dimension, and reduces the array along
+## this dimension.  As a special exception, the built-in @code{min} and
+## @code{max} functions can be used directly, and @code{accumdim}
+## accounts for the middle empty argument that is used in their calling.
 ##
-## The slices of the returned array that have no subscripts associated with
-## them are set to zero.  Defining @var{fillval} to some other value allows
-## these values to be defined.
+## The slices of the returned array that have no subscripts associated
+## with them are set to zero.  Defining @var{fillval} to some other
+## value allows these values to be defined.
 ##
 ## An example of the use of @code{accumdim} is:
 ##
-## @smallexample
+## @example
 ## @group
-## accumdim ([1, 2, 1, 2, 1], [7,-10,4;-5,-12,8;-12,2,8;-10,9,-3;-5,-3,-13])
+## accumdim ([1, 2, 1, 2, 1], [ 7, -10,   4;
+##                             -5, -12,   8;
+##                            -12,   2,   8;
+##                            -10,   9,  -3;
+##                             -5,  -3, -13])
 ## @result{} ans = [-10,-11,-1;-15,-3,5]
 ## @end group
-## @end smallexample
+## @end example
 ##
 ## @seealso{accumarray}
 ## @end deftypefn
 
 function A = accumdim (subs, vals, dim, n = 0, func = [], fillval = 0)
 
   if (nargin < 2 || nargin > 5)
     print_usage ();
@@ -63,17 +68,17 @@ function A = accumdim (subs, vals, dim, 
   endif
 
   if (! isvector (subs))
     error ("accumdim: SUBS must be a subscript vector");
   elseif (! isindex (subs)) # creates index cache
     error ("accumdim: indices must be positive integers");
   else
     m = max (subs);
-    if (n == 0)
+    if (n == 0 || isempty (n))
       n = m;
     elseif (n < m)
       error ("accumdim: N index out of range");
     endif
   endif
 
   sz = size (vals);
 
@@ -81,16 +86,20 @@ function A = accumdim (subs, vals, dim, 
     [~, dim] = max (sz != 1); # first non-singleton dim
   elseif (! isindex (dim))
     error ("accumdim: DIM must be a valid dimension");
   elseif (dim > length (sz))
     sz(end+1:dim) = 1;
   endif
   sz(dim) = n;
 
+  if (length (subs) != size (vals, dim))
+    error ("accumdim: dimension mismatch")
+  endif
+
   if (isempty (func) || func == @sum)
     ## Fast summation case.
     A = __accumdim_sum__ (subs, vals, dim, n);
 
     ## Fill in nonzero fill value
     if (fillval != 0)
       mask = true (n, 1);
       mask(subs) = false;
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -22,17 +22,17 @@
 ##
 ## Fourier interpolation.  If @var{x} is a vector, then @var{x} is
 ## resampled with @var{n} points.  The data in @var{x} is assumed to be
 ## equispaced.  If @var{x} is an array, then operate along each column of
 ## the array separately.  If @var{dim} is specified, then interpolate
 ## along the dimension @var{dim}.
 ##
 ## @code{interpft} assumes that the interpolated function is periodic,
-## and so assumptions are made about the end points of the interpolation.
+## and so assumptions are made about the endpoints of the interpolation.
 ##
 ## @seealso{interp1}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## 2001-02-11
 ##    * initial version
 ## 2002-03-17 aadler
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -1,9 +1,10 @@
 ## Copyright (C) 2009-2011 Eric Chassande-Mottin, CNRS (France)
+## Copyright (C) 2011 Philip Nienhuis
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -118,18 +119,20 @@
 ## (2) 2x1 cell string array: Everything between the left and right strings
 ## is skipped.
 ## @end itemize
 ##
 ## @item "delimiter"
 ## Any character in @var{value} will be used to split @var{str} into words
 ## (default value = any whitespace).
 ##
-## @item "emptyvalue"
-## Parts of the output where no word is available is filled with @var{value}.
+## @item "emptyvalue":
+## Value to return for empty numeric values in non-whitespace delimited data.
+## The default is NaN@.  When the data type does not support NaN
+## (int32 for example), then default is zero.
 ##
 ## @item "multipledelimsasone"
 ## Treat a series of consecutive delimiters, without whitespace in between,
 ## as a single delimiter.  Consecutive delimiter series need not be vertically
 ## "aligned".
 ##
 ## @item "treatasempty"
 ## Treat single occurrences (surrounded by delimiters or whitespace) of the
@@ -139,16 +142,18 @@
 ## If @var{value} true (1, default), ignore read errors and return normally.
 ## If false (0), return an error.
 ##
 ## @item "whitespace"
 ## Any character in @var{value} will be interpreted as whitespace and
 ## trimmed; the string defining whitespace must be enclosed in double
 ## quotes for proper processing of special characters like \t.
 ## The default value for whitespace = " \b\r\n\t" (note the space).
+## Unless whitespace is set to '' (empty) AND at least one "%s" format
+## conversion specifier is supplied, a space is always part of whitespace.
 ##
 ## @end table
 ##
 ## @seealso{textscan, textread, load, dlmread, fscanf}
 ## @end deftypefn
 
 function varargout = strread (str, format = "%f", varargin)
 
@@ -221,32 +226,32 @@ function varargout = strread (str, forma
               ## FIXME - a user may have numeric values specified: {'//', 7}
               ##         this will lead to an error in the warning message
               error ("strread: unknown or unrecognized comment style '%s'",
                       varargin{n+1});
             endif
         endswitch
       case "delimiter"
         delimiter_str = varargin{n+1};
-        if (is_sq_string (delimiter_str))
+        if (strcmp (typeinfo (delimiter_str), "sq_string"))
           delimiter_str = do_string_escapes (delimiter_str);
         endif
       case "emptyvalue"
         numeric_fill_value = varargin{n+1};
       case "expchars"
         warning ('strread: property "expchars" is not implemented');
       case "whitespace"
         white_spaces = varargin{n+1};
-        if (is_sq_string (white_spaces))
+        if (strcmp (typeinfo (white_spaces), "sq_string"))
           white_spaces = do_string_escapes (white_spaces);
         endif
       ## The following parameters are specific to textscan and textread
       case "endofline"
         eol_char = varargin{n+1};
-        if (is_sq_string (eol_char))
+        if (strcmp (typeinfo (eol_char), "sq_string"))
           eol_char = do_string_escapes (eol_char);
         endif
       case "returnonerror"
         err_action = varargin{n+1};
       case "multipledelimsasone"
         mult_dlms_s1 = varargin{n+1};
       case "treatasempty"
         if (iscellstr (varargin{n+1}))
@@ -324,52 +329,59 @@ function varargout = strread (str, forma
     endif
     len = length (str);
     c2len = length (comment_end);
     str = cellslices (str, [1, cstop + c2len], [cstart - 1, len]);
     str = [str{:}];
   endif
 
   if (! isempty (white_spaces))
-    ## Remove any delimiter chars from white_spaces list
-    white_spaces = setdiff (white_spaces, delimiter_str);
+    ## For numeric fields, whitespace is always a delimiter, but not for text fields
+    if (isempty (strfind (format, "%s")))
+      ## Add whitespace to delimiter set
+      delimiter_str = unique ([white_spaces delimiter_str]);
+    else
+      ## Remove any delimiter chars from white_spaces list
+      white_spaces = setdiff (white_spaces, delimiter_str);
+    endif
   endif
   if (isempty (delimiter_str))
     delimiter_str = " ";
   endif
   if (! isempty (eol_char))
     ## Add eol_char to delimiter collection
     delimiter_str = unique ([delimiter_str eol_char]);
     ## .. and remove it from whitespace collection
     white_spaces = strrep (white_spaces, eol_char, '');
   endif
 
   pad_out = 0;
   ## Trim whitespace if needed
-  ## FIXME: This is very complicated.  Can this be simplified with regexprep?
   if (! isempty (white_spaces))
     ## Check if trailing "\n" might signal padding output arrays to equal size
     ## before it is trimmed away below
     if ((str(end) == 10) && (nargout > 1))
       pad_out = 1;
     endif
-    ## Remove repeated white_space chars.  First find white_space positions
-    idx = strchr (str, white_spaces);
-    ## Find repeated white_spaces
-    idx2 = ! (idx(2:end) - idx(1:end-1) - 1);
-    ## Set all whitespace chars to spaces
-    ## FIXME: this implies real spaces are always part of white_spaces
-    str(idx) = ' ';
-    ## Set all repeated white_space to \0
-    str(idx(idx2)) = "\0";
-    str = strsplit (str, "\0");
-    ## Reconstruct trimmed str
-    str = cell2mat (str);
-    ## Remove leading & trailing space, but preserve delimiters.
-    str = strtrim (str);
+    ## Condense all repeated whitespace into one single space
+    ## FIXME: this will also fold repeated whitespace in a char field
+    rxp_wsp = sprintf ("[%s]+", white_spaces);
+    str = regexprep (str, rxp_wsp, ' ');
+    ## Remove possible leading space at string
+    if (str(1) == 32)
+       str = str(2:end);
+    endif
+    ## Check for single delimiter followed/preceded by whitespace
+    ## FIXME: Double strrep on str is enormously expensive of CPU time.
+    ## Can this be eliminated
+    if (! isempty (delimiter_str))
+      dlmstr = setdiff (delimiter_str, " ");
+      rxp_dlmwsp = sprintf ("( [%s]|[%s] )", dlmstr, dlmstr);
+      str = regexprep (str, rxp_dlmwsp, delimiter_str(1));
+    endif
     ## FIXME: Double strrep on str is enormously expensive of CPU time.
     ## Can this be eliminated
     ## Wipe leading and trailing whitespace on each line (it may be delimiter too)
     if (! isempty (eol_char))
       str = strrep (str, [eol_char " "], eol_char);
       str = strrep (str, [" " eol_char], eol_char);
     endif
   endif
@@ -389,35 +401,41 @@ function varargout = strread (str, forma
   ## Replace TreatAsEmpty char sequences by empty strings
   if (! isempty (empty_str))
     for ii = 1:numel (empty_str)
       idz = strmatch (empty_str{ii}, words, "exact");
       words(idz) = {""};
     endfor
   endif
 
-  ## We now may have to cope with 3 cases:
+  ## fmt_words has been split properly now, but words{} has only been split on
+  ## delimiter positions. 
+  ## As numeric fields can also be separated by whitespace, more splits may be
+  ## needed.
+  ## We also don't know the number of lines (as EndOfLine may have been set to
+  ## "" (empty) by the caller).
+  ##
+  ## We also may have to cope with 3 cases as far as literals go:
   ## A: Trailing literals (%f<literal>) w/o delimiter in between.
   ## B: Leading literals (<literal>%f) w/o delimiter in between.
   ## C. Skipping leftover parts of specified skip fields (%*N )
-  ## fmt_words has been split properly now, but words{} has only been split on
-  ## delimiter positions.  Some words columns may have to be split further.
-  ## We also don't know the number of lines (as EndOfLine may have been set to
-  ## "" (empty) by the caller).
+  ## Some words columns may have to be split further to fix these.
 
   ## Find indices and pointers to possible literals in fmt_words
   idf = cellfun ("isempty", strfind (fmt_words, "%"));
   ## Find indices and pointers to conversion specifiers with fixed width
   idg = ! cellfun ("isempty", regexp (fmt_words, '%\*?\d'));
   idy = find (idf | idg);
+  ## Find indices to numeric conversion specifiers
+  idn = ! cellfun ("isempty", regexp (fmt_words, "%[dnfu]"));
 
   ## If needed, split up columns in three steps:
   if (! isempty (idy))
     ## Try-catch because complexity of strings to read can be infinite
-    #try
+    try
 
       ## 1. Assess "period" in the split-up words array ( < num_words_per_line).
       ## Could be done using EndOfLine but that prohibits EndOfLine = "" option.
       ## Alternative below goes by simply parsing a first grab of words
       ## and counting words until the fmt_words array is exhausted:
       iwrd = 1; iwrdp = 0; iwrdl = length (words{iwrd});
       for ii = 1:numel (fmt_words)
 
@@ -429,33 +447,43 @@ function varargout = strread (str, forma
             if (ii < numel (fmt_words))
               iwrdl = length (words{iwrd});
             endif
           else
             ## Found it in current word.  Subtract literal length
             iwrdp += length (fmt_words{ii});
             if (iwrdp > iwrdl)
               ## Parse error.  Literal extends beyond delimiter (word boundary)
-              error ("strread: Literal '%s' (fmt spec # %d) does not match data", fmt_words{ii}, ii);
+              warning ("strread: literal '%s' (fmt spec # %d) does not match data", ...
+                fmt_words{ii}, ii);
+              ## Word assumed to be completely "used up". Next word
+              ++iwrd; iwrdp = 0;
+              if (ii < numel (fmt_words))
+                iwrdl = length (words{iwrd});
+              endif
             elseif (iwrdp == iwrdl)
               ## Word completely "used up". Next word
               ++iwrd; iwrdp = 0;
               if (ii < numel (fmt_words))
                 iwrdl = length (words{iwrd});
               endif
             endif
           endif
 
         elseif (idg(ii))
           ## Fixed width specifier (%N or %*N): read just a part of word
             iwrdp += floor ...
              (str2double (fmt_words{ii}(regexp(fmt_words{ii}, '\d') : end-1)));
             if (iwrdp > iwrdl)
-              ## Error. Field extends beyond word boundary.
-              error ("strread: Field width '%s' (fmt spec # %d) extends beyond word limit", fmt_words{ii}, ii);
+              ## Match error. Field extends beyond word boundary.
+              warning  ...
+              ("strread: field width '%s' (fmt spec # %d) extends beyond actual word limit", ...
+                 fmt_words{ii}, ii);
+              ## Assume word to be completely "used up".  Next word
+              ++iwrd; iwrdp = 0; iwrdl = length (words{iwrd});
             elseif (iwrdp == iwrdl)
               ## Word completely "used up".  Next word
               ++iwrd; iwrdp = 0; iwrdl = length (words{iwrd});
             endif
 
         else
           ## A simple format conv. specifier. Either (1) uses rest of word, or
           ## (2) is squeezed between current iwrdp and next literal, or (3) uses
@@ -551,34 +579,36 @@ function varargout = strread (str, forma
                 ## Former trailing literal may now be leading for next specifier
                 --ii;
               endif
             endif
           endif
 
         else
           ## Conv. specifier.  Peek if next fmt_word needs split from current column
-          if (ii < num_words_per_line && idf(ii+1))
-            if (! isempty (strfind (words{icol, 1}, fmt_words{ii+1})))
+          if (ii < num_words_per_line)
+            if (idf(ii+1) && (! isempty (strfind (words{icol, 1}, fmt_words{ii+1}))))
+              --icol;
+            elseif (idg(ii+1))
               --icol;
             endif
           endif
         endif
         ## Next fmt_word, next column
         ++ii; ++icol;
       endwhile
 
       ## Done.  Reshape words back into 1 long vector and strip padded empty words
       words = reshape (words, 1, numel (words))(1 : end-num_words_padded);
 
-    #catch
-    #  warning ("strread: unable to parse text or file with given format string");
-    #  return;
+    catch
+      warning ("strread: unable to parse text or file with given format string");
+      return;
 
-    #end_try_catch
+    end_try_catch
   endif
 
   ## For each specifier, process corresponding column
   k = 1;
   for m = 1:num_words_per_line
     try
       if (format_repeat_count < 0)
         data = words(m:num_words_per_line:end);
@@ -673,25 +703,29 @@ endfunction
 
 function out = split_by (text, sep, mult_dlms_s1, eol_char)
 
   ## Check & if needed, process MultipleDelimsAsOne parameter
   if (mult_dlms_s1)
     mult_dlms_s1 = true;
     ## FIXME: Should re-implement strsplit() function here in order
     ## to avoid strrep on megabytes of data.
-    ## If \n is in sep collection we need to enclose it in spaces in text
+    ## If \n is in sep collection we need to enclose it in text
     ## to avoid it being included in consecutive delim series
-    text = strrep (text, eol_char, [" " eol_char " "]);
+    enchr = ' ';
+    ## However watch out if eol_char is also in delimiters
+    if (index (sep, eol_char)); enchr = char(255); endif
+    text = strrep (text, eol_char, [enchr eol_char enchr]);
   else
     mult_dlms_s1 = false;
   endif
 
   ## Split text string along delimiters
   out = strsplit (text, sep, mult_dlms_s1);
+  if (index (sep, eol_char)); out = strrep (out, char(255), ''); endif
   ## In case of trailing delimiter, strip stray last empty word
   if (!isempty (out) && any (sep == text(end)))
     out(end) = [];
   endif
 
   ## Empty cells converted to empty cellstrings.
   out(cellfun ("isempty", out)) = {""};
 
@@ -790,29 +824,67 @@ endfunction
 %! # TreatAsEmpty
 %! [a, b, c, d] = strread ("1,2,3,NN,5,6\n", "%d%d%d%f", 'delimiter', ',', 'TreatAsEmpty', 'NN');
 %! assert (c, int32 ([3; 0]));
 %! assert (d, [NaN; NaN]);
 
 %!test
 %! # No delimiters at all besides EOL.  Plain reading numbers & strings
 %! str = "Text1Text2Text\nText398Text4Text\nText57Text";
-%! c = textscan (str, "Text%dText%1sText");
-%! assert (c{1}, int32 ([1; 398; 57]));
-%! assert (c{2}(1:2), {'2'; '4'});
-%! assert (isempty (c{2}{3}), true);
+%! [a, b] = strread (str, "Text%dText%1sText");
+%! assert (a, int32 ([1; 398; 57]));
+%! assert (b(1:2), {'2'; '4'});
+%! assert (isempty (b{3}), true);
 
 %% MultipleDelimsAsOne
 %!test
 %! str = "11, 12, 13,, 15\n21,, 23, 24, 25\n,, 33, 34, 35";
 %! [a b c d] = strread (str, "%f %f %f %f", 'delimiter', ',', 'multipledelimsasone', 1, 'endofline', "\n");
 %! assert (a', [11, 21, NaN]);
 %! assert (b', [12, 23, 33]);
 %! assert (c', [13, 24, 34]);
 %! assert (d', [15, 25, 35]);
 
 %% delimiter as sq_string and dq_string
+%!test
 %! assert (strread ("1\n2\n3", "%d", "delimiter", "\n"),
 %!         strread ("1\n2\n3", "%d", "delimiter", '\n'))
 
 %% whitespace as sq_string and dq_string
+%!test
 %! assert (strread ("1\b2\r3\b4\t5", "%d", "whitespace", "\b\r\n\t"),
 %!         strread ("1\b2\r3\b4\t5", "%d", "whitespace", '\b\r\n\t'))
+
+%!test
+%! str =  "0.31 0.86 0.94\n 0.60 0.72 0.87";
+%! fmt = "%f %f %f";
+%! args = {"delimiter", " ", "endofline", "\n", "whitespace", " "};
+%! [a, b, c] = strread (str, fmt, args {:});
+%! assert (a, [0.31; 0.60], 0.01)
+%! assert (b, [0.86; 0.72], 0.01)
+%! assert (c, [0.94; 0.87], 0.01)
+
+%!test
+%! str =  "0.31,0.86,0.94\n0.60,0.72,0.87";
+%! fmt = "%f %f %f";
+%! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
+%! [a, b, c] = strread (str, fmt, args {:});
+%! assert (a, [0.31; 0.60], 0.01)
+%! assert (b, [0.86; 0.72], 0.01)
+%! assert (c, [0.94; 0.87], 0.01)
+
+%!test
+%! str =  "0.31 0.86 0.94\n 0.60 0.72 0.87";
+%! fmt = "%f %f %f";
+%! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
+%! [a, b, c] = strread (str, fmt, args {:});
+%! assert (a, [0.31; 0.60], 0.01)
+%! assert (b, [0.86; 0.72], 0.01)
+%! assert (c, [0.94; 0.87], 0.01)
+
+%!test
+%! str =  "0.31, 0.86, 0.94\n 0.60, 0.72, 0.87";
+%! fmt = "%f %f %f";
+%! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
+%! [a, b, c] = strread (str, fmt, args {:});
+%! assert (a, [0.31; 0.60], 0.01)
+%! assert (b, [0.86; 0.72], 0.01)
+%! assert (c, [0.94; 0.87], 0.01)
diff --git a/scripts/miscellaneous/fact.m b/scripts/miscellaneous/fact.m
new file mode 100644
--- /dev/null
+++ b/scripts/miscellaneous/fact.m
@@ -0,0 +1,269 @@
+## Copyright (C) 2007-2011 Jordi Gutiérrez Hermoso 
+## Copyright (C) 2007 Stallmanfacts.com
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Command} {} fact
+## @deftypefnx {Function File} {T =} fact()
+## Display an amazing and random fact about the world's greatest hacker.
+## @end deftypefn
+
+
+function f = fact()
+  persistent wisdom = \
+      {
+       "Richard Stallman takes notes in binary.";
+       "Richard Stallman doesn't need sudo. I will make him a sandwich anyway.";
+       "Richard Stallman is my shephurd, and I am his GNU.";
+       "Richard Stallman doesn't wget, Richard Stallman wdemands!";
+       "Richard Stallman can touch MC Hammer";
+       "Richard Stallman doesn't read web pages. They write to him.";
+       "Richard Stallman gets 9 bits to the byte.";
+       "Richard Stallman doesn't really believe in open software, because it's not free enough.";
+       "Richard Stallman can leave neutral or negative feedback on eBay.";
+       "Richard Stallman is the only man alive who can pronounce GNU the way it is meant to be pronounced.";
+       "Richard Stallman does not own a mobile phone because he can fashion a crude convex dish and shout into it at the exact resonant frequency of the ozone, causing a voice to seemingly come from the sky above his intended recipient.";
+       "Richard Stallman is so handsome that when he was young he was responsible for all other geeks not being able to get girls. This is why he has to cover his face with a thick layer of hair.";
+       "Some people check their computers for viruses. Viruses check their computers for Richard Stallman.";
+       "Richard Stallman memorises all his documents. In binary. He just types everything in whenever he needs a document.";
+       "When Richard Stallman makes a sudo command, he loses permissions.";
+       "Richard Stallman's beard is made of parentheses.";
+       "Richard Stallman's DNA is in binary.";
+       "Richard Stallman's nervous system is completely wireless.";
+       "Richard Stallman's brain accepts UNIX commands.";
+       "If Richard Stallman has 1GB of RAM, and if you have 1GB of RAM, Richard Stallman has more RAM than you.";
+       "Richard Stallman eats ethernet cables. That's why they invented wireless.";
+       "Richard Stallman has a katana. 'Nuff said.";
+       "Richard Stallman wrote a program that divides by zero.";
+       "Ricahrd Stallman doesn't use zip drives, he just squeezes the hard drive.";
+       "Richard Stallman's compiler is afraid to report errors.";
+       "Richard Stallman wrote the compiler God used. The Big Bang was the Universe's first segfault.";
+       "Richard Stallman successfully compiled a kernel of popcorn.";
+       "Richard Stallman doesn't write programs, they write themselves out of reverence.";
+       "Richard Stallman can make infinite loops end.";
+       "Richard Stallman's anti-virus programs cures HIV.";
+       "Richard Stallman's computer doesn't have a clock; it defines what time it is.";
+       "Richard Stallman wrote a program to compute the last digit of pi.";
+       "Richard Stallman doesn't use web browsers. He sends a link to a demon that uses wget to fetch the page and sends it back to him.";
+       "Richard Stallman can solve the halting problem... in polynomial time.";
+       "For Richard Stallman, polynomial time is O(1).";
+       "Richard Stallman didn't \"write\" Emacs or created it in his own image. Richard Stallman made Emacs an instance of himself.";
+       "Richard Stallman can coerce meaningful data from /dev/null.";
+       "Some people wear Linus Torvalds pyjamas to bed, Linus Torvalds wears Richard Stallman pyjamas.";
+       "There is no software development process, only a bunch of programs Richard Stallman allows to exist. ";
+       "Richard Stallman spends his leisure time programming with Guile on GNU Hurd. ";
+       "Richard Stallman's left and right hands are named \"(\" and \")\" ";
+       "Richard Stallman first words were actually syscalls. ";
+       "Richard Stallman didn't create the singularity. He is the singularity. GNU/Linux is only the event horizon. ";
+       "When Richard Stallman pipes to more, he gets less ";
+       "Richard Stallman never showers: he runs 'make clean'. ";
+       "Richard Stallman needs neither mouse nor keyboard to operate his computer. He just stares it down until it does what he wants. ";
+       "Richard Stallman didn't write the GPL. He is the GPL. ";
+       "Richad Stallman's pinky finger is really a USB memory stick. ";
+       "Richard Stallman called his operating system GNU because he created it before computers existed, when actual gnus were used for calcuations. ";
+       "In Soviet Russia, Richard Stallman is still Richard Stallman! ";
+       "Richard Stallman's flute only plays free music. ";
+       "When Richard Stallman uses floats, there are no rounding errors.";
+       "Richard Stallman wrote a program so powerful, it knows the question to 42.";
+       "Richard Stallman released his own DNA under GNU FDL.";
+       "Richard Stallman knows the entire wikipedia by heart, markup included.";
+       "Richard Stallman wrote the HAL9000 OS.";
+       "Richard Stallman's laser pointer is a lightsaber.";
+       "Richard Stallman never steps down; he shifts the universe up .";
+       "Richard Stallman doesn't maintain code; he stares at it until it fixes itself out of reverence.";
+       "Richard Stallman doesn't use an editor; he sets the fundamental constants of the universe so that a magnetic platter with his code on it evolves itself.";
+       "Richard Stallman doesn’t code; he dares the computer to not do his bidding.";
+       "Global warming is caused by Richard Stallman’s rage toward non-free software.";
+       "Rather than being birthed like a normal child, Richard Stallman instead instantiated himself polymorphically. Shortly thereafter he grew a beard.";
+       "Richard Stallman discovered extra-terrestrial life but killed them because they used non-free software.";
+       "Richard Stallman doesn't evaluate expressions, expressions evaluate to Richard Stallman.";
+       "Richard Stallman can see Russia from his house.";
+       "Richard Stallman proved P=NP, twice!";
+       "Richard Stallman knows of an unfixed bug in TeX.";
+       "Richard Stallman can write a context-free grammar for C.";
+       "Richard Stallman can determine whether an arbitrary program will terminate.";
+       "Richard Stallman's computer has only two buttons. One is for guests.";
+       "Richard Stallman does not actually write programs. He comes up with a length and digit index in pi.";
+       "Richard Stallman's distributed version control system is a flamewar on Usenet.";
+       "Richard Stallman wrote the first version of Emacs on a typewriter.";
+       "Richard Stallman has no known weaknesses, except for a phobia against soap.";
+       "Richard Stallman is not affected by Godwin's Law.";
+       "Richard Stallman can write an anti-virus program that cures HIV. Too bad he never writes anti-virus programs.";
+       "Richard Stallman' facial hair is \"free as in beard\"";
+       "Richard Stallman is licensed under GPL, so you can clone him and redistribute copies so you can help your neighbor. For example a version that take a bath more often.";
+       "Richard Stallman doesn't code; he just travels around the world.";
+       "Richard Stallman was coded by himself in lisp with Emacs.";
+       "Richard Stallman doesn't eat McDonald's because the machine that kills the cows uses proprietary software.";
+       "There is no chin behind Richard Stallman's legendary beard, there is only another Emacs.";
+       "In an average living room there are 1,242 objects Richard Stallman could use to write an OS, including the room itself.";
+       "Vendor lock-in is when vendors lock themselves inside of a building out of fear of Richard Stallman's wrath.";
+       "When Richard Stallman executes ps -e, you show up.";
+       "When Richard Stallman gets angry he doesn't swear; he recurses.";
+       "On Richard Stallman's computer the bootloader is contained in his .emacs.";
+       "Richard Satallman can make any operating system free, free from drivers.";
+       "Richard Stallman programmed Chuck Norris.";
+       "Behind Richard Stallman's beard there is another fist, to code faster.";
+       "Richard Stallman won a Suduku that started with only one number in each line";
+       "Richard Stallman's brain compiles and runs C code.";
+       "Richard Stallman wrote the first version of Emacs using Emacs.";
+       "Richard Stallman never gonna give you up, never gonna let you down, never gonna run around and desert you, never gonna make you cry, never gonna say goodbye, never gonna tell a lie and hurt you.";
+       "Richard Stallman, upon reading these facts, didn't laugh at all. Instead, he complained that he is being linked to that dirty \"open source\" software. He also asked it to be changed to \"free software\", in order to raise awareness for software freedom in our society.";
+       "Richard Stallman has no problem using Emacs. He wrote it with his 4 hands.";
+       "Richard Stallman will revert the big rip by adding parenthesis to the dark matter.";
+       "When you make a Google search and it doesn't find the answer, Google gently consults Richard Stallman.";
+       "Richard Stallman's uptime is over 53 years. And counting up.";
+       "Richard Stallman's portable music player plays ogg and WMA.";
+       "Richard Stallman will never die, but may some day go to /dev/null.";
+       "Richard Stallman once got swine flu, but it got cleansed by hereditay GPL and thus got assimilated.";
+       "Richard Stallman don't cut his hair because there are no GNU/Scissors";
+       "Richard Stallman is the one who trims Chuck Norris beard. And he does it freely, of course.";
+       "Richard Stallman does not take bath, for the hydroelectric company uses proprietary software.";
+       "Agent Smith loves Richard Stallman's scent.";
+       "Richard Stallman is the One.";
+       "\"They can take our lives, but they can never take our freedom.\" Willian Wallace after a litle talk with Richard Stallman.";
+       "Richard Stallman can connect to any brain using an Emacs ssh client.";
+       "Richard Stallman ported Emacs to Intel 4004 chip.";
+       "Richard Stallman did not write GNU Emacs, he simply read the source code from /dev/null.";
+       "Richard Stallman once used GDB to reverse-engineer Windows 7 into a free operating system - able to run on GNU Emacs!";
+       "Richard Stallman does not contribute to open source projects; open source projects contribute to Richard Stallman, and then call themselves free software projects.";
+       "Richard Stallman programmed himself before he could even exist";
+       "Richard Stallman can fill up /dev/null.";
+       "Richard Stallman is so zealous about privacy he has /dev/null as his home.";
+       "When Richard Stallman runs /bin/false, it returns \"true\".";
+       "Richard Stallman doesn't like money, because banks don't run on free software.";
+       "Richard Stallman user GNU tar to compress air.";
+       "Richard Stallman was installed in the world, it runs on a free program ..";
+       "When Richard Stallman reports a bug, the bug prefers to squash itself instead of facing Richard Stallman's wrath.";
+       "There is no Windows in Richard Stallman's house... only Doors...";
+       "Richard Stallman doesn't like neither PCs-Intel nor Burger King... He prefers e-Macs...";
+       "Richard Stallman can use grep to find Jimmy Hoffa.";
+       "Richard Stallman made it possible to not absolutely abhor HPUX.";
+       "When Richard Stallman pours his alphabets cereal into a bowl, only G's, N's, and U's come out.";
+       "Richard Stallman is pronounced \"GNU slash Stallman\"";
+       "Richard Stallman doesn't mind if you read his mail as long as you don't delete it before he reads it.";
+       "Richard Stallman is just a guy who has strong principles and decided to follow them.";
+       "Richard Stallman knows that you don't have class because it is a keyword that he defined.";
+       "Richard Stallman doesn't need a qwerty/dvorak keyboard only two buttons \"1\" and \"0\" and his erect penis.";
+       "On the first day Richard Stallman said M-x create-light.";
+       "Richard Stallman once went out of scope for a while. The garbage collector never dared to touch him.";
+       "Richard Stallman does not compile; he closes his eyes, and see energy lines created between bit blocks by the compiler optimizations...";
+       "intx80 first calls Richard Stallman before calling sys_call";
+       "Tron is actually a biographical story about Richard Stallman. The director decided to tone it down or audiences wouldn't find it believable.";
+       "Richard Stallman always wears a red shirt to make sure that whatever attacks his away-team has to go through him first.";
+       "kill -9 invokes Richard Stallman's rage against a process.";
+       "If Richard were to stumble upon stallmanfacts.com, he would find it a gnuisance.";
+       "Richard Stallman can telnet into Mordor.";
+       "sudo chown Richard:Stallman /all/your/base";
+       "Richard Stallman's nervous system is completely wireless.";
+       "Richard Stallman does not sleep. He yields.";
+       "Some people say M-x psychoanalyse-pinhead is a merely a program. Others say M-x psychoanalyse-pinhead *is* Richard Stallman. All I know is, Richard Stallman is The Stig.";
+       "If you execute Emacs backward it either undoes the industrial revolution or induces the rapture. But only Richard Stallman knows which.";
+       "If Richard Stallman's beard were ever trimmed, the clippings would re-marshal into an exact copy of Richard Stallman.";
+       "Richard Stallman never sleeps because he altered his own source to gain background garbage collection.";
+       "Richard Stallman's doctor can retrieve a blood sample via CVS.";
+       "Richard Stallman can touch this";
+       "Because Richard Stallman's DNA is licensed under the FDL, his doctor can't draw his blood without violating HIPAA.";
+       "Richard Stallman can remove his own appendix, using only gdb.";
+       "Richard Stallman's DNA includes debugging symbols. But he doesn't need them.";
+       "Richard Stallman met Chuck Norris once. Chuck tried a roundhouse, but Richard bashed him in the skull.";
+       "Richard Stallman doesn't need to buy a bigger hard drive. He can compress data infinitely. ";
+       "When Richard Stallman cannot take your call, his beard answers the phone for you.";
+       "The R in RMS stands for RMS.";
+       "Richard Stallman can parse HTML with regular expressions.";
+       "Richard Stallman's traceroute goes all the way through an infinite number of anonymous proxies back to the traffic's source.";
+       "Richard Stallman's beard is in fact not a just a beard, but a microprinted hard copy of Emacs source code. New patches must be checked against new hair growth before being approved.";
+       "In the beginning-of-buffer there was Richard Stallman.";
+       "The NOOP was created to give Richard Stallman some time to comb his beard.";
+       "Whenever Richard Stallman looks at a Windows computer, it segfaults. Whenever Richard Stallman doesn't look at a Windows computer, it segfaults.";
+       "Richard Stallman can walk on Windows!";
+       "After being unable to satisfy my wife for years, Richard Stallman was able to single-handedly unlock her orgasm within seconds and managed to write a texinfo manual minutes later for other users.";
+       "Richard Stallman's tabbed browser is a set to wget/telnet fg/bg processes.";
+       "There is no chin under Richard Stallman' beard. There's only another beard. Recursively.";
+       "Stallman can chown anything! stallman@stallman~$ chown stallman:stallman Earth (for example)";
+       "Richard Stallman freed his beard so he can always check what's in it.";
+       "In the beginning was the Word, and the Word was with RMS, and the Word was GNU.";
+       "RMS means \"RMS means Stallman\"";
+       "Richard Stallman is the babelfish of his own speeches.";
+       "Richard Stallman wrote his own library and lives in it.";
+       "Richard Stallman found Waldo using grep in /dev/null";
+       "Richard Stallman doesn't sleep; he is compiling";
+       "Richard Stallman will get Coca Cola to release their recipe under the GPL.";
+       "Richard Stallman doesn't change clothes. He makes case mods.";
+       "Richard Stallman compiled the first version of gcc with an hexadecimal editor.";
+       "Richard Stallman will be the last guest on Linux Outlaws";
+       "Richard Stallman calculates the universe's entropy by exploiting forced stack overflows.";
+       "Richard Stallman's consciousness will one day become the singularity, which will create Deep Thought, and answer the meaning of life, the universe and everything.";
+       "C is actually written in RMS.";
+       "Richard Stallman can write software that does not have a buffer overflow when counting money lost by Jerome Kerviel.";
+       "There were no double rainbows before Richard Stallman.";
+       "Chuck Norris had to shorten his beard in the presence of Stallman because two beards that awsome, so close would segfault the universe (again).";
+       "RMS is Titanic.";
+       "Richard Stallman is the answer to the Turing Test.";
+       "Richard Stallman's beard makes ads for Gillette and Braun appear.";
+       "for i = 1 to Stallman will never stop.";
+       "\"RMS\" stands for \"RMS Makes Software\"";
+       "Whenever someone writes a \"Hello, world\" program, Richard Stallman says \"Hello\" back.";
+       "Richard Stallman wasn't born. He was compiled from source.";
+       "Richard Stallman has a URL tatooed on the left side of his chest where you can download his genetic code.";
+       "The GNU command line idiom that Richard Stallman never needs: \"date | more\"";
+       "Richard Stallman's toe cheese is aged to perfection.";
+       "Richard Stallman doesn't always run an OS kernel, but when he does he prefers GNU/Hurd. He is... the most interesting hacker in the world. Stay free, my friends.";
+       "When Richard Stallman gets hungry, he just picks debris from his foot and eats it.";
+       "Richard Stallman can GPL your code just by looking at it funny.";
+       "Richard Mathew Stallman loves birds. Birds make auricular love to Richard Mathew Stallman.";
+       "Richard Stallman is so free that the primitive recursive function for computing his liberty causes a stack overflow.";
+       "GNU Hurd is taking more than twenty years to develop because Richard Stallman is using a programming language comprised entirely of different lengths of time.";
+       "Richard Stallman's beard contains Richard Stallman, whose beard contains Richard Stallman....";
+       "Richard Stallman had a Google Plus account in 2010.";
+       "sudo chown rms:gnu ~/base -R";
+       "Richard Stallman pipes the Emacs binaries to /dev/dsp before he goes to sleep.";
+       "When Richard Stallman counted his fingers as a kid, he always started with 0.";
+       "When Richard Stallman's computer gets a virus, he simply applies a GPL license to it which converts the whole botnet to Linux. I mean, GNU/Linux.";
+       "Richard Stallman's beard trimmings can cure cancer. Too bad he never shaves.";
+       "Richard Stallman's doesn't kill a process, he just dares it to stay running.";
+       "Richard Stallman exists because he compiled himself into being. ";
+       "Richard Stallman's first words were in binary. When they couldn't understand him, he wrote a parser.";
+       "Richard Stallman doesn't need any codecs, he just opens a multimedia file with Emacs, and reads the bytes of the file as plain text. He then performs all the necessary decoding in his mind. But he refuses to decode files encrypted with DRM, although his mind is able to.";
+       };
+
+  w = wisdom{randi([1, numel(wisdom)])};
+  if nargout > 0
+    f = w;
+  else
+    w = wordwrap (w);
+    printf ("%s", w);
+  endif
+endfunction
+
+function out = wordwrap (w)
+  cols = terminal_size ()(2);
+  wc = strsplit (w, " ");
+  out = "\n";
+  i = 1;
+  numwords = numel (wc);
+  while i <= numwords;
+    line = wc{i};
+    while (i < numwords && length (newline = cstrcat (line, " ", wc{i+1})) < cols)
+      line = newline;
+      i++;
+    endwhile
+    out = cstrcat (out, line, "\n");
+    i++;
+  endwhile
+  out = cstrcat(out, "\n");
+endfunction
\ No newline at end of file
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -13,24 +13,27 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Command} {} mkoctfile [-options] file @dots{}
+## @deftypefnx {Function File} {[@var{output}, @var{status} =} mkoctfile (@dots{})
 ##
 ## The @code{mkoctfile} function compiles source code written in C,
 ## C++, or Fortran.  Depending on the options used with @code{mkoctfile}, the
 ## compiled code can be called within Octave or can be used as a stand-alone
 ## application.
 ##
 ## @code{mkoctfile} can be called from the shell prompt or from the Octave
-## prompt.
+## prompt.  Calling it from the Octave prompt simply delegates the
+## call to the shell prompt.  The output is stored in the @var{output}
+## variable and the exit status in the @var{status} variable.
 ##
 ## @code{mkoctfile} accepts the following options, all of which are optional
 ## except for the file name of the code you wish to compile:
 ##
 ## @table @samp
 ## @item -I DIR
 ## Add the include directory DIR to compile commands.
 ##
@@ -132,29 +135,35 @@
 ##                   .o    object file
 ##                   .a    library file
 ## @end group
 ## @end example
 ##
 ## @end table
 ## @end deftypefn
 
-function mkoctfile (varargin)
+function [output, status] = mkoctfile (varargin)
 
   bindir = octave_config_info ("bindir");
 
   shell_script = fullfile (bindir, sprintf ("mkoctfile-%s", OCTAVE_VERSION));
 
   cmd = cstrcat ("\"", shell_script, "\"");
   for i = 1:nargin
     cmd = cstrcat (cmd, " \"", varargin{i}, "\"");
   endfor
 
-  status = system (cmd);
+  [sys, out] = system (cmd);
 
-  if (status == 127)
+  if (nargout > 0)
+    [output, status] = deal (out, sys);
+  else
+    printf ("%s", out);
+  endif
+
+  if (sys == 127)
     warning ("unable to find mkoctfile in expected location: `%s'",
              shell_script);
 
     warning ("mkoctfile exited with failure status");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/module.mk b/scripts/miscellaneous/module.mk
--- a/scripts/miscellaneous/module.mk
+++ b/scripts/miscellaneous/module.mk
@@ -15,16 +15,17 @@ miscellaneous_FCN_FILES = \
   miscellaneous/computer.m \
   miscellaneous/copyfile.m \
   miscellaneous/debug.m \
   miscellaneous/delete.m \
   miscellaneous/dir.m \
   miscellaneous/dos.m \
   miscellaneous/dump_prefs.m \
   miscellaneous/edit.m \
+	miscellaneous/fact.m \
   miscellaneous/fileattrib.m \
   miscellaneous/fileparts.m \
   miscellaneous/fullfile.m \
   miscellaneous/getappdata.m \
   miscellaneous/getfield.m \
   miscellaneous/gunzip.m \
   miscellaneous/gzip.m \
   miscellaneous/info.m \
@@ -62,16 +63,17 @@ miscellaneous_FCN_FILES = \
   miscellaneous/symvar.m \
   miscellaneous/tar.m \
   miscellaneous/tempdir.m \
   miscellaneous/tempname.m \
   miscellaneous/unix.m \
   miscellaneous/unpack.m \
   miscellaneous/untar.m \
   miscellaneous/unzip.m \
+  miscellaneous/usejava.m \
   miscellaneous/ver.m \
   miscellaneous/version.m \
   miscellaneous/warning_ids.m \
   miscellaneous/what.m \
   miscellaneous/xor.m \
   miscellaneous/zip.m \
   $(miscellaneous_PRIVATE_FCN_FILES)
 
diff --git a/scripts/miscellaneous/parseparams.m b/scripts/miscellaneous/parseparams.m
--- a/scripts/miscellaneous/parseparams.m
+++ b/scripts/miscellaneous/parseparams.m
@@ -43,17 +43,17 @@
 ## The parseparams function may be used to separate 'regular'
 ## arguments and additional arguments given as property/value pairs of
 ## the @var{varargin} cell array.
 ##
 ## In the second form of the call, available options are specified directly
 ## with their default values given as name-value pairs.
 ## If @var{params} do not form name-value pairs, or if an option occurs
 ## that does not match any of the available options, an error occurs.
-## When called from a m-file function, the error is prefixed with the
+## When called from an m-file function, the error is prefixed with the
 ## name of the caller function.
 ## The matching of options is case-insensitive.
 ##
 ## @seealso{varargin}
 ## @end deftypefn
 
 ## Author: Alexander Barth <abarth93@users.sourceforge.net>
 ## Author: Aida Alvera Azcarate <aida@netecho.info>
diff --git a/scripts/miscellaneous/usejava.m b/scripts/miscellaneous/usejava.m
--- a/scripts/miscellaneous/usejava.m
+++ b/scripts/miscellaneous/usejava.m
@@ -31,17 +31,17 @@
 ##
 ## @item "jvm"
 ## Java Virtual Machine.
 ##
 ## @item "swing"
 ## Swing components for lightweight GUIs.
 ## @end table
 ##
-## This function is provided for compatability with @sc{matlab} scripts which
+## This function is provided for compatibility with @sc{matlab} scripts which
 ## may alter their behavior based on the availability of Java.  Octave does
 ## not implement an interface to Java and this function always returns
 ## @code{false}.
 ## @end deftypefn
 
 function retval = usejava (feature)
 
   if (nargin != 1 || ! ischar (feature))
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
+## @cindex warning ids
 ## @table @code
 ## @item Octave:abbreviated-property-match
 ## By default, the @code{Octave:abbreviated-property-match} warning is enabled.
 ##
 ## @item Octave:array-to-scalar
 ## If the @code{Octave:array-to-scalar} warning is enabled, Octave will
 ## warn when an implicit conversion from an array to a scalar value is
 ## attempted.
@@ -115,16 +116,21 @@
 ## @item Octave:autoload-relative-file-name
 ## If the @code{Octave:autoload-relative-file-name} is enabled,
 ## Octave will warn when parsing autoload() function calls with relative
 ## paths to function files.  This usually happens when using autoload()
 ## calls in PKG_ADD files, when the PKG_ADD file is not in the same
 ## directory as the .oct file referred to by the autoload() command.
 ## By default, the @code{Octave:autoload-relative-file-name} warning is enabled.
 ##
+## @item Octave:broadcast
+## Warn when performing broadcasting operations.  By default, this is
+## enabled.  See @ref{Broadcasting} in the chapter Vectorization and Faster
+## Code Execution of the manual.
+##
 ## @item Octave:built-in-variable-assignment
 ## By default, the @code{Octave:built-in-variable-assignment} warning is
 ## enabled.
 ##
 ## @item Octave:divide-by-zero
 ## If the @code{Octave:divide-by-zero} warning is enabled, a
 ## warning is issued when Octave encounters a division by zero.
 ## By default, the @code{Octave:divide-by-zero} warning is enabled.
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -501,52 +501,57 @@ endfunction
 %! title ("ylim = [1, 10]")
 
 %!demo
 %! clf
 %! loglog (1:20, "-s")
 %! axis tight
 
 %!demo
+%! clf
 %! x = -10:0.1:10;
 %! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
 %! plot (x, y)
 %! title ("no plot box")
 %! set (gca, "xaxislocation", "zero")
 %! set (gca, "yaxislocation", "zero")
 %! box off
 
 %!demo
+%! clf
 %! x = -10:0.1:10;
 %! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
 %! plot (x, y)
 %! title ("no plot box")
 %! set (gca, "xaxislocation", "zero")
 %! set (gca, "yaxislocation", "left")
 %! box off
 
 %!demo
+%! clf
 %! x = -10:0.1:10;
 %! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
 %! plot (x, y)
 %! title ("no plot box")
 %! set (gca, "xaxislocation", "zero")
 %! set (gca, "yaxislocation", "right")
 %! box off
 
 %!demo
+%! clf
 %! x = -10:0.1:10;
 %! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
 %! plot (x, y)
 %! title ("no plot box")
 %! set (gca, "xaxislocation", "bottom")
 %! set (gca, "yaxislocation", "zero")
 %! box off
 
 %!demo
+%! clf
 %! x = -10:0.1:10;
 %! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
 %! plot (x, y)
 %! title ("no plot box")
 %! set (gca, "xaxislocation", "top")
 %! set (gca, "yaxislocation", "zero")
 %! box off
 
diff --git a/scripts/plot/compass.m b/scripts/plot/compass.m
--- a/scripts/plot/compass.m
+++ b/scripts/plot/compass.m
@@ -107,13 +107,14 @@ function retval = compass (varargin)
   if (nargout > 0)
     retval = hlist;
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! randn_9x1_data = [-2.555884; 0.394974; -0.191871; -1.147024; 1.355425; -0.437335; -0.014370; -0.941312; 1.240300];
 %! randn_1x9_data = [1.42934, -1.10821, -1.70404, 0.63357, -0.68337, -1.19771, -0.96502, -1.12810, 0.22457];
 %! a = toeplitz ([1;randn_9x1_data], [1,randn_1x9_data]);
 %! compass (eig (a));
 
diff --git a/scripts/plot/contour3.m b/scripts/plot/contour3.m
--- a/scripts/plot/contour3.m
+++ b/scripts/plot/contour3.m
@@ -70,16 +70,17 @@ function [c, h] = contour3 (varargin)
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
 
 endfunction
 
 %!demo
+%! clf
 %! contour3 (peaks (19));
 %! hold on
 %! surface (peaks (19), "facecolor", "none", "edgecolor", "black")
 %! colormap hot
 %! axis tight
 %! zlim auto
 %! hold off
 %! box off
diff --git a/scripts/plot/contourf.m b/scripts/plot/contourf.m
--- a/scripts/plot/contourf.m
+++ b/scripts/plot/contourf.m
@@ -76,16 +76,18 @@ function [c, h] = contourf (varargin)
 
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
 endfunction
 
 %!demo
+%! clf
 %! [x, y, z] = peaks (50);
 %! contourf (x, y, z, -7:9)
 
 %!demo
+%! clf
 %! [theta, r] = meshgrid (linspace (0, 2*pi, 64), linspace(0,1,64));
 %! [X, Y] = pol2cart (theta, r);
 %! Z = sin(2*theta).*(1-r);
 %! contourf(X, Y, abs(Z), 10)
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -81,11 +81,12 @@ function [xx, yy, zz] = cylinder (vararg
     zz = z;
   else
     surf (ax, x, y, z);
   endif
 
 endfunction
 
 %!demo
+%! clf
 %! [x, y, z] = cylinder (10:-1:0,50);
 %! surf (x, y, z);
 %! title ("a cone")
diff --git a/scripts/plot/ellipsoid.m b/scripts/plot/ellipsoid.m
--- a/scripts/plot/ellipsoid.m
+++ b/scripts/plot/ellipsoid.m
@@ -65,9 +65,10 @@ function [xx, yy, zz] = ellipsoid (varar
     zz = z;
   else
     surf (h, x, y, z);
   endif
 
 endfunction
 
 %!demo
+%! clf
 %! ellipsoid (0, 0, 1, 2, 3, 4, 20);
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -133,39 +133,44 @@ function retval = errorbar (varargin)
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 
 %!demo
+%! clf
 %! rand_1x11_data1 = [0.82712, 0.50325, 0.35613, 0.77089, 0.20474, 0.69160, 0.30858, 0.88225, 0.35187, 0.14168, 0.54270];
 %! rand_1x11_data2 = [0.506375, 0.330106, 0.017982, 0.859270, 0.140641, 0.327839, 0.275886, 0.162453, 0.807592, 0.318509, 0.921112];
 %! errorbar (0:10, rand_1x11_data1, 0.25*rand_1x11_data2);
 
 %!demo
+%! clf
 %! rand_1x11_data3 = [0.423650, 0.142331, 0.213195, 0.129301, 0.975891, 0.012872, 0.635327, 0.338829, 0.764997, 0.401798, 0.551850];
 %! rand_1x11_data4 = [0.682566, 0.456342, 0.132390, 0.341292, 0.108633, 0.601553, 0.040455, 0.146665, 0.309187, 0.586291, 0.540149];
 %! errorbar(0:10, rand_1x11_data3, rand_1x11_data4, ">");
 
 %!demo
+%! clf
 %! x = 0:0.5:2*pi;
 %! err = x/100;
 %! y1 = sin (x);
 %! y2 = cos (x);
 %! hg = errorbar (x, y1, err, "~", x, y2, err, ">");
 
 %!demo
+%! clf
 %! x = 0:0.5:2*pi;
 %! err = x/100;
 %! y1 = sin (x);
 %! y2 = cos (x);
 %! hg = errorbar (x, y1, err, err, "#r", x, y2, err, err, "#~");
 
 %!demo
+%! clf
 %! x = 0:0.5:2*pi;
 %! err = x/100;
 %! y1 = sin (x);
 %! y2 = cos (x);
 %! hg = errorbar (x, y1, err, err, err, err, "~>", ...
 %!                x, y2, err, err, err, err, "#~>-*");
 
diff --git a/scripts/plot/ezcontour.m b/scripts/plot/ezcontour.m
--- a/scripts/plot/ezcontour.m
+++ b/scripts/plot/ezcontour.m
@@ -57,11 +57,12 @@ function retval = ezcontour (varargin)
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
 
 %!demo
+%! clf
 %! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezcontour (f, [-3, 3]);
 
diff --git a/scripts/plot/ezcontourf.m b/scripts/plot/ezcontourf.m
--- a/scripts/plot/ezcontourf.m
+++ b/scripts/plot/ezcontourf.m
@@ -57,10 +57,11 @@ function retval = ezcontourf (varargin)
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
 
 %!demo
+%! clf
 %! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezcontourf (f, [-3, 3]);
diff --git a/scripts/plot/ezmesh.m b/scripts/plot/ezmesh.m
--- a/scripts/plot/ezmesh.m
+++ b/scripts/plot/ezmesh.m
@@ -78,17 +78,19 @@ function retval = ezmesh (varargin)
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
 
 %!demo
+%! clf
 %! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezmesh (f, [-3, 3]);
 
 %!demo
+%! clf
 %! fx = @(s,t) cos (s) .* cos(t);
 %! fy = @(s,t) sin (s) .* cos(t);
 %! fz = @(s,t) sin (t);
 %! ezmesh (fx, fy, fz, [-pi,pi,-pi/2,pi/2], 20);
 
diff --git a/scripts/plot/ezmeshc.m b/scripts/plot/ezmeshc.m
--- a/scripts/plot/ezmeshc.m
+++ b/scripts/plot/ezmeshc.m
@@ -68,11 +68,12 @@ function retval = ezmeshc (varargin)
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
 
 %!demo
+%! clf
 %! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezmeshc (f, [-3, 3]);
 
diff --git a/scripts/plot/ezplot.m b/scripts/plot/ezplot.m
--- a/scripts/plot/ezplot.m
+++ b/scripts/plot/ezplot.m
@@ -76,16 +76,19 @@ function retval = ezplot (varargin)
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
 
 %!demo
+%! clf
 %! ezplot (@cos, @sin)
 
 %!demo
+%! clf
 %! ezplot ("1/x")
 
 %!demo
+%! clf
 %! ezplot (inline ("x^2 - y^2 = 1"))
 
diff --git a/scripts/plot/ezplot3.m b/scripts/plot/ezplot3.m
--- a/scripts/plot/ezplot3.m
+++ b/scripts/plot/ezplot3.m
@@ -56,13 +56,14 @@ function retval = ezplot3 (varargin)
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
 
 %!demo
+%! clf
 %! fx = @(t) cos (t);
 %! fy = @(t) sin (t);
 %! fz = @(t) t;
 %! ezplot3 (fx, fy, fz, [0, 10*pi], 100);
 
diff --git a/scripts/plot/ezpolar.m b/scripts/plot/ezpolar.m
--- a/scripts/plot/ezpolar.m
+++ b/scripts/plot/ezpolar.m
@@ -51,10 +51,11 @@ function retval = ezpolar (varargin)
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
 
 %!demo
+%! clf
 %! ezpolar (@(t) 1 + sin (t));
 
diff --git a/scripts/plot/ezsurf.m b/scripts/plot/ezsurf.m
--- a/scripts/plot/ezsurf.m
+++ b/scripts/plot/ezsurf.m
@@ -78,17 +78,19 @@ function retval = ezsurf (varargin)
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
 
 %!demo
+%! clf
 %! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezsurf (f, [-3, 3]);
 
 %!demo
+%! clf
 %! fx = @(s,t) cos (s) .* cos(t);
 %! fy = @(s,t) sin (s) .* cos(t);
 %! fz = @(s,t) sin (t);
 %! ezsurf (fx, fy, fz, [-pi,pi,-pi/2,pi/2], 20);
 
diff --git a/scripts/plot/ezsurfc.m b/scripts/plot/ezsurfc.m
--- a/scripts/plot/ezsurfc.m
+++ b/scripts/plot/ezsurfc.m
@@ -68,11 +68,12 @@ function retval = ezsurfc (varargin)
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
 
 %!demo
+%! clf
 %! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezsurfc (f, [-3, 3]);
 
diff --git a/scripts/plot/feather.m b/scripts/plot/feather.m
--- a/scripts/plot/feather.m
+++ b/scripts/plot/feather.m
@@ -106,11 +106,12 @@ function retval = feather (varargin)
   if (nargout > 0)
     retval = hlist;
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! phi = [0 : 15 : 360] * pi / 180;
 %! feather (sin (phi), cos (phi))
 
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -123,12 +123,14 @@ function fplot (fn, limits, n, fmt)
     for i = 1:columns (y)
       nams{i} = sprintf ("%s(:,%i)", nam, i);
     endfor
     legend (nams{:});
   endif
 endfunction
 
 %!demo
+%! clf
 %! fplot ("cos", [0, 2*pi])
 
 %!demo
+%! clf
 %! fplot ("[cos(x), sin(x)]", [0, 2*pi])
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/loglogerr.m
@@ -56,15 +56,16 @@ function retval = loglogerr (varargin)
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 %!demo
+%! clf
 %! x = exp (log(0.01):0.2:log(10));
 %! y = wblpdf (x, 3, 2);
 %! eyu = 2*rand (size (y)) .* y;
 %! eyl = 0.5*rand (size (y)) .* y;
 %! loglogerr (x, y, eyl, eyu, "#~x-")
 %! xlim (x([1, end]))
 
diff --git a/scripts/plot/module.mk b/scripts/plot/module.mk
--- a/scripts/plot/module.mk
+++ b/scripts/plot/module.mk
@@ -189,16 +189,17 @@ plot_FCN_FILES = \
   plot/uipanel.m \
   plot/uipushtool.m \
   plot/uiputfile.m \
   plot/uiresume.m \
   plot/uitoggletool.m \
   plot/uitoolbar.m \
   plot/uiwait.m \
   plot/view.m \
+  plot/waitbar.m \
   plot/waitforbuttonpress.m \
   plot/whitebg.m \
   plot/xlabel.m \
   plot/xlim.m \
   plot/ylabel.m \
   plot/ylim.m \
   plot/zlabel.m \
   plot/zlim.m \
diff --git a/scripts/plot/pcolor.m b/scripts/plot/pcolor.m
--- a/scripts/plot/pcolor.m
+++ b/scripts/plot/pcolor.m
@@ -82,12 +82,13 @@ function h = pcolor (x, y, c)
 endfunction
 
 %!demo
 %! clf
 %! [~,~,Z]=peaks;
 %! pcolor(Z);
 
 %!demo
+%! clf
 %! [X,Y,Z]=sombrero;
 %! [Fx,Fy] = gradient(Z);
 %! pcolor(X,Y,Fx+Fy);
 %! shading interp;
diff --git a/scripts/plot/pie.m b/scripts/plot/pie.m
--- a/scripts/plot/pie.m
+++ b/scripts/plot/pie.m
@@ -63,22 +63,25 @@ function retval = pie (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! pie ([3, 2, 1], [0, 0, 1]);
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 
 %!demo
+%! clf
 %! pie ([3, 2, 1], [0, 0, 1], {"Cheddar", "Swiss", "Camembert"});
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 
 %!demo
+%! clf
 %! pie ([0.17, 0.34, 0.41], {"Cheddar", "Swiss", "Camembert"});
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 %! title ("missing slice");
 
diff --git a/scripts/plot/pie3.m b/scripts/plot/pie3.m
--- a/scripts/plot/pie3.m
+++ b/scripts/plot/pie3.m
@@ -64,22 +64,25 @@ function retval = pie3 (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! pie3 ([5:-1:1], [0, 0, 1, 0, 0]);
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 
 %!demo
+%! clf
 %! pie3 ([3, 2, 1], [0, 0, 1], {"Cheddar", "Swiss", "Camembert"});
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 
 %!demo
+%! clf
 %! pie3 ([0.17, 0.34, 0.41], {"Cheddar", "Swiss", "Camembert"});
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 %! title ("missing slice");
 
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -328,11 +328,12 @@ function retval = plot3 (varargin)
 
   if (nargout > 0 && idx > 0)
     retval = tmp;
   endif
 
 endfunction
 
 %!demo
+%! clf
 %! z = [0:0.05:5];
 %! plot3 (cos(2*pi*z), sin(2*pi*z), z, ";helix;");
 %! plot3 (z, exp(2i*pi*z), ";complex sinusoid;");
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -91,16 +91,17 @@ function [h, ax, bigax, p, pax] = plotma
       set (bigax2, "visible", "off");
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
   endif
 endfunction
 
 %!demo
+%! clf
 %! plotmatrix (randn (100, 3), 'g+')
 
 function plotmatrixdelete (h, d, ax)
   for i = 1 : numel (ax)
     hc = ax(i);
     if (ishandle (hc) && strcmp (get (hc, "type"), "axes")
         && strcmpi (get (hc, "beingdeleted"), "off"))
       parent = get (hc, "parent");
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -212,17 +212,19 @@ function retval = __plr2__ (h, theta, rh
   else
     error ("__plr2__: invalid data for plotting");
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! theta = linspace (0, 2*pi, 1000);
 %! rho = sin (7*theta);
 %! polar (theta, rho);
 
 %!demo
+%! clf
 %! theta = linspace (0, 10*pi, 1000);
 %! rho = sin (5/4*theta);
 %! polar (theta, rho);
 
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -690,20 +690,21 @@ function __go_draw_axes__ (h, plot_strea
                                || size (obj.cdata, 2) == 3)))
                      ccol = cdat (i, :);
                    elseif (ndims (obj.cdata) == 3)
                      ccol = permute (cdat (:, i, :), [1, 3, 2]);
                    else
                      ccol = cdat;
                    endif
                    if (strncmp (obj.facecolor, "flat", 4))
-                     if (numel(ccol) == 3)
+                     if (isequal (size (ccol), [1, 3]))
+                       ## RGB Triplet
                        color = ccol;
                      elseif (nd == 3 && numel (xcol) == 3)
-                       ccdat = ccol * ones (3,1);
+                       ccdat = ccol;
                      else
                        if (cdatadirect)
                          r = round (ccol);
                        else
                          r = 1 + round ((size (cmap, 1) - 1)
                                         * (ccol - clim(1))/(clim(2) - clim(1)));
                        endif
                        r = max (1, min (r, size (cmap, 1)));
diff --git a/scripts/plot/private/__patch__.m b/scripts/plot/private/__patch__.m
--- a/scripts/plot/private/__patch__.m
+++ b/scripts/plot/private/__patch__.m
@@ -269,18 +269,20 @@ function args = setdata (args)
 
   if (size(fvc, 1) == nc || size (fvc, 1) == 1)
     c = reshape (fvc, [1, size(fvc)]);
   else
     if (size(fvc, 2) == 3)
       c = cat(3, reshape (fvc(idx, 1), size(idx)),
               reshape (fvc(idx, 2), size(idx)),
               reshape (fvc(idx, 3), size(idx)));
-    else
+    elseif (isempty (fvc))
       c = [];
+    else ## if (size (fvc, 2) == 1)
+      c = permute (fvc(faces), [2, 1]);
     endif
   endif
   args = {"xdata", x, "ydata", y, "zdata", z, "cdata", c, args{:}};
 endfunction
 
 function args = setvertexdata (args)
   args = delfields (args, {"vertices", "faces", "facevertexcdata"});
   ## Remove the readonly fields as well
@@ -330,20 +332,18 @@ function args = setvertexdata (args)
   else
     vert = [x(:), y(:)];
   endif
   faces = reshape (1:numel(x), nr, nc);
   faces = faces';
 
   if (ndims (c) == 3)
     fvc = reshape (c, size (c, 1) * size (c, 2), size(c, 3));
-  elseif (isvector (c))
+  else
     fvc = c(:);
-  else
-    fvc = c.'(:);
   endif
 
   args = {"faces", faces, "vertices", vert, "facevertexcdata", fvc, args{:}};
 endfunction
 
 function update_data (h, d)
   update_handle (h, false);
 endfunction
diff --git a/scripts/plot/quiver.m b/scripts/plot/quiver.m
--- a/scripts/plot/quiver.m
+++ b/scripts/plot/quiver.m
@@ -84,15 +84,16 @@ endfunction
 
 %!demo
 %! clf
 %! [x,y] = meshgrid (1:2:20);
 %! h = quiver (x,y, sin (2*pi*x/10), sin (2*pi*y/10));
 %! set (h, "maxheadsize", 0.33);
 
 %!demo
+%! clf
 %! axis ("equal");
 %! x = linspace (0,3,80);
 %! y = sin (2*pi*x);
 %! theta = 2*pi*x + pi/2;
 %! quiver (x, y, sin (theta)/10, cos (theta)/10);
 %! hold on; plot(x,y,"r"); hold off;
 
diff --git a/scripts/plot/quiver3.m b/scripts/plot/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/quiver3.m
@@ -101,10 +101,18 @@ endfunction
 %! surf (x, y, z);
 %! hold on;
 %! [u, v, w] = surfnorm (x, y, z / 10);
 %! h = quiver3 (x, y, z, u, v, w);
 %! set (h, "maxheadsize", 0.33);
 %! hold off;
 
 %!demo
+%! clf
+%! [x, y, z] = peaks (25);
+%! surf (x, y, z);
+%! hold on;
+%! [u, v, w] = surfnorm (x, y, z / 10);
+%! h = quiver3 (x, y, z, u, v, w);
+%! set (h, "maxheadsize", 0.33);
+%! hold off;
 %! shading interp
 
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/refreshdata.m
@@ -101,16 +101,17 @@ function refreshdata (h, workspace)
           set (objs(i), props{i}{j}(1:end-6), val);
         endif
       endif
     endfor
   endfor
 endfunction
 
 %!demo
+%! clf
 %! x = 0:0.1:10;
 %! y = sin (x);
 %! plot (x, y, "ydatasource", "y");
 %! for i = 1 : 100
 %!   pause(0.1)
 %!   y = sin (x + 0.1 * i);
 %!   refreshdata(gcf(), "caller");
 %! endfor
diff --git a/scripts/plot/ribbon.m b/scripts/plot/ribbon.m
--- a/scripts/plot/ribbon.m
+++ b/scripts/plot/ribbon.m
@@ -83,12 +83,13 @@ function h = ribbon (x, y, width)
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! [x, y, z] = sombrero ();
 %! [x, y] = meshgrid (x, y);
 %! ribbon (y, z);
 
diff --git a/scripts/plot/rose.m b/scripts/plot/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/rose.m
@@ -101,10 +101,11 @@ function [thout, rout] = rose (varargin)
     thout = th;
     rout = r;
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! rose ([2*randn(1e5, 1), pi + 2*randn(1e5, 1)]);
 
diff --git a/scripts/plot/scatter3.m b/scripts/plot/scatter3.m
--- a/scripts/plot/scatter3.m
+++ b/scripts/plot/scatter3.m
@@ -79,29 +79,33 @@ function retval = scatter3 (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! [x, y, z] = peaks (20);
 %! scatter3 (x(:), y(:), z(:), [], z(:));
 
 %!demo
+%! clf
 %! x = rand (20,1);
 %! y = rand (20,1);
 %! z = rand (20,1);
 %! scatter3 (x(:), y(:), z(:), 10, z(:), "s");
 
 %!demo
+%! clf
 %! x = rand (20,1);
 %! y = rand (20,1);
 %! z = rand (20,1);
 %! scatter3 (x(:), y(:), z(:), 20*z(:), z(:), "s");
 
 %!demo
+%! clf
 %! x = rand (20,1);
 %! y = rand (20,1);
 %! z = rand (20,1);
 %! scatter3 (x(:), y(:), z(:), 20*z(:), [], "s");
 
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -59,16 +59,17 @@ function retval = semilogx (varargin)
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 
 %!demo
+%! clf ();
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogx (y, x);
 
 %!demo
 %! clf ();
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -56,13 +56,14 @@ function retval = semilogxerr (varargin)
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 %!demo
+%! clf
 %! x = exp (log(0.01):0.2:log(10));
 %! y = wblpdf (x, 2, 2);
 %! ey = 0.5*rand (size (y)) .* y;
 %! semilogxerr (x, y, ey, "#~x-")
 %! xlim (x([1, end]))
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -59,16 +59,17 @@ function retval = semilogy (varargin)
 
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 %!demo
+%! clf ();
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogy (x, y);
 
 %!demo
 %! clf ();
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
diff --git a/scripts/plot/semilogyerr.m b/scripts/plot/semilogyerr.m
--- a/scripts/plot/semilogyerr.m
+++ b/scripts/plot/semilogyerr.m
@@ -56,15 +56,16 @@ function retval = semilogyerr (varargin)
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 %!demo
+%! clf
 %! x = 0.25:0.25:10;
 %! y = wblpdf (x, 4, 2);
 %! eyu = rand (size (y));
 %! eyl = 1.0 - 1./(1+eyu);
 %! semilogyerr (x, y, eyl.*y, eyu.*y, "~-d")
 %! xlim ([0 10])
 
diff --git a/scripts/plot/shading.m b/scripts/plot/shading.m
--- a/scripts/plot/shading.m
+++ b/scripts/plot/shading.m
@@ -77,32 +77,37 @@ endfunction
 %!demo
 %! clf
 %! colormap (jet)
 %! sombrero
 %! shading faceted
 %! title ('shading "faceted"')
 
 %!demo
+%! clf
 %! sombrero
 %! shading flat
 %! title ('shading "flat"')
 
 %!demo
+%! clf
 %! sombrero
 %! shading interp
 %! title ('shading "interp"')
 
 %!demo
+%! clf
 %! pcolor (peaks ())
 %! shading faceted
 %! title ('shading "faceted"')
 
 %!demo
+%! clf
 %! pcolor (peaks ())
 %! shading flat
 %! title ('shading "flat"')
 
 %!demo
+%! clf
 %! pcolor (peaks ())
 %! shading interp
 %! title ('shading "interp"')
 
diff --git a/scripts/plot/slice.m b/scripts/plot/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/slice.m
@@ -177,17 +177,21 @@ function h = slice (varargin)
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! [x, y, z] = meshgrid (linspace (-8, 8, 32));
 %! v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
 %! slice (x, y, z, v, [], 0, []);
 
 %!demo
+%! clf
+%! [x, y, z] = meshgrid (linspace (-8, 8, 32));
+%! v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
 %! [xi, yi] = meshgrid (linspace (-7, 7));
 %! zi = xi + yi;
 %! slice (x, y, z, v, xi, yi, zi);
 
diff --git a/scripts/plot/sombrero.m b/scripts/plot/sombrero.m
--- a/scripts/plot/sombrero.m
+++ b/scripts/plot/sombrero.m
@@ -57,9 +57,10 @@ function [x, y, z] = sombrero (n)
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!demo
+%! clf
 %! sombrero ();
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -205,32 +205,36 @@ function [h, xs, ys] = __stairs__ (doplo
   else
     h = 0;
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! x = 1:10;
 %! rand_1x10_data1 = [0.073, 0.455, 0.837, 0.124, 0.426, 0.781, 0.004, 0.024, 0.519, 0.698];
 %! y = rand_1x10_data1;
 %! stairs (x, y);
 
 %!demo
+%! clf
 %! x = 1:10;
 %! rand_1x10_data2 = [0.014, 0.460, 0.622, 0.394, 0.531, 0.378, 0.466, 0.788, 0.342, 0.893];
 %! y = rand_1x10_data2;
 %! [xs, ys] = stairs (x, y);
 %! plot (xs, ys);
 
 %!demo
+%! clf
 %! stairs (1:9);
 
 %!demo
+%! clf
 %! [xs, ys] = stairs (9:-1:1);
 %! plot (xs, ys);
 
 
 function update_props (h, d)
   set (get (h, "children"), "color", get (h, "color"),
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"),
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -83,43 +83,50 @@ function h = stem (varargin)
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! x = 1:10;
 %! stem (x);
 
 %!demo
+%! clf
 %! x = 1:10;
 %! y = 2*x;
 %! stem (x, y);
 
 %!demo
+%! clf
 %! x = 1:10;
 %! y = 2*x;
 %! h = stem (x, y, "r");
 
 %!demo
+%! clf
 %! x = 1:10;
 %! y = 2*x;
 %! h = stem (x, y, "-.k");
 
 %!demo
+%! clf
 %! x = 1:10;
 %! y = 2*x;
 %! h = stem (x, y, "-.k.");
 
 %!demo
+%! clf
 %! x = 1:10;
 %! y = 2*x;
 %! h = stem (x, y, "filled");
 
 %!demo
+%! clf
 %! x = [0 : 10]';
 %! y = [sin(x), cos(x)];
 %! h = stem (x, y);
 %! set (h(2), "color", "g");
 %! set (h(1), "basevalue", -1)
 
diff --git a/scripts/plot/stem3.m b/scripts/plot/stem3.m
--- a/scripts/plot/stem3.m
+++ b/scripts/plot/stem3.m
@@ -48,10 +48,11 @@ function h = stem3 (varargin)
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
 %!demo
+%! clf
 %! theta = 0:0.2:6;
 %! stem3 (cos (theta), sin (theta), theta)
diff --git a/scripts/plot/surf.m b/scripts/plot/surf.m
--- a/scripts/plot/surf.m
+++ b/scripts/plot/surf.m
@@ -66,19 +66,21 @@ endfunction
 
 
 %!demo
 %! clf
 %! [~,~,Z] = peaks;
 %! surf (Z);
 
 %!demo
+%! clf
 %! [~,~,Z] = sombrero;
 %! [Fx,Fy] = gradient (Z);
 %! surf (Z, Fx+Fy);
 %! shading interp;
 
 %!demo
+%! clf
 %! [X,Y,Z] = sombrero;
 %! [~,Fy] = gradient (Z);
 %! surf (X, Y, Z, Fy);
 %! shading interp;
 
diff --git a/scripts/plot/surfc.m b/scripts/plot/surfc.m
--- a/scripts/plot/surfc.m
+++ b/scripts/plot/surfc.m
@@ -75,18 +75,20 @@ function h = surfc (varargin)
 endfunction
 
 %!demo
 %! clf
 %! [~,~,Z]=peaks;
 %! surfc(Z);
 
 %!demo
+%! clf
 %! [~,~,Z]=sombrero;
 %! [Fx,Fy] = gradient(Z);
 %! surfc(Z,Fx+Fy);
 %! shading interp;
 
 %!demo
+%! clf
 %! [X,Y,Z]=sombrero;
 %! [~,Fy] = gradient(Z);
 %! surfc(X,Y,Z,Fy);
 %! shading interp;
diff --git a/scripts/plot/surfl.m b/scripts/plot/surfl.m
--- a/scripts/plot/surfl.m
+++ b/scripts/plot/surfl.m
@@ -174,14 +174,15 @@ endfunction
 %!demo
 %! clf
 %! [X,Y,Z]=sombrero;
 %! colormap(copper);
 %! surfl(X,Y,Z);
 %! shading interp;
 
 %!demo
+%! clf
 %! [X,Y,Z]=sombrero;
 %! colormap(copper);
 %! [az, el] = view;
 %! surfl(X,Y,Z,[az+225,el],[0.2 0.6 0.4 25]);
 %! shading interp;
 
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -137,18 +137,21 @@ function [Nx, Ny, Nz] = surfnorm (vararg
     Nx = nx;
     Ny = ny;
     Nz = nz;
   endif
 
 endfunction
 
 %!demo
+%! clf
 %! colormap (jet (64))
 %! [x, y, z] = peaks(10);
 %! surfnorm (x, y, z);
 
 %!demo
+%! clf
 %! surfnorm (peaks(10));
 
 %!demo
+%! clf
 %! surfnorm (peaks(32));
 %! shading interp
diff --git a/scripts/plot/trimesh.m b/scripts/plot/trimesh.m
--- a/scripts/plot/trimesh.m
+++ b/scripts/plot/trimesh.m
@@ -51,16 +51,17 @@ function h = trimesh (tri, x, y, z, vara
       h = handle;
     endif
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 10);
 %! N = 10;
 %! x = 3 - 6 * rand (N, N);
 %! y = 3 - 6 * rand (N, N);
 %! z = peaks (x, y);
 %! tri = delaunay (x(:), y(:));
diff --git a/scripts/plot/triplot.m b/scripts/plot/triplot.m
--- a/scripts/plot/triplot.m
+++ b/scripts/plot/triplot.m
@@ -43,16 +43,17 @@ function h = triplot (tri, x, y, varargi
   if (nargout > 0)
     h = handle;
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 2);
 %! N = 20;
 %! x = rand (N, 1);
 %! y = rand (N, 1);
 %! tri = delaunay (x, y);
 %! triplot (tri, x, y);
diff --git a/scripts/plot/trisurf.m b/scripts/plot/trisurf.m
--- a/scripts/plot/trisurf.m
+++ b/scripts/plot/trisurf.m
@@ -66,41 +66,66 @@ function h = trisurf (tri, x, y, z, vara
     if (! ishold ())
       set (gca(), "view", [-37.5, 30],
            "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
   endif
 
 endfunction
 
+%!demo
+%! clf
+%! N = 31;
+%! [x, y] = meshgrid (1:N);
+%! tri = delaunay (x, y);
+%! z = peaks (N);
+%! h = trisurf (tri, x, y, z, "facecolor", "interp");
+%! axis tight
+%! zlim auto
+%! title (sprintf ("facecolor = %s", get (h, "facecolor")))
 
 %!demo
+%! clf
+%! N = 31;
+%! [x, y] = meshgrid (1:N);
+%! tri = delaunay (x, y);
+%! z = peaks (N);
+%! h = trisurf (tri, x, y, z, "facecolor", "flat");
+%! axis tight
+%! zlim auto
+%! title (sprintf ("facecolor = %s", get (h, "facecolor")))
+
+%!demo
+%! clf
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 10);
 %! N = 10;
 %! x = 3 - 6 * rand (N, N);
 %! y = 3 - 6 * rand (N, N);
 %! z = peaks (x, y);
 %! tri = delaunay (x(:), y(:));
 %! trisurf (tri, x(:), y(:), z(:));
 
 %!demo
+%! clf
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
 %! trisurf (tri, x, y, z);
 
 %!demo
+%! clf
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
 %! trisurf (tri, x, y, z, "facecolor", "interp");
 
 %!demo
+%! clf
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
 %! trisurf (tri, x, y, z, "facecolor", "interp", "edgecolor", "k");
 
diff --git a/scripts/plot/uimenu.m b/scripts/plot/uimenu.m
--- a/scripts/plot/uimenu.m
+++ b/scripts/plot/uimenu.m
@@ -86,16 +86,17 @@ function hui = uimenu (varargin)
   if (nargout > 0)
     hui = tmp;
   endif
 
 endfunction
 
 
 %!demo
+%! clf
 %! surfl (peaks);
 %! colormap (copper);
 %! shading ("interp");
 %! f = uimenu ("label", "&File", "accelerator", "f");
 %! e = uimenu ("label", "&Edit", "accelerator", "e");
 %! uimenu (f, "label", "Close", "accelerator", "q", "callback", "close (gcf)");
 %! uimenu (e, "label", "Toggle &Grid", "accelerator", "g", "callback", "grid (gca)");
 
diff --git a/scripts/plot/waitbar.m b/scripts/plot/waitbar.m
--- a/scripts/plot/waitbar.m
+++ b/scripts/plot/waitbar.m
@@ -138,17 +138,17 @@ endfunction
 %! endfor
 %! close (h);
 
 %!demo
 %! h = waitbar (0, "please wait...");
 %! for i = 0:0.01:0.6
 %!   waitbar (i);
 %! endfor
-%! i = 0.3
+%! i = 0.3;
 %! waitbar (i, h, "don't you hate taking a step backward?")
 %! pause (0.5);
 %! for i = i:0.005:0.7
 %!   waitbar (i, h);
 %! endfor
 %! waitbar (i, h, "or stalling?")
 %! pause (1);
 %! for i = i:0.003:0.8
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -46,18 +46,17 @@
 ##     |       .            .        .       .             .      |
 ##     |_      0            0      @dots{}       1             0     _|
 ## @end group
 ## @end smallexample
 ##
 ## @end ifnottex
 ## The eigenvalues of the companion matrix are equal to the roots of the
 ## polynomial.
-## @seealso{poly, roots, residue, conv, deconv, polyval, polyder,
-## polyint}
+## @seealso{roots, poly, eig}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function A = compan (c)
 
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -31,17 +31,17 @@
 ## @table @asis
 ## @item @var{shape} = "full"
 ## Return the full convolution.  (default)
 ##
 ## @item @var{shape} = "same"
 ## Return the central part of the convolution with the same size as @var{a}.
 ## @end table
 ##
-## @seealso{deconv, fftconv, conv2, poly}
+## @seealso{deconv, conv2, convn, fftconv}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = conv (a, b, shape = "full")
 
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -21,17 +21,17 @@
 ## Deconvolve two vectors.
 ##
 ## @code{[b, r] = deconv (y, a)} solves for @var{b} and @var{r} such that
 ## @code{y = conv (a, b) + r}.
 ##
 ## If @var{y} and @var{a} are polynomial coefficient vectors, @var{b} will
 ## contain the coefficients of the polynomial quotient and @var{r} will be
 ## a remainder polynomial of lowest order.
-## @seealso{conv, poly, roots, residue, polyval, polyder, polyint}
+## @seealso{conv, residue}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [b, r] = deconv (y, a)
 
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} mkpp (@var{breaks}, @var{coefs})
 ## @deftypefnx {Function File} {@var{pp} =} mkpp (@var{breaks}, @var{coefs}, @var{d})
 ##
-## Construct a piece-wise polynomial (pp) structure from sample points
+## Construct a piecewise polynomial (pp) structure from sample points
 ## @var{breaks} and coefficients @var{coefs}.  @var{breaks} must be a vector of
 ## strictly increasing values.  The number of intervals is given by
 ## @code{@var{ni} = length (@var{breaks}) - 1}.
 ## When @var{m} is the polynomial order @var{coefs} must be of
 ## size: @var{ni} x @var{m} + 1.
 ##
 ## The i-th row of @var{coefs},
 ## @code{@var{coefs} (@var{i},:)}, contains the coefficients for the polynomial
@@ -35,17 +35,17 @@
 ## @var{coefs} may also be a multi-dimensional array, specifying a vector-valued
 ## or array-valued polynomial.  In that case the polynomial order is defined
 ## by the length of the last dimension of @var{coefs}.
 ## The size of first dimension(s) are given by the scalar or
 ## vector @var{d}.  If @var{d} is not given it is set to @code{1}.
 ## In any case @var{coefs} is reshaped to a 2-D matrix of
 ## size @code{[@var{ni}*prod(@var{d} @var{m})] }
 ##
-## @seealso{unmkpp, ppval, spline}
+## @seealso{unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps}
 ## @end deftypefn
 
 function pp = mkpp (x, P, d)
 
   # check number of arguments
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
diff --git a/scripts/polynomial/mpoles.m b/scripts/polynomial/mpoles.m
--- a/scripts/polynomial/mpoles.m
+++ b/scripts/polynomial/mpoles.m
@@ -12,44 +12,45 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{multp}, @var{indx}] =} mpoles (@var{p})
-## @deftypefnx {Function File} {[@var{multp}, @var{indx}] =} mpoles (@var{p}, @var{tol})
-## @deftypefnx {Function File} {[@var{multp}, @var{indx}] =} mpoles (@var{p}, @var{tol}, @var{reorder})
-## Identify unique poles in @var{p} and associates their multiplicity,
-## ordering them from largest to smallest.
+## @deftypefn  {Function File} {[@var{multp}, @var{idxp}] =} mpoles (@var{p})
+## @deftypefnx {Function File} {[@var{multp}, @var{idxp}] =} mpoles (@var{p}, @var{tol})
+## @deftypefnx {Function File} {[@var{multp}, @var{idxp}] =} mpoles (@var{p}, @var{tol}, @var{reorder})
+## Identify unique poles in @var{p} and their associated multiplicity.  The
+## output is ordered from largest pole to smallest pole.
 ##
-## If the relative difference of the poles is less than @var{tol}, then
+## If the relative difference of two poles is less than @var{tol} then
 ## they are considered to be multiples.  The default value for @var{tol}
 ## is 0.001.
 ##
 ## If the optional parameter @var{reorder} is zero, poles are not sorted.
 ##
-## The value @var{multp} is a vector specifying the multiplicity of the
-## poles.  @var{multp}(:) refers to multiplicity of @var{p}(@var{indx}(:)).
+## The output @var{multp} is a vector specifying the multiplicity of the
+## poles.  @code{@var{multp}(n)} refers to the multiplicity of the Nth pole
+## @code{@var{p}(@var{idxp}(n))}.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## p = [2 3 1 1 2];
 ## [m, n] = mpoles(p);
 ##   @result{} m = [1; 1; 2; 1; 2]
 ##   @result{} n = [2; 5; 1; 4; 3]
 ##   @result{} p(n) = [3, 2, 2, 1, 1]
 ## @end group
 ## @end example
 ##
-## @seealso{poly, roots, conv, deconv, polyval, polyder, polyint, residue}
+## @seealso{residue, poly, roots, conv, deconv}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: Sept 30, 2007
 
 function [multp, indx] = mpoles (p, tol, reorder)
 
   if (nargin < 1 || nargin > 3)
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -14,49 +14,47 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} pchip (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{yi} =} pchip (@var{x}, @var{y}, @var{xi})
+## Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip) of
+## points @var{x} and @var{y}.
 ##
-## Piecewise Cubic Hermite interpolating polynomial.  Called with two
-## arguments, the piecewise polynomial @var{pp} is returned, that may
-## later be used with @code{ppval} to evaluate the polynomial at
-## specific points.
+## If called with two arguments, return the piecewise polynomial @var{pp}
+## that may be used with @code{ppval} to evaluate the polynomial at specific
+## points.  When called with a third input argument, @code{pchip} evaluates
+## the pchip polynomial at the points @var{xi}.  The third calling form is
+## equivalent to @code{ppval (pchip (@var{x}, @var{y}), @var{xi})}.
 ##
 ## The variable @var{x} must be a strictly monotonic vector (either
-## increasing or decreasing).  While @var{y} can be either a vector or
-## an array.  In the case where @var{y} is a vector, it must have the
-## length @var{n}.  If @var{y} is an array, then the size of @var{y} must
+## increasing or decreasing) of length @var{n}.  @var{y} can be either a
+## vector or array.  If @var{y} is a vector then it must be the same length
+## @var{n} as @var{x}.  If @var{y} is an array then the size of @var{y} must
 ## have the form
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
 ## @end ifnottex
-## The array is then reshaped internally to a matrix where the leading
+## The array is reshaped internally to a matrix where the leading
 ## dimension is given by
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
-## and each row in this matrix is then treated separately.  Note that this
-## is exactly the opposite treatment than @code{interp1} and is done
-## for compatibility.
-##
-## Called with a third input argument, @code{pchip} evaluates the
-## piecewise polynomial at the points @var{xi}.  There is an equivalence
-## between @code{ppval (pchip (@var{x}, @var{y}), @var{xi})} and
-## @code{pchip (@var{x}, @var{y}, @var{xi})}.
+## and each row of this matrix is then treated separately.  Note that this
+## is exactly opposite to @code{interp1} but is done for @sc{matlab}
+## compatibility.
 ##
 ## @seealso{spline, ppval, mkpp, unmkpp}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Date: 9. mar 2001
 ##
 ## S_k = a_k + b_k*x + c_k*x^2 + d_k*x^3; (spline polynom)
@@ -163,9 +161,9 @@ endfunction
 %!assert(pp.pieces,8);
 %!assert(pp.order,4);
 %!assert(pp.dim,[3,2]);
 %!assert(ppval(pp,pi),[0,-1;1,0;-1,-2],1e-14);
 %!assert(yi3(:,:,2),ppval(pp,pi),1e-14);
 %!assert(yi3(:,:,1),[1,0;2,1;0,-1],1e-14);
 %!assert(squeeze(yi1(1,2,:)),[1/sqrt(2); 0; -1/sqrt(2);-1],1e-14);
 %!assert(size(yi2),[3,2,5,4]);
-%!assert(squeeze(yi2(1,2,3,:)),[1/sqrt(2); 0; -1/sqrt(2);-1],1e-14);
\ No newline at end of file
+%!assert(squeeze(yi2(1,2,3,:)),[1/sqrt(2); 0; -1/sqrt(2);-1],1e-14);
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -33,23 +33,22 @@
 ## @result{} 0.99999 + 0.00000i
 ## @end group
 ## @end example
 ##
 ## In fact, all three eigenvalues are exactly 1 which emphasizes that for
 ## numerical performance the @code{eig} function should be used to compute
 ## eigenvalues.
 ##
-## If @var{x} is a vector, @code{poly (@var{x})} is a vector of the coefficients
-## of the polynomial whose roots are the elements of @var{x}.  That is,
-## if @var{c} is a polynomial, then the elements of
-## @code{@var{d} = roots (poly (@var{c}))} are contained in @var{c}.
-## The vectors @var{c} and @var{d} are not identical, however, due to sorting
-## and numerical errors.
-## @seealso{eig, roots}
+## If @var{x} is a vector, @code{poly (@var{x})} is a vector of the
+## coefficients of the polynomial whose roots are the elements of @var{x}. 
+## That is, if @var{c} is a polynomial, then the elements of @code{@var{d} =
+## roots (poly (@var{c}))} are contained in @var{c}.  The vectors @var{c} and
+## @var{d} are not identical, however, due to sorting and numerical errors.
+## @seealso{roots, eig}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
 function y = poly (x)
 
diff --git a/scripts/polynomial/polyaffine.m b/scripts/polynomial/polyaffine.m
--- a/scripts/polynomial/polyaffine.m
+++ b/scripts/polynomial/polyaffine.m
@@ -22,17 +22,17 @@
 ## transformation.  If @var{f} is the vector representing the polynomial f(x),
 ## then @code{@var{g} = polyaffine (@var{f}, @var{mu})} is the vector
 ## representing:
 ##
 ## @example
 ## g(x) = f((x-@var{mu}(1))/@var{mu}(2)).
 ## @end example
 ##
-## @seealso{polyval}
+## @seealso{polyval, polyfit}
 ## @end deftypefn
 
 
 function g = polyaffine (f, mu)
 
    if (nargin != 2)
       print_usage ();
    endif
@@ -65,30 +65,24 @@ function g = polyaffine (f, mu)
      ii = lf:-1:1;
      g = g(ii) * (toeplitz (w) .* pascal (lf, -1));
      g = g(ii);
    endif
 
 endfunction
 
 
+%!demo
+%! f = [1/5 4/5 -7/5 -2];
+%! g = polyaffine (f, [1, 1.2]);
+%! x = linspace (-4, 4, 100);
+%! plot(x, polyval (f, x), x, polyval (g, x));
+%! legend ("original", "affine");
+%! axis ([-4 4 -3 5]);
+%! grid ("on");
+
 %!test
 %! f = [1/5 4/5 -7/5 -2];
-%!
 %! mu = [1, 1.2];
-%!
 %! g = polyaffine (f, mu);
-%!
 %! x = linspace (-4, 4, 100);
-%!
-%! assert (polyval(f, x, [], mu), polyval (g, x), 1e-10);
+%! assert (polyval (f, x, [], mu), polyval (g, x), 1e-10);
 
-%!demo
-%! f = [1/5 4/5 -7/5 -2];
-%!
-%! g = polyaffine (f, [1, 1.2]);
-%!
-%! x = linspace (-4, 4, 100);
-%!
-%! plot(x, polyval (f, x), x, polyval (g, x));
-%!
-%! axis ([-4 4 -3 5]);
-%! grid ("on");
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -21,18 +21,17 @@
 ## @deftypefnx {Function File} {[@var{k}] =} polyder (@var{a}, @var{b})
 ## @deftypefnx {Function File} {[@var{q}, @var{d}] =} polyder (@var{b}, @var{a})
 ## Return the coefficients of the derivative of the polynomial whose
 ## coefficients are given by the vector @var{p}.  If a pair of polynomials
 ## is given, return the derivative of the product @math{@var{a}*@var{b}}.
 ## If two inputs and two outputs are given, return the derivative of the
 ## polynomial quotient @math{@var{b}/@var{a}}.  The quotient numerator is
 ## in @var{q} and the denominator in @var{d}.
-## @seealso{poly, polyint, polyreduce, roots, conv, deconv, residue,
-## filter, polygcd, polyval, polyvalm}
+## @seealso{polyint, polyval, polyreduce}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [q, d] = polyder (p, a)
 
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -16,21 +16,22 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{p} =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}, @var{mu}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## Return the coefficients of a polynomial @var{p}(@var{x}) of degree
-## @var{n} that minimizes the least-squares-error of the fit.
+## @var{n} that minimizes the least-squares-error of the fit to the points
+## @code{[@var{x}, @var{y}]}.
 ##
 ## The polynomial coefficients are returned in a row vector.
 ##
-## The second output is a structure containing the following fields:
+## The optional output @var{s} is a structure containing the following fields:
 ##
 ## @table @samp
 ## @item R
 ## Triangular factor R from the QR@tie{}decomposition.
 ##
 ## @item X
 ## The Vandermonde matrix used to compute the polynomial coefficients.
 ##
@@ -48,17 +49,17 @@
 ## statistical error limits of the predicted values.
 ##
 ## When the third output, @var{mu}, is present the
 ## coefficients, @var{p}, are associated with a polynomial in
 ## @var{xhat} = (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## Where @var{mu}(1) = mean (@var{x}), and @var{mu}(2) = std (@var{x}).
 ## This linear transformation of @var{x} improves the numerical
 ## stability of the fit.
-## @seealso{polyval, residue}
+## @seealso{polyval, polyaffine, roots, vander, zscore}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 13 December 1994
 ## Adapted-By: jwe
 
 function [p, s, mu] = polyfit (x, y, n)
 
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -18,34 +18,32 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{q} =} polygcd (@var{b}, @var{a})
 ## @deftypefnx {Function File} {@var{q} =} polygcd (@var{b}, @var{a}, @var{tol})
 ##
 ## Find the greatest common divisor of two polynomials.  This is equivalent
 ## to the polynomial found by multiplying together all the common roots.
 ## Together with deconv, you can reduce a ratio of two polynomials.
-## Tolerance defaults to @code{sqrt(eps)}.
+## The tolerance @var{tol} defaults to @code{sqrt(eps)}.
 ##
-## Note that this is a numerically unstable algorithm, and should not be used
-## on large polynomials.
+## @strong{Caution:} This is a numerically unstable algorithm and should not be used on large polynomials.
 ##
-## Example:
+## Example code:
 ##
 ## @example
 ## @group
 ## polygcd (poly(1:8), poly(3:12)) - poly(3:8)
 ## @result{} [ 0, 0, 0, 0, 0, 0, 0 ]
 ## deconv (poly(1:8), polygcd (poly(1:8), poly(3:12))) ...
 ##   - poly(1:2)
 ## @result{} [ 0, 0, 0 ]
 ## @end group
 ## @end example
-## @seealso{poly, polyint, polyder, polyreduce, roots, conv, deconv,
-## residue, filter, polyval, polyvalm}
+## @seealso{poly, roots, conv, deconv, residue}
 ## @end deftypefn
 
 function x = polygcd (b, a, tol)
 
   if (nargin == 2 || nargin == 3)
     if (nargin == 2)
       if (isa (a, "single") || isa (b, "single"))
         tol = sqrt (eps ("single"));
diff --git a/scripts/polynomial/polyint.m b/scripts/polynomial/polyint.m
--- a/scripts/polynomial/polyint.m
+++ b/scripts/polynomial/polyint.m
@@ -17,18 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} polyint (@var{p})
 ## @deftypefnx {Function File} {} polyint (@var{p}, @var{k})
 ## Return the coefficients of the integral of the polynomial whose
 ## coefficients are represented by the vector @var{p}.  The variable
 ## @var{k} is the constant of integration, which by default is set to zero.
-## @seealso{poly, polyder, polyreduce, roots, conv, deconv, residue,
-## filter, polyval, polyvalm}
+## @seealso{polyder, polyval}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function retval = polyint (p, k)
 
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -26,21 +26,19 @@
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ##    c(x) = c(1) * x^n + @dots{} + c(n) x + c(n+1)
 ## @end example
 ##
 ## @end ifnottex
-## and return it as a string or write it to the screen (if
-## @var{nargout} is zero).
-## @var{x} defaults to the string @code{"s"}.
-## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
-## filter, polyder, polyint}
+## and return it as a string or write it to the screen (if @var{nargout} is
+## zero).  @var{x} defaults to the string @code{"s"}.
+## @seealso{polyreduce}
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: May 1995
 ## Nov 1998: Correctly handles complex coefficients
 
 function y = polyout (c, x)
 
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -15,18 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyreduce (@var{c})
 ## Reduce a polynomial coefficient vector to a minimum number of terms by
 ## stripping off any leading zeros.
-## @seealso{poly, roots, conv, deconv, residue, filter, polyval,
-## polyvalm, polyder, polyint}
+## @seealso{polyout}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function p = polyreduce (c)
 
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -19,25 +19,25 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} polyval (@var{p}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} polyval (@var{p}, @var{x}, [], @var{mu})
 ## Evaluate the polynomial @var{p} at the specified values of @var{x}.  When
 ## @var{mu} is present, evaluate the polynomial for
 ## (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## If @var{x} is a vector or matrix, the polynomial is evaluated for each of
 ## the elements of @var{x}.
+## 
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s})
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s}, @var{mu})
 ## In addition to evaluating the polynomial, the second output
 ## represents the prediction interval, @var{y} +/- @var{dy}, which
 ## contains at least 50% of the future predictions.  To calculate the
 ## prediction interval, the structured variable @var{s}, originating
-## form `polyfit', must be present.
-## @seealso{polyfit, polyvalm, poly, roots, conv, deconv, residue, filter,
-## polyder, polyint}
+## from @code{polyfit}, must be supplied.
+## @seealso{polyvalm, polyaffine, polyfit, roots, poly}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [y, dy] = polyval (p, x, s = [], mu)
 
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -18,21 +18,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyvalm (@var{c}, @var{x})
 ## Evaluate a polynomial in the matrix sense.
 ##
 ## @code{polyvalm (@var{c}, @var{x})} will evaluate the polynomial in the
 ## matrix sense, i.e., matrix multiplication is used instead of element by
-## element multiplication as is used in polyval.
+## element multiplication as used in @code{polyval}.
 ##
 ## The argument @var{x} must be a square matrix.
-## @seealso{polyval, poly, roots, conv, deconv, residue, filter,
-## polyder, polyint}
+## @seealso{polyval, roots, poly}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = polyvalm (c, x)
 
diff --git a/scripts/polynomial/ppder.m b/scripts/polynomial/ppder.m
--- a/scripts/polynomial/ppder.m
+++ b/scripts/polynomial/ppder.m
@@ -12,20 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this software; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {ppd =} ppder (pp, m)
+## @deftypefn  {Function File} {ppd =} ppder (pp)
+## @deftypefnx {Function File} {ppd =} ppder (pp, m)
 ## Compute the piecewise @var{m}-th derivative of a piecewise polynomial
-## struct @var{pp}.  If @var{m} is omitted the first derivate is
-## calculated.
+## struct @var{pp}.  If @var{m} is omitted the first derivative is calculated.
 ## @seealso{mkpp, ppval, ppint}
 ## @end deftypefn
 
 function ppd = ppder (pp, m)
 
   if ((nargin < 1) || (nargin > 2))
     print_usage ();
   elseif (nargin == 1)
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -13,28 +13,23 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{yi} =} ppval (@var{pp}, @var{xi})
-## Evaluate piece-wise polynomial structure @var{pp} at the points @var{xi}.
+## Evaluate the piecewise polynomial structure @var{pp} at the points @var{xi}.
 ## If @var{pp} describes a scalar polynomial function, the result is an
 ## array of the same shape as @var{xi}.
 ## Otherwise, the size of the result is @code{[pp.dim, length(@var{xi})]} if
 ## @var{xi} is a vector, or @code{[pp.dim, size(@var{xi})]} if it is a
 ## multi-dimensional array.
-##
-##, the dimensions are permuted as
-## in interp1, to
-## @code{[pp.d, length(@var{xi})]} and @code{[pp.d, size(@var{xi})]}
-## respectively.
-## @seealso{mkpp, unmkpp, spline, pchip, interp1}
+## @seealso{mkpp, unmkpp, spline, pchip}
 ## @end deftypefn
 
 function yi = ppval (pp, xi)
 
   if (nargin != 2)
     print_usage ();
   endif
   if (! (isstruct (pp) && strcmp (pp.form, "pp")))
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -131,17 +131,17 @@
 ## @group
 ##     -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
 ##    ----- + ------- + ----- + s = --------------------------
 ##    (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## @seealso{poly, roots, conv, deconv, mpoles, polyval, polyder, polyint}
+## @seealso{mpoles, poly, roots, conv, deconv}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [r, p, k, e] = residue (b, a, varargin)
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -45,17 +45,17 @@
 ## p(x) = x^2 - 5.
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @example
 ## @group
 ## c = [1, 0, -5];
-## roots(c)
+## roots (c)
 ## @result{}  2.2361
 ## @result{} -2.2361
 ## @end group
 ## @end example
 ##
 ## Note that the true result is
 ## @tex
 ## $\pm \sqrt{5}$
@@ -65,17 +65,17 @@
 ## @end ifnottex
 ## which is roughly
 ## @tex
 ## $\pm 2.2361$.
 ## @end tex
 ## @ifnottex
 ## @math{+/- 2.2361}.
 ## @end ifnottex
-## @seealso{compan}
+## @seealso{poly, compan, fzero}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
 function r = roots (v)
 
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -15,60 +15,60 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} spline (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{yi} =} spline (@var{x}, @var{y}, @var{xi})
+## Return the cubic spline interpolant of points @var{x} and @var{y}.
+## 
+## When called with two arguments, return the piecewise polynomial @var{pp}
+## that may be used with @code{ppval} to evaluate the polynomial at specific
+## points.  When called with a third input argument, @code{spline} evaluates
+## the spline at the points @var{xi}.  The third calling form @code{spline
+## (@var{x}, @var{y}, @var{xi})} is equivalent to @code{ppval (spline
+## (@var{x}, @var{y}), @var{xi})}.
 ##
-## Return the cubic spline interpolant of @var{y} at points @var{x}.
-## If called with two arguments, @code{spline} returns the piecewise
-## polynomial @var{pp} that may later be used with @code{ppval} to
-## evaluate the polynomial at specific points.
-## If called with a third input argument, @code{spline} evaluates the
-## spline at the points @var{xi}.  There is an equivalence
-## between @code{ppval (spline (@var{x}, @var{y}), @var{xi})} and
-## @code{spline (@var{x}, @var{y}, @var{xi})}.
-##
-## The variable @var{x} must be a vector of length @var{n}, and @var{y}
-## can be either a vector or array.  In the case where @var{y} is a
-## vector, it can have a length of either @var{n} or @code{@var{n} + 2}.
-## If the length of @var{y} is @var{n}, then the 'not-a-knot' end
-## condition is used.  If the length of @var{y} is @code{@var{n} + 2},
-## then the first and last values of the vector @var{y} are the values
-## of the first derivative of the cubic spline at the end-points.
+## The variable @var{x} must be a vector of length @var{n}.  @var{y} can be
+## either a vector or array.  If @var{y} is a vector it must have a length of
+## either @var{n} or @code{@var{n} + 2}.  If the length of @var{y} is
+## @var{n}, then the "not-a-knot" end condition is used.  If the length of
+## @var{y} is @code{@var{n} + 2}, then the first and last values of the
+## vector @var{y} are the values of the first derivative of the cubic spline
+## at the endpoints.
 ##
 ## If @var{y} is an array, then the size of @var{y} must have the form
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
 ## @end ifnottex
 ## or
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n + 2].$$
 ## @end tex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n} + 2]}.
 ## @end ifnottex
-## The array is then reshaped internally to a matrix where the leading
+## The array is reshaped internally to a matrix where the leading
 ## dimension is given by
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
 ## and each row of this matrix is then treated separately.  Note that this
-## is exactly the opposite treatment than @code{interp1} and is done
-## for compatibility.
-## @seealso{ppval, mkpp, unmkpp}
+## is exactly opposite to @code{interp1} but is done for @sc{matlab}
+## compatibility.
+##
+## @seealso{pchip, ppval, mkpp, unmkpp}
 ## @end deftypefn
 
 ## This code is based on csape.m from octave-forge, but has been
 ## modified to use the sparse solver code in octave that itself allows
 ## special casing of tri-diagonal matrices, modified for NDArrays and
 ## for the treatment of vectors y 2 elements longer than x as complete
 ## splines.
 
diff --git a/scripts/polynomial/unmkpp.m b/scripts/polynomial/unmkpp.m
--- a/scripts/polynomial/unmkpp.m
+++ b/scripts/polynomial/unmkpp.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{p}, @var{n}, @var{k}, @var{d}] =} unmkpp (@var{pp})
 ##
 ## Extract the components of a piecewise polynomial structure @var{pp}.
-## These are as follows:
+## The components are:
 ##
 ## @table @asis
 ## @item @var{x}
 ## Sample points.
 ##
 ## @item @var{p}
 ## Polynomial coefficients for points in sample interval.  @code{@var{p}
 ## (@var{i}, :)} contains the coefficients for the polynomial over
@@ -38,17 +38,17 @@
 ##
 ## @item @var{k}
 ## Order of the polynomial plus 1.
 ##
 ## @item @var{d}
 ## Number of polynomials defined for each interval.
 ## @end table
 ##
-## @seealso{mkpp, ppval, spline}
+## @seealso{mkpp, ppval, spline, pchip}
 ## @end deftypefn
 
 function [x, P, n, k, d] = unmkpp (pp)
 
   if (nargin != 1)
     print_usage ();
   endif
   if (! (isstruct (pp) && isfield (pp, "form") && strcmp (pp.form, "pp")))
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{x} =} pcg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m1}, @var{m2}, @var{x0}, @dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}, @var{eigest}] =} pcg (@dots{})
 ##
-## Solves the linear system of equations @code{@var{A} * @var{x} = @var{b}}
+## Solve the linear system of equations @code{@var{A} * @var{x} = @var{b}}
 ## by means of the Preconditioned Conjugate Gradient iterative
 ## method.  The input arguments are
 ##
 ## @itemize
 ## @item
 ## @var{A} can be either a square (preferably sparse) matrix or a
 ## function handle, inline function or string containing the name
 ## of a function which computes @code{@var{A} * @var{x}}.  In principle
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{x} =} pcr (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m}, @var{x0}, @dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} pcr (@dots{})
 ##
-## Solves the linear system of equations @code{@var{A} * @var{x} = @var{b}}
+## Solve the linear system of equations @code{@var{A} * @var{x} = @var{b}}
 ## by means of the Preconditioned Conjugate Residuals iterative
 ## method.  The input arguments are
 ##
 ## @itemize
 ## @item
 ## @var{A} can be either a square (preferably sparse) matrix or a
 ## function handle, inline function or string containing the name
 ## of a function which computes @code{@var{A} * @var{x}}.  In principle
diff --git a/scripts/specfun/nchoosek.m b/scripts/specfun/nchoosek.m
--- a/scripts/specfun/nchoosek.m
+++ b/scripts/specfun/nchoosek.m
@@ -13,21 +13,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{c} =} nchoosek (@var{n}, @var{k})
+## @deftypefn  {Function File} {@var{c} =} nchoosek (@var{n}, @var{k})
+## @deftypefnx {Function File} {@var{c} =} nchoosek (@var{set}, @var{k})
 ##
-## Compute the binomial coefficient or all combinations of @var{n}.
-## If @var{n} is a scalar then, calculate the binomial coefficient
-## of @var{n} and @var{k}, defined as
+## Compute the binomial coefficient or all combinations of a set of items.
+##
+## If @var{n} is a scalar then calculate the binomial coefficient
+## of @var{n} and @var{k} which is defined as
 ## @tex
 ## $$
 ##  {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
 ##                = {n! \over k! (n-k)!}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
@@ -37,42 +39,68 @@
 ##  | n |    n (n-1) (n-2) @dots{} (n-k+1)       n!
 ##  |   |  = ------------------------- =  ---------
 ##  | k |               k!                k! (n-k)!
 ##  \   /
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
+## @noindent
+## This is the number of combinations of @var{n} items taken in groups of
+## size @var{k}.
 ##
-## If @var{n} is a vector generate all combinations of the elements
-## of @var{n}, taken @var{k} at a time, one row per combination.  The
-## resulting @var{c} has size @code{[nchoosek (length (@var{n}),
-## @var{k}), @var{k}]}.
+## If the first argument is a vector, @var{set}, then generate all
+## combinations of the elements of @var{set}, taken @var{k} at a time, with
+## one row per combination.  The result @var{c} has @var{k} columns and
+## @w{@code{nchoosek (length (@var{set}), @var{k})}} rows.
+##
+## For example:
+##
+## How many ways can three items be grouped into pairs?
 ##
-## @code{nchoosek} works only for non-negative integer arguments; use
-## @code{bincoeff} for non-integer scalar arguments and for using vector
-## arguments to compute many coefficients at once.
+## @example
+## @group
+## nchoosek (3, 2)
+##    @result{} 3
+## @end group
+## @end example
+##
+## What are the possible pairs?
 ##
-## @seealso{bincoeff}
+## @example
+## @group
+## nchoosek (1:3, 2)
+##    @result{}  1   2
+##        1   3
+##        2   3
+## @end group
+## @end example
+##
+## @code{nchoosek} works only for non-negative, integer arguments.  Use
+## @code{bincoeff} for non-integer and negative scalar arguments, or for
+## computing many binomial coefficients at once with vector inputs
+## for @var{n} or @var{k}.
+##
+## @seealso{bincoeff, perms}
 ## @end deftypefn
 
 ## Author: Rolf Fabian  <fabian@tu-cottbus.de>
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## Author: Jaroslav Hajek
 
 function A = nchoosek (v, k)
 
   if (nargin != 2
-      || !isnumeric(k) || !isnumeric(v)
-      || !isscalar(k) || (!isscalar(v) && !isvector(v)))
+      || !isnumeric (k) || !isnumeric (v)
+      || !isscalar (k) || ! (isscalar (v) || isvector (v)))
     print_usage ();
   endif
-  if ((isscalar(v) && v < k) || k < 0
-      || k != round(k) || any (v < 0 || v != round(v)))
+  if (k < 0 || k != fix (k)
+      || (isscalar (v) && (v < k || v < 0 || v != fix (v))))
     error ("nchoosek: args are non-negative integers with V not less than K");
   endif
 
   n = length (v);
 
   if (n == 1)
     ## Improve precision at next step.
     k = min (k, v-k);
@@ -106,13 +134,24 @@ function A = nchoosek (v, k)
       l = cumsum (l);
       l = [1, 1 + l(1:n-k)];
     endfor
     clear cA b;
     A = A.';
   endif
 endfunction
 
-%!warning (nchoosek(100,45));
-%!error (nchoosek(100,45.5));
-%!error (nchoosek(100,145));
-%!assert (nchoosek(80,10), bincoeff(80,10))
-%!assert (nchoosek(1:5,3),[1:3;1,2,4;1,2,5;1,3,4;1,3,5;1,4,5;2:4;2,3,5;2,4,5;3:5])
+
+%!assert (nchoosek (80,10), bincoeff (80,10))
+%!assert (nchoosek(1:5,3), [1:3;1,2,4;1,2,5;1,3,4;1,3,5;1,4,5;2:4;2,3,5;2,4,5;3:5])
+
+%% Test input validation
+%!warning nchoosek (100,45);
+%!error nchoosek ("100", 45)
+%!error nchoosek (100, "45")
+%!error nchoosek (100, ones (2,2))
+%!error nchoosek (repmat (100, [2 2]), 45)
+%!error nchoosek (100, -45)
+%!error nchoosek (100, 45.5)
+%!error nchoosek (100, 145)
+%!error nchoosek (-100, 45)
+%!error nchoosek (100.5, 45)
+
diff --git a/scripts/strings/validatestring.m b/scripts/strings/validatestring.m
--- a/scripts/strings/validatestring.m
+++ b/scripts/strings/validatestring.m
@@ -34,28 +34,28 @@
 ## substrings of each other.  Otherwise, an error will be raised because the
 ## expansion of @var{str} is ambiguous.  All comparisons are case insensitive.
 ##
 ## The additional inputs @var{funcname}, @var{varname}, and @var{position}
 ## are optional and will make any generated validation error message more
 ## specific.
 ##
 ## Examples:
+## @c Set example in small font to prevent overfull line
 ##
-## @example
+## @smallexample
 ## @group
 ## validatestring ("r", @{"red", "green", "blue"@})
-##    @result{} "red"
+## @result{} "red"
 ##
 ## validatestring ("b", @{"red", "green", "blue", "black"@})
-##    @result{} error: validatestring: multiple unique matches were found for 'b':
-##       blue, black
+## @result{} error: validatestring: multiple unique matches were found for 'b':
+##    blue, black
 ## @end group
-## @end example
-##
+## @end smallexample
 ## 
 ## @seealso{strcmp, strcmpi}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
 
 function str = validatestring (str, strarray, varargin)
 
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -18,45 +18,43 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} assert (@var{cond})
 ## @deftypefnx {Function File} {} assert (@var{cond}, @var{errmsg}, @dots{})
 ## @deftypefnx {Function File} {} assert (@var{cond}, @var{msg_id}, @var{errmsg}, @dots{})
 ## @deftypefnx {Function File} {} assert (@var{observed}, @var{expected})
 ## @deftypefnx {Function File} {} assert (@var{observed}, @var{expected}, @var{tol})
 ##
-## Produce an error if the condition is not met.  @code{assert} can be
-## called in three different ways.
+## Produce an error if the specified condition is not met.  @code{assert} can
+## be called in three different ways.
 ##
 ## @table @code
 ## @item assert (@var{cond})
 ## @itemx assert (@var{cond}, @var{errmsg}, @dots{})
 ## @itemx assert (@var{cond}, @var{msg_id}, @var{errmsg}, @dots{})
 ## Called with a single argument @var{cond}, @code{assert} produces an
-## error if @var{cond} is zero.  If called with a single argument a
-## generic error message.  With more than one argument, the additional
-## arguments are passed to the @code{error} function.
+## error if @var{cond} is zero.  When called with more than one argument the
+## additional arguments are passed to the @code{error} function.
 ##
 ## @item assert (@var{observed}, @var{expected})
 ## Produce an error if observed is not the same as expected.  Note that
-## observed and expected can be strings, scalars, vectors, matrices,
-## lists or structures.
+## @var{observed} and @var{expected} can be scalars, vectors, matrices,
+## strings, cell arrays, or structures.
 ##
-## @item assert(@var{observed}, @var{expected}, @var{tol})
-## Accept a tolerance when comparing numbers.
-## If @var{tol} is positive use it as an absolute tolerance, will produce an
-## error if
-## @code{abs(@var{observed} - @var{expected}) > abs(@var{tol})}.
-## If @var{tol} is negative use it as a relative tolerance, will produce an
-## error if
-## @code{abs(@var{observed} - @var{expected}) > abs(@var{tol} *
-## @var{expected})}.  If @var{expected} is zero @var{tol} will always be used as
-## an absolute tolerance.
+## @item assert (@var{observed}, @var{expected}, @var{tol})
+## Produce an error if observed is not the same as expected but equality
+## comparison for numeric data uses a tolerance @var{tol}.
+## If @var{tol} is positive then it is an absolute tolerance which will produce
+## an error if @code{abs(@var{observed} - @var{expected}) > abs(@var{tol})}.
+## If @var{tol} is negative then it is a relative tolerance which will produce
+## an error if @code{abs(@var{observed} - @var{expected}) >
+## abs(@var{tol} * @var{expected})}.  If @var{expected} is zero @var{tol} will
+## always be interpreted as an absolute tolerance.
 ## @end table
-## @seealso{test, fail}
+## @seealso{test, fail, error}
 ## @end deftypefn
 
 ## FIXME: Output throttling: don't print out the entire 100x100 matrix,
 ## but instead give a summary; don't print out the whole list, just
 ## say what the first different element is, etc.  To do this, make
 ## the message generation type specific.
 
 function assert (cond, varargin)
@@ -76,21 +74,21 @@ function assert (cond, varargin)
         error (varargin{:});
       endif
     endif
   else
     if (nargin < 2 || nargin > 3)
       print_usage ();
     endif
 
-    expected = varargin {1};
+    expected = varargin{1};
     if (nargin < 3)
       tol = 0;
     else
-      tol = varargin {2};
+      tol = varargin{2};
     endif
 
     if (exist ("argn") == 0)
       argn = " ";
     endif
 
     coda = "";
     iserror = 0;
@@ -113,18 +111,19 @@ function assert (cond, varargin)
       endif
 
     elseif (isstruct (expected))
       if (! isstruct (cond) || any (size (cond) != size (expected))
           || rows (fieldnames (cond)) != rows (fieldnames (expected)))
         iserror = 1;
       else
         try
-          empty = numel (cond) == 0;
-          normal = numel (cond) == 1;
+          #empty = numel (cond) == 0;
+          empty = isempty (cond);
+          normal = (numel (cond) == 1);
           for [v, k] = cond
             if (! isfield (expected, k))
               error ();
             endif
             if (empty)
               v = {};
             elseif (normal)
               v = {v};
@@ -141,17 +140,17 @@ function assert (cond, varargin)
     elseif (ndims (cond) != ndims (expected)
             || any (size (cond) != size (expected)))
       iserror = 1;
       coda = "Dimensions don't match";
 
     else
       if (nargin < 3)
         ## Without explicit tolerance, be more strict.
-        if (! strcmp(class (cond), class (expected)))
+        if (! strcmp (class (cond), class (expected)))
           iserror = 1;
           coda = cstrcat ("Class ", class (cond), " != ", class (expected));
         elseif (isnumeric (cond))
           if (issparse (cond) != issparse (expected))
             if (issparse (cond))
               iserror = 1;
               coda = "sparse != non-sparse";
             else
@@ -183,18 +182,18 @@ function assert (cond, varargin)
           coda = "NaNs don't match";
           ## Try to avoid problems comparing strange values like Inf+NaNi.
         elseif (any (isinf (A) != isinf (B))
                 || any (A(isinf (A) & ! isnan (A)) != B(isinf (B) & ! isnan (B))))
           iserror = 1;
           coda = "Infs don't match";
         else
           ## Check normal values.
-          A = A(finite (A));
-          B = B(finite (B));
+          A = A(isfinite (A));
+          B = B(isfinite (B));
           if (tol == 0)
             err = any (A != B);
             errtype = "values do not match";
           elseif (tol >= 0)
             err = max (abs (A - B));
             errtype = "maximum absolute error %g exceeds tolerance %g";
           else
             abserr = max (abs (A(B == 0)));
@@ -229,96 +228,110 @@ function assert (cond, varargin)
     if (! isempty (idx))
       str2 = str2 (idx(1):idx(end));
     endif
     msg = cstrcat ("assert ", in, " expected\n", str, "\nbut got\n", str2);
     if (! isempty (coda))
       msg = cstrcat (msg, "\n", coda);
     endif
     error ("%s", msg);
-    ## disp (msg);
-    ## error ("assertion failed");
   endif
+
 endfunction
 
-## empty
-%!assert([])
-%!assert(zeros(3,0),zeros(3,0))
-%!error assert(zeros(3,0),zeros(0,2))
-%!error assert(zeros(3,0),[])
-%!fail("assert(zeros(2,0,2),zeros(2,0))", "Dimensions don't match")
+
+## empty input
+%!assert ([])
+%!assert (zeros (3,0), zeros (3,0))
+%!error assert (zeros (3,0), zeros (0,2))
+%!error assert (zeros (3,0), [])
+%!error <Dimensions don't match> assert (zeros (2,0,2), zeros (2,0))
 
 ## conditions
-%!assert(isempty([]))
-%!assert(1)
-%!error assert(0)
-%!assert(ones(3,1))
-%!assert(ones(1,3))
-%!assert(ones(3,4))
-%!error assert([1,0,1])
-%!error assert([1;1;0])
-%!error assert([1,0;1,1])
+%!assert (isempty ([]))
+%!assert (1)
+%!error assert (0)
+%!assert (ones(3,1))
+%!assert (ones(1,3))
+%!assert (ones(3,4))
+%!error assert ([1,0,1])
+%!error assert ([1;1;0])
+%!error assert ([1,0;1,1])
+
+## scalars
+%!error assert (3, [3,3; 3,3])
+%!error assert ([3,3; 3,3], 3)
+%!assert (3, 3)
+%!assert (3+eps, 3, eps)
+%!assert (3, 3+eps, eps)
+%!error assert (3+2*eps, 3, eps)
+%!error assert (3, 3+2*eps, eps)
 
 ## vectors
-%!assert([1,2,3],[1,2,3]);
-%!assert([1;2;3],[1;2;3]);
-%!error assert([2;2;3],[1;2;3]);
-%!error assert([1,2,3],[1;2;3]);
-%!error assert([1,2],[1,2,3]);
-%!error assert([1;2;3],[1;2]);
-%!assert([1,2;3,4],[1,2;3,4]);
-%!error assert([1,4;3,4],[1,2;3,4])
-%!error assert([1,3;2,4;3,5],[1,2;3,4])
-
-## exceptional values
-%!assert([NaN, NA, Inf, -Inf, 1+eps, eps],[NaN, NA, Inf, -Inf, 1, 0],eps)
-%!error assert(NaN, 1)
-%!error assert(NA, 1)
-%!error assert(-Inf, Inf)
+%!assert ([1,2,3],[1,2,3]);
+%!assert ([1;2;3],[1;2;3]);
+%!error assert ([2;2;3],[1;2;3]);
+%!error assert ([1,2,3],[1;2;3]);
+%!error assert ([1,2],[1,2,3]);
+%!error assert ([1;2;3],[1;2]);
+%!assert ([1,2;3,4],[1,2;3,4]);
+%!error assert ([1,4;3,4],[1,2;3,4])
+%!error assert ([1,3;2,4;3,5],[1,2;3,4])
 
-## scalars
-%!error assert(3, [3,3; 3,3])
-%!error assert([3,3; 3,3], 3)
-%!assert(3, 3);
-%!assert(3+eps, 3, eps);
-%!assert(3, 3+eps, eps);
-%!error assert(3+2*eps, 3, eps);
-%!error assert(3, 3+2*eps, eps);
-
-## must give a little space for floating point errors on relative
-%!assert(100+100*eps, 100, -2*eps);
-%!assert(100, 100+100*eps, -2*eps);
-%!error assert(100+300*eps, 100, -2*eps);
-%!error assert(100, 100+300*eps, -2*eps);
-%!error assert(3, [3,3]);
-%!error assert(3,4);
+## must give a small tolerance for floating point errors on relative
+%!assert (100+100*eps, 100, -2*eps)
+%!assert (100, 100+100*eps, -2*eps)
+%!error assert (100+300*eps, 100, -2*eps)
+%!error assert (100, 100+300*eps, -2*eps)
+%!error assert (3, [3,3])
+%!error assert (3, 4)
 
 ## test relative vs. absolute tolerances
 %!test  assert (0.1+eps, 0.1,  2*eps);  # accept absolute
 %!error assert (0.1+eps, 0.1, -2*eps);  # fail relative
 %!test  assert (100+100*eps, 100, -2*eps);  # accept relative
 %!error assert (100+100*eps, 100,  2*eps);  # fail absolute
 
+## exceptional values
+%!assert ([NaN, NA, Inf, -Inf, 1+eps, eps], [NaN, NA, Inf, -Inf, 1, 0], eps)
+%!error assert (NaN, 1)
+%!error assert (NA, 1)
+%!error assert (-Inf, Inf)
+
+## strings
+%!assert ("dog", "dog")
+%!error assert ("dog", "cat")
+%!error assert ("dog", 3)
+%!error assert (3, "dog")
+
 ## structures
 %!shared x,y
 %! x.a = 1; x.b=[2, 2];
 %! y.a = 1; y.b=[2, 2];
-%!assert (x,y)
+%!assert (x, y)
 %!test y.b=3;
-%!error assert (x,y)
-%!error assert (3, x);
-%!error assert (x, 3);
+%!error assert (x, y)
+%!error assert (3, x)
+%!error assert (x, 3)
 %!test
 %! # Empty structures
 %! x = resize (x, 0, 1);
 %! y = resize (y, 0, 1);
 %! assert (x, y);
 
-## strings
-%!assert("dog","dog")
-%!error assert("dog","cat")
-%!error assert("dog",3);
-%!error assert(3,"dog");
+## cell arrays
+%!test
+%! x = {[3], [1,2,3]; 100+100*eps, "dog"};
+%! y = x;
+%! assert (x, y);
+%! y = x; y(1,1) = [2];
+%! fail ("assert (x, y)");
+%! y = x; y(1,2) = [0, 2, 3];
+%! fail ("assert (x, y)");
+%! y = x; y(2,1) = 101;
+%! fail ("assert (x, y)");
+%! y = x; y(2,2) = "cat";
+%! fail ("assert (x, y)");
 
-## check input validation
+%% Test input validation
 %!error assert
-%!error assert (1,2,3,4,5)
+%!error assert (1,2,3,4)
 
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -57,17 +57,21 @@ endfunction
 function run_all_demos (directory)
   dirinfo = dir (directory);
   flist = {dirinfo.name};
   for i = 1:numel (flist)
     f = flist{i};
     if (length (f) > 2 && strcmp (f((end-1):end), ".m"))
       f = fullfile (directory, f);
       if (has_demos (f))
-        demo (f);
+        try
+          demo (f);
+        catch
+          printf ("error: %s\n\n", lasterror().message)
+        end_try_catch
         if (i != numel (flist))
           input ("Press <enter> to continue: ", "s");
         endif
       endif
     endif
   endfor
 endfunction
 
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -25,17 +25,17 @@
 ## @var{d} is a serial date number or a date string.
 ##
 ## If the string @var{format} is not present or is equal to "short" then
 ## @var{s} will contain the abbreviated name of the weekday.  If @var{format}
 ## is "long" then @var{s} will contain the full name.
 ##
 ## Table of return values based on @var{format}:
 ##
-## @multitable @columnfractions .06 .13 .13
+## @multitable @columnfractions .06 .13 .16
 ## @headitem @var{n} @tab "short" @tab "long"
 ## @item 1 @tab Sun @tab Sunday
 ## @item 2 @tab Mon @tab Monday
 ## @item 3 @tab Tue @tab Tuesday
 ## @item 4 @tab Wed @tab Wednesday
 ## @item 5 @tab Thu @tab Thursday
 ## @item 6 @tab Fri @tab Friday
 ## @item 7 @tab Sat @tab Saturday
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -30,16 +30,19 @@ To initialize:
 */
 
 // PKG_ADD: register_graphics_toolkit ("fltk");
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "defun-dld.h"
+#include "error.h"
+
 #if defined (HAVE_FLTK)
 
 #include <map>
 #include <set>
 #include <sstream>
 #include <iostream>
 
 #ifdef WIN32
@@ -64,18 +67,16 @@ To initialize:
 // conflicts with Octave's Complex typedef.  We don't need the X11
 // Complex definition in this file, so remove it before including Octave
 // headers which may require Octave's Complex typedef.
 #undef Complex
 
 #include "cmd-edit.h"
 #include "lo-ieee.h"
 
-#include "defun-dld.h"
-#include "error.h"
 #include "file-ops.h"
 #include "gl-render.h"
 #include "gl2ps-renderer.h"
 #include "graphics.h"
 #include "parse.h"
 #include "sysdep.h"
 #include "toplev.h"
 #include "variables.h"
@@ -1999,16 +2000,18 @@ DEFUN_DLD (__fltk_maxtime__, args, ,"")
         fltk_maxtime = args(0).double_value ();
       else
         error ("argument must be a real scalar");
     }
 
   return retval;
 }
 
+#endif
+
 // FIXME -- This function should be abstracted and made potentially
 // available to all graphics toolkits.  This suggests putting it in
 // graphics.cc as is done for drawnow() and having the master
 // mouse_wheel_zoom function call fltk_mouse_wheel_zoom.  The same
 // should be done for gui_mode and fltk_gui_mode.  For now (2011.01.30),
 // just changing function names and docstrings.
 
 DEFUN_DLD (mouse_wheel_zoom, args, ,
@@ -2016,27 +2019,32 @@ DEFUN_DLD (mouse_wheel_zoom, args, ,
 @deftypefn  {Built-in Function} {@var{speed} =} mouse_wheel_zoom ()\n\
 @deftypefnx {Built-in Function} {} mouse_wheel_zoom (@var{speed})\n\
 Query or set the mouse wheel zoom factor.\n\
 \n\
 This function is currently implemented only for the FLTK graphics toolkit.\n\
 @seealso{gui_mode}\n\
 @end deftypefn")
 {
+#if defined (HAVE_FLTK)
   octave_value retval = wheel_zoom_speed;
 
   if (args.length () == 1)
     {
       if (args(0).is_real_scalar ())
         wheel_zoom_speed = args(0).double_value ();
       else
         error ("mouse_wheel_zoom: SPEED must be a real scalar");
     }
 
   return retval;
+#else 
+  error ("mouse_wheel_zoom: not available without OpenGL and FLTK libraries");
+  return octave_value ();
+#endif
 }
 
 DEFUN_DLD (gui_mode, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{mode} =} gui_mode ()\n\
 @deftypefnx {Built-in Function} {} gui_mode (@var{mode})\n\
 Query or set the GUI mode for the current graphics toolkit.\n\
 The @var{mode} argument can be one of the following strings:\n\
@@ -2050,16 +2058,17 @@ Allows rotating and zooming of current a
 @item 'none'\n\
 Mouse inputs have no effect.\n\
 @end table\n\
 \n\
 This function is currently implemented only for the FLTK graphics toolkit.\n\
 @seealso{mouse_wheel_zoom}\n\
 @end deftypefn")
 {
+#if defined (HAVE_FLTK)
   caseless_str mode_str;
 
   if (gui_mode == pan_zoom)
     mode_str = "2d";
   else if (gui_mode == rotate_zoom)
     mode_str = "3d";
   else
     mode_str = "none";
@@ -2084,11 +2093,14 @@ This function is currently implemented o
       else
         failed = true;
     }
 
   if (failed)
     error ("MODE must be one of the strings: \"2D\", \"3D\", or \"none\"");
 
   return octave_value (mode_str);
+#else
+  error ("mouse_wheel_zoom: not available without OpenGL and FLTK libraries");
+  return octave_value ();
+#endif
 }
 
-#endif
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -307,18 +307,18 @@ update_index (Array<int>& idx, const dim
       idx (j) = i % dv (j);
       i = i / dv (j);
     }
 }
 
 DEFUN_DLD (bsxfun, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
-The binary singleton expansion function applier does what its name\n\
-suggests: applies a binary function @var{f} element-by-element to two\n\
+The binary singleton expansion function applier performs broadcasting,\n\
+that is, applies a binary function @var{f} element-by-element to two\n\
 array arguments @var{A} and @var{B}, and expands as necessary\n\
 singleton dimensions in either input argument.  @var{f} is a function\n\
 handle, inline function, or string containing the name of the function\n\
 to evaluate.  The function @var{f} must be capable of accepting two\n\
 column-vector arguments of equal length, or one column vector argument\n\
 and a scalar.\n\
 \n\
 The dimensions of @var{A} and @var{B} must be equal or singleton.  The\n\
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <string>
 #include <vector>
 #include <list>
 #include <memory>
 
+#include "caseless-str.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "oct-map.h"
 #include "defun-dld.h"
 #include "parse.h"
 #include "variables.h"
@@ -194,28 +195,27 @@ try_cellfun_internal_ops (const octave_v
         error ("cellfun: not enough arguments for \"isclass\"");
     }
 
   return retval;
 }
 
 static void
 get_mapper_fun_options (const octave_value_list& args, int& nargin,
-                     bool& uniform_output, octave_value& error_handler)
+                        bool& uniform_output, octave_value& error_handler)
 {
   while (nargin > 3 && args(nargin-2).is_string ())
     {
-      std::string arg = args(nargin-2).string_value ();
+      caseless_str arg = args(nargin-2).string_value ();
+
+      size_t compare_len = std::max (arg.length (), static_cast<size_t> (2));
 
-      std::transform (arg.begin (), arg.end (),
-                      arg.begin (), tolower);
-
-      if (arg == "uniformoutput")
+      if (arg.compare ("uniformoutput", compare_len))
         uniform_output = args(nargin-1).bool_value();
-      else if (arg == "errorhandler")
+      else if (arg.compare ("errorhandler", compare_len))
         {
           if (args(nargin-1).is_function_handle ()
               || args(nargin-1).is_inline_function ())
             {
               error_handler = args(nargin-1);
             }
           else if (args(nargin-1).is_string ())
             {
@@ -360,16 +360,31 @@ of the element that caused the error.  F
 @example\n\
 @group\n\
 function y = foo (s, x), y = NaN; endfunction\n\
 cellfun (\"factorial\", @{-1,2@}, 'ErrorHandler', @@foo)\n\
 @result{} ans = [NaN 2]\n\
 @end group\n\
 @end example\n\
 \n\
+Use @code{cellfun} intelligently.  The @code{cellfun} function is a\n\
+useful tool for avoiding loops.  It is often used with anonymous\n\
+function handles; however, calling an anonymous function involves an\n\
+overhead quite comparable to the overhead of an m-file function.\n\
+Passing a handle to a built-in function is faster, because the\n\
+interpreter is not involved in the internal loop.  For example:\n\
+\n\
+@example\n\
+@group\n\
+a = @{@dots{}@}\n\
+v = cellfun (@@(x) det(x), a); # compute determinants\n\
+v = cellfun (@@det, a); # faster\n\
+@end group\n\
+@end example\n\
+\n\
 @seealso{arrayfun, structfun, spfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   int nargout1 = (nargout < 1 ? 1 : nargout);
 
   if (nargin < 2)
@@ -691,59 +706,59 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
   else
     error ("cellfun: argument NAME must be a string or function handle");
 
   return retval;
 }
 
 /*
 
-%!function r = f11 (x)
+%!function r = __f11 (x)
 %!  global __cellfun_test_num_outputs__
 %!  __cellfun_test_num_outputs__ = nargout;
 %!  r = x;
-%! endfunction
+%!endfunction
 
-%!function f01 (x)
+%!function __f01 (x)
 %!  global __cellfun_test_num_outputs__
 %!  __cellfun_test_num_outputs__ = nargout;
-%! endfunction
+%!endfunction
 
 %!test
 %! global __cellfun_test_num_outputs__
-%! cellfun (@f11, {1});
+%! cellfun (@__f11, {1});
 %! assert (__cellfun_test_num_outputs__, 0)
-%! x = cellfun (@f11, {1});
+%! x = cellfun (@__f11, {1});
 %! assert (__cellfun_test_num_outputs__, 1)
 
 %!test
 %! global __cellfun_test_num_outputs__
-%! cellfun (@f01, {1});
+%! cellfun (@__f01, {1});
 %! assert (__cellfun_test_num_outputs__, 0)
 
-%!error x = cellfun (@f01, {1, 2});
+%!error x = cellfun (@__f01, {1, 2});
 
 %!test
-%! assert (cellfun (@f11, {1, 2}), [1, 2])
-%! assert (cellfun (@f11, {1, 2}, 'uniformoutput', false), {1, 2})
+%! assert (cellfun (@__f11, {1, 2}), [1, 2])
+%! assert (cellfun (@__f11, {1, 2}, 'uniformoutput', false), {1, 2})
 
 %!test
 %!  [a,b] = cellfun (@(x) x, cell (2, 0));
 %!  assert (a, zeros (2, 0));
 %!  assert (b, zeros (2, 0));
 
 %!test
 %!  [a,b] = cellfun (@(x) x, cell (2, 0), "uniformoutput", false);
 %!  assert (a, cell (2, 0));
 %!  assert (b, cell (2, 0));
 
 %% Test function to check the "Errorhandler" option
-%!function [z] = cellfunerror (S, varargin)
-%!    z = S;
-%!  endfunction
+%!function [z] = __cellfunerror (S, varargin)
+%!  z = S;
+%!endfunction
 
 %% First input argument can be a string, an inline function,
 %% a function_handle or an anonymous function
 %!test
 %!  A = cellfun ("islogical", {true, 0.1, false, i*2});
 %!  assert (A, [true, false, true, false]);
 %!test
 %!  A = cellfun (inline ("islogical (x)", "x"), {true, 0.1, false, i*2});
@@ -810,25 +825,25 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!test %% Three ouptut arguments of same type
 %!  [A, B, C] = cellfun (@find, {true, false; false, true}, \
 %!    "UniformOutput", false);
 %!  assert (isequal (A, {true, []; [], true}));
 %!  assert (isequal (B, {true, []; [], true}));
 %!  assert (isequal (C, {true, []; [], true}));
 %!test
 %!  A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 
 %% Input arguments can be of type cell array of numeric
 %!test
@@ -844,26 +859,26 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!  assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %!  [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
 %!  assert (isequal (A, {true, true; [], true}));
 %!  assert (isequal (B, {true, true; [], true}));
 %!  assert (isequal (C, {10, 11; [], 12}));
 %!test
 %!  A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  B = isfield (A(1), "message") && isfield (A(1), "index");
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  B = isfield (A(1), "message") && isfield (A(1), "index");
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell arrays of character or strings
@@ -872,25 +887,25 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!test
 %!  A = cellfun (@(x,y) x>y, {"a"; "f"}, {"c"; "d"}, "UniformOutput", true);
 %!  assert (A, [false; true]);
 %!test
 %!  A = cellfun (@(x,y) x:y, {"a", "d"}, {"c", "f"}, "UniformOutput", false);
 %!  assert (A, {"abc", "def"});
 %!test
 %!  A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Structures cannot be handled by cellfun
 %!error
@@ -906,25 +921,25 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!    "UniformOutput", true);
 %!  assert (A, [1; 0], 1e-16);
 %!test
 %!  A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}}, \
 %!    "UniformOutput", false);
 %!  assert (A, {true, false});
 %!test
 %!  A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell array of structure arrays
 %!test
@@ -939,26 +954,26 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!test
 %!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
 %!  A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, \
 %!    "UniformOutput", false);
 %!  assert (A, {true});
 %!test
 %!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
 %!  A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
 %!  A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 
 %% A lot of other tests
 %!error(cellfun(1))
@@ -1037,21 +1052,21 @@ function @var{func} must return a single
 concatenated into the return value and is of type matrix.  Otherwise,\n\
 if that parameter is set to @code{false}, then the outputs are\n\
 concatenated in a cell array.  For example:\n\
 \n\
 @example\n\
 @group\n\
 arrayfun (@@(x,y) x:y, \"abc\", \"def\", \"UniformOutput\", false)\n\
 @result{} ans =\n\
-@{\n\
-  [1,1] = abcd\n\
-  [1,2] = bcde\n\
-  [1,3] = cdef\n\
-@}\n\
+    @{\n\
+      [1,1] = abcd\n\
+      [1,2] = bcde\n\
+      [1,3] = cdef\n\
+    @}\n\
 @end group\n\
 @end example\n\
 \n\
 If more than one output arguments are given then the named function\n\
 must return the number of return values that also are expected, for\n\
 example:\n\
 \n\
 @example\n\
@@ -1094,22 +1109,22 @@ respectively, the error identifier, the 
 the array elements that caused the error.  The size of the output\n\
 argument of @var{errfunc} must have the same size as the output\n\
 argument of @var{func}, otherwise a real error is thrown.  For\n\
 example:\n\
 \n\
 @example\n\
 @group\n\
 function y = ferr (s, x), y = \"MyString\"; endfunction\n\
-arrayfun (@@str2num, [1234], \\n\
-          \"UniformOutput\", false, \"ErrorHandler\", @@ferr)\n\
+arrayfun (@@str2num, [1234],\n\
+           \"UniformOutput\", false, \"ErrorHandler\", @@ferr)\n\
 @result{} ans =\n\
-@{\n\
- [1,1] = MyString\n\
-@}\n\
+    @{\n\
+     [1,1] = MyString\n\
+    @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{spfun, cellfun, structfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
@@ -1415,53 +1430,53 @@ arrayfun (@@str2num, [1234], \\n\
     }
   else
     error ("arrayfun: argument NAME must be a string or function handle");
 
   return retval;
 }
 
 /*
-%!function r = f11 (x)
+%!function r = __f11 (x)
 %!  global __arrayfun_test_num_outputs__
 %!  __arrayfun_test_num_outputs__ = nargout;
 %!  r = x;
-%! endfunction
+%!endfunction
 
-%!function f01 (x)
+%!function __f01 (x)
 %!  global __arrayfun_test_num_outputs__
 %!  __arrayfun_test_num_outputs__ = nargout;
-%! endfunction
+%!endfunction
 
 %!test
 %! global __arrayfun_test_num_outputs__
-%! arrayfun (@f11, {1});
+%! arrayfun (@__f11, {1});
 %! assert (__arrayfun_test_num_outputs__, 0)
-%! x = arrayfun (@f11, {1});
+%! x = arrayfun (@__f11, {1});
 %! assert (__arrayfun_test_num_outputs__, 1)
 
 %!test
 %! global __arrayfun_test_num_outputs__
-%! arrayfun (@f01, {1});
+%! arrayfun (@__f01, {1});
 %! assert (__arrayfun_test_num_outputs__, 0)
 
-%!error x = arrayfun (@f01, [1, 2]);
+%!error x = arrayfun (@__f01, [1, 2]);
 
 %!test
-%! assert (arrayfun (@f11, [1, 2]), [1, 2])
-%! assert (arrayfun (@f11, [1, 2], 'uniformoutput', false), {1, 2});
-%! assert (arrayfun (@f11, {1, 2}), {1, 2})
-%! assert (arrayfun (@f11, {1, 2}, 'uniformoutput', false), {{1}, {2}});
+%! assert (arrayfun (@__f11, [1, 2]), [1, 2])
+%! assert (arrayfun (@__f11, [1, 2], 'uniformoutput', false), {1, 2});
+%! assert (arrayfun (@__f11, {1, 2}), {1, 2})
+%! assert (arrayfun (@__f11, {1, 2}, 'uniformoutput', false), {{1}, {2}});
 
 %!assert (arrayfun (@ones, 1, [2,3], 'uniformoutput', false), {[1,1], [1,1,1]});
 
 %% Test function to check the "Errorhandler" option
-%!function [z] = arrayfunerror (S, varargin)
+%!function [z] = __arrayfunerror (S, varargin)
 %!      z = S;
-%!    endfunction
+%!endfunction
 %% First input argument can be a string, an inline function, a
 %% function_handle or an anonymous function
 %!test
 %!  arrayfun (@isequal, [false, true], [true, true]); %% No output argument
 %!error
 %!  arrayfun (@isequal); %% One or less input arguments
 %!test
 %!  A = arrayfun ("isequal", [false, true], [true, true]);
@@ -1506,25 +1521,25 @@ arrayfun (@@str2num, [1234], \\n\
 %!  A = arrayfun (@(x) x, [false, true, false, true], "UniformOutput", false);
 %!  assert (A, {false, true, false, true});
 %!test %% Three ouptut arguments of same type
 %!  [A, B, C] = arrayfun (@find, [true, false; false, true], "UniformOutput", false);
 %!  assert (isequal (A, {true, []; [], true}));
 %!  assert (isequal (B, {true, []; [], true}));
 %!  assert (isequal (C, {true, []; [], true}));
 %!test
-%!  A = arrayfun (@(x,y) array2str (x,y), true, true, "ErrorHandler", @arrayfunerror);
+%!  A = arrayfun (@(x,y) array2str (x,y), true, true, "ErrorHandler", @__arrayfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = arrayfun (@(x,y) array2str (x,y), true, true, \
-%!                "UniformOutput", true, "ErrorHandler", @arrayfunerror);
+%!                "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 
 %% Input arguments can be of type numeric
 %!test
@@ -1538,26 +1553,26 @@ arrayfun (@@str2num, [1234], \\n\
 %!  assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %!  assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %!  [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
 %!  assert (isequal (A, {true, true; [], true}));
 %!  assert (isequal (B, {true, true; [], true}));
 %!  assert (isequal (C, {10, 11; [], 12}));
 %!test
-%!  A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, "ErrorHandler", @arrayfunerror);
+%!  A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, "ErrorHandler", @__arrayfunerror);
 %!  B = isfield (A(1), "message") && isfield (A(1), "index");
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, \
-%!                "UniformOutput", true, "ErrorHandler", @arrayfunerror);
+%!                "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %!  B = isfield (A(1), "message") && isfield (A(1), "index");
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type character or strings
@@ -1566,17 +1581,17 @@ arrayfun (@@str2num, [1234], \\n\
 %!  assert (A, [false, true, false, true, true, true]);
 %!test
 %!  A = arrayfun (@(x,y) x>y, ["a"; "f"], ["c"; "d"], "UniformOutput", true);
 %!  assert (A, [false; true]);
 %!test
 %!  A = arrayfun (@(x,y) x:y, ["a", "d"], ["c", "f"], "UniformOutput", false);
 %!  assert (A, {"abc", "def"});
 %! %#!test
-%!   A = arrayfun (@(x,y) cell2str(x,y), ["a", "d"], ["c", "f"], "ErrorHandler", @arrayfunerror);
+%!   A = arrayfun (@(x,y) cell2str(x,y), ["a", "d"], ["c", "f"], "ErrorHandler", @__arrayfunerror);
 %!   B = isfield (A(1), "identifier") && isfield (A(1), "message") && isfield (A(1), "index");
 %!   assert (B, true);
 
 %% Input arguments can be of type structure
 %!test
 %!  a = struct ("a", 1.1, "b", 4.2); b = struct ("a", 3.1, "b", 2);
 %!  A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b);
 %!  assert (A, true);
@@ -1584,25 +1599,25 @@ arrayfun (@@str2num, [1234], \\n\
 %!  a = struct ("a", 1.1, "b", 4.2); b = struct ("a", 3.1, "b", 2);
 %!  A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b, "UniformOutput", true);
 %!  assert (A, true);
 %!test
 %!  a = struct ("a", 1.1, "b", 4.2); b = struct ("a", 3.1, "b", 2);
 %!  A = arrayfun (@(x,y) x.a:y.a, a, b, "UniformOutput", false);
 %!  assert (isequal (A, {[1.1, 2.1, 3.1]}));
 %!test
-%!  A = arrayfun (@(x) mat2str(x), "a", "ErrorHandler", @arrayfunerror);
+%!  A = arrayfun (@(x) mat2str(x), "a", "ErrorHandler", @__arrayfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = arrayfun (@(x) mat2str(x), "a", "UniformOutput", true, \
-%!                "ErrorHandler", @arrayfunerror);
+%!                "ErrorHandler", @__arrayfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 
 %% Input arguments can be of type cell array
 %!test
@@ -1610,25 +1625,25 @@ arrayfun (@@str2num, [1234], \\n\
 %!  assert (A, [true, false]);
 %!test
 %!  A = arrayfun (@(x,y) x{1} < y{1}, {1.1; 4.2}, {3.1; 2}, "UniformOutput", true);
 %!  assert (A, [true; false]);
 %!test
 %!  A = arrayfun (@(x,y) x{1} < y{1}, {1.1, 4.2}, {3.1, 2}, "UniformOutput", false);
 %!  assert (A, {true, false});
 %!test
-%!  A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @arrayfunerror);
+%!  A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @__arrayfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test
 %!  A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, \
-%!                "UniformOutput", true, "ErrorHandler", @arrayfunerror);
+%!                "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 */
 
 static void
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -495,28 +495,31 @@ parameters for @code{dassl}.\n\
 %%
 %%    y1' = -y2,   y1(0) = 1
 %%    y2' =  y1,   y2(0) = 0
 %%
 %% Solution
 %%
 %%    y1(t) = cos(t)
 %%    y2(t) = sin(t)
-%!function res = f (x, xdot, t)
+
+%!function res = __f (x, xdot, t)
 %!  res = [xdot(1)+x(2); xdot(2)-x(1)];
+%!endfunction
+
 %!test
 %!
 %! x0 = [1; 0];
 %! xdot0 = [0; 1];
 %! t = (0:1:10)';
 %!
 %! tol = 100 * dassl_options ("relative tolerance");
 %!
 %!
-%! [x, xdot] = dassl ("f", x0, xdot0, t);
+%! [x, xdot] = dassl ("__f", x0, xdot0, t);
 %!
 %! y = [cos(t), sin(t)];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
 %% dassl-2.m
 %%
 %% Test dassl() function
@@ -532,28 +535,31 @@ parameters for @code{dassl}.\n\
 %%   x1' + 10*x1 = 0,   x1(0) = 1
 %%   x1  + x2    = 1,   x2(0) = 0
 %%
 %%
 %% Solution
 %%
 %%  x1(t) = exp(-10*t)
 %%  x2(t) = 1 - x(1)
-%!function res = f (x, xdot, t)
+
+%!function res = __f (x, xdot, t)
 %!  res = [xdot(1)+10*x(1); x(1)+x(2)-1];
+%!endfunction
+
 %!test
 %!
 %! x0 = [1; 0];
 %! xdot0 = [-10; 10];
 %! t = (0:0.2:1)';
 %!
 %! tol = 500 * dassl_options ("relative tolerance");
 %!
 %!
-%! [x, xdot] = dassl ("f", x0, xdot0, t);
+%! [x, xdot] = dassl ("__f", x0, xdot0, t);
 %!
 %! y = [exp(-10*t), 1-exp(-10*t)];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
 %!test
 %! dassl_options ("absolute tolerance", eps);
 %! assert(dassl_options ("absolute tolerance") == eps);
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -487,56 +487,56 @@ parameters for @code{lsode}.\n\
 %%
 %%    y1' = -y2,   y1(0) = 1
 %%    y2' =  y1,   y2(0) = 0
 %%
 %% Solution
 %%
 %%    y1(t) = cos(t)
 %%    y2(t) = sin(t)
-%!function xdot = f (x, t)
+%!function xdot = __f (x, t)
 %!  xdot = [-x(2); x(1)];
 %!test
 %!
 %! x0 = [1; 0];
 %! xdot0 = [0; 1];
 %! t = (0:1:10)';
 %!
 %! tol = 500 * lsode_options ("relative tolerance");
 %!
 %!
-%! x = lsode ("f", x0, t);
+%! x = lsode ("__f", x0, t);
 %!
 %! y = [cos(t), sin(t)];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
-%!function xdotdot = f (x, t)
+%!function xdotdot = __f (x, t)
 %!  xdotdot = [x(2); -x(1)];
 %!test
 %!
 %! x0 = [1; 0];
 %! t = [0; 2*pi];
 %! tol = 100 * dassl_options ("relative tolerance");
 %!
-%! x = lsode ("f", x0, t);
+%! x = lsode ("__f", x0, t);
 %!
 %! y = [1, 0; 1, 0];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
-%!function xdot = f (x, t)
+%!function xdot = __f (x, t)
 %!  xdot = x;
 %!test
 %!
 %! x0 = 1;
 %! t = [0; 1];
 %! tol = 100 * dassl_options ("relative tolerance");
 %!
-%! x = lsode ("f", x0, t);
+%! x = lsode ("__f", x0, t);
 %!
 %! y = [1; e];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
 %!test
 %! lsode_options ("absolute tolerance", eps);
 %! assert(lsode_options ("absolute tolerance") == eps);
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -495,17 +495,17 @@ x = @var{R} \\ @var{C}\n\
 %! [qe, re, pe] = qr (a, 0);
 %!
 %! assert (q * r, a * p, sqrt (eps));
 %! assert (qe * re, a(:, pe), sqrt (eps));
 
 %!error <Invalid call to qr> qr ();
 %!error <Invalid call to qr> qr ([1, 2; 3, 4], 0, 2);
 
-%!function retval = testqr (q, r, a, p)
+%!function retval = __testqr (q, r, a, p)
 %!  tol = 100*eps (class(q));
 %!  retval = 0;
 %!  if (nargin == 3)
 %!    n1 = norm (q*r-a);
 %!    n2 = norm (q'*q-eye(columns(q)));
 %!    retval = (n1 < tol && n2 < tol);
 %!  else
 %!    n1 = norm (q'*q-eye(columns(q)));
@@ -513,58 +513,60 @@ x = @var{R} \\ @var{C}\n\
 %!    if (isvector (p))
 %!      n2 = norm (q*r-a(:,p));
 %!      retval = (retval && n2 < tol);
 %!    else
 %!      n2 = norm (q*r - a*p);
 %!      retval = (retval && n2 < tol);
 %!    endif
 %!  endif
+%!endfunction
+
 %!test
 %!
 %! t = ones (24, 1);
 %! j = 1;
 %!
 %! if false # eliminate big matrix tests
 %!   a = rand(5000,20);
-%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %!   a = a+1i*eps;
-%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %! endif
 %!
 %! a = [ ones(1,15); sqrt(eps)*eye(15) ];
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = a+1i*eps;
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = [ ones(1,15); sqrt(eps)*eye(15) ];
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = a+1i*eps;
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = [
 %! 611   196  -192   407    -8   -52   -49    29
 %! 196   899   113  -192   -71   -43    -8   -44
 %! -192   113   899   196    61    49     8    52
 %! 407  -192   196   611     8    44    59   -23
 %! -8   -71    61     8   411  -599   208   208
 %! -52   -43    49    44  -599   411   208   208
@@ -620,51 +622,51 @@ x = @var{R} \\ @var{C}\n\
 
 %!test
 %!
 %! t = ones (24, 1);
 %! j = 1;
 %!
 %! if false # eliminate big matrix tests
 %!   a = rand(5000,20);
-%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %!   a = a+1i*eps('single');
-%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %! endif
 %!
 %! a = [ ones(1,15); sqrt(eps('single'))*eye(15) ];
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = a+1i*eps('single');
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = [ ones(1,15); sqrt(eps('single'))*eye(15) ];
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = a+1i*eps('single');
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = [
 %! 611   196  -192   407    -8   -52   -49    29
 %! 196   899   113  -192   -71   -43    -8   -44
 %! -192   113   899   196    61    49     8    52
 %! 407  -192   196   611     8    44    59   -23
 %! -8   -71    61     8   411  -599   208   208
 %! -52   -43    49    44  -599   411   208   208
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -469,39 +469,43 @@ variable by routines @code{dblquad} and 
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
-%!function y = f (x)
+%!function y = __f (x)
 %! y = x + 1;
+%!endfunction
+
 %!test
-%! [v, ier, nfun, err] = quad ("f", 0, 5);
+%! [v, ier, nfun, err] = quad ("__f", 0, 5);
 %! assert(ier == 0 && abs (v - 17.5) < sqrt (eps) && nfun > 0 &&
 %!        err < sqrt (eps))
 %!test
-%! [v, ier, nfun, err] = quad ("f", single(0), single(5));
+%! [v, ier, nfun, err] = quad ("__f", single(0), single(5));
 %! assert(ier == 0 && abs (v - 17.5) < sqrt (eps ("single")) && nfun > 0 &&
 %!        err < sqrt (eps ("single")))
 
-%!function y = f (x)
+%!function y = __f (x)
 %!  y = x .* sin (1 ./ x) .* sqrt (abs (1 - x));
+%!endfunction
+
 %!test
-%!  [v, ier, nfun, err] = quad ("f", 0.001, 3);
+%!  [v, ier, nfun, err] = quad ("__f", 0.001, 3);
 %! assert((ier == 0 || ier == 1) && abs (v - 1.98194120273598) < sqrt (eps) && nfun > 0);
 %!test
-%!  [v, ier, nfun, err] = quad ("f", single(0.001), single(3));
+%!  [v, ier, nfun, err] = quad ("__f", single(0.001), single(3));
 %! assert((ier == 0 || ier == 1) && abs (v - 1.98194120273598) < sqrt (eps ("single")) && nfun > 0);
 
 %!error <Invalid call to quad> quad ();
 
-%!error <Invalid call to quad> quad ("f", 1, 2, 3, 4, 5);
+%!error <Invalid call to quad> quad ("__f", 1, 2, 3, 4, 5);
 
 %!test
 %! quad_options ("absolute tolerance", eps);
 %! assert(quad_options ("absolute tolerance") == eps);
 
 %!error <Invalid call to quad_options> quad_options (1, 2, 3);
 
 */
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -41,46 +41,54 @@ along with Octave; see the file COPYING.
 static inline bool
 is_imag_unit (int c)
 { return c == 'i' || c == 'j'; }
 
 static std::istringstream&
 single_num (std::istringstream& is, double& num)
 {
   char c = is.peek ();
+
+  // Skip spaces.
+  while (isspace (c))
+    {
+      is.get ();
+      c = is.peek ();
+    }
+
   if (c == 'I')
     {
       // It's infinity.
       is.get ();
       char c1 = is.get (), c2 = is.get ();
       if (c1 == 'n' && c2 == 'f')
         {
           num = octave_Inf;
-          is.peek (); // Sets eof bit.
+          is.peek (); // May sets EOF bit.
         }
       else
         is.setstate (std::ios::failbit); // indicate that read has failed.
     }
   else if (c == 'N')
     {
       // It's NA or NaN
       is.get ();
       char c1 = is.get ();
       if (c1 == 'A')
         {
           num = octave_NA;
-          is.peek (); // Sets eof bit.
+          is.peek (); // May set EOF bit.
         }
       else
         {
           char c2 = is.get ();
           if (c1 == 'a' && c2 == 'N')
             {
               num = octave_NaN;
-              is.peek (); // Sets eof bit.
+              is.peek (); // May set EOF bit.
             }
           else
             is.setstate (std::ios::failbit); // indicate that read has failed.
         }
     }
   else
     is >> num;
 
@@ -88,70 +96,122 @@ single_num (std::istringstream& is, doub
 }
 
 static std::istringstream&
 extract_num (std::istringstream& is, double& num, bool& imag, bool& have_sign)
 {
   have_sign = imag = false;
 
   char c = is.peek ();
+
+  // Skip leading spaces.
+  while (isspace (c))
+    {
+      is.get ();
+      c = is.peek ();
+    }
+
   bool negative = false;
 
   // Accept leading sign.
   if (c == '+' || c == '-')
     {
       negative = c == '-';
       is.get ();
       c = is.peek ();
       have_sign = true;
     }
 
+  // Skip spaces after sign.
+  while (isspace (c))
+    {
+      is.get ();
+      c = is.peek ();
+    }
+
   // It's i*num or just i.
   if (is_imag_unit (c))
     {
-      c = is.get ();
       imag = true;
-      char cn = is.peek ();
-      if (cn == '*')
+      is.get ();
+      c = is.peek ();
+
+      // Skip spaces after imaginary unit.
+      while (isspace (c))
+        {
+          is.get ();
+          c = is.peek ();
+        }
+
+      if (c == '*')
         {
           // Multiplier follows, we extract it as a number.
           is.get ();
           single_num (is, num);
+          if (is.good ())
+            c = is.peek ();
         }
       else
         num = 1.0;
     }
   else
     {
       // It's num, num*i, or numi.
       single_num (is, num);
       if (is.good ())
         {
           c = is.peek ();
+
+          // Skip spaces after number.
+          while (isspace (c))
+            {
+              is.get ();
+              c = is.peek ();
+            }
+
           if (c == '*')
             {
               is.get ();
-              c = is.get ();
+              c = is.peek ();
+
+              // Skip spaces after operator.
+              while (isspace (c))
+                {
+                  is.get ();
+                  c = is.peek ();
+                }
+
               if (is_imag_unit (c))
                 {
                   imag = true;
-                  is.peek ();
+                  is.get ();
+                  c = is.peek ();
                 }
               else
                 is.setstate (std::ios::failbit); // indicate that read has failed.
             }
           else if (is_imag_unit (c))
             {
               imag = true;
               is.get ();
-              is.peek ();
+              c = is.peek ();
             }
         }
     }
 
+  if (is.good ())
+    {
+      // Skip trailing spaces.
+      while (isspace (c))
+        {
+          is.get ();
+          c = is.peek ();
+        }
+    }
+
   if (negative)
     num = -num;
 
   return is;
 }
 
 static inline void
 set_component (Complex& c, double num, bool imag)
@@ -176,24 +236,22 @@ set_component (Complex& c, double num, b
 
 static Complex
 str2double1 (const std::string& str_arg)
 {
   Complex val (0.0, 0.0);
 
   std::string str = str_arg;
 
+  // FIXME -- removing all commas does too much...
   std::string::iterator se = str.end ();
-
-  // Remove commas (thousand separators) and spaces.
   se = std::remove (str.begin (), se, ',');
-  se = std::remove (str.begin (), se, ' ');
   str.erase (se, str.end ());
+  std::istringstream is (str);
 
-  std::istringstream is (str);
   double num;
   bool i1, i2, s1, s2;
 
   if (is.eof ())
     val = octave_NaN;
   else if (! extract_num (is, num, i1, s1))
     val = octave_NaN;
   else
@@ -290,26 +348,29 @@ risk of using @code{eval} on unknown dat
 
   return retval;
 }
 
 /*
 
 %!assert (str2double ("1"), 1)
 %!assert (str2double ("-.1e-5"), -1e-6)
+%!assert (str2double (char ("1", "2 3", "4i")), [1; NaN; 4i]);
+%!assert (str2double ("-.1e-5"), -1e-6)
 %!assert (str2double ("1,222.5"), 1222.5)
 %!assert (str2double ("i"), i)
 %!assert (str2double ("2j"), 2i)
 %!assert (str2double ("2 + j"), 2+j)
 %!assert (str2double ("i*2 + 3"), 3+2i)
 %!assert (str2double (".5*i + 3.5"), 3.5+0.5i)
 %!assert (str2double ("1e-3 + i*.25"), 1e-3 + 0.25i)
 %!assert (str2double (["2 + j";"1.25e-3";"-05"]), [2+i; 1.25e-3; -5])
 %!assert (str2double ({"2 + j","1.25e-3","-05"}), [2+i, 1.25e-3, -5])
 %!assert (str2double (1), NaN)
+%!assert (str2double ("1 2 3 4"), NaN)
 %!assert (str2double ("Hello World"), NaN)
 %!assert (str2double ("NaN"), NaN)
 %!assert (str2double ("NA"), NA)
 %!assert (str2double ("Inf"), Inf)
 %!assert (str2double ("-Inf"), -Inf)
 %!assert (str2double ("Inf*i"), complex (0, Inf))
 %!assert (str2double ("NaN + Inf*i"), complex (NaN, Inf))
 %!assert (str2double ("Inf - Inf*i"), complex (Inf, -Inf))
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -2155,17 +2155,17 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
-%!function ret = testcat (t1, t2, tr, cmplx)
+%!function ret = __testcat (t1, t2, tr, cmplx)
 %! assert (cat (1, cast ([], t1), cast([], t2)), cast ([], tr));
 %!
 %! assert (cat (1, cast (1, t1), cast (2, t2)), cast ([1; 2], tr));
 %! assert (cat (1, cast (1, t1), cast ([2; 3], t2)), cast ([1; 2; 3], tr));
 %! assert (cat (1, cast ([1; 2], t1), cast (3, t2)), cast ([1; 2; 3], tr));
 %! assert (cat (1, cast ([1; 2], t1), cast ([3; 4], t2)), cast ([1; 2; 3; 4], tr));
 %! assert (cat (2, cast (1, t1), cast (2, t2)), cast ([1, 2], tr));
 %! assert (cat (2, cast (1, t1), cast ([2, 3], t2)), cast ([1, 2, 3], tr));
@@ -2232,77 +2232,78 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
 %!   assert ([cast([1i; 2], t1); cast(3i, t2)], cast ([1i; 2; 3i], tr));
 %!   assert ([cast([1i; 2], t1); cast([3i; 4], t2)], cast ([1i; 2; 3i; 4], tr));
 %!   assert ([cast(1i, t1), cast(2i, t2)], cast ([1i, 2i], tr));
 %!   assert ([cast(1i, t1), cast([2i, 3], t2)], cast ([1i, 2i, 3], tr));
 %!   assert ([cast([1i, 2], t1), cast(3i, t2)], cast ([1i, 2, 3i], tr));
 %!   assert ([cast([1i, 2], t1), cast([3i, 4], t2)], cast ([1i, 2, 3i, 4], tr));
 %! endif
 %! ret = true;
-
-%!assert (testcat('double', 'double', 'double'));
-%!assert (testcat('single', 'double', 'single'));
-%!assert (testcat('double', 'single', 'single'));
-%!assert (testcat('single', 'single', 'single'));
-
-%!assert (testcat('double', 'int8', 'int8', false));
-%!assert (testcat('int8', 'double', 'int8', false));
-%!assert (testcat('single', 'int8', 'int8', false));
-%!assert (testcat('int8', 'single', 'int8', false));
-%!assert (testcat('int8', 'int8', 'int8', false));
-%!assert (testcat('double', 'int16', 'int16', false));
-%!assert (testcat('int16', 'double', 'int16', false));
-%!assert (testcat('single', 'int16', 'int16', false));
-%!assert (testcat('int16', 'single', 'int16', false));
-%!assert (testcat('int16', 'int16', 'int16', false));
-%!assert (testcat('double', 'int32', 'int32', false));
-%!assert (testcat('int32', 'double', 'int32', false));
-%!assert (testcat('single', 'int32', 'int32', false));
-%!assert (testcat('int32', 'single', 'int32', false));
-%!assert (testcat('int32', 'int32', 'int32', false));
-%!assert (testcat('double', 'int64', 'int64', false));
-%!assert (testcat('int64', 'double', 'int64', false));
-%!assert (testcat('single', 'int64', 'int64', false));
-%!assert (testcat('int64', 'single', 'int64', false));
-%!assert (testcat('int64', 'int64', 'int64', false));
-
-%!assert (testcat('double', 'uint8', 'uint8', false));
-%!assert (testcat('uint8', 'double', 'uint8', false));
-%!assert (testcat('single', 'uint8', 'uint8', false));
-%!assert (testcat('uint8', 'single', 'uint8', false));
-%!assert (testcat('uint8', 'uint8', 'uint8', false));
-%!assert (testcat('double', 'uint16', 'uint16', false));
-%!assert (testcat('uint16', 'double', 'uint16', false));
-%!assert (testcat('single', 'uint16', 'uint16', false));
-%!assert (testcat('uint16', 'single', 'uint16', false));
-%!assert (testcat('uint16', 'uint16', 'uint16', false));
-%!assert (testcat('double', 'uint32', 'uint32', false));
-%!assert (testcat('uint32', 'double', 'uint32', false));
-%!assert (testcat('single', 'uint32', 'uint32', false));
-%!assert (testcat('uint32', 'single', 'uint32', false));
-%!assert (testcat('uint32', 'uint32', 'uint32', false));
-%!assert (testcat('double', 'uint64', 'uint64', false));
-%!assert (testcat('uint64', 'double', 'uint64', false));
-%!assert (testcat('single', 'uint64', 'uint64', false));
-%!assert (testcat('uint64', 'single', 'uint64', false));
-%!assert (testcat('uint64', 'uint64', 'uint64', false));
-
-%!assert (cat (3, [], [1,2;3,4]), [1,2;3,4]);
-%!assert (cat (3, [1,2;3,4], []), [1,2;3,4]);
-%!assert (cat (3, [], [1,2;3,4], []), [1,2;3,4]);
-%!assert (cat (3, [], [], []), zeros (0, 0, 3));
-
-%!assert (cat (3, [], [], 1, 2), cat (3, 1, 2));
-%!assert (cat (3, [], [], [1,2;3,4]), [1,2;3,4]);
-%!assert (cat (4, [], [], [1,2;3,4]), [1,2;3,4]);
-%!error <dimension mismatch> cat (3, cat (3, [], []), [1,2;3,4]);
-%!error <dimension mismatch> cat (3, zeros (0, 0, 2), [1,2;3,4]);
-
-%!assert ([zeros(3,2,2); ones(1,2,2)], repmat([0;0;0;1],[1,2,2]) );
-%!assert ([zeros(3,2,2); ones(1,2,2)], vertcat(zeros(3,2,2), ones(1,2,2)) );
+%!endfunction
+
+%!assert (__testcat('double', 'double', 'double'))
+%!assert (__testcat('single', 'double', 'single'))
+%!assert (__testcat('double', 'single', 'single'))
+%!assert (__testcat('single', 'single', 'single'))
+
+%!assert (__testcat('double', 'int8', 'int8', false))
+%!assert (__testcat('int8', 'double', 'int8', false))
+%!assert (__testcat('single', 'int8', 'int8', false))
+%!assert (__testcat('int8', 'single', 'int8', false))
+%!assert (__testcat('int8', 'int8', 'int8', false))
+%!assert (__testcat('double', 'int16', 'int16', false))
+%!assert (__testcat('int16', 'double', 'int16', false))
+%!assert (__testcat('single', 'int16', 'int16', false))
+%!assert (__testcat('int16', 'single', 'int16', false))
+%!assert (__testcat('int16', 'int16', 'int16', false))
+%!assert (__testcat('double', 'int32', 'int32', false))
+%!assert (__testcat('int32', 'double', 'int32', false))
+%!assert (__testcat('single', 'int32', 'int32', false))
+%!assert (__testcat('int32', 'single', 'int32', false))
+%!assert (__testcat('int32', 'int32', 'int32', false))
+%!assert (__testcat('double', 'int64', 'int64', false))
+%!assert (__testcat('int64', 'double', 'int64', false))
+%!assert (__testcat('single', 'int64', 'int64', false))
+%!assert (__testcat('int64', 'single', 'int64', false))
+%!assert (__testcat('int64', 'int64', 'int64', false))
+
+%!assert (__testcat('double', 'uint8', 'uint8', false))
+%!assert (__testcat('uint8', 'double', 'uint8', false))
+%!assert (__testcat('single', 'uint8', 'uint8', false))
+%!assert (__testcat('uint8', 'single', 'uint8', false))
+%!assert (__testcat('uint8', 'uint8', 'uint8', false))
+%!assert (__testcat('double', 'uint16', 'uint16', false))
+%!assert (__testcat('uint16', 'double', 'uint16', false))
+%!assert (__testcat('single', 'uint16', 'uint16', false))
+%!assert (__testcat('uint16', 'single', 'uint16', false))
+%!assert (__testcat('uint16', 'uint16', 'uint16', false))
+%!assert (__testcat('double', 'uint32', 'uint32', false))
+%!assert (__testcat('uint32', 'double', 'uint32', false))
+%!assert (__testcat('single', 'uint32', 'uint32', false))
+%!assert (__testcat('uint32', 'single', 'uint32', false))
+%!assert (__testcat('uint32', 'uint32', 'uint32', false))
+%!assert (__testcat('double', 'uint64', 'uint64', false))
+%!assert (__testcat('uint64', 'double', 'uint64', false))
+%!assert (__testcat('single', 'uint64', 'uint64', false))
+%!assert (__testcat('uint64', 'single', 'uint64', false))
+%!assert (__testcat('uint64', 'uint64', 'uint64', false))
+
+%!assert (cat (3, [], [1,2;3,4]), [1,2;3,4])
+%!assert (cat (3, [1,2;3,4], []), [1,2;3,4])
+%!assert (cat (3, [], [1,2;3,4], []), [1,2;3,4])
+%!assert (cat (3, [], [], []), zeros (0, 0, 3))
+
+%!assert (cat (3, [], [], 1, 2), cat (3, 1, 2))
+%!assert (cat (3, [], [], [1,2;3,4]), [1,2;3,4])
+%!assert (cat (4, [], [], [1,2;3,4]), [1,2;3,4])
+%!error <dimension mismatch> cat (3, cat (3, [], []), [1,2;3,4])
+%!error <dimension mismatch> cat (3, zeros (0, 0, 2), [1,2;3,4])
+
+%!assert ([zeros(3,2,2); ones(1,2,2)], repmat([0;0;0;1],[1,2,2]) )
+%!assert ([zeros(3,2,2); ones(1,2,2)], vertcat(zeros(3,2,2), ones(1,2,2)) )
 
 */
 
 static octave_value
 do_permute (const octave_value_list& args, bool inv)
 {
   octave_value retval;
 
@@ -4293,16 +4294,21 @@ either \"double\" or \"single\".\n\
 @seealso{realmax, intmin}\n\
 @end deftypefn")
 {
   return fill_matrix (args, DBL_MIN, FLT_MIN, "realmin");
 }
 
 DEFUN (I, args, ,
   "-*- texinfo -*-\n\
+@c List other forms of function in documentation index\n\
+@findex i\n\
+@findex j\n\
+@findex J\n\
+\n\
 @deftypefn  {Built-in Function} {} I\n\
 @deftypefnx {Built-in Function} {} I (@var{n})\n\
 @deftypefnx {Built-in Function} {} I (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} I (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} I (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the pure imaginary unit, defined as\n\
 @tex\n\
@@ -6625,29 +6631,34 @@ template <class NDT>
 static NDT
 do_accumdim_sum (const idx_vector& idx, const NDT& vals,
                  int dim = -1, octave_idx_type n = -1)
 {
   typedef typename NDT::element_type T;
   if (n < 0)
     n = idx.extent (0);
   else if (idx.extent (n) > n)
-    error ("accumarray: index out of range");
-
-  dim_vector rdv = vals.dims ();
+    error ("accumdim: index out of range");
+
+  dim_vector vals_dim = vals.dims (), rdv = vals_dim;
+
   if (dim < 0)
     dim = vals.dims ().first_non_singleton ();
   else if (dim >= rdv.length ())
     rdv.resize (dim+1, 1);
 
   rdv(dim) = n;
 
   NDT retval (rdv, T());
 
+  if (idx.length () != vals_dim(dim))
+    error ("accumdim: dimension mismatch");
+
   retval.idx_add_nd (idx, vals, dim);
+
   return retval;
 }
 
 DEFUN (__accumdim_sum__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __accumdim_sum__ (@var{idx}, @var{vals}, @var{dim}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -1090,37 +1090,46 @@ error: nargin != 1\n\
 
   return retval;
 }
 
 DEFUN (warning, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} warning (@var{template}, @dots{})\n\
 @deftypefnx {Built-in Function} {} warning (@var{id}, @var{template}, @dots{})\n\
+@deftypefnx {Built-in Function} {} warning (\"on\", @var{id})\n\
+@deftypefnx {Built-in Function} {} warning (\"off\", @var{id})\n\
+@deftypefnx {Built-in Function} {} warning (\"query\", @var{id})\n\
+@deftypefnx {Built-in Function} {} warning (\"error\", @var{id})\n\
 Format the optional arguments under the control of the template string\n\
 @var{template} using the same rules as the @code{printf} family of\n\
 functions (@pxref{Formatted Output}) and print the resulting message\n\
 on the @code{stderr} stream.  The message is prefixed by the character\n\
 string @samp{warning: }.\n\
 You should use this function when you want to notify the user\n\
 of an unusual condition, but only when it makes sense for your program\n\
 to go on.\n\
 \n\
 The optional message identifier allows users to enable or disable\n\
 warnings tagged by @var{id}.  The special identifier @samp{\"all\"} may\n\
 be used to set the state of all warnings.\n\
 \n\
-@deftypefnx {Built-in Function} {} warning (\"on\", @var{id})\n\
-@deftypefnx {Built-in Function} {} warning (\"off\", @var{id})\n\
-@deftypefnx {Built-in Function} {} warning (\"error\", @var{id})\n\
-@deftypefnx {Built-in Function} {} warning (\"query\", @var{id})\n\
-Set or query the state of a particular warning using the identifier\n\
-@var{id}.  If the identifier is omitted, a value of @samp{\"all\"} is\n\
-assumed.  If you set the state of a warning to @samp{\"error\"}, the\n\
-warning named by @var{id} is handled as if it were an error instead.\n\
+If the first argument is @samp{\"on\"} or @samp{\"off\"}, set the state\n\
+of a particular warning using the identifier @var{id}.  If the first\n\
+argument is @samp{\"query\"}, query the state of this warning instead.\n\
+If the identifier is omitted, a value of @samp{\"all\"} is assumed.  If\n\
+you set the state of a warning to @samp{\"error\"}, the warning named by\n\
+@var{id} is handled as if it were an error instead.  So, for example, the\n\
+following handles all warnings as errors:\n\
+\n\
+@example\n\
+@group\n\
+warning (\"error\");\n\
+@end group\n\
+@end example\n\
 @seealso{warning_ids}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
   int argc = nargin + 1;
 
@@ -1474,18 +1483,18 @@ initialize_default_warning_state (void)
 
 }
 
 DEFUN (lasterror, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{lasterr} =} lasterror ()\n\
 @deftypefnx {Built-in Function} {} lasterror (@var{err})\n\
 @deftypefnx {Built-in Function} {} lasterror ('reset')\n\
-Query or set the last error message structure.  When called without arguments\n\
-, return a structure containing the last error message and other\n\
+Query or set the last error message structure.  When called without\n\
+arguments, return a structure containing the last error message and other\n\
 information related to this error.  The elements of the structure are:\n\
 \n\
 @table @asis\n\
 @item 'message'\n\
 The text of the last error message\n\
 \n\
 @item 'identifier'\n\
 The message identifier of this error message\n\
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -612,17 +612,17 @@ endif\n\
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} otherwise\n\
 The default statement in a switch block (similar to else in an if block).\n\
 @seealso{switch}\n\
 @end deftypefn"),
 
   pair_type ("parfor",
     "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} for @var{i} = @var{range}\n\
+@deftypefn  {Keyword} {} for @var{i} = @var{range}\n\
 @deftypefnx {Keyword} {} for (@var{i} = @var{range}, @var{maxproc})\n\
 Begin a for loop that may execute in parallel.\n\
 \n\
 @example\n\
 @group\n\
 parfor i = 1:10\n\
   i\n\
 endparfor\n\
diff --git a/src/lex.ll b/src/lex.ll
--- a/src/lex.ll
+++ b/src/lex.ll
@@ -1136,19 +1136,21 @@ reset_parser (void)
   if (! (reading_script_file || reading_fcn_file || reading_classdef_file))
     {
       current_input_column = 1;
       input_line_number = command_editor::current_command_number ();
     }
 
   // Only ask for input from stdin if we are expecting interactive
   // input.
-  if ((interactive || forced_interactive)
+
+  if (! quitting_gracefully
+      && (interactive || forced_interactive)
       && ! (reading_fcn_file
-        || reading_classdef_file
+            || reading_classdef_file
             || reading_script_file
             || get_input_from_eval_string
             || input_from_startup_file))
     yyrestart (stdin);
 
   // Clear the buffer for help text.
   while (! help_buf.empty ())
     help_buf.pop ();
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -4513,94 +4513,44 @@ eval ('error (\"This is a bad example\")
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
-%% test/octave.test/eval/eval-1.m
-%!#test
+%!shared x
 %! x = 1;
-%! assert(eval ("x"),1);
-
-%% test/octave.test/eval/eval-2.m
-%!test
-%! x = 1;
-%! assert(eval ("x;"));
-
-%% test/octave.test/eval/eval-3.m
+
+%!assert (eval ("x"), 1)
+%!assert (eval ("x;"))
+%!assert (eval ("x;"), 1);
+
 %!test
-%! x = 1;
-%! assert(eval ("x;"),1);
-
-%% FIXME
-%% Disable this test as adding the ";" is redundant with eval-1 and
-%% in any case is a syntax error with assert
-%% test/octave.test/eval/eval-4.m
-%!#test
-%! x = 1;
-%! assert(eval ("x");,1);
-
-%% test/octave.test/eval/eval-5.m
+%! y = eval ("x");
+%! assert (y, 1);
+
+%!test
+%! y = eval ("x;");
+%! assert (y, 1);
+
+%!test
+%! eval ("x = 1;")
+%! assert (x,1);
+
 %!test
 %! eval ("flipud = 2;");
-%! assert(flipud,2);
-
-%% test/octave.test/eval/eval-6.m
-%!function y = f ()
+%! assert (flipud, 2);
+
+%!function y = __f ()
 %!  eval ("flipud = 2;");
 %!  y = flipud;
-%!test
-%! assert(f,2);
-
-%% test/octave.test/eval/eval-7.m
-%!#test
-%! eval ("x = 1");
-%! assert(x,1);
-
-%% test/octave.test/eval/eval-8.m
-%!test
-%! eval ("x = 1;")
-%! assert(x,1);
-
-%% test/octave.test/eval/eval-9.m
-%!test
-%! eval ("x = 1;");
-%! assert(x,1);
-
-%% test/octave.test/eval/eval-10.m
-%!#test
-%! eval ("x = 1")
-%! assert(x,1);
-
-%% test/octave.test/eval/eval-11.m
-%!test
-%! x = 1;
-%! y = eval ("x");
-%! assert(y,1);
-
-%% test/octave.test/eval/eval-12.m
-%!test
-%! x = 1;
-%! y = eval ("x;");
-%! assert(y,1);
-
-%% test/octave.test/eval/eval-13.m
-%!test
-%! x = 1;
-%! y = eval ("x;");
-%! assert(y,1);
-
-%% test/octave.test/eval/eval-14.m
-%!test
-%! x = 1;
-%! y = eval ("x");
-%! assert(y,1);
+%!endfunction
+%!assert (__f(), 2)
 
 */
 
 DEFUN (assignin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} assignin (@var{context}, @var{varname}, @var{value})\n\
 Assign @var{value} to @var{varname} in context @var{context}, which\n\
 may be either @code{\"base\"} or @code{\"caller\"}.\n\
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -896,17 +896,21 @@ octave_main (int argc, char **argv, int 
       // If we are running an executable script (#! /bin/octave) then
       // we should only see the args passed to the script.
 
       intern_argv (remaining_args, argv+last_arg_idx);
 
       execute_command_line_file (argv[last_arg_idx]);
 
       if (! persist)
-        clean_up_and_exit (error_state ? 1 : 0);
+        {
+          quitting_gracefully = true;
+
+          clean_up_and_exit (error_state ? 1 : 0);
+        }
     }
 
   // Avoid counting commands executed from startup files.
 
   command_editor::reset_current_command_number (1);
 
   // Now argv should have the full set of args.
   intern_argv (argc, argv);
@@ -935,16 +939,18 @@ octave_main (int argc, char **argv, int 
       return 1;
     }
 
   int retval = main_loop ();
 
   if (retval == 1 && ! error_state)
     retval = 0;
 
+  quitting_gracefully = true;
+
   clean_up_and_exit (retval);
 
   return 0;
 }
 
 DEFUN (argv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argv ()\n\
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1527,28 +1527,28 @@ install_base_type_conversions (void)
 }
 
 DEFUN (sparse_auto_mutate, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sparse_auto_mutate ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sparse_auto_mutate (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sparse_auto_mutate (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
-automatically mutate sparse matrices to real matrices to save memory.\n\
+automatically mutate sparse matrices to full matrices to save memory.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
-s = speye(3);\n\
+s = speye (3);\n\
 sparse_auto_mutate (false)\n\
-s (:, 1) = 1;\n\
+s(:, 1) = 1;\n\
 typeinfo (s)\n\
 @result{} sparse matrix\n\
 sparse_auto_mutate (true)\n\
-s (1, :) = 1;\n\
+s(1, :) = 1;\n\
 typeinfo (s)\n\
 @result{} matrix\n\
 @end group\n\
 @end example\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -74,16 +74,25 @@ public:
 
   type_conv_info numeric_demotion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
+  // Use this to give a more specific error message
+  idx_vector index_vector (void) const
+  {
+    error (
+           "attempted to use a complex scalar as an index\n"
+           "       (forgot to initialize i or j?)");
+    return idx_vector ();
+  }
+
   octave_value any (int = 0) const
     {
       return (scalar != Complex (0, 0)
               && ! (lo_ieee_isnan (std::real (scalar))
                     || lo_ieee_isnan (std::imag (scalar))));
     }
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -1754,28 +1754,31 @@ are ignored in the lookup.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!function y = testrecursionfunc (f, x, n)
+
+%!function y = __testrecursionfunc (f, x, n)
 %!  if (nargin < 3)
 %!    n = 0;
 %!  endif
 %!  if (n > 2)
 %!    y = f (x);
 %!  else
 %!    n++;
-%!    y = testrecursionfunc (@(x) f(2*x), x, n);
+%!    y = __testrecursionfunc (@(x) f(2*x), x, n);
 %!  endif
-%!test
-%! assert (testrecursionfunc (@(x) x, 1), 8);
+%!endfunction
+%!
+%!assert (__testrecursionfunc (@(x) x, 1), 8)
+
 */
 
 octave_fcn_binder::octave_fcn_binder (const octave_value& f,
                                       const octave_value& root,
                                       const octave_value_list& templ,
                                       const std::vector<int>& mask,
                                       int exp_nargin)
 : octave_fcn_handle (f), root_handle (root), arg_template (templ),
@@ -1953,15 +1956,15 @@ octave_fcn_binder::do_multi_index_op (in
     }
   else
      retval = octave_fcn_handle::do_multi_index_op (nargout, args, lvalue_list);
 
   return retval;
 }
 
 /*
-%!function r = f (g, i)
+%!function r = __f (g, i)
 %!  r = g(i);
 %!endfunction
 %!test
 %! x = [1,2;3,4];
-%! assert (f (@(i) x(:,i), 1), [1;3]);
+%! assert (__f (@(i) x(:,i), 1), [1;3]);
 */
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -656,30 +656,30 @@ If the second argument is an integer @va
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
-      std::string fun = args(0).string_value ();
-
-      if (! error_state)
+      if (args(0).is_string ())
         {
+          std::string fun = args(0).string_value ();
           string_vector fargs;
 
           if (nargin == 1)
             {
               bool is_arg = false;
               bool in_string = false;
               std::string tmp_arg;
               size_t i = 0;
+              size_t fun_length = fun.length ();
 
-              while (i < fun.length ())
+              while (i < fun_length)
                 {
                   bool terminate_arg = false;
                   char c = fun[i++];
 
                   if (in_string)
                     {
                       if (c == '\'' || c == '\"')
                         in_string = false;
@@ -693,35 +693,46 @@ If the second argument is an integer @va
                   else if (! isalpha (c) && c != '_')
                     if (! is_arg)
                       continue;
                     else if (isdigit (c))
                       tmp_arg.append (1, c);
                     else
                       {
                         // Before we do anything remove trailing whitespaces.
-                        while (i < fun.length () && isspace (c))
+                        while (i < fun_length && isspace (c))
                           c = fun[i++];
 
                         // Do we have a variable or a function?
                         if (c != '(')
                           terminate_arg = true;
                         else
                           {
                             tmp_arg = std::string ();
                             is_arg = false;
                           }
                       }
+                  else if (! is_arg)
+                    {
+                      if (c == 'e' || c == 'E')
+                        {
+                          // possible number in exponent form, not arg
+                          if (isdigit (fun[i])
+                              || fun[i] == '-' || fun[i] == '+')
+                            continue;
+                        }
+                      is_arg = true;
+                      tmp_arg.append (1, c);
+                    }
                   else
                     {
                       tmp_arg.append (1, c);
-                      is_arg = true;
                     }
 
-                  if (terminate_arg || (i == fun.length () && is_arg))
+                  if (terminate_arg || (i == fun_length && is_arg))
                     {
                       bool have_arg = false;
 
                       for (int j = 0; j < fargs.length (); j++)
                         if (tmp_arg == fargs (j))
                           {
                             have_arg = true;
                             break;
@@ -739,16 +750,22 @@ If the second argument is an integer @va
                     }
                 }
 
               // Sort the arguments into ascii order.
               fargs.sort ();
             }
           else if (nargin == 2 && args(1).is_numeric_type ())
             {
+              if (! args(1).is_scalar_type ()) 
+                {
+                  error ("inline: N must be an integer");
+                  return retval;
+                }
+              
               int n = args(1).int_value ();
 
               if (! error_state)
                 {
                   if (n >= 0)
                     {
                       fargs.resize (n+1);
 
@@ -758,37 +775,38 @@ If the second argument is an integer @va
                         {
                           std::ostringstream buf;
                           buf << "P" << i;
                           fargs(i) = buf.str ();
                         }
                     }
                   else
                     {
-                      error ("inline: N must be positive or zero");
+                      error ("inline: N must be a positive integer or zero");
                       return retval;
                     }
                 }
               else
                 {
                   error ("inline: N must be an integer");
                   return retval;
                 }
             }
           else
             {
               fargs.resize (nargin - 1);
 
               for (int i = 1; i < nargin; i++)
                 {
-                  std::string s = args(i).string_value ();
-
-                  if (! error_state)
-                    fargs(i-1) = s;
-                  else
+                  if (args(i).is_string ())
+                    {
+                      std::string s = args(i).string_value ();
+                      fargs(i-1) = s;
+                    }
+                    else
                     {
                       error ("inline: expecting string arguments");
                       return retval;
                     }
                 }
             }
 
           retval = octave_value (new octave_fcn_inline (fun, fargs));
@@ -799,19 +817,27 @@ If the second argument is an integer @va
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!shared fn
-%! fn = inline ("x.^2 + 1","x");
+%! fn = inline ("x.^2 + 1");
 %!assert (feval (fn, 6), 37)
 %!assert (fn (6), 37)
+%% FIXME: Need tests for other 2 calling forms of inline()
+
+%% Test input validation 
+%!error inline ()
+%!error <STR argument must be a string> inline (1)
+%!error <N must be an integer> inline ("2", ones (2,2))
+%!error <N must be a positive integer> inline ("2", -1)
+%!error <expecting string arguments> inline ("2", "x", -1, "y")
 */
 
 DEFUN (formula, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} formula (@var{fun})\n\
 Return a character string representing the inline function @var{fun}.\n\
 Note that @code{char (@var{fun})} is equivalent to\n\
 @code{formula (@var{fun})}.\n\
@@ -832,16 +858,26 @@ Note that @code{char (@var{fun})} is equ
         error ("formula: FUN must be an inline function");
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!assert (formula (fn), "x.^2 + 1")
+%!assert (formula (fn), char (fn))
+
+%% Test input validation
+%!error formula ()
+%!error formula (1, 2)
+%!error <FUN must be an inline function> formula (1)
+*/
+
 DEFUN (argnames, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argnames (@var{fun})\n\
 Return a cell array of character strings containing the names of\n\
 the arguments of the inline function @var{fun}.\n\
 @seealso{inline, formula, vectorize}\n\
 @end deftypefn")
 {
@@ -868,16 +904,27 @@ the arguments of the inline function @va
         error ("argnames: FUN must be an inline function");
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!assert (argnames (fn), {"x"})
+%!assert (argnames (inline ("1e-3*y + 2e4*z")), {"y"; "z"})
+%!assert (argnames (inline ("2", 2)), {"x"; "P1"; "P2"})
+
+%% Test input validation
+%!error argnames ()
+%!error argnames (1, 2)
+%!error <FUN must be an inline function> argnames (1)
+*/
+
 DEFUN (vectorize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vectorize (@var{fun})\n\
 Create a vectorized version of the inline function @var{fun}\n\
 by replacing all occurrences of @code{*}, @code{/}, etc., with\n\
 @code{.*}, @code{./}, etc.\n\
 \n\
 This may be useful, for example, when using inline functions with\n\
@@ -887,16 +934,17 @@ is expected.\n\
 @example\n\
 @group\n\
 fcn = vectorize (inline (\"x^2 - 1\"))\n\
    @result{} fcn = f(x) = x.^2 - 1\n\
 quadv (fcn, 0, 3)\n\
    @result{} 6\n\
 @end group\n\
 @end example\n\
+@seealso{inline, formula, argnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -909,17 +957,17 @@ quadv (fcn, 0, 3)\n\
       else
         {
           old = args(0).fcn_inline_value (true);
           func_is_string = false;
 
           if (old)
             old_func = old->fcn_text ();
           else
-            error ("vectorize: must be a string or inline function");
+            error ("vectorize: FUN must be a string or inline function");
         }
 
       if (! error_state)
         {
           std::string new_func;
           size_t i = 0;
 
           while (i < old_func.length ())
@@ -950,8 +998,23 @@ quadv (fcn, 0, 3)\n\
                                    (new_func, old->fcn_arg_names ()));
         }
     }
   else
     print_usage ();
 
   return retval;
 }
+
+/*
+%!assert (char (vectorize (fn)), "x.^2 + 1")
+%!assert (char (vectorize (inline ("1e-3*y + 2e4*z"))), "1e-3.*y + 2e4.*z")
+%!assert (char (vectorize (inline ("2**x^5"))), "2.**x.^5")
+%!assert (vectorize ("x.^2 + 1"), "x.^2 + 1")
+%!assert (vectorize ("1e-3*y + 2e4*z"), "1e-3.*y + 2e4.*z")
+%!assert (vectorize ("2**x^5"), "2.**x.^5")
+
+%% Test input validation
+%!error vectorize ()
+%!error vectorize (1, 2)
+%!error <FUN must be a string or inline function> vectorize (1)
+*/
+
diff --git a/src/pt-fcn-handle.cc b/src/pt-fcn-handle.cc
--- a/src/pt-fcn-handle.cc
+++ b/src/pt-fcn-handle.cc
@@ -136,32 +136,34 @@ tree_anon_fcn_handle::rvalue1 (int)
   octave_value ov_fcn (uf);
 
   octave_value fh (octave_fcn_binder::maybe_binder (ov_fcn));
 
   return fh;
 }
 
 /*
-%!function r = f2 (f, x)
+%!function r = __f2 (f, x)
 %!  r = f (x);
-%!function f = f1 (k)
-%!  f = @(x) f2 (@(y) y-k, x);
+%!endfunction
+%!function f = __f1 (k)
+%!  f = @(x) __f2 (@(y) y-k, x);
+%!endfunction
+
+%!assert ((__f1 (3)) (10) == 7)
+
 %!test
-%! assert ((f1 (3)) (10) == 7)
-%!
-%!shared g
 %! g = @(t) feval (@(x) t*x, 2);
-%!assert (g(0.5) == 1)
-%!
-%!shared f, g, h
+%! assert (g(0.5) == 1);
+
+%!test
 %! h = @(x) sin (x);
 %! g = @(f, x) h (x);
 %! f = @() g (@(x) h, pi);
-%!assert (f () == sin (pi))
+%! assert (f () == sin (pi));
 */
 
 octave_value_list
 tree_anon_fcn_handle::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -857,35 +857,36 @@ DEFUN (list_in_columns, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} list_in_columns (@var{arg}, @var{width})\n\
 Return a string containing the elements of @var{arg} listed in\n\
 columns with an overall maximum width of @var{width}.  The argument\n\
 @var{arg} must be a cell array of character strings or a character array.\n\
 If @var{width} is not specified, the width of the terminal screen is used.\n\
 Newline characters are used to break the lines in the output string.\n\
 For example:\n\
+@c Set example in small font to prevent overfull line\n\
 \n\
-@example\n\
+@smallexample\n\
 @group\n\
 list_in_columns (@{\"abc\", \"def\", \"ghijkl\", \"mnop\", \"qrs\", \"tuv\"@}, 20)\n\
      @result{} ans = abc     mnop\n\
             def     qrs\n\
             ghijkl  tuv\n\
 \n\
 whos ans\n\
      @result{}\n\
      Variables in the current scope:\n\
 \n\
        Attr Name        Size                     Bytes  Class\n\
        ==== ====        ====                     =====  =====\n\
             ans         1x37                        37  char\n\
 \n\
      Total is 37 elements using 37 bytes\n\
 @end group\n\
-@end example\n\
+@end smallexample\n\
 \n\
 @seealso{terminal_size}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -1638,218 +1638,263 @@ const_value (const octave_value_list& ar
 
   return retval;
 }
 
 #if !defined (O_NONBLOCK) && defined (O_NDELAY)
 #define O_NONBLOCK O_NDELAY
 #endif
 
-#if defined (F_DUPFD)
 DEFUNX ("F_DUPFD", FF_DUPFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_DUPFD ()\n\
 Return the value required to request that @code{fcntl} return a\n\
 duplicate file descriptor.\n\
 @seealso{fcntl, F_GETFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
+#if defined (F_DUPFD)
   return const_value (args, F_DUPFD);
-}
+#else
+  error ("F_DUPFD: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (F_GETFD)
 DEFUNX ("F_GETFD", FF_GETFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_GETFD ()\n\
 Return the value required to request that @code{fcntl} to return the\n\
 file descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
+#if defined (F_GETFD)
   return const_value (args, F_GETFD);
-}
+#else
+  error ("F_GETFD: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (F_GETFL)
 DEFUNX ("F_GETFL", FF_GETFL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_GETFL ()\n\
 Return the value required to request that @code{fcntl} to return the\n\
 file status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
+#if defined (F_GETFL)
   return const_value (args, F_GETFL);
-}
+#else
+  error ("F_GETFL: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (F_SETFD)
 DEFUNX ("F_SETFD", FF_SETFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_SETFD ()\n\
 Return the value required to request that @code{fcntl} to set the file\n\
 descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFL}\n\
 @end deftypefn")
 {
+#if defined (F_SETFD)
   return const_value (args, F_SETFD);
-}
+#else
+  error ("F_SETFD: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (F_SETFL)
 DEFUNX ("F_SETFL", FF_SETFL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_SETFL ()\n\
 Return the value required to request that @code{fcntl} to set the file\n\
 status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFD}\n\
 @end deftypefn")
 {
+#if defined (F_SETFL)
   return const_value (args, F_SETFL);
-}
+#else
+  error ("F_SETFL: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_APPEND)
 DEFUNX ("O_APPEND", FO_APPEND, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_APPEND ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate each write operation appends,\n\
 or that may be passed to @code{fcntl} to set the write mode to append.\n\
 @seealso{fcntl, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_APPEND)
   return const_value (args, O_APPEND);
-}
+#else
+  error ("O_APPEND: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_ASYNC)
 DEFUNX ("O_ASYNC", FO_ASYNC, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_ASYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate asynchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_ASYNC)
   return const_value (args, O_ASYNC);
-}
+#else
+  error ("O_ASYNC: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_CREAT)
 DEFUNX ("O_CREAT", FO_CREAT, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_CREAT ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file should be\n\
 created if it does not exist.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_CREAT)
   return const_value (args, O_CREAT);
-}
+#else
+  error ("O_CREAT: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_EXCL)
 DEFUNX ("O_EXCL", FO_EXCL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_EXCL ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that file locking is used.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_EXCL)
   return const_value (args, O_EXCL);
-}
+#else
+  error ("O_EXCL: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_NONBLOCK)
 DEFUNX ("O_NONBLOCK", FO_NONBLOCK, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_NONBLOCK ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that non-blocking I/O is in use,\n\
 or that may be passsed to @code{fcntl} to set non-blocking I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_NONBLOCK)
   return const_value (args, O_NONBLOCK);
-}
+#else
+  error ("O_NONBLOCK: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_RDONLY)
 DEFUNX ("O_RDONLY", FO_RDONLY, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_RDONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 reading only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_RDONLY)
   return const_value (args, O_RDONLY);
-}
+#else
+  error ("O_RDONLY: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_RDWR)
 DEFUNX ("O_RDWR", FO_RDWR, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_RDWR ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for both\n\
 reading and writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_RDWR)
   return const_value (args, O_RDWR);
-}
+#else
+  error ("O_RDWR: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_SYNC)
 DEFUNX ("O_SYNC", FO_SYNC, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_SYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 synchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_SYNC)
   return const_value (args, O_SYNC);
-}
+#else
+  error ("O_SYNC: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_TRUNC)
 DEFUNX ("O_TRUNC", FO_TRUNC, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} O_TRUNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that if file exists, it should\n\
 be truncated when writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_TRUNC)
   return const_value (args, O_TRUNC);
-}
+#else
+  error ("O_TRUNC: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_WRONLY)
 DEFUNX ("O_WRONLY", FO_WRONLY, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_WRONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 writing only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC}\n\
 @end deftypefn")
 {
+#if defined (O_WRONLY)
   return const_value (args, O_WRONLY);
+#else
+  error ("O_WRONLY: not available on this system");
+  return octave_value ();
+#endif
 }
-#endif
 
 #if !defined (WNOHANG)
 #define WNOHANG 0
 #endif
 
 DEFUNX ("WNOHANG", FWNOHANG, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WNOHANG ()\n\
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -664,30 +664,16 @@ main_loop (void)
 
 // Fix up things before exiting.
 
 void
 clean_up_and_exit (int retval)
 {
   do_octave_atexit ();
 
-  OCTAVE_SAFE_CALL (gh_manager::close_all_figures, ());
-
-  OCTAVE_SAFE_CALL (gtk_manager::unload_all_toolkits, ());
-
-  OCTAVE_SAFE_CALL (symbol_table::cleanup, ());
-
-  OCTAVE_SAFE_CALL (cleanup_parser, ());
-
-  OCTAVE_SAFE_CALL (sysdep_cleanup, ());
-
-  OCTAVE_SAFE_CALL (singleton_cleanup_list::cleanup, ());
-
-  OCTAVE_SAFE_CALL (octave_chunk_buffer::clear, ());
-
   if (octave_exit)
     (*octave_exit) (retval == EOF ? 0 : retval);
 }
 
 DEFUN (quit, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} exit (@var{status})\n\
 @deftypefnx {Built-in Function} {} quit (@var{status})\n\
@@ -1065,31 +1051,45 @@ do_octave_atexit (void)
       // FIXME -- is this needed?  Can it cause any trouble?
       OCTAVE_SAFE_CALL (raw_mode, (0));
 
       OCTAVE_SAFE_CALL (octave_history_write_timestamp, ());
 
       if (! command_history::ignoring_entries ())
         OCTAVE_SAFE_CALL (command_history::clean_up_and_save, ());
 
+      OCTAVE_SAFE_CALL (gh_manager::close_all_figures, ());
+
+      OCTAVE_SAFE_CALL (gtk_manager::unload_all_toolkits, ());
+
       OCTAVE_SAFE_CALL (close_files, ());
 
       OCTAVE_SAFE_CALL (cleanup_tmp_files, ());
 
+      OCTAVE_SAFE_CALL (symbol_table::cleanup, ());
+
+      OCTAVE_SAFE_CALL (cleanup_parser, ());
+
+      OCTAVE_SAFE_CALL (sysdep_cleanup, ());
+
       OCTAVE_SAFE_CALL (flush_octave_stdout, ());
 
       if (! quitting_gracefully && (interactive || forced_interactive))
         {
           octave_stdout << "\n";
 
           // Yes, we want this to be separate from the call to
           // flush_octave_stdout above.
 
           OCTAVE_SAFE_CALL (flush_octave_stdout, ());
         }
+
+      OCTAVE_SAFE_CALL (singleton_cleanup_list::cleanup, ());
+
+      OCTAVE_SAFE_CALL (octave_chunk_buffer::clear, ());
     }
 }
 
 void
 octave_add_atexit_function (const std::string& fname)
 {
   octave_atexit_functions.push_front (fname);
 }
diff --git a/src/version.h.in b/src/version.h.in
--- a/src/version.h.in
+++ b/src/version.h.in
@@ -82,11 +82,13 @@ For more information, visit http://www.o
   OCTAVE_BUGS_STATEMENT
 
 #define OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS \
   X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS ("")
 
 #define OCTAVE_STARTUP_MESSAGE \
   X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS \
     ("  For details, type `warranty'.") "\n\n" \
-  "For information about changes from previous versions, type `news'."
-
+  "For information about changes from previous versions, type `news'.\n\n\
+** WARNING ** Semantics for arithmetic operators have changed and now\n\
+              broadcast. Type `doc broadcast' to get a description of\n\
+              the changes."
 #endif
diff --git a/test/test_index-wfi-t.m b/test/test_index-wfi-t.m
deleted file mode 100644
--- a/test/test_index-wfi-t.m
+++ /dev/null
@@ -1,262 +0,0 @@
-## Copyright (C) 2006-2011 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-%% test/octave.test/index-wfi-t/s-1.m
-%!test
-%! a = [];
-%! assert(isempty (a));
-
-%% test/octave.test/index-wfi-t/s-2.m
-%!test
-%! a = 1;
-%! assert(a(1),1);
-
-%% test/octave.test/index-wfi-t/s-3.m
-%!test
-%! a = 1;
-%! assert(a(:),1);
-
-%% test/octave.test/index-wfi-t/s-4.m
-%!test
-%! a = 1;
-%! assert(a(:,:),1);
-
-%% test/octave.test/index-wfi-t/s-5.m
-%!test
-%! a = 1;
-%! assert(a(1,:),1);
-
-%% test/octave.test/index-wfi-t/s-6.m
-%!test
-%! a = 1;
-%! assert(a(:,1),1);
-
-%% test/octave.test/index-wfi-t/s-7.m
-%!test
-%! a = 1;
-%! assert(isempty (a(logical (0))));
-
-%% test/octave.test/index-wfi-t/s-8.m
-%!test
-%! a = 1;
-%! fail("a(-1);");
-
-%% test/octave.test/index-wfi-t/s-9.m
-%!test
-%! a = 1;
-%! fail("a(2);");
-
-%% test/octave.test/index-wfi-t/s-10.m
-%!test
-%! a = 1;
-%! fail("a(2,:);");
-
-%% test/octave.test/index-wfi-t/s-11.m
-%!test
-%! a = 1;
-%! fail("a(:,2);");
-
-%% test/octave.test/index-wfi-t/s-12.m
-%!test
-%! a = 1;
-%! fail("a(-1,:);");
-
-%% test/octave.test/index-wfi-t/s-13.m
-%!test
-%! a = 1;
-%! fail("a(:,-1);");
-
-%% test/octave.test/index-wfi-t/s-14.m
-%!test
-%! a = 1;
-%! fail("a([1,2,3]);");
-
-%% test/octave.test/index-wfi-t/s-15.m
-%!test
-%! a = 1;
-%! fail("a([1;2;3]);");
-
-%% test/octave.test/index-wfi-t/s-16.m
-%!test
-%! a = 1;
-%! fail("a([1,2;3,4]);");
-
-%% test/octave.test/index-wfi-t/s-17.m
-%!test
-%! a = 1;
-%! fail("a([0,1]);");
-
-%% test/octave.test/index-wfi-t/s-18.m
-%!test
-%! a = 1;
-%! fail("a([0;1]);");
-
-%% test/octave.test/index-wfi-t/s-19.m
-%!test
-%! a = 1;
-%! fail("a([-1,0]);");
-
-%% test/octave.test/index-wfi-t/s-20.m
-%!test
-%! a = 1;
-%! fail("a([-1;0]);");
-
-%% test/octave.test/index-wfi-t/v-1.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(1),4);
-
-%% test/octave.test/index-wfi-t/v-2.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(2),3);
-
-%% test/octave.test/index-wfi-t/v-3.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(:) == a_prime));
-
-%% test/octave.test/index-wfi-t/v-4.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(1,:) == a));
-
-%% test/octave.test/index-wfi-t/v-5.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(:,3),2);
-
-%% test/octave.test/index-wfi-t/v-6.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(:,:) == a));
-
-%% test/octave.test/index-wfi-t/v-7.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(logical ([0,1,1,0])) == mid_a));
-
-%% test/octave.test/index-wfi-t/v-8.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(0);");
-
-%% test/octave.test/index-wfi-t/v-9.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(5);");
-
-%% test/octave.test/index-wfi-t/v-10.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(0,1);");
-
-%% test/octave.test/index-wfi-t/v-11.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a(logical (0),:)));
-
-%% test/octave.test/index-wfi-t/v-12.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(:,0);");
-
-%% test/octave.test/index-wfi-t/v-13.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a([])));
-
-%% test/octave.test/index-wfi-t/v-14.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a([],:)));
-
-%% test/octave.test/index-wfi-t/v-15.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a(:,[])));
-
-%% test/octave.test/index-wfi-t/m-1.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! assert(all (all (a(:,:) == a)));
-
-%% test/octave.test/index-wfi-t/m-2.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! assert(all (a(:) == a_fvec));
-
-%% test/octave.test/index-wfi-t/m-3.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! fail("a(0);");
-
-%% test/octave.test/index-wfi-t/m-4.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! fail("a(2);","warning");
diff --git a/test/test_index-wfi-f.m b/test/test_index.m
rename from test/test_index-wfi-f.m
rename to test/test_index.m
--- a/test/test_index-wfi-f.m
+++ b/test/test_index.m
@@ -11,252 +11,213 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/index-wfi-f/s-1.m
 %!test
 %! a = [];
 %! assert(isempty (a));
 
-%% test/octave.test/index-wfi-f/s-2.m
 %!test
 %! a = 1;
 %! assert(a(1),1);
 
-%% test/octave.test/index-wfi-f/s-3.m
 %!test
 %! a = 1;
 %! assert(a(:),1);
 
-%% test/octave.test/index-wfi-f/s-4.m
 %!test
 %! a = 1;
 %! assert(a(:,:),1);
 
-%% test/octave.test/index-wfi-f/s-5.m
 %!test
 %! a = 1;
 %! assert(a(1,:),1);
 
-%% test/octave.test/index-wfi-f/s-6.m
 %!test
 %! a = 1;
 %! assert(a(:,1),1);
 
-%% test/octave.test/index-wfi-f/s-7.m
 %!test
 %! a = 1;
 %! assert(isempty (a(logical (0))));
 
-%% test/octave.test/index-wfi-f/s-8.m
 %!test
 %! a = 1;
 %! fail("a(-1)");
 
-%% test/octave.test/index-wfi-f/s-9.m
 %!test
 %! a = 1;
 %! fail("a(2);");
 
-%% test/octave.test/index-wfi-f/s-10.m
 %!test
 %! a = 1;
 %! fail("a(2,:);");
 
-%% test/octave.test/index-wfi-f/s-11.m
 %!test
 %! a = 1;
 %! fail("a(:,2);");
 
-%% test/octave.test/index-wfi-f/s-12.m
 %!test
 %! a = 1;
 %! fail("a(-1,:);");
 
-%% test/octave.test/index-wfi-f/s-13.m
 %!test
 %! a = 1;
 %! fail("a(:,-1);");
 
-%% test/octave.test/index-wfi-f/s-14.m
 %!test
 %! a = 1;
 %! fail("a([1,2,3]);");
 
-%% test/octave.test/index-wfi-f/s-15.m
 %!test
 %! a = 1;
 %! fail("a([1;2;3]);");
 
-%% test/octave.test/index-wfi-f/s-16.m
 %!test
 %! a = 1;
 %! fail("a([1,2;3,4]);");
 
-%% test/octave.test/index-wfi-f/s-17.m
 %!test
 %! a = 1;
 %! fail("a([0,1]);");
 
-%% test/octave.test/index-wfi-f/s-18.m
 %!test
 %! a = 1;
 %! fail("a([0;1]);");
 
-%% test/octave.test/index-wfi-f/s-19.m
 %!test
 %! a = 1;
 %! fail("a([-1,0]);");
 
-%% test/octave.test/index-wfi-f/s-20.m
 %!test
 %! a = 1;
 %! fail("a([-1;0]);");
 
-%% test/octave.test/index-wfi-f/v-1.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(1),4);
 
-%% test/octave.test/index-wfi-f/v-2.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(2),3);
 
-%% test/octave.test/index-wfi-f/v-3.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(:) == a_prime));
 
-%% test/octave.test/index-wfi-f/v-4.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(1,:) == a));
 
-%% test/octave.test/index-wfi-f/v-5.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(:,3),2);
 
-%% test/octave.test/index-wfi-f/v-6.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(:,:) == a));
 
-%% test/octave.test/index-wfi-f/v-7.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(logical ([0,1,1,0])) == mid_a));
 
-%% test/octave.test/index-wfi-f/v-8.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(0);");
 
-%% test/octave.test/index-wfi-f/v-9.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(5);");
 
-%% test/octave.test/index-wfi-f/v-10.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(0,1);");
 
-%% test/octave.test/index-wfi-f/v-11.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a(logical (0),:)));
 
-%% test/octave.test/index-wfi-f/v-12.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(:,0);");
 
-%% test/octave.test/index-wfi-f/v-13.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a([])));
 
-%% test/octave.test/index-wfi-f/v-14.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a([],:)));
 
-%% test/octave.test/index-wfi-f/v-15.m
 %!test
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a(:,[])));
 
-%% test/octave.test/index-wfi-f/m-1.m
 %!test
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(all (all (a(:,:) == a)));
 
-%% test/octave.test/index-wfi-f/m-2.m
 %!test
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(all (a(:) == a_fvec));
 
-%% test/octave.test/index-wfi-f/m-3.m
 %!test
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! fail("a(0);");
 
-%% test/octave.test/index-wfi-f/m-4.m
 %!test
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(a(2),3);
@@ -383,8 +344,14 @@
 %! a(1,:,:) = reshape(1:4,[1,1,4]);
 %! assert (a, [1:4]);
 
 %!test
 %! a(1,:,:,:) = reshape(1:4,[1,1,4]);
 %! assert (a, reshape (1:4,[1,1,1,4]));
 
 %!error (a(1:2,1:2) = 1:4)
+
+%!shared x
+%! x = 1:5;
+%!error <attempted to use a complex scalar as an index> x(i)
+%!error <attempted to use a complex scalar as an index> x(j)
+%!error <attempted to use a complex scalar as an index> x(1+i)
diff --git a/test/test_logical-wfi-t.m b/test/test_logical-wfi-t.m
deleted file mode 100644
--- a/test/test_logical-wfi-t.m
+++ /dev/null
@@ -1,239 +0,0 @@
-## Copyright (C) 2006-2011 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-%% test/octave.test/logical-wfi-t/s-1.m
-%!test
-%! a = [];
-%! fail("a(0);");
-
-%% test/octave.test/logical-wfi-t/s-2.m
-%!test
-%! a = 2;
-%! assert(a(1) == 2);
-
-%% test/octave.test/logical-wfi-t/s-3.m
-%!test
-%! a = 2;
-%! assert(a(1) == 2);
-
-%% test/octave.test/logical-wfi-t/s-4.m
-%!test
-%!shared a
-%! a = 2;
-%!error id=Octave:index-out-of-bounds a(logical ([1,1]));
-
-%% test/octave.test/logical-wfi-t/v-1.m
-%!test
-%! a = [9,8,7,6];
-%! assert(isempty (a(logical ([0,0,0,0]))));
-
-%% test/octave.test/logical-wfi-t/v-2.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([1,1,1,1])) == [9,8,7,6]));
-
-%% test/octave.test/logical-wfi-t/v-3.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([0,1,1,0])) == [8,7]));
-
-%% test/octave.test/logical-wfi-t/v-4.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([1,1])) == [9,8]));
-
-%% test/octave.test/logical-wfi-t/m-1.m
-%!test
-%! a = [9,8;7,6];
-%! isempty (a(logical ([0,0,0,0])));
-
-%% test/octave.test/logical-wfi-t/m-2.m
-%!test
-%! a = [9,8;7,6];
-%! all (a(logical ([1,1,1,1])) == [9,7,8,6]);
-
-%% test/octave.test/logical-wfi-t/m-3.m
-%!test
-%! a = [9,8;7,6];
-%! all (a(logical ([0,1,1,0])) == [7,8]);
-
-%% test/octave.test/logical-wfi-t/m-4.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),logical (0:1)) == 6);
-
-%% test/octave.test/logical-wfi-t/m-5.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),2:-1:1) == [6,7]));
-
-%% test/octave.test/logical-wfi-t/m-6.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),logical ([0,1])) == 6);
-
-%% test/octave.test/logical-wfi-t/m-7.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),[2,1]) == [6,7]));
-
-%% test/octave.test/logical-wfi-t/m-8.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),:) == [7,6]));
-
-%% test/octave.test/logical-wfi-t/m-9.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),1) == 7);
-
-%% test/octave.test/logical-wfi-t/m-10.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),logical ([1,1])) == [7,6]));
-
-%% test/octave.test/logical-wfi-t/m-11.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(2:-1:1,logical (0:1)) == [6;8]));
-
-%% test/octave.test/logical-wfi-t/m-12.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(2:-1:1,logical ([0,1])) == [6;8]));
-
-%% test/octave.test/logical-wfi-t/m-13.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(2:-1:1,logical ([1,1])) == [7,6;9,8])));
-
-%% test/octave.test/logical-wfi-t/m-14.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),logical (0:1)) == 6);
-
-%% test/octave.test/logical-wfi-t/m-15.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),2:-1:1) == [6,7]));
-
-%% test/octave.test/logical-wfi-t/m-16.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),logical ([0,1])) == 6);
-
-%% test/octave.test/logical-wfi-t/m-17.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),[2,1]) == [6,7]));
-
-%% test/octave.test/logical-wfi-t/m-18.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),:) == [7,6]));
-
-%% test/octave.test/logical-wfi-t/m-19.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),1) == 7);
-
-%% test/octave.test/logical-wfi-t/m-20.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),logical ([1,1])) == [7,6]));
-
-%% test/octave.test/logical-wfi-t/m-21.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a([2,1],logical (0:1)) == [6;8]));
-
-%% test/octave.test/logical-wfi-t/m-22.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a([2,1],logical ([0,1])) == [6;8]));
-
-%% test/octave.test/logical-wfi-t/m-23.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a([2,1],logical ([1,1])) == [7,6;9,8])));
-
-%% test/octave.test/logical-wfi-t/m-24.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(:,logical (0:1)) == [8;6]));
-
-%% test/octave.test/logical-wfi-t/m-25.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(:,logical ([0,1])) == [8;6]));
-
-%% test/octave.test/logical-wfi-t/m-26.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(:,logical ([1,1])) == [9,8;7,6])));
-
-%% test/octave.test/logical-wfi-t/m-27.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(1,logical (0:1)) == 8);
-
-%% test/octave.test/logical-wfi-t/m-28.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(1,logical ([0,1])) == 8);
-
-%% test/octave.test/logical-wfi-t/m-29.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(1,logical ([1,1])) == [9,8]));
-
-%% test/octave.test/logical-wfi-t/m-30.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),logical (0:1)) == [8;6]));
-
-%% test/octave.test/logical-wfi-t/m-31.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),2:-1:1) == [8,9;6,7])));
-
-%% test/octave.test/logical-wfi-t/m-32.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),logical ([0,1])) == [8;6]));
-
-%% test/octave.test/logical-wfi-t/m-33.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),[2,1]) == [8,9;6,7])));
-
-%% test/octave.test/logical-wfi-t/m-34.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),:) == [9,8;7,6])));
-
-%% test/octave.test/logical-wfi-t/m-35.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),1) == [9;7]));
-
-%% test/octave.test/logical-wfi-t/m-36.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),logical ([1,1])) == [9,8;7,6])));
-
diff --git a/test/test_logical-wfi-f.m b/test/test_logical_index.m
rename from test/test_logical-wfi-f.m
rename to test/test_logical_index.m
--- a/test/test_logical-wfi-f.m
+++ b/test/test_logical_index.m
@@ -11,229 +11,185 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/logical-wfi-f/s-1.m
 %!test
 %! a = [];
 %! fail("a(0);");
 
-%% test/octave.test/logical-wfi-f/s-2.m
 %!test
 %! a = 2;
 %! assert(a(1) == 2);
 
-%% test/octave.test/logical-wfi-f/s-3.m
 %!test
 %! a = 2;
 %! assert(a(1) == 2);
 
-%% test/octave.test/logical-wfi-f/s-4.m
 %!test
 %!shared a
 %!  a = 2;
 %!error id=Octave:index-out-of-bounds a(logical ([1,1]));
 
-%% test/octave.test/logical-wfi-f/v-1.m
 %!test
 %! a = [9,8,7,6];
 %! assert(isempty (a(logical ([0,0,0,0]))));
 
-%% test/octave.test/logical-wfi-f/v-2.m
 %!test
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([1,1,1,1])) == [9,8,7,6]));
 
-%% test/octave.test/logical-wfi-f/v-3.m
 %!test
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([0,1,1,0])) == [8,7]));
 
-%% test/octave.test/logical-wfi-f/v-4.m
 %!test
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([1,1])) == [9,8]));
 
-%% test/octave.test/logical-wfi-f/m-1.m
 %!test
 %! a = [9,8;7,6];
 %! assert(isempty (a(logical ([0,0,0,0]))));
 
-%% test/octave.test/logical-wfi-f/m-2.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1,1,1])) == [9,7,8,6]));
 
-%% test/octave.test/logical-wfi-f/m-3.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1,1,0])) == [7,8]));
 
-%% test/octave.test/logical-wfi-f/m-4.m
 %!test
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),logical (0:1)) == 6);
 
-%% test/octave.test/logical-wfi-f/m-5.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),2:-1:1) == [6,7]));
 
-%% test/octave.test/logical-wfi-f/m-6.m
 %!test
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),logical ([0,1])) == 6);
 
-%% test/octave.test/logical-wfi-f/m-7.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),[2,1]) == [6,7]));
 
-%% test/octave.test/logical-wfi-f/m-8.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),:) == [7,6]));
 
-%% test/octave.test/logical-wfi-f/m-9.m
 %!test
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),1) == 7);
 
-%% test/octave.test/logical-wfi-f/m-10.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),logical ([1,1])) == [7,6]));
 
-%% test/octave.test/logical-wfi-f/m-11.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(2:-1:1,logical (0:1)) == [6;8]));
 
-%% test/octave.test/logical-wfi-f/m-12.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(2:-1:1,logical ([0,1])) == [6;8]));
 
-%% test/octave.test/logical-wfi-f/m-13.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (all (a(2:-1:1,logical ([1,1])) == [7,6;9,8])));
 
-%% test/octave.test/logical-wfi-f/m-14.m
 %!test
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),logical (0:1)) == 6);
 
-%% test/octave.test/logical-wfi-f/m-15.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),2:-1:1) == [6,7]));
 
-%% test/octave.test/logical-wfi-f/m-16.m
 %!test
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),logical ([0,1])) == 6);
 
-%% test/octave.test/logical-wfi-f/m-17.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),[2,1]) == [6,7]));
 
-%% test/octave.test/logical-wfi-f/m-18.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),:) == [7,6]));
 
-%% test/octave.test/logical-wfi-f/m-19.m
 %!test
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),1) == 7);
 
-%% test/octave.test/logical-wfi-f/m-20.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),logical ([1,1])) == [7,6]));
 
-%% test/octave.test/logical-wfi-f/m-21.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a([2,1],logical (0:1)) == [6;8]));
 
-%% test/octave.test/logical-wfi-f/m-22.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a([2,1],logical ([0,1])) == [6;8]));
 
-%% test/octave.test/logical-wfi-f/m-23.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (all (a([2,1],logical ([1,1])) == [7,6;9,8])));
 
-%% test/octave.test/logical-wfi-f/m-24.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(:,logical (0:1)) == [8;6]));
 
-%% test/octave.test/logical-wfi-f/m-25.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(:,logical ([0,1])) == [8;6]));
 
-%% test/octave.test/logical-wfi-f/m-26.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (all (a(:,logical ([1,1])) == [9,8;7,6])));
 
-%% test/octave.test/logical-wfi-f/m-27.m
 %!test
 %! a = [9,8;7,6];
 %! assert(a(1,logical (0:1)) == 8);
 
-%% test/octave.test/logical-wfi-f/m-28.m
 %!test
 %! a = [9,8;7,6];
 %! assert(a(1,logical ([0,1])) == 8);
 
-%% test/octave.test/logical-wfi-f/m-29.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(1,logical ([1,1])) == [9,8]));
 
-%% test/octave.test/logical-wfi-f/m-30.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),logical (0:1)) == [8;6]));
 
-%% test/octave.test/logical-wfi-f/m-31.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),2:-1:1) == [8,9;6,7])));
 
-%% test/octave.test/logical-wfi-f/m-32.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),logical ([0,1])) == [8;6]));
 
-%% test/octave.test/logical-wfi-f/m-33.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),[2,1]) == [8,9;6,7])));
 
-%% test/octave.test/logical-wfi-f/m-34.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),:) == [9,8;7,6])));
 
-%% test/octave.test/logical-wfi-f/m-35.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),1) == [9;7]));
 
-%% test/octave.test/logical-wfi-f/m-36.m
 %!test
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),logical ([1,1])) == [9,8;7,6])));
 
