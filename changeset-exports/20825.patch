# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1449602405 18000
#      Tue Dec 08 14:20:05 2015 -0500
# Node ID 66cd994d1b790ea7f42e8bc149d2e248788a3b87
# Parent  8848e35e5ef8bf2632fcf2d74ddb35ab719b9190
eliminate return statements after calls to error

* __delaunayn__.cc, __eigs__.cc, __fltk_uigetfile__.cc, __glpk__.cc,
__init_fltk__.cc, __magick_read__.cc, __osmesa_print__.cc,
__voronoi__.cc, audiodevinfo.cc, audioread.cc, ccolamd.cc, colamd.cc,
convhulln.cc: Eliminate return statements after calls to error.

diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -125,20 +125,17 @@ Undocumented internal function.\n\
         {
           options = "";
           Array<std::string> tmp = args(1).cellstr_value ();
 
           for (octave_idx_type i = 0; i < tmp.numel (); i++)
             options += tmp(i) + " ";
         }
       else
-        {
-          error ("__delaunayn__: OPTIONS argument must be a string, cell array of strings, or empty");
-          return retval;
-        }
+        error ("__delaunayn__: OPTIONS argument must be a string, cell array of strings, or empty");
     }
 
   if (n > dim + 1)
     {
       p = p.transpose ();
       double *pt_array = p.fortran_vec ();
       boolT ismalloc = false;
 
@@ -155,20 +152,17 @@ Undocumented internal function.\n\
 #else
       FILE *outfile = gnulib::fopen ("/dev/null", "w");
 #endif
       FILE *errfile = stderr;
 
       if (outfile)
         frame.add_fcn (close_fcn, outfile);
       else
-        {
-          error ("__delaunayn__: unable to create temporary file for output");
-          return retval;
-        }
+        error ("__delaunayn__: unable to create temporary file for output");
 
       int exitcode = qh_new_qhull (dim, n, pt_array,
                                    ismalloc, flags, outfile, errfile);
       if (! exitcode)
         {
           // triangulate non-simplicial facets
           qh_triangulate ();
 
@@ -179,21 +173,17 @@ Undocumented internal function.\n\
 
           FORALLfacets
             {
               if (! facet->upperdelaunay)
                 nf++;
 
               // Double check.  Non-simplicial facets will cause segfault below
               if (! facet->simplicial)
-                {
-                  error ("__delaunayn__: Qhull returned non-simplicial facets -- try delaunayn with different options");
-                  exitcode = 1;
-                  break;
-                }
+                error ("__delaunayn__: Qhull returned non-simplicial facets -- try delaunayn with different options");
             }
 
           if (! exitcode)
             {
               Matrix simpl (nf, dim+1);
 
               FORALLfacets
                 {
@@ -232,17 +222,19 @@ Undocumented internal function.\n\
       RowVector vec (n);
       for (octave_idx_type i = 0; i < n; i++)
         vec(i) = i + 1.0;
 
       retval(0) = vec;
     }
 
 #else
+
   error ("__delaunayn__: not available in this version of Octave");
+
 #endif
 
   return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -209,26 +209,20 @@ Undocumented internal function.\n\
           fname.append ("(x) y = ");
           eigs_fcn = extract_function (args(0), "eigs", fcn_name, fname,
                                        "; endfunction");
         }
       else
         eigs_fcn = args(0).function_value ();
 
       if (!eigs_fcn)
-        {
-          error ("eigs: unknown function");
-          return retval;
-        }
+        error ("eigs: unknown function");
 
       if (nargin < 2)
-        {
-          error ("eigs: incorrect number of arguments");
-          return retval;
-        }
+        error ("eigs: incorrect number of arguments");
       else
         {
           n = args(1).nint_value ();
           arg_offset = 1;
           have_a_fun = true;
         }
     }
   else
@@ -360,20 +354,17 @@ Undocumented internal function.\n\
           if (tmp.is_defined ())
             permB = ColumnVector (tmp.vector_value ()) - 1.0;
         }
       else
         error ("eigs: OPTS argument must be a structure");
     }
 
   if (nargin > (4+arg_offset))
-    {
-      error ("eigs: incorrect number of arguments");
-      return retval;
-    }
+    error ("eigs: incorrect number of arguments");
 
   // Test undeclared (no issym) matrix inputs for symmetry
   if (!sym_tested && !have_a_fun)
     {
       if (a_is_sparse)
         symmetric = asmm.is_symmetric ();
       else
         symmetric = amm.is_symmetric ();
@@ -583,14 +574,15 @@ Undocumented internal function.\n\
   if (nconv <= 0)
     warning ("eigs: None of the %d requested eigenvalues converged", k);
   else if (nconv < k)
     warning ("eigs: Only %d of the %d requested eigenvalues converged",
              nconv, k);
 
   if (! fcn_name.empty ())
     clear_function (fcn_name);
+
 #else
   error ("eigs: not available in this version of Octave");
 #endif
 
   return retval;
 }
diff --git a/libinterp/dldfcn/__fltk_uigetfile__.cc b/libinterp/dldfcn/__fltk_uigetfile__.cc
--- a/libinterp/dldfcn/__fltk_uigetfile__.cc
+++ b/libinterp/dldfcn/__fltk_uigetfile__.cc
@@ -131,19 +131,24 @@ Undocumented internal function.\n\
           retval(2) = fc.filter_value () + 1;
         }
     }
 
   fc.hide ();
   Fl::flush ();
 
   return retval;
+
 #else
+
   error ("__fltk_uigetfile__: not available without OpenGL and FLTK libraries");
-  return octave_value ();
+
+  return octave_value_list ();
+
 #endif
+
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -304,38 +304,32 @@ glpk (int sense, int n, int m, double *c
     { \
       octave_value tmp = PARAM.getfield (NAME); \
  \
       if (tmp.is_defined ()) \
         { \
           if (! tmp.is_empty ()) \
             VAL = tmp.xscalar_value ("glpk: invalid value in PARAM" NAME); \
           else \
-            { \
-              error ("glpk: invalid value in PARAM" NAME); \
-              return retval; \
-            } \
+            error ("glpk: invalid value in PARAM" NAME); \
         } \
     } \
   while (0)
 
 #define OCTAVE_GLPK_GET_INT_PARAM(NAME, VAL) \
   do \
     { \
       octave_value tmp = PARAM.getfield (NAME); \
  \
       if (tmp.is_defined ()) \
         { \
           if (! tmp.is_empty ()) \
             VAL = tmp.xint_value ("glpk: invalid value in PARAM" NAME); \
           else \
-            { \
-              error ("glpk: invalid value in PARAM" NAME); \
-              return retval; \
-            } \
+            error ("glpk: invalid value in PARAM" NAME); \
         } \
     } \
   while (0)
 
 DEFUN_DLD (__glpk__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{values}] =} __glpk__ (@var{args})\n\
 Undocumented internal function.\n\
@@ -371,20 +365,17 @@ Undocumented internal function.\n\
       mrowsA = A.rows ();
       octave_idx_type Anc = A.cols ();
       octave_idx_type Anz = A.nnz ();
       rn.resize (dim_vector (Anz+1, 1));
       cn.resize (dim_vector (Anz+1, 1));
       a.resize (Anz+1, 0.0);
 
       if (Anc != mrowsc)
-        {
-          error ("__glpk__: invalid value of A");
-          return retval;
-        }
+        error ("__glpk__: invalid value of A");
 
       for (octave_idx_type j = 0; j < Anc; j++)
         for (octave_idx_type i = A.cidx (j); i < A.cidx (j+1); i++)
           {
             nz++;
             rn(nz) = A.ridx (i) + 1;
             cn(nz) = j + 1;
             a(nz) = A.data(i);
@@ -421,20 +412,17 @@ Undocumented internal function.\n\
 
   double *b = B.fortran_vec ();
 
   //-- 4th Input. An array of length mrowsc containing the lower
   //--            bound on each of the variables.
   Matrix LB = args(3).xmatrix_value ("__glpk__: invalid value of LB");
 
   if (LB.numel () < mrowsc)
-    {
-      error ("__glpk__: invalid dimensions for LB");
-      return retval;
-    }
+    error ("__glpk__: invalid dimensions for LB");
 
   double *lb = LB.fortran_vec ();
 
   //-- LB argument, default: Free
   Array<int> freeLB (dim_vector (mrowsc, 1));
   for (int i = 0; i < mrowsc; i++)
     {
       if (xisinf (lb[i]))
@@ -446,20 +434,17 @@ Undocumented internal function.\n\
         freeLB(i) = 0;
     }
 
   //-- 5th Input. An array of at least length numcols containing the upper
   //--            bound on each of the variables.
   Matrix UB = args(4).xmatrix_value ("__glpk__: invalid value of UB");
 
   if (UB.numel () < mrowsc)
-    {
-      error ("__glpk__: invalid dimensions for UB");
-      return retval;
-    }
+    error ("__glpk__: invalid dimensions for UB");
 
   double *ub = UB.fortran_vec ();
 
   Array<int> freeUB (dim_vector (mrowsc, 1));
   for (int i = 0; i < mrowsc; i++)
     {
       if (xisinf (ub[i]))
         {
@@ -509,100 +494,73 @@ Undocumented internal function.\n\
   //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   //-- Integer parameters
   //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
   //-- Level of messages output by the solver
   par.msglev = 1;
   OCTAVE_GLPK_GET_INT_PARAM ("msglev", par.msglev);
   if (par.msglev < 0 || par.msglev > 3)
-    {
-      error ("__glpk__: PARAM.msglev must be 0 (no output) or 1 (error and warning messages only [default]) or 2 (normal output) or 3 (full output)");
-      return retval;
-    }
+    error ("__glpk__: PARAM.msglev must be 0 (no output) or 1 (error and warning messages only [default]) or 2 (normal output) or 3 (full output)");
 
   //-- scaling option
   volatile int scale = 16;
   OCTAVE_GLPK_GET_INT_PARAM ("scale", scale);
   if (scale < 0 || scale > 128)
-    {
-      error ("__glpk__: PARAM.scale must either be 128 (automatic selection of scaling options), or a bitwise or of: 1 (geometric mean scaling), 16 (equilibration scaling), 32 (round scale factors to power of two), 64 (skip if problem is well scaled");
-      return retval;
-    }
+    error ("__glpk__: PARAM.scale must either be 128 (automatic selection of scaling options), or a bitwise or of: 1 (geometric mean scaling), 16 (equilibration scaling), 32 (round scale factors to power of two), 64 (skip if problem is well scaled");
 
   //-- Dual simplex option
   par.dual = 1;
   OCTAVE_GLPK_GET_INT_PARAM ("dual", par.dual);
   if (par.dual < 1 || par.dual > 3)
-    {
-      error ("__glpk__: PARAM.dual must be 1 (use two-phase primal simplex [default]) or 2 (use two-phase dual simplex) or 3 (use two-phase dual simplex, and if it fails, switch to the primal simplex)");
-      return retval;
-    }
+    error ("__glpk__: PARAM.dual must be 1 (use two-phase primal simplex [default]) or 2 (use two-phase dual simplex) or 3 (use two-phase dual simplex, and if it fails, switch to the primal simplex)");
 
   //-- Pricing option
   par.price = 34;
   OCTAVE_GLPK_GET_INT_PARAM ("price", par.price);
   if (par.price != 17 && par.price != 34)
-    {
-      error ("__glpk__: PARAM.price must be 17 (textbook pricing) or 34 (steepest edge pricing [default])");
-      return retval;
-    }
+    error ("__glpk__: PARAM.price must be 17 (textbook pricing) or 34 (steepest edge pricing [default])");
 
   //-- Simplex iterations limit
   par.itlim = std::numeric_limits<int>::max ();
   OCTAVE_GLPK_GET_INT_PARAM ("itlim", par.itlim);
 
   //-- Output frequency, in iterations
   par.outfrq = 200;
   OCTAVE_GLPK_GET_INT_PARAM ("outfrq", par.outfrq);
 
   //-- Branching heuristic option
   par.branch = 4;
   OCTAVE_GLPK_GET_INT_PARAM ("branch", par.branch);
   if (par.branch < 1 || par.branch > 5)
-    {
-      error ("__glpk__: PARAM.branch must be 1 (first fractional variable) or 2 (last fractional variable) or 3 (most fractional variable) or 4 (heuristic by Driebeck and Tomlin [default]) or 5 (hybrid pseudocost heuristic)");
-      return retval;
-    }
+    error ("__glpk__: PARAM.branch must be 1 (first fractional variable) or 2 (last fractional variable) or 3 (most fractional variable) or 4 (heuristic by Driebeck and Tomlin [default]) or 5 (hybrid pseudocost heuristic)");
 
   //-- Backtracking heuristic option
   par.btrack = 4;
   OCTAVE_GLPK_GET_INT_PARAM ("btrack", par.btrack);
   if (par.btrack < 1 || par.btrack > 4)
-    {
-      error ("__glpk__: PARAM.btrack must be 1 (depth first search) or 2 (breadth first search) or 3 (best local bound) or 4 (best projection heuristic [default]");
-      return retval;
-    }
+    error ("__glpk__: PARAM.btrack must be 1 (depth first search) or 2 (breadth first search) or 3 (best local bound) or 4 (best projection heuristic [default]");
 
   //-- Presolver option
   par.presol = 1;
   OCTAVE_GLPK_GET_INT_PARAM ("presol", par.presol);
   if (par.presol < 0 || par.presol > 1)
-    {
-      error ("__glpk__: PARAM.presol must be 0 (do NOT use LP presolver) or 1 (use LP presolver [default])");
-      return retval;
-    }
+    error ("__glpk__: PARAM.presol must be 0 (do NOT use LP presolver) or 1 (use LP presolver [default])");
 
   //-- LPsolver option
   volatile int lpsolver = 1;
   OCTAVE_GLPK_GET_INT_PARAM ("lpsolver", lpsolver);
   if (lpsolver < 1 || lpsolver > 2)
-    {
-      error ("__glpk__: PARAM.lpsolver must be 1 (simplex method) or 2 (interior point method)");
-      return retval;
-    }
+    error ("__glpk__: PARAM.lpsolver must be 1 (simplex method) or 2 (interior point method)");
 
   //-- Ratio test option
   par.rtest = 34;
   OCTAVE_GLPK_GET_INT_PARAM ("rtest", par.rtest);
   if (par.rtest != 17 && par.rtest != 34)
-    {
-      error ("__glpk__: PARAM.rtest must be 17 (standard ratio test) or 34 (Harris' two-pass ratio test [default])");
-      return retval;
-    }
+    error ("__glpk__: PARAM.rtest must be 17 (standard ratio test) or 34 (Harris' two-pass ratio test [default])");
 
   par.tmlim = std::numeric_limits<int>::max ();
   OCTAVE_GLPK_GET_INT_PARAM ("tmlim", par.tmlim);
 
   par.outdly = 0;
   OCTAVE_GLPK_GET_INT_PARAM ("outdly", par.outdly);
 
   //-- Save option
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -1771,21 +1771,17 @@ public:
   static bool instance_ok (void)
   {
     bool retval = true;
 
     if (! instance)
       instance = new figure_manager ();
 
     if (! instance)
-      {
-        error ("unable to create figure_manager object!");
-
-        retval = false;
-      }
+      error ("unable to create figure_manager object!");
 
     return retval;
   }
 
   ~figure_manager (void)
   {
     close_all ();
   }
@@ -2078,17 +2074,19 @@ private:
   {
     int ind;
     if (clstr.find (fltk_idx_header,0) == 0)
       {
         std::istringstream istr (clstr.substr (fltk_idx_header.size ()));
         if (istr >> ind)
           return ind;
       }
+
     error ("figure_manager: could not recognize fltk index");
+
     return -1;
   }
 
   void idx2figprops (int idx, figure::properties& fp)
   {
     std::ostringstream ind_str;
     ind_str << fltk_idx_header << idx;
     fp.set___plot_stream__ (ind_str.str ());
@@ -2099,30 +2097,34 @@ private:
     if (fp.get___graphics_toolkit__ () == FLTK_GRAPHICS_TOOLKIT_NAME)
       {
         octave_value ps = fp.get___plot_stream__ ();
         if (ps.is_string ())
           return str2idx (ps.string_value ());
         else
           return 0;
       }
+
     error ("figure_manager: figure is not fltk");
+
     return -1;
   }
 
   static int hnd2idx (double h)
   {
     graphics_object fobj = gh_manager::get_object (h);
     if (fobj &&  fobj.isa ("figure"))
       {
         figure::properties& fp =
           dynamic_cast<figure::properties&> (fobj.get_properties ());
         return figprops2idx (fp);
       }
+
     error ("figure_manager: H (= %g) is not a figure", h);
+
     return -1;
   }
 
   static int hnd2idx (const graphics_handle& fh)
   {
     return hnd2idx (fh.value ());
   }
 };
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -664,17 +664,16 @@ read_images (std::vector<Magick::Image>&
             img_fvec += frame_stride;
           }
         retval(2) = alpha;
         break;
       }
 
     default:
       error ("__magick_read__: unknown Magick++ image type");
-      return retval;
     }
 
   retval(0) = img;
   return retval;
 }
 
 // Read a file into vector of image objects.
 void static
@@ -790,17 +789,16 @@ Use @code{imread} instead.\n\
         {
           frameidx(i)--;
           if (frameidx(i) < 0 || frameidx(i) > nFrames - 1)
             {
               // We do this check inside the loop because frameidx does not
               // need to be ordered (this is a feature and even allows for
               // some frames to be read multiple times).
               error ("imread: index/frames specified are outside the number of images");
-              return output;
             }
         }
     }
 
   // Check that all frames have the same size. We don't do this at the same
   // time we decode the image because that's done in many different places,
   // to cover the different types of images which would lead to a lot of
   // copy and paste.
@@ -810,17 +808,16 @@ Use @code{imread} instead.\n\
     const octave_idx_type n = frameidx.numel ();
     for (octave_idx_type frame = 0; frame < n; frame++)
       {
         if (nRows != imvec[frameidx(frame)].rows ()
             || nCols != imvec[frameidx(frame)].columns ())
           {
             error ("imread: all frames must have the same size but frame %i is different",
                    frameidx(frame) +1);
-            return output;
           }
       }
   }
 
   const octave_idx_type depth = get_depth (imvec[frameidx(0)]);
   if (is_indexed (imvec[frameidx(0)]))
     {
       if (depth <= 1)
@@ -828,37 +825,32 @@ Use @code{imread} instead.\n\
                                                      nargout, options);
       else if (depth <= 8)
         output = read_indexed_images<uint8NDArray>  (imvec, frameidx,
                                                      nargout, options);
       else if (depth <= 16)
         output = read_indexed_images<uint16NDArray> (imvec, frameidx,
                                                      nargout, options);
       else
-        {
-          error ("imread: indexed images with depths greater than 16-bit are not supported");
-          return output;
-        }
+        error ("imread: indexed images with depths greater than 16-bit are not supported");
     }
 
   else
     {
       if (depth <= 1)
         output = read_images<boolNDArray>   (imvec, frameidx, nargout, options);
       else if (depth <= 8)
         output = read_images<uint8NDArray>  (imvec, frameidx, nargout, options);
       else if (depth <= 16)
         output = read_images<uint16NDArray> (imvec, frameidx, nargout, options);
       else if (depth <= 32)
         output = read_images<FloatNDArray>  (imvec, frameidx, nargout, options);
       else
-        {
-          error ("imread: reading of images with %i-bit depth is not supported",
-                 depth);
-        }
+        error ("imread: reading of images with %i-bit depth is not supported",
+               depth);
     }
 
 #endif
   return output;
 }
 
 /*
 ## No test needed for internal helper function.
@@ -1077,21 +1069,18 @@ encode_uint_image (std::vector<Magick::I
     case 4:
       if (has_alpha)
         type = Magick::ColorSeparationMatteType;
       else
         type = Magick::ColorSeparationType;
       break;
 
     default:
-      {
-        // __imwrite should have already filtered this cases
-        error ("__magick_write__: wrong size on 3rd dimension");
-        return;
-      }
+      // __imwrite should have already filtered this cases
+      error ("__magick_write__: wrong size on 3rd dimension");
     }
 
   // We will be passing the values as integers with depth as specified
   // by QuantumDepth (maximum value specified by MaxRGB). This is independent
   // of the actual depth of the image. GM will then convert the values but
   // while in memory, it always keeps the values as specified by QuantumDepth.
   // From GM documentation:
   //  Color arguments are must be scaled to fit the Quantum size according to
@@ -1310,21 +1299,19 @@ encode_uint_image (std::vector<Magick::I
             m_img.syncPixels ();
             imvec.push_back (m_img);
             img_fvec += K_offset;
           }
         break;
       }
 
     default:
-      {
-        error ("__magick_write__: unrecognized Magick::ImageType");
-        return;
-      }
+      error ("__magick_write__: unrecognized Magick::ImageType");
     }
+
   return;
 }
 
 // Meant to be shared with both imfinfo and imwrite.
 static std::map<octave_idx_type, std::string>
 init_disposal_methods ()
 {
   //  GIF Specifications:
@@ -1456,37 +1443,31 @@ Use @code{imwrite} instead.\n\
           else
             {
               clip_img   = img_float2uint<NDArray> (img.array_value ());
               clip_alpha = img_float2uint<NDArray> (alpha.array_value ());
             }
           encode_uint_image<uint32NDArray> (imvec, clip_img, clip_alpha);
         }
       else
-        {
-          error ("__magick_write__: image type not supported");
-          return retval;
-        }
+        error ("__magick_write__: image type not supported");
     }
   else
     {
       // We should not get floating point indexed images here because we
       // converted them in __imwrite__.m. We should probably do it here
       // but it would look much messier.
       if (img.is_uint8_type ())
         encode_indexed_images<uint8NDArray>  (imvec, img.uint8_array_value (),
                                               cmap);
       else if (img.is_uint16_type ())
         encode_indexed_images<uint16NDArray> (imvec, img.uint16_array_value (),
                                               cmap);
       else
-        {
-          error ("__magick_write__: indexed image must be uint8, uint16 or float.");
-          return retval;
-        }
+        error ("__magick_write__: indexed image must be uint8, uint16 or float.");
     }
   static std::map<std::string, octave_idx_type> disposal_methods
     = init_reverse_disposal_methods ();
 
   const octave_idx_type nFrames = imvec.size ();
 
   const octave_idx_type quality = options.getfield ("quality").int_value ();
   const ColumnVector delaytime =
@@ -1609,17 +1590,16 @@ This is a private internal function not 
     }
   catch (Magick::Warning& w)
     {
       warning ("Magick++ warning: %s", w.what ());
     }
   catch (Magick::Exception& e)
     {
       error ("Magick++ exception: %s", e.what ());
-      return retval;
     }
 
   static const char *fields[] = {"rows", "columns", "format", 0};
   octave_scalar_map ping = octave_scalar_map (string_vector (fields));
   ping.setfield ("rows",    octave_value (img.rows ()));
   ping.setfield ("columns", octave_value (img.columns ()));
   ping.setfield ("format",  octave_value (img.magick ()));
   retval = octave_value (ping);
@@ -1908,21 +1888,18 @@ Use @code{imfinfo} instead.\n\
     {
       const octave_localtime mtime (fs.mtime ());
       const std::string filetime = mtime.strftime ("%e-%b-%Y %H:%M:%S");
       template_info.setfield ("Filename",    octave_value (filename));
       template_info.setfield ("FileModDate", octave_value (filetime));
       template_info.setfield ("FileSize",    octave_value (fs.size ()));
     }
   else
-    {
-      error ("imfinfo: error reading '%s': %s",
-             filename.c_str (), fs.error ().c_str ());
-      return retval;
-    }
+    error ("imfinfo: error reading '%s': %s", filename.c_str (),
+           fs.error ().c_str ());
 
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
       OCTAVE_QUIT;
       octave_scalar_map info_frame (template_info);
       const Magick::Image img = imvec[frame];
 
       info_frame.setfield ("Width",  octave_value (img.columns ()));
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -96,61 +96,48 @@ instead.\n\
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
 
   if (nargin == 3)
     {
       if (! (args(1).is_string () && args(2).is_string ()))
-        {
-          error ("__osmesa_print__: FILE and TERM must be strings");
-          return retval;
-        }
+        error ("__osmesa_print__: FILE and TERM must be strings");
 
 #ifndef HAVE_GL2PS_H
       error ("__osmesa_print__: Octave has been compiled without gl2ps");
-      return retval;
 #endif
     }
 
   int h = args(0).double_value ();
   graphics_object fobj = gh_manager::get_object (h);
   if (! (fobj && fobj.isa ("figure")))
-    {
-      error ("__osmesa_print__: H must be a valid figure handle");
-      return retval;
-    }
+    error ("__osmesa_print__: H must be a valid figure handle");
 
   figure::properties& fp =
     dynamic_cast<figure::properties&> (fobj.get_properties ());
 
   bool internal = true;
   Matrix bb = fp.get_boundingbox (internal);
 
   GLsizei Width = static_cast<GLsizei> (bb(2));
   GLsizei Height = static_cast<GLsizei> (bb(3));
 
   // Create an RGBA-mode context, specify Z=16, stencil=0, accum=0 sizes
   OSMesaContext ctx = OSMesaCreateContextExt (OSMESA_RGBA, 16, 0, 0, NULL);
   if (! ctx)
-    {
-      error ("__osmesa_print__: OSMesaCreateContext failed!\n");
-      return retval;
-    }
+    error ("__osmesa_print__: OSMesaCreateContext failed!\n");
 
   // Allocate the image buffer
   OCTAVE_LOCAL_BUFFER (GLubyte, buffer, 4 * Width * Height);
 
   // Bind the buffer to the context and make it current
   if (! OSMesaMakeCurrent (ctx, buffer, GL_UNSIGNED_BYTE, Width, Height))
-    {
-      error ("__osmesa_print__: OSMesaMakeCurrent failed!\n");
-      return retval;
-    }
+    error ("__osmesa_print__: OSMesaMakeCurrent failed!\n");
 
   // Test for a bug in OSMesa with version < 9.0
   //
   // Unfortunately the macros OSMESA_MAJOR_VERSION and OSMESA_MINOR_VERSION
   // weren't updated between many releases and can't be used for detection.
   // (Version 8.0 until 9.1.4 all return MAJOR 6, MINOR 5)
   GLint z, s;
   glGetIntegerv (GL_DEPTH_BITS, &z);
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -63,20 +63,17 @@ close_fcn (FILE *f)
 static bool
 octave_qhull_dims_ok (octave_idx_type dim, octave_idx_type n, const char *who)
 {
   if (sizeof (octave_idx_type) > sizeof (int))
     {
       int maxval = std::numeric_limits<int>::max ();
 
       if (dim > maxval || n > maxval)
-        {
-          error ("%s: dimension too large for Qhull", who);
-          return false;
-        }
+        error ("%s: dimension too large for Qhull", who);
     }
 
   return true;
 }
 
 DEFUN_DLD (__voronoi__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts})\n\
@@ -126,21 +123,18 @@ Undocumented internal function.\n\
           options = "";
 
           Array<std::string> tmp = opt_arg.cellstr_value ();
 
           for (octave_idx_type i = 0; i < tmp.numel (); i++)
             options += " " + tmp(i);
         }
       else
-        {
-          error ("%s: OPTIONS must be a string, cell array of strings, or empty",
-                 caller.c_str ());
-          return retval;
-        }
+        error ("%s: OPTIONS must be a string, cell array of strings, or empty",
+               caller.c_str ());
     }
 
   boolT ismalloc = false;
 
   unwind_protect frame;
 
   // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
@@ -148,20 +142,17 @@ Undocumented internal function.\n\
 #else
   FILE *outfile = gnulib::fopen ("/dev/null", "w");
 #endif
   FILE *errfile = stderr;
 
   if (outfile)
     frame.add_fcn (close_fcn, outfile);
   else
-    {
-      error ("__voronoi__: unable to create temporary file for output");
-      return retval;
-    }
+    error ("__voronoi__: unable to create temporary file for output");
 
   // qh_new_qhull command and points arguments are not const...
 
   std::string cmd = "qhull v" + options;
 
   OCTAVE_LOCAL_BUFFER (char, cmd_str, cmd.length () + 1);
 
   strcpy (cmd_str, cmd.c_str ());
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -109,28 +109,22 @@ recording using those parameters.\n\
 
   octave_scalar_map devinfo;
   octave_value_list input;
   octave_value_list output;
 
   PaError err = Pa_Initialize ();
 
   if (err != paNoError)
-    {
-      error ("audiodevinfo: PortAudio initialization failed");
-      return retval;
-    }
+    error ("audiodevinfo: PortAudio initialization failed");
 
   int num_devices = Pa_GetDeviceCount ();
 
   if (num_devices < 0)
-    {
-      error ("audiodevinfo: no audio device found");
-      return retval;
-    }
+    error ("audiodevinfo: no audio device found");
 
   octave_idx_type numinput = 0, numoutput = 0;
   for (int i = 0; i < num_devices; i++)
     {
       const PaDeviceInfo *device_info = Pa_GetDeviceInfo (i);
 
       if (! device_info)
         {
@@ -206,20 +200,17 @@ recording using those parameters.\n\
   // Return the number of input or output devices
   else if (nargin == 1)
     {
       if (args(0).int_value () == 0)
         retval = numoutput;
       else if (args(0).int_value () == 1)
         retval = numinput;
       else
-        {
-          error ("audiodevinfo: please specify 0 for output and 1 for input devices");
-          return retval;
-        }
+        error ("audiodevinfo: please specify 0 for output and 1 for input devices");
     }
   // Return device name when given id or id when given device name.
   else if (nargin == 2)
     {
       bool found = false;
       int outin = args(0).int_value ();
       if (args(1).is_string ())
         {
@@ -243,20 +234,17 @@ recording using those parameters.\n\
                     {
                       retval = input_id(i);
                       found = true;
                       break;
                     }
                 }
             }
           else
-            {
-              error ("audiodevinfo: please specify 0 for output and 1 for input devices");
-              return retval;
-            }
+            error ("audiodevinfo: please specify 0 for output and 1 for input devices");
         }
       else
         {
           if (outin == 0)
             {
               for (int i = 0; i < numoutput; i++)
                 {
                   if (output_id(i).int_value () == args(1).int_value ())
@@ -275,21 +263,19 @@ recording using those parameters.\n\
                     {
                       retval = input_name(i);
                       found = true;
                       break;
                     }
                 }
             }
           else
-            {
-              error ("audiodevinfo: please specify 0 for output and 1 for input devices");
-              return retval;
-            }
+            error ("audiodevinfo: please specify 0 for output and 1 for input devices");
         }
+
       if (! found)
         error ("audiodevinfo: no device meeting the specified criteria found");
     }
   else if (nargin == 3)
     {
       // FIXME: what was supposed to happen here?
     }
   // Return the id of the first device meeting specified criteria.
@@ -305,20 +291,17 @@ recording using those parameters.\n\
           PaStreamParameters stream_parameters;
           stream_parameters.device = i;
           stream_parameters.channelCount = chans;
           PaSampleFormat format = bits_to_format (bits);
 
           if (format != 0)
             stream_parameters.sampleFormat = format;
           else
-            {
-              error ("audiodevinfo: no such bits per sample format");
-              return retval;
-            }
+            error ("audiodevinfo: no such bits per sample format");
 
           const PaDeviceInfo *device_info = Pa_GetDeviceInfo (i);
 
           if (! device_info)
             {
               warning ("Octave:invalid-audio-device",
                        "invalid audio device ID = %d", i);
               continue;
@@ -367,28 +350,22 @@ recording using those parameters.\n\
       int chans = args(4).int_value ();
       PaStreamParameters stream_parameters;
       stream_parameters.device = id;
       stream_parameters.channelCount = chans;
       PaSampleFormat format = bits_to_format (bits);
       if (format != 0)
         stream_parameters.sampleFormat = format;
       else
-        {
-          error ("audiodevinfo: no such bits per sample format");
-          return retval;
-        }
+        error ("audiodevinfo: no such bits per sample format");
 
       const PaDeviceInfo *device_info = Pa_GetDeviceInfo (id);
 
       if (! device_info)
-        {
-          error ("audiodevinfo: invalid audio device ID = %d", id);
-          return retval;
-        }
+        error ("audiodevinfo: invalid audio device ID = %d", id);
 
       stream_parameters.suggestedLatency
         = device_info->defaultLowInputLatency;
 
       stream_parameters.hostApiSpecificStreamInfo = 0;
       if (io == 0)
         {
           if (device_info->maxOutputChannels < chans)
@@ -413,27 +390,23 @@ recording using those parameters.\n\
           err = Pa_IsFormatSupported (&stream_parameters, 0, rate);
           if (err == paFormatIsSupported)
             {
               retval = 1;
               return retval;
             }
         }
       else
-        {
-          error ("audiodevinfo: please specify 0 for output and 1 for input devices");
-          return retval;
-        }
+        error ("audiodevinfo: please specify 0 for output and 1 for input devices");
+
       retval = 0;
     }
   else
-    {
-      error ("audiodevinfo: wrong number of arguments");
-      return retval;
-    }
+    error ("audiodevinfo: wrong number of arguments");
+
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
 #endif
 
   return retval;
 }
@@ -557,39 +530,30 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (aud
 static int
 octave_play_callback (const void *, void *output, unsigned long frames,
                       const PaStreamCallbackTimeInfo *,
                       PaStreamCallbackFlags, void *data)
 {
   audioplayer *player = static_cast<audioplayer *> (data);
 
   if (! player)
-    {
-      error ("audio player callback function called without player");
-      return paAbort;
-    }
+    error ("audio player callback function called without player");
 
   octave_value_list retval = feval (player->octave_callback_function,
                                     ovl (static_cast<double> (frames)), 1);
 
   if (retval.length () < 2)
-    {
-      error ("audio player callback function failed");
-      return paAbort;
-    }
+    error ("audio player callback function failed");
 
   const Matrix sound = retval(0).matrix_value ();
   int return_status = retval(1).int_value ();
 
   if (frames - sound.rows () != 0 || sound.columns () < 1
       || sound.columns () > 2)
-    {
-      error ("audio player callback function failed");
-      return paAbort;
-    }
+    error ("audio player callback function failed");
 
   // Don't multiply the audio data by scale_factor here.  Although it
   // does move the operation outside of the loops below, it also causes
   // a second copy of the data array to be made.
 
   const ColumnVector sound_l = sound.column (0);
   const ColumnVector sound_r = (sound.columns () == 1
                                 ? sound_l : sound.column (1));
@@ -657,34 +621,30 @@ octave_play_callback (const void *, void
             buffer[offset+4] = _sample_r[1+big_endian] * scale_factor;
             buffer[offset+5] = _sample_r[2+big_endian] * scale_factor;
           }
       }
       break;
 
     default:
       error ("invalid player bit depth in callback function");
-      break;
     }
 
   return return_status;
 }
 
 static int
 portaudio_play_callback (const void *, void *output, unsigned long frames,
                          const PaStreamCallbackTimeInfo*,
                          PaStreamCallbackFlags, void *data)
 {
   audioplayer *player = static_cast<audioplayer *> (data);
 
   if (! player)
-    {
-      error ("audio player callback function called without player");
-      return paAbort;
-    }
+    error ("audio player callback function called without player");
 
   // Don't multiply the audio data by scale_factor here.  Although it
   // would move the operation outside of the loops below, it also causes
   // a second copy of the *entire* data array to be made when only a
   // small portion (buffer_size elements) is usually needed for this
   // callback.
 
   const RowVector sound_l = player->get_left ();
@@ -780,17 +740,16 @@ portaudio_play_callback (const void *, v
 
                 player->set_sample_number (sample_number + 1);
               }
           }
           break;
 
         default:
           error ("invalid player bit depth in callback function");
-          break;
         }
     }
   else if (player->get_type () == TYPE_INT8)
     {
       int8_t *buffer = static_cast<int8_t *> (output);
 
       for (unsigned long j = 0; j < frames; j++)
         {
@@ -884,26 +843,20 @@ audioplayer::print_raw (std::ostream& os
 {
   os << 0;
 }
 
 void
 audioplayer::init_fn (void)
 {
   if (Pa_Initialize () != paNoError)
-    {
-      error ("audioplayer: initialization error!");
-      return;
-    }
+    error ("audioplayer: initialization error!");
 
   if (Pa_GetDeviceCount () < 1)
-    {
-      error ("audioplayer: no audio devices found or available!");
-      return;
-    }
+    error ("audioplayer: no audio devices found or available!");
 
   int device = get_id ();
 
   if (device == -1)
     device = Pa_GetDefaultOutputDevice ();
 
   output_parameters.device = device;
   output_parameters.channelCount = 2;
@@ -926,26 +879,20 @@ audioplayer::init (void)
 {
   // Both of these variables are unused.  Should they be
   // eliminated or is something not yet implemented?
   //
   // int channels = y.rows ();
   // RowVector *sound_l = get_left ();
 
   if (Pa_Initialize () != paNoError)
-    {
-      error ("audioplayer: initialization error!");
-      return;
-    }
+    error ("audioplayer: initialization error!");
 
   if (Pa_GetDeviceCount () < 1)
-    {
-      error ("audioplayer: no audio devices found or available!");
-      return;
-    }
+    error ("audioplayer: no audio devices found or available!");
 
   int device = get_id ();
 
   if (device == -1)
     device = Pa_GetDefaultOutputDevice ();
 
   output_parameters.device = device;
   output_parameters.channelCount = 2;
@@ -1139,27 +1086,21 @@ audioplayer::playblocking (void)
 
   const unsigned int buffer_size = get_fs () / 20;
   OCTAVE_LOCAL_BUFFER (uint32_t, buffer, buffer_size * 2);
 
   PaError err;
   err = Pa_OpenStream (&stream, 0, &(output_parameters), get_fs (),
                        buffer_size, paClipOff, 0, 0);
   if (err != paNoError)
-    {
-      error ("audioplayer: unable to open audio playback stream");
-      return;
-    }
+    error ("audioplayer: unable to open audio playback stream");
 
   err = Pa_StartStream (stream);
   if (err != paNoError)
-    {
-      error ("audioplayer: unable to start start audio playback stream");
-      return;
-    }
+    error ("audioplayer: unable to start start audio playback stream");
 
   unsigned int start, end;
   start = get_sample_number ();
   end = get_end_sample ();
 
   unwind_protect frame;
 
   frame.add_fcn (safe_audioplayer_stop, this);
@@ -1190,57 +1131,45 @@ audioplayer::play (void)
                          get_fs (), buffer_size, paClipOff,
                          octave_play_callback, this);
   else
     err = Pa_OpenStream (&stream, 0, &(output_parameters),
                          get_fs (), buffer_size, paClipOff,
                          portaudio_play_callback, this);
 
   if (err != paNoError)
-    {
-      error ("audioplayer: failed to open audio playback stream");
-      return;
-    }
+    error ("audioplayer: failed to open audio playback stream");
 
   err = Pa_StartStream (stream);
   if (err != paNoError)
-    {
-      error ("audioplayer: failed to start audio playback stream");
-      return;
-    }
+    error ("audioplayer: failed to start audio playback stream");
 }
 
 void
 audioplayer::pause (void)
 {
   if (get_stream () == 0)
     return;
 
   PaError err;
   err = Pa_StopStream (stream);
   if (err != paNoError)
-    {
-      error ("audiorecorder: failed to stop audio recording stream");
-      return;
-    }
+    error ("audiorecorder: failed to stop audio recording stream");
 }
 
 void
 audioplayer::resume (void)
 {
   if (get_stream () == 0)
     return;
 
   PaError err;
   err = Pa_StartStream (stream);
   if (err != paNoError)
-    {
-      error ("audiorecorder: failed to start audio recording stream");
-      return;
-    }
+    error ("audiorecorder: failed to start audio recording stream");
 }
 
 PaStream *
 audioplayer::get_stream (void)
 {
   return stream;
 }
 
@@ -1252,45 +1181,36 @@ audioplayer::stop (void)
 
   PaError err;
   set_sample_number (0);
   reset_end_sample ();
   if (! Pa_IsStreamStopped (get_stream ()))
     {
       err = Pa_AbortStream (get_stream ());
       if (err != paNoError)
-        {
-          error ("audioplayer: failed to stop audio playback stream");
-          return;
-        }
+        error ("audioplayer: failed to stop audio playback stream");
     }
 
   err = Pa_CloseStream (get_stream ());
   if (err != paNoError)
-    {
-      error ("audioplayer: failed to close audio playback stream");
-      return;
-    }
+    error ("audioplayer: failed to close audio playback stream");
 
   stream = 0;
 }
 
 bool
 audioplayer::isplaying (void)
 {
   if (get_stream () == 0)
     return false;
 
   PaError err;
   err = Pa_IsStreamActive (stream);
   if (err != 0 && err != 1)
-    {
-      error ("audiorecorder: checking stream activity status failed");
-      return false;
-    }
+    error ("audiorecorder: checking stream activity status failed");
 
   return (err == 1);
 }
 
 class audiorecorder : public octave_base_value
 {
 public:
   audiorecorder (void);
@@ -1367,20 +1287,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (aud
 static int
 octave_record_callback (const void *input, void *, unsigned long frames,
                         const PaStreamCallbackTimeInfo *,
                         PaStreamCallbackFlags, void *data)
 {
   audiorecorder *recorder = static_cast<audiorecorder *> (data);
 
   if (! recorder)
-    {
-      error ("audio recorder callback function called without player");
-      return paAbort;
-    }
+    error ("audio recorder callback function called without player");
 
   int channels = recorder->get_channels ();
 
   Matrix sound (frames, 2);
   sound.resize (frames, 2);
 
   if (recorder->get_nbits () == 8)
     {
@@ -1452,20 +1369,17 @@ octave_record_callback (const void *inpu
 static int
 portaudio_record_callback (const void *input, void *, unsigned long frames,
                            const PaStreamCallbackTimeInfo *,
                            PaStreamCallbackFlags, void *data)
 {
   audiorecorder *recorder = static_cast<audiorecorder *> (data);
 
   if (! recorder)
-    {
-      error ("audio recorder callback function called without player");
-      return paAbort;
-    }
+    error ("audio recorder callback function called without player");
 
   int channels = recorder->get_channels ();
 
   if (recorder->get_nbits () == 8)
     {
       static float scale_factor = std::pow (2.0f, 7) - 1.0f;
 
       const int8_t *input8 = static_cast<const int8_t *> (input);
@@ -1564,26 +1478,20 @@ audiorecorder::print_raw (std::ostream& 
 {
   os << 0;
 }
 
 void
 audiorecorder::init (void)
 {
   if (Pa_Initialize () != paNoError)
-    {
-      error ("audiorecorder: initialization error!");
-      return;
-    }
+    error ("audiorecorder: initialization error!");
 
   if (Pa_GetDeviceCount () < 1)
-    {
-      error ("audiorecorder: no audio devices found or available!");
-      return;
-    }
+    error ("audiorecorder: no audio devices found or available!");
 
   int device = get_id ();
 
   if (device == -1)
     device = Pa_GetDefaultInputDevice ();
 
   input_parameters.device = device;
   input_parameters.channelCount = get_channels ();
@@ -1747,20 +1655,17 @@ bool
 audiorecorder::isrecording (void)
 {
   if (get_stream () == 0)
     return false;
 
   PaError err;
   err = Pa_IsStreamActive (stream);
   if (err != 0 && err != 1)
-    {
-      error ("audiorecorder: checking stream activity status failed");
-      return false;
-    }
+    error ("audiorecorder: checking stream activity status failed");
 
   return (err == 1);
 }
 
 void
 audiorecorder::record (void)
 {
   if (get_stream ())
@@ -1780,26 +1685,21 @@ audiorecorder::record (void)
     }
   else
     {
       err = Pa_OpenStream (&stream, &(input_parameters), 0,
                            get_fs (), buffer_size, paClipOff,
                            portaudio_record_callback, this);
     }
   if (err != paNoError)
-    {
-      error ("audiorecorder: unable to open audio recording stream");
-      return;
-    }
+    error ("audiorecorder: unable to open audio recording stream");
+
   err = Pa_StartStream (stream);
   if (err != paNoError)
-    {
-      error ("audiorecorder: unable to start audio recording stream");
-      return;
-    }
+    error ("audiorecorder: unable to start audio recording stream");
 }
 
 void
 audiorecorder::recordblocking (float seconds)
 {
   if (get_stream ())
     stop ();
 
@@ -1808,27 +1708,21 @@ audiorecorder::recordblocking (float sec
 
   const unsigned int buffer_size = get_fs () / 20;
   OCTAVE_LOCAL_BUFFER (uint8_t, buffer, buffer_size * 2 * 3);
 
   PaError err;
   err = Pa_OpenStream (&stream, &(input_parameters), 0,
                        get_fs (), buffer_size, paClipOff, 0, this);
   if (err != paNoError)
-    {
-      error ("audiorecorder: unable to open audio recording stream");
-      return;
-    }
+    error ("audiorecorder: unable to open audio recording stream");
 
   err = Pa_StartStream (stream);
   if (err != paNoError)
-    {
-      error ("audiorecorder: unable to start audio recording stream");
-      return;
-    }
+    error ("audiorecorder: unable to start audio recording stream");
 
   unsigned int frames = seconds * get_fs ();
 
   unwind_protect frame;
 
   frame.add_fcn (safe_audiorecorder_stop, this);
 
   for (unsigned int i = 0; i < frames; i += buffer_size)
@@ -1847,60 +1741,48 @@ void
 audiorecorder::pause (void)
 {
   if (get_stream () == 0)
     return;
 
   PaError err;
   err = Pa_StopStream (stream);
   if (err != paNoError)
-    {
-      error ("audiorecorder: unable to stop audio recording stream");
-      return;
-    }
+    error ("audiorecorder: unable to stop audio recording stream");
 }
 
 void
 audiorecorder::resume (void)
 {
   if (get_stream () == 0)
     return;
 
   PaError err;
   err = Pa_StartStream (stream);
   if (err != paNoError)
-    {
-      error ("audiorecorder: unable to start audio recording stream");
-      return;
-    }
+    error ("audiorecorder: unable to start audio recording stream");
 }
 
 void
 audiorecorder::stop (void)
 {
   if (get_stream () == 0)
     return;
 
   PaError err;
   if (! Pa_IsStreamStopped (get_stream ()))
     {
       err = Pa_AbortStream (get_stream ());
       if (err != paNoError)
-        {
-          error ("audioplayer: unable to stop audio playback stream");
-          return;
-        }
+        error ("audioplayer: unable to stop audio playback stream");
     }
 
   err = Pa_CloseStream (stream);
   if (err != paNoError)
-    {
-      error ("audiorecorder: unable to close audio recording stream");
-      return;
-    }
+    error ("audiorecorder: unable to close audio recording stream");
 
   set_sample_number (0);
   reset_end_sample ();
   stream = 0;
 }
 
 void
 audiorecorder::append (float sample_l, float sample_r)
@@ -1937,23 +1819,17 @@ Undocumented internal function.\n\
   int offset = 0;
 
   if (nargin > 0)
     {
       bool is_function = (args(0).is_string () || args(0).is_function_handle ()
                           || args(0).is_inline_function ());
 
       if (is_function)
-        {
-          error ("audioplayer: callbacks not yet implemented");
-          return retval;
-
-          // recorder->octave_callback_function = args(0).function_value ();
-          // offset = 1;
-        }
+        error ("audioplayer: callbacks not yet implemented");
     }
 
   switch (nargin - offset)
     {
     case 3:
       recorder->set_fs (args(0 + offset).int_value ());
       recorder->set_nbits (args(1 + offset).int_value ());
       recorder->set_channels (args(2 + offset).int_value ());
@@ -2534,22 +2410,17 @@ Undocumented internal function.\n\
 
   if (! recorder)
     print_usage ();
 
   bool is_function = (args(0).is_string () || args(0).is_function_handle ()
                       || args(0).is_inline_function ());
 
   if (is_function)
-    {
-      error ("audioplayer: callbacks not yet implemented");
-      return retval;
-
-      // recorder->set_y (args(0).function_value ());
-    }
+    error ("audioplayer: callbacks not yet implemented");
   else
     recorder->set_y (args(0));
 
   recorder->set_fs (args(1).int_value ());
 
   switch (nargin)
     {
     case 3:
@@ -2907,33 +2778,27 @@ Undocumented internal function.\n\
         {
           RowVector range = args(1).row_vector_value ();
 
           unsigned int start = range.elem (0) - 1;
           unsigned int end = range.elem (1) - 1;
 
           if (start > player->get_total_samples ()
               || start > end || end > player->get_total_samples ())
-            {
-              error ("audioplayer: invalid range specified for playback");
-              return retval;
-            }
+            error ("audioplayer: invalid range specified for playback");
 
           player->set_sample_number (start);
           player->set_end_sample (end);
         }
       else
         {
           unsigned int start = args(1).int_value () - 1;
 
           if (start > player->get_total_samples ())
-            {
-              error ("audioplayer: invalid range specified for playback");
-              return retval;
-            }
+            error ("audioplayer: invalid range specified for playback");
 
           player->set_sample_number (start);
         }
 
       player->playblocking ();
     }
 
 #else
@@ -2974,33 +2839,27 @@ Undocumented internal function.\n\
         {
           RowVector range = args(1).row_vector_value ();
 
           unsigned int start = range.elem (0) - 1;
           unsigned int end = range.elem (1) - 1;
 
           if (start > player->get_total_samples ()
               || start > end || end > player->get_total_samples ())
-            {
-              error ("audioplayer: invalid range specified for playback");
-              return retval;
-            }
+            error ("audioplayer: invalid range specified for playback");
 
           player->set_sample_number (start);
           player->set_end_sample (end);
         }
       else
         {
           unsigned int start = args(1).int_value () - 1;
 
           if (start > player->get_total_samples ())
-            {
-              error ("audioplayer: invalid range specified for playback");
-              return retval;
-            }
+            error ("audioplayer: invalid range specified for playback");
 
           player->set_sample_number (start);
         }
 
       player->play ();
     }
 
 #else
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -81,20 +81,17 @@ is stored in the audio file.\n\
 
   std::string filename = args(0).string_value ();
 
   SF_INFO info;
   info.format = 0;
   SNDFILE *file = sf_open (filename.c_str (), SFM_READ, &info);
 
   if (! file)
-    {
-      error ("audioread: failed to open input file %s", filename.c_str ());
-      return retval;
-    }
+    error ("audioread: failed to open input file %s", filename.c_str ());
 
   unwind_protect frame;
 
   frame.add_fcn (safe_close, file);
 
   OCTAVE_LOCAL_BUFFER (float, data, info.frames * info.channels);
 
   sf_read_float (file, data, info.frames * info.channels);
@@ -102,30 +99,24 @@ is stored in the audio file.\n\
   sf_count_t start = 0;
   sf_count_t end = info.frames;
 
   if ((nargin == 2 && ! args(1).is_string ()) || nargin == 3)
     {
       RowVector range = args(1).row_vector_value ();
 
       if (range.numel () != 2)
-        {
-          error ("audioread: invalid specification for range of frames");
-          return retval;
-        }
+        error ("audioread: invalid specification for range of frames");
 
       double dstart = xisinf (range(0)) ? info.frames : range(0);
       double dend = xisinf (range(1)) ? info.frames : range(1);
 
       if (dstart < 1 || dstart > dend || dend > info.frames
           || D_NINT (dstart) != dstart || D_NINT (dend) != dend)
-        {
-          error ("audioread: invalid specification for range of frames");
-          return retval;
-        }
+        error ("audioread: invalid specification for range of frames");
 
       start = dstart - 1;
       end = dend;
     }
 
   sf_count_t items = end - start;
 
   Matrix audio (items, info.channels);
@@ -373,47 +364,38 @@ Comment.\n\
             }
           else if (bits == 16)
             info.format |= SF_FORMAT_PCM_16;
           else if (bits == 24)
             info.format |= SF_FORMAT_PCM_24;
           else if (bits == 32)
             info.format |= SF_FORMAT_PCM_32;
           else
-            {
-              error ("audiowrite: wrong number of bits specified");
-              return retval;
-            }
+            error ("audiowrite: wrong number of bits specified");
         }
       else if (args(i).string_value () == "BitRate")
         ;
       // Quality is currently unused?
       //
       // else if (args(i).string_value () == "Quality")
       //   quality = args(i + 1).int_value () * 0.01;
       else if (args(i).string_value () == "Title")
         title = args(i + 1).string_value ();
       else if (args(i).string_value () == "Artist")
         artist = args(i + 1).string_value ();
       else if (args(i).string_value () == "Comment")
         comment = args(i + 1).string_value ();
       else
-        {
-          error ("audiowrite: wrong argument name");
-          return retval;
-        }
+        error ("audiowrite: wrong argument name");
     }
 
   SNDFILE *file = sf_open (filename.c_str (), SFM_WRITE, &info);
 
   if (! file)
-    {
-      error ("audiowrite: failed to open output file %s", filename.c_str ());
-      return retval;
-    }
+    error ("audiowrite: failed to open output file %s", filename.c_str ());
 
   unwind_protect frame;
 
   frame.add_fcn (safe_close, file);
 
   if (title != "")
     sf_set_string (file, SF_STR_TITLE, title.c_str ());
 
@@ -432,21 +414,18 @@ Comment.\n\
   while (total_items_written < items_to_write)
     {
       if (items_to_write - offset < chunk_size)
         chunk_size = items_to_write - offset;
 
       sf_count_t items_written = sf_write_float (file, data+offset, chunk_size);
 
       if (items_written != chunk_size)
-        {
-          error ("audiowrite: write failed, wrote %ld of %ld items\n",
-                 items_written, chunk_size);
-          return retval;
-        }
+        error ("audiowrite: write failed, wrote %ld of %ld items\n",
+               items_written, chunk_size);
 
       total_items_written += items_written;
       offset += chunk_size;
     }
 
 #else
 
   error ("sndfile not found on your system and thus audiowrite is not functional");
@@ -471,20 +450,17 @@ Return information about an audio file s
 
   std::string filename = args(0).string_value ();
 
   SF_INFO info;
   info.format = 0;
   SNDFILE *file = sf_open (filename.c_str (), SFM_READ, &info);
 
   if (! file)
-    {
-      error ("audioinfo: failed to open file %s", filename.c_str ());
-      return retval;
-    }
+    error ("audioinfo: failed to open file %s", filename.c_str ());
 
   unwind_protect frame;
 
   frame.add_fcn (safe_close, file);
 
   octave_scalar_map result;
 
   result.assign ("Filename", filename);
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -282,28 +282,28 @@ ccolamd, csymamd, amd, colamd, symamd, a
           if (cslen != n_col)
             error ("ccolamd: CMEMBER must be of length equal to #cols of A");
           else
             // Order the columns (destroys A)
             if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p,
                                    knobs, stats, cmember))
               {
                 CCOLAMD_NAME (_report) (stats) ;
+
                 error ("ccolamd: internal error!");
-                return retval;
               }
         }
       else
         {
           // Order the columns (destroys A)
           if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, 0))
             {
               CCOLAMD_NAME (_report) (stats) ;
+
               error ("ccolamd: internal error!");
-              return retval;
             }
         }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
         out_perm(i) = p[i] + 1;
 
@@ -494,20 +494,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
 
           n_row = sm.rows ();
           n_col = sm.cols ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       if (n_row != n_col)
-        {
-          error ("csymamd: matrix S must be square");
-          return retval;
-        }
+        error ("csymamd: matrix S must be square");
 
       // Allocate workspace for symamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
         {
           NDArray in_cmember = args(2).array_value ();
@@ -518,28 +515,28 @@ ccolamd, csymamd, amd, colamd, symamd, a
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
           if (cslen != n_col)
             error ("csymamd: CMEMBER must be of length equal to #cols of A");
           else if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
                                      &calloc, &free, cmember, -1))
             {
               CSYMAMD_NAME (_report) (stats) ;
+
               error ("csymamd: internal error!") ;
-              return retval;
             }
         }
       else
         {
           if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
                                 &calloc, &free, 0, -1))
             {
               CSYMAMD_NAME (_report) (stats) ;
+
               error ("csymamd: internal error!") ;
-              return retval;
             }
         }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
         out_perm(i) = perm[i] + 1;
 
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -388,18 +388,18 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
   for (octave_idx_type i = 0; i < nnz; i++)
     A[i] = ridx[i];
 
   // Order the columns (destroys A)
   OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
   if (! COLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats))
     {
       COLAMD_NAME (_report) (stats) ;
+
       error ("colamd: internal error!");
-      return retval;
     }
 
   // column elimination tree post-ordering (reuse variables)
   OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col + 1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, colend, n_col + 1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
 
   for (octave_idx_type i = 0; i < n_col; i++)
@@ -577,30 +577,27 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
 
       n_row = sm.rows ();
       n_col = sm.cols ();
       ridx = sm.xridx ();
       cidx = sm.xcidx ();
     }
 
   if (n_row != n_col)
-    {
-      error ("symamd: matrix S must be square");
-      return retval;
-    }
+    error ("symamd: matrix S must be square");
 
   // Allocate workspace for symamd
   OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
   if (!SYMAMD_NAME () (n_col, ridx, cidx, perm,
                        knobs, stats, &calloc, &free))
     {
       SYMAMD_NAME (_report) (stats) ;
+
       error ("symamd: internal error!") ;
-      return retval;
     }
 
   // column elimination tree post-ordering
   OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
   symetree (ridx, cidx, etree, perm, n_col);
 
   // Calculate the tree post-ordering
   OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
@@ -661,65 +658,60 @@ permutations on the tree.\n\
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargout > 2 || nargin < 1 || nargin > 2)
     print_usage ();
 
-  octave_idx_type n_row, n_col;
-  octave_idx_type *ridx, *cidx;
-  bool is_sym = true;
-  SparseMatrix sm;
-  SparseComplexMatrix scm;
+  octave_idx_type n_row = 0, n_col = 0;
+  octave_idx_type *ridx = 0, *cidx = 0;
 
   if (args(0).is_sparse_type ())
     {
       if (args(0).is_complex_type ())
         {
-          scm = args(0).sparse_complex_matrix_value ();
+          SparseComplexMatrix scm = args(0).sparse_complex_matrix_value ();
+
           n_row = scm.rows ();
           n_col = scm.cols ();
           ridx = scm.xridx ();
           cidx = scm.xcidx ();
         }
       else
         {
-          sm = args(0).sparse_matrix_value ();
+          SparseMatrix sm = args(0).sparse_matrix_value ();
+
           n_row = sm.rows ();
           n_col = sm.cols ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
     }
   else
-    {
-      error ("etree: S must be a sparse matrix");
-      return retval;
-    }
+    error ("etree: S must be a sparse matrix");
+
+  bool is_sym = true;
 
   if (nargin == 2)
     {
       std::string str = args(1).xstring_value ("etree: TYP must be a string");
       if (str.find ("C") == 0 || str.find ("c") == 0)
         is_sym = false;
     }
 
   // column elimination tree post-ordering (reuse variables)
   OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
 
   if (is_sym)
     {
       if (n_row != n_col)
-        {
-          error ("etree: S is marked as symmetric, but is not square");
-          return retval;
-        }
+        error ("etree: S is marked as symmetric, but is not square");
 
       symetree (ridx, cidx, etree, 0, n_col);
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, colend, n_col);
 
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -58,20 +58,17 @@ close_fcn (FILE *f)
 static bool
 octave_qhull_dims_ok (octave_idx_type dim, octave_idx_type n, const char *who)
 {
   if (sizeof (octave_idx_type) > sizeof (int))
     {
       int maxval = std::numeric_limits<int>::max ();
 
       if (dim > maxval || n > maxval)
-        {
-          error ("%s: dimension too large for Qhull", who);
-          return false;
-        }
+        error ("%s: dimension too large for Qhull", who);
     }
 
   return true;
 }
 
 DEFUN_DLD (convhulln, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{h} =} convhulln (@var{pts})\n\
@@ -142,20 +139,17 @@ convex hull is calculated.\n\n\
           options = "";
 
           Array<std::string> tmp = args(1).cellstr_value ();
 
           for (octave_idx_type i = 0; i < tmp.numel (); i++)
             options += " " + tmp(i);
         }
       else
-        {
-          error ("convhulln: OPTIONS must be a string, cell array of strings, or empty");
-          return retval;
-        }
+        error ("convhulln: OPTIONS must be a string, cell array of strings, or empty");
     }
 
   boolT ismalloc = false;
 
   unwind_protect frame;
 
   // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
@@ -163,20 +157,17 @@ convex hull is calculated.\n\n\
 #else
   FILE *outfile = gnulib::fopen ("/dev/null", "w");
 #endif
   FILE *errfile = stderr;
 
   if (outfile)
     frame.add_fcn (close_fcn, outfile);
   else
-    {
-      error ("convhulln: unable to create temporary file for output");
-      return retval;
-    }
+    error ("convhulln: unable to create temporary file for output");
 
   // qh_new_qhull command and points arguments are not const...
 
   std::string cmd = "qhull" + options;
 
   OCTAVE_LOCAL_BUFFER (char, cmd_str, cmd.length () + 1);
 
   strcpy (cmd_str, cmd.c_str ());
@@ -199,21 +190,18 @@ convex hull is calculated.\n\n\
         {
           octave_idx_type j = 0;
 
           if (! (nonsimp_seen || facet->simplicial || qh hull_dim == 2))
             {
               nonsimp_seen = true;
 
               if (cmd.find ("QJ") != std::string::npos)
-                {
-                  // Should never happen with QJ.
-                  error ("convhulln: qhull failed: option 'QJ' returned non-simplicial facet");
-                  return retval;
-                }
+                // Should never happen with QJ.
+                error ("convhulln: qhull failed: option 'QJ' returned non-simplicial facet");
             }
 
           if (dim == 3)
             {
               setT *vertices = qh_facet3vertex (facet);
 
               vertexT *vertex, **vertexp;
 
