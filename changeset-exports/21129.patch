# HG changeset patch
# User Rik <rik@octave.org>
# Date 1453409657 28800
#      Thu Jan 21 12:54:17 2016 -0800
# Node ID 228b655045571f7b9fb1aaae25801536e80aeb20
# Parent  61ca546e19428639520724a70cf648a1ad855a2b
maint: Eliminate useless statements after err_XXX.

* Cell.cc, data.cc, eig.cc, hess.cc, oct-hist.cc, oct-stream.cc, rand.cc,
audioread.cc, ov-base.cc, ov-class.cc, ov.cc, op-int.h, ops.h, CColVector.cc,
CDiagMatrix.cc, CMatrix.cc, CRowVector.cc, DiagArray2.cc, MDiagArray2.cc,
PermMatrix.cc, dMatrix.cc, fCColVector.cc, fCDiagMatrix.cc, fCMatrix.cc,
fCRowVector.cc, fMatrix.cc, idx-vector.cc, CmplxGEPBAL.cc, dbleGEPBAL.cc,
fCmplxGEPBAL.cc, floatGEPBAL.cc, Sparse-diag-op-defs.h, Sparse-op-defs.h,
Sparse-perm-op-defs.h, mx-inlines.cc, mx-op-defs.h:
maint: Eliminate useless statements after err_XXX.

diff --git a/libinterp/corefcn/Cell.cc b/libinterp/corefcn/Cell.cc
--- a/libinterp/corefcn/Cell.cc
+++ b/libinterp/corefcn/Cell.cc
@@ -271,17 +271,16 @@ Cell::delete_elements (const octave_valu
 
   Array<octave_value>::delete_elements (ra_idx);
 }
 
 octave_idx_type
 Cell::nnz (void) const
 {
   err_wrong_type_arg ("nnz", "cell array");
-  return -1;
 }
 
 /*
 %!error <wrong type argument 'cell array'> nnz ({0, 1, 2})
 %!error <wrong type argument 'cell array'> nnz (cell ())
 %!error <wrong type argument 'cell array'> nnz ({"foo", "bar"})
 */
 
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1031,20 +1031,17 @@ negative numbers or when the values are 
             } \
           else if (arg.is_real_type ()) \
             { \
               NDArray tmp = arg.array_value (); \
 \
               retval = tmp.FCN (dim); \
             } \
           else \
-            { \
-              err_wrong_type_arg (#FCN, arg); \
-              return retval; \
-            } \
+            err_wrong_type_arg (#FCN, arg); \
         } \
       else if (arg.is_bool_type ()) \
         { \
           boolNDArray tmp = arg.bool_array_value (); \
 \
           retval = tmp.FCN (dim); \
         } \
       else if (! isdouble && arg.is_single_type ()) \
@@ -1071,20 +1068,17 @@ negative numbers or when the values are 
         } \
       else if (arg.is_complex_type ()) \
         { \
           ComplexNDArray tmp = arg.complex_array_value (); \
 \
           retval = tmp.FCN (dim); \
         } \
       else \
-        { \
-          err_wrong_type_arg (#FCN, arg); \
-          return retval; \
-        } \
+        err_wrong_type_arg (#FCN, arg); \
     } \
  \
   return retval
 
 #define DATA_REDUCTION(FCN) \
  \
   int nargin = args.length (); \
  \
@@ -1139,20 +1133,17 @@ negative numbers or when the values are 
       else \
         { \
           ComplexNDArray tmp = arg.complex_array_value (); \
 \
           retval = tmp.FCN (dim); \
         } \
     } \
   else \
-    { \
-      err_wrong_type_arg (#FCN, arg); \
-      return retval; \
-    } \
+    err_wrong_type_arg (#FCN, arg); \
  \
   return retval
 
 DEFUN (cumprod, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} cumprod (@var{x})\n\
 @deftypefnx {} {} cumprod (@var{x}, @var{dim})\n\
 Cumulative product of elements along dimension @var{dim}.\n\
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -68,38 +68,32 @@ The eigenvalues returned by @code{eig} a
 
   int arg_is_empty = empty_arg ("eig", nr_a, nc_a);
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
     return octave_value_list (2, Matrix ());
 
   if (! arg_a.is_double_type () && ! arg_a.is_single_type ())
-    {
-      err_wrong_type_arg ("eig", arg_a);
-      return retval;
-    }
+    err_wrong_type_arg ("eig", arg_a);
 
   if (nargin == 2)
     {
       arg_b = args(1);
       nr_b = arg_b.rows ();
       nc_b = arg_b.columns ();
 
       arg_is_empty = empty_arg ("eig", nr_b, nc_b);
       if (arg_is_empty < 0)
         return retval;
       else if (arg_is_empty > 0)
         return ovl (2, Matrix ());
 
-      if (!(arg_b.is_single_type () || arg_b.is_double_type ()))
-        {
-          err_wrong_type_arg ("eig", arg_b);
-          return retval;
-        }
+      if (! arg_b.is_single_type () && ! arg_b.is_double_type ())
+        err_wrong_type_arg ("eig", arg_b);
     }
 
   if (nr_a != nc_a)
     err_square_matrix_required ("eig", "A");
 
   if (nargin == 2 && nr_b != nc_b)
     err_square_matrix_required ("eig", "B");
 
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -133,19 +133,17 @@ IEEE Transactions on Automatic Control, 
 
           if (nargout <= 1)
             retval = ovl (result.hess_matrix ());
           else
             retval = ovl (result.unitary_hess_matrix (),
                           result.hess_matrix ());
         }
       else
-        {
-          err_wrong_type_arg ("hess", arg);
-        }
+        err_wrong_type_arg ("hess", arg);
     }
 
   return retval;
 }
 
 /*
 %!test
 %! a = [1, 2, 3; 5, 4, 6; 8, 7, 9];
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -156,20 +156,17 @@ do_history (const octave_value_list& arg
       else if (arg.is_numeric_type ())
         {
           limit = arg.int_value ();
           if (limit < 0)
             limit = -limit;
           continue;
         }
       else
-        {
-          err_wrong_type_arg ("history", arg);
-          return hlist;
-        }
+        err_wrong_type_arg ("history", arg);
 
       if (option == "-r" || option == "-w" || option == "-a"
           || option == "-n")
         {
           if (i < nargin - 1)
             {
               std::string fname
                 = args(++i).xstring_value ("history: filename must be a string for %s option",
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -2183,20 +2183,17 @@ public:
       n_vals (values.length ()), n_elts (0), have_data (false),
       curr_state (ok)
   {
     for (octave_idx_type i = 0; i < values.length (); i++)
       {
         octave_value val = values(i);
 
         if (val.is_map () || val.is_cell () || val.is_object ())
-          {
-            err_wrong_type_arg (who, val);
-            break;
-          }
+          err_wrong_type_arg (who, val);
       }
   }
 
   ~printf_value_cache (void) { }
 
   // Get the current value as a double and advance the internal pointer.
   octave_value get_next_value (char type = 0);
 
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -203,20 +203,17 @@ do_rand (const octave_value_list& args, 
                 // Negative dimensions treated as zero for Matlab compatibility
                 octave_idx_type elt = iv(i);
                 dims(i) = elt >=0 ? elt : 0;
               }
 
             goto gen_matrix;
           }
         else
-          {
-            err_wrong_type_arg ("rand", tmp);
-            return retval;
-          }
+          err_wrong_type_arg ("rand", tmp);
       }
       break;
 
     default:
       {
         octave_value tmp = args(idx);
 
         if (nargin == 2 && tmp.is_string ())
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -271,20 +271,17 @@ Comment.\n\
 
   if (args(1).is_uint8_type ())
     bias = scale = std::pow (2.0, 7);
   else if (args(1).is_int16_type ())
     scale = std::pow (2.0, 15);
   else if (args(1).is_int32_type ())
     scale = std::pow (2.0, 31);
   else if (args(1).is_integer_type ())
-    {
-      err_wrong_type_arg ("audiowrite", args(1));
-      return ovl ();
-    }
+    err_wrong_type_arg ("audiowrite", args(1));
 
   Matrix audio = args(1).matrix_value ();
 
   int samplerate = args(2).int_value ();
 
   std::string ext;
   size_t dotpos = filename.find_last_of (".");
   if (dotpos != std::string::npos)
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -129,17 +129,16 @@ octave_base_value::squeeze (void) const
   std::string nm = type_name ();
   error ("squeeze: invalid operation for %s type", nm.c_str ());
 }
 
 octave_value
 octave_base_value::full_value (void) const
 {
   err_wrong_type_arg ("full: invalid operation for %s type", type_name ());
-  return octave_value ();
 }
 
 Matrix
 octave_base_value::size (void)
 {
   const dim_vector dv = dims ();
   Matrix mdv (1, dv.length ());
   for (octave_idx_type i = 0; i < dv.length (); i++)
@@ -293,65 +292,58 @@ octave_base_value::undef_subsasgn (const
 
   return subsasgn (type, idx, rhs);
 }
 
 octave_idx_type
 octave_base_value::nnz (void) const
 {
   err_wrong_type_arg ("octave_base_value::nnz ()", type_name ());
-  return -1;
 }
 
 octave_idx_type
 octave_base_value::nzmax (void) const
 {
   return numel ();
 }
 
 octave_idx_type
 octave_base_value::nfields (void) const
 {
   err_wrong_type_arg ("octave_base_value::nfields ()", type_name ());
-  return -1;
 }
 
 octave_value
 octave_base_value::reshape (const dim_vector&) const
 {
   err_wrong_type_arg ("octave_base_value::reshape ()", type_name ());
-  return octave_value ();
 }
 
 octave_value
 octave_base_value::permute (const Array<int>&, bool) const
 {
   err_wrong_type_arg ("octave_base_value::permute ()", type_name ());
-  return octave_value ();
 }
 
 octave_value
 octave_base_value::resize (const dim_vector&, bool) const
 {
   err_wrong_type_arg ("octave_base_value::resize ()", type_name ());
-  return octave_value ();
 }
 
 MatrixType
 octave_base_value::matrix_type (void) const
 {
   err_wrong_type_arg ("octave_base_value::matrix_type ()", type_name ());
-  return MatrixType ();
 }
 
 MatrixType
 octave_base_value::matrix_type (const MatrixType&) const
 {
   err_wrong_type_arg ("octave_base_value::matrix_type ()", type_name ());
-  return MatrixType ();
 }
 
 octave_value
 octave_base_value::all (int) const
 {
   return 0.0;
 }
 
@@ -373,17 +365,16 @@ octave_base_value::convert_to_str (bool 
   return retval;
 }
 
 octave_value
 octave_base_value::convert_to_str_internal (bool, bool, char) const
 {
   err_wrong_type_arg ("octave_base_value::convert_to_str_internal ()",
                       type_name ());
-  return octave_value ();
 }
 
 void
 octave_base_value::convert_to_row_or_column_vector (void)
 {
   err_wrong_type_arg
     ("octave_base_value::convert_to_row_or_column_vector ()", type_name ());
 }
@@ -502,149 +493,110 @@ octave_base_value::nint_value (bool frc_
     error ("conversion of NaN to integer value failed");
 
   return static_cast<int> (::fix (d));
 }
 
 double
 octave_base_value::double_value (bool) const
 {
-  double retval = lo_ieee_nan_value ();
   err_wrong_type_arg ("octave_base_value::double_value ()", type_name ());
-  return retval;
 }
 
 float
 octave_base_value::float_value (bool) const
 {
-  float retval = lo_ieee_float_nan_value ();
   err_wrong_type_arg ("octave_base_value::float_value ()", type_name ());
-  return retval;
 }
 
 Cell
 octave_base_value::cell_value () const
 {
-  Cell retval;
   err_wrong_type_arg ("octave_base_value::cell_value()", type_name ());
-  return retval;
 }
 
 Matrix
 octave_base_value::matrix_value (bool) const
 {
-  Matrix retval;
   err_wrong_type_arg ("octave_base_value::matrix_value()", type_name ());
-  return retval;
 }
 
 FloatMatrix
 octave_base_value::float_matrix_value (bool) const
 {
-  FloatMatrix retval;
-  err_wrong_type_arg ("octave_base_value::float_matrix_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::float_matrix_value()", type_name ());
 }
 
 NDArray
 octave_base_value::array_value (bool) const
 {
-  FloatNDArray retval;
   err_wrong_type_arg ("octave_base_value::array_value()", type_name ());
-  return retval;
 }
 
 FloatNDArray
 octave_base_value::float_array_value (bool) const
 {
-  FloatNDArray retval;
   err_wrong_type_arg ("octave_base_value::float_array_value()", type_name ());
-  return retval;
 }
 
 Complex
 octave_base_value::complex_value (bool) const
 {
-  double tmp = lo_ieee_nan_value ();
-  Complex retval (tmp, tmp);
   err_wrong_type_arg ("octave_base_value::complex_value()", type_name ());
-  return retval;
 }
 
 FloatComplex
 octave_base_value::float_complex_value (bool) const
 {
-  float tmp = lo_ieee_float_nan_value ();
-  FloatComplex retval (tmp, tmp);
-  err_wrong_type_arg ("octave_base_value::float_complex_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::float_complex_value()", type_name ());
 }
 
 ComplexMatrix
 octave_base_value::complex_matrix_value (bool) const
 {
-  ComplexMatrix retval;
   err_wrong_type_arg ("octave_base_value::complex_matrix_value()",
                       type_name ());
-  return retval;
 }
 
 FloatComplexMatrix
 octave_base_value::float_complex_matrix_value (bool) const
 {
-  FloatComplexMatrix retval;
   err_wrong_type_arg ("octave_base_value::float_complex_matrix_value()",
                       type_name ());
-  return retval;
 }
 
 ComplexNDArray
 octave_base_value::complex_array_value (bool) const
 {
-  ComplexNDArray retval;
-  err_wrong_type_arg ("octave_base_value::complex_array_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::complex_array_value()", type_name ());
 }
 
 FloatComplexNDArray
 octave_base_value::float_complex_array_value (bool) const
 {
-  FloatComplexNDArray retval;
   err_wrong_type_arg ("octave_base_value::float_complex_array_value()",
                       type_name ());
-  return retval;
 }
 
 bool
 octave_base_value::bool_value (bool) const
 {
-  bool retval = false;
   err_wrong_type_arg ("octave_base_value::bool_value()", type_name ());
-  return retval;
 }
 
 boolMatrix
 octave_base_value::bool_matrix_value (bool) const
 {
-  boolMatrix retval;
-  err_wrong_type_arg ("octave_base_value::bool_matrix_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::bool_matrix_value()", type_name ());
 }
 
 boolNDArray
 octave_base_value::bool_array_value (bool) const
 {
-  boolNDArray retval;
-  err_wrong_type_arg ("octave_base_value::bool_array_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::bool_array_value()", type_name ());
 }
 
 charMatrix
 octave_base_value::char_matrix_value (bool force) const
 {
   charMatrix retval;
 
   octave_value tmp = convert_to_str (false, force);
@@ -652,234 +604,166 @@ octave_base_value::char_matrix_value (bo
   retval = tmp.char_matrix_value ();
 
   return retval;
 }
 
 charNDArray
 octave_base_value::char_array_value (bool) const
 {
-  charNDArray retval;
-  err_wrong_type_arg ("octave_base_value::char_array_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::char_array_value()", type_name ());
 }
 
 SparseMatrix
 octave_base_value::sparse_matrix_value (bool) const
 {
-  SparseMatrix retval;
-  err_wrong_type_arg ("octave_base_value::sparse_matrix_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::sparse_matrix_value()", type_name ());
 }
 
 SparseComplexMatrix
 octave_base_value::sparse_complex_matrix_value (bool) const
 {
-  SparseComplexMatrix retval;
   err_wrong_type_arg ("octave_base_value::sparse_complex_matrix_value()",
                       type_name ());
-  return retval;
 }
 
 SparseBoolMatrix
 octave_base_value::sparse_bool_matrix_value (bool) const
 {
-  SparseBoolMatrix retval;
   err_wrong_type_arg ("octave_base_value::sparse_bool_matrix_value()",
                       type_name ());
-  return retval;
 }
 
 DiagMatrix
 octave_base_value::diag_matrix_value (bool) const
 {
-  DiagMatrix retval;
   err_wrong_type_arg ("octave_base_value::diag_matrix_value()", type_name ());
-  return retval;
 }
 
 FloatDiagMatrix
 octave_base_value::float_diag_matrix_value (bool) const
 {
-  FloatDiagMatrix retval;
   err_wrong_type_arg ("octave_base_value::float_diag_matrix_value()",
                       type_name ());
-  return retval;
 }
 
 ComplexDiagMatrix
 octave_base_value::complex_diag_matrix_value (bool) const
 {
-  ComplexDiagMatrix retval;
   err_wrong_type_arg ("octave_base_value::complex_diag_matrix_value()",
                       type_name ());
-  return retval;
 }
 
 FloatComplexDiagMatrix
 octave_base_value::float_complex_diag_matrix_value (bool) const
 {
-  FloatComplexDiagMatrix retval;
   err_wrong_type_arg ("octave_base_value::float_complex_diag_matrix_value()",
                       type_name ());
-  return retval;
 }
 
 PermMatrix
 octave_base_value::perm_matrix_value (void) const
 {
-  PermMatrix retval;
   err_wrong_type_arg ("octave_base_value::perm_matrix_value()", type_name ());
-  return retval;
 }
 
 octave_int8
 octave_base_value::int8_scalar_value (void) const
 {
-  octave_int8 retval;
-  err_wrong_type_arg ("octave_base_value::int8_scalar_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::int8_scalar_value()", type_name ());
 }
 
 octave_int16
 octave_base_value::int16_scalar_value (void) const
 {
-  octave_int16 retval;
-  err_wrong_type_arg ("octave_base_value::int16_scalar_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::int16_scalar_value()", type_name ());
 }
 
 octave_int32
 octave_base_value::int32_scalar_value (void) const
 {
-  octave_int32 retval;
-  err_wrong_type_arg ("octave_base_value::int32_scalar_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::int32_scalar_value()", type_name ());
 }
 
 octave_int64
 octave_base_value::int64_scalar_value (void) const
 {
-  octave_int64 retval;
-  err_wrong_type_arg ("octave_base_value::int64_scalar_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::int64_scalar_value()", type_name ());
 }
 
 octave_uint8
 octave_base_value::uint8_scalar_value (void) const
 {
-  octave_uint8 retval;
-  err_wrong_type_arg ("octave_base_value::uint8_scalar_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::uint8_scalar_value()", type_name ());
 }
 
 octave_uint16
 octave_base_value::uint16_scalar_value (void) const
 {
-  octave_uint16 retval;
-  err_wrong_type_arg ("octave_base_value::uint16_scalar_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::uint16_scalar_value()", type_name ());
 }
 
 octave_uint32
 octave_base_value::uint32_scalar_value (void) const
 {
-  octave_uint32 retval;
-  err_wrong_type_arg ("octave_base_value::uint32_scalar_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::uint32_scalar_value()", type_name ());
 }
 
 octave_uint64
 octave_base_value::uint64_scalar_value (void) const
 {
-  octave_uint64 retval;
-  err_wrong_type_arg ("octave_base_value::uint64_scalar_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::uint64_scalar_value()", type_name ());
 }
 
 int8NDArray
 octave_base_value::int8_array_value (void) const
 {
-  int8NDArray retval;
-  err_wrong_type_arg ("octave_base_value::int8_array_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::int8_array_value()", type_name ());
 }
 
 int16NDArray
 octave_base_value::int16_array_value (void) const
 {
-  int16NDArray retval;
-  err_wrong_type_arg ("octave_base_value::int16_array_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::int16_array_value()", type_name ());
 }
 
 int32NDArray
 octave_base_value::int32_array_value (void) const
 {
-  int32NDArray retval;
-  err_wrong_type_arg ("octave_base_value::int32_array_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::int32_array_value()", type_name ());
 }
 
 int64NDArray
 octave_base_value::int64_array_value (void) const
 {
-  int64NDArray retval;
-  err_wrong_type_arg ("octave_base_value::int64_array_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::int64_array_value()", type_name ());
 }
 
 uint8NDArray
 octave_base_value::uint8_array_value (void) const
 {
-  uint8NDArray retval;
-  err_wrong_type_arg ("octave_base_value::uint8_array_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::uint8_array_value()", type_name ());
 }
 
 uint16NDArray
 octave_base_value::uint16_array_value (void) const
 {
-  uint16NDArray retval;
-  err_wrong_type_arg ("octave_base_value::uint16_array_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::uint16_array_value()", type_name ());
 }
 
 uint32NDArray
 octave_base_value::uint32_array_value (void) const
 {
-  uint32NDArray retval;
-  err_wrong_type_arg ("octave_base_value::uint32_array_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::uint32_array_value()", type_name ());
 }
 
 uint64NDArray
 octave_base_value::uint64_array_value (void) const
 {
-  uint64NDArray retval;
-  err_wrong_type_arg ("octave_base_value::uint64_array_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::uint64_array_value()", type_name ());
 }
 
 string_vector
 octave_base_value::string_vector_value (bool pad) const
 {
   string_vector retval;
 
   octave_value tmp = convert_to_str (pad, true);
@@ -907,91 +791,75 @@ octave_base_value::xstring_value (void) 
   std::string retval;
   wrong_type_arg_error ();
   return retval;
 }
 
 Array<std::string>
 octave_base_value::cellstr_value (void) const
 {
-  Array<std::string> retval;
-  err_wrong_type_arg ("octave_base_value::cellstr_value()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::cellstr_value()", type_name ());
 }
 
 Range
 octave_base_value::range_value (void) const
 {
-  Range retval;
   err_wrong_type_arg ("octave_base_value::range_value()", type_name ());
-  return retval;
 }
 
 octave_map
 octave_base_value::map_value (void) const
 {
-  octave_map retval;
   err_wrong_type_arg ("octave_base_value::map_value()", type_name ());
-  return retval;
 }
 
 octave_scalar_map
 octave_base_value::scalar_map_value (void) const
 {
   octave_map tmp = map_value ();
 
   if (tmp.numel () != 1)
     error ("invalid conversion of multi-dimensional struct to scalar struct");
 
   return octave_scalar_map (tmp.checkelem (0));
 }
 
 string_vector
 octave_base_value::map_keys (void) const
 {
-  string_vector retval;
   err_wrong_type_arg ("octave_base_value::map_keys()", type_name ());
-  return retval;
 }
 
 size_t
 octave_base_value::nparents (void) const
 {
-  size_t retval = 0;
   err_wrong_type_arg ("octave_base_value::nparents()", type_name ());
-  return retval;
 }
 
 std::list<std::string>
 octave_base_value::parent_class_name_list (void) const
 {
-  std::list<std::string> retval;
   err_wrong_type_arg ("octave_base_value::parent_class_name_list()",
                       type_name ());
-  return retval;
 }
 
 string_vector
 octave_base_value::parent_class_names (void) const
 {
-  string_vector retval;
-  err_wrong_type_arg ("octave_base_value::parent_class_names()",
-                      type_name ());
-  return retval;
+  err_wrong_type_arg ("octave_base_value::parent_class_names()", type_name ());
 }
 
 octave_function *
 octave_base_value::function_value (bool silent)
 {
   octave_function *retval = 0;
 
   if (! silent)
-    err_wrong_type_arg ("octave_base_value::function_value()",
-                        type_name ());
+    err_wrong_type_arg ("octave_base_value::function_value()", type_name ());
+
   return retval;
 }
 
 octave_user_function *
 octave_base_value::user_function_value (bool silent)
 {
   octave_user_function *retval = 0;
 
@@ -1002,177 +870,151 @@ octave_base_value::user_function_value (
 }
 
 octave_user_script *
 octave_base_value::user_script_value (bool silent)
 {
   octave_user_script *retval = 0;
 
   if (! silent)
-    err_wrong_type_arg ("octave_base_value::user_script_value()",
-                        type_name ());
+    err_wrong_type_arg ("octave_base_value::user_script_value()", type_name ());
+
   return retval;
 }
 
 octave_user_code *
 octave_base_value::user_code_value (bool silent)
 {
   octave_user_code *retval = 0;
 
   if (! silent)
-    err_wrong_type_arg ("octave_base_value::user_code_value()",
-                        type_name ());
+    err_wrong_type_arg ("octave_base_value::user_code_value()", type_name ());
+
   return retval;
 }
 
 octave_fcn_handle *
 octave_base_value::fcn_handle_value (bool silent)
 {
   octave_fcn_handle *retval = 0;
 
   if (! silent)
-    err_wrong_type_arg ("octave_base_value::fcn_handle_value()",
-                        type_name ());
+    err_wrong_type_arg ("octave_base_value::fcn_handle_value()", type_name ());
+
   return retval;
 }
 
 octave_fcn_inline *
 octave_base_value::fcn_inline_value (bool silent)
 {
   octave_fcn_inline *retval = 0;
 
   if (! silent)
-    err_wrong_type_arg ("octave_base_value::fcn_inline_value()",
-                        type_name ());
+    err_wrong_type_arg ("octave_base_value::fcn_inline_value()", type_name ());
+
   return retval;
 }
 
 octave_value_list
 octave_base_value::list_value (void) const
 {
-  octave_value_list retval;
   err_wrong_type_arg ("octave_base_value::list_value()", type_name ());
-  return retval;
 }
 
 bool
 octave_base_value::save_ascii (std::ostream&)
 {
   err_wrong_type_arg ("octave_base_value::save_ascii()", type_name ());
-  return false;
 }
 
 bool
 octave_base_value::load_ascii (std::istream&)
 {
   err_wrong_type_arg ("octave_base_value::load_ascii()", type_name ());
-  return false;
 }
 
 bool
 octave_base_value::save_binary (std::ostream&, bool&)
 {
   err_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
-  return false;
 }
 
 bool
 octave_base_value::load_binary (std::istream&, bool,
                                 oct_mach_info::float_format)
 {
   err_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
-  return false;
 }
 
 bool
 octave_base_value::save_hdf5 (octave_hdf5_id, const char *, bool)
 {
   err_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
-
-  return false;
 }
 
 bool
 octave_base_value::load_hdf5 (octave_hdf5_id, const char *)
 {
   err_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
-
-  return false;
 }
 
 int
 octave_base_value::write (octave_stream&, int, oct_data_conv::data_type,
                           int, oct_mach_info::float_format) const
 {
   err_wrong_type_arg ("octave_base_value::write()", type_name ());
-
-  return false;
 }
 
 mxArray *
 octave_base_value::as_mxArray (void) const
 {
   return 0;
 }
 
 octave_value
 octave_base_value::diag (octave_idx_type) const
 {
   err_wrong_type_arg ("octave_base_value::diag ()", type_name ());
-
-  return octave_value ();
 }
 
 octave_value
 octave_base_value::diag (octave_idx_type, octave_idx_type) const
 {
   err_wrong_type_arg ("octave_base_value::diag ()", type_name ());
-
-  return octave_value ();
 }
 
 octave_value
 octave_base_value::sort (octave_idx_type, sortmode) const
 {
   err_wrong_type_arg ("octave_base_value::sort ()", type_name ());
-
-  return octave_value ();
 }
 
 octave_value
 octave_base_value::sort (Array<octave_idx_type> &,
                          octave_idx_type, sortmode) const
 {
   err_wrong_type_arg ("octave_base_value::sort ()", type_name ());
-
-  return octave_value ();
 }
 
 sortmode
 octave_base_value::is_sorted (sortmode) const
 {
   err_wrong_type_arg ("octave_base_value::is_sorted ()", type_name ());
-
-  return UNSORTED;
 }
 
 Array<octave_idx_type>
 octave_base_value::sort_rows_idx (sortmode) const
 {
   err_wrong_type_arg ("octave_base_value::sort_rows_idx ()", type_name ());
-
-  return Array<octave_idx_type> ();
 }
 
 sortmode
 octave_base_value::is_sorted_rows (sortmode) const
 {
   err_wrong_type_arg ("octave_base_value::is_sorted_rows ()", type_name ());
-
-  return UNSORTED;
 }
 
 
 const char *
 octave_base_value::get_umap_name (unary_mapper_t umap)
 {
   static const char *names[num_unary_mappers] =
   {
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -837,19 +837,17 @@ octave_class::byte_size (void) const
     }
 
   return retval;
 }
 
 string_vector
 octave_class::map_keys (void) const
 {
-  string_vector retval;
   err_wrong_type_arg ("octave_class::map_keys()", type_name ());
-  return retval;
 }
 
 octave_base_value *
 octave_class::find_parent_class (const std::string& parent_class_name)
 {
   octave_base_value* retval = 0;
 
   if (parent_class_name == class_name ())
@@ -1613,18 +1611,16 @@ error_cleanup:
 
   return retval;
 }
 
 mxArray *
 octave_class::as_mxArray (void) const
 {
   err_wrong_type_arg ("octave_class::as_mxArray ()", type_name ());
-
-  return 0;
 }
 
 bool
 octave_class::in_class_method (void)
 {
   octave_function *fcn = octave_call_stack::current ();
 
   return (fcn
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2167,24 +2167,21 @@ do_binary_op (octave_value::binary_op op
                   tv1 = octave_value (tmp);
                   t1 = tv1.type_id ();
                 }
 
               if (cf2)
                 {
                   octave_base_value *tmp = cf2 (*tv2.rep);
 
-                  if (tmp)
-                    {
-                      tv2 = octave_value (tmp);
-                      t2 = tv2.type_id ();
-                    }
-                  else
-                    err_binary_op_conv
-                      (octave_value::binary_op_as_string (op));
+                  if (! tmp)
+                    err_binary_op_conv (octave_value::binary_op_as_string (op));
+
+                  tv2 = octave_value (tmp);
+                  t2 = tv2.type_id ();
                 }
 
               if (! cf1 && ! cf2)
                 err_binary_op (octave_value::binary_op_as_string (op),
                                v1.type_name (), v2.type_name ());
 
               f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -695,20 +695,20 @@ octave_value elem_xpow (FloatNDArray a, 
 #define OCTAVE_MM_POW_OPS(T1, T2) \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
-          return bsxfun_pow (a, b); \
-        else \
+        if (! is_valid_bsxfun ("operator .^", a_dims, b_dims)) \
           err_nonconformant ("operator .^", a_dims, b_dims);  \
+ \
+        return bsxfun_pow (a, b); \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -716,20 +716,20 @@ octave_value elem_xpow (FloatNDArray a, 
 \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
-          return bsxfun_pow (a, b); \
-        else \
+        if (! is_valid_bsxfun ("operator .^", a_dims, b_dims)) \
           err_nonconformant ("operator .^", a_dims, b_dims);  \
+ \
+        return bsxfun_pow (a, b); \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -737,20 +737,20 @@ octave_value elem_xpow (FloatNDArray a, 
 \
   octave_value \
   elem_xpow (const NDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
-          return bsxfun_pow (a, b); \
-        else \
-          err_nonconformant ("operator .^", a_dims, b_dims);  \
+        if (! is_valid_bsxfun ("operator .^", a_dims, b_dims)) \
+          err_nonconformant ("operator .^", a_dims, b_dims); \
+ \
+        return bsxfun_pow (a, b); \
       } \
     T2 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -758,20 +758,20 @@ octave_value elem_xpow (FloatNDArray a, 
 \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const FloatNDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
-          return bsxfun_pow (a, b); \
-        else \
-          err_nonconformant ("operator .^", a_dims, b_dims);  \
+        if (! is_valid_bsxfun ("operator .^", a_dims, b_dims)) \
+          err_nonconformant ("operator .^", a_dims, b_dims); \
+ \
+        return bsxfun_pow (a, b); \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -779,20 +779,20 @@ octave_value elem_xpow (FloatNDArray a, 
 \
   octave_value \
   elem_xpow (const FloatNDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
-          return bsxfun_pow (a, b); \
-        else \
-          err_nonconformant ("operator .^", a_dims, b_dims);  \
+        if (! is_valid_bsxfun ("operator .^", a_dims, b_dims)) \
+          err_nonconformant ("operator .^", a_dims, b_dims); \
+ \
+        return bsxfun_pow (a, b); \
       } \
     T2 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
diff --git a/libinterp/operators/ops.h b/libinterp/operators/ops.h
--- a/libinterp/operators/ops.h
+++ b/libinterp/operators/ops.h
@@ -382,13 +382,13 @@ extern void install_ops (void);
   CATOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     return octave_value (tc1 (v1.CONCAT2(e1, _value) ()) . f (tc2 (v2.CONCAT2(e2, _value) ()), ra_idx)); \
   }
 
 #define CATOP_NONCONFORMANT(msg) \
   err_nonconformant (msg, \
-                       a1.rows (), a1.columns (), \
-                       a2.rows (), a2.columns ()); \
+                     a1.rows (), a1.columns (), \
+                     a2.rows (), a2.columns ()); \
   return octave_value ()
 
 #endif
diff --git a/liboctave/array/CColVector.cc b/liboctave/array/CColVector.cc
--- a/liboctave/array/CColVector.cc
+++ b/liboctave/array/CColVector.cc
@@ -279,20 +279,17 @@ ComplexColumnVector::extract_n (octave_i
 ComplexColumnVector&
 ComplexColumnVector::operator += (const ColumnVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    {
-      err_nonconformant ("operator +=", len, a_len);
-      return *this;
-    }
+    err_nonconformant ("operator +=", len, a_len);
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
@@ -301,20 +298,17 @@ ComplexColumnVector::operator += (const 
 ComplexColumnVector&
 ComplexColumnVector::operator -= (const ColumnVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    {
-      err_nonconformant ("operator -=", len, a_len);
-      return *this;
-    }
+    err_nonconformant ("operator -=", len, a_len);
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_sub2 (len, d, a.data ());
   return *this;
@@ -378,20 +372,17 @@ ComplexColumnVector
 operator * (const DiagMatrix& m, const ComplexColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    {
-      err_nonconformant ("operator *", nr, nc, a_len, 1);
-      return ComplexColumnVector ();
-    }
+    err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
   for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
@@ -406,20 +397,17 @@ ComplexColumnVector
 operator * (const ComplexDiagMatrix& m, const ColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    {
-      err_nonconformant ("operator *", nr, nc, a_len, 1);
-      return ComplexColumnVector ();
-    }
+    err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
   for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
@@ -434,20 +422,17 @@ ComplexColumnVector
 operator * (const ComplexDiagMatrix& m, const ComplexColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    {
-      err_nonconformant ("operator *", nr, nc, a_len, 1);
-      return ComplexColumnVector ();
-    }
+    err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
   for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
diff --git a/liboctave/array/CDiagMatrix.cc b/liboctave/array/CDiagMatrix.cc
--- a/liboctave/array/CDiagMatrix.cc
+++ b/liboctave/array/CDiagMatrix.cc
@@ -416,20 +416,17 @@ ComplexDiagMatrix::operator += (const Di
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r != a_nr || c != a_nc)
-    {
-      err_nonconformant ("operator +=", r, c, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator +=", r, c, a_nr, a_nc);
 
   if (r == 0 || c == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_add2 (length (), d, a.data ());
   return *this;
@@ -465,20 +462,17 @@ operator * (const DiagMatrix& a, const C
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    {
-      err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
-      return ComplexDiagMatrix ();
-    }
+    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
 
@@ -498,20 +492,17 @@ operator * (const ComplexDiagMatrix& a, 
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    {
-      err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
-      return ComplexDiagMatrix ();
-    }
+    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
 
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -3000,20 +3000,17 @@ ComplexMatrix::operator += (const DiagMa
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 ComplexMatrix&
@@ -3021,20 +3018,17 @@ ComplexMatrix::operator -= (const DiagMa
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 ComplexMatrix&
@@ -3042,20 +3036,17 @@ ComplexMatrix::operator += (const Comple
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 ComplexMatrix&
@@ -3063,20 +3054,17 @@ ComplexMatrix::operator -= (const Comple
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 // matrix by matrix -> matrix operations
@@ -3086,20 +3074,17 @@ ComplexMatrix::operator += (const Matrix
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   if (nr == 0 || nc == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_add2 (numel (), d, a.data ());
   return *this;
@@ -3110,20 +3095,17 @@ ComplexMatrix::operator -= (const Matrix
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   if (nr == 0 || nc == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_sub2 (numel (), d, a.data ());
   return *this;
diff --git a/liboctave/array/CRowVector.cc b/liboctave/array/CRowVector.cc
--- a/liboctave/array/CRowVector.cc
+++ b/liboctave/array/CRowVector.cc
@@ -271,20 +271,17 @@ ComplexRowVector::extract_n (octave_idx_
 ComplexRowVector&
 ComplexRowVector::operator += (const RowVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    {
-      err_nonconformant ("operator +=", len, a_len);
-      return *this;
-    }
+    err_nonconformant ("operator +=", len, a_len);
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
@@ -293,20 +290,17 @@ ComplexRowVector::operator += (const Row
 ComplexRowVector&
 ComplexRowVector::operator -= (const RowVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    {
-      err_nonconformant ("operator -=", len, a_len);
-      return *this;
-    }
+    err_nonconformant ("operator -=", len, a_len);
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_sub2 (len, d, a.data ());
   return *this;
diff --git a/liboctave/array/DiagArray2.cc b/liboctave/array/DiagArray2.cc
--- a/liboctave/array/DiagArray2.cc
+++ b/liboctave/array/DiagArray2.cc
@@ -120,21 +120,15 @@ DiagArray2<T>::array_value (void) const
 
 template <typename T>
 bool
 DiagArray2<T>::check_idx (octave_idx_type r, octave_idx_type c) const
 {
   bool ok = true;
 
   if (r < 0 || r >= dim1 ())
-    {
-      err_index_out_of_range (2, 1, r+1, dim1 (), dims ());
-      ok = false;
-    }
+    err_index_out_of_range (2, 1, r+1, dim1 (), dims ());
 
   if (c < 0 || c >= dim2 ())
-    {
-      err_index_out_of_range (2, 2, c+1, dim2 (), dims ());
-      ok = false;
-    }
+    err_index_out_of_range (2, 2, c+1, dim2 (), dims ());
 
   return ok;
 }
diff --git a/liboctave/array/MDiagArray2.cc b/liboctave/array/MDiagArray2.cc
--- a/liboctave/array/MDiagArray2.cc
+++ b/liboctave/array/MDiagArray2.cc
@@ -77,16 +77,17 @@ operator * (const T& s, const MDiagArray
 
 #define MARRAY_DADA_OP(FCN, OP, FN) \
   template <class T> \
   MDiagArray2<T> \
   FCN (const MDiagArray2<T>& a, const MDiagArray2<T>& b) \
   { \
     if (a.d1 != b.d1 || a.d2 != b.d2) \
       err_nonconformant (#FCN, a.d1, a.d2, b.d1, b.d2); \
+ \
     return MDiagArray2<T> (do_mm_binary_op<T, T, T> (a, b, FN, FN, FN, #FCN), a.d1, a.d2); \
   }
 
 MARRAY_DADA_OP (operator +, +, mx_inline_add)
 MARRAY_DADA_OP (operator -, -, mx_inline_sub)
 MARRAY_DADA_OP (product,    *, mx_inline_mul)
 
 // Unary MDiagArray2 ops.
diff --git a/liboctave/array/PermMatrix.cc b/liboctave/array/PermMatrix.cc
--- a/liboctave/array/PermMatrix.cc
+++ b/liboctave/array/PermMatrix.cc
@@ -38,20 +38,17 @@ err_invalid_permutation (void)
 }
 
 void
 PermMatrix::setup (const Array<octave_idx_type>& p, bool colp, bool check)
 {
   if (check)
     {
       if (! idx_vector (p).is_permutation (p.numel ()))
-        {
-          err_invalid_permutation ();
-          Array<octave_idx_type>::operator = (Array<octave_idx_type> ());
-        }
+        err_invalid_permutation ();
     }
 
   if (! colp)
     *this = this->transpose ();
 }
 
 PermMatrix::PermMatrix (const Array<octave_idx_type>& p)
   : Array<octave_idx_type> (p)
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -2590,20 +2590,17 @@ Matrix::operator += (const DiagMatrix& a
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 Matrix&
@@ -2611,20 +2608,17 @@ Matrix::operator -= (const DiagMatrix& a
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 // unary operations
diff --git a/liboctave/array/fCColVector.cc b/liboctave/array/fCColVector.cc
--- a/liboctave/array/fCColVector.cc
+++ b/liboctave/array/fCColVector.cc
@@ -282,20 +282,17 @@ FloatComplexColumnVector::extract_n (oct
 FloatComplexColumnVector&
 FloatComplexColumnVector::operator += (const FloatColumnVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    {
-      err_nonconformant ("operator +=", len, a_len);
-      return *this;
-    }
+    err_nonconformant ("operator +=", len, a_len);
 
   if (len == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
@@ -304,20 +301,17 @@ FloatComplexColumnVector::operator += (c
 FloatComplexColumnVector&
 FloatComplexColumnVector::operator -= (const FloatColumnVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    {
-      err_nonconformant ("operator -=", len, a_len);
-      return *this;
-    }
+    err_nonconformant ("operator -=", len, a_len);
 
   if (len == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_sub2 (len, d, a.data ());
   return *this;
@@ -380,20 +374,17 @@ FloatComplexColumnVector
 operator * (const FloatDiagMatrix& m, const FloatComplexColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    {
-      err_nonconformant ("operator *", nr, nc, a_len, 1);
-      return FloatComplexColumnVector ();
-    }
+    err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return FloatComplexColumnVector (0);
 
   FloatComplexColumnVector result (nr);
 
   for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
@@ -408,20 +399,17 @@ FloatComplexColumnVector
 operator * (const FloatComplexDiagMatrix& m, const FloatColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    {
-      err_nonconformant ("operator *", nr, nc, a_len, 1);
-      return FloatComplexColumnVector ();
-    }
+    err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return FloatComplexColumnVector (0);
 
   FloatComplexColumnVector result (nr);
 
   for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
@@ -436,20 +424,17 @@ FloatComplexColumnVector
 operator * (const FloatComplexDiagMatrix& m, const FloatComplexColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    {
-      err_nonconformant ("operator *", nr, nc, a_len, 1);
-      return FloatComplexColumnVector ();
-    }
+    err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return FloatComplexColumnVector (0);
 
   FloatComplexColumnVector result (nr);
 
   for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
diff --git a/liboctave/array/fCDiagMatrix.cc b/liboctave/array/fCDiagMatrix.cc
--- a/liboctave/array/fCDiagMatrix.cc
+++ b/liboctave/array/fCDiagMatrix.cc
@@ -420,20 +420,17 @@ FloatComplexDiagMatrix::operator += (con
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r != a_nr || c != a_nc)
-    {
-      err_nonconformant ("operator +=", r, c, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator +=", r, c, a_nr, a_nc);
 
   if (r == 0 || c == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_add2 (length (), d, a.data ());
   return *this;
@@ -469,20 +466,17 @@ operator * (const FloatDiagMatrix& a, co
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    {
-      err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
-      return FloatComplexDiagMatrix ();
-    }
+    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return FloatComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   FloatComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
 
@@ -502,20 +496,17 @@ operator * (const FloatComplexDiagMatrix
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    {
-      err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
-      return FloatComplexDiagMatrix ();
-    }
+    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return FloatComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   FloatComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
 
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -3002,20 +3002,17 @@ FloatComplexMatrix::operator += (const F
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 FloatComplexMatrix&
@@ -3023,20 +3020,17 @@ FloatComplexMatrix::operator -= (const F
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 FloatComplexMatrix&
@@ -3044,20 +3038,17 @@ FloatComplexMatrix::operator += (const F
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 FloatComplexMatrix&
@@ -3065,20 +3056,17 @@ FloatComplexMatrix::operator -= (const F
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 // matrix by matrix -> matrix operations
@@ -3088,20 +3076,17 @@ FloatComplexMatrix::operator += (const F
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   if (nr == 0 || nc == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_add2 (numel (), d, a.data ());
   return *this;
@@ -3112,20 +3097,17 @@ FloatComplexMatrix::operator -= (const F
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   if (nr == 0 || nc == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_sub2 (numel (), d, a.data ());
   return *this;
diff --git a/liboctave/array/fCRowVector.cc b/liboctave/array/fCRowVector.cc
--- a/liboctave/array/fCRowVector.cc
+++ b/liboctave/array/fCRowVector.cc
@@ -272,20 +272,17 @@ FloatComplexRowVector::extract_n (octave
 FloatComplexRowVector&
 FloatComplexRowVector::operator += (const FloatRowVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    {
-      err_nonconformant ("operator +=", len, a_len);
-      return *this;
-    }
+    err_nonconformant ("operator +=", len, a_len);
 
   if (len == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
@@ -294,20 +291,17 @@ FloatComplexRowVector::operator += (cons
 FloatComplexRowVector&
 FloatComplexRowVector::operator -= (const FloatRowVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    {
-      err_nonconformant ("operator -=", len, a_len);
-      return *this;
-    }
+    err_nonconformant ("operator -=", len, a_len);
 
   if (len == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_sub2 (len, d, a.data ());
   return *this;
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -2615,20 +2615,17 @@ FloatMatrix::operator += (const FloatDia
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 FloatMatrix&
@@ -2636,20 +2633,17 @@ FloatMatrix::operator -= (const FloatDia
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    {
-      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
-      return *this;
-    }
+    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 // column vector by row vector -> matrix operations
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -73,22 +73,19 @@ idx_vector::idx_colon_rep::idx_colon_rep
       err = true;
     }
 }
 
 octave_idx_type
 idx_vector::idx_colon_rep::checkelem (octave_idx_type i) const
 {
   if (i < 0)
-    {
-      err_index_out_of_range ();
-      return 0;
-    }
-  else
-    return i;
+    err_index_out_of_range ();
+
+  return i;
 }
 
 idx_vector::idx_base_rep *
 idx_vector::idx_colon_rep::sort_idx (Array<octave_idx_type>&)
 {
   (*current_liboctave_error_handler)
     ("internal error: idx_colon_rep::sort_idx");
 
@@ -104,76 +101,57 @@ idx_vector::idx_colon_rep::print (std::o
 
 
 idx_vector::idx_range_rep::idx_range_rep (octave_idx_type _start,
                                           octave_idx_type _limit,
                                           octave_idx_type _step)
   : start(_start), len (_step ? std::max ((_limit - _start) / _step, static_cast<octave_idx_type> (0)) : -1), step (_step)
 {
   if (len < 0)
-    {
-      err_invalid_range ();
-      err = true;
-    }
-  else if (start < 0)
-    {
-      err_invalid_index (start);
-      err = true;
-    }
-  else if (step < 0 && start + (len-1)*step < 0)
-    {
-      err_invalid_index (start + (len-1)*step);
-      err = true;
-    }
+    err_invalid_range ();
+  if (start < 0)
+    err_invalid_index (start);
+  if (step < 0 && start + (len-1)*step < 0)
+    err_invalid_index (start + (len-1)*step);
 }
 
 idx_vector::idx_range_rep::idx_range_rep (const Range& r)
   : start (0), len (r.numel ()), step (1)
 {
   if (len < 0)
     err_invalid_range ();
 
   if (len > 0)
     {
       if (r.all_elements_are_ints ())
         {
           start = static_cast<octave_idx_type> (r.base ()) - 1;
           step = static_cast<octave_idx_type> (r.inc ());
           if (start < 0)
-            {
-              err_invalid_index (start);
-              err = true;
-            }
-          else if (step < 0 && start + (len - 1)*step < 0)
-            {
-              err_invalid_index (start + (len - 1)*step);
-              err = true;
-            }
+            err_invalid_index (start);
+          if (step < 0 && start + (len - 1)*step < 0)
+            err_invalid_index (start + (len - 1)*step);
         }
       else
         {
           // find first non-integer, then gripe about it
           double b = r.base ();
           double inc = r.inc ();
           err_invalid_index (b != gnulib::floor (b) ? b : b + inc);
-          err = true;
         }
     }
 }
 
 octave_idx_type
 idx_vector::idx_range_rep::checkelem (octave_idx_type i) const
 {
   if (i < 0 || i >= len)
-    {
-      err_index_out_of_range ();
-      return 0;
-    }
-  else
-    return start + i*step;
+    err_index_out_of_range ();
+
+  return start + i*step;
 }
 
 idx_vector::idx_base_rep *
 idx_vector::idx_range_rep::sort_uniq_clone (bool)
 {
   if (step < 0)
     return new idx_range_rep (start + (len - 1)*step, len, -step, DIRECT);
   else
@@ -241,20 +219,17 @@ convert_index (octave_idx_type i, bool& 
 }
 
 inline octave_idx_type
 convert_index (double x, bool& conv_error, octave_idx_type& ext)
 {
   octave_idx_type i = static_cast<octave_idx_type> (x);
 
   if (static_cast<double> (i) != x)
-    {
-      err_invalid_index (x-1);
-      conv_error = true;
-    }
+    err_invalid_index (x-1);
 
   return convert_index (i, conv_error, ext);
 }
 
 inline octave_idx_type
 convert_index (float x, bool& conv_error, octave_idx_type& ext)
 {
   return convert_index (static_cast<double> (x), conv_error, ext);
@@ -279,20 +254,17 @@ idx_vector::idx_scalar_rep::idx_scalar_r
 
   data = convert_index (x, err, dummy);
 }
 
 idx_vector::idx_scalar_rep::idx_scalar_rep (octave_idx_type i)
   : data (i)
 {
   if (data < 0)
-    {
-      err_invalid_index (data);
-      err = true;
-    }
+    err_invalid_index (data);
 }
 
 octave_idx_type
 idx_vector::idx_scalar_rep::checkelem (octave_idx_type i) const
 {
   if (i != 0)
     err_index_out_of_range ();
 
@@ -351,19 +323,18 @@ idx_vector::idx_vector_rep::idx_vector_r
   if (len != 0)
     {
       octave_idx_type max = -1;
       for (octave_idx_type i = 0; i < len; i++)
         {
           octave_idx_type k = inda.xelem (i);
           if (k < 0)
             {
-              if (! err)         // only report first error, in case 1000s.
+              if (! err)
                 err_invalid_index (k);
-              err = true;
             }
           else if (k > max)
             max = k;
         }
 
       ext = max + 1;
     }
 }
@@ -462,20 +433,17 @@ idx_vector::idx_vector_rep::~idx_vector_
   else
     delete [] data;
 }
 
 octave_idx_type
 idx_vector::idx_vector_rep::checkelem (octave_idx_type n) const
 {
   if (n < 0 || n >= len)
-    {
-      err_invalid_index (n);
-      return 0;
-    }
+    err_invalid_index (n);
 
   return xelem (n);
 }
 
 idx_vector::idx_base_rep *
 idx_vector::idx_vector_rep::sort_uniq_clone (bool uniq)
 {
   if (len == 0)
@@ -712,20 +680,17 @@ idx_vector::idx_mask_rep::xelem (octave_
     }
   return lste;
 }
 
 octave_idx_type
 idx_vector::idx_mask_rep::checkelem (octave_idx_type n) const
 {
   if (n < 0 || n >= len)
-    {
-      err_invalid_index (n);
-      return 0;
-    }
+    err_invalid_index (n);
 
   return xelem (n);
 }
 
 std::ostream&
 idx_vector::idx_mask_rep::print (std::ostream& os) const
 {
   os << '[';
diff --git a/liboctave/numeric/CmplxGEPBAL.cc b/liboctave/numeric/CmplxGEPBAL.cc
--- a/liboctave/numeric/CmplxGEPBAL.cc
+++ b/liboctave/numeric/CmplxGEPBAL.cc
@@ -67,20 +67,17 @@ ComplexGEPBALANCE::init (const ComplexMa
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler)
         ("ComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims () != b.dims ())
-    {
-      err_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
-      return -1;
-    }
+    err_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (double, plscale, n);
   OCTAVE_LOCAL_BUFFER (double, prscale,  n);
   OCTAVE_LOCAL_BUFFER (double, pwork, 6 * n);
diff --git a/liboctave/numeric/dbleGEPBAL.cc b/liboctave/numeric/dbleGEPBAL.cc
--- a/liboctave/numeric/dbleGEPBAL.cc
+++ b/liboctave/numeric/dbleGEPBAL.cc
@@ -66,20 +66,17 @@ GEPBALANCE::init (const Matrix& a, const
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("GEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims () != b.dims ())
-    {
-      err_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
-      return -1;
-    }
+    err_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (double, plscale, n);
   OCTAVE_LOCAL_BUFFER (double, prscale, n);
   OCTAVE_LOCAL_BUFFER (double, pwork, 6 * n);
diff --git a/liboctave/numeric/fCmplxGEPBAL.cc b/liboctave/numeric/fCmplxGEPBAL.cc
--- a/liboctave/numeric/fCmplxGEPBAL.cc
+++ b/liboctave/numeric/fCmplxGEPBAL.cc
@@ -67,20 +67,17 @@ FloatComplexGEPBALANCE::init (const Floa
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler)
         ("FloatComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims () != b.dims ())
-    {
-      err_nonconformant ("FloatComplexGEPBALANCE", n, n, b.rows(), b.cols());
-      return -1;
-    }
+    err_nonconformant ("FloatComplexGEPBALANCE", n, n, b.rows(), b.cols());
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (float, plscale, n);
   OCTAVE_LOCAL_BUFFER (float, prscale, n);
   OCTAVE_LOCAL_BUFFER (float, pwork, 6 * n);
diff --git a/liboctave/numeric/floatGEPBAL.cc b/liboctave/numeric/floatGEPBAL.cc
--- a/liboctave/numeric/floatGEPBAL.cc
+++ b/liboctave/numeric/floatGEPBAL.cc
@@ -67,20 +67,17 @@ FloatGEPBALANCE::init (const FloatMatrix
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler)
         ("FloatGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims () != b.dims ())
-    {
-      err_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
-      return -1;
-    }
+    err_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (float, plscale, n);
   OCTAVE_LOCAL_BUFFER (float, prscale, n);
   OCTAVE_LOCAL_BUFFER (float, pwork, 6 * n);
diff --git a/liboctave/operators/Sparse-diag-op-defs.h b/liboctave/operators/Sparse-diag-op-defs.h
--- a/liboctave/operators/Sparse-diag-op-defs.h
+++ b/liboctave/operators/Sparse-diag-op-defs.h
@@ -30,84 +30,73 @@ RT do_mul_dm_sm (const DM& d, const SM& 
 {
   const octave_idx_type nr = d.rows ();
   const octave_idx_type nc = d.cols ();
 
   const octave_idx_type a_nr = a.rows ();
   const octave_idx_type a_nc = a.cols ();
 
   if (nc != a_nr)
-    {
-      err_nonconformant ("operator *", nr, nc, a_nr, a_nc);
-      return RT ();
-    }
-  else
+    err_nonconformant ("operator *", nr, nc, a_nr, a_nc);
+
+  RT r (nr, a_nc, a.nnz ());
+
+  octave_idx_type l = 0;
+
+  for (octave_idx_type j = 0; j < a_nc; j++)
     {
-      RT r (nr, a_nc, a.nnz ());
-
-      octave_idx_type l = 0;
-
-      for (octave_idx_type j = 0; j < a_nc; j++)
+      r.xcidx (j) = l;
+      const octave_idx_type colend = a.cidx (j+1);
+      for (octave_idx_type k = a.cidx (j); k < colend; k++)
         {
-          r.xcidx (j) = l;
-          const octave_idx_type colend = a.cidx (j+1);
-          for (octave_idx_type k = a.cidx (j); k < colend; k++)
-            {
-              const octave_idx_type i = a.ridx (k);
-              if (i >= nr) break;
-              r.xdata (l) = d.dgelem (i) * a.data (k);
-              r.xridx (l) = i;
-              l++;
-            }
+          const octave_idx_type i = a.ridx (k);
+          if (i >= nr) break;
+          r.xdata (l) = d.dgelem (i) * a.data (k);
+          r.xridx (l) = i;
+          l++;
         }
-
-      r.xcidx (a_nc) = l;
+    }
 
-      r.maybe_compress (true);
-      return r;
-    }
+  r.xcidx (a_nc) = l;
+
+  r.maybe_compress (true);
+  return r;
 }
 
 template <typename RT, typename SM, typename DM>
 RT do_mul_sm_dm (const SM& a, const DM& d)
 {
   const octave_idx_type nr = d.rows ();
   const octave_idx_type nc = d.cols ();
 
   const octave_idx_type a_nr = a.rows ();
   const octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nc)
-    {
-      err_nonconformant ("operator *", a_nr, a_nc, nr, nc);
-      return RT ();
-    }
-  else
+    err_nonconformant ("operator *", a_nr, a_nc, nr, nc);
+
+  const octave_idx_type mnc = nc < a_nc ? nc: a_nc;
+  RT r (a_nr, nc, a.cidx (mnc));
+
+  for (octave_idx_type j = 0; j < mnc; ++j)
     {
-
-      const octave_idx_type mnc = nc < a_nc ? nc: a_nc;
-      RT r (a_nr, nc, a.cidx (mnc));
-
-      for (octave_idx_type j = 0; j < mnc; ++j)
+      const typename DM::element_type s = d.dgelem (j);
+      const octave_idx_type colend = a.cidx (j+1);
+      r.xcidx (j) = a.cidx (j);
+      for (octave_idx_type k = a.cidx (j); k < colend; ++k)
         {
-          const typename DM::element_type s = d.dgelem (j);
-          const octave_idx_type colend = a.cidx (j+1);
-          r.xcidx (j) = a.cidx (j);
-          for (octave_idx_type k = a.cidx (j); k < colend; ++k)
-            {
-              r.xdata (k) = s * a.data (k);
-              r.xridx (k) = a.ridx (k);
-            }
+          r.xdata (k) = s * a.data (k);
+          r.xridx (k) = a.ridx (k);
         }
-      for (octave_idx_type j = mnc; j <= nc; ++j)
-        r.xcidx (j) = a.cidx (mnc);
+    }
+  for (octave_idx_type j = mnc; j <= nc; ++j)
+    r.xcidx (j) = a.cidx (mnc);
 
-      r.maybe_compress (true);
-      return r;
-    }
+  r.maybe_compress (true);
+  return r;
 }
 
 // FIXME: functors such as this should be gathered somewhere
 template <typename T>
 struct identity_val
   : public std::unary_function <T, T>
 {
   T operator () (const T x) { return x; }
@@ -181,56 +170,44 @@ RT do_commutative_add_dm_sm (const DM& d
                                  identity_val<typename SM::element_type> (),
                                  identity_val<typename DM::element_type> ());
 }
 
 template <typename RT, typename DM, typename SM>
 RT do_add_dm_sm (const DM& d, const SM& a)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
-    {
-      err_nonconformant ("operator +", d.rows (), d.cols (), a.rows (), a.cols ());
-      return RT ();
-    }
+    err_nonconformant ("operator +", d.rows (), d.cols (), a.rows (), a.cols ());
   else
     return do_commutative_add_dm_sm<RT> (d, a);
 }
 
 template <typename RT, typename DM, typename SM>
 RT do_sub_dm_sm (const DM& d, const SM& a)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
-    {
-      err_nonconformant ("operator -", d.rows (), d.cols (), a.rows (), a.cols ());
-      return RT ();
-    }
-  else
-    return inner_do_add_sm_dm<RT> (a, d, std::negate<typename SM::element_type> (),
-                                   identity_val<typename DM::element_type> ());
+    err_nonconformant ("operator -", d.rows (), d.cols (), a.rows (), a.cols ());
+
+  return inner_do_add_sm_dm<RT> (a, d, std::negate<typename SM::element_type> (),
+                                 identity_val<typename DM::element_type> ());
 }
 
 template <typename RT, typename SM, typename DM>
 RT do_add_sm_dm (const SM& a, const DM& d)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
-    {
-      err_nonconformant ("operator +", a.rows (), a.cols (), d.rows (), d.cols ());
-      return RT ();
-    }
-  else
-    return do_commutative_add_dm_sm<RT> (d, a);
+    err_nonconformant ("operator +", a.rows (), a.cols (), d.rows (), d.cols ());
+
+  return do_commutative_add_dm_sm<RT> (d, a);
 }
 
 template <typename RT, typename SM, typename DM>
 RT do_sub_sm_dm (const SM& a, const DM& d)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
-    {
-      err_nonconformant ("operator -", a.rows (), a.cols (), d.rows (), d.cols ());
-      return RT ();
-    }
-  else
-    return inner_do_add_sm_dm<RT> (a, d,
-                                   identity_val<typename SM::element_type> (),
-                                   std::negate<typename DM::element_type> ());
+    err_nonconformant ("operator -", a.rows (), a.cols (), d.rows (), d.cols ());
+
+  return inner_do_add_sm_dm<RT> (a, d,
+                                 identity_val<typename SM::element_type> (),
+                                 std::negate<typename DM::element_type> ());
 }
 
 #endif
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -1736,20 +1736,17 @@ along with Octave; see the file COPYING.
          octave_quit (); \
          r.cidx (i) = m.cidx (i); \
        } \
      \
      r.maybe_compress (true); \
      return r; \
    } \
   else if (nc != a_nr) \
-    { \
-      err_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
-      return RET_TYPE (); \
-    } \
+    err_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
   else \
     { \
       OCTAVE_LOCAL_BUFFER (octave_idx_type, w, nr); \
       RET_TYPE retval (nr, a_nc, static_cast<octave_idx_type> (0)); \
       for (octave_idx_type i = 0; i < nr; i++) \
         w[i] = 0; \
       retval.xcidx (0) = 0; \
       \
@@ -1868,20 +1865,17 @@ along with Octave; see the file COPYING.
   octave_idx_type a_nc = a.cols (); \
   \
   if (nr == 1 && nc == 1) \
     { \
       RET_TYPE retval = m.elem (0,0) * a; \
       return retval; \
     } \
   else if (nc != a_nr) \
-    { \
-      err_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
-      return RET_TYPE (); \
-    } \
+    err_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
   else \
     { \
       RET_TYPE retval (nr, a_nc, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           for (octave_idx_type j = 0; j < a_nr; j++) \
             { \
@@ -1903,20 +1897,17 @@ along with Octave; see the file COPYING.
   octave_idx_type a_nc = a.cols (); \
   \
   if (nr == 1 && nc == 1) \
     { \
       RET_TYPE retval = CONJ_OP (m.elem (0,0)) * a; \
       return retval; \
     } \
   else if (nr != a_nr) \
-    { \
-      err_nonconformant ("operator *", nc, nr, a_nr, a_nc); \
-      return RET_TYPE (); \
-    } \
+    err_nonconformant ("operator *", nc, nr, a_nr, a_nc); \
   else \
     { \
       RET_TYPE retval (nc, a_nc); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           for (octave_idx_type j = 0; j < nc; j++) \
             { \
@@ -1939,20 +1930,17 @@ along with Octave; see the file COPYING.
   octave_idx_type a_nc = a.cols (); \
   \
   if (a_nr == 1 && a_nc == 1) \
     { \
       RET_TYPE retval = m * a.elem (0,0); \
       return retval; \
     } \
   else if (nc != a_nr) \
-    { \
-      err_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
-      return RET_TYPE (); \
-    } \
+    err_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
   else \
     { \
       RET_TYPE retval (nr, a_nc, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           octave_quit (); \
           for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
@@ -1975,20 +1963,17 @@ along with Octave; see the file COPYING.
   octave_idx_type a_nc = a.cols (); \
   \
   if (a_nr == 1 && a_nc == 1) \
     { \
       RET_TYPE retval = m * CONJ_OP (a.elem (0,0)); \
       return retval; \
     } \
   else if (nc != a_nc) \
-    { \
-      err_nonconformant ("operator *", nr, nc, a_nc, a_nr); \
-      return RET_TYPE (); \
-    } \
+    err_nonconformant ("operator *", nr, nc, a_nc, a_nr); \
   else \
     { \
       RET_TYPE retval (nr, a_nr, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           octave_quit (); \
           for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
diff --git a/liboctave/operators/Sparse-perm-op-defs.h b/liboctave/operators/Sparse-perm-op-defs.h
--- a/liboctave/operators/Sparse-perm-op-defs.h
+++ b/liboctave/operators/Sparse-perm-op-defs.h
@@ -57,20 +57,17 @@ SM octinternal_do_mul_colpm_sm (const oc
   return r;
 }
 
 template <typename SM>
 SM octinternal_do_mul_pm_sm (const PermMatrix& p, const SM& a)
 {
   const octave_idx_type nr = a.rows ();
   if (p.cols () != nr)
-    {
-      err_nonconformant ("operator *", p.rows (), p.cols (), a.rows (), a.cols ());
-      return SM ();
-    }
+    err_nonconformant ("operator *", p.rows (), p.cols (), a.rows (), a.cols ());
 
   return octinternal_do_mul_colpm_sm (p.col_perm_vec ().data (), a);
 }
 
 template <typename SM>
 SM octinternal_do_mul_sm_rowpm (const SM& a, const octave_idx_type *prow)
 // For a row permutation, iterate across the source a and stuff the
 // results into the correct destination column in r.
@@ -143,17 +140,14 @@ SM octinternal_do_mul_sm_colpm (const SM
   return r;
 }
 
 template <typename SM>
 SM octinternal_do_mul_sm_pm (const SM& a, const PermMatrix& p)
 {
   const octave_idx_type nc = a.cols ();
   if (p.rows () != nc)
-    {
-      err_nonconformant ("operator *", a.rows (), a.cols (), p.rows (), p.cols ());
-      return SM ();
-    }
+    err_nonconformant ("operator *", a.rows (), a.cols (), p.rows (), p.cols ());
 
   return octinternal_do_mul_sm_colpm (a, p.col_perm_vec ().data ());
 }
 
 #endif
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -374,20 +374,17 @@ do_mm_binary_op (const Array<X>& x, cons
       op (r.numel (), r.fortran_vec (), x.data (), y.data ());
       return r;
     }
   else if (is_valid_bsxfun (opname, dx, dy))
     {
       return do_bsxfun_op (x, y, op, op1, op2);
     }
   else
-    {
-      err_nonconformant (opname, dx, dy);
-      return Array<R> ();
-    }
+    err_nonconformant (opname, dx, dy);
 }
 
 template <class R, class X, class Y>
 inline Array<R>
 do_ms_binary_op (const Array<X>& x, const Y& y,
                  void (*op) (size_t, R *, const X *, Y) throw ())
 {
   Array<R> r (x.dims ());
diff --git a/liboctave/operators/mx-op-defs.h b/liboctave/operators/mx-op-defs.h
--- a/liboctave/operators/mx-op-defs.h
+++ b/liboctave/operators/mx-op-defs.h
@@ -398,29 +398,27 @@ OP (const M& m, const DM& dm) \
   octave_idx_type m_nr = m.rows (); \
   octave_idx_type m_nc = m.cols (); \
  \
   octave_idx_type dm_nr = dm.rows (); \
   octave_idx_type dm_nc = dm.cols (); \
  \
   if (m_nr != dm_nr || m_nc != dm_nc) \
     err_nonconformant (#OP, m_nr, m_nc, dm_nr, dm_nc); \
-  else \
-    { \
-      r.resize (m_nr, m_nc); \
+ \
+  r.resize (m_nr, m_nc); \
  \
-      if (m_nr > 0 && m_nc > 0) \
-        { \
-          r = R (m); \
+  if (m_nr > 0 && m_nc > 0) \
+    { \
+      r = R (m); \
  \
-          octave_idx_type len = dm.length (); \
+      octave_idx_type len = dm.length (); \
  \
-          for (octave_idx_type i = 0; i < len; i++) \
-            r.elem (i, i) OPEQ dm.elem (i, i); \
-        } \
+      for (octave_idx_type i = 0; i < len; i++) \
+        r.elem (i, i) OPEQ dm.elem (i, i); \
     } \
  \
   return r; \
 }
 
 #define MDM_MULTIPLY_OP(R, M, DM, R_ZERO) \
 R \
 operator * (const M& m, const DM& dm) \
@@ -430,31 +428,29 @@ operator * (const M& m, const DM& dm) \
   octave_idx_type m_nr = m.rows (); \
   octave_idx_type m_nc = m.cols (); \
  \
   octave_idx_type dm_nr = dm.rows (); \
   octave_idx_type dm_nc = dm.cols (); \
  \
   if (m_nc != dm_nr) \
     err_nonconformant ("operator *", m_nr, m_nc, dm_nr, dm_nc); \
-  else \
-    { \
-      r = R (m_nr, dm_nc); \
-      R::element_type *rd = r.fortran_vec (); \
-      const M::element_type *md = m.data (); \
-      const DM::element_type *dd = dm.data (); \
+ \
+  r = R (m_nr, dm_nc); \
+  R::element_type *rd = r.fortran_vec (); \
+  const M::element_type *md = m.data (); \
+  const DM::element_type *dd = dm.data (); \
  \
-      octave_idx_type len = dm.length (); \
-      for (octave_idx_type i = 0; i < len; i++) \
-        { \
-          mx_inline_mul (m_nr, rd, md, dd[i]); \
-          rd += m_nr; md += m_nr; \
-        } \
-      mx_inline_fill (m_nr * (dm_nc - len), rd, R_ZERO); \
+  octave_idx_type len = dm.length (); \
+  for (octave_idx_type i = 0; i < len; i++) \
+    { \
+      mx_inline_mul (m_nr, rd, md, dd[i]); \
+      rd += m_nr; md += m_nr; \
     } \
+  mx_inline_fill (m_nr * (dm_nc - len), rd, R_ZERO); \
  \
   return r; \
 }
 
 #define MDM_BIN_OPS(R, M, DM, R_ZERO) \
   MDM_BIN_OP (R, operator +, M, DM, +=) \
   MDM_BIN_OP (R, operator -, M, DM, -=) \
   MDM_MULTIPLY_OP (R, M, DM, R_ZERO)
@@ -502,31 +498,29 @@ operator * (const DM& dm, const M& m) \
   octave_idx_type dm_nr = dm.rows (); \
   octave_idx_type dm_nc = dm.cols (); \
  \
   octave_idx_type m_nr = m.rows (); \
   octave_idx_type m_nc = m.cols (); \
  \
   if (dm_nc != m_nr) \
     err_nonconformant ("operator *", dm_nr, dm_nc, m_nr, m_nc); \
-  else \
-    { \
-      r = R (dm_nr, m_nc); \
-      R::element_type *rd = r.fortran_vec (); \
-      const M::element_type *md = m.data (); \
-      const DM::element_type *dd = dm.data (); \
+ \
+  r = R (dm_nr, m_nc); \
+  R::element_type *rd = r.fortran_vec (); \
+  const M::element_type *md = m.data (); \
+  const DM::element_type *dd = dm.data (); \
  \
-      octave_idx_type len = dm.length (); \
-      for (octave_idx_type i = 0; i < m_nc; i++) \
-        { \
-          mx_inline_mul (len, rd, md, dd); \
-          rd += len; md += m_nr; \
-          mx_inline_fill (dm_nr - len, rd, R_ZERO); \
-          rd += dm_nr - len; \
-        } \
+  octave_idx_type len = dm.length (); \
+  for (octave_idx_type i = 0; i < m_nc; i++) \
+    { \
+      mx_inline_mul (len, rd, md, dd); \
+      rd += len; md += m_nr; \
+      mx_inline_fill (dm_nr - len, rd, R_ZERO); \
+      rd += dm_nr - len; \
     } \
  \
   return r; \
 }
 
 #define DMM_BIN_OPS(R, DM, M, R_ZERO) \
   DMM_BIN_OP (R, operator +, DM, M, +=, ) \
   DMM_BIN_OP (R, operator -, DM, M, +=, -) \
@@ -543,23 +537,21 @@ operator * (const DM& dm, const M& m) \
     octave_idx_type dm1_nr = dm1.rows (); \
     octave_idx_type dm1_nc = dm1.cols (); \
  \
     octave_idx_type dm2_nr = dm2.rows (); \
     octave_idx_type dm2_nc = dm2.cols (); \
  \
     if (dm1_nr != dm2_nr || dm1_nc != dm2_nc) \
       err_nonconformant (#OP, dm1_nr, dm1_nc, dm2_nr, dm2_nc); \
-    else \
-      { \
-        r.resize (dm1_nr, dm1_nc); \
+ \
+    r.resize (dm1_nr, dm1_nc); \
  \
-        if (dm1_nr > 0 && dm1_nc > 0) \
-          F (dm1.length (), r.fortran_vec (), dm1.data (), dm2.data ()); \
-      } \
+    if (dm1_nr > 0 && dm1_nc > 0) \
+      F (dm1.length (), r.fortran_vec (), dm1.data (), dm2.data ()); \
  \
     return r; \
   }
 
 #define DMDM_BIN_OPS(R, DM1, DM2) \
   DMDM_BIN_OP (R, operator +, DM1, DM2, mx_inline_add) \
   DMDM_BIN_OP (R, operator -, DM1, DM2, mx_inline_sub) \
   DMDM_BIN_OP (R, product,    DM1, DM2, mx_inline_mul)
@@ -617,18 +609,18 @@ M operator * (const PM& p, const M& x) \
 #define MPM_MULTIPLY_OP(M, PM) \
 M operator * (const M& x, const PM& p) \
 { \
   octave_idx_type nr = x.rows (); \
   octave_idx_type nc = x.columns (); \
   M result; \
   if (p.rows () != nc) \
     err_nonconformant ("operator *", nr, nc, p.rows (), p.columns ()); \
-  else \
-    result = x.index (idx_vector::colon, p.col_perm_vec ()); \
+  \
+  result = x.index (idx_vector::colon, p.col_perm_vec ()); \
   \
   return result; \
 }
 
 #define PMM_BIN_OPS(R, PM, M) \
   PMM_MULTIPLY_OP(PM, M);
 
 #define MPM_BIN_OPS(R, M, PM) \
