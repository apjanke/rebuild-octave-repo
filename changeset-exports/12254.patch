# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1296103782 18000
#      Wed Jan 26 23:49:42 2011 -0500
# Branch release-3-4-x
# Node ID 23385f2c90b7efb8f1fce545ecd22233ef383bcb
# Parent  1f14586af94cafe160b250c0a19fd50eb02327cb
whitespace fixes

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,17 @@
+2011-01-26  John W. Eaton  <jwe@octave.org>
+
+	* mk-opts.pl, mkoctfile.cc.in, mkoctfile.in: Untabify.
+
+	* mkf77def.in, mk-opts.pl, mkoctfile.cc.in, structdemo.cc,
+	unwinddemo.cc, fortdemo.cc, paramdemo.cc,
+	celldemo.cc,stringdemo.cc, hello.cc, embedded.cc, helloworld.cc:
+	Strip trailing whitespace.
+
 2011-01-26  Ben Abbott  <bpabbott@mac.com>
 
 	* README.MacOS: Modify organization, and update for MacPorts.
 
 2011-01-26  John W. Eaton  <jwe@octave.org>
 
 	* bootstrap: Update from gnulib sources.
 
diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,14 @@
+2011-01-26  John W. Eaton  <jwe@octave.org>
+
+	* interpreter/mk_doc_cache.m, interpreter/mkoctfile.1,
+	interpreter/munge-texi.cc, interpreter/doccheck/mk_undocumented_list:
+	Strip trailing whitespace.
+
 2011-01-26  Rik  <octave@nomad.inbox5.com>
 
 	* interpreter/octave-bug.1: Delete obsolete man page
 	* interpreter/Makefile.am: Stop distributing octave-bug.1 man page.
 
 2011-01-26  Olaf Till <olaf.till@uni-jena.de>
 
 	* interpreter/package.txi: Document variables MKOCTFILE,
diff --git a/doc/interpreter/doccheck/mk_undocumented_list b/doc/interpreter/doccheck/mk_undocumented_list
--- a/doc/interpreter/doccheck/mk_undocumented_list
+++ b/doc/interpreter/doccheck/mk_undocumented_list
@@ -1,17 +1,17 @@
 #!/usr/bin/perl -w
 
 ################################################################################
 # Get a list from Octave of all visible functions
 @octave_output = <<`_END_OCT_SCRIPT_`;
 ../../run-octave --norc --silent --no-history --eval '\
  funclist  = vertcat (__list_functions__ , __builtins__) \
  disp("#!-separator-!#") \
- where = cellfun (\@which, funclist, \"UniformOutput\", 0)' 
+ where = cellfun (\@which, funclist, \"UniformOutput\", 0)'
 _END_OCT_SCRIPT_
 
 die "Unable to invoke 'run-octave'.  Exiting\n" unless (@octave_output);
 
 ################################################################################
 # Winnow list of functions that require a DOCSTRING
 
 $idx = 0;
@@ -27,20 +27,20 @@ while ($_ = $octave_output[$idx++])
 # Remove functions based on directory location
 # deprecated directory, doc/interpreter directory, test/ directory
 FUNC: foreach $idx (0 .. $#where)
 {
    next FUNC if ($where[$idx] =~ /deprecated/i);
    next FUNC if ($where[$idx] =~ /interpreter/i);
    next FUNC if ($where[$idx] =~ m#test/#i);
 
-   push (@functions, $all_functions[$idx]); 
+   push (@functions, $all_functions[$idx]);
 }
 
-# Remove internal functions from the list of features requiring a DOCSTRING  
+# Remove internal functions from the list of features requiring a DOCSTRING
 @functions = grep (! /^__/, @functions);
 
 # Load list of function exceptions not requiring a DOCSTRING
 # Exception data is stored at the bottom of this script
 map { chomp, $exceptions{$_}=1; } <DATA>;
 
 # Remove exception data from the list
 @functions = grep (! $exceptions{$_}, @functions);
diff --git a/doc/interpreter/mk_doc_cache.m b/doc/interpreter/mk_doc_cache.m
--- a/doc/interpreter/mk_doc_cache.m
+++ b/doc/interpreter/mk_doc_cache.m
@@ -82,17 +82,17 @@ k = 1;
 for i = 2:n
 
   block = formatted_text(delim_idx(i-1)+1:delim_idx(i)-1);
 
   [symbol, doc] = strtok (block, "\r\n");
 
   doc = regexprep (doc, "^[\r\n]+", '');
 
-  ## Skip internal functions that start with __ as these aren't 
+  ## Skip internal functions that start with __ as these aren't
   ## indexed by lookfor.
   if (length (symbol) > 2 && regexp (symbol, '^__.+__$'))
     continue;
   endif
 
   if (isempty (doc))
     continue;
   endif
diff --git a/doc/interpreter/mkoctfile.1 b/doc/interpreter/mkoctfile.1
--- a/doc/interpreter/mkoctfile.1
+++ b/doc/interpreter/mkoctfile.1
@@ -17,25 +17,25 @@
 .\" <http://www.gnu.org/licenses/>.
 .\"
 .\" This page was contributed by Dirk Eddelbuettel <edd@debian.org>
 .\"
 .TH MKOCTFILE 1 "1 November 2002" "GNU Octave"
 .SH NAME
 mkoctfile \- Compile dynamic-load modules for GNU Octave
 .SH SYNOPSIS
-.BR mkoctfile\  [\-IDIR]\ [\-DDEF]\ [\-lLIB]\ [\-LDIR]\ [\-M|\-\-depend]\ 
-[\-c]\ [\-o FILE|\-\-output FILE]\ [\-p VAR|\-\-print VAR]\ [\-s|\-\-strip]\ 
-[\-v|\-\-verbose]\ [\-h|\-?|\-\-help]\ \fIfile\fP .\|.\|.  
+.BR mkoctfile\  [\-IDIR]\ [\-DDEF]\ [\-lLIB]\ [\-LDIR]\ [\-M|\-\-depend]
+\ [\-c]\ [\-o FILE|\-\-output FILE]\ [\-p VAR|\-\-print VAR]\ [\-s|\-\-strip]
+\ [\-v|\-\-verbose]\ [\-h|\-?|\-\-help]\ \fIfile\fP .\|.\|.
 .SH DESCRIPTION
 .PP
 \fImkoctfile\fP is used to compile source C, C++ or Fortran source code in
-dynamically loadable 
+dynamically loadable
 .I .oct
-file for 
+file for
 .BR octave (1).
 .SH OPTIONS
 \fImkoctfile\fP accepts the following options:
 .TP 8
 .B \-IDIR
 Add include directory DIR to compile commands.
 .TP 8
 .B \-DDEF
@@ -55,35 +55,35 @@ Compile but do not link.
 .TP 8
 .B \-o FILE|\-\-output FILE
 Output file name; default extension is .oct (or .mex if \-\-mex is
 specified) unless linking a stand-alone executable.
 .TP
 .B \-p VAR|\-\-print VAR
 Print configuration variable VAR.  Recognized variables are:
 .RS
-    ALL_CFLAGS                FFTW_LIBS     
-    ALL_CXXFLAGS              FLIBS       
-    ALL_FFLAGS                FPICFLAG      
-    ALL_LDFLAGS               INCFLAGS      
-    BLAS_LIBS                 LDFLAGS             
-    CC                        LD_CXX              
+    ALL_CFLAGS                FFTW_LIBS
+    ALL_CXXFLAGS              FLIBS
+    ALL_FFLAGS                FPICFLAG
+    ALL_LDFLAGS               INCFLAGS
+    BLAS_LIBS                 LDFLAGS
+    CC                        LD_CXX
     CFLAGS                    LD_STATIC_FLAG
-    CPICFLAG                  LFLAGS              
-    CPPFLAGS                  LIBCRUFT      
-    CXX                       LIBOCTAVE     
-    CXXFLAGS                  LIBOCTINTERP  
-    CXXPICFLAG                LIBREADLINE   
-    DEPEND_EXTRA_SED_PATTERN  LIBS        
-    DEPEND_FLAGS              OCTAVE_LIBS   
-    DL_LD                     RDYNAMIC_FLAG 
-    DL_LDFLAGS                RLD_FLAG      
-    F2C                       SED         
-    F2CFLAGS                  XTRA_CFLAGS   
-    F77                       XTRA_CXXFLAGS 
+    CPICFLAG                  LFLAGS
+    CPPFLAGS                  LIBCRUFT
+    CXX                       LIBOCTAVE
+    CXXFLAGS                  LIBOCTINTERP
+    CXXPICFLAG                LIBREADLINE
+    DEPEND_EXTRA_SED_PATTERN  LIBS
+    DEPEND_FLAGS              OCTAVE_LIBS
+    DL_LD                     RDYNAMIC_FLAG
+    DL_LDFLAGS                RLD_FLAG
+    F2C                       SED
+    F2CFLAGS                  XTRA_CFLAGS
+    F77                       XTRA_CXXFLAGS
     FFLAGS
 .RE
 .TP 8
 .B \-\-link-stand-alone
 Link a stand-alone executable file.
 .TP 8
 .B \-\-mex
 Assume we are creating a MEX file.  Set the default output extension
@@ -91,27 +91,27 @@ to .mex.
 .TP 8
 .B \-s|--strip
 Strip the output file.
 .TP 8
 .B \-v|--verbose
 Echo commands as they are executed.
 .TP 8
 .B file
-Compile or link file. Recognised file types are 
+Compile or link file. Recognised file types are
 .RS
     .c    C source
     .cc   C++ source
     .C    C++ source
     .cpp  C++ source
     .f    Fortran source
     .F    Fortran source
     .o    object file
     .a    library file
 .SH SEE ALSO
 .BR octave (1).
 .RE
 .SH AUTHOR
 John W. Eaton <jwe@octave.org>
 
 This manual page was contributed by Dirk Eddelbuettel
-<edd@debian.org> for the Debian GNU/Linux distribution but 
+<edd@debian.org> for the Debian GNU/Linux distribution but
 may be used by others.
diff --git a/doc/interpreter/munge-texi.cc b/doc/interpreter/munge-texi.cc
--- a/doc/interpreter/munge-texi.cc
+++ b/doc/interpreter/munge-texi.cc
@@ -70,52 +70,52 @@ extract_docstring (std::istream& is)
   while ((c = is.get ()) != EOF && c != doc_delim)
     {
       // Expand @seealso commands to Texinfo references.
       if (c == '@')
         {
           char buf[16];
           int i = 0;
           buf[i++] = static_cast<char> (c);
-          
-          if ((   buf[i++] = static_cast<char> (is.get ())) == 's'  
+
+          if ((   buf[i++] = static_cast<char> (is.get ())) == 's'
               && (buf[i++] = static_cast<char> (is.get ())) == 'e'
               && (buf[i++] = static_cast<char> (is.get ())) == 'e'
               && (buf[i++] = static_cast<char> (is.get ())) == 'a'
               && (buf[i++] = static_cast<char> (is.get ())) == 'l'
               && (buf[i++] = static_cast<char> (is.get ())) == 's'
               && (buf[i++] = static_cast<char> (is.get ())) == 'o'
               && (buf[i++] = static_cast<char> (is.get ())) == '{')
             {
               doc += "@seealso{";
-              
+
               bool first = true;
-              
+
               // process @seealso parameters
               while ((c = is.get ()) != EOF
                      && c != doc_delim
-                     && c != '}') 
+                     && c != '}')
                 {
                   // ignore whitespace and delimiters
-                  while (   c == ' ' 
+                  while (   c == ' '
                          || c == '\t'
                          || c == '\r'
                          || c == '\n'
                          || c == ',')
                     {
                       c = is.get ();
                     }
-                    
+
                   // test for end of @seealso
-                  if (c == '}') 
+                  if (c == '}')
                     break;
-                  
+
                   // get function name
                   std::string function_name;
-                  do 
+                  do
                     function_name += static_cast<char> (c);
                   while ((c = is.get ()) != EOF
                           && c != doc_delim
                           && c != ' '
                           && c != '\t'
                           && c != '\r'
                           && c != '\n'
                           && c != ','
@@ -127,17 +127,17 @@ extract_docstring (std::istream& is)
 
                   if (function_name[0] == '@')
                     function_name = "@" + function_name;
 
                   doc += "@ref{doc-" + function_name + ",,"
                     + function_name + "}";
 
                   // test for end of @seealso
-                  if (c == '}') 
+                  if (c == '}')
                     break;
                 }
               if (c == '}')
                 doc += static_cast<char> (c);
             }
           else
             {
               for (int j = 0; j < i; j++)
diff --git a/examples/celldemo.cc b/examples/celldemo.cc
--- a/examples/celldemo.cc
+++ b/examples/celldemo.cc
@@ -1,12 +1,12 @@
 #include <octave/oct.h>
 #include <octave/Cell.h>
 
-DEFUN_DLD (celldemo, args, , "Cell Demo") 
+DEFUN_DLD (celldemo, args, , "Cell Demo")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
   else
     {
diff --git a/examples/embedded.cc b/examples/embedded.cc
--- a/examples/embedded.cc
+++ b/examples/embedded.cc
@@ -13,17 +13,17 @@ main (void)
   octave_main (2, argv.c_str_vec(), 1);
 
   octave_idx_type n = 2;
   Matrix a_matrix = Matrix (1, 2);
 
   std::cout << "GCD of [";
   for (octave_idx_type i = 0; i < n; i++)
     {
-      a_matrix (i) = 5 * (i + 1); 
+      a_matrix (i) = 5 * (i + 1);
       if (i != 0)
         std::cout << ", " << 5 * (i + 2);
       else
         std::cout << 5 * (i + 2);
     }
   std::cout << "] is ";
 
   octave_value_list in = octave_value (a_matrix);
diff --git a/examples/fortdemo.cc b/examples/fortdemo.cc
--- a/examples/fortdemo.cc
+++ b/examples/fortdemo.cc
@@ -1,35 +1,35 @@
 #include <octave/oct.h>
 #include <octave/f77-fcn.h>
 
-extern "C" 
+extern "C"
 {
-  F77_RET_T 
-  F77_FUNC (fortsub, FORTSUB) 
-        (const int&, double*, F77_CHAR_ARG_DECL  
+  F77_RET_T
+  F77_FUNC (fortsub, FORTSUB)
+        (const int&, double*, F77_CHAR_ARG_DECL
          F77_CHAR_ARG_LEN_DECL);
 }
 
 DEFUN_DLD (fortdemo , args , , "Fortran Demo.")
 {
-  octave_value_list retval;  
+  octave_value_list retval;
   int nargin = args.length();
   if (nargin != 1)
     print_usage ();
   else
     {
       NDArray a = args(0).array_value ();
       if (! error_state)
         {
           double *av = a.fortran_vec ();
           octave_idx_type na = a.nelem ();
           OCTAVE_LOCAL_BUFFER (char, ctmp, 128);
 
-          F77_XFCN (fortsub, FORTSUB, (na, av, ctmp 
+          F77_XFCN (fortsub, FORTSUB, (na, av, ctmp
                     F77_CHAR_ARG_LEN (128)));
 
           retval(1) = std::string (ctmp);
           retval(0) = a;
         }
     }
   return retval;
 }
diff --git a/examples/hello.cc b/examples/hello.cc
--- a/examples/hello.cc
+++ b/examples/hello.cc
@@ -57,17 +57,17 @@
 #include <octave/symtab.h>
 #include <octave/variables.h>
 
 // DEFUN_DLD and the macros that it depends on are defined in the
 // files defun-dld.h, defun.h, and defun-int.h.
 
 // Note that the third parameter (nargout) is not used, so it is
 // omitted from the list of arguments to DEFUN_DLD in order to avoid
-// the warning from gcc about an unused function parameter. 
+// the warning from gcc about an unused function parameter.
 
 DEFUN_DLD (hello, args, ,
   "[...] = hello (...)\n\
 \n\
 Print greeting followed by the values of all the arguments passed.\n\
 Returns all arguments in reverse order.")
 {
   // The list of values to return.  See the declaration in oct-obj.h
diff --git a/examples/helloworld.cc b/examples/helloworld.cc
--- a/examples/helloworld.cc
+++ b/examples/helloworld.cc
@@ -1,11 +1,11 @@
 #include <octave/oct.h>
 
 DEFUN_DLD (helloworld, args, nargout,
   "Hello World Help String")
 {
   int nargin = args.length ();
-  octave_stdout << "Hello World has " << nargin 
+  octave_stdout << "Hello World has " << nargin
         << " input arguments and "
         << nargout << " output arguments.\n";
   return octave_value_list ();
 }
diff --git a/examples/paramdemo.cc b/examples/paramdemo.cc
--- a/examples/paramdemo.cc
+++ b/examples/paramdemo.cc
@@ -1,11 +1,11 @@
 #include <octave/oct.h>
 
-DEFUN_DLD (paramdemo, args, nargout, 
+DEFUN_DLD (paramdemo, args, nargout,
            "Parameter Check Demo.")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin != 1)
     print_usage();
   else if (nargout != 0)
@@ -16,19 +16,19 @@ DEFUN_DLD (paramdemo, args, nargout,
       double min_val = -10.0;
       double max_val = 10.0;
       octave_stdout << "Properties of input array:\n";
       if (m.any_element_is_negative ())
         octave_stdout << "  includes negative values\n";
       if (m.any_element_is_inf_or_nan())
         octave_stdout << "  includes Inf or NaN values\n";
       if (m.any_element_not_one_or_zero())
-        octave_stdout << 
+        octave_stdout <<
           "  includes other values than 1 and 0\n";
       if (m.all_elements_are_int_or_inf_or_nan())
-        octave_stdout << 
+        octave_stdout <<
           "  includes only int, Inf or NaN values\n";
       if (m.all_integers (min_val, max_val))
-        octave_stdout << 
+        octave_stdout <<
           "  includes only integers in [-10,10]\n";
     }
   return retval;
 }
diff --git a/examples/stringdemo.cc b/examples/stringdemo.cc
--- a/examples/stringdemo.cc
+++ b/examples/stringdemo.cc
@@ -1,14 +1,14 @@
 #include <octave/oct.h>
 
 DEFUN_DLD (stringdemo, args, , "String Demo")
 {
   int nargin = args.length();
-  octave_value_list retval; 
+  octave_value_list retval;
 
   if (nargin != 1)
     print_usage ();
   else
     {
       charMatrix ch = args(0).char_matrix_value ();
 
       if (! error_state)
@@ -17,17 +17,17 @@ DEFUN_DLD (stringdemo, args, , "String D
             retval(1) = octave_value (ch, true);
           else
             retval(1) = octave_value (ch, true, '\'');
 
           octave_idx_type nr = ch.rows();
           for (octave_idx_type i = 0; i < nr / 2; i++)
             {
               std::string tmp = ch.row_as_string (i);
-              ch.insert (ch.row_as_string(nr-i-1).c_str(), 
+              ch.insert (ch.row_as_string(nr-i-1).c_str(),
                          i, 0);
               ch.insert (tmp.c_str(), nr-i-1, 0);
             }
           retval(0) = octave_value (ch, true);
         }
     }
   return retval;
 }
diff --git a/examples/structdemo.cc b/examples/structdemo.cc
--- a/examples/structdemo.cc
+++ b/examples/structdemo.cc
@@ -34,11 +34,11 @@ DEFUN_DLD (structdemo, args, , "Struct d
             error ("expecting character string as second argument");
         }
       else
         error ("expecting struct as first argument");
     }
   else
     print_usage ();
 
-  return retval; 
+  return retval;
 }
 
diff --git a/examples/unwinddemo.cc b/examples/unwinddemo.cc
--- a/examples/unwinddemo.cc
+++ b/examples/unwinddemo.cc
@@ -16,17 +16,16 @@ DEFUN_DLD (unwinddemo, args, nargout, "U
   else
     {
       NDArray a = args(0).array_value ();
       NDArray b = args(1).array_value ();
 
       if (! error_state)
         {
           unwind_protect::begin_frame ("Funwinddemo");
-          unwind_protect_ptr 
-            (current_liboctave_warning_handler);
+          unwind_protect_ptr (current_liboctave_warning_handler);
           set_liboctave_warning_handler(err_hand);
           retval = octave_value (quotient (a, b));
           unwind_protect::run_frame ("Funwinddemo");
         }
     }
   return retval;
 }
diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,12 @@
+2011-01-26  John W. Eaton  <jwe@octave.org>
+
+	* mkf77def.in: Strip trailing whitespace.
+
 2011-01-20  John W. Eaton  <jwe@octave.org>
 
 	* misc/cquit.c, misc/f77-fcn.h, misc/quit.cc: Strip trailing
 	whitespace.
 
 2011-01-14  John W. Eaton  <jwe@octave.org>
 
 	* Update copyright notices for 2011.
diff --git a/libcruft/mkf77def.in b/libcruft/mkf77def.in
--- a/libcruft/mkf77def.in
+++ b/libcruft/mkf77def.in
@@ -1,24 +1,24 @@
 #! /bin/sh
 #
 # Copyright (C) 2006-2011 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 SED=${SED:-'sed'}
 AWK=${AWK:-'awk'}
 
 F77_TOLOWER="@F77_APPEND_UNDERSCORE@"
@@ -48,12 +48,13 @@ if [ $# -gt 1 ]; then
   shift
 fi
 
 echo EXPORTS
 for arg
 do
   case "$arg" in
     *.f)
+      ## There are TABS in this sed command.
       $SED -n -e 'y/ABCDEFGHIJLKMNOPQRSTUVWXYZ/abcdefghijlkmnopqrstuvwxyz/; s/^\(      \|	\)[ 	]*\(.*function\|subroutine\|entry\)[ 	]*\([^ 	(]*\).*$/\3/p' "$srcdir/$arg" | eval $awkcmd
     ;;
   esac
 done
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,12 @@
+2011-01-26  John W. Eaton  <jwe@octave.org>
+
+	* oct-refcount.h: Strip trailing whitespace.
+
 2011-01-24  Pascal Dupuis  <Pascal.Dupuis@worldonline.be>
 
 	* SparseQR.h (class SparseQR::SparseQR_reps): Disallow copying.
 	* Array.cc (class rec_permute_helper, class rec_index_helper,
 	class  rec_resize_helper): Likewise.
 	* cmd-edit.cc (class default_command_editor): Likewise.
 
 2011-01-22  Jaroslav Hajek  <highegg@gmail.com>
diff --git a/liboctave/oct-refcount.h b/liboctave/oct-refcount.h
--- a/liboctave/oct-refcount.h
+++ b/liboctave/oct-refcount.h
@@ -28,34 +28,34 @@ template <class T>
 class octave_refcount
 {
 public:
   typedef T count_type;
 
   octave_refcount(count_type initial_count) : count(initial_count) {}
 
   // Increment/Decrement. int is postfix.
-  count_type operator++(void) 
-    { 
-      return ++count; 
+  count_type operator++(void)
+    {
+      return ++count;
     }
 
-  count_type operator++(int) 
-    { 
-      return count++; 
+  count_type operator++(int)
+    {
+      return count++;
     }
 
   count_type operator--(void)
-    { 
-      return --count; 
+    {
+      return --count;
     }
 
   count_type operator--(int)
-    { 
-      return count--; 
+    {
+      return count--;
     }
 
   operator count_type (void) const { return count; }
 
   // For low-level optimizations only.
   count_type& direct (void) const { return count; }
 
 private:
diff --git a/mk-opts.pl b/mk-opts.pl
--- a/mk-opts.pl
+++ b/mk-opts.pl
@@ -1,35 +1,35 @@
 #! /usr/bin/perl
 #
 # Copyright (C) 2002-2011 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 # Generate option handling code from a simpler input files for
 # Octave's functions like lsode, dassl, etc.
 
 # FIXME:
 #
 # * Improve default documentation and/or individual documentation
-#   in data files. 
+#   in data files.
 #
 # * Fix print/show code to display/return something more informative
 #   for special values (for example, -1 ==> infinite in some cases).
 #   Probably need more information in the data files for this.
 
 # Input file format:
 #
 # CLASS = string
@@ -106,27 +106,27 @@ sub parse_input
       elsif (/^\s*FCN_NAME\s*=\s*"(\w+)"\s*$/)
         {
           die "duplicate FCN_NAME" if ($fcn_name ne "");
           $fcn_name = $1;
         }
       elsif (/^\s*INCLUDE\s*=\s*"(\S+)"\s*$/)
         {
           $include = "${include}#include <$1>\n";
-	}
+        }
       elsif (/^\s*DOC_STRING\s*$/)
         {
           die "duplicate DOC_STRING" if ($have_doc_string);
           &parse_doc_string;
           $have_doc_string = 1;
         }
       else
         {
-	  die "mk-opts.pl: unknown command: $_\n"
-	}
+          die "mk-opts.pl: unknown command: $_\n"
+        }
     }
 }
 
 sub parse_option_block
 {
   local ($have_doc_item, $have_init_body, $have_set_body, $have_set_code);
 
   while (<INFILE>)
@@ -208,17 +208,17 @@ sub parse_option_block
 
 sub process_data
 {
   $max_tokens = &max (@n_toks);
 
   &get_min_match_len_info ($max_tokens);
 
   $fcn_name = lc ($CLASS) if ($fcn_name eq "");
-    
+
   $opt_fcn_name = "${fcn_name}_options" if ($opt_fcn_name eq "");
 
   $static_object_name = "${fcn_name}_opts";
 
   if ($doc_string eq "")
     {
       $doc_string = "When called with two arguments, this function\\n\\
 allows you set options parameters for the function \@code{$fcn_name}.\\n\\
@@ -233,24 +233,24 @@ sub get_min_match_len_info
   local ($max_tokens) = @_;
 
   local ($i, $j, $k);
 
   for ($i = 0; $i < $opt_num; $i++)
     {
       for ($j = 0; $j < $max_tokens; $j++)
         {
-	  $min_tok_len_to_match[$i][$j] = 0;
+          $min_tok_len_to_match[$i][$j] = 0;
         }
 
       $min_toks_to_match[$i] = 1;
 
     L1: for ($k = 0; $k < $opt_num; $k++)
         {
-	  local ($duplicate) = 1;
+          local ($duplicate) = 1;
 
           if ($i != $k)
             {
             L2: for ($j = 0; $j < $max_tokens; $j++)
                 {
                   if ($j < $n_toks[$i])
                     {
                       if ($kw_tok[$i][$j] eq $kw_tok[$k][$j])
@@ -259,52 +259,52 @@ sub get_min_match_len_info
                             {
                               $min_tok_len_to_match[$i][$j] = 1;
                             }
 
                           $min_toks_to_match[$i]++;
                         }
                       else
                         {
-			  $duplicate = 0;
+                          $duplicate = 0;
 
-			  if ($min_tok_len_to_match[$i][$j] == 0)
-			    {
-			      $min_tok_len_to_match[$i][$j] = 1;
-			    }
+                          if ($min_tok_len_to_match[$i][$j] == 0)
+                            {
+                              $min_tok_len_to_match[$i][$j] = 1;
+                            }
 
                           local (@s) = split (//, $kw_tok[$i][$j]);
                           local (@t) = split (//, $kw_tok[$k][$j]);
 
                           local ($n, $ii);
                           $n = scalar (@s);
                           $n = scalar (@t) if (@t < $n);
 
                           for ($ii = 0; $ii < $n; $ii++)
                             {
                               if ("$s[$ii]" eq "$t[$ii]")
                                 {
-				  if ($ii + 2 > $min_tok_len_to_match[$i][$j])
-				    {
-				      $min_tok_len_to_match[$i][$j]++;
-				    }
+                                  if ($ii + 2 > $min_tok_len_to_match[$i][$j])
+                                    {
+                                      $min_tok_len_to_match[$i][$j]++;
+                                    }
                                 }
                               else
                                 {
                                   last L2;
                                 }
                             }
 
                           last L1;
                         }
                     }
-		  else
-		    {
-		      die "ambiguous options \"$name[$i]\" and \"$name[$k]\"" if ($duplicate);
-		    }
+                  else
+                    {
+                      die "ambiguous options \"$name[$i]\" and \"$name[$k]\"" if ($duplicate);
+                    }
                 }
             }
         }
     }
 }
 
 sub parse_doc_string
 {
@@ -613,19 +613,19 @@ sub emit_struct_def
 
   print "static ${struct_name} ${static_table_name} [] =\n{\n";
 
   for ($i = 0; $i < $opt_num; $i++)
     {
       &emit_option_table_entry ($i, 0);
 
       if ($i < $opt_num - 1)
-	{
-	  print "\n";
-	}
+        {
+          print "\n";
+        }
     }
 
   print "};\n\n";
 }
 
 sub emit_option_table_entry
 {
   local ($i, $empty) = @_;
@@ -715,36 +715,36 @@ print_${class_name} (std::ostream& os)
           print "    os << val << \"\\n\";\n";
         }
       elsif ($type[$i] eq "std::string")
         {
           print "    os << $static_object_name.$opt[$i] () << \"\\n\";\n";
         }
       elsif ($type[$i] eq "Array<int>" || $type[$i] eq "Array<octave_idx_type>")
         {
-	  if ($type[$i] eq "Array<int>")
+          if ($type[$i] eq "Array<int>")
             {
               $elt_type = "int";
             }
           else
             {
               $elt_type = "octave_idx_type";
             }
           print "    Array<$elt_type> val = $static_object_name.$opt[$i] ();\n\n";
           print "    if (val.length () == 1)
       {
         os << val(0) << \"\\n\";
       }
     else
       {
         os << \"\\n\\n\";
-	octave_idx_type len = val.length ();
-	Matrix tmp (len, 1);
-	for (octave_idx_type i = 0; i < len; i++)
-	  tmp(i,0) = val(i);
+        octave_idx_type len = val.length ();
+        Matrix tmp (len, 1);
+        for (octave_idx_type i = 0; i < len; i++)
+          tmp(i,0) = val(i);
         octave_print_internal (os, tmp, false, 2);
         os << \"\\n\\n\";
       }\n";
         }
       elsif ($type[$i] eq "Array<double>")
         {
           print "    Array<double> val = $static_object_name.$opt[$i] ();\n\n";
           print "    if (val.length () == 1)
@@ -896,35 +896,35 @@ show_${class_name} (const std::string& k
           print "      retval = static_cast<double> (val);\n";
         }
       elsif ($type[$i] eq "std::string")
         {
           print "      retval = $static_object_name.$opt[$i] ();\n";
         }
       elsif ($type[$i] eq "Array<int>" || $type[$i] eq "Array<octave_idx_type>")
         {
-	  if ($type[$i] eq "Array<int>")
+          if ($type[$i] eq "Array<int>")
             {
               $elt_type = "int";
             }
           else
             {
               $elt_type = "octave_idx_type";
             }
           print "      Array<$elt_type> val = $static_object_name.$opt[$i] ();\n\n";
           print "      if (val.length () == 1)
         {
           retval = static_cast<double> (val(0));
         }
       else
         {
-	  octave_idx_type len = val.length ();
-	  ColumnVector tmp (len);
-	  for (octave_idx_type i = 0; i < len; i++)
-	    tmp(i) = val(i);
+          octave_idx_type len = val.length ();
+          ColumnVector tmp (len);
+          for (octave_idx_type i = 0; i < len; i++)
+            tmp(i) = val(i);
           retval = tmp;
         }\n";
         }
       elsif ($type[$i] eq "Array<double>")
         {
           print "      Array<double> val = $static_object_name.$opt[$i] ();\n\n";
           print "      if (val.length () == 1)
         {
@@ -972,19 +972,19 @@ sub emit_options_function
 Options include\\n\\
 \\n\\
 \@table \@code\\n\\\n";
 
   for ($i = 0; $i < $opt_num; $i++)
     {
       print "\@item \\\"$name[$i]\\\"\\n\\\n";
       if ($doc_item[$i] ne "")
-	{
-	  print "$doc_item[$i]";
-	}
+        {
+          print "$doc_item[$i]";
+        }
     }
 
   print "\@end table\\n\\\n\@end deftypefn\")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
@@ -1005,17 +1005,17 @@ Options include\\n\\
         }
       else
         error (\"$opt_fcn_name: expecting keyword as first argument\");
     }
   else
     print_usage ();
 
   return retval;
-}\n";  
+}\n";
 }
 
 sub emit_options_debug
 {
   print "CLASS = \"$class\"\n";
 
   for ($i = 0; $i < $opt_num; $i++)
     {
diff --git a/mkoctfile.cc.in b/mkoctfile.cc.in
--- a/mkoctfile.cc.in
+++ b/mkoctfile.cc.in
@@ -45,25 +45,25 @@ using namespace std;
 
 static bool initialized = false;
 static map<string,string> vars;
 
 static string OCTAVE_VERSION = %OCTAVE_CONF_VERSION%;
 
 static std::string
 substitute_prefix (const std::string& s, const std::string& prefix,
-		   const std::string& new_prefix)
+                   const std::string& new_prefix)
 {
   std::string retval = s;
 
   if (!prefix.empty () && new_prefix != prefix)
     {
       int len = prefix.length ();
       if (retval.find (prefix) == 0)
-	retval.replace (0, len, new_prefix);
+        retval.replace (0, len, new_prefix);
     }
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
   std::replace (retval.begin (), retval.end (), '/', '\\');
 #endif
 
   return retval;
 }
@@ -74,19 +74,19 @@ get_line (FILE *fp)
   static vector<char> buf (100);
   int idx = 0;
   char c;
 
   while (true)
     {
       c = static_cast<char> (fgetc (fp));
       if (c == '\n' || c == EOF)
-	break;
+        break;
       if (buf.size () <= idx)
-	buf.resize (buf.size () + 100);
+        buf.resize (buf.size () + 100);
       buf[idx++] = c;
     }
   if (idx == 0)
     return string ("");
   else
     return string (&buf[0], idx);
 }
 
@@ -125,62 +125,62 @@ initialize (void)
 
   std::string bin_dir (n, '\0');
 
   while (true)
     {
       int status = GetModuleFileName (0, &bin_dir[0], n);
 
       if (status < n)
-	{
-	  bin_dir.resize (status);
-	  break;
-	}
+        {
+          bin_dir.resize (status);
+          break;
+        }
       else
-	{
-	  n *= 2;
-	  bin_dir.resize (n);
-	}
+        {
+          n *= 2;
+          bin_dir.resize (n);
+        }
     }
 
   if (! bin_dir.empty ())
     {
       size_t pos = bin_dir.rfind ("\\bin\\");
 
       if (pos != string::npos)
-	vars["OCTAVE_HOME"] = bin_dir.substr (0, pos);
+        vars["OCTAVE_HOME"] = bin_dir.substr (0, pos);
     }
 #endif
 
   vars["SED"] = get_variable ("SED", %OCTAVE_CONF_SED%);
 
   vars["OCTAVE_PREFIX"] = %OCTAVE_CONF_PREFIX%;
 
   std::string DEFAULT_OCTINCLUDEDIR = %OCTAVE_CONF_OCTINCLUDEDIR%;
   std::string DEFAULT_INCLUDEDIR = %OCTAVE_CONF_INCLUDEDIR%;
   std::string DEFAULT_LIBDIR = %OCTAVE_CONF_LIBDIR%;
   std::string DEFAULT_OCTLIBDIR = %OCTAVE_CONF_OCTLIBDIR%;
 
   if (! vars["OCTAVE_HOME"].empty ())
     {
       DEFAULT_OCTINCLUDEDIR
-	= substitute_prefix (DEFAULT_OCTINCLUDEDIR, vars["OCTAVE_PREFIX"],
-			     vars["OCTAVE_HOME"]);
+        = substitute_prefix (DEFAULT_OCTINCLUDEDIR, vars["OCTAVE_PREFIX"],
+                             vars["OCTAVE_HOME"]);
 
       DEFAULT_INCLUDEDIR
-	= substitute_prefix (DEFAULT_INCLUDEDIR, vars["OCTAVE_PREFIX"],
-			     vars["OCTAVE_HOME"]);
+        = substitute_prefix (DEFAULT_INCLUDEDIR, vars["OCTAVE_PREFIX"],
+                             vars["OCTAVE_HOME"]);
 
       DEFAULT_LIBDIR
-	= substitute_prefix (DEFAULT_LIBDIR, vars["OCTAVE_PREFIX"],
-			     vars["OCTAVE_HOME"]);
+        = substitute_prefix (DEFAULT_LIBDIR, vars["OCTAVE_PREFIX"],
+                             vars["OCTAVE_HOME"]);
 
       DEFAULT_OCTLIBDIR
-	= substitute_prefix (DEFAULT_OCTLIBDIR, vars["OCTAVE_PREFIX"],
-			     vars["OCTAVE_HOME"]);
+        = substitute_prefix (DEFAULT_OCTLIBDIR, vars["OCTAVE_PREFIX"],
+                             vars["OCTAVE_HOME"]);
     }
 
   vars["OCTINCLUDEDIR"] = get_variable ("OCTINCLUDEDIR", DEFAULT_OCTINCLUDEDIR);
   vars["INCLUDEDIR"] = get_variable ("INCLUDEDIR", DEFAULT_INCLUDEDIR);
   vars["LIBDIR"] = get_variable ("LIBDIR", DEFAULT_LIBDIR);
   vars["OCTLIBDIR"] = get_variable ("OCTLIBDIR", DEFAULT_OCTLIBDIR);
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
@@ -291,35 +291,35 @@ static string help_msg =
 "                          (or .mex if --mex is specified) unless linking\n"
 "                          a stand-alone executable.\n"
 "\n"
 "  -g                      Enable debugging options for compilers.\n"
 "\n"
 "  -p VAR, --print VAR     Print configuration variable VAR.  Recognized\n"
 "                          variables are:\n"
 "\n"
-"			    ALL_CFLAGS                FLIBS\n"
-"			    ALL_CXXFLAGS              FPICFLAG\n"
-"			    ALL_FFLAGS                INCFLAGS\n"
-"			    ALL_LDFLAGS               LAPACK_LIBS\n"
-"			    BLAS_LIBS                 LDFLAGS\n"
-"			    CC                        LD_CXX\n"
-"			    CFLAGS                    LD_STATIC_FLAG\n"
-"			    CPICFLAG                  LFLAGS\n"
-"			    CPPFLAGS                  LIBCRUFT\n"
-"			    CXX                       LIBOCTAVE\n"
-"			    CXXFLAGS                  LIBOCTINTERP\n"
-"			    CXXPICFLAG                LIBS\n"
-"			    DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS\n"
-"			    DEPEND_FLAGS              RDYNAMIC_FLAG\n"
-"			    DL_LD                     READLINE_LIBS\n"
-"			    DL_LDFLAGS                RLD_FLAG\n"
-"			    F77                       SED\n"
-"			    FFLAGS                    XTRA_CFLAGS\n"
-"			    FFTW_LIBS                 XTRA_CXXFLAGS\n"
+"                           ALL_CFLAGS                FLIBS\n"
+"                           ALL_CXXFLAGS              FPICFLAG\n"
+"                           ALL_FFLAGS                INCFLAGS\n"
+"                           ALL_LDFLAGS               LAPACK_LIBS\n"
+"                           BLAS_LIBS                 LDFLAGS\n"
+"                           CC                        LD_CXX\n"
+"                           CFLAGS                    LD_STATIC_FLAG\n"
+"                           CPICFLAG                  LFLAGS\n"
+"                           CPPFLAGS                  LIBCRUFT\n"
+"                           CXX                       LIBOCTAVE\n"
+"                           CXXFLAGS                  LIBOCTINTERP\n"
+"                           CXXPICFLAG                LIBS\n"
+"                           DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS\n"
+"                           DEPEND_FLAGS              RDYNAMIC_FLAG\n"
+"                           DL_LD                     READLINE_LIBS\n"
+"                           DL_LDFLAGS                RLD_FLAG\n"
+"                           F77                       SED\n"
+"                           FFLAGS                    XTRA_CFLAGS\n"
+"                           FFTW_LIBS                 XTRA_CXXFLAGS\n"
 "\n"
 "  --link-stand-alone      Link a stand-alone executable file.\n"
 "\n"
 "  --mex                   Assume we are creating a MEX file.  Set the\n"
 "                          default output extension to \".mex\".\n"
 "\n"
 "  -s, --strip             Strip output file.\n"
 "\n"
@@ -351,34 +351,34 @@ basename (const string& s, bool strip_pa
   if (pos == string::npos)
     retval = s;
   else
     retval = s.substr (0, pos);
   if (strip_path)
     {
       size_t p1 = retval.rfind ('/'), p2 = retval.rfind ('\\');
       pos = (p1 != string::npos && p2 != string::npos
-	     ? max (p1, p2) : (p2 != string::npos ? p2 : p1));
+             ? max (p1, p2) : (p2 != string::npos ? p2 : p1));
       if (pos != string::npos)
-	retval = retval.substr (0, pos);
+        retval = retval.substr (0, pos);
     }
   return retval;
 }
 
 inline bool
 starts_with (const string& s, const string& prefix)
 {
   return (s.length () >= prefix.length () && s.find (prefix) == 0);
 }
 
 inline bool
 ends_with (const string& s, const string& suffix)
 {
   return (s.length () >= suffix.length ()
-	  && s.rfind (suffix) == s.length () - suffix.length ());
+          && s.rfind (suffix) == s.length () - suffix.length ());
 }
 
 static int
 run_command (const string& cmd)
 {
   if (debug)
     cout << cmd << endl;
   return system (cmd.c_str ());
@@ -424,355 +424,355 @@ main (int argc, char **argv)
     }
 
   for (int i = 1; i < argc; i++)
     {
       string arg = argv[i];
       size_t len = arg.length ();
 
       if (ends_with (arg, ".c"))
-	{
-	  file = arg;
-	  cfiles.push_back (file);
-	}
+        {
+          file = arg;
+          cfiles.push_back (file);
+        }
       else if (ends_with (arg, ".cc") || ends_with (arg, ".C")
-	       || ends_with (arg, ".cpp"))
-	{
-	  file = arg;
-	  ccfiles.push_back (file);
-	}
+               || ends_with (arg, ".cpp"))
+        {
+          file = arg;
+          ccfiles.push_back (file);
+        }
       else if (ends_with (arg, ".f") || ends_with (arg, ".F")
-	       || ends_with (arg, "f90") || ends_with (arg, ".F90"))
-	{
-	  file = arg;
-	  f77files.push_back (file);
-	}
+               || ends_with (arg, "f90") || ends_with (arg, ".F90"))
+        {
+          file = arg;
+          f77files.push_back (file);
+        }
       else if (ends_with (arg, ".o") || ends_with (arg, ".obj"))
-	{
-	  file = arg;
-	  objfiles += (" " + quote_path (arg));
-	}
+        {
+          file = arg;
+          objfiles += (" " + quote_path (arg));
+        }
       else if (ends_with (arg, ".lib") || ends_with (arg, ".a"))
-	{
-	  file = arg;
-	  libfiles += (" " + quote_path (arg));
-	}
+        {
+          file = arg;
+          libfiles += (" " + quote_path (arg));
+        }
       else if (arg == "-d" || arg == "-debug" || arg == "--debug"
                || arg == "-v" || arg == "-verbose" ||  arg == "--verbose")
-	{
-	  debug = true;
-	  if (vars["CC"] == "cc-msvc")
-	    vars["CC"] += " -d";
-	  if (vars["CXX"] == "cc-msvc")
-	    vars["CXX"] += " -d";
-	  if (vars["DL_LD"] == "cc-msvc")
-	    vars["DL_LD"] += " -d";
-	}
+        {
+          debug = true;
+          if (vars["CC"] == "cc-msvc")
+            vars["CC"] += " -d";
+          if (vars["CXX"] == "cc-msvc")
+            vars["CXX"] += " -d";
+          if (vars["DL_LD"] == "cc-msvc")
+            vars["DL_LD"] += " -d";
+        }
       else if (arg == "-h" || arg == "-?" || arg == "-help" || arg == "--help")
-	{
-	  cout << usage_msg << endl;
-	  cout << help_msg << endl;
-	  return 0;
-	}
+        {
+          cout << usage_msg << endl;
+          cout << help_msg << endl;
+          return 0;
+        }
       else if (starts_with (arg, "-I"))
-	{
-	  incflags += (" " + quote_path (arg));
-	}
+        {
+          incflags += (" " + quote_path (arg));
+        }
       else if (arg == "-idirafter")
-	{
-	  if (i < argc-1)
-	    {
-	      arg = argv[++i];
-	      incflags += (" -idirafter " + arg);
-	    }
-	  else
-	    cerr << "mkoctfile: include directory name missing" << endl;
-	}
+        {
+          if (i < argc-1)
+            {
+              arg = argv[++i];
+              incflags += (" -idirafter " + arg);
+            }
+          else
+            cerr << "mkoctfile: include directory name missing" << endl;
+        }
       else if (starts_with (arg, "-D"))
-	{
-	  defs += (" " + arg);
-	}
+        {
+          defs += (" " + arg);
+        }
       else if (starts_with (arg, "-Wl,") || starts_with (arg, "-l")
-	       || starts_with (arg, "-L") || starts_with (arg, "-R"))
-	{
-	  ldflags += (" " + arg);
-	}
+               || starts_with (arg, "-L") || starts_with (arg, "-R"))
+        {
+          ldflags += (" " + arg);
+        }
       else if (arg == "-M" || arg == "-depend" || arg == "--depend")
-	{
-	  depend = true;
-	  compile = false;
-	}
+        {
+          depend = true;
+          compile = false;
+        }
       else if (arg == "-o" || arg == "-output" || arg == "--output")
-	{
-	  if (i < argc-1)
-	    {
-	      arg = argv[++i];
-	      outputfile = arg;
-	    }
-	  else
-	    cerr << "mkoctfile: output file name missing" << endl;
-	}
+        {
+          if (i < argc-1)
+            {
+              arg = argv[++i];
+              outputfile = arg;
+            }
+          else
+            cerr << "mkoctfile: output file name missing" << endl;
+        }
       else if (arg == "-p" || arg == "-print" || arg == "--print")
-	{
-	  if (i < argc-1)
-	    {
-	      arg = argv[++i];
-	      cout << vars[arg] << endl;
-	      return 0;
-	    }
-	  else
-	    cerr << "mkoctfile: --print requires argument" << endl;
-	}
+        {
+          if (i < argc-1)
+            {
+              arg = argv[++i];
+              cout << vars[arg] << endl;
+              return 0;
+            }
+          else
+            cerr << "mkoctfile: --print requires argument" << endl;
+        }
       else if (arg == "-s" || arg == "-strip" || arg == "--strip")
-	{
-	  if (no_oct_file_strip_on_this_platform)
-	    cerr << "mkoctfile: stripping disabled on this platform" << endl;
-	  else
-	    strip = true;
-	}
+        {
+          if (no_oct_file_strip_on_this_platform)
+            cerr << "mkoctfile: stripping disabled on this platform" << endl;
+          else
+            strip = true;
+        }
       else if (arg == "-c" || arg == "-compile" || arg == "--compile")
-	{
-	  link = false;
-	}
+        {
+          link = false;
+        }
       else if (arg == "-g")
-	{
-	  vars["ALL_CFLAGS"] += " -g";
-	  vars["ALL_CXXFLAGS"] += " -g";
-	  vars["ALL_FFLAGS"] += " -g";
-	}
+        {
+          vars["ALL_CFLAGS"] += " -g";
+          vars["ALL_CXXFLAGS"] += " -g";
+          vars["ALL_FFLAGS"] += " -g";
+        }
       else if (arg == "-link-stand-alone" || arg == "--link-stand-alone")
-	{
-	  link_stand_alone = true;
-	}
+        {
+          link_stand_alone = true;
+        }
       else if (arg == "-mex" || arg == "--mex")
-	{
-	  incflags += " -I.";
+        {
+          incflags += " -I.";
 #ifdef _MSC_VER
-	  ldflags += " -Wl,-export:mexFunction";
+          ldflags += " -Wl,-export:mexFunction";
 #endif
-	  output_ext = ".mex";
-	}
+          output_ext = ".mex";
+        }
       else if (starts_with (arg, "-W"))
-	{
-	  pass_on_options += (" " + arg);
-	}
+        {
+          pass_on_options += (" " + arg);
+        }
       else
-	{
-	  cerr << "mkoctfile: unrecognized argument " << arg;
-	  return 1;
-	}
+        {
+          cerr << "mkoctfile: unrecognized argument " << arg;
+          return 1;
+        }
 
       if (!file.empty () && octfile.empty ())
-	octfile = file;
+        octfile = file;
     }
 
   if (link_stand_alone)
     {
       if (!outputfile.empty ())
-	output_option = "-o " + outputfile;
+        output_option = "-o " + outputfile;
     }
   else
     {
       if (!outputfile.empty ())
         {
           octfile = outputfile;
           size_t len = octfile.length ();
           size_t len_ext = output_ext.length ();
           if (octfile.substr (len-len_ext) != output_ext)
             octfile += output_ext;
         }
       else
-	octfile = basename (octfile, true) + output_ext;
+        octfile = basename (octfile, true) + output_ext;
     }
 
   list<string>::const_iterator it;
 
   if (depend)
     {
       for (it = cfiles.begin (); it != cfiles.end (); ++it)
-	{
-	  string f = *it, dfile = basename (f, true) + ".d", line;
+        {
+          string f = *it, dfile = basename (f, true) + ".d", line;
 
-	  unlink (dfile.c_str ());
-	  string cmd = vars["CC"] + " " + vars["DEPEND_FLAGS"] + " "
-	    + vars["CPPFLAGS"] + " " + vars["ALL_CFLAGS"] + " "
-	    + incflags  + " " + defs + " " + quote_path (f);
+          unlink (dfile.c_str ());
+          string cmd = vars["CC"] + " " + vars["DEPEND_FLAGS"] + " "
+            + vars["CPPFLAGS"] + " " + vars["ALL_CFLAGS"] + " "
+            + incflags  + " " + defs + " " + quote_path (f);
 
-	  FILE *fd = popen (cmd.c_str (), "r");
-	  ofstream fo (dfile.c_str ());
-	  int pos;
-	  while (!feof (fd))
-	    {
-	      line = get_line (fd);
-	      if ((pos = line.rfind (".o:")) != string::npos)
-		{
-		  int spos = line.rfind ('/', pos);
-		  string ofile = (spos == string::npos ? line.substr (0, pos+2) : line.substr (spos+1, pos-spos+1));
-		  fo << "pic/" << ofile << " " << ofile << " " << dfile << line.substr (pos) << endl;
-		}
-	      else
-		fo << line << endl;
-	    }
-	  pclose (fd);
-	  fo.close ();
-	}
+          FILE *fd = popen (cmd.c_str (), "r");
+          ofstream fo (dfile.c_str ());
+          int pos;
+          while (!feof (fd))
+            {
+              line = get_line (fd);
+              if ((pos = line.rfind (".o:")) != string::npos)
+                {
+                  int spos = line.rfind ('/', pos);
+                  string ofile = (spos == string::npos ? line.substr (0, pos+2) : line.substr (spos+1, pos-spos+1));
+                  fo << "pic/" << ofile << " " << ofile << " " << dfile << line.substr (pos) << endl;
+                }
+              else
+                fo << line << endl;
+            }
+          pclose (fd);
+          fo.close ();
+        }
 
       for (it = ccfiles.begin (); it != ccfiles.end (); ++it)
-	{
-	  string f = *it, dfile = basename (f, true) + ".d", line;
+        {
+          string f = *it, dfile = basename (f, true) + ".d", line;
 
-	  unlink (dfile.c_str ());
-	  string cmd = vars["CC"] + " " + vars["DEPEND_FLAGS"] + " "
-	    + vars["CPPFLAGS"] + " " + vars["ALL_CXXFLAGS"] + " "
-	    + incflags  + " " + defs + " " + quote_path (f);
+          unlink (dfile.c_str ());
+          string cmd = vars["CC"] + " " + vars["DEPEND_FLAGS"] + " "
+            + vars["CPPFLAGS"] + " " + vars["ALL_CXXFLAGS"] + " "
+            + incflags  + " " + defs + " " + quote_path (f);
 
-	  FILE *fd = popen (cmd.c_str (), "r");
-	  ofstream fo (dfile.c_str ());
-	  int pos;
-	  while (!feof (fd))
-	    {
-	      line = get_line (fd);
-	      if ((pos = line.rfind (".o:")) != string::npos)
-		{
-		  int spos = line.rfind ('/', pos);
-		  string ofile = (spos == string::npos ? line.substr (0, pos+2) : line.substr (spos+1, pos-spos+1));
-		  fo << "pic/" << ofile << " " << ofile << " " << dfile << line.substr (pos+2) << endl;
-		}
-	      else
-		fo << line << endl;
-	    }
-	  pclose (fd);
-	  fo.close ();
-	}
+          FILE *fd = popen (cmd.c_str (), "r");
+          ofstream fo (dfile.c_str ());
+          int pos;
+          while (!feof (fd))
+            {
+              line = get_line (fd);
+              if ((pos = line.rfind (".o:")) != string::npos)
+                {
+                  int spos = line.rfind ('/', pos);
+                  string ofile = (spos == string::npos ? line.substr (0, pos+2) : line.substr (spos+1, pos-spos+1));
+                  fo << "pic/" << ofile << " " << ofile << " " << dfile << line.substr (pos+2) << endl;
+                }
+              else
+                fo << line << endl;
+            }
+          pclose (fd);
+          fo.close ();
+        }
 
       return 0;
     }
 
   for (it = f77files.begin (); it != f77files.end (); ++it)
     {
       string f = *it, b = basename (f, true);
       if (!vars["F77"].empty ())
-	{
-	  string o;
-	  if (!outputfile.empty ())
-	    {
-	      if (link)
-		o = b + ".o";
-	      else
-		o = outputfile;
-	    }
-	  else
-	    o = b + ".o";
-	  objfiles += (" " + o);
-	  string cmd = vars["F77"] + " -c " + vars["FPICFLAG"] + " "
-	    + vars["ALL_FFLAGS"] + " " + incflags + " " + defs + " "
-	    + pass_on_options + " " + f + " -o " + o;
-	  result = run_command (cmd);
-	}
+        {
+          string o;
+          if (!outputfile.empty ())
+            {
+              if (link)
+                o = b + ".o";
+              else
+                o = outputfile;
+            }
+          else
+            o = b + ".o";
+          objfiles += (" " + o);
+          string cmd = vars["F77"] + " -c " + vars["FPICFLAG"] + " "
+            + vars["ALL_FFLAGS"] + " " + incflags + " " + defs + " "
+            + pass_on_options + " " + f + " -o " + o;
+          result = run_command (cmd);
+        }
       else
-	{
-	  cerr << "mkoctfile: no way to compile Fortran file " << f << endl;
-	  return 1;
-	}
+        {
+          cerr << "mkoctfile: no way to compile Fortran file " << f << endl;
+          return 1;
+        }
     }
 
   for (it = cfiles.begin (); it != cfiles.end (); ++it)
     {
       string f = *it;
       if (!vars["CC"].empty ())
-	{
-	  string b = basename (f, true), o;
-	  if (!outputfile.empty ())
-	    {
-	      if (link)
-		o = b + ".o";
-	      else
-		o = outputfile;
-	    }
-	  else
-	    o = b + ".o";
-	  objfiles += (" " + o);
-	  string cmd = vars["CC"] + " -c " + vars["CPPFLAGS"] + " "
-	    + vars["CPICFLAG"] + " " + vars["ALL_CFLAGS"] + " "
-	    + pass_on_options + " " + incflags + " " + defs + " "
-	    + quote_path (f) + " -o " + quote_path (o);
-	  result = run_command (cmd);
-	}
+        {
+          string b = basename (f, true), o;
+          if (!outputfile.empty ())
+            {
+              if (link)
+                o = b + ".o";
+              else
+                o = outputfile;
+            }
+          else
+            o = b + ".o";
+          objfiles += (" " + o);
+          string cmd = vars["CC"] + " -c " + vars["CPPFLAGS"] + " "
+            + vars["CPICFLAG"] + " " + vars["ALL_CFLAGS"] + " "
+            + pass_on_options + " " + incflags + " " + defs + " "
+            + quote_path (f) + " -o " + quote_path (o);
+          result = run_command (cmd);
+        }
       else
-	{
-	  cerr << "mkoctfile: no way to compile C file " << f << endl;
-	  return 1;
-	}
+        {
+          cerr << "mkoctfile: no way to compile C file " << f << endl;
+          return 1;
+        }
     }
-	
+
   for (it = ccfiles.begin (); it != ccfiles.end (); ++it)
     {
       string f = *it;
       if (!vars["CXX"].empty ())
-	{
-	  string b = basename (f, true), o;
-	  if (!outputfile.empty ())
-	    {
-	      if (link)
-		o = b + ".o";
-	      else
-		o = outputfile;
-	    }
-	  else
-	    o = b + ".o";
-	  objfiles += (" " + o);
-	  string cmd = vars["CXX"] + " -c " + vars["CPPFLAGS"] + " "
-	    + vars["CXXPICFLAG"] + " " + vars["ALL_CXXFLAGS"] + " "
-	    + pass_on_options + " " + incflags + " " + defs + " "
-	    + quote_path (f) + " -o " + quote_path (o);
-	  result = run_command (cmd);
-	}
+        {
+          string b = basename (f, true), o;
+          if (!outputfile.empty ())
+            {
+              if (link)
+                o = b + ".o";
+              else
+                o = outputfile;
+            }
+          else
+            o = b + ".o";
+          objfiles += (" " + o);
+          string cmd = vars["CXX"] + " -c " + vars["CPPFLAGS"] + " "
+            + vars["CXXPICFLAG"] + " " + vars["ALL_CXXFLAGS"] + " "
+            + pass_on_options + " " + incflags + " " + defs + " "
+            + quote_path (f) + " -o " + quote_path (o);
+          result = run_command (cmd);
+        }
       else
-	{
-	  cerr << "mkoctfile: no way to compile C++ file " << f << endl;
-	  return 1;
-	}
+        {
+          cerr << "mkoctfile: no way to compile C++ file " << f << endl;
+          return 1;
+        }
     }
 
   if (link && !objfiles.empty ())
     {
       if (link_stand_alone)
-	{
-	  if (!vars["LD_CXX"].empty ())
-	    {
-	      string cmd = vars["LD_CXX"] + " " + vars["CPPFLAGS"] + " "
-		+ vars["ALL_CXXFLAGS"] + " " + vars["RDYNAMIC_FLAG"]
-		+ " " + vars["ALL_LDFLAGS"] + " " +  pass_on_options
-		+ " " + output_option + " " + objfiles + " " + libfiles
-		+ " " + ldflags + " " + vars["LFLAGS"] + " "
-		+ vars["RLD_FLAG"] + " " + vars["OCTAVE_LIBS"] + " "
-		+ vars["LAPACK_LIBS"] + " " + vars["BLAS_LIBS"] + " "
+        {
+          if (!vars["LD_CXX"].empty ())
+            {
+              string cmd = vars["LD_CXX"] + " " + vars["CPPFLAGS"] + " "
+                + vars["ALL_CXXFLAGS"] + " " + vars["RDYNAMIC_FLAG"]
+                + " " + vars["ALL_LDFLAGS"] + " " +  pass_on_options
+                + " " + output_option + " " + objfiles + " " + libfiles
+                + " " + ldflags + " " + vars["LFLAGS"] + " "
+                + vars["RLD_FLAG"] + " " + vars["OCTAVE_LIBS"] + " "
+                + vars["LAPACK_LIBS"] + " " + vars["BLAS_LIBS"] + " "
                 + vars["FFTW_LIBS"] + " " + vars["READLINE_LIBS"] + " "
                 + vars["LIBS"] + " " + vars["FLIBS"];
-	      result = run_command (cmd);
-	    }
-	  else
-	    {
-	      cerr << "mkoctfile: no way to link stand-alone executable file"
-		   << endl;
-	      return 1;
-	    }
-	}
+              result = run_command (cmd);
+            }
+          else
+            {
+              cerr << "mkoctfile: no way to link stand-alone executable file"
+                   << endl;
+              return 1;
+            }
+        }
       else
-	{
-	  string LINK_DEPS = vars["LFLAGS"] + " " + vars["OCTAVE_LIBS"]
-	    + " " + vars["LDFLAGS"] + " " + vars["BLAS_LIBS"] + " "
-	    + vars["FFTW_LIBS"] + " " + vars["LIBS"] + " " + vars["FLIBS"];
-	  string cmd = vars["DL_LD"] + " " + vars["DL_LDFLAGS"] + " "
-	    + pass_on_options + " -o " + octfile + " " + objfiles + " "
-	    + libfiles + " " + ldflags + " " + LINK_DEPS;
-	  result = run_command (cmd);
-	}
+        {
+          string LINK_DEPS = vars["LFLAGS"] + " " + vars["OCTAVE_LIBS"]
+            + " " + vars["LDFLAGS"] + " " + vars["BLAS_LIBS"] + " "
+            + vars["FFTW_LIBS"] + " " + vars["LIBS"] + " " + vars["FLIBS"];
+          string cmd = vars["DL_LD"] + " " + vars["DL_LDFLAGS"] + " "
+            + pass_on_options + " -o " + octfile + " " + objfiles + " "
+            + libfiles + " " + ldflags + " " + LINK_DEPS;
+          result = run_command (cmd);
+        }
 
       if (strip)
-	{
-	  string cmd = "strip " + octfile;
-	  result = run_command (cmd);
-	}
+        {
+          string cmd = "strip " + octfile;
+          result = run_command (cmd);
+        }
     }
 
   return result;
 }
diff --git a/mkoctfile.in b/mkoctfile.in
--- a/mkoctfile.in
+++ b/mkoctfile.in
@@ -217,35 +217,35 @@ Options:
                           (or .mex if --mex is specified) unless linking
                           a stand-alone executable.
 
   -g                      Enable debugging options for compilers.
 
   -p VAR, --print VAR     Print configuration variable VAR.  Recognized
                           variables are:
 
-			    ALL_CFLAGS                FLIBS
-			    ALL_CXXFLAGS              FPICFLAG
-			    ALL_FFLAGS                INCFLAGS
-			    ALL_LDFLAGS               LAPACK_LIBS
-			    BLAS_LIBS                 LDFLAGS
-			    CC                        LD_CXX
-			    CFLAGS                    LD_STATIC_FLAG
-			    CPICFLAG                  LFLAGS
-			    CPPFLAGS                  LIBCRUFT
-			    CXX                       LIBOCTAVE
-			    CXXFLAGS                  LIBOCTINTERP
-			    CXXPICFLAG                LIBS
-			    DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS
-			    DEPEND_FLAGS              RDYNAMIC_FLAG
-			    DL_LD                     READLINE_LIBS
-			    DL_LDFLAGS                RLD_FLAG
-			    F77                       SED
-			    FFLAGS                    XTRA_CFLAGS
-			    FFTW_LIBS                 XTRA_CXXFLAGS
+                            ALL_CFLAGS                FLIBS
+                            ALL_CXXFLAGS              FPICFLAG
+                            ALL_FFLAGS                INCFLAGS
+                            ALL_LDFLAGS               LAPACK_LIBS
+                            BLAS_LIBS                 LDFLAGS
+                            CC                        LD_CXX
+                            CFLAGS                    LD_STATIC_FLAG
+                            CPICFLAG                  LFLAGS
+                            CPPFLAGS                  LIBCRUFT
+                            CXX                       LIBOCTAVE
+                            CXXFLAGS                  LIBOCTINTERP
+                            CXXPICFLAG                LIBS
+                            DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS
+                            DEPEND_FLAGS              RDYNAMIC_FLAG
+                            DL_LD                     READLINE_LIBS
+                            DL_LDFLAGS                RLD_FLAG
+                            F77                       SED
+                            FFLAGS                    XTRA_CFLAGS
+                            FFTW_LIBS                 XTRA_CXXFLAGS
 
   --link-stand-alone      Link a stand-alone executable file.
 
   --mex                   Assume we are creating a MEX file.  Set the
                           default output extension to ".mex".
 
   -s, --strip             Strip output file.
 
@@ -425,21 +425,21 @@ if [ -n "$f77files" ]; then
         b=`echo $f | $SED 's,.*/,,; s,\.f90$,,'`
       ;;
       *.F90)
         b=`echo $f | $SED 's,.*/,,; s,\.F90$,,'`
       ;;
     esac
     if [ -n "$F77" ]; then
       if [ -n "$outputfile" ]; then
-	if $link; then
-	  o=$b.o
-	else
-	  o=$outputfile
-	fi
+        if $link; then
+          o=$b.o
+        else
+          o=$outputfile
+        fi
       else
         o=$b.o
       fi
       objfiles="$objfiles $o"
       cmd="$F77 -c $FPICFLAG $ALL_FFLAGS $incflags $defs $pass_on_options $f -o $o"
       $dbg $cmd
       eval $cmd
     else
@@ -448,56 +448,56 @@ if [ -n "$f77files" ]; then
   done
 fi
 
 if [ -n "$cfiles" ]; then
   for f in $cfiles; do
     if [ -n  "$CC" ]; then
       b=`echo $f | $SED 's,.*/,,; s,\.c$,,'`
       if [ -n "$outputfile" ]; then
-	if $link; then
-	  o=$b.o
-	else
-	  o=$outputfile
-	fi
+        if $link; then
+          o=$b.o
+        else
+          o=$outputfile
+        fi
       else
-	o=$b.o
+        o=$b.o
       fi
       objfiles="$objfiles $o"
       cmd="$CC -c $CPPFLAGS $CPICFLAG $ALL_CFLAGS $pass_on_options $incflags $defs $f -o $o"
       $dbg $cmd
       eval $cmd
     else
       echo "mkoctfile: no way to compile C++ file $f" 1>&2
     fi
   done
 fi
 
 if [ -n "$ccfiles" ]; then
   for f in $ccfiles; do
     if [ -n "$CXX" ]; then
       case $f in
-	*.cc)
-	  b=`echo $f | $SED 's,.*/,,; s,\.cc$,,'`
-	;;
-	*.C)
-	  b=`echo $f | $SED 's,.*/,,; s,\.C$,,'`
-	;;
-	*.cpp)
-	  b=`echo $f | $SED 's,.*/,,; s,\.cpp$,,'`
-	;;
+        *.cc)
+          b=`echo $f | $SED 's,.*/,,; s,\.cc$,,'`
+        ;;
+        *.C)
+          b=`echo $f | $SED 's,.*/,,; s,\.C$,,'`
+        ;;
+        *.cpp)
+          b=`echo $f | $SED 's,.*/,,; s,\.cpp$,,'`
+        ;;
       esac
       if [ -n "$outputfile" ]; then
-	if $link; then
-	  o=$b.o
-	else
-	  o=$outputfile
-	fi
+        if $link; then
+          o=$b.o
+        else
+          o=$outputfile
+        fi
       else
-	o=$b.o
+        o=$b.o
       fi
       objfiles="$objfiles $o"
       cmd="$CXX -c $CPPFLAGS $CXXPICFLAG $ALL_CXXFLAGS $pass_on_options $incflags $defs $f -o $o"
       $dbg $cmd
       eval $cmd
     else
       echo "mkoctfile: no way to compile C++ file $f" 1>&2
     fi
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,14 @@
+2011-01-26  John W. Eaton  <jwe@octave.org>
+
+	* mkdoc: Untabify.
+
+	* mkdoc, gethelp.cc: Strip trailing whitespace.
+
 2011-01-26  John W. Eaton  <jwe@octave.org>
 
 	* general/curl.m: Simplify processing of outptut values.
 
 2011-01-26  Olaf Till  <olaf.till@uni-jena.de>
 
 	* pkg/pkg.m: Export environment variables MKOCTFILE and
 	OCTAVE_CONFIG for configure and make, to configure also OCTAVE.
diff --git a/scripts/gethelp.cc b/scripts/gethelp.cc
--- a/scripts/gethelp.cc
+++ b/scripts/gethelp.cc
@@ -112,17 +112,17 @@ extract_help_text (void)
             }
         }
     }
 
  done:
 
   if (! help_txt.empty ())
     {
-      if (looks_like_octave_copyright (help_txt)) 
+      if (looks_like_octave_copyright (help_txt))
         help_txt.resize (0);
 
       if (help_txt.empty ())
         help_txt = extract_help_text ();
     }
 
   return help_txt;
 }
@@ -139,17 +139,17 @@ main (int argc, char **argv)
       return 1;
     }
   else
     {
       name = argv[1];
       file_name = argv[2];
     }
 
-  std::string help_text = extract_help_text ();  
+  std::string help_text = extract_help_text ();
 
   if (! help_text.empty ())
     {
       std::cout << "" << name << "\n"
                 << "@c " << name << " " << file_name << "\n"
                 << help_text;
 
       if (help_text[help_text.length () - 1] != '\n')
diff --git a/scripts/mkdoc b/scripts/mkdoc
--- a/scripts/mkdoc
+++ b/scripts/mkdoc
@@ -1,24 +1,24 @@
 #! /bin/sh
 #
 # Copyright (C) 1999-2011 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 ## Expecting arguments in this order:
 ##
 ##  SRCDIR SRCDIR-FILES ... -- LOCAL-FILES ...
 
@@ -38,32 +38,32 @@ if test -f gethelp; then
 
 EOF
   for arg
   do
     if [ "$arg" = "--" ]; then
       prefix="./"
     else
       $PERL -w -e '
-	unless (@ARGV == 2) { die "Usage: $0 srcdir m_filename" ; }
-	($srcdir, $m_fname) = ($ARGV[0], $ARGV[1]);
-	$full_fname = $srcdir . $m_fname;
-	exit unless ( $full_fname =~ m{(.*)/(@|)([^/]*)/(.*)\.m} );
-	if ($2) {
-	  $fcn = "$2$3/$4";
-	} else {
-	  $fcn = $4;
-	}
-	$re_srcdir = quotemeta($srcdir);
-	for (qx{ ./gethelp $fcn "$full_fname" < "$full_fname"} ) {
-	  s/^\s+\@/\@/ unless $in_example;
-	  s/^\s+\@group/\@group/;
-	  s/^\s+\@end\s+group/\@end group/;
-	  s|\@c $fcn $re_srcdir|\@c $fcn scripts/|o;
-	  $in_example = (/\s*\@example\b/ .. /\s*\@end\s+example\b/);
-	  print;
-	}' "$prefix" "$arg"
+        unless (@ARGV == 2) { die "Usage: $0 srcdir m_filename" ; }
+        ($srcdir, $m_fname) = ($ARGV[0], $ARGV[1]);
+        $full_fname = $srcdir . $m_fname;
+        exit unless ( $full_fname =~ m{(.*)/(@|)([^/]*)/(.*)\.m} );
+        if ($2) {
+          $fcn = "$2$3/$4";
+        } else {
+          $fcn = $4;
+        }
+        $re_srcdir = quotemeta($srcdir);
+        for (qx{ ./gethelp $fcn "$full_fname" < "$full_fname"} ) {
+          s/^\s+\@/\@/ unless $in_example;
+          s/^\s+\@group/\@group/;
+          s/^\s+\@end\s+group/\@end group/;
+          s|\@c $fcn $re_srcdir|\@c $fcn scripts/|o;
+          $in_example = (/\s*\@example\b/ .. /\s*\@end\s+example\b/);
+          print;
+        }' "$prefix" "$arg"
     fi
   done
 else
   echo "gethelp program seems to be missing!" 1>&2
   exit 1
 fi
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,13 @@
+2011-01-26  John W. Eaton  <jwe@octave.org>
+
+	* lex.ll, graphics.cc, gl-render.cc, ov-mex-fcn.h, graphics.h.in:
+	Delete trailing whitespace.
+
 2011-01-26  John W. Eaton  <jwe@octave.org>
 
 	Bug #32242.
 
 	* ov.h, ov.cc (octave_value::undef_subsasgn): New function.
 	* ov-class.h, ov-class.cc (octave_class::undef_subsasgn,
 	octave_class::subsasgn_common): New functions.
 	* ov-base.h, ov-base.cc (octave_base_value::subsasgn): If
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -321,19 +321,19 @@ private:
 
   static void CALLBACK tess_error (GLenum err, void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->error (err); }
 
 private:
 
   // No copying!
 
-  opengl_tesselator (const opengl_tesselator&);  
-
-  opengl_tesselator operator = (const opengl_tesselator&);  
+  opengl_tesselator (const opengl_tesselator&);
+
+  opengl_tesselator operator = (const opengl_tesselator&);
 
   GLUtesselator *glu_tess;
   bool fill;
 };
 
 class
 vertex_data
 {
@@ -729,25 +729,25 @@ opengl_renderer::render_ticktexts(Matrix
 
       if (lim1 <= val && val <= lim2)
         {
           Matrix b;
           // FIXME: as tick text is transparent, shouldn't be
           //        drawn after axes object, for correct rendering?
           if (xyz == 0) // X
             {
-              b = render_text (ticklabels(i), val, p1, p2, ha, va); 
+              b = render_text (ticklabels(i), val, p1, p2, ha, va);
             }
           else if (xyz == 1) // Y
             {
-              b = render_text (ticklabels(i), p1, val, p2, ha, va); 
+              b = render_text (ticklabels(i), p1, val, p2, ha, va);
             }
           else if (xyz == 2) // Z
             {
-              b = render_text (ticklabels(i), p1, p2, val, ha, va); 
+              b = render_text (ticklabels(i), p1, p2, val, ha, va);
             }
 
           wmax = std::max (wmax, static_cast<int> (b(2)));
           hmax = std::max (hmax, static_cast<int> (b(3)));
         }
     }
 }
 
@@ -965,17 +965,17 @@ opengl_renderer::draw_axes (const axes::
         zpTick = zPlaneN;
         layer2Dtop = true;
       }
     else
       zpTick = zPlane;
   }
 
   Matrix view = props.get_view ().matrix_value ();
-  bool nearhoriz = std::abs(view(1)) <= 5; 
+  bool nearhoriz = std::abs(view(1)) <= 5;
 
   Matrix axe_color = props.get_color_rgb ();
   bool visible = props.is_visible ();
   bool box = props.is_box ();
 
   // Axes planes
 
   if (axe_color.numel () > 0 && visible)
@@ -1138,17 +1138,17 @@ opengl_renderer::draw_axes (const axes::
             }
         }
 
       // minor grid lines
       if (do_xminorgrid)
         render_grid (minorgridstyle, xmticks, x_min, x_max,
             yPlane, yPlaneN, layer2Dtop ? zPlaneN : zPlane, zPlaneN,
             0, (zstate != AXE_DEPTH_DIR));
-                        
+
       // minor tick marks
       if (do_xminortick)
         {
           if (tick_along_z)
             {
               render_tickmarks (xmticks, x_min, x_max, ypTick, ypTick, zpTick, zpTickN,
                                 0., 0., signum(zpTick-zpTickN)*fz*xticklen/2*tickdir,
                                 0, (box && xstate != AXE_ANY_DIR));
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -5610,17 +5610,17 @@ public:
 
   void execute (void)
     {
       gh_manager::execute_callback (handle, callback_name, callback_data);
     }
 
 private:
   callback_event (void)
-    : base_graphics_event (), handle (), 
+    : base_graphics_event (), handle (),
       callback_name (), callback_data ()
   { }
 
 private:
   graphics_handle handle;
   std::string callback_name;
   octave_value callback_data;
 };
@@ -5634,17 +5634,17 @@ public:
         function_data (data) { }
 
   void execute (void)
     {
       function (function_data);
     }
 
 private:
-  
+
   graphics_event::event_fcn function;
 
   void* function_data;
 
   // function_event objects must be created with at least a function.
   function_event (void);
 
   // No copying!
@@ -5667,19 +5667,17 @@ public:
     {
       gh_manager::autolock guard;
 
       xset (handle, property_name, property_value);
     }
 
 private:
   set_event (void)
-    : base_graphics_event (), 
-      // FIXME: it it private in order not to be used ? 
-      handle (), property_name (), property_value ()
+    : base_graphics_event (), handle (), property_name (), property_value ()
   { }
 
 private:
   graphics_handle handle;
   std::string property_name;
   octave_value property_value;
 };
 
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -321,27 +321,27 @@ class property;
 enum listener_mode { POSTSET };
 
 class base_property
 {
 public:
   friend class property;
 
 public:
-  base_property (void) 
-    : id (-1), count (1), name (), parent (), hidden (), listeners () 
+  base_property (void)
+    : id (-1), count (1), name (), parent (), hidden (), listeners ()
     { }
 
   base_property (const std::string& s, const graphics_handle& h)
-    : id (-1), count (1), name (s), parent (h), hidden (false), listeners () 
+    : id (-1), count (1), name (s), parent (h), hidden (false), listeners ()
     { }
 
   base_property (const base_property& p)
-    : id (-1), count (1), name (p.name), parent (p.parent), 
-      hidden (p.hidden), listeners () 
+    : id (-1), count (1), name (p.name), parent (p.parent),
+      hidden (p.hidden), listeners ()
     { }
 
   virtual ~base_property (void) { }
 
   bool ok (void) const { return parent.ok (); }
 
   std::string get_name (void) const { return name; }
 
@@ -1098,18 +1098,17 @@ public:
       xmin (), xmax (), xminp (), type_constraints (), size_constraints ()
     {
       get_data_limits ();
     }
 
   array_property (const std::string& nm, const graphics_handle& h,
                   const octave_value& m)
     : base_property (nm, h), data (m),
-    xmin (), xmax (), xminp (), type_constraints (), size_constraints ()
-    
+      xmin (), xmax (), xminp (), type_constraints (), size_constraints ()
     {
       get_data_limits ();
     }
 
   // This copy constructor is only intended to be used
   // internally to access min/max values; no need to
   // copy constraints.
   array_property (const array_property& p)
@@ -2973,17 +2972,17 @@ private:
 };
 
 // ---------------------------------------------------------------------
 
 class OCTINTERP_API graphics_xform
 {
 public:
   graphics_xform (void)
-    : xform (xform_eye ()), xform_inv (xform_eye ()), 
+    : xform (xform_eye ()), xform_inv (xform_eye ()),
       sx ("linear"), sy ("linear"), sz ("linear"),  zlim (1, 2, 0.0)
     {
       zlim(1) = 1.0;
     }
 
   graphics_xform (const Matrix& xm, const Matrix& xim,
                   const scaler& x, const scaler& y, const scaler& z,
                   const Matrix& zl)
diff --git a/src/lex.ll b/src/lex.ll
--- a/src/lex.ll
+++ b/src/lex.ll
@@ -1881,17 +1881,17 @@ public:
   int ungetc (int c) { ::xunput (c, buf); return 0; }
 
 private:
 
   // No copying!
 
   flex_stream_reader (const flex_stream_reader&);
 
-  flex_stream_reader& operator = (const flex_stream_reader&);	
+  flex_stream_reader& operator = (const flex_stream_reader&);
 
   char *buf;
 };
 
 static int
 process_comment (bool start_in_block, bool& eof)
 {
   eof = false;
diff --git a/src/ov-mex-fcn.h b/src/ov-mex-fcn.h
--- a/src/ov-mex-fcn.h
+++ b/src/ov-mex-fcn.h
@@ -39,17 +39,17 @@ class octave_value_list;
 // Dynamically-linked functions.
 
 class
 octave_mex_function : public octave_function
 {
 public:
 
   octave_mex_function (void)
-    : mex_fcn_ptr (), exit_fcn_ptr (), have_fmex (), sh_lib (), 
+    : mex_fcn_ptr (), exit_fcn_ptr (), have_fmex (), sh_lib (),
       t_checked (), system_fcn_file () { }
 
   octave_mex_function (void *fptr, bool fmex, const octave_shlib& shl,
                        const std::string& nm = std::string ());
 
   ~octave_mex_function (void);
 
   octave_value subsref (const std::string& type,
