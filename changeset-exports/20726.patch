# HG changeset patch
# User Rik <rik@octave.org>
# Date 1447971465 28800
#      Thu Nov 19 14:17:45 2015 -0800
# Node ID 25d676f9619c3afe9994ab15c3f7aa7fe60997f5
# Parent  7164a69472dd3e9c9a8b20c5a85a2874ae0c34a5
Preface error() messages with name of function when possible.

* FIRfilter.m, subsasgn.m, get.m, polynomial.m, polynomial_superiorto.m,
set.m, subsasgn.m, subsref.m, Cell.cc, data.cc, graphics.in.h, toplev.cc,
urlwrite.cc, audiodevinfo.cc, symbfact.cc, CollocWt.cc, inputParser.m,
narginchk.m, nargoutchk.m, uicontrol.m, rgb2ind.m, textread.m, open.m,
__w2mpth__.m, fminbnd.m, pkg.m, pan.m, printd.m, rotate3d.m, zoom.m, eigs.m,
validatestring.m, __run_test_suite__.m, runtests.m, test.m:
Preface error() messages with name of function when possible.

diff --git a/examples/code/@FIRfilter/FIRfilter.m b/examples/code/@FIRfilter/FIRfilter.m
--- a/examples/code/@FIRfilter/FIRfilter.m
+++ b/examples/code/@FIRfilter/FIRfilter.m
@@ -6,15 +6,15 @@
 
 function f = FIRfilter (p)
 
   f.polynomial = [];
   if (nargin == 0)
     p = @polynomial ([1]);
   elseif (nargin == 1)
     if (!isa (p, "polynomial"))
-      error ("FIRfilter: expecting polynomial as input argument");
+      error ("@FIRfilter: expecting polynomial as input argument");
     endif
   else
     print_usage ();
   endif
   f = class (f, "FIRfilter", p);
 endfunction
diff --git a/examples/code/@FIRfilter/subsasgn.m b/examples/code/@FIRfilter/subsasgn.m
--- a/examples/code/@FIRfilter/subsasgn.m
+++ b/examples/code/@FIRfilter/subsasgn.m
@@ -1,14 +1,14 @@
 function out = subsasgn (f, index, val)
   switch (index.type)
     case "."
       fld = index.subs;
       if (strcmp (fld, "polynomial"))
         out = f;
         out.polynomial = val;
       else
-        error ("@FIRfilter/subsref: invalid property \"%s\"", fld);
+        error ("@FIRfilter/subsasgn: invalid property \"%s\"", fld);
       endif
     otherwise
-      error ("FIRfilter/subsagn: Invalid index type")
+      error ("@FIRfilter/subsasgn: Invalid index type")
   endswitch
 endfunction
diff --git a/examples/code/@polynomial/get.m b/examples/code/@polynomial/get.m
--- a/examples/code/@polynomial/get.m
+++ b/examples/code/@polynomial/get.m
@@ -2,17 +2,17 @@ function s = get (p, f)
   if (nargin == 1)
     s.poly = p.poly;
   elseif (nargin == 2)
     if (ischar (f))
       switch (f)
         case "poly"
           s = p.poly;
         otherwise
-          error ("get: invalid property %s", f);
+          error ("@polynomial/get: invalid property %s", f);
       endswitch
     else
-      error ("get: expecting the property to be a string");
+      error ("@polynomial/get: expecting the property to be a string");
     endif
   else
     print_usage ();
   endif
 endfunction
diff --git a/examples/code/@polynomial/polynomial.m b/examples/code/@polynomial/polynomial.m
--- a/examples/code/@polynomial/polynomial.m
+++ b/examples/code/@polynomial/polynomial.m
@@ -17,14 +17,14 @@ function p = polynomial (a)
     p = class (p, "polynomial");
   elseif (nargin == 1)
     if (strcmp (class (a), "polynomial"))
       p = a;
     elseif (isvector (a) && isreal (a))
       p.poly = a(:).';
       p = class (p, "polynomial");
     else
-      error ("polynomial: expecting real vector");
+      error ("@polynomial: expecting real vector");
     endif
   else
     print_usage ();
   endif
 endfunction
diff --git a/examples/code/@polynomial/polynomial_superiorto.m b/examples/code/@polynomial/polynomial_superiorto.m
--- a/examples/code/@polynomial/polynomial_superiorto.m
+++ b/examples/code/@polynomial/polynomial_superiorto.m
@@ -17,15 +17,15 @@ function p = polynomial (a)
     p = class (p, "polynomial");
   elseif (nargin == 1)
     if (strcmp (class (a), "polynomial"))
       p = a;
     elseif (isvector (a) && isreal (a))
       p.poly = a(:).';
       p = class (p, "polynomial");
     else
-      error ("polynomial: expecting real vector");
+      error ("@polynomial: expecting real vector");
     endif
   else
     print_usage ();
   endif
   superiorto ("double");
 endfunction
diff --git a/examples/code/@polynomial/set.m b/examples/code/@polynomial/set.m
--- a/examples/code/@polynomial/set.m
+++ b/examples/code/@polynomial/set.m
@@ -1,20 +1,20 @@
 function s = set (p, varargin)
   s = p;
   if (length (varargin) < 2 || rem (length (varargin), 2) != 0)
-    error ("set: expecting property/value pairs");
+    error ("@polynomial/set: expecting property/value pairs");
   endif
   while (length (varargin) > 1)
     prop = varargin{1};
     val = varargin{2};
     varargin(1:2) = [];
     if (ischar (prop) && strcmp (prop, "poly"))
       if (isvector (val) && isreal (val))
         s.poly = val(:).';
       else
-        error ("set: expecting the value to be a real vector");
+        error ("@polynomial/set: expecting the value to be a real vector");
       endif
     else
-      error ("set: invalid property of polynomial class");
+      error ("@polynomial/set: invalid property of polynomial class");
     endif
   endwhile
 endfunction
diff --git a/examples/code/@polynomial/subsasgn.m b/examples/code/@polynomial/subsasgn.m
--- a/examples/code/@polynomial/subsasgn.m
+++ b/examples/code/@polynomial/subsasgn.m
@@ -1,35 +1,35 @@
 function p = subsasgn (p, s, val)
   if (length (s) < 1)
-    error ("polynomial: needs index");
+    error ("@polynomial/subsasgn: needs index");
   endif
   switch (s(1).type)
     case "{}"
       ind = s(1).subs;
       if (numel (ind) != 1)
-        error ("polynomial: need exactly one index");
+        error ("@polynomial/subsasgn: need exactly one index");
       else
         if (length (s) == 1)
           if (isnumeric (ind{1}))
             p.poly(ind{1}+1) = val;
           else
             p.poly(ind{1}) = val;
           endif
         else
-          error ("polynomial: chained subscripts not allowed for {}");
+          error ("@polynomial/subsasgn: chained subscripts not allowed for {}");
         endif
       endif
     case "."
       fld = s(1).subs;
       if (strcmp (fld, "poly"))
         if (length (s) == 1)
           p.poly = val;
         else
           p.poly = subsasgn (p.poly, s(2:end), val);
         endif
       else
-        error ("@polynomial/subsref: invalid property \"%s\"", fld);
+        error ("@polynomial/subsasgn: invalid property \"%s\"", fld);
       endif
     otherwise
-      error ("invalid subscript type");
+      error ("@polynomial/subsasgn: invalid subscript type");
   endswitch
 endfunction
diff --git a/examples/code/@polynomial/subsref.m b/examples/code/@polynomial/subsref.m
--- a/examples/code/@polynomial/subsref.m
+++ b/examples/code/@polynomial/subsref.m
@@ -1,37 +1,37 @@
 function b = subsref (a, s)
   if (isempty (s))
-    error ("polynomial: missing index");
+    error ("@polynomial/subsref: missing index");
   endif
   switch (s(1).type)
     case "()"
       ind = s(1).subs;
       if (numel (ind) != 1)
-        error ("polynomial: need exactly one index");
+        error ("@polynomial/subsref: need exactly one index");
       else
         b = polyval (fliplr (a.poly), ind{1});
       endif
     case "{}"
       ind = s(1).subs;
       if (numel (ind) != 1)
-        error ("polynomial: need exactly one index");
+        error ("@polynomial/subsref: need exactly one index");
       else
         if (isnumeric (ind{1}))
           b = a.poly(ind{1}+1);
         else
           b = a.poly(ind{1});
         endif
       endif
     case "."
       fld = s.subs;
       if (strcmp (fld, "poly"))
         b = a.poly;
       else
         error ("@polynomial/subsref: invalid property \"%s\"", fld);
       endif
     otherwise
-      error ("invalid subscript type");
+      error ("@polynomial/subsref: invalid subscript type");
   endswitch
   if (numel (s) > 1)
     b = subsref (b, s(2:end));
   endif
 endfunction
diff --git a/libinterp/corefcn/Cell.cc b/libinterp/corefcn/Cell.cc
--- a/libinterp/corefcn/Cell.cc
+++ b/libinterp/corefcn/Cell.cc
@@ -300,17 +300,17 @@ Cell::column (octave_idx_type i) const
 
           retval.resize (dim_vector (nr, 1));
 
           for (octave_idx_type j = 0; j < nr; j++)
             retval.xelem (j) = elem (j, i);
         }
     }
   else
-    error ("Cell::column: requires 2-d cell array");
+    error ("Cell::column: requires 2-D cell array");
 
   return retval;
 }
 
 Cell
 Cell::concat (const Cell& rb, const Array<octave_idx_type>& ra_idx)
 {
   return insert (rb, ra_idx);
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1846,18 +1846,17 @@ do_class_concat (const octave_value_list
   // Get dominant type for list
 
   std::string dtype = get_dispatch_type (ovl);
 
   octave_value fcn = symbol_table::find_method (cattype, dtype);
 
   if (fcn.is_defined ())
     {
-      // Have method for dominant type, so call it and let it handle
-      // conversions.
+      // Have method for dominant type.  Call it and let it handle conversions.
 
       octave_value_list tmp2 = fcn.do_multi_index_op (1, ovl);
 
       if (tmp2.length () > 0)
         retval = tmp2(0);
       else
         {
           error ("%s/%s method did not return a value",
@@ -5272,18 +5271,18 @@ if fewer than two values are requested.\
 %!error linspace ()
 %!error linspace (1, 2, 3, 4)
 %!error <N must be a scalar> linspace (1, 2, [3, 4])
 %!error <must be scalars or vectors> linspace (ones (2,2), 2, 3)
 %!error <must be scalars or vectors> linspace (2, ones (2,2), 3)
 %!error <must be scalars or vectors> linspace (1, [], 3)
 */
 
-// FIXME: should accept dimensions as separate args for N-d
-// arrays as well as 1-d and 2-d arrays.
+// FIXME: should accept dimensions as separate args for N-D
+// arrays as well as 1-D and 2-D arrays.
 
 DEFUN (resize, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} resize (@var{x}, @var{m})\n\
 @deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n}, @dots{})\n\
 @deftypefnx {Built-in Function} {} resize (@var{x}, [@var{m} @var{n} @dots{}])\n\
 Resize @var{x} cutting off elements as necessary.\n\
 \n\
@@ -7712,26 +7711,26 @@ an empty matrix is returned.\n\
 
   int dim = -1;
   octave_idx_type order = 1;
   if (nargin > 1)
     {
       if (args(1).is_scalar_type ())
         order = args(1).idx_type_value (true, false);
       else if (! args(1).is_zero_by_zero ())
-        error ("order K must be a scalar or []");
+        error ("diff: order K must be a scalar or []");
       if (order < 0)
-        error ("order K must be non-negative");
+        error ("diff: order K must be non-negative");
     }
 
   if (nargin > 2)
     {
       dim = args(2).int_value (true, false);
       if (dim < 1 || dim > args(0).ndims ())
-        error ("DIM must be a valid dimension");
+        error ("diff: DIM must be a valid dimension");
       else
         dim -= 1;
     }
 
   retval = do_diff (args(0), order, dim);
 
   return retval;
 }
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1131,17 +1131,17 @@ public:
   bool is_radio (void) const { return (current_type == radio_t); }
 
   bool is (const std::string& v) const
   { return (is_radio () && current_val == v); }
 
   Matrix rgb (void) const
   {
     if (current_type != color_t)
-      error ("color has no rgb value");
+      error ("color has no RGB value");
 
     return color_val.rgb ();
   }
 
   const std::string& current_value (void) const
   {
     if (current_type != radio_t)
       error ("color has no radio value");
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -960,17 +960,17 @@ run_command_and_return_output (const std
         cmd_status = octave_wait::exitstatus (cmd_status);
       else
         cmd_status = 127;
 
       retval(1) = output_buf.str ();
       retval(0) = cmd_status;
     }
   else
-    error ("unable to start subprocess for '%s'", cmd_str.c_str ());
+    error ("system: unable to start subprocess for '%s'", cmd_str.c_str ());
 
   return retval;
 }
 
 enum system_exec_type { et_sync, et_async };
 
 DEFUN (system, args, nargout,
        "-*- texinfo -*-\n\
@@ -1108,17 +1108,17 @@ command shell that is started to run the
             error ("system: CreateProcess failed -- can't create child process");
           else
             {
               retval(0) = pi.dwProcessId;
               CloseHandle (pi.hProcess);
               CloseHandle (pi.hThread);
             }
 #else
-          error ("asynchronous system calls are not supported");
+          error ("system: asynchronous system calls are not supported");
 #endif
         }
       else if (return_output)
         retval = run_command_and_return_output (cmd_str);
       else
         {
           int status = system (cmd_str.c_str ());
 
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -187,17 +187,17 @@ private:
   {
     curl_handle h = get_handle ();
 
     url_transfer obj (host, user, passwd, os);
 
     if (obj.is_valid ())
       handle_map[h] = obj;
     else
-      error ("support for url transfers was disabled when Octave was built");
+      error ("support for URL transfers was disabled when Octave was built");
 
     return h;
   }
 
   Matrix do_handle_list (void)
   {
     Matrix retval (1, handle_map.size ());
 
@@ -416,17 +416,17 @@ urlwrite (\"http://www.google.com/search
               retval(0) = std::string ();
             }
         }
 
       if (nargout < 2 && ! curl.good ())
         error ("urlwrite: %s", curl.lasterror ().c_str ());
     }
   else
-    error ("support for url transfers was disabled when Octave was built");
+    error ("support for URL transfers was disabled when Octave was built");
 
   return retval;
 }
 
 DEFUN (urlread, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{s} =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{success}] =} urlread (@var{url})\n\
@@ -521,17 +521,17 @@ s = urlread (\"http://www.google.com/sea
           retval(1) = curl.good ();
           retval(0) = buf.str ();
         }
 
       if (nargout < 2 && ! curl.good ())
         error ("urlread: %s", curl.lasterror().c_str());
     }
   else
-    error ("support for url transfers was disabled when Octave was built");
+    error ("support for URL transfers was disabled when Octave was built");
 
   return retval;
 }
 
 DEFUN (__ftp__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{handle} =} __ftp__ (@var{host})\n\
 @deftypefnx {Loadable Function} {@var{handle} =} __ftp__ (@var{host}, @var{username}, @var{password})\n\
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -376,17 +376,17 @@ recording using those parameters.\n\
           error ("audiodevinfo: no such bits per sample format");
           return retval;
         }
 
       const PaDeviceInfo *device_info = Pa_GetDeviceInfo (id);
 
       if (! device_info)
         {
-          error ("invalid audio device ID = %d", id);
+          error ("audiodevinfo: invalid audio device ID = %d", id);
           return retval;
         }
 
       stream_parameters.suggestedLatency
         = device_info->defaultLowInputLatency;
 
       stream_parameters.hostApiSpecificStreamInfo = 0;
       if (io == 0)
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -216,26 +216,26 @@ factorization as determined by @var{typ}
     {
       Aup = F ;
       Alo = A ;
     }
 
   CHOLMOD_NAME(etree) (Aup, Parent, cm);
 
   if (cm->status < CHOLMOD_OK)
-    error ("matrix corrupted");
+    error ("symbfact: matrix corrupted");
 
   if (CHOLMOD_NAME(postorder) (Parent, n, 0, Post, cm) != n)
-    error ("postorder failed");
+    error ("symbfact: postorder failed");
 
   CHOLMOD_NAME(rowcolcounts) (Alo, 0, 0, Parent, Post, 0,
                               ColCount, First, Level, cm);
 
   if (cm->status < CHOLMOD_OK)
-    error ("matrix corrupted");
+    error ("symbfact: matrix corrupted");
 
   if (nargout > 4)
     {
       cholmod_sparse *A1, *A2;
 
       if (A->stype == 1)
         {
           A1 = A;
diff --git a/liboctave/numeric/CollocWt.cc b/liboctave/numeric/CollocWt.cc
--- a/liboctave/numeric/CollocWt.cc
+++ b/liboctave/numeric/CollocWt.cc
@@ -370,64 +370,64 @@ dfopr (octave_idx_type n, octave_idx_typ
     }
 }
 
 // Error handling.
 
 void
 CollocWt::error (const char* msg)
 {
-  (*current_liboctave_error_handler) ("fatal CollocWt error: %s", msg);
+  (*current_liboctave_error_handler) ("CollocWt: fatal error '%s'", msg);
 }
 
 CollocWt&
 CollocWt::set_left (double val)
 {
   if (val >= rb)
     {
-      error ("left bound greater than right bound");
+      error ("CollocWt: left bound greater than right bound");
       return *this;
     }
 
   lb = val;
   initialized = 0;
   return *this;
 }
 
 CollocWt&
 CollocWt::set_right (double val)
 {
   if (val <= lb)
     {
-      error ("right bound less than left bound");
+      error ("CollocWt: right bound less than left bound");
       return *this;
     }
 
   rb = val;
   initialized = 0;
   return *this;
 }
 
 void
 CollocWt::init (void)
 {
   // Check for possible errors.
 
   double wid = rb - lb;
   if (wid <= 0.0)
     {
-      error ("width less than or equal to zero");
+      error ("CollocWt: width less than or equal to zero");
       return;
     }
 
   octave_idx_type nt = n + inc_left + inc_right;
 
   if (nt < 0)
     {
-      error ("total number of collocation points less than zero");
+      error ("CollocWt: total number of collocation points less than zero");
       return;
     }
   else if (nt == 0)
     return;
 
   Array<double> dif1 (dim_vector (nt, 1));
   double *pdif1 = dif1.fortran_vec ();
 
diff --git a/scripts/general/inputParser.m b/scripts/general/inputParser.m
--- a/scripts/general/inputParser.m
+++ b/scripts/general/inputParser.m
@@ -323,17 +323,17 @@ classdef inputParser < handle
       this.Switch.(name).def = false;
     endfunction
 
     function parse (this, varargin)
       if (numel (varargin) < numel (this.Required))
         if (this.FunctionName)
           print_usage (this.FunctionName);
         else
-          this.error ("not enough input arguments");
+          this.error ("inputParser.parse: not enough input arguments");
         endif
       endif
       pnargin = numel (varargin);
 
       this.ParamValueNames = fieldnames (this.ParamValue);
       this.SwitchNames     = fieldnames (this.Switch);
 
       ## Evaluate the Required arguments first
diff --git a/scripts/general/narginchk.m b/scripts/general/narginchk.m
--- a/scripts/general/narginchk.m
+++ b/scripts/general/narginchk.m
@@ -34,29 +34,29 @@
 
 ## Author: CarnÃ« Draug <carandraug+dev@gmail.com>
 
 function narginchk (minargs, maxargs)
 
   if (nargin != 2)
     print_usage;
   elseif (! isnumeric (minargs) || ! isscalar (minargs))
-    error ("minargs must be a numeric scalar");
+    error ("narginchk: minargs must be a numeric scalar");
   elseif (! isnumeric (maxargs) || ! isscalar (maxargs))
-    error ("maxargs must be a numeric scalar");
+    error ("narginchk: maxargs must be a numeric scalar");
   elseif (minargs > maxargs)
-    error ("minargs cannot be larger than maxargs");
+    error ("narginchk: minargs cannot be larger than maxargs");
   endif
 
   args = evalin ("caller", "nargin;");
 
   if (args < minargs)
-    error ("not enough input arguments");
+    error ("narginchk: not enough input arguments");
   elseif (args > maxargs)
-    error ("too many input arguments");
+    error ("narginchk: too many input arguments");
   endif
 
 endfunction
 
 
 %!function f (nargs, varargin)
 %! narginchk (nargs(1), nargs(2));
 %!endfunction
diff --git a/scripts/general/nargoutchk.m b/scripts/general/nargoutchk.m
--- a/scripts/general/nargoutchk.m
+++ b/scripts/general/nargoutchk.m
@@ -79,29 +79,29 @@ function msg = nargoutchk (minargs, maxa
     elseif (isempty (msg.message))
       ## Compatibility: Matlab returns a 0x1 empty struct when nargoutchk passes
       msg = resize (msg, 0, 1);
     endif
 
   elseif (nargout == 0 && nargin == 2)
 
     if (! isnumeric (minargs) || ! isscalar (minargs))
-      error ("minargs must be a numeric scalar");
+      error ("nargoutchk: minargs must be a numeric scalar");
     elseif (! isnumeric (maxargs) || ! isscalar (maxargs))
-      error ("maxargs must be a numeric scalar");
+      error ("nargoutchk: maxargs must be a numeric scalar");
     elseif (minargs > maxargs)
-      error ("minargs cannot be larger than maxargs");
+      error ("nargoutchk: minargs cannot be larger than maxargs");
     endif
 
     args = evalin ("caller", "nargout;");
 
     if (args < minargs)
-      error ("Not enough output arguments.");
+      error ("nargoutchk: Not enough output arguments.");
     elseif (args > maxargs)
-      error ("Too many output arguments.");
+      error ("nargoutchk: Too many output arguments.");
     endif
 
   else
     print_usage;
   endif
 
 endfunction
 
diff --git a/scripts/gui/uicontrol.m b/scripts/gui/uicontrol.m
--- a/scripts/gui/uicontrol.m
+++ b/scripts/gui/uicontrol.m
@@ -97,17 +97,17 @@
 ## @end deftypefn
 
 ## Author: goffioul
 
 function hui = uicontrol (varargin)
 
   if (nargin == 1 && ishandle (varargin{1})
       && strcmpi (get (varargin{1}, "type"), "uicontrol"))
-    error ("uicontrol focusing not implemented yet.");
+    error ("uicontrol: focusing not implemented yet");
   endif
 
   [h, args] = __uiobject_split_args__ ("uicontrol", varargin,
                                        {"figure", "uipanel", "uibuttongroup"});
   hui = __go_uicontrol__ (h, args{:});
 
 endfunction
 
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -77,17 +77,17 @@ function [x, map] = rgb2ind (R, G, B)
   switch (class (R))
     case {"single", "double", "logical"}
       ## do nothing, return the same
     case {"uint8", "uint16"}
       map = double (map) / double (intmax (class (R)));
     case "int16"
       map = (double (im) + 32768) / 65535;
     otherwise
-      error ("unsupported image class %s", im_class);
+      error ("rgb2ind: unsupported image class %s", im_class);
   endswitch
 
   ## we convert to the smallest class necessary to encode the image. Matlab
   ## documentation does not mention what it does when uint16 is not enough...
   ## When an indexed image is of integer class, there's a -1 offset to the
   ## colormap, hence the adjustment
   if (rows (map) < 256)
     x = uint8 (x - 1);
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -139,17 +139,17 @@ function varargout = textread (filename,
   endif
 
   ## Skip header lines if requested
   headerlines = find (strcmpi (varargin, "headerlines"), 1);
   if (! isempty (headerlines))
     ## Beware of missing or wrong headerline value
     if (headerlines  == numel (varargin)
        || ! isnumeric (varargin{headerlines + 1}))
-      error ("missing or illegal value for 'headerlines'" );
+      error ("textread: missing or invalid value for 'headerlines'" );
     endif
     ## Avoid conveying floats to fskipl
     varargin{headerlines + 1} = round (varargin{headerlines + 1});
     ## Beware of zero valued headerline, fskipl would skip to EOF
     if (varargin{headerlines + 1} > 0)
       fskipl (fid, varargin{headerlines + 1});
     elseif (varargin{headerlines + 1} < 0)
       warning ("textread: negative headerline value ignored");
@@ -167,20 +167,20 @@ function varargout = textread (filename,
   endif
 
   endofline = find (strcmpi (varargin, "endofline"), 1);
   if (! isempty (endofline))
     ## 'endofline' option set by user.
     if (ischar (varargin{endofline + 1}))
       eol_char = varargin{endofline + 1};
       if (! any (strcmp (eol_char, {"", "\n", "\r", "\r\n"})))
-        error ("textscan: illegal EndOfLine character value specified");
+        error ("textread: invalid EndOfLine character value specified");
       endif
     else
-      error ("character value required for EndOfLine");
+      error ("textread: character value required for EndOfLine");
     endif
   else
     ## Determine EOL from file.
     ## Search for EOL candidates in the first BUFLENGTH chars
     ## FIXME Ignore risk of 2-byte EOL (\r\n) being split at exactly BUFLENGTH
     eol_srch_len = min (length (str), BUFLENGTH);
     ## First try DOS (CRLF)
     if (! isempty (strfind (str(1 : eol_srch_len), "\r\n")))
@@ -486,12 +486,12 @@ endfunction
 %! assert (d, {"a"; "b"; "c"});
 %! unlink (f);
 
 ## Test input validation
 %!error textread ()
 %!error textread (1)
 %!error <arguments must be strings> textread (1, "%f")
 %!error <arguments must be strings> textread ("fname", 1)
-%!error <missing or illegal value for> textread (file_in_loadpath ("textread.m"), "", "headerlines")
-%!error <missing or illegal value for> textread (file_in_loadpath ("textread.m"), "", "headerlines", 'hh')
+%!error <missing or invalid value for> textread (file_in_loadpath ("textread.m"), "", "headerlines")
+%!error <missing or invalid value for> textread (file_in_loadpath ("textread.m"), "", "headerlines", 'hh')
 %!error <character value required for> textread (file_in_loadpath ("textread.m"), "%s", "endofline", true)
 
diff --git a/scripts/miscellaneous/open.m b/scripts/miscellaneous/open.m
--- a/scripts/miscellaneous/open.m
+++ b/scripts/miscellaneous/open.m
@@ -54,25 +54,27 @@ function output = open (file)
     edit (file);
   elseif (strcmpi (ext, ".mat"))
     if (nargout > 0)
       output = load (file);
     else
       evalin ("base", sprintf ("load ('%s');", file));
     endif
   elseif (any (strcmpi (ext, {".fig", ".mdl", ".slx", ".prj"})))
-    error ("opening file type '%s' is not supported", ext);
+    error ("open: opening file type '%s' is not supported", ext);
   elseif (strcmpi (ext, ".exe"))
     if (ispc ())
       dos (file);
     else
-      error ("executing .exe files is only supported on Windows systems");
+      error ("open: executing .exe files is only supported on Windows systems");
     endif
   else
     __open_with_system_app__ (file);
   endif
 
 endfunction
 
+
 ## Test input validation
-%!error open
-%!error open (1)
-%!error output = open (1)
+%!error open ()
+%!error open ("abc", "def")
+%!error <FILE must be a string> open (1)
+
diff --git a/scripts/miscellaneous/private/__w2mpth__.m b/scripts/miscellaneous/private/__w2mpth__.m
--- a/scripts/miscellaneous/private/__w2mpth__.m
+++ b/scripts/miscellaneous/private/__w2mpth__.m
@@ -42,17 +42,17 @@
 
 ## Author: Philip Nienhuis <prnienhuis@users.sf.net>
 ## Created: 2015-01-16
 
 function mingwpath = __w2mpth__ (winpath)
 
   ## Check for platform
   if (! ispc)
-    error ("__w2mpth__ should only be called on Windows platforms\n");
+    error ("__w2mpth__: function must only be called on Windows platforms\n");
   endif
 
   ## Replace backslash file separators by forward slashes
   mingwpath = strrep (winpath, '\', '/');
   ## Also treat drive letter but beware of relative filenames
   mingwpath = regexprep (mingwpath, '^([a-zA-Z]):', '/$1');
 
 endfunction
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -273,17 +273,17 @@ function print_exit_msg (info, opt=struc
       printf (" the current x satisfies the termination criteria using OPTIONS.TolX of %e\n", opt.TolX);
     case 0
       printf ("Exiting: Maximum number of iterations has been exceeded\n");
       printf ("         - increase MaxIter option.\n");
       printf ("         Current function value: %.6f\n", opt.fx);
     case -1
       "FIXME"; # FIXME: what's the message MATLAB prints for this case?
     otherwise
-      error ("internal error - fminbnd() is bug, sorry!");
+      error ("fminbnd: internal error, info return code was %d", info);
   endswitch
   printf ("\n");
 endfunction
 
 
 %!shared opt0
 %! opt0 = optimset ("tolx", 0);
 %!assert (fminbnd (@cos, pi/2, 3*pi/2, opt0), pi, 10*sqrt (eps))
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -347,26 +347,26 @@ function [local_packages, global_package
         endif
       case "-global"
         global_install = true;
         if (! user_prefix)
           [prefix, archprefix] = default_prefix (global_install);
         endif
       case available_actions
         if (! strcmp (action, "none"))
-          error ("more than one action specified");
+          error ("pkg: more than one action specified");
         endif
         action = varargin{i};
       otherwise
         files{end+1} = varargin{i};
     endswitch
   endfor
 
   if (octave_forge && ! any (strcmp (action, {"install", "list"})))
-    error ("-forge can only be used with install or list");
+    error ("pkg: '-forge' can only be used with install or list");
   endif
 
   ## Take action
   switch (action)
     case "list"
       if (octave_forge)
         if (nargout)
           local_packages = list_forge_packages ();
@@ -382,131 +382,131 @@ function [local_packages, global_package
                                                                   files);
         else
           installed_packages (local_list, global_list, files);
         endif
       endif
 
     case "install"
       if (isempty (files))
-        error ("you must specify at least one filename when calling 'pkg install'");
+        error ("pkg: install action requires at least one filename");
       endif
 
       local_files = {};
       unwind_protect
 
         if (octave_forge)
           [urls, local_files] = cellfun ("get_forge_download", files,
                                          "uniformoutput", false);
           [files, succ] = cellfun ("urlwrite", urls, local_files,
                                    "uniformoutput", false);
           succ = [succ{:}];
           if (! all (succ))
             i = find (! succ, 1);
-            error ("could not download file %s from url %s",
+            error ("pkg: could not download file %s from url %s",
                    local_files{i}, urls{i});
           endif
         endif
 
         install (files, deps, auto, prefix, archprefix, verbose, local_list,
                  global_list, global_install);
 
       unwind_protect_cleanup
         cellfun ("unlink", local_files);
       end_unwind_protect
 
     case "uninstall"
       if (isempty (files))
-        error ("you must specify at least one package when calling 'pkg uninstall'");
+        error ("pkg: uninstall action requires at least one package name");
       endif
       uninstall (files, deps, verbose, local_list, global_list, global_install);
 
     case "load"
       if (isempty (files))
-        error ("you must specify at least one package, 'all', or 'auto' when calling 'pkg load'");
+        error ("pkg: load action requires at least one package, 'all', or 'auto'");
       endif
       load_packages (files, deps, local_list, global_list);
 
     case "unload"
       if (isempty (files))
-        error ("you must specify at least one package or 'all' when calling 'pkg unload'");
+        error ("pkg: unload action requires at least one package or 'all'");
       endif
       unload_packages (files, deps, local_list, global_list);
 
     case "prefix"
       if (isempty (files) && ! nargout)
         printf ("Installation prefix:             %s\n", prefix);
         printf ("Architecture dependent prefix:   %s\n", archprefix);
       elseif (isempty (files) && nargout)
         local_packages = prefix;
         global_packages = archprefix;
       elseif (numel (files) >= 1 && ischar (files{1}))
         prefix = tilde_expand (files{1});
         if (! exist (prefix, "dir"))
           [status, msg] = mkdir (prefix);
           if (status == 0)
-            error ("cannot create prefix %s: %s", prefix, msg);
+            error ("pkg: cannot create prefix %s: %s", prefix, msg);
           endif
           warning ("creating the directory %s\n", prefix);
         endif
         local_packages = prefix = canonicalize_file_name (prefix);
         user_prefix = true;
         if (numel (files) >= 2 && ischar (files{2}))
           archprefix = tilde_expand (files{2});
           if (! exist (archprefix, "dir"))
             [status, msg] = mkdir (archprefix);
             if (status == 0)
-              error ("cannot create archprefix %s: %s", archprefix, msg);
+              error ("pkg: cannot create archprefix %s: %s", archprefix, msg);
             endif
             warning ("creating the directory %s\n", archprefix);
             global_packages = archprefix = canonicalize_file_name (archprefix);
           endif
         endif
       else
-        error ("you must specify a prefix directory, or request an output argument");
+        error ("pkg: prefix action requires a directory input, or an output argument");
       endif
 
     case "local_list"
       if (isempty (files) && ! nargout)
         disp (local_list);
       elseif (isempty (files) && nargout)
         local_packages = local_list;
       elseif (numel (files) == 1 && ! nargout && ischar (files{1}))
         local_list = files{1};
         if (! exist (local_list, "file"))
           try
             ## Force file to be created
             fclose (fopen (local_list, "wt"));
           catch
-            error ("cannot create file %s", local_list);
+            error ("pkg: cannot create file %s", local_list);
           end_try_catch
         endif
         local_list = canonicalize_file_name (local_list);
       else
-        error ("you must specify a local_list file, or request an output argument");
+        error ("pkg: specify a local_list file, or request an output argument");
       endif
 
     case "global_list"
       if (isempty (files) && ! nargout)
         disp (global_list);
       elseif (isempty (files) && nargout)
         local_packages = global_list;
       elseif (numel (files) == 1 && ! nargout && ischar (files{1}))
         global_list = files{1};
         if (! exist (global_list, "file"))
           try
             ## Force file to be created
             fclose (fopen (files{1}, "wt"));
           catch
-            error ("cannot create file %s", global_list);
+            error ("pkg: cannot create file %s", global_list);
           end_try_catch
         endif
         global_list = canonicalize_file_name (global_list);
       else
-        error ("you must specify a global_list file, or request an output argument");
+        error ("pkg: specify a global_list file, or request an output argument");
       endif
 
     case "rebuild"
       if (global_install)
         global_packages = rebuild (prefix, archprefix, global_list, files,
                                    auto, verbose);
         global_packages = save_order (global_packages);
         save (global_list, "global_packages");
@@ -520,23 +520,23 @@ function [local_packages, global_package
         save (local_list, "local_packages");
         if (! nargout)
           clear ("local_packages");
         endif
       endif
 
     case "build"
       if (numel (files) < 2)
-        error ("you must specify at least the build directory and one filename\nwhen calling 'pkg build'");
+        error ("pkg: build action requires build directory and at least one filename");
       endif
       build (files, deps, auto, verbose);
 
     case "describe"
       if (isempty (files))
-        error ("you must specify at least one package or 'all' when calling 'pkg describe'");
+        error ("pkg: describe action requires at least one package or 'all'");
       endif
       ## FIXME: name of the output variables is inconsistent with their content
       if (nargout)
         [local_packages, global_packages] = describe (files, verbose,
                                                       local_list, global_list);
       else
         describe (files, verbose, local_list, global_list);
       endif
@@ -561,13 +561,13 @@ function [local_packages, global_package
         installed_pkg_version = installed_pkgs_lst{i}.version;
         forge_pkg_version = get_forge_pkg (installed_pkg_name);
         if (compare_versions (forge_pkg_version, installed_pkg_version, ">"))
           feval (@pkg, "install", "-forge", installed_pkg_name);
         endif
       endfor
 
     otherwise
-      error ("you must specify a valid action for 'pkg'.  See 'help pkg' for details");
+      error ("pkg: invalid action.  See 'help pkg' for available actions");
   endswitch
 
 endfunction
 
diff --git a/scripts/plot/util/pan.m b/scripts/plot/util/pan.m
--- a/scripts/plot/util/pan.m
+++ b/scripts/plot/util/pan.m
@@ -45,17 +45,17 @@ function pan (varargin)
 
   nargs = nargin;
 
   if (nargs > 2)
     print_usage ();
   endif
 
   if (nargin == 1 && nargout > 0 && isfigure (varargin{1}))
-    error ("pan_object_handle = pan (hfig): not implemented");
+    error ("pan: syntax 'handle = pan (hfig)' not implemented");
   endif
 
   if (nargs == 2)
     hfig = varargin{1};
     if (isfigure (hfig))
       varargin(1) = [];
       nargs--;
     else
diff --git a/scripts/plot/util/printd.m b/scripts/plot/util/printd.m
--- a/scripts/plot/util/printd.m
+++ b/scripts/plot/util/printd.m
@@ -38,17 +38,17 @@
 
 function pr_out = printd (obj, filename)
   ## Convert any object acceptable to disp() into various display formats.
   ## obj is the input object.
   ## filename is the output file (with required suffix).
 
   ## Extract .suffix from filename
   if ((sufix = rindex (filename, ".")) <= 0)
-    error ("The output filename: %s requires a suffix.\nOptions are: pdf ps eps txt jpg jpeg", filename);
+    error ("printd: output filename '%s' requires a suffix.\nOptions are: pdf ps eps txt jpg jpeg", filename);
   endif
   opt = substr (filename, sufix+1);
   [pf, tempf, mag] = mkstemp ("oct-XXXXXX", 1);
   fprintf (pf, "%s", disp (obj));
   frewind (pf);
 
   ## It seems best to only use convert for image output.  Its ps and pdf
   ## are badly rendered.
@@ -71,17 +71,17 @@ function pr_out = printd (obj, filename)
       enscr = sprintf ("cp %s %s", tempf, filename);
       system (enscr);
     case {"jpg", "jpeg"}
       enscr = sprintf ("convert -trim txt:%s  jpg:%s", tempf, filename);
       system (enscr);
     otherwise
       fclose (pf);
       delete (tempf);
-      error ("Unknown conversion type: %s.\nOptions are: pdf ps eps txt jpg jpeg", opt);
+      error ("printd: unknown conversion type: %s.\nOptions are: pdf ps eps txt jpg jpeg", opt);
 
   endswitch
   fclose (pf);
   delete (tempf);
   pr_out = sprintf ("%s file %s written\n", opt, filename);
 endfunction
 
 
diff --git a/scripts/plot/util/rotate3d.m b/scripts/plot/util/rotate3d.m
--- a/scripts/plot/util/rotate3d.m
+++ b/scripts/plot/util/rotate3d.m
@@ -40,17 +40,17 @@ function rotate3d (varargin)
 
   nargs = nargin;
 
   if (nargs > 2)
     print_usage ();
   endif
 
   if (nargin == 1 && nargout > 0 && isfigure (varargin{1}))
-    error ("rotate_object_handle = rotate3d (hfig): not implemented");
+    error ("rotate3d: syntax 'handle = rotate3d (hfig)' not implemented");
   endif
 
   if (nargs == 2)
     hfig = varargin{1};
     if (isfigure (hfig))
       varargin(1) = [];
       nargs--;
     else
diff --git a/scripts/plot/util/zoom.m b/scripts/plot/util/zoom.m
--- a/scripts/plot/util/zoom.m
+++ b/scripts/plot/util/zoom.m
@@ -60,17 +60,17 @@
 function zoom (varargin)
 
   nargs = nargin;
   if (nargs > 2)
     print_usage ();
   endif
 
   if (nargs == 1 && nargout > 0 && isfigure (varargin{1}))
-    error ("zoom_object_handle = zoom (hfig): not implemented");
+    error ("zoom: syntax 'handle = zoom (hfig)' not implemented");
   endif
 
   hfig = NaN;
   if (nargs == 2)
     hfig = varargin{1};
     if (isfigure (hfig))
       varargin(1) = [];
       nargs--;
diff --git a/scripts/sparse/eigs.m b/scripts/sparse/eigs.m
--- a/scripts/sparse/eigs.m
+++ b/scripts/sparse/eigs.m
@@ -281,63 +281,63 @@ function out = select (args, k, sigma, r
 
       case "sm"
         [~, idx] = sort (abs (d), "ascend");
 
       case "la"
         if (real_valued && symmetric)
           [~, idx] = sort (real (d), "descend");
         else
-          error ('sigma = "la" requires real symmetric problem');
+          error ('eigs: sigma = "la" requires real symmetric problem');
         endif
 
       case "sa"
         if (real_valued && symmetric)
           [~, idx] = sort (real (d), "ascend");
         else
-          error ('sigma = "sa" requires real symmetric problem');
+          error ('eigs: sigma = "sa" requires real symmetric problem');
         endif
 
       case "be"
         if (real_valued && symmetric)
           [~, idx] = sort (real (d), "ascend");
         else
-          error ('sigma = "be" requires real symmetric problem');
+          error ('eigs: sigma = "be" requires real symmetric problem');
         endif
 
       case "lr"
         if (! (real_valued || symmetric))
           [~, idx] = sort (real (d), "descend");
         else
-          error ('sigma = "lr" requires complex or unsymmetric problem');
+          error ('eigs: sigma = "lr" requires complex or unsymmetric problem');
         endif
 
       case "sr"
         if (! (real_valued || symmetric))
           [~, idx] = sort (real (d), "ascend");
         else
-          error ('sigma = "sr" requires complex or unsymmetric problem');
+          error ('eigs: sigma = "sr" requires complex or unsymmetric problem');
         endif
 
       case "li"
         if (! (real_valued || symmetric))
           [~, idx] = sort (imag (d), "descend");
         else
-          error ('sigma = "li" requires complex or unsymmetric problem');
+          error ('eigs: sigma = "li" requires complex or unsymmetric problem');
         endif
 
       case "si"
         if (! (real_valued || symmetric))
           [~, idx] = sort (imag (d), "ascend");
         else
-          error ('sigma = "si" requires complex or unsymmetric problem');
+          error ('eigs: sigma = "si" requires complex or unsymmetric problem');
         endif
 
       otherwise
-        error ("unrecognized value for sigma: %s", sigma);
+        error ("eigs: unrecognized value for sigma: %s", sigma);
     endswitch
   else
     ## numeric sigma, find k closest values
     [~, idx] = sort (abs (d - sigma));
   endif
 
   d = d(idx);
 
diff --git a/scripts/strings/validatestring.m b/scripts/strings/validatestring.m
--- a/scripts/strings/validatestring.m
+++ b/scripts/strings/validatestring.m
@@ -109,32 +109,32 @@ function str = validatestring (str, stra
   endif
   if (position > 0)
     errstr = sprintf ("%s(argument #%i) ", errstr, position);
   endif
 
   matches = strncmpi (str, strarray(:), length (str));
   nmatches = sum (matches);
   if (nmatches == 0)
-    error ("%sdoes not match any of\n%s", errstr,
+    error ("validatestring: %sdoes not match any of\n%s", errstr,
            sprintf ("%s, ", strarray{:})(1:end-2));
   elseif (nmatches == 1)
     str = strarray{matches};
   else
     ## Are the matches substrings of each other?
     ## If true, choose the shortest.  If not, raise an error.
     match_idx = find (matches);
     match_len = cellfun ("length", strarray(match_idx));
     [min_len, min_idx] = min (match_len);
     short_str = strarray{match_idx(min_idx)};
     submatch = strncmpi (short_str, strarray(match_idx), min_len);
     if (all (submatch))
       str = short_str;
     else
-      error ("%sallows multiple unique matches:\n%s",
+      error ("validatestring: %sallows multiple unique matches:\n%s",
              errstr, sprintf ("%s, ", strarray{match_idx})(1:end-2));
     endif
   endif
 
 endfunction
 
 
 %!shared strarray
diff --git a/scripts/testfun/__run_test_suite__.m b/scripts/testfun/__run_test_suite__.m
--- a/scripts/testfun/__run_test_suite__.m
+++ b/scripts/testfun/__run_test_suite__.m
@@ -45,17 +45,17 @@ function [pass, fail, xfail, skip] = __r
   logfile = make_absolute_filename ("fntests.log");
   unwind_protect
     page_screen_output (false);
     warning ("on", "quiet");
     warning ("off", "Octave:deprecated-function");
     try
       fid = fopen (logfile, "wt");
       if (fid < 0)
-        error ("could not open %s for writing", logfile);
+        error ("__run_test_suite__: could not open %s for writing", logfile);
       endif
       test ("", "explain", fid);
       dp = dn = dxf = dsk = 0;
       puts ("\nIntegrated test scripts:\n\n");
       for i = 1:length (fcndirs)
         [p, n, xf, sk] = run_test_script (fid, fcndirs{i});
         dp += p;
         dn += n;
@@ -155,17 +155,17 @@ function retval = has_functions (f)
   if (n > 3 && strcmpi (f((end-2):end), ".cc"))
     fid = fopen (f);
     if (fid >= 0)
       str = fread (fid, "*char")';
       fclose (fid);
       retval = ! isempty (regexp (str,'^(DEFUN|DEFUN_DLD)\>',
                                       'lineanchors', 'once'));
     else
-      error ("fopen failed: %s", f);
+      error ("__run_test_suite__: fopen failed: %s", f);
     endif
   elseif (n > 2 && strcmpi (f((end-1):end), ".m"))
     retval = true;
   else
     retval = false;
   endif
 endfunction
 
@@ -173,17 +173,17 @@ function retval = has_tests (f)
   fid = fopen (f);
   if (fid >= 0)
     str = fread (fid, "*char")';
     fclose (fid);
     retval = ! isempty (regexp (str,
                                 '^%!(assert|error|fail|test|xtest|warning)',
                                 'lineanchors', 'once'));
   else
-    error ("fopen failed: %s", f);
+    error ("__run_test_suite__: fopen failed: %s", f);
   endif
 endfunction
 
 function [dp, dn, dxf, dsk] = run_test_dir (fid, d);
   global files_with_tests;
   global files_with_no_tests;
   lst = dir (d);
   dp = dn = dxf = dsk = 0;
diff --git a/scripts/testfun/runtests.m b/scripts/testfun/runtests.m
--- a/scripts/testfun/runtests.m
+++ b/scripts/testfun/runtests.m
@@ -106,17 +106,17 @@ function retval = has_functions (f)
   if (n > 3 && strcmpi (f((end-2):end), ".cc"))
     fid = fopen (f);
     if (fid >= 0)
       str = fread (fid, "*char")';
       fclose (fid);
       retval = ! isempty (regexp (str,'^(?:DEFUN|DEFUN_DLD|DEFUNX)\>',
                                       'lineanchors', 'once'));
     else
-      error ("fopen failed: %s", f);
+      error ("runtests: fopen failed: %s", f);
     endif
   elseif (n > 2 && strcmpi (f((end-1):end), ".m"))
     retval = true;
   else
     retval = false;
   endif
 endfunction
 
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -590,17 +590,17 @@ function [__n, __nmax, __nxfail, __nskip
             __msg = [__signal_fail "known failure\n" lasterr()];
             __xfail++;
             __success = false;
           else
             __msg = [__signal_fail "test failed\n" lasterr()];
             __success = false;
           endif
           if (isempty (lasterr ()))
-            error ("empty error text, probably Ctrl-C --- aborting");
+            error ("test: empty error text, probably Ctrl-C --- aborting");
           endif
         end_try_catch
         clear __test__;
       endif
 
       ## All done.  Remember if we were successful and print any messages.
       if (! isempty (__msg) && (__verbose >= 0 || __logfile))
         ## Make sure the user knows what caused the error.
