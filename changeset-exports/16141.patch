# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1361994681 18000
#      Wed Feb 27 14:51:21 2013 -0500
# Node ID c6b2409672e9271eb12e4b2c9f92f229416682db
# Parent  797ac81586d1da502243583eb4f78c6a08a00367
# Parent  2fd39ab122091adb1e824cb5f7ad2ff5632a5b39
Merge in Julien's changes

diff --git a/build-aux/common.mk b/build-aux/common.mk
--- a/build-aux/common.mk
+++ b/build-aux/common.mk
@@ -1,19 +1,22 @@
 CROSS_TOOL_PREFIX = @CROSS_TOOL_PREFIX@
 
 AWK = @AWK@
 export AWK
 
-SED = @SED@
-export SED
+GREP = @GREP@
+export GREP
 
 FIND = @FIND@
 export FIND
 
+SED = @SED@
+export SED
+
 PERL = @PERL@
 export PERL
 
 PYTHON = @PYTHON@
 
 GNUPLOT = @GNUPLOT@
 
 DESKTOP_FILE_INSTALL = @DESKTOP_FILE_INSTALL@
@@ -273,19 +276,19 @@ SPARSE_XCPPFLAGS = \
 
 SPARSE_XLDFLAGS = \
   $(CHOLMOD_LDFLAGS) $(UMFPACK_LDFLAGS) \
   $(AMD_LDFLAGS) $(CAMD_LDFLAGS) $(COLAMD_LDFLAGS) \
   $(CCOLAMD_LDFLAGS) $(CXSPARSE_LDFLAGS)
 
 ## Order matters, at least on some systems (Cygwin, for example).
 SPARSE_XLIBS = \
-    $(CHOLMOD_LIBS) $(UMFPACK_LIBS) \
-    $(AMD_LIBS) $(CAMD_LIBS) $(COLAMD_LIBS) \
-    $(CCOLAMD_LIBS) $(CXSPARSE_LIBS)
+  $(CHOLMOD_LIBS) $(UMFPACK_LIBS) \
+  $(AMD_LIBS) $(CAMD_LIBS) $(COLAMD_LIBS) \
+  $(CCOLAMD_LIBS) $(CXSPARSE_LIBS)
 
 TERM_LIBS = @TERM_LIBS@
 
 UMFPACK_CPPFLAGS = @UMFPACK_CPPFLAGS@
 UMFPACK_LDFLAGS = @UMFPACK_LDFLAGS@
 UMFPACK_LIBS = @UMFPACK_LIBS@
 
 X11_INCFLAGS = @X11_INCFLAGS@
@@ -691,52 +694,23 @@ echo "making $@ from $<"
 endef
 
 define do_subst_script_vals
 echo "making $@ from $<"
 $(SED) < $< \
   -e "s|%AWK%|${AWK}|g" \
   -e "s|%FIND%|${FIND}|g" \
   -e "s|%SED%|${SED}|g" \
-  -e "s|%library_path_var%|${library_path_var}|g" \
-  -e "s|%liboctinterp%|${SHLPRE}octinterp.${SHLEXT}|g" \
-  -e "s|%liboctave%|${SHLPRE}octave.${SHLEXT}|g" \
-  -e "s|%ldpreloadsep%|${ldpreloadsep}|g" \
-  -e "s|%srcdir%|${srcdir}|" \
-  -e "s|%top_srcdir%|${top_srcdir}|" \
   -e "s|%abs_top_srcdir%|${abs_top_srcdir}|" \
   -e "s|%builddir%|$(shell pwd)|" > $@-t
 $(simple_move_if_change_rule)
 endef
 
-define do_script_install
-$(top_srcdir)/build-aux/mkinstalldirs $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)
-for f in $(FCN_FILES); do \
-  fbase=`basename $$f`; \
-  rm -f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/$$fbase; \
-  $(INSTALL_DATA) $$f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/$$fbase; \
-done
-$(top_srcdir)/mkpkgadd $(DESTDIR)$(fcnfiledir)/$(script_sub_dir) > $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD.t
-if [ -n "`cat $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD.t`" ]; then \
-  $(INSTALL_DATA) $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD.t $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD ; \
-else \
-  rm -f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD.t ; \
-fi
-endef
-
-define do_script_uninstall
-for f in $(FCN_FILES_NO_DIR); \
-  do rm -f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/$$f; \
-done
-rm -f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD
--rmdir $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)
-endef
-
 define test-file-commands
-( echo "## DO NOT EDIT!  Generated automatically from $(<F) by Make."; grep '^%!' $< ) > $@-t
+( echo "## DO NOT EDIT!  Generated automatically from $(<F) by Make."; $(GREP) '^%!' $< ) > $@-t
 mv $@-t $@
 endef
 
 %.cc-tst : %.cc
 	$(test-file-commands)
 
 %.yy-tst : %.yy
 	$(test-file-commands)
diff --git a/build-aux/find-files-with-tests.sh b/build-aux/find-files-with-tests.sh
--- a/build-aux/find-files-with-tests.sh
+++ b/build-aux/find-files-with-tests.sh
@@ -1,19 +1,20 @@
 #! /bin/sh
 
 set -e
+GREP=${GREP:-grep}
 SED=${SED:-sed}
 
 srcdir="$1"
 shift
 
 for arg
 do
   if [ -f "$arg" ]; then
     file="$arg"
   else
     file="$srcdir/$arg"
   fi
-  if [ "`grep -l '^%!' $file`" ]; then
+  if [ "`$GREP -l '^%!' $file`" ]; then
     echo "$file" | $SED "s,\\$srcdir/,,";
   fi
 done
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -92,16 +92,17 @@ OCTAVE_SET_DEFAULT([infofile], '$(infodi
 ### Check for programs used in building, installing, and running Octave.
 
 ## Programs used in configuring Octave.
 ## Find pkg-config executable (sets $PKG_CONFIG)
 PKG_PROG_PKG_CONFIG
 
 ## Programs used in Makefiles.
 AC_PROG_AWK
+AC_PROG_GREP
 OCTAVE_PROG_FIND
 OCTAVE_PROG_SED
 OCTAVE_PROG_PERL
 
 ## Programs used to build parts of Octave.
 OCTAVE_PROG_GPERF
 
 OCTAVE_PROG_FLEX
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -493,17 +493,17 @@ Plotting
 
 High-Level Plotting
 
 * Two-Dimensional Plots::       
 * Three-Dimensional Plots::  
 * Plot Annotations::            
 * Multiple Plots on One Page::  
 * Multiple Plot Windows::       
-* Use of @code{axis}@comma{} @code{line}@comma{} and @code{patch} Functions
+* Use of axis@comma{} line@comma{} and patch Functions::
 * Manipulation of Plot Windows::
 * Use of the @code{interpreter} Property::
 * Printing and Saving Plots::              
 * Interacting with Plots::      
 * Test Plotting Functions::     
 
 Two-Dimensional Plots
 
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -57,17 +57,17 @@ If you need more detailed control, see @
 and @ref{Advanced Plotting}.
 
 @menu
 * Two-Dimensional Plots::       
 * Three-Dimensional Plots::  
 * Plot Annotations::            
 * Multiple Plots on One Page::  
 * Multiple Plot Windows::       
-* Use of @code{axis}@comma{} @code{line}@comma{} and @code{patch} Functions::
+* Use of axis@comma{} line@comma{} and patch Functions::
 * Manipulation of Plot Windows::
 * Use of the @code{interpreter} Property::
 * Printing and Saving Plots::              
 * Interacting with Plots::      
 * Test Plotting Functions::     
 @end menu
 
 @node Two-Dimensional Plots
@@ -516,18 +516,18 @@ fplot (@@cos, [-10, 10]);
 @end example
 
 @noindent
 creates two figures, with the first displaying a sine wave and
 the second a cosine wave.  Figure numbers must be positive integers.
 
 @DOCSTRING(figure)
 
-@node Use of @code{axis}@comma{} @code{line}@comma{} and @code{patch} Functions
-@subsection Use of @code{axis}@comma{} @code{line}@comma{} and @code{patch} Functions
+@node Use of axis@comma{} line@comma{} and patch Functions
+@subsection Use of axis@comma{} line@comma{} and patch Functions
 
 You can create axes, line, and patch objects directly using the
 @code{axes}, @code{line}, and @code{patch} functions.  These objects
 become children of the current axes object.
 
 @DOCSTRING(axes)
 @DOCSTRING(line)
 @DOCSTRING(patch)
diff --git a/libinterp/interp-core/pt-jit.cc b/libinterp/interp-core/pt-jit.cc
--- a/libinterp/interp-core/pt-jit.cc
+++ b/libinterp/interp-core/pt-jit.cc
@@ -31,22 +31,22 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "ov.h"
 #include "pt-all.h"
 #include "pt-jit.h"
 #include "sighandlers.h"
 #include "symtab.h"
 #include "variables.h"
 
+#ifdef HAVE_LLVM
+
 static bool Venable_jit_debugging = false;
 
 static bool Venable_jit_compiler = true;
 
-#ifdef HAVE_LLVM
-
 #include <llvm/Analysis/CallGraph.h>
 #include <llvm/Analysis/Passes.h>
 #include <llvm/Analysis/Verifier.h>
 #include <llvm/Bitcode/ReaderWriter.h>
 #include <llvm/LLVMContext.h>
 #include <llvm/ExecutionEngine/ExecutionEngine.h>
 #include <llvm/ExecutionEngine/JIT.h>
 #include <llvm/Module.h>
diff --git a/libinterp/interpfcn/input.cc b/libinterp/interpfcn/input.cc
--- a/libinterp/interpfcn/input.cc
+++ b/libinterp/interpfcn/input.cc
@@ -675,34 +675,41 @@ get_debug_input (const std::string& prom
       frame.add_fcn (switch_to_buffer, old_buf);
       frame.add_fcn (delete_buffer, new_buf);
 
       switch_to_buffer (new_buf);
     }
 
   frame.protect_var (curr_lexer);
   curr_lexer = new lexical_feedback ();
+  frame.add_fcn (lexical_feedback::cleanup, curr_lexer);
+
+  frame.protect_var (curr_parser);
+  curr_parser = new octave_parser ();
+  frame.add_fcn (octave_parser::cleanup, curr_parser);
 
   while (Vdebugging)
     {
+      unwind_protect middle_frame;
+
       reset_error_handler ();
 
-      reset_parser ();
+      curr_parser->reset ();
 
       // Save current value of global_command.
-      frame.protect_var (global_command);
+      middle_frame.protect_var (global_command);
 
       global_command = 0;
 
       // Do this with an unwind-protect cleanup function so that the
       // forced variables will be unmarked in the event of an interrupt.
       symbol_table::scope_id scope = symbol_table::top_scope ();
-      frame.add_fcn (symbol_table::unmark_forced_variables, scope);
+      middle_frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
-      int retval = octave_parse_input ();
+      int retval = curr_parser->run ();
 
       if (retval == 0 && global_command)
         {
           unwind_protect inner_frame;
 
           // Use an unwind-protect cleanup function so that the
           // global_command list will be deleted in the event of an
           // interrupt.
@@ -710,20 +717,16 @@ get_debug_input (const std::string& prom
           inner_frame.add_fcn (cleanup_statement_list, &global_command);
 
           global_command->accept (*current_evaluator);
 
           if (octave_completion_matches_called)
             octave_completion_matches_called = false;
         }
 
-      // Unmark forced variables.
-      // Restore previous value of global_command.
-      frame.run (2);
-
       octave_quit ();
     }
 }
 
 // If the user simply hits return, this will produce an empty matrix.
 
 static octave_value_list
 get_user_input (const octave_value_list& args, int nargout)
diff --git a/libinterp/interpfcn/toplev.cc b/libinterp/interpfcn/toplev.cc
--- a/libinterp/interpfcn/toplev.cc
+++ b/libinterp/interpfcn/toplev.cc
@@ -556,44 +556,49 @@ main_loop (void)
   octave_catch_interrupts ();
 
   octave_initialized = true;
 
   unwind_protect frame;
 
   frame.protect_var (curr_lexer);
   curr_lexer = new lexical_feedback ();
+  frame.add_fcn (lexical_feedback::cleanup, curr_lexer);
+
+  frame.protect_var (curr_parser);
+  curr_parser = new octave_parser ();
+  frame.add_fcn (octave_parser::cleanup, curr_parser);
 
   // The big loop.
 
   int retval = 0;
   do
     {
       try
         {
           unwind_protect inner_frame;
 
           reset_error_handler ();
 
-          reset_parser ();
+          curr_parser->reset ();
 
           if (symbol_table::at_top_level ())
             tree_evaluator::reset_debug_state ();
 
           // Do this with an unwind-protect cleanup function so that
           // the forced variables will be unmarked in the event of an
           // interrupt.
           symbol_table::scope_id scope = symbol_table::top_scope ();
           frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
           frame.protect_var (global_command);
 
           global_command = 0;
 
-          retval = octave_parse_input ();
+          retval = curr_parser->run ();
 
           if (retval == 0)
             {
               if (global_command)
                 {
                   // Use an unwind-protect cleanup function so that the
                   // global_command list will be deleted in the event of
                   // an interrupt.
@@ -631,17 +636,17 @@ main_loop (void)
                   else
                     {
                       if (octave_completion_matches_called)
                         octave_completion_matches_called = false;
                       else
                         command_editor::increment_current_command_number ();
                     }
                 }
-              else if (curr_lexer->parser_end_of_input)
+              else if (curr_parser->end_of_input)
                 break;
             }
         }
       catch (octave_interrupt_exception)
         {
           recover_from_exception ();
           octave_stdout << "\n";
           if (quitting_gracefully)
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -46,19 +46,16 @@ extern OCTINTERP_API void delete_buffer 
 
 extern OCTINTERP_API void clear_all_buffers (void);
 
 extern OCTINTERP_API void cleanup_parser (void);
 
 // Is the given string a keyword?
 extern bool is_keyword (const std::string& s);
 
-extern void prep_lexer_for_script_file (void);
-extern void prep_lexer_for_function_file (void);
-
 class
 stream_reader
 {
 public:
   virtual int getc (void) = 0;
   virtual int ungetc (int c) = 0;
 
 protected:
@@ -180,17 +177,17 @@ public:
       at_beginning_of_statement (true),
       looking_at_anon_fcn_args (false), looking_at_return_list (false),
       looking_at_parameter_list (false), looking_at_decl_list (false),
       looking_at_initializer_expression (false),
       looking_at_matrix_or_assign_lhs (false),
       looking_for_object_index (false), 
       looking_at_indirect_ref (false), parsing_class_method (false),
       maybe_classdef_get_set_method (false), parsing_classdef (false),
-      quote_is_transpose (false), parser_end_of_input (false),
+      quote_is_transpose (false),
       input_line_number (1), current_input_column (1),
       bracketflag (0), braceflag (0),
       looping (0), defining_func (0), looking_at_function_handle (0),
       block_comment_nesting_level (0),
       looking_at_object_index (), parsed_function_name (),
       pending_local_variables (), nesting_level ()
   {
     init ();
@@ -200,22 +197,36 @@ public:
 
   void init (void)
   {
     // The closest paren, brace, or bracket nesting is not an object
     // index.
     looking_at_object_index.push_front (false);
   }
 
+  void reset (void);
+
+  void prep_for_script_file (void);
+
+  void prep_for_function_file (void);
+
+  int octave_read (char *buf, unsigned int max_size);
+
+  char *flex_yytext (void);
+
+  int flex_yyleng (void);
+
   void do_comma_insert_check (void);
 
   int text_yyinput (void);
 
   void xunput (char c, char *buf);
 
+  void xunput (char c);
+
   void fixup_column_count (char *s);
 
   bool inside_any_object_index (void);
 
   int is_keyword_token (const std::string& s);
 
   bool is_variable (const std::string& name);
 
@@ -271,16 +282,26 @@ public:
   void gripe_matlab_incompatible (const std::string& msg);
 
   void maybe_gripe_matlab_incompatible_comment (char c);
 
   void gripe_matlab_incompatible_continuation (void);
 
   void gripe_matlab_incompatible_operator (const std::string& op);
 
+  void push_token (token *);
+
+  token *current_token (void);
+
+  void display_token (int tok);
+
+  void fatal_error (const char *msg);
+
+  void lexer_debug (const char *pattern, const char *text);
+
   // TRUE means that we should convert spaces to a comma inside a
   // matrix definition.
   bool convert_spaces_to_comma;
 
   // GAG.  Stupid kludge so that [[1,2][3,4]] will work.
   bool do_comma_insert;
 
   // TRUE means we are at the beginning of a statement, where a
@@ -324,19 +345,16 @@ public:
   bool maybe_classdef_get_set_method;
 
   // TRUE means we are parsing a classdef file
   bool parsing_classdef;
 
   // Return transpose or start a string?
   bool quote_is_transpose;
 
-  // TRUE means that we have encountered EOF on the input stream.
-  bool parser_end_of_input;
-
   // The current input line number.
   int input_line_number;
 
   // The column of the current token.
   int current_input_column;
 
   // Square bracket level count.
   int bracketflag;
@@ -367,23 +385,26 @@ public:
 
   // Set of identifiers that might be local variable names.
   std::set<std::string> pending_local_variables;
 
   // Is the closest nesting level a square bracket, squiggly brace or
   // a paren?
   bbp_nesting_level nesting_level;
 
+  // For unwind protect.
+  static void cleanup (lexical_feedback *lexer) { delete lexer; }
+
+private:
+
   // Stack to hold tokens so that we can delete them when the parser is
   // reset and avoid growing forever just because we are stashing some
   // information.
   std::stack <token*> token_stack;
 
-private:
-
   // No copying!
 
   lexical_feedback (const lexical_feedback&);
 
   lexical_feedback& operator = (const lexical_feedback&);
 };
 
 // The current state of the lexer.
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -98,44 +98,38 @@ along with Octave; see the file COPYING.
 #define yylval octave_lval
 
 // Arrange to get input via readline.
 
 #ifdef YY_INPUT
 #undef YY_INPUT
 #endif
 #define YY_INPUT(buf, result, max_size) \
-  result = octave_read (buf, max_size)
+  result = curr_lexer->octave_read (buf, max_size)
 
 // Try to avoid crashing out completely on fatal scanner errors.
 // The call to yy_fatal_error should never happen, but it avoids a
 // 'static function defined but not used' warning from gcc.
 
 #ifdef YY_FATAL_ERROR
 #undef YY_FATAL_ERROR
 #endif
 #define YY_FATAL_ERROR(msg) \
-  do \
-    { \
-      error (msg); \
-      OCTAVE_QUIT; \
-      yy_fatal_error (msg); \
-    } \
-  while (0)
+  curr_lexer->fatal_error (msg)
 
 #define DISPLAY_TOK_AND_RETURN(tok) \
   do \
     { \
       int tok_val = tok; \
       if (Vdisplay_tokens) \
-        display_token (tok_val); \
+        curr_lexer->display_token (tok_val); \
       if (lexer_debug_flag) \
         { \
           std::cerr << "R: "; \
-          display_token (tok_val); \
+          curr_lexer->display_token (tok_val); \
           std::cerr << std::endl;  \
         } \
       return tok_val; \
     } \
   while (0)
 
 #define COUNT_TOK_AND_RETURN(tok) \
   do \
@@ -153,29 +147,29 @@ along with Octave; see the file COPYING.
       curr_lexer->convert_spaces_to_comma = true; \
       COUNT_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
 #define TOK_PUSH_AND_RETURN(name, tok) \
   do \
     { \
-      yylval.tok_val = new token (name, curr_lexer->input_line_number, \
-                                  curr_lexer->current_input_column); \
-      curr_lexer->token_stack.push (yylval.tok_val); \
+      curr_lexer->push_token \
+        (new token (name, curr_lexer->input_line_number, \
+         curr_lexer->current_input_column)); \
       TOK_RETURN (tok); \
     } \
   while (0)
 
 #define BIN_OP_RETURN_INTERNAL(tok, convert, bos, qit) \
   do \
     { \
-      yylval.tok_val = new token (curr_lexer->input_line_number, \
-                                  curr_lexer->current_input_column); \
-      curr_lexer->token_stack.push (yylval.tok_val); \
+      curr_lexer->push_token \
+        (new token (curr_lexer->input_line_number, \
+         curr_lexer->current_input_column)); \
       curr_lexer->current_input_column += yyleng; \
       curr_lexer->quote_is_transpose = qit; \
       curr_lexer->convert_spaces_to_comma = convert; \
       curr_lexer->looking_for_object_index = false; \
       curr_lexer->at_beginning_of_statement = bos; \
       COUNT_TOK_AND_RETURN (tok); \
     } \
   while (0)
@@ -202,17 +196,17 @@ along with Octave; see the file COPYING.
       BIN_OP_RETURN (tok, convert, bos); \
     } \
   while (0)
 
 #define LEXER_DEBUG(pattern) \
   do \
     { \
       if (lexer_debug_flag) \
-        lexer_debug (pattern, yytext); \
+        curr_lexer->lexer_debug (pattern, yytext); \
     } \
   while (0)
 
 // The state of the lexer.
 lexical_feedback *curr_lexer = 0;
 
 static bool Vdisplay_tokens = false;
 
@@ -220,19 +214,16 @@ static unsigned int Vtoken_count = 0;
 
 // Internal variable for lexer debugging state.
 static bool lexer_debug_flag = false;
 
 // Forward declarations for functions defined at the bottom of this
 // file that are needed inside the lexer actions.
 
 static std::string strip_trailing_whitespace (char *s);
-static int octave_read (char *buf, unsigned int max_size);
-static void display_token (int tok);
-static void lexer_debug (const char *pattern, const char *text);
 
 %}
 
 D       [0-9]
 S       [ \t]
 NL      ((\n)|(\r)|(\r\n))
 SNL     ({S}|{NL})
 EL      (\.\.\.)
@@ -254,25 +245,25 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // Make script and function files start with a bogus token. This makes
 // the parser go down a special path.
 %}
 
 <SCRIPT_FILE_BEGIN>. {
     LEXER_DEBUG ("<SCRIPT_FILE_BEGIN>.");
 
     BEGIN (INITIAL);
-    curr_lexer->xunput (yytext[0], yytext);
+    curr_lexer->xunput (yytext[0]);
     COUNT_TOK_AND_RETURN (SCRIPT_FILE);
   }
 
 <FUNCTION_FILE_BEGIN>. {
     LEXER_DEBUG ("<FUNCTION_FILE_BEGIN>.");
 
     BEGIN (INITIAL);
-    curr_lexer->xunput (yytext[0], yytext);
+    curr_lexer->xunput (yytext[0]);
     COUNT_TOK_AND_RETURN (FUNCTION_FILE);
   }
 
 %{
 // Help and other command-style functions.
 %}
 
 <COMMAND_START>{NL} {
@@ -352,17 +343,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     curr_lexer->at_beginning_of_statement = false;
 
     int c = yytext[yyleng-1];
     bool cont_is_spc = (curr_lexer->eat_continuation () != lexical_feedback::NO_WHITESPACE);
     bool spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
     int tok_to_return = curr_lexer->handle_close_bracket (spc_gobbled, ']');
 
     if (spc_gobbled)
-      curr_lexer->xunput (' ', yytext);
+      curr_lexer->xunput (' ');
 
     COUNT_TOK_AND_RETURN (tok_to_return);
   }
 
 %{
 // FIXME -- we need to handle block comments here.
 %}
 
@@ -378,17 +369,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     curr_lexer->at_beginning_of_statement = false;
 
     int c = yytext[yyleng-1];
     bool cont_is_spc = (curr_lexer->eat_continuation () != lexical_feedback::NO_WHITESPACE);
     bool spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
     int tok_to_return = curr_lexer->handle_close_bracket (spc_gobbled, '}');
 
     if (spc_gobbled)
-      curr_lexer->xunput (' ', yytext);
+      curr_lexer->xunput (' ');
 
     COUNT_TOK_AND_RETURN (tok_to_return);
   }
 
 %{
 // Commas are element separators in matrix constants.  If we don't
 // check for continuations here we can end up inserting too many
 // commas.
@@ -407,17 +398,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     curr_lexer->at_beginning_of_statement = false;
 
     if (! curr_lexer->looking_at_object_index.front ())
       {
         if ((tmp & lexical_feedback::NEWLINE) == lexical_feedback::NEWLINE)
           {
             curr_lexer->maybe_warn_separator_insert (';');
 
-            curr_lexer->xunput (';', yytext);
+            curr_lexer->xunput (';');
           }
       }
 
     COUNT_TOK_AND_RETURN (',');
   }
 
 %{
 // In some cases, spaces in matrix constants can turn into commas.
@@ -444,17 +435,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
         if (! (postfix_un_op || bin_op || sep_op)
             && curr_lexer->nesting_level.is_bracket_or_brace ()
             && curr_lexer->convert_spaces_to_comma)
           {
             if ((tmp & lexical_feedback::NEWLINE) == lexical_feedback::NEWLINE)
               {
                 curr_lexer->maybe_warn_separator_insert (';');
 
-                curr_lexer->xunput (';', yytext);
+                curr_lexer->xunput (';');
               }
 
             curr_lexer->quote_is_transpose = false;
             curr_lexer->convert_spaces_to_comma = true;
             curr_lexer->looking_for_object_index = false;
 
             curr_lexer->maybe_warn_separator_insert (',');
 
@@ -764,17 +755,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // Gobble comments.
 %}
 
 {CCHAR} {
     LEXER_DEBUG ("{CCHAR}");
 
     curr_lexer->looking_for_object_index = false;
 
-    curr_lexer->xunput (yytext[0], yytext);
+    curr_lexer->xunput (yytext[0]);
 
     bool eof = false;
     int tok = curr_lexer->process_comment (false, eof);
 
     if (eof)
       TOK_RETURN (END_OF_INPUT);
     else if (tok > 0)
       COUNT_TOK_AND_RETURN (tok);
@@ -954,17 +945,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
 %{
 // Unrecognized input is a lexical error.
 %}
 
 . {
     LEXER_DEBUG (".");
 
-    curr_lexer->xunput (yytext[0], yytext);
+    curr_lexer->xunput (yytext[0]);
 
     int c = curr_lexer->text_yyinput ();
 
     if (c != EOF)
       {
         curr_lexer->current_input_column++;
 
         error ("invalid character '%s' (ASCII %d) near line %d, column %d",
@@ -974,48 +965,16 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
         return LEXICAL_ERROR;
       }
     else
       TOK_RETURN (END_OF_INPUT);
   }
 
 %%
 
-// Fix things up for errors or interrupts.  The parser is never called
-// recursively, so it is always safe to reinitialize its state before
-// doing any parsing.
-
-void
-reset_parser (void)
-{
-  // Start off on the right foot.
-  BEGIN (INITIAL);
-
-  parser_symtab_context.clear ();
-
-  // We do want a prompt by default.
-  promptflag = 1;
-
-  // Only ask for input from stdin if we are expecting interactive
-  // input.
-
-  if (! quitting_gracefully
-      && (interactive || forced_interactive)
-      && ! (reading_fcn_file
-            || reading_classdef_file
-            || reading_script_file
-            || get_input_from_eval_string
-            || input_from_startup_file))
-    yyrestart (stdin);
-
-  // Clear the buffer for help text.
-  while (! help_buf.empty ())
-    help_buf.pop ();
-}
-
 static void
 display_character (char c)
 {
   if (isgraph (c))
     std::cerr << c;
   else
     switch (c)
       {
@@ -1207,18 +1166,16 @@ clear_all_buffers (void)
 {                 
   while (current_buffer ())
     octave_pop_buffer_state ();
 }
 
 void
 cleanup_parser (void)
 {
-  reset_parser ();
-
   clear_all_buffers ();
 }
 
 // Restore a buffer (for unwind-prot).
 
 void
 restore_input_buffer (void *buf)
 {
@@ -1228,36 +1185,16 @@ restore_input_buffer (void *buf)
 // Delete a buffer (for unwind-prot).
 
 void
 delete_input_buffer (void *buf)
 {
   delete_buffer (static_cast<YY_BUFFER_STATE> (buf));
 }
 
-class
-flex_stream_reader : public stream_reader
-{
-public:
-  flex_stream_reader (char *buf_arg) : stream_reader (), buf (buf_arg) { }
-
-  int getc (void) { return curr_lexer->text_yyinput (); }
-  int ungetc (int c) { curr_lexer->xunput (c, buf); return 0; }
-
-private:
-
-  // No copying!
-
-  flex_stream_reader (const flex_stream_reader&);
-
-  flex_stream_reader& operator = (const flex_stream_reader&);
-
-  char *buf;
-};
-
 // Return 1 if the given character matches any character in the given
 // string.
 
 static bool
 match_any (char c, const char *s)
 {
   char tmp;
   while ((tmp = *s++) != '\0')
@@ -1349,45 +1286,142 @@ is omitted, return a list of keywords.\n
 /*
 
 %!assert (iskeyword ("for"))
 %!assert (iskeyword ("fort"), false)
 %!assert (iskeyword ("fft"), false)
 
 */
 
-void
-prep_lexer_for_script_file (void)
-{
-  BEGIN (SCRIPT_FILE_BEGIN);
-}
-
-void
-prep_lexer_for_function_file (void)
-{
-  BEGIN (FUNCTION_FILE_BEGIN);
-}
-
 // Used to delete trailing white space from tokens.
 
 static std::string
 strip_trailing_whitespace (char *s)
 {
   std::string retval = s;
 
   size_t pos = retval.find_first_of (" \t");
 
   if (pos != std::string::npos)
     retval.resize (pos);
 
   return retval;
 }
 
-static int
-octave_read (char *buf, unsigned max_size)
+DEFUN (__display_tokens__, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __display_tokens__ ()\n\
+Query or set the internal variable that determines whether Octave's\n\
+lexer displays tokens as they are read.\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (display_tokens);
+}
+
+DEFUN (__token_count__, , ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __token_count__ ()\n\
+Number of language tokens processed since Octave startup.\n\
+@end deftypefn")
+{
+  return octave_value (Vtoken_count);
+}
+
+DEFUN (__lexer_debug_flag__, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{old_val} =} __lexer_debug_flag__ (@var{new_val}))\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  retval = set_internal_variable (lexer_debug_flag, args, nargout,
+                                  "__lexer_debug_flag__");
+
+  return retval;
+}
+
+class
+flex_stream_reader : public stream_reader
+{
+public:
+  flex_stream_reader (lexical_feedback *l, char *buf_arg)
+    : stream_reader (), lexer (l), buf (buf_arg)
+  { }
+
+  int getc (void) { return lexer->text_yyinput (); }
+  int ungetc (int c) { lexer->xunput (c, buf); return 0; }
+
+private:
+
+  // No copying!
+
+  flex_stream_reader (const flex_stream_reader&);
+
+  flex_stream_reader& operator = (const flex_stream_reader&);
+
+  lexical_feedback *lexer;
+
+  char *buf;
+};
+
+lexical_feedback::~lexical_feedback (void)
+{
+  // Clear out the stack of token info used to track line and
+  // column numbers.
+
+  while (! token_stack.empty ())
+    {
+      delete token_stack.top ();
+      token_stack.pop ();
+    }
+}
+
+void
+lexical_feedback::reset (void)
+{
+  // Start off on the right foot.
+  BEGIN (INITIAL);
+
+  parser_symtab_context.clear ();
+
+  // We do want a prompt by default.
+  promptflag = 1;
+
+  // Only ask for input from stdin if we are expecting interactive
+  // input.
+
+  if (! quitting_gracefully
+      && (interactive || forced_interactive)
+      && ! (reading_fcn_file
+            || reading_classdef_file
+            || reading_script_file
+            || get_input_from_eval_string
+            || input_from_startup_file))
+    yyrestart (stdin);
+
+  // Clear the buffer for help text.
+  while (! help_buf.empty ())
+    help_buf.pop ();
+}
+
+void
+lexical_feedback::prep_for_script_file (void)
+{
+  BEGIN (SCRIPT_FILE_BEGIN);
+}
+
+void
+lexical_feedback::prep_for_function_file (void)
+{
+  BEGIN (FUNCTION_FILE_BEGIN);
+}
+
+int
+lexical_feedback::octave_read (char *buf, unsigned max_size)
 {
   static const char * const eol = "\n";
   static std::string input_buf;
   static const char *pos = 0;
   static size_t chars_left = 0;
   static bool eof = false;
 
   int status = 0;
@@ -1440,247 +1474,44 @@ octave_read (char *buf, unsigned max_siz
 
       if (! eof)
         YY_FATAL_ERROR ("octave_read () in flex scanner failed");
     }
 
   return status;
 }
 
-static void
-display_token (int tok)
+char *
+lexical_feedback::flex_yytext (void)
 {
-  switch (tok)
-    {
-    case '=': std::cerr << "'='\n"; break;
-    case ':': std::cerr << "':'\n"; break;
-    case '-': std::cerr << "'-'\n"; break;
-    case '+': std::cerr << "'+'\n"; break;
-    case '*': std::cerr << "'*'\n"; break;
-    case '/': std::cerr << "'/'\n"; break;
-    case ADD_EQ: std::cerr << "ADD_EQ\n"; break;
-    case SUB_EQ: std::cerr << "SUB_EQ\n"; break;
-    case MUL_EQ: std::cerr << "MUL_EQ\n"; break;
-    case DIV_EQ: std::cerr << "DIV_EQ\n"; break;
-    case LEFTDIV_EQ: std::cerr << "LEFTDIV_EQ\n"; break;
-    case POW_EQ: std::cerr << "POW_EQ\n"; break;
-    case EMUL_EQ: std::cerr << "EMUL_EQ\n"; break;
-    case EDIV_EQ: std::cerr << "EDIV_EQ\n"; break;
-    case ELEFTDIV_EQ: std::cerr << "ELEFTDIV_EQ\n"; break;
-    case EPOW_EQ: std::cerr << "EPOW_EQ\n"; break;
-    case AND_EQ: std::cerr << "AND_EQ\n"; break;
-    case OR_EQ: std::cerr << "OR_EQ\n"; break;
-    case LSHIFT_EQ: std::cerr << "LSHIFT_EQ\n"; break;
-    case RSHIFT_EQ: std::cerr << "RSHIFT_EQ\n"; break;
-    case LSHIFT: std::cerr << "LSHIFT\n"; break;
-    case RSHIFT: std::cerr << "RSHIFT\n"; break;
-    case EXPR_AND_AND: std::cerr << "EXPR_AND_AND\n"; break;
-    case EXPR_OR_OR: std::cerr << "EXPR_OR_OR\n"; break;
-    case EXPR_AND: std::cerr << "EXPR_AND\n"; break;
-    case EXPR_OR: std::cerr << "EXPR_OR\n"; break;
-    case EXPR_NOT: std::cerr << "EXPR_NOT\n"; break;
-    case EXPR_LT: std::cerr << "EXPR_LT\n"; break;
-    case EXPR_LE: std::cerr << "EXPR_LE\n"; break;
-    case EXPR_EQ: std::cerr << "EXPR_EQ\n"; break;
-    case EXPR_NE: std::cerr << "EXPR_NE\n"; break;
-    case EXPR_GE: std::cerr << "EXPR_GE\n"; break;
-    case EXPR_GT: std::cerr << "EXPR_GT\n"; break;
-    case LEFTDIV: std::cerr << "LEFTDIV\n"; break;
-    case EMUL: std::cerr << "EMUL\n"; break;
-    case EDIV: std::cerr << "EDIV\n"; break;
-    case ELEFTDIV: std::cerr << "ELEFTDIV\n"; break;
-    case EPLUS: std::cerr << "EPLUS\n"; break;
-    case EMINUS: std::cerr << "EMINUS\n"; break;
-    case QUOTE: std::cerr << "QUOTE\n"; break;
-    case TRANSPOSE: std::cerr << "TRANSPOSE\n"; break;
-    case PLUS_PLUS: std::cerr << "PLUS_PLUS\n"; break;
-    case MINUS_MINUS: std::cerr << "MINUS_MINUS\n"; break;
-    case POW: std::cerr << "POW\n"; break;
-    case EPOW: std::cerr << "EPOW\n"; break;
-
-    case NUM:
-    case IMAG_NUM:
-      std::cerr << (tok == NUM ? "NUM" : "IMAG_NUM")
-                << " [" << yylval.tok_val->number () << "]\n";
-      break;
-
-    case STRUCT_ELT:
-      std::cerr << "STRUCT_ELT [" << yylval.tok_val->text () << "]\n"; break;
-
-    case NAME:
-      {
-        symbol_table::symbol_record *sr = yylval.tok_val->sym_rec ();
-        std::cerr << "NAME";
-        if (sr)
-          std::cerr << " [" << sr->name () << "]";
-        std::cerr << "\n";
-      }
-      break;
-
-    case END: std::cerr << "END\n"; break;
-
-    case DQ_STRING:
-    case SQ_STRING:
-      std::cerr << (tok == DQ_STRING ? "DQ_STRING" : "SQ_STRING")
-                << " [" << yylval.tok_val->text () << "]\n";
-      break;
-
-    case FOR: std::cerr << "FOR\n"; break;
-    case WHILE: std::cerr << "WHILE\n"; break;
-    case DO: std::cerr << "DO\n"; break;
-    case UNTIL: std::cerr << "UNTIL\n"; break;
-    case IF: std::cerr << "IF\n"; break;
-    case ELSEIF: std::cerr << "ELSEIF\n"; break;
-    case ELSE: std::cerr << "ELSE\n"; break;
-    case SWITCH: std::cerr << "SWITCH\n"; break;
-    case CASE: std::cerr << "CASE\n"; break;
-    case OTHERWISE: std::cerr << "OTHERWISE\n"; break;
-    case BREAK: std::cerr << "BREAK\n"; break;
-    case CONTINUE: std::cerr << "CONTINUE\n"; break;
-    case FUNC_RET: std::cerr << "FUNC_RET\n"; break;
-    case UNWIND: std::cerr << "UNWIND\n"; break;
-    case CLEANUP: std::cerr << "CLEANUP\n"; break;
-    case TRY: std::cerr << "TRY\n"; break;
-    case CATCH: std::cerr << "CATCH\n"; break;
-    case GLOBAL: std::cerr << "GLOBAL\n"; break;
-    case PERSISTENT: std::cerr << "PERSISTENT\n"; break;
-    case FCN_HANDLE: std::cerr << "FCN_HANDLE\n"; break;
-    case END_OF_INPUT: std::cerr << "END_OF_INPUT\n\n"; break;
-    case LEXICAL_ERROR: std::cerr << "LEXICAL_ERROR\n\n"; break;
-    case FCN: std::cerr << "FCN\n"; break;
-    case CLOSE_BRACE: std::cerr << "CLOSE_BRACE\n"; break;
-    case SCRIPT_FILE: std::cerr << "SCRIPT_FILE\n"; break;
-    case FUNCTION_FILE: std::cerr << "FUNCTION_FILE\n"; break;
-    case SUPERCLASSREF: std::cerr << "SUPERCLASSREF\n"; break;
-    case METAQUERY: std::cerr << "METAQUERY\n"; break;
-    case GET: std::cerr << "GET\n"; break;
-    case SET: std::cerr << "SET\n"; break;
-    case PROPERTIES: std::cerr << "PROPERTIES\n"; break;
-    case METHODS: std::cerr << "METHODS\n"; break;
-    case EVENTS: std::cerr << "EVENTS\n"; break;
-    case CLASSDEF: std::cerr << "CLASSDEF\n"; break;
-    case '\n': std::cerr << "\\n\n"; break;
-    case '\r': std::cerr << "\\r\n"; break;
-    case '\t': std::cerr << "TAB\n"; break;
-    default:
-      {
-        if (tok < 256)
-          std::cerr << static_cast<char> (tok) << "\n";
-        else
-          std::cerr << "UNKNOWN(" << tok << ")\n";
-      }
-      break;
-    }
+  return yytext;
 }
 
-static void
-display_state (void)
-{
-  std::cerr << "S: ";
-
-  switch (YY_START)
-    {
-    case INITIAL:
-      std::cerr << "INITIAL" << std::endl;
-      break;
-
-    case COMMAND_START:
-      std::cerr << "COMMAND_START" << std::endl;
-      break;
-
-    case MATRIX_START:
-      std::cerr << "MATRIX_START" << std::endl;
-      break;
-
-    case SCRIPT_FILE_BEGIN:
-      std::cerr << "SCRIPT_FILE_BEGIN" << std::endl;
-      break;
-
-    case FUNCTION_FILE_BEGIN:
-      std::cerr << "FUNCTION_FILE_BEGIN" << std::endl;
-      break;
-
-    default:
-      std::cerr << "UNKNOWN START STATE!" << std::endl;
-      break;
-    }
-}
-
-static void
-lexer_debug (const char *pattern, const char *text)
+int
+lexical_feedback::flex_yyleng (void)
 {
-  std::cerr << std::endl;
-
-  display_state ();
-
-  std::cerr << "P: " << pattern << std::endl;
-  std::cerr << "T: " << text << std::endl;
-}
-
-DEFUN (__display_tokens__, args, nargout,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __display_tokens__ ()\n\
-Query or set the internal variable that determines whether Octave's\n\
-lexer displays tokens as they are read.\n\
-@end deftypefn")
-{
-  return SET_INTERNAL_VARIABLE (display_tokens);
-}
-
-DEFUN (__token_count__, , ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __token_count__ ()\n\
-Number of language tokens processed since Octave startup.\n\
-@end deftypefn")
-{
-  return octave_value (Vtoken_count);
-}
-
-DEFUN (__lexer_debug_flag__, args, nargout,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{old_val} =} __lexer_debug_flag__ (@var{new_val}))\n\
-Undocumented internal function.\n\
-@end deftypefn")
-{
-  octave_value retval;
-
-  retval = set_internal_variable (lexer_debug_flag, args, nargout,
-                                  "__lexer_debug_flag__");
-
-  return retval;
-}
-
-lexical_feedback::~lexical_feedback (void)
-{
-  // Clear out the stack of token info used to track line and
-  // column numbers.
-
-  while (! token_stack.empty ())
-    {
-      delete token_stack.top ();
-      token_stack.pop ();
-    }
+  return yyleng;
 }
 
 // GAG.
 //
 // If we're reading a matrix and the next character is '[', make sure
 // that we insert a comma ahead of it.
 
 void
 lexical_feedback::do_comma_insert_check (void)
 {
   bool spc_gobbled = (eat_continuation () != lexical_feedback::NO_WHITESPACE);
 
   int c = text_yyinput ();
 
-  xunput (c, yytext);
+  xunput (c);
 
   if (spc_gobbled)
-    xunput (' ', yytext);
+    xunput (' ');
 
   do_comma_insert = (! looking_at_object_index.front ()
                      && bracketflag && c == '[');
 }
 
 int
 lexical_feedback::text_yyinput (void)
 {
@@ -1703,17 +1534,17 @@ lexical_feedback::text_yyinput (void)
         {
           std::cerr << "I: ";
           display_character (c);
           std::cerr << std::endl;
         }
 
       if (c != '\n')
         {
-          xunput (c, yytext);
+          xunput (c);
           c = '\n';
         }
     }
 
   if (c == '\n')
     input_line_number++;
 
   return c;
@@ -1730,16 +1561,23 @@ lexical_feedback::xunput (char c, char *
     }
 
   if (c == '\n')
     input_line_number--;
 
   yyunput (c, buf);
 }
 
+void
+lexical_feedback::xunput (char c)
+{
+  char *yytxt = flex_yytext ();
+  xunput (c, yytxt);
+}
+
 // If we read some newlines, we need figure out what column we're
 // really looking at.
 
 void
 lexical_feedback::fixup_column_count (char *s)
 {
   char c;
   while ((c = *s++) != '\0')
@@ -1781,17 +1619,17 @@ lexical_feedback::is_keyword_token (cons
   int c = current_input_column;
 
   int len = s.length ();
 
   const octave_kw *kw = octave_kw_hash::in_word_set (s.c_str (), len);
 
   if (kw)
     {
-      yylval.tok_val = 0;
+      token *tok_val = 0;
 
       switch (kw->kw_id)
         {
         case break_kw:
         case catch_kw:
         case continue_kw:
         case else_kw:
         case otherwise_kw:
@@ -1826,82 +1664,82 @@ lexical_feedback::is_keyword_token (cons
         case end_kw:
           if (inside_any_object_index ()
               || (! reading_classdef_file
                   && (defining_func
                       && ! (looking_at_return_list
                             || parsed_function_name.top ()))))
             return 0;
 
-          yylval.tok_val = new token (token::simple_end, l, c);
+          tok_val = new token (token::simple_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case end_try_catch_kw:
-          yylval.tok_val = new token (token::try_catch_end, l, c);
+          tok_val = new token (token::try_catch_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case end_unwind_protect_kw:
-          yylval.tok_val = new token (token::unwind_protect_end, l, c);
+          tok_val = new token (token::unwind_protect_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case endfor_kw:
-          yylval.tok_val = new token (token::for_end, l, c);
+          tok_val = new token (token::for_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case endfunction_kw:
-          yylval.tok_val = new token (token::function_end, l, c);
+          tok_val = new token (token::function_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case endif_kw:
-          yylval.tok_val = new token (token::if_end, l, c);
+          tok_val = new token (token::if_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case endparfor_kw:
-          yylval.tok_val = new token (token::parfor_end, l, c);
+          tok_val = new token (token::parfor_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case endswitch_kw:
-          yylval.tok_val = new token (token::switch_end, l, c);
+          tok_val = new token (token::switch_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case endwhile_kw:
-          yylval.tok_val = new token (token::while_end, l, c);
+          tok_val = new token (token::while_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case endclassdef_kw:
-          yylval.tok_val = new token (token::classdef_end, l, c);
+          tok_val = new token (token::classdef_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case endenumeration_kw:
-          yylval.tok_val = new token (token::enumeration_end, l, c);
+          tok_val = new token (token::enumeration_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case endevents_kw:
-          yylval.tok_val = new token (token::events_end, l, c);
+          tok_val = new token (token::events_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case endmethods_kw:
-          yylval.tok_val = new token (token::methods_end, l, c);
+          tok_val = new token (token::methods_end, l, c);
           at_beginning_of_statement = true;
           break;
 
         case endproperties_kw:
-          yylval.tok_val = new token (token::properties_end, l, c);
+          tok_val = new token (token::properties_end, l, c);
           at_beginning_of_statement = true;
           break;
 
 
         case for_kw:
         case parfor_kw:
         case while_kw:
           promptflag--;
@@ -1959,34 +1797,34 @@ lexical_feedback::is_keyword_token (cons
             input_line_number = 1;
           break;
 
         case magic_file_kw:
           {
             if ((reading_fcn_file || reading_script_file
                  || reading_classdef_file)
                 && ! curr_fcn_file_full_name.empty ())
-              yylval.tok_val = new token (curr_fcn_file_full_name, l, c);
+              tok_val = new token (curr_fcn_file_full_name, l, c);
             else
-              yylval.tok_val = new token ("stdin", l, c);
+              tok_val = new token ("stdin", l, c);
           }
           break;
 
         case magic_line_kw:
-          yylval.tok_val = new token (static_cast<double> (l), "", l, c);
+          tok_val = new token (static_cast<double> (l), "", l, c);
           break;
 
         default:
           panic_impossible ();
         }
 
-      if (! yylval.tok_val)
-        yylval.tok_val = new token (l, c);
-
-      token_stack.push (yylval.tok_val);
+      if (! tok_val)
+        tok_val = new token (l, c);
+
+      curr_lexer->push_token (tok_val);
 
       return kw->tok;
     }
 
   return 0;
 }
 
 bool
@@ -2248,17 +2086,18 @@ lexical_feedback::process_comment (bool 
 {
   eof = false;
 
   std::string help_txt;
 
   if (! help_buf.empty ())
     help_txt = help_buf.top ();
 
-  flex_stream_reader flex_reader (yytext);
+  char *yytxt = flex_yytext ();
+  flex_stream_reader flex_reader (this, yytxt);
 
   // process_comment is only supposed to be called when we are not
   // initially looking at a block comment.
 
   std::string txt = start_in_block
     ? grab_block_comment (flex_reader, eof)
     : grab_comment_block (flex_reader, false, eof);
 
@@ -2298,17 +2137,17 @@ bool
 lexical_feedback::next_token_is_sep_op (void)
 {
   bool retval = false;
 
   int c = text_yyinput ();
 
   retval = match_any (c, ",;\n]");
 
-  xunput (c, yytext);
+  xunput (c);
 
   return retval;
 }
 
 // Try to determine if the next token should be treated as a postfix
 // unary operator.  This is ugly, but it seems to do the right thing.
 
 bool
@@ -2321,32 +2160,32 @@ lexical_feedback::next_token_is_postfix_
   if (c0 == '\'' && ! spc_prev)
     {
       un_op = true;
     }
   else if (c0 == '.')
     {
       int c1 = text_yyinput ();
       un_op = (c1 == '\'');
-      xunput (c1, yytext);
+      xunput (c1);
     }
   else if (c0 == '+')
     {
       int c1 = text_yyinput ();
       un_op = (c1 == '+');
-      xunput (c1, yytext);
+      xunput (c1);
     }
   else if (c0 == '-')
     {
       int c1 = text_yyinput ();
       un_op = (c1 == '-');
-      xunput (c1, yytext);
+      xunput (c1);
     }
 
-  xunput (c0, yytext);
+  xunput (c0);
 
   return un_op;
 }
 
 // Try to determine if the next token should be treated as a binary
 // operator.
 //
 // This kluge exists because whitespace is not always ignored inside
@@ -2385,17 +2224,17 @@ lexical_feedback::next_token_is_bin_op (
             break;
 
           default:
             // Could be either, spacing matters.
             bin_op = looks_like_bin_op (spc_prev, c1);
             break;
           }
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     case ':':
     case '/':
     case '\\':
     case '^':
       // Always a binary op (may also include /=, \=, and ^=).
@@ -2409,17 +2248,17 @@ lexical_feedback::next_token_is_bin_op (
 
         if (match_any (c1, "+-/\\^*"))
           // Always a binary op (may also include .+=, .-=, ./=, ...).
           bin_op = true;
         else if (! isdigit (c1) && c1 != ' ' && c1 != '\t' && c1 != '.')
           // A structure element reference is a binary op.
           bin_op = true;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     // = == & && | || * **
     case '=':
     case '&':
     case '|':
     case '*':
@@ -2439,25 +2278,25 @@ lexical_feedback::next_token_is_bin_op (
     case '!':
       {
         int c1 = text_yyinput ();
 
         // ~ and ! can be unary ops, so require following =.
         if (c1 == '=')
           bin_op = true;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     default:
       break;
     }
 
-  xunput (c0, yytext);
+  xunput (c0);
 
   return bin_op;
 }
 
 // FIXME -- we need to handle block comments here.
 
 void
 lexical_feedback::scan_for_comments (const char *text)
@@ -2617,44 +2456,46 @@ lexical_feedback::eat_whitespace (void)
             goto done;
         }
     }
 
   if (! comment_buf.empty ())
     octave_comment_buffer::append (comment_buf);
 
  done:
-  xunput (c, yytext);
+  xunput (c);
   current_input_column--;
   return retval;
 }
 
 static inline bool
 looks_like_hex (const char *s, int len)
 {
   return (len > 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X'));
 }
 
 void
 lexical_feedback::handle_number (void)
 {
   double value = 0.0;
   int nread = 0;
 
-  if (looks_like_hex (yytext, strlen (yytext)))
+  char *yytxt = flex_yytext ();
+
+  if (looks_like_hex (yytxt, strlen (yytxt)))
     {
       unsigned long ival;
 
-      nread = sscanf (yytext, "%lx", &ival);
+      nread = sscanf (yytxt, "%lx", &ival);
 
       value = static_cast<double> (ival);
     }
   else
     {
-      char *tmp = strsave (yytext);
+      char *tmp = strsave (yytxt);
 
       char *idx = strpbrk (tmp, "Dd");
 
       if (idx)
         *idx = 'e';
 
       nread = sscanf (tmp, "%lf", &value);
 
@@ -2665,22 +2506,20 @@ lexical_feedback::handle_number (void)
 
   assert (nread == 1);
 
   quote_is_transpose = true;
   convert_spaces_to_comma = true;
   looking_for_object_index = false;
   at_beginning_of_statement = false;
 
-  yylval.tok_val = new token (value, yytext, input_line_number,
-                              current_input_column);
-
-  token_stack.push (yylval.tok_val);
-
-  current_input_column += yyleng;
+  curr_lexer->push_token (new token (value, yytxt, input_line_number,
+                                     current_input_column));
+
+  current_input_column += flex_yyleng ();
 
   do_comma_insert_check ();
 }
 
 // We have seen a backslash and need to find out if it should be
 // treated as a continuation character.  If so, this eats it, up to
 // and including the new line character.
 //
@@ -2756,26 +2595,26 @@ lexical_feedback::have_continuation (boo
               beginning_of_comment = false;
             }
           else
             goto cleanup;
           break;
         }
     }
 
-  xunput (c, yytext);
+  xunput (c);
   return false;
 
 cleanup:
 
   std::string s = buf.str ();
 
   int len = s.length ();
   while (len--)
-    xunput (s[len], yytext);
+    xunput (s[len]);
 
   return false;
 }
 
 // We have seen a '.' and need to see if it is the start of a
 // continuation.  If so, this eats it, up to and including the new
 // line character.
 
@@ -2785,22 +2624,22 @@ lexical_feedback::have_ellipsis_continua
   char c1 = text_yyinput ();
   if (c1 == '.')
     {
       char c2 = text_yyinput ();
       if (c2 == '.' && have_continuation (trailing_comments_ok))
         return true;
       else
         {
-          xunput (c2, yytext);
-          xunput (c1, yytext);
+          xunput (c2);
+          xunput (c1);
         }
     }
   else
-    xunput (c1, yytext);
+    xunput (c1);
 
   return false;
 }
 
 // See if we have a continuation line.  If so, eat it and the leading
 // whitespace on the next line.
 
 int
@@ -2809,17 +2648,17 @@ lexical_feedback::eat_continuation (void
   int retval = lexical_feedback::NO_WHITESPACE;
 
   int c = text_yyinput ();
 
   if ((c == '.' && have_ellipsis_continuation ())
       || (c == '\\' && have_continuation ()))
     retval = eat_whitespace ();
   else
-    xunput (c, yytext);
+    xunput (c);
 
   return retval;
 }
 
 int
 lexical_feedback::handle_string (char delim)
 {
   std::ostringstream buf;
@@ -2872,28 +2711,27 @@ lexical_feedback::handle_string (char de
               c = text_yyinput ();
               if (c == delim)
                 {
                   buf << static_cast<char> (c);
                 }
               else
                 {
                   std::string s;
-                  xunput (c, yytext);
+                  xunput (c);
 
                   if (delim == '\'')
                     s = buf.str ();
                   else
                     s = do_string_escapes (buf.str ());
 
                   quote_is_transpose = true;
                   convert_spaces_to_comma = true;
 
-                  yylval.tok_val = new token (s, bos_line, bos_col);
-                  token_stack.push (yylval.tok_val);
+                  curr_lexer->push_token (new token (s, bos_line, bos_col));
 
                   if (delim == '"')
                     gripe_matlab_incompatible ("\" used as string delimiter");
                   else if (delim == '\'')
                     gripe_single_quote_string ();
 
                   looking_for_object_index = true;
                   at_beginning_of_statement = false;
@@ -2920,93 +2758,93 @@ lexical_feedback::next_token_is_assign_o
 
   int c0 = text_yyinput ();
 
   switch (c0)
     {
     case '=':
       {
         int c1 = text_yyinput ();
-        xunput (c1, yytext);
+        xunput (c1);
         if (c1 != '=')
           retval = true;
       }
       break;
 
     case '+':
     case '-':
     case '*':
     case '/':
     case '\\':
     case '&':
     case '|':
       {
         int c1 = text_yyinput ();
-        xunput (c1, yytext);
+        xunput (c1);
         if (c1 == '=')
           retval = true;
       }
       break;
 
     case '.':
       {
         int c1 = text_yyinput ();
         if (match_any (c1, "+-*/\\"))
           {
             int c2 = text_yyinput ();
-            xunput (c2, yytext);
+            xunput (c2);
             if (c2 == '=')
               retval = true;
           }
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     case '>':
       {
         int c1 = text_yyinput ();
         if (c1 == '>')
           {
             int c2 = text_yyinput ();
-            xunput (c2, yytext);
+            xunput (c2);
             if (c2 == '=')
               retval = true;
           }
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     case '<':
       {
         int c1 = text_yyinput ();
         if (c1 == '<')
           {
             int c2 = text_yyinput ();
-            xunput (c2, yytext);
+            xunput (c2);
             if (c2 == '=')
               retval = true;
           }
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     default:
       break;
     }
 
-  xunput (c0, yytext);
+  xunput (c0);
 
   return retval;
 }
 
 bool
 lexical_feedback::next_token_is_index_op (void)
 {
   int c = text_yyinput ();
-  xunput (c, yytext);
+  xunput (c);
   return c == '(' || c == '{';
 }
 
 int
 lexical_feedback::handle_close_bracket (bool spc_gobbled, int bracket_type)
 {
   int retval = bracket_type;
 
@@ -3054,17 +2892,17 @@ lexical_feedback::handle_close_bracket (
           bool postfix_un_op = next_token_is_postfix_unary_op (spc_gobbled);
 
           bool sep_op = next_token_is_sep_op ();
 
           if (! (postfix_un_op || bin_op || sep_op))
             {
               maybe_warn_separator_insert (',');
 
-              xunput (',', yytext);
+              xunput (',');
               return retval;
             }
         }
     }
 
   quote_is_transpose = true;
   convert_spaces_to_comma = true;
 
@@ -3080,18 +2918,18 @@ lexical_feedback::maybe_unput_comma (int
     {
       int bin_op = next_token_is_bin_op (spc_gobbled);
 
       int postfix_un_op = next_token_is_postfix_unary_op (spc_gobbled);
 
       int c1 = text_yyinput ();
       int c2 = text_yyinput ();
 
-      xunput (c2, yytext);
-      xunput (c1, yytext);
+      xunput (c2);
+      xunput (c1);
 
       int sep_op = next_token_is_sep_op ();
 
       int dot_op = (c1 == '.'
                     && (isalpha (c2) || isspace (c2) || c2 == '_'));
 
       if (postfix_un_op || bin_op || sep_op || dot_op)
         return;
@@ -3101,17 +2939,17 @@ lexical_feedback::maybe_unput_comma (int
       // If there is no space before the indexing op, we don't insert
       // a comma.
 
       if (index_op && ! spc_gobbled)
         return;
 
       maybe_warn_separator_insert (',');
 
-      xunput (',', yytext);
+      xunput (',');
     }
 }
 
 bool
 lexical_feedback::next_token_can_follow_bin_op (void)
 {
   std::stack<char> buf;
 
@@ -3126,17 +2964,17 @@ lexical_feedback::next_token_can_follow_
 
       if (match_any (c, ",;\n") || (c != ' ' && c != '\t'))
         break;
     }
 
   // Restore input.
   while (! buf.empty ())
     {
-      xunput (buf.top (), yytext);
+      xunput (buf.top ());
 
       buf.pop ();
     }
 
   return (isalnum (c) || match_any (c, "!\"'(-[_{~"));
 }
 
 static bool
@@ -3169,22 +3007,22 @@ lexical_feedback::looks_like_command_arg
         if (c1 == '=')
           {
             int c2 = text_yyinput ();
 
             if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
                 && next_token_can_follow_bin_op ())
               retval = false;
 
-            xunput (c2, yytext);
+            xunput (c2);
           }
         else
           retval = false;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     case '(':
     case '{':
       // Indexing.
       retval = false;
       break;
@@ -3224,37 +3062,37 @@ lexical_feedback::looks_like_command_arg
           case '=':
             {
               int c2 = text_yyinput ();
 
               if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
                   && next_token_can_follow_bin_op ())
                 retval = false;
 
-              xunput (c2, yytext);
+              xunput (c2);
             }
             break;
           }
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     case ':':
     case '/':
     case '\\':
     case '^':
       {
         int c1 = text_yyinput ();
 
         if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
             && next_token_can_follow_bin_op ())
           retval = false;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     // .+ .- ./ .\ .^ .* .**
     case '.':
       {
         int c1 = text_yyinput ();
 
@@ -3265,34 +3103,34 @@ lexical_feedback::looks_like_command_arg
             if (c2 == '=')
               {
                 int c3 = text_yyinput ();
 
                 if (! match_any (c3, ",;\n") && (c3 == ' ' || c3 == '\t')
                     && next_token_can_follow_bin_op ())
                   retval = false;
 
-                xunput (c3, yytext);
+                xunput (c3);
               }
             else if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
                      && next_token_can_follow_bin_op ())
               retval = false;
 
-            xunput (c2, yytext);
+            xunput (c2);
           }
         else if (! match_any (c1, ",;\n")
                  && (! isdigit (c1) && c1 != ' ' && c1 != '\t'
                      && c1 != '.'))
           {
             // Structure reference.  FIXME -- is this a complete check?
 
             retval = false;
           }
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     // & && | || * **
     case '&':
     case '|':
     case '*':
       {
@@ -3301,23 +3139,23 @@ lexical_feedback::looks_like_command_arg
         if (c1 == c0)
           {
             int c2 = text_yyinput ();
 
             if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
                 && next_token_can_follow_bin_op ())
               retval = false;
 
-            xunput (c2, yytext);
+            xunput (c2);
           }
         else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
                  && next_token_can_follow_bin_op ())
           retval = false;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     // < <= > >=
     case '<':
     case '>':
       {
         int c1 = text_yyinput ();
@@ -3325,23 +3163,23 @@ lexical_feedback::looks_like_command_arg
         if (c1 == '=')
           {
             int c2 = text_yyinput ();
 
             if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
                 && next_token_can_follow_bin_op ())
               retval = false;
 
-            xunput (c2, yytext);
+            xunput (c2);
           }
         else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
                  && next_token_can_follow_bin_op ())
           retval = false;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     // ~= !=
     case '~':
     case '!':
       {
         int c1 = text_yyinput ();
@@ -3350,42 +3188,43 @@ lexical_feedback::looks_like_command_arg
         if (c1 == '=')
           {
             int c2 = text_yyinput ();
 
             if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
                 && next_token_can_follow_bin_op ())
               retval = false;
 
-            xunput (c2, yytext);
+            xunput (c2);
           }
         else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
                  && next_token_can_follow_bin_op ())
           retval = false;
 
-        xunput (c1, yytext);
+        xunput (c1);
       }
       break;
 
     default:
       break;
     }
 
-  xunput (c0, yytext);
+  xunput (c0);
 
   return retval;
 }
 
 int
 lexical_feedback::handle_superclass_identifier (void)
 {
   eat_continuation ();
 
   std::string pkg;
-  std::string meth = strip_trailing_whitespace (yytext);
+  char *yytxt = flex_yytext ();
+  std::string meth = strip_trailing_whitespace (yytxt);
   size_t pos = meth.find ("@");
   std::string cls = meth.substr (pos).substr (1);
   meth = meth.substr (0, pos - 1);
 
   pos = cls.find (".");
   if (pos != std::string::npos)
     {
       pkg = cls.substr (pos).substr (1);
@@ -3395,104 +3234,100 @@ lexical_feedback::handle_superclass_iden
   int kw_token = (is_keyword_token (meth) || is_keyword_token (cls)
                   || is_keyword_token (pkg));
   if (kw_token)
     {
       error ("method, class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
 
-  yylval.tok_val
-    = new token (meth.empty () ? 0 : &(symbol_table::insert (meth)),
-                 cls.empty () ? 0 : &(symbol_table::insert (cls)),
-                 pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-                 input_line_number,
-                 current_input_column);
-  token_stack.push (yylval.tok_val);
+  curr_lexer->push_token
+    (new token (meth.empty () ? 0 : &(symbol_table::insert (meth)),
+                cls.empty () ? 0 : &(symbol_table::insert (cls)),
+                pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
+                input_line_number, current_input_column));
 
   convert_spaces_to_comma = true;
-  current_input_column += yyleng;
+  current_input_column += flex_yyleng ();
 
   return SUPERCLASSREF;
 }
 
 int
 lexical_feedback::handle_meta_identifier (void)
 {
   eat_continuation ();
 
   std::string pkg;
-  std::string cls = strip_trailing_whitespace (yytext).substr (1);
+  char *yytxt = flex_yytext ();
+  std::string cls = strip_trailing_whitespace (yytxt).substr (1);
   size_t pos = cls.find (".");
 
   if (pos != std::string::npos)
     {
       pkg = cls.substr (pos).substr (1);
       cls = cls.substr (0, pos - 1);
     }
 
   int kw_token = is_keyword_token (cls) || is_keyword_token (pkg);
   if (kw_token)
     {
        error ("class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
 
-  yylval.tok_val
-    = new token (cls.empty () ? 0 : &(symbol_table::insert (cls)),
-                 pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-                 input_line_number,
-                 current_input_column);
-
-  token_stack.push (yylval.tok_val);
+  curr_lexer->push_token
+    (new token (cls.empty () ? 0 : &(symbol_table::insert (cls)),
+                pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
+                input_line_number, current_input_column));
 
   convert_spaces_to_comma = true;
-  current_input_column += yyleng;
+  current_input_column += flex_yyleng ();
 
   return METAQUERY;
 }
 
 // Figure out exactly what kind of token to return when we have seen
 // an identifier.  Handles keywords.  Return -1 if the identifier
 // should be ignored.
 
 int
 lexical_feedback::handle_identifier (void)
 {
   bool at_bos = at_beginning_of_statement;
 
-  std::string tok = strip_trailing_whitespace (yytext);
-
-  int c = yytext[yyleng-1];
+  char *yytxt = flex_yytext ();
+
+  std::string tok = strip_trailing_whitespace (yytxt);
+
+  int c = yytxt[flex_yyleng()-1];
 
   bool cont_is_spc = (eat_continuation () != lexical_feedback::NO_WHITESPACE);
 
   int spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
 
   // If we are expecting a structure element, avoid recognizing
   // keywords and other special names and return STRUCT_ELT, which is
   // a string that is also a valid identifier.  But first, we have to
   // decide whether to insert a comma.
 
   if (looking_at_indirect_ref)
     {
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
 
-      yylval.tok_val = new token (tok, input_line_number,
-                                  current_input_column);
-
-      token_stack.push (yylval.tok_val);
+      curr_lexer->push_token (new token (tok, input_line_number,
+                                         current_input_column));
 
       quote_is_transpose = true;
       convert_spaces_to_comma = true;
       looking_for_object_index = true;
 
-      current_input_column += yyleng;
+      current_input_column += flex_yyleng ();
 
       return STRUCT_ELT;
     }
 
   at_beginning_of_statement = false;
 
   // The is_keyword_token may reset
   // at_beginning_of_statement.  For example, if it sees
@@ -3510,61 +3345,59 @@ lexical_feedback::handle_identifier (voi
       if (kw_token)
         {
           error ("function handles may not refer to keywords");
 
           return LEXICAL_ERROR;
         }
       else
         {
-          yylval.tok_val = new token (tok, input_line_number,
-                                      current_input_column);
-
-          token_stack.push (yylval.tok_val);
-
-          current_input_column += yyleng;
+          curr_lexer->push_token (new token (tok, input_line_number,
+                                             current_input_column));
+
+          current_input_column += flex_yyleng ();
           quote_is_transpose = false;
           convert_spaces_to_comma = true;
           looking_for_object_index = true;
 
           return FCN_HANDLE;
         }
     }
 
   // If we have a regular keyword, return it.
   // Keywords can be followed by identifiers.
 
   if (kw_token)
     {
       if (kw_token >= 0)
         {
-          current_input_column += yyleng;
+          current_input_column += flex_yyleng ();
           quote_is_transpose = false;
           convert_spaces_to_comma = true;
           looking_for_object_index = false;
         }
 
       return kw_token;
     }
 
   // See if we have a plot keyword (title, using, with, or clear).
 
   int c1 = text_yyinput ();
 
   bool next_tok_is_eq = false;
   if (c1 == '=')
     {
       int c2 = text_yyinput ();
-      xunput (c2, yytext);
+      xunput (c2);
 
       if (c2 != '=')
         next_tok_is_eq = true;
     }
 
-  xunput (c1, yytext);
+  xunput (c1);
 
   // Kluge alert.
   //
   // If we are looking at a text style function, set up to gobble its
   // arguments.
   //
   // If the following token is '=', or if we are parsing a function
   // return list or function parameter list, or if we are looking at
@@ -3593,37 +3426,34 @@ lexical_feedback::handle_identifier (voi
     }
 
   // Find the token in the symbol table.  Beware the magic
   // transformation of the end keyword...
 
   if (tok == "end")
     tok = "__end__";
 
-  yylval.tok_val = new token (&(symbol_table::insert (tok)),
-                              input_line_number,
-                              current_input_column);
-
-  token_stack.push (yylval.tok_val);
+  curr_lexer->push_token (new token (&(symbol_table::insert (tok)),
+                                     input_line_number, current_input_column));
 
   // After seeing an identifer, it is ok to convert spaces to a comma
   // (if needed).
 
   convert_spaces_to_comma = true;
 
   if (! (next_tok_is_eq || YY_START == COMMAND_START))
     {
       quote_is_transpose = true;
 
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
     }
 
-  current_input_column += yyleng;
+  current_input_column += flex_yyleng ();
 
   if (tok != "__end__")
     looking_for_object_index = true;
 
   return NAME;
 }
 
 void
@@ -3688,8 +3518,213 @@ void
 lexical_feedback::gripe_matlab_incompatible_operator (const std::string& op)
 {
   std::string t = op;
   int n = t.length ();
   if (t[n-1] == '\n')
     t.resize (n-1);
   gripe_matlab_incompatible (t + " used as operator");
 }
+
+void
+lexical_feedback::push_token (token *tok)
+{
+  yylval.tok_val = tok;
+  token_stack.push (tok);
+}
+
+token *
+lexical_feedback::current_token (void)
+{
+  return yylval.tok_val;
+}
+
+void
+lexical_feedback::display_token (int tok)
+{
+  switch (tok)
+    {
+    case '=': std::cerr << "'='\n"; break;
+    case ':': std::cerr << "':'\n"; break;
+    case '-': std::cerr << "'-'\n"; break;
+    case '+': std::cerr << "'+'\n"; break;
+    case '*': std::cerr << "'*'\n"; break;
+    case '/': std::cerr << "'/'\n"; break;
+    case ADD_EQ: std::cerr << "ADD_EQ\n"; break;
+    case SUB_EQ: std::cerr << "SUB_EQ\n"; break;
+    case MUL_EQ: std::cerr << "MUL_EQ\n"; break;
+    case DIV_EQ: std::cerr << "DIV_EQ\n"; break;
+    case LEFTDIV_EQ: std::cerr << "LEFTDIV_EQ\n"; break;
+    case POW_EQ: std::cerr << "POW_EQ\n"; break;
+    case EMUL_EQ: std::cerr << "EMUL_EQ\n"; break;
+    case EDIV_EQ: std::cerr << "EDIV_EQ\n"; break;
+    case ELEFTDIV_EQ: std::cerr << "ELEFTDIV_EQ\n"; break;
+    case EPOW_EQ: std::cerr << "EPOW_EQ\n"; break;
+    case AND_EQ: std::cerr << "AND_EQ\n"; break;
+    case OR_EQ: std::cerr << "OR_EQ\n"; break;
+    case LSHIFT_EQ: std::cerr << "LSHIFT_EQ\n"; break;
+    case RSHIFT_EQ: std::cerr << "RSHIFT_EQ\n"; break;
+    case LSHIFT: std::cerr << "LSHIFT\n"; break;
+    case RSHIFT: std::cerr << "RSHIFT\n"; break;
+    case EXPR_AND_AND: std::cerr << "EXPR_AND_AND\n"; break;
+    case EXPR_OR_OR: std::cerr << "EXPR_OR_OR\n"; break;
+    case EXPR_AND: std::cerr << "EXPR_AND\n"; break;
+    case EXPR_OR: std::cerr << "EXPR_OR\n"; break;
+    case EXPR_NOT: std::cerr << "EXPR_NOT\n"; break;
+    case EXPR_LT: std::cerr << "EXPR_LT\n"; break;
+    case EXPR_LE: std::cerr << "EXPR_LE\n"; break;
+    case EXPR_EQ: std::cerr << "EXPR_EQ\n"; break;
+    case EXPR_NE: std::cerr << "EXPR_NE\n"; break;
+    case EXPR_GE: std::cerr << "EXPR_GE\n"; break;
+    case EXPR_GT: std::cerr << "EXPR_GT\n"; break;
+    case LEFTDIV: std::cerr << "LEFTDIV\n"; break;
+    case EMUL: std::cerr << "EMUL\n"; break;
+    case EDIV: std::cerr << "EDIV\n"; break;
+    case ELEFTDIV: std::cerr << "ELEFTDIV\n"; break;
+    case EPLUS: std::cerr << "EPLUS\n"; break;
+    case EMINUS: std::cerr << "EMINUS\n"; break;
+    case QUOTE: std::cerr << "QUOTE\n"; break;
+    case TRANSPOSE: std::cerr << "TRANSPOSE\n"; break;
+    case PLUS_PLUS: std::cerr << "PLUS_PLUS\n"; break;
+    case MINUS_MINUS: std::cerr << "MINUS_MINUS\n"; break;
+    case POW: std::cerr << "POW\n"; break;
+    case EPOW: std::cerr << "EPOW\n"; break;
+
+    case NUM:
+    case IMAG_NUM:
+      {
+        token *tok_val = curr_lexer->current_token ();
+        std::cerr << (tok == NUM ? "NUM" : "IMAG_NUM")
+                  << " [" << tok_val->number () << "]\n";
+      }
+      break;
+
+    case STRUCT_ELT:
+      {
+        token *tok_val = curr_lexer->current_token ();
+        std::cerr << "STRUCT_ELT [" << tok_val->text () << "]\n";
+      }
+      break;
+
+    case NAME:
+      {
+        token *tok_val = curr_lexer->current_token ();
+        symbol_table::symbol_record *sr = tok_val->sym_rec ();
+        std::cerr << "NAME";
+        if (sr)
+          std::cerr << " [" << sr->name () << "]";
+        std::cerr << "\n";
+      }
+      break;
+
+    case END: std::cerr << "END\n"; break;
+
+    case DQ_STRING:
+    case SQ_STRING:
+      {
+        token *tok_val = curr_lexer->current_token ();
+
+        std::cerr << (tok == DQ_STRING ? "DQ_STRING" : "SQ_STRING")
+                  << " [" << tok_val->text () << "]\n";
+      }
+      break;
+
+    case FOR: std::cerr << "FOR\n"; break;
+    case WHILE: std::cerr << "WHILE\n"; break;
+    case DO: std::cerr << "DO\n"; break;
+    case UNTIL: std::cerr << "UNTIL\n"; break;
+    case IF: std::cerr << "IF\n"; break;
+    case ELSEIF: std::cerr << "ELSEIF\n"; break;
+    case ELSE: std::cerr << "ELSE\n"; break;
+    case SWITCH: std::cerr << "SWITCH\n"; break;
+    case CASE: std::cerr << "CASE\n"; break;
+    case OTHERWISE: std::cerr << "OTHERWISE\n"; break;
+    case BREAK: std::cerr << "BREAK\n"; break;
+    case CONTINUE: std::cerr << "CONTINUE\n"; break;
+    case FUNC_RET: std::cerr << "FUNC_RET\n"; break;
+    case UNWIND: std::cerr << "UNWIND\n"; break;
+    case CLEANUP: std::cerr << "CLEANUP\n"; break;
+    case TRY: std::cerr << "TRY\n"; break;
+    case CATCH: std::cerr << "CATCH\n"; break;
+    case GLOBAL: std::cerr << "GLOBAL\n"; break;
+    case PERSISTENT: std::cerr << "PERSISTENT\n"; break;
+    case FCN_HANDLE: std::cerr << "FCN_HANDLE\n"; break;
+    case END_OF_INPUT: std::cerr << "END_OF_INPUT\n\n"; break;
+    case LEXICAL_ERROR: std::cerr << "LEXICAL_ERROR\n\n"; break;
+    case FCN: std::cerr << "FCN\n"; break;
+    case CLOSE_BRACE: std::cerr << "CLOSE_BRACE\n"; break;
+    case SCRIPT_FILE: std::cerr << "SCRIPT_FILE\n"; break;
+    case FUNCTION_FILE: std::cerr << "FUNCTION_FILE\n"; break;
+    case SUPERCLASSREF: std::cerr << "SUPERCLASSREF\n"; break;
+    case METAQUERY: std::cerr << "METAQUERY\n"; break;
+    case GET: std::cerr << "GET\n"; break;
+    case SET: std::cerr << "SET\n"; break;
+    case PROPERTIES: std::cerr << "PROPERTIES\n"; break;
+    case METHODS: std::cerr << "METHODS\n"; break;
+    case EVENTS: std::cerr << "EVENTS\n"; break;
+    case CLASSDEF: std::cerr << "CLASSDEF\n"; break;
+    case '\n': std::cerr << "\\n\n"; break;
+    case '\r': std::cerr << "\\r\n"; break;
+    case '\t': std::cerr << "TAB\n"; break;
+    default:
+      {
+        if (tok < 256)
+          std::cerr << static_cast<char> (tok) << "\n";
+        else
+          std::cerr << "UNKNOWN(" << tok << ")\n";
+      }
+      break;
+    }
+}
+
+static void
+display_state (int state)
+{
+  std::cerr << "S: ";
+
+  switch (state)
+    {
+    case INITIAL:
+      std::cerr << "INITIAL" << std::endl;
+      break;
+
+    case COMMAND_START:
+      std::cerr << "COMMAND_START" << std::endl;
+      break;
+
+    case MATRIX_START:
+      std::cerr << "MATRIX_START" << std::endl;
+      break;
+
+    case SCRIPT_FILE_BEGIN:
+      std::cerr << "SCRIPT_FILE_BEGIN" << std::endl;
+      break;
+
+    case FUNCTION_FILE_BEGIN:
+      std::cerr << "FUNCTION_FILE_BEGIN" << std::endl;
+      break;
+
+    default:
+      std::cerr << "UNKNOWN START STATE!" << std::endl;
+      break;
+    }
+}
+
+void
+lexical_feedback::fatal_error (const char *msg)
+{
+  error (msg);
+
+  OCTAVE_QUIT;
+
+  yy_fatal_error (msg);
+}
+
+void
+lexical_feedback::lexer_debug (const char *pattern, const char *text)
+{
+  std::cerr << std::endl;
+
+  display_state (YY_START);
+
+  std::cerr << "P: " << pattern << std::endl;
+  std::cerr << "T: " << text << std::endl;
+}
diff --git a/libinterp/parse-tree/oct-parse.yy b/libinterp/parse-tree/oct-parse.yy
--- a/libinterp/parse-tree/oct-parse.yy
+++ b/libinterp/parse-tree/oct-parse.yy
@@ -81,16 +81,19 @@ along with Octave; see the file COPYING.
 // Calls to the following functions appear in the generated output from
 // Bison without the namespace tag.  Redefine them so we will use them
 // via the gnulib namespace.
 #define fclose GNULIB_NAMESPACE::fclose
 #define fprintf GNULIB_NAMESPACE::fprintf
 #define malloc GNULIB_NAMESPACE::malloc
 #endif
 
+// The state of the parser.
+octave_parser *curr_parser = 0;
+
 // Buffer for help text snagged from function files.
 std::stack<std::string> help_buf;
 
 // Buffer for comments appearing before a function statement.
 static std::string fcn_comment_header;
 
 // TRUE means we are using readline.
 // (--no-line-editing)
@@ -151,210 +154,16 @@ static std::map<std::string, std::string
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
 // Generic error messages.
 static void
 yyerror (const char *s);
 
-// Error mesages for mismatched end tokens.
-static void
-end_error (const char *type, token::end_tok_type ettype, int l, int c);
-
-// Check to see that end tokens are properly matched.
-static bool
-end_token_ok (token *tok, token::end_tok_type expected);
-
-// Maybe print a warning if an assignment expression is used as the
-// test in a logical expression.
-static void
-maybe_warn_assign_as_truth_value (tree_expression *expr);
-
-// Maybe print a warning about switch labels that aren't constants.
-static void
-maybe_warn_variable_switch_label (tree_expression *expr);
-
-// Finish building a range.
-static tree_expression *
-finish_colon_expression (tree_colon_expression *e);
-
-// Build a constant.
-static tree_constant *
-make_constant (int op, token *tok_val);
-
-// Build a function handle.
-static tree_fcn_handle *
-make_fcn_handle (token *tok_val);
-
-// Build an anonymous function handle.
-static tree_anon_fcn_handle *
-make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt);
-
-// Build a binary expression.
-static tree_expression *
-make_binary_op (int op, tree_expression *op1, token *tok_val,
-                tree_expression *op2);
-
-// Build a boolean expression.
-static tree_expression *
-make_boolean_op (int op, tree_expression *op1, token *tok_val,
-                 tree_expression *op2);
-
-// Build a prefix expression.
-static tree_expression *
-make_prefix_op (int op, tree_expression *op1, token *tok_val);
-
-// Build a postfix expression.
-static tree_expression *
-make_postfix_op (int op, tree_expression *op1, token *tok_val);
-
-// Build an unwind-protect command.
-static tree_command *
-make_unwind_command (token *unwind_tok, tree_statement_list *body,
-                     tree_statement_list *cleanup, token *end_tok,
-                     octave_comment_list *lc, octave_comment_list *mc);
-
-// Build a try-catch command.
-static tree_command *
-make_try_command (token *try_tok, tree_statement_list *body,
-                  tree_statement_list *cleanup, token *end_tok,
-                  octave_comment_list *lc, octave_comment_list *mc);
-
-// Build a while command.
-static tree_command *
-make_while_command (token *while_tok, tree_expression *expr,
-                    tree_statement_list *body, token *end_tok,
-                    octave_comment_list *lc);
-
-// Build a do-until command.
-static tree_command *
-make_do_until_command (token *until_tok, tree_statement_list *body,
-                       tree_expression *expr, octave_comment_list *lc);
-
-// Build a for command.
-static tree_command *
-make_for_command (int tok_id, token *for_tok, tree_argument_list *lhs,
-                  tree_expression *expr, tree_expression *maxproc,
-                  tree_statement_list *body, token *end_tok,
-                  octave_comment_list *lc);
-
-// Build a break command.
-static tree_command *
-make_break_command (token *break_tok);
-
-// Build a continue command.
-static tree_command *
-make_continue_command (token *continue_tok);
-
-// Build a return command.
-static tree_command *
-make_return_command (token *return_tok);
-
-// Start an if command.
-static tree_if_command_list *
-start_if_command (tree_expression *expr, tree_statement_list *list);
-
-// Finish an if command.
-static tree_if_command *
-finish_if_command (token *if_tok, tree_if_command_list *list,
-                   token *end_tok, octave_comment_list *lc);
-
-// Build an elseif clause.
-static tree_if_clause *
-make_elseif_clause (token *elseif_tok, tree_expression *expr,
-                    tree_statement_list *list, octave_comment_list *lc);
-
-// Finish a switch command.
-static tree_switch_command *
-finish_switch_command (token *switch_tok, tree_expression *expr,
-                       tree_switch_case_list *list, token *end_tok,
-                       octave_comment_list *lc);
-
-// Build a switch case.
-static tree_switch_case *
-make_switch_case (token *case_tok, tree_expression *expr,
-                  tree_statement_list *list, octave_comment_list *lc);
-
-// Build an assignment to a variable.
-static tree_expression *
-make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
-                tree_expression *rhs);
-
-// Define a script.
-static void
-make_script (tree_statement_list *cmds, tree_statement *end_script);
-
-// Begin defining a function.
-static octave_user_function *
-start_function (tree_parameter_list *param_list, tree_statement_list *body,
-                tree_statement *end_function);
-
-// Create a no-op statement for end_function.
-static tree_statement *
-make_end (const std::string& type, int l, int c);
-
-// Do most of the work for defining a function.
-static octave_user_function *
-frob_function (const std::string& fname, octave_user_function *fcn);
-
-// Finish defining a function.
-static tree_function_def *
-finish_function (tree_parameter_list *ret_list,
-                 octave_user_function *fcn, octave_comment_list *lc);
-
-// Reset state after parsing function.
-static void
-recover_from_parsing_function (void);
-
-// Make an index expression.
-static tree_index_expression *
-make_index_expression (tree_expression *expr,
-                       tree_argument_list *args, char type);
-
-// Make an indirect reference expression.
-static tree_index_expression *
-make_indirect_ref (tree_expression *expr, const std::string&);
-
-// Make an indirect reference expression with dynamic field name.
-static tree_index_expression *
-make_indirect_ref (tree_expression *expr, tree_expression *field);
-
-// Make a declaration command.
-static tree_decl_command *
-make_decl_command (int tok, token *tok_val, tree_decl_init_list *lst);
-
-// Validate argument list forming a matrix or cell row.
-static tree_argument_list *
-validate_matrix_row (tree_argument_list *row);
-
-// Finish building a matrix list.
-static tree_expression *
-finish_matrix (tree_matrix *m);
-
-// Finish building a cell list.
-static tree_expression *
-finish_cell (tree_cell *c);
-
-// Maybe print a warning.  Duh.
-static void
-maybe_warn_missing_semi (tree_statement_list *);
-
-// Set the print flag for a statement based on the separator type.
-static tree_statement_list *
-set_stmt_print_flag (tree_statement_list *, char, bool);
-
-// Create a statement list.
-static tree_statement_list *make_statement_list (tree_statement *stmt);
-
-// Append a statement to an existing statement list.
-static tree_statement_list *
-append_statement_list (tree_statement_list *list, char sep,
-                       tree_statement *stmt, bool warn_missing_semi);
-
 // Finish building a statement.
 template <class T>
 static tree_statement *
 make_statement (T *arg)
 {
   octave_comment_list *comment = octave_comment_buffer::get_comment ();
 
   return new tree_statement (arg, comment);
@@ -551,51 +360,51 @@ input           : input1
                 | parse_error
                   { ABORT_PARSE; }
                 ;
 
 input1          : '\n'
                   { $$ = 0; }
                 | END_OF_INPUT
                   {
-                    curr_lexer->parser_end_of_input = 1;
+                    curr_parser->end_of_input = true;
                     $$ = 0;
                   }
                 | simple_list
                   { $$ = $1; }
                 | simple_list '\n'
                   { $$ = $1; }
                 | simple_list END_OF_INPUT
                   { $$ = $1; }
                 ;
 
 simple_list     : simple_list1 opt_sep_no_nl
-                  { $$ = set_stmt_print_flag ($1, $2, false); }
+                  { $$ = curr_parser->set_stmt_print_flag ($1, $2, false); }
                 ;
 
 simple_list1    : statement
-                  { $$ = make_statement_list ($1); }
+                  { $$ = curr_parser->make_statement_list ($1); }
                 | simple_list1 sep_no_nl statement
-                  { $$ = append_statement_list ($1, $2, $3, false); }
+                  { $$ = curr_parser->append_statement_list ($1, $2, $3, false); }
                 ;
 
 opt_list        : // empty
                   { $$ = new tree_statement_list (); }
                 | list
                   { $$ = $1; }
                 ;
 
 list            : list1 opt_sep
-                  { $$ = set_stmt_print_flag ($1, $2, true); }
+                  { $$ = curr_parser->set_stmt_print_flag ($1, $2, true); }
                 ;
 
 list1           : statement
-                  { $$ = make_statement_list ($1); }
+                  { $$ = curr_parser->make_statement_list ($1); }
                 | list1 sep statement
-                  { $$ = append_statement_list ($1, $2, $3, true); }
+                  { $$ = curr_parser->append_statement_list ($1, $2, $3, true); }
                 ;
 
 statement       : expression
                   { $$ = make_statement ($1); }
                 | command
                   { $$ = make_statement ($1); }
                 | word_list_cmd
                   { $$ = make_statement ($1); }
@@ -605,17 +414,17 @@ statement       : expression
 // Word-list command
 // =================
 
 // These are not really like expressions since they can't appear on
 // the RHS of an assignment.  But they are also not like commands (IF,
 // WHILE, etc.
 
 word_list_cmd   : identifier word_list
-                  { $$ = make_index_expression ($1, $2, '('); }
+                  { $$ = curr_parser->make_index_expression ($1, $2, '('); }
                 ;
 
 word_list       : string
                   { $$ = new tree_argument_list ($1); }
                 | word_list string
                   {
                     $1->append ($2);
                     $$ = $1;
@@ -638,25 +447,25 @@ superclass_identifier
                   { $$ = new tree_identifier ($1->line (), $1->column ()); }
                 ;
 
 meta_identifier : METAQUERY
                   { $$ = new tree_identifier ($1->line (), $1->column ()); }
                 ;
 
 string          : DQ_STRING
-                  { $$ = make_constant (DQ_STRING, $1); }
+                  { $$ = curr_parser->make_constant (DQ_STRING, $1); }
                 | SQ_STRING
-                  { $$ = make_constant (SQ_STRING, $1); }
+                  { $$ = curr_parser->make_constant (SQ_STRING, $1); }
                 ;
 
 constant        : NUM
-                  { $$ = make_constant (NUM, $1); }
+                  { $$ = curr_parser->make_constant (NUM, $1); }
                 | IMAG_NUM
-                  { $$ = make_constant (IMAG_NUM, $1); }
+                  { $$ = curr_parser->make_constant (IMAG_NUM, $1); }
                 | string
                   { $$ = $1; }
                 ;
 
 matrix          : '[' ']'
                   {
                     $$ = new tree_constant (octave_null_matrix::instance);
                     curr_lexer->looking_at_matrix_or_assign_lhs = false;
@@ -671,17 +480,17 @@ matrix          : '[' ']'
                 | '[' ',' ']'
                   {
                     $$ = new tree_constant (octave_null_matrix::instance);
                     curr_lexer->looking_at_matrix_or_assign_lhs = false;
                     curr_lexer->pending_local_variables.clear ();
                   }
                 | '[' matrix_rows ']'
                   {
-                    $$ = finish_matrix ($2);
+                    $$ = curr_parser->finish_matrix ($2);
                     curr_lexer->looking_at_matrix_or_assign_lhs = false;
                     curr_lexer->pending_local_variables.clear ();
                   }
                 ;
 
 matrix_rows     : matrix_rows1
                   { $$ = $1; }
                 | matrix_rows1 ';'      // Ignore trailing semicolon.
@@ -697,17 +506,17 @@ matrix_rows1    : cell_or_matrix_row
                   }
                 ;
 
 cell            : '{' '}'
                   { $$ = new tree_constant (octave_value (Cell ())); }
                 | '{' ';' '}'
                   { $$ = new tree_constant (octave_value (Cell ())); }
                 | '{' cell_rows '}'
-                  { $$ = finish_cell ($2); }
+                  { $$ = curr_parser->finish_cell ($2); }
                 ;
 
 cell_rows       : cell_rows1
                   { $$ = $1; }
                 | cell_rows1 ';'        // Ignore trailing semicolon.
                   { $$ = $1; }
                 ;
 
@@ -717,32 +526,32 @@ cell_rows1      : cell_or_matrix_row
                   {
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 cell_or_matrix_row
                 : arg_list
-                  { $$ = validate_matrix_row ($1); }
+                  { $$ = curr_parser->validate_matrix_row ($1); }
                 | arg_list ','  // Ignore trailing comma.
-                  { $$ = validate_matrix_row ($1); }
+                  { $$ = curr_parser->validate_matrix_row ($1); }
                 ;
 
 fcn_handle      : '@' FCN_HANDLE
                   {
-                    $$ = make_fcn_handle ($2);
+                    $$ = curr_parser->make_fcn_handle ($2);
                     curr_lexer->looking_at_function_handle--;
                   }
                 ;
 
 anon_fcn_handle : '@' param_list statement
                   {
                     curr_lexer->quote_is_transpose = false;
-                    $$ = make_anon_fcn_handle ($2, $3);
+                    $$ = curr_parser->make_anon_fcn_handle ($2, $3);
                   }
                 ;
 
 primary_expr    : identifier
                   { $$ = $1; }
                 | constant
                   { $$ = $1; }
                 | fcn_handle
@@ -797,110 +606,110 @@ arg_list        : expression
 
 indirect_ref_op : '.'
                   { curr_lexer->looking_at_indirect_ref = true; }
                 ;
 
 oper_expr       : primary_expr
                   { $$ = $1; }
                 | oper_expr PLUS_PLUS
-                  { $$ = make_postfix_op (PLUS_PLUS, $1, $2); }
+                  { $$ = curr_parser->make_postfix_op (PLUS_PLUS, $1, $2); }
                 | oper_expr MINUS_MINUS
-                  { $$ = make_postfix_op (MINUS_MINUS, $1, $2); }
+                  { $$ = curr_parser->make_postfix_op (MINUS_MINUS, $1, $2); }
                 | oper_expr '(' ')'
-                  { $$ = make_index_expression ($1, 0, '('); }
+                  { $$ = curr_parser->make_index_expression ($1, 0, '('); }
                 | oper_expr '(' arg_list ')'
-                  { $$ = make_index_expression ($1, $3, '('); }
+                  { $$ = curr_parser->make_index_expression ($1, $3, '('); }
                 | oper_expr '{' '}'
-                  { $$ = make_index_expression ($1, 0, '{'); }
+                  { $$ = curr_parser->make_index_expression ($1, 0, '{'); }
                 | oper_expr '{' arg_list '}'
-                  { $$ = make_index_expression ($1, $3, '{'); }
+                  { $$ = curr_parser->make_index_expression ($1, $3, '{'); }
                 | oper_expr QUOTE
-                  { $$ = make_postfix_op (QUOTE, $1, $2); }
+                  { $$ = curr_parser->make_postfix_op (QUOTE, $1, $2); }
                 | oper_expr TRANSPOSE
-                  { $$ = make_postfix_op (TRANSPOSE, $1, $2); }
+                  { $$ = curr_parser->make_postfix_op (TRANSPOSE, $1, $2); }
                 | oper_expr indirect_ref_op STRUCT_ELT
-                  { $$ = make_indirect_ref ($1, $3->text ()); }
+                  { $$ = curr_parser->make_indirect_ref ($1, $3->text ()); }
                 | oper_expr indirect_ref_op '(' expression ')'
-                  { $$ = make_indirect_ref ($1, $4); }
+                  { $$ = curr_parser->make_indirect_ref ($1, $4); }
                 | PLUS_PLUS oper_expr %prec UNARY
-                  { $$ = make_prefix_op (PLUS_PLUS, $2, $1); }
+                  { $$ = curr_parser->make_prefix_op (PLUS_PLUS, $2, $1); }
                 | MINUS_MINUS oper_expr %prec UNARY
-                  { $$ = make_prefix_op (MINUS_MINUS, $2, $1); }
+                  { $$ = curr_parser->make_prefix_op (MINUS_MINUS, $2, $1); }
                 | EXPR_NOT oper_expr %prec UNARY
-                  { $$ = make_prefix_op (EXPR_NOT, $2, $1); }
+                  { $$ = curr_parser->make_prefix_op (EXPR_NOT, $2, $1); }
                 | '+' oper_expr %prec UNARY
-                  { $$ = make_prefix_op ('+', $2, $1); }
+                  { $$ = curr_parser->make_prefix_op ('+', $2, $1); }
                 | '-' oper_expr %prec UNARY
-                  { $$ = make_prefix_op ('-', $2, $1); }
+                  { $$ = curr_parser->make_prefix_op ('-', $2, $1); }
                 | oper_expr POW oper_expr
-                  { $$ = make_binary_op (POW, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (POW, $1, $2, $3); }
                 | oper_expr EPOW oper_expr
-                  { $$ = make_binary_op (EPOW, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EPOW, $1, $2, $3); }
                 | oper_expr '+' oper_expr
-                  { $$ = make_binary_op ('+', $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op ('+', $1, $2, $3); }
                 | oper_expr '-' oper_expr
-                  { $$ = make_binary_op ('-', $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op ('-', $1, $2, $3); }
                 | oper_expr '*' oper_expr
-                  { $$ = make_binary_op ('*', $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op ('*', $1, $2, $3); }
                 | oper_expr '/' oper_expr
-                  { $$ = make_binary_op ('/', $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op ('/', $1, $2, $3); }
                 | oper_expr EPLUS oper_expr
-                  { $$ = make_binary_op ('+', $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op ('+', $1, $2, $3); }
                 | oper_expr EMINUS oper_expr
-                  { $$ = make_binary_op ('-', $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op ('-', $1, $2, $3); }
                 | oper_expr EMUL oper_expr
-                  { $$ = make_binary_op (EMUL, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EMUL, $1, $2, $3); }
                 | oper_expr EDIV oper_expr
-                  { $$ = make_binary_op (EDIV, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EDIV, $1, $2, $3); }
                 | oper_expr LEFTDIV oper_expr
-                  { $$ = make_binary_op (LEFTDIV, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (LEFTDIV, $1, $2, $3); }
                 | oper_expr ELEFTDIV oper_expr
-                  { $$ = make_binary_op (ELEFTDIV, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (ELEFTDIV, $1, $2, $3); }
                 ;
 
 colon_expr      : colon_expr1
-                  { $$ = finish_colon_expression ($1); }
+                  { $$ = curr_parser->finish_colon_expression ($1); }
                 ;
 
 colon_expr1     : oper_expr
                   { $$ = new tree_colon_expression ($1); }
                 | colon_expr1 ':' oper_expr
                   {
                     if (! ($$ = $1->append ($3)))
                       ABORT_PARSE;
                   }
                 ;
 
 simple_expr     : colon_expr
                   { $$ = $1; }
                 | simple_expr LSHIFT simple_expr
-                  { $$ = make_binary_op (LSHIFT, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (LSHIFT, $1, $2, $3); }
                 | simple_expr RSHIFT simple_expr
-                  { $$ = make_binary_op (RSHIFT, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (RSHIFT, $1, $2, $3); }
                 | simple_expr EXPR_LT simple_expr
-                  { $$ = make_binary_op (EXPR_LT, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_LT, $1, $2, $3); }
                 | simple_expr EXPR_LE simple_expr
-                  { $$ = make_binary_op (EXPR_LE, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_LE, $1, $2, $3); }
                 | simple_expr EXPR_EQ simple_expr
-                  { $$ = make_binary_op (EXPR_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_EQ, $1, $2, $3); }
                 | simple_expr EXPR_GE simple_expr
-                  { $$ = make_binary_op (EXPR_GE, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_GE, $1, $2, $3); }
                 | simple_expr EXPR_GT simple_expr
-                  { $$ = make_binary_op (EXPR_GT, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_GT, $1, $2, $3); }
                 | simple_expr EXPR_NE simple_expr
-                  { $$ = make_binary_op (EXPR_NE, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_NE, $1, $2, $3); }
                 | simple_expr EXPR_AND simple_expr
-                  { $$ = make_binary_op (EXPR_AND, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_AND, $1, $2, $3); }
                 | simple_expr EXPR_OR simple_expr
-                  { $$ = make_binary_op (EXPR_OR, $1, $2, $3); }
+                  { $$ = curr_parser->make_binary_op (EXPR_OR, $1, $2, $3); }
                 | simple_expr EXPR_AND_AND simple_expr
-                  { $$ = make_boolean_op (EXPR_AND_AND, $1, $2, $3); }
+                  { $$ = curr_parser->make_boolean_op (EXPR_AND_AND, $1, $2, $3); }
                 | simple_expr EXPR_OR_OR simple_expr
-                  { $$ = make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
+                  { $$ = curr_parser->make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
                 ;
 
 // Arrange for the lexer to return CLOSE_BRACE for ']' by looking ahead
 // one token for an assignment op.
 
 assign_lhs      : simple_expr
                   {
                     $$ = new tree_argument_list ($1);
@@ -916,45 +725,45 @@ assign_lhs      : simple_expr
                       {
                         symbol_table::force_variable (*p);
                       }
                     curr_lexer->pending_local_variables.clear ();
                   }
                 ;
 
 assign_expr     : assign_lhs '=' expression
-                  { $$ = make_assign_op ('=', $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op ('=', $1, $2, $3); }
                 | assign_lhs ADD_EQ expression
-                  { $$ = make_assign_op (ADD_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (ADD_EQ, $1, $2, $3); }
                 | assign_lhs SUB_EQ expression
-                  { $$ = make_assign_op (SUB_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (SUB_EQ, $1, $2, $3); }
                 | assign_lhs MUL_EQ expression
-                  { $$ = make_assign_op (MUL_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (MUL_EQ, $1, $2, $3); }
                 | assign_lhs DIV_EQ expression
-                  { $$ = make_assign_op (DIV_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (DIV_EQ, $1, $2, $3); }
                 | assign_lhs LEFTDIV_EQ expression
-                  { $$ = make_assign_op (LEFTDIV_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (LEFTDIV_EQ, $1, $2, $3); }
                 | assign_lhs POW_EQ expression
-                  { $$ = make_assign_op (POW_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (POW_EQ, $1, $2, $3); }
                 | assign_lhs LSHIFT_EQ expression
-                  { $$ = make_assign_op (LSHIFT_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (LSHIFT_EQ, $1, $2, $3); }
                 | assign_lhs RSHIFT_EQ expression
-                  { $$ = make_assign_op (RSHIFT_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (RSHIFT_EQ, $1, $2, $3); }
                 | assign_lhs EMUL_EQ expression
-                  { $$ = make_assign_op (EMUL_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (EMUL_EQ, $1, $2, $3); }
                 | assign_lhs EDIV_EQ expression
-                  { $$ = make_assign_op (EDIV_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (EDIV_EQ, $1, $2, $3); }
                 | assign_lhs ELEFTDIV_EQ expression
-                  { $$ = make_assign_op (ELEFTDIV_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (ELEFTDIV_EQ, $1, $2, $3); }
                 | assign_lhs EPOW_EQ expression
-                  { $$ = make_assign_op (EPOW_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (EPOW_EQ, $1, $2, $3); }
                 | assign_lhs AND_EQ expression
-                  { $$ = make_assign_op (AND_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (AND_EQ, $1, $2, $3); }
                 | assign_lhs OR_EQ expression
-                  { $$ = make_assign_op (OR_EQ, $1, $2, $3); }
+                  { $$ = curr_parser->make_assign_op (OR_EQ, $1, $2, $3); }
                 ;
 
 expression      : simple_expr
                   { $$ = $1; }
                 | assign_expr
                   { $$ = $1; }
                 | anon_fcn_handle
                   { $$ = $1; }
@@ -987,22 +796,22 @@ command         : declaration
 // =====================
 
 parsing_decl_list
                 : // empty
                   { curr_lexer->looking_at_decl_list = true; }
 
 declaration     : GLOBAL parsing_decl_list decl1
                   {
-                    $$ = make_decl_command (GLOBAL, $1, $3);
+                    $$ = curr_parser->make_decl_command (GLOBAL, $1, $3);
                     curr_lexer->looking_at_decl_list = false;
                   }
                 | PERSISTENT parsing_decl_list decl1
                   {
-                    $$ = make_decl_command (PERSISTENT, $1, $3);
+                    $$ = curr_parser->make_decl_command (PERSISTENT, $1, $3);
                     curr_lexer->looking_at_decl_list = false;
                   }
                 ;
 
 decl1           : decl2
                   { $$ = new tree_decl_init_list ($1); }
                 | decl1 decl2
                   {
@@ -1038,17 +847,17 @@ select_command  : if_command
                 ;
 
 // ============
 // If statement
 // ============
 
 if_command      : IF stash_comment if_cmd_list END
                   {
-                    if (! ($$ = finish_if_command ($1, $3, $4, $2)))
+                    if (! ($$ = curr_parser->finish_if_command ($1, $3, $4, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 if_cmd_list     : if_cmd_list1
                   { $$ = $1; }
                 | if_cmd_list1 else_clause
                   {
@@ -1056,44 +865,44 @@ if_cmd_list     : if_cmd_list1
                     $$ = $1;
                   }
                 ;
 
 if_cmd_list1    : expression opt_sep opt_list
                   {
                     $1->mark_braindead_shortcircuit (curr_fcn_file_full_name);
 
-                    $$ = start_if_command ($1, $3);
+                    $$ = curr_parser->start_if_command ($1, $3);
                   }
                 | if_cmd_list1 elseif_clause
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 elseif_clause   : ELSEIF stash_comment opt_sep expression opt_sep opt_list
                   {
                     $4->mark_braindead_shortcircuit (curr_fcn_file_full_name);
 
-                    $$ = make_elseif_clause ($1, $4, $6, $2);
+                    $$ = curr_parser->make_elseif_clause ($1, $4, $6, $2);
                   }
                 ;
 
 else_clause     : ELSE stash_comment opt_sep opt_list
                   { $$ = new tree_if_clause ($4, $2); }
                 ;
 
 // ================
 // Switch statement
 // ================
 
 switch_command  : SWITCH stash_comment expression opt_sep case_list END
                   {
-                    if (! ($$ = finish_switch_command ($1, $3, $5, $6, $2)))
+                    if (! ($$ = curr_parser->finish_switch_command ($1, $3, $5, $6, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 case_list       : // empty
                   { $$ = new tree_switch_case_list (); }
                 | default_case
                   { $$ = new tree_switch_case_list ($1); }
@@ -1111,107 +920,107 @@ case_list1      : switch_case
                 | case_list1 switch_case
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 switch_case     : CASE stash_comment opt_sep expression opt_sep opt_list
-                  { $$ = make_switch_case ($1, $4, $6, $2); }
+                  { $$ = curr_parser->make_switch_case ($1, $4, $6, $2); }
                 ;
 
 default_case    : OTHERWISE stash_comment opt_sep opt_list
                   {
                     $$ = new tree_switch_case ($4, $2);
                   }
                 ;
 
 // =======
 // Looping
 // =======
 
 loop_command    : WHILE stash_comment expression opt_sep opt_list END
                   {
                     $3->mark_braindead_shortcircuit (curr_fcn_file_full_name);
 
-                    if (! ($$ = make_while_command ($1, $3, $5, $6, $2)))
+                    if (! ($$ = curr_parser->make_while_command ($1, $3, $5, $6, $2)))
                       ABORT_PARSE;
                   }
                 | DO stash_comment opt_sep opt_list UNTIL expression
                   {
-                    if (! ($$ = make_do_until_command ($5, $4, $6, $2)))
+                    if (! ($$ = curr_parser->make_do_until_command ($5, $4, $6, $2)))
                       ABORT_PARSE;
                   }
                 | FOR stash_comment assign_lhs '=' expression opt_sep opt_list END
                   {
-                    if (! ($$ = make_for_command (FOR, $1, $3, $5, 0,
+                    if (! ($$ = curr_parser->make_for_command (FOR, $1, $3, $5, 0,
                                                   $7, $8, $2)))
                       ABORT_PARSE;
                   }
                 | FOR stash_comment '(' assign_lhs '=' expression ')' opt_sep opt_list END
                   {
-                    if (! ($$ = make_for_command (FOR, $1, $4, $6, 0,
+                    if (! ($$ = curr_parser->make_for_command (FOR, $1, $4, $6, 0,
                                                   $9, $10, $2)))
                       ABORT_PARSE;
                   }
                 | PARFOR stash_comment assign_lhs '=' expression opt_sep opt_list END
                   {
-                    if (! ($$ = make_for_command (PARFOR, $1, $3, $5,
+                    if (! ($$ = curr_parser->make_for_command (PARFOR, $1, $3, $5,
                                                   0, $7, $8, $2)))
                       ABORT_PARSE;
                   }
                 | PARFOR stash_comment '(' assign_lhs '=' expression ',' expression ')' opt_sep opt_list END
                   {
-                    if (! ($$ = make_for_command (PARFOR, $1, $4, $6,
+                    if (! ($$ = curr_parser->make_for_command (PARFOR, $1, $4, $6,
                                                   $8, $11, $12, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 // =======
 // Jumping
 // =======
 
 jump_command    : BREAK
                   {
-                    if (! ($$ = make_break_command ($1)))
+                    if (! ($$ = curr_parser->make_break_command ($1)))
                       ABORT_PARSE;
                   }
                 | CONTINUE
                   {
-                    if (! ($$ = make_continue_command ($1)))
+                    if (! ($$ = curr_parser->make_continue_command ($1)))
                       ABORT_PARSE;
                   }
                 | FUNC_RET
                   {
-                    if (! ($$ = make_return_command ($1)))
+                    if (! ($$ = curr_parser->make_return_command ($1)))
                       ABORT_PARSE;
                   }
                 ;
 
 // ==========
 // Exceptions
 // ==========
 
 except_command  : UNWIND stash_comment opt_sep opt_list CLEANUP
                   stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = make_unwind_command ($1, $4, $8, $9, $2, $6)))
+                    if (! ($$ = curr_parser->make_unwind_command ($1, $4, $8, $9, $2, $6)))
                       ABORT_PARSE;
                   }
                 | TRY stash_comment opt_sep opt_list CATCH
                   stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = make_try_command ($1, $4, $8, $9, $2, $6)))
+                    if (! ($$ = curr_parser->make_try_command ($1, $4, $8, $9, $2, $6)))
                       ABORT_PARSE;
                   }
                 | TRY stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = make_try_command ($1, $4, 0, $5, $2, 0)))
+                    if (! ($$ = curr_parser->make_try_command ($1, $4, 0, $5, $2, 0)))
                       ABORT_PARSE;
                   }
                 ;
 
 // ===========================================
 // Some 'subroutines' for function definitions
 // ===========================================
 
@@ -1334,20 +1143,21 @@ return_list1    : identifier
 
 // ===========
 // Script file
 // ===========
 
 script_file     : SCRIPT_FILE opt_list END_OF_INPUT
                   {
                     tree_statement *end_of_script
-                      = make_end ("endscript", curr_lexer->input_line_number,
-                                  curr_lexer->current_input_column);
-
-                    make_script ($2, end_of_script);
+                      = curr_parser->make_end ("endscript",
+                                               curr_lexer->input_line_number,
+                                               curr_lexer->current_input_column);
+
+                    curr_parser->make_script ($2, end_of_script);
 
                     $$ = 0;
                   }
                 ;
 
 // =============
 // Function file
 // =============
@@ -1370,23 +1180,23 @@ function_beg    : push_fcn_symtab FCN st
 
                     if (reading_classdef_file || curr_lexer->parsing_classdef)
                       curr_lexer->maybe_classdef_get_set_method = true;
                   }
                 ;
 
 function        : function_beg function1
                   {
-                    $$ = finish_function (0, $2, $1);
-                    recover_from_parsing_function ();
+                    $$ = curr_parser->finish_function (0, $2, $1);
+                    curr_parser->recover_from_parsing_function ();
                   }
                 | function_beg return_list '=' function1
                   {
-                    $$ = finish_function ($2, $4, $1);
-                    recover_from_parsing_function ();
+                    $$ = curr_parser->finish_function ($2, $4, $1);
+                    curr_parser->recover_from_parsing_function ();
                   }
                 ;
 
 fcn_name        : identifier
                   {
                     std::string id_name = $1->name ();
 
                     curr_lexer->parsed_function_name.top () = true;
@@ -1409,32 +1219,32 @@ fcn_name        : identifier
                 ;
 
 function1       : fcn_name function2
                   {
                     std::string fname = $1->name ();
 
                     delete $1;
 
-                    if (! ($$ = frob_function (fname, $2)))
+                    if (! ($$ = curr_parser->frob_function (fname, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 function2       : param_list opt_sep opt_list function_end
-                  { $$ = start_function ($1, $3, $4); }
+                  { $$ = curr_parser->start_function ($1, $3, $4); }
                 | opt_sep opt_list function_end
-                  { $$ = start_function (0, $2, $3); }
+                  { $$ = curr_parser->start_function (0, $2, $3); }
                 ;
 
 function_end    : END
                   {
                     endfunction_found = true;
-                    if (end_token_ok ($1, token::function_end))
-                      $$ = make_end ("endfunction", $1->line (), $1->column ());
+                    if (curr_parser->end_token_ok ($1, token::function_end))
+                      $$ = curr_parser->make_end ("endfunction", $1->line (), $1->column ());
                     else
                       ABORT_PARSE;
                   }
                 | END_OF_INPUT
                   {
 // A lot of tests are based on the assumption that this is OK
 //                  if (reading_script_file)
 //                    {
@@ -1458,18 +1268,19 @@ function_end    : END
                       }
 
                     if (reading_classdef_file)
                       {
                         yyerror ("classdef body open at end of input");
                         YYABORT;
                       }
 
-                    $$ = make_end ("endfunction", curr_lexer->input_line_number,
-                                   curr_lexer->current_input_column);
+                    $$ = curr_parser->make_end ("endfunction",
+                                                curr_lexer->input_line_number,
+                                                curr_lexer->current_input_column);
                   }
                 ;
 
 // ========
 // Classdef
 // ========
 
 classdef_beg    : CLASSDEF stash_comment
@@ -1478,18 +1289,18 @@ classdef_beg    : CLASSDEF stash_comment
                     curr_lexer->parsing_classdef = true;
                   }
                 ;
 
 classdef_end    : END
                   {
                     curr_lexer->parsing_classdef = false;
 
-                    if (end_token_ok ($1, token::classdef_end))
-                      $$ = make_end ("endclassdef", $1->line (), $1->column ());
+                    if (curr_parser->end_token_ok ($1, token::classdef_end))
+                      $$ = curr_parser->make_end ("endclassdef", $1->line (), $1->column ());
                     else
                       ABORT_PARSE;
                   }
                 ;
 
 classdef1       : classdef_beg opt_attr_list identifier opt_superclasses
                   { $$ = 0; }
                 ;
@@ -1724,20 +1535,27 @@ yyerror (const char *s)
 
   output_buf << "\n";
 
   std::string msg = output_buf.str ();
 
   parse_error ("%s", msg.c_str ());
 }
 
+int
+octave_parser::run (void)
+{
+  return octave_parse ();
+}
+
 // Error mesages for mismatched end tokens.
 
-static void
-end_error (const char *type, token::end_tok_type ettype, int l, int c)
+void
+octave_parser::end_error (const char *type, token::end_tok_type ettype,
+                          int l, int c)
 {
   static const char *fmt
     = "'%s' command matched by '%s' near line %d column %d";
 
   switch (ettype)
     {
     case token::simple_end:
       error (fmt, type, "end", l, c);
@@ -1778,18 +1596,18 @@ end_error (const char *type, token::end_
     default:
       panic_impossible ();
       break;
     }
 }
 
 // Check to see that end tokens are properly matched.
 
-static bool
-end_token_ok (token *tok, token::end_tok_type expected)
+bool
+octave_parser::end_token_ok (token *tok, token::end_tok_type expected)
 {
   bool retval = true;
 
   token::end_tok_type ettype = tok->ettype ();
 
   if (ettype != expected && ettype != token::simple_end)
     {
       retval = false;
@@ -1848,18 +1666,18 @@ end_token_ok (token *tok, token::end_tok
     }
 
   return retval;
 }
 
 // Maybe print a warning if an assignment expression is used as the
 // test in a logical expression.
 
-static void
-maybe_warn_assign_as_truth_value (tree_expression *expr)
+void
+octave_parser::maybe_warn_assign_as_truth_value (tree_expression *expr)
 {
   if (expr->is_assignment_expression ()
       && expr->paren_count () < 2)
     {
       if (curr_fcn_file_full_name.empty ())
         warning_with_id
           ("Octave:assign-as-truth-value",
            "suggest parenthesis around assignment used as truth value");
@@ -1868,18 +1686,18 @@ maybe_warn_assign_as_truth_value (tree_e
           ("Octave:assign-as-truth-value",
            "suggest parenthesis around assignment used as truth value near line %d, column %d in file '%s'",
            expr->line (), expr->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
 // Maybe print a warning about switch labels that aren't constants.
 
-static void
-maybe_warn_variable_switch_label (tree_expression *expr)
+void
+octave_parser::maybe_warn_variable_switch_label (tree_expression *expr)
 {
   if (! expr->is_constant ())
     {
       if (curr_fcn_file_full_name.empty ())
         warning_with_id ("Octave:variable-switch-label",
                          "variable switch label");
       else
         warning_with_id
@@ -1975,18 +1793,18 @@ fold (tree_unary_expression *e)
         }
     }
 
   return retval;
 }
 
 // Finish building a range.
 
-static tree_expression *
-finish_colon_expression (tree_colon_expression *e)
+tree_expression *
+octave_parser::finish_colon_expression (tree_colon_expression *e)
 {
   tree_expression *retval = e;
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
   frame.protect_var (warning_state);
 
@@ -2039,18 +1857,18 @@ finish_colon_expression (tree_colon_expr
         }
     }
 
   return retval;
 }
 
 // Make a constant.
 
-static tree_constant *
-make_constant (int op, token *tok_val)
+tree_constant *
+octave_parser::make_constant (int op, token *tok_val)
 {
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   tree_constant *retval = 0;
 
   switch (op)
     {
@@ -2102,31 +1920,32 @@ make_constant (int op, token *tok_val)
       break;
     }
 
   return retval;
 }
 
 // Make a function handle.
 
-static tree_fcn_handle *
-make_fcn_handle (token *tok_val)
+tree_fcn_handle *
+octave_parser::make_fcn_handle (token *tok_val)
 {
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   tree_fcn_handle *retval = new tree_fcn_handle (tok_val->text (), l, c);
 
   return retval;
 }
 
 // Make an anonymous function handle.
 
-static tree_anon_fcn_handle *
-make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt)
+tree_anon_fcn_handle *
+octave_parser::make_anon_fcn_handle (tree_parameter_list *param_list,
+                                     tree_statement *stmt)
 {
   // FIXME -- need to get these from the location of the @ symbol.
   int l = curr_lexer->input_line_number;
   int c = curr_lexer->current_input_column;
 
   tree_parameter_list *ret_list = 0;
 
   symbol_table::scope_id fcn_scope = symbol_table::current_scope ();
@@ -2148,19 +1967,19 @@ make_anon_fcn_handle (tree_parameter_lis
   // errors when executed.
   //retval->stash_file_name (curr_fcn_file_name);
 
   return retval;
 }
 
 // Build a binary expression.
 
-static tree_expression *
-make_binary_op (int op, tree_expression *op1, token *tok_val,
-                tree_expression *op2)
+tree_expression *
+octave_parser::make_binary_op (int op, tree_expression *op1, token *tok_val,
+                               tree_expression *op2)
 {
   octave_value::binary_op t = octave_value::unknown_binary_op;
 
   switch (op)
     {
     case POW:
       t = octave_value::op_pow;
       break;
@@ -2252,19 +2071,19 @@ make_binary_op (int op, tree_expression 
   tree_binary_expression *e
     = maybe_compound_binary_expression (op1, op2, l, c, t);
 
   return fold (e);
 }
 
 // Build a boolean expression.
 
-static tree_expression *
-make_boolean_op (int op, tree_expression *op1, token *tok_val,
-                 tree_expression *op2)
+tree_expression *
+octave_parser::make_boolean_op (int op, tree_expression *op1, token *tok_val,
+                                tree_expression *op2)
 {
   tree_boolean_expression::type t;
 
   switch (op)
     {
     case EXPR_AND_AND:
       t = tree_boolean_expression::bool_and;
       break;
@@ -2284,18 +2103,18 @@ make_boolean_op (int op, tree_expression
   tree_boolean_expression *e
     = new tree_boolean_expression (op1, op2, l, c, t);
 
   return fold (e);
 }
 
 // Build a prefix expression.
 
-static tree_expression *
-make_prefix_op (int op, tree_expression *op1, token *tok_val)
+tree_expression *
+octave_parser::make_prefix_op (int op, tree_expression *op1, token *tok_val)
 {
   octave_value::unary_op t = octave_value::unknown_unary_op;
 
   switch (op)
     {
     case EXPR_NOT:
       t = octave_value::op_not;
       break;
@@ -2327,18 +2146,18 @@ make_prefix_op (int op, tree_expression 
   tree_prefix_expression *e
     = new tree_prefix_expression (op1, l, c, t);
 
   return fold (e);
 }
 
 // Build a postfix expression.
 
-static tree_expression *
-make_postfix_op (int op, tree_expression *op1, token *tok_val)
+tree_expression *
+octave_parser::make_postfix_op (int op, tree_expression *op1, token *tok_val)
 {
   octave_value::unary_op t = octave_value::unknown_unary_op;
 
   switch (op)
     {
     case QUOTE:
       t = octave_value::op_hermitian;
       break;
@@ -2366,66 +2185,71 @@ make_postfix_op (int op, tree_expression
   tree_postfix_expression *e
     = new tree_postfix_expression (op1, l, c, t);
 
   return fold (e);
 }
 
 // Build an unwind-protect command.
 
-static tree_command *
-make_unwind_command (token *unwind_tok, tree_statement_list *body,
-                     tree_statement_list *cleanup, token *end_tok,
-                     octave_comment_list *lc, octave_comment_list *mc)
+tree_command *
+octave_parser::make_unwind_command (token *unwind_tok,
+                                    tree_statement_list *body,
+                                    tree_statement_list *cleanup_stmts,
+                                    token *end_tok,
+                                    octave_comment_list *lc,
+                                    octave_comment_list *mc)
 {
   tree_command *retval = 0;
 
   if (end_token_ok (end_tok, token::unwind_protect_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = unwind_tok->line ();
       int c = unwind_tok->column ();
 
-      retval = new tree_unwind_protect_command (body, cleanup,
+      retval = new tree_unwind_protect_command (body, cleanup_stmts,
                                                 lc, mc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a try-catch command.
 
-static tree_command *
-make_try_command (token *try_tok, tree_statement_list *body,
-                  tree_statement_list *cleanup, token *end_tok,
-                  octave_comment_list *lc, octave_comment_list *mc)
+tree_command *
+octave_parser::make_try_command (token *try_tok, tree_statement_list *body,
+                                 tree_statement_list *cleanup_stmts,
+                                 token *end_tok,
+                                 octave_comment_list *lc,
+                                 octave_comment_list *mc)
 {
   tree_command *retval = 0;
 
   if (end_token_ok (end_tok, token::try_catch_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = try_tok->line ();
       int c = try_tok->column ();
 
-      retval = new tree_try_catch_command (body, cleanup,
+      retval = new tree_try_catch_command (body, cleanup_stmts,
                                            lc, mc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a while command.
 
-static tree_command *
-make_while_command (token *while_tok, tree_expression *expr,
-                    tree_statement_list *body, token *end_tok,
-                    octave_comment_list *lc)
+tree_command *
+octave_parser::make_while_command (token *while_tok, tree_expression *expr,
+                                   tree_statement_list *body, token *end_tok,
+                                   octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   if (end_token_ok (end_tok, token::while_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
@@ -2438,19 +2262,21 @@ make_while_command (token *while_tok, tr
       retval = new tree_while_command (expr, body, lc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a do-until command.
 
-static tree_command *
-make_do_until_command (token *until_tok, tree_statement_list *body,
-                       tree_expression *expr, octave_comment_list *lc)
+tree_command *
+octave_parser::make_do_until_command (token *until_tok,
+                                      tree_statement_list *body,
+                                      tree_expression *expr,
+                                      octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
   curr_lexer->looping--;
@@ -2460,21 +2286,23 @@ make_do_until_command (token *until_tok,
 
   retval = new tree_do_until_command (expr, body, lc, tc, l, c);
 
   return retval;
 }
 
 // Build a for command.
 
-static tree_command *
-make_for_command (int tok_id, token *for_tok, tree_argument_list *lhs,
-                  tree_expression *expr, tree_expression *maxproc,
-                  tree_statement_list *body, token *end_tok,
-                  octave_comment_list *lc)
+tree_command *
+octave_parser::make_for_command (int tok_id, token *for_tok,
+                                 tree_argument_list *lhs,
+                                 tree_expression *expr,
+                                 tree_expression *maxproc,
+                                 tree_statement_list *body, token *end_tok,
+                                 octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   bool parfor = tok_id == PARFOR;
 
   if (end_token_ok (end_tok, parfor ? token::parfor_end : token::for_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
@@ -2503,76 +2331,77 @@ make_for_command (int tok_id, token *for
         }
     }
 
   return retval;
 }
 
 // Build a break command.
 
-static tree_command *
-make_break_command (token *break_tok)
+tree_command *
+octave_parser::make_break_command (token *break_tok)
 {
   tree_command *retval = 0;
 
   int l = break_tok->line ();
   int c = break_tok->column ();
 
   retval = new tree_break_command (l, c);
 
   return retval;
 }
 
 // Build a continue command.
 
-static tree_command *
-make_continue_command (token *continue_tok)
+tree_command *
+octave_parser::make_continue_command (token *continue_tok)
 {
   tree_command *retval = 0;
 
   int l = continue_tok->line ();
   int c = continue_tok->column ();
 
   retval = new tree_continue_command (l, c);
 
   return retval;
 }
 
 // Build a return command.
 
-static tree_command *
-make_return_command (token *return_tok)
+tree_command *
+octave_parser::make_return_command (token *return_tok)
 {
   tree_command *retval = 0;
 
   int l = return_tok->line ();
   int c = return_tok->column ();
 
   retval = new tree_return_command (l, c);
 
   return retval;
 }
 
 // Start an if command.
 
-static tree_if_command_list *
-start_if_command (tree_expression *expr, tree_statement_list *list)
+tree_if_command_list *
+octave_parser::start_if_command (tree_expression *expr,
+                                 tree_statement_list *list)
 {
   maybe_warn_assign_as_truth_value (expr);
 
   tree_if_clause *t = new tree_if_clause (expr, list);
 
   return new tree_if_command_list (t);
 }
 
 // Finish an if command.
 
-static tree_if_command *
-finish_if_command (token *if_tok, tree_if_command_list *list,
-                   token *end_tok, octave_comment_list *lc)
+tree_if_command *
+octave_parser::finish_if_command (token *if_tok, tree_if_command_list *list,
+                                  token *end_tok, octave_comment_list *lc)
 {
   tree_if_command *retval = 0;
 
   if (end_token_ok (end_tok, token::if_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = if_tok->line ();
@@ -2592,34 +2421,35 @@ finish_if_command (token *if_tok, tree_i
       retval = new tree_if_command (list, lc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build an elseif clause.
 
-static tree_if_clause *
-make_elseif_clause (token *elseif_tok, tree_expression *expr,
-                    tree_statement_list *list, octave_comment_list *lc)
+tree_if_clause *
+octave_parser::make_elseif_clause (token *elseif_tok, tree_expression *expr,
+                                   tree_statement_list *list,
+                                   octave_comment_list *lc)
 {
   maybe_warn_assign_as_truth_value (expr);
 
   int l = elseif_tok->line ();
   int c = elseif_tok->column ();
 
   return new tree_if_clause (expr, list, lc, l, c);
 }
 
 // Finish a switch command.
 
-static tree_switch_command *
-finish_switch_command (token *switch_tok, tree_expression *expr,
-                       tree_switch_case_list *list, token *end_tok,
-                       octave_comment_list *lc)
+tree_switch_command *
+octave_parser::finish_switch_command (token *switch_tok, tree_expression *expr,
+                                      tree_switch_case_list *list,
+                                      token *end_tok, octave_comment_list *lc)
 {
   tree_switch_command *retval = 0;
 
   if (end_token_ok (end_tok, token::switch_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = switch_tok->line ();
@@ -2639,33 +2469,34 @@ finish_switch_command (token *switch_tok
       retval = new tree_switch_command (expr, list, lc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a switch case.
 
-static tree_switch_case *
-make_switch_case (token *case_tok, tree_expression *expr,
-                  tree_statement_list *list, octave_comment_list *lc)
+tree_switch_case *
+octave_parser::make_switch_case (token *case_tok, tree_expression *expr,
+                                 tree_statement_list *list,
+                                 octave_comment_list *lc)
 {
   maybe_warn_variable_switch_label (expr);
 
   int l = case_tok->line ();
   int c = case_tok->column ();
 
   return new tree_switch_case (expr, list, lc, l, c);
 }
 
 // Build an assignment to a variable.
 
-static tree_expression *
-make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
-                tree_expression *rhs)
+tree_expression *
+octave_parser::make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
+                               tree_expression *rhs)
 {
   tree_expression *retval = 0;
 
   octave_value::assign_op t = octave_value::unknown_assign_op;
 
   switch (op)
     {
     case '=':
@@ -2749,18 +2580,19 @@ make_assign_op (int op, tree_argument_li
   else
     yyerror ("computed multiple assignment not allowed");
 
   return retval;
 }
 
 // Define a script.
 
-static void
-make_script (tree_statement_list *cmds, tree_statement *end_script)
+void
+octave_parser::make_script (tree_statement_list *cmds,
+                            tree_statement *end_script)
 {
   std::string doc_string;
 
   if (! help_buf.empty ())
     {
       doc_string = help_buf.top ();
       help_buf.pop ();
     }
@@ -2783,19 +2615,20 @@ make_script (tree_statement_list *cmds, 
   // Unmark any symbols that may have been tagged as local variables
   // while parsing (for example, by force_local_variable in lex.l).
 
   symbol_table::unmark_forced_variables ();
 }
 
 // Begin defining a function.
 
-static octave_user_function *
-start_function (tree_parameter_list *param_list, tree_statement_list *body,
-                tree_statement *end_fcn_stmt)
+octave_user_function *
+octave_parser::start_function (tree_parameter_list *param_list,
+                               tree_statement_list *body,
+                               tree_statement *end_fcn_stmt)
 {
   // We'll fill in the return list later.
 
   if (! body)
     body = new tree_statement_list ();
 
   body->append (end_fcn_stmt);
 
@@ -2808,26 +2641,27 @@ start_function (tree_parameter_list *par
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       fcn->stash_trailing_comment (tc);
     }
 
   return fcn;
 }
 
-static tree_statement *
-make_end (const std::string& type, int l, int c)
+tree_statement *
+octave_parser::make_end (const std::string& type, int l, int c)
 {
   return make_statement (new tree_no_op_command (type, l, c));
 }
 
 // Do most of the work for defining a function.
 
-static octave_user_function *
-frob_function (const std::string& fname, octave_user_function *fcn)
+octave_user_function *
+octave_parser::frob_function (const std::string& fname,
+                              octave_user_function *fcn)
 {
   std::string id_name = fname;
 
   // If input is coming from a file, issue a warning if the name of
   // the file does not match the name of the function stated in the
   // file.  Matlab doesn't provide a diagnostic (it ignores the stated
   // name).
   if (! autoloading && reading_fcn_file
@@ -2916,19 +2750,20 @@ frob_function (const std::string& fname,
 
   if (reading_fcn_file && current_function_depth == 1
       && ! parsing_subfunctions)
     primary_fcn_ptr = fcn;
 
   return fcn;
 }
 
-static tree_function_def *
-finish_function (tree_parameter_list *ret_list,
-                 octave_user_function *fcn, octave_comment_list *lc)
+tree_function_def *
+octave_parser::finish_function (tree_parameter_list *ret_list,
+                                octave_user_function *fcn,
+                                octave_comment_list *lc)
 {
   tree_function_def *retval = 0;
 
   if (ret_list)
     ret_list->mark_as_formal_parameters ();
 
   if (fcn)
     {
@@ -2986,18 +2821,18 @@ finish_function (tree_parameter_list *re
       // in lex.l).
 
       symbol_table::unmark_forced_variables (fcn->scope ());
     }
 
   return retval;
 }
 
-static void
-recover_from_parsing_function (void)
+void
+octave_parser::recover_from_parsing_function (void)
 {
   if (parser_symtab_context.empty ())
     panic_impossible ();
 
   parser_symtab_context.pop ();
 
   if (reading_fcn_file && current_function_depth == 1
       && ! parsing_subfunctions)
@@ -3009,19 +2844,19 @@ recover_from_parsing_function (void)
   curr_lexer->defining_func--;
   curr_lexer->parsed_function_name.pop ();
   curr_lexer->looking_at_return_list = false;
   curr_lexer->looking_at_parameter_list = false;
 }
 
 // Make an index expression.
 
-static tree_index_expression *
-make_index_expression (tree_expression *expr, tree_argument_list *args,
-                       char type)
+tree_index_expression *
+octave_parser::make_index_expression (tree_expression *expr,
+                                      tree_argument_list *args, char type)
 {
   tree_index_expression *retval = 0;
 
   if (args && args->has_magic_tilde ())
     {
       yyerror ("invalid use of empty argument (~) in index expression");
       return retval;
     }
@@ -3042,18 +2877,19 @@ make_index_expression (tree_expression *
   else
     retval = new tree_index_expression (expr, args, l, c, type);
 
   return retval;
 }
 
 // Make an indirect reference expression.
 
-static tree_index_expression *
-make_indirect_ref (tree_expression *expr, const std::string& elt)
+tree_index_expression *
+octave_parser::make_indirect_ref (tree_expression *expr,
+                                  const std::string& elt)
 {
   tree_index_expression *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
   if (expr->is_index_expression ())
     {
@@ -3068,18 +2904,18 @@ make_indirect_ref (tree_expression *expr
 
   curr_lexer->looking_at_indirect_ref = false;
 
   return retval;
 }
 
 // Make an indirect reference expression with dynamic field name.
 
-static tree_index_expression *
-make_indirect_ref (tree_expression *expr, tree_expression *elt)
+tree_index_expression *
+octave_parser::make_indirect_ref (tree_expression *expr, tree_expression *elt)
 {
   tree_index_expression *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
   if (expr->is_index_expression ())
     {
@@ -3094,18 +2930,19 @@ make_indirect_ref (tree_expression *expr
 
   curr_lexer->looking_at_indirect_ref = false;
 
   return retval;
 }
 
 // Make a declaration command.
 
-static tree_decl_command *
-make_decl_command (int tok, token *tok_val, tree_decl_init_list *lst)
+tree_decl_command *
+octave_parser::make_decl_command (int tok, token *tok_val,
+                                  tree_decl_init_list *lst)
 {
   tree_decl_command *retval = 0;
 
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   switch (tok)
     {
@@ -3129,28 +2966,28 @@ make_decl_command (int tok, token *tok_v
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
-static tree_argument_list *
-validate_matrix_row (tree_argument_list *row)
+tree_argument_list *
+octave_parser::validate_matrix_row (tree_argument_list *row)
 {
   if (row && row->has_magic_tilde ())
     yyerror ("invalid use of tilde (~) in matrix expression");
   return row;
 }
 
 // Finish building a matrix list.
 
-static tree_expression *
-finish_matrix (tree_matrix *m)
+tree_expression *
+octave_parser::finish_matrix (tree_matrix *m)
 {
   tree_expression *retval = m;
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
   frame.protect_var (warning_state);
 
@@ -3183,40 +3020,40 @@ finish_matrix (tree_matrix *m)
         }
     }
 
   return retval;
 }
 
 // Finish building a cell list.
 
-static tree_expression *
-finish_cell (tree_cell *c)
+tree_expression *
+octave_parser::finish_cell (tree_cell *c)
 {
   return finish_matrix (c);
 }
 
-static void
-maybe_warn_missing_semi (tree_statement_list *t)
+void
+octave_parser::maybe_warn_missing_semi (tree_statement_list *t)
 {
   if (current_function_depth > 0)
     {
       tree_statement *tmp = t->back ();
 
       if (tmp->is_expression ())
         warning_with_id
           ("Octave:missing-semicolon",
            "missing semicolon near line %d, column %d in file '%s'",
             tmp->line (), tmp->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
-static tree_statement_list *
-set_stmt_print_flag (tree_statement_list *list, char sep,
-                     bool warn_missing_semi)
+tree_statement_list *
+octave_parser::set_stmt_print_flag (tree_statement_list *list, char sep,
+                                    bool warn_missing_semi)
 {
   tree_statement *tmp = list->back ();
 
   switch (sep)
     {
     case ';':
       tmp->set_print_flag (false);
       break;
@@ -3241,25 +3078,26 @@ set_stmt_print_flag (tree_statement_list
     {
       list->pop_back ();
       delete tmp;
     }
 
   return list;
 }
 
-static tree_statement_list *
-make_statement_list (tree_statement *stmt)
+tree_statement_list *
+octave_parser::make_statement_list (tree_statement *stmt)
 {
   return new tree_statement_list (stmt);
 }
 
-static tree_statement_list *
-append_statement_list (tree_statement_list *list, char sep,
-                       tree_statement *stmt, bool warn_missing_semi)
+tree_statement_list *
+octave_parser::append_statement_list (tree_statement_list *list, char sep,
+                                      tree_statement *stmt,
+                                      bool warn_missing_semi)
 {
   set_stmt_print_flag (list, sep, warn_missing_semi);
 
   list->append (stmt);
 
   return list;
 }
 
@@ -3495,20 +3333,24 @@ parse_fcn_file (const std::string& ff, c
 
   frame.add_fcn (safe_fclose, ffile);
 
   if (ffile)
     {
       bool eof;
 
       frame.protect_var (curr_lexer);
-
       curr_lexer = new lexical_feedback ();
-
-      reset_parser ();
+      frame.add_fcn (lexical_feedback::cleanup, curr_lexer);
+
+      frame.protect_var (curr_parser);
+      curr_parser = new octave_parser ();
+      frame.add_fcn (octave_parser::cleanup, curr_parser);
+
+      curr_parser->reset ();
 
       std::string help_txt = gobble_leading_white_space (ffile, eof);
 
       if (! help_txt.empty ())
         help_buf.push (help_txt);
 
       if (! eof)
         {
@@ -3573,47 +3415,47 @@ parse_fcn_file (const std::string& ff, c
           // interrupt.
           symbol_table::scope_id scope = symbol_table::top_scope ();
           frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
           if (! help_txt.empty ())
             help_buf.push (help_txt);
 
           if (reading_script_file)
-            prep_lexer_for_script_file ();
+            curr_lexer->prep_for_script_file ();
           else
-            prep_lexer_for_function_file ();
+            curr_lexer->prep_for_function_file ();
 
           curr_lexer->parsing_class_method = ! dispatch_type.empty ();
 
           frame.protect_var (global_command);
 
           global_command = 0;
 
-          int status = octave_parse_input ();
+          int status = curr_parser->run ();
 
           // Use an unwind-protect cleanup function so that the
           // global_command list will be deleted in the event of an
           // interrupt.
 
           frame.add_fcn (cleanup_statement_list, &global_command);
 
           fcn_ptr = primary_fcn_ptr;
 
           if (status != 0)
             error ("parse error while reading %s file %s",
                    file_type.c_str (), ff.c_str ());
         }
       else
         {
           tree_statement *end_of_script
-            = make_end ("endscript", curr_lexer->input_line_number,
-                        curr_lexer->current_input_column);
-
-          make_script (0, end_of_script);
+            = curr_parser->make_end ("endscript", curr_lexer->input_line_number,
+                                     curr_lexer->current_input_column);
+
+          curr_parser->make_script (0, end_of_script);
 
           fcn_ptr = primary_fcn_ptr;
         }
     }
   else if (require_file)
     error ("no such file, '%s'", ff.c_str ());
   else if (! warn_for.empty ())
     error ("%s: unable to open file '%s'", warn_for.c_str (), ff.c_str ());
@@ -4301,31 +4143,35 @@ another function for the given type sign
 octave_value_list
 eval_string (const std::string& s, bool silent, int& parse_status, int nargout)
 {
   octave_value_list retval;
 
   unwind_protect frame;
 
   frame.protect_var (curr_lexer);
+  curr_lexer = new lexical_feedback ();
+  frame.add_fcn (lexical_feedback::cleanup, curr_lexer);
+
+  frame.protect_var (curr_parser);
+  curr_parser = new octave_parser ();
+  frame.add_fcn (octave_parser::cleanup, curr_parser);
 
   frame.protect_var (get_input_from_eval_string);
   frame.protect_var (line_editing);
   frame.protect_var (current_eval_string);
   frame.protect_var (current_function_depth);
   frame.protect_var (function_scopes);
   frame.protect_var (max_function_depth);
   frame.protect_var (parsing_subfunctions);
   frame.protect_var (endfunction_found);
   frame.protect_var (reading_fcn_file);
   frame.protect_var (reading_script_file);
   frame.protect_var (reading_classdef_file);
 
-  curr_lexer = new lexical_feedback ();
-
   get_input_from_eval_string = true;
   line_editing = false;
   current_function_depth = 0;
   function_scopes.clear ();
   max_function_depth = 0;
   parsing_subfunctions = false;
   endfunction_found = false;
   reading_fcn_file = false;
@@ -4339,29 +4185,29 @@ eval_string (const std::string& s, bool 
 
   frame.add_fcn (switch_to_buffer, old_buf);
   frame.add_fcn (delete_buffer, new_buf);
 
   switch_to_buffer (new_buf);
 
   do
     {
-      reset_parser ();
+      curr_parser->reset ();
 
       frame.protect_var (global_command);
 
       global_command = 0;
 
       // Do this with an unwind-protect cleanup function so that the
       // forced variables will be unmarked in the event of an
       // interrupt.
       symbol_table::scope_id scope = symbol_table::top_scope ();
       frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
-      parse_status = octave_parse_input ();
+      parse_status = curr_parser->run ();
 
       tree_statement_list *command_list = global_command;
 
       // Unmark forced variables.
       // Restore previous value of global_command.
       frame.run (2);
 
       if (parse_status == 0)
@@ -4413,17 +4259,17 @@ eval_string (const std::string& s, bool 
                 error ("eval: invalid use of statement list");
 
               if (error_state
                   || tree_return_command::returning
                   || tree_break_command::breaking
                   || tree_continue_command::continuing)
                 break;
             }
-          else if (curr_lexer->parser_end_of_input)
+          else if (curr_parser->end_of_input)
             break;
         }
     }
   while (parse_status == 0);
 
   return retval;
 }
 
@@ -4460,22 +4306,16 @@ cleanup_statement_list (tree_statement_l
 {
   if (*lst)
     {
       delete *lst;
       *lst = 0;
     }
 }
 
-int
-octave_parse_input (void)
-{
-  return octave_parse ();
-}
-
 DEFUN (eval, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} eval (@var{try})\n\
 @deftypefnx {Built-in Function} {} eval (@var{try}, @var{catch})\n\
 Parse the string @var{try} and evaluate it as if it were an Octave\n\
 program.  If that fails, evaluate the optional string @var{catch}.\n\
 The string @var{try} is evaluated in the current context,\n\
 so any results remain available after @code{eval} returns.\n\
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -24,24 +24,50 @@ along with Octave; see the file COPYING.
 #define octave_parse_h 1
 
 #include <cstdio>
 
 #include <string>
 
 #include <stack>
 
-extern void reset_parser (void);
+#include "lex.h"
+#include "token.h"
+
 extern int octave_lex (void);
 
+class octave_comment_list;
+class octave_function;
+class octave_user_function;
 class tree;
-class tree_matrix;
+class tree_anon_fcn_handle;
+class tree_argument_list;
+class tree_cell;
+class tree_colon_expression;
+class tree_command;
+class tree_constant;
+class tree_decl_command;
+class tree_decl_init_list;
+class tree_expression;
+class tree_fcn_handle;
+class tree_function_def;
 class tree_identifier;
+class tree_if_clause;
+class tree_if_command;
+class tree_if_command_list;
+class tree_index_expression;
+class tree_matrix;
+class tree_matrix;
+class tree_parameter_list;
+class tree_statement;
 class tree_statement_list;
-class octave_function;
+class tree_statement_listtree_statement;
+class tree_switch_case;
+class tree_switch_case_list;
+class tree_switch_command;
 
 #include "oct-obj.h"
 
 // Nonzero means print parser debugging info (-d).
 extern int octave_debug;
 
 // Buffer for help text snagged from function files.
 extern std::stack<std::string> help_buf;
@@ -101,11 +127,221 @@ feval (const octave_value_list& args, in
 extern OCTINTERP_API octave_value_list
 eval_string (const std::string&, bool silent, int& parse_status, int hargout);
 
 extern OCTINTERP_API octave_value
 eval_string (const std::string&, bool silent, int& parse_status);
 
 extern OCTINTERP_API void cleanup_statement_list (tree_statement_list **lst);
 
-extern OCTINTERP_API int octave_parse_input (void);
+class
+octave_parser
+{
+public:
+
+  octave_parser (void) : end_of_input (false) { }
+
+  ~octave_parser (void) { }
+
+  void reset (void)
+  {
+    curr_lexer->reset ();
+  }
+
+  int run (void);
+
+  // Error mesages for mismatched end tokens.
+  void end_error (const char *type, token::end_tok_type ettype, int l, int c);
+
+  // Check to see that end tokens are properly matched.
+  bool end_token_ok (token *tok, token::end_tok_type expected);
+
+  // Maybe print a warning if an assignment expression is used as the
+  // test in a logical expression.
+  void maybe_warn_assign_as_truth_value (tree_expression *expr);
+
+  // Maybe print a warning about switch labels that aren't constants.
+  void maybe_warn_variable_switch_label (tree_expression *expr);
+
+  // Finish building a range.
+  tree_expression *finish_colon_expression (tree_colon_expression *e);
+
+  // Build a constant.
+  tree_constant *make_constant (int op, token *tok_val);
+
+  // Build a function handle.
+  tree_fcn_handle *make_fcn_handle (token *tok_val);
+
+  // Build an anonymous function handle.
+  tree_anon_fcn_handle *
+  make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt);
+
+  // Build a binary expression.
+  tree_expression *
+  make_binary_op (int op, tree_expression *op1, token *tok_val,
+                  tree_expression *op2);
+
+  // Build a boolean expression.
+  tree_expression *
+  make_boolean_op (int op, tree_expression *op1, token *tok_val,
+                   tree_expression *op2);
+
+  // Build a prefix expression.
+  tree_expression *
+  make_prefix_op (int op, tree_expression *op1, token *tok_val);
+
+  // Build a postfix expression.
+  tree_expression *
+  make_postfix_op (int op, tree_expression *op1, token *tok_val);
+
+  // Build an unwind-protect command.
+  tree_command *
+  make_unwind_command (token *unwind_tok, tree_statement_list *body,
+                       tree_statement_list *cleanup, token *end_tok,
+                       octave_comment_list *lc, octave_comment_list *mc);
+
+  // Build a try-catch command.
+  tree_command *
+  make_try_command (token *try_tok, tree_statement_list *body,
+                    tree_statement_list *cleanup, token *end_tok,
+                    octave_comment_list *lc, octave_comment_list *mc);
+
+  // Build a while command.
+  tree_command *
+  make_while_command (token *while_tok, tree_expression *expr,
+                      tree_statement_list *body, token *end_tok,
+                      octave_comment_list *lc);
+
+  // Build a do-until command.
+  tree_command *
+  make_do_until_command (token *until_tok, tree_statement_list *body,
+                         tree_expression *expr, octave_comment_list *lc);
+
+  // Build a for command.
+  tree_command *
+  make_for_command (int tok_id, token *for_tok, tree_argument_list *lhs,
+                    tree_expression *expr, tree_expression *maxproc,
+                    tree_statement_list *body, token *end_tok,
+                    octave_comment_list *lc);
+
+  // Build a break command.
+  tree_command *make_break_command (token *break_tok);
+
+  // Build a continue command.
+  tree_command *make_continue_command (token *continue_tok);
+
+  // Build a return command.
+  tree_command *make_return_command (token *return_tok);
+
+  // Start an if command.
+  tree_if_command_list *
+  start_if_command (tree_expression *expr, tree_statement_list *list);
+
+  // Finish an if command.
+  tree_if_command *
+  finish_if_command (token *if_tok, tree_if_command_list *list,
+                     token *end_tok, octave_comment_list *lc);
+
+  // Build an elseif clause.
+  tree_if_clause *
+  make_elseif_clause (token *elseif_tok, tree_expression *expr,
+                      tree_statement_list *list, octave_comment_list *lc);
+
+  // Finish a switch command.
+  tree_switch_command *
+  finish_switch_command (token *switch_tok, tree_expression *expr,
+                         tree_switch_case_list *list, token *end_tok,
+                         octave_comment_list *lc);
+
+  // Build a switch case.
+  tree_switch_case *
+  make_switch_case (token *case_tok, tree_expression *expr,
+                    tree_statement_list *list, octave_comment_list *lc);
+
+  // Build an assignment to a variable.
+  tree_expression *
+  make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
+                  tree_expression *rhs);
+
+  // Define a script.
+  void make_script (tree_statement_list *cmds, tree_statement *end_script);
+
+  // Begin defining a function.
+  octave_user_function *
+  start_function (tree_parameter_list *param_list, tree_statement_list *body,
+                  tree_statement *end_function);
+
+  // Create a no-op statement for end_function.
+  tree_statement *make_end (const std::string& type, int l, int c);
+
+  // Do most of the work for defining a function.
+  octave_user_function *
+  frob_function (const std::string& fname, octave_user_function *fcn);
+
+  // Finish defining a function.
+  tree_function_def *
+  finish_function (tree_parameter_list *ret_list,
+                   octave_user_function *fcn, octave_comment_list *lc);
+
+  // Reset state after parsing function.
+  void
+  recover_from_parsing_function (void);
+
+  // Make an index expression.
+  tree_index_expression *
+  make_index_expression (tree_expression *expr,
+                         tree_argument_list *args, char type);
+
+  // Make an indirect reference expression.
+  tree_index_expression *
+  make_indirect_ref (tree_expression *expr, const std::string&);
+
+  // Make an indirect reference expression with dynamic field name.
+  tree_index_expression *
+  make_indirect_ref (tree_expression *expr, tree_expression *field);
+
+  // Make a declaration command.
+  tree_decl_command *
+  make_decl_command (int tok, token *tok_val, tree_decl_init_list *lst);
+
+  // Validate argument list forming a matrix or cell row.
+  tree_argument_list *validate_matrix_row (tree_argument_list *row);
+
+  // Finish building a matrix list.
+  tree_expression *finish_matrix (tree_matrix *m);
+
+  // Finish building a cell list.
+  tree_expression *finish_cell (tree_cell *c);
+
+  // Maybe print a warning.  Duh.
+  void maybe_warn_missing_semi (tree_statement_list *);
+
+  // Set the print flag for a statement based on the separator type.
+  tree_statement_list *
+  set_stmt_print_flag (tree_statement_list *, char, bool);
+
+  // Create a statement list.
+  tree_statement_list *make_statement_list (tree_statement *stmt);
+
+  // Append a statement to an existing statement list.
+  tree_statement_list *
+  append_statement_list (tree_statement_list *list, char sep,
+                         tree_statement *stmt, bool warn_missing_semi);
+
+  // TRUE means that we have encountered EOF on the input stream.
+  bool end_of_input;
+
+  // For unwind protect.
+  static void cleanup (octave_parser *parser) { delete parser; }
+
+private:
+
+  // No copying!
+
+  octave_parser (const octave_parser&);
+
+  octave_parser& operator = (const octave_parser&);
+};
+
+// The current state of the parser.
+extern octave_parser *curr_parser;
 
 #endif
diff --git a/libinterp/parse-tree/token.h b/libinterp/parse-tree/token.h
--- a/libinterp/parse-tree/token.h
+++ b/libinterp/parse-tree/token.h
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_token_h)
 #define octave_token_h 1
 
 #include <string>
 
+#include "symtab.h"
+
 class
 token
 {
 public:
 
   enum token_type
     {
       generic_token,
