# HG changeset patch
# User Rik <rik@octave.org>
# Date 1450808962 28800
#      Tue Dec 22 10:29:22 2015 -0800
# Node ID 3aa293be0e8d907b61920a14f8fb92c1b7fc6fa0
# Parent  f55251db08334d09c96fbfd1d2218185ad7f0ce9
maint: Invert simple conditionals in if/else/error paradigm.
Invert conditional in if statement and place error next to if.
Delete else, and decrease code indent by 4.

* cellfun.cc, data.cc, debug.cc, dirfns.cc, dynamic-ld.cc, file-io.cc,
gl2ps-renderer.cc, graphics.cc, graphics.in.h, hex2num.cc, load-save.cc,
ls-mat-ascii.cc, ls-oct-text.cc, oct-hist.cc, oct-lvalue.cc, oct-map.cc,
toplev.cc, __init_fltk__.cc, ov-base-int.cc, ov-bool-mat.cc, ov-cell.cc,
ov-class.cc, ov-classdef.cc, ov-cx-mat.cc, ov-fcn-handle.cc, ov-flt-cx-mat.cc,
ov-flt-re-mat.cc, ov-oncleanup.cc, ov-re-mat.cc, ov-str-mat.cc, ov-struct.cc,
ov-usr-fcn.cc, ov.cc, pt-arg-list.cc, pt-assign.cc, pt-colon.cc, pt-eval.cc,
pt-exp.cc:
Invert conditional in if statement and place error next to if.
Delete else, and decrease code indent by 4.

diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -1716,35 +1716,33 @@ static Cell
 do_object2cell (const octave_value& obj, const Array<int>& dimv)
 {
   Cell retval;
 
   // FIXME: this copy is only needed because the octave_value::size
   // method is not const.
   octave_value array = obj;
 
-  if (dimv.is_empty ())
-    {
-      dim_vector dv = get_object_dims (array);
+  if (! dimv.is_empty ())
+    error ("num2cell (A, dim) not implemented for class objects");
 
-      retval.resize (dv);
+  dim_vector dv = get_object_dims (array);
 
-      octave_value_list idx (1);
+  retval.resize (dv);
+
+  octave_value_list idx (1);
 
-      for (octave_idx_type i = 0; i < dv.numel (); i++)
-        {
-          octave_quit ();
-
-          idx(0) = double (i+1);
+  for (octave_idx_type i = 0; i < dv.numel (); i++)
+    {
+      octave_quit ();
 
-          retval.xelem (i) = array.single_subsref ("(", idx);
-        }
+      idx(0) = double (i+1);
+
+      retval.xelem (i) = array.single_subsref ("(", idx);
     }
-  else
-    error ("num2cell (A, dim) not implemented for class objects");
 
   return retval;
 }
 
 DEFUN (num2cell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{C} =} num2cell (@var{A})\n\
 @deftypefnx {} {@var{C} =} num2cell (@var{A}, @var{dim})\n\
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1806,38 +1806,36 @@ attempt_type_conversion (const octave_va
     }
   else
     {
       // No conversion function available.  Try the constructor for the
       // dispatch type.
 
       fcn = symbol_table::find_method (dtype, dtype);
 
-      if (fcn.is_defined ())
+      if (! fcn.is_defined ())
+        error ("no constructor for %s!", dtype.c_str ());
+
+      octave_value_list result;
+
+      try
         {
-          octave_value_list result;
-
-          try
-            {
-              result = fcn.do_multi_index_op (1, octave_value_list (1, ov));
-            }
-          catch (octave_execution_exception& e)
-            {
-              error (e, "%s constructor failed for %s argument", dtype.c_str (),
-                     cname.c_str ());
-            }
-
-          if (result.length () > 0)
-            retval = result(0);
-          else
-            error ("%s constructor failed for %s argument", dtype.c_str (),
-                   cname.c_str ());
+          result = fcn.do_multi_index_op (1, octave_value_list (1, ov));
+        }
+      catch (octave_execution_exception& e)
+        {
+          error (e, "%s constructor failed for %s argument", dtype.c_str (),
+                 cname.c_str ());
         }
+
+      if (result.length () > 0)
+        retval = result(0);
       else
-        error ("no constructor for %s!", dtype.c_str ());
+        error ("%s constructor failed for %s argument", dtype.c_str (),
+               cname.c_str ());
     }
 
   return retval;
 }
 
 octave_value
 do_class_concat (const octave_value_list& ovl, std::string cattype, int dim)
 {
@@ -6679,17 +6677,17 @@ Undocumented internal function.\n\
   if (nargin > 1)
     {
       std::string mode = args(1).string_value ();
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
-          error ("__sort_rows_idx__: MODE must be either \"ascend\" or \"descend\"");
+        error ("__sort_rows_idx__: MODE must be either \"ascend\" or \"descend\"");
     }
 
   octave_value arg = args(0);
 
   if (arg.is_sparse_type ())
     error ("__sort_rows_idx__: sparse matrices not yet supported");
 
   if (arg.ndims () != 2)
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -78,23 +78,21 @@ snarf_file (const std::string& fname)
       std::ifstream file (fname.c_str (), std::ios::in|std::ios::binary);
 
       if (file)
         {
           std::string buf (sz+1, 0);
 
           file.read (&buf[0], sz+1);
 
-          if (file.eof ())
-            {
-              // Expected to read the entire file.
-              retval = buf;
-            }
-          else
+          if (! file.eof ())
             error ("error reading file %s", fname.c_str ());
+
+          // Expected to read the entire file.
+          retval = buf;
         }
     }
 
   return retval;
 }
 
 static std::deque<size_t>
 get_line_offsets (const std::string& buf)
@@ -215,23 +213,21 @@ parse_dbfunction_params (const char *who
           // It was a function name
           symbol_name = args(0).string_value ();
 
           idx = 1;
         }
       else
         {
           // It was a line number.  Need to get function name from debugger.
-          if (Vdebugging)
-            {
-              symbol_name = get_user_code ()->name ();
-              idx = 0;
-            }
-          else
+          if (! Vdebugging)
             error ("%s: no function specified", who);
+
+          symbol_name = get_user_code ()->name ();
+          idx = 0;
         }
     }
   else if (args(0).is_map ())
     {
       // This is a problem because parse_dbfunction_params()
       // can only pass out a single function.
       error ("%s: struct input not implemented", who);
     }
@@ -260,30 +256,28 @@ parse_dbfunction_params (const char *who
             }
         }
     }
 }
 
 bool
 bp_table::instance_ok (void)
 {
-  bool retval = true;
-
   if (! instance)
     {
       instance = new bp_table ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     error ("unable to create breakpoint table!");
 
-  return retval;
+  return true;
 }
 
 bool
 bp_table::do_add_breakpoint_1 (octave_user_code *fcn,
                                const std::string& fname,
                                const bp_table::intmap& line,
                                bp_table::intmap& retval)
 {
@@ -310,50 +304,48 @@ bp_table::do_add_breakpoint_1 (octave_us
 
   return found;
 }
 
 bp_table::intmap
 bp_table::do_add_breakpoint (const std::string& fname,
                              const bp_table::intmap& line)
 {
-  intmap retval;
-
   octave_user_code *dbg_fcn = get_user_code (fname);
 
-  if (dbg_fcn)
-    {
-      if (! do_add_breakpoint_1 (dbg_fcn, fname, line, retval))
-        {
-          // Search subfunctions in the order they appear in the file.
+  if (! dbg_fcn)
+    error ("add_breakpoint: unable to find the requested function\n");
+
+  intmap retval;
 
-          const std::list<std::string> subfcn_names
-            = dbg_fcn->subfunction_names ();
+  if (! do_add_breakpoint_1 (dbg_fcn, fname, line, retval))
+    {
+      // Search subfunctions in the order they appear in the file.
 
-          std::map<std::string, octave_value> subfcns
-            = dbg_fcn->subfunctions ();
+      const std::list<std::string> subfcn_names
+        = dbg_fcn->subfunction_names ();
 
-          for (std::list<std::string>::const_iterator p = subfcn_names.begin ();
-               p != subfcn_names.end (); p++)
-            {
-              std::map<std::string, octave_value>::const_iterator
-                q = subfcns.find (*p);
+      std::map<std::string, octave_value> subfcns
+        = dbg_fcn->subfunctions ();
 
-              if (q != subfcns.end ())
-                {
-                  octave_user_code *dbg_subfcn = q->second.user_code_value ();
+      for (std::list<std::string>::const_iterator p = subfcn_names.begin ();
+           p != subfcn_names.end (); p++)
+        {
+          std::map<std::string, octave_value>::const_iterator
+            q = subfcns.find (*p);
 
-                  if (do_add_breakpoint_1 (dbg_subfcn, fname, line, retval))
-                    break;
-                }
+          if (q != subfcns.end ())
+            {
+              octave_user_code *dbg_subfcn = q->second.user_code_value ();
+
+              if (do_add_breakpoint_1 (dbg_subfcn, fname, line, retval))
+                break;
             }
         }
     }
-  else
-    error ("add_breakpoint: unable to find the requested function\n");
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 int
 bp_table::do_remove_breakpoint_1 (octave_user_code *fcn,
@@ -416,44 +408,42 @@ bp_table::do_remove_breakpoint (const st
     {
       intmap results = remove_all_breakpoints_in_file (fname);
       retval = results.size ();
     }
   else
     {
       octave_user_code *dbg_fcn = get_user_code (fname);
 
-      if (dbg_fcn)
-        {
-          retval = do_remove_breakpoint_1 (dbg_fcn, fname, line);
+      if (! dbg_fcn)
+        error ("remove_breakpoint: unable to find the requested function\n");
 
-          // Search subfunctions in the order they appear in the file.
+      retval = do_remove_breakpoint_1 (dbg_fcn, fname, line);
 
-          const std::list<std::string> subfcn_names
-            = dbg_fcn->subfunction_names ();
+      // Search subfunctions in the order they appear in the file.
 
-          std::map<std::string, octave_value> subfcns
-            = dbg_fcn->subfunctions ();
+      const std::list<std::string> subfcn_names
+        = dbg_fcn->subfunction_names ();
 
-          for (std::list<std::string>::const_iterator p = subfcn_names.begin ();
-               p != subfcn_names.end (); p++)
-            {
-              std::map<std::string, octave_value>::const_iterator
-                q = subfcns.find (*p);
+      std::map<std::string, octave_value> subfcns
+        = dbg_fcn->subfunctions ();
 
-              if (q != subfcns.end ())
-                {
-                  octave_user_code *dbg_subfcn = q->second.user_code_value ();
+      for (std::list<std::string>::const_iterator p = subfcn_names.begin ();
+           p != subfcn_names.end (); p++)
+        {
+          std::map<std::string, octave_value>::const_iterator
+            q = subfcns.find (*p);
 
-                  retval += do_remove_breakpoint_1 (dbg_subfcn, fname, line);
-                }
+          if (q != subfcns.end ())
+            {
+              octave_user_code *dbg_subfcn = q->second.user_code_value ();
+
+              retval += do_remove_breakpoint_1 (dbg_subfcn, fname, line);
             }
         }
-      else
-        error ("remove_breakpoint: unable to find the requested function\n");
     }
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 // Remove all breakpoints from a file, including those in subfunctions
@@ -500,18 +490,17 @@ bp_table::do_remove_all_breakpoints (voi
       ++it_next;
       remove_all_breakpoints_in_file (*it);
     }
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 }
 
 std::string
-do_find_bkpt_list (octave_value_list slist,
-                   std::string match)
+do_find_bkpt_list (octave_value_list slist, std::string match)
 {
   std::string retval;
 
   for (int i = 0; i < slist.length (); i++)
     {
       if (slist(i).string_value () == match)
         {
           retval = slist(i).string_value ();
@@ -668,28 +657,27 @@ function are cleared.\n\
 \n\
 If the requested line is not a breakpoint no action is performed.\n\
 \n\
 The special keyword @qcode{\"all\"} will clear all breakpoints from all\n\
 files.\n\
 @seealso{dbstop, dbstatus, dbwhere}\n\
 @end deftypefn")
 {
-  octave_value retval;
   std::string symbol_name = "";
   bp_table::intmap lines;
 
   parse_dbfunction_params ("dbclear", args, symbol_name, lines);
 
   if (args.length () == 1 && symbol_name == "all")
     bp_table::remove_all_breakpoints ();
   else
     bp_table::remove_breakpoint (symbol_name, lines);
 
-  return retval;
+  return ovl ();
 }
 
 DEFUN (dbstatus, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} dbstatus ()\n\
 @deftypefnx {} {@var{brk_list} =} dbstatus ()\n\
 @deftypefnx {} {@var{brk_list} =} dbstatus (\"@var{func}\")\n\
 Report the location of active breakpoints.\n\
@@ -716,25 +704,25 @@ A line number, or vector of line numbers
 @end table\n\
 \n\
 Note: When @code{dbstatus} is called from the debug prompt within a function,\n\
 the list of breakpoints is automatically trimmed to the breakpoints in the\n\
 current function.\n\
 @seealso{dbclear, dbwhere}\n\
 @end deftypefn")
 {
-  octave_map retval;
   int nargin = args.length ();
+
+  if (nargin != 0 && nargin != 1)
+    error ("dbstatus: only zero or one arguments accepted\n");
+
   octave_value_list fcn_list;
   bp_table::fname_line_map bp_list;
   std::string symbol_name;
 
-  if (nargin != 0 && nargin != 1)
-    error ("dbstatus: only zero or one arguments accepted\n");
-
   if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           symbol_name = args(0).string_value ();
           fcn_list(0) = symbol_name;
           bp_list = bp_table::get_breakpoint_list (fcn_list);
         }
@@ -774,17 +762,17 @@ current function.\n\
             octave_stdout << " at line ";
 
           for (size_t j = 0; j < nel; j++)
             octave_stdout << m[j] << ((j < nel - 1) ? ", " : ".");
 
           if (nel > 0)
             octave_stdout << std::endl;
         }
-      return octave_value ();
+      return ovl ();
     }
   else
     {
       // Fill in an array for return.
 
       int i = 0;
       Cell names (dim_vector (bp_list.size (), 1));
       Cell file (dim_vector (bp_list.size (), 1));
@@ -794,101 +782,94 @@ current function.\n\
            it != bp_list.end (); it++)
         {
           names(i) = it->first;
           line(i) = intmap_to_ov (it->second);
           file(i) = do_which (it->first);
           i++;
         }
 
+      octave_map retval;
       retval.assign ("name", names);
       retval.assign ("file", file);
       retval.assign ("line", line);
 
-      return octave_value (retval);
+      return ovl (retval);
     }
 }
 
 DEFUN (dbwhere, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} dbwhere\n\
 In debugging mode, report the current file and line number where execution\n\
 is stopped.\n\
 @seealso{dbstatus, dbcont, dbstep, dbup}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   octave_user_code *dbg_fcn = get_user_code ();
 
-  if (dbg_fcn)
-    {
-      bool have_file = true;
+  if (! dbg_fcn)
+    error ("dbwhere: must be inside a user function to use dbwhere\n");
 
-      std::string name = dbg_fcn->fcn_file_name ();
+  bool have_file = true;
+
+  std::string name = dbg_fcn->fcn_file_name ();
 
-      if (name.empty ())
-        {
-          have_file = false;
+  if (name.empty ())
+    {
+      have_file = false;
 
-          name = dbg_fcn->name ();
-        }
-
-      octave_stdout << "stopped in " << name << " at ";
+      name = dbg_fcn->name ();
+    }
 
-      int l = octave_call_stack::caller_user_code_line ();
+  octave_stdout << "stopped in " << name << " at ";
+
+  int l = octave_call_stack::caller_user_code_line ();
 
-      if (l > 0)
-        {
-          octave_stdout << "line " << l << std::endl;
+  if (l > 0)
+    {
+      octave_stdout << "line " << l << std::endl;
 
-          if (have_file)
-            {
-              std::string line = get_file_line (name, l);
+      if (have_file)
+        {
+          std::string line = get_file_line (name, l);
 
-              if (! line.empty ())
-                octave_stdout << l << ": " << line << std::endl;
-            }
+          if (! line.empty ())
+            octave_stdout << l << ": " << line << std::endl;
         }
-      else
-        octave_stdout << "<unknown line>" << std::endl;
     }
   else
-    error ("dbwhere: must be inside a user function to use dbwhere\n");
+    octave_stdout << "<unknown line>" << std::endl;
 
-  return retval;
+  return ovl ();
 }
 
 void
 do_dbtype (std::ostream& os, const std::string& name, int start, int end)
 {
   std::string ff = fcn_file_in_path (name);
 
   if (! ff.empty ())
-    {
-      std::ifstream fs (ff.c_str (), std::ios::in);
+    os << "dbtype: unknown function " << name << "\n";
 
-      if (fs)
-        {
-          int line = 1;
-          std::string text;
+  std::ifstream fs (ff.c_str (), std::ios::in);
+
+  if (! fs)
+    os << "dbtype: unable to open '" << ff << "' for reading!\n";
 
-          while (std::getline (fs, text) && line <= end)
-            {
-              if (line >= start)
-                os << line << "\t" << text << "\n";
+  int line = 1;
+  std::string text;
 
-              line++;
-            }
-        }
-      else
-        os << "dbtype: unable to open '" << ff << "' for reading!\n";
+  while (std::getline (fs, text) && line <= end)
+    {
+      if (line >= start)
+        os << line << "\t" << text << "\n";
+
+      line++;
     }
-  else
-    os << "dbtype: unknown function " << name << "\n";
 
   os.flush ();
 }
 
 DEFUN (dbtype, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} dbtype\n\
 @deftypefnx {} {} dbtype @var{lineno}\n\
@@ -907,17 +888,16 @@ An optional range specification can be u
 file.  The special keyword @qcode{\"end\"} is a valid line number\n\
 specification for the last line of the file.\n\
 \n\
 When called with the name of a function, list that script file with line\n\
 numbers.\n\
 @seealso{dbwhere, dbstatus, dbstop}\n\
 @end deftypefn")
 {
-  octave_value retval;
   octave_user_code *dbg_fcn;
 
   string_vector argv = args.make_argv ("dbtype");
 
   switch (args.length ())
     {
     case 0: // dbtype
       dbg_fcn = get_user_code ();
@@ -987,75 +967,70 @@ numbers.\n\
                   do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
                              line, line);
               }
           }
       }
       break;
 
     case 2: // (dbtype func start:end) || (dbtype func start)
-      dbg_fcn = get_user_code (argv[1]);
+      {
+        dbg_fcn = get_user_code (argv[1]);
+
+        if (! dbg_fcn)
+          error ("dbtype: function <%s> not found\n", argv[1].c_str ());
 
-      if (dbg_fcn)
-        {
-          std::string arg = argv[2];
-          int start, end;
-          size_t ind = arg.find (':');
+        std::string arg = argv[2];
+        int start, end;
+        size_t ind = arg.find (':');
 
-          if (ind != std::string::npos)
-            {
-              std::string start_str = arg.substr (0, ind);
-              std::string end_str = arg.substr (ind + 1);
+        if (ind != std::string::npos)
+          {
+            std::string start_str = arg.substr (0, ind);
+            std::string end_str = arg.substr (ind + 1);
 
-              start = atoi (start_str.c_str ());
-              if (end_str == "end")
-                end = std::numeric_limits<int>::max ();
-              else
-                end = atoi (end_str.c_str ());
-            }
-          else
-            {
-              start = atoi (arg.c_str ());
-              end = start;
-            }
+            start = atoi (start_str.c_str ());
+            if (end_str == "end")
+              end = std::numeric_limits<int>::max ();
+            else
+              end = atoi (end_str.c_str ());
+          }
+        else
+          {
+            start = atoi (arg.c_str ());
+            end = start;
+          }
 
-          if (std::min (start, end) <= 0)
-            error ("dbtype: start and end lines must be >= 1\n");
+        if (std::min (start, end) <= 0)
+          error ("dbtype: start and end lines must be >= 1\n");
+        else if (start > end)
+          error ("dbtype: start line must be less than end line\n");
 
-          if (start <= end)
-            do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
-                       start, end);
-          else
-            error ("dbtype: start line must be less than end line\n");
-        }
-      else
-        error ("dbtype: function <%s> not found\n", argv[1].c_str ());
-
+        do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (), start, end);
+      }
       break;
 
     default:
       error ("dbtype: expecting zero, one, or two arguments\n");
     }
 
-  return retval;
+  return ovl ();
 }
 
 DEFUN (dblist, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} dblist\n\
 @deftypefnx {} {} dblist @var{n}\n\
 In debugging mode, list @var{n} lines of the function being debugged\n\
 centered around the current line to be executed.\n\
 \n\
 If unspecified @var{n} defaults to 10 (+/- 5 lines)\n\
 @seealso{dbwhere, dbtype}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int n = 10;
 
   if (args.length () == 1)
     {
       octave_value arg = args(0);
 
       if (arg.is_string ())
         {
@@ -1067,55 +1042,53 @@ If unspecified @var{n} defaults to 10 (+
         n = args(0).int_value ();
 
       if (n < 0)
         error ("dblist: N must be a non-negative integer");
     }
 
   octave_user_code *dbg_fcn = get_user_code ();
 
-  if (dbg_fcn)
-    {
-      bool have_file = true;
+  if (! dbg_fcn)
+    error ("dblist: must be inside a user function to use dblist\n");
 
-      std::string name = dbg_fcn->fcn_file_name ();
+  bool have_file = true;
+
+  std::string name = dbg_fcn->fcn_file_name ();
 
-      if (name.empty ())
-        {
-          have_file = false;
-          name = dbg_fcn->name ();
-        }
+  if (name.empty ())
+    {
+      have_file = false;
+      name = dbg_fcn->name ();
+    }
 
-      int l = octave_call_stack::caller_user_code_line ();
+  int l = octave_call_stack::caller_user_code_line ();
 
-      if (l > 0)
+  if (l > 0)
+    {
+      if (have_file)
         {
-          if (have_file)
-            {
-              int l_min = std::max (l - n/2, 0);
-              int l_max = l + n/2;
-              do_dbtype (octave_stdout, name, l_min, l-1);
+          int l_min = std::max (l - n/2, 0);
+          int l_max = l + n/2;
+          do_dbtype (octave_stdout, name, l_min, l-1);
 
-              std::string line = get_file_line (name, l);
-              if (! line.empty ())
-                octave_stdout << l << "-->\t" << line << std::endl;
+          std::string line = get_file_line (name, l);
+          if (! line.empty ())
+            octave_stdout << l << "-->\t" << line << std::endl;
 
-              do_dbtype (octave_stdout, name, l+1, l_max);
-            }
-        }
-      else
-        {
-          octave_stdout << "dblist: unable to determine source code line"
-                        << std::endl;
+          do_dbtype (octave_stdout, name, l+1, l_max);
         }
     }
   else
-    error ("dblist: must be inside a user function to use dblist\n");
+    {
+      octave_stdout << "dblist: unable to determine source code line"
+                    << std::endl;
+    }
 
-  return retval;
+  return ovl ();
 }
 
 static octave_value_list
 do_dbstack (const octave_value_list& args, int nargout, std::ostream& os)
 {
   int nargin = args.length ();
 
   if (nargin > 2)
@@ -1202,31 +1175,28 @@ do_dbstack (const octave_value_list& arg
             }
 
           if (show_top_level)
             os << "  --> top level" << std::endl;
         }
     }
   else
     {
-      octave_map stk = octave_call_stack::backtrace (nskip,
-                                                     curr_frame,
-                                                     false);
+      octave_map stk = octave_call_stack::backtrace (nskip, curr_frame, false);
 
-      retval = ovl (stk,
-                    curr_frame < 0 ? 1 : curr_frame + 1);
+      retval = ovl (stk, curr_frame < 0 ? 1 : curr_frame + 1);
     }
 
   return retval;
 }
 
-// A function that can be easily called from a debugger print the Octave
-// stack.  This can be useful for finding what line of code the
-// interpreter is currently executing when the debugger is stopped in
-// some C++ function, for example.
+// A function that can be easily called from a debugger print the Octave stack.
+// This can be useful for finding what line of code the interpreter is
+// currently executing when the debugger is stopped in some C++ function,
+// for example.
 
 void
 show_octave_dbstack (void)
 {
   do_dbstack (octave_value_list (), 0, std::cerr);
 }
 
 DEFUN (dbstack, args, nargout,
@@ -1307,38 +1277,34 @@ DEFUN (dbup, args, ,
 @deftypefn  {} {} dbup\n\
 @deftypefnx {} {} dbup @var{n}\n\
 In debugging mode, move up the execution stack @var{n} frames.\n\
 \n\
 If @var{n} is omitted, move up one frame.\n\
 @seealso{dbstack, dbdown}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   do_dbupdown (args, "dbup");
 
-  return retval;
+  return ovl ();
 }
 
 DEFUN (dbdown, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} dbdown\n\
 @deftypefnx {} {} dbdown @var{n}\n\
 In debugging mode, move down the execution stack @var{n} frames.\n\
 \n\
 If @var{n} is omitted, move down one frame.\n\
 @seealso{dbstack, dbup}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   do_dbupdown (args, "dbdown");
 
-  return retval;
+  return ovl ();
 }
 
 DEFUN (dbstep, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} dbstep\n\
 @deftypefnx {} {} dbstep @var{n}\n\
 @deftypefnx {} {} dbstep in\n\
 @deftypefnx {} {} dbstep out\n\
@@ -1382,24 +1348,22 @@ function returns.\n\
           Vdebugging = false;
 
           tree_evaluator::dbstep_flag = -2;
         }
       else
         {
           int n = atoi (arg.c_str ());
 
-          if (n > 0)
-            {
-              Vdebugging = false;
+          if (n < 1)
+            error ("dbstep: invalid argument");
 
-              tree_evaluator::dbstep_flag = n;
-            }
-          else
-            error ("dbstep: invalid argument");
+          Vdebugging = false;
+
+          tree_evaluator::dbstep_flag = n;
         }
     }
   else
     {
       Vdebugging = false;
 
       tree_evaluator::dbstep_flag = 1;
     }
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -70,29 +70,27 @@ octave_time Vlast_chdir_time = 0.0;
 
 static int
 octave_change_to_directory (const std::string& newdir)
 {
   std::string xdir = file_ops::tilde_expand (newdir);
 
   int cd_ok = octave_env::chdir (xdir);
 
-  if (cd_ok)
-    {
-      Vlast_chdir_time.stamp ();
+  if (! cd_ok)
+    error ("%s: %s", newdir.c_str (), gnulib::strerror (errno));
 
-      // FIXME: should these actions be handled as a list of functions
-      // to call so users can add their own chdir handlers?
+  Vlast_chdir_time.stamp ();
 
-      load_path::update ();
+  // FIXME: should these actions be handled as a list of functions
+  // to call so users can add their own chdir handlers?
 
-      octave_link::change_directory (octave_env::get_current_directory ());
-    }
-  else
-    error ("%s: %s", newdir.c_str (), gnulib::strerror (errno));
+  load_path::update ();
+
+  octave_link::change_directory (octave_env::get_current_directory ());
 
   return cd_ok;
 }
 
 DEFUN (cd, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} cd @var{dir}\n\
 @deftypefnx {} {} cd\n\
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -261,42 +261,40 @@ octave_dynamic_loader::do_load_oct (cons
   if (! oct_file)
     {
       oct_file.open (file_name);
 
       if (oct_file)
         octave_shlib_list::append (oct_file);
     }
 
-  if (oct_file)
-    {
-      void *function = oct_file.search (fcn_name, name_mangler);
+  if (! oct_file)
+    error ("%s is not a valid shared library", file_name.c_str ());
+
+  void *function = oct_file.search (fcn_name, name_mangler);
 
-      if (! function)
-        {
-          // FIXME: can we determine this C mangling scheme
-          // automatically at run time or configure time?
-
-          function = oct_file.search (fcn_name, name_uscore_mangler);
-        }
+  if (! function)
+    {
+      // FIXME: can we determine this C mangling scheme
+      // automatically at run time or configure time?
 
-      if (function)
-        {
-          octave_dld_fcn_getter f
-            = FCN_PTR_CAST (octave_dld_fcn_getter, function);
-
-          retval = f (oct_file, relative);
+      function = oct_file.search (fcn_name, name_uscore_mangler);
+    }
 
-          if (! retval)
-            error ("failed to install .oct file function '%s'",
-                   fcn_name.c_str ());
-        }
+  if (function)
+    {
+      octave_dld_fcn_getter f
+        = FCN_PTR_CAST (octave_dld_fcn_getter, function);
+
+      retval = f (oct_file, relative);
+
+      if (! retval)
+        error ("failed to install .oct file function '%s'",
+               fcn_name.c_str ());
     }
-  else
-    error ("%s is not a valid shared library", file_name.c_str ());
 
   return retval;
 }
 
 octave_function *
 octave_dynamic_loader::do_load_mex (const std::string& fcn_name,
                                     const std::string& file_name,
                                     bool /*relative*/)
@@ -317,49 +315,45 @@ octave_dynamic_loader::do_load_mex (cons
   if (! mex_file)
     {
       mex_file.open (file_name);
 
       if (mex_file)
         octave_shlib_list::append (mex_file);
     }
 
-  if (mex_file)
-    {
-      void *function = 0;
+  if (! mex_file)
+    error ("%s is not a valid shared library", file_name.c_str ());
+
+  void *function = 0;
+
+  bool have_fmex = false;
 
-      bool have_fmex = false;
+  function = mex_file.search (fcn_name, mex_mangler);
 
-      function = mex_file.search (fcn_name, mex_mangler);
+  if (! function)
+    {
+      // FIXME: can we determine this C mangling scheme
+      // automatically at run time or configure time?
+
+      function = mex_file.search (fcn_name, mex_uscore_mangler);
 
       if (! function)
         {
-          // FIXME: can we determine this C mangling scheme
-          // automatically at run time or configure time?
-
-          function = mex_file.search (fcn_name, mex_uscore_mangler);
-
-          if (! function)
-            {
-              function = mex_file.search (fcn_name, mex_f77_mangler);
+          function = mex_file.search (fcn_name, mex_f77_mangler);
 
-              if (function)
-                have_fmex = true;
-            }
+          if (function)
+            have_fmex = true;
         }
+    }
 
-      if (function)
-        retval = new octave_mex_function (function, have_fmex,
-                                          mex_file, fcn_name);
-      else
-        error ("failed to install .mex file function '%s'",
-               fcn_name.c_str ());
-    }
+  if (function)
+    retval = new octave_mex_function (function, have_fmex, mex_file, fcn_name);
   else
-    error ("%s is not a valid shared library", file_name.c_str ());
+    error ("failed to install .mex file function '%s'", fcn_name.c_str ());
 
   return retval;
 }
 
 bool
 octave_dynamic_loader::do_remove_oct (const std::string& fcn_name,
                                       octave_shlib& shl)
 {
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1063,24 +1063,22 @@ complete description of the syntax of th
   return retval;
 }
 
 static std::string
 get_sscanf_data (const octave_value& val)
 {
   std::string retval;
 
-  if (val.is_string ())
-    {
-      octave_value tmp = val.reshape (dim_vector (1, val.numel ()));
+  if (! val.is_string ())
+    error ("sscanf: argument STRING must be a string");
 
-      retval = tmp.string_value ();
-    }
-  else
-    error ("sscanf: argument STRING must be a string");
+  octave_value tmp = val.reshape (dim_vector (1, val.numel ()));
+
+  retval = tmp.string_value ();
 
   return retval;
 }
 
 DEFUN (sscanf, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{val}, @var{count}, @var{errmsg}, @var{pos}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
 @deftypefnx {} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} sscanf (@var{string}, @var{template}, \"C\")\n\
diff --git a/libinterp/corefcn/gl2ps-renderer.cc b/libinterp/corefcn/gl2ps-renderer.cc
--- a/libinterp/corefcn/gl2ps-renderer.cc
+++ b/libinterp/corefcn/gl2ps-renderer.cc
@@ -625,27 +625,25 @@ safe_pclose (FILE *f)
 void
 gl2ps_print (const graphics_object& fig, const std::string& cmd,
              const std::string& term)
 {
 #ifdef HAVE_GL2PS_H
 
   FILE *fp = octave_popen (cmd.c_str (), "w");
 
-  if (fp)
-    {
-      unwind_protect frame;
+  if (! fp)
+    error ("print: failed to open pipe for gl2ps renderer");
 
-      frame.add_fcn (safe_pclose, fp);
+  unwind_protect frame;
 
-      glps_renderer rend (fp, term);
+  frame.add_fcn (safe_pclose, fp);
 
-      rend.draw (fig, cmd);
-    }
-  else
-    error ("print: failed to open pipe for gl2ps renderer");
+  glps_renderer rend (fp, term);
+
+  rend.draw (fig, cmd);
 
 #else
 
   error ("print: printing not available without gl2ps library");
 
 #endif
 }
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1762,57 +1762,53 @@ property::create (const std::string& nam
         retval.set (args(0));
       else
         retval.set (rv.default_value ());
     }
   else
     {
       caseless_str go_name, go_rest;
 
-      if (lookup_object_name (type, go_name, go_rest))
-        {
-          graphics_object go;
-
-          std::map<caseless_str, graphics_object>::const_iterator it =
-            dprop_obj_map.find (go_name);
-
-          if (it == dprop_obj_map.end ())
-            {
-              base_graphics_object *bgo =
-                make_graphics_object_from_type (go_name);
-
-              if (bgo)
-                {
-                  go = graphics_object (bgo);
-
-                  dprop_obj_map[go_name] = go;
-                }
-            }
-          else
-            go = it->second;
-
-          if (go.valid_object ())
-            {
-              property prop = go.get_properties ().get_property (go_rest);
-
-              retval = prop.clone ();
-
-              retval.set_parent (h);
-              retval.set_name (name);
-
-              if (args.length () > 0)
-                retval.set (args(0));
-            }
-          else
-            error ("addproperty: invalid object type (= %s)",
-                   go_name.c_str ());
+      if (! lookup_object_name (type, go_name, go_rest))
+        error ("addproperty: unsupported type for dynamic property (= %s)",
+               type.c_str ());
+
+      graphics_object go;
+
+      std::map<caseless_str, graphics_object>::const_iterator it =
+        dprop_obj_map.find (go_name);
+
+      if (it == dprop_obj_map.end ())
+        {
+          base_graphics_object *bgo =
+            make_graphics_object_from_type (go_name);
+
+          if (bgo)
+            {
+              go = graphics_object (bgo);
+
+              dprop_obj_map[go_name] = go;
+            }
         }
       else
-        error ("addproperty: unsupported type for dynamic property (= %s)",
-               type.c_str ());
+        go = it->second;
+
+      if (! go.valid_object ())
+        error ("addproperty: invalid object type (= %s)",
+               go_name.c_str ());
+
+      property prop = go.get_properties ().get_property (go_rest);
+
+      retval = prop.clone ();
+
+      retval.set_parent (h);
+      retval.set_name (name);
+
+      if (args.length () > 0)
+        retval.set (args(0));
     }
 
   return retval;
 }
 
 static void
 finalize_r (const graphics_handle& h)
 {
@@ -2022,40 +2018,38 @@ property_list::set (const caseless_str& 
             has_property = uipanel::properties::has_core_property (pname);
           else if (pfx == "uicontextmenu")
             has_property = uicontextmenu::properties::has_core_property (pname);
           else if (pfx == "uitoolbar")
             has_property = uitoolbar::properties::has_core_property (pname);
           else if (pfx == "uipushtool")
             has_property = uipushtool::properties::has_core_property (pname);
 
-          if (has_property)
-            {
-              bool remove = false;
-              if (val.is_string ())
-                {
-                  std::string sval = val.string_value ();
-
-                  remove = (sval.compare ("remove") == 0);
-                }
-
-              pval_map_type& pval_map = plist_map[pfx];
-
-              if (remove)
-                {
-                  pval_map_iterator p = pval_map.find (pname);
-
-                  if (p != pval_map.end ())
-                    pval_map.erase (p);
-                }
-              else
-                pval_map[pname] = val;
+          if (! has_property)
+            error ("invalid %s property '%s'", pfx.c_str (), pname.c_str ());
+
+          bool remove = false;
+          if (val.is_string ())
+            {
+              std::string sval = val.string_value ();
+
+              remove = (sval.compare ("remove") == 0);
+            }
+
+          pval_map_type& pval_map = plist_map[pfx];
+
+          if (remove)
+            {
+              pval_map_iterator p = pval_map.find (pname);
+
+              if (p != pval_map.end ())
+                pval_map.erase (p);
             }
           else
-            error ("invalid %s property '%s'", pfx.c_str (), pname.c_str ());
+            pval_map[pname] = val;
         }
     }
 
   if (offset == 0)
     error ("invalid default property specification");
 }
 
 octave_value
@@ -2590,35 +2584,33 @@ reparent (const octave_value& ov, const 
 {
   graphics_handle h = octave_NaN;
 
   double hv = ov.xdouble_value ("%s: %s must be a graphics handle",
                                who.c_str (), pname.c_str ());
 
   h = gh_manager::lookup (hv);
 
-  if (h.ok ())
-    {
-      graphics_object go = gh_manager::get_object (h);
-
-      graphics_handle parent_h = go.get_parent ();
-
-      graphics_object parent_go = gh_manager::get_object (parent_h);
-
-      parent_go.remove_child (h);
-
-      if (adopt)
-        go.set ("parent", new_parent.value ());
-      else
-        go.reparent (new_parent);
-    }
-  else
+  if (! h.ok ())
     error ("%s: invalid graphics handle (= %g) for %s",
            who.c_str (), hv, pname.c_str ());
 
+  graphics_object go = gh_manager::get_object (h);
+
+  graphics_handle parent_h = go.get_parent ();
+
+  graphics_object parent_go = gh_manager::get_object (parent_h);
+
+  parent_go.remove_child (h);
+
+  if (adopt)
+    go.set ("parent", new_parent.value ());
+  else
+    go.reparent (new_parent);
+
   return h;
 }
 
 // This function is NOT equivalent to the scripting language function gcf.
 graphics_handle
 gcf (void)
 {
   octave_value val = xget (0, "currentfigure");
@@ -3006,42 +2998,40 @@ base_properties::set_parent (const octav
   graphics_handle new_parent = octave_NaN;
 
   if (hp == __myhandle__)
     error ("set: can not set object parent to be object itself");
   else
     {
       new_parent = gh_manager::lookup (hp);
 
-      if (new_parent.ok ())
-        {
-          // Remove child from current parent
-          graphics_object old_parent_go;
-          old_parent_go = gh_manager::get_object (get_parent ());
-
-          if (old_parent_go.get_handle () != hp)
-            old_parent_go.remove_child (__myhandle__);
-          else
-            return;  // Do nothing more
-
-          // Check new parent's parent is not this child to avoid recursion
-          graphics_object new_parent_go;
-          new_parent_go = gh_manager::get_object (new_parent);
-          if (new_parent_go.get_parent () == __myhandle__)
-            {
-              // new parent's parent gets child's original parent
-              new_parent_go.get_properties ().set_parent (get_parent ().as_octave_value ());
-            }
-
-          // Set parent property to new_parent and do adoption
-          parent = new_parent.as_octave_value ();
-          ::adopt (parent.handle_value (), __myhandle__);
-        }
+      if (! new_parent.ok ())
+        error ("set: invalid graphics handle (= %g) for parent", hp);
+
+      // Remove child from current parent
+      graphics_object old_parent_go;
+      old_parent_go = gh_manager::get_object (get_parent ());
+
+      if (old_parent_go.get_handle () != hp)
+        old_parent_go.remove_child (__myhandle__);
       else
-        error ("set: invalid graphics handle (= %g) for parent", hp);
+        return;  // Do nothing more
+
+      // Check new parent's parent is not this child to avoid recursion
+      graphics_object new_parent_go;
+      new_parent_go = gh_manager::get_object (new_parent);
+      if (new_parent_go.get_parent () == __myhandle__)
+        {
+          // new parent's parent gets child's original parent
+          new_parent_go.get_properties ().set_parent (get_parent ().as_octave_value ());
+        }
+
+      // Set parent property to new_parent and do adoption
+      parent = new_parent.as_octave_value ();
+      ::adopt (parent.handle_value (), __myhandle__);
     }
 }
 
 /*
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   hax = gca ();
@@ -3169,25 +3159,23 @@ base_properties::delete_listener (const 
     p.delete_listener (val, mode);
 }
 
 // ---------------------------------------------------------------------
 
 void
 base_graphics_object::update_axis_limits (const std::string& axis_type)
 {
-  if (valid_object ())
-    {
-      graphics_object parent_go = gh_manager::get_object (get_parent ());
-
-      if (parent_go)
-        parent_go.update_axis_limits (axis_type);
-    }
-  else
+  if (! valid_object ())
     error ("base_graphics_object::update_axis_limits: invalid graphics object");
+
+  graphics_object parent_go = gh_manager::get_object (get_parent ());
+
+  if (parent_go)
+    parent_go.update_axis_limits (axis_type);
 }
 
 void
 base_graphics_object::update_axis_limits (const std::string& axis_type,
                                           const graphics_handle& h)
 {
   if (! valid_object ())
     error ("base_graphics_object::update_axis_limits: invalid graphics object");
@@ -9049,61 +9037,59 @@ gh_manager::do_make_graphics_handle (con
                                      bool do_notify_toolkit)
 {
   graphics_handle h = get_handle (integer_figure_handle);
 
   base_graphics_object *bgo = 0;
 
   bgo = make_graphics_object_from_type (go_name, h, p);
 
-  if (bgo)
-    {
-      graphics_object go (bgo);
-
-      handle_map[h] = go;
-
-      // Overriding defaults will work now because the handle is valid
-      // and we can find parent objects (not just handles).
-      go.override_defaults ();
-
-      if (go_name == "axes")
-        {
-          // Handle defaults for labels since overriding defaults for
-          // them can't work before the axes object is fully
-          // constructed.
-
-          axes::properties& props =
-            dynamic_cast<axes::properties&> (go.get_properties ());
-
-          graphics_object tgo;
-
-          tgo = gh_manager::get_object (props.get_xlabel ());
-          tgo.override_defaults ();
-
-          tgo = gh_manager::get_object (props.get_ylabel ());
-          tgo.override_defaults ();
-
-          tgo = gh_manager::get_object (props.get_zlabel ());
-          tgo.override_defaults ();
-
-          tgo = gh_manager::get_object (props.get_title ());
-          tgo.override_defaults ();
-        }
-
-      if (do_createfcn)
-        bgo->get_properties ().execute_createfcn ();
-
-      // Notify graphics toolkit.
-      if (do_notify_toolkit)
-        go.initialize ();
-    }
-  else
+  if (! bgo)
     error ("gh_manager::do_make_graphics_handle: invalid object type '%s'",
            go_name.c_str ());
 
+  graphics_object go (bgo);
+
+  handle_map[h] = go;
+
+  // Overriding defaults will work now because the handle is valid
+  // and we can find parent objects (not just handles).
+  go.override_defaults ();
+
+  if (go_name == "axes")
+    {
+      // Handle defaults for labels since overriding defaults for
+      // them can't work before the axes object is fully
+      // constructed.
+
+      axes::properties& props =
+        dynamic_cast<axes::properties&> (go.get_properties ());
+
+      graphics_object tgo;
+
+      tgo = gh_manager::get_object (props.get_xlabel ());
+      tgo.override_defaults ();
+
+      tgo = gh_manager::get_object (props.get_ylabel ());
+      tgo.override_defaults ();
+
+      tgo = gh_manager::get_object (props.get_zlabel ());
+      tgo.override_defaults ();
+
+      tgo = gh_manager::get_object (props.get_title ());
+      tgo.override_defaults ();
+    }
+
+  if (do_createfcn)
+    bgo->get_properties ().execute_createfcn ();
+
+  // Notify graphics toolkit.
+  if (do_notify_toolkit)
+    go.initialize ();
+
   return h;
 }
 
 graphics_handle
 gh_manager::do_make_figure_handle (double val, bool do_notify_toolkit)
 {
   graphics_handle h = val;
 
@@ -10148,45 +10134,43 @@ make_graphics_object (const std::string&
         }
     }
 
   if (xisnan (val))
     val = args(0).xdouble_value ("__go_%s__: invalid parent", go_name.c_str ());
 
   graphics_handle parent = gh_manager::lookup (val);
 
-  if (parent.ok ())
-    {
-      graphics_handle h;
-
-      try
-        {
-          h = gh_manager::make_graphics_handle (go_name, parent,
-                                                integer_figure_handle,
-                                                false, false);
-        }
-      catch (octave_execution_exception& e)
-        {
-          error (e, "__go%s__: unable to create graphics handle",
-                 go_name.c_str ());
-        }
-
-      adopt (parent, h);
-
-      xset (h, xargs);
-      xcreatefcn (h);
-      xinitialize (h);
-
-      retval = h.value ();
-
-      Vdrawnow_requested = true;
-    }
-  else
+  if (! parent.ok ())
     error ("__go_%s__: invalid parent", go_name.c_str ());
 
+  graphics_handle h;
+
+  try
+    {
+      h = gh_manager::make_graphics_handle (go_name, parent,
+                                            integer_figure_handle,
+                                            false, false);
+    }
+  catch (octave_execution_exception& e)
+    {
+      error (e, "__go%s__: unable to create graphics handle",
+             go_name.c_str ());
+    }
+
+  adopt (parent, h);
+
+  xset (h, xargs);
+  xcreatefcn (h);
+  xinitialize (h);
+
+  retval = h.value ();
+
+  Vdrawnow_requested = true;
+
   return retval;
 }
 
 DEFUN (__go_figure__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __go_figure__ (@var{fignum})\n\
 Undocumented internal function.\n\
 @end deftypefn")
@@ -10880,37 +10864,35 @@ undocumented.\n\
             }
 
           mono = (args.length () >= 3 ? args(2).xbool_value ("drawnow: MONO colormode must be a boolean value") : false);
 
           debug_file = (args.length () > 3 ? args(3).xstring_value ("drawnow: DEBUG_FILE must be a string") : "");
 
           graphics_handle h = gcf ();
 
-          if (h.ok ())
-            {
-              graphics_object go = gh_manager::get_object (h);
-
-              // FIXME: when using qt toolkit the print_figure method
-              // returns immediately and Canvas::print doesn't have
-              // enough time to lock the mutex before we lock it here
-              // again.  We thus wait 50 ms (which may not be enough) to
-              // give it a chance: see http://octave.1599824.n4.nabble.com/Printing-issues-with-Qt-toolkit-tp4673270.html
-
-              gh_manager::unlock ();
-
-              go.get_toolkit ().print_figure (go, term, file, mono,
-                                              debug_file);
-
-              octave_sleep (0.05); // FIXME: really needed?
-
-              gh_manager::lock ();
-            }
-          else
+          if (! h.ok ())
             error ("drawnow: nothing to draw");
+
+          graphics_object go = gh_manager::get_object (h);
+
+          // FIXME: when using qt toolkit the print_figure method
+          // returns immediately and Canvas::print doesn't have
+          // enough time to lock the mutex before we lock it here
+          // again.  We thus wait 50 ms (which may not be enough) to
+          // give it a chance: see http://octave.1599824.n4.nabble.com/Printing-issues-with-Qt-toolkit-tp4673270.html
+
+          gh_manager::unlock ();
+
+          go.get_toolkit ().print_figure (go, term, file, mono,
+                                          debug_file);
+
+          octave_sleep (0.05); // FIXME: really needed?
+
+          gh_manager::lock ();
         }
     }
 
   gh_manager::unlock ();
 
   return ovl ();
 }
 
@@ -11163,25 +11145,23 @@ bool
 set_property_in_handle (double handle, const std::string& property,
                         const octave_value& arg, const std::string& func)
 {
   gh_manager::auto_lock guard;
 
   int ret = false;
   graphics_object go = gh_manager::get_object (handle);
 
-  if (go)
-    {
-      go.set (caseless_str (property), arg);
-
-      ret = true;
-    }
-  else
+  if (! go)
     error ("%s: invalid handle (= %g)", func.c_str (), handle);
 
+  go.set (caseless_str (property), arg);
+
+  ret = true;
+
   return ret;
 }
 
 static bool
 compare_property_values (const octave_value& ov1, const octave_value& ov2)
 {
   octave_value_list args(2);
 
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -438,29 +438,27 @@ public:
     return *this;
   }
 
   base_property* clone (void) const { return new string_property (*this); }
 
 protected:
   bool do_set (const octave_value& val)
   {
-    if (val.is_string ())
-      {
-        std::string new_str = val.string_value ();
-
-        if (new_str != str)
-          {
-            str = new_str;
-            return true;
-          }
-      }
-    else
+    if (! val.is_string ())
       error ("set: invalid string property value for \"%s\"",
              get_name ().c_str ());
+
+    std::string new_str = val.string_value ();
+
+    if (new_str != str)
+      {
+        str = new_str;
+        return true;
+      }
     return false;
   }
 
 private:
   std::string str;
 };
 
 // ---------------------------------------------------------------------
@@ -493,28 +491,26 @@ public:
       }
   }
 
   string_array_property (const std::string& s, const graphics_handle& h,
                          const Cell& c, const char& sep = '|',
                          const desired_enum& typ = string_t)
     : base_property (s, h), desired_type (typ), separator (sep), str ()
   {
-    if (c.is_cellstr ())
-      {
-        string_vector strings (c.numel ());
-
-        for (octave_idx_type i = 0; i < c.numel (); i++)
-          strings[i] = c(i).string_value ();
-
-        str = strings;
-      }
-    else
+    if (! c.is_cellstr ())
       error ("set: invalid order property value for \"%s\"",
              get_name ().c_str ());
+
+    string_vector strings (c.numel ());
+
+    for (octave_idx_type i = 0; i < c.numel (); i++)
+      strings[i] = c(i).string_value ();
+
+    str = strings;
   }
 
   string_array_property (const string_array_property& p)
     : base_property (p), desired_type (p.desired_type),
       separator (p.separator), str (p.str) { }
 
   octave_value get (void) const
   {
@@ -953,42 +949,38 @@ public:
     return *this;
   }
 
   base_property* clone (void) const { return new radio_property (*this); }
 
 protected:
   bool do_set (const octave_value& newval)
   {
-    if (newval.is_string ())
-      {
-        std::string s = newval.string_value ();
-
-        std::string match;
-
-        if (vals.validate (s, match))
-          {
-            if (match != current_val)
-              {
-                if (s.length () != match.length ())
-                  warning_with_id ("Octave:abbreviated-property-match",
-                                   "%s: allowing %s to match %s value %s",
-                                   "set", s.c_str (), get_name ().c_str (),
-                                   match.c_str ());
-                current_val = match;
-                return true;
-              }
-          }
-        else
-          error ("set: invalid value for radio property \"%s\" (value = %s)",
-                 get_name ().c_str (), s.c_str ());
-      }
-    else
+    if (! newval.is_string ())
       error ("set: invalid value for radio property \"%s\"",
              get_name ().c_str ());
+
+    std::string s = newval.string_value ();
+
+    std::string match;
+
+    if (! vals.validate (s, match))
+      error ("set: invalid value for radio property \"%s\" (value = %s)",
+             get_name ().c_str (), s.c_str ());
+
+    if (match != current_val)
+      {
+        if (s.length () != match.length ())
+          warning_with_id ("Octave:abbreviated-property-match",
+                           "%s: allowing %s to match %s value %s",
+                           "set", s.c_str (), get_name ().c_str (),
+                           match.c_str ());
+        current_val = match;
+        return true;
+      }
     return false;
   }
 
 private:
   radio_values vals;
   std::string current_val;
 };
 
@@ -1362,32 +1354,30 @@ public:
     return p;
   }
 
 protected:
   bool do_set (const octave_value& v)
   {
     octave_value tmp = v.is_sparse_type () ? v.full_value () : v;
 
-    if (validate (tmp))
-      {
-        // FIXME: should we check for actual data change?
-        if (! is_equal (tmp))
-          {
-            data = tmp;
-
-            get_data_limits ();
-
-            return true;
-          }
-      }
-    else
+    if (! validate (tmp))
       error ("invalid value for array property \"%s\"",
              get_name ().c_str ());
 
+    // FIXME: should we check for actual data change?
+    if (! is_equal (tmp))
+      {
+        data = tmp;
+
+        get_data_limits ();
+
+        return true;
+      }
+
     return false;
   }
 
 private:
   OCTINTERP_API bool validate (const octave_value& v);
 
   OCTINTERP_API bool is_equal (const octave_value& v) const;
 
@@ -1820,24 +1810,22 @@ public:
     return *this;
   }
 
   base_property* clone (void) const { return new callback_property (*this); }
 
 protected:
   bool do_set (const octave_value& v)
   {
-    if (validate (v))
-      {
-        callback = v;
-        return true;
-      }
-    else
+    if (! validate (v))
       error ("invalid value for callback property \"%s\"",
              get_name ().c_str ());
+
+    callback = v;
+    return true;
     return false;
   }
 
 private:
   OCTINTERP_API bool validate (const octave_value& v) const;
 
 private:
   octave_value callback;
@@ -2804,23 +2792,21 @@ public:
     if (valid_object ())
       get_properties ().reparent (np);
     else
       error ("base_graphics_object::reparent: invalid graphics object");
   }
 
   virtual void defaults (void) const
   {
-    if (valid_object ())
-      {
-        std::string msg = (type () + "::defaults");
-        gripe_not_implemented (msg.c_str ());
-      }
-    else
+    if (! valid_object ())
       error ("base_graphics_object::default: invalid graphics object");
+
+    std::string msg = (type () + "::defaults");
+    gripe_not_implemented (msg.c_str ());
   }
 
   virtual base_properties& get_properties (void)
   {
     static base_properties properties;
     error ("base_graphics_object::get_properties: invalid graphics object");
   }
 
@@ -3338,31 +3324,29 @@ public:
 
       return toolkit;
     }
 
     void set_toolkit (const graphics_toolkit& b);
 
     void set___graphics_toolkit__ (const octave_value& val)
     {
-      if (val.is_string ())
+      if (! val.is_string ())
+        error ("set___graphics_toolkit__ must be a string");
+
+      std::string nm = val.string_value ();
+      graphics_toolkit b = gtk_manager::find_toolkit (nm);
+
+      if (b.get_name () != nm)
+        error ("set___graphics_toolkit__: invalid graphics toolkit");
+      else if (nm != get___graphics_toolkit__ ())
         {
-          std::string nm = val.string_value ();
-          graphics_toolkit b = gtk_manager::find_toolkit (nm);
-
-          if (b.get_name () != nm)
-            error ("set___graphics_toolkit__: invalid graphics toolkit");
-          else if (nm != get___graphics_toolkit__ ())
-            {
-              set_toolkit (b);
-              mark_modified ();
-            }
+          set_toolkit (b);
+          mark_modified ();
         }
-      else
-        error ("set___graphics_toolkit__ must be a string");
     }
 
     void adopt (const graphics_handle& h);
 
     void set_position (const octave_value& val,
                        bool do_notify_toolkit = true);
 
     void set_outerposition (const octave_value& val,
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -100,28 +100,26 @@ hex2num ([\"402df854\"; \"41200000\"], \
           } num;
 
           num.ival = 0;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               unsigned char ch = cmat.elem (i, j);
 
-              if (isxdigit (ch))
-                {
-                  num.ival <<= 4;
-                  if (ch >= 'a')
-                    num.ival += static_cast<uint32_t> (ch - 'a' + 10);
-                  else if (ch >= 'A')
-                    num.ival += static_cast<uint32_t> (ch - 'A' + 10);
-                  else
-                    num.ival += static_cast<uint32_t> (ch - '0');
-                }
+              if (! isxdigit (ch))
+                error ("hex2num: illegal character found in string S");
+
+              num.ival <<= 4;
+              if (ch >= 'a')
+                num.ival += static_cast<uint32_t> (ch - 'a' + 10);
+              else if (ch >= 'A')
+                num.ival += static_cast<uint32_t> (ch - 'A' + 10);
               else
-                error ("hex2num: illegal character found in string S");
+                num.ival += static_cast<uint32_t> (ch - '0');
             }
 
           if (nc < nchars)
             num.ival <<= (nchars - nc) * 4;
 
           m(i) = num.dval;
         }
 
@@ -140,28 +138,26 @@ hex2num ([\"402df854\"; \"41200000\"], \
           } num;
 
           num.ival = 0;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               unsigned char ch = cmat.elem (i, j);
 
-              if (isxdigit (ch))
-                {
-                  num.ival <<= 4;
-                  if (ch >= 'a')
-                    num.ival += static_cast<uint64_t> (ch - 'a' + 10);
-                  else if (ch >= 'A')
-                    num.ival += static_cast<uint64_t> (ch - 'A' + 10);
-                  else
-                    num.ival += static_cast<uint64_t> (ch - '0');
-                }
+              if (! isxdigit (ch))
+                error ("hex2num: illegal character found in string S");
+
+              num.ival <<= 4;
+              if (ch >= 'a')
+                num.ival += static_cast<uint64_t> (ch - 'a' + 10);
+              else if (ch >= 'A')
+                num.ival += static_cast<uint64_t> (ch - 'A' + 10);
               else
-                error ("hex2num: illegal character found in string S");
+                num.ival += static_cast<uint64_t> (ch - '0');
             }
 
           if (nc < nchars)
             num.ival <<= (nchars - nc) * 4;
 
           m(i) = num.dval;
         }
 
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -398,68 +398,66 @@ do_load (std::istream& stream, const std
           gripe_unrecognized_data_fmt ("load");
           break;
         }
 
       if (stream.eof () || name.empty ())
         break;
       else
         {
-          if (tc.is_defined ())
-            {
-              if (format == LS_MAT_ASCII && argv_idx < argc)
-                warning ("load: loaded ASCII file '%s' -- ignoring extra args",
-                         orig_fname.c_str ());
+          if (! tc.is_defined ())
+            error ("load: unable to load variable '%s'", name.c_str ());
+
+          if (format == LS_MAT_ASCII && argv_idx < argc)
+            warning ("load: loaded ASCII file '%s' -- ignoring extra args",
+                     orig_fname.c_str ());
 
-              if (format == LS_MAT_ASCII
-                  || argv_idx == argc
-                  || matches_patterns (argv, argv_idx, argc, name))
+          if (format == LS_MAT_ASCII
+              || argv_idx == argc
+              || matches_patterns (argv, argv_idx, argc, name))
+            {
+              count++;
+              if (list_only)
                 {
-                  count++;
-                  if (list_only)
+                  if (verbose)
                     {
-                      if (verbose)
-                        {
-                          if (count == 1)
-                            output_buf
-                              << "type               rows   cols   name\n"
-                              << "====               ====   ====   ====\n";
+                      if (count == 1)
+                        output_buf
+                          << "type               rows   cols   name\n"
+                          << "====               ====   ====   ====\n";
 
-                          output_buf
-                            << std::setiosflags (std::ios::left)
-                            << std::setw (16) << tc.type_name () . c_str ()
-                            << std::setiosflags (std::ios::right)
-                            << std::setw (7) << tc.rows ()
-                            << std::setw (7) << tc.columns ()
-                            << "   " << name << "\n";
-                        }
-                      else
-                        symbol_names.push_back (name);
+                      output_buf
+                        << std::setiosflags (std::ios::left)
+                        << std::setw (16) << tc.type_name () . c_str ()
+                        << std::setiosflags (std::ios::right)
+                        << std::setw (7) << tc.rows ()
+                        << std::setw (7) << tc.columns ()
+                        << "   " << name << "\n";
                     }
                   else
+                    symbol_names.push_back (name);
+                }
+              else
+                {
+                  if (nargout == 1)
                     {
-                      if (nargout == 1)
-                        {
-                          if (format == LS_MAT_ASCII)
-                            retval = tc;
-                          else
-                            retstruct.assign (name, tc);
-                        }
+                      if (format == LS_MAT_ASCII)
+                        retval = tc;
                       else
-                        install_loaded_variable (name, tc, global, doc);
+                        retstruct.assign (name, tc);
                     }
+                  else
+                    install_loaded_variable (name, tc, global, doc);
                 }
-
-              // Only attempt to read one item from a headless text file.
+            }
 
-              if (format == LS_MAT_ASCII)
-                break;
-            }
-          else
-            error ("load: unable to load variable '%s'", name.c_str ());
+          // Only attempt to read one item from a headless text file.
+
+          if (format == LS_MAT_ASCII)
+            break;
         }
     }
 
   if (list_only && count)
     {
       if (verbose)
         {
           std::string msg = output_buf.str ();
@@ -825,46 +823,44 @@ Force Octave to assume the file is in Oc
               else
                 gripe_file_open ("load", orig_fname);
             }
           else
 #endif
             {
               std::ifstream file (fname.c_str (), mode);
 
-              if (file)
-                {
-                  if (format == LS_BINARY)
-                    {
-                      if (read_binary_file_header (file, swap, flt_fmt) < 0)
-                        {
-                          if (file) file.close ();
-                          return retval;
-                        }
-                    }
-                  else if (format == LS_MAT5_BINARY
-                           || format == LS_MAT7_BINARY)
-                    {
-                      if (read_mat5_binary_file_header (file, swap, false,
-                                                        orig_fname) < 0)
-                        {
-                          if (file) file.close ();
-                          return retval;
-                        }
-                    }
-
-                  retval = do_load (file, orig_fname, format,
-                                    flt_fmt, list_only, swap, verbose,
-                                    argv, i, argc, nargout);
-
-                  file.close ();
-                }
-              else
+              if (! file)
                 error ("load: unable to open input file '%s'",
                        orig_fname.c_str ());
+
+              if (format == LS_BINARY)
+                {
+                  if (read_binary_file_header (file, swap, flt_fmt) < 0)
+                    {
+                      if (file) file.close ();
+                      return retval;
+                    }
+                }
+              else if (format == LS_MAT5_BINARY
+                       || format == LS_MAT7_BINARY)
+                {
+                  if (read_mat5_binary_file_header (file, swap, false,
+                                                    orig_fname) < 0)
+                    {
+                      if (file) file.close ();
+                      return retval;
+                    }
+                }
+
+              retval = do_load (file, orig_fname, format,
+                                flt_fmt, list_only, swap, verbose,
+                                argv, i, argc, nargout);
+
+              file.close ();
             }
         }
       else
         error ("load: unable to determine file format of '%s'",
                orig_fname.c_str ());
 
     }
 
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -255,107 +255,105 @@ read_mat_ascii_data (std::istream& is, c
       char c = varname[i];
       if (! (isalnum (c) || c == '_'))
         varname[i] = '_';
     }
 
   if (is_keyword (varname) || ! isalpha (varname[0]))
     varname.insert (0, "X");
 
-  if (valid_identifier (varname))
-    {
-      octave_idx_type nr = 0;
-      octave_idx_type nc = 0;
-
-      int total_count = 0;
+  if (! valid_identifier (varname))
+    error ("load: unable to convert filename '%s' to valid identifier",
+           filename.c_str ());
 
-      get_lines_and_columns (is, nr, nc, filename);
-
-      octave_quit ();
+  octave_idx_type nr = 0;
+  octave_idx_type nc = 0;
 
-      if (nr > 0 && nc > 0)
-        {
-          Matrix tmp (nr, nc);
+  int total_count = 0;
+
+  get_lines_and_columns (is, nr, nc, filename);
+
+  octave_quit ();
 
-          if (nr < 1 || nc < 1)
-            is.clear (std::ios::badbit);
-          else
+  if (nr > 0 && nc > 0)
+    {
+      Matrix tmp (nr, nc);
+
+      if (nr < 1 || nc < 1)
+        is.clear (std::ios::badbit);
+      else
+        {
+          double d;
+          for (octave_idx_type i = 0; i < nr; i++)
             {
-              double d;
-              for (octave_idx_type i = 0; i < nr; i++)
-                {
-                  std::string buf = get_mat_data_input_line (is);
+              std::string buf = get_mat_data_input_line (is);
 
-                  std::istringstream tmp_stream (buf);
-
-                  for (octave_idx_type j = 0; j < nc; j++)
-                    {
-                      octave_quit ();
+              std::istringstream tmp_stream (buf);
 
-                      d = octave_read_value<double> (tmp_stream);
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  octave_quit ();
+
+                  d = octave_read_value<double> (tmp_stream);
 
-                      if (tmp_stream || tmp_stream.eof ())
+                  if (tmp_stream || tmp_stream.eof ())
+                    {
+                      tmp.elem (i, j) = d;
+                      total_count++;
+
+                      // Skip whitespace and commas.
+                      char c;
+                      while (1)
                         {
-                          tmp.elem (i, j) = d;
-                          total_count++;
-
-                          // Skip whitespace and commas.
-                          char c;
-                          while (1)
-                            {
-                              tmp_stream >> c;
+                          tmp_stream >> c;
 
-                              if (! tmp_stream)
-                                break;
+                          if (! tmp_stream)
+                            break;
 
-                              if (! (c == ' ' || c == '\t' || c == ','))
-                                {
-                                  tmp_stream.putback (c);
-                                  break;
-                                }
+                          if (! (c == ' ' || c == '\t' || c == ','))
+                            {
+                              tmp_stream.putback (c);
+                              break;
                             }
+                        }
 
-                          if (tmp_stream.eof ())
-                            break;
-                        }
-                      else
-                        error ("load: failed to read matrix from file '%s'",
-                               filename.c_str ());
+                      if (tmp_stream.eof ())
+                        break;
                     }
+                  else
+                    error ("load: failed to read matrix from file '%s'",
+                           filename.c_str ());
                 }
             }
+        }
 
-          if (is || is.eof ())
-            {
-              // FIXME: not sure this is best, but it works.
-
-              if (is.eof ())
-                is.clear ();
+      if (is || is.eof ())
+        {
+          // FIXME: not sure this is best, but it works.
 
-              octave_idx_type expected = nr * nc;
+          if (is.eof ())
+            is.clear ();
+
+          octave_idx_type expected = nr * nc;
 
-              if (expected == total_count)
-                {
-                  tc = tmp;
-                  retval = varname;
-                }
-              else
-                error ("load: expected %d elements, found %d",
-                       expected, total_count);
+          if (expected == total_count)
+            {
+              tc = tmp;
+              retval = varname;
             }
           else
-            error ("load: failed to read matrix from file '%s'",
-                   filename.c_str ());
+            error ("load: expected %d elements, found %d",
+                   expected, total_count);
         }
       else
-        error ("load: unable to extract matrix size from file '%s'",
+        error ("load: failed to read matrix from file '%s'",
                filename.c_str ());
     }
   else
-    error ("load: unable to convert filename '%s' to valid identifier",
+    error ("load: unable to extract matrix size from file '%s'",
            filename.c_str ());
 
   return retval;
 }
 
 bool
 save_mat_ascii_data (std::ostream& os, const octave_value& val,
                      int precision, bool tabs)
diff --git a/libinterp/corefcn/ls-oct-text.cc b/libinterp/corefcn/ls-oct-text.cc
--- a/libinterp/corefcn/ls-oct-text.cc
+++ b/libinterp/corefcn/ls-oct-text.cc
@@ -350,59 +350,57 @@ save_text_data_for_plotting (std::ostrea
 bool
 save_three_d (std::ostream& os, const octave_value& tc, bool parametric)
 {
   bool fail = false;
 
   octave_idx_type nr = tc.rows ();
   octave_idx_type nc = tc.columns ();
 
-  if (tc.is_real_matrix ())
-    {
-      os << "# 3-D data...\n"
-         << "# type: matrix\n"
-         << "# total rows: " << nr << "\n"
-         << "# total columns: " << nc << "\n";
+  if (! tc.is_real_matrix ())
+    error ("for now, I can only save real matrices in 3-D format");
 
-      long old_precision = os.precision ();
-      os.precision (6);
+  os << "# 3-D data...\n"
+     << "# type: matrix\n"
+     << "# total rows: " << nr << "\n"
+     << "# total columns: " << nc << "\n";
 
-      if (parametric)
-        {
-          octave_idx_type extras = nc % 3;
-          if (extras)
-            warning ("ignoring last %d columns", extras);
-
-          Matrix tmp = tc.matrix_value ();
-          nr = tmp.rows ();
+  long old_precision = os.precision ();
+  os.precision (6);
 
-          for (octave_idx_type i = 0; i < nc-extras; i += 3)
-            {
-              os << tmp.extract (0, i, nr-1, i+2);
-              if (i+3 < nc-extras)
-                os << "\n";
-            }
-        }
-      else
+  if (parametric)
+    {
+      octave_idx_type extras = nc % 3;
+      if (extras)
+        warning ("ignoring last %d columns", extras);
+
+      Matrix tmp = tc.matrix_value ();
+      nr = tmp.rows ();
+
+      for (octave_idx_type i = 0; i < nc-extras; i += 3)
         {
-          Matrix tmp = tc.matrix_value ();
-          nr = tmp.rows ();
-
-          for (octave_idx_type i = 0; i < nc; i++)
-            {
-              os << tmp.extract (0, i, nr-1, i);
-              if (i+1 < nc)
-                os << "\n";
-            }
+          os << tmp.extract (0, i, nr-1, i+2);
+          if (i+3 < nc-extras)
+            os << "\n";
         }
-
-      os.precision (old_precision);
     }
   else
-    error ("for now, I can only save real matrices in 3-D format");
+    {
+      Matrix tmp = tc.matrix_value ();
+      nr = tmp.rows ();
+
+      for (octave_idx_type i = 0; i < nc; i++)
+        {
+          os << tmp.extract (0, i, nr-1, i);
+          if (i+1 < nc)
+            os << "\n";
+        }
+    }
+
+  os.precision (old_precision);
 
   return (os && ! fail);
 }
 
 DEFUN (save_precision, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} save_precision ()\n\
 @deftypefnx {} {@var{old_val} =} save_precision (@var{new_val})\n\
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -234,18 +234,16 @@ do_history (const octave_value_list& arg
             }
 
           else
             {
               if (option.length () > 0 && option[0] == '-')
                 error ("history: unrecognized option '%s'", option.c_str ());
               else
                 error ("history: bad non-numeric arg '%s'", option.c_str ());
-
-              return  hlist;
             }
         }
     }
 
   hlist = command_history::list (limit, numbered_output);
 
   int len = hlist.numel ();
 
diff --git a/libinterp/corefcn/oct-lvalue.cc b/libinterp/corefcn/oct-lvalue.cc
--- a/libinterp/corefcn/oct-lvalue.cc
+++ b/libinterp/corefcn/oct-lvalue.cc
@@ -40,23 +40,21 @@ octave_lvalue::assign (octave_value::ass
         sym->assign (op, type, idx, rhs);
     }
 }
 
 void
 octave_lvalue::set_index (const std::string& t,
                           const std::list<octave_value_list>& i)
 {
-  if (idx.empty ())
-    {
-      type = t;
-      idx = i;
-    }
-  else
+  if (! idx.empty ())
     error ("invalid index expression in assignment");
+
+  type = t;
+  idx = i;
 }
 
 bool
 octave_lvalue::index_is_empty (void) const
 {
   bool retval = false;
 
   if (idx.size () == 1)
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -209,25 +209,23 @@ octave_scalar_map
 octave_scalar_map::orderfields (const octave_scalar_map& other,
                                 Array<octave_idx_type>& perm) const
 {
   if (xkeys.is_same (other.xkeys))
     return *this;
   else
     {
       octave_scalar_map retval (other.xkeys);
-      if (other.xkeys.equal_up_to_order (xkeys, perm))
-        {
-          octave_idx_type nf = nfields ();
-          for (octave_idx_type i = 0; i < nf; i++)
-            retval.xvals[i] = xvals[perm.xelem (i)];
-        }
-      else
+      if (! other.xkeys.equal_up_to_order (xkeys, perm))
         error ("orderfields: structs must have same fields up to order");
 
+      octave_idx_type nf = nfields ();
+      for (octave_idx_type i = 0; i < nf; i++)
+        retval.xvals[i] = xvals[perm.xelem (i)];
+
       return retval;
     }
 }
 
 octave_value
 octave_scalar_map::contents (const std::string& k) const
 {
   return getfield (k);
@@ -311,25 +309,23 @@ octave_map
 octave_map::orderfields (const octave_map& other,
                          Array<octave_idx_type>& perm) const
 {
   if (xkeys.is_same (other.xkeys))
     return *this;
   else
     {
       octave_map retval (other.xkeys);
-      if (other.xkeys.equal_up_to_order (xkeys, perm))
-        {
-          octave_idx_type nf = nfields ();
-          for (octave_idx_type i = 0; i < nf; i++)
-            retval.xvals[i] = xvals[perm.xelem (i)];
-        }
-      else
+      if (! other.xkeys.equal_up_to_order (xkeys, perm))
         error ("orderfields: structs must have same fields up to order");
 
+      octave_idx_type nf = nfields ();
+      for (octave_idx_type i = 0; i < nf; i++)
+        retval.xvals[i] = xvals[perm.xelem (i)];
+
       return retval;
     }
 }
 
 Cell
 octave_map::contents (const std::string& k) const
 {
   return getfield (k);
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -922,53 +922,51 @@ run_command_and_return_output (const std
   octave_value_list retval;
   unwind_protect frame;
 
   iprocstream *cmd = new iprocstream (cmd_str.c_str ());
 
   frame.add_delete (cmd);
   frame.add_fcn (octave_child_list::remove, cmd->pid ());
 
-  if (*cmd)
-    {
-      int fid = cmd->file_number ();
+  if (! *cmd)
+    error ("system: unable to start subprocess for '%s'", cmd_str.c_str ());
+
+  int fid = cmd->file_number ();
+
+  std::ostringstream output_buf;
 
-      std::ostringstream output_buf;
+  char ch;
 
-      char ch;
-
-      for (;;)
+  for (;;)
+    {
+      if (cmd->get (ch))
+        output_buf.put (ch);
+      else
         {
-          if (cmd->get (ch))
-            output_buf.put (ch);
-          else
+          if (! cmd->eof () && errno == EAGAIN)
             {
-              if (! cmd->eof () && errno == EAGAIN)
-                {
-                  cmd->clear ();
+              cmd->clear ();
 
-                  if (wait_for_input (fid) != 1)
-                    break;
-                }
-              else
+              if (wait_for_input (fid) != 1)
                 break;
             }
+          else
+            break;
         }
+    }
 
-      int cmd_status = cmd->close ();
+  int cmd_status = cmd->close ();
 
-      if (octave_wait::ifexited (cmd_status))
-        cmd_status = octave_wait::exitstatus (cmd_status);
-      else
-        cmd_status = 127;
+  if (octave_wait::ifexited (cmd_status))
+    cmd_status = octave_wait::exitstatus (cmd_status);
+  else
+    cmd_status = 127;
 
-      retval = ovl (cmd_status, output_buf.str ());
-    }
-  else
-    error ("system: unable to start subprocess for '%s'", cmd_str.c_str ());
+  retval = ovl (cmd_status, output_buf.str ());
 
   return retval;
 }
 
 enum system_exec_type { et_sync, et_async };
 
 DEFUN (system, args, nargout,
        "-*- texinfo -*-\n\
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -809,23 +809,21 @@ public:
     this->hide ();
     Fl::check ();
   }
 
   double number (void) { return fp.get___myhandle__ ().value (); }
 
   void renumber (double new_number)
   {
-    if (canvas)
-      {
-        if (canvas->renumber (new_number))
-          mark_modified ();
-      }
-    else
+    if (! canvas)
       error ("unable to renumber figure");
+
+    if (canvas->renumber (new_number))
+      mark_modified ();
   }
 
   void print (const std::string& cmd, const std::string& term)
   {
     canvas->print (cmd, term);
   }
 
   void show_menubar (void)
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -202,40 +202,38 @@ octave_base_int_matrix<T>::save_ascii (s
 
 template <class T>
 bool
 octave_base_int_matrix<T>::load_ascii (std::istream& is)
 {
   int mdims = 0;
   bool success = true;
 
-  if (extract_keyword (is, "ndims", mdims, true))
+  if (! extract_keyword (is, "ndims", mdims, true))
+    error ("load: failed to extract number of dimensions");
+
+  if (mdims >= 0)
     {
-      if (mdims >= 0)
-        {
-          dim_vector dv;
-          dv.resize (mdims);
-
-          for (int i = 0; i < mdims; i++)
-            is >> dv(i);
+      dim_vector dv;
+      dv.resize (mdims);
 
-          T tmp(dv);
+      for (int i = 0; i < mdims; i++)
+        is >> dv(i);
 
-          is >> tmp;
+      T tmp(dv);
 
-          if (! is)
-            error ("load: failed to load matrix constant");
+      is >> tmp;
 
-          this->matrix = tmp;
-        }
-      else
-        error ("load: failed to extract number of rows and columns");
+      if (! is)
+        error ("load: failed to load matrix constant");
+
+      this->matrix = tmp;
     }
   else
-    error ("load: failed to extract number of dimensions");
+    error ("load: failed to extract number of rows and columns");
 
   return success;
 }
 
 template <class T>
 bool
 octave_base_int_matrix<T>::save_binary (std::ostream& os, bool&)
 {
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -220,94 +220,86 @@ octave_bool_matrix::load_ascii (std::ist
   string_vector keywords (2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
 
   std::string kw;
   octave_idx_type val = 0;
 
-  if (extract_keyword (is, keywords, kw, val, true))
-    {
-      if (kw == "ndims")
-        {
-          int mdims = static_cast<int> (val);
+  if (! extract_keyword (is, keywords, kw, val, true))
+    error ("load: failed to extract number of rows and columns");
 
-          if (mdims >= 0)
-            {
-              dim_vector dv;
-              dv.resize (mdims);
-
-              for (int i = 0; i < mdims; i++)
-                is >> dv(i);
+  if (kw == "ndims")
+    {
+      int mdims = static_cast<int> (val);
 
-              if (is)
-                {
-                  boolNDArray btmp (dv);
+      if (mdims >= 0)
+        {
+          dim_vector dv;
+          dv.resize (mdims);
 
-                  if (btmp.is_empty ())
-                    matrix = btmp;
-                  else
-                    {
-                      NDArray tmp(dv);
-                      is >> tmp;
+          for (int i = 0; i < mdims; i++)
+            is >> dv(i);
 
-                      if (is)
-                        {
-                          for (octave_idx_type i = 0; i < btmp.numel (); i++)
-                            btmp.elem (i) = (tmp.elem (i) != 0.);
+          if (! is)
+            error ("load: failed to extract dimensions");
 
-                          matrix = btmp;
-                        }
-                      else
-                        error ("load: failed to load matrix constant");
-                    }
-                }
-              else
-                error ("load: failed to extract dimensions");
-            }
+          boolNDArray btmp (dv);
+
+          if (btmp.is_empty ())
+            matrix = btmp;
           else
-            error ("load: failed to extract number of dimensions");
-        }
-      else if (kw == "rows")
-        {
-          octave_idx_type nr = val;
-          octave_idx_type nc = 0;
-
-          if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
             {
-              if (nr > 0 && nc > 0)
-                {
-                  Matrix tmp (nr, nc);
-                  is >> tmp;
-                  if (is)
-                    {
-                      boolMatrix btmp (nr, nc);
-                      for (octave_idx_type j = 0; j < nc; j++)
-                        for (octave_idx_type i = 0; i < nr; i++)
-                          btmp.elem (i,j) = (tmp.elem (i, j) != 0.);
+              NDArray tmp(dv);
+              is >> tmp;
+
+              if (! is)
+                error ("load: failed to load matrix constant");
 
-                      matrix = btmp;
-                    }
-                  else
-                    error ("load: failed to load matrix constant");
-                }
-              else if (nr == 0 || nc == 0)
-                matrix = boolMatrix (nr, nc);
-              else
-                panic_impossible ();
+              for (octave_idx_type i = 0; i < btmp.numel (); i++)
+                btmp.elem (i) = (tmp.elem (i) != 0.);
+
+              matrix = btmp;
             }
-          else
-            error ("load: failed to extract number of rows and columns");
         }
       else
-        panic_impossible ();
+        error ("load: failed to extract number of dimensions");
+    }
+  else if (kw == "rows")
+    {
+      octave_idx_type nr = val;
+      octave_idx_type nc = 0;
+
+      if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+        {
+          if (nr > 0 && nc > 0)
+            {
+              Matrix tmp (nr, nc);
+              is >> tmp;
+              if (! is)
+                error ("load: failed to load matrix constant");
+
+              boolMatrix btmp (nr, nc);
+              for (octave_idx_type j = 0; j < nc; j++)
+                for (octave_idx_type i = 0; i < nr; i++)
+                  btmp.elem (i,j) = (tmp.elem (i, j) != 0.);
+
+              matrix = btmp;
+            }
+          else if (nr == 0 || nc == 0)
+            matrix = boolMatrix (nr, nc);
+          else
+            panic_impossible ();
+        }
+      else
+        error ("load: failed to extract number of rows and columns");
     }
   else
-    error ("load: failed to extract number of rows and columns");
+    panic_impossible ();
 
   return success;
 }
 
 bool
 octave_bool_matrix::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
 
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -613,25 +613,23 @@ octave_cell::all_strings (bool pad) cons
   return retval;
 }
 
 Array<std::string>
 octave_cell::cellstr_value (void) const
 {
   Array<std::string> retval;
 
-  if (is_cellstr ())
-    {
-      if (cellstr_cache->is_empty ())
-        *cellstr_cache = matrix.cellstr_value ();
+  if (! is_cellstr ())
+    error ("invalid conversion from cell array to array of strings");
 
-      return *cellstr_cache;
-    }
-  else
-    error ("invalid conversion from cell array to array of strings");
+  if (cellstr_cache->is_empty ())
+    *cellstr_cache = matrix.cellstr_value ();
+
+  return *cellstr_cache;
 
   return retval;
 }
 
 bool
 octave_cell::print_as_scalar (void) const
 {
   return true;
@@ -771,108 +769,106 @@ octave_cell::load_ascii (std::istream& i
   string_vector keywords(2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
 
   std::string kw;
   octave_idx_type val = 0;
 
-  if (extract_keyword (is, keywords, kw, val, true))
+  if (! extract_keyword (is, keywords, kw, val, true))
+    error ("load: failed to extract number of rows and columns");
+
+  if (kw == "ndims")
     {
-      if (kw == "ndims")
+      int mdims = static_cast<int> (val);
+
+      if (mdims >= 0)
         {
-          int mdims = static_cast<int> (val);
+          dim_vector dv;
+          dv.resize (mdims);
 
-          if (mdims >= 0)
+          for (int i = 0; i < mdims; i++)
+            is >> dv(i);
+
+          Cell tmp(dv);
+
+          for (octave_idx_type i = 0; i < dv.numel (); i++)
             {
-              dim_vector dv;
-              dv.resize (mdims);
+              octave_value t2;
+              bool dummy;
+
+              // recurse to read cell elements
+              std::string nm = read_text_data (is, std::string (),
+                                                dummy, t2, i);
 
-              for (int i = 0; i < mdims; i++)
-                is >> dv(i);
-
-              Cell tmp(dv);
+              if (nm == CELL_ELT_TAG)
+                {
+                  if (is)
+                    tmp.elem (i) = t2;
+                }
+              else
+                error ("load: cell array element had unexpected name");
+            }
 
-              for (octave_idx_type i = 0; i < dv.numel (); i++)
-                {
-                  octave_value t2;
-                  bool dummy;
+          if (is)
+            matrix = tmp;
+          else
+            error ("load: failed to load matrix constant");
+        }
+      else
+        error ("load: failed to extract number of rows and columns");
+    }
+  else if (kw == "rows")
+    {
+      octave_idx_type nr = val;
+      octave_idx_type nc = 0;
+
+      if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+        {
+          if (nr > 0 && nc > 0)
+            {
+              Cell tmp (nr, nc);
 
-                  // recurse to read cell elements
-                  std::string nm = read_text_data (is, std::string (),
-                                                    dummy, t2, i);
-
-                  if (nm == CELL_ELT_TAG)
+              for (octave_idx_type j = 0; j < nc; j++)
+                {
+                  for (octave_idx_type i = 0; i < nr; i++)
                     {
-                      if (is)
-                        tmp.elem (i) = t2;
+                      octave_value t2;
+                      bool dummy;
+
+                      // recurse to read cell elements
+                      std::string nm = read_text_data (is, std::string (),
+                                                        dummy, t2, i);
+
+                      if (nm == CELL_ELT_TAG)
+                        {
+                          if (is)
+                            tmp.elem (i, j) = t2;
+                        }
+                      else
+                        error ("load: cell array element had unexpected name");
                     }
-                  else
-                    error ("load: cell array element had unexpected name");
                 }
 
               if (is)
                 matrix = tmp;
               else
-                error ("load: failed to load matrix constant");
+                error ("load: failed to load cell element");
             }
+          else if (nr == 0 || nc == 0)
+            matrix = Cell (nr, nc);
           else
-            error ("load: failed to extract number of rows and columns");
-        }
-      else if (kw == "rows")
-        {
-          octave_idx_type nr = val;
-          octave_idx_type nc = 0;
-
-          if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
-            {
-              if (nr > 0 && nc > 0)
-                {
-                  Cell tmp (nr, nc);
-
-                  for (octave_idx_type j = 0; j < nc; j++)
-                    {
-                      for (octave_idx_type i = 0; i < nr; i++)
-                        {
-                          octave_value t2;
-                          bool dummy;
-
-                          // recurse to read cell elements
-                          std::string nm = read_text_data (is, std::string (),
-                                                            dummy, t2, i);
-
-                          if (nm == CELL_ELT_TAG)
-                            {
-                              if (is)
-                                tmp.elem (i, j) = t2;
-                            }
-                          else
-                            error ("load: cell array element had unexpected name");
-                        }
-                    }
-
-                  if (is)
-                    matrix = tmp;
-                  else
-                    error ("load: failed to load cell element");
-                }
-              else if (nr == 0 || nc == 0)
-                matrix = Cell (nr, nc);
-              else
-                panic_impossible ();
-            }
-          else
-            error ("load: failed to extract number of rows and columns for cell array");
+            panic_impossible ();
         }
       else
-        panic_impossible ();
+        error ("load: failed to extract number of rows and columns for cell array");
     }
   else
-    error ("load: failed to extract number of rows and columns");
+    panic_impossible ();
 
   return true;
 }
 
 bool
 octave_cell::save_binary (std::ostream& os, bool& save_as_floats)
 {
   dim_vector d = dims ();
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -595,25 +595,23 @@ octave_class::subsasgn_common (const oct
   // attempting to do the indexed assignment.
 
   std::string method_class = get_current_method_class ();
 
   octave_base_value *obvp = unique_parent_class (method_class);
   if (obvp != this)
     {
 
-      if (obvp)
-        {
-          obvp->subsasgn (type, idx, rhs);
+      if (! obvp)
+        error ("malformed class");
 
-          count++;
-          retval = octave_value (this);
-        }
-      else
-        error ("malformed class");
+      obvp->subsasgn (type, idx, rhs);
+
+      count++;
+      retval = octave_value (this);
 
       return retval;
     }
 
   // FIXME: this block of code is the same as the body of
   // octave_struct::subsasgn.  Maybe it could be shared instead of
   // duplicated.
 
@@ -746,25 +744,23 @@ octave_class::subsasgn_common (const oct
 
                 map.assign (idx.front (), rhs_map);
 
                 count++;
                 retval = octave_value (this);
               }
             else
               {
-                if (t_rhs.is_empty ())
-                  {
-                    map.delete_elements (idx.front ());
+                if (! t_rhs.is_empty ())
+                  error ("invalid class assignment");
 
-                    count++;
-                    retval = octave_value (this);
-                  }
-                else
-                  error ("invalid class assignment");
+                map.delete_elements (idx.front ());
+
+                count++;
+                retval = octave_value (this);
               }
           }
       }
       break;
 
     case '.':
       {
         octave_value_list key_idx = idx.front ();
@@ -811,37 +807,35 @@ octave_class::subsasgn_common (const oct
 
 idx_vector
 octave_class::index_vector (bool require_integers) const
 {
   idx_vector retval;
 
   octave_value meth = symbol_table::find_method ("subsindex", class_name ());
 
-  if (meth.is_defined ())
-    {
-      octave_value_list args;
-      args(0) = octave_value (new octave_class (map, c_name, parent_list));
-
-      octave_value_list tmp = feval (meth.function_value (), args, 1);
-
-      if (tmp(0).is_object ())
-        error ("subsindex function must return a valid index vector");
-      else
-        // Index vector returned by subsindex is zero based
-        // (why this inconsistency Mathworks?), and so we must
-        // add one to the value returned as the index_vector method
-        // expects it to be one based.
-        retval = do_binary_op (octave_value::op_add, tmp (0),
-                               octave_value (1.0)).index_vector (require_integers);
-    }
-  else
+  if (! meth.is_defined ())
     error ("no subsindex method defined for class %s",
            class_name ().c_str ());
 
+  octave_value_list args;
+  args(0) = octave_value (new octave_class (map, c_name, parent_list));
+
+  octave_value_list tmp = feval (meth.function_value (), args, 1);
+
+  if (tmp(0).is_object ())
+    error ("subsindex function must return a valid index vector");
+  else
+    // Index vector returned by subsindex is zero based
+    // (why this inconsistency Mathworks?), and so we must
+    // add one to the value returned as the index_vector method
+    // expects it to be one based.
+    retval = do_binary_op (octave_value::op_add, tmp (0),
+                           octave_value (1.0)).index_vector (require_integers);
+
   return retval;
 }
 
 size_t
 octave_class::byte_size (void) const
 {
   // Neglect the size of the fieldnames.
 
@@ -967,33 +961,31 @@ octave_class::is_instance_of (const std:
 
 string_vector
 octave_class::all_strings (bool pad) const
 {
   string_vector retval;
 
   octave_value meth = symbol_table::find_method ("char", class_name ());
 
-  if (meth.is_defined ())
-    {
-      octave_value_list args;
-      args(0) = octave_value (new octave_class (map, c_name, parent_list));
+  if (! meth.is_defined ())
+    error ("no char method defined for class %s", class_name ().c_str ());
 
-      octave_value_list tmp = feval (meth.function_value (), args, 1);
+  octave_value_list args;
+  args(0) = octave_value (new octave_class (map, c_name, parent_list));
+
+  octave_value_list tmp = feval (meth.function_value (), args, 1);
 
-      if (tmp.length () >= 1)
-        {
-          if (tmp(0).is_string ())
-            retval = tmp(0).all_strings (pad);
-          else
-            error ("cname/char method did not return a string");
-        }
+  if (tmp.length () >= 1)
+    {
+      if (tmp(0).is_string ())
+        retval = tmp(0).all_strings (pad);
+      else
+        error ("cname/char method did not return a string");
     }
-  else
-    error ("no char method defined for class %s", class_name ().c_str ());
 
   return retval;
 }
 
 
 void
 octave_class::print (std::ostream& os, bool)
 {
@@ -1243,37 +1235,35 @@ octave_class::load_ascii (std::istream& 
                   if (! is)
                     break;
 
                   Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2);
 
                   m.assign (nm, tcell);
                 }
 
-              if (is)
-                {
-                  c_name = classname;
-                  reconstruct_exemplar ();
+              if (! is)
+                error ("load: failed to load class");
 
-                  map = m;
+              c_name = classname;
+              reconstruct_exemplar ();
 
-                  if (! reconstruct_parents ())
-                    warning ("load: unable to reconstruct object inheritance");
+              map = m;
 
-                  if (load_path::find_method (classname, "loadobj")
-                      != std::string ())
-                    {
-                      octave_value in = new octave_class (*this);
-                      octave_value_list tmp = feval ("loadobj", in, 1);
+              if (! reconstruct_parents ())
+                warning ("load: unable to reconstruct object inheritance");
 
-                      map = tmp(0).map_value ();
-                    }
+              if (load_path::find_method (classname, "loadobj")
+                  != std::string ())
+                {
+                  octave_value in = new octave_class (*this);
+                  octave_value_list tmp = feval ("loadobj", in, 1);
+
+                  map = tmp(0).map_value ();
                 }
-              else
-                error ("load: failed to load class");
             }
           else if (len == 0)
             {
               map = octave_map (dim_vector (1, 1));
               c_name = classname;
             }
           else
             panic_impossible ();
@@ -1661,72 +1651,68 @@ octave_class::in_class_method (void)
               || fcn->is_anonymous_function_of_class ()
               || fcn->is_private_function_of_class (class_name ()))
           && find_parent_class (fcn->dispatch_class ()));
 }
 
 octave_class::exemplar_info::exemplar_info (const octave_value& obj)
   : field_names (), parent_class_names ()
 {
-  if (obj.is_object ())
-    {
-      octave_map m = obj.map_value ();
-      field_names = m.keys ();
+  if (! obj.is_object ())
+    error ("invalid call to exemplar_info constructor");
 
-      parent_class_names = obj.parent_class_name_list ();
-    }
-  else
-    error ("invalid call to exemplar_info constructor");
+  octave_map m = obj.map_value ();
+  field_names = m.keys ();
+
+  parent_class_names = obj.parent_class_name_list ();
 }
 
 
 // A map from class names to lists of fields.
 std::map<std::string, octave_class::exemplar_info> octave_class::exemplar_map;
 
 bool
 octave_class::exemplar_info::compare (const octave_value& obj) const
 {
 
-  if (obj.is_object ())
+  if (! obj.is_object ())
+    error ("invalid comparison of class exemplar to non-class object");
+
+  if (nfields () == obj.nfields ())
     {
-      if (nfields () == obj.nfields ())
-        {
-          octave_map obj_map = obj.map_value ();
-          string_vector obj_fnames = obj_map.keys ();
-          string_vector fnames = fields ();
+      octave_map obj_map = obj.map_value ();
+      string_vector obj_fnames = obj_map.keys ();
+      string_vector fnames = fields ();
 
-          for (octave_idx_type i = 0; i < nfields (); i++)
-            {
-              if (obj_fnames[i] != fnames[i])
-                error ("mismatch in field names");
-            }
+      for (octave_idx_type i = 0; i < nfields (); i++)
+        {
+          if (obj_fnames[i] != fnames[i])
+            error ("mismatch in field names");
+        }
 
-          if (nparents () == obj.nparents ())
+      if (nparents () == obj.nparents ())
+        {
+          std::list<std::string> obj_parents
+            = obj.parent_class_name_list ();
+          std::list<std::string> pnames = parents ();
+
+          std::list<std::string>::const_iterator p = obj_parents.begin ();
+          std::list<std::string>::const_iterator q = pnames.begin ();
+
+          while (p != obj_parents.end ())
             {
-              std::list<std::string> obj_parents
-                = obj.parent_class_name_list ();
-              std::list<std::string> pnames = parents ();
-
-              std::list<std::string>::const_iterator p = obj_parents.begin ();
-              std::list<std::string>::const_iterator q = pnames.begin ();
-
-              while (p != obj_parents.end ())
-                {
-                  if (*p++ != *q++)
-                    error ("mismatch in parent classes");
-                }
+              if (*p++ != *q++)
+                error ("mismatch in parent classes");
             }
-          else
-            error ("mismatch in number of parent classes");
         }
       else
-        error ("mismatch in number of fields");
+        error ("mismatch in number of parent classes");
     }
   else
-    error ("invalid comparison of class exemplar to non-class object");
+    error ("mismatch in number of fields");
 
   return true;
 }
 
 DEFUN (class, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{classname} =} class (@var{obj})\n\
 @deftypefnx {} {} class (@var{s}, @var{id})\n\
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -540,27 +540,24 @@ class_fevalStatic (const octave_value_li
   if (args.length () > 1 && args(0).type_name () == "object")
     {
       cdef_class cls (to_cdef (args(0)));
 
       std::string meth_name = args(1).xstring_value ("fevalStatic: method name must be a string");
 
       cdef_method meth = cls.find_method (meth_name);
 
-      if (meth.ok ())
-        {
-          if (meth.is_static ())
-            retval = meth.execute (args.splice (0, 2), nargout,
-                                   true, "fevalStatic");
-          else
-            error ("fevalStatic: method `%s' is not static",
-                   meth_name.c_str ());
-        }
+      if (! meth.ok ())
+        error ("fevalStatic: method not found: %s", meth_name.c_str ());
+
+      if (meth.is_static ())
+        retval = meth.execute (args.splice (0, 2), nargout,
+                               true, "fevalStatic");
       else
-        error ("fevalStatic: method not found: %s", meth_name.c_str ());
+        error ("fevalStatic: method `%s' is not static", meth_name.c_str ());
     }
   else
     error ("fevalStatic: first argument must be a meta.class object");
 
   return retval;
 }
 
 static octave_value_list
@@ -572,26 +569,24 @@ class_getConstant (const octave_value_li
       && args(0).class_name () == "meta.class")
     {
       cdef_class cls = to_cdef (args(0));
 
       std::string prop_name = args(1).xstring_value ("getConstant: property name must be a string");
 
       cdef_property prop = cls.find_property (prop_name);
 
-      if (prop.ok ())
-        {
-          if (prop.is_constant ())
-            retval(0) = prop.get_value (true, "getConstant");
-          else
-            error ("getConstant: property `%s' is not constant",
-                   prop_name.c_str ());
-        }
+      if (! prop.ok ())
+        error ("getConstant: property not found: %s",
+               prop_name.c_str ());
+
+      if (prop.is_constant ())
+        retval(0) = prop.get_value (true, "getConstant");
       else
-        error ("getConstant: property not found: %s",
+        error ("getConstant: property `%s' is not constant",
                prop_name.c_str ());
     }
   else
     error ("getConstant: first argument must be a meta.class object");
 
   return retval;
 }
 
@@ -1165,80 +1160,72 @@ public:
     octave_value_list retval;
 
     std::string meth_name;
     bool in_constructor;
     cdef_class ctx;
 
     ctx = get_class_context (meth_name, in_constructor);
 
-    if (ctx.ok ())
+    if (! ctx.ok ())
+      error ("superclass calls can only occur in methods or constructors");
+
+    std::string mname = args(0).string_value ();
+    std::string cname = args(1).string_value ();
+
+    cdef_class cls = lookup_class (cname);
+
+    if (in_constructor)
       {
-        std::string mname = args(0).string_value ();
-        std::string cname = args(1).string_value ();
-
-        cdef_class cls = lookup_class (cname);
-
-        if (in_constructor)
+        if (! is_direct_superclass (cls, ctx))
+          error ("`%s' is not a direct superclass of `%s'",
+                 cname.c_str (), ctx.get_name ().c_str ());
+
+        if (! is_constructed_object (mname))
+          error ("cannot call superclass constructor with "
+                 "variable `%s'", mname.c_str ());
+
+        octave_value sym = symbol_table::varval (mname);
+
+        cls.run_constructor (to_cdef_ref (sym), idx);
+
+        retval(0) = sym;
+      }
+    else
+      {
+        if (mname == meth_name)
           {
-            if (is_direct_superclass (cls, ctx))
-              {
-                if (is_constructed_object (mname))
-                  {
-                    octave_value sym = symbol_table::varval (mname);
-
-                    cls.run_constructor (to_cdef_ref (sym), idx);
-
-                    retval(0) = sym;
-                  }
-                else
-                  error ("cannot call superclass constructor with "
-                         "variable `%s'", mname.c_str ());
-              }
+            if (! is_strict_superclass (cls, ctx))
+              error ("`%s' is not a superclass of `%s'",
+                     cname.c_str (), ctx.get_name ().c_str ());
+
+            // I see 2 possible implementations here:
+            // 1) use cdef_object::subsref with a different class
+            //    context; this avoids duplicating code, but
+            //    assumes the object is always the first argument
+            // 2) lookup the method manually and call
+            //    cdef_method::execute; this duplicates part of
+            //    logic in cdef_object::subsref, but avoid the
+            //    assumption of 1)
+            // Not being sure about the assumption of 1), I
+            // go with option 2) for the time being.
+
+            cdef_method meth = cls.find_method (meth_name, false);
+
+            if (meth.ok ())
+              retval = meth.execute (idx, nargout, true,
+                                     meth_name);
             else
-              error ("`%s' is not a direct superclass of `%s'",
-                     cname.c_str (), ctx.get_name ().c_str ());
+              error ("no method `%s' found in superclass `%s'",
+                     meth_name.c_str (), cname.c_str ());
           }
         else
-          {
-            if (mname == meth_name)
-              {
-                if (is_strict_superclass (cls, ctx))
-                  {
-                    // I see 2 possible implementations here:
-                    // 1) use cdef_object::subsref with a different class
-                    //    context; this avoids duplicating code, but
-                    //    assumes the object is always the first argument
-                    // 2) lookup the method manually and call
-                    //    cdef_method::execute; this duplicates part of
-                    //    logic in cdef_object::subsref, but avoid the
-                    //    assumption of 1)
-                    // Not being sure about the assumption of 1), I
-                    // go with option 2) for the time being.
-
-                    cdef_method meth = cls.find_method (meth_name, false);
-
-                    if (meth.ok ())
-                      retval = meth.execute (idx, nargout, true,
-                                             meth_name);
-                    else
-                      error ("no method `%s' found in superclass `%s'",
-                             meth_name.c_str (), cname.c_str ());
-                  }
-                else
-                  error ("`%s' is not a superclass of `%s'",
-                         cname.c_str (), ctx.get_name ().c_str ());
-              }
-            else
-              error ("method name mismatch (`%s' != `%s')",
-                     mname.c_str (), meth_name.c_str ());
-          }
+          error ("method name mismatch (`%s' != `%s')",
+                 mname.c_str (), meth_name.c_str ());
       }
-    else
-      error ("superclass calls can only occur in methods or constructors");
 
     return retval;
   }
 
 private:
   bool is_constructed_object (const std::string nm)
   {
     octave_function *of = octave_call_stack::current ();
@@ -1373,31 +1360,29 @@ cdef_object_scalar::subsref (const std::
                                        true, "subsref");
               }
           }
 
         if (skip == 0)
           {
             cdef_property prop = cls.find_property (name);
 
-            if (prop.ok ())
+            if (! prop.ok ())
+              error ("subsref: unknown method or property: %s", name.c_str ());
+
+            if (prop.is_constant ())
+              retval(0) = prop.get_value (true, "subsref");
+            else
               {
-                if (prop.is_constant ())
-                  retval(0) = prop.get_value (true, "subsref");
-                else
-                  {
-                    refcount++;
-                    retval(0) = prop.get_value (cdef_object (this),
-                                                true, "subsref");
-                  }
-
-                skip = 1;
+                refcount++;
+                retval(0) = prop.get_value (cdef_object (this),
+                                            true, "subsref");
               }
-            else
-              error ("subsref: unknown method or property: %s", name.c_str ());
+
+            skip = 1;
           }
         break;
       }
 
     case '(':
       {
         const octave_value_list& ival = idx.front ();
 
@@ -1442,55 +1427,53 @@ cdef_object_scalar::subsasgn (const std:
   switch (type[0])
     {
     case '.':
       {
         std::string name = (idx.front ())(0).string_value ();
 
         cdef_property prop = cls.find_property (name);
 
-        if (prop.ok ())
+        if (! prop.ok ())
+          error ("subsasgn: unknown property: %s", name.c_str ());
+
+        if (prop.is_constant ())
+          error ("subsasgn: cannot assign constant property: %s",
+                 name.c_str ());
+        else
           {
-            if (prop.is_constant ())
-              error ("subsasgn: cannot assign constant property: %s",
-                     name.c_str ());
+            refcount++;
+
+            cdef_object obj (this);
+
+            if (type.length () == 1)
+              {
+                prop.set_value (obj, rhs, true, "subsasgn");
+
+                retval = to_ov (obj);
+              }
             else
               {
-                refcount++;
-
-                cdef_object obj (this);
-
-                if (type.length () == 1)
-                  {
-                    prop.set_value (obj, rhs, true, "subsasgn");
-
-                    retval = to_ov (obj);
-                  }
-                else
-                  {
-                    octave_value val =
-                      prop.get_value (obj, true, "subsasgn");
-
-                    std::list<octave_value_list> args (idx);
-
-                    args.erase (args.begin ());
-
-                    val = val.assign (octave_value::op_asn_eq,
-                                      type.substr (1), args, rhs);
-
-                    if (val.class_name () != "object"
-                        || ! to_cdef (val).is_handle_object ())
-                      prop.set_value (obj, val, true, "subsasgn");
-
-                    retval = to_ov (obj);
-                  }
+                octave_value val =
+                  prop.get_value (obj, true, "subsasgn");
+
+                std::list<octave_value_list> args (idx);
+
+                args.erase (args.begin ());
+
+                val = val.assign (octave_value::op_asn_eq,
+                                  type.substr (1), args, rhs);
+
+                if (val.class_name () != "object"
+                    || ! to_cdef (val).is_handle_object ())
+                  prop.set_value (obj, val, true, "subsasgn");
+
+                retval = to_ov (obj);
               }
           }
-        else
-          error ("subsasgn: unknown property: %s", name.c_str ());
       }
       break;
 
     case '(':
       {
         refcount++;
 
         cdef_object this_obj (this);
@@ -2382,47 +2365,43 @@ cdef_class::cdef_class_rep::meta_subsref
       if (idx.front ().length () == 1)
         {
           std::string nm = idx.front ()(0).xstring_value ("invalid meta.class indexing, expected a method or property name");
 
           cdef_method meth = find_method (nm);
 
           if (meth.ok ())
             {
-              if (meth.is_static ())
+              if (! meth.is_static ())
+                error ("method `%s' is not static", nm.c_str ());
+
+              octave_value_list args;
+
+              if (type.length () > 1 && idx.size () > 1
+                  && type[1] == '(')
                 {
-                  octave_value_list args;
-
-                  if (type.length () > 1 && idx.size () > 1
-                      && type[1] == '(')
-                    {
-                      args = *(++(idx.begin ()));
-                      skip++;
-                    }
-
-                  retval = meth.execute (args, (type.length () > skip
-                                                ? 1 : nargout), true,
-                                         "meta.class");
+                  args = *(++(idx.begin ()));
+                  skip++;
                 }
-              else
-                error ("method `%s' is not static", nm.c_str ());
+
+              retval = meth.execute (args, (type.length () > skip
+                                            ? 1 : nargout), true,
+                                     "meta.class");
             }
           else
             {
               cdef_property prop = find_property (nm);
 
-              if (prop.ok ())
-                {
-                  if (prop.is_constant ())
-                    retval(0) = prop.get_value (true, "meta.class");
-                  else
-                    error ("property `%s' is not constant", nm.c_str ());
-                }
+              if (! prop.ok ())
+                error ("no such method or property `%s'", nm.c_str ());
+
+              if (prop.is_constant ())
+                retval(0) = prop.get_value (true, "meta.class");
               else
-                error ("no such method or property `%s'", nm.c_str ());
+                error ("property `%s' is not constant", nm.c_str ());
             }
         }
       else
         error ("invalid meta.class indexing");
       break;
 
     default:
       error ("invalid meta.class indexing");
@@ -2496,21 +2475,18 @@ cdef_class::cdef_class_rep::run_construc
       octave_value_list ctor_retval;
 
       ctor_args.prepend (to_ov (obj));
       ctor_retval = ctor.execute (ctor_args, 1, true, "constructor");
 
       if (ctor_retval.length () == 1)
         obj = to_cdef (ctor_retval(0));
       else
-        {
-          error ("%s: invalid number of output arguments for classdef constructor",
-                 ctor_name.c_str ());
-          return;
-        }
+        error ("%s: invalid number of output arguments for classdef constructor",
+               ctor_name.c_str ());
     }
 
   obj.mark_as_constructed (wrap ());
 }
 
 octave_value
 cdef_class::cdef_class_rep::construct (const octave_value_list& args)
 {
@@ -2664,22 +2640,18 @@ cdef_class::make_meta_class (tree_classd
           std::cerr << "superclass: " << sclass_name << std::endl;
 #endif
 
           cdef_class sclass = lookup_class (sclass_name);
 
           if (! sclass.get ("Sealed").bool_value ())
             slist.push_back (sclass);
           else
-            {
-              error ("`%s' cannot inherit from `%s', because it is sealed",
-                     full_class_name.c_str (), sclass_name.c_str ());
-              return retval;
-            }
-
+            error ("`%s' cannot inherit from `%s', because it is sealed",
+                   full_class_name.c_str (), sclass_name.c_str ());
         }
     }
 
   retval = ::make_class (full_class_name, slist);
 
   // Package owning this class
 
   if (! t->package_name ().empty ())
@@ -3428,51 +3400,49 @@ cdef_package::cdef_package_rep::meta_sub
           std::string nm = idx.front ()(0).xstring_value ("invalid meta.package indexing, expected a symbol name");
 
 #if DEBUG_TRACE
           std::cerr << "meta.package query: " << nm << std::endl;
 #endif
 
           octave_value o = find (nm);
 
-          if (o.is_defined ())
+          if (! o.is_defined ())
+            error ("member `%s' in package `%s' does not exist",
+                   nm.c_str (), get_name ().c_str ());
+
+          if (o.is_function ())
             {
-              if (o.is_function ())
+              octave_function* fcn = o.function_value ();
+
+              // NOTE: the case where the package query is the last
+              // part of this subsref index is handled in the parse
+              // tree, because there is some logic to handle magic
+              // "end" that makes it impossible to execute the
+              // function call at this stage.
+
+              if (type.size () > 1
+                  && ! fcn->is_postfix_index_handled (type[1]))
                 {
-                  octave_function* fcn = o.function_value ();
-
-                  // NOTE: the case where the package query is the last
-                  // part of this subsref index is handled in the parse
-                  // tree, because there is some logic to handle magic
-                  // "end" that makes it impossible to execute the
-                  // function call at this stage.
-
-                  if (type.size () > 1
-                      && ! fcn->is_postfix_index_handled (type[1]))
-                    {
-                      octave_value_list tmp_args;
-
-                      retval = o.do_multi_index_op (nargout,
-                                                    tmp_args);
-                    }
-                  else
-                    retval(0) = o;
-
-                  if (type.size () > 1 && idx.size () > 1)
-                    retval = retval(0).next_subsref (nargout, type,
-                                                     idx, 1);
+                  octave_value_list tmp_args;
+
+                  retval = o.do_multi_index_op (nargout,
+                                                tmp_args);
                 }
-              else if (type.size () > 1 && idx.size () > 1)
-                retval = o.next_subsref (nargout, type, idx, 1);
               else
                 retval(0) = o;
+
+              if (type.size () > 1 && idx.size () > 1)
+                retval = retval(0).next_subsref (nargout, type,
+                                                 idx, 1);
             }
+          else if (type.size () > 1 && idx.size () > 1)
+            retval = o.next_subsref (nargout, type, idx, 1);
           else
-            error ("member `%s' in package `%s' does not exist",
-                   nm.c_str (), get_name ().c_str ());
+            retval(0) = o;
         }
       else
         error ("invalid meta.package indexing");
       break;
 
     default:
       error ("invalid meta.package indexing");
       break;
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -362,76 +362,72 @@ octave_complex_matrix::load_ascii (std::
   string_vector keywords(2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
 
   std::string kw;
   octave_idx_type val = 0;
 
-  if (extract_keyword (is, keywords, kw, val, true))
-    {
-      if (kw == "ndims")
-        {
-          int mdims = static_cast<int> (val);
+  if (! extract_keyword (is, keywords, kw, val, true))
+    error ("load: failed to extract number of rows and columns");
 
-          if (mdims >= 0)
-            {
-              dim_vector dv;
-              dv.resize (mdims);
+  if (kw == "ndims")
+    {
+      int mdims = static_cast<int> (val);
 
-              for (int i = 0; i < mdims; i++)
-                is >> dv(i);
-
-              if (is)
-                {
-                  ComplexNDArray tmp(dv);
-
-                  is >> tmp;
+      if (mdims >= 0)
+        {
+          dim_vector dv;
+          dv.resize (mdims);
 
-                  if (is)
-                    matrix = tmp;
-                  else
-                    error ("load: failed to load matrix constant");
-                }
-              else
-                error ("load: failed to read dimensions");
-            }
-          else
-            error ("load: failed to extract number of dimensions");
-        }
-      else if (kw == "rows")
-        {
-          octave_idx_type nr = val;
-          octave_idx_type nc = 0;
+          for (int i = 0; i < mdims; i++)
+            is >> dv(i);
+
+          if (! is)
+            error ("load: failed to read dimensions");
 
-          if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
-            {
-              if (nr > 0 && nc > 0)
-                {
-                  ComplexMatrix tmp (nr, nc);
-                  is >> tmp;
-                  if (is)
-                    matrix = tmp;
-                  else
-                    error ("load: failed to load matrix constant");
-                }
-              else if (nr == 0 || nc == 0)
-                matrix = ComplexMatrix (nr, nc);
-              else
-                panic_impossible ();
-            }
+          ComplexNDArray tmp(dv);
+
+          is >> tmp;
+
+          if (is)
+            matrix = tmp;
           else
-            error ("load: failed to extract number of rows and columns");
+            error ("load: failed to load matrix constant");
         }
       else
-        panic_impossible ();
+        error ("load: failed to extract number of dimensions");
+    }
+  else if (kw == "rows")
+    {
+      octave_idx_type nr = val;
+      octave_idx_type nc = 0;
+
+      if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+        {
+          if (nr > 0 && nc > 0)
+            {
+              ComplexMatrix tmp (nr, nc);
+              is >> tmp;
+              if (is)
+                matrix = tmp;
+              else
+                error ("load: failed to load matrix constant");
+            }
+          else if (nr == 0 || nc == 0)
+            matrix = ComplexMatrix (nr, nc);
+          else
+            panic_impossible ();
+        }
+      else
+        error ("load: failed to extract number of rows and columns");
     }
   else
-    error ("load: failed to extract number of rows and columns");
+    panic_impossible ();
 
   return success;
 }
 
 bool
 octave_complex_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
   dim_vector d = dims ();
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -267,24 +267,22 @@ octave_fcn_handle::set_fcn (const std::s
         {
           size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
           octave_function *xfcn
             = load_fcn_from_file (str, dir_name, "", "", nm);
 
-          if (xfcn)
-            {
-              octave_value tmp (xfcn);
+          if (! xfcn)
+            error ("function handle points to non-existent function");
 
-              fcn = octave_value (new octave_fcn_handle (tmp, nm));
-            }
-          else
-            error ("function handle points to non-existent function");
+          octave_value tmp (xfcn);
+
+          fcn = octave_value (new octave_fcn_handle (tmp, nm));
         }
       else
         {
           // Next just search for it anywhere in the system path
           string_vector names(3);
           names(0) = nm + ".oct";
           names(1) = nm + ".mex";
           names(2) = nm + ".m";
@@ -294,44 +292,40 @@ octave_fcn_handle::set_fcn (const std::s
           str = octave_env::make_absolute (p.find_first_of (names));
 
           size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
           octave_function *xfcn = load_fcn_from_file (str, dir_name, "", "", nm);
 
-          if (xfcn)
-            {
-              octave_value tmp (xfcn);
+          if (! xfcn)
+            error ("function handle points to non-existent function");
 
-              fcn = octave_value (new octave_fcn_handle (tmp, nm));
-            }
-          else
-            error ("function handle points to non-existent function");
+          octave_value tmp (xfcn);
+
+          fcn = octave_value (new octave_fcn_handle (tmp, nm));
         }
     }
   else
     {
       if (fpath.length () > 0)
         {
           size_t xpos = fpath.find_last_of (file_ops::dir_sep_chars ());
 
           std::string dir_name = fpath.substr (0, xpos);
 
           octave_function *xfcn = load_fcn_from_file (fpath, dir_name, "", "", nm);
 
-          if (xfcn)
-            {
-              octave_value tmp (xfcn);
+          if (! xfcn)
+            error ("function handle points to non-existent function");
 
-              fcn = octave_value (new octave_fcn_handle (tmp, nm));
-            }
-          else
-            error ("function handle points to non-existent function");
+          octave_value tmp (xfcn);
+
+          fcn = octave_value (new octave_fcn_handle (tmp, nm));
         }
       else
         {
           fcn = symbol_table::find_function (nm);
 
           if (! fcn.is_function ())
             error ("function handle points to non-existent function");
         }
@@ -1570,44 +1564,42 @@ make_fcn_handle (const std::string& nm, 
       if (! any_match)
         {
           // No match found, try updating load_path and query classes again.
           load_path::update ();
           classes = load_path::overloads (tnm);
           any_match = classes.size () > 0;
         }
 
-      if (any_match)
-        {
-          octave_fcn_handle *fh = new octave_fcn_handle (f, tnm);
-          retval = fh;
+      if (! any_match)
+        error ("@%s: no function and no method found", tnm.c_str ());
+
+      octave_fcn_handle *fh = new octave_fcn_handle (f, tnm);
+      retval = fh;
 
-          for (std::list<std::string>::iterator iter = classes.begin ();
-               iter != classes.end (); iter++)
+      for (std::list<std::string>::iterator iter = classes.begin ();
+           iter != classes.end (); iter++)
+        {
+          std::string class_name = *iter;
+          octave_value fmeth = symbol_table::find_method (tnm, class_name);
+
+          bool is_builtin = false;
+          for (int i = 0; i < btyp_num_types; i++)
             {
-              std::string class_name = *iter;
-              octave_value fmeth = symbol_table::find_method (tnm, class_name);
-
-              bool is_builtin = false;
-              for (int i = 0; i < btyp_num_types; i++)
+              // FIXME: Too slow? Maybe binary lookup?
+              if (class_name == btyp_class_name[i])
                 {
-                  // FIXME: Too slow? Maybe binary lookup?
-                  if (class_name == btyp_class_name[i])
-                    {
-                      is_builtin = true;
-                      fh->set_overload (static_cast<builtin_type_t> (i), fmeth);
-                    }
+                  is_builtin = true;
+                  fh->set_overload (static_cast<builtin_type_t> (i), fmeth);
                 }
+            }
 
-              if (! is_builtin)
-                fh->set_overload (class_name, fmeth);
-            }
+          if (! is_builtin)
+            fh->set_overload (class_name, fmeth);
         }
-      else
-        error ("@%s: no function and no method found", tnm.c_str ());
     }
 
   return retval;
 }
 
 /*
 %!test
 %! x = {".**", "power";
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -336,76 +336,72 @@ octave_float_complex_matrix::load_ascii 
   string_vector keywords(2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
 
   std::string kw;
   octave_idx_type val = 0;
 
-  if (extract_keyword (is, keywords, kw, val, true))
-    {
-      if (kw == "ndims")
-        {
-          int mdims = static_cast<int> (val);
+  if (! extract_keyword (is, keywords, kw, val, true))
+    error ("load: failed to extract number of rows and columns");
 
-          if (mdims >= 0)
-            {
-              dim_vector dv;
-              dv.resize (mdims);
+  if (kw == "ndims")
+    {
+      int mdims = static_cast<int> (val);
 
-              for (int i = 0; i < mdims; i++)
-                is >> dv(i);
-
-              if (is)
-                {
-                  FloatComplexNDArray tmp(dv);
-
-                  is >> tmp;
+      if (mdims >= 0)
+        {
+          dim_vector dv;
+          dv.resize (mdims);
 
-                  if (is)
-                    matrix = tmp;
-                  else
-                    error ("load: failed to load matrix constant");
-                }
-              else
-                error ("load: failed to read dimensions");
-            }
-          else
-            error ("load: failed to extract number of dimensions");
-        }
-      else if (kw == "rows")
-        {
-          octave_idx_type nr = val;
-          octave_idx_type nc = 0;
+          for (int i = 0; i < mdims; i++)
+            is >> dv(i);
+
+          if (! is)
+            error ("load: failed to read dimensions");
 
-          if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
-            {
-              if (nr > 0 && nc > 0)
-                {
-                  FloatComplexMatrix tmp (nr, nc);
-                  is >> tmp;
-                  if (is)
-                    matrix = tmp;
-                  else
-                    error ("load: failed to load matrix constant");
-                }
-              else if (nr == 0 || nc == 0)
-                matrix = FloatComplexMatrix (nr, nc);
-              else
-                panic_impossible ();
-            }
+          FloatComplexNDArray tmp(dv);
+
+          is >> tmp;
+
+          if (is)
+            matrix = tmp;
           else
-            error ("load: failed to extract number of rows and columns");
+            error ("load: failed to load matrix constant");
         }
       else
-        panic_impossible ();
+        error ("load: failed to extract number of dimensions");
+    }
+  else if (kw == "rows")
+    {
+      octave_idx_type nr = val;
+      octave_idx_type nc = 0;
+
+      if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+        {
+          if (nr > 0 && nc > 0)
+            {
+              FloatComplexMatrix tmp (nr, nc);
+              is >> tmp;
+              if (is)
+                matrix = tmp;
+              else
+                error ("load: failed to load matrix constant");
+            }
+          else if (nr == 0 || nc == 0)
+            matrix = FloatComplexMatrix (nr, nc);
+          else
+            panic_impossible ();
+        }
+      else
+        error ("load: failed to extract number of rows and columns");
     }
   else
-    error ("load: failed to extract number of rows and columns");
+    panic_impossible ();
 
   return success;
 }
 
 bool
 octave_float_complex_matrix::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = dims ();
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -363,76 +363,72 @@ octave_float_matrix::load_ascii (std::is
   string_vector keywords(2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
 
   std::string kw;
   octave_idx_type val = 0;
 
-  if (extract_keyword (is, keywords, kw, val, true))
-    {
-      if (kw == "ndims")
-        {
-          int mdims = static_cast<int> (val);
+  if (! extract_keyword (is, keywords, kw, val, true))
+    error ("load: failed to extract number of rows and columns");
 
-          if (mdims >= 0)
-            {
-              dim_vector dv;
-              dv.resize (mdims);
+  if (kw == "ndims")
+    {
+      int mdims = static_cast<int> (val);
 
-              for (int i = 0; i < mdims; i++)
-                is >> dv(i);
-
-              if (is)
-                {
-                  FloatNDArray tmp(dv);
-
-                  is >> tmp;
+      if (mdims >= 0)
+        {
+          dim_vector dv;
+          dv.resize (mdims);
 
-                  if (is)
-                    matrix = tmp;
-                  else
-                    error ("load: failed to load matrix constant");
-                }
-              else
-                error ("load: failed to read dimensions");
-            }
-          else
-            error ("load: failed to extract number of dimensions");
-        }
-      else if (kw == "rows")
-        {
-          octave_idx_type nr = val;
-          octave_idx_type nc = 0;
+          for (int i = 0; i < mdims; i++)
+            is >> dv(i);
+
+          if (! is)
+            error ("load: failed to read dimensions");
 
-          if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
-            {
-              if (nr > 0 && nc > 0)
-                {
-                  FloatMatrix tmp (nr, nc);
-                  is >> tmp;
-                  if (is)
-                    matrix = tmp;
-                  else
-                    error ("load: failed to load matrix constant");
-                }
-              else if (nr == 0 || nc == 0)
-                matrix = FloatMatrix (nr, nc);
-              else
-                panic_impossible ();
-            }
+          FloatNDArray tmp(dv);
+
+          is >> tmp;
+
+          if (is)
+            matrix = tmp;
           else
-            error ("load: failed to extract number of rows and columns");
+            error ("load: failed to load matrix constant");
         }
       else
-        panic_impossible ();
+        error ("load: failed to extract number of dimensions");
+    }
+  else if (kw == "rows")
+    {
+      octave_idx_type nr = val;
+      octave_idx_type nc = 0;
+
+      if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+        {
+          if (nr > 0 && nc > 0)
+            {
+              FloatMatrix tmp (nr, nc);
+              is >> tmp;
+              if (is)
+                matrix = tmp;
+              else
+                error ("load: failed to load matrix constant");
+            }
+          else if (nr == 0 || nc == 0)
+            matrix = FloatMatrix (nr, nc);
+          else
+            panic_impossible ();
+        }
+      else
+        error ("load: failed to extract number of rows and columns");
     }
   else
-    error ("load: failed to extract number of rows and columns");
+    panic_impossible ();
 
   return success;
 }
 
 bool
 octave_float_matrix::save_binary (std::ostream& os, bool&)
 {
 
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -35,31 +35,29 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "onCleanup");
 
 octave_oncleanup::octave_oncleanup (const octave_value& f)
   : fcn (f)
 {
   if (f.is_function_handle ())
     {
       octave_function *fptr = f.function_value (true);
-      if (fptr)
-        {
-          octave_user_function *uptr
-            = dynamic_cast<octave_user_function *> (fptr);
+      if (! fptr)
+        error ("onCleanup: no default dispatch for function handle");
+
+      octave_user_function *uptr
+        = dynamic_cast<octave_user_function *> (fptr);
 
-          if (uptr != 0)
-            {
-              tree_parameter_list *pl = uptr->parameter_list ();
+      if (uptr != 0)
+        {
+          tree_parameter_list *pl = uptr->parameter_list ();
 
-              if (pl != 0 && pl->length () > 0)
-                warning ("onCleanup: cleanup action takes parameters");
-            }
+          if (pl != 0 && pl->length () > 0)
+            warning ("onCleanup: cleanup action takes parameters");
         }
-      else
-        error ("onCleanup: no default dispatch for function handle");
     }
   else
     {
       fcn = octave_value ();
       error ("onCleanup: argument must be a function handle");
     }
 }
 
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -465,76 +465,72 @@ octave_matrix::load_ascii (std::istream&
   string_vector keywords(2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
 
   std::string kw;
   octave_idx_type val = 0;
 
-  if (extract_keyword (is, keywords, kw, val, true))
-    {
-      if (kw == "ndims")
-        {
-          int mdims = static_cast<int> (val);
+  if (! extract_keyword (is, keywords, kw, val, true))
+    error ("load: failed to extract number of rows and columns");
 
-          if (mdims >= 0)
-            {
-              dim_vector dv;
-              dv.resize (mdims);
+  if (kw == "ndims")
+    {
+      int mdims = static_cast<int> (val);
 
-              for (int i = 0; i < mdims; i++)
-                is >> dv(i);
-
-              if (is)
-                {
-                  NDArray tmp(dv);
-
-                  is >> tmp;
+      if (mdims >= 0)
+        {
+          dim_vector dv;
+          dv.resize (mdims);
 
-                  if (is)
-                    matrix = tmp;
-                  else
-                    error ("load: failed to load matrix constant");
-                }
-              else
-                error ("load: failed to read dimensions");
-            }
-          else
-            error ("load: failed to extract number of dimensions");
-        }
-      else if (kw == "rows")
-        {
-          octave_idx_type nr = val;
-          octave_idx_type nc = 0;
+          for (int i = 0; i < mdims; i++)
+            is >> dv(i);
+
+          if (! is)
+            error ("load: failed to read dimensions");
 
-          if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
-            {
-              if (nr > 0 && nc > 0)
-                {
-                  Matrix tmp (nr, nc);
-                  is >> tmp;
-                  if (is)
-                    matrix = tmp;
-                  else
-                    error ("load: failed to load matrix constant");
-                }
-              else if (nr == 0 || nc == 0)
-                matrix = Matrix (nr, nc);
-              else
-                panic_impossible ();
-            }
+          NDArray tmp(dv);
+
+          is >> tmp;
+
+          if (is)
+            matrix = tmp;
           else
-            error ("load: failed to extract number of rows and columns");
+            error ("load: failed to load matrix constant");
         }
       else
-        panic_impossible ();
+        error ("load: failed to extract number of dimensions");
+    }
+  else if (kw == "rows")
+    {
+      octave_idx_type nr = val;
+      octave_idx_type nc = 0;
+
+      if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+        {
+          if (nr > 0 && nc > 0)
+            {
+              Matrix tmp (nr, nc);
+              is >> tmp;
+              if (is)
+                matrix = tmp;
+              else
+                error ("load: failed to load matrix constant");
+            }
+          else if (nr == 0 || nc == 0)
+            matrix = Matrix (nr, nc);
+          else
+            panic_impossible ();
+        }
+      else
+        error ("load: failed to extract number of rows and columns");
     }
   else
-    error ("load: failed to extract number of rows and columns");
+    panic_impossible ();
 
   return success;
 }
 
 bool
 octave_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -339,128 +339,124 @@ octave_char_matrix_str::load_ascii (std:
 
   keywords[0] = "ndims";
   keywords[1] = "elements";
   keywords[2] = "length";
 
   std::string kw;
   int val = 0;
 
-  if (extract_keyword (is, keywords, kw, val, true))
+  if (! extract_keyword (is, keywords, kw, val, true))
+    error ("load: failed to extract number of rows and columns");
+
+  if (kw == "ndims")
     {
-      if (kw == "ndims")
+      int mdims = val;
+
+      if (mdims >= 0)
         {
-          int mdims = val;
+          dim_vector dv;
+          dv.resize (mdims);
+
+          for (int i = 0; i < mdims; i++)
+            is >> dv(i);
 
-          if (mdims >= 0)
+          if (! is)
+            error ("load: failed to read dimensions");
+
+          charNDArray tmp(dv);
+
+          if (tmp.is_empty ())
+            matrix = tmp;
+          else
             {
-              dim_vector dv;
-              dv.resize (mdims);
+              char *ftmp = tmp.fortran_vec ();
+
+              skip_preceeding_newline (is);
 
-              for (int i = 0; i < mdims; i++)
-                is >> dv(i);
+              if (! is.read (ftmp, dv.numel ()) || ! is)
+                error ("load: failed to load string constant");
+              else
+                matrix = tmp;
+            }
+        }
+      else
+        error ("load: failed to extract matrix size");
+    }
+  else if (kw == "elements")
+    {
+      int elements = val;
 
-              if (is)
+      if (elements >= 0)
+        {
+          // FIXME: need to be able to get max length before doing anything.
+
+          charMatrix chm (elements, 0);
+          int max_len = 0;
+          for (int i = 0; i < elements; i++)
+            {
+              int len;
+              if (extract_keyword (is, "length", len) && len >= 0)
                 {
-                  charNDArray tmp(dv);
+                  // Use this instead of a C-style character
+                  // buffer so that we can properly handle
+                  // embedded NUL characters.
+                  charMatrix tmp (1, len);
+                  char *ptmp = tmp.fortran_vec ();
 
-                  if (tmp.is_empty ())
-                    matrix = tmp;
+                  if (len > 0 && ! is.read (ptmp, len))
+                    error ("load: failed to load string constant");
                   else
                     {
-                      char *ftmp = tmp.fortran_vec ();
-
-                      skip_preceeding_newline (is);
+                      if (len > max_len)
+                        {
+                          max_len = len;
+                          chm.resize (elements, max_len, 0);
+                        }
 
-                      if (! is.read (ftmp, dv.numel ()) || ! is)
-                        error ("load: failed to load string constant");
-                      else
-                        matrix = tmp;
+                      chm.insert (tmp, i, 0);
                     }
                 }
               else
-                error ("load: failed to read dimensions");
+                error ("load: failed to extract string length for element %d",
+                       i+1);
             }
-          else
-            error ("load: failed to extract matrix size");
-        }
-      else if (kw == "elements")
-        {
-          int elements = val;
-
-          if (elements >= 0)
-            {
-              // FIXME: need to be able to get max length before doing anything.
 
-              charMatrix chm (elements, 0);
-              int max_len = 0;
-              for (int i = 0; i < elements; i++)
-                {
-                  int len;
-                  if (extract_keyword (is, "length", len) && len >= 0)
-                    {
-                      // Use this instead of a C-style character
-                      // buffer so that we can properly handle
-                      // embedded NUL characters.
-                      charMatrix tmp (1, len);
-                      char *ptmp = tmp.fortran_vec ();
-
-                      if (len > 0 && ! is.read (ptmp, len))
-                        error ("load: failed to load string constant");
-                      else
-                        {
-                          if (len > max_len)
-                            {
-                              max_len = len;
-                              chm.resize (elements, max_len, 0);
-                            }
+          matrix = chm;
+        }
+      else
+        error ("load: failed to extract number of string elements");
+    }
+  else if (kw == "length")
+    {
+      int len = val;
 
-                          chm.insert (tmp, i, 0);
-                        }
-                    }
-                  else
-                    error ("load: failed to extract string length for element %d",
-                           i+1);
-                }
-
-              matrix = chm;
-            }
-          else
-            error ("load: failed to extract number of string elements");
-        }
-      else if (kw == "length")
+      if (len >= 0)
         {
-          int len = val;
+          // This is cruft for backward compatibility,
+          // but relatively harmless.
 
-          if (len >= 0)
-            {
-              // This is cruft for backward compatibility,
-              // but relatively harmless.
-
-              // Use this instead of a C-style character buffer so
-              // that we can properly handle embedded NUL characters.
-              charMatrix tmp (1, len);
-              char *ptmp = tmp.fortran_vec ();
+          // Use this instead of a C-style character buffer so
+          // that we can properly handle embedded NUL characters.
+          charMatrix tmp (1, len);
+          char *ptmp = tmp.fortran_vec ();
 
-              if (len > 0 && ! is.read (ptmp, len))
-                error ("load: failed to load string constant");
+          if (len > 0 && ! is.read (ptmp, len))
+            error ("load: failed to load string constant");
+          else
+            {
+              if (is)
+                matrix = tmp;
               else
-                {
-                  if (is)
-                    matrix = tmp;
-                  else
-                    error ("load: failed to load string constant");
-                }
+                error ("load: failed to load string constant");
             }
         }
-      else
-        panic_impossible ();
     }
   else
-    error ("load: failed to extract number of rows and columns");
+    panic_impossible ();
 
   return success;
 }
 
 bool
 octave_char_matrix_str::save_binary (std::ostream& os,
                                      bool& /* save_as_floats */)
 {
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -476,25 +476,23 @@ octave_struct::subsasgn (const std::stri
 
                 map.assign (idx.front (), rhs_map);
 
                 count++;
                 retval = octave_value (this);
               }
             else
               {
-                if (t_rhs.is_null_value ())
-                  {
-                    map.delete_elements (idx.front ());
-
-                    count++;
-                    retval = octave_value (this);
-                  }
-                else
+                if (! t_rhs.is_null_value ())
                   error ("invalid structure assignment");
+
+                map.delete_elements (idx.front ());
+
+                count++;
+                retval = octave_value (this);
               }
           }
       }
       break;
 
     case '.':
       {
         octave_value_list key_idx = idx.front ();
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -528,17 +528,16 @@ octave_user_function::do_multi_index_op 
 
   if (is_classdef_constructor ())
     {
       if (ret_list)
         ret_list->define_from_arg_vector (ret_args);
       else
         error ("%s: invalid classdef constructor, no output argument defined",
                dispatch_class ().c_str ());
-
     }
 
   // Force parameter list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named function parameters.
 
   if (param_list)
     frame.add_method (param_list, &tree_parameter_list::undefine);
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1415,26 +1415,24 @@ octave_value::assign (assign_op op, cons
   octave_value retval;
 
   make_unique ();
 
   octave_value t_rhs = rhs;
 
   if (op != op_asn_eq)
     {
-      if (is_defined ())
-        {
-          octave_value t = subsref (type, idx);
-
-          binary_op binop = op_eq_to_binary_op (op);
-
-          t_rhs = do_binary_op (binop, t, rhs);
-        }
-      else
+      if (! is_defined ())
         error ("in computed assignment A(index) OP= X, A must be defined first");
+
+      octave_value t = subsref (type, idx);
+
+      binary_op binop = op_eq_to_binary_op (op);
+
+      t_rhs = do_binary_op (binop, t, rhs);
     }
 
   *this = subsasgn (type, idx, t_rhs);
 
   return *this;
 }
 
 octave_value&
@@ -2436,37 +2434,35 @@ do_colon_op (const octave_value& base, c
         dispatch_type = base.class_name ();
       else if (increment.is_defined () && increment.is_object ())
         dispatch_type = increment.class_name ();
       else
         dispatch_type = limit.class_name ();
 
       octave_value meth = symbol_table::find_method ("colon", dispatch_type);
 
-      if (meth.is_defined ())
+      if (! meth.is_defined ())
+        error ("colon method not defined for %s class", dispatch_type.c_str ());
+
+      octave_value_list args;
+
+      if (increment.is_defined ())
         {
-          octave_value_list args;
-
-          if (increment.is_defined ())
-            {
-              args(2) = limit;
-              args(1) = increment;
-            }
-          else
-            args(1) = limit;
-
-          args(0) = base;
-
-          octave_value_list tmp = feval (meth.function_value (), args, 1);
-
-          if (tmp.length () > 0)
-            retval = tmp(0);
+          args(2) = limit;
+          args(1) = increment;
         }
       else
-        error ("colon method not defined for %s class", dispatch_type.c_str ());
+        args(1) = limit;
+
+      args(0) = base;
+
+      octave_value_list tmp = feval (meth.function_value (), args, 1);
+
+      if (tmp.length () > 0)
+        retval = tmp(0);
     }
   else
     {
       bool result_is_str = (base.is_string () && limit.is_string ());
       bool dq_str = (base.is_dq_string () || limit.is_dq_string ());
 
       Matrix m_base, m_limit, m_increment;
 
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -145,62 +145,60 @@ Example:\n\
 @var{x}(end,end)\n\
     @result{} 6\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (indexed_object)
+  if (! indexed_object)
+    error ("invalid use of end");
+
+  if (indexed_object->is_object ())
     {
-      if (indexed_object->is_object ())
-        {
-          octave_value_list args;
+      octave_value_list args;
 
-          args(2) = num_indices;
-          args(1) = index_position + 1;
-          args(0) = *indexed_object;
+      args(2) = num_indices;
+      args(1) = index_position + 1;
+      args(0) = *indexed_object;
+
+      std::string class_name = indexed_object->class_name ();
 
-          std::string class_name = indexed_object->class_name ();
+      octave_value meth = symbol_table::find_method ("end", class_name);
 
-          octave_value meth = symbol_table::find_method ("end", class_name);
+      if (meth.is_defined ())
+        return feval (meth.function_value (), args, 1);
+    }
 
-          if (meth.is_defined ())
-            return feval (meth.function_value (), args, 1);
-        }
+  dim_vector dv = indexed_object->dims ();
+  int ndims = dv.length ();
 
-      dim_vector dv = indexed_object->dims ();
-      int ndims = dv.length ();
+  if (num_indices < ndims)
+    {
+      for (int i = num_indices; i < ndims; i++)
+        dv(num_indices-1) *= dv(i);
 
-      if (num_indices < ndims)
+      if (num_indices == 1)
         {
-          for (int i = num_indices; i < ndims; i++)
-            dv(num_indices-1) *= dv(i);
+          ndims = 2;
+          dv.resize (ndims);
+          dv(1) = 1;
+        }
+      else
+        {
+          ndims = num_indices;
+          dv.resize (ndims);
+        }
+    }
 
-          if (num_indices == 1)
-            {
-              ndims = 2;
-              dv.resize (ndims);
-              dv(1) = 1;
-            }
-          else
-            {
-              ndims = num_indices;
-              dv.resize (ndims);
-            }
-        }
-
-      if (index_position < ndims)
-        retval = dv(index_position);
-      else
-        retval = 1;
-    }
+  if (index_position < ndims)
+    retval = dv(index_position);
   else
-    error ("invalid use of end");
+    retval = 1;
 
   return retval;
 }
 
 octave_value_list
 tree_argument_list::convert_to_const_vector (const octave_value *object)
 {
   // END doesn't make sense for functions.  Maybe we need a different
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -307,23 +307,21 @@ tree_multi_assignment::rvalue (int)
                   //
                   //    [a, ~] = f ();
                   //
                   // Then the list of of RHS values will contain one
                   // element but we are iterating over the list of all
                   // RHS values.  We shouldn't complain that a value we
                   // don't need is missing from the list.
 
-                  if (ult.is_black_hole ())
-                    {
-                      k++;
-                      continue;
-                    }
-                  else
+                  if (! ult.is_black_hole ())
                     error ("element number %d undefined in return list", k+1);
+
+                  k++;
+                  continue;
                 }
             }
 
           if (print_result ()
               && tree_evaluator::statement_printing_enabled ())
             {
               // We clear any index here so that we can get
               // the new value of the referenced object below,
diff --git a/libinterp/parse-tree/pt-colon.cc b/libinterp/parse-tree/pt-colon.cc
--- a/libinterp/parse-tree/pt-colon.cc
+++ b/libinterp/parse-tree/pt-colon.cc
@@ -34,38 +34,36 @@ along with Octave; see the file COPYING.
 
 // Colon expressions.
 
 tree_colon_expression *
 tree_colon_expression::append (tree_expression *t)
 {
   tree_colon_expression *retval = 0;
 
-  if (op_base)
+  if (! op_base)
+    error ("invalid colon expression");
+
+  if (op_limit)
     {
-      if (op_limit)
-        {
-          if (op_increment)
-            error ("invalid colon expression");
+      if (op_increment)
+        error ("invalid colon expression");
 
-          // Stupid syntax:
-          //
-          // base : limit
-          // base : increment : limit
+      // Stupid syntax:
+      //
+      // base : limit
+      // base : increment : limit
 
-          op_increment = op_limit;
-          op_limit = t;
-        }
-      else
-        op_limit = t;
-
-      retval = this;
+      op_increment = op_limit;
+      op_limit = t;
     }
   else
-    error ("invalid colon expression");
+    op_limit = t;
+
+  retval = this;
 
   return retval;
 }
 
 octave_value_list
 tree_colon_expression::rvalue (int nargout)
 {
   if (nargout > 1)
@@ -101,24 +99,22 @@ tree_colon_expression::rvalue1 (int)
       else
         {
           tmp1(1) = ov_limit;
           tmp1(0) = ov_base;
         }
 
       octave_value fcn = symbol_table::find_function ("colon", tmp1);
 
-      if (fcn.is_defined ())
-        {
-          octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
+      if (! fcn.is_defined ())
+        error ("can not find overloaded colon function");
 
-          retval = tmp2 (0);
-        }
-      else
-        error ("can not find overloaded colon function");
+      octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
+
+      retval = tmp2 (0);
     }
   else
     {
       octave_value ov_increment = 1.0;
 
       if (op_increment)
         ov_increment = op_increment->rvalue1 ();
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -407,64 +407,62 @@ tree_evaluator::visit_complex_for_comman
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
 
   if (rhs.is_undefined ())
     return;
 
-  if (rhs.is_map ())
-    {
-      // Cycle through structure elements.  First element of id_list
-      // is set to value and the second is set to the name of the
-      // structure element.
+  if (! rhs.is_map ())
+    error ("in statement 'for [X, Y] = VAL', VAL must be a structure");
 
-      tree_argument_list *lhs = cmd.left_hand_side ();
+  // Cycle through structure elements.  First element of id_list
+  // is set to value and the second is set to the name of the
+  // structure element.
 
-      tree_argument_list::iterator p = lhs->begin ();
+  tree_argument_list *lhs = cmd.left_hand_side ();
 
-      tree_expression *elt = *p++;
+  tree_argument_list::iterator p = lhs->begin ();
 
-      octave_lvalue val_ref = elt->lvalue ();
+  tree_expression *elt = *p++;
 
-      elt = *p;
+  octave_lvalue val_ref = elt->lvalue ();
 
-      octave_lvalue key_ref = elt->lvalue ();
+  elt = *p;
 
-      const octave_map tmp_val = rhs.map_value ();
+  octave_lvalue key_ref = elt->lvalue ();
 
-      tree_statement_list *loop_body = cmd.body ();
+  const octave_map tmp_val = rhs.map_value ();
 
-      string_vector keys = tmp_val.keys ();
+  tree_statement_list *loop_body = cmd.body ();
 
-      octave_idx_type nel = keys.numel ();
+  string_vector keys = tmp_val.keys ();
 
-      for (octave_idx_type i = 0; i < nel; i++)
-        {
-          std::string key = keys[i];
+  octave_idx_type nel = keys.numel ();
 
-          const Cell val_lst = tmp_val.contents (key);
+  for (octave_idx_type i = 0; i < nel; i++)
+    {
+      std::string key = keys[i];
 
-          octave_idx_type n = val_lst.numel ();
+      const Cell val_lst = tmp_val.contents (key);
 
-          octave_value val = (n == 1) ? val_lst(0) : octave_value (val_lst);
+      octave_idx_type n = val_lst.numel ();
 
-          val_ref.assign (octave_value::op_asn_eq, val);
-          key_ref.assign (octave_value::op_asn_eq, key);
+      octave_value val = (n == 1) ? val_lst(0) : octave_value (val_lst);
 
-          if (loop_body)
-            loop_body->accept (*this);
+      val_ref.assign (octave_value::op_asn_eq, val);
+      key_ref.assign (octave_value::op_asn_eq, key);
 
-          if (quit_loop_now ())
-            break;
-        }
+      if (loop_body)
+        loop_body->accept (*this);
+
+      if (quit_loop_now ())
+        break;
     }
-  else
-    error ("in statement 'for [X, Y] = VAL', VAL must be a structure");
 }
 
 void
 tree_evaluator::visit_octave_user_script (octave_user_script&)
 {
   panic_impossible ();
 }
 
@@ -738,51 +736,49 @@ tree_evaluator::visit_statement_list (tr
   tree_statement_list::iterator p = lst.begin ();
 
   if (p != lst.end ())
     {
       while (true)
         {
           tree_statement *elt = *p++;
 
-          if (elt)
-            {
-              octave_quit ();
+          if (! elt)
+            error ("invalid statement found in statement list!");
 
-              elt->accept (*this);
+          octave_quit ();
+
+          elt->accept (*this);
 
-              if (tree_break_command::breaking
-                  || tree_continue_command::continuing)
-                break;
+          if (tree_break_command::breaking
+              || tree_continue_command::continuing)
+            break;
 
-              if (tree_return_command::returning)
-                break;
+          if (tree_return_command::returning)
+            break;
 
-              if (p == lst.end ())
-                break;
-              else
-                {
-                  // Clear previous values before next statement is
-                  // evaluated so that we aren't holding an extra
-                  // reference to a value that may be used next.  For
-                  // example, in code like this:
-                  //
-                  //   X = rand (N);  # refcount for X should be 1
-                  //                  # after this statement
-                  //
-                  //   X(idx) = val;  # no extra copy of X should be
-                  //                  # needed, but we will be faked
-                  //                  # out if retval is not cleared
-                  //                  # between statements here
+          if (p == lst.end ())
+            break;
+          else
+            {
+              // Clear previous values before next statement is
+              // evaluated so that we aren't holding an extra
+              // reference to a value that may be used next.  For
+              // example, in code like this:
+              //
+              //   X = rand (N);  # refcount for X should be 1
+              //                  # after this statement
+              //
+              //   X(idx) = val;  # no extra copy of X should be
+              //                  # needed, but we will be faked
+              //                  # out if retval is not cleared
+              //                  # between statements here
 
-                  //              result_values = empty_list;
-                }
+              //              result_values = empty_list;
             }
-          else
-            error ("invalid statement found in statement list!");
         }
     }
 }
 
 void
 tree_evaluator::visit_switch_case (tree_switch_case&)
 {
   panic_impossible ();
@@ -797,44 +793,42 @@ tree_evaluator::visit_switch_case_list (
 void
 tree_evaluator::visit_switch_command (tree_switch_command& cmd)
 {
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint ());
 
   tree_expression *expr = cmd.switch_value ();
 
-  if (expr)
-    {
-      octave_value val = expr->rvalue1 ();
+  if (! expr)
+    error ("missing value in switch command near line %d, column %d",
+           cmd.line (), cmd.column ());
+
+  octave_value val = expr->rvalue1 ();
+
+  tree_switch_case_list *lst = cmd.case_list ();
 
-      tree_switch_case_list *lst = cmd.case_list ();
+  if (lst)
+    {
+      for (tree_switch_case_list::iterator p = lst->begin ();
+           p != lst->end (); p++)
+        {
+          tree_switch_case *t = *p;
 
-      if (lst)
-        {
-          for (tree_switch_case_list::iterator p = lst->begin ();
-               p != lst->end (); p++)
+          if (t->is_default_case () || t->label_matches (val))
             {
-              tree_switch_case *t = *p;
-
-              if (t->is_default_case () || t->label_matches (val))
-                {
-                  tree_statement_list *stmt_lst = t->commands ();
+              tree_statement_list *stmt_lst = t->commands ();
 
-                  if (stmt_lst)
-                    stmt_lst->accept (*this);
+              if (stmt_lst)
+                stmt_lst->accept (*this);
 
-                  break;
-                }
+              break;
             }
         }
     }
-  else
-    error ("missing value in switch command near line %d, column %d",
-           cmd.line (), cmd.column ());
 }
 
 void
 tree_evaluator::visit_try_catch_command (tree_try_catch_command& cmd)
 {
   unwind_protect frame;
 
   frame.protect_var (buffer_error_messages);
diff --git a/libinterp/parse-tree/pt-exp.cc b/libinterp/parse-tree/pt-exp.cc
--- a/libinterp/parse-tree/pt-exp.cc
+++ b/libinterp/parse-tree/pt-exp.cc
@@ -40,18 +40,17 @@ tree_expression::is_logically_true (cons
 {
   bool expr_value = false;
 
   octave_value t1 = rvalue1 ();
 
   if (t1.is_defined ())
     return t1.is_true ();
   else
-    error ("%s: undefined value used in conditional expression",
-           warn_for);
+    error ("%s: undefined value used in conditional expression", warn_for);
 
   return expr_value;
 }
 
 octave_value
 tree_expression::rvalue1 (int)
 {
   error ("invalid rvalue function called in expression");
