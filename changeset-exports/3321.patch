# HG changeset patch
# User jwe
# Date 940961741 0
#      Tue Oct 26 18:15:41 1999 +0000
# Node ID 6923abb04e16937f221bf64c6784236c92e09e11
# Parent  b0b71d14dab9b29d43e1b1150e36be80637edc58
[project @ 1999-10-26 18:15:30 by jwe]

diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -20,203 +20,49 @@ will work for real and complex scalar or
 @node Utility Functions, Complex Arithmetic, Arithmetic, Arithmetic
 @section Utility Functions
 
 The following functions are available for working with complex numbers.
 Each expects a single argument.  They are called @dfn{mapping functions}
 because when given a matrix argument, they apply the given function to
 each element of the matrix.
 
-@deftypefn {Mapping Function} {} ceil (@var{x})
-Return the smallest integer not less than @var{x}.  If @var{x} is
-complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.
-@end deftypefn
-
-@deftypefn {Mapping Function} {} exp (@var{x})
-Compute the exponential of @var{x}.  To compute the matrix exponential,
-see @ref{Linear Algebra}.
-@end deftypefn
+@DOCSTRING(ceil)
 
-@deftypefn {Mapping Function} {} fix (@var{x})
-Truncate @var{x} toward zero.  If @var{x} is complex, return
-@code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.
-@end deftypefn
-
-@deftypefn {Mapping Function} {} floor (@var{x})
-Return the largest integer not greater than @var{x}.  If @var{x} is
-complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.
-@end deftypefn
+@DOCSTRING(exp)
 
-@deftypefn {Mapping Function} {} gcd (@var{x}, @code{...})
-Compute the greatest common divisor of the elements of @var{x}, or the
-list of all the arguments.  For example, 
-
-@example
-gcd (a1, ..., ak)
-@end example
-
-@noindent
-is the same as
+@DOCSTRING(fix)
 
-@example
-gcd ([a1, ..., ak])
-@end example
-
-An optional second return value, @var{v}
-contains an integer vector such that
-
-@example
-g = v(1) * a(k) + ... + v(k) * a(k)
-@end example
-@end deftypefn
+@DOCSTRING(floor)
 
-@deftypefn {Mapping Function} {} lcm (@var{x}, @code{...})
-Compute the least common multiple of the elements elements of @var{x}, or
-the list of all the arguments.  For example, 
-
-@example
-lcm (a1, ..., ak)
-@end example
-
-@noindent
-is the same as
+@DOCSTRING(gcd)
 
-@example
-lcm ([a1, ..., ak]).
-@end example
-@end deftypefn
-
-@deftypefn {Mapping Function} {} log (@var{x})
-Compute the natural logarithm of @var{x}.  To compute the matrix logarithm, 
-see @ref{Linear Algebra}.
-@end deftypefn
-
-@deftypefn {Mapping Function} {} log10 (@var{x})
-Compute the base-10 logarithm of @var{x}.
-@end deftypefn
+@DOCSTRING(lcm)
 
-@deftypefn {Mapping Function} {@var{y} =} log2 (@var{x})
-@deftypefnx {Mapping Function} {[@var{f}, @var{e}]} log2 (@var{x})
-Compute the base-2 logarithm of @var{x}.  With two outputs, returns
-@var{f} and @var{e} such that
-@iftex
-@tex
- $1/2 <= |f| < 1$ and $x = f \cdot 2^e$.
-@end tex
-@end iftex
-@ifinfo
- 1/2 <= abs(f) < 1 and x = f * 2^e.
-@end ifinfo
-@end deftypefn
+@DOCSTRING(log)
 
-@deftypefn {Loadable Function} {} max (@var{x})
-For a vector argument, return the maximum value.  For a matrix argument,
-return the maximum value from each column, as a row vector.  Thus,
-
-@example
-max (max (@var{x}))
-@end example
-
-@noindent
-returns the largest element of @var{x}.
+@DOCSTRING(log10)
 
-For complex arguments, the magnitude of the elements are used for
-comparison.
-@end deftypefn
-
-@deftypefn {Loadable Function} {} min (@var{x})
-Like @code{max}, but return the minimum value.
-@end deftypefn
+@DOCSTRING(log2)
 
-@deftypefn {Function File} {} nextpow2 (@var{x})
-If @var{x} is a scalar, returns the first integer @var{n} such that
-@iftex
-@tex
- $2^n \ge |x|$.
-@end tex
-@end iftex
-@ifinfo
- 2^n >= abs (x).
-@end ifinfo
-
-If @var{x} is a vector, return @code{nextpow2 (length (@var{x}))}.
-@end deftypefn
+@DOCSTRING(max)
 
-@deftypefn {Mapping Function} {} pow2 (@var{x})
-@deftypefnx {Mapping Function} {} pow2 (@var{f}, @var{e})
-With one argument, computes
-@iftex
-@tex
- $2^x$
-@end tex
-@end iftex
-@ifinfo
- 2 .^ x
-@end ifinfo
-for each element of @var{x}.  With two arguments, returns
-@iftex
-@tex
- $f \cdot 2^e$.
-@end tex
-@end iftex
-@ifinfo
- f .* (2 .^ e).
-@end ifinfo
-@end deftypefn
+@DOCSTRING(min)
+
+@DOCSTRING(nextpow2)
 
-@deftypefn {Mapping Function} {} rem (@var{x}, @var{y})
-Return the remainder of @code{@var{x} / @var{y}}, computed using the
-expression
-
-@example
-x - y .* fix (x ./ y)
-@end example
+@DOCSTRING(pow2)
 
-An error message is printed if the dimensions of the arguments do not
-agree, or if either of the arguments is complex.
-@end deftypefn
-
-@deftypefn {Mapping Function} {} round (@var{x})
-Return the integer nearest to @var{x}.  If @var{x} is complex, return
-@code{round (real (@var{x})) + round (imag (@var{x})) * I}.
-@end deftypefn
+@DOCSTRING(rem)
 
-@deftypefn {Mapping Function} {} sign (@var{x})
-Compute the @dfn{signum} function, which is defined as
-@iftex
-@tex
-$$
-{\rm sign} (@var{x}) = \cases{1,&$x>0$;\cr 0,&$x=0$;\cr -1,&$x<0$.\cr}
-$$
-@end tex
-@end iftex
-@ifinfo
+@DOCSTRING(round)
 
-@example
-           -1, x < 0;
-sign (x) =  0, x = 0;
-            1, x > 0.
-@end example
-@end ifinfo
-
-For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.
-@end deftypefn
+@DOCSTRING(sign)
 
-@deftypefn {Mapping Function} {} sqrt (@var{x})
-Compute the square root of @var{x}.  If @var{x} is negative, a complex
-result is returned.  To compute the matrix square root, see
-@ref{Linear Algebra}.
-@end deftypefn
-
-@deftypefn {Mapping Function} {} xor (@var{x}, @var{y})
-Return the `exclusive or' of the entries of @var{x} and @var{y}.
-For boolean expressions @var{x} and @var{y},
-@code{xor (@var{x}, @var{y})} is true if and only if @var{x} or @var{y}
-is true, but not if both @var{x} and @var{y} are true.
-@end deftypefn
+@DOCSTRING(sqrt)
 
 @node Complex Arithmetic, Trigonometry, Utility Functions, Arithmetic
 @section Complex Arithmetic
 
 The following functions are available for working with complex
 numbers.  Each expects a single argument.  Given a matrix they work on
 an element by element basis.  In the descriptions of the following
 functions,
@@ -226,636 +72,135 @@ functions,
 $\sqrt{-1}$.
 @end tex
 @end iftex
 @ifinfo
 @var{z} is the complex number @var{x} + @var{i}@var{y}, where @var{i} is
 defined as @code{sqrt (-1)}.
 @end ifinfo
 
-@deftypefn {Mapping Function} {} abs (@var{z})
-Compute the magnitude of @var{z}, defined as
-@iftex
-@tex
-$|z| = \sqrt{x^2 + y^2}$.
-@end tex
-@end iftex
-@ifinfo
-|@var{z}| = @code{sqrt (x^2 + y^2)}.
-@end ifinfo
-
-For example,
+@DOCSTRING(abs)
 
-@example
-@group
-abs (3 + 4i)
-     @result{} 5
-@end group
-@end example
-@end deftypefn
-
-@deftypefn {Mapping Function} {} arg (@var{z})
-@deftypefnx {Mapping Function} {} angle (@var{z})
-Compute the argument of @var{z}, defined as
-@iftex
-@tex
-$\theta = \tan^{-1}(y/x)$.
-@end tex
-@end iftex
-@ifinfo
-@var{theta} = @code{atan (@var{y}/@var{x})}.
-@end ifinfo
+@DOCSTRING(arg)
 
-@noindent
-in radians. 
-
-For example,
-
-@example
-@group
-arg (3 + 4i)
-     @result{} 0.92730
-@end group
-@end example
-@end deftypefn
+@DOCSTRING(conj)
 
-@deftypefn {Mapping Function} {} conj (@var{z})
-Return the complex conjugate of @var{z}, defined as
-@iftex
-@tex
-$\bar{z} = x - iy$.
-@end tex
-@end iftex
-@ifinfo
-@code{conj (@var{z})} = @var{x} - @var{i}@var{y}.
-@end ifinfo
-@end deftypefn
+@DOCSTRING(imag)
 
-@deftypefn {Mapping Function} {} imag (@var{z})
-Return the imaginary part of @var{z} as a real number.
-@end deftypefn
-
-@deftypefn {Mapping Function} {} real (@var{z})
-Return the real part of @var{z}.
-@end deftypefn
+@DOCSTRING(real)
 
 @node Trigonometry, Sums and Products, Complex Arithmetic, Arithmetic
 @section Trigonometry
 
 Octave provides the following trigonometric functions.  Angles are
 specified in radians.  To convert from degrees to radians multipy by
 @iftex
 @tex
 $\pi/180$
 @end tex
 @end iftex
 @ifinfo
 @code{pi/180}
 @end ifinfo
  (e.g. @code{sin (30 * pi/180)} returns the sine of 30 degrees).
 
-@deftypefn {Mapping Function} {} sin (@var{z})
-@deftypefnx {Mapping Function} {} cos (@var{z})
-@deftypefnx {Mapping Function} {} tan (@var{z})
-@deftypefnx {Mapping Function} {} sec (@var{z})
-@deftypefnx {Mapping Function} {} csc (@var{z})
-@deftypefnx {Mapping Function} {} cot (@var{z})
-The ordinary trigonometric functions.
-@end deftypefn
+@DOCSTRING(sin)
+@DOCSTRING(cos)
+@DOCSTRING(tan)
+@DOCSTRING(sec)
+@DOCSTRING(csc)
+@DOCSTRING(cot)
 
-@deftypefn {Mapping Function} {} asin (@var{z})
-@deftypefnx {Mapping Function} {} acos (@var{z})
-@deftypefnx {Mapping Function} {} atan (@var{z})
-@deftypefnx {Mapping Function} {} asec (@var{z})
-@deftypefnx {Mapping Function} {} acsc (@var{z})
-@deftypefnx {Mapping Function} {} acot (@var{z})
-The ordinary inverse trigonometric functions.
-@end deftypefn
+@DOCSTRING(asin)
+@DOCSTRING(acos)
+@DOCSTRING(atan)
+@DOCSTRING(asec)
+@DOCSTRING(acsc)
+@DOCSTRING(acot)
 
-@deftypefn {Mapping Function} {} sinh (@var{z})
-@deftypefnx {Mapping Function} {} cosh (@var{z})
-@deftypefnx {Mapping Function} {} tanh (@var{z})
-@deftypefnx {Mapping Function} {} sech (@var{z})
-@deftypefnx {Mapping Function} {} csch (@var{z})
-@deftypefnx {Mapping Function} {} coth (@var{z})
-Hyperbolic trigonometric functions.
-@end deftypefn
+@DOCSTRING(sinh)
+@DOCSTRING(cosh)
+@DOCSTRING(tanh)
+@DOCSTRING(sech)
+@DOCSTRING(scsh)
+@DOCSTRING(coth)
 
-@deftypefn {Mapping Function} {} asinh (@var{z})
-@deftypefnx {Mapping Function} {} acosh (@var{z})
-@deftypefnx {Mapping Function} {} atanh (@var{z})
-@deftypefnx {Mapping Function} {} asech (@var{z})
-@deftypefnx {Mapping Function} {} acsch (@var{z})
-@deftypefnx {Mapping Function} {} acoth (@var{z})
-Inverse hyperbolic trigonometric functions.
-@end deftypefn
+@DOCSTRING(asinh)
+@DOCSTRING(acosh)
+@DOCSTRING(atanh)
+@DOCSTRING(asech)
+@DOCSTRING(acsch)
+@DOCSTRING(acoth)
 
 Each of these functions expect a single argument.  For matrix arguments,
 they work on an element by element basis.  For example,
 
 @example
 @group
 sin ([1, 2; 3, 4])
      @result{}  0.84147   0.90930
          0.14112  -0.75680
 @end group
 @end example
 
-@deftypefn {Mapping Function} {} atan2 (@var{y}, @var{x})
-Return the arctangent of @var{y}/@var{x}.  The signs of the arguments
-are used to determine the quadrant of the result, which is in the range
-@iftex
-@tex
-$\pi$ to $-\pi$.
-@end tex
-@end iftex
-@ifinfo
-@code{pi} to -@code{pi}.
-@end ifinfo
-@end deftypefn
+@DOCSTRING(atan2)
+
 
 @node Sums and Products, Special Functions, Trigonometry, Arithmetic
 @section Sums and Products
 
-@deftypefn {Built-in Function} {} sum (@var{x})
-For a vector argument, return the sum of all the elements.  For a matrix
-argument, return the sum of the elements in each column, as a row
-vector.  The sum of an empty matrix is 0 if it has no columns, or a
-vector of zeros if it has no rows (@pxref{Empty Matrices}).
-@end deftypefn
+@DOCSTRING(sum)
 
-@deftypefn {Built-in Function} {} prod (@var{x})
-For a vector argument, return the product of all the elements.  For a
-matrix argument, return the product of the elements in each column, as a
-row vector.  The product of an empty matrix is 1 if it has no columns,
-or a vector of ones if it has no rows (@pxref{Empty Matrices}).
-@end deftypefn
-
-@deftypefn {Built-in Function} {} cumsum (@var{x})
-Return the cumulative sum of each column of @var{x}.  For example,
+@DOCSTRING(prod)
 
-@example
-@group
-cumsum ([1, 2; 3, 4])
-     @result{}  1  2
-         4  6
-@end group
-@end example
-@end deftypefn
-
-@deftypefn {Built-in Function} {} cumprod (@var{x})
-Return the cumulative product of each column of @var{x}.  For example,
+@DOCSTRING(cumsum)
 
-@example
-@group
-cumprod ([1, 2; 3, 4])
-     @result{}  1  2
-         3  8
-@end group
-@end example
-@end deftypefn
+@DOCSTRING(cumprod)
 
-@deftypefn {Built-in Function} {} sumsq (@var{x})
-For a vector argument, return the sum of the squares of all the
-elements.  For a matrix argument, return the sum of the squares of the
-elements in each column, as a row vector.
-@end deftypefn
+@DOCSTRING(sumsq)
 
 @node Special Functions, Mathematical Constants, Sums and Products, Arithmetic
 @section Special Functions
 
-@deftypefn {Mapping Function} {} besseli (@var{alpha}, @var{x})
-@deftypefnx {Mapping Function} {} besselj (@var{alpha}, @var{x})
-@deftypefnx {Mapping Function} {} besselk (@var{alpha}, @var{x})
-@deftypefnx {Mapping Function} {} bessely (@var{alpha}, @var{x})
-Compute Bessel functions of the following types:
-
-@table @code
-@item besselj
-Bessel functions of the first kind.
-
-@item bessely
-Bessel functions of the second kind.
-
-@item besseli
-Modified Bessel functions of the first kind.
-
-@item besselk
-Modified Bessel functions of the second kind.
-@end table
-
-The second argument, @var{x}, must be a real matrix, vector, or scalar.
-
-The first argument, @var{alpha}, must be greater than or equal to zero.
-If @var{alpha} is a range, it must have an increment equal to one.
-
-If @var{alpha} is a scalar, the result is the same size as @var{x}.
-
-If @var{alpha} is a range, @var{x} must be a vector or scalar, and the
-result is a matrix with @code{length(@var{x})} rows and
-@code{length(@var{alpha})} columns.
-@end deftypefn
+@DOCSTRING(bessel)
 
-@deftypefn {Mapping Function} {} beta (@var{a}, @var{b})
-Return the Beta function,
-@iftex
-@tex
-$$
- B (a, b) = {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
-$$
-@end tex
-@end iftex
-@ifinfo
-
-@example
-beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).
-@end example
-@end ifinfo
-@end deftypefn
+@DOCSTRING(beta)
 
-@deftypefn {Mapping Function} {} betai (@var{a}, @var{b}, @var{x})
-Return the incomplete Beta function,
-@iftex
-@tex
-$$
- \beta (a, b, x) = B (a, b)^{-1} \int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.
-$$
-@end tex
-@end iftex
-@ifinfo
-
-@smallexample
-                                    x
-                                   /
-betai (a, b, x) = beta (a, b)^(-1) | t^(a-1) (1-t)^(b-1) dt.
-                                   /
-                                t=0
-@end smallexample
-@end ifinfo
-
-If x has more than one component, both @var{a} and @var{b} must be
-scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of
-compatible dimensions.
-@end deftypefn
+@DOCSTRING(betai)
 
-@deftypefn {Mapping Function} {} bincoeff (@var{n}, @var{k})
-Return the binomial coefficient of @var{n} and @var{k}, defined as
-@iftex
-@tex
-$$
- {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
-$$
-@end tex
-@end iftex
-@ifinfo
-
-@example
-@group
- /   \
- | n |    n (n-1) (n-2) ... (n-k+1)
- |   |  = -------------------------
- | k |               k!
- \   /
-@end group
-@end example
-@end ifinfo
-
-For example,
-
-@example
-@group
-bincoeff (5, 2)
-     @result{} 10
-@end group
-@end example
-@end deftypefn
+@DOCSTRING(bincoeff)
 
-@deftypefn {Mapping Function} {} erf (@var{z})
-Computes the error function,
-@iftex
-@tex
-$$
- {\rm erf} (z) = {2 \over \sqrt{\pi}}\int_0^z e^{-t^2} dt
-$$
-@end tex
-@end iftex
-@ifinfo
-
-@smallexample
-                         z
-                        /
-erf (z) = (2/sqrt (pi)) | e^(-t^2) dt
-                        /
-                     t=0
-@end smallexample
-@end ifinfo
-@end deftypefn
+@DOCSTRING(erf)
 
-@deftypefn {Mapping Function} {} erfc (@var{z})
-Computes the complementary error function,
-@iftex
-@tex
-$1 - {\rm erf} (z)$.
-@end tex
-@end iftex
-@ifinfo
-@code{1 - erf (@var{z})}.
-@end ifinfo
-@end deftypefn
-
-@deftypefn {Mapping Function} {} erfinv (@var{z})
-Computes the inverse of the error function,
-@end deftypefn
-
-@deftypefn {Mapping Function} {} gamma (@var{z})
-Computes the Gamma function,
-@iftex
-@tex
-$$
- \Gamma (z) = \int_0^\infty t^{z-1} e^{-t} dt.
-$$
-@end tex
-@end iftex
-@ifinfo
+@DOCSTRING(erfc)
 
-@example
-            infinity
-            /
-gamma (z) = | t^(z-1) exp (-t) dt.
-            /
-         t=0
-@end example
-@end ifinfo
-@end deftypefn
-
-@deftypefn {Mapping Function} {} gammai (@var{a}, @var{x})
-Computes the incomplete gamma function,
-@iftex
-@tex
-$$
- \gamma (a, x) = {\displaystyle\int_0^x e^{-t} t^{a-1} dt \over \Gamma (a)}
-$$
-@end tex
-@end iftex
-@ifinfo
+@DOCSTRING(erfinv)
 
-@smallexample
-                              x
-                    1        /
-gammai (a, x) = ---------    | exp (-t) t^(a-1) dt
-                gamma (a)    /
-                          t=0
-@end smallexample
-@end ifinfo
-
-If @var{a} is scalar, then @code{gammai (@var{a}, @var{x})} is returned
-for each element of @var{x} and vice versa.
-
-If neither @var{a} nor @var{x} is scalar, the sizes of @var{a} and
-@var{x} must agree, and @var{gammai} is applied element-by-element.
-@end deftypefn
+@DOCSTRING(gamma)
 
-@deftypefn {Mapping Function} {} lgamma (@var{a}, @var{x})
-@deftypefnx {Mapping Function} {} gammaln (@var{a}, @var{x})
-Return the natural logarithm of the gamma function.
-@end deftypefn
-
-@deftypefn {Function File} {} cross (@var{x}, @var{y})
-Computes the vector cross product of the two 3-dimensional vectors
-@var{x} and @var{y}.  For example,
-
-@example
-@group
-cross ([1,1,0], [0,1,1])
-     @result{} [ 1; -1; 1 ]
-@end group
-@end example
-@end deftypefn
+@DOCSTRING(gammai)
 
-@deftypefn {Function File} {} commutation_matrix (@var{m}, @var{n})
-Return the commutation matrix
-@iftex
-@tex
- $K_{m,n}$
-@end tex
-@end iftex
-@ifinfo
- K(m,n)
-@end ifinfo
- which is the unique
-@iftex
-@tex
- $m n \times m n$
-@end tex
-@end iftex
-@ifinfo
- @var{m}*@var{n} by @var{m}*@var{n}
-@end ifinfo
- matrix such that
-@iftex
-@tex
- $K_{m,n} \cdot {\rm vec} (A) = {\rm vec} (A^T)$
-@end tex
-@end iftex
-@ifinfo
- @var{K}(@var{m},@var{n}) * vec (@var{A}) = vec (@var{A}')
-@end ifinfo
- for all
-@iftex
-@tex
- $m\times n$
-@end tex
-@end iftex
-@ifinfo
- @var{m} by @var{n}
-@end ifinfo
- matrices
-@iftex
-@tex
- $A$.
-@end tex
-@end iftex
-@ifinfo
- @var{A}.
-@end ifinfo
+@DOCSTRING(lgamma)
+
+@DOCSTRING(cross)
 
-If only one argument @var{m} is given,
-@iftex
-@tex
- $K_{m,m}$
-@end tex
-@end iftex
-@ifinfo
- K(m,m)
-@end ifinfo
- is returned.
-
-See Magnus and Neudecker (1988), Matrix differential calculus with
-applications in statistics and econometrics.
-@end deftypefn
+@DOCSTRING(commutation_matrix)
 
-@deftypefn {Function File} {} duplication_matrix (@var{n})
-Return the duplication matrix
-@iftex
-@tex
- $D_n$
-@end tex
-@end iftex
-@ifinfo
- @var{D}_@var{n}
-@end ifinfo
- which is the unique
-@iftex
-@tex
- $n^2 \times n(n+1)/2$
-@end tex
-@end iftex
-@ifinfo
- @var{n}^2 by @var{n}*(@var{n}+1)/2
-@end ifinfo
- matrix such that
-@iftex
-@tex
- $D_n * {\rm vech} (A) = {\rm vec} (A)$
-@end tex
-@end iftex
-@ifinfo
- @var{D}_@var{n} \cdot vech (@var{A}) = vec (@var{A})
-@end ifinfo
- for all symmetric
-@iftex
-@tex
- $n \times n$
-@end tex
-@end iftex
-@ifinfo
- @var{n} by @var{n}
-@end ifinfo
- matrices
-@iftex
-@tex
- $A$.
-@end tex
-@end iftex
-@ifinfo
- @var{A}.
-@end ifinfo
-
-See Magnus and Neudecker (1988), Matrix differential calculus with
-applications in statistics and econometrics.
-@end deftypefn
+@DOCSTRING(duplication_matrix)
 
 @node Mathematical Constants,  , Special Functions, Arithmetic
 @section Mathematical Constants
 
-@defvr {Built-in Variable} I
-@defvrx {Built-in Variable} J
-@defvrx {Built-in Variable} i
-@defvrx {Built-in Variable} j
-A pure imaginary number, defined as
-@iftex
-@tex
-  $\sqrt{-1}$.
-@end tex
-@end iftex
-@ifinfo
-  @code{sqrt (-1)}.
-@end ifinfo
-The @code{I} and @code{J} forms are true constants, and cannot be
-modified.  The @code{i} and @code{j} forms are like ordinary variables,
-and may be used for other purposes.  However, unlike other variables,
-they once again assume their special predefined values if they are
-cleared @xref{Status of Variables}.
-@end defvr
+@DOCSTRING(I)
+
+@DOCSTRING(Inf)
 
-@defvr {Built-in Variable} Inf
-@defvrx {Built-in Variable} inf
-Infinity.  This is the result of an operation like 1/0, or an operation
-that results in a floating point overflow.
-@end defvr
+@DOCSTRING(NaN)
 
-@defvr {Built-in Variable} NaN
-@defvrx {Built-in Variable} nan
-Not a number.  This is the result of an operation like
-@iftex
-@tex
-$0/0$, or $\infty - \infty$,
-@end tex
-@end iftex
-@ifinfo
-0/0, or @samp{Inf - Inf},
-@end ifinfo
-or any operation with a NaN.
-
-Note that NaN always compares not equal to NaN.  This behavior is
-specified by the IEEE standard for floating point arithmetic.  To
-find NaN values, you must use the @code{isnan} function.
-@end defvr
-
-@defvr {Built-in Variable} pi
-The ratio of the circumference of a circle to its diameter.
-Internally, @code{pi} is computed as @samp{4.0 * atan (1.0)}.
-@end defvr
+@DOCSTRING(pi)
 
-@defvr {Built-in Variable} e
-The base of natural logarithms.  The constant
-@iftex
-@tex
- $e$
-@end tex
-@end iftex
-@ifinfo
- @var{e}
-@end ifinfo
- satisfies the equation
-@iftex
-@tex
- $\log (e) = 1$.
-@end tex
-@end iftex
-@ifinfo
- @code{log} (@var{e}) = 1.
-@end ifinfo
-@end defvr
+@DOCSTRING(e)
+
+@DOCSTRING(eps)
 
-@defvr {Built-in Variable} eps
-The machine precision.  More precisely, @code{eps} is the largest
-relative spacing between any two adjacent numbers in the machine's
-floating point system.  This number is obviously system-dependent.  On
-machines that support 64 bit IEEE floating point arithmetic, @code{eps}
-is approximately
-@ifinfo
- 2.2204e-16.
-@end ifinfo
-@iftex
-@tex
- $2.2204\times10^{-16}$.
-@end tex
-@end iftex
-@end defvr
+@DOCSTRING(realmax)
 
-@defvr {Built-in Variable} realmax
-The largest floating point number that is representable.  The actual
-value is system-dependent.  On machines that support 64 bit IEEE
-floating point arithmetic, @code{realmax} is approximately
-@ifinfo
- 1.7977e+308
-@end ifinfo
-@iftex
-@tex
- $1.7977\times10^{308}$.
-@end tex
-@end iftex
-@end defvr
-
-@defvr {Built-in Variable} realmin
-The smallest floating point number that is representable.  The actual
-value is system-dependent.  On machines that support 64 bit IEEE
-floating point arithmetic, @code{realmin} is approximately
-@ifinfo
- 2.2251e-308
-@end ifinfo
-@iftex
-@tex
- $2.2251\times10^{-308}$.
-@end tex
-@end iftex
-@end defvr
+@DOCSTRING(realmin)
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -217,184 +217,45 @@ valid expression
 [ a 'foo' ]
 @end example
 
 For clarity, it is probably best to always use commas and semicolons to
 separate matrix elements and rows.  It is possible to enforce this style
 by setting the built-in variable @code{whitespace_in_literal_matrix} to
 @code{"ignore"}.
 
-@defvr {Built-in Variable} whitespace_in_literal_matrix
-This variable allows some control over how Octave decides to convert
-spaces to commas and semicolons in matrix expressions like
-@code{[m (1)]} or
-
-@example
-[ 1, 2,
-  3, 4 ]
-@end example
-
-If the value of @code{whitespace_in_literal_matrix} is @code{"ignore"},
-Octave will never insert a comma or a semicolon in a literal matrix
-list.  For example, the expression @code{[1 2]} will result in an error
-instead of being treated the same as @code{[1, 2]}, and the expression
-
-@example
-[ 1, 2,
-  3, 4 ]
-@end example
-
-@noindent
-will result in the vector @code{[ 1, 2, 3, 4 ]} instead of a matrix.
-
-If the value of @code{whitespace_in_literal_matrix} is @code{"traditional"},
-Octave will convert spaces to a comma between identifiers and @samp{(}.  For
-example, given the matrix
-
-@example
-m = [3 2]
-@end example
-
-@noindent
-the expression
-
-@example
-[m (1)]
-@end example
-
-@noindent
-will be parsed as
-
-@example
-[m, (1)]
-@end example
-
-@noindent
-and will result in
-
-@example
-[3 2 1]
-@end example
-
-@noindent
-and the expression
-
-@example
-[ 1, 2,
-  3, 4 ]
-@end example
-
-@noindent
-will result in a matrix because the newline character is converted to a
-semicolon (row separator) even though there is a comma at the end of the
-first line (trailing commas or semicolons are ignored).  This is
-apparently how @sc{Matlab} behaves.
-
-Any other value for @code{whitespace_in_literal_matrix} results in behavior
-that is the same as traditional, except that Octave does not
-convert spaces to a comma between identifiers and @samp{(}.  For
-example, the expression
-
-@example
-[m (1)]
-@end example
-
-will produce @samp{3}.  This is the way Octave has always behaved.
-@end defvr
+@DOCSTRING(whitespace_in_literal_matrix)
 
 When you type a matrix or the name of a variable whose value is a
 matrix, Octave responds by printing the matrix in with neatly aligned
 rows and columns.  If the rows of the matrix are too large to fit on the
 screen, Octave splits the matrix and displays a header before each
 section to indicate which columns are being displayed.  You can use the
 following variables to control the format of the output.
 
-@defvr {Built-in Variable} output_max_field_width
-This variable specifies the maximum width of a numeric output field.
-The default value is 10.
-@end defvr
+@DOCSTRING(output_max_field_width)
 
-@defvr {Built-in Variable} output_precision
-This variable specifies the minimum number of significant figures to
-display for numeric output.  The default value is 5.
-@end defvr
+@DOCSTRING(output_precision)
 
 It is possible to achieve a wide range of output styles by using
 different values of @code{output_precision} and
 @code{output_max_field_width}.  Reasonable combinations can be set using
 the @code{format} function.  @xref{Basic Input and Output}.
 
-@defvr {Built-in Variable} split_long_rows
-For large matrices, Octave may not be able to display all the columns of
-a given row on one line of your screen.  This can result in missing
-information or output that is nearly impossible to decipher, depending
-on whether your terminal truncates or wraps long lines.
-
-If the value of @code{split_long_rows} is nonzero, Octave will display
-the matrix in a series of smaller pieces, each of which can fit within
-the limits of your terminal width.  Each set of rows is labeled so that
-you can easily see which columns are currently being displayed.
-For example:
-
-@smallexample
-@group
-octave:13> rand (2,10)
-ans =
-
- Columns 1 through 6:
-
-  0.75883  0.93290  0.40064  0.43818  0.94958  0.16467
-  0.75697  0.51942  0.40031  0.61784  0.92309  0.40201
-
- Columns 7 through 10:
-
-  0.90174  0.11854  0.72313  0.73326
-  0.44672  0.94303  0.56564  0.82150
-@end group
-@end smallexample
-
-@noindent
-The default value of @code{split_long_rows} is nonzero.
-@end defvr
+@DOCSTRING(split_long_rows)
 
 Octave automatically switches to scientific notation when values become
 very large or very small.  This guarantees that you will see several
 significant figures for every value in a matrix.  If you would prefer to
 see all values in a matrix printed in a fixed point format, you can set
 the built-in variable @code{fixed_point_format} to a nonzero value.  But
 doing so is not recommended, because it can produce output that can
 easily be misinterpreted.
 
-@defvr {Built-in Variable} fixed_point_format
-If the value of this variable is nonzero, Octave will scale all values
-in a matrix so that the largest may be written with one leading digit.
-The scaling factor is printed on the first line of output.  For example,
-
-@example
-@group
-octave:1> logspace (1, 7, 5)'
-ans =
-
-  1.0e+07  *
-
-  0.00000
-  0.00003
-  0.00100
-  0.03162
-  1.00000
-@end group
-@end example
-
-@noindent
-Notice that first value appears to be zero when it is actually 1.  For
-this reason, you should be careful when setting
-@code{fixed_point_format} to a nonzero value.
-
-The default value of @code{fixed_point_format} is 0.
-@end defvr
+@DOCSTRING(fixed_point_format)
 
 @menu
 * Empty Matrices::              
 @end menu
 
 @node Empty Matrices,  , Matrices, Matrices
 @subsection Empty Matrices
 
@@ -439,68 +300,34 @@ s * [](mxn) = [](mxn) * s = [](mxn)
 @end group
 @end example
 @end ifinfo
 
 By default, dimensions of the empty matrix are printed along with the
 empty matrix symbol, @samp{[]}.  The built-in variable
 @code{print_empty_dimensions} controls this behavior.
 
-@defvr {Built-in Variable} print_empty_dimensions
-If the value of @code{print_empty_dimensions} is nonzero, the
-dimensions of empty matrices are printed along with the empty matrix
-symbol, @samp{[]}.  For example, the expression
-
-@example
-zeros (3, 0)
-@end example
-
-@noindent
-will print
-
-@example
-ans = [](3x0)
-@end example
-@end defvr
+@DOCSTRING(print_empty_dimensions)
 
 Empty matrices may also be used in assignment statements as a convenient
 way to delete rows or columns of matrices.
 @xref{Assignment Ops, ,Assignment Expressions}.
 
 Octave will normally issue a warning if it finds an empty matrix in the
 list of elements that make up another matrix.  You can use the variable
 @code{empty_list_elements_ok} to suppress the warning or to treat it as
 an error.
 
-@defvr {Built-in Variable} empty_list_elements_ok
-This variable controls whether Octave ignores empty matrices in a matrix
-list.
-
-For example, if the value of @code{empty_list_elements_ok} is
-nonzero, Octave will ignore the empty matrices in the expression
-
-@example
-a = [1, [], 3, [], 5]
-@end example
-
-@noindent
-and the variable @code{a} will be assigned the value @code{[ 1, 3, 5 ]}.
-
-The default value is @code{"warn"}.
-@end defvr
+@DOCSTRING(empty_list_elements_ok)
 
 When Octave parses a matrix expression, it examines the elements of the
 list to determine whether they are all constants.  If they are, it
 replaces the list with a single matrix constant.
 
-@defvr {Built-in Variable} propagate_empty_matrices
-If the value of @code{propagate_empty_matrices} is nonzero,
-functions like @code{inverse} and @code{svd} will return an empty matrix
-if they are given one as an argument.  The default value is 1.
-@end defvr
+@DOCSTRING(propagate_empty_matrices)
 
 @node Ranges, Predicates for Numeric Objects, Matrices, Numeric Data Types
 @section Ranges
 @cindex range expressions
 @cindex expression, range
 
 @opindex :
 
@@ -542,30 +369,17 @@ instead (@pxref{Special Utility Matrices
 
 When Octave parses a range expression, it examines the elements of the
 expression to determine whether they are all constants.  If they are, it
 replaces the range expression with a single range constant.
 
 @node Predicates for Numeric Objects,  , Ranges, Numeric Data Types
 @section Predicates for Numeric Objects
 
-@deftypefn {Function File} {} is_matrix (@var{a})
-Return 1 if @var{a} is a matrix.  Otherwise, return 0.
-@end deftypefn
+@DOCSTRING(is_matrix)
 
-@deftypefn {Function File} {} is_vector (@var{a})
-Return 1 if @var{a} is a vector.  Otherwise, return 0.
-@end deftypefn
+@DOCSTRING(is_vector)
 
-@deftypefn {Function File} {} is_scalar (@var{a})
-Return 1 if @var{a} is a scalar.  Otherwise, return 0.
-@end deftypefn
+@DOCSTRING(is_scalar)
 
-@deftypefn {Function File} {} is_square (@var{x})
-If @var{x} is a square matrix, then return the dimension of @var{x}.
-Otherwise, return 0.
-@end deftypefn
+@DOCSTRING(is_square)
 
-@deftypefn {Function File} {} is_symmetric (@var{x}, @var{tol})
-If @var{x} is symmetric within the tolerance specified by @var{tol}, 
-then return the dimension of @var{x}.  Otherwise, return 0.  If
-@var{tol} is omitted, use a tolerance equal to the machine precision.
-@end deftypefn
+@DOCSTRING(is_symmetric)
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,44 @@
+1999-10-26  Ben Sapp <bsapp@nua.lampf.lanl.gov>
+
+	* elfun/acot.m: Texinfoize doc string.
+	* elfun/acsc.m: Ditto.
+	* elfun/acsch.m: Ditto.
+	* elfun/asec.m: Ditto.
+	* elfun/asech.m: Ditto.
+	* elfun/cot.m: Ditto.
+	* elfun/coth.m: Ditto.
+	* elfun/csc.m: Ditto.
+	* elfun/csch.m: Ditto.
+	* elfun/gcd.m: Ditto.
+	* elfun/lcm.m: Ditto.
+	* elfun/sec.m: Ditto.
+	* elfun/sech.m: Ditto.
+	* general/nextpow2.m: Ditto.
+	* general/rem.m: Ditto.
+	* linear-algebra/commutation_matrix.m: Ditto.
+	* linear-algebra/cross.m: Ditto.
+	* linear-algebra/duplication_matrix.m: Ditto.
+	* miscellaneous/bincoeff.m: Ditto.
+	* miscellaneous/xor.m: Ditto.
+	* specfun/bessel.m: Ditto.
+	* specfun/beta.m: Ditto.
+	* specfun/betai.m: Ditto.
+	* specfun/erfinv.m: Ditto.
+	* specfun/gammai.m: Ditto.
+	* specfun/log2.m: Ditto.
+	* specfun/pow2.m: Ditto.
+
+1999-10-23  Ben Sapp <bsapp@nua.lampf.lanl.gov>
+
+	* general/is_scalar.m: Texinfoize help text.
+	* general/is_square.m: Ditto.
+	* general/is_symmetric.m: Ditto.
+
 1999-10-22  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* strings/split.m: If the string to be split is empty, just return
 	an empty string.
 
 1999-10-21  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (ALL_M_FILES): New macro.
diff --git a/scripts/elfun/acot.m b/scripts/elfun/acot.m
--- a/scripts/elfun/acot.m
+++ b/scripts/elfun/acot.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## acot (z):  compute the inverse cotangent for each element of z.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} acot (@var{X})
+## acot (X): compute the inverse cotangent of X for each element of X
+## @end deftypefn
 
 ## Author: jwe
 
 function w = acot (z)
 
   if (nargin != 1)
     usage ("acot (z)");
   endif
diff --git a/scripts/elfun/acsc.m b/scripts/elfun/acsc.m
--- a/scripts/elfun/acsc.m
+++ b/scripts/elfun/acsc.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## acsc (z):  compute the inverse cosecant for each element of z.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} acsc (@var{X})
+## acsc (X): compute the inverse cosecant of X for each element of X
+## @end deftypefn
 
 ## Author: jwe
 
 function w = acsc (z)
 
   if (nargin != 1)
     usage ("acsc (z)");
   endif
diff --git a/scripts/elfun/acsch.m b/scripts/elfun/acsch.m
--- a/scripts/elfun/acsch.m
+++ b/scripts/elfun/acsch.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## acsch (z):  compute the inverse hyperbolic cosecant for each element of z.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} acsch (@var{X})
+## acsch (X): compute the inverse hyperbolic for each element of X
+## @end deftypefn
 
 ## Author: jwe
 
 function w = acsch (z)
 
   if (nargin != 1)
     usage ("acsch (z)");
   endif
diff --git a/scripts/elfun/asec.m b/scripts/elfun/asec.m
--- a/scripts/elfun/asec.m
+++ b/scripts/elfun/asec.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## asec (z):  compute the inverse secant for each element of z.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} asec (@var{X})
+## asec (X): compute the inverse secant of X for each element of X
+## @end deftypefn
 
 ## Author: jwe
 
 function w = asec (z)
 
   if (nargin != 1)
     usage ("asec (z)");
   endif
diff --git a/scripts/elfun/asech.m b/scripts/elfun/asech.m
--- a/scripts/elfun/asech.m
+++ b/scripts/elfun/asech.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## asech (z):  compute the inverse hyperbolic secant for each element of z.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} asech (@var{X})
+## asech (X): compute the inverse hyperbolic secant of X for each element of X
+## @end deftypefn
 
 ## Author: jwe
 
 function w = asech (z)
 
   if (nargin != 1)
     usage ("acosh (z)");
   endif
diff --git a/scripts/elfun/cot.m b/scripts/elfun/cot.m
--- a/scripts/elfun/cot.m
+++ b/scripts/elfun/cot.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## cot (z):  compute the cotangent for each element of z.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} cot (@var{X})
+## cot (X): compute the cotangent of X for each element of X
+## @end deftypefn
 
 ## Author: jwe
 
 function w = cot (z)
 
   if (nargin != 1)
     usage ("cot (z)");
   endif
diff --git a/scripts/elfun/coth.m b/scripts/elfun/coth.m
--- a/scripts/elfun/coth.m
+++ b/scripts/elfun/coth.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## coth (z):  compute the hyperbolic cotangent for each element of z.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} coth (@var{X})
+## coth (X): compute the hyperbolic cotangent of X for each element of X
+## @end deftypefn
 
 ## Author: jwe
 
 function w = coth (z)
 
   if (nargin != 1)
     usage ("coth (z)");
   endif
diff --git a/scripts/elfun/csc.m b/scripts/elfun/csc.m
--- a/scripts/elfun/csc.m
+++ b/scripts/elfun/csc.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## csc (z):  compute the cosecant for each element of z.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} csc (@var{X})
+## csc (X): compute the cosecant of X for each element of X
+## @end deftypefn
 
 ## Author: jwe
 
 function w = csc (z)
 
   if (nargin != 1)
     usage ("csc (z)");
   endif
diff --git a/scripts/elfun/csch.m b/scripts/elfun/csch.m
--- a/scripts/elfun/csch.m
+++ b/scripts/elfun/csch.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## csch (z):  compute the hyperbolic cosecant for each element of z.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} csch (@var{X})
+## csch (X): compute the hyperbolic cosecant of X for each element of X
+## @end deftypefn
 
 ## Author: jwe
 
 function w = csch (z)
 
   if (nargin != 1)
     usage ("csch (z)");
   endif
diff --git a/scripts/elfun/gcd.m b/scripts/elfun/gcd.m
--- a/scripts/elfun/gcd.m
+++ b/scripts/elfun/gcd.m
@@ -12,23 +12,41 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: gcd (a, ...)
-##
-## [g [, v]] = gcd (a) returns the greatest common divisor g of the
-## entries of the integer vector a, and an integer vector v such that
-## g = v(1) * a(k) + ... + v(k) * a(k).
-##
-## [g [, v]] = gcd (a1, ..., ak) is the same with a = [a1, ..., ak].
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} gcd (@var{x}, @code{...})
+## Compute the greatest common divisor of the elements of @var{x}, or the
+## list of all the arguments.  For example, 
+## 
+## @example
+## gcd (a1, ..., ak)
+## @end example
+## 
+## @noindent
+## is the same as
+## 
+## @example
+## gcd ([a1, ..., ak])
+## @end example
+## 
+## An optional second return value, @var{v}
+## contains an integer vector such that
+## 
+## @example
+## g = v(1) * a(k) + ... + v(k) * a(k)
+## @end example
+## @end deftypefn
+
+## See also: lcm, min, max, ceil, floor.
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function [g, v] = gcd (a, ...)
 
   if (nargin == 0)
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -12,21 +12,34 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: lcm (a, ...)
-##
-## lcm (a) returns the least common multiple of the entries of the
-## integer vector a.
-## lcm (a1, ..., ak) is the same as lcm([a1, ..., ak]).
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} lcm (@var{x}, @code{...})
+## Compute the least common multiple of the elements elements of @var{x}, or
+## the list of all the arguments.  For example, 
+## 
+## @example
+## lcm (a1, ..., ak)
+## @end example
+## 
+## @noindent
+## is the same as
+## 
+## @example
+## lcm ([a1, ..., ak]).
+## @end example
+## @end deftypefn
+
+## See also: gcd, min, max, ceil, floor.  
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function l = lcm (a, ...)
 
   if (nargin == 0)
diff --git a/scripts/elfun/sec.m b/scripts/elfun/sec.m
--- a/scripts/elfun/sec.m
+++ b/scripts/elfun/sec.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## sec (z): compute the secant for each element of z.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} sec (@var{X})
+## sec (X): compute the secant of X for each element of X
+## @end deftypefn
 
 ## Author: jwe
 
 function w = sec (z)
 
   if (nargin != 1)
     usage ("sec (z)");
   endif
diff --git a/scripts/elfun/sech.m b/scripts/elfun/sech.m
--- a/scripts/elfun/sech.m
+++ b/scripts/elfun/sech.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## sech (z):  compute the hyperbolic secant for each element of z.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} sech (@var{X})
+## sech (X): compute the hyperbolic secant of X for each element of X
+## @end deftypefn
 
 ## Author: jwe
 
 function w = sech (z)
 
 if (nargin != 1)
     usage ("sech (z)");
   endif
diff --git a/scripts/general/is_scalar.m b/scripts/general/is_scalar.m
--- a/scripts/general/is_scalar.m
+++ b/scripts/general/is_scalar.m
@@ -12,20 +12,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: is_scalar (x)
-##
-## Return 1 if the number of rows and columns of x are both equal to 1.
-##
+## -*- texinfo -*-
+## @deftypefn {Usage} {} is_scalar (@var{a})
+## Return 1 if @var{a} is a scalar.  Otherwise, return 0.
+## @end deftypefn
+
 ## See also: size, rows, columns, length, is_scalar, is_matrix
 
 ## Author: jwe
 
 function retval = is_scalar (x)
 
   retval = 0;
 
diff --git a/scripts/general/is_square.m b/scripts/general/is_square.m
--- a/scripts/general/is_square.m
+++ b/scripts/general/is_square.m
@@ -12,21 +12,22 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: is_square (x)
-##
-## If x is square, then return value is the dimension of x.
-## otherwise, returns a value of 0
-##
+## -*- texinfo -*-
+## @deftypefn {Usage} {} is_square (@var{x})
+## If @var{x} is a square matrix, then return the dimension of @var{x}.
+## Otherwise, return 0.
+## @end deftypefn
+
 ## See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function retval = is_square (x)
 
diff --git a/scripts/general/is_symmetric.m b/scripts/general/is_symmetric.m
--- a/scripts/general/is_symmetric.m
+++ b/scripts/general/is_symmetric.m
@@ -12,20 +12,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## Usage: is_symmetric (x {,tol})
-##
-## If x is symmetric, return the dimension of x, otherwise, return 0.
-##
+## -*- texinfo -*-
+## @deftypefn {Function File} {} is_symmetric (@var{x}, @var{tol})
+## If @var{x} is symmetric within the tolerance specified by @var{tol}, 
+## then return the dimension of @var{x}.  Otherwise, return 0.  If
+## @var{tol} is omitted, use a tolerance equal to the machine precision.
+## @end deftypefn
+
 ## See also: size, rows, columns, length, is_matrix, is_scalar,
 ## is_square, is_vector
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function retval = is_symmetric (x,tol)
diff --git a/scripts/general/is_vector.m b/scripts/general/is_vector.m
--- a/scripts/general/is_vector.m
+++ b/scripts/general/is_vector.m
@@ -12,20 +12,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: is_vector (x)
-##
-## Return 1 if X is a vector.  Otherwise, return 0.
-##
+## -*- texinfo -*-
+## @deftypefn {Usage} {} is_vector (@var{a})
+## Return 1 if @var{a} is a vector.  Otherwise, return 0.
+## @end deftypefn
+
 ## See also: size, rows, columns, length, is_scalar, is_matrix
 
 ## Author: jwe
 
 function retval = is_vector (x)
 
   retval = 0;
 
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -9,22 +9,32 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  nextpow2 (x)
-##
-## If x is a scalar, returns the first integer n such that
-## 2^n >= abs (x). 
-##
-## If x is a vector, return nextpow2 (length (x)). 
+## -*- texinfo -*-
+## @deftypefn {Function File} {} nextpow2 (@var{x})
+## If @var{x} is a scalar, returns the first integer @var{n} such that
+## @iftex
+## @tex
+##  $2^n \ge |x|$.
+## @end tex
+## @end iftex
+## @ifinfo
+##  2^n >= abs (x).
+## @end ifinfo
+## 
+## If @var{x} is a vector, return @code{nextpow2 (length (@var{x}))}.
+## @end deftypefn
+
+## See also: pow2
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 7 October 1994
 ## Adapted-By: jwe
 
 function n = nextpow2 (x)
   
   if (nargin != 1)
diff --git a/scripts/general/rem.m b/scripts/general/rem.m
--- a/scripts/general/rem.m
+++ b/scripts/general/rem.m
@@ -12,19 +12,30 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: rem (x, y)
-##
-## Return remainder (x, y).
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} rem (@var{x}, @var{y})
+## Return the remainder of @code{@var{x} / @var{y}}, computed using the
+## expression
+## 
+## @example
+## x - y .* fix (x ./ y)
+## @end example
+## 
+## An error message is printed if the dimensions of the arguments do not
+## agree, or if either of the arguments is complex.
+## @end deftypefn
+
+## See also: round
 
 ## Author: jwe
 
 function retval = rem (x, y)
 
   if (nargin != 2)
     usage ("rem (x, y)");
   endif
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -9,26 +9,78 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  commutation_matrix (m [, n])
+## -*- texinfo -*-
+## @deftypefn {Function File} {} commutation_matrix (@var{m}, @var{n})
+## Return the commutation matrix
+## @iftex
+## @tex
+##  $K_{m,n}$
+## @end tex
+## @end iftex
+## @ifinfo
+##  K(m,n)
+## @end ifinfo
+##  which is the unique
+## @iftex
+## @tex
+##  $m n \times m n$
+## @end tex
+## @end iftex
+## @ifinfo
+##  @var{m}*@var{n} by @var{m}*@var{n}
+## @end ifinfo
+##  matrix such that
+## @iftex
+## @tex
+##  $K_{m,n} \cdot {\rm vec} (A) = {\rm vec} (A^T)$
+## @end tex
+## @end iftex
+## @ifinfo
+##  @var{K}(@var{m},@var{n}) * vec (@var{A}) = vec (@var{A}')
+## @end ifinfo
+##  for all
+## @iftex
+## @tex
+##  $m\times n$
+## @end tex
+## @end iftex
+## @ifinfo
+##  @var{m} by @var{n}
+## @end ifinfo
+##  matrices
+## @iftex
+## @tex
+##  $A$.
+## @end tex
+## @end iftex
+## @ifinfo
+##  @var{A}.
+## @end ifinfo
 ## 
-## Returns the commutation matrix K_{m,n} which is the unique m*n by
-## m*n matrix such that K_{m,n} * vec (A) = vec (A') for all m by n
-## matrices A.
-##
-## If only one argument m is given, K_{m,m} is returned.
-##
+## If only one argument @var{m} is given,
+## @iftex
+## @tex
+##  $K_{m,m}$
+## @end tex
+## @end iftex
+## @ifinfo
+##  K(m,m)
+## @end ifinfo
+##  is returned.
+## 
 ## See Magnus and Neudecker (1988), Matrix differential calculus with
 ## applications in statistics and econometrics.
+## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 8 May 1995
 ## Adapted-By: jwe
 
 function k = commutation_matrix (m, n)
   
   if (nargin < 1 || nargin > 2)
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -9,20 +9,28 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  cross (x, y)
-##
+## -*- texinfo -*-
+## @deftypefn {Function File} {} cross (@var{x}, @var{y})
 ## Computes the vector cross product of the two 3-dimensional vectors
-## x and y.
+## @var{x} and @var{y}.  For example,
+## 
+## @example
+## @group
+## cross ([1,1,0], [0,1,1])
+##      @result{} [ 1; -1; 1 ]
+## @end group
+## @end example
+## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 15 October 1994
 ## Adapted-By: jwe
 
 function z = cross (x, y)
   
   if (nargin != 2)
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -9,24 +9,67 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage: duplication_matrix (n)
-## 
-## Returns the duplication matrix D_n which is the unique n^2 by
-## n*(n+1)/2 matrix such that D_n * vech (A) = vec (A) for all
-## symmetric n by n matrices A.
+## -*- texinfo -*- 
+## @deftypefn {Function File} {} duplication_matrix (@var{n})
+## Return the duplication matrix
+## @iftex
+## @tex
+##  $D_n$
+## @end tex
+## @end iftex
+## @ifinfo
+##  @var{D}_@var{n}
+## @end ifinfo
+##  which is the unique
+## @iftex
+## @tex
+##  $n^2 \times n(n+1)/2$
+## @end tex
+## @end iftex
+## @ifinfo
+##  @var{n}^2 by @var{n}*(@var{n}+1)/2
+## @end ifinfo
+##  matrix such that
+## @iftex
+## @tex
+##  $D_n * {\rm vech} (A) = {\rm vec} (A)$
+## @end tex
+## @end iftex
+## @ifinfo
+##  @var{D}_@var{n} \cdot vech (@var{A}) = vec (@var{A})
+## @end ifinfo
+##  for all symmetric
+## @iftex
+## @tex
+##  $n \times n$
+## @end tex
+## @end iftex
+## @ifinfo
+##  @var{n} by @var{n}
+## @end ifinfo
+##  matrices
+## @iftex
+## @tex
+##  $A$.
+## @end tex
+## @end iftex
+## @ifinfo
+##  @var{A}.
+## @end ifinfo
 ## 
 ## See Magnus and Neudecker (1988), Matrix differential calculus with
 ## applications in statistics and econometrics.
+## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 8 May 1995
 ## Adapged-By: jwe
 
 function d = duplication_matrix (n)
 
   if (nargin != 1)
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -9,19 +9,48 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  bincoeff (n, k)
-##
-## Returns the binomial coefficient of n and k.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} bincoeff (@var{n}, @var{k})
+## Return the binomial coefficient of @var{n} and @var{k}, defined as
+## @iftex
+## @tex
+## $$
+##  {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
+## $$
+## @end tex
+## @end iftex
+## @ifinfo
+## 
+## @example
+## @group
+##  /   \
+##  | n |    n (n-1) (n-2) ... (n-k+1)
+##  |   |  = -------------------------
+##  | k |               k!
+##  \   /
+## @end group
+## @end example
+## @end ifinfo
+## 
+## For example,
+## 
+## @example
+## @group
+## bincoeff (5, 2)
+##      @result{} 10
+## @end group
+## @end example
+## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 8 October 1994
 ## Adapted-By: jwe
 
 function b = bincoeff (n, k)
   
   if (nargin != 2)
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -9,21 +9,23 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  xor (x, y)
-##
-## Returns the "exclusive or" of the entries of x and y.
-## For boolean expressions x and y, xor (x, y) is true iff either x
-## or y is true.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} xor (@var{x}, @var{y})
+## Return the `exclusive or' of the entries of @var{x} and @var{y}.
+## For boolean expressions @var{x} and @var{y},
+## @code{xor (@var{x}, @var{y})} is true if and only if @var{x} or @var{y}
+## is true, but not if both @var{x} and @var{y} are true.
+## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function z = xor (x, y)
 
   if (nargin == 2)
diff --git a/scripts/mkdoc b/scripts/mkdoc
--- a/scripts/mkdoc
+++ b/scripts/mkdoc
@@ -1,9 +1,11 @@
 #! /bin/sh
 
 if test $# != 1; then
   d=.
 else
   d=$1
 fi
 
-find $d -name '*.m' | sed "s,\(.*\)/\(.*\)\.m,./gethelp \2 < &," | /bin/sh
+find $d -name '*.m' | \
+  sed "s,\(.*\)/\(.*\)\.m,./gethelp \2 < & | sed 's/ *@/@/'," | \
+  /bin/sh
diff --git a/scripts/specfun/bessel.m b/scripts/specfun/bessel.m
--- a/scripts/specfun/bessel.m
+++ b/scripts/specfun/bessel.m
@@ -12,28 +12,45 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## The following functions are available for computing the values of
-## Bessel functions:
-##
-##   besselj (alpha, x)   Bessel functions of the first kind
-##   bessely (alpha, x)   Bessel functions of the second kind
-##   besseli (alpha, x)   modified Bessel functions of the first kind
-##   besselk (alpha, x)   modified Bessel functions of the second kind
-##
-## X must be a real matrix, vector or scalar.
-##
-## If ALPHA is a scalar, the result is the same size as X.  If ALPHA is
-## a range, X must be a vector or scalar, and the result is a matrix
-## with length(X) rows and length(ALPHA) columns.
-##
-## ALPHA must be greater than or equal to zero.  If ALPHA is a range, it
-## must have an increment equal to one.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} besseli (@var{alpha}, @var{x})
+## @deftypefnx {Mapping Function} {} besselj (@var{alpha}, @var{x})
+## @deftypefnx {Mapping Function} {} besselk (@var{alpha}, @var{x})
+## @deftypefnx {Mapping Function} {} bessely (@var{alpha}, @var{x})
+## Compute Bessel functions of the following types:
+## 
+## @table @code
+## @item besselj
+## Bessel functions of the first kind.
+## 
+## @item bessely
+## Bessel functions of the second kind.
+## 
+## @item besseli
+## Modified Bessel functions of the first kind.
+## 
+## @item besselk
+## Modified Bessel functions of the second kind.
+## @end table
+## 
+## The second argument, @var{x}, must be a real matrix, vector, or scalar.
+## 
+## The first argument, @var{alpha}, must be greater than or equal to zero.
+## If @var{alpha} is a range, it must have an increment equal to one.
+## 
+## If @var{alpha} is a scalar, the result is the same size as @var{x}.
+## 
+## If @var{alpha} is a range, @var{x} must be a vector or scalar, and the
+## result is a matrix with @code{length(@var{x})} rows and
+## @code{length(@var{alpha})} columns.
+## @end deftypefn
 
 function bessel ()
   error ("bessel: you must use besselj, bessely, besseli, or besselk");
 endfunction
+
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -12,20 +12,32 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: beta (a, b)
-##
-## Returns the beta function beta(a,b) = gamma(a) * gamma(b) / gamma(a+b)
-## of a and b.
+## @deftypefn {Mapping Function} {} beta (@var{a}, @var{b})
+## Return the Beta function,
+## @iftex
+## @tex
+## $$
+##  B (a, b) = {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
+## $$
+## @end tex
+## @end iftex
+## @ifinfo
+## 
+## @example
+## beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).
+## @end example
+## @end ifinfo
+## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 13 June 1993
 ## Adapted-By: jwe
 
 function retval = beta (a, b)
 
   if (nargin != 2)
diff --git a/scripts/specfun/betai.m b/scripts/specfun/betai.m
--- a/scripts/specfun/betai.m
+++ b/scripts/specfun/betai.m
@@ -12,23 +12,41 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: beta (a, b, x)
-##
-## Compute the incomplete beta function
-##
-##  betai (a, b, x) = beta(a,b)^(-1) \int_0^x t^(a-1) (1-t)^(b-1) dt
-##
-## The sizes of x, a, and b must agree.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} betai (@var{a}, @var{b}, @var{x})
+## Return the incomplete Beta function,
+## @iftex
+## @tex
+## $$
+##  \beta (a, b, x) = B (a, b)^{-1} \int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.
+## $$
+## @end tex
+## @end iftex
+## @ifinfo
+## 
+## @smallexample
+##                                     x
+##                                    /
+## betai (a, b, x) = beta (a, b)^(-1) | t^(a-1) (1-t)^(b-1) dt.
+##                                    /
+##                                 t=0
+## @end smallexample
+## @end ifinfo
+## 
+## If x has more than one component, both @var{a} and @var{b} must be
+## scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of
+## compatible dimensions.
+## @end deftypefn
 
 ## Author: jwe
 ## Created: 30 Jan 1998
 
 function retval = betai (a, b, x)
 
   if (nargin == 3)
     retval = betainc (x, a, b);
diff --git a/scripts/specfun/erfinv.m b/scripts/specfun/erfinv.m
--- a/scripts/specfun/erfinv.m
+++ b/scripts/specfun/erfinv.m
@@ -9,19 +9,22 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  erfinv (x)
-##
-## Computes the inverse of the error function erf.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} erfinv (@var{z})
+## Computes the inverse of the error function,
+## @end deftypefn
+
+##  See also: erf, erfc
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 27 September 1994
 ## Adapted-By: jwe
 
 function [y, iterations] = erfinv (x)
   
   if (nargin != 1)
diff --git a/scripts/specfun/gammai.m b/scripts/specfun/gammai.m
--- a/scripts/specfun/gammai.m
+++ b/scripts/specfun/gammai.m
@@ -12,27 +12,45 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: gammai (a, x)
-##
-## Compute the incomplete gamma function
-##
-##   gammai (a, x) = (\int_0^x exp(-t) t^(a-1) dt) / gamma(a).
-##
-## If a is scalar, then gammai (a, x) is returned for each element of x
-## and vice versa.
-##
-## If neither a nor x is scalar, the sizes of a and x must agree, and
-## gammainc is applied for corresponding elements of x and a.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} gammai (@var{a}, @var{x})
+## Computes the incomplete gamma function,
+## @iftex
+## @tex
+## $$
+##  \gamma (a, x) = {\displaystyle\int_0^x e^{-t} t^{a-1} dt \over \Gamma (a)}
+## $$
+## @end tex
+## @end iftex
+## @ifinfo
+## 
+## @smallexample
+##                               x
+##                     1        /
+## gammai (a, x) = ---------    | exp (-t) t^(a-1) dt
+##                 gamma (a)    /
+##                           t=0
+## @end smallexample
+## @end ifinfo
+## 
+## If @var{a} is scalar, then @code{gammai (@var{a}, @var{x})} is returned
+## for each element of @var{x} and vice versa.
+## 
+## If neither @var{a} nor @var{x} is scalar, the sizes of @var{a} and
+## @var{x} must agree, and @var{gammai} is applied element-by-element.
+## @end deftypefn
+
+## See also: gamma, lgamma
 
 ## Author: jwe
 ## Created: 30 Jan 1998
 
 function retval = gammai (a, x)
 
   if (nargin == 2)
     retval = gammainc (x, a);
diff --git a/scripts/specfun/log2.m b/scripts/specfun/log2.m
--- a/scripts/specfun/log2.m
+++ b/scripts/specfun/log2.m
@@ -9,22 +9,32 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  y = log2 (x) or [f, e] = log2 (x)
-##
-## y = log2 (x) returns the logarithm of base 2 of x.
-##
-## [f, e] = log2 (x) returns f and e with 1/2 <= abs(f) < 1 and
-## x = f * 2^e.
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {@var{y} =} log2 (@var{x})
+## @deftypefnx {Mapping Function} {[@var{f}, @var{e}]} log2 (@var{x})
+## Compute the base-2 logarithm of @var{x}.  With two outputs, returns
+## @var{f} and @var{e} such that
+## @iftex
+## @tex
+##  $1/2 <= |f| < 1$ and $x = f \cdot 2^e$.
+## @end tex
+## @end iftex
+## @ifinfo
+##  1/2 <= abs(f) < 1 and x = f * 2^e.
+## @end ifinfo
+## @end deftypefn
+
+## See also: log, log10, logspace, exp
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
 
 function [f, e] = log2 (x)
 
   if (nargin != 1)
diff --git a/scripts/specfun/pow2.m b/scripts/specfun/pow2.m
--- a/scripts/specfun/pow2.m
+++ b/scripts/specfun/pow2.m
@@ -9,20 +9,40 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage: y = pow2 (f [, e])
-##
-## y = pow2 (x) returns 2 .^ x.
-## y = pow2 (f, e) returns f .* (2 .^ e).
+## -*- texinfo -*-
+## @deftypefn {Mapping Function} {} pow2 (@var{x})
+## @deftypefnx {Mapping Function} {} pow2 (@var{f}, @var{e})
+## With one argument, computes
+## @iftex
+## @tex
+##  $2^x$
+## @end tex
+## @end iftex
+## @ifinfo
+##  2 .^ x
+## @end ifinfo
+## for each element of @var{x}.  With two arguments, returns
+## @iftex
+## @tex
+##  $f \cdot 2^e$.
+## @end tex
+## @end iftex
+## @ifinfo
+##  f .* (2 .^ e).
+## @end ifinfo
+## @end deftypefn
+
+## See also: nextpow2
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
 
 function y = pow2 (f, e)
   
   if (nargin == 1)
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,53 @@
+1999-10-26  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* mkgendoc (print_doc_string): Handle quoted names.
+
+	* file-io.cc (symbols_of_file_io): Use DEFCONSTX for SEEK_SET,
+	SEEK_CUR, and SEEK_END.
+
+	* defun.h (DEFCONST): Just pass name, defn, and doc to
+	DEFCONST_INTERNAL.
+	(DEFCONSTX): Likewise, pass name, defn, and doc to DEFCONSTX_INTERNAL.
+	* defun-int.h [MKBUILTINS] (DEFCONST_INTERNAL): Likewise, pass
+	name, defn, and doc to XDEFCONST_INTERNAL.
+	[MKBUILTINS] (DEFCONSTX_INTERNAL): New macro.
+	(INSTALL_CONST): New macro.
+	[! MKBUILTINS] (DEFCONST_INTERNAL): Use it to handle details here.
+	[! MKBUILTINS] (DEFCONSTX_INTERNAL): Ditto.
+	* mkgendoc: Fix definition of XDEFCONST_INTERNAL to match.
+	* mkbuiltins: Ditto.
+
+	* mkdefs: Match spaces before BEGIN_INSTALL_BUILTIN.
+
+	* Makefile.in (DEFUN_PATTERN): Also match DEFUN_MAPPER.
+
+1999-10-26  Ben Sapp <bsapp@nua.lampf.lanl.gov>
+
+	* data.cc (VI, VInf, VJ, VNaN, Ve, Veps, Vfalse, Vi, Vinf, Vj,
+	Vnan, Vpi, Vrealmax, Vrealmin): Texinfoize doc strings.
+	* mappers.cc (Fabs, Facos, Facosh, Fangle, Farg, Fasin, Fasinh,
+	Fatan, Fatanh, Fceil, Fconj, Fcos, Fcosh, Ferf, Ferfc, Fexp,
+	Ffinite, Ffix, Ffloor, Fgamma, Fimag, Flgamma, Flog, Flog10,
+	Freal, Fround, Fsign, Fsin, Fsinh, Fsqrt, Ftan, Ftanh): Ditto.
+
+1999-10-23  Ben Sapp <bsapp@nua.lampf.lanl.gov>
+
+	* data.cc (Fis_matrix): Texinfoize doc string.  * ov.cc
+	(Vpropagate_empty_matrices): Ditto.  * pr-output.cc
+	(Vfixed_point_format, Voutput_max_field_width, Voutput_precision,
+	Vprint_empty_dimensions, Vsplit_long_rows): Ditto.  * pt-mat.cc:cd
+	(Vempty_list_elements_ok): Ditto.
+
+1999-10-22  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* ov-usr-fcn.cc (octave_user_function::do_index_op): If call_depth
+	is exceeded, call unwind_protect::run_frame before returning.
+
 1999-10-21  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* cutils.c (do_octave_usleep): Handle useconds > 1e6.
 
 	* variables.h (is_valid_function): Provide default values for the
 	string argument.
 
 	* symtab.cc (variable_reference): Maybe print warning (or error)
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -380,13 +380,29 @@ to the shortest match.")
 	}
     }
 
   print_usage ("dassl_options");
 
   return retval;
 }
 
+#define DLD_INSTALLER_FCN() \
+  bool \
+  FSoctave_install_dld_functions (void)
+
+#define INSTALL_DLD_FCN(name) \
+  if (! FS ## name ()) \
+    return false
+
+DLD_INSTALLER_FCN ()
+{
+  INSTALL_DLD_FCN (dassl);
+  INSTALL_DLD_FCN (dassl_options);
+
+  return true;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/fsolve.cc b/src/DLD-FUNCTIONS/fsolve.cc
--- a/src/DLD-FUNCTIONS/fsolve.cc
+++ b/src/DLD-FUNCTIONS/fsolve.cc
@@ -339,13 +339,29 @@ to the shortest match.")
 	}
     }
 
   print_usage ("fsolve_options");
 
   return retval;
 }
 
+#define DLD_INSTALLER_FCN() \
+  bool \
+  FSoctave_install_dld_functions (void)
+
+#define INSTALL_DLD_FCN(name) \
+  if (! FS ## name ()) \
+    return false
+
+DLD_INSTALLER_FCN ()
+{
+  INSTALL_DLD_FCN (fsolve);
+  INSTALL_DLD_FCN (fsolve_options);
+
+  return true;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -475,13 +475,29 @@ to the shortest match.")
 	}
     }
 
   print_usage ("lsode_options");
 
   return retval;
 }
 
+#define DLD_INSTALLER_FCN() \
+  bool \
+  FSoctave_install_dld_functions (void)
+
+#define INSTALL_DLD_FCN(name) \
+  if (! FS ## name ()) \
+    return false
+
+DLD_INSTALLER_FCN ()
+{
+  INSTALL_DLD_FCN (lsode);
+  INSTALL_DLD_FCN (lsode_options);
+
+  return true;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -412,13 +412,29 @@ to the shortest match.")
 	}
     }
 
   print_usage ("quad_options");
 
   return retval;
 }
 
+#define DLD_INSTALLER_FCN() \
+  bool \
+  FSoctave_install_dld_functions (void)
+
+#define INSTALL_DLD_FCN(name) \
+  if (! FS ## name ()) \
+    return false
+
+DLD_INSTALLER_FCN ()
+{
+  INSTALL_DLD_FCN (quad);
+  INSTALL_DLD_FCN (quad_options);
+
+  return true;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -158,17 +158,17 @@ DEP_3 := $(patsubst %.l, %.cc, $(DEP_4))
 DEP_2 := $(patsubst %.y, %.cc, $(DEP_3))
 DEP_1 := $(patsubst %.c, %.d, $(DEP_2))
 MAKEDEPS := $(patsubst %.cc, %.d, $(DEP_1))
 
 # Some stupid egreps don't like empty elements in alternation patterns,
 # so we have to repeat ourselves because some stupid egreps don't like
 # empty elements in alternation patterns.
 
-DEFUN_PATTERN = "^[ \t]*DEFU(N|N_DLD|N_TEXT)[ \t]*\\("
+DEFUN_PATTERN = "^[ \t]*DEFU(N|N_DLD|N_TEXT|N_MAPPER)[ \t]*\\("
 
 DEF_5 := $(SOURCES) $(DLD_SRC)
 DEF_4 := $(addprefix $(srcdir)/, $(DEF_5))
 DEF_3 := $(notdir $(shell egrep -l $(DEFUN_PATTERN) $(DEF_4)))
 DEF_2 := $(patsubst %.y, %.df, $(DEF_3))
 DEF_1 := $(patsubst %.l, %.df, $(DEF_2))
 DEF_FILES := $(patsubst %.cc, %.df, $(DEF_1))
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -792,17 +792,21 @@ DEFUN (is_list, args, ,
     retval = args(0).is_list ();
   else
     print_usage ("is_list");
 
   return retval;
 }
 
 DEFUN (is_matrix, args, ,
-  "is_matrix (x): return nonzero if x can be considered a matrix")
+  "-*- texinfo -*-\n\
+@deftypefn {Usage} {} is_matrix (@var{a})\n\
+Return 1 if @var{a} is a matrix.  Otherwise, return 0.\n\
+@end deftypefn\n\
+")
 {
   double retval = 0.0;
 
   if (args.length () == 1)
     {
       octave_value arg = args(0);
 
       if (arg.is_scalar_type () || arg.is_range ())
@@ -1181,69 +1185,182 @@ treat_neg_dim_as_zero (void)
   Vtreat_neg_dim_as_zero = check_preference ("treat_neg_dim_as_zero");
 
   return 0;
 }
 
 void
 symbols_of_data (void)
 {
+
+#define IMAGINARY_DOC_STRING "-*- texinfo -*-\n\
+@defvr {Built-in Variable} I\n\
+@defvrx {Built-in Variable} J\n\
+@defvrx {Built-in Variable} i\n\
+@defvrx {Built-in Variable} j\n\
+A pure imaginary number, defined as\n\
+@iftex\n\
+@tex\n\
+  $\\sqrt{-1}$.\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+  @code{sqrt (-1)}.\n\
+@end ifinfo\n\
+The @code{I} and @code{J} forms are true constants, and cannot be\n\
+modified.  The @code{i} and @code{j} forms are like ordinary variables,\n\
+and may be used for other purposes.  However, unlike other variables,\n\
+they once again assume their special predefined values if they are\n\
+cleared @xref{Status of Variables}.\n\
+@end defvr"
+
+#define INFINITY_DOC_STRING "-*- texinfo -*-\n\
+@defvr {Built-in Variable} Inf\n\
+@defvrx {Built-in Variable} inf\n\
+Infinity.  This is the result of an operation like 1/0, or an operation\n\
+that results in a floating point overflow.\n\
+@end defvr"
+
+#define NAN_DOC_STRING "-*- texinfo -*-\n\
+@defvr {Built-in Variable} NaN\n\
+@defvrx {Built-in Variable} nan\n\
+Not a number.  This is the result of an operation like\n\
+@iftex\n\
+@tex\n\
+$0/0$, or $\\infty - \\infty$,\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+0/0, or @samp{Inf - Inf},\n\
+@end ifinfo\n\
+or any operation with a NaN.\n\
+\n\
+Note that NaN always compares not equal to NaN.  This behavior is\n\
+specified by the IEEE standard for floating point arithmetic.  To\n\
+find NaN values, you must use the @code{isnan} function.\n\
+@end defvr"
+
   DEFCONST (I, Complex (0.0, 1.0),
-    "sqrt (-1)");
+    IMAGINARY_DOC_STRING);
 
   DEFCONST (Inf, octave_Inf,
-    "infinity");
+    INFINITY_DOC_STRING);
 
   DEFCONST (J, Complex (0.0, 1.0),
-    "sqrt (-1)");
+    IMAGINARY_DOC_STRING);
 
   DEFCONST (NaN, octave_NaN,
-    "not a number");
+    NAN_DOC_STRING);
 
 #if defined (M_E)
   double e_val = M_E;
 #else
   double e_val = exp (1.0);
 #endif
 
   DEFCONST (e, e_val,
-    "exp (1)");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} e\n\
+The base of natural logarithms.  The constant\n\
+@iftex\n\
+@tex\n\
+ $e$\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+ @var{e}\n\
+@end ifinfo\n\
+ satisfies the equation\n\
+@iftex\n\
+@tex\n\
+ $\\log (e) = 1$.\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+ @code{log} (@var{e}) = 1.\n\
+@end ifinfo\n\
+@end defvr");
 
   DEFCONST (eps, DBL_EPSILON,
-    "machine precision");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} eps\n\
+The machine precision.  More precisely, @code{eps} is the largest\n\
+relative spacing between any two adjacent numbers in the machine's\n\
+floating point system.  This number is obviously system-dependent.  On\n\
+machines that support 64 bit IEEE floating point arithmetic, @code{eps}\n\
+is approximately\n\
+@ifinfo\n\
+ 2.2204e-16.\n\
+@end ifinfo\n\
+@iftex\n\
+@tex\n\
+ $2.2204\\times10^{-16}$.\n\
+@end tex\n\
+@end iftex\n\
+@end defvr");
 
   DEFCONST (false, false,
     "logical false value");
 
   DEFCONST (i, Complex (0.0, 1.0),
-    "sqrt (-1)");
+    IMAGINARY_DOC_STRING);
 
   DEFCONST (inf, octave_Inf,
-    "infinity");
+    INFINITY_DOC_STRING);
 
   DEFCONST (j, Complex (0.0, 1.0),
-    "sqrt (-1)");
+    IMAGINARY_DOC_STRING);
 
   DEFCONST (nan, octave_NaN,
-    "not a number");
+    NAN_DOC_STRING);
 
 #if defined (M_PI)
   double pi_val = M_PI;
 #else
   double pi_val = 4.0 * atan (1.0);
 #endif
 
   DEFCONST (pi, pi_val,
-    "ratio of the circumference of a circle to its diameter");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} pi\n\
+The ratio of the circumference of a circle to its diameter.\n\
+Internally, @code{pi} is computed as @samp{4.0 * atan (1.0)}.\n\
+@end defvr");
 
   DEFCONST (realmax, DBL_MAX,
-    "realmax (): return largest representable floating point number");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} realmax\n\
+The largest floating point number that is representable.  The actual\n\
+value is system-dependent.  On machines that support 64 bit IEEE\n\
+floating point arithmetic, @code{realmax} is approximately\n\
+@ifinfo\n\
+ 1.7977e+308\n\
+@end ifinfo\n\
+@iftex\n\
+@tex\n\
+ $1.7977\\times10^{308}$.\n\
+@end tex\n\
+@end iftex\n\
+@end defvr");
 
   DEFCONST (realmin, DBL_MIN,
-    "realmin (): return smallest representable floating point number");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} realmin\n\
+The smallest floating point number that is representable.  The actual\n\
+value is system-dependent.  On machines that support 64 bit IEEE\n\
+floating point arithmetic, @code{realmin} is approximately\n\
+@ifinfo\n\
+ 2.2251e-308\n\
+@end ifinfo\n\
+@iftex\n\
+@tex\n\
+ $2.2251\\times10^{-308}$.\n\
+@end tex\n\
+@end iftex\n\
+@end defvr");
 
   DEFVAR (treat_neg_dim_as_zero, 0.0, treat_neg_dim_as_zero,
     "convert negative dimensions to zero");
 
   DEFCONST (true, true,
     "logical true value");
 }
 
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -99,19 +99,24 @@ alias_builtin (const string& alias, cons
     XDEFALIAS_INTERNAL(alias, name) \
   END_INSTALL_BUILTIN
 
 #define DEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc) \
   BEGIN_INSTALL_BUILTIN \
     XDEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc) \
   END_INSTALL_BUILTIN
 
-#define DEFCONST_INTERNAL(name, sname, defn, protect, doc) \
+#define DEFCONST_INTERNAL(name, defn, doc) \
   BEGIN_INSTALL_BUILTIN \
-    XDEFCONST_INTERNAL(name, sname, defn, protect, doc) \
+    XDEFCONST_INTERNAL(name, defn, doc) \
+  END_INSTALL_BUILTIN
+
+#define DEFCONSTX_INTERNAL(name, sname, defn, doc) \
+  BEGIN_INSTALL_BUILTIN \
+    XDEFCONST_INTERNAL(name, defn, doc) \
   END_INSTALL_BUILTIN
 
 #define DEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
 			      d_c_map, c_c_map, lo, hi, \
 			      can_ret_cmplx_for_real, doc) \
   BEGIN_INSTALL_BUILTIN \
     XDEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
 		           d_c_map, c_c_map, lo, hi, \
@@ -133,19 +138,27 @@ alias_builtin (const string& alias, cons
 // How builtin variables are actually installed.
 
 #define DEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc) \
   install_builtin_variable (name, octave_value (defn), protect, \
 			    (chg_fcn != 0), chg_fcn, doc)
 
 // How builtin variables are actually installed.
 
-#define DEFCONST_INTERNAL(name, sname, defn, protect, doc) \
+#define INSTALL_CONST(name, sname, defn, protect, doc) \
   install_builtin_constant (name, octave_value (defn), protect, doc)
 
+#define DEFCONST_INTERNAL(name, defn, doc) \
+  INSTALL_CONST (#name, SBV_ ## name, defn, false, doc); \
+  INSTALL_CONST ("__" ## #name ## "__", XSBV_ ## name, defn, true, doc)
+
+#define DEFCONSTX_INTERNAL(name, sname, defn, doc) \
+  INSTALL_CONST (name, sname, defn, false, doc); \
+  INSTALL_CONST ("__" ## name ## "__", X ## sname, defn, true, doc)
+
 // How mapper functions are actually installed.
 
 #define DEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
 			      d_c_map, c_c_map, lo, hi, \
 			      can_ret_cmplx_for_real, doc) \
   install_builtin_mapper \
     (new octave_mapper (ch_map, d_b_map, c_b_map, d_d_map, d_c_map, \
 			c_c_map, lo, hi, \
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -51,26 +51,24 @@ Software Foundation, 59 Temple Place - S
 #define DEFVAR(name, defn, chg_fcn, doc) \
   DEFVAR_INTERNAL (#name, SBV_ ## name, defn, false, chg_fcn, doc)
 
 // Define a builtin constant `name' (which may be redefined, but will
 // retain its original value when cleared) and also an alias to it
 // called `__name__' (which may not be redefined).
 
 #define DEFCONST(name, defn, doc) \
-  DEFCONST_INTERNAL (#name, SBV_ ## name, defn, false, doc); \
-  DEFCONST_INTERNAL ("__" ## #name ## "__", XSBV_ ## name, defn, true, doc)
+  DEFCONST_INTERNAL (name, defn, doc)
 
 // This one can be used when `name' cannot be used directly (if it is
 // already defined as a macro).  In that case, name is already a
 // quoted string, and the name of the structure has to be passed too.
 
 #define DEFCONSTX(name, sname, defn, doc) \
-  DEFCONST_INTERNAL (name, sname, defn, false, doc); \
-  DEFCONST_INTERNAL ("__" ## name ## "__", X ## sname, defn, true, doc)
+  DEFCONSTX_INTERNAL (name, sname, defn, doc)
 
 // Define a builtin function.
 //
 //   name is the name of the function, unqouted.
 //
 //   args_name is the name of the octave_value_list variable used to pass
 //     the argument list to this function.
 //
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -94,34 +94,49 @@ octave_dlopen_dynamic_loader::resolve_re
   octave_dynamic_loader::builtin_fcn_installer retval = 0;
 
   // Dynamic linking with dlopen/dlsym doesn't require specification
   // of the libraries at runtime.  Instead, they are specified when
   // the .oct file is created.
 
   void *handle = dlopen (file.c_str (), RTLD_LAZY);
 
-  const char *nm = name.c_str ();
+  string mangled_name = mangle_name (name);
+
+  const char *nm = mangled_name.c_str ();
 
   if (handle)
     {
-      void *tmp = dlsym (handle, nm);
+      // Try the installer function first.
+
+      string tmp_name = mangle_name ("octave_install_dld_functions");
 
-      retval = X_CAST (octave_dynamic_loader::builtin_fcn_installer, tmp);
+      const char *tmp_nm = tmp_name.c_str ();
 
+      void *tmp = dlsym (handle, tmp_nm);
+
+      retval = X_CAST (octave_dynamic_loader::builtin_fcn_installer,
+		       tmp);
       if (! retval)
 	{
-	  const char *errmsg = dlerror ();
+	  tmp = dlsym (handle, nm);
+
+	  retval = X_CAST (octave_dynamic_loader::builtin_fcn_installer, tmp);
+
+	  if (! retval)
+	    {
+	      const char *errmsg = dlerror ();
 
-	  if (errmsg)
-	    error("%s: `%s'", nm, errmsg);
-	  else
-	    error("unable to link function `%s'", nm);
+	      if (errmsg)
+		error("%s: `%s'", nm, errmsg);
+	      else
+		error("unable to link function `%s'", nm);
 
-	  dlclose (handle);
+	      dlclose (handle);
+	    }
 	}
     }
   else
     error ("%s: %s `%s'", dlerror (), file.c_str (), nm);
 
   return retval;
 }
 
@@ -157,35 +172,48 @@ octave_shl_load_dynamic_loader::resolve_
   octave_dynamic_loader::builtin_fcn_installer retval = 0;
 
   // Dynamic linking with shl_load/shl_findsym doesn't require
   // specification of the libraries at runtime.  Instead, they are
   // specified when the .oct file is created.
 
   shl_t handle = shl_load (file.c_str (), BIND_DEFERRED, 0L);
 
-  const char *nm = name.c_str ();
+  string mangled_name = mangle_name (name);
+
+  const char *nm = mangled_name.c_str ();
 
   if (handle)
     {
+      // Try the installer function first.
+
+      string tmp_name = mangle_name ("octave_install_dld_functions");
+
+      const char *tmp_nm = tmp_name.c_str ();
+
       // Don't use TYPE_PROCEDURE here.  The man page says that future
       // versions of HP-UX may not support it.
 
-      int status = shl_findsym (&handle, nm, TYPE_UNDEFINED, &retval);
+      int status = shl_findsym (&handle, tmp_nm, TYPE_UNDEFINED, &retval);
 
       if (status < 0)
 	{
-	  const char *errmsg = strerror (errno);
+	  status = shl_findsym (&handle, nm, TYPE_UNDEFINED, &retval);
+
+	  if (status < 0)
+	    {
+	      const char *errmsg = strerror (errno);
 
-	  if (errmsg)
-	    error("%s: `%s'", nm, errmsg);
-	  else
-	    error("unable to link function `%s'", nm);
+	      if (errmsg)
+		error("%s: `%s'", nm, errmsg);
+	      else
+		error("unable to link function `%s'", nm);
 
-	  retval = 0;
+	      retval = 0;
+	    }
 	}
     }
   else
     error ("%s: %s `%s'", strerror (errno), file.c_str (), nm);
 
   return retval;
 }
 
@@ -230,20 +258,18 @@ octave_dynamic_loader::load_fcn_from_dot
     make_dynamic_loader ();
 
   bool retval = false;
 
   string oct_file = oct_file_in_path (fcn_name);
 
   if (! oct_file.empty ())
     {
-      string mangled_name = instance->mangle_name (fcn_name);
-
       builtin_fcn_installer f
-	= instance->resolve_reference (mangled_name, oct_file);
+	= instance->resolve_reference (fcn_name, oct_file);
 
       if (f)
 	retval = f ();
     }
 
   return retval;
 }
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1403,23 +1403,23 @@ Set the permission mask for file creatio
 }
 
 void
 symbols_of_file_io (void)
 {
   // NOTE: the values of SEEK_SET, SEEK_CUR, and SEEK_END have to be
   // this way for Matlab compatibility.
 
-  DEFCONST (SEEK_SET, -1.0,
+  DEFCONSTX ("SEEK_SET", SBV_SEEK_SET, -1.0,
     "used with fseek to position file relative to the beginning");
 
-  DEFCONST (SEEK_CUR, 0.0,
+  DEFCONSTX ("SEEK_CUR", SBV_SEEK_CUR, 0.0,
     "used with fseek to position file relative to the current position");
 
-  DEFCONST (SEEK_END, 1.0,
+  DEFCONSTX ("SEEK_END", SBV_SEEK_END, 1.0,
     "used with fseek to position file relative to the end");
 
   DEFCONSTX ("stdin", SBV_stdin, stdin_file,
     "file number of the standard input stream");
 
   DEFCONSTX ("stdout", SBV_stdout, stdout_file,
     "file number of the standard output stream");
 
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -127,77 +127,235 @@ xtoupper (int c)
 {
   return toupper (c);
 }
 
 void
 install_mapper_functions (void)
 {
   DEFUN_MAPPER (abs, 0, 0, 0, fabs, abs, 0, 0.0, 0.0, 0,
-    "abs (X): compute abs (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} abs (@var{z})\n\
+Compute the magnitude of @var{z}, defined as\n\
+@iftex\n\
+@tex\n\
+$|z| = \\sqrt{x^2 + y^2}$.\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+|@var{z}| = @code{sqrt (x^2 + y^2)}.\n\
+@end ifinfo\n\
+\n\
+For example,\n\
+\n\
+@example\n\
+@group\n\
+abs (3 + 4i)\n\
+     @result{} 5\n\
+@end group\n\
+@end example\n\
+@end deftypefn");
 
   DEFUN_MAPPER (acos, 0, 0, 0, acos, 0, acos, -1.0, 1.0, 1,
-    "acos (X): compute acos (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} acos (@var{X})\n\
+acos (X): compute the inverse cosine of X for each element of X\n\
+@end deftypefn");
 
   DEFUN_MAPPER (acosh, 0, 0, 0, acosh, 0, acosh, 1.0, DBL_MAX, 1,
-    "acosh (X): compute acosh (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} acosh (@var{X})\n\
+acosh (X): compute the inverse hyperbolic cosine of X for each element of X.\n\
+@end deftypefn");
 
   DEFUN_MAPPER (angle, 0, 0, 0, arg, arg, 0, 0.0, 0.0, 0,
-    "angle (X): compute arg (X) for each element of X");
+    "See arg.")
 
   DEFUN_MAPPER (arg, 0, 0, 0, arg, arg, 0, 0.0, 0.0, 0,
-    "arg (X): compute arg (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} angle (@var{z})\n\
+Compute the argument of @var{z}, defined as\n\
+@iftex\n\
+@tex\n\
+$\\theta = \\tan^{-1}(y/x)$.\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+@var{theta} = @code{atan (@var{y}/@var{x})}.\n\
+@end ifinfo\n\
+\n\
+@noindent\n\
+in radians. \n\
+\n\
+For example,\n\
+\n\
+@example\n\
+@group\n\
+arg (3 + 4i)\n\
+     @result{} 0.92730\n\
+@end group\n\
+@end example\n\
+@end deftypefn");
 
   DEFUN_MAPPER (asin, 0, 0, 0, asin, 0, asin, -1.0, 1.0, 1,
-    "asin (X): compute asin (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} asin (@var{X})\n\
+asin (X): compute inverse sin (X) for each element of X\n\
+@end deftypefn");
 
   DEFUN_MAPPER (asinh, 0, 0, 0, asinh, 0, asinh, 0.0, 0.0, 0,
-    "asinh (X): compute asinh (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} asinh (@var{X})\n\
+asinh (X): compute the inverse hyperbolic sin (X) for each element of X\n\
+@end deftypefn");
 
   DEFUN_MAPPER (atan, 0, 0, 0, atan, 0, atan, 0.0, 0.0, 0,
-    "atan (X): compute atan (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} atan (@var{X})\n\
+atan (X): compute the inverse tangent of (X) for each element of X\n\
+@end deftypefn");
 
   DEFUN_MAPPER (atanh, 0, 0, 0, atanh, 0, atanh, -1.0, 1.0, 1,
-    "atanh (X): compute atanh (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} atanh (@var{X})\n\
+atanh (X): compute the inverse hyperbolic tanget of X for each element of X\n\
+@end deftypefn");
 
   DEFUN_MAPPER (ceil, 0, 0, 0, ceil, 0, ceil, 0.0, 0.0, 0,
-    "ceil (X): round elements of X toward +Inf");
+    "-*- texinfo -*-\n\
+@deftypefn {Usage} {} ceil (@var{x})\n\
+Return the smallest integer not less than @var{x}.  If @var{x} is\n\
+complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
+@end deftypefn");
 
   DEFUN_MAPPER (conj, 0, 0, 0, conj, 0, conj, 0.0, 0.0, 0,
-    "conj (X): compute complex conjugate for each element of X");
+    "-* texinfo -*-\n\
+@deftypefn {Mapping Function} {} conj (@var{z})\n\
+Return the complex conjugate of @var{z}, defined as\n\
+@iftex\n\
+@tex\n\
+$\\bar{z} = x - iy$.\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+@code{conj (@var{z})} = @var{x} - @var{i}@var{y}.\n\
+@end ifinfo\n\
+@end deftypefn\n\
+\n\
+See also: real, imag");
 
   DEFUN_MAPPER (cos, 0, 0, 0, cos, 0, cos, 0.0, 0.0, 0,
-    "cos (X): compute cos (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} cos (@var{X})\n\
+cos (X): compute the cosine of X for each element of X\n\
+@end deftypefn");
 
   DEFUN_MAPPER (cosh, 0, 0, 0, cosh, 0, cosh, 0.0, 0.0, 0,
-    "cosh (X): compute cosh (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} acosh (@var{X})\n\
+acosh (X): compute the inverse hyperbolic cosine of X for each element of X\n\
+@end deftypefn");
 
   DEFUN_MAPPER (erf, 0, 0, 0, xerf, 0, 0, 0.0, 0.0, 0,
-    "erf (X): compute erf (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} erf (@var{z})\n\
+Computes the error function,\n\
+@iftex\n\
+@tex\n\
+$$\n\
+ {\\rm erf} (z) = {2 \\over \\sqrt{\\pi}}\\int_0^z e^{-t^2} dt\n\
+$$\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+\n\
+@smallexample\n\
+                         z\n\
+                        /\n\
+erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
+                        /\n\
+                     t=0\n\
+@end smallexample\n\
+@end ifinfo\n\
+@end deftypefn\n\
+
+See also: erfc, erfinv");
 
   DEFUN_MAPPER (erfc, 0, 0, 0, xerfc, 0, 0, 0.0, 0.0, 0,
-    "erfc (X): compute erfc (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} erfc (@var{z})\n\
+Computes the complementary error function,\n\
+@iftex\n\
+@tex\n\
+$1 - {\\rm erf} (z)$.\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+@code{1 - erf (@var{z})}.\n\
+@end ifinfo\n\
+@end deftypefn\n\
+\n\
+See also: erf, erfinv");
 
   DEFUN_MAPPER (exp, 0, 0, 0, exp, 0, exp, 0.0, 0.0, 0,
-    "exp (X): compute exp (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Usage} {} exp (@var{x})\n\
+Compute the exponential of @var{x}.  To compute the matrix exponential,\n\
+see @ref{Linear Algebra}.\n\
+@end deftypefn");
 
   DEFUN_MAPPER (finite, 0, xfinite, xfinite, 0, 0, 0, 0.0, 0.0, 0,
     "finite (X): return 1 for finite elements of X");
 
   DEFUN_MAPPER (fix, 0, 0, 0, fix, 0, fix, 0.0, 0.0, 0,
-    "fix (X): round elements of X toward zero");
+    "-*- texinfo -*-\n\
+@deftypefn {Usage} {} fix (@var{x})\n\
+Truncate @var{x} toward zero.  If @var{x} is complex, return\n\
+@code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.\n\
+@end deftypefn");
 
   DEFUN_MAPPER (floor, 0, 0, 0, floor, 0, floor, 0.0, 0.0, 0,
-    "floor (X): round elements of X toward -Inf");
+    "-*- texinfo -*-\n\
+@deftypefn {Usage} {} floor (@var{x})\n\
+Return the largest integer not greater than @var{x}.  If @var{x} is\n\
+complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.\n\
+@end deftypefn");
 
   DEFUN_MAPPER (gamma, 0, 0, 0, xgamma, 0, 0, 0.0, 0.0, 0,
-    "gamma (X): compute gamma (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} gamma (@var{z})\n\
+Computes the Gamma function,\n\
+@iftex\n\
+@tex\n\
+$$\n\
+ \\Gamma (z) = \\int_0^\\infty t^{z-1} e^{-t} dt.\n\
+$$\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+\n\
+@example\n\
+            infinity\n\
+            /\n\
+gamma (z) = | t^(z-1) exp (-t) dt.\n\
+            /\n\
+         t=0\n\
+@end example\n\
+@end ifinfo\n\
+@end deftypefn\n\
+\n\
+See also: gammai, lgamma");
 
   DEFUN_MAPPER (imag, 0, 0, 0, imag, imag, 0, 0.0, 0.0, 0,
-    "imag (X): return imaginary part for each elements of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} imag (@var{z})\n\
+Return the imaginary part of @var{z} as a real number.\n\
+@end deftypefn\n\
+\n\
+See also: real, conj");
 
   DEFUN_MAPPER (isalnum, xisalnum, 0, 0, 0, 0, 0, 0.0, 0.0, 0,
     "isalnum (X): ");
 
   DEFUN_MAPPER (isalpha, xisalpha, 0, 0, 0, 0, 0, 0.0, 0.0, 0,
     "isalpha (X): ");
 
   DEFUN_MAPPER (isascii, xisascii, 0, 0, 0, 0, 0, 0.0, 0.0, 0,
@@ -232,59 +390,126 @@ install_mapper_functions (void)
 
   DEFUN_MAPPER (isupper, xisupper, 0, 0, 0, 0, 0, 0.0, 0.0, 0,
     "isupper (X): ");
 
   DEFUN_MAPPER (isxdigit, xisxdigit, 0, 0, 0, 0, 0, 0.0, 0.0, 0,
     "isxdigit (X): ");
 
   DEFUN_MAPPER (lgamma, 0, 0, 0, xlgamma, 0, 0, 0.0, 0.0, 0,
-    "lgamma (X): compute log gamma (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} lgamma (@var{a}, @var{x})\n\
+@deftypefnx {Mapping Function} {} gammaln (@var{a}, @var{x})\n\
+Return the natural logarithm of the gamma function.\n\
+@end deftypefn\n\
+\n\
+See also: gamma, gammai");
 
   DEFUN_MAPPER (log, 0, 0, 0, log, 0, log, 0.0, DBL_MAX, 1,
-    "log (X): compute log (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} log (@var{x})\n\
+Compute the natural logarithm for each element of @var{x}.  To compute the\n\
+matrix logarithm, see @ref{Linear Algebra}.\n\
+@end deftypefn\n\
+\n\
+See also: log2, log10, logspace, exp");
 
   DEFUN_MAPPER (log10, 0, 0, 0, log10, 0, log10, 0.0, DBL_MAX, 1,
-    "log10 (X): compute log10 (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} log10 (@var{x})\n\
+Compute the base-10 logarithm for each element of @var{x}.\n\
+@end deftypefn\n\
+\n\
+See also: log, log2, logspace, exp");
 
   DEFUN_MAPPER (real, 0, 0, 0, real, real, 0, 0.0, 0.0, 0,
-    "real (X): return real part for each element of X");
+    "-*-texinfo -*-\n\
+@deftypefn {Mapping Function} {} real (@var{z})\n\
+Return the real part of @var{z}.\n\
+@end deftypefn\n\
+\n\
+See also: imag, conj");
 
   DEFUN_MAPPER (round, 0, 0, 0, round, 0, round, 0.0, 0.0, 0,
-    "round (X): round elements of X to nearest integer");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} round (@var{x})\n\
+Return the integer nearest to @var{x}.  If @var{x} is complex, return\n\
+@code{round (real (@var{x})) + round (imag (@var{x})) * I}.\n\
+@end deftypefn\n\
+\n\
+See also: rem");
 
   DEFUN_MAPPER (sign, 0, 0, 0, signum, 0, signum, 0.0, 0.0, 0,
-    "sign (X): apply signum function to elements of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} sign (@var{x})\n\
+Compute the @dfn{signum} function, which is defined as\n\
+@iftex\n\
+@tex\n\
+$$\n\
+{\\rm sign} (@var{x}) = \\cases{1,&$x>0$;\\cr 0,&$x=0$;\\cr -1,&$x<0$.\\cr}\n\
+$$\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+\n\
+@example\n\
+           -1, x < 0;\n\
+sign (x) =  0, x = 0;\n\
+            1, x > 0.\n\
+@end example\n\
+@end ifinfo\n\
+\n\
+For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.\n\
+@end deftypefn");
 
   DEFUN_MAPPER (sin, 0, 0, 0, sin, 0, sin, 0.0, 0.0, 0,
-    "sin (X): compute sin (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} sin (@var{X})\n\
+sin (X): compute the sin of X for each element of X\n\
+@end deftypefn");
 
   DEFUN_MAPPER (sinh, 0, 0, 0, sinh, 0, sinh, 0.0, 0.0, 0,
-    "sinh (X): compute sinh (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} sinh (@var{X})\n\
+sinh (X): compute the inverse hyperbolic sin of X for each element of X\n\
+@end deftypefn");
 
   DEFUN_MAPPER (sqrt, 0, 0, 0, sqrt, 0, sqrt, 0.0, DBL_MAX, 1,
-    "sqrt (X): compute sqrt (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} sqrt (@var{x})\n\
+Compute the square root of @var{x}.  If @var{x} is negative, a complex\n\
+result is returned.  To compute the matrix square root, see\n\
+@ref{Linear Algebra}.\n\
+@end deftypefn");
 
   DEFUN_MAPPER (tan, 0, 0, 0, tan, 0, tan, 0.0, 0.0, 0,
-    "tan (X): compute tan (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} tan (@var{z})\n\
+tan (X): compute tanget of X for each element of X\n\
+@end deftypefn");
 
   DEFUN_MAPPER (tanh, 0, 0, 0, tanh, 0, tanh, 0.0, 0.0, 0,
-    "tanh (X): compute tanh (X) for each element of X");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} tanh (@var{X})\n\
+tanh (X): compute hyperbolic tangent of X for each element of X\n\
+@end deftypefn");
 
   DEFUN_MAPPER (toascii, xtoascii, 0, 0, 0, 0, 0, 0.0, 0.0, 1,
     "toascii (STRING): return ASCII representation of STRING in a matrix");
 
   DEFUN_MAPPER (tolower, xtolower, 0, 0, 0, 0, 0, 0.0, 0.0, 2,
     "tolower (STRING): convert upper case characters to lower case in STRING");
 
   DEFUN_MAPPER (toupper, xtoupper, 0, 0, 0, 0, 0, 0.0, 0.0, 2,
     "toupper (STRING): convert lower case characters to upper case in STRING");
 
   DEFALIAS (gammaln, lgamma);
 
   DEFALIAS (isfinite, finite);
+
+  // Leave the previous new line, mkgendoc needs it!
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/mkbuiltins b/src/mkbuiltins
--- a/src/mkbuiltins
+++ b/src/mkbuiltins
@@ -33,17 +33,17 @@ cat << \EOF
   extern DECLARE_FUN (name, args_name, nargout_name); \
     install_builtin_function (F ## name, #name, doc, is_text_fcn); \
 
 #define XDEFALIAS_INTERNAL(alias, name) \
   alias_builtin (#alias, #name);
 
 #define XDEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc)
 
-#define XDEFCONST_INTERNAL(name, sname, defn, protect, doc)
+#define XDEFCONST_INTERNAL(name, defn, doc)
 
 #define XDEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
 			       d_c_map, c_c_map, lo, hi, \
 			       can_ret_cmplx_for_real, doc)
 
 EOF
 
 for file in $DEF_FILES; do
diff --git a/src/mkdefs b/src/mkdefs
--- a/src/mkdefs
+++ b/src/mkdefs
@@ -1,11 +1,11 @@
 #!/bin/sh
 
-sed -n -e '/^BEGIN_INSTALL_BUILTIN/{
+sed -n -e '/^ *BEGIN_INSTALL_BUILTIN/{
   : loop
   N
   /END_INSTALL_BUILTIN/b done
   b loop
   : done
   s/BEGIN_INSTALL_BUILTIN//
   s/END_INSTALL_BUILTIN//
   p
diff --git a/src/mkgendoc b/src/mkgendoc
--- a/src/mkgendoc
+++ b/src/mkgendoc
@@ -21,29 +21,37 @@ cat << \EOF
 #define XDEFUN_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc) \
   print_doc_string (#name, doc);
 
 #define XDEFALIAS_INTERNAL(alias, name)
 
 #define XDEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc) \
   print_doc_string (#name, doc);
 
-#define XDEFCONST_INTERNAL(name, sname, defn, protect, doc) \
+#define XDEFCONST_INTERNAL(name, defn, doc) \
   print_doc_string (#name, doc);
 
 #define XDEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
 			       d_c_map, c_c_map, lo, hi, \
 			       can_ret_cmplx_for_real, doc) \
   print_doc_string (#name, doc);
 
 static void
 print_doc_string (const string& name, const string& doc)
 {
-  cout << "" << name << "\n";
-  cout << doc << "\n";
+  cout << "";
+
+  size_t len = name.length ();
+
+  if (name[0] == '"' && name[len-1] == '"')
+    cout << name.substr (1, len-2);
+  else
+    cout << name;
+
+  cout << "\n" << doc << "\n";
 }
 
 EOF
 
 for file in $DOC_FILES; do
   fcn=`echo $file | sed 's,^\./,,; s/\.df//; s/-/_/g'`
   echo "static void"
   echo "print_${fcn}_doc_strings (void)"
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -268,16 +268,17 @@ octave_user_function::do_index_op (int n
   unwind_protect::begin_frame ("func_eval");
 
   unwind_protect_int (call_depth);
   call_depth++;
 
   if (call_depth > Vmax_recursion_depth)
     {
       ::error ("max_recursion_limit exceeded");
+      unwind_protect::run_frame ("func_eval");
       return retval;
     }
 
   if (symtab_entry && ! symtab_entry->is_read_only ())
     {
       symtab_entry->protect ();
       unwind_protect::add (unprotect_function, symtab_entry);
     }
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1514,17 +1514,23 @@ symbols_of_ov (void)
 
   DEFVAR (prefer_column_vectors, 1.0, prefer_column_vectors,
     "prefer column/row vectors");
 
   DEFVAR (print_answer_id_name, 1.0, print_answer_id_name,
     "set output style to print `var_name = ...'");
 
   DEFVAR (propagate_empty_matrices, 1.0, propagate_empty_matrices,
-    "operations on empty matrices return an empty matrix, not an error");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} propagate_empty_matrices\n\
+If the value of @code{propagate_empty_matrices} is nonzero,\n\
+functions like @code{inverse} and @code{svd} will return an empty matrix\n\
+if they are given one as an argument.  The default value is 1.\n\
+@end defvr\n\
+");
 
   DEFVAR (resize_on_range_error, 1.0, resize_on_range_error,
     "enlarge matrices on assignment");
 
   DEFVAR (struct_levels_to_print, 2.0, struct_levels_to_print,
     "number of levels of structure elements to print");
 
   DEFVAR (warn_divide_by_zero, 1.0, warn_divide_by_zero,
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1885,28 +1885,116 @@ split_long_rows (void)
 
   return 0;
 }
 
 void
 symbols_of_pr_output (void)
 {
   DEFVAR (fixed_point_format, 0.0, fixed_point_format,
-    "use scaled fixed point format for `format short' and `format long'");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} fixed_point_format\n\
+If the value of this variable is nonzero, Octave will scale all values\n\
+in a matrix so that the largest may be written with one leading digit.\n\
+The scaling factor is printed on the first line of output.  For example,\n\
+\n\
+@example\n\
+@group\n\
+octave:1> logspace (1, 7, 5)'\n\
+ans =\n\
+\n\
+  1.0e+07  *\n\
+\n\
+  0.00000\n\
+  0.00003\n\
+  0.00100\n\
+  0.03162\n\
+  1.00000\n\
+@end group\n\
+@end example\n\
+\n\
+@noindent\n\
+Notice that first value appears to be zero when it is actually 1.  For\n\
+this reason, you should be careful when setting\n\
+@code{fixed_point_format} to a nonzero value.\n\
+\n\
+The default value of @code{fixed_point_format} is 0.\n\
+@end defvr\n\
+");
 
   DEFVAR (output_max_field_width, 10.0, output_max_field_width,
-    "maximum width of an output field for numeric output");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} output_max_field_width\n\
+This variable specifies the maximum width of a numeric output field.\n\
+The default value is 10.\n\
+@end defvr\n\
+");
 
   DEFVAR (output_precision, 5.0, output_precision,
-    "number of significant figures to display for numeric output");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} output_precision\n\
+This variable specifies the minimum number of significant figures to\n\
+display for numeric output.  The default value is 5.\n\
+@end defvr\n\
+");
 
   DEFVAR (print_empty_dimensions, 1.0, print_empty_dimensions,
-    "also print dimensions of empty matrices");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} print_empty_dimensions\n\
+If the value of @code{print_empty_dimensions} is nonzero, the\n\
+dimensions of empty matrices are printed along with the empty matrix\n\
+symbol, @samp{[]}.  For example, the expression\n\
+\n\
+@example\n\
+zeros (3, 0)\n\
+@end example\n\
+\n\
+@noindent\n\
+will print\n\
+\n\
+@example\n\
+ans = [](3x0)\n\
+@end example\n\
+@end defvr\n\
+");
 
   DEFVAR (split_long_rows, 1.0, split_long_rows,
-    "split long matrix rows instead of wrapping");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} split_long_rows\n\
+For large matrices, Octave may not be able to display all the columns of\n\
+a given row on one line of your screen.  This can result in missing\n\
+information or output that is nearly impossible to decipher, depending\n\
+on whether your terminal truncates or wraps long lines.\n\
+\n\
+If the value of @code{split_long_rows} is nonzero, Octave will display\n\
+the matrix in a series of smaller pieces, each of which can fit within\n\
+the limits of your terminal width.  Each set of rows is labeled so that\n\
+you can easily see which columns are currently being displayed.\n\
+For example:\n\
+\n\
+@smallexample\n\
+@group\n\
+octave:13> rand (2,10)\n\
+ans =\n\
+\n\
+ Columns 1 through 6:\n\
+\n\
+  0.75883  0.93290  0.40064  0.43818  0.94958  0.16467\n\
+  0.75697  0.51942  0.40031  0.61784  0.92309  0.40201\n\
+\n\
+ Columns 7 through 10:\n\
+\n\
+  0.90174  0.11854  0.72313  0.73326\n\
+  0.44672  0.94303  0.56564  0.82150\n\
+@end group\n\
+@end smallexample\n\
+\n\
+@noindent\n\
+The default value of @code{split_long_rows} is nonzero.\n\
+@end defvr\n\
+");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -605,18 +605,34 @@ string_fill_char (void)
 
   return status;
 }
 
 void
 symbols_of_pt_mat (void)
 {
   DEFVAR (empty_list_elements_ok, "warn", empty_list_elements_ok,
-    "ignore the empty element in expressions like `a = [[], 1]'");
-
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} empty_list_elements_ok\n\
+This variable controls whether Octave ignores empty matrices in a matrix\n\
+list.\n\
+\n\
+For example, if the value of @code{empty_list_elements_ok} is\n\
+nonzero, Octave will ignore the empty matrices in the expression\n\
+\n\
+@example\n\
+a = [1, [], 3, [], 5]\n\
+@end example\n\
+\n\
+@noindent\n\
+and the variable @code{a} will be assigned the value @code{[ 1, 3, 5 ]}.\n\
+\n\
+The default value is @code{\"warn\"}.\n\
+@end defvr\n\
+");
   DEFVAR (implicit_num_to_str_ok, 0.0, implicit_num_to_str_ok,
     "make the result of things like `[97, 98, 99, \"123\"]' be a string");
 
   DEFVAR (string_fill_char, " ", string_fill_char,
     "the character to fill with when creating string arrays.");
 }
 
 /*
