# HG changeset patch
# User jwe
# Date 1036615130 0
#      Wed Nov 06 20:38:50 2002 +0000
# Node ID 6b96ce9f57431d0eba63010effb03aa5841ec6a6
# Parent  f14251d33b01853c0143efa6ce15349b090da8fb
[project @ 2002-11-06 20:38:49 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2002-11-06  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in (AH_BOTTOM): Define USE_EXCEPTIONS_FOR_INTERRUPTS.
+
 2002-11-04  Joseph P. Skudlarek  <jskud@jskud.com>
 
 	* emacs/otags: handle declarations without arguments and/or return
 	values.
 
 2002-10-31  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* configure.in (SHLEXT_VER, SHLLIB_VER, SHLBIN_VER): Use
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -17,17 +17,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, write to the Free
 ### Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ### 02111-1307, USA. 
 
 AC_INIT
-AC_REVISION($Revision: 1.384 $)
+AC_REVISION($Revision: 1.385 $)
 AC_PREREQ(2.52)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -1303,16 +1303,18 @@ typedef int sigset_t;
 #undef OCTAVE_HAVE_POSIX_FILESYSTEM
 #endif
 #endif
 
 /* Define if we expect to have <windows.h>, Sleep, etc. */
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
 #define OCTAVE_USE_WINDOWS_API 1
 #endif
+
+#define USE_EXCEPTIONS_FOR_INTERRUPTS 1
 ])
 
 ### Do the substitutions in all the Makefiles.
 
 AC_CONFIG_FILES([Makefile octMakefile Makeconf install-octave \
   test/Makefile dlfcn/Makefile \
   doc/Makefile doc/faq/Makefile doc/interpreter/Makefile \
   doc/liboctave/Makefile doc/refcard/Makefile emacs/Makefile \
diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,25 @@
+2002-11-06  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* misc/f77-fcn.h (F77_XFCN): Adapt to new signal/exception
+	handling scheme.
+	(f77_context): Delete decl.
+	(copy_f77_context): Likewise.
+	* misc/f77-fcn.cn (copy_f77_context): Delete.
+	(Fxstopx): Set f77_exception_encountered.
+	Use octave_jump_to_enclosing_context, not longjmp.
+
+	* misc/f77-extern.cc (f77_context): Delete definition.
+
+	* misc/quit.h, misc/quit.cc: New files.
+	* misc/Makefile: Add them to the appropriate lists.
+
+	* Makefile (MISC_OBJ): Add misc/quit.o
+
 2002-10-31  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* odessa/odessa.f (ODESSA): Second arg of xerrwd is string length.
 	* odessa/odessa_intdy.f (ODESSA_INTDY): Likewise.
 
 2002-10-29  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* dasrt/ddasrt.f (DDASRT): Fix computation of LENRW.
diff --git a/libcruft/Makefile.in b/libcruft/Makefile.in
--- a/libcruft/Makefile.in
+++ b/libcruft/Makefile.in
@@ -55,17 +55,17 @@ all: libraries
 $(SUBDIRS):
 	$(MAKE) -C $@ all
 .PHONY: $(SUBDIRS)
 
 # XXX FIXME XXX -- this should build the shared library directly from
 # a normal archive file (created from PIC code, though).
 
 MISC_OBJ := misc/machar.o misc/f77-extern.o \
-	misc/f77-fcn.o misc/lo-error.o
+	misc/f77-fcn.o misc/lo-error.o misc/quit.o
 
 CRUFT_FSRC := $(foreach dir, $(SUBDIRS), $(wildcard $(srcdir)/$(dir)/*.f))
 CRUFT_OBJ2 := $(patsubst $(srcdir)/%, %, $(CRUFT_FSRC))
 CRUFT_OBJ1 := $(patsubst %.f, %.o, $(CRUFT_OBJ2))
 CRUFT_OBJ := $(CRUFT_OBJ1) $(MISC_OBJ)
 
 ifeq ($(SHARED_LIBS), true)
   ifdef FPICFLAG
diff --git a/libcruft/misc/Makefile.in b/libcruft/misc/Makefile.in
--- a/libcruft/misc/Makefile.in
+++ b/libcruft/misc/Makefile.in
@@ -8,36 +8,36 @@
 
 TOPDIR = ../..
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 
 SPECIAL := machar.c d1mach-tst.for f77-extern.cc \
-	f77-fcn.c f77-fcn.h lo-error.c lo-error.h
+	f77-fcn.c f77-fcn.h lo-error.c lo-error.h quit.h quit.cc
 
-SPECIAL_DEPEND := machar.o f77-extern.o f77-fcn.o lo-error.o
+SPECIAL_DEPEND := machar.o f77-extern.o f77-fcn.o lo-error.o quit.o
 
 EXTERNAL_DISTFILES = $(DISTFILES)
 
 include $(TOPDIR)/Makeconf
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 
-INCLUDES := f77-fcn.h lo-error.h
+INCLUDES := f77-fcn.h lo-error.h quit.h
 
 ifeq ($(SHARED_LIBS), true)
   ifdef CPICFLAG
     CPICDEP := pic/machar.o pic/f77-fcn.o
   endif
   ifdef CXXPICFLAG
-    CXXPICDEP := pic/f77-extern.o pic/lo-error.o
+    CXXPICDEP := pic/f77-extern.o pic/lo-error.o pic/quit.o
   endif
   SPECIAL_PICDEPEND := $(CPICDEP) $(CXXPICDEP)
 endif
 
 include ../Makerules
 
 install install-strip::
 	$(top_srcdir)/mkinstalldirs $(octincludedir)/octave
diff --git a/libcruft/misc/f77-extern.cc b/libcruft/misc/f77-extern.cc
--- a/libcruft/misc/f77-extern.cc
+++ b/libcruft/misc/f77-extern.cc
@@ -29,17 +29,14 @@ Software Foundation, 59 Temple Place - S
 #include "lo-error.h"
 
 // This whole file is a kluge just to avoid unresolved symbol errors
 // when creating shared versions of libcruft.
 
 // So we can check to see if an exception has occurred.
 int f77_exception_encountered = 0;
 
-// For setjmp/longjmp.
-jmp_buf f77_context;
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/libcruft/misc/f77-fcn.c b/libcruft/misc/f77-fcn.c
--- a/libcruft/misc/f77-fcn.c
+++ b/libcruft/misc/f77-fcn.c
@@ -23,38 +23,35 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <stdlib.h>
 #include <string.h>
 
 #include "f77-fcn.h"
+#include "quit.h"
 #include "lo-error.h"
 
-void
-copy_f77_context (void *from, void *to, unsigned int size)
-{
-  memcpy (to, from, size);
-}
-
 /* All the STOP statements in the Fortran routines have been replaced
    with a call to XSTOPX.
 
    XSTOPX jumps back to the entry point for the Fortran function that
    called us.  Then the calling function should do whatever cleanup
    is necessary.  */
 
 void
 F77_FUNC (xstopx, XSTOPX) (const char *s, long int slen)
 {
+  f77_exception_encountered = 1;
+
   /* Skip printing message if it is just a single blank character.  */
   if (s && slen > 0 && ! (slen == 1 && *s == ' '))
     (*current_liboctave_error_handler) ("%.*s", slen, s);
 
-  longjmp (f77_context, 1);
+  octave_jump_to_enclosing_context ();
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/libcruft/misc/f77-fcn.h b/libcruft/misc/f77-fcn.h
--- a/libcruft/misc/f77-fcn.h
+++ b/libcruft/misc/f77-fcn.h
@@ -22,64 +22,66 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_f77_fcn_h)
 #define octave_f77_fcn_h 1
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#include <setjmp.h>
+#include "quit.h"
 
-/* hack to stringize macro results */
+#include <stdio.h>
+
+/* Hack to stringize macro results. */
 #define xSTRINGIZE(x) #x
 #define STRINGIZE(x) xSTRINGIZE(x)
 
 /* How to print an error for the F77_XFCN macro. */
 
 #define F77_XFCN_ERROR(f, F) \
   (*current_liboctave_error_handler) \
     ("exception encountered in Fortran subroutine %s", \
      STRINGIZE (F77_FUNC (f, F)))
 
 /* This can be used to call a Fortran subroutine that might call
-   XSTOPX.  XSTOPX will call lonjmp with f77_context and we'll return,
-   call the error function, restore the previous context.  After using
-   this macro, error_state should be checked. */
+   XSTOPX.  XSTOPX will call lonjmp with current_context.  Once back
+   here, we'll restore the previous context and return.  We may also
+   end up here if an interrupt is processed when the Fortran
+   subroutine is called.  In that case, we resotre the context and go
+   to the top level.  The error_state should be checked immediately
+   after this macro is used. */
 
 #define F77_XFCN(f, F, args) \
   do \
     { \
-      jmp_buf saved_f77_context; \
+      jmp_buf saved_context; \
       f77_exception_encountered = 0; \
-      copy_f77_context ((char *) f77_context, (char *) saved_f77_context, \
-			sizeof (jmp_buf)); \
-      if (setjmp (f77_context)) \
+      octave_save_current_context ((char *) saved_context); \
+      if (octave_set_current_context) \
 	{ \
-	  f77_exception_encountered = 1; \
-	  F77_XFCN_ERROR (f, F); \
+          octave_restore_current_context ((char *) saved_context); \
+	  if (f77_exception_encountered) \
+	    F77_XFCN_ERROR (f, F); \
+          else \
+            OCTAVE_THROW_TO_TOP_LEVEL; \
 	} \
       else \
-	F77_FUNC (f, F) args; \
-      copy_f77_context ((char *) saved_f77_context, (char *) f77_context, \
-			sizeof (jmp_buf)); \
+        { \
+	  octave_interrupt_immediately++; \
+	  F77_FUNC (f, F) args; \
+	  octave_interrupt_immediately--; \
+          octave_restore_current_context ((char *) saved_context); \
+        } \
     } \
   while (0)
 
 /* So we can check to see if an exception has occurred. */
 extern int f77_exception_encountered;
 
-/* For setjmp/longjmp. */
-extern jmp_buf f77_context;
-
-/* Defining this as a separate function allows us to avoid having to
-   include string.h in this file. */
-
-extern void copy_f77_context (void *, void *, unsigned int);
-
 extern void
 F77_FUNC (xstopx, XSTOPX) (const char *s, long int slen) GCC_ATTR_NORETURN;
 
 #if !defined (F77_FCN)
 #define F77_FCN(f, F) F77_FUNC (f, F)
 #endif
 
 #ifdef __cplusplus
diff --git a/libcruft/misc/quit.cc b/libcruft/misc/quit.cc
new file mode 100644
--- /dev/null
+++ b/libcruft/misc/quit.cc
@@ -0,0 +1,100 @@
+/*
+
+Copyright (C) 2002 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+// Include signal.h, not csignal since the latter might only define
+// the ANSI standard C signal interface.
+
+#include <signal.h>
+
+#include "quit.h"
+
+jmp_buf current_context;
+
+void
+octave_save_current_context (void *save_buf)
+{
+  memcpy (save_buf, current_context, sizeof (jmp_buf));
+}
+
+void
+octave_restore_current_context (void *save_buf)
+{
+  memcpy (current_context, save_buf, sizeof (jmp_buf));
+}
+
+void
+octave_jump_to_enclosing_context (void)
+{
+  longjmp (current_context, 1);
+}
+
+// Allow us to save the signal mask and then restore it to the most
+// recently saved value.  This is necessary when using the POSIX
+// signal handling interface on some systems calling longjmp out of
+// the signal handler to get to the top level on an interrupt doesn't
+// restore the original signal mask.  Alternatively, we could use
+// sigsetjmp/siglongjmp, but saving and restoring the signal mask
+// ourselves works ok and seems simpler just now.
+
+#if defined (HAVE_POSIX_SIGNALS)
+static sigset_t octave_signal_mask;
+#endif
+
+void
+octave_save_signal_mask (void)
+{
+#if defined (HAVE_POSIX_SIGNALS)
+  sigprocmask (0, 0, &octave_signal_mask);
+#endif
+}
+
+void
+octave_restore_signal_mask (void)
+{
+#if defined (HAVE_POSIX_SIGNALS)
+  sigprocmask (SIG_SETMASK, &octave_signal_mask, 0);
+#endif
+}
+
+#if defined (USE_EXCEPTIONS_FOR_INTERRUPTS)
+
+int octave_interrupt_immediately = 0;
+
+int octave_interrupt_state = 0;
+
+void
+octave_throw_interrupt_exception (void)
+{
+  throw octave_interrupt_exception ();
+}
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/libcruft/misc/quit.h b/libcruft/misc/quit.h
new file mode 100644
--- /dev/null
+++ b/libcruft/misc/quit.h
@@ -0,0 +1,135 @@
+/*
+
+Copyright (C) 2002 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_quit_h)
+#define octave_quit_h 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Include setjmp.h, not csetjmp since the latter might only define
+// the ANSI standard C interface.
+
+#include <setjmp.h>
+
+extern jmp_buf current_context;
+
+extern void octave_save_current_context (void *);
+
+#define octave_set_current_context setjmp (current_context)
+
+extern void octave_restore_current_context (void *);
+
+extern void octave_jump_to_enclosing_context (void) GCC_ATTR_NORETURN;
+
+extern void octave_save_signal_mask (void);
+
+extern void octave_restore_signal_mask (void);
+
+#if defined (USE_EXCEPTIONS_FOR_INTERRUPTS)
+
+#ifdef __cplusplus
+class
+octave_interrupt_exception
+{
+};
+#endif
+
+extern int octave_interrupt_immediately;
+
+extern int octave_interrupt_state;
+
+extern void octave_throw_interrupt_exception (void) GCC_ATTR_NORETURN;
+
+#define OCTAVE_QUIT \
+  do \
+    { \
+      if (octave_interrupt_state) \
+        { \
+          octave_interrupt_state = 0; \
+          octave_throw_interrupt_exception (); \
+        } \
+    } \
+  while (0)
+
+#define OCTAVE_JUMP_TO_TOP_LEVEL \
+  do { octave_interrupt_state = 1; } while (0)
+
+#define OCTAVE_THROW_TO_TOP_LEVEL octave_throw_interrupt_exception ()
+
+#define OCTAVE_TRY_WITH_INTERRUPTS try
+
+#define OCTAVE_CATCH_INTERRUPTS catch (octave_interrupt_exception)
+
+#define BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE \
+  do \
+    { \
+      jmp_buf saved_context; \
+ \
+      octave_save_current_context ((char *) saved_context); \
+ \
+      if (octave_set_current_context) \
+	{ \
+	  octave_restore_current_context ((char *) saved_context); \
+	  OCTAVE_THROW_TO_TOP_LEVEL; \
+	} \
+      else \
+	{ \
+	  octave_interrupt_immediately++
+
+#define END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE \
+          octave_interrupt_immediately--; \
+          octave_restore_current_context ((char *) saved_context); \
+        } \
+    } \
+  while (0)
+
+#else
+
+#define OCTAVE_QUIT do { } while (0)
+
+#define OCTAVE_JUMP_TO_TOP_LEVEL octave_jump_to_enclosing_context ()
+
+#define OCTAVE_THROW_TO_TOP_LEVEL OCTAVE_JUMP_TO_TOP_LEVEL
+
+#define OCTAVE_TRY_WITH_INTERRUPTS
+
+#define OCTAVE_CATCH_INTERRUPTS if (0)
+
+#define BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE do { } while (0)
+
+#define END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE do { } while (0)
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -981,16 +981,18 @@ ComplexMatrix::fourier (void) const
       nsamples = nc;
     }
 
   const Complex *in (data ());
   Complex *out (retval.fortran_vec ());
 
   for (size_t i = 0; i < nsamples; i++)
     {
+      OCTAVE_QUIT;
+
       octave_fftw::fft (&in[npts * i], &out[npts * i], npts);
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier (void) const
@@ -1013,16 +1015,18 @@ ComplexMatrix::ifourier (void) const
       nsamples = nc;
     }
 
   const Complex *in (data ());
   Complex *out (retval.fortran_vec ());
 
   for (size_t i = 0; i < nsamples; i++)
     {
+      OCTAVE_QUIT;
+
       octave_fftw::ifft (&in[npts * i], &out[npts * i], npts);
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::fourier2d (void) const
@@ -1081,17 +1085,21 @@ ComplexMatrix::fourier (void) const
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
+    {
+      OCTAVE_QUIT;
+
+      F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
+    }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier (void) const
 {
   ComplexMatrix retval;
@@ -1118,17 +1126,21 @@ ComplexMatrix::ifourier (void) const
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
+    {
+      OCTAVE_QUIT;
+
+      F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
+    }
 
   for (int j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   return retval;
 }
 
 ComplexMatrix
@@ -1158,32 +1170,38 @@ ComplexMatrix::fourier2d (void) const
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
+    {
+      OCTAVE_QUIT;
+
+      F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
+    }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (nn);
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> row (npts);
   Complex *prow = row.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
     {
+      OCTAVE_QUIT;
+
       for (int i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
       for (int i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i];
     }
@@ -1218,17 +1236,21 @@ ComplexMatrix::ifourier2d (void) const
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
+    {
+      OCTAVE_QUIT;
+
+      F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
+    }
 
   for (int j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
@@ -1237,16 +1259,18 @@ ComplexMatrix::ifourier2d (void) const
 
   Array<Complex> row (npts);
   Complex *prow = row.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
     {
+      OCTAVE_QUIT;
+
       for (int i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
       for (int i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
     }
@@ -1932,16 +1956,18 @@ ComplexMatrix::expm (void) const
   // Reverse preconditioning step 2: inverse balancing.
   // Done in two steps: inverse scaling, then inverse permutation
 
   // inverse scaling (diagonal transformation)
   for (int i = 0; i < nc; i++)
     for (int j = 0; j < nc; j++)
        retval(i,j) *= dscale(i) / dscale(j);
 
+  OCTAVE_QUIT;
+
   // construct balancing permutation vector
   Array<int> ipermute (nc);
   for (int i = 0; i < nc; i++)
     ipermute(i) = i;  // initialize to identity permutation
 
   // leading permutations in forward order
   for (int i = 0; i < (ilo-1); i++)
     {
@@ -1960,16 +1986,18 @@ ComplexMatrix::expm (void) const
       ipermute(swapidx) = tmp;
     }
 
   // construct inverse balancing permutation vector
   Array<int> invpvec (nc);
   for (int i = 0; i < nc; i++)
     invpvec(ipermute(i)) = i;     // Thanks to R. A. Lippert for this method
 
+  OCTAVE_QUIT;
+
   ComplexMatrix tmpMat = retval;
   for (int i = 0; i < nc; i++)
     for (int j = 0; j < nc; j++)
       retval(i,j) = tmpMat(invpvec(i),invpvec(j));
 
   // Reverse preconditioning step 1: fix trace normalization.
 
   return exp (trshift) * retval;
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,10 +1,12 @@
 2002-11-06  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* CMatrix.cc, dMatrix.cc: Sprinkle with OCTAVE_QUIT.
+
 	* ODESSA.cc (odessa_f, odessa_j, odessa_b): Abort on error.
 
 	* Array.h: Include <cstddef> here.
 
 2002-11-01  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* DASPK.cc (DASPK::do_integrate): Resize rwork and iwork before
 	using them.  Accept inequality contraint option of 0.  Assign
diff --git a/liboctave/ODESSA.cc b/liboctave/ODESSA.cc
--- a/liboctave/ODESSA.cc
+++ b/liboctave/ODESSA.cc
@@ -34,16 +34,17 @@ Software Foundation, 59 Temple Place - S
 // For instantiating the Array<Matrix> object.
 #include "Array.h"
 #include "Array.cc"
 
 #include "ODESSA.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-sstream.h"
+#include "quit.h"
 
 typedef int (*odessa_fcn_ptr) (int*, const double&, double*,
 			       double*, double*);
 
 typedef int (*odessa_jac_ptr) (int*, const double&, double*,
 			       double*, const int&, const int&,
 			       double*, const int&);
 
@@ -80,17 +81,17 @@ odessa_f (int* neq, const double& t, dou
 
   ColumnVector tmp_param (n_par);
   for (int i = 0; i < n_par; i++)
     tmp_param(i) = par[i];
 
   ColumnVector tmp_fval = user_fsub (tmp_state, t, tmp_param);
 
   if (tmp_fval.length () == 0)
-    longjmp (f77_context, 1);
+    octave_jump_to_enclosing_context ();
   else
     {
       for (int i = 0; i < n; i++)
 	fval[i] = tmp_fval(i);
     }
 
   return 0;
 }
@@ -110,17 +111,17 @@ odessa_j (int* neq, const double& t, dou
 
   ColumnVector tmp_param (n_par);
   for (int i = 0; i < n_par; i++)
     tmp_param(i) = par[i];
 
   Matrix tmp_fval = user_jsub (tmp_state, t, tmp_param);
 
   if (tmp_fval.length () == 0)
-    longjmp (f77_context, 1);
+    octave_jump_to_enclosing_context ();
   else
     {
       for (int j = 0; j < n; j++)
 	for (int i = 0; i < nrowpd; i++)
 	  pd[nrowpd*j+i] = tmp_fval(i,j);
     }
 
   return 0;
@@ -141,17 +142,17 @@ odessa_b (int* neq, const double& t, dou
 
   ColumnVector tmp_param (n_par);
   for (int i = 0; i < n_par; i++)
     tmp_param(i) = par[i];
 
   ColumnVector tmp_fval = user_bsub (tmp_state, t, tmp_param, jpar);
 
   if (tmp_fval.length () == 0)
-    longjmp (f77_context, 1);
+    octave_jump_to_enclosing_context ();
   else
     {
       for (int i = 0; i < n; i++)
 	dfdp[i] = tmp_fval(i);
     }
 
   return 0;
 }
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -44,16 +44,17 @@ Software Foundation, 59 Temple Place - S
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "mx-m-dm.h"
 #include "mx-dm-m.h"
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
+#include "quit.h"
 
 #ifdef HAVE_FFTW
 #include "oct-fftw.h"
 #endif
 
 // Fortran functions we call.
 
 extern "C"
@@ -676,16 +677,18 @@ Matrix::fourier (void) const
     }
 
   ComplexMatrix tmp (*this);
   Complex *in (tmp.fortran_vec ());
   Complex *out (retval.fortran_vec ());
 
   for (size_t i = 0; i < nsamples; i++)
     {
+      OCTAVE_QUIT;
+
       octave_fftw::fft (&in[npts * i], &out[npts * i], npts);
     }
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::ifourier (void) const
@@ -709,16 +712,18 @@ Matrix::ifourier (void) const
     }
 
   ComplexMatrix tmp (*this);
   Complex *in (tmp.fortran_vec ());
   Complex *out (retval.fortran_vec ());
 
   for (size_t i = 0; i < nsamples; i++)
     {
+      OCTAVE_QUIT;
+
       octave_fftw::ifft (&in[npts * i], &out[npts * i], npts);
     }
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::fourier2d (void) const
@@ -777,17 +782,21 @@ Matrix::fourier (void) const
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
+    {
+      OCTAVE_QUIT;
+
+      F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
+    }
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::ifourier (void) const
 {
   ComplexMatrix retval;
@@ -814,17 +823,21 @@ Matrix::ifourier (void) const
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
+    {
+      OCTAVE_QUIT;
+
+      F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
+    }
 
   for (int j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   return retval;
 }
 
 ComplexMatrix
@@ -854,32 +867,38 @@ Matrix::fourier2d (void) const
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
+    {
+      OCTAVE_QUIT;
+
+      F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
+    }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (nn);
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> row (npts);
   Complex *prow = row.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
     {
+      OCTAVE_QUIT;
+
       for (int i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
       for (int i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i];
     }
@@ -914,17 +933,21 @@ Matrix::ifourier2d (void) const
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
+    {
+      OCTAVE_QUIT;
+
+      F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
+    }
 
   for (int j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
@@ -933,16 +956,18 @@ Matrix::ifourier2d (void) const
 
   Array<Complex> row (npts);
   Complex *prow = row.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
     {
+      OCTAVE_QUIT;
+
       for (int i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
       for (int i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
     }
@@ -1605,16 +1630,18 @@ Matrix::expm (void) const
     }
   
   // Reverse preconditioning step 2: inverse balancing.
   // apply inverse scaling to computed exponential
   for (int i = 0; i < nc; i++)
     for (int j = 0; j < nc; j++)
        retval(i,j) *= dscale(i) / dscale(j);
 
+  OCTAVE_QUIT;
+
   // construct balancing permutation vector
   Array<int> ipermute (nc);
   for (int i = 0; i < nc; i++)
     ipermute(i) = i;  // identity permutation
 
   // leading permutations in forward order
   for (int i = 0; i < (ilo-1); i++)
     {
@@ -1632,16 +1659,18 @@ Matrix::expm (void) const
       ipermute(i) = ipermute(swapidx);
       ipermute(swapidx) = tmp;
     }
 
   // construct inverse balancing permutation vector
   Array<int> invpvec (nc);
   for (int i = 0; i < nc; i++)
     invpvec(ipermute(i)) = i;     // Thanks to R. A. Lippert for this method
+
+  OCTAVE_QUIT;
  
   Matrix tmpMat = retval;
   for (int i = 0; i < nc; i++)
     for (int j = 0; j < nc; j++)
       retval(i,j) = tmpMat(invpvec(i),invpvec(j));
 
   // Reverse preconditioning step 1: fix trace normalization.
   
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,40 @@
 2002-11-06  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* utils.cc (jump_to_top_level): Delete.
+
+	* toplev.cc (toplevel): Delete.
+	(main_loop): Adapt to new signal/exception handling scheme.
+
+	* sighandlers.cc (octave_signal_mask, octave_save_signal_mask,
+	octave_restore_signal_mask): Move to libcruft/misc/quit.cc.
+	(sigint_handler) [USE_EXCEPTIONS_FOR_INTERRUPTS]: set
+	octave_interrupt_state.  Only jump if octave_interrupt_immediately
+	is true, and then only to enclosing context.
+
+	* lex.h (YY_FATAL_ERROR): Use OCTAVE_JUMP_TO_TOP_LEVEL, not
+	jump_to_top_level.
+	* sighandlers.cc (octave_new_handler, sigfpe_handler, endif,
+	sigpipe_handler): Likewise.
+
+	* input.cc (gnu_readline): Surround call to
+	command_editor::readline with
+	BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE and 
+	END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE.
+
+	* data.cc, oct-stream.cc, ov-cell.cc, ov-mapper.cc, ov-re-mat.cc,
+	ov.cc, pr-output.cc, pt-loop.cc, pt-stmt.cc, xdiv.cc, xpow.cc,
+	DLD-FUNCTIONS/balance.cc, DLD-FUNCTIONS/besselj.cc,
+	DLD-FUNCTIONS/filter.cc, DLD-FUNCTIONS/find.cc,
+	DLD-FUNCTIONS/kron.cc, DLD-FUNCTIONS/log.cc,
+	DLD-FUNCTIONS/minmax.cc, DLD-FUNCTIONS/qz.cc,
+	DLD-FUNCTIONS/rand.cc, DLD-FUNCTIONS/sort.cc: Sprinkle with
+	OCTAVE_QUIT.
+
 	* DLD-FUNCTIONS/odessa.cc (Fodessa): Correctly extract bsub from
 	function arg.
 
 2002-11-04  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* cutils.c (octave_vsnprintf): Handle C99 snprintf semantics.
 
 	* oct-obj.h (octave_value_list::operator =): Copy names too.
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -27,16 +27,17 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <string>
 
 #include "CmplxAEPBAL.h"
 #include "CmplxAEPBAL.h"
 #include "dbleAEPBAL.h"
 #include "dbleAEPBAL.h"
+#include "quit.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "f77-fcn.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
@@ -267,17 +268,21 @@ Generalized eigenvalue problem balancing
       
       // Since we just want the balancing matrices, we can use dggbal
       // for both the real and complex cases.
 
       Matrix Pl(nn,nn), Pr(nn,nn);
 
       for (int ii = 0; ii < nn; ii++)
 	for (int jj = 0; jj < nn; jj++)
-	  Pl(ii,jj) = Pr(ii,jj) = (ii == jj ? 1.0 : 0.0);
+	  {
+	    OCTAVE_QUIT;
+
+	    Pl(ii,jj) = Pr(ii,jj) = (ii == jj ? 1.0 : 0.0);
+	  }
   
       // left first
       F77_XFCN (dggbak, DGGBAK,
 		(&job, "L", nn, ilo, ihi, lscale.fortran_vec(),
 		 rscale.fortran_vec(), nn, Pl.fortran_vec(),
 		 nn, info, 1L, 1L));
       
       if (f77_exception_encountered)
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -20,16 +20,17 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-specfun.h"
+#include "quit.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 enum bessel_type
@@ -82,17 +83,21 @@ int_array2_to_matrix (const Array2<int>&
 {
   int nr = a.rows ();
   int nc = a.cols ();
 
   Matrix retval (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      retval(i,j) = (double) (a(i,j));
+      {
+	OCTAVE_QUIT;
+
+	retval(i,j) = (double) (a(i,j));
+      }
 
   return retval;
 }
 
 static void
 gripe_bessel_arg (const char *fn, const char *arg)
 {
   error ("%s: expecting scalar or matrix as %s argument", fn, arg);
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -27,16 +27,18 @@ Software Foundation, 59 Temple Place - S
 //
 // Rewritten to use templates to handle both real and complex cases by
 // jwe, Wed Nov  1 19:15:29 1995.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "quit.h"
+
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern MArray<double>
 filter (MArray<double>&, MArray<double>&, MArray<double>&);
 
@@ -88,18 +90,22 @@ filter (MArray<T>& b, MArray<T>& a, MArr
 
       for (int i = 0; i < x_len; i++)
 	{
 	  y (i) = si (0) + b (0) * x (i);
 
 	  if (si_len > 1)
 	    {
 	      for (int j = 0; j < si_len - 1; j++)
-		si (j) = si (j+1) - a (j+1) * y (i)
-		  + b (j+1) * x (i);
+		{
+		  OCTAVE_QUIT;
+
+		  si (j) = si (j+1) - a (j+1) * y (i)
+		    + b (j+1) * x (i);
+		}
 
 	      si (si_len-1) = b (si_len) * x (i)
 		- a (si_len) * y (i);
 	    }
 	  else
 	    si (0) = b (si_len) * x (i)
 	      - a (si_len) * y (i);
 	}
@@ -108,17 +114,21 @@ filter (MArray<T>& b, MArray<T>& a, MArr
     {
       for (int i = 0; i < x_len; i++)
 	{
 	  y (i) = si (0) + b (0) * x (i);
 
 	  if (si_len > 1)
 	    {
 	      for (int j = 0; j < si_len - 1; j++)
-		si (j) = si (j+1) + b (j+1) * x (i);
+		{
+		  OCTAVE_QUIT;
+
+		  si (j) = si (j+1) + b (j+1) * x (i);
+		}
 
 	      si (si_len-1) = b (si_len) * x (i);
 	    }
 	  else
 	    si (0) = b (1) * x (i);
 	}
     }
   else
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -19,16 +19,18 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "quit.h"
+
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 #define DO_FIND_OP(T) \
   do \
     { \
@@ -87,32 +89,38 @@ find_nonzero_elem_idx (const Matrix& m, 
 {
   int count = 0;
   int m_nr = m.rows ();
   int m_nc = m.columns ();
 
   int i, j;
   for (j = 0; j < m_nc; j++)
     for (i = 0; i < m_nr; i++)
-      if (m (i, j) != 0.0)
-	count++;
+      {
+	OCTAVE_QUIT;
+
+	if (m (i, j) != 0.0)
+	  count++;
+      }
 
   octave_value_list retval (((nargout == 0) ? 1 : nargout), Matrix ());
 
   if (count == 0)
     return retval;
 
   ColumnVector i_idx (count);
   ColumnVector j_idx (count);
   ColumnVector v (count);
 
   count = 0;
   for (j = 0; j < m_nc; j++)
     for (i = 0; i < m_nr; i++)
       {
+	OCTAVE_QUIT;
+
 	double d = m (i, j);
 	if (d != 0.0)
 	  {
 	    i_idx (count) = i + 1;
 	    j_idx (count) = j + 1;
 	    v (count) = d;
 	    count++;
 	  }
@@ -126,32 +134,38 @@ find_nonzero_elem_idx (const ComplexMatr
 {
   int count = 0;
   int m_nr = m.rows ();
   int m_nc = m.columns ();
 
   int i, j;
   for (j = 0; j < m_nc; j++)
     for (i = 0; i < m_nr; i++)
-      if (m (i, j) != 0.0)
-	count++;
+      {
+	OCTAVE_QUIT;
+
+	if (m (i, j) != 0.0)
+	  count++;
+      }
 
   octave_value_list retval (((nargout == 0) ? 1 : nargout), Matrix ());
 
   if (count == 0)
     return retval;
 
   ColumnVector i_idx (count);
   ColumnVector j_idx (count);
   ComplexColumnVector v (count);
 
   count = 0;
   for (j = 0; j < m_nc; j++)
     for (i = 0; i < m_nr; i++)
       {
+	OCTAVE_QUIT;
+
 	Complex c = m (i, j);
 	if (c != 0.0)
 	  {
 	    i_idx (count) = i + 1;
 	    j_idx (count) = j + 1;
 	    v (count) = c;
 	    count++;
 	  }
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -23,16 +23,17 @@ Software Foundation, 59 Temple Place - S
 // Author: Paul Kienzle <pkienzle@users.sf.net>
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "dMatrix.h"
 #include "CMatrix.h"
+#include "quit.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern void
 kron (const Array2<double>&, const Array2<double>&, Array2<double>&);
@@ -50,17 +51,20 @@ kron (const Array2<T>& A, const Array2<T
   int Ac, Ar, Cc, Cr;
 
   for (Ac = Cc = 0; Ac < A.columns (); Ac++, Cc += B.columns ())
     for (Ar = Cr = 0; Ar < A.rows (); Ar++, Cr += B.rows ())
       {
 	const T v = A (Ar, Ac);
 	for (int Bc = 0; Bc < B.columns (); Bc++)
 	  for (int Br = 0; Br < B.rows (); Br++)
-	    C.xelem (Cr+Br, Cc+Bc) = v * B.elem (Br, Bc);
+	    {
+	      OCTAVE_QUIT;
+	      C.xelem (Cr+Br, Cc+Bc) = v * B.elem (Br, Bc);
+	    }
       }
 }
 
 template void
 kron (const Array2<double>&, const Array2<double>&, Array2<double>&);
 
 template void
 kron (const Array2<Complex>&, const Array2<Complex>&, Array2<Complex>&);
diff --git a/src/DLD-FUNCTIONS/log.cc b/src/DLD-FUNCTIONS/log.cc
--- a/src/DLD-FUNCTIONS/log.cc
+++ b/src/DLD-FUNCTIONS/log.cc
@@ -21,16 +21,17 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "EIG.h"
 #include "mx-cm-cdm.h"
+#include "quit.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // XXX FIXME XXX -- the next two functions should really be just
@@ -93,16 +94,17 @@ needs to be improved to be more robust.\
 	  else
 	    {
 	      EIG m_eig (m);
 	      ComplexColumnVector lambda (m_eig.eigenvalues ());
 	      ComplexMatrix Q (m_eig.eigenvectors ());
 
 	      for (int i = 0; i < nr; i++)
 		{
+		  OCTAVE_QUIT;
 		  Complex elt = lambda (i);
 		  if (imag (elt) == 0.0 && real (elt) > 0.0)
 		    lambda (i) = log (real (elt));
 		  else
 		    lambda (i) = log (elt);
 		}
 
 	      ComplexDiagMatrix D (lambda);
@@ -126,16 +128,17 @@ needs to be improved to be more robust.\
 	  else
 	    {
 	      EIG m_eig (m);
 	      ComplexColumnVector lambda (m_eig.eigenvalues ());
 	      ComplexMatrix Q (m_eig.eigenvectors ());
 
 	      for (int i = 0; i < nr; i++)
 		{
+		  OCTAVE_QUIT;
 		  Complex elt = lambda (i);
 		  if (imag (elt) == 0.0 && real (elt) > 0.0)
 		    lambda (i) = log (real (elt));
 		  else
 		    lambda (i) = log (elt);
 		}
 
 	      ComplexDiagMatrix D (lambda);
@@ -210,16 +213,17 @@ needs to be improved to be more robust.\
 	  else
 	    {
 	      EIG m_eig (m);
 	      ComplexColumnVector lambda (m_eig.eigenvalues ());
 	      ComplexMatrix Q (m_eig.eigenvectors ());
 
 	      for (int i = 0; i < nr; i++)
 		{
+		  OCTAVE_QUIT;
 		  Complex elt = lambda (i);
 		  if (imag (elt) == 0.0 && real (elt) > 0.0)
 		    lambda (i) = sqrt (real (elt));
 		  else
 		    lambda (i) = sqrt (elt);
 		}
 
 	      ComplexDiagMatrix D (lambda);
@@ -243,16 +247,17 @@ needs to be improved to be more robust.\
 	  else
 	    {
 	      EIG m_eig (m);
 	      ComplexColumnVector lambda (m_eig.eigenvalues ());
 	      ComplexMatrix Q (m_eig.eigenvectors ());
 
 	      for (int i = 0; i < nr; i++)
 		{
+		  OCTAVE_QUIT;
 		  Complex elt = lambda (i);
 		  if (imag (elt) == 0.0 && real (elt) > 0.0)
 		    lambda (i) = sqrt (real (elt));
 		  else
 		    lambda (i) = sqrt (elt);
 		}
 
 	      ComplexDiagMatrix D (lambda);
diff --git a/src/DLD-FUNCTIONS/minmax.cc b/src/DLD-FUNCTIONS/minmax.cc
--- a/src/DLD-FUNCTIONS/minmax.cc
+++ b/src/DLD-FUNCTIONS/minmax.cc
@@ -23,16 +23,17 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cmath>
 
 #include "lo-ieee.h"
 #include "lo-mappers.h"
+#include "quit.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 // XXX FIXME XXX -- it would be nice to share code among the min/max
 // functions below.
@@ -48,68 +49,80 @@ min (double d, const Matrix& m)
   int nc = m.columns ();
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = xmin (d, m (i, j));
+      {
+	OCTAVE_QUIT;
+	result (i, j) = xmin (d, m (i, j));
+      }
 
   return result;
 }
 
 static Matrix
 min (const Matrix& m, double d)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = xmin (m (i, j), d);
+      {
+	OCTAVE_QUIT;
+	result (i, j) = xmin (m (i, j), d);
+      }
 
   return result;
 }
 
 static ComplexMatrix
 min (const Complex& c, const ComplexMatrix& m)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = xmin (c, m (i, j));
+      {
+	OCTAVE_QUIT;
+	result (i, j) = xmin (c, m (i, j));
+      }
 
   return result;
 }
 
 static ComplexMatrix
 min (const ComplexMatrix& m, const Complex& c)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = xmin (m (i, j), c);
+      {
+	OCTAVE_QUIT;
+	result (i, j) = xmin (m (i, j), c);
+      }
 
   return result;
 }
 
 static Matrix
 min (const Matrix& a, const Matrix& b)
 {
   int nr = a.rows ();
@@ -122,17 +135,20 @@ min (const Matrix& a, const Matrix& b)
     }
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = xmin (a (i, j), b (i, j));
+      {
+	OCTAVE_QUIT;
+	result (i, j) = xmin (a (i, j), b (i, j));
+      }
 
   return result;
 }
 
 static ComplexMatrix
 min (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   int nr = a.rows ();
@@ -147,31 +163,37 @@ min (const ComplexMatrix& a, const Compl
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (int i = 0; i < nr; i++)
-	if (imag (a (i, j)) != 0.0 || imag (b (i, j)) != 0.0)
-	  {
-	    columns_are_real_only = 0;
-	    break;
-	  }
+	{
+	  OCTAVE_QUIT;
+	  if (imag (a (i, j)) != 0.0 || imag (b (i, j)) != 0.0)
+	    {
+	      columns_are_real_only = 0;
+	      break;
+	    }
+	}
 
       if (columns_are_real_only)
 	{
 	  for (int i = 0; i < nr; i++)
 	    result (i, j) = xmin (real (a (i, j)), real (b (i, j)));
 	}
       else
 	{
 	  for (int i = 0; i < nr; i++)
-	    result (i, j) = xmin (a (i, j), b (i, j));
+	    {
+	      OCTAVE_QUIT;
+	      result (i, j) = xmin (a (i, j), b (i, j));
+	    }
 	}
     }
 
   return result;
 }
 
 static Matrix
 max (double d, const Matrix& m)
@@ -180,68 +202,80 @@ max (double d, const Matrix& m)
   int nc = m.columns ();
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = xmax (d, m (i, j));
+      {
+	OCTAVE_QUIT;
+	result (i, j) = xmax (d, m (i, j));
+      }
 
   return result;
 }
 
 static Matrix
 max (const Matrix& m, double d)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = xmax (m (i, j), d);
+      {
+	OCTAVE_QUIT;
+	result (i, j) = xmax (m (i, j), d);
+      }
 
   return result;
 }
 
 static ComplexMatrix
 max (const Complex& c, const ComplexMatrix& m)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = xmax (c, m (i, j));
+      {
+	OCTAVE_QUIT;
+	result (i, j) = xmax (c, m (i, j));
+      }
 
   return result;
 }
 
 static ComplexMatrix
 max (const ComplexMatrix& m, const Complex& c)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = xmax (m (i, j), c);
+      {
+	OCTAVE_QUIT;
+	result (i, j) = xmax (m (i, j), c);
+      }
 
   return result;
 }
 
 static Matrix
 max (const Matrix& a, const Matrix& b)
 {
   int nr = a.rows ();
@@ -254,17 +288,20 @@ max (const Matrix& a, const Matrix& b)
     }
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = xmax (a (i, j), b (i, j));
+      {
+	OCTAVE_QUIT;
+	result (i, j) = xmax (a (i, j), b (i, j));
+      }
 
   return result;
 }
 
 static ComplexMatrix
 max (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   int nr = a.rows ();
@@ -279,31 +316,40 @@ max (const ComplexMatrix& a, const Compl
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (int i = 0; i < nr; i++)
-	if (imag (a (i, j)) != 0.0 || imag (b (i, j)) != 0.0)
-	  {
-	    columns_are_real_only = 0;
-	    break;
-	  }
+	{
+	  OCTAVE_QUIT;
+	  if (imag (a (i, j)) != 0.0 || imag (b (i, j)) != 0.0)
+	    {
+	      columns_are_real_only = 0;
+	      break;
+	    }
+	}
 
       if (columns_are_real_only)
 	{
 	  for (int i = 0; i < nr; i++)
-	    result (i, j) = xmax (real (a (i, j)), real (b (i, j)));
+	    {
+	      OCTAVE_QUIT;
+	      result (i, j) = xmax (real (a (i, j)), real (b (i, j)));
+	    }
 	}
       else
 	{
 	  for (int i = 0; i < nr; i++)
-	    result (i, j) = xmax (a (i, j), b (i, j));
+	    {
+	      OCTAVE_QUIT;
+	      result (i, j) = xmax (a (i, j), b (i, j));
+	    }
 	}
     }
 
   return result;
 }
 
 #define MINMAX_BODY(FCN) \
  \
@@ -423,16 +469,17 @@ max (const ComplexMatrix& a, const Compl
       if (len > 0) \
 	{ \
 	  double nan_val = lo_ieee_nan_value (); \
  \
 	  RowVector idx (len); \
  \
 	  for (int i = 0; i < len; i++) \
 	    { \
+	      OCTAVE_QUIT; \
 	      int tmp = index.elem (i) + 1; \
 	      idx.elem (i) = (tmp <= 0) \
 		? nan_val : static_cast<double> (tmp); \
 	    } \
  \
 	  retval(1) = idx; \
 	} \
       else \
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -33,19 +33,21 @@ Software Foundation, 59 Temple Place - S
 #include <cfloat>
 #include <cmath>
 
 #include <iostream>
 #include <iomanip>
 
 #include "CmplxQRP.h"
 #include "dbleQR.h"
+#include "f77-fcn.h"
+#include "quit.h"
+
 #include "defun-dld.h"
 #include "error.h"
-#include "f77-fcn.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "pager.h"
 #if defined (DEBUG) || defined (DEBUG_SORT)
 #include "pr-output.h"
 #endif
@@ -392,17 +394,20 @@ See also: balance, dare, eig, schur\n\
   int ilo, ihi, info;
   char compq = (nargout >= 3 ? 'V' : 'N');
   char compz = (nargout >= 4 ? 'V' : 'N');
 
   // initialize Q, Z to identity if we need either of them
   if (compq == 'V' || compz == 'V')
     for (int ii = 0; ii < nn; ii++)
       for (int jj = 0; jj < nn; jj++)
-        QQ(ii,jj) = ZZ(ii,jj) = (ii == jj ? 1.0 : 0.0);
+	{
+	  OCTAVE_QUIT;
+	  QQ(ii,jj) = ZZ(ii,jj) = (ii == jj ? 1.0 : 0.0);
+	}
 
   // always perform permutation balancing
   char bal_job = 'P';
   RowVector lscale(nn), rscale(nn), work(6*nn);
 
   if (complex_case)
     {
       error ("Complex case not implemented yet");
@@ -831,16 +836,18 @@ See also: balance, dare, eig, schur\n\
 	      return retval;
 	    }
 
 	  // now construct the complex form of VV, WW
 	  int jj = 0;
 
 	  while (jj < nn)
 	    {
+	      OCTAVE_QUIT;
+
 	      // see if real or complex eigenvalue
 	      int cinc = 2;	// column increment; assume complex eigenvalue
 
 	      if (jj == (nn-1))
 		cinc = 1;	// single column
 	      else if (aa(jj+1,jj) == 0)
 		cinc = 1;
 
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -25,16 +25,17 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <ctime>
 
 #include <string>
 
 #include "f77-fcn.h"
 #include "lo-mappers.h"
+#include "quit.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
@@ -66,17 +67,17 @@ extern "C"
   int F77_FUNC (setcgn, SETCGN) (const int&);
 }
 
 static double
 curr_rand_seed (void)
 {
   union d2i { double d; int i[2]; };
   union d2i u;
-  F77_XFCN (getsd, GETSD, (u.i[0], u.i[1]));
+  F77_FUNC (getsd, GETSD) (u.i[0], u.i[1]);
   return u.d;
 }
 
 static int
 force_to_fit_range (int i, int lo, int hi)
 {
   assert (hi > lo && lo >= 0 && hi > lo);
 
@@ -93,17 +94,17 @@ force_to_fit_range (int i, int lo, int h
 static void
 set_rand_seed (double val)
 {
   union d2i { double d; int i[2]; };
   union d2i u;
   u.d = val;
   int i0 = force_to_fit_range (u.i[0], 1, 2147483563);
   int i1 = force_to_fit_range (u.i[1], 1, 2147483399);
-  F77_XFCN (setsd, SETSD, (i0, i1));
+  F77_FUNC (setsd, SETSD) (i0, i1);
 }
 
 static const char *
 curr_rand_dist (void)
 {
   if (current_distribution == uniform_dist)
     return "uniform";
   else if (current_distribution == normal_dist)
@@ -134,21 +135,35 @@ do_initialization (void)
   int second = tm->tm_sec + 1;
 
   int s0 = tm->tm_mday * hour * minute * second;
   int s1 = hour * minute * second;
 
   s0 = force_to_fit_range (s0, 1, 2147483563);
   s1 = force_to_fit_range (s1, 1, 2147483399);
 
-  F77_XFCN (setall, SETALL, (s0, s1));
+  F77_FUNC (setall, SETALL) (s0, s1);
 
   initialized = 1;
 }
 
+#define MAKE_RAND_MAT(mat, nr, nc, f, F) \
+  do \
+    { \
+      double val; \
+      for (volatile int j = 0; j < nc; j++) \
+	for (volatile int i = 0; i < nr; i++) \
+	  { \
+	    OCTAVE_QUIT; \
+	    F77_FUNC (f, F) (0.0, 1.0, val); \
+	    mat(i,j) = val; \
+	  } \
+    } \
+  while (0)
+
 static octave_value_list
 do_rand (const octave_value_list& args, int nargin)
 {
   octave_value_list retval;
 
   volatile int n = 0;
   volatile int m = 0;
 
@@ -174,23 +189,23 @@ do_rand (const octave_value_list& args, 
 	  else if (s_arg == "seed")
 	    {
 	      retval(0) = curr_rand_seed ();
 	    }
 	  else if (s_arg == "uniform")
 	    {
 	      current_distribution = uniform_dist;
 
-	      F77_XFCN (setcgn, SETCGN, (uniform_dist));
+	      F77_FUNC (setcgn, SETCGN) (uniform_dist);
 	    }
 	  else if (s_arg == "normal")
 	    {
 	      current_distribution = normal_dist;
 
-	      F77_XFCN (setcgn, SETCGN, (normal_dist));
+	      F77_FUNC (setcgn, SETCGN) (normal_dist);
 	    }
 	  else
 	    error ("rand: unrecognized string argument");
 	}
       else if (tmp.is_scalar_type ())
 	{
 	  double dval = tmp.double_value ();
 
@@ -292,37 +307,30 @@ do_rand (const octave_value_list& args, 
     {
       Matrix m;
       retval.resize (1, m);
     }
   else if (n > 0 && m > 0)
     {
       Matrix rand_mat (n, m);
 
-      for (volatile int j = 0; j < m; j++)
-	for (volatile int i = 0; i < n; i++)
-	  {
-	    double val;
-	    switch (current_distribution)
-	      {
-	      case uniform_dist:
-		F77_XFCN (dgenunf, DGENUNF, (0.0, 1.0, val));
-		rand_mat (i, j) = val;
-		break;
+      switch (current_distribution)
+	{
+	case uniform_dist:
+	  MAKE_RAND_MAT (rand_mat, n, m, dgenunf, DGENUNF);
+	  break;
 
-	      case normal_dist:
-		F77_XFCN (dgennor, DGENNOR, (0.0, 1.0, val));
-		rand_mat (i, j) = val;
-		break;
+	case normal_dist:
+	  MAKE_RAND_MAT (rand_mat, n, m, dgennor, DGENNOR);
+	  break;
 
-	      default:
-		panic_impossible ();
-		break;
-	      }
-	  }
+	default:
+	  panic_impossible ();
+	  break;
+	}
 
       retval(0) = rand_mat;
     }
   else
     error ("rand: invalid negative argument");
 
   return retval;
 }
@@ -368,17 +376,17 @@ rand (\"seed\")\n\
     }
 
   return retval;
 }
 
 static void
 reset_rand_generator (void *)
 {
-  F77_XFCN (setcgn, SETCGN, (current_distribution));
+  F77_FUNC (setcgn, SETCGN) (current_distribution);
 }
 
 DEFUN_DLD (randn, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} randn (@var{x})\n\
 @deftypefnx {Loadable Function} {} randn (@var{n}, @var{m})\n\
 @deftypefnx {Loadable Function} {} randn (@code{\"seed\"}, @var{x})\n\
 Return a matrix with normally distributed random elements.  The\n\
@@ -419,17 +427,17 @@ randn (\"seed\")\n\
       // (i.e. current_distribution will be reset before calling
       // reset_rand_generator()).
 
       unwind_protect::add (reset_rand_generator, 0);
       unwind_protect_int (current_distribution);
 
       current_distribution = normal_dist;
 
-      F77_XFCN (setcgn, SETCGN, (normal_dist));
+      F77_FUNC (setcgn, SETCGN) (normal_dist);
 
       retval = do_rand (args, nargin);
 
       unwind_protect::run_frame ("randn");
     }
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/sort.cc b/src/DLD-FUNCTIONS/sort.cc
--- a/src/DLD-FUNCTIONS/sort.cc
+++ b/src/DLD-FUNCTIONS/sort.cc
@@ -20,16 +20,17 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-mappers.h"
+#include "quit.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 // This is algorithm 5.2.4L from Knuth, Volume 3.
 
@@ -115,16 +116,17 @@ create_index_array (int n)
     }
 
 #define DO_SORT(n, condition) \
   while (1) \
     { \
       SORT_INIT_PHASE(n); \
       while (1) \
 	{ \
+          OCTAVE_QUIT; \
 	  if (condition) \
 	    { \
 	      SORT_REORDER_PHASE_ONE; \
 	    } \
 	  else \
 	    { \
 	      SORT_REORDER_PHASE_TWO; \
 	    } \
@@ -132,27 +134,29 @@ create_index_array (int n)
     }
 
 #define VECTOR_CREATE_RETURN_VALUES(vs, v) \
   int k = l (0); \
   idx (0) = k; \
   vs (0) = v (k-1); \
   for (int i = 1; i < n; i++) \
     { \
+      OCTAVE_QUIT; \
       k = l (static_cast<int> (idx (i-1))); \
       idx (i) = k; \
       vs (i) = v (k-1); \
     }
 
 #define MATRIX_CREATE_RETURN_VALUES(ms, m) \
   int k = l (0); \
   idx (0, j) = k; \
   ms (0, j) = m (k-1, j); \
   for (int i = 1; i < nr; i++) \
     { \
+      OCTAVE_QUIT; \
       k = l (static_cast<int> (idx (i-1, j))); \
       idx (i, j) = k; \
       ms (i, j) = m (k-1, j); \
     }
 
 static octave_value_list
 mx_sort (const Matrix& m)
 {
@@ -242,21 +246,24 @@ mx_sort (const ComplexMatrix& cm)
   else if (nr > 1 && nc > 0)
     {
       for (int j = 0; j < nc; j++)
 	{
 	  Array<int> l = create_index_array (nr);
 
 	  bool all_elts_real = true;
 	  for (int i = 0; i < nr; i++)
-	    if (imag (cm (i, j)) != 0.0)
-	      {
-		all_elts_real = false;
-		break;
-	      }
+	    {
+	      OCTAVE_QUIT;
+	      if (imag (cm (i, j)) != 0.0)
+		{
+		  all_elts_real = false;
+		  break;
+		}
+	    }
 
 	  DO_SORT (nr, ((all_elts_real
 			 && (xisnan (real (cm (p-1, j)))
 			     || real (cm (p-1, j)) > real (cm (q-1, j))))
 			|| xisnan (cm (p-1, j))
 			|| abs (cm (p-1, j)) > abs (cm (q-1, j))));
 
 	  MATRIX_CREATE_RETURN_VALUES (cms, cm);
@@ -287,21 +294,24 @@ mx_sort (ComplexRowVector& cv)
       return retval;
     }
   else if (n > 1)
     {
       Array<int> l = create_index_array (n);
 
       bool all_elts_real = true;
       for (int i = 0; i < n; i++)
-	if (imag (cv (i)) != 0.0)
-	  {
-	    all_elts_real = false;
-	    break;
-	  }
+	{
+	  OCTAVE_QUIT;
+	  if (imag (cv (i)) != 0.0)
+	    {
+	      all_elts_real = false;
+	      break;
+	    }
+	}
 
       DO_SORT (n, ((all_elts_real
 		    && (xisnan (real (cv (p-1)))
 			|| real (cv (p-1)) > real (cv (q-1))))
 		   || xisnan (cv (p-1))
 		   || abs (cv (p-1)) > abs (cv (q-1))));
 
       VECTOR_CREATE_RETURN_VALUES (cvs, cv);
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -26,16 +26,17 @@ Software Foundation, 59 Temple Place - S
 
 #include <cfloat>
 #include <cmath>
 
 #include <string>
 
 #include "lo-ieee.h"
 #include "str-vec.h"
+#include "quit.h"
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "ov-re-nd-array.h"
 #include "variables.h"
@@ -126,32 +127,38 @@ map_d_m (d_dd_fcn f, double x, const Mat
 {
   int nr = y.rows ();
   int nc = y.columns ();
 
   Matrix retval (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      retval (i, j) = f (x, y (i, j));
+      {
+	OCTAVE_QUIT;
+	retval (i, j) = f (x, y (i, j));
+      }
 
   return retval;
 }
 
 static Matrix
 map_m_d (d_dd_fcn f, const Matrix& x, double y)
 {
   int nr = x.rows ();
   int nc = x.columns ();
 
   Matrix retval (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      retval (i, j) = f (x (i, j), y);
+      {
+	OCTAVE_QUIT;
+	retval (i, j) = f (x (i, j), y);
+      }
 
   return retval;
 }
 
 static Matrix
 map_m_m (d_dd_fcn f, const Matrix& x, const Matrix& y)
 {
   int x_nr = x.rows ();
@@ -161,17 +168,20 @@ map_m_m (d_dd_fcn f, const Matrix& x, co
   int y_nc = y.columns ();
 
   assert (x_nr == y_nr && x_nc == y_nc);
 
   Matrix retval (x_nr, x_nc);
 
   for (int j = 0; j < x_nc; j++)
     for (int i = 0; i < x_nr; i++)
-      retval (i, j) = f (x (i, j), y (i, j));
+      {
+	OCTAVE_QUIT;
+	retval (i, j) = f (x (i, j), y (i, j));
+      }
 
   return retval;
 }
 
 DEFUN (atan2, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan2 (@var{y}, @var{x})\n\
 Compute atan (@var{y} / @var{x}) for corresponding elements of @var{y}\n\
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -38,16 +38,17 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
 
 #include "cmd-edit.h"
 #include "file-ops.h"
+#include "quit.h"
 #include "str-vec.h"
 
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "input.h"
@@ -165,18 +166,22 @@ std::string
 gnu_readline (const std::string& s, bool force_readline)
 {
   std::string retval;
 
   if (line_editing || force_readline)
     {
       bool eof;
 
+      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       retval = command_editor::readline (s, eof);
 
+      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       if (! eof && retval.empty ())
 	retval = "\n";
     }
   else
     {
       if (! s.empty () && (interactive || forced_interactive))
 	{
 	  FILE *stream = command_editor::get_output_stream ();
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -38,17 +38,17 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef YY_FATAL_ERROR
 #undef YY_FATAL_ERROR
 #endif
 #define YY_FATAL_ERROR(msg) \
   do \
     { \
       error (msg); \
-      jump_to_top_level (); \
+      OCTAVE_JUMP_TO_TOP_LEVEL; \
       yy_fatal_error (msg); \
     } \
   while (0)
 
 #define TOK_RETURN(tok) \
   do \
     { \
       current_input_column += yyleng; \
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -38,16 +38,17 @@ Software Foundation, 59 Temple Place - S
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
 
 #include "SLStack.h"
 
 #include "cmd-edit.h"
+#include "quit.h"
 #include "lo-sstream.h"
 
 // These would be alphabetical, but y.tab.h must be included before
 // oct-gperf.h and y.tab.h must be included after token.h and the tree
 // class declarations.  We can't include y.tab.h in oct-gperf.h
 // because it may not be protected to allow it to be included multiple
 // times.
 
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -2631,17 +2631,17 @@ read_mat5_binary_element (std::istream& 
 	  }
 
 	elname = new char[len];
 
 	if (! is.read (elname, len))
 	  goto data_read_error;
 
 	// fields subelements
-	for (i=0; i < len/field_name_length; i++)
+	for (i = 0; i < len/field_name_length; i++)
 	  {
 	    char *thename;
 	    octave_value fieldtc;
 	    thename = read_mat5_binary_element (is, filename, swap,
 						global, fieldtc);
 	    m[elname + i*field_name_length] = fieldtc;
 	    delete [] thename;
 	  }
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -31,16 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include <fstream>
 #include <string>
 
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-sstream.h"
 #include "lo-utils.h"
 #include "str-vec.h"
+#include "quit.h"
 
 #include "error.h"
 #include "input.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "oct-obj.h"
 #include "utils.h"
 
@@ -1431,16 +1432,18 @@ octave_base_stream::do_scanf (scanf_form
       std::istream& is = *isp;
 
       const scanf_format_elt *elt = fmt_list.first ();
 
       std::ios::fmtflags flags = is.flags ();
 
       for (;;)
 	{
+	  OCTAVE_QUIT;
+
 	  if (elt)
 	    {
 	      if (max_conv > 0 && conversion_count == max_conv)
 		{
 		  if (all_char_conv && one_elt_size_spec)
 		    {
 		      final_nr = 1;
 		      final_nc = data_index;
@@ -2241,16 +2244,18 @@ octave_base_stream::do_printf (printf_fo
       std::ostream& os = *osp;
 
       const printf_format_elt *elt = fmt_list.first ();
 
       printf_value_cache val_cache (args);
 
       for (;;)
 	{
+	  OCTAVE_QUIT;
+
 	  if (elt)
 	    {
 	      // NSA is the number of `star' args to convert.
 
 	      int nsa = (elt->fw < 0) + (elt->prec < 0);
 
 	      int sa_1 = 0;
 	      int sa_2 = 0; 
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -27,16 +27,17 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "lo-sstream.h"
 #include "lo-utils.h"
+#include "quit.h"
 
 #include "defun.h"
 #include "error.h"
 #include "ov-cell.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "ov-base-mat.h"
@@ -73,17 +74,20 @@ octave_cell::subsref (const std::string 
 	else
 	  {
 	    int nr = tcell.rows ();
 	    int nc = tcell.columns ();
 	    octave_value_list lst (nr * nc, octave_value ());
 	    int k = 0;
 	    for (int j = 0; j < nc; j++)
 	      for (int i = 0; i < nr; i++)
-		lst(k++) = tcell(i,j);
+		{
+		  OCTAVE_QUIT;
+		  lst(k++) = tcell(i,j);
+		}
 	    retval = octave_value (lst, true);
 	  }
       }
       break;
 
     case '.':
       {
 	std::string nm = type_name ();
@@ -263,16 +267,18 @@ octave_cell::print_raw (std::ostream& os
       newline (os);
 
       increment_indent_level ();
 
       for (int j = 0; j < nc; j++)
 	{
 	  for (int i = 0; i < nr; i++)
 	    {
+	      OCTAVE_QUIT;
+
 	      OSSTREAM buf;
 	      buf << "[" << i+1 << "," << j+1 << "]" << OSSTREAM_ENDS;
 
 	      octave_value val = matrix(i,j);
 
 	      val.print_with_name (os, OSSTREAM_STR (buf));
 
 	      OSSTREAM_FREEZE (buf);
diff --git a/src/ov-mapper.cc b/src/ov-mapper.cc
--- a/src/ov-mapper.cc
+++ b/src/ov-mapper.cc
@@ -23,16 +23,18 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__) && ! defined (NO_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "quit.h"
+
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-mapper.h"
 #include "ov.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_mapper);
 
@@ -42,32 +44,40 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 static bool
 any_element_less_than (const Matrix& a, double val)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      if (a (i, j) < val)
-	return true;
+      {
+	OCTAVE_QUIT;
+
+	if (a (i, j) < val)
+	  return true;
+      }
 
   return false;
 }
 
 static bool
 any_element_greater_than (const Matrix& a, double val)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      if (a (i, j) > val)
-	return true;
+      {
+	OCTAVE_QUIT;
+
+	if (a (i, j) > val)
+	  return true;
+      }
 
   return false;
 }
 
 // In most cases, we could use the map member function from the Matrix
 // classes, but as currently implemented, they don't allow us to
 // detect errors and abort properly.  So use these macros to do the
 // looping here instead.
@@ -79,16 +89,18 @@ any_element_greater_than (const Matrix& 
       int nc = M.cols (); \
  \
       T result (nr, nc); \
  \
       for (int j = 0; j < nc; j++) \
 	{ \
 	   for (int i = 0; i < nr; i++) \
 	     { \
+                OCTAVE_QUIT; \
+ \
 		result (i, j) = CONV (F (M (i, j))); \
  \
 		if (error_state) \
 		  return retval; \
 	     } \
 	} \
       retval = R; \
     } \
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -30,16 +30,17 @@ Software Foundation, 59 Temple Place - S
 
 #include <climits>
 
 #include <iostream>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
+#include "quit.h"
 
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
@@ -135,16 +136,18 @@ octave_matrix::convert_to_str (void) con
 	  charMatrix chm (nr, nc);
 	  
 	  bool warned = false;
 
 	  for (int j = 0; j < nc; j++)
 	    {
 	      for (int i = 0; i < nr; i++)
 		{
+		  OCTAVE_QUIT;
+
 		  double d = matrix (i, j);
 
 		  if (xisnan (d))
 		    {
 		      ::error ("invalid conversion from NaN to character");
 		      return retval;
 		    }
 		  else
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -25,16 +25,17 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "Array-flags.h"
 #include "str-vec.h"
+#include "quit.h"
 
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-base.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-cell.h"
 #include "ov-scalar.h"
@@ -891,17 +892,21 @@ octave_value::vector_value (bool force_s
     }
   else if (nr > 0 && nc > 0
 	   && (Vdo_fortran_indexing || force_vector_conversion))
     {
       retval.resize (nr * nc);
       int k = 0;
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  retval (k++) = m (i, j);
+	  {
+	    OCTAVE_QUIT;
+
+	    retval (k++) = m (i, j);
+	  }
     }
   else
     {
       std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "real vector");
     }
 
   return retval;
@@ -921,32 +926,36 @@ octave_value::int_vector_value (bool for
   int nr = m.rows ();
   int nc = m.columns ();
 
   if (nr == 1)
     {
       retval.resize (nc);
       for (int i = 0; i < nc; i++)
 	{
+	  OCTAVE_QUIT;
+
 	  double d = m (0, i);
 
 	  if (require_int && D_NINT (d) != d)
 	    {
 	      error ("conversion to integer value failed");
 	      return retval;
 	    }
 
 	  retval (i) = static_cast<int> (d);
 	}
     }
   else if (nc == 1)
     {
       retval.resize (nr);
       for (int i = 0; i < nr; i++)
 	{
+	  OCTAVE_QUIT;
+
 	  double d = m (i, 0);
 
 	  if (require_int && D_NINT (d) != d)
 	    {
 	      error ("conversion to integer value failed");
 	      return retval;
 	    }
 
@@ -957,16 +966,18 @@ octave_value::int_vector_value (bool for
 	   && (Vdo_fortran_indexing || force_vector_conversion))
     {
       retval.resize (nr * nc);
       int k = 0;
       for (int j = 0; j < nc; j++)
 	{
 	  for (int i = 0; i < nr; i++)
 	    {
+	      OCTAVE_QUIT;
+
 	      double d = m (i, j);
 
 	      if (require_int && D_NINT (d) != d)
 		{
 		  error ("conversion to integer value failed");
 		  return retval;
 		}
 
@@ -996,32 +1007,41 @@ octave_value::complex_vector_value (bool
 
   int nr = m.rows ();
   int nc = m.columns ();
 
   if (nr == 1)
     {
       retval.resize (nc);
       for (int i = 0; i < nc; i++)
-	retval (i) = m (0, i);
+	{
+	  OCTAVE_QUIT;
+	  retval (i) = m (0, i);
+	}
     }
   else if (nc == 1)
     {
       retval.resize (nr);
       for (int i = 0; i < nr; i++)
-	retval (i) = m (i, 0);
+	{
+	  OCTAVE_QUIT;
+	  retval (i) = m (i, 0);
+	}
     }
   else if (nr > 0 && nc > 0
 	   && (Vdo_fortran_indexing || force_vector_conversion))
     {
       retval.resize (nr * nc);
       int k = 0;
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  retval (k++) = m (i, j);
+	  {
+	    OCTAVE_QUIT;
+	    retval (k++) = m (i, j);
+	  }
     }
   else
     {
       std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "complex vector");
     }
 
   return retval;
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -36,16 +36,17 @@ Software Foundation, 59 Temple Place - S
 #include "CMatrix.h"
 #include "Range.h"
 #include "cmd-edit.h"
 #include "dMatrix.h"
 #include "lo-mappers.h"
 #include "lo-sstream.h"
 #include "mach-info.h"
 #include "oct-cmplx.h"
+#include "quit.h"
 #include "str-vec.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-stream.h"
@@ -1306,16 +1307,18 @@ octave_print_internal (std::ostream& os,
   if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (int i = 0; i < nr; i++)
 	{
 	  for (int j = 0; j < nc; j++)
 	    {
+	      OCTAVE_QUIT;
+
 	      if (j == 0)
 		os << "  ";
 
 	      pr_plus_format (os, m(i,j));
 	    }
 
 	  if (i < nr - 1)
 	    os << "\n";
@@ -1365,16 +1368,18 @@ octave_print_internal (std::ostream& os,
 	    {
 	      int col = 0;
 	      while (col < nc)
 		{
 		  int lim = col + inc < nc ? col + inc : nc;
 
 		  for (int j = col; j < lim; j++)
 		    {
+		      OCTAVE_QUIT;
+
 		      if (i == 0 && j == 0)
 			os << "[ ";
 		      else
 			{
 			  if (j > col && j < lim)
 			    os << ", ";
 			  else
 			    os << "  ";
@@ -1409,16 +1414,18 @@ octave_print_internal (std::ostream& os,
 				 extra_indent);
 
 	      for (int i = 0; i < nr; i++)
 		{
 		  os << std::setw (extra_indent) << "";
 
 		  for (int j = col; j < lim; j++)
 		    {
+		      OCTAVE_QUIT;
+
 		      os << "  ";
 
 		      pr_float (os, m(i,j), fw, scale);
 		    }
 
 		  if (i < nr - 1)
 		    os << "\n";
 		}
@@ -1474,16 +1481,18 @@ octave_print_internal (std::ostream& os,
  if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (int i = 0; i < nr; i++)
 	{
 	  for (int j = 0; j < nc; j++)
 	    {
+	      OCTAVE_QUIT;
+
 	      if (j == 0)
 		os << "  ";
 
 	      pr_plus_format (os, cm(i,j));
 	    }
 
 	  if (i < nr - 1)
 	    os << "\n";
@@ -1534,16 +1543,18 @@ octave_print_internal (std::ostream& os,
 	    {
 	      int col = 0;
 	      while (col < nc)
 		{
 		  int lim = col + inc < nc ? col + inc : nc;
 
 		  for (int j = col; j < lim; j++)
 		    {
+		      OCTAVE_QUIT;
+
 		      if (i == 0 && j == 0)
 			os << "[ ";
 		      else
 			{
 			  if (j > col && j < lim)
 			    os << ", ";
 			  else
 			    os << "  ";
@@ -1578,16 +1589,18 @@ octave_print_internal (std::ostream& os,
 				 extra_indent);
 
 	      for (int i = 0; i < nr; i++)
 		{
 		  os << std::setw (extra_indent) << "";
 
 		  for (int j = col; j < lim; j++)
 		    {
+		      OCTAVE_QUIT;
+
 		      os << "  ";
 
 		      pr_complex (os, cm(i,j), r_fw, i_fw, scale);
 		    }
 
 		  if (i < nr - 1) 
 		    os << "\n";
 		}
@@ -1605,16 +1618,18 @@ octave_print_internal (std::ostream& os,
   double limit = r.limit ();
   int num_elem = r.nelem ();
 
   if (plus_format && ! pr_as_read_syntax)
     {
       os << "  ";
       for (int i = 0; i < num_elem; i++)
 	{
+	  OCTAVE_QUIT;
+
 	  double val = base + i * increment;
 	  if (val == 0.0)
 	    os << " ";
 	  else
 	    os << "+";
 	}
     }
   else
@@ -1678,16 +1693,18 @@ octave_print_internal (std::ostream& os,
 
 	      pr_col_num_header (os, total_width, max_width, lim, col,
 				 extra_indent);
 
 	      os << std::setw (extra_indent) << "";
 
 	      for (int i = col; i < lim; i++)
 		{
+		  OCTAVE_QUIT;
+
 		  double val = base + i * increment;
 
 		  os << "  ";
 
 		  pr_float (os, val, fw, scale);
 		}
 
 	      col += inc;
@@ -1720,16 +1737,18 @@ octave_print_internal (std::ostream& os,
 
       if (pr_as_read_syntax && nstr > 1)
 	os << "[ ";
 
       if (nstr != 0)
 	{
 	  for (int i = 0; i < nstr; i++)
 	    {
+	      OCTAVE_QUIT;
+
 	      std::string row = chm.row_as_string (i);
 
 	      if (pr_as_read_syntax)
 		{
 		  os << "\"" << undo_string_escapes (row) << "\"";
 
 		  if (i < nstr - 1)
 		    os << "; ";
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -23,16 +23,18 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__) && ! defined (NO_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "quit.h"
+
 #include "error.h"
 #include "gripes.h"
 #include "oct-map.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-cmd.h"
@@ -45,16 +47,18 @@ Software Foundation, 59 Temple Place - S
 
 // TRUE means we are evaluating some kind of looping construct.
 bool evaluating_looping_command = false;
 
 // Decide if it's time to quit a for or while loop.
 static inline bool
 quit_loop_now (void)
 {
+  OCTAVE_QUIT;
+
   // Maybe handle `continue N' someday...
 
   if (tree_continue_command::continuing)
     tree_continue_command::continuing--;
 
   bool quit = (error_state
 	       || tree_return_command::returning
 	       || tree_break_command::breaking
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -25,16 +25,18 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <SLList.h>
 
+#include "quit.h"
+
 #include "defun.h"
 #include "error.h"
 #include "ov.h"
 #include "oct-lvalue.h"
 #include "input.h"
 #include "pager.h"
 #include "pt-bp.h"
 #include "pt-cmd.h"
@@ -151,16 +153,18 @@ tree_statement_list::eval (bool silent, 
     return retval;
 
   for (Pix p = first (); p != 0; next (p))
     {
       tree_statement *elt = this->operator () (p);
 
       if (elt)
 	{
+	  OCTAVE_QUIT;
+
 	  retval = elt->eval (silent, nargout, function_body);
 
 	  if (error_state)
 	    break;
 
 	  if (tree_break_command::breaking
 	      || tree_continue_command::continuing)
 	    break;
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -32,44 +32,33 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
 
 #include "cmd-edit.h"
+#include "quit.h"
 
 #include "error.h"
 #include "load-save.h"
 #include "pager.h"
 #include "sighandlers.h"
 #include "syswait.h"
 #include "toplev.h"
 #include "utils.h"
 
 // Nonzero means we have already printed a message for this series of
 // SIGPIPES.  We assume that the writer will eventually give up.
 int pipe_handler_error_count = 0;
 
 // TRUE means we can be interrupted.
 bool can_interrupt = false;
 
-// Allow us to save the signal mask and then restore it to the most
-// recently saved value.  This is necessary when using the POSIX
-// signal handling interface on some systems calling longjmp out of
-// the signal handler to get to the top level on an interrupt doesn't
-// restore the original signal mask.  Alternatively, we could use
-// sigsetjmp/siglongjmp, but saving and restoring the signal mask
-// ourselves works ok and seems simpler just now.
-
-#if defined (HAVE_POSIX_SIGNALS)
-static sigset_t octave_signal_mask;
-#endif
-
 #if RETSIGTYPE == void
 #define SIGHANDLER_RETURN(status) return
 #else
 #define SIGHANDLER_RETURN(status) return status
 #endif
 
 #if defined (MUST_REINSTALL_SIGHANDLERS)
 #define MAYBE_REINSTALL_SIGHANDLER(sig, handler) \
@@ -90,32 +79,16 @@ static sigset_t octave_signal_mask;
 #endif
 
 #if defined (SIGABRT)
 #define OCTAVE_MEMORY_EXHAUSTED_ERROR SIGABRT
 #else
 #define OCTAVE_MEMORY_EXHAUSTED_ERROR (-1)
 #endif
 
-void
-octave_save_signal_mask (void)
-{
-#if defined (HAVE_POSIX_SIGNALS)
-  sigprocmask (0, 0, &octave_signal_mask);
-#endif
-}
-
-void
-octave_restore_signal_mask (void)
-{
-#if defined (HAVE_POSIX_SIGNALS)
-  sigprocmask (SIG_SETMASK, &octave_signal_mask, 0);
-#endif
-}
-
 static void
 my_friendly_exit (const char *sig_name, int sig_number)
 {
   static bool been_there_done_that = false;
 
   if (been_there_done_that)
     {
 #if defined (SIGABRT)
@@ -155,17 +128,17 @@ my_friendly_exit (const char *sig_name, 
 
 static void
 octave_new_handler (void)
 {
   std::cerr << "error: memory exhausted -- trying to return to prompt\n";
 
   if (can_interrupt)
     {
-      jump_to_top_level ();
+      OCTAVE_JUMP_TO_TOP_LEVEL;
       panic_impossible ();
     }
   else
     my_friendly_exit ("operator new", OCTAVE_MEMORY_EXHAUSTED_ERROR);
 }
 
 sig_handler *
 octave_set_signal_handler (int sig, sig_handler *handler)
@@ -263,17 +236,17 @@ sigfpe_handler (int /* sig */)
   MAYBE_ACK_SIGNAL (SIGFPE);
 
   MAYBE_REINSTALL_SIGHANDLER (SIGFPE, sigfpe_handler);
 
   std::cerr << "error: floating point exception -- trying to return to prompt\n";
 
   if (can_interrupt)
     {
-      jump_to_top_level ();
+      OCTAVE_OCTAVE_JUMP_TO_TOP_LEVEL;
       panic_impossible ();
     }
 
   SIGHANDLER_RETURN (0);
 }
 #endif /* defined(__alpha__) */
 #endif /* defined(SIGFPE) */
 
@@ -307,18 +280,25 @@ sigint_handler (int)
 #endif
 {
   MAYBE_ACK_SIGNAL (sig);
 
   MAYBE_REINSTALL_SIGHANDLER (sig, sigint_handler);
 
   if (can_interrupt)
     {
-      jump_to_top_level ();
+#if defined (USE_EXCEPTIONS_FOR_INTERRUPTS)
+      octave_interrupt_state = 1;
+
+      if (octave_interrupt_immediately)
+	octave_jump_to_enclosing_context ();
+#else
+      OCTAVE_JUMP_TO_TOP_LEVEL;
       panic_impossible ();
+#endif
     }
 
   SIGHANDLER_RETURN (0);
 }
 
 #ifdef SIGPIPE
 static RETSIGTYPE
 sigpipe_handler (int /* sig */)
@@ -328,17 +308,17 @@ sigpipe_handler (int /* sig */)
   MAYBE_REINSTALL_SIGHANDLER (SIGPIPE, sigpipe_handler);
 
   if (pipe_handler_error_count++ == 0)
     std::cerr << "warning: broken pipe\n";
 
   // Don't loop forever on account of this.
 
   if (pipe_handler_error_count  > 100)
-    jump_to_top_level ();
+    OCTAVE_JUMP_TO_TOP_LEVEL;
 
   SIGHANDLER_RETURN (0);
 }
 #endif /* defined(SIGPIPE) */
 
 octave_interrupt_handler
 octave_catch_interrupts (void)
 {
diff --git a/src/sighandlers.h b/src/sighandlers.h
--- a/src/sighandlers.h
+++ b/src/sighandlers.h
@@ -98,20 +98,16 @@ extern void install_signal_handlers (voi
 
 extern octave_interrupt_handler octave_catch_interrupts (void);
 
 extern octave_interrupt_handler octave_ignore_interrupts (void);
 
 extern octave_interrupt_handler
 octave_set_interrupt_handler (const volatile octave_interrupt_handler&);
 
-extern void octave_save_signal_mask (void);
-
-extern void octave_restore_signal_mask (void);
-
 // extern void ignore_sigchld (void);
 
 // Maybe this should be in a separate file?
 
 class
 octave_child
 {
 public:
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -34,27 +34,23 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
 
-// Include setjmp.h, not csetjmp since the latter might only define
-// the ANSI standard C interface.
-
-#include <setjmp.h>
-
 #include "cmd-edit.h"
 #include "file-ops.h"
 #include "lo-error.h"
 #include "lo-mappers.h"
 #include "lo-sstream.h"
 #include "oct-env.h"
+#include "quit.h"
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "defun.h"
 #include "error.h"
 #include "file-io.h"
 #include "input.h"
 #include "lex.h"
@@ -86,94 +82,105 @@ static bool quitting_gracefully = false;
 tree_statement_list *global_command = 0;
 
 // Pointer to function that is currently being evaluated.
 octave_user_function *curr_function = 0;
 
 // Original value of TEXMFDBS environment variable.
 std::string octave_original_texmfdbs;
 
-// Top level context (?)
-jmp_buf toplevel;
-
 int
 main_loop (void)
 {
-  // Allow the user to interrupt us without exiting.
-
   octave_save_signal_mask ();
 
-  if (setjmp (toplevel) != 0)
+  if (octave_set_current_context)
     {
+#if defined (USE_EXCEPTIONS_FOR_INTERRUPTS)
+      panic_impossible ();
+#else
+      unwind_protect::run_all ();
       raw_mode (0);
-
       std::cout << "\n";
-
       octave_restore_signal_mask ();
+#endif
     }
 
   can_interrupt = true;
 
   octave_catch_interrupts ();
 
   // The big loop.
 
-  int retval;
+  int retval = 0;
   do
     {
-      curr_sym_tab = top_level_sym_tab;
-
-      reset_parser ();
-
-      retval = yyparse ();
-
-      if (retval == 0)
+      OCTAVE_TRY_WITH_INTERRUPTS
 	{
-	  if (global_command)
-	    {
-	      global_command->eval ();
+	  curr_sym_tab = top_level_sym_tab;
 
-	      delete global_command;
+	  reset_parser ();
 
-	      global_command = 0;
+	  retval = yyparse ();
 
-	      if (! (interactive || forced_interactive))
+	  if (retval == 0)
+	    {
+	      if (global_command)
 		{
-		  bool quit = (tree_return_command::returning
-			       || tree_break_command::breaking);
-
-		  if (tree_return_command::returning)
-		    tree_return_command::returning = 0;
+		  global_command->eval ();
 
-		  if (tree_break_command::breaking)
-		    tree_break_command::breaking--;
+		  delete global_command;
 
-		  if (quit)
-		    break;
-		}
+		  global_command = 0;
 
-	      if (error_state)
-		{
 		  if (! (interactive || forced_interactive))
 		    {
-		      // We should exit with a non-zero status.
-		      retval = 1;
-		      break;
+		      bool quit = (tree_return_command::returning
+				   || tree_break_command::breaking);
+
+		      if (tree_return_command::returning)
+			tree_return_command::returning = 0;
+
+		      if (tree_break_command::breaking)
+			tree_break_command::breaking--;
+
+		      if (quit)
+			break;
+		    }
+
+		  if (error_state)
+		    {
+		      if (! (interactive || forced_interactive))
+			{
+			  // We should exit with a non-zero status.
+			  retval = 1;
+			  break;
+			}
+		    }
+		  else
+		    {
+		      if (octave_completion_matches_called)
+			octave_completion_matches_called = false;	    
+		      else
+			command_editor::increment_current_command_number ();
 		    }
 		}
-	      else
-		{
-		  if (octave_completion_matches_called)
-		    octave_completion_matches_called = false;	    
-		  else
-		    command_editor::increment_current_command_number ();
-		}
+	      else if (parser_end_of_input)
+		break;
 	    }
-	  else if (parser_end_of_input)
-	    break;
+	}
+      OCTAVE_CATCH_INTERRUPTS
+	{
+	  unwind_protect::run_all ();
+	  can_interrupt = true;
+	  octave_interrupt_immediately = 0;
+	  octave_interrupt_state = 0;
+	  std::cout << "\n"; \
+	  octave_restore_signal_mask (); \
+	  octave_catch_interrupts ();
 	}
     }
   while (retval == 0);
 
   return retval;
 }
 
 // Fix up things before exiting.
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -95,26 +95,16 @@ valid_identifier (const char *s)
 }
 
 bool
 valid_identifier (const std::string& s)
 {
   return valid_identifier (s.c_str ());
 }
 
-// Return to the main command loop in octave.cc.
-
-void
-jump_to_top_level (void)
-{
-  unwind_protect::run_all ();
-
-  longjmp (toplevel, 1);
-}
-
 int
 almost_match (const std::string& std, const std::string& s, int min_match_len,
 	      int case_sens)
 {
   int stdlen = std.length ();
   int slen = s.length ();
 
   return (slen <= stdlen
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -32,18 +32,16 @@ Software Foundation, 59 Temple Place - S
 
 class octave_value;
 class octave_value_list;
 class string_vector;
 
 extern bool valid_identifier (const char *s);
 extern bool valid_identifier (const std::string& s);
 
-extern void jump_to_top_level (void) GCC_ATTR_NORETURN;
-
 extern int almost_match (const std::string& std, const std::string& s,
 			 int min_match_len = 1, int case_sens = 1);
 
 extern int
 keyword_almost_match (const char * const *std, int *min_len,
 		      const std::string& s, int min_toks_to_match,
 		      int max_toks);
 
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -24,16 +24,17 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <cassert>
 
 #include "CMatrix.h"
 #include "dMatrix.h"
 #include "oct-cmplx.h"
+#include "quit.h"
 
 #include "error.h"
 #include "xdiv.h"
 
 static inline bool
 result_ok (int info)
 {
   assert (info != -1);
@@ -237,62 +238,74 @@ x_el_div (double a, const Matrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = a / b (i, j);
+      {
+	OCTAVE_QUIT;
+	result (i, j) = a / b (i, j);
+      }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (double a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = a / b (i, j);
+      {
+	OCTAVE_QUIT;
+	result (i, j) = a / b (i, j);
+      }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const Matrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = a / b (i, j);
+      {
+	OCTAVE_QUIT;
+	result (i, j) = a / b (i, j);
+      }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = a / b (i, j);
+      {
+	OCTAVE_QUIT;
+	result (i, j) = a / b (i, j);
+      }
 
   return result;
 }
 
 // Left division functions.
 //
 //       op2 \ op1:   m   cm
 //            +--   +---+----+
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -30,16 +30,17 @@ Software Foundation, 59 Temple Place - S
 #include "CColVector.h"
 #include "CDiagMatrix.h"
 #include "CMatrix.h"
 #include "EIG.h"
 #include "dDiagMatrix.h"
 #include "dMatrix.h"
 #include "mx-cm-cdm.h"
 #include "oct-cmplx.h"
+#include "quit.h"
 
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "xpow.h"
 
 static inline int
 xisint (double x)
@@ -495,26 +496,32 @@ elem_xpow (double a, const Matrix& b)
   double d1, d2;
 
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result (i, j) = pow (atmp, b (i, j));
+	  {
+	    OCTAVE_QUIT;
+	    result (i, j) = pow (atmp, b (i, j));
+	  }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result (i, j) = pow (a, b (i, j)); 
+	  {
+	    OCTAVE_QUIT;
+	    result (i, j) = pow (a, b (i, j));
+	  }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 2 -*-
@@ -523,17 +530,20 @@ elem_xpow (double a, const ComplexMatrix
 {
   int nr = b.rows ();
   int nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
   Complex atmp (a);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = pow (atmp, b (i, j));
+      {
+	OCTAVE_QUIT;
+	result (i, j) = pow (atmp, b (i, j));
+      }
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
 elem_xpow (const Matrix& a, double b)
 {
@@ -543,28 +553,32 @@ elem_xpow (const Matrix& a, double b)
   int nc = a.cols ();
 
   if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       ComplexMatrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
+	    OCTAVE_QUIT;
 	    Complex atmp (a (i, j));
 	    result (i, j) = pow (atmp, b);
 	  }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result (i, j) = pow (a (i, j), b);
+	  {
+	    OCTAVE_QUIT;
+	    result (i, j) = pow (a (i, j), b);
+	  }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 4 -*-
@@ -584,16 +598,17 @@ elem_xpow (const Matrix& a, const Matrix
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   int convert_to_complex = 0;
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
+	OCTAVE_QUIT;
 	double atmp = a (i, j);
 	double btmp = b (i, j);
 	if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
 	  {
 	    convert_to_complex = 1;
 	    goto done;
 	  }
       }
@@ -602,30 +617,34 @@ done:
 
   if (convert_to_complex)
     {
       ComplexMatrix complex_result (nr, nc);
 
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
+	    OCTAVE_QUIT;
 	    Complex atmp (a (i, j));
 	    Complex btmp (b (i, j));
 	    complex_result (i, j) = pow (atmp, btmp);
 	  }
 
       retval = complex_result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result (i, j) = pow (a (i, j), b (i, j));
+	  {
+	    OCTAVE_QUIT;
+	    result (i, j) = pow (a (i, j), b (i, j));
+	  }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 5 -*-
@@ -633,17 +652,20 @@ octave_value
 elem_xpow (const Matrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = pow (Complex (a (i, j)), b);
+      {
+	OCTAVE_QUIT;
+	result (i, j) = pow (Complex (a (i, j)), b);
+      }
 
   return result;
 }
 
 // -*- 6 -*-
 octave_value
 elem_xpow (const Matrix& a, const ComplexMatrix& b)
 {
@@ -657,32 +679,36 @@ elem_xpow (const Matrix& a, const Comple
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = pow (Complex (a (i, j)), b (i, j));
+      {
+	OCTAVE_QUIT;
+	result (i, j) = pow (Complex (a (i, j)), b (i, j));
+      }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const Complex& a, const Matrix& b)
 {
   int nr = b.rows ();
   int nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
+	OCTAVE_QUIT;
 	double btmp = b (i, j);
 	if (xisint (btmp))
 	  result (i, j) = pow (a, static_cast<int> (btmp));
 	else
 	  result (i, j) = pow (a, btmp);
       }
 
   return result;
@@ -693,17 +719,20 @@ octave_value
 elem_xpow (const Complex& a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = pow (a, b (i, j));
+      {
+	OCTAVE_QUIT;
+	result (i, j) = pow (a, b (i, j));
+      }
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, double b)
 {
@@ -711,23 +740,29 @@ elem_xpow (const ComplexMatrix& a, doubl
   int nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
 
   if (xisint (b))
     {
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result (i, j) = pow (a (i, j), static_cast<int> (b));
+	  {
+	    OCTAVE_QUIT;
+	    result (i, j) = pow (a (i, j), static_cast<int> (b));
+	  }
     }
   else
     {
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result (i, j) = pow (a (i, j), b);
+	  {
+	    OCTAVE_QUIT;
+	    result (i, j) = pow (a (i, j), b);
+	  }
     }
 
   return result;
 }
 
 // -*- 10 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const Matrix& b)
@@ -743,16 +778,17 @@ elem_xpow (const ComplexMatrix& a, const
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
+	OCTAVE_QUIT;
 	double btmp = b (i, j);
 	if (xisint (btmp))
 	  result (i, j) = pow (a (i, j), static_cast<int> (btmp));
 	else
 	  result (i, j) = pow (a (i, j), btmp);
       }
 
   return result;
@@ -763,17 +799,20 @@ octave_value
 elem_xpow (const ComplexMatrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = pow (a (i, j), b);
+      {
+	OCTAVE_QUIT;
+	result (i, j) = pow (a (i, j), b);
+      }
 
   return result;
 }
 
 // -*- 12 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const ComplexMatrix& b)
 {
@@ -787,17 +826,20 @@ elem_xpow (const ComplexMatrix& a, const
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result (i, j) = pow (a (i, j), b (i, j));
+      {
+	OCTAVE_QUIT;
+	result (i, j) = pow (a (i, j), b (i, j));
+      }
 
   return result;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
