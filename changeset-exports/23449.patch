# HG changeset patch
# User Rik <rik@octave.org>
# Date 1493331500 25200
#      Thu Apr 27 15:18:20 2017 -0700
# Node ID c763214a82603262a0ee08a419c609b8a2d4c257
# Parent  e1c02e7126a9bc9acc065f48973c9bb8a429a762
maint: Use convention 'int *x' for naming pointers.

* mycell.c, myfeval.c, mypow2.c, myprop.c, myset.c, mystruct.c, Backend.cc,
Backend.h, BaseControl.cc, BaseControl.h, ButtonControl.cc, ButtonControl.h,
ButtonGroup.cc, ButtonGroup.h, Canvas.cc, Canvas.h, CheckBoxControl.cc,
CheckBoxControl.h, Container.cc, Container.h, ContextMenu.cc, ContextMenu.h,
EditControl.cc, EditControl.h, Figure.cc, Figure.h, FigureWindow.cc,
FigureWindow.h, GLCanvas.cc, GLCanvas.h, GenericEventNotify.h,
ListBoxControl.cc, ListBoxControl.h, Logger.cc, Logger.h, Menu.cc, Menu.h,
MenuContainer.h, MouseModeActionGroup.cc, MouseModeActionGroup.h, Object.cc,
Object.h, ObjectFactory.cc, ObjectFactory.h, ObjectProxy.cc, ObjectProxy.h,
Panel.cc, Panel.h, PopupMenuControl.cc, PopupMenuControl.h,
PushButtonControl.cc, PushButtonControl.h, PushTool.cc, PushTool.h,
QtHandlesUtils.cc, QtHandlesUtils.h, RadioButtonControl.cc,
RadioButtonControl.h, SliderControl.cc, SliderControl.h, TextControl.cc,
TextControl.h, TextEdit.cc, TextEdit.h, ToggleButtonControl.cc,
ToggleButtonControl.h, ToggleTool.cc, ToggleTool.h, ToolBar.cc, ToolBar.h,
ToolBarButton.cc, ToolBarButton.h, color-picker.cc, file-editor-tab.cc,
file-editor.cc, file-editor.h, find-dialog.cc, find-dialog.h,
octave-qscintilla.cc, main-window.cc, main-window.h, octave-cmd.cc,
octave-dock-widget.cc, parser.cc, shortcut-manager.cc, workspace-view.cc,
__ichol__.cc, __ilu__.cc, __magick_read__.cc, c-file-ptr-stream.cc,
c-file-ptr-stream.h, cellfun.cc, data.cc, gl2ps-print.cc, graphics.cc,
graphics.in.h, ls-hdf5.cc, ls-hdf5.h, ls-mat5.cc, mex.h, oct-map.cc, oct-map.h,
oct-stream.cc, octave-link.cc, profiler.cc, profiler.h, psi.cc, qz.cc,
sighandlers.cc, symtab.h, txt-eng.h, zfstream.cc, zfstream.h, __init_fltk__.cc,
audiodevinfo.cc, gzip.cc, ov-class.cc, ov-classdef.cc, ov-classdef.h,
ov-dld-fcn.h, ov-fcn-inline.cc, ov-java.cc, ov-java.h, ov.cc, pt-arg-list.cc,
pt-array-list.cc, pt-bp.cc, pt-check.cc, pt-classdef.h, pt-decl.cc, pt-eval.cc,
pt-idx.cc, pt-idx.h, pt-jit.cc, pt-misc.cc, pt-pr-code.cc, pt-select.cc,
pt-stmt.cc, Array.cc, Array.h, CMatrix.cc, MSparse.cc, Sparse.h, dMatrix.cc,
dim-vector.h, fCMatrix.cc, fMatrix.cc, CollocWt.cc, bsxfun-defs.cc,
eigs-base.cc, gsvd.cc, gsvd.h, lo-lapack-proto.h, oct-norm.cc, randmtzig.cc,
svd.cc, svd.h, mx-inlines.cc, oct-binmap.h, oct-sort.cc, oct-sort.h,
oct-string.cc, oct-string.h, sparse-sort.cc, sparse-sort.h:
Use convention 'int *x' for naming pointers.

diff --git a/examples/code/mycell.c b/examples/code/mycell.c
--- a/examples/code/mycell.c
+++ b/examples/code/mycell.c
@@ -1,13 +1,13 @@
 #include "mex.h"
 
 void
-mexFunction (int nlhs, mxArray* plhs[],
-             int nrhs, const mxArray* prhs[])
+mexFunction (int nlhs, mxArray *plhs[],
+             int nrhs, const mxArray *prhs[])
 {
   mwSize n;
   mwIndex i;
 
   if (nrhs != 1 || ! mxIsCell (prhs[0]))
     mexErrMsgTxt ("ARG1 must be a cell");
 
   n = mxGetNumberOfElements (prhs[0]);
diff --git a/examples/code/myfeval.c b/examples/code/myfeval.c
--- a/examples/code/myfeval.c
+++ b/examples/code/myfeval.c
@@ -1,13 +1,13 @@
 #include "mex.h"
 
 void
-mexFunction (int nlhs, mxArray* plhs[],
-             int nrhs, const mxArray* prhs[])
+mexFunction (int nlhs, mxArray *plhs[],
+             int nrhs, const mxArray *prhs[])
 {
   char *str;
 
   mexPrintf ("Starting file myfeval.mex\n");
 
   mexPrintf ("I have %d inputs and %d outputs\n", nrhs, nlhs);
 
   if (nrhs < 1 || ! mxIsChar (prhs[0]))
diff --git a/examples/code/mypow2.c b/examples/code/mypow2.c
--- a/examples/code/mypow2.c
+++ b/examples/code/mypow2.c
@@ -1,13 +1,13 @@
 #include "mex.h"
 
 void
-mexFunction (int nlhs, mxArray* plhs[],
-             int nrhs, const mxArray* prhs[])
+mexFunction (int nlhs, mxArray *plhs[],
+             int nrhs, const mxArray *prhs[])
 {
   mwSize n;
   mwIndex i;
   double *vri, *vro;
 
   if (nrhs != 1 || ! mxIsDouble (prhs[0]))
     mexErrMsgTxt ("ARG1 must be a double matrix");
 
diff --git a/examples/code/myprop.c b/examples/code/myprop.c
--- a/examples/code/myprop.c
+++ b/examples/code/myprop.c
@@ -1,13 +1,13 @@
 #include "mex.h"
 
 void
-mexFunction (int nlhs, mxArray* plhs[],
-             int nrhs, const mxArray* prhs[])
+mexFunction (int nlhs, mxArray *plhs[],
+             int nrhs, const mxArray *prhs[])
 {
   double handle;
   char property[256];
 
   if (nrhs < 2 || nrhs > 3)
     mexErrMsgTxt ("incorrect number of arguments");
   if (! mxIsDouble (prhs[0]))
     mexErrMsgTxt ("handle must be a double scalar");
diff --git a/examples/code/myset.c b/examples/code/myset.c
--- a/examples/code/myset.c
+++ b/examples/code/myset.c
@@ -1,13 +1,13 @@
 #include "mex.h"
 
 void
-mexFunction (int nlhs, mxArray* plhs[],
-             int nrhs, const mxArray* prhs[])
+mexFunction (int nlhs, mxArray *plhs[],
+             int nrhs, const mxArray *prhs[])
 {
   char *str;
   mxArray *v;
   int found = 0;
 
   if (nrhs != 2 || ! mxIsChar (prhs[0]))
     mexErrMsgTxt ("Arguments must be a symbol name and a value");
 
diff --git a/examples/code/mystruct.c b/examples/code/mystruct.c
--- a/examples/code/mystruct.c
+++ b/examples/code/mystruct.c
@@ -1,13 +1,13 @@
 #include "mex.h"
 
 void
-mexFunction (int nlhs, mxArray* plhs[],
-             int nrhs, const mxArray* prhs[])
+mexFunction (int nlhs, mxArray *plhs[],
+             int nrhs, const mxArray *prhs[])
 {
   int i;
   mwIndex j;
   mxArray *v;
   const char *keys[] = { "this", "that" };
 
   if (nrhs != 1 || ! mxIsStruct (prhs[0]))
     mexErrMsgTxt ("ARG1 must be a struct");
diff --git a/libgui/graphics/Backend.cc b/libgui/graphics/Backend.cc
--- a/libgui/graphics/Backend.cc
+++ b/libgui/graphics/Backend.cc
@@ -67,17 +67,17 @@ namespace QtHandles
                  "of type %s", go.type ().c_str ());
 
     return "";
   }
 
   Backend::Backend (void)
     : QObject (), base_graphics_toolkit ("qt")
   {
-    ObjectFactory* factory = ObjectFactory::instance ();
+    ObjectFactory *factory = ObjectFactory::instance ();
 
     connect (this, SIGNAL (createObject (double)),
              factory, SLOT (createObject (double)));
   }
 
   Backend::~Backend (void)
   { }
 
@@ -92,17 +92,17 @@ namespace QtHandles
         || go.isa ("uicontextmenu")
         || go.isa ("uitoolbar")
         || go.isa ("uipushtool")
         || go.isa ("uitoggletool"))
       {
         Logger::debug ("Backend::initialize %s from thread %08x",
                        go.type ().c_str (), QThread::currentThreadId ());
 
-        ObjectProxy* proxy = new ObjectProxy ();
+        ObjectProxy *proxy = new ObjectProxy ();
         graphics_object gObj (go);
 
         OCTAVE_PTR_TYPE tmp (reinterpret_cast<OCTAVE_INTPTR_TYPE> (proxy));
         gObj.get_properties ().set (toolkitObjectProperty (go), tmp);
 
         emit createObject (go.get_handle ().value ());
 
         return true;
@@ -125,17 +125,17 @@ namespace QtHandles
         || pId == uipushtool::properties::ID___OBJECT__
         || pId == uitoggletool::properties::ID___OBJECT__
         || pId == base_properties::ID___MODIFIED__)
       return;
 
     Logger::debug ("Backend::update %s(%d) from thread %08x",
                    go.type ().c_str (), pId, QThread::currentThreadId ());
 
-    ObjectProxy* proxy = toolkitObjectProxy (go);
+    ObjectProxy *proxy = toolkitObjectProxy (go);
 
     if (proxy)
       {
         if (go.isa ("uicontrol")
             && pId == uicontrol::properties::ID_STYLE)
           {
             // Special case: we need to recreate the control widget
             // associated with the octave graphics_object
@@ -149,17 +149,17 @@ namespace QtHandles
   }
 
   void
   Backend::finalize (const graphics_object& go)
   {
     Logger::debug ("Backend::finalize %s from thread %08x",
                    go.type ().c_str (), QThread::currentThreadId ());
 
-    ObjectProxy* proxy = toolkitObjectProxy (go);
+    ObjectProxy *proxy = toolkitObjectProxy (go);
 
     if (proxy)
       {
         proxy->finalize ();
         delete proxy;
 
         graphics_object gObj (go);
 
@@ -167,43 +167,43 @@ namespace QtHandles
       }
   }
 
   void
   Backend::redraw_figure (const graphics_object& go) const
   {
     if (go.get_properties ().is_visible ())
       {
-        ObjectProxy* proxy = toolkitObjectProxy (go);
+        ObjectProxy *proxy = toolkitObjectProxy (go);
 
         if (proxy)
           proxy->redraw ();
       }
   }
 
   void
   Backend::print_figure (const graphics_object& go,
                          const std::string& term,
                          const std::string& file_cmd,
                          const std::string& /*debug_file*/) const
   {
     if (go.get_properties ().is_visible ())
       {
-        ObjectProxy* proxy = toolkitObjectProxy (go);
+        ObjectProxy *proxy = toolkitObjectProxy (go);
 
         if (proxy)
           proxy->print (QString::fromStdString (file_cmd),
                         QString::fromStdString (term));
       }
   }
 
   Object*
   Backend::toolkitObject (const graphics_object& go)
   {
-    ObjectProxy* proxy = toolkitObjectProxy (go);
+    ObjectProxy *proxy = toolkitObjectProxy (go);
 
     if (proxy)
       return proxy->object ();
 
     return 0;
   }
 
   ObjectProxy*
diff --git a/libgui/graphics/Backend.h b/libgui/graphics/Backend.h
--- a/libgui/graphics/Backend.h
+++ b/libgui/graphics/Backend.h
@@ -54,19 +54,19 @@ namespace QtHandles
 
     void finalize (const graphics_object& obj);
 
     void print_figure (const graphics_object& go,
                        const std::string& term,
                        const std::string& file_cmd,
                        const std::string& /*debug_file*/) const;
 
-    static Object* toolkitObject (const graphics_object& go);
+    static Object * toolkitObject (const graphics_object& go);
 
-    static ObjectProxy* toolkitObjectProxy (const graphics_object& go);
+    static ObjectProxy * toolkitObjectProxy (const graphics_object& go);
 
   signals:
     void createObject (double handle);
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/BaseControl.cc b/libgui/graphics/BaseControl.cc
--- a/libgui/graphics/BaseControl.cc
+++ b/libgui/graphics/BaseControl.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "BaseControl.h"
 #include "ContextMenu.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   static void
-  updatePalette (const uicontrol::properties& props, QWidget* w)
+  updatePalette (const uicontrol::properties& props, QWidget *w)
   {
     QPalette p = w->palette ();
 
     if (props.style_is ("edit")
         || props.style_is ("listbox"))
       {
         p.setColor (QPalette::Base,
                     Utils::fromRgb (props.get_backgroundcolor_rgb ()));
@@ -83,24 +83,24 @@ namespace QtHandles
                     Utils::fromRgb (props.get_backgroundcolor_rgb ()));
         p.setColor (QPalette::WindowText,
                     Utils::fromRgb (props.get_foregroundcolor_rgb ()));
       }
 
     w->setPalette (p);
   }
 
-  BaseControl::BaseControl (const graphics_object& go, QWidget* w)
+  BaseControl::BaseControl (const graphics_object& go, QWidget *w)
     : Object (go, w), m_normalizedFont (false), m_keyPressHandlerDefined (false)
   {
     init (w);
   }
 
   void
-  BaseControl::init (QWidget* w, bool callBase)
+  BaseControl::init (QWidget *w, bool callBase)
   {
     if (callBase)
       Object::init (w, callBase);
 
     uicontrol::properties& up = properties<uicontrol> ();
 
     Matrix bb = up.get_boundingbox (false);
     w->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
@@ -119,17 +119,17 @@ namespace QtHandles
 
   BaseControl::~BaseControl (void)
   { }
 
   void
   BaseControl::update (int pId)
   {
     uicontrol::properties& up = properties<uicontrol> ();
-    QWidget* w = qWidget<QWidget> ();
+    QWidget *w = qWidget<QWidget> ();
 
     switch (pId)
       {
       case uicontrol::properties::ID_POSITION:
         {
           Matrix bb = up.get_boundingbox (false);
           w->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
                           octave::math::round (bb(2)), octave::math::round (bb(3)));
@@ -172,17 +172,17 @@ namespace QtHandles
         break;
 
       default:
         break;
       }
   }
 
   bool
-  BaseControl::eventFilter (QObject* watched, QEvent* xevent)
+  BaseControl::eventFilter (QObject *watched, QEvent *xevent)
   {
     switch (xevent->type ())
       {
       case QEvent::Resize:
         if (m_normalizedFont)
           {
             gh_manager::auto_lock lock;
 
diff --git a/libgui/graphics/BaseControl.h b/libgui/graphics/BaseControl.h
--- a/libgui/graphics/BaseControl.h
+++ b/libgui/graphics/BaseControl.h
@@ -29,25 +29,25 @@ class QEvent;
 class QObject;
 
 namespace QtHandles
 {
 
   class BaseControl : public Object
   {
   public:
-    BaseControl (const graphics_object& go, QWidget* w);
+    BaseControl (const graphics_object& go, QWidget *w);
     ~BaseControl (void);
 
-    Container* innerContainer (void) { return 0; }
+    Container * innerContainer (void) { return 0; }
 
-    bool eventFilter (QObject* watched, QEvent* e);
+    bool eventFilter (QObject *watched, QEvent *e);
 
   protected:
-    void init (QWidget* w, bool callBase = false);
+    void init (QWidget *w, bool callBase = false);
     void update (int pId);
 
   private:
     bool m_normalizedFont;
     bool m_keyPressHandlerDefined;
   };
 
 }
diff --git a/libgui/graphics/ButtonControl.cc b/libgui/graphics/ButtonControl.cc
--- a/libgui/graphics/ButtonControl.cc
+++ b/libgui/graphics/ButtonControl.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include "ButtonControl.h"
 #include "ButtonGroup.h"
 #include "Container.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-  ButtonControl::ButtonControl (const graphics_object& go, QAbstractButton* btn)
+  ButtonControl::ButtonControl (const graphics_object& go, QAbstractButton *btn)
     : BaseControl (go, btn), m_blockCallback (false)
   {
     uicontrol::properties& up = properties<uicontrol> ();
 
     QString str = Utils::fromStdString (up.get_string_string ());
     str.replace ("&", "&&");
     btn->setText (str);
     if (btn->isCheckable () || up.style_is ("togglebutton"))
@@ -58,17 +58,17 @@ namespace QtHandles
 
   ButtonControl::~ButtonControl (void)
   { }
 
   void
   ButtonControl::update (int pId)
   {
     uicontrol::properties& up = properties<uicontrol> ();
-    QAbstractButton* btn = qWidget<QAbstractButton> ();
+    QAbstractButton *btn = qWidget<QAbstractButton> ();
 
     switch (pId)
       {
       case uicontrol::properties::ID_STRING:
         {
           QString str = Utils::fromStdString (up.get_string_string ());
           str.replace ("&", "&&");
           btn->setText (str);
@@ -87,19 +87,19 @@ namespace QtHandles
 
                 if (dValue != 0.0 && dValue != 1.0)
                   warning ("button value not within valid display range");
                 else if (dValue == up.get_min () && btn->isChecked ())
                   {
                     btn->setChecked (false);
                     if (up.style_is ("radiobutton") || up.style_is ("togglebutton"))
                       {
-                        Object* parent = Object::parentObject (gh_manager::get_object (
+                        Object *parent = Object::parentObject (gh_manager::get_object (
                             up.get___myhandle__ ()));
-                        ButtonGroup* btnGroup = dynamic_cast<ButtonGroup *>(parent);
+                        ButtonGroup *btnGroup = dynamic_cast<ButtonGroup *>(parent);
                         if (btnGroup)
                           btnGroup->selectNothing ();
                       }
                   }
                 else if (dValue == up.get_max () && ! btn->isChecked ())
                   btn->setChecked (true);
               }
           }
@@ -110,17 +110,17 @@ namespace QtHandles
         BaseControl::update (pId);
         break;
       }
   }
 
   void
   ButtonControl::toggled (bool checked)
   {
-    QAbstractButton* btn = qWidget<QAbstractButton> ();
+    QAbstractButton *btn = qWidget<QAbstractButton> ();
 
     if (! m_blockCallback && btn->isCheckable ())
       {
         gh_manager::auto_lock lock;
 
         uicontrol::properties& up = properties<uicontrol> ();
 
         Matrix oldValue = up.get_value ().matrix_value ();
@@ -130,15 +130,15 @@ namespace QtHandles
           gh_manager::post_set (m_handle, "value", newValue, false);
         gh_manager::post_callback (m_handle, "callback");
       }
   }
 
   void
   ButtonControl::clicked (void)
   {
-    QAbstractButton* btn = qWidget<QAbstractButton> ();
+    QAbstractButton *btn = qWidget<QAbstractButton> ();
 
     if (! btn->isCheckable ())
       gh_manager::post_callback (m_handle, "callback");
   }
 
 };
diff --git a/libgui/graphics/ButtonControl.h b/libgui/graphics/ButtonControl.h
--- a/libgui/graphics/ButtonControl.h
+++ b/libgui/graphics/ButtonControl.h
@@ -30,17 +30,17 @@ class QAbstractButton;
 namespace QtHandles
 {
 
   class ButtonControl : public BaseControl
   {
     Q_OBJECT
 
   public:
-    ButtonControl (const graphics_object& go, QAbstractButton* btn);
+    ButtonControl (const graphics_object& go, QAbstractButton *btn);
     ~ButtonControl (void);
 
   protected:
     void update (int pId);
 
   private slots:
     void clicked (void);
     void toggled (bool checked);
diff --git a/libgui/graphics/ButtonGroup.cc b/libgui/graphics/ButtonGroup.cc
--- a/libgui/graphics/ButtonGroup.cc
+++ b/libgui/graphics/ButtonGroup.cc
@@ -90,34 +90,34 @@ namespace QtHandles
       }
 
     return bw;
   }
 
   ButtonGroup*
   ButtonGroup::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        Container* container = parent->innerContainer ();
+        Container *container = parent->innerContainer ();
 
         if (container)
           {
-            QFrame* frame = new QFrame (container);
+            QFrame *frame = new QFrame (container);
             return new ButtonGroup (go, new QButtonGroup (frame), frame);
           }
       }
 
     return 0;
   }
 
-  ButtonGroup::ButtonGroup (const graphics_object& go, QButtonGroup* buttongroup,
-                            QFrame* frame)
+  ButtonGroup::ButtonGroup (const graphics_object& go, QButtonGroup *buttongroup,
+                            QFrame *frame)
     : Object (go, frame), m_hiddenbutton(0), m_container (0), m_title (0),
       m_blockUpdates (false)
   {
     uibuttongroup::properties& pp = properties<uibuttongroup> ();
 
     frame->setObjectName ("UIButtonGroup");
     frame->setAutoFillBackground (true);
     Matrix bb = pp.get_boundingbox (false);
@@ -133,19 +133,19 @@ namespace QtHandles
     m_hiddenbutton->hide ();
     m_buttongroup->addButton (m_hiddenbutton);
 
     m_container = new Container (frame);
     m_container->canvas (m_handle);
 
     if (frame->hasMouseTracking ())
       {
-        foreach (QWidget* w, frame->findChildren<QWidget*> ())
+        foreach (QWidget *w, frame->findChildren<QWidget*> ())
           w->setMouseTracking (true);
-        foreach (QWidget* w, buttongroup->findChildren<QWidget*> ())
+        foreach (QWidget *w, buttongroup->findChildren<QWidget*> ())
           w->setMouseTracking (true);
       }
 
     QString title = Utils::fromStdString (pp.get_title ());
     if (! title.isEmpty ())
       {
         m_title = new QLabel (title, frame);
         m_title->setAutoFillBackground (true);
@@ -168,17 +168,17 @@ namespace QtHandles
     connect (m_buttongroup, SIGNAL (buttonClicked (QAbstractButton*)),
              SLOT (buttonClicked (QAbstractButton*)));
   }
 
   ButtonGroup::~ButtonGroup (void)
   { }
 
   bool
-  ButtonGroup::eventFilter (QObject* watched, QEvent* xevent)
+  ButtonGroup::eventFilter (QObject *watched, QEvent *xevent)
   {
     if (! m_blockUpdates)
       {
         if (watched == qObject ())
           {
             switch (xevent->type ())
               {
               case QEvent::Resize:
@@ -190,31 +190,31 @@ namespace QtHandles
                     {
                       if (m_title)
                         {
                           const uibuttongroup::properties& pp =
                             Utils::properties<uibuttongroup> (go);
 
                           if (pp.fontunits_is ("normalized"))
                             {
-                              QFrame* frame = qWidget<QFrame> ();
+                              QFrame *frame = qWidget<QFrame> ();
 
                               m_title->setFont (Utils::computeFont<uibuttongroup>
                                                 (pp, frame->height ()));
                               m_title->resize (m_title->sizeHint ());
                             }
                         }
                       updateLayout ();
                     }
                 }
                 break;
 
               case QEvent::MouseButtonPress:
                 {
-                  QMouseEvent* m = dynamic_cast<QMouseEvent *> (xevent);
+                  QMouseEvent *m = dynamic_cast<QMouseEvent *> (xevent);
 
                   if (m->button () == Qt::RightButton)
                     {
                       gh_manager::auto_lock lock;
 
                       ContextMenu::executeAt (properties (), m->globalPos ());
                     }
                 }
@@ -245,17 +245,17 @@ namespace QtHandles
 
     return false;
   }
 
   void
   ButtonGroup::update (int pId)
   {
     uibuttongroup::properties& pp = properties<uibuttongroup> ();
-    QFrame* frame = qWidget<QFrame> ();
+    QFrame *frame = qWidget<QFrame> ();
 
     m_blockUpdates = true;
 
     switch (pId)
       {
       case uibuttongroup::properties::ID_POSITION:
         {
           Matrix bb = pp.get_boundingbox (false);
@@ -344,20 +344,20 @@ namespace QtHandles
         updateLayout ();
         break;
 
       case uibuttongroup::properties::ID_SELECTEDOBJECT:
         {
           graphics_handle h = pp.get_selectedobject ();
           gh_manager::auto_lock lock;
           graphics_object go = gh_manager::get_object (h);
-          Object* selectedObject = Backend::toolkitObject (go);
-          ToggleButtonControl* toggle = static_cast<ToggleButtonControl *>
+          Object *selectedObject = Backend::toolkitObject (go);
+          ToggleButtonControl *toggle = static_cast<ToggleButtonControl *>
                                         (selectedObject);
-          RadioButtonControl* radio = static_cast<RadioButtonControl *>(selectedObject);
+          RadioButtonControl *radio = static_cast<RadioButtonControl *>(selectedObject);
           if (toggle)
             {
               go.get_properties ().set ("value", 1);
             }
           else if (radio)
             {
               go.get_properties ().set ("value", 1);
             }
@@ -373,27 +373,27 @@ namespace QtHandles
       }
 
     m_blockUpdates = false;
   }
 
   void
   ButtonGroup::redraw (void)
   {
-    Canvas* canvas = m_container->canvas (m_handle);
+    Canvas *canvas = m_container->canvas (m_handle);
 
     if (canvas)
       canvas->redraw ();
   }
 
   void
   ButtonGroup::updateLayout (void)
   {
     uibuttongroup::properties& pp = properties<uibuttongroup> ();
-    QFrame* frame = qWidget<QFrame> ();
+    QFrame *frame = qWidget<QFrame> ();
 
     Matrix bb = pp.get_boundingbox (true);
     int bw = borderWidthFromProperties (pp);
 
     frame->setFrameRect (QRect (octave::math::round (bb(0)) - bw,
                                 octave::math::round (bb(1)) - bw,
                                 octave::math::round (bb(2)) + 2*bw, octave::math::round (bb(3)) + 2*bw));
     m_container->setGeometry (octave::math::round (bb(0)),
@@ -428,60 +428,60 @@ namespace QtHandles
   void
   ButtonGroup::selectNothing (void)
   {
     m_hiddenbutton->setChecked (true);
   }
 
 
   void
-  ButtonGroup::addButton (QAbstractButton* btn)
+  ButtonGroup::addButton (QAbstractButton *btn)
   {
     m_buttongroup->addButton (btn);
     connect (btn, SIGNAL (toggled (bool)), SLOT (buttonToggled (bool)));
   }
 
   void
   ButtonGroup::buttonToggled (bool toggled)
   {
     Q_UNUSED (toggled);
     if (! m_blockUpdates)
       {
         gh_manager::auto_lock lock;
         uibuttongroup::properties& bp = properties<uibuttongroup> ();
 
         graphics_handle oldValue = bp.get_selectedobject ();
 
-        QAbstractButton* checkedBtn = m_buttongroup->checkedButton ();
+        QAbstractButton *checkedBtn = m_buttongroup->checkedButton ();
 
         graphics_handle newValue = graphics_handle ();
         if (checkedBtn != m_hiddenbutton)
           {
-            Object* checkedObj = Object::fromQObject (checkedBtn);
+            Object *checkedObj = Object::fromQObject (checkedBtn);
             newValue = checkedObj->properties ().get___myhandle__ ();
           }
 
         if (oldValue != newValue)
           gh_manager::post_set (m_handle, "selectedobject", newValue.as_octave_value (),
                                 false);
       }
   }
 
   void
-  ButtonGroup::buttonClicked (QAbstractButton* btn)
+  ButtonGroup::buttonClicked (QAbstractButton *btn)
   {
     Q_UNUSED (btn);
 
     gh_manager::auto_lock lock;
     uibuttongroup::properties& bp = properties<uibuttongroup> ();
 
     graphics_handle oldValue = bp.get_selectedobject ();
 
-    QAbstractButton* checkedBtn = m_buttongroup->checkedButton ();
-    Object* checkedObj = Object::fromQObject (checkedBtn);
+    QAbstractButton *checkedBtn = m_buttongroup->checkedButton ();
+    Object *checkedObj = Object::fromQObject (checkedBtn);
     graphics_handle newValue = checkedObj->properties ().get___myhandle__ ();
 
     if (oldValue != newValue)
       {
         octave_scalar_map eventData;
         eventData.setfield ("OldValue", oldValue.as_octave_value ());
         eventData.setfield ("NewValue", newValue.as_octave_value ());
         eventData.setfield ("Source", bp.get___myhandle__ ().as_octave_value ());
diff --git a/libgui/graphics/ButtonGroup.h b/libgui/graphics/ButtonGroup.h
--- a/libgui/graphics/ButtonGroup.h
+++ b/libgui/graphics/ButtonGroup.h
@@ -36,44 +36,44 @@ namespace QtHandles
 
   class Container;
 
   class ButtonGroup : public Object
   {
     Q_OBJECT
 
   public:
-    ButtonGroup (const graphics_object& go, QButtonGroup* buttongroup,
-                 QFrame* frame);
+    ButtonGroup (const graphics_object& go, QButtonGroup *buttongroup,
+                 QFrame *frame);
     ~ButtonGroup (void);
 
-    Container* innerContainer (void) { return m_container; }
+    Container * innerContainer (void) { return m_container; }
 
-    bool eventFilter (QObject* watched, QEvent* event);
+    bool eventFilter (QObject *watched, QEvent *event);
 
-    static ButtonGroup* create (const graphics_object& go);
+    static ButtonGroup * create (const graphics_object& go);
 
-    void addButton (QAbstractButton* btn);
+    void addButton (QAbstractButton *btn);
 
     void selectNothing (void);
 
   protected:
     void update (int pId);
     void redraw (void);
 
   private slots:
     void buttonToggled (bool toggled);
-    void buttonClicked (QAbstractButton* btn);
+    void buttonClicked (QAbstractButton *btn);
 
   private:
     void updateLayout (void);
 
   private:
-    QButtonGroup* m_buttongroup;
-    QRadioButton* m_hiddenbutton;
-    Container* m_container;
-    QLabel* m_title;
+    QButtonGroup *m_buttongroup;
+    QRadioButton *m_hiddenbutton;
+    Container *m_container;
+    QLabel *m_title;
     bool m_blockUpdates;
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -117,17 +117,17 @@ namespace QtHandles
 
   /*
      Two updateCurrentPoint() routines are required:
      1) Used for QMouseEvents where cursor position data is in callback from Qt.
      2) Used for QKeyEvents where cursor position must be determined.
   */
   void
   Canvas::updateCurrentPoint (const graphics_object& fig,
-                              const graphics_object& obj, QMouseEvent* event)
+                              const graphics_object& obj, QMouseEvent *event)
   {
     gh_manager::auto_lock lock;
 
     gh_manager::post_set (fig.get_handle (), "currentpoint",
                           Utils::figureCurrentPoint (fig, event), false);
 
     Matrix children = obj.get_properties ().get_children ();
     octave_idx_type num_children = children.numel ();
@@ -367,17 +367,17 @@ namespace QtHandles
       = Utils::properties<figure> (figObj).get___zoom_mode__ ();
 
     octave_scalar_map zm = ov_zm.scalar_map_value ();
 
     return zm.contents ("Motion").string_value ();
   }
 
   void
-  Canvas::select_object (graphics_object obj, QMouseEvent* event,
+  Canvas::select_object (graphics_object obj, QMouseEvent *event,
                          graphics_object& currentObj, graphics_object& axesObj,
                          bool axes_only, std::vector<std::string> omit)
   {
     QList<graphics_object> axesList;
     Matrix children = obj.get_properties ().get_all_children ();
     octave_idx_type num_children = children.numel ();
 
     for (int i = 0; i < num_children; i++)
@@ -469,17 +469,17 @@ namespace QtHandles
 
             if (axesObj && currentObj)
               break;
           }
       }
   }
 
   void
-  Canvas::canvasMouseMoveEvent (QMouseEvent* event)
+  Canvas::canvasMouseMoveEvent (QMouseEvent *event)
   {
     gh_manager::auto_lock lock;
     graphics_object ax = gh_manager::get_object (m_mouseAxes);
 
     if (m_mouseMode != NoMode && (ax.valid_object () || m_mouseMode == TextMode))
       {
         switch (m_mouseMode)
           {
@@ -557,28 +557,28 @@ namespace QtHandles
         graphics_object currentObj, axesObj;
         std::vector<std::string> omit = {"legend", "colorbar", "scribeoverlay"};
         select_object (obj, event, currentObj, axesObj, true, omit);
 
         if (axesObj.valid_object ())
           {
             // FIXME: should we use signal/slot mechanism instead of
             //        directly calling parent fig methods
-            Figure* fig =
+            Figure *fig =
               dynamic_cast<Figure *> (Backend::toolkitObject (figObj));
             axes::properties& ap = Utils::properties<axes> (axesObj);
 
             if (fig)
               fig->updateStatusBar (ap.pixel2coord (event->x (), event->y ()));
           }
       }
   }
 
   void
-  Canvas::canvasMouseDoubleClickEvent (QMouseEvent* event)
+  Canvas::canvasMouseDoubleClickEvent (QMouseEvent *event)
   {
     // same processing as normal click, but event type is MouseButtonDblClick
     canvasMousePressEvent (event);
   }
 
   static double
   button_number (QMouseEvent *event)
   {
@@ -601,17 +601,17 @@ namespace QtHandles
       default:
         break;
       }
 
     return retval;
   }
 
   void
-  Canvas::canvasMousePressEvent (QMouseEvent* event)
+  Canvas::canvasMousePressEvent (QMouseEvent *event)
   {
     gh_manager::auto_lock lock;
     graphics_object obj = gh_manager::get_object (m_handle);
 
     bool isdblclick = (event->type () == QEvent::MouseButtonDblClick);
 
     if (obj.valid_object ())
       {
@@ -644,17 +644,17 @@ namespace QtHandles
 
         if (currentObj.get_properties ().handlevisibility_is ("on"))
           Utils::properties<figure> (figObj)
           .set_currentobject (currentObj.get_handle ().as_octave_value ());
         else
           Utils::properties<figure> (figObj).set_currentobject (
             octave::numeric_limits<double>::NaN ());
 
-        Figure* fig = dynamic_cast<Figure *> (Backend::toolkitObject (figObj));
+        Figure *fig = dynamic_cast<Figure *> (Backend::toolkitObject (figObj));
 
         MouseMode newMouseMode = NoMode;
 
         if (fig)
           newMouseMode = fig->mouseMode ();
 
         switch (newMouseMode)
           {
@@ -789,17 +789,17 @@ namespace QtHandles
           default:
             break;
           }
       }
 
   }
 
   void
-  Canvas::canvasMouseReleaseEvent (QMouseEvent* event)
+  Canvas::canvasMouseReleaseEvent (QMouseEvent *event)
   {
     if ((m_mouseMode == ZoomInMode || m_mouseMode == ZoomOutMode)
         && m_mouseAxes.ok ())
       {
         gh_manager::auto_lock lock;
         graphics_object ax = gh_manager::get_object (m_mouseAxes);
 
         if (ax.valid_object ())
@@ -888,17 +888,17 @@ namespace QtHandles
           }
       }
     m_rectMode = false;
     m_mouseAxes = graphics_handle ();
     m_mouseMode = NoMode;
   }
 
   void
-  Canvas::canvasWheelEvent (QWheelEvent* event)
+  Canvas::canvasWheelEvent (QWheelEvent *event)
   {
     gh_manager::auto_lock lock;
     graphics_object obj = gh_manager::get_object (m_handle);
 
     if (obj.valid_object ())
       {
         std::string mode;
 
@@ -924,17 +924,17 @@ namespace QtHandles
           }
 
         if (axesObj)
           {
             MouseMode newMouseMode = NoMode;
 
             graphics_object figObj (obj.get_ancestor ("figure"));
 
-            Figure* fig = dynamic_cast<Figure *> (Backend::toolkitObject (figObj));
+            Figure *fig = dynamic_cast<Figure *> (Backend::toolkitObject (figObj));
 
             if (fig)
               newMouseMode = fig->mouseMode ();
 
             if (axesObj.get_properties ().handlevisibility_is ("on"))
               {
                 Utils::properties<figure> (figObj)
                 .set_currentaxes (axesObj.get_handle ().as_octave_value ());
@@ -996,17 +996,17 @@ namespace QtHandles
 
             if (redrawFigure)
               redraw (false);
           }
       }
   }
 
   bool
-  Canvas::canvasKeyPressEvent (QKeyEvent* event)
+  Canvas::canvasKeyPressEvent (QKeyEvent *event)
   {
     if (m_eventMask & KeyPress)
       {
         gh_manager::auto_lock lock;
         graphics_object obj = gh_manager::get_object (m_handle);
 
         if (obj.valid_object ())
           {
@@ -1023,30 +1023,30 @@ namespace QtHandles
 
         return true;
       }
 
     return false;
   }
 
   bool
-  Canvas::canvasKeyReleaseEvent (QKeyEvent* event)
+  Canvas::canvasKeyReleaseEvent (QKeyEvent *event)
   {
     if (! event->isAutoRepeat () && (m_eventMask & KeyRelease))
       {
         gh_manager::post_callback (m_handle, "keyreleasefcn",
                                    Utils::makeKeyEventStruct (event));
 
         return true;
       }
 
     return false;
   }
 
   Canvas*
-  Canvas::create (const std::string& /* name */, QWidget* parent,
+  Canvas::create (const std::string& /* name */, QWidget *parent,
                   const graphics_handle& handle)
   {
     // Only OpenGL
     return new GLCanvas (parent, handle);
   }
 
 }
diff --git a/libgui/graphics/Canvas.h b/libgui/graphics/Canvas.h
--- a/libgui/graphics/Canvas.h
+++ b/libgui/graphics/Canvas.h
@@ -57,20 +57,20 @@ namespace QtHandles
     void print (const QString& file_cmd, const QString& term);
 
     void addEventMask (int m) { m_eventMask |= m; }
     void clearEventMask (int m) { m_eventMask &= (~m); }
     void setEventMask (int m) { m_eventMask = m; }
 
     void setCursor (MouseMode mode);
 
-    virtual QWidget* qWidget (void) = 0;
+    virtual QWidget * qWidget (void) = 0;
 
-    static Canvas* create (const std::string& name, QWidget* parent,
-                           const graphics_handle& handle);
+    static Canvas * create (const std::string& name, QWidget *parent,
+                            const graphics_handle& handle);
 
     virtual void toggleAxes (const graphics_handle& handle) = 0;
     virtual void toggleGrid (const graphics_handle& handle) = 0;
     virtual void autoAxes (const graphics_handle& handle) = 0;
 
   protected:
     virtual void draw (const graphics_handle& handle) = 0;
     virtual void drawZoomBox (const QPoint& p1, const QPoint& p2) = 0;
@@ -87,31 +87,31 @@ namespace QtHandles
         m_eventMask (0),
         m_rectMode (false)
     { }
 
     void canvasToggleAxes (const graphics_handle& handle);
     void canvasToggleGrid (const graphics_handle& handle);
     void canvasAutoAxes (const graphics_handle& handle);
     void canvasPaintEvent (void);
-    void canvasMouseDoubleClickEvent (QMouseEvent* event);
-    void canvasMouseMoveEvent (QMouseEvent* event);
-    void canvasMousePressEvent (QMouseEvent* event);
-    void canvasMouseReleaseEvent (QMouseEvent* event);
-    void canvasWheelEvent (QWheelEvent* event);
-    bool canvasKeyPressEvent (QKeyEvent* event);
-    bool canvasKeyReleaseEvent (QKeyEvent* event);
+    void canvasMouseDoubleClickEvent (QMouseEvent *event);
+    void canvasMouseMoveEvent (QMouseEvent *event);
+    void canvasMousePressEvent (QMouseEvent *event);
+    void canvasMouseReleaseEvent (QMouseEvent *event);
+    void canvasWheelEvent (QWheelEvent *event);
+    bool canvasKeyPressEvent (QKeyEvent *event);
+    bool canvasKeyReleaseEvent (QKeyEvent *event);
 
     void updateCurrentPoint (const graphics_object& fig,
                              const graphics_object& obj, QMouseEvent *event);
     void updateCurrentPoint (const graphics_object& fig,
                              const graphics_object& obj);
 
     void annotation_callback (const octave_value_list& args);
-    void select_object (graphics_object obj, QMouseEvent* event,
+    void select_object (graphics_object obj, QMouseEvent *event,
                         graphics_object& currentObj, graphics_object& axesObj,
                         bool axes_only = false,
                         std::vector<std::string> omit = std::vector<std::string> ());
 
   private:
     graphics_handle m_handle;
     bool m_redrawBlocked;
     MouseMode m_mouseMode;
diff --git a/libgui/graphics/CheckBoxControl.cc b/libgui/graphics/CheckBoxControl.cc
--- a/libgui/graphics/CheckBoxControl.cc
+++ b/libgui/graphics/CheckBoxControl.cc
@@ -30,30 +30,30 @@ along with Octave; see the file COPYING.
 #include "Container.h"
 
 namespace QtHandles
 {
 
   CheckBoxControl*
   CheckBoxControl::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        Container* container = parent->innerContainer ();
+        Container *container = parent->innerContainer ();
 
         if (container)
           return new CheckBoxControl (go, new QCheckBox (container));
       }
 
     return 0;
   }
 
-  CheckBoxControl::CheckBoxControl (const graphics_object& go, QCheckBox* box)
+  CheckBoxControl::CheckBoxControl (const graphics_object& go, QCheckBox *box)
     : ButtonControl (go, box)
   {
     box->setAutoFillBackground (true);
   }
 
   CheckBoxControl::~CheckBoxControl (void)
   { }
 
diff --git a/libgui/graphics/CheckBoxControl.h b/libgui/graphics/CheckBoxControl.h
--- a/libgui/graphics/CheckBoxControl.h
+++ b/libgui/graphics/CheckBoxControl.h
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 class QCheckBox;
 
 namespace QtHandles
 {
 
   class CheckBoxControl : public ButtonControl
   {
   public:
-    CheckBoxControl (const graphics_object& go, QCheckBox* box);
+    CheckBoxControl (const graphics_object& go, QCheckBox *box);
     ~CheckBoxControl (void);
 
-    static CheckBoxControl* create (const graphics_object& go);
+    static CheckBoxControl * create (const graphics_object& go);
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/Container.cc b/libgui/graphics/Container.cc
--- a/libgui/graphics/Container.cc
+++ b/libgui/graphics/Container.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "Canvas.h"
 #include "Container.h"
 #include "Object.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-  Container::Container (QWidget* xparent)
+  Container::Container (QWidget *xparent)
     : ContainerBase (xparent), m_canvas (0)
   {
     setFocusPolicy (Qt::ClickFocus);
   }
 
   Container::~Container (void)
   { }
 
@@ -56,17 +56,17 @@ namespace QtHandles
 
         if (go)
           {
             graphics_object fig = go.get_ancestor ("figure");
 
             m_canvas = Canvas::create (fig.get ("renderer").string_value (),
                                        this, gh);
 
-            QWidget* canvasWidget = m_canvas->qWidget ();
+            QWidget *canvasWidget = m_canvas->qWidget ();
 
             canvasWidget->lower ();
             canvasWidget->show ();
             canvasWidget->setGeometry (0, 0, width (), height ());
           }
       }
 
     return m_canvas;
@@ -75,21 +75,21 @@ namespace QtHandles
   void
   Container::resizeEvent (QResizeEvent* /* event */)
   {
     if (m_canvas)
       m_canvas->qWidget ()->setGeometry (0, 0, width (), height ());
 
     gh_manager::auto_lock lock;
 
-    foreach (QObject* qObj, children ())
+    foreach (QObject *qObj, children ())
       {
         if (qObj->isWidgetType ())
           {
-            Object* obj = Object::fromQObject (qObj);
+            Object *obj = Object::fromQObject (qObj);
 
             if (obj)
               {
                 graphics_object go = obj->object ();
 
                 if (go.valid_object ())
                   {
                     Matrix bb = go.get_properties ().get_boundingbox (false);
@@ -99,17 +99,17 @@ namespace QtHandles
                       octave::math::round (bb(2)), octave::math::round (bb(3)));
                   }
               }
           }
       }
   }
 
   void
-  Container::childEvent (QChildEvent* xevent)
+  Container::childEvent (QChildEvent *xevent)
   {
     // Enable mouse tracking in child widgets as they are added if the
     // container also has mouse tracking enabled.  There is no need to
     // do this when child objects are removed.
 
     if (xevent->added ())
       {
         QObject *obj = xevent->child ();
diff --git a/libgui/graphics/Container.h b/libgui/graphics/Container.h
--- a/libgui/graphics/Container.h
+++ b/libgui/graphics/Container.h
@@ -34,24 +34,24 @@ namespace QtHandles
 
   DECLARE_GENERICEVENTNOTIFY_SENDER(ContainerBase, QWidget);
 
   class Canvas;
 
   class Container : public ContainerBase
   {
   public:
-    Container (QWidget* parent);
+    Container (QWidget *parent);
     ~Container (void);
 
-    Canvas* canvas (const graphics_handle& handle, bool create = true);
+    Canvas * canvas (const graphics_handle& handle, bool create = true);
 
   protected:
-    void childEvent (QChildEvent* event);
-    void resizeEvent (QResizeEvent* event);
+    void childEvent (QChildEvent *event);
+    void resizeEvent (QResizeEvent *event);
 
   private:
-    Canvas* m_canvas;
+    Canvas *m_canvas;
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/ContextMenu.cc b/libgui/graphics/ContextMenu.cc
--- a/libgui/graphics/ContextMenu.cc
+++ b/libgui/graphics/ContextMenu.cc
@@ -31,53 +31,53 @@ along with Octave; see the file COPYING.
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   ContextMenu*
   ContextMenu::create (const graphics_object& go)
   {
-    Object* xparent = Object::parentObject (go);
+    Object *xparent = Object::parentObject (go);
 
     if (xparent)
       {
-        QWidget* w = xparent->qWidget<QWidget> ();
+        QWidget *w = xparent->qWidget<QWidget> ();
 
         return new ContextMenu (go, new QMenu (w));
       }
 
     return 0;
   }
 
-  ContextMenu::ContextMenu (const graphics_object& go, QMenu* xmenu)
+  ContextMenu::ContextMenu (const graphics_object& go, QMenu *xmenu)
     : Object (go, xmenu)
   {
     xmenu->setAutoFillBackground (true);
 
     connect (xmenu, SIGNAL (aboutToShow (void)), SLOT (aboutToShow (void)));
     connect (xmenu, SIGNAL (aboutToHide (void)), SLOT (aboutToHide (void)));
   }
 
   ContextMenu::~ContextMenu (void)
   { }
 
   void
   ContextMenu::update (int pId)
   {
     uicontextmenu::properties& up = properties<uicontextmenu> ();
-    QMenu* xmenu = qWidget<QMenu> ();
+    QMenu *xmenu = qWidget<QMenu> ();
 
     switch (pId)
       {
       case base_properties::ID_VISIBLE:
         if (up.is_visible ())
           {
             Matrix pos = up.get_position ().matrix_value ();
-            QWidget* parentW = xmenu->parentWidget ();
+            QWidget *parentW = xmenu->parentWidget ();
             QPoint pt;
 
             pt.rx () = octave::math::round (pos(0));
             pt.ry () = parentW->height () - octave::math::round (pos(1));
             pt = parentW->mapToGlobal (pt);
 
             xmenu->popup (pt);
           }
@@ -116,22 +116,22 @@ namespace QtHandles
 
     if (h.ok ())
       {
         gh_manager::auto_lock lock;
         graphics_object go = gh_manager::get_object (h);
 
         if (go.valid_object ())
           {
-            ContextMenu* cMenu =
+            ContextMenu *cMenu =
               dynamic_cast<ContextMenu *> (Backend::toolkitObject (go));
 
             if (cMenu)
               {
-                QMenu* menu = cMenu->qWidget<QMenu> ();
+                QMenu *menu = cMenu->qWidget<QMenu> ();
 
                 if (menu)
                   menu->popup (pt);
               }
           }
       }
   }
 
diff --git a/libgui/graphics/ContextMenu.h b/libgui/graphics/ContextMenu.h
--- a/libgui/graphics/ContextMenu.h
+++ b/libgui/graphics/ContextMenu.h
@@ -33,25 +33,25 @@ class QMenu;
 namespace QtHandles
 {
 
   class ContextMenu : public Object, public MenuContainer
   {
     Q_OBJECT
 
   public:
-    ContextMenu (const graphics_object& go, QMenu* menu);
+    ContextMenu (const graphics_object& go, QMenu *menu);
     ~ContextMenu (void);
 
-    static ContextMenu* create (const graphics_object& go);
+    static ContextMenu * create (const graphics_object& go);
     static void executeAt (const base_properties& props, const QPoint& pt);
 
-    Container* innerContainer (void) { return 0; }
+    Container * innerContainer (void) { return 0; }
 
-    QWidget* menu (void);
+    QWidget * menu (void);
 
   protected:
     void update (int pId);
 
   private slots:
     void aboutToShow (void);
     void aboutToHide (void);
   };
diff --git a/libgui/graphics/EditControl.cc b/libgui/graphics/EditControl.cc
--- a/libgui/graphics/EditControl.cc
+++ b/libgui/graphics/EditControl.cc
@@ -32,44 +32,44 @@ along with Octave; see the file COPYING.
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   EditControl*
   EditControl::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        Container* container = parent->innerContainer ();
+        Container *container = parent->innerContainer ();
 
         if (container)
           {
             uicontrol::properties& up = Utils::properties<uicontrol> (go);
 
             if ((up.get_max () - up.get_min ()) > 1)
               return new EditControl (go, new TextEdit (container));
             else
               return new EditControl (go, new QLineEdit (container));
           }
       }
 
     return 0;
   }
 
-  EditControl::EditControl (const graphics_object& go, QLineEdit* edit)
+  EditControl::EditControl (const graphics_object& go, QLineEdit *edit)
     : BaseControl (go, edit), m_multiLine (false), m_textChanged (false)
   {
     init (edit);
   }
 
   void
-  EditControl::init (QLineEdit* edit, bool callBase)
+  EditControl::init (QLineEdit *edit, bool callBase)
   {
     if (callBase)
       BaseControl::init (edit, callBase);
 
     m_multiLine = false;
     initCommon (edit);
 
     uicontrol::properties& up = properties<uicontrol> ();
@@ -81,24 +81,24 @@ namespace QtHandles
     connect (edit, SIGNAL (textEdited (const QString&)),
              SLOT (textChanged (void)));
     connect (edit, SIGNAL (editingFinished (void)),
              SLOT (editingFinished (void)));
     connect (edit, SIGNAL (returnPressed (void)),
              SLOT (returnPressed (void)));
   }
 
-  EditControl::EditControl (const graphics_object& go, TextEdit* edit)
+  EditControl::EditControl (const graphics_object& go, TextEdit *edit)
     : BaseControl (go, edit), m_multiLine (true), m_textChanged (false)
   {
     init (edit);
   }
 
   void
-  EditControl::init (TextEdit* edit, bool callBase)
+  EditControl::init (TextEdit *edit, bool callBase)
   {
     if (callBase)
       BaseControl::init (edit, callBase);
 
     m_multiLine = true;
     initCommon (edit);
 
     uicontrol::properties& up = properties<uicontrol> ();
@@ -144,17 +144,17 @@ namespace QtHandles
           }
       }
   }
 
   bool
   EditControl::updateSingleLine (int pId)
   {
     uicontrol::properties& up = properties<uicontrol> ();
-    QLineEdit* edit = qWidget<QLineEdit> ();
+    QLineEdit *edit = qWidget<QLineEdit> ();
 
     switch (pId)
       {
       case uicontrol::properties::ID_STRING:
         edit->setText (Utils::fromStdString (up.get_string_string ()));
         return true;
 
       case uicontrol::properties::ID_HORIZONTALALIGNMENT:
@@ -162,17 +162,17 @@ namespace QtHandles
         edit->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
                                                 up.get_verticalalignment ()));
         return true;
 
       case uicontrol::properties::ID_MIN:
       case uicontrol::properties::ID_MAX:
         if ((up.get_max () - up.get_min ()) > 1)
           {
-            QWidget* container = edit->parentWidget ();
+            QWidget *container = edit->parentWidget ();
 
             delete edit;
             init (new TextEdit (container), true);
           }
         return true;
 
       default:
         break;
@@ -180,30 +180,30 @@ namespace QtHandles
 
     return false;
   }
 
   bool
   EditControl::updateMultiLine (int pId)
   {
     uicontrol::properties& up = properties<uicontrol> ();
-    TextEdit* edit = qWidget<TextEdit> ();
+    TextEdit *edit = qWidget<TextEdit> ();
 
     switch (pId)
       {
       case uicontrol::properties::ID_STRING:
         edit->setPlainText (Utils::fromStringVector (
                               up.get_string_vector ()).join ("\n"));
         return true;
 
       case uicontrol::properties::ID_MIN:
       case uicontrol::properties::ID_MAX:
         if ((up.get_max () - up.get_min ()) <= 1)
           {
-            QWidget* container = edit->parentWidget ();
+            QWidget *container = edit->parentWidget ();
 
             delete edit;
             init (new QLineEdit (container), true);
           }
         return true;
 
       default:
         break;
diff --git a/libgui/graphics/EditControl.h b/libgui/graphics/EditControl.h
--- a/libgui/graphics/EditControl.h
+++ b/libgui/graphics/EditControl.h
@@ -33,29 +33,29 @@ namespace QtHandles
 
   class TextEdit;
 
   class EditControl : public BaseControl
   {
     Q_OBJECT
 
   public:
-    EditControl (const graphics_object& go, QLineEdit* edit);
-    EditControl (const graphics_object& go, TextEdit* edit);
+    EditControl (const graphics_object& go, QLineEdit *edit);
+    EditControl (const graphics_object& go, TextEdit *edit);
     ~EditControl (void);
 
-    static EditControl* create (const graphics_object& go);
+    static EditControl * create (const graphics_object& go);
 
   protected:
     void update (int pId);
 
   private:
-    void init (QLineEdit* edit, bool callBase = false);
-    void init (TextEdit* edit, bool callBase = false);
-    void initCommon (QWidget* widget);
+    void init (QLineEdit *edit, bool callBase = false);
+    void init (TextEdit *edit, bool callBase = false);
+    void initCommon (QWidget *widget);
     bool updateSingleLine (int pId);
     bool updateMultiLine (int pId);
 
   private slots:
     void textChanged (void);
     void editingFinished (void);
     void returnPressed (void);
 
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -118,17 +118,17 @@ namespace QtHandles
   }
 
   Figure*
   Figure::create (const graphics_object& go)
   {
     return new Figure (go, new FigureWindow ());
   }
 
-  Figure::Figure (const graphics_object& go, FigureWindow* win)
+  Figure::Figure (const graphics_object& go, FigureWindow *win)
     : Object (go, win), m_blockUpdates (false), m_figureToolBar (0),
       m_menuBar (0), m_innerRect (), m_outerRect (), m_mouseModeGroup (0)
   {
     m_container = new Container (win);
     win->setCentralWidget (m_container);
 
     figure::properties& fp = properties<figure> ();
 
@@ -288,17 +288,17 @@ namespace QtHandles
       }
 
     return mouse_mode_from_string (mode);
   }
 
   void
   Figure::createFigureToolBarAndMenuBar (void)
   {
-    QMainWindow* win = qWidget<QMainWindow> ();
+    QMainWindow *win = qWidget<QMainWindow> ();
 
     m_figureToolBar = win->addToolBar (tr ("Figure ToolBar"));
     m_figureToolBar->setMovable (false);
     m_figureToolBar->setFloatable (false);
 
     m_mouseModeGroup = new MouseModeActionGroup (win);
     connect (m_mouseModeGroup, SIGNAL (modeChanged (MouseMode)),
              SLOT (setMouseMode (MouseMode)));
@@ -314,32 +314,32 @@ namespace QtHandles
 
     QAction *auto_axes = m_figureToolBar->addAction (tr ("Autoscale"));
     connect (auto_axes, SIGNAL (triggered (void)),
              this, SLOT (autoAxes (void)));
 
     m_menuBar = new MenuBar (win);
     win->setMenuBar (m_menuBar);
 
-    QMenu* fileMenu = m_menuBar->addMenu (tr ("&File"));
+    QMenu *fileMenu = m_menuBar->addMenu (tr ("&File"));
     fileMenu->menuAction ()->setObjectName ("builtinMenu");
     fileMenu->addAction (tr ("&Save"), this, SLOT (fileSaveFigure (bool)));
     fileMenu->addAction (tr ("Save &As"), this, SLOT (fileSaveFigureAs (void)));
     fileMenu->addSeparator ();
     fileMenu->addAction (tr ("&Close Figure"), this,
                          SLOT (fileCloseFigure (void)), Qt::CTRL | Qt::Key_W);
 
-    QMenu* editMenu = m_menuBar->addMenu (tr ("&Edit"));
+    QMenu *editMenu = m_menuBar->addMenu (tr ("&Edit"));
     editMenu->menuAction ()->setObjectName ("builtinMenu");
     editMenu->addAction (tr ("Cop&y"), this, SLOT (editCopy (bool)),
                          Qt::CTRL | Qt::Key_C);
     editMenu->addSeparator ();
     editMenu->addActions (m_mouseModeGroup->actions ());
 
-    QMenu* helpMenu = m_menuBar->addMenu (tr ("&Help"));
+    QMenu *helpMenu = m_menuBar->addMenu (tr ("&Help"));
     helpMenu->menuAction ()->setObjectName ("builtinMenu");
     helpMenu->addAction (tr ("About Octave"), this,
                          SLOT (helpAboutOctave (void)));
 
     m_menuBar->addReceiver (this);
   }
 
   void
@@ -357,82 +357,82 @@ namespace QtHandles
   Figure::innerContainer (void)
   {
     return m_container;
   }
 
   void
   Figure::redraw (void)
   {
-    Canvas* canvas = m_container->canvas (m_handle);
+    Canvas *canvas = m_container->canvas (m_handle);
 
     if (canvas)
       {
         canvas->redraw ();
         //canvas->setMouseMode (RotateMode);
       }
 
-    foreach (QFrame* frame,
+    foreach (QFrame *frame,
              qWidget<QWidget> ()->findChildren<QFrame*> ())
       {
         if (frame->objectName () == "UIPanel"
             || frame->objectName () == "UIButtonGroup")
           {
-            Object* obj = Object::fromQObject (frame);
+            Object *obj = Object::fromQObject (frame);
 
             if (obj)
               obj->slotRedraw ();
           }
       }
 
     updateFigureToolBarAndMenuBar ();
   }
 
   void
   Figure::print (const QString& file_cmd, const QString& term)
   {
-    Canvas* canvas = m_container->canvas (m_handle);
+    Canvas *canvas = m_container->canvas (m_handle);
 
     if (canvas)
       canvas->print (file_cmd, term);
   }
 
   void
   Figure::beingDeleted (void)
   {
-    Canvas* canvas = m_container->canvas (m_handle.value (), false);
+    Canvas *canvas = m_container->canvas (m_handle.value (), false);
 
     if (canvas)
       canvas->blockRedraw (true);
 
     m_menuBar->removeReceiver (this);
     m_container->removeReceiver (this);
     qWidget<FigureWindow> ()->removeReceiver (this);
   }
 
   void
   Figure::update (int pId)
   {
     if (m_blockUpdates)
       return;
 
     figure::properties& fp = properties<figure> ();
-    QMainWindow* win = qWidget<QMainWindow> ();
+    QMainWindow *win = qWidget<QMainWindow> ();
 
     m_blockUpdates = true;
 
     switch (pId)
       {
       case figure::properties::ID_POSITION:
         {
           m_innerRect = boundingBoxToRect (fp.get_boundingbox (true));
           int toffset = 0;
           int boffset = 0;
 
-          foreach (QToolBar* tb, win->findChildren<QToolBar*> ())
+          foreach (QToolBar *tb, win->findChildren<QToolBar*> ())
             if (! tb->isHidden ())
               toffset += tb->sizeHint ().height ();
 
           if (! m_menuBar->isHidden ())
             toffset += m_menuBar->sizeHint ().height ();
 
           if (! m_statusBar->isHidden ())
             boffset += m_statusBar->sizeHint ().height ();
@@ -534,17 +534,17 @@ namespace QtHandles
 
   void
   Figure::showMenuBar (bool visible, int h1)
   {
     // Get the height before and after toggling the visibility of builtin menus
     if (h1 <= 0)
       h1 = m_menuBar->sizeHint ().height ();
 
-    foreach (QAction* a, m_menuBar->actions ())
+    foreach (QAction *a, m_menuBar->actions ())
       if (a->objectName () == "builtinMenu")
         a->setVisible (visible);
 
     int h2 = m_menuBar->sizeHint ().height ();
 
     // Keep the menubar visible if it contains custom menus
     if (! visible)
       visible = hasUiMenuChildren (properties<figure> ());
@@ -593,41 +593,41 @@ namespace QtHandles
     return qWidget<QMainWindow> ()->menuBar ();
   }
 
   struct UpdateBoundingBoxData
   {
     Matrix m_bbox;
     bool m_internal;
     graphics_handle m_handle;
-    Figure* m_figure;
+    Figure *m_figure;
   };
 
   void
-  Figure::updateBoundingBoxHelper (void* data)
+  Figure::updateBoundingBoxHelper (void *data)
   {
     gh_manager::auto_lock lock;
 
-    UpdateBoundingBoxData* d = reinterpret_cast<UpdateBoundingBoxData *> (data);
+    UpdateBoundingBoxData *d = reinterpret_cast<UpdateBoundingBoxData *> (data);
     graphics_object go = gh_manager::get_object (d->m_handle);
 
     if (go.valid_object ())
       {
         figure::properties& fp = Utils::properties<figure> (go);
 
         fp.set_boundingbox (d->m_bbox, d->m_internal, false);
       }
 
     delete d;
   }
 
   void
   Figure::updateBoundingBox (bool internal, int flags)
   {
-    QWidget* win = qWidget<QWidget> ();
+    QWidget *win = qWidget<QWidget> ();
     Matrix bb (1, 4);
 
     if (internal)
       {
         QRect r = m_innerRect;
 
         if (flags & UpdateBoundingBoxPosition)
           r.moveTopLeft (win->mapToGlobal (m_container->pos ()));
@@ -663,45 +663,45 @@ namespace QtHandles
             bb(1) = r.y ();
             bb(2) = r.width ();
             bb(3) = r.height ();
           }
         else
           return;
       }
 
-    UpdateBoundingBoxData* d = new UpdateBoundingBoxData ();
+    UpdateBoundingBoxData *d = new UpdateBoundingBoxData ();
 
     d->m_bbox = bb;
     d->m_internal = internal;
     d->m_handle = m_handle;
     d->m_figure = this;
 
     gh_manager::post_function (Figure::updateBoundingBoxHelper, d);
   }
 
   bool
-  Figure::eventNotifyBefore (QObject* obj, QEvent* xevent)
+  Figure::eventNotifyBefore (QObject *obj, QEvent *xevent)
   {
     if (! m_blockUpdates)
       {
         if (obj == m_container)
           {
             // Do nothing...
           }
         else if (obj == m_menuBar)
           {
             switch (xevent->type ())
               {
               case QEvent::ActionChanged:
                 m_previousHeight = m_menuBar->sizeHint ().height ();
                 break;
               case QEvent::ActionRemoved:
                 {
-                  QAction* a = dynamic_cast<QActionEvent *> (xevent)->action ();
+                  QAction *a = dynamic_cast<QActionEvent *> (xevent)->action ();
 
                   if (! a->isSeparator ()
                       && a->objectName () != "builtinMenu")
                     updateMenuBar ();
                 }
                 break;
 
               default:
@@ -722,17 +722,17 @@ namespace QtHandles
               }
           }
       }
 
     return false;
   }
 
   void
-  Figure::eventNotifyAfter (QObject* watched, QEvent* xevent)
+  Figure::eventNotifyAfter (QObject *watched, QEvent *xevent)
   {
     if (! m_blockUpdates)
       {
         if (watched == m_container)
           {
             switch (xevent->type ())
               {
               case QEvent::Resize:
@@ -763,26 +763,26 @@ namespace QtHandles
           }
         else if (watched == m_menuBar)
           {
             switch (xevent->type ())
               {
               case QEvent::ActionChanged:
                 // The menubar may have been resized if no action is visible
                 {
-                  QAction* a = dynamic_cast<QActionEvent *> (xevent)->action ();
+                  QAction *a = dynamic_cast<QActionEvent *> (xevent)->action ();
                   if (m_menuBar->sizeHint ().height () != m_previousHeight
                       && a->objectName () != "builtinMenu"
                       && ! a->isSeparator ())
                     updateMenuBar (m_previousHeight);
                 }
                 break;
               case QEvent::ActionAdded:
                 {
-                  QAction* a = dynamic_cast<QActionEvent *> (xevent)->action ();
+                  QAction *a = dynamic_cast<QActionEvent *> (xevent)->action ();
 
                   if (! a->isSeparator ()
                       && a->objectName () != "builtinMenu"
                       && a->isVisible ())
                     updateMenuBar ();
                 }
                 break;
 
@@ -827,17 +827,17 @@ namespace QtHandles
       return;
 
     gh_manager::auto_lock lock;
 
     figure::properties& fp = properties<figure> ();
 
     fp.set___mouse_mode__ (mouse_mode_to_string (mode));
 
-    Canvas* canvas = m_container->canvas (m_handle);
+    Canvas *canvas = m_container->canvas (m_handle);
 
     if (canvas)
       canvas->setCursor (mode);
   }
 
   void
   Figure::fileSaveFigure (bool prompt)
   {
@@ -930,19 +930,19 @@ namespace QtHandles
       }
 #endif
 
     octave_link::post_event (this, &Figure::copy_figure_callback,
                              format.toStdString ());
   }
 
   void
-  Figure::addCustomToolBar (QToolBar* bar, bool visible)
+  Figure::addCustomToolBar (QToolBar *bar, bool visible)
   {
-    QMainWindow* win = qWidget<QMainWindow> ();
+    QMainWindow *win = qWidget<QMainWindow> ();
 
     if (! visible)
       win->addToolBar (bar);
     else
       {
         QSize sz = bar->sizeHint ();
         QRect r = win->geometry ();
         //qDebug () << "Figure::addCustomToolBar:" << r;
@@ -956,19 +956,19 @@ namespace QtHandles
         m_blockUpdates = false;
 
         //qDebug () << "Figure::addCustomToolBar:" << win->geometry ();
         updateBoundingBox (false);
       }
   }
 
   void
-  Figure::showCustomToolBar (QToolBar* bar, bool visible)
+  Figure::showCustomToolBar (QToolBar *bar, bool visible)
   {
-    QMainWindow* win = qWidget<QMainWindow> ();
+    QMainWindow *win = qWidget<QMainWindow> ();
 
     if ((! bar->isHidden ()) != visible)
       {
         QSize sz = bar->sizeHint ();
         QRect r = win->geometry ();
 
         if (visible)
           r.adjust (0, -sz.height (), 0, 0);
@@ -988,43 +988,43 @@ namespace QtHandles
   Figure::updateContainer (void)
   {
     redraw ();
   }
 
   void
   Figure::toggleAxes (void)
   {
-    Canvas* canvas = m_container->canvas (m_handle);
+    Canvas *canvas = m_container->canvas (m_handle);
 
     if (canvas)
       canvas->toggleAxes (m_handle);
   }
 
   void
   Figure::toggleGrid (void)
   {
-    Canvas* canvas = m_container->canvas (m_handle);
+    Canvas *canvas = m_container->canvas (m_handle);
 
     if (canvas)
       canvas->toggleGrid (m_handle);
   }
 
   void
   Figure::autoAxes (void)
   {
-    Canvas* canvas = m_container->canvas (m_handle);
+    Canvas *canvas = m_container->canvas (m_handle);
 
     if (canvas)
       canvas->autoAxes (m_handle);
   }
 
   void
   Figure::enableMouseTracking (void)
   {
     // Enable mouse tracking on every widgets
     m_container->setMouseTracking (true);
     m_container->canvas (m_handle)->qWidget ()->setMouseTracking (true);
-    foreach (QWidget* w, m_container->findChildren<QWidget*> ())
+    foreach (QWidget *w, m_container->findChildren<QWidget*> ())
       w->setMouseTracking (true);
   }
 
 }
diff --git a/libgui/graphics/Figure.h b/libgui/graphics/Figure.h
--- a/libgui/graphics/Figure.h
+++ b/libgui/graphics/Figure.h
@@ -62,32 +62,32 @@ namespace QtHandles
   public MenuContainer,
   public GenericEventNotifyReceiver
   {
     Q_OBJECT
 
     friend class ToolBar;
 
   public:
-    Figure (const graphics_object& go, FigureWindow* win);
+    Figure (const graphics_object& go, FigureWindow *win);
     ~Figure (void);
 
-    static Figure* create (const graphics_object& go);
+    static Figure * create (const graphics_object& go);
 
     QString fileName (void);
     void setFileName (const QString& name);
 
     MouseMode mouseMode (void);
 
-    Container* innerContainer (void);
-    QWidget* menu (void);
+    Container * innerContainer (void);
+    QWidget * menu (void);
     void updateStatusBar (ColumnVector pt);
 
-    bool eventNotifyBefore (QObject* watched, QEvent* event);
-    void eventNotifyAfter (QObject* watched, QEvent* event);
+    bool eventNotifyBefore (QObject *watched, QEvent *event);
+    void eventNotifyAfter (QObject *watched, QEvent *event);
 
   protected:
     enum UpdateBoundingBoxFlag
     {
       UpdateBoundingBoxPosition = 0x1,
       UpdateBoundingBoxSize     = 0x2,
       UpdateBoundingBoxAll      = 0x3
     };
@@ -98,18 +98,18 @@ namespace QtHandles
     void update (int pId);
     void updateBoundingBox (bool internal = false, int flags = 0);
     void beingDeleted (void);
 
   private:
     void createFigureToolBarAndMenuBar (void);
     void showFigureToolBar (bool visible);
     void showMenuBar (bool visible, int height = -1);
-    void addCustomToolBar (QToolBar* bar, bool visible);
-    void showCustomToolBar (QToolBar* bar, bool visible);
+    void addCustomToolBar (QToolBar *bar, bool visible);
+    void showCustomToolBar (QToolBar *bar, bool visible);
 
     void updateFigureToolBarAndMenuBar (void);
 
     static void updateBoundingBoxHelper (void*);
 
     void save_figure_callback (const std::string& file);
     void copy_figure_callback (const std::string& format);
 
@@ -127,22 +127,22 @@ namespace QtHandles
     void toggleAxes (void);
     void toggleGrid (void);
     void autoAxes (void);
 
   signals:
     void asyncUpdate (void);
 
   private:
-    Container* m_container;
+    Container *m_container;
     bool m_blockUpdates;
-    QToolBar* m_figureToolBar;
-    MenuBar* m_menuBar;
-    QStatusBar* m_statusBar;
+    QToolBar *m_figureToolBar;
+    MenuBar *m_menuBar;
+    QStatusBar *m_statusBar;
     QRect m_innerRect;
     QRect m_outerRect;
-    MouseModeActionGroup* m_mouseModeGroup;
+    MouseModeActionGroup *m_mouseModeGroup;
     int m_previousHeight;
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/FigureWindow.cc b/libgui/graphics/FigureWindow.cc
--- a/libgui/graphics/FigureWindow.cc
+++ b/libgui/graphics/FigureWindow.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <QMenu>
 
 #include "FigureWindow.h"
 
 namespace QtHandles
 {
 
-  FigureWindow::FigureWindow (QWidget* xparent)
+  FigureWindow::FigureWindow (QWidget *xparent)
     : FigureWindowBase (xparent)
   {
     // set icon from application resources
     setWindowIcon (QIcon (":/actions/icons/logo.png"));
   }
 
   FigureWindow::~FigureWindow (void)
   { }
diff --git a/libgui/graphics/FigureWindow.h b/libgui/graphics/FigureWindow.h
--- a/libgui/graphics/FigureWindow.h
+++ b/libgui/graphics/FigureWindow.h
@@ -32,17 +32,17 @@ namespace QtHandles
 
   DECLARE_GENERICEVENTNOTIFY_SENDER(FigureWindowBase, QMainWindow);
 
   class FigureWindow : public FigureWindowBase
   {
     Q_OBJECT
 
   public:
-    FigureWindow (QWidget* parent = 0);
+    FigureWindow (QWidget *parent = 0);
     ~FigureWindow (void);
 
-    QMenu* createPopupMenu (void);
+    QMenu * createPopupMenu (void);
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/GLCanvas.cc b/libgui/graphics/GLCanvas.cc
--- a/libgui/graphics/GLCanvas.cc
+++ b/libgui/graphics/GLCanvas.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include "graphics.h"
 
 #include "GLCanvas.h"
 #include "gl-select.h"
 
 namespace QtHandles
 {
 
-  GLCanvas::GLCanvas (QWidget* xparent, const graphics_handle& gh)
+  GLCanvas::GLCanvas (QWidget *xparent, const graphics_handle& gh)
 #if defined (Q_OS_WIN32)
     : QGLWidget (QGLFormat (QGL::SampleBuffers | QGL::AlphaChannel |
                             QGL::IndirectRendering),
                  xparent),
       Canvas (gh)
 #else
     : QGLWidget (QGLFormat (QGL::SampleBuffers | QGL::AlphaChannel),
                  xparent),
@@ -148,52 +148,52 @@ namespace QtHandles
 
   void
   GLCanvas::paintGL (void)
   {
     canvasPaintEvent ();
   }
 
   void
-  GLCanvas::mouseDoubleClickEvent (QMouseEvent* xevent)
+  GLCanvas::mouseDoubleClickEvent (QMouseEvent *xevent)
   {
     canvasMouseDoubleClickEvent (xevent);
   }
 
   void
-  GLCanvas::mouseMoveEvent (QMouseEvent* xevent)
+  GLCanvas::mouseMoveEvent (QMouseEvent *xevent)
   {
     canvasMouseMoveEvent (xevent);
   }
 
   void
-  GLCanvas::mousePressEvent (QMouseEvent* xevent)
+  GLCanvas::mousePressEvent (QMouseEvent *xevent)
   {
     canvasMousePressEvent (xevent);
   }
 
   void
-  GLCanvas::mouseReleaseEvent (QMouseEvent* xevent)
+  GLCanvas::mouseReleaseEvent (QMouseEvent *xevent)
   {
     canvasMouseReleaseEvent (xevent);
   }
 
   void
-  GLCanvas::wheelEvent (QWheelEvent* xevent)
+  GLCanvas::wheelEvent (QWheelEvent *xevent)
   {
     canvasWheelEvent (xevent);
   }
 
   void
-  GLCanvas::keyPressEvent (QKeyEvent* xevent)
+  GLCanvas::keyPressEvent (QKeyEvent *xevent)
   {
     if (! canvasKeyPressEvent (xevent))
       QGLWidget::keyPressEvent (xevent);
   }
 
   void
-  GLCanvas::keyReleaseEvent (QKeyEvent* xevent)
+  GLCanvas::keyReleaseEvent (QKeyEvent *xevent)
   {
     if (! canvasKeyReleaseEvent (xevent))
       QGLWidget::keyReleaseEvent (xevent);
   }
 
 }
diff --git a/libgui/graphics/GLCanvas.h b/libgui/graphics/GLCanvas.h
--- a/libgui/graphics/GLCanvas.h
+++ b/libgui/graphics/GLCanvas.h
@@ -28,36 +28,36 @@ along with Octave; see the file COPYING.
 #include "Canvas.h"
 
 namespace QtHandles
 {
 
   class GLCanvas : public QGLWidget, public Canvas
   {
   public:
-    GLCanvas (QWidget* parent, const graphics_handle& handle);
+    GLCanvas (QWidget *parent, const graphics_handle& handle);
     ~GLCanvas (void);
 
     void draw (const graphics_handle& handle);
     void toggleAxes (const graphics_handle& handle);
     void toggleGrid (const graphics_handle& handle);
     void autoAxes (const graphics_handle& handle);
     void drawZoomBox (const QPoint& p1, const QPoint& p2);
     void resize (int /* x */, int /* y */,
                  int /* width */, int /* height */) { }
     graphics_object selectFromAxes (const graphics_object& ax,
                                     const QPoint& pt);
-    QWidget* qWidget (void) { return this; }
+    QWidget * qWidget (void) { return this; }
 
   protected:
     void paintGL (void);
-    void mouseDoubleClickEvent (QMouseEvent* event);
-    void mouseMoveEvent (QMouseEvent* event);
-    void mousePressEvent (QMouseEvent* event);
-    void mouseReleaseEvent (QMouseEvent* event);
-    void wheelEvent (QWheelEvent* event);
-    void keyPressEvent (QKeyEvent* event);
-    void keyReleaseEvent (QKeyEvent* event);
+    void mouseDoubleClickEvent (QMouseEvent *event);
+    void mouseMoveEvent (QMouseEvent *event);
+    void mousePressEvent (QMouseEvent *event);
+    void mouseReleaseEvent (QMouseEvent *event);
+    void wheelEvent (QWheelEvent *event);
+    void keyPressEvent (QKeyEvent *event);
+    void keyReleaseEvent (QKeyEvent *event);
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/GenericEventNotify.h b/libgui/graphics/GenericEventNotify.h
--- a/libgui/graphics/GenericEventNotify.h
+++ b/libgui/graphics/GenericEventNotify.h
@@ -35,67 +35,67 @@ namespace QtHandles
   class GenericEventNotifyReceiver;
 
   class GenericEventNotifySender
   {
   public:
     GenericEventNotifySender (void) : m_receivers () { }
     virtual ~GenericEventNotifySender (void) = default;
 
-    void addReceiver (GenericEventNotifyReceiver* r)
+    void addReceiver (GenericEventNotifyReceiver *r)
     { m_receivers.insert (r); }
 
-    void removeReceiver (GenericEventNotifyReceiver* r)
+    void removeReceiver (GenericEventNotifyReceiver *r)
     { m_receivers.remove (r); }
 
   protected:
-    bool notifyReceiversBefore (QObject* obj, QEvent* evt);
-    void notifyReceiversAfter (QObject* obj, QEvent* evt);
+    bool notifyReceiversBefore (QObject *obj, QEvent *evt);
+    void notifyReceiversAfter (QObject *obj, QEvent *evt);
 
   private:
     QSet<GenericEventNotifyReceiver*> m_receivers;
   };
 
   class GenericEventNotifyReceiver
   {
   public:
     GenericEventNotifyReceiver (void) { }
     virtual ~GenericEventNotifyReceiver (void) = default;
 
-    virtual bool eventNotifyBefore (QObject* obj, QEvent* evt) = 0;
-    virtual void eventNotifyAfter (QObject* obj, QEvent* evt) = 0;
+    virtual bool eventNotifyBefore (QObject *obj, QEvent *evt) = 0;
+    virtual void eventNotifyAfter (QObject *obj, QEvent *evt) = 0;
   };
 
   inline
-  bool GenericEventNotifySender::notifyReceiversBefore (QObject* obj,
-      QEvent* evt)
+  bool GenericEventNotifySender::notifyReceiversBefore (QObject *obj,
+      QEvent *evt)
   {
-    foreach (GenericEventNotifyReceiver* r, m_receivers)
+    foreach (GenericEventNotifyReceiver *r, m_receivers)
       if (r->eventNotifyBefore (obj, evt))
         return true;
 
     return false;
   }
 
   inline
-  void GenericEventNotifySender::notifyReceiversAfter (QObject* obj,
-      QEvent* evt)
+  void GenericEventNotifySender::notifyReceiversAfter (QObject *obj,
+      QEvent *evt)
   {
-    foreach (GenericEventNotifyReceiver* r, m_receivers)
+    foreach (GenericEventNotifyReceiver *r, m_receivers)
       r->eventNotifyAfter (obj, evt);
   }
 
 #define DECLARE_GENERICEVENTNOTIFY_SENDER(T,B) \
 class T : public B, public GenericEventNotifySender \
 { \
 public: \
-  T (QWidget* xparent) : B (xparent), GenericEventNotifySender () { } \
+  T (QWidget *xparent) : B (xparent), GenericEventNotifySender () { } \
   ~ T (void) = default; \
 \
-  bool event (QEvent* evt) \
+  bool event (QEvent *evt) \
     { \
       bool result = true; \
       if (! notifyReceiversBefore (this, evt)) \
         result = B::event (evt); \
       notifyReceiversAfter (this, evt); \
       return result; \
     } \
 }
diff --git a/libgui/graphics/ListBoxControl.cc b/libgui/graphics/ListBoxControl.cc
--- a/libgui/graphics/ListBoxControl.cc
+++ b/libgui/graphics/ListBoxControl.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "Container.h"
 #include "ListBoxControl.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   static void
-  updateSelection (QListWidget* list, const Matrix& value)
+  updateSelection (QListWidget *list, const Matrix& value)
   {
     octave_idx_type n = value.numel ();
     int lc = list->count ();
 
     list->clearSelection ();
 
     for (octave_idx_type i = 0; i < n; i++)
       {
@@ -62,30 +62,30 @@ namespace QtHandles
             break;
           }
       }
   }
 
   ListBoxControl*
   ListBoxControl::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        Container* container = parent->innerContainer ();
+        Container *container = parent->innerContainer ();
 
         if (container)
           return new ListBoxControl (go, new QListWidget (container));
       }
 
     return 0;
   }
 
-  ListBoxControl::ListBoxControl (const graphics_object& go, QListWidget* list)
+  ListBoxControl::ListBoxControl (const graphics_object& go, QListWidget *list)
     : BaseControl (go, list), m_blockCallback (false), m_selectionChanged (false)
   {
     uicontrol::properties& up = properties<uicontrol> ();
 
     list->addItems (Utils::fromStringVector (up.get_string_vector ()));
     if ((up.get_max () - up.get_min ()) > 1)
       list->setSelectionMode (QAbstractItemView::ExtendedSelection);
     else
@@ -123,17 +123,17 @@ namespace QtHandles
 
   ListBoxControl::~ListBoxControl (void)
   { }
 
   void
   ListBoxControl::update (int pId)
   {
     uicontrol::properties& up = properties<uicontrol> ();
-    QListWidget* list = qWidget<QListWidget> ();
+    QListWidget *list = qWidget<QListWidget> ();
 
     switch (pId)
       {
       case uicontrol::properties::ID_STRING:
         m_blockCallback = true;
         list->clear ();
         list->addItems (Utils::fromStringVector (up.get_string_vector ()));
         updateSelection (list, up.get_value ().matrix_value ());
@@ -161,17 +161,17 @@ namespace QtHandles
       }
   }
 
   void
   ListBoxControl::sendSelectionChange ()
   {
     if (! m_blockCallback)
       {
-        QListWidget* list = qWidget<QListWidget> ();
+        QListWidget *list = qWidget<QListWidget> ();
 
         QModelIndexList l = list->selectionModel ()->selectedIndexes ();
         Matrix value (dim_vector (1, l.size ()));
         int i = 0;
 
         foreach (const QModelIndex& idx, l)
           value(i++) = idx.row () + 1;
 
@@ -196,17 +196,17 @@ namespace QtHandles
   }
   void
   ListBoxControl::itemPressed (QListWidgetItem*)
   {
     m_selectionChanged = true;
   }
 
   bool
-  ListBoxControl::eventFilter (QObject* watched, QEvent* e)
+  ListBoxControl::eventFilter (QObject *watched, QEvent *e)
   {
     // listbox change
     if (watched == m_qobject)
       {
         switch (e->type ())
           {
             case QEvent::KeyRelease:
               if (m_selectionChanged)
@@ -219,37 +219,37 @@ namespace QtHandles
           }
 
         return Object::eventFilter (watched, e);
       }
     // listbox viewport
     else
       {
         bool override_return = false;
-        QListWidget* list = qWidget<QListWidget> ();
+        QListWidget *list = qWidget<QListWidget> ();
 
         switch (e->type ())
           {
             case QEvent::MouseButtonPress:
               {
-                QMouseEvent* m = dynamic_cast<QMouseEvent *> (e);
+                QMouseEvent *m = dynamic_cast<QMouseEvent *> (e);
 
                 if (m->button () & Qt::RightButton)
                   override_return = true;
                 else
                   {
                     if (! list->indexAt (m->pos ()).isValid ())
                       override_return = true;
                     m_selectionChanged = true;
                   }
                 break;
               }
             case QEvent::MouseButtonRelease:
               {
-                QMouseEvent* m = dynamic_cast<QMouseEvent *> (e);
+                QMouseEvent *m = dynamic_cast<QMouseEvent *> (e);
 
                 if (m->button () & Qt::RightButton)
                   override_return = true;
 
                 else if (! list->indexAt (m->pos ()).isValid ())
                   {
                     list->setCurrentRow (list->count () - 1);
                     override_return = true;
diff --git a/libgui/graphics/ListBoxControl.h b/libgui/graphics/ListBoxControl.h
--- a/libgui/graphics/ListBoxControl.h
+++ b/libgui/graphics/ListBoxControl.h
@@ -32,24 +32,24 @@ class QModelIndex;
 namespace QtHandles
 {
 
   class ListBoxControl : public BaseControl
   {
     Q_OBJECT
 
   public:
-    ListBoxControl (const graphics_object& go, QListWidget* list);
+    ListBoxControl (const graphics_object& go, QListWidget *list);
     ~ListBoxControl (void);
 
-    static ListBoxControl* create (const graphics_object& go);
+    static ListBoxControl * create (const graphics_object& go);
 
   protected:
     void update (int pId);
-    bool eventFilter (QObject* watched, QEvent* e);
+    bool eventFilter (QObject *watched, QEvent *e);
     void sendSelectionChange ();
 
   private slots:
     void itemSelectionChanged (void);
     void itemActivated (const QModelIndex &);
     void itemPressed (QListWidgetItem*);
 
   private:
diff --git a/libgui/graphics/Logger.cc b/libgui/graphics/Logger.cc
--- a/libgui/graphics/Logger.cc
+++ b/libgui/graphics/Logger.cc
@@ -30,18 +30,18 @@ along with Octave; see the file COPYING.
 
 #include <cstdio>
 
 #include "Logger.h"
 
 namespace QtHandles
 {
 
-  Logger* Logger::s_instance = 0;
-  QMutex* Logger::s_mutex = 0;
+  Logger *Logger::s_instance = 0;
+  QMutex *Logger::s_mutex = 0;
 
   Logger::Logger (void)
     : m_debugEnabled (false)
   {
     QProcessEnvironment pe (QProcessEnvironment::systemEnvironment ());
 
     if (pe.value ("QTHANDLES_DEBUG", "0") != "0")
       m_debugEnabled = true;
@@ -58,29 +58,29 @@ namespace QtHandles
         s_instance = new Logger ();
         s_mutex = new QMutex ();
       }
 
     return s_instance;
   }
 
 #define STATIC_LOGGER(fun) \
-  void Logger::fun (const char* fmt, ...) \
+  void Logger::fun (const char *fmt, ...) \
   { \
     QMutexLocker lock (s_mutex); \
     va_list vl; \
     va_start (vl, fmt); \
     instance ()->fun ## V (fmt, vl); \
     va_end (vl); \
   }
 
   STATIC_LOGGER (debug)
 
   void
-  Logger::debugV (const char* fmt, va_list arg)
+  Logger::debugV (const char *fmt, va_list arg)
   {
     if (m_debugEnabled)
       {
         vfprintf (stderr, fmt, arg);
         fprintf (stderr, "\n");
       }
   }
 
diff --git a/libgui/graphics/Logger.h b/libgui/graphics/Logger.h
--- a/libgui/graphics/Logger.h
+++ b/libgui/graphics/Logger.h
@@ -28,28 +28,28 @@ along with Octave; see the file COPYING.
 class QMutex;
 
 namespace QtHandles
 {
 
   class Logger
   {
   public:
-    static void debug (const char* fmt, ...);
+    static void debug (const char *fmt, ...);
 
   private:
     bool m_debugEnabled;
 
-    static Logger* s_instance;
-    static QMutex* s_mutex;
+    static Logger *s_instance;
+    static QMutex *s_mutex;
 
   private:
     Logger (void);
     ~Logger (void);
 
-    static Logger* instance (void);
+    static Logger * instance (void);
 
-    void debugV (const char* fmt, va_list arg);
+    void debugV (const char *fmt, va_list arg);
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/Menu.cc b/libgui/graphics/Menu.cc
--- a/libgui/graphics/Menu.cc
+++ b/libgui/graphics/Menu.cc
@@ -55,30 +55,30 @@ namespace QtHandles
       }
 
     return QKeySequence ();
   }
 
   Menu*
   Menu::create (const graphics_object& go)
   {
-    Object* parent_obj = Object::parentObject (go);
+    Object *parent_obj = Object::parentObject (go);
 
     if (parent_obj)
       {
-        QObject* qObj = parent_obj->qObject ();
+        QObject *qObj = parent_obj->qObject ();
 
         if (qObj)
           return new Menu (go, new QAction (qObj), parent_obj);
       }
 
     return 0;
   }
 
-  Menu::Menu (const graphics_object& go, QAction* action, Object* xparent)
+  Menu::Menu (const graphics_object& go, QAction *action, Object *xparent)
     : Object (go, action), m_parent (0), m_separator (0)
   {
     uimenu::properties& up = properties<uimenu> ();
 
     action->setText (Utils::fromStdString (up.get_label ()));
 
     if (up.is_checked ())
       {
@@ -92,47 +92,47 @@ namespace QtHandles
 
     if (up.is_separator ())
       {
         m_separator = new QAction (action);
         m_separator->setSeparator (true);
         m_separator->setVisible (up.is_visible ());
       }
 
-    MenuContainer* menuContainer = dynamic_cast<MenuContainer *> (xparent);
+    MenuContainer *menuContainer = dynamic_cast<MenuContainer *> (xparent);
 
     if (menuContainer)
       m_parent = menuContainer->menu ();
 
     if (m_parent)
       {
         int pos = static_cast<int> (up.get_position ());
 
         if (pos <= 0)
           {
             if (m_separator)
               m_parent->insertAction (0, m_separator);
             m_parent->insertAction (0, action);
 
             int count = 0;
 
-            foreach (QAction* a, m_parent->actions ())
+            foreach (QAction *a, m_parent->actions ())
               if (! a->isSeparator ())
                 count++;
 
             up.get_property ("position").set
             (octave_value (static_cast<double> (count)), true, false);
           }
         else
           {
 
             int count = 0;
-            QAction* before = 0;
+            QAction *before = 0;
 
-            foreach (QAction* a, m_parent->actions ())
+            foreach (QAction *a, m_parent->actions ())
               {
                 if (! a->isSeparator ())
                   {
                     count++;
                     if (pos <= count)
                       {
                         before = a;
                         break;
@@ -157,17 +157,17 @@ namespace QtHandles
 
   Menu::~Menu (void)
   { }
 
   void
   Menu::update (int pId)
   {
     uimenu::properties& up = properties<uimenu> ();
-    QAction* action = qWidget<QAction> ();
+    QAction *action = qWidget<QAction> ();
 
     switch (pId)
       {
       case uimenu::properties::ID_LABEL:
         action->setText (Utils::fromStdString (up.get_label ()));
         break;
 
       case uimenu::properties::ID_CHECKED:
@@ -221,23 +221,23 @@ namespace QtHandles
       case uimenu::properties::ID_POSITION:
         {
           if (m_separator)
             m_parent->removeAction (m_separator);
 
           m_parent->removeAction (action);
 
           int pos = static_cast<int> (up.get_position ());
-          QAction* before = 0;
+          QAction *before = 0;
 
           if (pos > 0)
             {
               int count = 0;
 
-              foreach (QAction* a, m_parent->actions ())
+              foreach (QAction *a, m_parent->actions ())
                 {
                   if (! a->isSeparator ())
                     {
                       count++;
                       if (pos <= count)
                         {
                           before = a;
                           break;
@@ -259,35 +259,35 @@ namespace QtHandles
         Object::update (pId);
         break;
       }
   }
 
   QWidget*
   Menu::menu (void)
   {
-    QAction* action = qWidget<QAction> ();
-    QMenu* _menu = action->menu ();
+    QAction *action = qWidget<QAction> ();
+    QMenu *_menu = action->menu ();
 
     if (! _menu)
       {
         _menu = new QMenu (action->parentWidget ());
         action->setMenu (_menu);
         action->setShortcut (QKeySequence ());
         connect (_menu, SIGNAL (aboutToShow (void)),
                  this, SLOT (actionHovered (void)));
       }
 
     return _menu;
   }
 
   void
   Menu::actionTriggered (void)
   {
-    QAction* action = qWidget<QAction> ();
+    QAction *action = qWidget<QAction> ();
 
     if (action->isCheckable ())
       action->setChecked (! action->isChecked ());
     gh_manager::post_callback (m_handle, "callback");
   }
 
   void
   Menu::actionHovered (void)
@@ -297,21 +297,21 @@ namespace QtHandles
 
   void
   Menu::updateSiblingPositions (void)
   {
     if (m_parent)
       {
         double count = 1.0;
 
-        foreach (QAction* a, m_parent->actions ())
+        foreach (QAction *a, m_parent->actions ())
           {
             if (! a->isSeparator ())
               {
-                Object* aObj = Object::fromQObject (a);
+                Object *aObj = Object::fromQObject (a);
 
                 if (aObj)
                   {
                     graphics_object go = aObj->object ();
 
                     // Probably overkill as a uimenu child can only be another
                     // uimenu object.
                     if (go.isa ("uimenu"))
diff --git a/libgui/graphics/Menu.h b/libgui/graphics/Menu.h
--- a/libgui/graphics/Menu.h
+++ b/libgui/graphics/Menu.h
@@ -33,35 +33,35 @@ class QWidget;
 namespace QtHandles
 {
 
   class Menu : public Object, public MenuContainer
   {
     Q_OBJECT
 
   public:
-    Menu (const graphics_object& go, QAction* action, Object* parent);
+    Menu (const graphics_object& go, QAction *action, Object *parent);
     ~Menu (void);
 
-    static Menu* create (const graphics_object& go);
+    static Menu * create (const graphics_object& go);
 
-    Container* innerContainer (void) { return 0; }
+    Container * innerContainer (void) { return 0; }
 
-    QWidget* menu (void);
+    QWidget * menu (void);
 
   protected:
     void update (int pId);
 
   private slots:
     void actionTriggered (void);
     void actionHovered (void);
 
   private:
     void updateSiblingPositions (void);
 
   private:
-    QWidget* m_parent;
-    QAction* m_separator;
+    QWidget *m_parent;
+    QAction *m_separator;
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/MenuContainer.h b/libgui/graphics/MenuContainer.h
--- a/libgui/graphics/MenuContainer.h
+++ b/libgui/graphics/MenuContainer.h
@@ -26,14 +26,14 @@ along with Octave; see the file COPYING.
 class QWidget;
 
 namespace QtHandles
 {
 
   class MenuContainer
   {
   public:
-    virtual QWidget* menu (void) = 0;
+    virtual QWidget * menu (void) = 0;
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/MouseModeActionGroup.cc b/libgui/graphics/MouseModeActionGroup.cc
--- a/libgui/graphics/MouseModeActionGroup.cc
+++ b/libgui/graphics/MouseModeActionGroup.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <QIcon>
 
 #include "Figure.h"
 #include "MouseModeActionGroup.h"
 
 namespace QtHandles
 {
 
-  MouseModeActionGroup::MouseModeActionGroup (QObject* xparent)
+  MouseModeActionGroup::MouseModeActionGroup (QObject *xparent)
     : QObject (xparent), m_current (0)
   {
     m_actions.append (new QAction (QIcon (":/images/rotate.png"),
                                    tr ("Rotate"), this));
     QAction *zoom_in = new QAction ("Z+", this);
     zoom_in->setToolTip (tr ("Zoom In"));
     m_actions.append (zoom_in);
 
@@ -48,17 +48,17 @@ namespace QtHandles
 
     m_actions.append (new QAction (QIcon (":/images/pan.png"),
                                    tr ("Pan"), this));
     m_actions.append (new QAction (QIcon::fromTheme ("insert-text"),
                                    tr ("Insert Text"), this));
     m_actions.append (new QAction (QIcon (":/images/select.png"),
                                    tr ("Select"), this));
 
-    foreach (QAction* a, m_actions)
+    foreach (QAction *a, m_actions)
       {
         a->setCheckable (true);
         connect (a, SIGNAL (toggled (bool)), this, SLOT (actionToggled (bool)));
       }
   }
 
   MouseModeActionGroup::~MouseModeActionGroup (void)
   { }
diff --git a/libgui/graphics/MouseModeActionGroup.h b/libgui/graphics/MouseModeActionGroup.h
--- a/libgui/graphics/MouseModeActionGroup.h
+++ b/libgui/graphics/MouseModeActionGroup.h
@@ -33,29 +33,29 @@ class QAction;
 namespace QtHandles
 {
 
   class MouseModeActionGroup : public QObject
   {
     Q_OBJECT
 
   public:
-    MouseModeActionGroup (QObject* parent = 0);
+    MouseModeActionGroup (QObject *parent = 0);
     ~MouseModeActionGroup (void);
 
     QList<QAction*> actions (void) const { return m_actions; }
 
     void setMode (MouseMode mode);
 
   signals:
     void modeChanged (MouseMode mode);
 
   private slots:
     void actionToggled (bool checked);
 
   private:
     QList<QAction*> m_actions;
-    QAction* m_current;
+    QAction *m_current;
   };
 
 };
 
 #endif
diff --git a/libgui/graphics/Object.cc b/libgui/graphics/Object.cc
--- a/libgui/graphics/Object.cc
+++ b/libgui/graphics/Object.cc
@@ -29,31 +29,31 @@ along with Octave; see the file COPYING.
 
 #include "Backend.h"
 #include "Object.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-  Object::Object (const graphics_object& go, QObject* obj)
+  Object::Object (const graphics_object& go, QObject *obj)
     : QObject (), m_handle (go.get_handle ()), m_qobject (0)
   {
     gh_manager::auto_lock lock (false);
 
     if (! lock)
       qCritical ("QtHandles::Object::Object: "
                  "creating Object (h=%g) without a valid lock!!!",
                  m_handle.value ());
 
     init (obj);
   }
 
   void
-  Object::init (QObject* obj, bool)
+  Object::init (QObject *obj, bool)
   {
     if (m_qobject)
       qCritical ("QtHandles::Object::init: "
                  "resetting QObject while in invalid state");
 
     m_qobject = obj;
 
     if (m_qobject)
@@ -150,35 +150,35 @@ namespace QtHandles
   void
   Object::print (const QString& /* file_cmd */, const QString& /* term */)
   { }
 
   void
   Object::beingDeleted (void)
   { }
 
-  void Object::objectDestroyed (QObject* obj)
+  void Object::objectDestroyed (QObject *obj)
   {
     if (obj && obj == m_qobject)
       m_qobject = 0;
   }
 
   Object*
   Object::parentObject (const graphics_object& go)
   {
     gh_manager::auto_lock lock;
 
-    Object* parent = Backend::toolkitObject
+    Object *parent = Backend::toolkitObject
                      (gh_manager::get_object (go.get_parent ()));
 
     return parent;
   }
 
   Object*
-  Object::fromQObject (QObject* obj)
+  Object::fromQObject (QObject *obj)
   {
     QVariant v = obj->property ("QtHandles::Object");
 
     if (v.isValid ())
       return reinterpret_cast<Object *> (qvariant_cast<void*> (v));
 
     return 0;
   }
diff --git a/libgui/graphics/Object.h b/libgui/graphics/Object.h
--- a/libgui/graphics/Object.h
+++ b/libgui/graphics/Object.h
@@ -37,17 +37,17 @@ namespace QtHandles
   class Container;
   class ObjectProxy;
 
   class Object : public QObject
   {
     Q_OBJECT
 
   public:
-    Object (const graphics_object& go, QObject* obj = 0);
+    Object (const graphics_object& go, QObject *obj = 0);
 
     virtual ~Object (void);
 
     base_properties& properties (void)
     { return object ().get_properties (); }
 
     const base_properties& properties (void) const
     { return object ().get_properties (); }
@@ -63,44 +63,44 @@ namespace QtHandles
     const typename T::properties& properties (void) const
     {
       return dynamic_cast<const typename T::properties&>
              (object ().get_properties ());
     }
 
     graphics_object object (void) const;
 
-    virtual QObject* qObject (void) { return m_qobject; }
+    virtual QObject * qObject (void) { return m_qobject; }
 
     template <typename T>
-    T* qWidget (void) { return qobject_cast<T *>(qObject ()); }
+    T * qWidget (void) { return qobject_cast<T *>(qObject ()); }
 
-    virtual Container* innerContainer (void) = 0;
+    virtual Container * innerContainer (void) = 0;
 
-    static Object* fromQObject (QObject* obj);
+    static Object * fromQObject (QObject *obj);
 
   public slots:
     void slotUpdate (int pId);
     void slotFinalize (void);
     void slotRedraw (void);
     void slotPrint (const QString& file_cmd, const QString& term);
 
     void objectDestroyed (QObject *obj = 0);
 
   protected:
-    static Object* parentObject (const graphics_object& go);
-    void init (QObject* obj, bool callBase = false);
+    static Object * parentObject (const graphics_object& go);
+    void init (QObject *obj, bool callBase = false);
 
     virtual void update (int pId);
     virtual void finalize (void);
     virtual void redraw (void);
     virtual void print (const QString& file_cmd, const QString& term);
 
     virtual void beingDeleted (void);
 
   protected:
     graphics_handle m_handle;
-    QObject* m_qobject;
+    QObject *m_qobject;
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/ObjectFactory.cc b/libgui/graphics/ObjectFactory.cc
--- a/libgui/graphics/ObjectFactory.cc
+++ b/libgui/graphics/ObjectFactory.cc
@@ -79,25 +79,25 @@ namespace QtHandles
     graphics_object go (gh_manager::get_object (graphics_handle (handle)));
 
     if (go.valid_object ())
       {
         if (go.get_properties ().is_beingdeleted ())
           qWarning ("ObjectFactory::createObject: object is being deleted");
         else
           {
-            ObjectProxy* proxy = Backend::toolkitObjectProxy (go);
+            ObjectProxy *proxy = Backend::toolkitObjectProxy (go);
 
             if (proxy)
               {
                 Logger::debug ("ObjectFactory::createObject: "
                                "create %s from thread %08x",
                                go.type ().c_str (), QThread::currentThreadId ());
 
-                Object* obj = 0;
+                Object *obj = 0;
 
                 if (go.isa ("figure"))
                   obj = Figure::create (go);
                 else if (go.isa ("uicontrol"))
                   {
                     uicontrol::properties& up =
                       Utils::properties<uicontrol> (go);
 
diff --git a/libgui/graphics/ObjectFactory.h b/libgui/graphics/ObjectFactory.h
--- a/libgui/graphics/ObjectFactory.h
+++ b/libgui/graphics/ObjectFactory.h
@@ -32,17 +32,17 @@ namespace QtHandles
 
   class Object;
 
   class ObjectFactory : public QObject
   {
     Q_OBJECT
 
   public:
-    static ObjectFactory* instance (void);
+    static ObjectFactory * instance (void);
 
   public slots:
     void createObject (double handle);
 
   private:
     ObjectFactory (void)
       : QObject ()
     { }
diff --git a/libgui/graphics/ObjectProxy.cc b/libgui/graphics/ObjectProxy.cc
--- a/libgui/graphics/ObjectProxy.cc
+++ b/libgui/graphics/ObjectProxy.cc
@@ -29,24 +29,24 @@ along with Octave; see the file COPYING.
 #include "oct-mutex.h"
 
 #include "Object.h"
 #include "ObjectProxy.h"
 
 namespace QtHandles
 {
 
-  ObjectProxy::ObjectProxy (Object* obj)
+  ObjectProxy::ObjectProxy (Object *obj)
     : QObject (), m_object (0)
   {
     init (obj);
   }
 
   void
-  ObjectProxy::init (Object* obj)
+  ObjectProxy::init (Object *obj)
   {
     if (obj != m_object)
       {
         if (m_object)
           {
             disconnect (this, SIGNAL (sendUpdate (int)),
                         m_object, SLOT (slotUpdate (int)));
             disconnect (this, SIGNAL (sendFinalize (void)),
@@ -70,17 +70,17 @@ namespace QtHandles
             connect (this, SIGNAL (sendPrint (const QString&, const QString&)),
                      m_object, SLOT (slotPrint (const QString&, const QString&)),
                      Qt::BlockingQueuedConnection);
           }
       }
   }
 
   void
-  ObjectProxy::setObject (Object* obj)
+  ObjectProxy::setObject (Object *obj)
   {
     emit sendFinalize ();
     init (obj);
   }
 
   void
   ObjectProxy::update (int pId)
   {
diff --git a/libgui/graphics/ObjectProxy.h b/libgui/graphics/ObjectProxy.h
--- a/libgui/graphics/ObjectProxy.h
+++ b/libgui/graphics/ObjectProxy.h
@@ -32,34 +32,34 @@ namespace QtHandles
 
   class Object;
 
   class ObjectProxy : public QObject
   {
     Q_OBJECT
 
   public:
-    ObjectProxy (Object* obj = 0);
+    ObjectProxy (Object *obj = 0);
 
     void update (int pId);
     void finalize (void);
     void redraw (void);
     void print (const QString& file_cmd, const QString& term);
 
-    Object* object (void) { return m_object; }
-    void setObject (Object* obj);
+    Object * object (void) { return m_object; }
+    void setObject (Object *obj);
 
   signals:
     void sendUpdate (int pId);
     void sendFinalize (void);
     void sendRedraw (void);
     void sendPrint (const QString& file_cmd, const QString& term);
 
   private:
-    void init (Object* obj);
+    void init (Object *obj);
 
   private:
-    Object* m_object;
+    Object *m_object;
   };
 
 };
 
 #endif
diff --git a/libgui/graphics/Panel.cc b/libgui/graphics/Panel.cc
--- a/libgui/graphics/Panel.cc
+++ b/libgui/graphics/Panel.cc
@@ -82,30 +82,30 @@ namespace QtHandles
       }
 
     return bw;
   }
 
   Panel*
   Panel::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        Container* container = parent->innerContainer ();
+        Container *container = parent->innerContainer ();
 
         if (container)
           return new Panel (go, new QFrame (container));
       }
 
     return 0;
   }
 
-  Panel::Panel (const graphics_object& go, QFrame* frame)
+  Panel::Panel (const graphics_object& go, QFrame *frame)
     : Object (go, frame), m_container (0), m_title (0), m_blockUpdates (false)
   {
     uipanel::properties& pp = properties<uipanel> ();
 
     frame->setObjectName ("UIPanel");
     frame->setAutoFillBackground (true);
     Matrix bb = pp.get_boundingbox (false);
     frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
@@ -116,17 +116,17 @@ namespace QtHandles
     setupPalette (pp, pal);
     frame->setPalette (pal);
 
     m_container = new Container (frame);
     m_container->canvas (m_handle);
 
     if (frame->hasMouseTracking ())
       {
-        foreach (QWidget* w, frame->findChildren<QWidget*> ())
+        foreach (QWidget *w, frame->findChildren<QWidget*> ())
           w->setMouseTracking (true);
       }
 
     QString title = Utils::fromStdString (pp.get_title ());
     if (! title.isEmpty ())
       {
         m_title = new QLabel (title, frame);
         m_title->setAutoFillBackground (true);
@@ -143,17 +143,17 @@ namespace QtHandles
     else
       frame->hide ();
   }
 
   Panel::~Panel (void)
   { }
 
   bool
-  Panel::eventFilter (QObject* watched, QEvent* xevent)
+  Panel::eventFilter (QObject *watched, QEvent *xevent)
   {
     if (! m_blockUpdates)
       {
         if (watched == qObject ())
           {
             switch (xevent->type ())
               {
               case QEvent::Resize:
@@ -165,31 +165,31 @@ namespace QtHandles
                     {
                       if (m_title)
                         {
                           const uipanel::properties& pp =
                             Utils::properties<uipanel> (go);
 
                           if (pp.fontunits_is ("normalized"))
                             {
-                              QFrame* frame = qWidget<QFrame> ();
+                              QFrame *frame = qWidget<QFrame> ();
 
                               m_title->setFont (Utils::computeFont<uipanel>
                                                 (pp, frame->height ()));
                               m_title->resize (m_title->sizeHint ());
                             }
                         }
                       updateLayout ();
                     }
                 }
                 break;
 
               case QEvent::MouseButtonPress:
                 {
-                  QMouseEvent* m = dynamic_cast<QMouseEvent *> (xevent);
+                  QMouseEvent *m = dynamic_cast<QMouseEvent *> (xevent);
 
                   if (m->button () == Qt::RightButton)
                     {
                       gh_manager::auto_lock lock;
 
                       graphics_object go = object ();
 
                       if (go.valid_object ())
@@ -227,17 +227,17 @@ namespace QtHandles
 
     return false;
   }
 
   void
   Panel::update (int pId)
   {
     uipanel::properties& pp = properties<uipanel> ();
-    QFrame* frame = qWidget<QFrame> ();
+    QFrame *frame = qWidget<QFrame> ();
 
     m_blockUpdates = true;
 
     switch (pId)
       {
       case uipanel::properties::ID_POSITION:
         {
           Matrix bb = pp.get_boundingbox (false);
@@ -331,27 +331,27 @@ namespace QtHandles
       }
 
     m_blockUpdates = false;
   }
 
   void
   Panel::redraw (void)
   {
-    Canvas* canvas = m_container->canvas (m_handle);
+    Canvas *canvas = m_container->canvas (m_handle);
 
     if (canvas)
       canvas->redraw ();
   }
 
   void
   Panel::updateLayout (void)
   {
     uipanel::properties& pp = properties<uipanel> ();
-    QFrame* frame = qWidget<QFrame> ();
+    QFrame *frame = qWidget<QFrame> ();
 
     Matrix bb = pp.get_boundingbox (true);
     int bw = borderWidthFromProperties (pp);
 
     frame->setFrameRect (QRect (octave::math::round (bb(0)) - bw,
                                 octave::math::round (bb(1)) - bw,
                                 octave::math::round (bb(2)) + 2*bw, octave::math::round (bb(3)) + 2*bw));
     m_container->setGeometry (octave::math::round (bb(0)),
diff --git a/libgui/graphics/Panel.h b/libgui/graphics/Panel.h
--- a/libgui/graphics/Panel.h
+++ b/libgui/graphics/Panel.h
@@ -31,33 +31,33 @@ class QLabel;
 namespace QtHandles
 {
 
   class Container;
 
   class Panel : public Object
   {
   public:
-    Panel (const graphics_object& go, QFrame* frame);
+    Panel (const graphics_object& go, QFrame *frame);
     ~Panel (void);
 
-    Container* innerContainer (void) { return m_container; }
+    Container * innerContainer (void) { return m_container; }
 
-    bool eventFilter (QObject* watched, QEvent* event);
+    bool eventFilter (QObject *watched, QEvent *event);
 
-    static Panel* create (const graphics_object& go);
+    static Panel * create (const graphics_object& go);
 
   protected:
     void update (int pId);
     void redraw (void);
 
   private:
     void updateLayout (void);
 
   private:
-    Container* m_container;
-    QLabel* m_title;
+    Container *m_container;
+    QLabel *m_title;
     bool m_blockUpdates;
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/PopupMenuControl.cc b/libgui/graphics/PopupMenuControl.cc
--- a/libgui/graphics/PopupMenuControl.cc
+++ b/libgui/graphics/PopupMenuControl.cc
@@ -31,21 +31,21 @@ along with Octave; see the file COPYING.
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   PopupMenuControl*
   PopupMenuControl::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        Container* container = parent->innerContainer ();
+        Container *container = parent->innerContainer ();
 
         if (container)
           return new PopupMenuControl (go, new QComboBox (container));
       }
 
     return 0;
   }
 
@@ -63,17 +63,17 @@ namespace QtHandles
   }
 
   PopupMenuControl::~PopupMenuControl (void)
   { }
 
   void PopupMenuControl::update (int pId)
   {
     uicontrol::properties& up = properties<uicontrol> ();
-    QComboBox* box = qWidget<QComboBox> ();
+    QComboBox *box = qWidget<QComboBox> ();
 
     switch (pId)
       {
       case uicontrol::properties::ID_STRING:
         m_blockUpdate = true;
         {
           int oldCurrent = box->currentIndex ();
 
diff --git a/libgui/graphics/PopupMenuControl.h b/libgui/graphics/PopupMenuControl.h
--- a/libgui/graphics/PopupMenuControl.h
+++ b/libgui/graphics/PopupMenuControl.h
@@ -30,20 +30,20 @@ class QComboBox;
 namespace QtHandles
 {
 
   class PopupMenuControl : public BaseControl
   {
     Q_OBJECT
 
   public:
-    PopupMenuControl (const graphics_object& go, QComboBox* box);
+    PopupMenuControl (const graphics_object& go, QComboBox *box);
     ~PopupMenuControl (void);
 
-    static PopupMenuControl* create (const graphics_object& go);
+    static PopupMenuControl * create (const graphics_object& go);
 
   protected:
     void update (int pId);
 
   private slots:
     void currentIndexChanged (int index);
 
   private:
diff --git a/libgui/graphics/PushButtonControl.cc b/libgui/graphics/PushButtonControl.cc
--- a/libgui/graphics/PushButtonControl.cc
+++ b/libgui/graphics/PushButtonControl.cc
@@ -32,44 +32,44 @@ along with Octave; see the file COPYING.
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   PushButtonControl*
   PushButtonControl::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        Container* container = parent->innerContainer ();
+        Container *container = parent->innerContainer ();
 
         if (container)
           return new PushButtonControl (go, new QPushButton (container));
       }
 
     return 0;
   }
 
   PushButtonControl::PushButtonControl (const graphics_object& go,
-                                        QPushButton* btn)
+                                        QPushButton *btn)
     : ButtonControl (go, btn)
   {
     btn->setAutoFillBackground (true);
   }
 
   PushButtonControl::~PushButtonControl (void)
   { }
 
   void
   PushButtonControl::update (int pId)
   {
     uicontrol::properties& up = properties<uicontrol> ();
-    QPushButton* btn = qWidget<QPushButton> ();
+    QPushButton *btn = qWidget<QPushButton> ();
 
     switch (pId)
       {
       case uicontrol::properties::ID_STRING:
         btn->setText (Utils::fromStdString (up.get_string_string ()));
         break;
 
       default:
diff --git a/libgui/graphics/PushButtonControl.h b/libgui/graphics/PushButtonControl.h
--- a/libgui/graphics/PushButtonControl.h
+++ b/libgui/graphics/PushButtonControl.h
@@ -28,20 +28,20 @@ along with Octave; see the file COPYING.
 class QPushButton;
 
 namespace QtHandles
 {
 
   class PushButtonControl : public ButtonControl
   {
   public:
-    PushButtonControl (const graphics_object& go, QPushButton* btn);
+    PushButtonControl (const graphics_object& go, QPushButton *btn);
     ~PushButtonControl (void);
 
-    static PushButtonControl* create (const graphics_object& go);
+    static PushButtonControl * create (const graphics_object& go);
 
   protected:
     void update (int pId);
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/PushTool.cc b/libgui/graphics/PushTool.cc
--- a/libgui/graphics/PushTool.cc
+++ b/libgui/graphics/PushTool.cc
@@ -29,30 +29,30 @@ along with Octave; see the file COPYING.
 #include "ToolBarButton.cc"
 
 namespace QtHandles
 {
 
   PushTool*
   PushTool::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        QWidget* parentWidget = parent->qWidget<QWidget> ();
+        QWidget *parentWidget = parent->qWidget<QWidget> ();
 
         if (parentWidget)
           return new PushTool (go, new QAction (parentWidget));
       }
 
     return 0;
   }
 
-  PushTool::PushTool (const graphics_object& go, QAction* action)
+  PushTool::PushTool (const graphics_object& go, QAction *action)
     : ToolBarButton<uipushtool> (go, action)
   {
     connect (action, SIGNAL (triggered (bool)), this, SLOT (clicked (void)));
   }
 
   PushTool::~PushTool (void)
   { }
 
diff --git a/libgui/graphics/PushTool.h b/libgui/graphics/PushTool.h
--- a/libgui/graphics/PushTool.h
+++ b/libgui/graphics/PushTool.h
@@ -28,20 +28,20 @@ along with Octave; see the file COPYING.
 namespace QtHandles
 {
 
   class PushTool : public ToolBarButton<uipushtool>
   {
     Q_OBJECT
 
   public:
-    PushTool (const graphics_object& go, QAction* action);
+    PushTool (const graphics_object& go, QAction *action);
     ~PushTool (void);
 
-    static PushTool* create (const graphics_object& go);
+    static PushTool * create (const graphics_object& go);
 
   protected:
     void update (int pId);
 
   private slots:
     void clicked (void);
   };
 
diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -150,29 +150,29 @@ namespace QtHandles
 
       return c;
     }
 
     Matrix
     toRgb (const QColor& c)
     {
       Matrix rgb (1, 3);
-      double* rgbData = rgb.fortran_vec ();
+      double *rgbData = rgb.fortran_vec ();
 
       // qreal is a typedef for double except for ARM CPU architectures
       // where it is a typedef for float (Bug #44970).
       qreal tmp[3];
       c.getRgbF (tmp, tmp+1, tmp+2);
       rgbData[0] = tmp[0]; rgbData[1] = tmp[1]; rgbData[2] = tmp[2];
 
       return rgb;
     }
 
     std::string
-    figureSelectionType (QMouseEvent* event, bool isDoubleClick)
+    figureSelectionType (QMouseEvent *event, bool isDoubleClick)
     {
       if (isDoubleClick)
         return std::string ("open");
       else
         {
           Qt::MouseButtons buttons = event->buttons ();
           Qt::KeyboardModifiers mods = event->modifiers ();
 
@@ -203,44 +203,44 @@ namespace QtHandles
     }
 
     /*
        Two figureCurrentPoint() routines are required:
        1) Used for QMouseEvents where cursor position data is in callback from Qt.
        2) Used for QKeyEvents where cursor position must be determined.
     */
     Matrix
-    figureCurrentPoint (const graphics_object& fig, QMouseEvent* event)
+    figureCurrentPoint (const graphics_object& fig, QMouseEvent *event)
     {
-      Object* tkFig = Backend::toolkitObject (fig);
+      Object *tkFig = Backend::toolkitObject (fig);
 
       if (tkFig)
         {
-          Container* c = tkFig->innerContainer ();
+          Container *c = tkFig->innerContainer ();
 
           if (c)
             {
               QPoint qp = c->mapFromGlobal (event->globalPos ());
 
               return tkFig->properties<figure> ().map_from_boundingbox (qp.x (),
                      qp.y ());
             }
         }
 
       return Matrix (1, 2, 0.0);
     }
 
     Matrix
     figureCurrentPoint (const graphics_object& fig)
     {
-      Object* tkFig = Backend::toolkitObject (fig);
+      Object *tkFig = Backend::toolkitObject (fig);
 
       if (tkFig)
         {
-          Container* c = tkFig->innerContainer ();
+          Container *c = tkFig->innerContainer ();
 
           if (c)
             {
               // FIXME: QCursor::pos() may give inaccurate results with
               //        asynchronous window systems like X11 over ssh.
               QPoint qp = c->mapFromGlobal (QCursor::pos ());
 
               return tkFig->properties<figure> ().map_from_boundingbox (qp.x (),
@@ -351,17 +351,17 @@ namespace QtHandles
 
           return img;
         }
 
       return QImage ();
     }
 
     octave_scalar_map
-    makeKeyEventStruct (QKeyEvent* event)
+    makeKeyEventStruct (QKeyEvent *event)
     {
       octave_scalar_map retval;
 
       retval.setfield ("Key", KeyMap::qKeyToKeyString (event->key ()));
       retval.setfield ("Character", toStdString (event->text ()));
 
       std::list<std::string> modList;
       Qt::KeyboardModifiers mods = event->modifiers ();
diff --git a/libgui/graphics/QtHandlesUtils.h b/libgui/graphics/QtHandlesUtils.h
--- a/libgui/graphics/QtHandlesUtils.h
+++ b/libgui/graphics/QtHandlesUtils.h
@@ -53,33 +53,33 @@ namespace QtHandles
     QFont computeFont (const typename T::properties& props, int height = -1);
 
     QColor fromRgb (const Matrix& rgb);
     Matrix toRgb (const QColor& c);
 
     Qt::Alignment fromHVAlign (const std::string& halign,
                                const std::string& valign);
 
-    std::string figureSelectionType (QMouseEvent* event,
+    std::string figureSelectionType (QMouseEvent *event,
                                      bool isDoubleClick = false);
 
-    Matrix figureCurrentPoint (const graphics_object& fig, QMouseEvent* event);
+    Matrix figureCurrentPoint (const graphics_object& fig, QMouseEvent *event);
     Matrix figureCurrentPoint (const graphics_object& fig);
 
     template <typename T>
     inline typename T::properties&
     properties (graphics_object obj)
     { return dynamic_cast<typename T::properties&> (obj.get_properties ()); }
 
     template <typename T>
     inline typename T::properties&
     properties (const graphics_handle& h)
     { return Utils::properties<T> (gh_manager::get_object (h)); }
 
     QImage makeImageFromCData (const octave_value& v, int width = -1,
                                int height = -1);
 
-    octave_scalar_map makeKeyEventStruct (QKeyEvent* event);
+    octave_scalar_map makeKeyEventStruct (QKeyEvent *event);
   }
 
 }
 
 #endif
diff --git a/libgui/graphics/RadioButtonControl.cc b/libgui/graphics/RadioButtonControl.cc
--- a/libgui/graphics/RadioButtonControl.cc
+++ b/libgui/graphics/RadioButtonControl.cc
@@ -32,35 +32,35 @@ along with Octave; see the file COPYING.
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   RadioButtonControl*
   RadioButtonControl::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        Container* container = parent->innerContainer ();
+        Container *container = parent->innerContainer ();
 
         if (container)
           return new RadioButtonControl (go, new QRadioButton (container));
       }
 
     return 0;
   }
 
   RadioButtonControl::RadioButtonControl (const graphics_object& go,
-                                          QRadioButton* radio)
+                                          QRadioButton *radio)
     : ButtonControl (go, radio)
   {
-    Object* parent = Object::parentObject (go);
-    ButtonGroup* btnGroup = dynamic_cast<ButtonGroup *>(parent);
+    Object *parent = Object::parentObject (go);
+    ButtonGroup *btnGroup = dynamic_cast<ButtonGroup *>(parent);
     if (btnGroup)
       btnGroup->addButton (radio);
 
     radio->setAutoFillBackground (true);
     radio->setAutoExclusive (false);
   }
 
   RadioButtonControl::~RadioButtonControl (void)
diff --git a/libgui/graphics/RadioButtonControl.h b/libgui/graphics/RadioButtonControl.h
--- a/libgui/graphics/RadioButtonControl.h
+++ b/libgui/graphics/RadioButtonControl.h
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 class QRadioButton;
 
 namespace QtHandles
 {
 
   class RadioButtonControl : public ButtonControl
   {
   public:
-    RadioButtonControl (const graphics_object& go, QRadioButton* box);
+    RadioButtonControl (const graphics_object& go, QRadioButton *box);
     ~RadioButtonControl (void);
 
-    static RadioButtonControl* create (const graphics_object& go);
+    static RadioButtonControl * create (const graphics_object& go);
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/SliderControl.cc b/libgui/graphics/SliderControl.cc
--- a/libgui/graphics/SliderControl.cc
+++ b/libgui/graphics/SliderControl.cc
@@ -33,31 +33,31 @@ along with Octave; see the file COPYING.
 #define RANGE_INT_MAX 1000000
 
 namespace QtHandles
 {
 
   SliderControl*
   SliderControl::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        Container* container = parent->innerContainer ();
+        Container *container = parent->innerContainer ();
 
         if (container)
           return new SliderControl (go, new QScrollBar (container));
       }
 
     return 0;
   }
 
   SliderControl::SliderControl (const graphics_object& go,
-                                QAbstractSlider* slider)
+                                QAbstractSlider *slider)
     : BaseControl (go, slider), m_blockUpdates (false)
   {
     uicontrol::properties& up = properties<uicontrol> ();
 
     slider->setTracking (false);
     Matrix bb = up.get_boundingbox ();
     bool vertical_slider = ( bb(2) < bb(3) );
     slider->setOrientation (vertical_slider ? Qt::Vertical : Qt::Horizontal);
@@ -82,17 +82,17 @@ namespace QtHandles
 
   SliderControl::~SliderControl (void)
   { }
 
   void
   SliderControl::update (int pId)
   {
     uicontrol::properties& up = properties<uicontrol> ();
-    QScrollBar* slider = qWidget<QScrollBar> ();
+    QScrollBar *slider = qWidget<QScrollBar> ();
 
     switch (pId)
       {
       case uicontrol::properties::ID_SLIDERSTEP:
         {
           Matrix steps = up.get_sliderstep ().matrix_value ();
 
           slider->setSingleStep (octave::math::round (steps(0) * RANGE_INT_MAX));
diff --git a/libgui/graphics/SliderControl.h b/libgui/graphics/SliderControl.h
--- a/libgui/graphics/SliderControl.h
+++ b/libgui/graphics/SliderControl.h
@@ -30,20 +30,20 @@ class QAbstractSlider;
 namespace QtHandles
 {
 
   class SliderControl : public BaseControl
   {
     Q_OBJECT
 
   public:
-    SliderControl (const graphics_object& go, QAbstractSlider* slider);
+    SliderControl (const graphics_object& go, QAbstractSlider *slider);
     ~SliderControl (void);
 
-    static SliderControl* create (const graphics_object& go);
+    static SliderControl * create (const graphics_object& go);
 
   protected:
     void update (int pId);
 
   private slots:
     void valueChanged (int ival);
 
   private:
diff --git a/libgui/graphics/TextControl.cc b/libgui/graphics/TextControl.cc
--- a/libgui/graphics/TextControl.cc
+++ b/libgui/graphics/TextControl.cc
@@ -31,30 +31,30 @@ along with Octave; see the file COPYING.
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   TextControl*
   TextControl::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        Container* container = parent->innerContainer ();
+        Container *container = parent->innerContainer ();
 
         if (container)
           return new TextControl (go, new QLabel (container));
       }
 
     return 0;
   }
 
-  TextControl::TextControl (const graphics_object& go, QLabel* label)
+  TextControl::TextControl (const graphics_object& go, QLabel *label)
     : BaseControl (go, label)
   {
     uicontrol::properties& up = properties<uicontrol> ();
 
     label->setAutoFillBackground (true);
     label->setTextFormat (Qt::PlainText);
     label->setWordWrap (false);
     label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
@@ -64,17 +64,17 @@ namespace QtHandles
 
   TextControl::~TextControl (void)
   { }
 
   void
   TextControl::update (int pId)
   {
     uicontrol::properties& up = properties<uicontrol> ();
-    QLabel* label = qWidget<QLabel> ();
+    QLabel *label = qWidget<QLabel> ();
 
     switch (pId)
       {
       case uicontrol::properties::ID_STRING:
         label->setText (Utils::fromStringVector (up.get_string_vector ()).join ("\n"));
         break;
 
       case uicontrol::properties::ID_HORIZONTALALIGNMENT:
diff --git a/libgui/graphics/TextControl.h b/libgui/graphics/TextControl.h
--- a/libgui/graphics/TextControl.h
+++ b/libgui/graphics/TextControl.h
@@ -28,20 +28,20 @@ along with Octave; see the file COPYING.
 class QLabel;
 
 namespace QtHandles
 {
 
   class TextControl : public BaseControl
   {
   public:
-    TextControl (const graphics_object& go, QLabel* label);
+    TextControl (const graphics_object& go, QLabel *label);
     ~TextControl (void);
 
-    static TextControl* create (const graphics_object& go);
+    static TextControl * create (const graphics_object& go);
 
   protected:
     void update (int pId);
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/TextEdit.cc b/libgui/graphics/TextEdit.cc
--- a/libgui/graphics/TextEdit.cc
+++ b/libgui/graphics/TextEdit.cc
@@ -27,25 +27,25 @@ along with Octave; see the file COPYING.
 #include <QKeyEvent>
 
 #include "TextEdit.h"
 
 namespace QtHandles
 {
 
   void
-  TextEdit::focusOutEvent (QFocusEvent* xevent)
+  TextEdit::focusOutEvent (QFocusEvent *xevent)
   {
     QTextEdit::focusOutEvent (xevent);
 
     emit editingFinished ();
   }
 
   void
-  TextEdit::keyPressEvent (QKeyEvent* xevent)
+  TextEdit::keyPressEvent (QKeyEvent *xevent)
   {
     QTextEdit::keyPressEvent (xevent);
 
     if ((xevent->key () == Qt::Key_Return
          || xevent->key () == Qt::Key_Enter)
         && xevent->modifiers () == Qt::ControlModifier)
       emit returnPressed ();
   }
diff --git a/libgui/graphics/TextEdit.h b/libgui/graphics/TextEdit.h
--- a/libgui/graphics/TextEdit.h
+++ b/libgui/graphics/TextEdit.h
@@ -28,23 +28,23 @@ along with Octave; see the file COPYING.
 namespace QtHandles
 {
 
   class TextEdit : public QTextEdit
   {
     Q_OBJECT
 
   public:
-    TextEdit (QWidget* xparent) : QTextEdit (xparent) { }
+    TextEdit (QWidget *xparent) : QTextEdit (xparent) { }
     ~TextEdit (void) = default;
 
   signals:
     void editingFinished (void);
     void returnPressed (void);
 
   protected:
-    void focusOutEvent (QFocusEvent* event);
-    void keyPressEvent (QKeyEvent* event);
+    void focusOutEvent (QFocusEvent *event);
+    void keyPressEvent (QKeyEvent *event);
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/ToggleButtonControl.cc b/libgui/graphics/ToggleButtonControl.cc
--- a/libgui/graphics/ToggleButtonControl.cc
+++ b/libgui/graphics/ToggleButtonControl.cc
@@ -32,35 +32,35 @@ along with Octave; see the file COPYING.
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   ToggleButtonControl*
   ToggleButtonControl::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        Container* container = parent->innerContainer ();
+        Container *container = parent->innerContainer ();
 
         if (container)
           return new ToggleButtonControl (go, new QPushButton (container));
       }
 
     return 0;
   }
 
   ToggleButtonControl::ToggleButtonControl (const graphics_object& go,
-      QPushButton* btn)
+      QPushButton *btn)
     : ButtonControl (go, btn)
   {
-    Object* parent = Object::parentObject (go);
-    ButtonGroup* btnGroup = dynamic_cast<ButtonGroup *>(parent);
+    Object *parent = Object::parentObject (go);
+    ButtonGroup *btnGroup = dynamic_cast<ButtonGroup *>(parent);
     if (btnGroup)
       btnGroup->addButton (btn);
 
     btn->setCheckable (true);
     btn->setAutoFillBackground (true);
   }
 
   ToggleButtonControl::~ToggleButtonControl (void)
diff --git a/libgui/graphics/ToggleButtonControl.h b/libgui/graphics/ToggleButtonControl.h
--- a/libgui/graphics/ToggleButtonControl.h
+++ b/libgui/graphics/ToggleButtonControl.h
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 class QPushButton;
 
 namespace QtHandles
 {
 
   class ToggleButtonControl : public ButtonControl
   {
   public:
-    ToggleButtonControl (const graphics_object& go, QPushButton* box);
+    ToggleButtonControl (const graphics_object& go, QPushButton *box);
     ~ToggleButtonControl (void);
 
-    static ToggleButtonControl* create (const graphics_object& go);
+    static ToggleButtonControl * create (const graphics_object& go);
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/ToggleTool.cc b/libgui/graphics/ToggleTool.cc
--- a/libgui/graphics/ToggleTool.cc
+++ b/libgui/graphics/ToggleTool.cc
@@ -29,30 +29,30 @@ along with Octave; see the file COPYING.
 #include "ToolBarButton.cc"
 
 namespace QtHandles
 {
 
   ToggleTool*
   ToggleTool::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        QWidget* parentWidget = parent->qWidget<QWidget> ();
+        QWidget *parentWidget = parent->qWidget<QWidget> ();
 
         if (parentWidget)
           return new ToggleTool (go, new QAction (parentWidget));
       }
 
     return 0;
   }
 
-  ToggleTool::ToggleTool (const graphics_object& go, QAction* action)
+  ToggleTool::ToggleTool (const graphics_object& go, QAction *action)
     : ToolBarButton<uitoggletool> (go, action)
   {
     uitoggletool::properties& tp = properties<uitoggletool> ();
 
     action->setCheckable (true);
     action->setChecked (tp.is_state ());
 
     connect (action, SIGNAL (toggled (bool)),
@@ -61,17 +61,17 @@ namespace QtHandles
 
   ToggleTool::~ToggleTool (void)
   { }
 
   void
   ToggleTool::update (int pId)
   {
     uitoggletool::properties& tp = properties<uitoggletool> ();
-    QAction* action = qWidget<QAction> ();
+    QAction *action = qWidget<QAction> ();
 
     switch (pId)
       {
       case uitoggletool::properties::ID_STATE:
         action->setChecked (tp.is_state ());
         break;
 
       default:
diff --git a/libgui/graphics/ToggleTool.h b/libgui/graphics/ToggleTool.h
--- a/libgui/graphics/ToggleTool.h
+++ b/libgui/graphics/ToggleTool.h
@@ -28,20 +28,20 @@ along with Octave; see the file COPYING.
 namespace QtHandles
 {
 
   class ToggleTool : public ToolBarButton<uitoggletool>
   {
     Q_OBJECT
 
   public:
-    ToggleTool (const graphics_object& go, QAction* action);
+    ToggleTool (const graphics_object& go, QAction *action);
     ~ToggleTool (void);
 
-    static ToggleTool* create (const graphics_object& go);
+    static ToggleTool * create (const graphics_object& go);
 
   protected:
     void update (int pId);
 
   private slots:
     void triggered (bool checked);
   };
 
diff --git a/libgui/graphics/ToolBar.cc b/libgui/graphics/ToolBar.cc
--- a/libgui/graphics/ToolBar.cc
+++ b/libgui/graphics/ToolBar.cc
@@ -37,54 +37,54 @@ along with Octave; see the file COPYING.
 #include "Figure.h"
 #include "ToolBar.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   static QAction*
-  addEmptyAction (QToolBar* bar)
+  addEmptyAction (QToolBar *bar)
   {
     static QIcon _empty;
 
     if (_empty.isNull ())
       {
         QPixmap pix (16, 16);
 
         pix.fill (Qt::transparent);
 
         _empty = QIcon (pix);
       }
 
-    QAction* a = bar->addAction (_empty, "Empty Toolbar");
+    QAction *a = bar->addAction (_empty, "Empty Toolbar");
 
     a->setEnabled (false);
     a->setToolTip ("");
 
     return a;
   }
 
   ToolBar*
   ToolBar::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        QWidget* parentWidget = parent->qWidget<QWidget> ();
+        QWidget *parentWidget = parent->qWidget<QWidget> ();
 
         if (parentWidget)
           return new ToolBar (go, new QToolBar (parentWidget));
       }
 
     return 0;
   }
 
-  ToolBar::ToolBar (const graphics_object& go, QToolBar* bar)
+  ToolBar::ToolBar (const graphics_object& go, QToolBar *bar)
     : Object (go, bar), m_empty (0), m_figure (0)
   {
     uitoolbar::properties& tp = properties<uitoolbar> ();
 
     bar->setFloatable (false);
     bar->setMovable (false);
     bar->setVisible (tp.is_visible ());
 
@@ -101,43 +101,43 @@ namespace QtHandles
 
   ToolBar::~ToolBar (void)
   { }
 
   void
   ToolBar::update (int pId)
   {
     uitoolbar::properties& tp = properties<uitoolbar> ();
-    QToolBar* bar = qWidget<QToolBar> ();
+    QToolBar *bar = qWidget<QToolBar> ();
 
     switch (pId)
       {
       case base_properties::ID_VISIBLE:
         if (m_figure)
           m_figure->showCustomToolBar (bar, tp.is_visible ());
         break;
 
       default:
         Object::update (pId);
         break;
       }
   }
 
   bool
-  ToolBar::eventFilter (QObject* watched, QEvent* xevent)
+  ToolBar::eventFilter (QObject *watched, QEvent *xevent)
   {
     if (watched == qObject ())
       {
         switch (xevent->type ())
           {
           case QEvent::ActionAdded:
           case QEvent::ActionRemoved:
             {
-              QActionEvent* ae = dynamic_cast<QActionEvent *> (xevent);
-              QToolBar* bar = qWidget<QToolBar> ();
+              QActionEvent *ae = dynamic_cast<QActionEvent *> (xevent);
+              QToolBar *bar = qWidget<QToolBar> ();
 
               if (ae->action () != m_empty)
                 {
                   if (xevent->type () == QEvent::ActionAdded)
                     {
                       if (bar->actions ().size () == 2)
                         QTimer::singleShot (0, this, SLOT (hideEmpty (void)));
                     }
@@ -164,16 +164,16 @@ namespace QtHandles
     m_empty->setVisible (false);
   }
 
   void
   ToolBar::beingDeleted (void)
   {
     if (m_figure)
       {
-        QToolBar* bar = qWidget<QToolBar> ();
+        QToolBar *bar = qWidget<QToolBar> ();
 
         if (bar)
           m_figure->showCustomToolBar (bar, false);
       }
   }
 
 }
diff --git a/libgui/graphics/ToolBar.h b/libgui/graphics/ToolBar.h
--- a/libgui/graphics/ToolBar.h
+++ b/libgui/graphics/ToolBar.h
@@ -33,32 +33,32 @@ namespace QtHandles
 
   class Figure;
 
   class ToolBar : public Object
   {
     Q_OBJECT
 
   public:
-    ToolBar (const graphics_object& go, QToolBar* bar);
+    ToolBar (const graphics_object& go, QToolBar *bar);
     ~ToolBar (void);
 
-    static ToolBar* create (const graphics_object& go);
+    static ToolBar * create (const graphics_object& go);
 
-    Container* innerContainer (void) { return 0; }
+    Container * innerContainer (void) { return 0; }
 
-    bool eventFilter (QObject* watched, QEvent* event);
+    bool eventFilter (QObject *watched, QEvent *event);
 
   protected:
     void update (int pId);
     void beingDeleted (void);
 
   private slots:
     void hideEmpty (void);
 
   private:
-    QAction* m_empty;
-    Figure* m_figure;
+    QAction *m_empty;
+    Figure *m_figure;
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/ToolBarButton.cc b/libgui/graphics/ToolBarButton.cc
--- a/libgui/graphics/ToolBarButton.cc
+++ b/libgui/graphics/ToolBarButton.cc
@@ -29,50 +29,50 @@ along with Octave; see the file COPYING.
 
 #include "ToolBarButton.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   template <typename T>
-  ToolBarButton<T>::ToolBarButton (const graphics_object& go, QAction* action)
+  ToolBarButton<T>::ToolBarButton (const graphics_object& go, QAction *action)
     : Object (go, action), m_separator (0)
   {
     typename T::properties& tp = properties<T> ();
 
     action->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
     action->setVisible (tp.is_visible ());
     QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
     action->setIcon (QIcon (QPixmap::fromImage (img)));
     if (tp.is_separator ())
       {
         m_separator = new QAction (action);
         m_separator->setSeparator (true);
         m_separator->setVisible (tp.is_visible ());
       }
     action->setEnabled (tp.is_enable ());
 
-    QWidget* w = qobject_cast<QWidget *> (action->parent ());
+    QWidget *w = qobject_cast<QWidget *> (action->parent ());
 
     w->insertAction (w->actions ().back (), action);
     if (m_separator)
       w->insertAction (action, m_separator);
   }
 
   template <typename T>
   ToolBarButton<T>::~ToolBarButton (void)
   { }
 
   template <typename T>
   void
   ToolBarButton<T>::update (int pId)
   {
     typename T::properties& tp = properties<T> ();
-    QAction* action = qWidget<QAction> ();
+    QAction *action = qWidget<QAction> ();
 
     switch (pId)
       {
       case base_properties::ID_VISIBLE:
         action->setVisible (tp.is_visible ());
         if (m_separator)
           m_separator->setVisible (tp.is_visible ());
         break;
@@ -93,17 +93,17 @@ namespace QtHandles
         if (tp.is_separator ())
           {
             if (! m_separator)
               {
                 m_separator = new QAction (action);
                 m_separator->setSeparator (true);
                 m_separator->setVisible (tp.is_visible ());
 
-                QWidget* w = qobject_cast<QWidget *> (action->parent ());
+                QWidget *w = qobject_cast<QWidget *> (action->parent ());
 
                 w->insertAction (action, m_separator);
               }
           }
         else
           {
             if (m_separator)
               delete m_separator;
diff --git a/libgui/graphics/ToolBarButton.h b/libgui/graphics/ToolBarButton.h
--- a/libgui/graphics/ToolBarButton.h
+++ b/libgui/graphics/ToolBarButton.h
@@ -31,23 +31,23 @@ namespace QtHandles
 {
 
   class Container;
 
   template <typename T>
   class ToolBarButton : public Object
   {
   public:
-    ToolBarButton (const graphics_object& go, QAction* action);
+    ToolBarButton (const graphics_object& go, QAction *action);
     ~ToolBarButton (void);
 
-    Container* innerContainer (void) { return 0; }
+    Container * innerContainer (void) { return 0; }
 
   protected:
     void update (int pId);
 
   private:
-    QAction* m_separator;
+    QAction *m_separator;
   };
 
 };
 
 #endif
diff --git a/libgui/src/color-picker.cc b/libgui/src/color-picker.cc
--- a/libgui/src/color-picker.cc
+++ b/libgui/src/color-picker.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "color-picker.h"
 
 // constuctor with initial color as parameter
-color_picker::color_picker (QColor old_color, QWidget* p) : QPushButton (p)
+color_picker::color_picker (QColor old_color, QWidget *p) : QPushButton (p)
 {
   _color = old_color;
   setFlat (true);
   setFocusPolicy (Qt::NoFocus);  // no focus, would changes the color
   update_button ();
   connect (this, SIGNAL (clicked ()), SLOT (select_color ()));
 }
 
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -1499,17 +1499,17 @@ file_editor_tab::check_file_modified ()
           tr ("Do you want to cancel closing, save or discard the changes?");
 
       QString file;
       if (valid_file_name ())
           file = _file_name;
       else
           file = tr ("<unnamed>");
 
-      QMessageBox* msgBox
+      QMessageBox *msgBox
         = new QMessageBox (QMessageBox::Warning, tr ("Octave Editor"),
                            tr ("The file\n\n"
                                "  %1\n\n"
                                "is about to be closed but has been modified.  "
                                "%2").
                            arg (file). arg (available_actions),
                            buttons, qobject_cast<QWidget *> (parent ()));
 
@@ -1871,17 +1871,17 @@ file_editor_tab::save_file (const QStrin
   if (! file.open (QIODevice::WriteOnly))
     {
       // Unsuccessful, begin watching file again if it was being
       // watched previously.
       if (trackedFiles.contains (file_to_save))
         _file_system_watcher.addPath (file_to_save);
 
       // Create a NonModal message about error.
-      QMessageBox* msgBox
+      QMessageBox *msgBox
         = new QMessageBox (QMessageBox::Critical,
                            tr ("Octave Editor"),
                            tr ("Could not open file %1 for write:\n%2.").
                            arg (file_to_save).arg (file.errorString ()),
                            QMessageBox::Ok, 0);
       show_dialog (msgBox, false);
 
       return;
@@ -1944,17 +1944,17 @@ file_editor_tab::save_file_as (bool remo
   // Simply put up the file chooser dialog box with a slot connection
   // then return control to the system waiting for a file selection.
 
   // reset _new_encoding
   _new_encoding = _encoding;
 
   // If the tab is removed in response to a QFileDialog signal, the tab
   // can't be a parent.
-  QFileDialog* fileDialog;
+  QFileDialog *fileDialog;
   if (remove_on_success)
     {
       // If tab is closed, "this" cannot be parent in which case modality
       // has no effect.  Disable editing instead.
       _edit_area->setReadOnly (true);
       fileDialog = new QFileDialog ();
     }
   else
@@ -2195,17 +2195,17 @@ file_editor_tab::file_has_changed (const
         {
           // give editor and this tab the focus,
           // possibly making the editor visible if it is hidden
           emit set_focus_editor_signal (this);
           _edit_area->setFocus ();
 
           // Create a WindowModal message that blocks the edit area
           // by making _edit_area parent.
-          QMessageBox* msgBox
+          QMessageBox *msgBox
             = new QMessageBox (QMessageBox::Warning,
                                tr ("Octave Editor"),
                                tr ("It seems that \'%1\' has been modified by another application. Do you want to reload it?").
                                arg (_file_name),
                                QMessageBox::Yes | QMessageBox::No, this);
 
           connect (msgBox, SIGNAL (finished (int)),
                    this, SLOT (handle_file_reload_answer (int)));
@@ -2224,17 +2224,17 @@ file_editor_tab::file_has_changed (const
 
       QString modified = "";
       if (_edit_area->isModified ())
         modified = tr ("\n\nWarning: The contents in the editor is modified!");
 
       // Create a WindowModal message. The file editor tab can't be made
       // parent because it may be deleted depending upon the response.
       // Instead, change the _edit_area to read only.
-      QMessageBox* msgBox
+      QMessageBox *msgBox
         = new QMessageBox (QMessageBox::Warning, tr ("Octave Editor"),
                            tr ("It seems that the file\n"
                                "%1\n"
                                "has been deleted or renamed. Do you want to save it now?%2").
                            arg (_file_name).arg (modified),
                            QMessageBox::Save | QMessageBox::Close, 0);
 
       _edit_area->setReadOnly (true);
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -1038,17 +1038,17 @@ file_editor::active_tab_changed (int ind
 {
   emit fetab_change_request (_tab_widget->widget (index));
 }
 
 void file_editor::create_context_menu (QMenu *menu)
 {
   // remove all standard actions from scintilla
   QList<QAction *> all_actions = menu->actions ();
-  QAction* a;
+  QAction *a;
 
   foreach (a, all_actions)
     menu->removeAction (a);
 
   // add editor's actions with icons and customized shortcuts
   menu->addAction (_undo_action);
   menu->addAction (_redo_action);
   menu->addSeparator ();
@@ -2348,17 +2348,17 @@ file_editor_tab_bar::mousePressEvent (QM
 
 //
 // Functions of the the reimplemented tab widget
 //
 
 file_editor_tab_widget::file_editor_tab_widget (QWidget *p)
   : QTabWidget (p)
 {
-  file_editor_tab_bar* bar;
+  file_editor_tab_bar *bar;
   bar = new file_editor_tab_bar (this);
 
   connect (bar, SIGNAL (close_current_tab_signal (bool)),
            p->parent (), SLOT (request_close_file (bool)));
 
   this->setTabBar(bar);
 }
 
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -73,17 +73,17 @@ class file_editor_tab_widget : public QT
 {
   Q_OBJECT
 
 public:
 
   file_editor_tab_widget (QWidget *p);
   ~file_editor_tab_widget ();
 
-  QTabBar* tabBar () const;
+  QTabBar * tabBar () const;
 
 };
 
 
 //
 // the class for the file editor
 //
 class file_editor : public file_editor_interface
@@ -140,73 +140,73 @@ public:
   void handle_exit_debug_mode (void);
 
   void check_actions (void);
   void empty_script (bool startup, bool visible);
 
 signals:
 
   void fetab_settings_changed (const QSettings *settings);
-  void fetab_change_request (const QWidget* ID);
-  void fetab_file_name_query (const QWidget* ID);
+  void fetab_change_request (const QWidget *ID);
+  void fetab_file_name_query (const QWidget *ID);
   // Save is a ping-pong type of communication
-  void fetab_save_file (const QWidget* ID, const QString& fileName,
+  void fetab_save_file (const QWidget *ID, const QString& fileName,
                         bool remove_on_success);
   // No fetab_open, functionality in editor
   // No fetab_new, functionality in editor
-  void fetab_context_help (const QWidget* ID, bool);
-  void fetab_context_edit (const QWidget* ID);
+  void fetab_context_help (const QWidget *ID, bool);
+  void fetab_context_edit (const QWidget *ID);
   void fetab_check_modified_file (void);
-  void fetab_save_file (const QWidget* ID);
-  void fetab_save_file_as (const QWidget* ID);
-  void fetab_print_file (const QWidget* ID);
-  void fetab_run_file (const QWidget* ID);
-  void fetab_context_run (const QWidget* ID);
-  void fetab_toggle_bookmark (const QWidget* ID);
-  void fetab_next_bookmark (const QWidget* ID);
-  void fetab_previous_bookmark (const QWidget* ID);
-  void fetab_remove_bookmark (const QWidget* ID);
-  void fetab_toggle_breakpoint (const QWidget* ID);
-  void fetab_next_breakpoint (const QWidget* ID);
-  void fetab_previous_breakpoint (const QWidget* ID);
-  void fetab_remove_all_breakpoints (const QWidget* ID);
-  void fetab_comment_selected_text (const QWidget* ID);
-  void fetab_uncomment_selected_text (const QWidget* ID);
-  void fetab_indent_selected_text (const QWidget* ID);
-  void fetab_unindent_selected_text (const QWidget* ID);
-  void fetab_convert_eol (const QWidget* ID, QsciScintilla::EolMode eol_mode);
-  void fetab_find (const QWidget* ID, QList<QAction *>);
-  void fetab_find_next (const QWidget* ID);
-  void fetab_find_previous (const QWidget* ID);
-  void fetab_goto_line (const QWidget* ID, int line = -1);
-  void fetab_move_match_brace (const QWidget* ID, bool select);
+  void fetab_save_file (const QWidget *ID);
+  void fetab_save_file_as (const QWidget *ID);
+  void fetab_print_file (const QWidget *ID);
+  void fetab_run_file (const QWidget *ID);
+  void fetab_context_run (const QWidget *ID);
+  void fetab_toggle_bookmark (const QWidget *ID);
+  void fetab_next_bookmark (const QWidget *ID);
+  void fetab_previous_bookmark (const QWidget *ID);
+  void fetab_remove_bookmark (const QWidget *ID);
+  void fetab_toggle_breakpoint (const QWidget *ID);
+  void fetab_next_breakpoint (const QWidget *ID);
+  void fetab_previous_breakpoint (const QWidget *ID);
+  void fetab_remove_all_breakpoints (const QWidget *ID);
+  void fetab_comment_selected_text (const QWidget *ID);
+  void fetab_uncomment_selected_text (const QWidget *ID);
+  void fetab_indent_selected_text (const QWidget *ID);
+  void fetab_unindent_selected_text (const QWidget *ID);
+  void fetab_convert_eol (const QWidget *ID, QsciScintilla::EolMode eol_mode);
+  void fetab_find (const QWidget *ID, QList<QAction *>);
+  void fetab_find_next (const QWidget *ID);
+  void fetab_find_previous (const QWidget *ID);
+  void fetab_goto_line (const QWidget *ID, int line = -1);
+  void fetab_move_match_brace (const QWidget *ID, bool select);
   void fetab_completion (const QWidget*);
-  void fetab_insert_debugger_pointer (const QWidget* ID, int line = -1);
-  void fetab_delete_debugger_pointer (const QWidget* ID, int line = -1);
-  void fetab_do_breakpoint_marker (bool insert, const QWidget* ID,
+  void fetab_insert_debugger_pointer (const QWidget *ID, int line = -1);
+  void fetab_delete_debugger_pointer (const QWidget *ID, int line = -1);
+  void fetab_do_breakpoint_marker (bool insert, const QWidget *ID,
                                    int line = -1, const QString& = "");
-  void fetab_set_focus (const QWidget* ID);
-  void fetab_scintilla_command (const QWidget* ID, unsigned int sci_msg);
+  void fetab_set_focus (const QWidget *ID);
+  void fetab_scintilla_command (const QWidget *ID, unsigned int sci_msg);
 
-  void fetab_zoom_in (const QWidget* ID);
-  void fetab_zoom_out (const QWidget* ID);
-  void fetab_zoom_normal (const QWidget* ID);
+  void fetab_zoom_in (const QWidget *ID);
+  void fetab_zoom_out (const QWidget *ID);
+  void fetab_zoom_normal (const QWidget *ID);
 
   void fetab_set_directory (const QString& dir);
   void fetab_recover_from_exit (void);
 
   void request_settings_dialog (const QString&);
   void execute_command_in_terminal_signal (const QString&);
   void request_open_file_external (const QString& file_name, int line);
   void file_loaded_signal ();
 
 public slots:
 
   void focus (void);
-  void set_focus (QWidget* fet);
+  void set_focus (QWidget *fet);
   void enable_menu_shortcuts (bool);
   bool check_closing (void);
 
   void request_new_file (const QString& commands);
   void request_close_file (bool);
   void request_close_all_files (bool);
   void request_close_other_files (bool);
   void request_mru_open_file (QAction *action);
@@ -348,17 +348,17 @@ private:
   void restore_session (QSettings *settings);
 
   bool editor_tab_has_focus ();
 
   QWidget * find_tab_widget (const QString& openFileName) const;
   QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
                         const char *member);
 
-  QMenu* m_add_menu (QMenuBar *p, QString text);
+  QMenu * m_add_menu (QMenuBar *p, QString text);
 
   std::map<QString, tab_info> editor_tab_map;
   QHash<QMenu*, QStringList> _hash_menu_text;
 
   QString ced;
 
   QMenuBar *_menu_bar;
   QToolBar *_tool_bar;
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -73,17 +73,17 @@ along with Octave; see the file COPYING.
 #include <QLabel>
 #include <QLineEdit>
 #include <QMessageBox>
 #include <QPushButton>
 #include <QVBoxLayout>
 
 #include "find-dialog.h"
 
-find_dialog::find_dialog (QsciScintilla* edit_area,
+find_dialog::find_dialog (QsciScintilla *edit_area,
                           QList<QAction *> find_actions, QWidget *p)
   : QDialog (p)
 {
   setWindowTitle (tr ("Find and Replace"));
   setWindowIcon (QIcon (":/actions/icons/find.png"));
 
   _search_label = new QLabel (tr ("Find &what:"));
   _search_line_edit = new QLineEdit;
diff --git a/libgui/src/m-editor/find-dialog.h b/libgui/src/m-editor/find-dialog.h
--- a/libgui/src/m-editor/find-dialog.h
+++ b/libgui/src/m-editor/find-dialog.h
@@ -71,17 +71,17 @@ class QGroupBox;
 class QLabel;
 class QLineEdit;
 class QPushButton;
 
 class find_dialog : public QDialog
 {
   Q_OBJECT
 public:
-  find_dialog (QsciScintilla* edit_area, QList<QAction *> find_actions,
+  find_dialog (QsciScintilla *edit_area, QList<QAction *> find_actions,
                QWidget *parent = 0);
   void init_search_text ();
 
 private slots:
   void handle_sel_search_changed (int);
   void handle_selection_changed (bool has_selected);
 
   void handle_backward_search_changed (int);
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -259,17 +259,17 @@ octave_qscintilla::contextMenuEvent (QCo
             }
         }
     }
 #if defined (HAVE_QSCI_VERSION_2_6_0)
   else
     {
       // remove all standard actions from scintilla
       QList<QAction *> all_actions = context_menu->actions ();
-      QAction* a;
+      QAction *a;
 
       foreach (a, all_actions)
         context_menu->removeAction (a);
 
       a = context_menu->addAction (tr ("dbstop if ..."), this,
                                    SLOT (contextmenu_break_condition (bool)));
       a->setData (local_pos);
     }
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -240,17 +240,17 @@ main_window::~main_window (void)
       community_news_window = 0;
     }
 }
 
 // catch focus changes and determine the active dock widget
 void
 main_window::focus_changed (QWidget *, QWidget *new_widget)
 {
-  octave_dock_widget* dock = 0;
+  octave_dock_widget *dock = 0;
   QWidget *w_new = new_widget;  // get a copy of new focus widget
   QWidget *start = w_new;       // Save it as start of our search
   int count = 0;                // fallback to prevent endless loop
 
   while (w_new && w_new != _main_tool_bar && count < 100)
     {
       dock = qobject_cast<octave_dock_widget *> (w_new);
       if (dock)
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -279,23 +279,23 @@ private:
 
   void construct (void);
 
   void construct_octave_qt_link (void);
 
   QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
                         const char *member, const QWidget *receiver = 0);
 
-  QMenu* m_add_menu (QMenuBar *p, QString text);
+  QMenu * m_add_menu (QMenuBar *p, QString text);
   void construct_menu_bar (void);
   void construct_file_menu (QMenuBar *p);
   void construct_new_menu (QMenu *p);
   void construct_edit_menu (QMenuBar *p);
   QAction * construct_debug_menu_item (const char *icon, const QString& item,
-                                       const char* member);
+                                       const char *member);
   void construct_debug_menu (QMenuBar *p);
   QAction * construct_window_menu_item (QMenu *p, const QString& item,
                                         bool checkable, QWidget*);
   void construct_window_menu (QMenuBar *p);
   void construct_help_menu (QMenuBar *p);
   void construct_documentation_menu (QMenu *p);
 
   void construct_news_menu (QMenuBar *p);
diff --git a/libgui/src/octave-cmd.cc b/libgui/src/octave-cmd.cc
--- a/libgui/src/octave-cmd.cc
+++ b/libgui/src/octave-cmd.cc
@@ -107,17 +107,17 @@ octave_cmd_debug::execute ()
   octave::command_editor::interrupt (true);
 }
 
 // ---------------------------------------------------------------------
 //  class octave_command_queue: queue of octave commands
 
 // add_cmd: add a command to the queue
 void
-octave_command_queue::add_cmd (octave_cmd* cmd)
+octave_command_queue::add_cmd (octave_cmd *cmd)
 {
   _queue_mutex.lock ();
   _queue.append (cmd);
   _queue_mutex.unlock ();
 
   if (_processing.tryAcquire ())  // if callback not processing, post event
     octave_link::post_event (this,
                              &octave_command_queue::execute_command_callback);
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -168,17 +168,17 @@ octave_dock_widget::set_predecessor_widg
   _predecessor_widget = prev_widget;
 }
 
 // set the title in the dockwidgets title bar
 void
 octave_dock_widget::set_title (const QString& title)
 {
 #if defined (Q_OS_WIN32)
-  QHBoxLayout* h_layout
+  QHBoxLayout *h_layout
     = static_cast<QHBoxLayout *> (titleBarWidget ()->layout ());
   QLabel *label = new QLabel (title);
   label->setStyleSheet ("background: transparent;");
   h_layout->insertWidget (0,label);
 #endif
   setWindowTitle (title);
 }
 
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -372,17 +372,17 @@ replace_colons (QString& text)
 
 static void
 info_to_html (QString& text)
 {
   text.replace ("&", "&amp;");
   text.replace ("<", "&lt;");
   text.replace (">", "&gt;");
 
-  text.replace ("\n* Menu:",
+  text.replace ("\n *Menu:",
                 "\n<font style=\"color:DarkRed;font-weight:bold\">Menu:</font>");
   text.replace ("See also:",
                 "<font style=\"color:DarkRed;font-style:italic;font-weight:bold\">See also:</font>");
   replace_links (text);
   replace_colons (text);
 }
 
 QString
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -419,18 +419,18 @@ shortcut_manager::do_fill_treewidget (QT
 
   connect (tree_view, SIGNAL (itemDoubleClicked (QTreeWidgetItem*, int)),
            this, SLOT (handle_double_clicked (QTreeWidgetItem*, int)));
 
   for (int i = 0; i < _sc.count (); i++)
     {
       shortcut_t sc = _sc.at (i);
 
-      QTreeWidgetItem* section = _level_hash[sc.settings_key.section (':',0,0)];
-      QTreeWidgetItem* tree_item = new QTreeWidgetItem (section);
+      QTreeWidgetItem *section = _level_hash[sc.settings_key.section (':',0,0)];
+      QTreeWidgetItem *tree_item = new QTreeWidgetItem (section);
 
       // set a slightly transparent foreground for default columns
       QColor fg = QColor (tree_item->foreground (1).color ());
       fg.setAlpha (128);
       tree_item->setForeground (1, QBrush (fg));
 
       // write the shortcuts
       tree_item->setText (0, sc.description);
@@ -440,17 +440,17 @@ shortcut_manager::do_fill_treewidget (QT
       _item_index_hash[tree_item] = i + 1; // index+1 to avoid 0
       _index_item_hash[i] = tree_item;
     }
 
 }
 
 // write one or all actual shortcut set(s) into a settings file
 void
-shortcut_manager::do_write_shortcuts (QSettings* settings,
+shortcut_manager::do_write_shortcuts (QSettings *settings,
                                       bool closing)
 {
   bool sc_ctrld = false;
 
   for (int i = 0; i < _sc.count (); i++)  // loop over all shortcuts
     {
       settings->setValue ("shortcuts/"+_sc.at (i).settings_key,
                           _sc.at (i).actual_sc.toString ());
@@ -467,31 +467,31 @@ shortcut_manager::do_write_shortcuts (QS
       delete _dialog;  // the dialog for key sequences can be removed now
       _dialog = 0;     // make sure it is zero again
     }
 
   settings->sync ();    // sync the settings file
 }
 
 void
-shortcut_manager::do_set_shortcut (QAction* action, const QString& key)
+shortcut_manager::do_set_shortcut (QAction *action, const QString& key)
 {
   int index;
 
   index = _action_hash[key] - 1;
 
   if (index > -1 && index < _sc.count ())
     action->setShortcut (QKeySequence (
       _settings->value ("shortcuts/" + key, _sc.at (index).default_sc).toString ()));
   else
     qDebug () << "Key: " << key << " not found in _action_hash";
 }
 
 void
-shortcut_manager::handle_double_clicked (QTreeWidgetItem* item, int col)
+shortcut_manager::handle_double_clicked (QTreeWidgetItem *item, int col)
 {
   if (col != 2)
     return;
 
   int i = _item_index_hash[item];
   if (i == 0)
     return;  // top-level-item clicked
 
@@ -632,17 +632,17 @@ shortcut_manager::import_shortcuts (QSet
           settings->value ("shortcuts/"+sc.settings_key,sc.actual_sc).
                           toString ());       // and use the old one as default
       else
         sc.actual_sc = QKeySequence (sc.default_sc); // get default shortcut
 
       _sc.replace (i,sc);                   // replace the old with the new one
 
       // update the tree view
-      QTreeWidgetItem* tree_item = _index_item_hash[i]; // get related tree item
+      QTreeWidgetItem *tree_item = _index_item_hash[i]; // get related tree item
       tree_item->setText (2, sc.actual_sc.toString ()); // display new shortcut
     }
 }
 
 // ask the user whether to save the current shortcut set;
 // returns true to proceed with import action, false to abort it
 bool
 shortcut_manager::overwrite_all_shortcuts ()
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -384,17 +384,17 @@ void
 workspace_view::handle_contextmenu_rename (void)
 {
   QModelIndex index = view->currentIndex ();
 
   if (index.isValid ())
     {
       QString var_name = get_var_name (index);
 
-      QInputDialog* inputDialog = new QInputDialog ();
+      QInputDialog *inputDialog = new QInputDialog ();
 
       inputDialog->setOptions (QInputDialog::NoButtons);
 
       bool ok = false;
 
       QString new_name
         = inputDialog->getText (0, "Rename Variable", "New name:",
                                 QLineEdit::Normal, var_name, &ok);
diff --git a/libinterp/corefcn/__ichol__.cc b/libinterp/corefcn/__ichol__.cc
--- a/libinterp/corefcn/__ichol__.cc
+++ b/libinterp/corefcn/__ichol__.cc
@@ -80,18 +80,18 @@ void ichol_0 (octave_matrix_t& sm, const
   char opt;
   enum {OFF, ON};
   if (michol == "on")
     opt = ON;
   else
     opt = OFF;
 
   // Input matrix pointers
-  octave_idx_type* cidx = sm.cidx ();
-  octave_idx_type* ridx = sm.ridx ();
+  octave_idx_type *cidx = sm.cidx ();
+  octave_idx_type *ridx = sm.ridx ();
   T* data = sm.data ();
 
   // Working arrays
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Lfirst, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Llist, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, iw, n);
   OCTAVE_LOCAL_BUFFER (T, dropsums, n);
 
@@ -224,33 +224,33 @@ void ichol_t (const octave_matrix_t& sm,
   char opt;
   enum {OFF, ON};
   if (michol == "on")
     opt = ON;
   else
     opt = OFF;
 
   // Input matrix pointers
-  octave_idx_type* cidx = sm.cidx ();
-  octave_idx_type* ridx = sm.ridx ();
+  octave_idx_type *cidx = sm.cidx ();
+  octave_idx_type *ridx = sm.ridx ();
   T* data = sm.data ();
 
   // Output matrix data structures.  Because the final zero pattern pattern of
   // the output matrix is not known due to fill-in elements, a heuristic
   // approach has been adopted for memory allocation.  The size of ridx_out_l
   // and data_out_l is incremented 10% of their actual size (nnz (A) in the
   // beginning).  If that amount is less than n, their size is just incremented
   // in n elements.  This way the number of reallocations decreases throughout
   // the process, obtaining a good performance.
   max_len = sm.nnz ();
   max_len += (0.1 * max_len) > n ? 0.1 * max_len : n;
   Array <octave_idx_type> cidx_out_l (dim_vector (n + 1, 1));
-  octave_idx_type* cidx_l = cidx_out_l.fortran_vec ();
+  octave_idx_type *cidx_l = cidx_out_l.fortran_vec ();
   Array <octave_idx_type> ridx_out_l (dim_vector (max_len ,1));
-  octave_idx_type* ridx_l = ridx_out_l.fortran_vec ();
+  octave_idx_type *ridx_l = ridx_out_l.fortran_vec ();
   Array <T> data_out_l (dim_vector (max_len, 1));
   T* data_l = data_out_l.fortran_vec ();
 
   // Working arrays
   OCTAVE_LOCAL_BUFFER (T, w_data, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Lfirst, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Llist, n);
   OCTAVE_LOCAL_BUFFER (T, col_drops, n);
diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -55,19 +55,19 @@ void ilu_0 (octave_matrix_t& sm, const s
       sm = sm.transpose ();
     }
   else if (milu == "col")
     opt = COL;
   else
     opt = OFF;
 
   // Input matrix pointers
-  octave_idx_type* cidx = sm.cidx ();
-  octave_idx_type* ridx = sm.ridx ();
-  T* data = sm.data ();
+  octave_idx_type *cidx = sm.cidx ();
+  octave_idx_type *ridx = sm.ridx ();
+  T *data = sm.data ();
 
   // Working arrays
   OCTAVE_LOCAL_BUFFER (octave_idx_type, iw, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, uptr, n);
 
   // Initialize working arrays
   for (i = 0; i < n; i++)
     iw[i] = -1;
@@ -175,18 +175,18 @@ Undocumented internal function.
       retval(1) = Ftriu (ovl (sm))(0).sparse_complex_matrix_value ();
     }
 
   return retval;
 }
 
 template <typename octave_matrix_t, typename T>
 void ilu_crout (octave_matrix_t& sm_l, octave_matrix_t& sm_u,
-                octave_matrix_t& L, octave_matrix_t& U, T* cols_norm,
-                T* rows_norm, const T droptol = 0,
+                octave_matrix_t& L, octave_matrix_t& U, T *cols_norm,
+                T *rows_norm, const T droptol = 0,
                 const std::string milu = "off")
 {
   // Map the strings into chars for faster comparing inside loops
   char opt;
   enum {OFF, ROW, COL};
   if (milu == "row")
     opt = ROW;
   else if (milu == "col")
@@ -201,34 +201,34 @@ void ilu_crout (octave_matrix_t& sm_l, o
   sm_u = sm_u.transpose ();
 
   max_len_u = sm_u.nnz ();
   max_len_u += (0.1 * max_len_u) > n ? 0.1 * max_len_u : n;
   max_len_l = sm_l.nnz ();
   max_len_l += (0.1 * max_len_l) > n ? 0.1 * max_len_l : n;
 
   // Extract pointers to the arrays for faster access inside loops
-  octave_idx_type* cidx_in_u = sm_u.cidx ();
-  octave_idx_type* ridx_in_u = sm_u.ridx ();
-  T* data_in_u = sm_u.data ();
-  octave_idx_type* cidx_in_l = sm_l.cidx ();
-  octave_idx_type* ridx_in_l = sm_l.ridx ();
-  T* data_in_l = sm_l.data ();
+  octave_idx_type *cidx_in_u = sm_u.cidx ();
+  octave_idx_type *ridx_in_u = sm_u.ridx ();
+  T *data_in_u = sm_u.data ();
+  octave_idx_type *cidx_in_l = sm_l.cidx ();
+  octave_idx_type *ridx_in_l = sm_l.ridx ();
+  T *data_in_l = sm_l.data ();
 
   // L output arrays
   Array <octave_idx_type> ridx_out_l (dim_vector (max_len_l, 1));
-  octave_idx_type* ridx_l = ridx_out_l.fortran_vec ();
+  octave_idx_type *ridx_l = ridx_out_l.fortran_vec ();
   Array <T> data_out_l (dim_vector (max_len_l, 1));
-  T* data_l = data_out_l.fortran_vec ();
+  T *data_l = data_out_l.fortran_vec ();
 
   // U output arrays
   Array <octave_idx_type> ridx_out_u (dim_vector (max_len_u, 1));
-  octave_idx_type* ridx_u = ridx_out_u.fortran_vec ();
+  octave_idx_type *ridx_u = ridx_out_u.fortran_vec ();
   Array <T> data_out_u (dim_vector (max_len_u, 1));
-  T* data_u = data_out_u.fortran_vec ();
+  T *data_u = data_out_u.fortran_vec ();
 
   // Working arrays
   OCTAVE_LOCAL_BUFFER (octave_idx_type, cidx_l, n + 1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, cidx_u, n + 1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, cols_list, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, rows_list, n);
   OCTAVE_LOCAL_BUFFER (T, w_data_l, n);
   OCTAVE_LOCAL_BUFFER (T, w_data_u, n);
@@ -513,17 +513,17 @@ Undocumented internal function.
 // parameter.  If milu = ['off'|'col'] the JKI version is performed taking
 // advantage of CCS format of the input matrix.  Row pivoting is performed.
 // If milu = 'row' the input matrix has to be transposed to obtain the
 // equivalent CRS structure so we can work efficiently with rows.  In that
 // case IKJ version is used and column pivoting is performed.
 
 template <typename octave_matrix_t, typename T>
 void ilu_tp (octave_matrix_t& sm, octave_matrix_t& L, octave_matrix_t& U,
-             octave_idx_type nnz_u, octave_idx_type nnz_l, T* cols_norm,
+             octave_idx_type nnz_u, octave_idx_type nnz_l, T *cols_norm,
              Array <octave_idx_type>& perm_vec, const T droptol = T(0),
              const T thresh = T(0), const  std::string milu = "off",
              const double udiag = 0)
 {
   char opt;
   enum {OFF, ROW, COL};
   if (milu == "row")
     opt = ROW;
@@ -534,55 +534,55 @@ void ilu_tp (octave_matrix_t& sm, octave
 
   const octave_idx_type n = sm.cols ();
 
   // This is necessary for the JKI (milu = "row") variant.
   if (opt == ROW)
     sm = sm.transpose ();
 
   // Extract pointers to the arrays for faster access inside loops
-  octave_idx_type* cidx_in = sm.cidx ();
-  octave_idx_type* ridx_in = sm.ridx ();
-  T* data_in = sm.data ();
+  octave_idx_type *cidx_in = sm.cidx ();
+  octave_idx_type *ridx_in = sm.ridx ();
+  T *data_in = sm.data ();
   octave_idx_type jrow, i, j, k, jj, c, total_len_l, total_len_u, p_perm,
                   max_ind, max_len_l, max_len_u;
   T zero = T(0);
 
   T tl = zero, aux, maximum;
 
   max_len_u = nnz_u;
   max_len_u += (0.1 * max_len_u) > n ? 0.1 * max_len_u : n;
   max_len_l = nnz_l;
   max_len_l += (0.1 * max_len_l) > n ? 0.1 * max_len_l : n;
 
   // Extract pointers to the arrays for faster access inside loops
   Array <octave_idx_type> cidx_out_l (dim_vector (n + 1, 1));
-  octave_idx_type* cidx_l = cidx_out_l.fortran_vec ();
+  octave_idx_type *cidx_l = cidx_out_l.fortran_vec ();
   Array <octave_idx_type> ridx_out_l (dim_vector (max_len_l, 1));
-  octave_idx_type* ridx_l = ridx_out_l.fortran_vec ();
+  octave_idx_type *ridx_l = ridx_out_l.fortran_vec ();
   Array <T> data_out_l (dim_vector (max_len_l, 1));
-  T* data_l = data_out_l.fortran_vec ();
+  T *data_l = data_out_l.fortran_vec ();
 
   // Data for U
   Array <octave_idx_type> cidx_out_u (dim_vector (n + 1, 1));
-  octave_idx_type* cidx_u = cidx_out_u.fortran_vec ();
+  octave_idx_type *cidx_u = cidx_out_u.fortran_vec ();
   Array <octave_idx_type> ridx_out_u (dim_vector (max_len_u, 1));
-  octave_idx_type* ridx_u = ridx_out_u.fortran_vec ();
+  octave_idx_type *ridx_u = ridx_out_u.fortran_vec ();
   Array <T> data_out_u (dim_vector (max_len_u, 1));
-  T* data_u = data_out_u.fortran_vec ();
+  T *data_u = data_out_u.fortran_vec ();
 
   // Working arrays and permutation arrays
   octave_idx_type w_len_u, w_len_l;
   T total_sum, partial_col_sum = zero, partial_row_sum = zero;
   std::set <octave_idx_type> iw_l;
   std::set <octave_idx_type> iw_u;
   std::set <octave_idx_type>::iterator it, it2;
   OCTAVE_LOCAL_BUFFER (T, w_data, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, iperm, n);
-  octave_idx_type* perm = perm_vec.fortran_vec ();
+  octave_idx_type *perm = perm_vec.fortran_vec ();
   OCTAVE_LOCAL_BUFFER (octave_idx_type, uptr, n);
 
   // Initialize working and permutation arrays
   cidx_l[0] = cidx_in[0];
   cidx_u[0] = cidx_in[0];
   for (i = 0; i < n; i++)
     {
       w_data[i] = 0;
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -283,17 +283,17 @@ read_indexed_images (const std::vector<M
   const octave_idx_type nCols = region.col_out ();
 
   // imvec has all of the pages of a file, even the ones we are not
   // interested in.  We will use the first image that we will be actually
   // reading to get information about the image.
   const octave_idx_type def_elem = frameidx(0);
 
   T img       = T (dim_vector (nRows, nCols, 1, nFrames));
-  P* img_fvec = img.fortran_vec ();
+  P *img_fvec = img.fortran_vec ();
 
   const octave_idx_type row_start = region.row_start ();
   const octave_idx_type col_start = region.col_start ();
   const octave_idx_type row_shift = region.row_shift ();
   const octave_idx_type col_shift = region.col_shift ();
   const octave_idx_type row_cache = region.row_cache ();
   const octave_idx_type col_cache = region.col_cache ();
 
@@ -335,20 +335,20 @@ read_indexed_images (const std::vector<M
         read_maps (const_cast<Magick::Image&> (imvec[frameidx(def_elem)]));
 
       retval(1) = maps(0);
 
       // only interpret alpha channel if it exists and was requested as output
       if (imvec[def_elem].matte () && nargout >= 3)
         {
           const Matrix amap = maps(1).matrix_value ();
-          const double* amap_fvec = amap.fortran_vec ();
+          const double *amap_fvec = amap.fortran_vec ();
 
           NDArray alpha (dim_vector (nRows, nCols, 1, nFrames));
-          double* alpha_fvec = alpha.fortran_vec ();
+          double *alpha_fvec = alpha.fortran_vec ();
 
           // GraphicsMagick stores the alpha values inverted, i.e.,
           // 1 for transparent and 0 for opaque so we fix that here.
           const octave_idx_type nPixels = alpha.numel ();
           for (octave_idx_type pix = 0; pix < nPixels; pix++)
             alpha_fvec[pix] = 1 - amap_fvec[static_cast<int> (img_fvec[3])];
 
           retval(2) = alpha;
@@ -935,18 +935,18 @@ Use @code{imread} instead.
 
 template <typename T>
 static uint32NDArray
 img_float2uint (const T& img)
 {
   typedef typename T::element_type P;
   uint32NDArray out (img.dims ());
 
-  octave_uint32* out_fvec = out.fortran_vec ();
-  const P*       img_fvec = img.fortran_vec ();
+  octave_uint32 *out_fvec = out.fortran_vec ();
+  const P       *img_fvec = img.fortran_vec ();
 
   const octave_uint32 max = octave_uint32::max ();
   const octave_idx_type numel = img.numel ();
   for (octave_idx_type idx = 0; idx < numel; idx++)
     out_fvec[idx] = img_fvec[idx] * max;
 
   return out;
 }
@@ -1006,17 +1006,17 @@ encode_indexed_images (std::vector<Magic
   const octave_idx_type nCols     = img.columns ();
   const octave_idx_type cmap_size = cmap.rows ();
   const octave_idx_type bitdepth  = bitdepth_from_class<T> ();
 
   // There is no colormap object, we need to build a new one for each frame,
   // even if it's always the same.  We can least get a vector for the Colors.
   std::vector<Magick::ColorRGB> colormap;
   {
-    const double* cmap_fvec = cmap.fortran_vec ();
+    const double *cmap_fvec = cmap.fortran_vec ();
     const octave_idx_type G_offset = cmap_size;
     const octave_idx_type B_offset = cmap_size * 2;
     for (octave_idx_type map_idx = 0; map_idx < cmap_size; map_idx++)
       colormap.push_back (Magick::ColorRGB (cmap_fvec[map_idx],
                                             cmap_fvec[map_idx + G_offset],
                                             cmap_fvec[map_idx + B_offset]));
   }
 
@@ -1037,19 +1037,19 @@ encode_indexed_images (std::vector<Magic
       // index values? We don't know if a file format supports indexed
       // images.  If we only set the indexes and then try to save the
       // image as JPEG for example, the indexed values get discarded,
       // there is no conversion from the indexes, it's the initial values
       // that get used.  An alternative would be to only set the pixel
       // values (no indexes), then set the image as PseudoClass and GM
       // would create a colormap for us.  However, we wouldn't have control
       // over the order of that colormap.  And that's why we set both.
-      Magick::PixelPacket* pix = m_img.getPixels (0, 0, nCols, nRows);
-      Magick::IndexPacket* ind = m_img.getIndexes ();
-      const P* img_fvec        = img.fortran_vec ();
+      Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+      Magick::IndexPacket *ind = m_img.getIndexes ();
+      const P *img_fvec        = img.fortran_vec ();
 
       octave_idx_type GM_idx = 0;
       for (octave_idx_type column = 0; column < nCols; column++)
         {
           for (octave_idx_type row = 0; row < nRows; row++)
             {
               ind[GM_idx] = double (*img_fvec);
               pix[GM_idx] = m_img.colorMap (double (*img_fvec));
@@ -2050,17 +2050,17 @@ Use @code{imfinfo} instead.
         info_frame.setfield ("Colormap",  octave_value (cmap));
       }
 
       {
         // Not all images have chroma values.  In such cases, they'll
         // be all zeros.  So rather than send a matrix of zeros, we will
         // check for that, and send an empty vector instead.
         RowVector chromaticities (8);
-        double* chroma_fvec = chromaticities.fortran_vec ();
+        double *chroma_fvec = chromaticities.fortran_vec ();
         img.chromaWhitePoint    (&chroma_fvec[0], &chroma_fvec[1]);
         img.chromaRedPrimary    (&chroma_fvec[2], &chroma_fvec[3]);
         img.chromaGreenPrimary  (&chroma_fvec[4], &chroma_fvec[5]);
         img.chromaBluePrimary   (&chroma_fvec[6], &chroma_fvec[7]);
         if (chromaticities.nnz () == 0)
           chromaticities = RowVector (0);
         info_frame.setfield ("Chromaticities", octave_value (chromaticities));
       }
diff --git a/libinterp/corefcn/c-file-ptr-stream.cc b/libinterp/corefcn/c-file-ptr-stream.cc
--- a/libinterp/corefcn/c-file-ptr-stream.cc
+++ b/libinterp/corefcn/c-file-ptr-stream.cc
@@ -77,17 +77,17 @@ c_file_ptr_buf::underflow_common (bool b
 c_file_ptr_buf::int_type
 c_file_ptr_buf::pbackfail (int_type c)
 {
   return ((c != traits_type::eof () && f)
           ? ungetc (c, f) : traits_type::not_eof (c));
 }
 
 std::streamsize
-c_file_ptr_buf::xsputn (const char* s, std::streamsize n)
+c_file_ptr_buf::xsputn (const char *s, std::streamsize n)
 {
   if (f)
     return std::fwrite (s, 1, n, f);
   else
     return 0;
 }
 
 std::streamsize
@@ -221,17 +221,17 @@ c_zfile_ptr_buf::underflow_common (bool 
 c_zfile_ptr_buf::int_type
 c_zfile_ptr_buf::pbackfail (int_type c)
 {
   return ((c != traits_type::eof () && f)
           ? gzungetc (c, f) : traits_type::not_eof (c));
 }
 
 std::streamsize
-c_zfile_ptr_buf::xsputn (const char* s, std::streamsize n)
+c_zfile_ptr_buf::xsputn (const char *s, std::streamsize n)
 {
   if (f)
     return gzwrite (f, s, n);
   else
     return 0;
 }
 
 std::streamsize
diff --git a/libinterp/corefcn/c-file-ptr-stream.h b/libinterp/corefcn/c-file-ptr-stream.h
--- a/libinterp/corefcn/c-file-ptr-stream.h
+++ b/libinterp/corefcn/c-file-ptr-stream.h
@@ -34,17 +34,17 @@ class
 c_file_ptr_buf : public std::streambuf
 {
 public:
 
   typedef std::streambuf::int_type int_type;
 
   typedef int (*close_fcn) (FILE *);
 
-  FILE* stdiofile (void) { return f; }
+  FILE *stdiofile (void) { return f; }
 
   c_file_ptr_buf (FILE *f_arg, close_fcn cf_arg = file_close)
     : std::streambuf (), f (f_arg), cf (cf_arg)
   { }
 
   // No copying!
 
   c_file_ptr_buf (const c_file_ptr_buf&) = delete;
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -452,17 +452,17 @@ v = cellfun (@@det, a); # faster
   get_mapper_fun_options (args, nargin, uniform_output, error_handler);
 
   // The following is an optimization because the symbol table can give a
   // more specific function class, so this can result in fewer polymorphic
   // function calls as the function gets called for each value of the array.
   {
     if (func.is_function_handle ())
       {
-        octave_fcn_handle* f = func.fcn_handle_value ();
+        octave_fcn_handle *f = func.fcn_handle_value ();
 
         // Overloaded function handles need to check the type of the
         // arguments for each element of the array, so they cannot be
         // optimized this way.
         if (f -> is_overloaded ())
           goto nevermind;
       }
 
@@ -1157,17 +1157,17 @@ arrayfun (@@str2num, [1234],
       // The following is an optimization because the symbol table can give a
       // more specific function class, so this can result in fewer polymorphic
       // function calls as the function gets called for each value of the array.
 
       if (! symbol_table_lookup)
         {
           if (func.is_function_handle ())
             {
-              octave_fcn_handle* f = func.fcn_handle_value ();
+              octave_fcn_handle *f = func.fcn_handle_value ();
 
               // Overloaded function handles need to check the type of the
               // arguments for each element of the array, so they cannot be
               // optimized this way.
               if (f -> is_overloaded ())
                 goto nevermind;
             }
           octave_value f
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -7740,18 +7740,18 @@ Encode a double matrix or array @var{x} 
 
   if (args(0).is_integer_type ())
     {
 #define MAKE_INT_BRANCH(X)                                               \
       if (args(0).is_ ## X ## _type ())                                  \
         {                                                                \
           const X##NDArray in = args(0).  X## _array_value ();           \
           size_t inlen = in.numel () * sizeof (X## _t) / sizeof (char);  \
-          const char* inc = reinterpret_cast<const char *> (in.data ()); \
-          char* out;                                                     \
+          const char *inc = reinterpret_cast<const char *> (in.data ()); \
+          char *out;                                                     \
           if (octave_base64_encode (inc, inlen, &out))                   \
             {                                                            \
               retval(0) = octave_value (out);                            \
               ::free (out);                                              \
             }                                                            \
         }
 
       MAKE_INT_BRANCH(int8)
@@ -7770,31 +7770,31 @@ Encode a double matrix or array @var{x} 
     }
   else if (args(0).is_single_type ())
     {
       const Array<float> in = args(0).float_array_value ();
       size_t inlen;
       inlen = in.numel () * sizeof (float) / sizeof (char);
       const char*  inc;
       inc = reinterpret_cast<const char *> (in.data ());
-      char* out;
+      char *out;
       if (octave_base64_encode (inc, inlen, &out))
         {
           retval(0) = octave_value (out);
           ::free (out);
         }
     }
   else  // double_type
     {
       const Array<double> in = args(0).array_value ();
       size_t inlen;
       inlen = in.numel () * sizeof (double) / sizeof (char);
       const char*  inc;
       inc = reinterpret_cast<const char *> (in.data ());
-      char* out;
+      char *out;
       if (octave_base64_encode (inc, inlen, &out))
         {
           retval(0) = octave_value (out);
           ::free (out);
         }
     }
 
   return retval;
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -226,17 +226,17 @@ namespace octave
         // Default sort order optimizes for 3D plots
         GLint gl2ps_sort = GL2PS_BSP_SORT;
 
         // For 2D plots we can use a simpler Z-depth sorting algorithm
         if (term.find ("is2D") != std::string::npos)
           gl2ps_sort = GL2PS_SIMPLE_SORT;
 
         // Use a temporary file in case an overflow happens
-        FILE* tmpf = octave_tmpfile_wrapper ();
+        FILE *tmpf = octave_tmpfile_wrapper ();
 
         if (! tmpf)
           error ("gl2ps_renderer::draw: couldn't open temporary file for printing");
 
         // Reset buffsize, unless this is 2nd pass of a texstandalone print.
         if (term.find ("tex") == std::string::npos)
           buffsize = 2*1024*1024;
         else
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1526,19 +1526,19 @@ array_property::is_equal (const octave_v
               return data.F ## scalar_value () ==                       \
                 v.F ## scalar_value ();                                 \
             else                                                        \
               {                                                         \
                 /* Keep copy of array_value to allow */                 \
                 /* sparse/bool arrays that are converted, to */         \
                 /* not be deallocated early */                          \
                 const A m1 = data.F ## array_value ();                  \
-                const T* d1 = m1.data ();                               \
+                const T *d1 = m1.data ();                               \
                 const A m2 = v.F ## array_value ();                     \
-                const T* d2 = m2.data ();                               \
+                const T *d2 = m2.data ();                               \
                                                                         \
                 bool flag = true;                                       \
                                                                         \
                 for (int i = 0; flag && i < data.numel (); i++)         \
                   if (d1[i] != d2[i])                                   \
                     flag = false;                                       \
                                                                         \
                 return flag;                                            \
@@ -9610,17 +9610,17 @@ gh_manager::do_make_graphics_handle (con
   return h;
 }
 
 graphics_handle
 gh_manager::do_make_figure_handle (double val, bool do_notify_toolkit)
 {
   graphics_handle h = val;
 
-  base_graphics_object* bgo = new figure (h, 0);
+  base_graphics_object *bgo = new figure (h, 0);
   graphics_object go (bgo);
 
   handle_map[h] = go;
 
   // Notify graphics toolkit.
   if (do_notify_toolkit)
     go.initialize ();
 
@@ -9688,17 +9688,17 @@ class
 function_event : public base_graphics_event
 {
 public:
 
   // function_event objects must be created with at least a function.
 
   function_event (void) = delete;
 
-  function_event (graphics_event::event_fcn fcn, void* data = 0)
+  function_event (graphics_event::event_fcn fcn, void *data = 0)
     : base_graphics_event (), function (fcn), function_data (data)
   { }
 
   // No copying!
 
   function_event (const function_event&) = delete;
 
   function_event & operator = (const function_event&) = delete;
@@ -9707,17 +9707,17 @@ public:
   {
     function (function_data);
   }
 
 private:
 
   graphics_event::event_fcn function;
 
-  void* function_data;
+  void *function_data;
 };
 
 class
 set_event : public base_graphics_event
 {
 public:
   set_event (const graphics_handle& h, const std::string& name,
              const octave_value& value, bool do_notify_toolkit = true)
@@ -9984,17 +9984,17 @@ gh_manager::do_post_callback (const grap
                       graphics_event::create_callback_event (h, name, data));
                 }
             }
         }
     }
 }
 
 void
-gh_manager::do_post_function (graphics_event::event_fcn fcn, void* fcn_data)
+gh_manager::do_post_function (graphics_event::event_fcn fcn, void *fcn_data)
 {
   gh_manager::auto_lock guard;
 
   do_post_event (graphics_event::create_function_event (fcn, fcn_data));
 }
 
 void
 gh_manager::do_post_set (const graphics_handle& h, const std::string& name,
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -77,17 +77,17 @@ public:
     error ("invalid axis scale");
   }
 
   virtual double unscale (double) const
   {
     error ("invalid axis scale");
   }
 
-  virtual base_scaler* clone () const
+  virtual base_scaler * clone () const
   { return new base_scaler (); }
 
   virtual bool is_linear (void) const
   { return false; }
 };
 
 class lin_scaler : public base_scaler
 {
@@ -97,17 +97,17 @@ public:
   Matrix scale (const Matrix& m) const { return m; }
 
   NDArray scale (const NDArray& m) const { return m; }
 
   double scale (double d) const { return d; }
 
   double unscale (double d) const { return d; }
 
-  base_scaler* clone (void) const { return new lin_scaler (); }
+  base_scaler * clone (void) const { return new lin_scaler (); }
 
   bool is_linear (void) const { return true; }
 };
 
 class log_scaler : public base_scaler
 {
 public:
   log_scaler (void) { }
@@ -131,17 +131,17 @@ public:
   }
 
   double scale (double d) const
   { return log10 (d); }
 
   double unscale (double d) const
   { return pow (10.0, d); }
 
-  base_scaler* clone (void) const
+  base_scaler * clone (void) const
   { return new log_scaler (); }
 
 private:
   void do_scale (const double *src, double *dest, int n) const
   {
     for (int i = 0; i < n; i++)
       dest[i] = log10 (src[i]);
   }
@@ -171,17 +171,17 @@ public:
   }
 
   double scale (double d) const
   { return -log10 (-d); }
 
   double unscale (double d) const
   { return -pow (10.0, -d); }
 
-  base_scaler* clone (void) const
+  base_scaler * clone (void) const
   { return new neg_log_scaler (); }
 
 private:
   void do_scale (const double *src, double *dest, int n) const
   {
     for (int i = 0; i < n; i++)
       dest[i] = -log10 (-src[i]);
   }
@@ -382,17 +382,17 @@ public:
             l = lnew;
           }
       }
 
   }
 
   OCTINTERP_API void run_listeners (listener_mode mode = POSTSET);
 
-  virtual base_property* clone (void) const
+  virtual base_property * clone (void) const
   { return new base_property (*this); }
 
 protected:
   virtual bool do_set (const octave_value&)
   {
     error ("set: invalid property \"%s\"", name.c_str ());
   }
 
@@ -430,17 +430,17 @@ public:
   std::string string_value (void) const { return str; }
 
   string_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
-  base_property* clone (void) const { return new string_property (*this); }
+  base_property * clone (void) const { return new string_property (*this); }
 
 protected:
   bool do_set (const octave_value& val)
   {
     if (! val.is_string ())
       error ("set: invalid string property value for \"%s\"",
              get_name ().c_str ());
 
@@ -536,17 +536,17 @@ public:
   string_vector string_vector_value (void) const { return str; }
 
   string_array_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
-  base_property* clone (void) const
+  base_property * clone (void) const
   { return new string_array_property (*this); }
 
 protected:
   bool do_set (const octave_value& val)
   {
     if (val.is_string () && val.rows () == 1)
       {
         bool replace = false;
@@ -741,17 +741,17 @@ public:
   Cell cell_value (void) const {return Cell (value); }
 
   text_label_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
-  base_property* clone (void) const { return new text_label_property (*this); }
+  base_property * clone (void) const { return new text_label_property (*this); }
 
 protected:
 
   bool do_set (const octave_value& val)
   {
     if (val.is_string ())
       {
         value = val.string_vector_value ();
@@ -939,17 +939,17 @@ public:
   bool is_radio (void) const { return true; }
 
   radio_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
-  base_property* clone (void) const { return new radio_property (*this); }
+  base_property * clone (void) const { return new radio_property (*this); }
 
 protected:
   bool do_set (const octave_value& newval)
   {
     if (! newval.is_string ())
       error ("set: invalid value for radio property \"%s\"",
              get_name ().c_str ());
 
@@ -1125,17 +1125,17 @@ public:
   color_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
   operator octave_value (void) const { return get (); }
 
-  base_property* clone (void) const { return new color_property (*this); }
+  base_property * clone (void) const { return new color_property (*this); }
 
   std::string values_as_string (void) const
   { return radio_val.values_as_string (); }
 
   Cell values_as_cell (void) const { return radio_val.values_as_cell (); }
 
 protected:
   OCTINTERP_API bool do_set (const octave_value& newval);
@@ -1177,17 +1177,17 @@ public:
   double double_value (void) const { return current_val; }
 
   double_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
-  base_property* clone (void) const
+  base_property * clone (void) const
   {
     double_property *p = new double_property (*this);
 
     p->finite_constraint = finite_constraint;
     p->minval = minval;
     p->maxval = maxval;
 
     return p;
@@ -1330,17 +1330,17 @@ public:
   double_radio_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
   operator octave_value (void) const { return get (); }
 
-  base_property* clone (void) const
+  base_property * clone (void) const
   { return new double_radio_property (*this); }
 
 protected:
   OCTINTERP_API bool do_set (const octave_value& v);
 
 private:
   enum current_enum { double_t, radio_t } current_type;
   double dval;
@@ -1422,17 +1422,17 @@ public:
   }
 
   array_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
-  base_property* clone (void) const
+  base_property * clone (void) const
   {
     array_property *p = new array_property (*this);
 
     p->type_constraints = type_constraints;
     p->size_constraints = size_constraints;
     p->finite_constraint = finite_constraint;
     p->minval = minval;
     p->maxval = maxval;
@@ -1532,17 +1532,17 @@ public:
   }
 
   row_vector_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
-  base_property* clone (void) const
+  base_property * clone (void) const
   {
     row_vector_property *p = new row_vector_property (*this);
 
     p->type_constraints = type_constraints;
     p->size_constraints = size_constraints;
 
     return p;
   }
@@ -1576,32 +1576,32 @@ class bool_property : public radio_prope
 {
 public:
   bool_property (const std::string& nm, const graphics_handle& h,
                  bool val)
     : radio_property (nm, h, radio_values (val ? "{on}|off" : "on|{off}"))
   { }
 
   bool_property (const std::string& nm, const graphics_handle& h,
-                 const char* val)
+                 const char *val)
     : radio_property (nm, h, radio_values ("on|off"), val)
   { }
 
   bool_property (const bool_property& p)
     : radio_property (p) { }
 
   bool is_on (void) const { return is ("on"); }
 
   bool_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
-  base_property* clone (void) const { return new bool_property (*this); }
+  base_property * clone (void) const { return new bool_property (*this); }
 
 protected:
   bool do_set (const octave_value& val)
   {
     if (val.is_bool_scalar ())
       return radio_property::do_set (val.bool_value () ? "on" : "off");
     else
       return radio_property::do_set (val);
@@ -1635,17 +1635,17 @@ public:
   {
     set (octave_value (h.value ()));
     return *this;
   }
 
   void invalidate (void)
   { current_val = octave::numeric_limits<double>::NaN (); }
 
-  base_property* clone (void) const { return new handle_property (*this); }
+  base_property * clone (void) const { return new handle_property (*this); }
 
   void add_constraint (const std::string& type)
   { type_constraints.insert (type); }
 
 protected:
   OCTINTERP_API bool do_set (const octave_value& v);
   std::set<std::string> type_constraints;
 
@@ -1668,17 +1668,17 @@ public:
   octave_value get (void) const { return data; }
 
   any_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
-  base_property* clone (void) const { return new any_property (*this); }
+  base_property * clone (void) const { return new any_property (*this); }
 
 protected:
   bool do_set (const octave_value& v)
   {
     data = v;
     return true;
   }
 
@@ -1711,17 +1711,17 @@ public:
   }
 
   children_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
-  base_property* clone (void) const { return new children_property (*this); }
+  base_property * clone (void) const { return new children_property (*this); }
 
   bool remove_child (double val)
   {
     return do_remove_child (val);
   }
 
   void adopt (double val)
   {
@@ -1903,17 +1903,17 @@ public:
   }
 
   callback_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
-  base_property* clone (void) const { return new callback_property (*this); }
+  base_property * clone (void) const { return new callback_property (*this); }
 
 protected:
   bool do_set (const octave_value& v)
   {
     if (! validate (v))
       error ("invalid value for callback property \"%s\"",
              get_name ().c_str ());
 
@@ -2260,17 +2260,17 @@ class graphics_toolkit
 {
 public:
   graphics_toolkit (void)
     : rep (new base_graphics_toolkit ("unknown"))
   {
     rep->count++;
   }
 
-  graphics_toolkit (base_graphics_toolkit* b)
+  graphics_toolkit (base_graphics_toolkit *b)
     : rep (b)
   {
     rep->count++;
   }
 
   graphics_toolkit (const graphics_toolkit& b)
     : rep (b.rep)
   {
@@ -6520,17 +6520,17 @@ public:
   static void post_callback (const graphics_handle& h,
                              const std::string& name,
                              const octave_value& data = Matrix ())
   {
     if (instance_ok ())
       instance->do_post_callback (h, name, data);
   }
 
-  static void post_function (graphics_event::event_fcn fcn, void* data = 0)
+  static void post_function (graphics_event::event_fcn fcn, void *data = 0)
   {
     if (instance_ok ())
       instance->do_post_function (fcn, data);
   }
 
   static void post_set (const graphics_handle& h, const std::string& name,
                         const octave_value& value, bool notify_toolkit = true)
   {
@@ -6719,17 +6719,17 @@ private:
   void do_execute_listener (const graphics_handle& h, const octave_value& l);
 
   void do_execute_callback (const graphics_handle& h, const octave_value& cb,
                             const octave_value& data);
 
   void do_post_callback (const graphics_handle& h, const std::string& name,
                          const octave_value& data);
 
-  void do_post_function (graphics_event::event_fcn fcn, void* fcn_data);
+  void do_post_function (graphics_event::event_fcn fcn, void *fcn_data);
 
   void do_post_set (const graphics_handle& h, const std::string& name,
                     const octave_value& value, bool notify_toolkit = true);
 
   int do_process_events (bool force = false);
 
   void do_close_all_figures (void);
 
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -698,17 +698,17 @@ hdf5_read_next_data (octave_hdf5_id grou
   return hdf5_read_next_data_internal (new_id, name, dv);
 
 #else
   err_disabled_feature ("hdf5_read_next_data", "HDF5");
 #endif
 }
 
 octave_hdf5_err
-hdf5_h5g_iterate (octave_hdf5_id loc_id, const char* name, int *idx,
+hdf5_h5g_iterate (octave_hdf5_id loc_id, const char *name, int *idx,
                   void *operator_data)
 {
 #if defined (HAVE_HDF5)
 
   hid_t new_id = check_hdf5_id_value (loc_id, "hdf5_h5g_iterate");
 
   return H5Giterate (new_id, name, idx, hdf5_read_next_data_internal,
                      operator_data);
diff --git a/libinterp/corefcn/ls-hdf5.h b/libinterp/corefcn/ls-hdf5.h
--- a/libinterp/corefcn/ls-hdf5.h
+++ b/libinterp/corefcn/ls-hdf5.h
@@ -121,17 +121,17 @@ hdf5_make_complex_type (octave_hdf5_id n
 
 extern OCTINTERP_API bool
 hdf5_types_compatible (octave_hdf5_id t1, octave_hdf5_id t2);
 
 extern OCTINTERP_API octave_hdf5_err
 hdf5_read_next_data (octave_hdf5_id group_id, const char *name, void *dv);
 
 extern OCTINTERP_API octave_hdf5_err
-hdf5_h5g_iterate (octave_hdf5_id loc_id, const char* name, int *idx,
+hdf5_h5g_iterate (octave_hdf5_id loc_id, const char *name, int *idx,
                   void *operator_data);
 
 extern OCTINTERP_API bool
 add_hdf5_data (octave_hdf5_id loc_id, const octave_value& tc,
                const std::string& name, const std::string& doc,
                bool mark_as_global, bool save_as_floats);
 
 extern OCTINTERP_API int
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -1191,17 +1191,17 @@ read_mat5_binary_element (std::istream& 
                 // inline is not an object in Octave but rather an
                 // overload of a function handle.  Special case.
                 tc =
                   new octave_fcn_inline (m.contents ("expr")(0).string_value (),
                                          m.contents ("args")(0).string_value ());
               }
             else
               {
-                octave_class* cls
+                octave_class *cls
                   = new octave_class (m, classname,
                                       std::list<std::string> ());
 
                 if (cls->reconstruct_exemplar ())
                   {
 
                     if (! cls->reconstruct_parents ())
                       warning ("load: unable to reconstruct object inheritance");
@@ -1877,17 +1877,17 @@ write_mat5_cell_array (std::ostream& os,
                                       false, save_as_floats))
         return false;
     }
 
   return true;
 }
 
 int
-save_mat5_array_length (const double* val, octave_idx_type nel,
+save_mat5_array_length (const double *val, octave_idx_type nel,
                         bool save_as_floats)
 {
   if (nel > 0)
     {
       int size = 8;
 
       if (save_as_floats)
         {
@@ -2007,17 +2007,17 @@ save_mat5_array_length (const float* /* 
       // Take into account short tags for 4 byte elements.
       return PAD ((nel > 0 && nel * size <= 4 ? 4 : 8) + nel * size);
     }
   else
     return 8;
 }
 
 int
-save_mat5_array_length (const Complex* val, octave_idx_type nel,
+save_mat5_array_length (const Complex *val, octave_idx_type nel,
                         bool save_as_floats)
 {
   int ret;
 
   OCTAVE_LOCAL_BUFFER (double, tmp, nel);
 
   for (octave_idx_type i = 1; i < nel; i++)
     tmp[i] = octave::math::real (val[i]);
@@ -2028,17 +2028,17 @@ save_mat5_array_length (const Complex* v
     tmp[i] = octave::math::imag (val[i]);
 
   ret += save_mat5_array_length (tmp, nel, save_as_floats);
 
   return ret;
 }
 
 int
-save_mat5_array_length (const FloatComplex* val, octave_idx_type nel,
+save_mat5_array_length (const FloatComplex *val, octave_idx_type nel,
                         bool save_as_floats)
 {
   int ret;
 
   OCTAVE_LOCAL_BUFFER (float, tmp, nel);
 
   for (octave_idx_type i = 1; i < nel; i++)
     tmp[i] = octave::math::real (val[i]);
diff --git a/libinterp/corefcn/mex.h b/libinterp/corefcn/mex.h
--- a/libinterp/corefcn/mex.h
+++ b/libinterp/corefcn/mex.h
@@ -64,19 +64,19 @@ typedef void mxArray;
 
 #include "mexproto.h"
 
 #if defined (__cplusplus)
 extern "C" {
 #endif
 
 #if defined (V4)
-void mexFunction (int nlhs, mxArray* plhs[], int nrhs, mxArray *prhs[]);
+void mexFunction (int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[]);
 #else
-void mexFunction (int nlhs, mxArray* plhs[], int nrhs, const mxArray *prhs[]);
+void mexFunction (int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]);
 #endif
 
 /* V4 floating point routines renamed in V5.  */
 #define mexIsNaN mxIsNaN
 #define mexIsFinite mxIsFinite
 #define mexIsInf mxIsInf
 #define mexGetEps mxGetEps
 #define mexGetInf mxGetInf
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -117,17 +117,17 @@ octave_fields::orderfields (Array<octave
       octave_idx_type j = fld_idx.second;
       fld_idx.second = i;
       perm(i++) = j;
     }
 }
 
 bool
 octave_fields::equal_up_to_order (const octave_fields& other,
-                                  octave_idx_type* perm) const
+                                  octave_idx_type *perm) const
 {
   bool retval = true;
 
   iterator p = begin ();
   iterator q = other.begin ();
   for (; p != end () && q != other.end (); p++, q++)
     {
       if (p->first == q->first)
diff --git a/libinterp/corefcn/oct-map.h b/libinterp/corefcn/oct-map.h
--- a/libinterp/corefcn/oct-map.h
+++ b/libinterp/corefcn/oct-map.h
@@ -125,17 +125,17 @@ public:
   // order the fields of this map.
   // creates a permutation used to order the fields.
   void orderfields (Array<octave_idx_type>& perm);
 
   // compares two instances for equality up to order of fields.
   // returns a permutation needed to bring the fields of *other*
   // into the order of *this*.
   bool equal_up_to_order (const octave_fields& other,
-                          octave_idx_type* perm) const;
+                          octave_idx_type *perm) const;
 
   bool equal_up_to_order (const octave_fields& other,
                           Array<octave_idx_type>& perm) const;
 
   bool is_same (const octave_fields& other) const
   { return rep == other.rep; }
 
   // Returns the fields as a vector of strings.
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -4165,17 +4165,17 @@ namespace octave
       }
 
     return cnt;
   }
 
   template <typename T>
   std::istream&
   octave_scan_1 (std::istream& is, const scanf_format_elt& fmt,
-                 T* valptr)
+                 T *valptr)
   {
     T value = T ();
 
     switch (fmt.type)
       {
       case 'o':
         is >> std::oct >> value >> std::dec;
         break;
@@ -4252,17 +4252,17 @@ namespace octave
     if (! (is.rdstate () & std::ios::failbit))
       *valptr = value;
 
     return is;
   }
 
   template <typename T>
   std::istream&
-  octave_scan (std::istream& is, const scanf_format_elt& fmt, T* valptr)
+  octave_scan (std::istream& is, const scanf_format_elt& fmt, T *valptr)
   {
     if (fmt.width)
       {
         // Limit input to fmt.width characters by reading into a
         // temporary stringstream buffer.
         std::string tmp;
 
         is.width (fmt.width);
@@ -4279,24 +4279,24 @@ namespace octave
   }
 
   // Note that this specialization is only used for reading characters, not
   // character strings.  See BEGIN_S_CONVERSION for details.
 
   template <>
   std::istream&
   octave_scan<> (std::istream& is, const scanf_format_elt& /* fmt */,
-                 char* valptr)
+                 char *valptr)
   {
     return is >> valptr;
   }
 
   template <>
   std::istream&
-  octave_scan<> (std::istream& is, const scanf_format_elt& fmt, double* valptr)
+  octave_scan<> (std::istream& is, const scanf_format_elt& fmt, double *valptr)
   {
     double& ref = *valptr;
 
     switch (fmt.type)
       {
       case 'e':
       case 'f':
       case 'g':
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -71,17 +71,17 @@ octave_link::set_workspace (void)
                                 symbol_table::workspace_info ());
 }
 
 // OBJ should be an object of a class that is derived from the base
 // class octave_link, or 0 to disconnect the link.  It is the
 // responsibility of the caller to delete obj.
 
 void
-octave_link::connect_link (octave_link* obj)
+octave_link::connect_link (octave_link *obj)
 {
   if (obj && instance)
     error ("octave_link is already linked!");
 
   instance = obj;
 }
 
 void
diff --git a/libinterp/corefcn/profiler.cc b/libinterp/corefcn/profiler.cc
--- a/libinterp/corefcn/profiler.cc
+++ b/libinterp/corefcn/profiler.cc
@@ -48,30 +48,30 @@ profile_data_accumulator::stats::functio
   for (const auto& nm : list)
     retval(i++) = nm;
 
   assert (i == n);
 
   return retval;
 }
 
-profile_data_accumulator::tree_node::tree_node (tree_node* p, octave_idx_type f)
+profile_data_accumulator::tree_node::tree_node (tree_node *p, octave_idx_type f)
   : parent (p), fcn_id (f), children (), time (0.0), calls (0)
 { }
 
 profile_data_accumulator::tree_node::~tree_node ()
 {
   for (auto& idx_tnode : children)
     delete idx_tnode.second;
 }
 
 profile_data_accumulator::tree_node*
 profile_data_accumulator::tree_node::enter (octave_idx_type fcn)
 {
-  tree_node* retval;
+  tree_node *retval;
 
   child_map::iterator pos = children.find (fcn);
   if (pos == children.end ())
     {
       retval = new tree_node (this, fcn);
       children[fcn] = retval;
     }
   else
@@ -106,31 +106,31 @@ profile_data_accumulator::tree_node::bui
       assert (parent);
       if (parent->fcn_id != 0)
         {
           entry.parents.insert (parent->fcn_id);
           data[parent->fcn_id - 1].children.insert (fcn_id);
         }
 
       if (! entry.recursive)
-        for (const tree_node* i = parent; i; i = i->parent)
+        for (const tree_node *i = parent; i; i = i->parent)
           if (i->fcn_id == fcn_id)
             {
               entry.recursive = true;
               break;
             }
     }
 
   // Recurse on children.
   for (const auto& idx_tnode : children)
     idx_tnode.second->build_flat (data);
 }
 
 octave_value
-profile_data_accumulator::tree_node::get_hierarchical (double* total) const
+profile_data_accumulator::tree_node::get_hierarchical (double *total) const
 {
   // Note that we don't generate the entry just for this node, but
   // rather a struct-array with entries for all children.  This way, the
   // top-node (for which we don't want a real entry) generates already
   // the final hierarchical profile data.
 
   const octave_idx_type n = children.size ();
 
diff --git a/libinterp/corefcn/profiler.h b/libinterp/corefcn/profiler.h
--- a/libinterp/corefcn/profiler.h
+++ b/libinterp/corefcn/profiler.h
@@ -141,33 +141,33 @@ private:
     tree_node (const tree_node&) = delete;
 
     tree_node& operator = (const tree_node&) = delete;
 
     void add_time (double dt) { time += dt; }
 
     // Enter a child function.  It is created in the list of children if it
     // wasn't already there.  The now-active child node is returned.
-    tree_node* enter (octave_idx_type);
+    tree_node *enter (octave_idx_type);
 
     // Exit function.  As a sanity-check, it is verified that the currently
     // active function actually is the one handed in here.  Returned is the
     // then-active node, which is our parent.
-    tree_node* exit (octave_idx_type);
+    tree_node *exit (octave_idx_type);
 
     void build_flat (flat_profile&) const;
 
     // Get the hierarchical profile for this node and its children.  If total
     // is set, accumulate total time of the subtree in that variable as
     // additional return value.
-    octave_value get_hierarchical (double* total = 0) const;
+    octave_value get_hierarchical (double *total = 0) const;
 
   private:
 
-    tree_node* parent;
+    tree_node *parent;
     octave_idx_type fcn_id;
 
     typedef std::map<octave_idx_type, tree_node*> child_map;
     child_map children;
 
     // This is only time spent *directly* on this level, excluding children!
     double time;
 
@@ -181,18 +181,18 @@ private:
   typedef std::vector<std::string> function_set;
   typedef std::map<std::string, octave_idx_type> fcn_index_map;
 
   function_set known_functions;
   fcn_index_map fcn_index;
 
   bool enabled;
 
-  tree_node* call_tree;
-  tree_node* active_fcn;
+  tree_node *call_tree;
+  tree_node *active_fcn;
 
   // Store last timestamp we had, when the currently active function was called.
   double last_time;
 
   // These are private as only the unwind-protecting inner class enter
   // should be allowed to call them.
   void enter_function (const std::string&);
   void exit_function (const std::string&);
diff --git a/libinterp/corefcn/psi.cc b/libinterp/corefcn/psi.cc
--- a/libinterp/corefcn/psi.cc
+++ b/libinterp/corefcn/psi.cc
@@ -82,18 +82,18 @@ can have any value real or complex value
   if (k == 0)
     {
 #define FLOAT_BRANCH(T, A, M, E)                                \
       if (oct_z.is_ ## T ##_type ())                            \
         {                                                       \
           const A ## NDArray z = oct_z.M ## array_value ();     \
           A ## NDArray psi_z (z.dims ());                       \
                                                                 \
-          const E* zv = z.data ();                              \
-          E* psi_zv = psi_z.fortran_vec ();                     \
+          const E *zv = z.data ();                              \
+          E *psi_zv = psi_z.fortran_vec ();                     \
           const octave_idx_type n = z.numel ();                 \
           for (octave_idx_type i = 0; i < n; i++)               \
             *psi_zv++ = octave::math::psi (*zv++);              \
                                                                 \
           retval = psi_z;                                       \
         }
 
       if (oct_z.is_complex_type ())
@@ -119,18 +119,18 @@ can have any value real or complex value
         error ("psi: Z must be real value for polygamma (K > 0)");
 
 #define FLOAT_BRANCH(T, A, M, E)                                        \
       if (oct_z.is_ ## T ##_type ())                                    \
         {                                                               \
           const A ## NDArray z = oct_z.M ## array_value ();             \
           A ## NDArray psi_z (z.dims ());                               \
                                                                         \
-          const E* zv = z.data ();                                      \
-          E* psi_zv = psi_z.fortran_vec ();                             \
+          const E *zv = z.data ();                                      \
+          E *psi_zv = psi_z.fortran_vec ();                             \
           const octave_idx_type n = z.numel ();                         \
           for (octave_idx_type i = 0; i < n; i++)                       \
             {                                                           \
               if (*zv < 0)                                              \
                 error ("psi: Z must be non-negative for polygamma (K > 0)"); \
                                                                         \
               *psi_zv++ = octave::math::psi (k, *zv++);                 \
             }                                                           \
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -61,19 +61,19 @@ typedef F77_INT (*sort_function) (const 
                                   const double& S, const double& P);
 
 extern "C"
 {
   // Van Dooren's code (netlib.org: toms/590) for reordering GEP.
   // Only processes Z, not Q.
   F77_RET_T
   F77_FUNC (dsubsp, DSUBSP) (const F77_INT& NMAX, const F77_INT& N,
-                             F77_DBLE* A, F77_DBLE* B, F77_DBLE* Z,
+                             F77_DBLE *A, F77_DBLE *B, F77_DBLE *Z,
                              sort_function, const F77_DBLE& EPS,
-                             F77_INT& NDIM, F77_INT& FAIL, F77_INT* IND);
+                             F77_INT& NDIM, F77_INT& FAIL, F77_INT *IND);
 }
 
 // fcrhp, fin, fout, folhp:
 // Routines for ordering of generalized eigenvalues.
 // Return 1 if test is passed, 0 otherwise.
 //   fin:  |lambda| < 1
 //   fout: |lambda| >= 1
 //   fcrhp: real(lambda) >= 0
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -327,17 +327,17 @@ namespace octave
       return new w32_interrupt_manager ();
 #else
       return new posix_interrupt_manager ();
 #endif
     }
 
     static void cleanup_instance (void) { delete instance; instance = 0; }
 
-    static base_interrupt_manager* instance;
+    static base_interrupt_manager *instance;
   };
 
   base_interrupt_manager *interrupt_manager::instance = 0;
 
   static void
   my_friendly_exit (int sig, bool save_vars = true)
   {
     std::cerr << "fatal: caught signal "
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -460,17 +460,17 @@ public:
         return new symbol_record_rep (new_scope, name, varval (),
                                       storage_class);
       }
 
       void dump (std::ostream& os, const std::string& prefix) const;
 
       scope_id decl_scope;
 
-      octave_user_function* curr_fcn;
+      octave_user_function *curr_fcn;
 
       std::string name;
 
       std::deque<octave_value> value_stack;
 
       unsigned int storage_class;
 
       fcn_info *finfo;
diff --git a/libinterp/corefcn/txt-eng.h b/libinterp/corefcn/txt-eng.h
--- a/libinterp/corefcn/txt-eng.h
+++ b/libinterp/corefcn/txt-eng.h
@@ -109,17 +109,17 @@ class
 OCTINTERP_API
 text_element_list
   : public text_element, public octave::base_list<text_element *>
 {
 public:
   text_element_list (void)
     : text_element (), octave::base_list<text_element*> () { }
 
-  text_element_list (text_element* e)
+  text_element_list (text_element *e)
     : text_element (), octave::base_list<text_element*> ()
   { push_back (e); }
 
   ~text_element_list (void)
   {
     while (! empty ())
       {
         iterator it = begin ();
@@ -131,72 +131,72 @@ public:
   void accept (text_processor& p);
 };
 
 class
 OCTINTERP_API
 text_element_subscript : public text_element
 {
 public:
-  text_element_subscript (text_element* e)
+  text_element_subscript (text_element *e)
     : text_element (), elem (e) { }
 
   text_element_subscript (char c)
     : text_element ()
   { elem = new text_element_string (std::string (1, c)); }
 
   ~text_element_subscript (void)
   { delete elem; }
 
   void accept (text_processor& p);
 
-  text_element* get_element (void) { return elem; }
+  text_element * get_element (void) { return elem; }
 
 private:
-  text_element* elem;
+  text_element *elem;
 
 private:
   text_element_subscript (void);
 };
 
 class
 OCTINTERP_API
 text_element_superscript : public text_element
 {
 public:
-  text_element_superscript (text_element* e)
+  text_element_superscript (text_element *e)
     : text_element (), elem (e) { }
 
   text_element_superscript (char c)
     : text_element ()
   { elem = new text_element_string (std::string (1, c)); }
 
   ~text_element_superscript (void)
   { delete elem; }
 
   void accept (text_processor& p);
 
-  text_element* get_element (void) { return elem; }
+  text_element * get_element (void) { return elem; }
 
 private:
-  text_element* elem;
+  text_element *elem;
 
 private:
   text_element_superscript (void);
 };
 
 class
 OCTINTERP_API
 text_element_combined : public text_element_list
 {
 public:
-  text_element_combined (text_element* e)
+  text_element_combined (text_element *e)
     : text_element_list (e) { }
 
-  text_element_combined (text_element* e1, text_element* e2)
+  text_element_combined (text_element *e1, text_element *e2)
     : text_element_list(e1)
   { push_back (e2); }
 
   void accept (text_processor& p);
 };
 
 class
 OCTINTERP_API
@@ -373,38 +373,38 @@ class
 OCTINTERP_API
 text_parser
 {
 public:
   text_parser (void) { }
 
   virtual ~text_parser (void) = default;
 
-  virtual text_element* parse (const std::string& s) = 0;
+  virtual text_element * parse (const std::string& s) = 0;
 
 public:
-  static text_element* parse (const std::string& s,
-                              const caseless_str& interpreter);
+  static text_element * parse (const std::string& s,
+                               const caseless_str& interpreter);
 };
 
 class
 OCTINTERP_API
 text_parser_none : public text_parser
 {
 public:
   text_parser_none (void) : text_parser () { }
 
   ~text_parser_none (void) = default;
 
   // FIXME: is it possible to use reference counting to manage the
   // memory for the object returned by the text parser?  That would be
   // preferable to having to know when and where to delete the object it
   // creates...
 
-  text_element* parse (const std::string& s)
+  text_element * parse (const std::string& s)
   {
     return new text_element_string (s);
   }
 };
 
 class
 OCTINTERP_API
 text_parser_tex : public text_parser
@@ -412,35 +412,35 @@ text_parser_tex : public text_parser
 public:
   text_parser_tex (void)
     : text_parser (), scanner (0), buffer_state (0), result (0)
   { }
 
   ~text_parser_tex (void)
   { destroy_lexer (); }
 
-  text_element* parse (const std::string& s);
+  text_element * parse (const std::string& s);
 
-  void* get_scanner (void) { return scanner; }
+  void * get_scanner (void) { return scanner; }
 
-  void set_parse_result (text_element* e) { result = e; }
+  void set_parse_result (text_element *e) { result = e; }
 
-  text_element* get_parse_result (void) { return result; }
+  text_element * get_parse_result (void) { return result; }
 
 private:
   bool init_lexer (const std::string& s);
 
   void destroy_lexer (void);
 
 private:
-  void* scanner;
+  void *scanner;
 
-  void* buffer_state;
+  void *buffer_state;
 
-  text_element* result;
+  text_element *result;
 };
 
 inline text_element*
 text_parser::parse (const std::string& s, const caseless_str& interpreter)
 {
   std::unique_ptr<text_parser> parser;
 
   if (interpreter.compare ("tex"))
diff --git a/libinterp/corefcn/zfstream.cc b/libinterp/corefcn/zfstream.cc
--- a/libinterp/corefcn/zfstream.cc
+++ b/libinterp/corefcn/zfstream.cc
@@ -135,17 +135,17 @@ gzfilebuf::attach (int fd, std::ios_base
 // Close gzipped file
 gzfilebuf*
 gzfilebuf::close ()
 {
   // Fail immediately if no file is open
   if (! this->is_open ())
     return 0;
   // Assume success
-  gzfilebuf* retval = this;
+  gzfilebuf *retval = this;
   // Attempt to sync and close gzipped file
   if (this->sync () == -1)
     retval = 0;
   if (gzclose (file) < 0)
     retval = 0;
   // File is now gone anyway (postcondition [27.8.1.3.8])
   file = 0;
   own_fd = false;
@@ -153,17 +153,17 @@ gzfilebuf::close ()
   this->disable_buffer ();
   return retval;
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Convert int open mode to mode string
 bool
-gzfilebuf::open_mode (std::ios_base::openmode mode, char* c_mode) const
+gzfilebuf::open_mode (std::ios_base::openmode mode, char *c_mode) const
 {
   // FIXME: do we need testb?
   // bool testb = mode & std::ios_base::binary;
   bool testi = mode & std::ios_base::in;
   bool testo = mode & std::ios_base::out;
   bool testt = mode & std::ios_base::trunc;
   bool testa = mode & std::ios_base::app;
 
@@ -342,17 +342,17 @@ gzfilebuf::overflow (int_type c)
   if (traits_type::eq_int_type (c, traits_type::eof ()))
     return traits_type::not_eof (c);
   else
     return c;
 }
 
 // Assign new buffer
 std::streambuf*
-gzfilebuf::setbuf (char_type* p, std::streamsize n)
+gzfilebuf::setbuf (char_type *p, std::streamsize n)
 {
   // First make sure stuff is sync'ed, for safety
   if (this->sync () == -1)
     return 0;
   // If buffering is turned off on purpose via setbuf(0,0), still allocate one.
   // "Unbuffered" only really refers to put [27.8.1.4.10], while get needs at
   // least a buffer of size 1 (very inefficient though, therefore make it
   // bigger?).  This follows from [27.5.2.4.3]/12 (gptr needs to point at
@@ -515,34 +515,34 @@ gzfilebuf::seekpos (pos_type sp, std::io
 }
 
 // Default constructor initializes stream buffer
 gzifstream::gzifstream ()
   : std::istream (0), sb ()
 { this->init (&sb); }
 
 // Initialize stream buffer and open file
-gzifstream::gzifstream (const char* name, std::ios_base::openmode mode)
+gzifstream::gzifstream (const char *name, std::ios_base::openmode mode)
   : std::istream (0), sb ()
 {
   this->init (&sb);
   this->open (name, mode);
 }
 
 // Initialize stream buffer and attach to file
 gzifstream::gzifstream (int fd, std::ios_base::openmode mode)
   : std::istream (0), sb ()
 {
   this->init (&sb);
   this->attach (fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
-gzifstream::open (const char* name, std::ios_base::openmode mode)
+gzifstream::open (const char *name, std::ios_base::openmode mode)
 {
   if (! sb.open (name, mode | std::ios_base::in))
     this->setstate (std::ios_base::failbit);
   else
     this->clear ();
 }
 
 // Attach to file and go into fail() state if unsuccessful
@@ -564,34 +564,34 @@ gzifstream::close ()
 }
 
 // Default constructor initializes stream buffer
 gzofstream::gzofstream ()
   : std::ostream (0), sb ()
 { this->init (&sb); }
 
 // Initialize stream buffer and open file
-gzofstream::gzofstream (const char* name, std::ios_base::openmode mode)
+gzofstream::gzofstream (const char *name, std::ios_base::openmode mode)
   : std::ostream (0), sb ()
 {
   this->init (&sb);
   this->open (name, mode);
 }
 
 // Initialize stream buffer and attach to file
 gzofstream::gzofstream (int fd, std::ios_base::openmode mode)
   : std::ostream (0), sb ()
 {
   this->init (&sb);
   this->attach (fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
-gzofstream::open (const char* name, std::ios_base::openmode mode)
+gzofstream::open (const char *name, std::ios_base::openmode mode)
 {
   if (! sb.open (name, mode | std::ios_base::out))
     this->setstate (std::ios_base::failbit);
   else
     this->clear ();
 }
 
 // Attach to file and go into fail() state if unsuccessful
diff --git a/libinterp/corefcn/zfstream.h b/libinterp/corefcn/zfstream.h
--- a/libinterp/corefcn/zfstream.h
+++ b/libinterp/corefcn/zfstream.h
@@ -88,17 +88,17 @@ public:
 
   /**
    *  @brief  Open gzipped file.
    *  @param  name  Filename.
    *  @param  mode  Open mode flags.
    *  @return  @c this on success, NULL on failure.
   */
   gzfilebuf*
-  open (const char* name,
+  open (const char *name,
         std::ios_base::openmode mode);
 
   /**
    *  @brief  Attach to already open gzipped file.
    *  @param  fd  File descriptor.
    *  @param  mode  Open mode flags.
    *  @return  @c this on success, NULL on failure.
   */
@@ -115,17 +115,17 @@ public:
 
 protected:
   /**
    *  @brief  Convert ios open mode int to mode string used by zlib.
    *  @return  True if valid mode flag combination.
   */
   bool
   open_mode (std::ios_base::openmode mode,
-             char* c_mode) const;
+             char *c_mode) const;
 
   /**
    *  @brief  Number of characters available in stream buffer.
    *  @return  Number of characters.
    *
    *  This indicates number of characters in get area of stream buffer.
    *  These characters can be read without accessing the gzipped file.
   */
@@ -158,17 +158,17 @@ protected:
    *  @brief  Installs external stream buffer.
    *  @param  p  Pointer to char buffer.
    *  @param  n  Size of external buffer.
    *  @return  @c this on success, NULL on failure.
    *
    *  Call setbuf(0,0) to enable unbuffered output.
   */
   virtual std::streambuf*
-  setbuf (char_type* p,
+  setbuf (char_type *p,
           std::streamsize n);
 
   /**
    *  @brief  Flush stream buffer to file.
    *  @return  0 on success, -1 on error.
    *
    *  This calls underflow(EOF) to do the job.
   */
@@ -245,17 +245,17 @@ private:
   bool own_fd;
 
   /**
    *  @brief  Stream buffer.
    *
    *  For simplicity this remains allocated on the free store for the
    *  entire life span of the gzfilebuf object, unless replaced by setbuf.
   */
-  char_type* buffer;
+  char_type *buffer;
 
   /**
    *  @brief  Stream buffer size.
    *
    *  Defaults to system default buffer size (typically 8192 bytes).
    *  Modified by setbuf.
   */
   std::streamsize buffer_size;
@@ -282,17 +282,17 @@ public:
   gzifstream ();
 
   /**
    *  @brief  Construct stream on gzipped file to be opened.
    *  @param  name  Filename.
    *  @param  mode  Open mode flags (forced to contain ios::in).
   */
   explicit
-  gzifstream (const char* name,
+  gzifstream (const char *name,
               std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  @brief  Construct stream on already open gzipped file.
    *  @param  fd    File descriptor.
    *  @param  mode  Open mode flags (forced to contain ios::in).
   */
   explicit
@@ -321,17 +321,17 @@ public:
    *  Stream will be in state good() if file opens successfully;
    *  otherwise in state fail().  This differs from the behavior of
    *  ifstream, which never sets the state to good() and therefore
    *  won't allow you to reuse the stream for a second file unless
    *  you manually clear() the state.  The choice is a matter of
    *  convenience.
   */
   void
-  open (const char* name,
+  open (const char *name,
         std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  @brief  Attach to already open gzipped file.
    *  @param  fd  File descriptor.
    *  @param  mode  Open mode flags (forced to contain ios::in).
    *
    *  Stream will be in state good() if attach succeeded; otherwise
@@ -369,17 +369,17 @@ public:
   gzofstream ();
 
   /**
    *  @brief  Construct stream on gzipped file to be opened.
    *  @param  name  Filename.
    *  @param  mode  Open mode flags (forced to contain ios::out).
   */
   explicit
-  gzofstream (const char* name,
+  gzofstream (const char *name,
               std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  @brief  Construct stream on already open gzipped file.
    *  @param  fd    File descriptor.
    *  @param  mode  Open mode flags (forced to contain ios::out).
   */
   explicit
@@ -408,17 +408,17 @@ public:
    *  Stream will be in state good() if file opens successfully;
    *  otherwise in state fail().  This differs from the behavior of
    *  ofstream, which never sets the state to good() and therefore
    *  won't allow you to reuse the stream for a second file unless
    *  you manually clear() the state.  The choice is a matter of
    *  convenience.
   */
   void
-  open (const char* name,
+  open (const char *name,
         std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  @brief  Attach to already open gzipped file.
    *  @param  fd  File descriptor.
    *  @param  mode  Open mode flags (forced to contain ios::out).
    *
    *  Stream will be in state good() if attach succeeded; otherwise
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -98,17 +98,17 @@ To initialize:
 #include "ov-fcn-handle.h"
 #include "ov.h"
 #include "ovl.h"
 #include "parse.h"
 #include "variables.h"
 
 #define FLTK_GRAPHICS_TOOLKIT_NAME "fltk"
 
-const char* help_text = "\
+const char *help_text = "\
 Keyboard Shortcuts\n\
 a - autoscale\n\
 p - pan/zoom\n\
 r - rotate\n\
 g - toggle grid\n\
 \n\
 Mouse\n\
 left drag - pan\n\
@@ -294,17 +294,17 @@ private:
     // This shouldn't happen because construction of Opengl_fltk
     // objects is supposed to be impossible if OpenGL is not available.
 
     panic_impossible ();
 #endif
   }
 };
 
-void script_cb (Fl_Widget*, void* data)
+void script_cb (Fl_Widget *, void *data)
 {
   static_cast<uimenu::properties *> (data)->execute_callback ();
 }
 
 class fltk_uimenu
 {
 public:
 
@@ -447,17 +447,17 @@ public:
       m_menubar->remove (idx);
   }
 
   void update_accelerator (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
-        Fl_Menu_Item* item =
+        Fl_Menu_Item *item =
           const_cast<Fl_Menu_Item *> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             std::string acc = uimenup.get_accelerator ();
             if (acc.length () > 0)
               {
                 int key = FL_CTRL + acc[0];
                 item->shortcut (key);
@@ -466,17 +466,17 @@ public:
       }
   }
 
   void update_callback (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
-        Fl_Menu_Item* item
+        Fl_Menu_Item *item
           = const_cast<Fl_Menu_Item *> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             if (! uimenup.get_callback ().is_empty ())
               item->callback (static_cast<Fl_Callback *> (script_cb),
                               static_cast<void *> (&uimenup));
             else
               item->callback (0, static_cast<void *> (0));
@@ -484,34 +484,34 @@ public:
       }
   }
 
   void update_enable (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
-        Fl_Menu_Item* item
+        Fl_Menu_Item *item
           = const_cast<Fl_Menu_Item *> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             if (uimenup.is_enable ())
               item->activate ();
             else
               item->deactivate ();
           }
       }
   }
 
   void update_foregroundcolor (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
-        Fl_Menu_Item* item
+        Fl_Menu_Item *item
           = const_cast<Fl_Menu_Item *> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             Matrix rgb = uimenup.get_foregroundcolor_rgb ();
 
             uchar r = static_cast<uchar> (std::floor (rgb (0) * 255));
             uchar g = static_cast<uchar> (std::floor (rgb (1) * 255));
             uchar b = static_cast<uchar> (std::floor (rgb (2) * 255));
@@ -529,17 +529,17 @@ public:
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
         int itemflags = 0, idx;
         int curr_idx = find_index_by_name (fltk_label.c_str ());
 
         for (idx = curr_idx - 1; idx >= 0; idx--)
           {
-            Fl_Menu_Item* item
+            Fl_Menu_Item *item
               = const_cast<Fl_Menu_Item *> (&m_menubar->menu () [idx]);
             itemflags = item->flags;
             if (item->label ())
               break;
           }
 
         if (idx >= 0 && idx < m_menubar->size ())
           {
@@ -554,17 +554,17 @@ public:
       }
   }
 
   void update_visible (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
-        Fl_Menu_Item* item
+        Fl_Menu_Item *item
           = const_cast<Fl_Menu_Item *> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             if (uimenup.is_visible ())
               item->show ();
             else
               item->hide ();
           }
@@ -582,17 +582,17 @@ public:
 
     std::string fltk_label = uimenup.get___fltk_label__ ();
 
     if (! fltk_label.empty ())
       {
         bool item_added = false;
         do
           {
-            const Fl_Menu_Item* item
+            const Fl_Menu_Item *item
               = m_menubar->find_item (fltk_label.c_str ());
 
             if (item)
               {
                 //avoid duplicate menulabels
                 size_t idx1 = fltk_label.find_last_of ("(");
                 size_t idx2 = fltk_label.find_last_of (")");
                 int len = idx2 - idx1;
@@ -754,17 +754,17 @@ public:
 
   ~fltk_uimenu (void)
   {
     delete m_menubar;
   }
 
 private:
 
-  Fl_Menu_Bar* m_menubar;
+  Fl_Menu_Bar *m_menubar;
 };
 
 #if defined (HAVE_X_WINDOWS)
 static int
 xerror_handler (Display *, XErrorEvent *)
 {
   return 0;
 }
@@ -1070,49 +1070,49 @@ private:
   figure::properties& m_fp;
 
   // Status area height.
   static const int m_status_h = 20;
 
   // Menu height
   static const int m_menu_h = 25;
 
-  fltk_uimenu* m_uimenu;
-
-  OpenGL_fltk* m_canvas;
-
-  Fl_Button* m_autoscale;
-  Fl_Button* m_togglegrid;
-  Fl_Button* m_panzoom;
-  Fl_Button* m_rotate;
-  Fl_Button* m_help;
-  Fl_Output* m_status;
-
-  Fl_Box* m_resize_dummy;
+  fltk_uimenu *m_uimenu;
+
+  OpenGL_fltk *m_canvas;
+
+  Fl_Button *m_autoscale;
+  Fl_Button *m_togglegrid;
+  Fl_Button *m_panzoom;
+  Fl_Button *m_rotate;
+  Fl_Button *m_help;
+  Fl_Output *m_status;
+
+  Fl_Box *m_resize_dummy;
 
   graphics_object m_ax_obj;
 
   int m_pos_x;
   int m_pos_y;
 
   // Window callback.
-  static void window_close (Fl_Widget*, void* data)
+  static void window_close (Fl_Widget *, void *data)
   {
     octave_value_list args;
     args(0) = static_cast<plot_window *> (data)->number ();
     octave::feval ("close", args);
   }
 
   // Button callbacks.
-  static void button_callback (Fl_Widget* ww, void* data)
+  static void button_callback (Fl_Widget *ww, void *data)
   {
     static_cast<plot_window *> (data)->button_press (ww, data);
   }
 
-  void button_press (Fl_Widget* widg, void*)
+  void button_press (Fl_Widget *widg, void *)
   {
     if (widg == m_autoscale)
       axis_auto ();
     else if (widg == m_togglegrid)
       toggle_grid ();
     else if (widg == m_panzoom)
       m_fp.set___mouse_mode__ ("pan");
     else if (widg == m_rotate)
@@ -1300,17 +1300,17 @@ private:
   int menu_dy ()
   {
     if (m_uimenu->is_visible ())
       return m_menu_h;
     else
       return 0;
   }
 
-  octave_scalar_map format_key_event (int e_key, const char* e_text, int e_state)
+  octave_scalar_map format_key_event (int e_key, const char *e_text, int e_state)
   {
     octave_scalar_map evt;
 
     evt.assign ("Character", octave_value (e_text));
     evt.assign ("Modifier", octave_value (modifier2cell (e_state)));
 
     std::string key_str;
     std::ostringstream tmp_str;
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -1825,17 +1825,17 @@ Undocumented internal function.
   octave_unused_parameter (args);
 
   err_disabled_feature ("__recorder_audiorecorder__",
                         "audio playback and recording through PortAudio");
 #else
 
   int nargin = args.length ();
 
-  audiorecorder* recorder = new audiorecorder ();
+  audiorecorder *recorder = new audiorecorder ();
 
   if (nargin > 0)
     {
       bool is_function = (args(0).is_string () || args(0).is_function_handle ()
                           || args(0).is_inline_function ());
 
       if (is_function)
         error ("audioplayer: callbacks not yet implemented");
@@ -2218,17 +2218,17 @@ Undocumented internal function.
   octave_value retval;
 #if ! defined (HAVE_PORTAUDIO)
   octave_unused_parameter (args);
 
   err_disabled_feature ("__player_audioplayer__",
                         "audio playback and recording through PortAudio");
 #else
 
-  audioplayer* recorder = new audioplayer ();
+  audioplayer *recorder = new audioplayer ();
 
   if (! recorder)
     error ("__player_audioplayer__: Couldn't instantiate new audioplayer");
 
   bool is_function = (args(0).is_string () || args(0).is_function_handle ()
                       || args(0).is_inline_function ());
 
   if (is_function)
diff --git a/libinterp/dldfcn/gzip.cc b/libinterp/dldfcn/gzip.cc
--- a/libinterp/dldfcn/gzip.cc
+++ b/libinterp/dldfcn/gzip.cc
@@ -117,26 +117,26 @@ namespace octave
     void close (void)
     {
       if (std::fclose (m_fp))
         throw std::runtime_error ("unable to close file");
 
       m_fp = nullptr;
     }
 
-    std::FILE* m_fp;
+    std::FILE *m_fp;
   };
 
 #if defined (HAVE_BZ2)
 
   class bz2
   {
   public:
 
-    static const constexpr char* extension = ".bz2";
+    static const constexpr char *extension = ".bz2";
 
     static void zip (const std::string& source_path,
                      const std::string& dest_path)
     {
       bz2::zipper z (source_path, dest_path);
       z.deflate ();
       z.close ();
     }
@@ -198,17 +198,17 @@ namespace octave
         m_dest.close ();
       }
 
     private:
 
       int m_status;
       CFile m_source;
       CFile m_dest;
-      BZFILE* m_bz;
+      BZFILE *m_bz;
     };
   };
 
 #endif
 
   // Note about zlib and gzip
   //
   // gzip is a format for compressed single files.  zlib is a format
@@ -237,17 +237,17 @@ namespace octave
 
 
 #if defined (HAVE_Z)
 
   class gz
   {
   public:
 
-    static const constexpr char* extension = ".gz";
+    static const constexpr char *extension = ".gz";
 
     static void zip (const std::string& source_path,
                      const std::string& dest_path)
     {
       gz::zipper z (source_path, dest_path);
       z.deflate ();
       z.close ();
     }
@@ -255,17 +255,17 @@ namespace octave
   private:
 
     // Util class to get a non-const char*
     class uchar_array
     {
     public:
 
       // Bytef is a typedef for unsigned char
-      unsigned char* p;
+      unsigned char *p;
 
       uchar_array (void) = delete;
 
       uchar_array (const std::string& str)
       {
         p = new Bytef[str.length () +1];
         std::strcpy (reinterpret_cast<char *> (p), str.c_str ());
       }
@@ -458,17 +458,17 @@ namespace octave
         m_dest.close ();
       }
 
     private:
 
       CFile m_source;
       CFile m_dest;
       gzip_header m_header;
-      z_stream* m_strm;
+      z_stream *m_strm;
     };
   };
 
 #endif
 
 
   template<typename X>
   string_vector
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -859,17 +859,17 @@ string_vector
 octave_class::map_keys (void) const
 {
   err_wrong_type_arg ("octave_class::map_keys()", type_name ());
 }
 
 octave_base_value *
 octave_class::find_parent_class (const std::string& parent_class_name)
 {
-  octave_base_value* retval = 0;
+  octave_base_value *retval = 0;
 
   if (parent_class_name == class_name ())
     retval = this;
   else
     {
       for (auto& par : parent_list)
         {
           octave_map::const_iterator smap = map.seek (par);
@@ -888,17 +888,17 @@ octave_class::find_parent_class (const s
     }
 
   return retval;
 }
 
 octave_base_value *
 octave_class::unique_parent_class (const std::string& parent_class_name)
 {
-  octave_base_value* retval = 0;
+  octave_base_value *retval = 0;
 
   if (parent_class_name == class_name ())
     retval = this;
   else
     {
       for (auto& par : parent_list)
         {
           octave_map::iterator smap = map.seek (par);
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -263,17 +263,17 @@ class_get_properties (const octave_value
   return retval;
 }
 
 static cdef_class
 get_class_context (std::string& name, bool& in_constructor)
 {
   cdef_class cls;
 
-  octave_function* fcn = octave::call_stack::current ();
+  octave_function *fcn = octave::call_stack::current ();
 
   in_constructor = false;
 
   if (fcn && (fcn->is_class_method ()
               || fcn->is_classdef_constructor ()
               || fcn->is_anonymous_function_of_class ()
               || (fcn->is_private_function ()
                   && ! fcn->dispatch_class ().empty ())))
@@ -422,39 +422,39 @@ is_dummy_method (const octave_value& fcn
   return retval;
 }
 
 static bool
 is_method_executing (const octave_value& ov, const cdef_object& obj)
 {
   octave::tree_evaluator *tw = octave::current_evaluator;
 
-  octave_function* stack_fcn = octave::call_stack::current ();
-
-  octave_function* method_fcn = ov.function_value (true);
+  octave_function *stack_fcn = octave::call_stack::current ();
+
+  octave_function *method_fcn = ov.function_value (true);
 
   // Does the top of the call stack match our target function?
 
   if (stack_fcn && stack_fcn == method_fcn)
     {
-      octave_user_function* uf = method_fcn->user_function_value (true);
+      octave_user_function *uf = method_fcn->user_function_value (true);
 
       // We can only check the context object for user-function (not builtin),
       // where we have access to the parameters (arguments and return values).
       // That's ok as there's no need to call this function for builtin
       // methods.
 
       if (uf)
         {
           // At this point, the method is executing, but we still need to
           // check the context object for which the method is executing.  For
           // methods, it's the first argument of the function; for ctors, it
           // is the first return value.
 
-          octave::tree_parameter_list* pl = uf->is_classdef_constructor ()
+          octave::tree_parameter_list *pl = uf->is_classdef_constructor ()
             ? uf->return_list () : uf->parameter_list ();
 
           if (pl && pl->size () > 0)
             {
               octave::tree_decl_elt *elt = pl->front ();
 
               octave_lvalue ref = elt->lvalue (tw);
 
@@ -999,17 +999,17 @@ class octave_classdef_meta : public octa
 {
 public:
   octave_classdef_meta (const cdef_meta_object& obj)
     : object (obj) { }
 
   ~octave_classdef_meta (void)
   { object.meta_release (); }
 
-  octave_function* function_value (bool = false) { return this; }
+  octave_function * function_value (bool = false) { return this; }
 
   octave_value_list
   subsref (const std::string& type,
            const std::list<octave_value_list>& idx,
            int nargout)
   { return object.meta_subsref (type, idx, nargout); }
 
   octave_value
@@ -1067,17 +1067,17 @@ private:
 class octave_classdef_superclass_ref : public octave_function
 {
 public:
   octave_classdef_superclass_ref (const octave_value_list& a)
     : octave_function (), args (a) { }
 
   ~octave_classdef_superclass_ref (void) = default;
 
-  octave_function* function_value (bool = false) { return this; }
+  octave_function * function_value (bool = false) { return this; }
 
   octave_value_list
   subsref (const std::string& type,
            const std::list<octave_value_list>& idx,
            int nargout)
   {
     size_t skip = 0;
     octave_value_list retval;
@@ -2509,17 +2509,17 @@ cdef_class::cdef_class_rep::construct_ob
       return obj;
     }
 
   return cdef_object ();
 }
 
 static octave_value
 compute_attribute_value (octave::tree_evaluator *tw,
-                         octave::tree_classdef_attribute* t)
+                         octave::tree_classdef_attribute *t)
 {
   octave::tree_expression *expr = t->expression ();
 
   if (expr)
     {
       if (expr->is_identifier ())
         {
           std::string s = expr->name ();
@@ -2535,29 +2535,29 @@ compute_attribute_value (octave::tree_ev
       return tw->evaluate (expr);
     }
   else
     return octave_value (true);
 }
 
 template <typename T>
 static std::string
-attribute_value_to_string (T* t, octave_value v)
+attribute_value_to_string (T *t, octave_value v)
 {
   if (v.is_string ())
     return v.string_value ();
   else if (t->expression ())
     return t->expression ()->original_text ();
   else
     return std::string ("true");
 }
 
 cdef_class
 cdef_class::make_meta_class (octave::tree_evaluator *tw,
-                             octave::tree_classdef* t, bool is_at_folder)
+                             octave::tree_classdef *t, bool is_at_folder)
 {
   cdef_class retval;
   std::string class_name, full_class_name;
 
   // Class creation
 
   class_name = full_class_name = t->ident ()->name ();
   if (! t->package_name ().empty ())
@@ -2614,17 +2614,17 @@ cdef_class::make_meta_class (octave::tre
           std::cerr << "class attribute: " << aname << " = "
                     << attribute_value_to_string (attr, avalue) << std::endl;
 #endif
 
           retval.put (aname, avalue);
         }
     }
 
-  octave::tree_classdef_body* b = t->body ();
+  octave::tree_classdef_body *b = t->body ();
 
   if (b)
     {
       // Keep track of the get/set accessor methods.  They will be used
       // later on when creating properties.
 
       std::map<std::string, octave_value> get_methods;
       std::map<std::string, octave_value> set_methods;
@@ -2842,17 +2842,17 @@ cdef_class::make_meta_class (octave::tre
     }
 
   return retval;
 }
 
 octave_function*
 cdef_class::get_method_function (const std::string& /* nm */)
 {
-  octave_classdef_meta* p = new octave_classdef_meta (*this);
+  octave_classdef_meta *p = new octave_classdef_meta (*this);
 
   return p;
 }
 
 octave_value
 cdef_property::cdef_property_rep::get_value (const cdef_object& obj,
                                              bool do_check_access,
                                              const std::string& who)
@@ -3301,17 +3301,17 @@ cdef_package::cdef_package_rep::meta_sub
         octave_value o = find (nm);
 
         if (! o.is_defined ())
           error ("member `%s' in package `%s' does not exist",
                  nm.c_str (), get_name ().c_str ());
 
         if (o.is_function ())
           {
-            octave_function* fcn = o.function_value ();
+            octave_function *fcn = o.function_value ();
 
             // NOTE: the case where the package query is the last
             // part of this subsref index is handled in the parse
             // tree, because there is some logic to handle magic
             // "end" that makes it impossible to execute the
             // function call at this stage.
 
             if (type.size () > 1
@@ -3528,17 +3528,17 @@ install_classdef (octave::tree_evaluator
   symbol_table::install_built_in_function
     ("meta.event", octave_value (meta_event.get_constructor_function ()));
   symbol_table::install_built_in_function
     ("meta.dynproperty", octave_value (meta_dynproperty.get_constructor_function ()));
 }
 
 //----------------------------------------------------------------------------
 
-cdef_manager* cdef_manager::instance = 0;
+cdef_manager *cdef_manager::instance = 0;
 
 void
 cdef_manager::create_instance (void)
 {
   instance = new cdef_manager ();
 
   if (instance)
     singleton_cleanup_list::add (cleanup_instance);
@@ -3655,17 +3655,17 @@ cdef_manager::do_find_package (const std
     }
 
   return retval;
 }
 
 octave_function*
 cdef_manager::do_find_package_symbol (const std::string& pack_name)
 {
-  octave_function* retval = 0;
+  octave_function *retval = 0;
 
   cdef_package pack = find_package (pack_name, false);
 
   if (pack.ok ())
     retval = new octave_classdef_meta (pack);
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -60,32 +60,32 @@ public:
 
   virtual ~cdef_object_rep (void) = default;
 
   virtual cdef_class get_class (void) const;
 
   virtual void set_class (const cdef_class&)
   { err_invalid_object ("set_class"); }
 
-  virtual cdef_object_rep* clone (void) const
+  virtual cdef_object_rep * clone (void) const
   {
     err_invalid_object ("clone");
   }
 
-  virtual cdef_object_rep* empty_clone (void) const
+  virtual cdef_object_rep * empty_clone (void) const
   {
     err_invalid_object ("empty_clone");
   }
 
-  virtual cdef_object_rep* copy (void) const
+  virtual cdef_object_rep * copy (void) const
   {
     err_invalid_object ("copy");
   }
 
-  virtual cdef_object_rep* make_array (void) const
+  virtual cdef_object_rep * make_array (void) const
   {
     err_invalid_object ("make_array");
   }
 
   virtual bool is_array (void) const { return false; }
 
   virtual bool is_value_object (void) const { return false; }
 
@@ -268,17 +268,17 @@ public:
     make_unique (ignore_copies);
     return rep->subsasgn (type, idx, rhs);
   }
 
   string_vector map_keys (void) const { return rep->map_keys (); }
 
   octave_map map_value (void) const;
 
-  const cdef_object_rep* get_rep (void) const { return rep; }
+  const cdef_object_rep * get_rep (void) const { return rep; }
 
   bool ok (void) const { return rep->is_valid (); }
 
   void mark_for_construction (const cdef_class& cls)
   { rep->mark_for_construction (cls); }
 
   bool is_constructed (void) const { return rep->is_constructed (); }
 
@@ -291,17 +291,17 @@ public:
   void mark_as_constructed (void) { rep->mark_as_constructed (); }
 
   void mark_as_constructed (const cdef_class& cls)
   { rep->mark_as_constructed (cls); }
 
   bool is (const cdef_object& obj) const { return rep == obj.rep; }
 
 protected:
-  cdef_object_rep* get_rep (void) { return rep; }
+  cdef_object_rep * get_rep (void) { return rep; }
 
   void make_unique (int ignore_copies)
   {
     if (rep->refcount > ignore_copies + 1)
       *this = clone ();
   }
 
 private:
@@ -319,20 +319,20 @@ public:
   }
 
   ~cdef_object_base (void) { unregister_object (); }
 
   cdef_class get_class (void) const;
 
   void set_class (const cdef_class& cls);
 
-  cdef_object_rep* empty_clone (void) const
+  cdef_object_rep * empty_clone (void) const
   { return new cdef_object_base (*this); }
 
-  cdef_object_rep* make_array (void) const;
+  cdef_object_rep * make_array (void) const;
 
 protected:
   // Restricted copying!
   cdef_object_base (const cdef_object_base& obj)
     : cdef_object_rep (obj), klass (obj.klass)
   {
     register_object ();
   }
@@ -355,17 +355,17 @@ class
 cdef_object_array : public cdef_object_base
 {
 public:
   cdef_object_array (void) : cdef_object_base () { }
 
   cdef_object_array (const Array<cdef_object>& a)
     : cdef_object_base (), array (a) { }
 
-  cdef_object_rep* clone (void) const
+  cdef_object_rep * clone (void) const
   { return new cdef_object_array (*this); }
 
   dim_vector dims (void) const { return array.dims (); }
 
   bool is_valid (void) const { return true; }
 
   bool is_array (void) const { return true; }
 
@@ -461,24 +461,24 @@ class
 handle_cdef_object : public cdef_object_scalar
 {
 public:
   handle_cdef_object (void)
     : cdef_object_scalar () { }
 
   ~handle_cdef_object (void);
 
-  cdef_object_rep* clone (void) const
+  cdef_object_rep * clone (void) const
   {
     handle_cdef_object *obj = const_cast<handle_cdef_object *> (this);
     obj->refcount++;
     return obj;
   }
 
-  cdef_object_rep* copy (void) const
+  cdef_object_rep * copy (void) const
   { return new handle_cdef_object (*this); }
 
   bool is_valid (void) const { return true; }
 
   bool is_handle_object (void) const { return true; }
 
 protected:
   // Restricted copying!
@@ -494,20 +494,20 @@ class
 value_cdef_object : public cdef_object_scalar
 {
 public:
   value_cdef_object (void)
     : cdef_object_scalar () { }
 
   ~value_cdef_object (void);
 
-  cdef_object_rep* clone (void) const
+  cdef_object_rep * clone (void) const
   { return new value_cdef_object (*this); }
 
-  cdef_object_rep* copy (void) const { return clone (); }
+  cdef_object_rep * copy (void) const { return clone (); }
 
   bool is_valid (void) const { return true; }
 
   bool is_value_object (void) const { return true; }
 
 private:
   // Private copying!
   value_cdef_object (const value_cdef_object& obj)
@@ -521,17 +521,17 @@ class
 cdef_meta_object_rep : public handle_cdef_object
 {
 public:
   cdef_meta_object_rep (void)
     : handle_cdef_object () { }
 
   ~cdef_meta_object_rep (void) = default;
 
-  cdef_object_rep* copy (void) const
+  cdef_object_rep * copy (void) const
   { return new cdef_meta_object_rep (*this); }
 
   bool is_meta_object (void) const { return true; }
 
   virtual bool is_class (void) const { return false; }
 
   virtual bool is_property (void) const { return false; }
 
@@ -595,20 +595,20 @@ public:
   { return get_rep ()->meta_subsref (type, idx, nargout); }
 
   void meta_release (void) { get_rep ()->meta_release (); }
 
   bool meta_is_postfix_index_handled (char type) const
   { return get_rep ()->meta_is_postfix_index_handled (type); }
 
 private:
-  cdef_meta_object_rep* get_rep (void)
+  cdef_meta_object_rep * get_rep (void)
   { return dynamic_cast<cdef_meta_object_rep *> (cdef_object::get_rep ()); }
 
-  const cdef_meta_object_rep* get_rep (void) const
+  const cdef_meta_object_rep * get_rep (void) const
   { return dynamic_cast<const cdef_meta_object_rep *> (cdef_object::get_rep ()); }
 };
 
 class
 cdef_class : public cdef_meta_object
 {
 private:
 
@@ -619,17 +619,17 @@ private:
     cdef_class_rep (void)
       : cdef_meta_object_rep (), m_evaluator (0), member_count (0),
         handle_class (false), object_count (0), meta (false)
     { }
 
     cdef_class_rep (octave::tree_evaluator *tw,
                     const std::list<cdef_class>& superclasses);
 
-    cdef_object_rep* copy (void) const { return new cdef_class_rep (*this); }
+    cdef_object_rep * copy (void) const { return new cdef_class_rep (*this); }
 
     bool is_class (void) const { return true; }
 
     std::string get_name (void) const
     { return get ("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
 
@@ -837,22 +837,22 @@ public:
 
   bool is_builtin (void) const
   { return get_directory ().empty (); }
 
   void delete_object (cdef_object obj)
   { get_rep ()->delete_object (obj); }
 
   static cdef_class make_meta_class (octave::tree_evaluator *tw,
-                                     octave::tree_classdef* t,
+                                     octave::tree_classdef *t,
                                      bool is_at_folder = false);
 
-  octave_function* get_method_function (const std::string& nm);
+  octave_function * get_method_function (const std::string& nm);
 
-  octave_function* get_constructor_function (void)
+  octave_function * get_constructor_function (void)
   { return get_method_function (get_name ()); }
 
   octave_value construct (const octave_value_list& args)
   { return get_rep ()->construct (args); }
 
   cdef_object construct_object (const octave_value_list& args)
   { return get_rep ()->construct_object (args); }
 
@@ -885,20 +885,20 @@ public:
   enum
   {
     property_normal,
     property_inherited,
     property_all
   };
 
 private:
-  cdef_class_rep* get_rep (void)
+  cdef_class_rep * get_rep (void)
   { return dynamic_cast<cdef_class_rep *> (cdef_object::get_rep ()); }
 
-  const cdef_class_rep* get_rep (void) const
+  const cdef_class_rep * get_rep (void) const
   { return dynamic_cast<const cdef_class_rep *> (cdef_object::get_rep ()); }
 
   octave::tree_evaluator * evaluator (void) const
   { return get_rep ()->evaluator (); }
 
   friend bool operator == (const cdef_class&, const cdef_class&);
   friend bool operator != (const cdef_class&, const cdef_class&);
   friend bool operator < (const cdef_class&, const cdef_class&);
@@ -935,17 +935,17 @@ private:
 
   class
   cdef_property_rep : public cdef_meta_object_rep
   {
   public:
     cdef_property_rep (void)
       : cdef_meta_object_rep () { }
 
-    cdef_object_rep* copy (void) const { return new cdef_property_rep (*this); }
+    cdef_object_rep * copy (void) const { return new cdef_property_rep (*this); }
 
     bool is_property (void) const { return true; }
 
     std::string get_name (void) const { return get("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
 
     bool is_constant (void) const { return get("Constant").bool_value (); }
@@ -1023,20 +1023,20 @@ public:
   bool check_set_access (void) const
   { return get_rep ()->check_set_access (); }
 
   std::string get_name (void) const { return get_rep ()->get_name (); }
 
   bool is_constant (void) const { return get_rep ()->is_constant (); }
 
 private:
-  cdef_property_rep* get_rep (void)
+  cdef_property_rep * get_rep (void)
   { return dynamic_cast<cdef_property_rep *> (cdef_object::get_rep ()); }
 
-  const cdef_property_rep* get_rep (void) const
+  const cdef_property_rep * get_rep (void) const
   { return dynamic_cast<const cdef_property_rep *> (cdef_object::get_rep ()); }
 };
 
 class
 cdef_method : public cdef_meta_object
 {
   friend class cdef_class;
 
@@ -1045,17 +1045,17 @@ private:
   class
   cdef_method_rep : public cdef_meta_object_rep
   {
   public:
     cdef_method_rep (void)
       : cdef_meta_object_rep (), function (), dispatch_type ()
     { }
 
-    cdef_object_rep* copy (void) const { return new cdef_method_rep(*this); }
+    cdef_object_rep * copy (void) const { return new cdef_method_rep(*this); }
 
     bool is_method (void) const { return true; }
 
     std::string get_name (void) const { return get("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
 
     bool is_static (void) const { return get("Static").bool_value (); }
@@ -1166,20 +1166,20 @@ public:
   { return get_rep ()->is_constructor (); }
 
   bool is_external (void) const { return get_rep ()->is_external (); }
 
   void mark_as_external (const std::string& dtype)
   { get_rep ()->mark_as_external (dtype); }
 
 private:
-  cdef_method_rep* get_rep (void)
+  cdef_method_rep * get_rep (void)
   { return dynamic_cast<cdef_method_rep *> (cdef_object::get_rep ()); }
 
-  const cdef_method_rep* get_rep (void) const
+  const cdef_method_rep * get_rep (void) const
   { return dynamic_cast<const cdef_method_rep *> (cdef_object::get_rep ()); }
 };
 
 inline cdef_class
 cdef_object_rep::get_class (void) const
 {
   err_invalid_object ("get_class");
 }
@@ -1231,17 +1231,17 @@ cdef_object_base::unregister_object (voi
       if (cls.ok ())
         cls.unregister_object ();
     }
 }
 
 inline cdef_object_rep*
 cdef_object_base::make_array (void) const
 {
-  cdef_object_rep* r = new cdef_object_array ();
+  cdef_object_rep *r = new cdef_object_array ();
 
   r->set_class (get_class ());
 
   return r;
 }
 
 inline cdef_method
 cdef_class::find_method (const std::string& nm, bool local)
@@ -1262,17 +1262,17 @@ private:
   cdef_package_rep : public cdef_meta_object_rep
   {
   public:
     cdef_package_rep (void)
       : cdef_meta_object_rep (), member_count (0) { }
 
     ~cdef_package_rep (void) = default;
 
-    cdef_object_rep* copy (void) const { return new cdef_package_rep (*this); }
+    cdef_object_rep * copy (void) const { return new cdef_package_rep (*this); }
 
     bool is_package (void) const { return true; }
 
     std::string get_name (void) const { return get("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
 
     void install_class (const cdef_class& cls, const std::string& nm);
@@ -1392,20 +1392,20 @@ public:
 
   std::string get_name (void) const { return get_rep ()->get_name (); }
 
   octave_value find (const std::string& nm) { return get_rep ()->find (nm); }
 
   static const cdef_package& meta (void) { return _meta; }
 
 private:
-  cdef_package_rep* get_rep (void)
+  cdef_package_rep * get_rep (void)
   { return dynamic_cast<cdef_package_rep *> (cdef_object::get_rep ()); }
 
-  const cdef_package_rep* get_rep (void) const
+  const cdef_package_rep * get_rep (void) const
   { return dynamic_cast<const cdef_package_rep *> (cdef_object::get_rep ()); }
 
 private:
   static cdef_package _meta;
 
   friend void install_classdef (octave::tree_evaluator *);
 };
 
@@ -1417,20 +1417,20 @@ public:
     : octave_base_value (), object () { }
 
   octave_classdef (const cdef_object& obj)
     : octave_base_value (), object (obj) { }
 
   octave_classdef (const octave_classdef& obj)
     : octave_base_value (obj), object (obj.object) { }
 
-  octave_base_value* clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_classdef (object.clone ()); }
 
-  octave_base_value* empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_classdef (object.empty_clone ()); }
 
   cdef_object get_object (void) const { return object; }
 
   cdef_object& get_object_ref (void) { return object; }
 
   bool is_defined (void) const { return true; }
 
@@ -1550,17 +1550,17 @@ public:
   {
     if (instance_ok ())
       return instance->do_find_class (name, error_if_not_found,
                                       load_if_not_found);
 
     return cdef_class ();
   }
 
-  static octave_function* find_method_symbol (const std::string& method_name,
+  static octave_function * find_method_symbol (const std::string& method_name,
       const std::string& class_name)
   {
     if (instance_ok ())
       return instance->do_find_method_symbol (method_name, class_name);
 
     return 0;
   }
 
@@ -1570,17 +1570,17 @@ public:
   {
     if (instance_ok ())
       return instance->do_find_package (name, error_if_not_found,
                                         load_if_not_found);
 
     return cdef_package ();
   }
 
-  static octave_function* find_package_symbol (const std::string& pack_name)
+  static octave_function * find_package_symbol (const std::string& pack_name)
   {
     if (instance_ok ())
       return instance->do_find_package_symbol (pack_name);
 
     return 0;
   }
 
   static void register_class (const cdef_class& cls)
@@ -1637,24 +1637,24 @@ private:
     delete instance;
 
     instance = 0;
   }
 
   cdef_class do_find_class (const std::string& name, bool error_if_not_found,
                             bool load_if_not_found);
 
-  octave_function* do_find_method_symbol (const std::string& method_name,
-                                          const std::string& class_name);
+  octave_function * do_find_method_symbol (const std::string& method_name,
+                                           const std::string& class_name);
 
   cdef_package do_find_package (const std::string& name,
                                 bool error_if_not_found,
                                 bool load_if_not_found);
 
-  octave_function* do_find_package_symbol (const std::string& pack_name);
+  octave_function * do_find_package_symbol (const std::string& pack_name);
 
   void do_register_class (const cdef_class& cls)
   { all_classes[cls.get_name ()] = cls; }
 
   void do_unregister_class (const cdef_class& cls)
   { all_classes.erase(cls.get_name ()); }
 
   void do_register_package (const cdef_package& pkg)
diff --git a/libinterp/octave-value/ov-dld-fcn.h b/libinterp/octave-value/ov-dld-fcn.h
--- a/libinterp/octave-value/ov-dld-fcn.h
+++ b/libinterp/octave-value/ov-dld-fcn.h
@@ -69,20 +69,20 @@ public:
   octave::sys::time time_checked (void) const { return t_checked; }
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_builtin_function (void) const { return false; }
 
   bool is_dld_function (void) const { return true; }
 
-  static octave_dld_function* create (octave_builtin::fcn ff,
-                                      const octave::dynamic_library& shl,
-                                      const std::string& nm = "",
-                                      const std::string& ds = "");
+  static octave_dld_function * create (octave_builtin::fcn ff,
+                                       const octave::dynamic_library& shl,
+                                       const std::string& nm = "",
+                                       const std::string& ds = "");
 
   octave::dynamic_library get_shlib (void) const
   { return sh_lib; }
 
 private:
 
   octave::dynamic_library sh_lib;
 
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -848,17 +848,17 @@ Return a character string representing t
 Note that @code{char (@var{fun})} is equivalent to
 @code{formula (@var{fun})}.
 @seealso{char, argnames, inline, vectorize}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  octave_fcn_inline* fn = args(0).fcn_inline_value (true);
+  octave_fcn_inline *fn = args(0).fcn_inline_value (true);
 
   if (! fn)
     error ("formula: FUN must be an inline function");
 
   return ovl (fn->fcn_text ());
 }
 
 /*
@@ -927,17 +927,17 @@ quadv (fcn, 0, 3)
 @end example
 @seealso{inline, formula, argnames}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string old_func;
-  octave_fcn_inline* old = 0;
+  octave_fcn_inline *old = 0;
   bool func_is_string = true;
 
   if (args(0).is_string ())
     old_func = args(0).string_value ();
   else
     {
       old = args(0).fcn_inline_value (true);
       func_is_string = false;
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -125,33 +125,33 @@ typedef java_local_ref<jclass> jclass_re
 typedef java_local_ref<jstring> jstring_ref;
 typedef java_local_ref<jobjectArray> jobjectArray_ref;
 typedef java_local_ref<jintArray> jintArray_ref;
 typedef java_local_ref<jbyteArray> jbyteArray_ref;
 typedef java_local_ref<jdoubleArray> jdoubleArray_ref;
 typedef java_local_ref<jthrowable> jthrowable_ref;
 
 static std::string
-jstring_to_string (JNIEnv* jni_env, jstring s);
+jstring_to_string (JNIEnv *jni_env, jstring s);
 
 static std::string
-jstring_to_string (JNIEnv* jni_env, jobject obj);
+jstring_to_string (JNIEnv *jni_env, jobject obj);
 
 static octave_value
-box (JNIEnv* jni_env, void *jobj, void *jcls_arg = 0);
+box (JNIEnv *jni_env, void *jobj, void *jcls_arg = 0);
 
 static octave_value
-box_more (JNIEnv* jni_env, void *jobj_arg, void *jcls_arg = 0);
+box_more (JNIEnv *jni_env, void *jobj_arg, void *jcls_arg = 0);
 
 static bool
-unbox (JNIEnv* jni_env, const octave_value& val, jobject_ref& jobj,
+unbox (JNIEnv *jni_env, const octave_value& val, jobject_ref& jobj,
        jclass_ref& jcls);
 
 static bool
-unbox (JNIEnv* jni_env, const octave_value_list& args,
+unbox (JNIEnv *jni_env, const octave_value_list& args,
        jobjectArray_ref& jobjs, jobjectArray_ref& jclss);
 
 extern "C"
 {
   JNIEXPORT jboolean JNICALL
   Java_org_octave_Octave_call (JNIEnv *, jclass, jstring, jobjectArray,
                                jobjectArray);
 
diff --git a/libinterp/octave-value/ov-java.h b/libinterp/octave-value/ov-java.h
--- a/libinterp/octave-value/ov-java.h
+++ b/libinterp/octave-value/ov-java.h
@@ -46,18 +46,18 @@ public:
 
   ~octave_java (void) { release (); }
 
   void * to_java (void) const { return java_object; }
   void * to_class (void) const { return java_class; }
 
   std::string java_class_name (void) const { return java_classname; }
 
-  octave_base_value* clone (void) const { return new octave_java (*this); }
-  octave_base_value* empty_clone (void) const { return new octave_java (); }
+  octave_base_value * clone (void) const { return new octave_java (*this); }
+  octave_base_value * empty_clone (void) const { return new octave_java (); }
 
   bool is_instance_of (const std::string&) const;
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_map (void) const { return false; }
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2984,17 +2984,17 @@ Return the size of @var{val} in bytes.
 
 /*
 %!assert (sizeof (uint64 (ones (3))), 72)
 %!assert (sizeof (double (zeros (2,4))), 64)
 %!assert (sizeof ({"foo", "bar", "baaz"}), 10)
 */
 
 static void
-decode_subscripts (const char* name, const octave_value& arg,
+decode_subscripts (const char *name, const octave_value& arg,
                    std::string& type_string,
                    std::list<octave_value_list>& idx)
 {
   const octave_map m = arg.xmap_value ("%s: second argument must be a structure with fields 'type' and 'subs'", name);
 
   if (m.nfields () != 2 || ! m.contains ("type") || ! m.contains ("subs"))
     error ("%s: second argument must be a structure with fields 'type' and 'subs'",
            name);
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -58,17 +58,17 @@ namespace octave
         delete *p;
         erase (p);
       }
   }
 
   bool
   tree_argument_list::has_magic_end (void) const
   {
-    for (const tree_expression* elt : *this)
+    for (const tree_expression *elt : *this)
       {
         if (elt && elt->has_magic_end ())
           return true;
       }
 
     return false;
   }
 
@@ -85,31 +85,31 @@ namespace octave
         tree_identifier *id = dynamic_cast<tree_identifier *> (s);
         list_includes_magic_tilde = id && id->is_black_hole ();
       }
   }
 
   bool
   tree_argument_list::all_elements_are_constant (void) const
   {
-    for (const tree_expression* elt : *this)
+    for (const tree_expression *elt : *this)
       {
         if (! elt->is_constant ())
           return false;
       }
 
     return true;
   }
 
   bool
   tree_argument_list::is_valid_lvalue_list (void) const
   {
     bool retval = true;
 
-    for (const tree_expression* elt : *this)
+    for (const tree_expression *elt : *this)
       {
         // There is no need for a separate check for the magic "~" because it
         // is represented by tree_black_hole, and that is derived from
         // tree_identifier.
         if (! (elt->is_identifier () || elt->is_index_expression ()))
           {
             retval = false;
             break;
@@ -262,43 +262,43 @@ namespace octave
     return args;
   }
 
   std::list<octave_lvalue>
   tree_argument_list::lvalue_list (tree_evaluator *tw)
   {
     std::list<octave_lvalue> retval;
 
-    for (tree_expression* elt : *this)
+    for (tree_expression *elt : *this)
       retval.push_back (elt->lvalue (tw));
 
     return retval;
   }
 
   string_vector
   tree_argument_list::get_arg_names (void) const
   {
     int len = length ();
 
     string_vector retval (len);
 
     int k = 0;
 
-    for (tree_expression* elt : *this)
+    for (tree_expression *elt : *this)
       retval(k++) = elt->str_print_code ();
 
     return retval;
   }
 
   std::list<std::string>
   tree_argument_list::variable_names (void) const
   {
     std::list<std::string> retval;
 
-    for (tree_expression* elt : *this)
+    for (tree_expression *elt : *this)
       {
         if (elt->is_identifier ())
           {
             tree_identifier *id = dynamic_cast<tree_identifier *> (elt);
 
             retval.push_back (id->name ());
           }
         else if (elt->is_index_expression ())
@@ -317,14 +317,14 @@ namespace octave
   tree_argument_list::dup (symbol_table::scope_id scope,
                            symbol_table::context_id context) const
   {
     tree_argument_list *new_list = new tree_argument_list ();
 
     new_list->list_includes_magic_end = list_includes_magic_end;
     new_list->simple_assign_lhs = simple_assign_lhs;
 
-    for (const tree_expression* elt : *this)
+    for (const tree_expression *elt : *this)
       new_list->append (elt ? elt->dup (scope, context) : 0);
 
     return new_list;
   }
 }
diff --git a/libinterp/parse-tree/pt-array-list.cc b/libinterp/parse-tree/pt-array-list.cc
--- a/libinterp/parse-tree/pt-array-list.cc
+++ b/libinterp/parse-tree/pt-array-list.cc
@@ -39,31 +39,31 @@ namespace octave
         delete *p;
         erase (p);
       }
   }
 
   bool
   tree_array_list::all_elements_are_constant (void) const
   {
-    for (const tree_argument_list* elt : *this)
+    for (const tree_argument_list *elt : *this)
       {
         octave_quit ();
 
         if (! elt->all_elements_are_constant ())
           return false;
       }
 
     return true;
   }
 
   bool
   tree_array_list::has_magic_end (void) const
   {
-    for (const tree_argument_list* elt : *this)
+    for (const tree_argument_list *elt : *this)
       {
         octave_quit ();
 
         if (elt && elt->has_magic_end ())
           return true;
       }
 
     return false;
@@ -75,17 +75,17 @@ namespace octave
     tree_expression::copy_base (array_list);
   }
 
   void
   tree_array_list::copy_base (const tree_array_list& array_list,
                               symbol_table::scope_id scope,
                               symbol_table::context_id context)
   {
-    for (const tree_argument_list* elt : array_list)
+    for (const tree_argument_list *elt : array_list)
       append (elt ? elt->dup (scope, context) : 0);
 
     copy_base (*this);
   }
 
   tree_expression *
   tree_array_list::dup (symbol_table::scope_id,
                         symbol_table::context_id) const
diff --git a/libinterp/parse-tree/pt-bp.cc b/libinterp/parse-tree/pt-bp.cc
--- a/libinterp/parse-tree/pt-bp.cc
+++ b/libinterp/parse-tree/pt-bp.cc
@@ -220,17 +220,17 @@ namespace octave
 
     if (lst)
       lst->accept (*this);
   }
 
   void
   tree_breakpoint::visit_if_command_list (tree_if_command_list& lst)
   {
-    for (tree_if_clause* t : lst)
+    for (tree_if_clause *t : lst)
       {
         if (t->line () >= line)
           take_action (*t);
 
         if (! found)
           {
             tree_statement_list *stmt_lst = t->commands ();
 
@@ -352,17 +352,17 @@ namespace octave
   }
 
   // Called by
   //   tree_statement_list::set_breakpoint (int line, std::string& condition)
   // with <lst> consisting of a user function in which to set a breakpoint.
   void
   tree_breakpoint::visit_statement_list (tree_statement_list& lst)
   {
-    for (tree_statement* elt : lst)
+    for (tree_statement *elt : lst)
       {
         if (elt)
           {
             elt->accept (*this);
 
             if (found)
               break;
           }
@@ -373,17 +373,17 @@ namespace octave
   tree_breakpoint::visit_switch_case (tree_switch_case&)
   {
     panic_impossible ();
   }
 
   void
   tree_breakpoint::visit_switch_case_list (tree_switch_case_list& lst)
   {
-    for (tree_switch_case* t : lst)
+    for (tree_switch_case *t : lst)
       {
         if (t->line () >= line)
           take_action (*t);
 
         if (! found)
           {
             tree_statement_list *stmt_lst = t->commands ();
 
diff --git a/libinterp/parse-tree/pt-check.cc b/libinterp/parse-tree/pt-check.cc
--- a/libinterp/parse-tree/pt-check.cc
+++ b/libinterp/parse-tree/pt-check.cc
@@ -436,17 +436,17 @@ namespace octave
         if (expr)
           expr->accept (*this);
       }
   }
 
   void
   tree_checker::visit_statement_list (tree_statement_list& lst)
   {
-    for (tree_statement* elt : lst)
+    for (tree_statement *elt : lst)
       {
         if (elt)
           elt->accept (*this);
       }
   }
 
   void
   tree_checker::visit_switch_case (tree_switch_case& cs)
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -245,17 +245,17 @@ namespace octave
   };
 
   class tree_classdef_property_list : public octave::base_list<tree_classdef_property *>
   {
   public:
 
     tree_classdef_property_list (void) { }
 
-    tree_classdef_property_list (tree_classdef_property* p) { append (p); }
+    tree_classdef_property_list (tree_classdef_property *p) { append (p); }
 
     tree_classdef_property_list (const octave::base_list<tree_classdef_property *>& a)
       : octave::base_list<tree_classdef_property *> (a) { }
 
     // No copying!
 
     tree_classdef_property_list (const tree_classdef_property_list&) = delete;
 
@@ -663,18 +663,18 @@ namespace octave
 
     tree_classdef_body * body (void) { return element_list; }
 
     octave_comment_list * leading_comment (void) { return lead_comm; }
     octave_comment_list * trailing_comment (void) { return trail_comm; }
 
     const std::string& package_name (void) const { return pack_name; }
 
-    octave_function* make_meta_class (tree_evaluator *tw,
-                                      bool is_at_folder = false);
+    octave_function * make_meta_class (tree_evaluator *tw,
+                                       bool is_at_folder = false);
 
     tree_classdef * dup (symbol_table::scope_id scope,
                          symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef (*this);
     }
diff --git a/libinterp/parse-tree/pt-decl.cc b/libinterp/parse-tree/pt-decl.cc
--- a/libinterp/parse-tree/pt-decl.cc
+++ b/libinterp/parse-tree/pt-decl.cc
@@ -58,17 +58,17 @@ namespace octave
   // Initializer lists for declaration statements.
 
   tree_decl_init_list *
   tree_decl_init_list::dup (symbol_table::scope_id scope,
                             symbol_table::context_id context) const
   {
     tree_decl_init_list *new_dil = new tree_decl_init_list ();
 
-    for (const tree_decl_elt* elt : *this)
+    for (const tree_decl_elt *elt : *this)
       new_dil->append (elt ? elt->dup (scope, context) : 0);
 
     return new_dil;
   }
 
   // Base class for declaration commands (global, static).
 
   tree_decl_command::~tree_decl_command (void)
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -427,17 +427,17 @@ namespace octave
 
     int count = 0;
 
     octave_value tmp = symbol_table::varval (".ignored.");
     const Matrix ignored = tmp.is_defined () ? tmp.matrix_value () : Matrix ();
 
     octave_idx_type k = 0;
 
-    for (tree_decl_elt* elt : *param_list)
+    for (tree_decl_elt *elt : *param_list)
       {
         if (++count > nargout)
           break;
 
         if (! elt->is_variable ())
           {
             if (! warned)
               {
@@ -474,17 +474,17 @@ namespace octave
   }
 
   void
   tree_evaluator::define_parameter_list_from_arg_vector
     (tree_parameter_list *param_list, const octave_value_list& args)
   {
     int i = -1;
 
-    for (tree_decl_elt* elt : *param_list)
+    for (tree_decl_elt *elt : *param_list)
       {
         i++;
 
         octave_lvalue ref = elt->lvalue (this);
 
         if (i < args.length ())
           {
             if (args(i).is_defined () && args(i).is_magic_colon ())
@@ -498,17 +498,17 @@ namespace octave
         else
           eval_decl_elt (elt);
       }
   }
 
   void
   tree_evaluator::undefine_parameter_list (tree_parameter_list *param_list)
   {
-    for (tree_decl_elt* elt : *param_list)
+    for (tree_decl_elt *elt : *param_list)
       {
         octave_lvalue ref = elt->lvalue (this);
 
         ref.assign (octave_value::op_asn_eq, octave_value ());
       }
   }
 
   octave_value_list
@@ -522,33 +522,33 @@ namespace octave
     if (len == 0)
       return varargout;
     else if (nargout <= len)
       {
         octave_value_list retval (nargout);
 
         int i = 0;
 
-        for (tree_decl_elt* elt : *param_list)
+        for (tree_decl_elt *elt : *param_list)
           {
             if (elt->is_defined ())
               retval(i++) = evaluate (elt);
             else
               break;
           }
 
         return retval;
       }
     else
       {
         octave_value_list retval (len + vlen);
 
         int i = 0;
 
-        for (tree_decl_elt* elt : *param_list)
+        for (tree_decl_elt *elt : *param_list)
           retval(i++) = evaluate (elt);
 
         for (octave_idx_type j = 0; j < vlen; j++)
           retval(i++) = varargout(j);
 
         return retval;
       }
   }
@@ -670,17 +670,17 @@ namespace octave
     tree_decl_init_list *init_list = cmd.initializer_list ();
 
     if (init_list)
       {
         // If we called init_list->accept (*this), we would need a way
         // to tell tree_evaluator::visit_decl_init_list that we are
         // evaluating a global init list.
 
-        for (tree_decl_elt* elt : *init_list)
+        for (tree_decl_elt *elt : *init_list)
           do_global_init (*elt);
       }
   }
 
   void
   tree_evaluator::visit_persistent_command (tree_persistent_command& cmd)
   {
     if (debug_mode)
@@ -689,17 +689,17 @@ namespace octave
     tree_decl_init_list *init_list = cmd.initializer_list ();
 
     if (init_list)
       {
         // If we called init_list->accept (*this), we would need a way
         // to tell tree_evaluator::visit_decl_init_list that we are
         // evaluating a static init list.
 
-        for (tree_decl_elt* elt : *init_list)
+        for (tree_decl_elt *elt : *init_list)
           do_static_init (*elt);
       }
   }
 
   void
   tree_evaluator::visit_decl_elt (tree_decl_elt&)
   {
     panic_impossible ();
@@ -1038,17 +1038,17 @@ namespace octave
 
     if (lst)
       lst->accept (*this);
   }
 
   void
   tree_evaluator::visit_if_command_list (tree_if_command_list& lst)
   {
-    for (tree_if_clause* tic : lst)
+    for (tree_if_clause *tic : lst)
       {
         tree_expression *expr = tic->condition ();
 
         if (statement_context == function || statement_context == script)
           octave::call_stack::set_location (tic->line (), tic->column ());
 
         if (debug_mode && ! tic->is_else_clause ())
           do_breakpoint (tic->is_breakpoint (true));
@@ -1519,17 +1519,17 @@ namespace octave
 
     octave_idx_type nr = expr.length ();
     octave_idx_type nc = -1;
 
     Cell val;
 
     octave_idx_type i = 0;
 
-    for (tree_argument_list* elt : expr)
+    for (tree_argument_list *elt : expr)
       {
         octave_value_list row = elt->convert_to_const_vector (this);
 
         if (nr == 1)
           // Optimize the single row case.
           val = row.cell_value ();
         else if (nc < 0)
           {
@@ -2118,17 +2118,17 @@ namespace octave
              cmd.line (), cmd.column ());
 
     octave_value val = evaluate (expr);
 
     tree_switch_case_list *lst = cmd.case_list ();
 
     if (lst)
       {
-        for (tree_switch_case* t : *lst)
+        for (tree_switch_case *t : *lst)
           {
             if (t->is_default_case () || switch_case_label_matches (t, val))
               {
                 tree_statement_list *stmt_lst = t->commands ();
 
                 if (stmt_lst)
                   stmt_lst->accept (*this);
 
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -123,17 +123,17 @@ namespace octave
         delete *p;
         dyn_field.erase (p);
       }
   }
 
   bool
   tree_index_expression::has_magic_end (void) const
   {
-    for (const tree_argument_list* elt : args)
+    for (const tree_argument_list *elt : args)
       {
         if (elt && elt->has_magic_end ())
           return true;
       }
 
     return false;
   }
 
@@ -391,28 +391,28 @@ namespace octave
   {
     tree_index_expression *new_idx_expr
       = new tree_index_expression (line (), column ());
 
     new_idx_expr->expr = expr ? expr->dup (scope, context) : 0;
 
     std::list<tree_argument_list *> new_args;
 
-    for (const tree_argument_list* elt : args)
+    for (const tree_argument_list *elt : args)
       new_args.push_back (elt ? elt->dup (scope, context) : 0);
 
     new_idx_expr->args = new_args;
 
     new_idx_expr->type = type;
 
     new_idx_expr->arg_nm = arg_nm;
 
     std::list<tree_expression *> new_dyn_field;
 
-    for (const tree_expression* elt : dyn_field)
+    for (const tree_expression *elt : dyn_field)
       new_dyn_field.push_back (elt ? elt->dup (scope, context) : 0);
 
     new_idx_expr->dyn_field = new_dyn_field;
 
     new_idx_expr->copy_base (*this);
 
     return new_idx_expr;
   }
diff --git a/libinterp/parse-tree/pt-idx.h b/libinterp/parse-tree/pt-idx.h
--- a/libinterp/parse-tree/pt-idx.h
+++ b/libinterp/parse-tree/pt-idx.h
@@ -50,17 +50,17 @@ namespace octave
   public:
 
     tree_index_expression (tree_expression *e = 0, tree_argument_list *lst = 0,
                            int l = -1, int c = -1, char t = '(');
 
     tree_index_expression (tree_expression *e, const std::string& n,
                            int l = -1, int c = -1);
 
-    tree_index_expression (tree_expression *e, tree_expression* df,
+    tree_index_expression (tree_expression *e, tree_expression *df,
                            int l = -1, int c = -1);
 
     // No copying!
 
     tree_index_expression (const tree_index_expression&) = delete;
 
     tree_index_expression& operator = (const tree_index_expression&) = delete;
 
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -2292,17 +2292,17 @@ jit_function_info::jit_function_info (tr
       if (Vdebug_jit)
         {
           std::cout << "-------------------- optimized and wrapped ";
           std::cout << "--------------------\n";
           std::cout << *llvm_function << std::endl;
           llvm::verifyFunction (*llvm_function);
         }
 
-      llvm::ExecutionEngine* engine = tjit.get_engine ();
+      llvm::ExecutionEngine *engine = tjit.get_engine ();
       void *void_fn = engine->getPointerToFunction (llvm_function);
       function = reinterpret_cast<jited_function> (void_fn);
     }
   catch (const jit_fail_exception& e)
     {
       argument_types.clear ();
 
       if (Vdebug_jit)
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -48,28 +48,28 @@ namespace octave
         delete *p;
         erase (p);
       }
   }
 
   void
   tree_parameter_list::mark_as_formal_parameters (void)
   {
-    for (tree_decl_elt* elt : *this)
+    for (tree_decl_elt *elt : *this)
       elt->mark_as_formal_parameter ();
   }
 
   bool
   tree_parameter_list::validate (in_or_out type)
   {
     bool retval = true;
 
     std::set<std::string> dict;
 
-    for (tree_decl_elt* elt : *this)
+    for (tree_decl_elt *elt : *this)
       {
         tree_identifier *id = elt->ident ();
 
         if (id)
           {
             std::string name = id->name ();
 
             if (id->is_black_hole ())
@@ -112,28 +112,28 @@ namespace octave
     return retval;
   }
 
   std::list<std::string>
   tree_parameter_list::variable_names (void) const
   {
     std::list<std::string> retval;
 
-    for (tree_decl_elt* elt : *this)
+    for (tree_decl_elt *elt : *this)
       retval.push_back (elt->name ());
 
     return retval;
   }
 
   bool
   tree_parameter_list::is_defined (void)
   {
     bool status = true;
 
-    for (tree_decl_elt* elt : *this)
+    for (tree_decl_elt *elt : *this)
       {
         if (! elt->is_variable ())
           {
             status = false;
             break;
           }
       }
 
@@ -144,17 +144,17 @@ namespace octave
   tree_parameter_list::dup (symbol_table::scope_id scope,
                             symbol_table::context_id context) const
   {
     tree_parameter_list *new_list = new tree_parameter_list ();
 
     if (takes_varargs ())
       new_list->mark_varargs ();
 
-    for (const tree_decl_elt* elt : *this)
+    for (const tree_decl_elt *elt : *this)
       new_list->append (elt->dup (scope, context));
 
     return new_list;
   }
 
   // Return lists.
 
   tree_return_list::~tree_return_list (void)
@@ -168,14 +168,14 @@ namespace octave
   }
 
   tree_return_list *
   tree_return_list::dup (symbol_table::scope_id scope,
                          symbol_table::context_id context) const
   {
     tree_return_list *new_list = new tree_return_list ();
 
-    for (const tree_index_expression* elt : *this)
+    for (const tree_index_expression *elt : *this)
       new_list->append (elt->dup (scope, context));
 
     return new_list;
   }
 }
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -897,17 +897,17 @@ namespace octave
               newline ();
           }
       }
   }
 
   void
   tree_print_code::visit_statement_list (tree_statement_list& lst)
   {
-    for (tree_statement* elt : lst)
+    for (tree_statement *elt : lst)
       {
         if (elt)
           elt->accept (*this);
       }
   }
 
   void
   tree_print_code::visit_switch_case (tree_switch_case& cs)
diff --git a/libinterp/parse-tree/pt-select.cc b/libinterp/parse-tree/pt-select.cc
--- a/libinterp/parse-tree/pt-select.cc
+++ b/libinterp/parse-tree/pt-select.cc
@@ -58,17 +58,17 @@ namespace octave
   // List of if commands.
 
   tree_if_command_list *
   tree_if_command_list::dup (symbol_table::scope_id scope,
                              symbol_table::context_id context) const
   {
     tree_if_command_list *new_icl = new tree_if_command_list ();
 
-    for (const tree_if_clause* elt : *this)
+    for (const tree_if_clause *elt : *this)
       new_icl->append (elt ? elt->dup (scope, context) : 0);
 
     return new_icl;
   }
 
   // If.
 
   tree_if_command::~tree_if_command (void)
@@ -109,17 +109,17 @@ namespace octave
   // List of switch cases.
 
   tree_switch_case_list *
   tree_switch_case_list::dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const
   {
     tree_switch_case_list *new_scl = new tree_switch_case_list ();
 
-    for (const tree_switch_case* elt : *this)
+    for (const tree_switch_case *elt : *this)
       new_scl->append (elt ? elt->dup (scope, context) : 0);
 
     return new_scl;
   }
 
   // Switch.
 
   tree_switch_command::~tree_switch_command (void)
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -300,14 +300,14 @@ namespace octave
   tree_statement_list *
   tree_statement_list::dup (symbol_table::scope_id scope,
                             symbol_table::context_id context) const
   {
     tree_statement_list *new_list = new tree_statement_list ();
 
     new_list->function_body = function_body;
 
-    for (const tree_statement* elt : *this)
+    for (const tree_statement *elt : *this)
       new_list->append (elt ? elt->dup (scope, context) : 0);
 
     return new_list;
   }
 }
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -674,17 +674,17 @@ public:
   rec_resize_helper& operator = (const rec_resize_helper&) = delete;
 
   ~rec_resize_helper (void) { delete [] cext; }
 
 private:
 
   // recursive resizing
   template <typename T>
-  void do_resize_fill (const T* src, T *dest, const T& rfv, int lev) const
+  void do_resize_fill (const T *src, T *dest, const T& rfv, int lev) const
   {
     if (lev == 0)
       {
         std::copy_n (src, cext[0], dest);
         std::fill_n (dest + cext[0], dext[0] - cext[0], rfv);
       }
     else
       {
@@ -696,17 +696,17 @@ private:
 
         std::fill_n (dest + k * dd, dext[lev] - k * dd, rfv);
       }
   }
 
 public:
 
   template <typename T>
-  void resize_fill (const T* src, T *dest, const T& rfv) const
+  void resize_fill (const T *src, T *dest, const T& rfv) const
   { do_resize_fill (src, dest, rfv, n-1); }
 };
 
 template <typename T>
 Array<T>
 Array<T>::index (const idx_vector& i) const
 {
   // Colon:
@@ -814,17 +814,17 @@ Array<T>::index (const idx_vector& i, co
               ii.index (data (), n, retval.fortran_vec ());
             }
         }
       else
         {
           // Don't use resize to avoid useless initialization for POD types.
           retval = Array<T> (dim_vector (il, jl));
 
-          const T* src = data ();
+          const T *src = data ();
           T *dest = retval.fortran_vec ();
 
           for (octave_idx_type k = 0; k < jl; k++)
             dest += i.index (src + r * j.xelem (k), r, dest);
         }
     }
 
   return retval;
@@ -1237,17 +1237,17 @@ Array<T>::assign (const idx_vector& i, c
       else
         {
           // The actual work.
           octave_idx_type n = numel ();
           octave_idx_type r = dv(0);
           octave_idx_type c = dv(1);
           idx_vector ii (i);
 
-          const T* src = rhs.data ();
+          const T *src = rhs.data ();
           T *dest = fortran_vec ();
 
           // Try reduction first.
           if (ii.maybe_reduce (r, j, c))
             {
               if (isfill)
                 ii.fill (*src, n, dest);
               else
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -221,17 +221,17 @@ protected:
 
   // Rationale:
   // slice_data is a pointer to rep->data, denoting together with slice_len the
   // actual portion of the data referenced by this Array<T> object.  This
   // allows to make shallow copies not only of a whole array, but also of
   // contiguous subranges.  Every time rep is directly manipulated, slice_data
   // and slice_len need to be properly updated.
 
-  T* slice_data;
+  T *slice_data;
   octave_idx_type slice_len;
 
   //! slice constructor
   Array (const Array<T>& a, const dim_vector& dv,
          octave_idx_type l, octave_idx_type u)
     : dimensions (dv), rep(a.rep), slice_data (a.slice_data+l), slice_len (u-l)
   {
     rep->count++;
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -2500,17 +2500,17 @@ ComplexMatrix::lssolve (const ComplexMat
         lrwork = 1;
       Array<double> rwork (dim_vector (lrwork, 1));
       double *prwork = rwork.fortran_vec ();
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<F77_INT> iwork (dim_vector (liwork, 1));
-      F77_INT* piwork = iwork.fortran_vec ();
+      F77_INT *piwork = iwork.fortran_vec ();
 
       F77_INT tmp_info = 0;
       F77_INT tmp_rank = 0;
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m,
                                  F77_DBLE_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, tmp_rank, F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, tmp_info));
@@ -2712,17 +2712,17 @@ ComplexMatrix::lssolve (const ComplexCol
         lrwork = 1;
       Array<double> rwork (dim_vector (lrwork, 1));
       double *prwork = rwork.fortran_vec ();
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<F77_INT> iwork (dim_vector (liwork, 1));
-      F77_INT* piwork = iwork.fortran_vec ();
+      F77_INT *piwork = iwork.fortran_vec ();
 
       F77_INT tmp_info = 0;
       F77_INT tmp_rank = 0;
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m,
                                  F77_DBLE_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, tmp_rank, F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, tmp_info));
diff --git a/liboctave/array/MSparse.cc b/liboctave/array/MSparse.cc
--- a/liboctave/array/MSparse.cc
+++ b/liboctave/array/MSparse.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 // sparse array with math ops.
 
 // Element by element MSparse by MSparse ops.
 
 template <typename T, typename OP>
 MSparse<T>&
-plus_or_minus (MSparse<T>& a, const MSparse<T>& b, OP op, const char* op_name)
+plus_or_minus (MSparse<T>& a, const MSparse<T>& b, OP op, const char *op_name)
 {
   MSparse<T> r;
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
@@ -241,17 +241,17 @@ operator / (const T& s, const MSparse<T>
   return times_or_divides (s, a, std::divides<T> ());
 }
 
 // Element by element MSparse by MSparse ops.
 
 template <typename T, typename OP>
 MSparse<T>
 plus_or_minus (const MSparse<T>& a, const MSparse<T>& b, OP op,
-               const char* op_name, bool negate)
+               const char *op_name, bool negate)
 {
   MSparse<T> r;
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -500,50 +500,50 @@ public:
   Sparse<T>& insert (const Sparse<T>& a, const Array<octave_idx_type>& idx);
 
   bool is_square (void) const { return (dim1 () == dim2 ()); }
 
   bool is_empty (void) const { return (rows () < 1 && cols () < 1); }
 
   Sparse<T> transpose (void) const;
 
-  T* data (void) { make_unique (); return rep->d; }
+  T * data (void) { make_unique (); return rep->d; }
   T& data (octave_idx_type i) { make_unique (); return rep->data (i); }
-  T* xdata (void) { return rep->d; }
+  T * xdata (void) { return rep->d; }
   T& xdata (octave_idx_type i) { return rep->data (i); }
 
   T data (octave_idx_type i) const { return rep->data (i); }
   // FIXME: shouldn't this be returning const T*?
-  T* data (void) const { return rep->d; }
+  T * data (void) const { return rep->d; }
 
-  octave_idx_type* ridx (void) { make_unique (); return rep->r; }
+  octave_idx_type * ridx (void) { make_unique (); return rep->r; }
   octave_idx_type& ridx (octave_idx_type i)
   {
     make_unique (); return rep->ridx (i);
   }
 
-  octave_idx_type* xridx (void) { return rep->r; }
+  octave_idx_type * xridx (void) { return rep->r; }
   octave_idx_type& xridx (octave_idx_type i) { return rep->ridx (i); }
 
   octave_idx_type ridx (octave_idx_type i) const { return rep->cridx (i); }
   // FIXME: shouldn't this be returning const octave_idx_type*?
-  octave_idx_type* ridx (void) const { return rep->r; }
+  octave_idx_type * ridx (void) const { return rep->r; }
 
-  octave_idx_type* cidx (void) { make_unique (); return rep->c; }
+  octave_idx_type * cidx (void) { make_unique (); return rep->c; }
   octave_idx_type& cidx (octave_idx_type i)
   {
     make_unique (); return rep->cidx (i);
   }
 
-  octave_idx_type* xcidx (void) { return rep->c; }
+  octave_idx_type * xcidx (void) { return rep->c; }
   octave_idx_type& xcidx (octave_idx_type i) { return rep->cidx (i); }
 
   octave_idx_type cidx (octave_idx_type i) const { return rep->ccidx (i); }
   // FIXME: shouldn't this be returning const octave_idx_type*?
-  octave_idx_type* cidx (void) const { return rep->c; }
+  octave_idx_type * cidx (void) const { return rep->c; }
 
   octave_idx_type ndims (void) const { return dimensions.ndims (); }
 
   void delete_elements (const idx_vector& i);
 
   void delete_elements (int dim, const idx_vector& i);
 
   void delete_elements (const idx_vector& i, const idx_vector& j);
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -2145,17 +2145,17 @@ Matrix::lssolve (const Matrix& b, octave
       F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<F77_INT> iwork (dim_vector (liwork, 1));
-      F77_INT* piwork = iwork.fortran_vec ();
+      F77_INT *piwork = iwork.fortran_vec ();
 
       F77_INT tmp_info = 0;
       F77_INT tmp_rank = 0;
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, tmp_rank, work.fortran_vec (),
                                  lwork, piwork, tmp_info));
 
@@ -2356,17 +2356,17 @@ Matrix::lssolve (const ColumnVector& b, 
       F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<F77_INT> iwork (dim_vector (liwork, 1));
-      F77_INT* piwork = iwork.fortran_vec ();
+      F77_INT *piwork = iwork.fortran_vec ();
 
       F77_INT tmp_info = 0;
       F77_INT tmp_rank = 0;
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, tmp_rank, work.fortran_vec (),
                                  lwork, piwork, tmp_info));
 
diff --git a/liboctave/array/dim-vector.h b/liboctave/array/dim-vector.h
--- a/liboctave/array/dim-vector.h
+++ b/liboctave/array/dim-vector.h
@@ -106,33 +106,33 @@ private:
   }
 
   //! Clone this->rep.
 
   octave_idx_type * clonerep (void)
   {
     int nd = ndims ();
 
-    octave_idx_type* r = newrep (nd);
+    octave_idx_type *r = newrep (nd);
 
     std::copy_n (rep, nd, r);
 
     return r;
   }
 
   //! Clone and resize this->rep to length n, filling by given value.
 
   octave_idx_type * resizerep (int n, octave_idx_type fill_value)
   {
     int nd = ndims ();
 
     if (n < 2)
       n = 2;
 
-    octave_idx_type* r = newrep (n);
+    octave_idx_type *r = newrep (n);
 
     if (nd > n)
       nd = n;
 
     std::copy_n (rep, nd, r);
     std::fill_n (r + nd, n - nd, fill_value);
 
     return r;
@@ -488,17 +488,17 @@ public:
         if (xelem (i) != 1)
           return i;
       }
 
     return def;
   }
 
   //! Linear index from an index tuple.
-  octave_idx_type compute_index (const octave_idx_type* idx) const
+  octave_idx_type compute_index (const octave_idx_type *idx) const
   { return compute_index (idx, ndims ()); }
 
   //! Linear index from an incomplete index tuple (nidx < length ()).
   octave_idx_type compute_index (const octave_idx_type *idx, int nidx) const
   {
     octave_idx_type k = 0;
     for (int i = nidx - 1; i >= 0; i--)
       k = rep[i] * k + idx[i];
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -2521,17 +2521,17 @@ FloatComplexMatrix::lssolve (const Float
         lrwork = 1;
       Array<float> rwork (dim_vector (lrwork, 1));
       float *prwork = rwork.fortran_vec ();
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<F77_INT> iwork (dim_vector (liwork, 1));
-      F77_INT* piwork = iwork.fortran_vec ();
+      F77_INT *piwork = iwork.fortran_vec ();
 
       F77_INT tmp_info = 0;
       F77_INT tmp_rank = 0;
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m,
                                  F77_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, tmp_rank, F77_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, tmp_info));
@@ -2736,17 +2736,17 @@ FloatComplexMatrix::lssolve (const Float
         lrwork = 1;
       Array<float> rwork (dim_vector (lrwork, 1));
       float *prwork = rwork.fortran_vec ();
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<F77_INT> iwork (dim_vector (liwork, 1));
-      F77_INT* piwork = iwork.fortran_vec ();
+      F77_INT *piwork = iwork.fortran_vec ();
 
       F77_INT tmp_info = 0;
       F77_INT tmp_rank = 0;
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m,
                                  F77_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, tmp_rank, F77_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, tmp_info));
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -2169,17 +2169,17 @@ FloatMatrix::lssolve (const FloatMatrix&
       F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<F77_INT> iwork (dim_vector (liwork, 1));
-      F77_INT* piwork = iwork.fortran_vec ();
+      F77_INT *piwork = iwork.fortran_vec ();
 
       F77_INT tmp_info = 0;
       F77_INT tmp_rank = 0;
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, tmp_rank, work.fortran_vec (),
                                  lwork, piwork, tmp_info));
 
@@ -2378,17 +2378,17 @@ FloatMatrix::lssolve (const FloatColumnV
       F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<F77_INT> iwork (dim_vector (liwork, 1));
-      F77_INT* piwork = iwork.fortran_vec ();
+      F77_INT *piwork = iwork.fortran_vec ();
 
       F77_INT tmp_info = 0;
       F77_INT tmp_rank = 0;
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, tmp_rank, work.fortran_vec (),
                                  lwork, piwork, tmp_info));
 
diff --git a/liboctave/numeric/CollocWt.cc b/liboctave/numeric/CollocWt.cc
--- a/liboctave/numeric/CollocWt.cc
+++ b/liboctave/numeric/CollocWt.cc
@@ -367,17 +367,17 @@ dfopr (octave_idx_type n, octave_idx_typ
       for (octave_idx_type j = 0; j < nt; j++)
         vect[j] = vect[j] / y;
     }
 }
 
 // Error handling.
 
 void
-CollocWt::error (const char* msg)
+CollocWt::error (const char *msg)
 {
   (*current_liboctave_error_handler) ("CollocWt: fatal error '%s'", msg);
 }
 
 CollocWt&
 CollocWt::set_left (double val)
 {
   if (val >= rb)
diff --git a/liboctave/numeric/bsxfun-defs.cc b/liboctave/numeric/bsxfun-defs.cc
--- a/liboctave/numeric/bsxfun-defs.cc
+++ b/liboctave/numeric/bsxfun-defs.cc
@@ -144,18 +144,18 @@ do_inplace_bsxfun_op (Array<R>& r, const
                       void (*op_vv) (size_t, R *, const X *),
                       void (*op_vs) (size_t, R *, X))
 {
   dim_vector dvr = r.dims ();
   dim_vector dvx = x.dims ();
   octave_idx_type nd = r.ndims ();
   dvx.redim (nd);
 
-  const X* xvec = x.fortran_vec ();
-  R* rvec = r.fortran_vec ();
+  const X *xvec = x.fortran_vec ();
+  R *rvec = r.fortran_vec ();
 
   // Fold the common leading dimensions.
   octave_idx_type start, ldr = 1;
   for (start = 0; start < nd; start++)
     {
       if (dvr(start) != dvx(start))
         break;
       ldr *= dvr(start);
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -78,17 +78,17 @@ ltsolve (const SM& L, const ColumnVector
 {
   // Solve (Q_mat * L) * x = m, that is L * x = Q_mat' * m = m(Q)
   octave_idx_type n = L.cols ();
   octave_idx_type b_nc = m.cols ();
   octave_idx_type err = 0;
   double rcond;
   MatrixType ltyp (MatrixType::Lower);
   M retval (n, b_nc);
-  const double* qv = Q.fortran_vec ();
+  const double *qv = Q.fortran_vec ();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = 0; i < n; i++)
         retval.elem (i,j) = m.elem (static_cast<octave_idx_type>(qv[i]), j);
     }
   return L.solve (ltyp, retval, err, rcond, 0);
 }
 
@@ -99,34 +99,34 @@ utsolve (const SM& U, const ColumnVector
   // Solve (U * Q_mat') * x = m by U * tmp = m, x(Q) = tmp (Q_mat * tmp = x)
   octave_idx_type n = U.cols ();
   octave_idx_type b_nc = m.cols ();
   octave_idx_type err = 0;
   double rcond;
   MatrixType utyp (MatrixType::Upper);
   M tmp = U.solve (utyp, m, err, rcond, 0);
   M retval;
-  const double* qv = Q.fortran_vec ();
+  const double *qv = Q.fortran_vec ();
 
   if (! err)
     {
       retval.resize (n, b_nc);
       for (octave_idx_type j = 0; j < b_nc; j++)
         {
           for (octave_idx_type i = 0; i < n; i++)
             retval.elem (static_cast<octave_idx_type>(qv[i]), j) =
               tmp.elem (i,j);
         }
     }
 
   return retval;
 }
 
 static bool
-vector_product (const SparseMatrix& m, const double* x, double* y)
+vector_product (const SparseMatrix& m, const double *x, double *y)
 {
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     y[j] = 0.;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
@@ -148,18 +148,18 @@ vector_product (const Matrix& m, const d
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("eigs: unrecoverable error in dgemv");
 
   return true;
 }
 
 static bool
-vector_product (const SparseComplexMatrix& m, const Complex* x,
-                Complex* y)
+vector_product (const SparseComplexMatrix& m, const Complex *x,
+                Complex *y)
 {
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     y[j] = 0.;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
diff --git a/liboctave/numeric/gsvd.cc b/liboctave/numeric/gsvd.cc
--- a/liboctave/numeric/gsvd.cc
+++ b/liboctave/numeric/gsvd.cc
@@ -45,17 +45,17 @@ namespace octave
   {
     template <>
     void
     gsvd<Matrix>::ggsvd (char& jobu, char& jobv, char& jobq, F77_INT m,
                          F77_INT n, F77_INT p, F77_INT& k, F77_INT& l,
                          double *tmp_dataA, F77_INT m1, double *tmp_dataB,
                          F77_INT p1, Matrix& alpha, Matrix& beta, double *u,
                          F77_INT nrow_u, double *v, F77_INT nrow_v, double *q,
-                         F77_INT nrow_q, Matrix& work, F77_INT* iwork,
+                         F77_INT nrow_q, Matrix& work, F77_INT *iwork,
                          F77_INT& info)
     {
       F77_XFCN (dggsvd, DGGSVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  F77_CONST_CHAR_ARG2 (&jobq, 1),
                                  m, n, p, k, l, tmp_dataA, m1,
                                  tmp_dataB, p1, alpha.fortran_vec (),
                                  beta.fortran_vec (), u, nrow_u,
@@ -70,17 +70,17 @@ namespace octave
     void
     gsvd<FloatMatrix>::ggsvd (char& jobu, char& jobv, char& jobq, F77_INT m,
                               F77_INT n, F77_INT p, F77_INT& k, F77_INT& l,
                               float *tmp_dataA, F77_INT m1, float *tmp_dataB,
                               F77_INT p1, FloatMatrix& alpha,
                               FloatMatrix& beta, float *u, F77_INT nrow_u,
                               float *v, F77_INT nrow_v, float *q,
                               F77_INT nrow_q, FloatMatrix& work,
-                              F77_INT* iwork, F77_INT& info)
+                              F77_INT *iwork, F77_INT& info)
     {
       F77_XFCN (sggsvd, SGGSVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  F77_CONST_CHAR_ARG2 (&jobq, 1),
                                  m, n, p, k, l, tmp_dataA, m1,
                                  tmp_dataB, p1, alpha.fortran_vec (),
                                  beta.fortran_vec (), u, nrow_u,
                                  v, nrow_v, q, nrow_q, work.fortran_vec (),
@@ -94,17 +94,17 @@ namespace octave
     void
     gsvd<ComplexMatrix>::ggsvd (char& jobu, char& jobv, char& jobq,
                                 F77_INT m, F77_INT n, F77_INT p, F77_INT& k,
                                 F77_INT& l, Complex *tmp_dataA, F77_INT m1,
                                 Complex *tmp_dataB, F77_INT p1, Matrix& alpha,
                                 Matrix& beta, Complex *u, F77_INT nrow_u,
                                 Complex *v, F77_INT nrow_v, Complex *q,
                                 F77_INT nrow_q, ComplexMatrix& work,
-                                F77_INT* iwork, F77_INT& info)
+                                F77_INT *iwork, F77_INT& info)
     {
       Matrix rwork(2*n, 1);
       F77_XFCN (zggsvd, ZGGSVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  F77_CONST_CHAR_ARG2 (&jobq, 1),
                                  m, n, p, k, l, F77_DBLE_CMPLX_ARG (tmp_dataA),
                                  m1, F77_DBLE_CMPLX_ARG (tmp_dataB), p1,
                                  alpha.fortran_vec (), beta.fortran_vec (),
@@ -125,17 +125,17 @@ namespace octave
                                      F77_INT& k, F77_INT& l,
                                      FloatComplex *tmp_dataA, F77_INT m1,
                                      FloatComplex *tmp_dataB, F77_INT p1,
                                      FloatMatrix& alpha, FloatMatrix& beta,
                                      FloatComplex *u, F77_INT nrow_u,
                                      FloatComplex *v, F77_INT nrow_v,
                                      FloatComplex *q, F77_INT nrow_q,
                                      FloatComplexMatrix& work,
-                                     F77_INT* iwork, F77_INT& info)
+                                     F77_INT *iwork, F77_INT& info)
     {
       FloatMatrix rwork(2*n, 1);
       F77_XFCN (cggsvd, CGGSVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  F77_CONST_CHAR_ARG2 (&jobq, 1),
                                  m, n, p, k, l, F77_CMPLX_ARG (tmp_dataA), m1,
                                  F77_CMPLX_ARG (tmp_dataB), p1,
                                  alpha.fortran_vec (), beta.fortran_vec (),
diff --git a/liboctave/numeric/gsvd.h b/liboctave/numeric/gsvd.h
--- a/liboctave/numeric/gsvd.h
+++ b/liboctave/numeric/gsvd.h
@@ -99,15 +99,15 @@ namespace octave
                   octave_f77_int_type n, octave_f77_int_type p,
                   octave_f77_int_type& k, octave_f77_int_type& l,
                   P *tmp_dataA, octave_f77_int_type m1,
                   P *tmp_dataB, octave_f77_int_type p1,
                   real_matrix& alpha, real_matrix& beta,
                   P *u, octave_f77_int_type nrow_u,
                   P *v, octave_f77_int_type nrow_v,
                   P *q, octave_f77_int_type nrow_q,
-                  T& work, octave_f77_int_type* iwork,
+                  T& work, octave_f77_int_type *iwork,
                   octave_f77_int_type& info);
     };
   }
 }
 
 #endif
diff --git a/liboctave/numeric/lo-lapack-proto.h b/liboctave/numeric/lo-lapack-proto.h
--- a/liboctave/numeric/lo-lapack-proto.h
+++ b/liboctave/numeric/lo-lapack-proto.h
@@ -646,87 +646,87 @@ extern "C"
                              const F77_INT&, F77_INT&
                              F77_CHAR_ARG_LEN_DECL);
 
   // GGBAL
 
   F77_RET_T
   F77_FUNC (cggbal, CGGBAL) (F77_CONST_CHAR_ARG_DECL,
                              const F77_INT& N,
-                             F77_CMPLX* A, const F77_INT& LDA,
-                             F77_CMPLX* B, const F77_INT& LDB,
+                             F77_CMPLX *A, const F77_INT& LDA,
+                             F77_CMPLX *B, const F77_INT& LDB,
                              F77_INT& ILO, F77_INT& IHI,
-                             F77_REAL* LSCALE, F77_REAL* RSCALE,
-                             F77_REAL* WORK, F77_INT& INFO
+                             F77_REAL *LSCALE, F77_REAL *RSCALE,
+                             F77_REAL *WORK, F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dggbal, DGGBAL) (F77_CONST_CHAR_ARG_DECL,
-                             const F77_INT& N, F77_DBLE* A,
-                             const F77_INT& LDA, F77_DBLE* B,
+                             const F77_INT& N, F77_DBLE *A,
+                             const F77_INT& LDA, F77_DBLE *B,
                              const F77_INT& LDB, F77_INT& ILO,
-                             F77_INT& IHI, F77_DBLE* LSCALE,
-                             F77_DBLE* RSCALE, F77_DBLE* WORK,
+                             F77_INT& IHI, F77_DBLE *LSCALE,
+                             F77_DBLE *RSCALE, F77_DBLE *WORK,
                              F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sggbal, SGGBAL) (F77_CONST_CHAR_ARG_DECL,
-                             const F77_INT& N, F77_REAL* A,
-                             const F77_INT& LDA, F77_REAL* B,
+                             const F77_INT& N, F77_REAL *A,
+                             const F77_INT& LDA, F77_REAL *B,
                              const F77_INT& LDB,
                              F77_INT& ILO, F77_INT& IHI,
-                             F77_REAL* LSCALE, F77_REAL* RSCALE,
-                             F77_REAL* WORK, F77_INT& INFO
+                             F77_REAL *LSCALE, F77_REAL *RSCALE,
+                             F77_REAL *WORK, F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zggbal, ZGGBAL) (F77_CONST_CHAR_ARG_DECL,
-                             const F77_INT& N, F77_DBLE_CMPLX* A,
-                             const F77_INT& LDA, F77_DBLE_CMPLX* B,
+                             const F77_INT& N, F77_DBLE_CMPLX *A,
+                             const F77_INT& LDA, F77_DBLE_CMPLX *B,
                              const F77_INT& LDB, F77_INT& ILO,
-                             F77_INT& IHI, F77_DBLE* LSCALE,
-                             F77_DBLE* RSCALE, F77_DBLE* WORK,
+                             F77_INT& IHI, F77_DBLE *LSCALE,
+                             F77_DBLE *RSCALE, F77_DBLE *WORK,
                              F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL);
 
   // GGBAK
 
   F77_RET_T
   F77_FUNC (dggbak, DGGBAK) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const F77_INT& N,
                              const F77_INT& ILO,
                              const F77_INT& IHI,
-                             const F77_DBLE* LSCALE, const F77_DBLE* RSCALE,
-                             F77_INT& M, F77_DBLE* V,
+                             const F77_DBLE *LSCALE, const F77_DBLE *RSCALE,
+                             F77_INT& M, F77_DBLE *V,
                              const F77_INT& LDV, F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sggbak, SGGBAK) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const F77_INT& N,
                              const F77_INT& ILO,
                              const F77_INT& IHI,
-                             const F77_REAL* LSCALE, const F77_REAL* RSCALE,
-                             F77_INT& M, F77_REAL* V,
+                             const F77_REAL *LSCALE, const F77_REAL *RSCALE,
+                             F77_INT& M, F77_REAL *V,
                              const F77_INT& LDV, F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zggbak, ZGGBAK) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const F77_INT& N,
                              const F77_INT& ILO,
                              const F77_INT& IHI,
-                             const F77_DBLE* LSCALE, const F77_DBLE* RSCALE,
-                             F77_INT& M, F77_DBLE_CMPLX* V,
+                             const F77_DBLE *LSCALE, const F77_DBLE *RSCALE,
+                             F77_INT& M, F77_DBLE_CMPLX *V,
                              const F77_INT& LDV, F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   // GGEV
 
   F77_RET_T
   F77_FUNC (cggev, CGGEV) (F77_CONST_CHAR_ARG_DECL,
@@ -781,33 +781,33 @@ extern "C"
 
   // GGHRD
 
   F77_RET_T
   F77_FUNC (dgghrd, DGGHRD) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const F77_INT& N,
                              const F77_INT& ILO,
-                             const F77_INT& IHI, F77_DBLE* A,
-                             const F77_INT& LDA, F77_DBLE* B,
-                             const F77_INT& LDB, F77_DBLE* Q,
-                             const F77_INT& LDQ, F77_DBLE* Z,
+                             const F77_INT& IHI, F77_DBLE *A,
+                             const F77_INT& LDA, F77_DBLE *B,
+                             const F77_INT& LDB, F77_DBLE *Q,
+                             const F77_INT& LDQ, F77_DBLE *Z,
                              const F77_INT& LDZ, F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgghrd, ZGGHRD) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const F77_INT& N,
                              const F77_INT& ILO,
-                             const F77_INT& IHI, F77_DBLE_CMPLX* A,
-                             const F77_INT& LDA, F77_DBLE_CMPLX* B,
-                             const F77_INT& LDB, F77_DBLE_CMPLX* Q,
-                             const F77_INT& LDQ, F77_DBLE_CMPLX* Z,
+                             const F77_INT& IHI, F77_DBLE_CMPLX *A,
+                             const F77_INT& LDA, F77_DBLE_CMPLX *B,
+                             const F77_INT& LDB, F77_DBLE_CMPLX *Q,
+                             const F77_INT& LDQ, F77_DBLE_CMPLX *Z,
                              const F77_INT& LDZ, F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   // GGSVD
 
   F77_RET_T
   F77_FUNC (dggsvd, DGGSVD)
@@ -1043,41 +1043,41 @@ extern "C"
 
   F77_RET_T
   F77_FUNC (dhgeqz, DHGEQZ) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const F77_INT& N,
                              const F77_INT& ILO,
                              const F77_INT& IHI,
-                             F77_DBLE* A, const F77_INT& LDA, F77_DBLE* B,
-                             const F77_INT& LDB, F77_DBLE* ALPHAR,
-                             F77_DBLE* ALPHAI, F77_DBLE* BETA, F77_DBLE* Q,
-                             const F77_INT& LDQ, F77_DBLE* Z,
-                             const F77_INT& LDZ, F77_DBLE* WORK,
+                             F77_DBLE *A, const F77_INT& LDA, F77_DBLE *B,
+                             const F77_INT& LDB, F77_DBLE *ALPHAR,
+                             F77_DBLE *ALPHAI, F77_DBLE *BETA, F77_DBLE *Q,
+                             const F77_INT& LDQ, F77_DBLE *Z,
+                             const F77_INT& LDZ, F77_DBLE *WORK,
                              const F77_INT& LWORK,
                              F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zhgeqz, ZHGEQZ) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const F77_INT& N,
                              const F77_INT& ILO,
                              const F77_INT& IHI,
-                             F77_DBLE_CMPLX* A, const F77_INT& LDA,
-                             F77_DBLE_CMPLX* B, const F77_INT& LDB,
-                             F77_DBLE_CMPLX* ALPHA, F77_DBLE_CMPLX* BETA,
-                             F77_DBLE_CMPLX* CQ, const F77_INT& LDQ,
-                             F77_DBLE_CMPLX* CZ, const F77_INT& LDZ,
-                             F77_DBLE_CMPLX* WORK, const F77_INT& LWORK,
-                             F77_DBLE* RWORK, F77_INT& INFO
+                             F77_DBLE_CMPLX *A, const F77_INT& LDA,
+                             F77_DBLE_CMPLX *B, const F77_INT& LDB,
+                             F77_DBLE_CMPLX *ALPHA, F77_DBLE_CMPLX *BETA,
+                             F77_DBLE_CMPLX *CQ, const F77_INT& LDQ,
+                             F77_DBLE_CMPLX *CZ, const F77_INT& LDZ,
+                             F77_DBLE_CMPLX *WORK, const F77_INT& LWORK,
+                             F77_DBLE *RWORK, F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   // LAENV (liboctave/external/lapack-xtra)
 
   F77_RET_T
   F77_FUNC (xilaenv, XILAENV) (const F77_INT&,
@@ -1087,18 +1087,18 @@ extern "C"
                                const F77_INT&, const F77_INT&,
                                F77_INT&
                                F77_CHAR_ARG_LEN_DECL
                                F77_CHAR_ARG_LEN_DECL);
 
   // LAG2
 
   F77_RET_T
-  F77_FUNC (dlag2, DLAG2) (const F77_DBLE* A, const F77_INT& LDA,
-                           const F77_DBLE* B, const F77_INT& LDB,
+  F77_FUNC (dlag2, DLAG2) (const F77_DBLE *A, const F77_INT& LDA,
+                           const F77_DBLE *B, const F77_INT& LDB,
                            const F77_DBLE& SAFMIN, F77_DBLE& SCALE1,
                            F77_DBLE& SCALE2, F77_DBLE& WR1, F77_DBLE& WR2,
                            F77_DBLE& WI);
 
   // LAMCH (liboctave/external/lapack-xtra)
 
   F77_RET_T
   F77_FUNC (xdlamch, XDLAMCH) (F77_CONST_CHAR_ARG_DECL,
@@ -1454,38 +1454,38 @@ extern "C"
   // TGEVC
 
   // Documentation for DTGEVC incorrectly states that VR, VL are
   // complex*16; they are declared in DTGEVC as double precision
   // (probably a cut and paste problem fro ZTGEVC).
   F77_RET_T
   F77_FUNC (dtgevc, DTGEVC) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
-                             F77_INT* SELECT,
-                             const F77_INT& N, F77_DBLE* A,
-                             const F77_INT& LDA, F77_DBLE* B,
-                             const F77_INT& LDB, F77_DBLE* VL,
-                             const F77_INT& LDVL, F77_DBLE* VR,
+                             F77_INT *SELECT,
+                             const F77_INT& N, F77_DBLE *A,
+                             const F77_INT& LDA, F77_DBLE *B,
+                             const F77_INT& LDB, F77_DBLE *VL,
+                             const F77_INT& LDVL, F77_DBLE *VR,
                              const F77_INT& LDVR,
                              const F77_INT& MM, F77_INT& M,
-                             F77_DBLE* WORK, F77_INT& INFO
+                             F77_DBLE *WORK, F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ztgevc, ZTGEVC) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
-                             F77_INT* SELECT,
-                             const F77_INT& N, const F77_DBLE_CMPLX* A,
-                             const F77_INT& LDA,const F77_DBLE_CMPLX* B,
-                             const F77_INT& LDB, F77_DBLE_CMPLX* xVL,
-                             const F77_INT& LDVL, F77_DBLE_CMPLX* xVR,
+                             F77_INT *SELECT,
+                             const F77_INT& N, const F77_DBLE_CMPLX *A,
+                             const F77_INT& LDA,const F77_DBLE_CMPLX *B,
+                             const F77_INT& LDB, F77_DBLE_CMPLX *xVL,
+                             const F77_INT& LDVL, F77_DBLE_CMPLX *xVR,
                              const F77_INT& LDVR,
                              const F77_INT& MM, F77_INT& M,
-                             F77_DBLE_CMPLX* CWORK, F77_DBLE* RWORK,
+                             F77_DBLE_CMPLX *CWORK, F77_DBLE* RWORK,
                              F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   // TRCON
 
   F77_RET_T
   F77_FUNC (ctrcon, CTRCON) (F77_CONST_CHAR_ARG_DECL,
diff --git a/liboctave/numeric/oct-norm.cc b/liboctave/numeric/oct-norm.cc
--- a/liboctave/numeric/oct-norm.cc
+++ b/liboctave/numeric/oct-norm.cc
@@ -546,17 +546,17 @@ R matrix_norm (const MatrixT& m, R p, Ve
 
 DEFINE_XNORM_FUNCS(, double)
 DEFINE_XNORM_FUNCS(Complex, double)
 DEFINE_XNORM_FUNCS(Float, float)
 DEFINE_XNORM_FUNCS(FloatComplex, float)
 
 // this is needed to avoid copying the sparse matrix for xfrobnorm
 template <typename T, typename R>
-inline void array_norm_2 (const T* v, octave_idx_type n, R& res)
+inline void array_norm_2 (const T *v, octave_idx_type n, R& res)
 {
   norm_accumulator_2<R> acc;
   for (octave_idx_type i = 0; i < n; i++)
     acc.accum (v[i]);
 
   res = acc;
 }
 
diff --git a/liboctave/numeric/randmtzig.cc b/liboctave/numeric/randmtzig.cc
--- a/liboctave/numeric/randmtzig.cc
+++ b/liboctave/numeric/randmtzig.cc
@@ -252,17 +252,17 @@ oct_init_by_array (uint32_t *init_key, i
 
 void
 oct_init_by_entropy (void)
 {
   uint32_t entropy[MT_N];
   int n = 0;
 
   /* Look for entropy in /dev/urandom */
-  FILE* urandom = std::fopen ("/dev/urandom", "rb");
+  FILE *urandom = std::fopen ("/dev/urandom", "rb");
   if (urandom)
     {
       while (n < MT_N)
         {
           unsigned char word[4];
           if (std::fread (word, 4, 1, urandom) != 1)
             break;
           entropy[n++] = word[0] + (word[1]<<8) + (word[2]<<16)
diff --git a/liboctave/numeric/svd.cc b/liboctave/numeric/svd.cc
--- a/liboctave/numeric/svd.cc
+++ b/liboctave/numeric/svd.cc
@@ -87,52 +87,52 @@ namespace octave
                      lwork, rwork.data (), info         \
                      F77_CHAR_ARG_LEN (1)               \
                      F77_CHAR_ARG_LEN (1)))
 
     // DGESVD
     template<>
     void
     svd<Matrix>::gesvd (char& jobu, char& jobv, F77_INT m, F77_INT n,
-                        double* tmp_data, F77_INT m1, double* s_vec,
-                        double* u, double* vt, F77_INT nrow_vt1,
+                        double *tmp_data, F77_INT m1, double *s_vec,
+                        double *u, double *vt, F77_INT nrow_vt1,
                         std::vector<double>& work, F77_INT& lwork,
                         F77_INT& info)
     {
       GESVD_REAL_STEP (dgesvd, DGESVD);
 
       lwork = static_cast<F77_INT> (work[0]);
       work.reserve (lwork);
 
       GESVD_REAL_STEP (dgesvd, DGESVD);
     }
 
     // SGESVD
     template<>
     void
     svd<FloatMatrix>::gesvd (char& jobu, char& jobv, F77_INT m, F77_INT n,
-                             float* tmp_data, F77_INT m1, float* s_vec,
-                             float* u, float* vt, F77_INT nrow_vt1,
+                             float *tmp_data, F77_INT m1, float *s_vec,
+                             float *u, float *vt, F77_INT nrow_vt1,
                              std::vector<float>& work, F77_INT& lwork,
                              F77_INT& info)
     {
       GESVD_REAL_STEP (sgesvd, SGESVD);
 
       lwork = static_cast<F77_INT> (work[0]);
       work.reserve (lwork);
 
       GESVD_REAL_STEP (sgesvd, SGESVD);
     }
 
     // ZGESVD
     template<>
     void
     svd<ComplexMatrix>::gesvd (char& jobu, char& jobv, F77_INT m, F77_INT n,
-                               Complex* tmp_data, F77_INT m1, double* s_vec,
-                               Complex* u, Complex* vt, F77_INT nrow_vt1,
+                               Complex *tmp_data, F77_INT m1, double *s_vec,
+                               Complex *u, Complex *vt, F77_INT nrow_vt1,
                                std::vector<Complex>& work, F77_INT& lwork,
                                F77_INT& info)
     {
       std::vector<double> rwork (5 * std::max (m, n));
 
       GESVD_COMPLEX_STEP (zgesvd, ZGESVD, F77_DBLE_CMPLX_ARG);
 
       lwork = static_cast<F77_INT> (work[0].real ());
@@ -140,19 +140,19 @@ namespace octave
 
       GESVD_COMPLEX_STEP (zgesvd, ZGESVD, F77_DBLE_CMPLX_ARG);
     }
 
     // CGESVD
     template<>
     void
     svd<FloatComplexMatrix>::gesvd (char& jobu, char& jobv, F77_INT m,
-                                    F77_INT n, FloatComplex* tmp_data,
-                                    F77_INT m1, float* s_vec, FloatComplex* u,
-                                    FloatComplex* vt, F77_INT nrow_vt1,
+                                    F77_INT n, FloatComplex *tmp_data,
+                                    F77_INT m1, float *s_vec, FloatComplex *u,
+                                    FloatComplex *vt, F77_INT nrow_vt1,
                                     std::vector<FloatComplex>& work,
                                     F77_INT& lwork, F77_INT& info)
     {
       std::vector<float> rwork (5 * std::max (m, n));
 
       GESVD_COMPLEX_STEP (cgesvd, CGESVD, F77_CMPLX_ARG);
 
       lwork = static_cast<F77_INT> (work[0].real ());
@@ -180,53 +180,53 @@ namespace octave
                      CMPLX_ARG (vt), nrow_vt1,                  \
                      CMPLX_ARG (work.data ()), lwork,           \
                      rwork.data (), iwork, info                 \
                      F77_CHAR_ARG_LEN (1)))
 
     // DGESDD
     template<>
     void
-    svd<Matrix>::gesdd (char& jobz, F77_INT m, F77_INT n, double* tmp_data,
-                        F77_INT m1, double* s_vec, double* u, double* vt,
+    svd<Matrix>::gesdd (char& jobz, F77_INT m, F77_INT n, double *tmp_data,
+                        F77_INT m1, double *s_vec, double *u, double *vt,
                         F77_INT nrow_vt1, std::vector<double>& work,
-                        F77_INT& lwork, F77_INT* iwork, F77_INT& info)
+                        F77_INT& lwork, F77_INT *iwork, F77_INT& info)
     {
       GESDD_REAL_STEP (dgesdd, DGESDD);
 
       lwork = static_cast<F77_INT> (work[0]);
       work.reserve (lwork);
 
       GESDD_REAL_STEP (dgesdd, DGESDD);
     }
 
     // SGESDD
     template<>
     void
-    svd<FloatMatrix>::gesdd (char& jobz, F77_INT m, F77_INT n, float* tmp_data,
-                             F77_INT m1, float* s_vec, float* u, float* vt,
+    svd<FloatMatrix>::gesdd (char& jobz, F77_INT m, F77_INT n, float *tmp_data,
+                             F77_INT m1, float *s_vec, float *u, float *vt,
                              F77_INT nrow_vt1, std::vector<float>& work,
                              F77_INT& lwork, F77_INT* iwork, F77_INT& info)
     {
       GESDD_REAL_STEP (sgesdd, SGESDD);
 
       lwork = static_cast<F77_INT> (work[0]);
       work.reserve (lwork);
 
       GESDD_REAL_STEP (sgesdd, SGESDD);
     }
 
     // ZGESDD
     template<>
     void
     svd<ComplexMatrix>::gesdd (char& jobz, F77_INT m, F77_INT n,
-                               Complex* tmp_data, F77_INT m1, double* s_vec,
-                               Complex* u, Complex* vt, F77_INT nrow_vt1,
+                               Complex *tmp_data, F77_INT m1, double *s_vec,
+                               Complex *u, Complex *vt, F77_INT nrow_vt1,
                                std::vector<Complex>& work, F77_INT& lwork,
-                               F77_INT* iwork, F77_INT& info)
+                               F77_INT *iwork, F77_INT& info)
     {
 
       F77_INT min_mn = std::min (m, n);
 
       F77_INT lrwork;
       if (jobz == 'N')
         lrwork = 7*min_mn;
       else
@@ -241,21 +241,21 @@ namespace octave
 
       GESDD_COMPLEX_STEP (zgesdd, ZGESDD, F77_DBLE_CMPLX_ARG);
     }
 
     // CGESDD
     template<>
     void
     svd<FloatComplexMatrix>::gesdd (char& jobz, F77_INT m, F77_INT n,
-                                    FloatComplex* tmp_data, F77_INT m1,
-                                    float* s_vec, FloatComplex* u,
-                                    FloatComplex* vt, F77_INT nrow_vt1,
+                                    FloatComplex *tmp_data, F77_INT m1,
+                                    float *s_vec, FloatComplex *u,
+                                    FloatComplex *vt, F77_INT nrow_vt1,
                                     std::vector<FloatComplex>& work,
-                                    F77_INT& lwork, F77_INT* iwork,
+                                    F77_INT& lwork, F77_INT *iwork,
                                     F77_INT& info)
     {
       F77_INT min_mn = std::min (m, n);
       F77_INT max_mn = std::max (m, n);
 
       F77_INT lrwork;
       if (jobz == 'N')
         lrwork = 5*min_mn;
@@ -309,17 +309,17 @@ namespace octave
             default:
               sigma = DM_T (0, 1);
               break;
             }
           return;
         }
 
       T atmp = a;
-      P* tmp_data = atmp.fortran_vec ();
+      P *tmp_data = atmp.fortran_vec ();
 
       F77_INT min_mn = m < n ? m : n;
 
       char jobu = 'A';
       char jobv = 'A';
 
       F77_INT ncol_u = m;
       F77_INT nrow_vt = n;
@@ -349,25 +349,25 @@ namespace octave
 
         default:
           break;
         }
 
       if (! (jobu == 'N' || jobu == 'O'))
         left_sm.resize (m, ncol_u);
 
-      P* u = left_sm.fortran_vec ();
+      P *u = left_sm.fortran_vec ();
 
       sigma.resize (nrow_s, ncol_s);
-      DM_P* s_vec = sigma.fortran_vec ();
+      DM_P *s_vec = sigma.fortran_vec ();
 
       if (! (jobv == 'N' || jobv == 'O'))
         right_sm.resize (nrow_vt, n);
 
-      P* vt = right_sm.fortran_vec ();
+      P *vt = right_sm.fortran_vec ();
 
       // Query _GESVD for the correct dimension of WORK.
 
       F77_INT lwork = -1;
 
       std::vector<P> work (1);
 
       F77_INT m1 = std::max (m, static_cast<F77_INT> (1));
diff --git a/liboctave/numeric/svd.h b/liboctave/numeric/svd.h
--- a/liboctave/numeric/svd.h
+++ b/liboctave/numeric/svd.h
@@ -95,23 +95,23 @@ namespace octave
       svd::Type m_type;
       svd::Driver m_driver;
 
       T left_sm;
       DM_T sigma;
       T right_sm;
 
       void gesvd (char& jobu, char& jobv, octave_f77_int_type m,
-                  octave_f77_int_type n, P* tmp_data, octave_f77_int_type m1,
-                  DM_P* s_vec, P* u, P* vt, octave_f77_int_type nrow_vt1,
+                  octave_f77_int_type n, P *tmp_data, octave_f77_int_type m1,
+                  DM_P *s_vec, P *u, P *vt, octave_f77_int_type nrow_vt1,
                   std::vector<P>& work, octave_f77_int_type& lwork,
                   octave_f77_int_type& info);
 
       void gesdd (char& jobz, octave_f77_int_type m, octave_f77_int_type n,
-                  P* tmp_data, octave_f77_int_type m1, DM_P* s_vec, P* u,
-                  P* vt, octave_f77_int_type nrow_vt1, std::vector<P>& work,
-                  octave_f77_int_type& lwork, octave_f77_int_type* iwork,
+                  P *tmp_data, octave_f77_int_type m1, DM_P *s_vec, P *u,
+                  P *vt, octave_f77_int_type nrow_vt1, std::vector<P>& work,
+                  octave_f77_int_type& lwork, octave_f77_int_type *iwork,
                   octave_f77_int_type& info);
     };
   }
 }
 
 #endif
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -176,17 +176,17 @@ logical_value (const std::complex<T>& x)
 template <typename T>
 inline bool
 logical_value (const octave_int<T>& x)
 {
   return x.value ();
 }
 
 template <typename X>
-void mx_inline_not (size_t n, bool *r, const X* x) throw ()
+void mx_inline_not (size_t n, bool *r, const X *x) throw ()
 {
   for (size_t i = 0; i < n; i++)
     r[i] = ! logical_value (x[i]);
 }
 
 inline void mx_inline_not2 (size_t n, bool *r) throw ()
 {
   for (size_t i = 0; i < n; i++)
@@ -252,56 +252,56 @@ inline void
 mx_inline_or2 (size_t n, bool *r, X x) throw ()
 {
   for (size_t i = 0; i < n; i++)
     r[i] |= x;
 }
 
 template <typename T>
 inline bool
-mx_inline_any_nan (size_t n, const T* x)  throw ()
+mx_inline_any_nan (size_t n, const T *x)  throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
       if (octave::math::isnan (x[i]))
         return true;
     }
 
   return false;
 }
 
 template <typename T>
 inline bool
-mx_inline_all_finite (size_t n, const T* x)  throw ()
+mx_inline_all_finite (size_t n, const T *x)  throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
       if (! octave::math::finite (x[i]))
         return false;
     }
 
   return true;
 }
 
 template <typename T>
 inline bool
-mx_inline_any_negative (size_t n, const T* x) throw ()
+mx_inline_any_negative (size_t n, const T *x) throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
       if (x[i] < 0)
         return true;
     }
 
   return false;
 }
 
 template <typename T>
 inline bool
-mx_inline_any_positive (size_t n, const T* x) throw ()
+mx_inline_any_positive (size_t n, const T *x) throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
       if (x[i] > 0)
         return true;
     }
 
   return false;
@@ -735,17 +735,17 @@ op_dble_sum (double& ac, const octave_in
       break;                                    \
     }                                           \
   else                                          \
     continue
 
 #define OP_RED_FCN(F, TSRC, TRES, OP, ZERO)     \
   template <typename T>                         \
   inline TRES                                   \
-  F (const TSRC* v, octave_idx_type n)          \
+  F (const TSRC *v, octave_idx_type n)          \
   {                                             \
     TRES ac = ZERO;                             \
     for (octave_idx_type i = 0; i < n; i++)     \
       OP(ac, v[i]);                             \
     return ac;                                  \
   }
 
 #define PROMOTE_DOUBLE(T)                                       \
@@ -759,17 +759,17 @@ OP_RED_FCN (mx_inline_dprod, T, PROMOTE_
 OP_RED_FCN (mx_inline_sumsq, T, T, OP_RED_SUMSQ, 0)
 OP_RED_FCN (mx_inline_sumsq, std::complex<T>, T, OP_RED_SUMSQC, 0)
 OP_RED_FCN (mx_inline_any, T, bool, OP_RED_ANYC, false)
 OP_RED_FCN (mx_inline_all, T, bool, OP_RED_ALLC, true)
 
 #define OP_RED_FCN2(F, TSRC, TRES, OP, ZERO)                            \
   template <typename T>                                                 \
   inline void                                                           \
-  F (const TSRC* v, TRES *r, octave_idx_type m, octave_idx_type n)      \
+  F (const TSRC *v, TRES *r, octave_idx_type m, octave_idx_type n)      \
   {                                                                     \
     for (octave_idx_type i = 0; i < m; i++)                             \
       r[i] = ZERO;                                                      \
     for (octave_idx_type j = 0; j < n; j++)                             \
       {                                                                 \
         for (octave_idx_type i = 0; i < m; i++)                         \
           OP(r[i], v[i]);                                               \
         v += m;                                                         \
@@ -793,17 +793,17 @@ OP_RED_FCN2 (mx_inline_all_r, T, bool, O
 // Using the general code for any/all would sacrifice short-circuiting.
 // OTOH, going by rows would sacrifice cache-coherence.  The following
 // algorithm will achieve both, at the cost of a temporary octave_idx_type
 // array.
 
 #define OP_ROW_SHORT_CIRCUIT(F, PRED, ZERO)                             \
   template <typename T>                                                 \
   inline void                                                           \
-  F (const T* v, bool *r, octave_idx_type m, octave_idx_type n)         \
+  F (const T *v, bool *r, octave_idx_type m, octave_idx_type n)         \
   {                                                                     \
     if (n <= 8)                                                         \
       return F ## _r (v, r, m, n);                                      \
                                                                         \
     /* FIXME: it may be sub-optimal to allocate the buffer here. */     \
     OCTAVE_LOCAL_BUFFER (octave_idx_type, iact, m);                     \
     for (octave_idx_type i = 0; i < m; i++) iact[i] = i;                \
     octave_idx_type nact = m;                                           \
diff --git a/liboctave/util/oct-binmap.h b/liboctave/util/oct-binmap.h
--- a/liboctave/util/oct-binmap.h
+++ b/liboctave/util/oct-binmap.h
@@ -71,31 +71,31 @@ private:
 public:
   static void
   set_f (const F& f_in)
   {
     f = f_in;
   }
 
   static void
-  op_mm (size_t n, R* r, const X* x , const Y* y)
+  op_mm (size_t n, R *r, const X *x , const Y *y)
   {
     for (size_t i = 0; i < n; i++)
       r[i] = f (x[i], y[i]);
   }
 
   static void
-  op_sm (size_t n, R* r, X x, const Y* y)
+  op_sm (size_t n, R *r, X x, const Y *y)
   {
     for (size_t i = 0; i < n; i++)
       r[i] = f (x, y[i]);
   }
 
   static void
-  op_ms (size_t n , R* r, const X* x, Y y)
+  op_ms (size_t n , R *r, const X *x, Y y)
   {
     for (size_t i = 0; i < n; i++)
       r[i] = f (x[i], y);
   }
 };
 
 // Static init
 template <typename R, typename X, typename Y, typename F>
diff --git a/liboctave/util/oct-sort.cc b/liboctave/util/oct-sort.cc
--- a/liboctave/util/oct-sort.cc
+++ b/liboctave/util/oct-sort.cc
@@ -1803,17 +1803,17 @@ octave_sort<T>::lookup (const T *data, o
   // elsewhere.
   for (octave_idx_type j = 0; j < nvalues; j++)
     idx[j] = lookup (data, nel, values[j], comp);
 }
 
 template <typename T>
 void
 octave_sort<T>::lookup (const T *data, octave_idx_type nel,
-                        const T* values, octave_idx_type nvalues,
+                        const T *values, octave_idx_type nvalues,
                         octave_idx_type *idx)
 {
 #if defined (INLINE_ASCENDING_SORT)
   if (compare == ascending_compare)
     lookup (data, nel, values, nvalues, idx, std::less<T> ());
   else
 #endif
 #if defined (INLINE_DESCENDING_SORT)
@@ -1878,17 +1878,17 @@ octave_sort<T>::lookup_sorted (const T *
       for (; j != nvalues; j++)
         idx[j] = i;
     }
 }
 
 template <typename T>
 void
 octave_sort<T>::lookup_sorted (const T *data, octave_idx_type nel,
-                               const T* values, octave_idx_type nvalues,
+                               const T *values, octave_idx_type nvalues,
                                octave_idx_type *idx, bool rev)
 {
 #if defined (INLINE_ASCENDING_SORT)
   if (compare == ascending_compare)
     lookup_sorted (data, nel, values, nvalues, idx, rev, std::less<T> ());
   else
 #endif
 #if defined (INLINE_DESCENDING_SORT)
diff --git a/liboctave/util/oct-sort.h b/liboctave/util/oct-sort.h
--- a/liboctave/util/oct-sort.h
+++ b/liboctave/util/oct-sort.h
@@ -148,23 +148,23 @@ public:
                        octave_idx_type rows, octave_idx_type cols);
 
   // Do a binary lookup in a sorted array.
   octave_idx_type lookup (const T *data, octave_idx_type nel,
                           const T& value);
 
   // Ditto, but for an array.
   void lookup (const T *data, octave_idx_type nel,
-               const T* values, octave_idx_type nvalues,
+               const T *values, octave_idx_type nvalues,
                octave_idx_type *idx);
 
   // A linear merge of two sorted tables.  rev indicates the second table is
   // in reverse order.
   void lookup_sorted (const T *data, octave_idx_type nel,
-                      const T* values, octave_idx_type nvalues,
+                      const T *values, octave_idx_type nvalues,
                       octave_idx_type *idx, bool rev = false);
 
   // Rearranges the array so that the elements with indices
   // lo..up-1 are in their correct place.
   void nth_element (T *data, octave_idx_type nel,
                     octave_idx_type lo, octave_idx_type up = -1);
 
   static bool ascending_compare (typename ref_param<T>::type,
@@ -317,22 +317,22 @@ private:
                        octave_idx_type cols, Comp comp);
 
   template <typename Comp>
   octave_idx_type lookup (const T *data, octave_idx_type nel,
                           const T& value, Comp comp);
 
   template <typename Comp>
   void lookup (const T *data, octave_idx_type nel,
-               const T* values, octave_idx_type nvalues,
+               const T *values, octave_idx_type nvalues,
                octave_idx_type *idx, Comp comp);
 
   template <typename Comp>
   void lookup_sorted (const T *data, octave_idx_type nel,
-                      const T* values, octave_idx_type nvalues,
+                      const T *values, octave_idx_type nvalues,
                       octave_idx_type *idx, bool rev, Comp comp);
 
   template <typename Comp>
   void nth_element (T *data, octave_idx_type nel,
                     octave_idx_type lo, octave_idx_type up,
                     Comp comp);
 };
 
diff --git a/liboctave/util/oct-string.cc b/liboctave/util/oct-string.cc
--- a/liboctave/util/oct-string.cc
+++ b/liboctave/util/oct-string.cc
@@ -29,28 +29,28 @@ along with Octave; see the file COPYING.
 #include <cstring>
 
 #include <string>
 
 #include <Array.h>
 
 template <typename T>
 static bool
-str_data_cmp (const typename T::value_type* a, const typename T::value_type* b,
+str_data_cmp (const typename T::value_type *a, const typename T::value_type *b,
               const typename T::size_type n)
 {
   for (typename T::size_type i = 0; i < n; ++i)
     if (a[i] != b[i])
       return false;
   return true;
 }
 
 template <typename T>
 static bool
-str_data_cmpi (const typename T::value_type* a, const typename T::value_type* b,
+str_data_cmpi (const typename T::value_type *a, const typename T::value_type *b,
                const typename T::size_type n)
 {
   for (typename T::size_type i = 0; i < n; ++i)
     if (std::tolower (a[i]) != std::tolower (b[i]))
       return false;
   return true;
 }
 
@@ -67,17 +67,17 @@ template <>
 octave_idx_type
 numel (const Array<char>& str)
 {
   return str.numel ();
 }
 
 template <typename T>
 typename T::size_type
-strlen (const typename T::value_type* str)
+strlen (const typename T::value_type *str)
 {
   return std::strlen (str);
 }
 
 template <typename T>
 bool
 sizes_cmp (const T& str_a, const T& str_b)
 {
@@ -88,58 +88,58 @@ template <>
 bool
 sizes_cmp (const Array<char>& str_a, const Array<char>& str_b)
 {
   return str_a.dims () == str_b.dims ();
 }
 
 template <typename T>
 bool
-sizes_cmp (const T& str_a, const typename T::value_type* str_b)
+sizes_cmp (const T& str_a, const typename T::value_type *str_b)
 {
   return str_a.size () == strlen<T> (str_b);
 }
 
 template <>
 bool
-sizes_cmp (const Array<char>& str_a, const char* str_b)
+sizes_cmp (const Array<char>& str_a, const char *str_b)
 {
   return (str_a.is_vector () && str_a.rows () == 1
           && str_a.numel () == strlen<Array<char>> (str_b));
 }
 
 
 template<typename T>
 bool
 octave::string::strcmp (const T& str_a, const T& str_b)
 {
   return (sizes_cmp (str_a, str_b)
           && str_data_cmp<T> (str_a.data (), str_b.data (), numel (str_a)));
 }
 
 template<typename T>
 bool
-octave::string::strcmp (const T& str_a, const typename T::value_type* str_b)
+octave::string::strcmp (const T& str_a, const typename T::value_type *str_b)
 {
   return (sizes_cmp (str_a, str_b)
           && str_data_cmp<T> (str_a.data (), str_b, numel (str_a)));
 }
 
 
 template<typename T>
 bool
 octave::string::strcmpi (const T& str_a, const T& str_b)
 {
   return (sizes_cmp (str_a, str_b)
           && str_data_cmpi<T> (str_a.data (), str_b.data (), numel (str_a)));
 }
 
 template<typename T>
 bool
-octave::string::strcmpi (const T& str_a, const typename T::value_type* str_b)
+octave::string::strcmpi (const T& str_a, const typename T::value_type *str_b)
 {
   return (sizes_cmp (str_a, str_b)
           && str_data_cmpi<T> (str_a.data (), str_b, numel (str_a)));
 }
 
 
 template<typename T>
 bool
@@ -147,17 +147,17 @@ octave::string::strncmp (const T& str_a,
                          const typename T::size_type n)
 {
   return (numel (str_a) >= n && numel (str_b) >= n
           && str_data_cmpi<T> (str_a.data (), str_b.data (), n));
 }
 
 template<typename T>
 bool
-octave::string::strncmp (const T& str_a, const typename T::value_type* str_b,
+octave::string::strncmp (const T& str_a, const typename T::value_type *str_b,
                          const typename T::size_type n)
 {
   return (numel (str_a) >= n && strlen<T> (str_b) >= n
           && str_data_cmpi<T> (str_a.data (), str_b, n));
 }
 
 
 template<typename T>
@@ -166,17 +166,17 @@ octave::string::strncmpi (const T& str_a
                           const typename T::size_type n)
 {
   return (numel (str_a) >= n && numel (str_b) >= n
           && str_data_cmpi<T> (str_a.data (), str_b.data (), n));
 }
 
 template<typename T>
 bool
-octave::string::strncmpi (const T& str_a, const typename T::value_type* str_b,
+octave::string::strncmpi (const T& str_a, const typename T::value_type *str_b,
                           const typename T::size_type n)
 {
   return (numel (str_a) >= n && strlen<T> (str_b) >= n
           && str_data_cmpi<T> (str_a.data (), str_b, n));
 }
 
 
 // Instantiations we need
diff --git a/liboctave/util/oct-string.h b/liboctave/util/oct-string.h
--- a/liboctave/util/oct-string.h
+++ b/liboctave/util/oct-string.h
@@ -59,17 +59,17 @@ namespace octave
         beginning at the character pointed to by str_b.
 
         ## Specialization for Array<char>
 
         For purposes of comparison of dimensions, the character sequence
         is considered to be a row vector.
     */
     template <typename T>
-    bool strcmp (const T& str_a, const typename T::value_type* str_b);
+    bool strcmp (const T& str_a, const typename T::value_type *str_b);
 
     //! True if strings are the same, ignoring case.
     /*!
         ## Specialization for Array<char>
 
         When comparing whole Array of chars, the actual Array dimensions
         are significant.  A column vector and row vector with the same
         char array, will still return false.
@@ -80,47 +80,47 @@ namespace octave
     //! True if string is the same as character sequence, ignoring case.
     /*!
         ## Specialization for Array<char>
 
         For purposes of comparison of dimensions, the character sequence
         is considered to be a row vector.
     */
     template <typename T>
-    bool strcmpi (const T& str_a, const typename T::value_type* str_b);
+    bool strcmpi (const T& str_a, const typename T::value_type *str_b);
 
     //! True if the first N characters are the same.
     /*!
         ## Specialization for Array<char>
 
         The comparison is done in the first N characters, the actual
         dimensions of the Array are irrelevant.  A row vector and
         a column vector of the same still return true.
     */
     template <typename T>
     bool strncmp (const T& str_a, const T& str_b,
                   const typename T::size_type n);
 
     //! True if the first N characters are the same.
     template <typename T>
-    bool strncmp (const T& str_a, const typename T::value_type* str_b,
+    bool strncmp (const T& str_a, const typename T::value_type *str_b,
                   const typename T::size_type n);
 
     //! True if the first N characters are the same, ignoring case.
     /*!
         ## Specialization for Array<char>
 
         The comparison is done in the first N characters, the actual
         dimensions of the Array are irrelevant.  A row vector and
         a column vector of the same still return true.
     */
     template <typename T>
     bool strncmpi (const T& str_a, const T& str_b,
                    const typename T::size_type n);
 
     //! True if the first N characters are the same, ignoring case.
     template <typename T>
-    bool strncmpi (const T& str_a, const typename T::value_type* str_b,
+    bool strncmpi (const T& str_a, const typename T::value_type *str_b,
                    const typename T::size_type n);
   }
 }
 
 #endif
diff --git a/liboctave/util/sparse-sort.cc b/liboctave/util/sparse-sort.cc
--- a/liboctave/util/sparse-sort.cc
+++ b/liboctave/util/sparse-sort.cc
@@ -33,31 +33,31 @@ along with Octave; see the file COPYING.
 
 #include "sparse-sort.h"
 
 // A simple class and instantiation of the octave merge sort class
 // to sort sparse data before matrix creation.  This is significantly
 // faster than using octave_qsort.
 
 bool
-octave_sparse_sidxl_comp (octave_sparse_sort_idxl* i,
-                          octave_sparse_sort_idxl* j)
+octave_sparse_sidxl_comp (octave_sparse_sort_idxl *i,
+                          octave_sparse_sort_idxl *j)
 {
   octave_idx_type tmp = i->c - j->c;
   if (tmp < 0)
     return true;
   else if (tmp > 0)
     return false;
   return  (i->r < j->r);
 }
 
 template class octave_sort<octave_sparse_sort_idxl *>;
 
 // Need to know the original order of the sorted indexes in
 // sparse assignments, and this class does that
 bool
-octave_idx_vector_comp (octave_idx_vector_sort* i,
-                        octave_idx_vector_sort* j)
+octave_idx_vector_comp (octave_idx_vector_sort *i,
+                        octave_idx_vector_sort *j)
 {
   return (i->i < j->i);
 }
 
 template class octave_sort<octave_idx_vector_sort *>;
diff --git a/liboctave/util/sparse-sort.h b/liboctave/util/sparse-sort.h
--- a/liboctave/util/sparse-sort.h
+++ b/liboctave/util/sparse-sort.h
@@ -32,23 +32,23 @@ class
 octave_sparse_sort_idxl
 {
 public:
   octave_idx_type r;
   octave_idx_type c;
   octave_idx_type idx;
 };
 
-bool octave_sparse_sidxl_comp (octave_sparse_sort_idxl* i,
-                               octave_sparse_sort_idxl* j);
+bool octave_sparse_sidxl_comp (octave_sparse_sort_idxl *i,
+                               octave_sparse_sort_idxl *j);
 
 class
 octave_idx_vector_sort
 {
 public:
   octave_idx_type i;
   octave_idx_type idx;
 };
 
-bool octave_idx_vector_comp (octave_idx_vector_sort* i,
-                             octave_idx_vector_sort* j);
+bool octave_idx_vector_comp (octave_idx_vector_sort *i,
+                             octave_idx_vector_sort *j);
 
 #endif
