# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1365436884 14400
#      Mon Apr 08 12:01:24 2013 -0400
# Node ID 0f143f68078dd97a03585e8b1957f14577c0beb3
# Parent  cc9e2751e0730aa8ff2498d829c01903c1d2d7fe
use signal/slot for updating workspace instead of using event listener

* main-window.h, main-window.cc: Clean up list of include files.
(main_window::prepare_to_exit): Rename from prepare_to_quit.  Change
all uses.
(main_window::update_workspace): Delete.
(main_window::construct): Don't connect
_octave_qt_event_listener:update_workspace_signal to
main_window::update_workspace.
(main_window::construct_octave_qt_link):
Connect _octave_qt_link::set_workspace_signal to
_workspace_model::set_workspace.
Connect _octave_qt_link::clear_workspace_signal to
_workspace_model::clear_workspace.

* symbol-information.h, symbol-information.cc: Delete
* libgui/src/module.mk (noinst_HEADERS, src_libgui_src_la_SOURCES):
Remove them from the lists.

* octave-qt-link.h, octave-qt-link.cc: Don't use symbol_information to
store workspace info.
(octave_qt_link::do_update_workspace): Delete.
(octave_qt_link::do_set_workspace,
octave_qt_link::do_clear_workspace): New functions.
(octave_qt_link::do_pre_input_event): Don't call do_update_workspace.
(octave_qt_link::set_workspace_signal,
octave_qt_link::clear_workspace_signal): New signals.

* workspace-model.h, workspace-model.cc: Don't use symbol_information
to store workspace info.  Accept workspace info through a signal/slot
combination, not by asking the symbol table.
(workspace_model::request_update_workspace,
(workspace_model::update_workspace_callback): Delete.
(workspace_model::set_workspace, workspace_model::clear_workspace,
workspace_model::clear_data, workspace_model::clear_tree,
workspace_model::update_tree, workspace_model::append_tree):
New functions.

* workspace-view.h, workspace-view.cc (workspace_view::model_changed):
Don't call update_workspace_callback.  The model now signals the view
when it has changed.

* input.cc (octave_base_reader::octave_gets, get_debug_input):
Call octave_link::set_workspace just prior to prompting for input.

* workspace-element.h: New file.
* libinterp/interpfcn/module.mk (INTERPFCN_INC): Include it in the list.

* octave-link.cc: Don't include symtab.h.
* octave-link.h (octave_link::update_workspace): Delete.
(octave_link::set_workspace, octave_link::do_set_workspace,
* octave_link::clear_workspace, octave_link::do_clear_workspace):
New functions.

* symtab.h, symtab.cc (symbol_table::workspace_info,
symbol_table::do_workspace_info): New functions.

* ov.h (octave_value::short_disp): New function.
* ov-base.h, ov-base.cc (octave_base_value::short_disp): New function.
* ov-base-scalar.h, ov-base-scalar.cc
(octave_base_scalar<ST>::short_disp): New function.
* ov-range.h, ov-range.cc (octave_range::short_disp): New function.

diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -40,26 +40,22 @@ along with Octave; see the file COPYING.
 #include <QIcon>
 
 #ifdef HAVE_QSCINTILLA
 #include "file-editor.h"
 #endif
 #include "main-window.h"
 #include "settings-dialog.h"
 
-#include "builtins.h"
+#include "cmd-edit.h"
+
+#include "builtin-defun-decls.h"
 #include "defaults.h"
-#include "load-save.h"
-#include "toplev.h"
 #include "version.h"
 
-#include "cmd-edit.h"
-#include "cmd-hist.h"
-#include "oct-env.h"
-
 static file_editor_interface *
 create_default_editor (QWidget *p)
 {
 #ifdef HAVE_QSCINTILLA
   return new file_editor (p);
 #else
   return 0;
 #endif
@@ -259,34 +255,28 @@ main_window::notice_settings (const QSet
         }
     }
 
   resource_manager::update_network_settings ();
 }
 
 
 void
-main_window::prepare_for_quit (void)
+main_window::prepare_to_exit (void)
 {
   write_settings ();
 }
 
 void
 main_window::reset_windows ()
 {
   // TODO: Implement.
 }
 
 void
-main_window::update_workspace (void)
-{
-  workspace_window->model_changed ();
-}
-
-void
 main_window::change_directory (const QString& dir)
 {
   // Remove existing entry, if any, then add new directory at top and
   // mark it as the current directory.  Finally, update the file list
   // widget.
 
   int index = _current_directory_combo_box->findText (dir);
 
@@ -548,17 +538,17 @@ main_window::construct (void)
   dummyWidget->hide ();
   setCentralWidget (dummyWidget);
 
   construct_menu_bar ();
 
   construct_tool_bar ();
 
   connect (qApp, SIGNAL (aboutToQuit ()),
-           this, SLOT (prepare_for_quit ()));
+           this, SLOT (prepare_to_exit ()));
 
   connect (this, SIGNAL (settings_changed (const QSettings *)),
            this, SLOT (notice_settings (const QSettings *)));
 
   setWindowTitle ("Octave");
 
   setDockOptions (QMainWindow::AnimatedDocks
                   | QMainWindow::AllowNestedDocks
@@ -587,32 +577,41 @@ main_window::construct (void)
     win_y = 720;
 
   setGeometry (0, 0, win_x, win_y);
 
   setStatusBar (status_bar);
 
   _octave_qt_event_listener = new octave_qt_event_listener ();
 
-  connect (_octave_qt_event_listener, SIGNAL (update_workspace_signal ()),
-           this, SLOT (update_workspace ()));
-
   // FIXME -- is it possible to eliminate the event_listenter?
 
   construct_octave_qt_link ();
 
   QDir curr_dir;
   set_current_working_directory (curr_dir.absolutePath ());
 }
 
 void
 main_window::construct_octave_qt_link (void)
 {
   _octave_qt_link = new octave_qt_link ();
 
+  connect (_octave_qt_link,
+           SIGNAL (set_workspace_signal
+                   (const QString&, const QStringList&, const QStringList&,
+                    const QStringList&, const QStringList&)),
+           _workspace_model,
+           SLOT (set_workspace
+                 (const QString&, const QStringList&,const QStringList&,
+                  const QStringList&, const QStringList&)));
+
+  connect (_octave_qt_link, SIGNAL (clear_workspace_signal ()),
+           _workspace_model, SLOT (clear_workspace ()));
+
   connect (_octave_qt_link, SIGNAL (change_directory_signal (QString)),
            this, SLOT (change_directory (QString)));
 
   connect (_octave_qt_link,
            SIGNAL (set_history_signal (const QStringList&)),
            history_window, SLOT (set_history (const QStringList&)));
 
   connect (_octave_qt_link,
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -87,19 +87,18 @@ public slots:
   void open_file (const QString& file_name = QString ());
   void open_online_documentation_page (void);
   void open_bug_tracker_page (void);
   void open_octave_forge_page (void);
   void open_agora_page (void);
   void process_settings_dialog_request (void);
   void show_about_octave (void);
   void notice_settings (const QSettings *settings);
-  void prepare_for_quit (void);
+  void prepare_to_exit (void);
   void reset_windows (void);
-  void update_workspace (void);
 
   void change_directory (const QString& dir);
   void browse_for_directory (void);
   void set_current_working_directory (const QString& dir);
   void change_directory_up (void);
   void accept_directory_line_edit (void);
 
   void handle_command_double_clicked (const QString& command);
diff --git a/libgui/src/module.mk b/libgui/src/module.mk
--- a/libgui/src/module.mk
+++ b/libgui/src/module.mk
@@ -108,17 +108,16 @@ noinst_HEADERS += \
   src/octave-gui.h \
   src/octave-main-thread.h \
   src/octave-qt-event-listener.h \
   src/octave-qt-link.h \
   src/qtinfo/parser.h \
   src/qtinfo/webinfo.h \
   src/resource-manager.h \
   src/settings-dialog.h \
-  src/symbol-information.h \
   src/terminal-dock-widget.h \
   src/color-picker.h \
   src/welcome-wizard.h \
   src/workspace-model.h \
   src/workspace-view.h
 
 src_libgui_src_la_SOURCES = \
   src/documentation-dock-widget.cc \
@@ -132,17 +131,16 @@ src_libgui_src_la_SOURCES = \
   src/octave-gui.cc \
   src/octave-main-thread.cc \
   src/octave-qt-event-listener.cc \
   src/octave-qt-link.cc \
   src/qtinfo/parser.cc \
   src/qtinfo/webinfo.cc \
   src/resource-manager.cc \
   src/settings-dialog.cc \
-  src/symbol-information.cc \
   src/terminal-dock-widget.cc \
   src/color-picker.cc \
   src/welcome-wizard.cc \
   src/workspace-model.cc \
   src/workspace-view.cc
 
 nodist_src_libgui_src_la_SOURCES = $(octave_gui_MOC) $(octave_gui_RC)
 
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -25,16 +25,18 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <QStringList>
 
 #include "str-vec.h"
 
+#include "workspace-element.h"
+
 #include "octave-qt-link.h"
 
 octave_qt_link::octave_qt_link (void)
   : octave_link (), main_thread (new octave_main_thread)
 {
 }
 
 void
@@ -53,24 +55,41 @@ octave_qt_link::do_edit_file (const std:
 
 void
 octave_qt_link::do_change_directory (const std::string& dir)
 {
   emit change_directory_signal (QString::fromStdString (dir));
 }
 
 void
-octave_qt_link::do_update_workspace (void)
+octave_qt_link::do_set_workspace (const std::list<workspace_element>& ws)
 {
-  if (event_listener)
+  QString scopes;
+  QStringList symbols;
+  QStringList class_names;
+  QStringList dimensions;
+  QStringList values;
+
+  for (std::list<workspace_element>::const_iterator it = ws.begin ();
+       it != ws.end (); it++)
     {
-      event_listener->update_workspace ();
+      scopes.append (it->scope ());
+      symbols.append (QString::fromStdString (it->symbol ()));
+      class_names.append (QString::fromStdString (it->class_name ()));
+      dimensions.append (QString::fromStdString (it->dimension ()));
+      values.append (QString::fromStdString (it->value ()));
+    }
 
-      do_process_events ();
-    }
+  emit set_workspace_signal (scopes, symbols, class_names, dimensions, values);
+}
+
+void
+octave_qt_link::do_clear_workspace (void)
+{
+  emit clear_workspace_signal ();
 }
 
 void
 octave_qt_link::do_set_history (const string_vector& hist)
 {
   QStringList qt_hist;
 
   for (octave_idx_type i = 0; i < hist.length (); i++)
@@ -89,17 +108,16 @@ void
 octave_qt_link::do_clear_history (void)
 {
   emit clear_history_signal ();
 }
 
 void
 octave_qt_link::do_pre_input_event (void)
 {
-  do_update_workspace ();
 }
 
 void
 octave_qt_link::do_post_input_event (void)
 {
 }
 
 void
diff --git a/libgui/src/octave-qt-link.h b/libgui/src/octave-qt-link.h
--- a/libgui/src/octave-qt-link.h
+++ b/libgui/src/octave-qt-link.h
@@ -20,18 +20,20 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifndef OCTAVE_QT_LINK_H
 #define OCTAVE_QT_LINK_H
 
+#include <list>
 #include <string>
 
+#include <QList>
 #include <QObject>
 #include <QString>
 
 #include "octave-link.h"
 #include "octave-main-thread.h"
 
 // \class OctaveLink
 // \brief Provides threadsafe access to octave.
@@ -52,17 +54,18 @@ public:
   ~octave_qt_link (void) { }
 
   void execute_interpreter (void);
 
   bool do_edit_file (const std::string& file);
 
   void do_change_directory (const std::string& dir);
 
-  void do_update_workspace (void);
+  void do_set_workspace (const std::list<workspace_element>& ws);
+  void do_clear_workspace (void);
 
   void do_set_history (const string_vector& hist);
   void do_append_history (const std::string& hist_entry);
   void do_clear_history (void);
 
   void do_pre_input_event (void);
   void do_post_input_event (void);
 
@@ -87,16 +90,24 @@ private:
   octave_main_thread *main_thread;
 
 signals:
 
   void edit_file_signal (const QString& file);
 
   void change_directory_signal (const QString& dir);
 
+  void set_workspace_signal (const QString& scopes,
+                             const QStringList& symbols,
+                             const QStringList& class_names,
+                             const QStringList& dimensions,
+                             const QStringList& values);
+
+  void clear_workspace_signal (void);
+
   void set_history_signal (const QStringList& hist);
   void append_history_signal (const QString& hist_entry);
   void clear_history_signal (void);
 
   void enter_debugger_signal (void);
   void exit_debugger_signal (void);
 
   void update_breakpoint_marker_signal (bool insert, const QString& file,
diff --git a/libgui/src/symbol-information.cc b/libgui/src/symbol-information.cc
deleted file mode 100644
--- a/libgui/src/symbol-information.cc
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
-
-Copyright (C) 2011-2012 Jacob Dawid
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <QString>
-
-#include "ov.h"
-#include "symtab.h"
-
-#include "symbol-information.h"
-
-symbol_information::symbol_information (const symbol_table::symbol_record& sr)
-{
-  if (sr.is_local () && !sr.is_global () && !sr.is_hidden ())
-    _scope = local;
-  else if (sr.is_global ())
-    _scope = global;
-  else if (sr.is_persistent ())
-    _scope = persistent;
-  else
-    _scope = unknown;
-
-  _symbol = QString (sr.name ().c_str ());
-  _class_name = QString (sr.varval ().class_name ().c_str ());
-  octave_value ov = sr.varval ();
-  dim_vector dv = ov.dims ();
-
-  // In case we have really large matrices or strings, cut them down
-  // for performance reasons.
-  QString short_value_string;
-  bool use_short_value_string = false;
-
-  if (ov.is_range ())
-    {
-      use_short_value_string = true;
-
-      Range r = ov.range_value ();
-
-      double base = r.base ();
-      double increment = r.inc ();
-      double limit = r.limit ();
-
-      std::stringstream buffer;
-
-      buffer << base << ":";
-      if (increment != 1 )
-        buffer << increment << ":";
-      buffer << limit;
-
-      short_value_string = QString::fromStdString (buffer.str ());
-    }
-  else if (ov.is_matrix_type () || ov.is_cell ())
-    {
-      if (ov.is_string ())  // a string?
-        {
-          if (ov.string_value ().length () > 30)
-            {
-              use_short_value_string = true;
-              short_value_string = QString ("\"")
-                  + QString::fromStdString (ov.string_value ().substr (0, 30))
-                  + QString (" ... \"");
-            }
-        }
-      else  // arrays and cell arrays
-        {
-          if (ov.numel () > 10)
-            {
-              use_short_value_string = true;
-              short_value_string = QString("...");
-              // TODO: what kind of short version can be printed for arrays?
-            }
-        }
-    }
-
-  if (use_short_value_string)
-    {
-      _value = short_value_string;
-    }
-  else
-    {
-      std::stringstream buffer;
-      ov.print (buffer, true);
-      _value  = QString::fromStdString (buffer.str ());
-    }
-  _value.replace("\n", " ");
-
-  _dimension = QString::fromStdString (dv.str ());
-
-  _hash = _scope + qHash (_symbol) + qHash (_class_name) + qHash (_value)
-    + qHash (_dimension);
-}
diff --git a/libgui/src/symbol-information.h b/libgui/src/symbol-information.h
deleted file mode 100644
--- a/libgui/src/symbol-information.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
-
-Copyright (C) 2011-2012 Jacob Dawid
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef SYMBOLINFORMATION_H
-#define SYMBOLINFORMATION_H
-
-// FIXME -- we should not be including config.h in header files.
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <QString>
-#include <QHash>
-
-#include "symtab.h"
-
-/**
- * \struct symbol_information
- * \brief Meta-information over a symbol-table entry.
- * \author Jacob Dawid
- * This struct is used to store meta information over a symbol entry.
- * It reduces memory consumption, since it only stores relevant data
- * about a symbol-table entry that will be used in the model for the
- * graphical user interface.
- */
-class symbol_information
-{
-public:
-
-  enum Scope
-    {
-      unknown     = 0,
-      local       = 1,
-      global      = 2,
-      persistent  = 3
-    };
-
-  symbol_information (const symbol_table::symbol_record& symbol_record);
-
-  symbol_information (const symbol_information& x)
-    : _scope (x._scope), _symbol (x._symbol), _class_name (x._class_name),
-      _value (x._value), _dimension (x._dimension), _hash (x._hash)
-  { }
-
-  symbol_information operator = (const symbol_information& x)
-  {
-    if (this != &x)
-      {
-        _scope = x._scope;
-        _symbol = x._symbol;
-        _class_name = x._class_name;
-        _value = x._value;
-        _dimension = x._dimension;
-        _hash = x._hash;
-      }
-
-    return *this;
-  }
-
-  ~symbol_information (void) { }
-
-  QString symbol (void) const { return _symbol; }
-  QString class_name (void) const { return _class_name; }
-  QString value (void) const
-    {
-      return QString::fromUtf8 (_value.toStdString ().data (),
-                                _value.toStdString ().size ());
-    }
-  QString dimension (void) const { return _dimension; }
-  Scope scope (void) const { return _scope; }
-
-  friend bool
-  operator == (const symbol_information& a, const symbol_information& b)
-  {
-    return (a.hash () == b.hash ()
-            && a.scope () == b.scope ()
-            && a.symbol () == b.symbol ()
-            && a.class_name () == b.class_name ()
-            && a.value () == b.value ()
-            && a.dimension () == b.dimension ());
-  }
-
-private:
-
-  // FIXME -- this is not really the scope of the symbol.
-  Scope _scope;
-
-  QString _symbol;
-  QString _class_name;
-  QString _value;
-  QString _dimension;
-
-  int _hash;
-
-  int hash (void) const { return _hash; }
-};
-
-#endif // SYMBOLINFORMATION_H
diff --git a/libgui/src/workspace-model.cc b/libgui/src/workspace-model.cc
--- a/libgui/src/workspace-model.cc
+++ b/libgui/src/workspace-model.cc
@@ -1,11 +1,12 @@
 
 /*
 
+Copyright (C) 2013 John W. Eaton
 Copyright (C) 2011-2012 Jacob Dawid
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -23,18 +24,16 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <QTreeWidget>
 #include <QTime>
 
-#include <list>
-
 #include "symtab.h"
 #include "variables.h"
 
 #include "workspace-model.h"
 #include "octave-link.h"
 
 workspace_model::workspace_model(QObject *p)
   : QAbstractItemModel (p)
@@ -48,22 +47,16 @@ workspace_model::workspace_model(QObject
   insert_top_level_item(2, new tree_item ("Persistent"));
 }
 
 workspace_model::~workspace_model()
 {
   delete _rootItem;
 }
 
-void
-workspace_model::request_update_workspace ()
-{
-  octave_link::post_event (this, &workspace_model::update_workspace_callback);
-}
-
 QModelIndex
 workspace_model::index(int row, int column, const QModelIndex &p) const
 {
   if (!hasIndex(row, column, p))
     return QModelIndex();
 
   tree_item *parentItem;
 
@@ -164,52 +157,89 @@ workspace_model::data(const QModelIndex 
     return QVariant();
 
   tree_item *item = static_cast<tree_item*>(idx.internalPointer());
 
   return item->data(idx.column());
 }
 
 void
-workspace_model::update_workspace_callback (void)
+workspace_model::set_workspace (const QString& scopes,
+                                const QStringList& symbols,
+                                const QStringList& class_names,
+                                const QStringList& dimensions,
+                                const QStringList& values)
 {
-  std::list < symbol_table::symbol_record > symbolTable = symbol_table::all_variables ();
+  _scopes = scopes;
+  _symbols = symbols;
+  _class_names = class_names;
+  _dimensions = dimensions;
+  _values = values;
 
-  _symbol_information.clear ();
-  for (std::list < symbol_table::symbol_record > ::iterator iterator = symbolTable.begin ();
-       iterator != symbolTable.end (); iterator++)
-    _symbol_information.push_back (symbol_information (*iterator));
+  update_tree ();
+
+  emit model_changed ();
+}
 
-  beginResetModel();
-  top_level_item (0)->delete_child_items ();
-  top_level_item (1)->delete_child_items ();
-  top_level_item (2)->delete_child_items ();
+void
+workspace_model::clear_workspace (void)
+{
+  clear_data ();
+
+  update_tree ();
+
+  emit model_changed ();
+}
 
-  foreach (const symbol_information& s, _symbol_information)
-    {
-      tree_item *child = new tree_item ();
+void
+workspace_model::clear_data (void)
+{
+  _scopes = QString ();
+  _symbols = QStringList ();
+  _class_names = QStringList ();
+  _dimensions = QStringList ();
+  _values = QStringList ();
+}
 
-      child->set_data (0, s.symbol ());
-      child->set_data (1, s.class_name ());
-      child->set_data (2, s.dimension ());
-      child->set_data (3, s.value ());
+void
+workspace_model::clear_tree (void)
+{
+  top_level_item(0)->delete_child_items ();
+  top_level_item(1)->delete_child_items ();
+  top_level_item(2)->delete_child_items ();
+}
 
-      switch (s.scope ())
-        {
-        case symbol_information::local:
-          top_level_item (0)->add_child (child);
-          break;
+void
+workspace_model::update_tree (void)
+{
+  beginResetModel();
+
+  clear_tree ();
+
+  for (int i = 0; i < _symbols.size (); i++)
+    append_tree (_scopes[i], _symbols[i], _class_names[i], _dimensions[i],
+                 _values[i]);
+
+  endResetModel ();
 
-        case symbol_information::global:
-          top_level_item (1)->add_child (child);
-          break;
+  emit model_changed ();
+}
 
-        case symbol_information::persistent:
-          top_level_item (2)->add_child (child);
-          break;
+void
+workspace_model::append_tree (QChar scope, const QString& symbol,
+                              const QString& class_name,
+                              const QString& dimension,
+                              const QString& value)
+{
+  tree_item *child = new tree_item ();
 
-        default:
-          break;
-        }
-    }
+  child->set_data (0, symbol);
+  child->set_data (1, class_name);
+  child->set_data (2, dimension);
+  child->set_data (3, value);
 
-  endResetModel();
+  if (scope == 'p')
+    top_level_item(2)->add_child (child);
+  else if (scope == 'g')
+    top_level_item(1)->add_child (child);
+  else
+    top_level_item(0)->add_child (child);
 }
diff --git a/libgui/src/workspace-model.h b/libgui/src/workspace-model.h
--- a/libgui/src/workspace-model.h
+++ b/libgui/src/workspace-model.h
@@ -1,10 +1,11 @@
 /*
 
+Copyright (C) 2013 John W. Eaton
 Copyright (C) 2011-2012 Jacob Dawid
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -15,25 +16,23 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-#ifndef WORKSPACEMODEL_H
-#define WORKSPACEMODEL_H
+#if !defined (workspace_model_h)
+#define workspace_model_h 1
 
-// Qt includes
 #include <QAbstractItemModel>
 #include <QVector>
 #include <QSemaphore>
-
-#include "symbol-information.h"
+#include <QStringList>
 
 class tree_item
 {
 public:
   tree_item (const QList<QVariant> &d, tree_item *p = 0) {
     _parent_item = p;
     _item_data = d;
   }
@@ -109,41 +108,70 @@ private:
   tree_item *_parent_item;
 };
 
 class workspace_model
   : public QAbstractItemModel
 {
   Q_OBJECT
 
-  public:
+public:
+
   workspace_model (QObject *parent = 0);
-  ~workspace_model ();
+
+  ~workspace_model (void);
 
   QVariant data (const QModelIndex &index, int role) const;
+
   Qt::ItemFlags flags (const QModelIndex &index) const;
+
   QVariant headerData (int section, Qt::Orientation orientation,
                        int role = Qt::DisplayRole) const;
+
   QModelIndex index (int row, int column,
                      const QModelIndex &parent = QModelIndex ()) const;
+
   QModelIndex parent (const QModelIndex &index) const;
+
   int rowCount (const QModelIndex &parent = QModelIndex ()) const;
+
   int columnCount (const QModelIndex &parent = QModelIndex ()) const;
 
   void insert_top_level_item (int at, tree_item *treeItem);
+
   tree_item *top_level_item (int at);
 
-  void update_workspace_callback (void);
-
 public slots:
-  void request_update_workspace ();
+
+  void set_workspace (const QString& scopes,
+                      const QStringList& symbols,
+                      const QStringList& class_names,
+                      const QStringList& dimensions,
+                      const QStringList& values);
+
+  void clear_workspace (void);
 
 signals:
-  void model_changed ();
+
+  void model_changed (void);
 
 private:
 
-  /** Stores the current symbol information. */
-  QList <symbol_information> _symbol_information;
+  void clear_data (void);
+
+  void clear_tree (void);
+
+  void update_tree (void);
+
+  void append_tree (QChar scope, const QString& symbol,
+                    const QString& class_name, const QString& dimension,
+                    const QString& value);
+
+  QString _scopes;
+  QStringList _symbols;
+  QStringList _class_names;
+  QStringList _dimensions;
+  QStringList _values;
+
   tree_item *_rootItem;
 };
 
 #endif // WORKSPACEMODEL_H
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -116,18 +116,16 @@ workspace_view::~workspace_view (void)
   settings->sync ();
 }
 
 void
 workspace_view::model_changed ()
 {
   QAbstractItemModel *m = view->model ();
 
-  dynamic_cast<workspace_model *> (m)->update_workspace_callback ();
-
   // This code is very quirky and requires some explanation.
   // Usually, we should not deal with collapsing or expanding ourselves,
   // because the view itself determines (based on the model) whether it
   // is appropriate to collapse or expand items.
   //
   // Now, the logic requires that we update our model item by item, which
   // would make it work correctly, but this is extremely slow and scales
   // very bad (O(n^2)). That's why we throw away our model and rebuild it
diff --git a/libinterp/interpfcn/input.cc b/libinterp/interpfcn/input.cc
--- a/libinterp/interpfcn/input.cc
+++ b/libinterp/interpfcn/input.cc
@@ -62,16 +62,17 @@ along with Octave; see the file COPYING.
 #include "pager.h"
 #include "parse.h"
 #include "pathlen.h"
 #include "pt.h"
 #include "pt-const.h"
 #include "pt-eval.h"
 #include "pt-stmt.h"
 #include "sighandlers.h"
+#include "symtab.h"
 #include "sysdep.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // Primary prompt string.
 static std::string VPS1 = "\\s:\\#> ";
@@ -212,16 +213,18 @@ octave_base_reader::octave_gets (bool& e
   // printing the prompt.
 
   if (interactive || forced_interactive)
     {
       if (! Vdebugging)
         octave_link::exit_debugger_event ();
 
       octave_link::pre_input_event ();
+
+      octave_link::set_workspace (symbol_table::workspace_info ());
     }
 
   bool history_skip_auto_repeated_debugging_command = false;
 
   std::string ps = (pflag > 0) ? VPS1 : VPS2;
 
   std::string prompt = command_editor::decode_prompt_string (ps);
 
@@ -514,16 +517,18 @@ get_debug_input (const std::string& prom
 
           if (curr_debug_line > 0)
             buf << " at line " << curr_debug_line;
 
           if (have_file)
             {
               octave_link::enter_debugger_event (nm, curr_debug_line);
 
+              octave_link::set_workspace (symbol_table::workspace_info ());
+
               frame.add_fcn (execute_in_debugger_handler,
                              std::pair<std::string, int> (nm, curr_debug_line));
 
               std::string line_buf
                 = get_file_line (nm, curr_debug_line);
 
               if (! line_buf.empty ())
                 buf << "\n" << curr_debug_line << ": " << line_buf;
diff --git a/libinterp/interpfcn/module.mk b/libinterp/interpfcn/module.mk
--- a/libinterp/interpfcn/module.mk
+++ b/libinterp/interpfcn/module.mk
@@ -21,17 +21,18 @@ INTERPFCN_INC = \
   interpfcn/pager.h \
   interpfcn/pr-output.h \
   interpfcn/profiler.h \
   interpfcn/sighandlers.h \
   interpfcn/symtab.h \
   interpfcn/sysdep.h \
   interpfcn/toplev.h \
   interpfcn/utils.h \
-  interpfcn/variables.h
+  interpfcn/variables.h \
+  interpfcn/workspace-element.h
 
 INTERPFCN_SRC = \
   interpfcn/data.cc \
   interpfcn/debug.cc \
   interpfcn/defaults.cc \
   interpfcn/defun.cc \
   interpfcn/dirfns.cc \
   interpfcn/error.cc \
diff --git a/libinterp/interpfcn/octave-link.cc b/libinterp/interpfcn/octave-link.cc
--- a/libinterp/interpfcn/octave-link.cc
+++ b/libinterp/interpfcn/octave-link.cc
@@ -26,17 +26,16 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "cmd-edit.h"
 #include "defun.h"
 #include "oct-env.h"
 #include "oct-mutex.h"
 #include "singleton-cleanup.h"
-#include "symtab.h"
 #include "toplev.h"
 
 #include "octave-link.h"
 
 static int
 octave_readline_hook (void)
 {
   octave_link::entered_readline_hook ();
diff --git a/libinterp/interpfcn/octave-link.h b/libinterp/interpfcn/octave-link.h
--- a/libinterp/interpfcn/octave-link.h
+++ b/libinterp/interpfcn/octave-link.h
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include "event-queue.h"
 #include "octave-event-listener.h"
 
 class octave_mutex;
 class string_vector;
+class workspace_element;
 
 // \class OctaveLink
 // \brief Provides threadsafe access to octave.
 // \author Jacob Dawid
 //
 // This class is a wrapper around octave and provides thread safety by
 // buffering access operations to octave and executing them in the
 // readline event hook, which lives in the octave thread.
@@ -115,20 +116,26 @@ public:
   }
 
   static void change_directory (const std::string& dir)
   {
     if (instance_ok ())
       instance->do_change_directory (dir);
   }
 
-  static void update_workspace (void)
+  static void set_workspace (const std::list<workspace_element>& ws)
   {
     if (instance_ok ())
-      instance->do_update_workspace ();
+      instance->do_set_workspace (ws);
+  }
+
+  static void clear_workspace (void)
+  {
+    if (instance_ok ())
+      instance->do_clear_workspace ();
   }
 
   static void set_history (const string_vector& hist)
   {
     if (instance_ok ())
       instance->do_set_history (hist);
   }
 
@@ -244,26 +251,33 @@ protected:
 
   void do_entered_readline_hook (void) { }
   void do_finished_readline_hook (void) { }
 
   virtual bool do_edit_file (const std::string& file) = 0;
 
   virtual void do_change_directory (const std::string& dir) = 0;
 
-  virtual void do_update_workspace (void) = 0;
+  virtual void
+  do_set_workspace (const std::list<workspace_element>& ws) = 0;
+
+  virtual void do_clear_workspace (void) = 0;
 
   virtual void do_set_history (const string_vector& hist) = 0;
   virtual void do_append_history (const std::string& hist_entry) = 0;
   virtual void do_clear_history (void) = 0;
 
   virtual void do_pre_input_event (void) = 0;
   virtual void do_post_input_event (void) = 0;
 
-  virtual void do_enter_debugger_event (const std::string& file, int line) = 0;
-  virtual void do_execute_in_debugger_event (const std::string& file, int line) = 0;
+  virtual void
+  do_enter_debugger_event (const std::string& file, int line) = 0;
+
+  virtual void
+  do_execute_in_debugger_event (const std::string& file, int line) = 0;
+
   virtual void do_exit_debugger_event (void) = 0;
 
   virtual void do_update_breakpoint (bool insert,
                                      const std::string& file, int line) = 0;
 };
 
 #endif // OCTAVELINK_H
diff --git a/libinterp/interpfcn/symtab.cc b/libinterp/interpfcn/symtab.cc
--- a/libinterp/interpfcn/symtab.cc
+++ b/libinterp/interpfcn/symtab.cc
@@ -1375,16 +1375,51 @@ symbol_table::do_builtin_find (const std
         fcn_table[name] = finfo;
 
       return fcn;
     }
 
   return retval;
 }
 
+std::list<workspace_element>
+symbol_table::do_workspace_info (void) const
+{
+  std::list<workspace_element> retval;
+
+  for (table_const_iterator p = table.begin (); p != table.end (); p++)
+    {
+      std::string nm = p->first;
+      symbol_record sr = p->second;
+
+      if (! sr.is_hidden ())
+        {
+          octave_value val = sr.varval ();
+
+          if (val.is_defined ())
+            {
+              dim_vector dv = val.dims ();
+
+              char storage = ' ';
+              if (sr.is_global ())
+                storage = 'g';
+              else if (sr.is_persistent ())
+                storage = 'p';
+
+              workspace_element elt (storage, nm, val.class_name (),
+                                     val.short_disp (), dv.str ());
+
+              retval.push_back (elt);
+            }
+        }
+    }
+
+  return retval;
+}
+
 void
 symbol_table::do_dump (std::ostream& os)
 {
   if (! persistent_table.empty ())
     {
       os << "  persistent variables in this scope:\n\n";
 
       for (persistent_table_const_iterator p = persistent_table.begin ();
diff --git a/libinterp/interpfcn/symtab.h b/libinterp/interpfcn/symtab.h
--- a/libinterp/interpfcn/symtab.h
+++ b/libinterp/interpfcn/symtab.h
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 
 #include "glob-match.h"
 #include "regexp.h"
 
 class tree_argument_list;
 class octave_user_function;
 
 #include "oct-obj.h"
+#include "workspace-element.h"
 #include "oct-refcount.h"
 #include "ov.h"
 
 class
 OCTINTERP_API
 symbol_table
 {
 public:
@@ -2121,16 +2122,24 @@ public:
     else
       {
         symbol_table *inst = get_instance (xcurrent_scope);
 
         return inst ? inst->do_is_global (name) : false;
       }
   }
 
+  static std::list<workspace_element> workspace_info (void)
+  {
+    symbol_table *inst = get_instance (xcurrent_scope);
+
+    return inst
+      ? inst->do_workspace_info () : std::list<workspace_element> ();
+  }
+
   static void dump (std::ostream& os, scope_id scope = xcurrent_scope);
 
   static void dump_global (std::ostream& os);
 
   static void dump_functions (std::ostream& os);
 
   static void cache_name (scope_id scope, const std::string& name)
   {
@@ -2790,16 +2799,18 @@ private:
 
   bool do_is_global (const std::string& name) const
   {
     table_const_iterator p = table.find (name);
 
     return p != table.end () && p->second.is_global ();
   }
 
+  std::list<workspace_element> do_workspace_info (void) const;
+
   void do_dump (std::ostream& os);
 
   void do_cache_name (const std::string& name) { table_name = name; }
 
   void do_update_nest (void);
 
   bool look_nonlocal (const std::string& name, symbol_record& result)
   {
diff --git a/libinterp/octave-value/ov-base-scalar.cc b/libinterp/octave-value/ov-base-scalar.cc
--- a/libinterp/octave-value/ov-base-scalar.cc
+++ b/libinterp/octave-value/ov-base-scalar.cc
@@ -164,16 +164,25 @@ octave_base_scalar<ST>::print_name_tag (
                                         const std::string& name) const
 {
   indent (os);
   os << name << " = ";
   return false;
 }
 
 template <class ST>
+std::string
+octave_base_scalar<ST>::short_disp (void) const
+{
+  std::ostringstream buf;
+  octave_print_internal (buf, scalar);
+  return buf.str ();
+}
+
+template <class ST>
 bool
 octave_base_scalar<ST>::fast_elem_insert_self (void *where, builtin_type_t btyp) const
 {
 
   // Don't use builtin_type () here to avoid an extra VM call.
   if (btyp == class_to_btyp<ST>::btyp)
     {
       *(reinterpret_cast<ST *>(where)) = scalar;
diff --git a/libinterp/octave-value/ov-base-scalar.h b/libinterp/octave-value/ov-base-scalar.h
--- a/libinterp/octave-value/ov-base-scalar.h
+++ b/libinterp/octave-value/ov-base-scalar.h
@@ -133,16 +133,18 @@ public:
   bool is_true (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
+  std::string short_disp (void) const;
+
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return const_cast<ST *> (&scalar); }
 
   const ST& scalar_ref (void) const { return scalar; }
 
   ST& scalar_ref (void) { return scalar; }
 
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -611,16 +611,18 @@ public:
 
   virtual bool
   print_name_tag (std::ostream& os, const std::string& name) const;
 
   virtual void
   print_with_name (std::ostream& output_buf, const std::string& name,
                    bool print_padding = true);
 
+  virtual std::string short_disp (void) const { return "..."; }
+
   virtual void print_info (std::ostream& os, const std::string& prefix) const;
 
   virtual bool save_ascii (std::ostream& os);
 
   virtual bool load_ascii (std::istream& is);
 
   virtual bool save_binary (std::ostream& os, bool& save_as_floats);
 
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -382,16 +382,41 @@ octave_range::print_name_tag (std::ostre
         newline (os);
 
       retval = true;
     }
 
   return retval;
 }
 
+std::string
+octave_range::short_disp (void) const
+{
+  std::ostringstream buf;
+  
+  octave_idx_type len = range.nelem ();
+
+  if (len == 0)
+    buf << "[]";
+  else
+    {
+      buf << range.base () << ":";
+
+      if (len > 1)
+        {
+          if (range.inc () != 1)
+            buf << range.inc () << ":";
+
+          buf << range.limit ();
+        }
+    }
+
+  return buf.str ();
+}
+
 // Skip white space and comments on stream IS.
 
 static void
 skip_comments (std::istream& is)
 {
   char c = '\0';
   while (is.get (c))
     {
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -250,16 +250,18 @@ public:
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
+  std::string short_disp (void) const;
+
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -1017,16 +1017,18 @@ public:
     { rep->print_raw (os, pr_as_read_syntax); }
 
   bool print_name_tag (std::ostream& os, const std::string& name) const
     { return rep->print_name_tag (os, name); }
 
   void print_with_name (std::ostream& os, const std::string& name) const
   { rep->print_with_name (os, name, true); }
 
+  std::string short_disp (void) const { return rep->short_disp (); }
+
   int type_id (void) const { return rep->type_id (); }
 
   std::string type_name (void) const { return rep->type_name (); }
 
   std::string class_name (void) const { return rep->class_name (); }
 
   // Unary and binary operations.
 
