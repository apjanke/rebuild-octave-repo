# HG changeset patch
# User Rik <rdrider0-list@yahoo.com>
# Date 1238218263 25200
#      Fri Mar 27 22:31:03 2009 -0700
# Node ID 1bf0ce0930be5d6b10a0cb7251cc0c817d8dcb64
# Parent  656ad518f385b5f80b275a35b35f0b3ee6e7b938
Grammar check TexInfo in all .m files

Cleanup documentation sources to follow a few consistent rules.
Spellcheck was NOT done. (but will be in another changeset)

diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -185,17 +185,17 @@ named on the command line.
 @cindex @code{--quiet}
 @cindex @code{-q}
 Don't print the usual greeting and version message at startup.
 
 @item --traditional
 @itemx --braindead
 @cindex @code{--traditional}
 @cindex @code{--braindead}
-For compatibility with @sc{Matlab}, set initial values for
+For compatibility with @sc{matlab}, set initial values for
 user preferences to the following values
 
 @example
 @group
 PS1                     = ">> "
 PS2                     = ""
 beep_on_error           = true
 crash_dumps_octave_core = false
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -18,24 +18,24 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} lcm (@var{x}, @dots{})
 ## Compute the least common multiple of the elements of @var{x}, or
 ## the list of all the arguments.  For example,
 ##
 ## @example
-## lcm (a1, ..., ak)
+## lcm (a1, @dots{}, ak)
 ## @end example
 ##
 ## @noindent
 ## is the same as
 ##
 ## @example
-## lcm ([a1, ..., ak]).
+## lcm ([a1, @dots{}, ak]).
 ## @end example
 ##
 ## All elements must be the same size or scalar.
 ## @seealso{gcd, min, max, ceil, floor}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 16 September 1994
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -17,35 +17,35 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} accumarray (@var{subs}, @var{vals}, @var{sz}, @var{fun}, @var{fillval}, @var{issparse})
 ## @deftypefnx {Function File} {} accumarray (@var{csubs}, @var{vals}, @dots{})
 ##
 ## Create an array by accumulating the elements of a vector into the
-## positions defined by their subscripts. The subscripts are defined by
-## the rows of the matrix @var{subs} and the values by @var{vals}. Each row
+## positions defined by their subscripts.  The subscripts are defined by
+## the rows of the matrix @var{subs} and the values by @var{vals}.  Each row
 ## of @var{subs} corresponds to one of the values in @var{vals}.
 ##
 ## The size of the matrix will be determined by the subscripts themselves.
-## However, if @var{sz} is defined it determines the matrix size. The length
+## However, if @var{sz} is defined it determines the matrix size.  The length
 ## of @var{sz} must correspond to the number of columns in @var{subs}.
 ##
 ## The default action of @code{accumarray} is to sum the elements with the
-## same subscripts. This behavior can be modified by defining the @var{fun}
-## function. This should be a function or function handle that accepts a 
-## column vector and returns a scalar. The result of the function should not
+## same subscripts.  This behavior can be modified by defining the @var{fun}
+## function.  This should be a function or function handle that accepts a 
+## column vector and returns a scalar.  The result of the function should not
 ## depend on the order of the subscripts.
 ##
 ## The elements of the returned array that have no subscripts associated with
-## them are set to zero. Defining @var{fillval} to some other value allows
+## them are set to zero.  Defining @var{fillval} to some other value allows
 ## these values to be defined.
 ##
-## By default @code{accumarray} returns a full matrix. If @var{issparse} is
+## By default @code{accumarray} returns a full matrix.  If @var{issparse} is
 ## logically true, then a sparse matrix is returned instead.
 ##
 ## An example of the use of @code{accumarray} is:
 ##
 ## @example
 ## @group
 ## accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2], 101:105)
 ## @result{} ans(:,:,1) = [101, 0, 0; 0, 0, 0]
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -12,21 +12,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{zi}=} bicubic (@var{x}, @var{y}, @var{z}, @var{xi}, @var{yi}, @var{extrapval})
+## @deftypefn {Function File} {@var{zi} =} bicubic (@var{x}, @var{y}, @var{z}, @var{xi}, @var{yi}, @var{extrapval})
 ##
 ## Return a matrix @var{zi} corresponding to the bicubic
 ## interpolations at @var{xi} and @var{yi} of the data supplied
-## as @var{x}, @var{y} and @var{z}. Points outside the grid are set
+## as @var{x}, @var{y} and @var{z}.  Points outside the grid are set
 ## to @var{extrapval}.
 ##
 ## See @url{http://wiki.woodpecker.org.cn/moin/Octave/Bicubic}
 ## for further information.
 ## @seealso{interp2}
 ## @end deftypefn
 
 ## Bicubic interpolation method.
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -17,22 +17,24 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} bitcmp (@var{a}, @var{k})
 ## Return the @var{k}-bit complement of integers in @var{a}.  If
 ## @var{k} is omitted @code{k = log2 (bitmax) + 1} is assumed.
 ##
 ## @example
+## @group
 ## bitcmp(7,4)
 ## @result{} 8
 ## dec2bin(11)
 ## @result{} 1011
 ## dec2bin(bitcmp(11, 6))
 ## @result{} 110100
+## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based of the version by Kai Habel from octave-forge
 
 function x = bitcmp (a, n)
   
diff --git a/scripts/general/bitget.m b/scripts/general/bitget.m
--- a/scripts/general/bitget.m
+++ b/scripts/general/bitget.m
@@ -17,18 +17,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{X} =} bitget (@var{a},@var{n})
 ## Return the status of bit(s) @var{n} of unsigned integers in @var{a}
 ## the lowest significant bit is @var{n} = 1.
 ##
 ## @example
+## @group
 ## bitget (100, 8:-1:1)
 ## @result{} 0  1  1  0  0  1  0  0 
+## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitset, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based of the version by Kai Habel from octave-forge
 
 function X = bitget (A, n)
 
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -19,18 +19,20 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{x} =} bitset (@var{a}, @var{n})
 ## @deftypefnx {Function File} {@var{x} =} bitset (@var{a}, @var{n}, @var{v})
 ## Set or reset bit(s) @var{n} of unsigned integers in @var{a}.
 ## @var{v} = 0 resets and @var{v} = 1 sets the bits.
 ## The lowest significant bit is: @var{n} = 1
 ##
 ## @example
+## @group
 ## dec2bin (bitset (10, 1))
 ## @result{} 1011
+## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based of the version by Kai Habel from octave-forge
 
 function X = bitset (A, n, value)
 
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -13,19 +13,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} circshift (@var{x}, @var{n})
-## Circularly shifts the values of the array @var{x}. @var{n} must be
+## Circularly shifts the values of the array @var{x}.  @var{n} must be
 ## a vector of integers no longer than the number of dimensions in 
-## @var{x}. The values of @var{n} can be either positive or negative,
+## @var{x}.  The values of @var{n} can be either positive or negative,
 ## which determines the direction in which the values or @var{x} are
 ## shifted.  If an element of @var{n} is zero, then the corresponding
 ## dimension of @var{x} will not be shifted.  For example
 ##
 ## @example
 ## @group
 ## x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
 ## circshift (x, 1)
diff --git a/scripts/general/colon.m b/scripts/general/colon.m
--- a/scripts/general/colon.m
+++ b/scripts/general/colon.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{r} =} colon (@var{a}, @var{b})
 ## @deftypefnx {Function File} {@var{r} =} colon (@var{a}, @var{b}, @var{c})
-## Method of a class to construct a range with the @code{:} operator. For
+## Method of a class to construct a range with the @code{:} operator.  For
 ## example.
 ##
 ## @example
 ## @group
 ## a = myclass (@dots{})
 ## b = myclass (@dots{})
 ## c = a : b
 ## @end group
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -15,29 +15,29 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cplxpair (@var{z}, @var{tol}, @var{dim})
 ## Sort the numbers @var{z} into complex conjugate pairs ordered by 
 ## increasing real part.  With identical real parts, order by increasing
-## imaginary magnitude. Place the negative imaginary complex number
-## first within each pair. Place all the real numbers after all the 
+## imaginary magnitude.  Place the negative imaginary complex number
+## first within each pair.  Place all the real numbers after all the 
 ## complex pairs (those with @code{abs (imag (@var{z}) / @var{z}) < 
 ## @var{tol})}, where the default value of @var{tol} is @code{100 * 
 ## @var{eps}}.
 ##
 ## By default the complex pairs are sorted along the first non-singleton
-## dimension of @var{z}. If @var{dim} is specified, then the complex
+## dimension of @var{z}.  If @var{dim} is specified, then the complex
 ## pairs are sorted along this dimension.
 ##
-## Signal an error if some complex numbers could not be paired. Requires
+## Signal an error if some complex numbers could not be paired.  Requires
 ## all complex numbers to be exact conjugates within tol, or signals an 
-## error. Note that there are no guarantees on the order of the returned
+## error.  Note that there are no guarantees on the order of the returned
 ## pairs with identical real parts but differing imaginary parts.
 ##
 ## @c Using 'smallexample' to make text fit in page when using 'smallbook'
 ## @smallexample
 ## cplxpair (exp(2i*pi*[0:4]'/5)) == exp(2i*pi*[3; 2; 4; 1; 0]/5)
 ## @end smallexample
 ## @end deftypefn
 
diff --git a/scripts/general/cumtrapz.m b/scripts/general/cumtrapz.m
--- a/scripts/general/cumtrapz.m
+++ b/scripts/general/cumtrapz.m
@@ -18,18 +18,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{z} =} cumtrapz (@var{y})
 ## @deftypefnx {Function File} {@var{z} =} cumtrapz (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{z} =} cumtrapz (@dots{}, @var{dim})
 ## 
 ## Cumulative numerical integration using trapezoidal method.
 ## @code{cumtrapz (@var{y})} computes the cumulative integral of the 
-## @var{y} along the first non-singleton dimension. If the argument 
-## @var{x} is omitted a equally spaced vector is assumed. @code{cumtrapz 
+## @var{y} along the first non-singleton dimension.  If the argument 
+## @var{x} is omitted a equally spaced vector is assumed.  @code{cumtrapz 
 ## (@var{x}, @var{y})} evaluates the cumulative integral with respect 
 ## to @var{x}.
 ##  
 ## @seealso{trapz,cumsum}
 ## @end deftypefn
 
 ## Author:	Kai Habel <kai.habel@gmx.de>
 ##
diff --git a/scripts/general/dblquad.m b/scripts/general/dblquad.m
--- a/scripts/general/dblquad.m
+++ b/scripts/general/dblquad.m
@@ -13,26 +13,26 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dblquad (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{tol}, @var{quadf}, @dots{})
-## Numerically evaluate a double integral. The function over with to
+## Numerically evaluate a double integral.  The function over with to
 ## integrate is defined by @code{@var{f}}, and the interval for the
 ## integration is defined by @code{[@var{xa}, @var{xb}, @var{ya},
-## @var{yb}]}. The function @var{f} must accept a vector @var{x} and a
+## @var{yb}]}.  The function @var{f} must accept a vector @var{x} and a
 ## scalar @var{y}, and return a vector of the same length as @var{x}. 
 ##
 ## If defined, @var{tol} defines the absolute tolerance to which to
 ## which to integrate each sub-integral.
 ##
-## Additional arguments, are passed directly to @var{f}. To use the default
+## Additional arguments, are passed directly to @var{f}.  To use the default
 ## value for @var{tol} one may pass an empty matrix.
 ## @seealso{triplequad, quad, quadv, quadl, quadgk, trapz}
 ## @end deftypefn
 
 function q = dblquad(f, xa, xb, ya, yb, tol, quadf, varargin) 
   if (nargin < 5)
     print_usage ();
   endif
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -17,17 +17,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{d} =} del2 (@var{m})
 ## @deftypefnx {Function File} {@var{d} =} del2 (@var{m}, @var{h})
 ## @deftypefnx {Function File} {@var{d} =} del2 (@var{m}, @var{dx}, @var{dy}, @dots{})
 ##
-## Calculates the discrete Laplace operator. If @var{m} is a matrix this is
+## Calculates the discrete Laplace operator.  If @var{m} is a matrix this is
 ## defined as
 ##
 ## @iftex
 ## @tex
 ## $$d = {1 \over 4} \left( {d^2 \over dx^2} M(x,y) + {d^2 \over dy^2} M(x,y) \right)$$
 ## @end tex
 ## @end iftex
 ## @ifnottex
@@ -39,24 +39,24 @@
 ## @end group
 ## @end example
 ## @end ifnottex
 ##
 ## The above to continued to N-dimensional arrays calculating the second
 ## derivative over the higher dimensions.
 ##
 ## The spacing between evaluation points may be defined by @var{h}, which is a
-## scalar defining the spacing in all dimensions. Or alternatively, the spacing
+## scalar defining the spacing in all dimensions.  Or alternatively, the spacing
 ## in each dimension may be defined separately by @var{dx}, @var{dy}, etc. 
 ## Scalar spacing values give equidistant spacing, whereas vector spacing 
-## values can be used to specify variable spacing. The length of the vectors
-## must match the respective dimension of @var{m}. The default spacing value
+## values can be used to specify variable spacing.  The length of the vectors
+## must match the respective dimension of @var{m}.  The default spacing value
 ## is 1.
 ##
-## You need at least 3 data points for each dimension. Boundary points are
+## You need at least 3 data points for each dimension.  Boundary points are
 ## calculated as the linear extrapolation of the interior points.
 ##
 ## @seealso{gradient, diff}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function D = del2 (M, varargin)
diff --git a/scripts/general/diff.m b/scripts/general/diff.m
--- a/scripts/general/diff.m
+++ b/scripts/general/diff.m
@@ -36,17 +36,17 @@
 ## The second argument is optional.  If supplied, @code{diff (@var{x},
 ## @var{k})}, where @var{k} is a nonnegative integer, returns the
 ## @var{k}-th differences.  It is possible that @var{k} is larger than
 ## then first non-singleton dimension of the matrix.  In this case,
 ## @code{diff} continues to take the differences along the next
 ## non-singleton dimension.
 ##
 ## The dimension along which to take the difference can be explicitly
-## stated with the optional variable @var{dim}. In this case the 
+## stated with the optional variable @var{dim}.  In this case the 
 ## @var{k}-th order differences are calculated along this dimension.
 ## In the case where @var{k} exceeds @code{size (@var{x}, @var{dim})}
 ## then an empty matrix is returned.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 2 February 1995
 ## Adapted-By: jwe
diff --git a/scripts/general/display.m b/scripts/general/display.m
--- a/scripts/general/display.m
+++ b/scripts/general/display.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} display (@var{a})
-## Display the contents of an object. If @var{a} is an object of the
+## Display the contents of an object.  If @var{a} is an object of the
 ## class "myclass", then @code{display} is called in a case like
 ##
 ## @example
 ## myclass (@dots{})
 ## @end example
 ##
 ## @noindent
 ## where Octave is requried to display the contents of a variable of the
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -21,46 +21,46 @@
 ## @deftypefnx {Function File} {[@var{dx}, @var{dy}, @var{dz}, @dots{}] =} gradient (@var{m})
 ## @deftypefnx {Function File} {[@dots{}] =} gradient (@var{m}, @var{s})
 ## @deftypefnx {Function File} {[@dots{}] =} gradient (@var{m}, @var{x}, @var{y}, @var{z}, @dots{})
 ## @deftypefnx {Function File} {[@dots{}] =} gradient (@var{f}, @var{x0})
 ## @deftypefnx {Function File} {[@dots{}] =} gradient (@var{f}, @var{x0}, @var{s})
 ## @deftypefnx {Function File} {[@dots{}] =} gradient (@var{f}, @var{x0}, @var{x}, @var{y}, @dots{})
 ##
 ## Calculate the gradient of sampled data, or of a function.  If @var{m}
-## is a vector, calculate the one dimensional gradient of @var{m}. If
+## is a vector, calculate the one dimensional gradient of @var{m}.  If
 ## @var{m} is a matrix the gradient is calculated for each dimension.
 ##
 ## @code{[@var{dx}, @var{dy}] = gradient (@var{m})} calculates the one
 ## dimensional gradient for @var{x} and @var{y} direction if @var{m} is a
-## matrix. Additional return arguments can be use for multi-dimensional
+## matrix.  Additional return arguments can be use for multi-dimensional
 ## matrices.
 ##
 ## A constant spacing between two points can be provided by the
-## @var{s} parameter. If @var{s} is a scalar, it is assumed to be the spacing
+## @var{s} parameter.  If @var{s} is a scalar, it is assumed to be the spacing
 ## for all dimensions. 
 ## Otherwise, separate values of the spacing can be supplied by
-## the @var{x}, @dots{} arguments. Scalar values specify an equidistant spacing.
+## the @var{x}, @dots{} arguments.  Scalar values specify an equidistant spacing.
 ## Vector values for the @var{x}, @dots{} arguments specify the coordinate for that
-## dimension. The length must match their respective dimension of @var{m}.
+## dimension.  The length must match their respective dimension of @var{m}.
 ## 
-## At boundary points a linear extrapolation is applied. Interior points
+## At boundary points a linear extrapolation is applied.  Interior points
 ## are calculated with the first approximation of the numerical gradient
 ##
 ## @example
 ## y'(i) = 1/(x(i+1)-x(i-1)) * (y(i-1)-y(i+1)).
 ## @end example
 ## 
 ## If the first argument @var{f} is a function handle, the gradient of the
 ## function at the points in @var{x0} is approximated using central
 ## difference.  For example, @code{gradient (@@cos, 0)} approximates the
-## gradient of the cosine function in the point @math{x0 = 0}. As with
+## gradient of the cosine function in the point @math{x0 = 0}.  As with
 ## sampled data, the spacing values between the points from which the
 ## gradient is estimated can be set via the @var{s} or @var{dx},
-## @var{dy}, @dots{} arguments. By default a spacing of 1 is used.
+## @var{dy}, @dots{} arguments.  By default a spacing of 1 is used.
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Modified: David Bateman <dbateman@free.fr> Added NDArray support
 
 function varargout = gradient (m, varargin)
   
   if (nargin < 1)
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -41,24 +41,26 @@
 ## upwards.
 ## @end table
 ## 
 ## @noindent
 ## If @var{op} is not given it is assumed that it is @code{"fix"}.
 ## An example demonstrating these rounding rules is
 ##
 ## @example
+## @group
 ## idivide (int8 ([-3, 3]), int8 (4), "fix")
 ## @result{} int8 ([0, 0])
 ## idivide (int8 ([-3, 3]), int8 (4), "round")
 ## @result{} int8 ([-1, 1])
 ## idivide (int8 ([-3, 3]), int8 (4), "ceil")
 ## @result{} int8 ([0, 1])
 ## idivide (int8 ([-3, 3]), int8 (4), "floor")
 ## @result{} int8 ([-1, 0])
+## @end group
 ## @end example
 ##
 ## @seealso{ldivide, rdivide}
 ## @end deftypefn
 
 function z = idivide (x, y, op)
   if (nargin < 2 || nargin > 3)
     print_usage ();
diff --git a/scripts/general/ind2sub.m b/scripts/general/ind2sub.m
--- a/scripts/general/ind2sub.m
+++ b/scripts/general/ind2sub.m
@@ -19,19 +19,21 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{s1}, @var{s2}, @dots{}, @var{sN}] =} ind2sub (@var{dims}, @var{ind})
 ## Convert a linear index into subscripts.
 ##
 ## The following example shows how to convert the linear index @code{8}
 ## in a 3-by-3 matrix into a subscript.  The matrix is linearly indexed
 ## moving from one column to next, filling up all rows in each column.
 ## @example
+## @group
 ## [r, c] = ind2sub ([3, 3], 8)
 ## @result{} r =  2
 ## c =  3
+## @end group
 ## @end example
 ## @seealso{sub2ind}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ## Adapted-by: jwe
 
 function varargout = ind2sub (dims, ind)
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -17,19 +17,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{yi} =} interp1 (@var{x}, @var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{extrap})
 ## @deftypefnx {Function File} {@var{pp} =} interp1 (@dots{}, 'pp')
 ##
-## One-dimensional interpolation. Interpolate @var{y}, defined at the
-## points @var{x}, at the points @var{xi}. The sample points @var{x} 
-## must be strictly monotonic. If @var{y} is an array, treat the columns
+## One-dimensional interpolation.  Interpolate @var{y}, defined at the
+## points @var{x}, at the points @var{xi}.  The sample points @var{x} 
+## must be strictly monotonic.  If @var{y} is an array, treat the columns
 ## of @var{y} separately.
 ##
 ## Method is one of:
 ##
 ## @table @asis
 ## @item 'nearest'
 ## Return the nearest neighbour.
 ## @item 'linear'
@@ -40,18 +40,18 @@
 ## Cubic interpolation from four nearest neighbours
 ## @item 'spline'
 ## Cubic spline interpolation--smooth first and second derivatives
 ## throughout the curve
 ## @end table
 ##
 ## Appending '*' to the start of the above method forces @code{interp1}
 ## to assume that @var{x} is uniformly spaced, and only @code{@var{x}
-## (1)} and @code{@var{x} (2)} are referenced. This is usually faster,
-## and is never slower. The default method is 'linear'.
+## (1)} and @code{@var{x} (2)} are referenced.  This is usually faster,
+## and is never slower.  The default method is 'linear'.
 ##
 ## If @var{extrap} is the string 'extrap', then extrapolate values beyond
 ## the endpoints.  If @var{extrap} is a number, replace values beyond the
 ## endpoints with that number.  If @var{extrap} is missing, assume NA.
 ##
 ## If the string argument 'pp' is specified, then @var{xi} should not be
 ## supplied and @code{interp1} returns the piece-wise polynomial that
 ## can later be used with @code{ppval} to evaluate the interpolation.
diff --git a/scripts/general/interp1q.m b/scripts/general/interp1q.m
--- a/scripts/general/interp1q.m
+++ b/scripts/general/interp1q.m
@@ -15,27 +15,27 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{yi} =} interp1q (@var{x}, @var{y}, @var{xi})
 ## One-dimensional linear interpolation without error checking.
 ## Interpolates @var{y}, defined at the points @var{x}, at the points
-## @var{xi}. The sample points @var{x} must be a strictly monotonically
-## increasing column vector. If @var{y} is an array, treat the columns
-## of @var{y} separately. If @var{y} is a vector, it must be a column
+## @var{xi}.  The sample points @var{x} must be a strictly monotonically
+## increasing column vector.  If @var{y} is an array, treat the columns
+## of @var{y} separately.  If @var{y} is a vector, it must be a column
 ## vector of the same length as @var{x}.
 ##
 ## Values of @var{xi} beyond the endpoints of the interpolation result
 ## in NA being returned.
 ##
 ## Note that the error checking is only a significant portion of the
 ## execution time of this @code{interp1} if the size of the input arguments
-## is relatively small. Therefore, the benefit of using @code{interp1q}
+## is relatively small.  Therefore, the benefit of using @code{interp1q}
 ## is relatively small.
 ## @seealso{interp1}
 ## @end deftypefn
 
 function yi = interp1q (x, y, xi)
   x = x(:);
   nx = size (x, 1);
   szy = size (y);
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -13,66 +13,66 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{zi}=} interp2 (@var{x}, @var{y}, @var{z}, @var{xi}, @var{yi})
-## @deftypefnx {Function File} {@var{zi}=} interp2 (@var{Z}, @var{xi}, @var{yi})
-## @deftypefnx {Function File} {@var{zi}=} interp2 (@var{Z}, @var{n})
-## @deftypefnx {Function File} {@var{zi}=} interp2 (@dots{}, @var{method})
-## @deftypefnx {Function File} {@var{zi}=} interp2 (@dots{}, @var{method}, @var{extrapval})
+## @deftypefn {Function File} {@var{zi} =} interp2 (@var{x}, @var{y}, @var{z}, @var{xi}, @var{yi})
+## @deftypefnx {Function File} {@var{zi} =} interp2 (@var{Z}, @var{xi}, @var{yi})
+## @deftypefnx {Function File} {@var{zi} =} interp2 (@var{Z}, @var{n})
+## @deftypefnx {Function File} {@var{zi} =} interp2 (@dots{}, @var{method})
+## @deftypefnx {Function File} {@var{zi} =} interp2 (@dots{}, @var{method}, @var{extrapval})
 ##
-## Two-dimensional interpolation. @var{x}, @var{y} and @var{z} describe a
-## surface function. If @var{x} and @var{y} are vectors their length
-## must correspondent to the size of @var{z}. @var{x} and @var{y} must be
-## monotonic. If they are matrices they  must have the @code{meshgrid} 
+## Two-dimensional interpolation.  @var{x}, @var{y} and @var{z} describe a
+## surface function.  If @var{x} and @var{y} are vectors their length
+## must correspondent to the size of @var{z}.  @var{x} and @var{y} must be
+## monotonic.  If they are matrices they must have the @code{meshgrid} 
 ## format. 
 ##
 ## @table @code
 ## @item interp2 (@var{x}, @var{y}, @var{Z}, @var{xi}, @var{yi}, @dots{}) 
 ## Returns a matrix corresponding to the points described by the
 ## matrices @var{xi}, @var{yi}.  
 ##
 ## If the last argument is a string, the interpolation method can
-## be specified. The method can be 'linear', 'nearest' or 'cubic'.
-## If it is omitted 'linear' interpolation  is assumed.
+## be specified.  The method can be 'linear', 'nearest' or 'cubic'.
+## If it is omitted 'linear' interpolation is assumed.
 ##
-## @item  interp2 (@var{z}, @var{xi}, @var{yi})
+## @item interp2 (@var{z}, @var{xi}, @var{yi})
 ## Assumes @code{@var{x} = 1:rows (@var{z})} and @code{@var{y} = 
 ## 1:columns (@var{z})}
 ## 
 ## @item interp2 (@var{z}, @var{n}) 
-## Interleaves the matrix @var{z} n-times. If @var{n} is omitted a value
+## Interleaves the matrix @var{z} n-times.  If @var{n} is omitted a value
 ## of @code{@var{n} = 1} is assumed.
 ## @end table
 ##
 ## The variable @var{method} defines the method to use for the
-## interpolation. It can take one of the following values 
+## interpolation.  It can take one of the following values 
 ##
 ## @table @asis
 ## @item 'nearest'
 ## Return the nearest neighbor.
 ## @item 'linear'
 ## Linear interpolation from nearest neighbors.
 ## @item 'pchip'
 ## Piece-wise cubic hermite interpolating polynomial (not implemented yet).
 ## @item 'cubic'
 ## Cubic interpolation from four nearest neighbors.
 ## @item 'spline'
 ## Cubic spline interpolation--smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
 ## If a scalar value @var{extrapval} is defined as the final value, then
-## values outside the mesh as set to this value. Note that in this case 
-## @var{method} must be defined as well. If @var{extrapval} is not
+## values outside the mesh as set to this value.  Note that in this case 
+## @var{method} must be defined as well.  If @var{extrapval} is not
 ## defined then NA is assumed. 
 ##
 ## @seealso{interp1}
 ## @end deftypefn
 
 ## Author:	Kai Habel <kai.habel@gmx.de>
 ## 2005-03-02 Thomas Weber <weber@num.uni-sb.de> 
 ##     * Add test cases
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -19,29 +19,29 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{vi} =} interp3 (@var{x}, @var{y},@var{z}, @var{v}, @var{xi}, @var{yi}, @var{zi})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@var{v}, @var{xi}, @var{yi}, @var{zi})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@var{v}, @var{m})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@var{v})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@dots{}, @var{method}, @var{extrapval})
 ##
-## Perform 3-dimensional interpolation. Each element of the 3-dimensional 
+## Perform 3-dimensional interpolation.  Each element of the 3-dimensional 
 ## array @var{v} represents a value at a location given by the parameters 
-## @var{x}, @var{y}, and @var{z}. The parameters @var{x}, @var{x}, and 
+## @var{x}, @var{y}, and @var{z}.  The parameters @var{x}, @var{x}, and 
 ## @var{z} are either 3-dimensional arrays of the same size as the array 
-## @var{v} in the 'meshgrid' format or vectors. The parameters @var{xi}, etc 
+## @var{v} in the 'meshgrid' format or vectors.  The parameters @var{xi}, etc 
 ## respect a similar format to @var{x}, etc, and they represent the points 
 ## at which the array @var{vi} is interpolated.
 ##
 ## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be 
 ## @code{x = 1 : size (@var{v}, 2)}, @code{y = 1 : size (@var{v}, 1)} and
-## @code{z = 1 : size (@var{v}, 3)}. If @var{m} is specified, then
+## @code{z = 1 : size (@var{v}, 3)}.  If @var{m} is specified, then
 ## the interpolation adds a point half way between each of the interpolation 
-## points. This process is performed @var{m} times. If only @var{v} is 
+## points.  This process is performed @var{m} times.  If only @var{v} is 
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
 ## @item 'nearest'
 ## Return the nearest neighbour.
 ## @item 'linear'
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -15,20 +15,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} interpft (@var{x}, @var{n})
 ## @deftypefnx {Function File} {} interpft (@var{x}, @var{n}, @var{dim})
 ##
-## Fourier interpolation. If @var{x} is a vector, then @var{x} is
-## resampled with @var{n} points. The data in @var{x} is assumed to be
-## equispaced. If @var{x} is an array, then operate along each column of
-## the array separately. If @var{dim} is specified, then interpolate
+## Fourier interpolation.  If @var{x} is a vector, then @var{x} is
+## resampled with @var{n} points.  The data in @var{x} is assumed to be
+## equispaced.  If @var{x} is an array, then operate along each column of
+## the array separately.  If @var{dim} is specified, then interpolate
 ## along the dimension @var{dim}.
 ##
 ## @code{interpft} assumes that the interpolated function is periodic,
 ## and so assumptions are made about the end points of the interpolation.
 ##
 ## @seealso{interp1}
 ## @end deftypefn
 
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -24,24 +24,24 @@
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method}, @var{extrapval})
 ##
 ## Perform @var{n}-dimensional interpolation, where @var{n} is at least two. 
 ## Each element of the @var{n}-dimensional array @var{v} represents a value 
 ## at a location given by the parameters @var{x1}, @var{x2}, @dots{}, @var{xn}. 
 ## The parameters @var{x1}, @var{x2}, @dots{}, @var{xn} are either 
 ## @var{n}-dimensional arrays of the same size as the array @var{v} in 
-## the 'ndgrid' format or vectors. The parameters @var{y1}, etc respect a 
+## the 'ndgrid' format or vectors.  The parameters @var{y1}, etc respect a 
 ## similar format to @var{x1}, etc, and they represent the points at which
 ## the array @var{vi} is interpolated.
 ##
 ## If @var{x1}, @dots{}, @var{xn} are omitted, they are assumed to be 
-## @code{x1 = 1 : size (@var{v}, 1)}, etc. If @var{m} is specified, then
+## @code{x1 = 1 : size (@var{v}, 1)}, etc.  If @var{m} is specified, then
 ## the interpolation adds a point half way between each of the interpolation 
-## points. This process is performed @var{m} times. If only @var{v} is 
+## points.  This process is performed @var{m} times.  If only @var{v} is 
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
 ## @item 'nearest'
 ## Return the nearest neighbour.
 ## @item 'linear'
@@ -51,17 +51,17 @@
 ## @item 'spline'
 ## Cubic spline interpolation--smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
 ## The default method is 'linear'.
 ##
 ## If @var{extrapval} is the scalar value, use it to replace the values
-## beyond the endpoints with that number. If @var{extrapval} is missing,
+## beyond the endpoints with that number.  If @var{extrapval} is missing,
 ## assume NA.
 ## @seealso{interp1, interp2, spline, ndgrid}
 ## @end deftypefn
 
 function vi = interpn (varargin)
 
   method = "linear";
   extrapval = NA;
diff --git a/scripts/general/loadobj.m b/scripts/general/loadobj.m
--- a/scripts/general/loadobj.m
+++ b/scripts/general/loadobj.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{b} =} loadobj (@var{a})
 ## Method of a class to manipulate an object after loading it tfrom a file. 
 ## The function @code{loadobj} is called when the object @var{a} is loaded 
-## using the @code{load} function. An example of the use of @code{saveobj}
+## using the @code{load} function.  An example of the use of @code{saveobj}
 ## might be to add fields to an object that don't make sense to be saved.
 ## For example
 ##
 ## @example
 ## @group
 ## function b = loadobj (a)
 ##   b = a;
 ##   b.addmssingfield = addfield (b;
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -52,17 +52,17 @@
 ## @iftex
 ## @tex
 ## $10^{base}$ and $10^{\pi}$,
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ## 10^base and 10^pi,
 ## @end ifnottex
-## in order to  be compatible with the corresponding @sc{Matlab}
+## in order to be compatible with the corresponding @sc{matlab}
 ## function.
 ##
 ## Also for compatibility, return the second argument if fewer than two
 ## values are requested.
 ## @seealso{linspace}
 ## @end deftypefn
 
 ## Author: jwe
diff --git a/scripts/general/mod.m b/scripts/general/mod.m
--- a/scripts/general/mod.m
+++ b/scripts/general/mod.m
@@ -13,24 +13,24 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} mod (@var{x}, @var{y})
-## Compute modulo function. Conceptually this is given by
+## Compute modulo function.  Conceptually this is given by
 ##
 ## @example
 ## x - y .* floor (x ./ y)
 ## @end example
 ##
 ## and is written in a manner that the correct modulus is returned for
-##integer types. This function handles negative values correctly. That
+##integer types.  This function handles negative values correctly.  That
 ##is @code{mod (-1, 3)} is 2, not -1 as @code{rem (-1, 3)} returns.
 ## Also, @code{mod (@var{x}, 0)} returns @var{x}.
 ##
 ## An error message is printed if the dimensions of the arguments do not
 ## agree, or if either of the arguments is complex.
 ## @seealso{rem, round}
 ## @end deftypefn
 
diff --git a/scripts/general/nthroot.m b/scripts/general/nthroot.m
--- a/scripts/general/nthroot.m
+++ b/scripts/general/nthroot.m
@@ -18,17 +18,17 @@
 ##
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nthroot (@var{x}, @var{n})
 ## 
 ## Compute the n-th root of @var{x}, returning real results for real 
-## components of @var{x}. For example
+## components of @var{x}.  For example
 ##
 ## @example
 ## @group
 ## nthroot (-1, 3)
 ## @result{} -1
 ## (-1) ^ (1 / 3)
 ## @result{} 0.50000 - 0.86603i
 ## @end group
diff --git a/scripts/general/polyarea.m b/scripts/general/polyarea.m
--- a/scripts/general/polyarea.m
+++ b/scripts/general/polyarea.m
@@ -15,19 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyarea (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} polyarea (@var{x}, @var{y}, @var{dim})
 ##
-## Determines area of a polygon by triangle method. The variables
+## Determines area of a polygon by triangle method.  The variables
 ## @var{x} and @var{y} define the vertex pairs, and must therefore have
-## the same shape. They can be either vectors or arrays. If they are
+## the same shape.  They can be either vectors or arrays.  If they are
 ## arrays then the columns of @var{x} and @var{y} are treated separately
 ## and an area returned for each.
 ##
 ## If the optional @var{dim} argument is given, then @code{polyarea}
 ## works along this dimension of the arrays @var{x} and @var{y}.
 ##
 ## @end deftypefn
 
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -17,70 +17,70 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} quadgk (@var{f}, @var{a}, @var{b}, @var{abstol}, @var{trace})
 ## @deftypefnx {Function File} {} quadgk (@var{f}, @var{a}, @var{b}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {[@var{q}, @var{err}] =} quadgk (@dots{})
 ## Numerically evaluate integral using adaptive Guass-Konrod quadrature.
 ## The formulation is based on a proposal by L.F. Shampine,
-## @cite{"Vectorized adaptive quadrature in MATLAB", Journal of
+## @cite{"Vectorized adaptive quadrature in @sc{matlab}", Journal of
 ## Computational and Applied Mathematics, pp131-140, Vol 211, Issue 2,
 ## Feb 2008} where all function evalutions at an iteration are
-## calculated with a single call to @var{f}. Therefore the function
+## calculated with a single call to @var{f}.  Therefore the function
 ## @var{f} must be of the form @code{@var{f} (@var{x})} and accept
 ## vector values of @var{x} and return a vector of the same length
 ## representing the function evalutaions at the given values of @var{x}.
 ## The function @var{f} can be defined in terms of a function handle,
 ## inline function or string.
 ##
 ## The bounds of the quadrature @code{[@var{a}, @var{b}]} can be finite
-## or infinite and contain weak end singularities. Variable
+## or infinite and contain weak end singularities.  Variable
 ## transformation will be used to treat infinite intervals and weaken
-## the singularities. For example
+## the singularities.  For example
 ##
 ## @example
 ## quadgk(@@(x) 1 ./ (sqrt (x) .* (x + 1)), 0, Inf)
 ## @end example
 ##
 ## @noindent
 ## Note that the formulation of the integrand uses the
 ## element-by-element operator @code{./} and all user functions to
 ## @code{quadgk} should do the same.
 ##
 ## The absolute tolerance can be passed as a fourth argument in a manner
-## compatible with @code{quadv}. Equally the user can request that
+## compatible with @code{quadv}.  Equally the user can request that
 ## information on the convergence can be printed is the fifth argument
 ## is logicallly true.
 ##
 ## Alternatively, certain properties of @code{quadgk} can be passed as
-## pairs @code{@var{prop}, @var{val}}. Valid properties are
+## pairs @code{@var{prop}, @var{val}}.  Valid properties are
 ##
 ## @table @code
 ## @item AbsTol
-## Defines the absolute error tolerance for the quadrature. The default
+## Defines the absolute error tolerance for the quadrature.  The default
 ## absolute tolerance is 1e-10.
 ##
 ## @item RelTol
-## Defines the relative error tolerance for the quadrature. The default
+## Defines the relative error tolerance for the quadrature.  The default
 ## relative tolerance is 1e-5.
 ##
 ## @item MaxIntervalCount
 ## @code{quadgk} initially subdivides the interval on which to perform
-## the quadrature into 10 intervals. Sub-intervals that have an
-## unacceptable error are sub-divided and re-evaluated. If the number of
+## the quadrature into 10 intervals.  Sub-intervals that have an
+## unacceptable error are sub-divided and re-evaluated.  If the number of
 ## sub-intervals exceeds at any point 650 sub-intervals then a poor
 ## convergence is signaled and the current estimate of the integral is
-## returned. The property 'MaxIntervalCount' can be used to alter the
+## returned.  The property 'MaxIntervalCount' can be used to alter the
 ## number of sub-intervals that can exist before exiting.
 ##
 ## @item WayPoints
 ## If there exists discontinuities in the first derivative of the
 ## function to integrate, then these can be flagged with the
-## @code{"WayPoints"} property. This forces the ends of a sub-interval
+## @code{"WayPoints"} property.  This forces the ends of a sub-interval
 ## to fall on the breakpoints of the function and can result in
 ## significantly improved estimated of the error in the integral, faster
 ## computation or both.  For example,
 ##
 ## @example
 ## quadgk (@@(x) abs (1 - x .^ 2), 0, 2, 'Waypoints', 1)
 ## @end example
 ##
@@ -89,22 +89,24 @@
 ##
 ## @item Trace
 ## If logically true, then @code{quadgk} prints information on the
 ## convergence of the quadrature at each iteration.
 ##@end table
 ##
 ## If any of @var{a}, @var{b} or @var{waypoints} is complex, then the
 ## quadrature is treated as a contour integral along a piecewise
-## continuous path defined by the above. In this case the integral is
-## assuemd to have no edge singularities. For example
+## continuous path defined by the above.  In this case the integral is
+## assuemd to have no edge singularities.  For example
 ##
 ## @example
+## @group
 ## quadgk (@@(z) log (z), 1+1i, 1+1i, "WayPoints",
 ##         [1-1i, -1,-1i, -1+1i])
+## @end group
 ## @end example
 ##
 ## @noindent
 ## integrates @code{log (z)} along the square defined by @code{[1+1i,
 ##  1-1i, -1-1i, -1+1i]}
 ##
 ## If two output arguments are requested, then @var{err} returns the
 ## approximate bounds on the error in the integral @code{abs (@var{q} -
diff --git a/scripts/general/quadl.m b/scripts/general/quadl.m
--- a/scripts/general/quadl.m
+++ b/scripts/general/quadl.m
@@ -19,23 +19,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{q} =} quadl (@var{f}, @var{a}, @var{b})
 ## @deftypefnx {Function File} {@var{q} =} quadl (@var{f}, @var{a}, @var{b}, @var{tol})
 ## @deftypefnx {Function File} {@var{q} =} quadl (@var{f}, @var{a}, @var{b}, @var{tol}, @var{trace})
 ## @deftypefnx {Function File} {@var{q} =} quadl (@var{f}, @var{a}, @var{b}, @var{tol}, @var{trace}, @var{p1}, @var{p2}, @dots{})
 ##
 ## Numerically evaluate integral using adaptive Lobatto rule.
 ## @code{quadl (@var{f}, @var{a}, @var{b})} approximates the integral of
-## @code{@var{f}(@var{x})} to machine precision. @var{f} is either a
+## @code{@var{f}(@var{x})} to machine precision.  @var{f} is either a
 ## function handle, inline function or string containing the name of
-## the function to evaluate. The function @var{f} must return a vector
+## the function to evaluate.  The function @var{f} must return a vector
 ## of output values if given a vector of input values.
 ##
 ## If defined, @var{tol} defines the relative tolerance to which to
-## which to integrate @code{@var{f}(@var{x})}. While if @var{trace} is
+## which to integrate @code{@var{f}(@var{x})}.  While if @var{trace} is
 ## defined, displays the left end point of the current interval, the 
 ## interval length, and the partial integral.
 ##
 ## Additional arguments @var{p1}, etc, are passed directly to @var{f}.
 ## To use default values for @var{tol} and @var{trace}, one may pass
 ## empty matrices.
 ##
 ## Reference: W. Gander and W. Gautschi, 'Adaptive Quadrature - 
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {@var{q} =} quadl (@var{f}, @var{a}, @var{b}, @var{tol}, @var{trace})
 ## @deftypefnx {Function File} {@var{q} =} quadl (@var{f}, @var{a}, @var{b}, @var{tol}, @var{trace}, @var{p1}, @var{p2}, @dots{})
 ## @deftypefnx {Function File} {[@var{q}, @var{fcnt}] =} quadl (@dots{})
 ##
 ## Numerically evaluate integral using adaptive Simpson's rule.
 ## @code{quadv (@var{f}, @var{a}, @var{b})} approximates the integral of
 ## @code{@var{f}(@var{x})} to the default absolute tolerance of @code{1e-6}. 
 ## @var{f} is either a function handle, inline function or string
-## containing the name of the function to evaluate. The function @var{f}
+## containing the name of the function to evaluate.  The function @var{f}
 ## must accept a string, and can return a vector representing the
 ## approximation to @var{n} different sub-functions.
 ##
 ## If defined, @var{tol} defines the absolute tolerance to which to
 ## which to integrate each sub-interval of @code{@var{f}(@var{x})}.
 ## While if @var{trace} is defined, displays the left end point of the
 ## current interval, the interval length, and the partial integral.
 ##
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -19,19 +19,21 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{s} =} rat (@var{x}, @var{tol})
 ## @deftypefnx {Function File} {[@var{n}, @var{d}] =} rat (@var{x}, @var{tol})
 ##
 ## Find a rational approximation to @var{x} within the tolerance defined
 ## by @var{tol} using a continued fraction expansion.  For example,
 ##
 ## @example
+## @group
 ## rat(pi) = 3 + 1/(7 + 1/16) = 355/113
 ## rat(e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7))))) 
 ##        = 1457/536
+## @end group
 ## @end example
 ##
 ## Called with two arguments returns the numerator and denominator separately
 ## as two matrices.
 ## @end deftypefn
 ## @seealso{rats}
 
 function [n,d] = rat(x,tol)
diff --git a/scripts/general/runlength.m b/scripts/general/runlength.m
--- a/scripts/general/runlength.m
+++ b/scripts/general/runlength.m
@@ -17,18 +17,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} runlength (@var{x})
 ## Find the lengths of all sequences of common values.  Return the
 ## vector of lengths and the value that was repeated.
 ##
 ## @example
+## @group
 ## runlength ([2, 2, 0, 4, 4, 4, 0, 1, 1, 1, 1])
 ## @result{}  [2, 1, 3, 1, 4]
+## @end group
 ## @end example
 ## @end deftypefn
 
 function [count, value] = runlength (x)
   idx = [find(x(1:end-1) != x(2:end)), length(x)];
   value = x(idx);
   count = diff ([0 idx]);
 endfunction
diff --git a/scripts/general/saveobj.m b/scripts/general/saveobj.m
--- a/scripts/general/saveobj.m
+++ b/scripts/general/saveobj.m
@@ -15,20 +15,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{b} =} saveobj (@var{a})
 ## Method of a class to manipulate an object prior to saving it to a file. 
 ## The function @code{saveobj} is called when the object @var{a} is saved 
-## using the @code{save} function. An example of the use of @code{saveobj}
+## using the @code{save} function.  An example of the use of @code{saveobj}
 ## might be to remove fields of the object that don't make sense to be saved
 ## or it might be used to ensure that certain fields of the object are
-## initialized before the object is saved. For example
+## initialized before the object is saved.  For example
 ##
 ## @example
 ## @group
 ## function b = saveobj (a)
 ##   b = a;
 ##   if (isempty (b.field))
 ##      b.field = initfield(b);
 ##   endif
diff --git a/scripts/general/sub2ind.m b/scripts/general/sub2ind.m
--- a/scripts/general/sub2ind.m
+++ b/scripts/general/sub2ind.m
@@ -22,18 +22,20 @@
 ## Convert subscripts into a linear index.
 ##
 ## The following example shows how to convert the two-dimensional
 ## index @code{(2,3)} of a 3-by-3 matrix to a linear index.  The matrix
 ## is linearly indexed moving from one column to next, filling up
 ## all rows in each column.
 ##
 ## @example
+## @group
 ## linear_index = sub2ind ([3, 3], 2, 3)
 ## @result{} 8
+## @end group
 ## @end example
 ## @seealso{ind2sub}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ## Adapted-by: jwe
 
 function ind = sub2ind (dims, varargin)
diff --git a/scripts/general/subsindex.m b/scripts/general/subsindex.m
--- a/scripts/general/subsindex.m
+++ b/scripts/general/subsindex.m
@@ -13,22 +13,22 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{idx} =} subsindex (@var{a})
-## Convert an object to an index vector. When @var{a} is a class object 
+## Convert an object to an index vector.  When @var{a} is a class object 
 ## defined with a class constructor, then @code{subsindex} is the
 ## overloading method that allows the conversion of this class object to
-## a valid indexing vector. It is important to note that
+## a valid indexing vector.  It is important to note that
 ## @code{subsindex} must return a zero-based real integer vector of the
-## class "double". For example, if the class constructor
+## class "double".  For example, if the class constructor
 ##
 ## @example
 ## @group
 ## function b = myclass (a)
 ##  b = myclass (struct ("a", a), "myclass");
 ## endfunction
 ## @end group
 ## @end example
diff --git a/scripts/general/trapz.m b/scripts/general/trapz.m
--- a/scripts/general/trapz.m
+++ b/scripts/general/trapz.m
@@ -16,20 +16,20 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{z} =} trapz (@var{y})
 ## @deftypefnx {Function File} {@var{z} =} trapz (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{z} =} trapz (@dots{}, @var{dim})
 ## 
-## Numerical integration using trapezoidal method. @code{trapz
+## Numerical integration using trapezoidal method.  @code{trapz
 ## (@var{y})} computes the integral of the @var{y} along the first
-## non-singleton dimension. If the argument @var{x} is omitted a 
-## equally spaced vector is assumed. @code{trapz (@var{x}, @var{y})} 
+## non-singleton dimension.  If the argument @var{x} is omitted a 
+## equally spaced vector is assumed.  @code{trapz (@var{x}, @var{y})} 
 ## evaluates the integral with respect to @var{x}.
 ##  
 ## @seealso{cumtrapz}
 ## @end deftypefn
 
 ## Author:	Kai Habel <kai.habel@gmx.de>
 ##
 ## also: June 2000 - Paul Kienzle (fixes,suggestions) 
diff --git a/scripts/general/triplequad.m b/scripts/general/triplequad.m
--- a/scripts/general/triplequad.m
+++ b/scripts/general/triplequad.m
@@ -13,27 +13,27 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} triplequad (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{za}, @var{zb}, @var{tol}, @var{quadf}, @dots{})
-## Numerically evaluate a triple integral. The function over with to
+## Numerically evaluate a triple integral.  The function over which to
 ## integrate is defined by @code{@var{f}}, and the interval for the
 ## integration is defined by @code{[@var{xa}, @var{xb}, @var{ya},
-## @var{yb}, @var{za}, @var{zb}]}. The function @var{f} must accept a
+## @var{yb}, @var{za}, @var{zb}]}.  The function @var{f} must accept a
 ## vector @var{x} and a scalar @var{y}, and return a vector of the same
 ## length as @var{x}.
 ##
 ## If defined, @var{tol} defines the absolute tolerance to which to
 ## which to integrate each sub-integral.
 ##
-## Additional arguments, are passed directly to @var{f}. To use the default
+## Additional arguments, are passed directly to @var{f}.  To use the default
 ## value for @var{tol} one may pass an empty matrix.
 ## @seealso{dblquad, quad, quadv, quadl, quadgk, trapz}
 ## @end deftypefn
 
 function Q = triplequad(f, xa, xb, ya, yb, za, zb, tol, quadf, varargin)
   if (nargin < 7)
     print_usage ();
   endif
diff --git a/scripts/geometry/delaunay.m b/scripts/geometry/delaunay.m
--- a/scripts/geometry/delaunay.m
+++ b/scripts/geometry/delaunay.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{tri}=} delaunay (@var{x}, @var{y})
-## @deftypefnx {Function File} {@var{tri}=} delaunay (@var{x}, @var{y}, @var{opt})
+## @deftypefn {Function File} {@var{tri} =} delaunay (@var{x}, @var{y})
+## @deftypefnx {Function File} {@var{tri} =} delaunay (@var{x}, @var{y}, @var{opt})
 ## The return matrix of size [n, 3] contains a set triangles which are
 ## described by the indices to the data point x and y vector.
 ## The triangulation satisfies the Delaunay circumcircle criterion.
 ## No other data point is in the circumcircle of the defining triangle.
 ##
 ## A third optional argument, which must be a string, contains extra options
 ## passed to the underlying qhull command.  See the documentation for the 
 ## Qhull library for details.
diff --git a/scripts/geometry/delaunay3.m b/scripts/geometry/delaunay3.m
--- a/scripts/geometry/delaunay3.m
+++ b/scripts/geometry/delaunay3.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{T} =} delaunay3 (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {@var{T} =} delaunay3 (@var{x}, @var{y}, @var{z}, @var{opt})
-## A matrix of size [n, 4] is returned. Each row contains a 
+## A matrix of size [n, 4] is returned.  Each row contains a 
 ## set of tetrahedron which are
 ## described by the indices to the data point vectors (x,y,z).
 ##
 ## A fourth optional argument, which must be a string or cell array of strings,
 ## contains extra options passed to the underlying qhull command.  See the 
 ## documentation for the Qhull library for details.
 ## @seealso{delaunay,delaunayn}
 ## @end deftypefn
diff --git a/scripts/geometry/delaunayn.m b/scripts/geometry/delaunayn.m
--- a/scripts/geometry/delaunayn.m
+++ b/scripts/geometry/delaunayn.m
@@ -19,31 +19,31 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{T} =} delaunayn (@var{P})
 ## @deftypefnx {Function File} {@var{T} =} delaunayn (@var{P}, @var{opt})
 ## Form the Delaunay triangulation for a set of points.
 ## The Delaunay triangulation is a tessellation of the convex hull of the
 ## points such that no n-sphere defined by the n-triangles contains
 ## any other points from the set.
 ## The input matrix @var{P} of size @code{[n, dim]} contains @var{n}
-## points in a space of dimension dim. The return matrix @var{T} has the
+## points in a space of dimension dim.  The return matrix @var{T} has the
 ## size @code{[m, dim+1]}.  It contains for each row a set of indices to
 ## the points, which describes a simplex of dimension dim.  For example,
 ## a 2d simplex is a triangle and 3d simplex is a tetrahedron.
 ## 
 ## Extra options for the underlying Qhull command can be specified by the
-## second argument. This argument is a cell array of strings. The default
+## second argument.  This argument is a cell array of strings.  The default
 ## options depend on the dimension of the input: 
 ## 
 ## @itemize 
-## @item  2D and 3D: @var{opt} = @code{@{"Qt", "Qbb", "Qc"@}}
-## @item  4D and higher: @var{opt} = @code{@{"Qt", "Qbb", "Qc", "Qz"@}} 
+## @item 2D and 3D: @var{opt} = @code{@{"Qt", "Qbb", "Qc"@}}
+## @item 4D and higher: @var{opt} = @code{@{"Qt", "Qbb", "Qc", "Qz"@}} 
 ## @end itemize
 ## 
-## If @var{opt} is [], then the default arguments are used. If @var{opt}
+## If @var{opt} is [], then the default arguments are used.  If @var{opt}
 ## is @code{@{"@w{}"@}}, then none of the default arguments are used by Qhull. 
 ## See the Qhull documentation for the available options. 
 ## 
 ## All options can also be specified as single string, for example
 ## @code{"Qt Qbb Qc Qz"}.
 ## 
 ## @end deftypefn
 
diff --git a/scripts/geometry/dsearch.m b/scripts/geometry/dsearch.m
--- a/scripts/geometry/dsearch.m
+++ b/scripts/geometry/dsearch.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{idx} =} dsearch (@var{x}, @var{y}, @var{tri}, @var{xi}, @var{yi})
 ## @deftypefnx {Function File} {@var{idx} =} dsearch (@var{x}, @var{y}, @var{tri}, @var{xi}, @var{yi}, @var{s})
 ## Returns the index @var{idx} or the closest point in @code{@var{x}, @var{y}}
-## to the elements @code{[@var{xi}(:), @var{yi}(:)]}. The variable @var{s} is
+## to the elements @code{[@var{xi}(:), @var{yi}(:)]}.  The variable @var{s} is
 ## accepted but ignored for compatibility.
 ## @seealso{dsearchn, tsearch}
 ## @end deftypefn
 
 function idx = dsearch (x, y, t, xi, yi, s)
   if (nargin < 5 || nargin > 6)
     print_usage ();
   endif
diff --git a/scripts/geometry/dsearchn.m b/scripts/geometry/dsearchn.m
--- a/scripts/geometry/dsearchn.m
+++ b/scripts/geometry/dsearchn.m
@@ -17,19 +17,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{idx} =} dsearchn (@var{x}, @var{tri}, @var{xi})
 ## @deftypefnx {Function File} {@var{idx} =} dsearchn (@var{x}, @var{tri}, @var{xi}, @var{outval})
 ## @deftypefnx {Function File} {@var{idx} =} dsearchn (@var{x}, @var{xi})
 ## @deftypefnx {Function File} {[@var{idx}, @var{d}] =} dsearchn (@dots{})
 ## Returns the index @var{idx} or the closest point in @var{x} to the elements
-## @var{xi}. If @var{outval} is supplied, then the values of @var{xi} that are
+## @var{xi}.  If @var{outval} is supplied, then the values of @var{xi} that are
 ## not contained within one of the simplicies @var{tri} are set to 
-## @var{outval}. Generally, @var{tri} is returned from @code{delaunayn 
+## @var{outval}.  Generally, @var{tri} is returned from @code{delaunayn 
 ## (@var{x})}.
 ## @seealso{dsearch, tsearch}
 ## @end deftypefn
 
 function [idx, d] = dsearchn (x, t, xi, outval)
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2006, 2007, 2008, 2009 Frederick (Rick) A Niles
-##               and Sren Hauberg
+##               and Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -17,25 +17,25 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{in}, @var{on}] =} inpolygon (@var{x}, @var{y}, @var{xv}, @var{xy})
 ##
 ## For a polygon defined by @code{(@var{xv}, @var{yv})} points, determine
 ## if the points @code{(@var{x}, @var{y})} are inside or outside the polygon.
-## The variables @var{x}, @var{y}, must have the same dimension. The optional
+## The variables @var{x}, @var{y}, must have the same dimension.  The optional
 ## output @var{on} gives the points that are on the polygon.
 ##
 ## @end deftypefn
 
 ## Author: Frederick (Rick) A Niles <niles@rickniles.com>
 ## Created: 14 November 2006
 
-## Vectorized by Sren Hauberg <soren@hauberg.org>
+## Vectorized by Sren Hauberg <soren@hauberg.org>
 
 ## The method for determining if a point is in in a polygon is based on
 ## the algorithm shown on
 ## http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/ and is
 ## credited to Randolph Franklin.
 
 function [IN, ON] = inpolygon (X, Y, xv, yv)
 
diff --git a/scripts/geometry/trimesh.m b/scripts/geometry/trimesh.m
--- a/scripts/geometry/trimesh.m
+++ b/scripts/geometry/trimesh.m
@@ -14,20 +14,20 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} trimesh (@var{tri}, @var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {@var{h} =} trimesh (@dots{})
-## Plot a triangular mesh in 3D. The variable @var{tri} is the triangular
+## Plot a triangular mesh in 3D.  The variable @var{tri} is the triangular
 ## meshing of the points @code{(@var{x}, @var{y})} which is returned 
-## from @code{delaunay}. The variable @var{z} is value at the point 
-## @code{(@var{x}, @var{y})}. The output argument @var{h} is the graphic 
+## from @code{delaunay}.  The variable @var{z} is value at the point 
+## @code{(@var{x}, @var{y})}.  The output argument @var{h} is the graphic 
 ## handle to the plot.
 ## @seealso{triplot, delaunay3}
 ## @end deftypefn
 
 function h = trimesh (tri, x, y, z, varargin)
 
   if (nargin < 3)
     print_usage ();
diff --git a/scripts/geometry/triplot.m b/scripts/geometry/triplot.m
--- a/scripts/geometry/triplot.m
+++ b/scripts/geometry/triplot.m
@@ -15,20 +15,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} triplot (@var{tri}, @var{x}, @var{y})
 ## @deftypefnx {Function File} {} triplot (@var{tri}, @var{x}, @var{y}, @var{linespec})
 ## @deftypefnx {Function File} {@var{h} =} triplot (@dots{})
-## Plot a triangular mesh in 2D. The variable @var{tri} is the triangular
+## Plot a triangular mesh in 2D.  The variable @var{tri} is the triangular
 ## meshing of the points @code{(@var{x}, @var{y})} which is returned from
-## @code{delaunay}. If given, the @var{linespec} determines the properties
-## to use for the lines. The output argument @var{h} is the graphic handle
+## @code{delaunay}.  If given, the @var{linespec} determines the properties
+## to use for the lines.  The output argument @var{h} is the graphic handle
 ## to the plot.
 ## @seealso{plot, trimesh, delaunay}
 ## @end deftypefn
 
 function h = triplot (tri, x, y, varargin)
 
   if (nargin < 3)
     print_usage ();
diff --git a/scripts/geometry/tsearchn.m b/scripts/geometry/tsearchn.m
--- a/scripts/geometry/tsearchn.m
+++ b/scripts/geometry/tsearchn.m
@@ -13,19 +13,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{idx}, @var{p}] =} tsearchn (@var{x}, @var{t}, @var{xi})
-## Searches for the enclosing Delaunay convex hull. For @code{@var{t} =
+## Searches for the enclosing Delaunay convex hull.  For @code{@var{t} =
 ## delaunayn (@var{x})}, finds the index in @var{t} containing the
-## points @var{xi}. For points outside the convex hull, @var{idx} is NaN.
+## points @var{xi}.  For points outside the convex hull, @var{idx} is NaN.
 ## If requested @code{tsearchn} also returns the barycentric coordinates @var{p}
 ## of the enclosing triangles.
 ## @seealso{delaunay, delaunayn}
 ## @end deftypefn
 
 function [idx, p] = tsearchn (x, t, xi)
   if (nargin != 3)
     print_usage ();
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} voronoi (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} voronoi (@var{x}, @var{y}, "plotstyle")
 ## @deftypefnx {Function File} {} voronoi (@var{x}, @var{y}, "plotstyle", @var{options})
 ## @deftypefnx {Function File} {[@var{vx}, @var{vy}] =} voronoi (@dots{})
 ## plots voronoi diagram of points @code{(@var{x}, @var{y})}.
 ## The voronoi facets with points at infinity are not drawn.
-## [@var{vx}, @var{vy}] = voronoi(...) returns the vertices instead of plotting the
+## [@var{vx}, @var{vy}] = voronoi(@dots{}) returns the vertices instead of plotting the
 ## diagram. plot (@var{vx}, @var{vy}) shows the voronoi diagram.
 ##
 ## A fourth optional argument, which must be a string, contains extra options
 ## passed to the underlying qhull command.  See the documentation for the
 ## Qhull library for details.
 ##
 ## @example
 ## @group
diff --git a/scripts/geometry/voronoin.m b/scripts/geometry/voronoin.m
--- a/scripts/geometry/voronoin.m
+++ b/scripts/geometry/voronoin.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{C}, @var{F}] =} voronoin (@var{pts})
 ## @deftypefnx {Function File} {[@var{C}, @var{F}] =} voronoin (@var{pts}, @var{options})
 ## computes n- dimensional voronoi facets.  The input matrix @var{pts}
 ## of size [n, dim] contains n points of dimension dim.
-## @var{C} contains the points of the voronoi facets. The list @var{F}
+## @var{C} contains the points of the voronoi facets.  The list @var{F}
 ## contains for each facet the indices of the voronoi points.
 ##
 ## A second optional argument, which must be a string, contains extra options
 ## passed to the underlying qhull command.  See the documentation for the
 ## Qhull library for details.
 ## @seealso{voronoin, delaunay, convhull}
 ## @end deftypefn
 
diff --git a/scripts/help/gen_doc_cache.m b/scripts/help/gen_doc_cache.m
--- a/scripts/help/gen_doc_cache.m
+++ b/scripts/help/gen_doc_cache.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009 Sren Hauberg
+## Copyright (C) 2009 Sren Hauberg
 ##
 ## This program is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -13,17 +13,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with this program; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} gen_doc_cache (@var{out_file}, @var{directory})
 ## Generate documentation caches for all functions in a given directory.
 ##
-## A documentation cache is generated for all functions in @var{directory}. The
+## A documentation cache is generated for all functions in @var{directory}.  The
 ## resulting cache is saved in the file @var{out_file}.
 ## The cache is used to speed up @code{lookfor}.
 ##
 ## If no directory is given (or it is the empty matrix), a cache for builtin
 ## operators, etc. is generated.
 ##
 ## @seealso{lookfor, path}
 ## @end deftypefn
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009 Sren Hauberg
+## Copyright (C) 2009 Sren Hauberg
 ##
 ## This program is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -14,30 +14,32 @@
 ## along with this program; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{retval}, @var{status}] =} get_first_help_sentence (@var{name}, @var{max_len})
 ## Return the first sentence of a function help text.
 ##
 ## The function reads the first sentence of the help text of the function
-## @var{name}. The first sentence is defined as the text after the function
+## @var{name}.  The first sentence is defined as the text after the function
 ## declaration until either the first period (".") or the first appearance of
-## two consecutive end-lines ("\n\n"). The text is truncated to a maximum length
+## two consecutive end-lines ("\n\n").  The text is truncated to a maximum length
 ## of @var{max_len}, which defaults to 80.
 ##
 ## The optional output argument @var{status} returns the status reported by
-## @code{makeinfo}. If only one output argument is requested, and @var{status}
+## @code{makeinfo}.  If only one output argument is requested, and @var{status}
 ## is non-zero, a warning is displayed.
 ##
 ## As an example, the first sentence of this help text is
 ##
 ## @example
+## @group
 ## get_first_help_sentence ("get_first_help_sentence")
 ## @print{} ans = Return the first sentence of a function help text.
+## @end group
 ## @end example
 ## @end deftypefn
 
 function [retval, status] = get_first_help_sentence (name, max_len = 80)
   ## Check input
   if (nargin == 0)
     error ("get_first_help_sentence: not enough input arguments");
   endif
diff --git a/scripts/image/autumn.m b/scripts/image/autumn.m
--- a/scripts/image/autumn.m
+++ b/scripts/image/autumn.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} autumn (@var{n})
-## Create color colormap. This colormap is red through orange to yellow.
+## Create color colormap.  This colormap is red through orange to yellow.
 ## The argument @var{n} should be a scalar.  If it
 ## is omitted, the length of the current colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = autumn (number)
diff --git a/scripts/image/bone.m b/scripts/image/bone.m
--- a/scripts/image/bone.m
+++ b/scripts/image/bone.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} bone (@var{n})
-## Create color colormap. This colormap is a gray colormap with a light 
-## blue tone. The argument @var{n} should be a scalar.  If it
+## Create color colormap.  This colormap is a gray colormap with a light 
+## blue tone.  The argument @var{n} should be a scalar.  If it
 ## is omitted, the length of the current colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = bone (number)
 
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
--- a/scripts/image/brighten.m
+++ b/scripts/image/brighten.m
@@ -15,18 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{map_out} =} brighten (@var{map}, @var{beta})
 ## @deftypefnx {Function File} {@var{map_out} =} brighten (@var{h}, @var{beta})
 ## @deftypefnx {Function File} {@var{map_out} =} brighten (@var{beta})
-## Darkens or brightens the given colormap. If the @var{map} argument 
-## is omitted, the function is applied to the current colormap. The first
+## Darkens or brightens the given colormap.  If the @var{map} argument 
+## is omitted, the function is applied to the current colormap.  The first
 ## argument can also be a valid graphics handle @var{h}, in which case 
 ## @code{brighten} is applied to the colormap associated with this handle.
 ##
 ## Should the resulting colormap @var{map_out} not be assigned, it will be
 ## written to the current colormap.
 ##
 ## The argument @var{beta} should be a scalar between -1 and 1,
 ## where a negative value darkens and a positive value brightens
diff --git a/scripts/image/contrast.m b/scripts/image/contrast.m
--- a/scripts/image/contrast.m
+++ b/scripts/image/contrast.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} contrast (@var{x}, @var{n})
-## Return a gray colormap that maximizes the contrast in an image. The
-## returned colormap will have @var{n} rows. If @var{n} is not defined
+## Return a gray colormap that maximizes the contrast in an image.  The
+## returned colormap will have @var{n} rows.  If @var{n} is not defined
 ## then the size of the current colormap is used instead.
 ## @seealso{colormap}
 ## @end deftypefn
 
 function map = contrast (x, n)
 
   if (nargin == 1)
     n = rows (colormap);
diff --git a/scripts/image/cool.m b/scripts/image/cool.m
--- a/scripts/image/cool.m
+++ b/scripts/image/cool.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cool (@var{n})
-## Create color colormap. The colormap is cyan to magenta. The argument 
+## Create color colormap.  The colormap is cyan to magenta.  The argument 
 ## @var{n} should be a scalar.  If it is omitted, the length of the current
 ## colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = cool (number)
diff --git a/scripts/image/copper.m b/scripts/image/copper.m
--- a/scripts/image/copper.m
+++ b/scripts/image/copper.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} copper (@var{n})
-## Create color colormap. This colormap is black to a light copper tone.
+## Create color colormap.  This colormap is black to a light copper tone.
 ## The argument @var{n} should be a scalar.  If it
 ## is omitted, the length of the current colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = copper (number)
diff --git a/scripts/image/flag.m b/scripts/image/flag.m
--- a/scripts/image/flag.m
+++ b/scripts/image/flag.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} flag (@var{n})
-## Create color colormap. This colormap cycles through red, white, blue 
-## and black. The argument @var{n} should be a scalar.  If it
+## Create color colormap.  This colormap cycles through red, white, blue 
+## and black.  The argument @var{n} should be a scalar.  If it
 ## is omitted, the length of the current colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 ## flag(number) gives a colormap consists of red, white, blue and black
 ## changing with each index
diff --git a/scripts/image/gmap40.m b/scripts/image/gmap40.m
--- a/scripts/image/gmap40.m
+++ b/scripts/image/gmap40.m
@@ -13,21 +13,21 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} gmap40 (@var{n})
-## Create a color colormap. The colormap is red, green, blue, yellow,
-## magenta and cyan. These are the colors that are allowed with patch
+## Create a color colormap.  The colormap is red, green, blue, yellow,
+## magenta and cyan.  These are the colors that are allowed with patch
 ## objects using gnuplot 4.0, and so this colormap function is specially
 ## designed for users of gnuplot 4.0.  The argument @var{n} should be 
-## a scalar.  If it is omitted, a length of 6 is assumed. Larger values
+## a scalar.  If it is omitted, a length of 6 is assumed.  Larger values
 ## of @var{n} result in a repetition of the above colors
 ## @seealso{colormap}
 ## @end deftypefn
 
 function map = gmap40 (number)
 
   if (nargin == 0)
     number = 6;
diff --git a/scripts/image/gray2ind.m b/scripts/image/gray2ind.m
--- a/scripts/image/gray2ind.m
+++ b/scripts/image/gray2ind.m
@@ -15,17 +15,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{img}, @var{map}] =} gray2ind (@var{I}, @var{n})
 ## Convert a gray scale intensity image to an Octave indexed image.
-## The indexed image will consist of @var{n} different intensity values. If not
+## The indexed image will consist of @var{n} different intensity values.  If not
 ## given @var{n} will default to 64.
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [X, map] = gray2ind (I, n = 64)
diff --git a/scripts/image/hot.m b/scripts/image/hot.m
--- a/scripts/image/hot.m
+++ b/scripts/image/hot.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hot (@var{n})
-## Create color colormap. This colormap is black through dark red, red, 
-## orange, yellow to white. The argument @var{n} should be a scalar.  If it
+## Create color colormap.  This colormap is black through dark red, red, 
+## orange, yellow to white.  The argument @var{n} should be a scalar.  If it
 ## is omitted, the length of the current colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = hot (number)
 
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -25,17 +25,17 @@
 ## extremes of @var{x} are mapped to the extremes of the colormap.
 ##
 ## It first tries to use @code{gnuplot}, then @code{display} from 
 ## @code{ImageMagick}, then @code{xv}, and then @code{xloadimage}.
 ## The actual program used can be changed using the @code{image_viewer}
 ## function.
 ##
 ## The axis values corresponding to the matrix elements are specified in
-## @var{x} and @var{y}. If you're not using gnuplot 4.2 or later, these
+## @var{x} and @var{y}.  If you're not using gnuplot 4.2 or later, these
 ## variables are ignored.
 ## @seealso{imshow, imagesc, colormap, image_viewer}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/image/image_viewer.m b/scripts/image/image_viewer.m
--- a/scripts/image/image_viewer.m
+++ b/scripts/image/image_viewer.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006, 2007, 2008 Sren Hauberg
+## Copyright (C) 2006, 2007, 2008 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -26,17 +26,17 @@
 ## is to use gnuplot if the installed version supports image viewing,
 ## and otherwise try the programs @code{display}, @code{xv}, and
 ## @code{xloadimage}.  Using this function it is possible to change that
 ## behaviour.
 ##
 ## When called with one input argument images will be displayed by saving
 ## the image to a file and the system command @var{command} will be called
 ## to view the image.  The @var{command} must be a string containing
-## @code{%s} and possibly @code{%f}. The @code{%s} will be replaced by
+## @code{%s} and possibly @code{%f}.  The @code{%s} will be replaced by
 ## the filename of the image, and the @code{%f} will (if present) be
 ## replaced by the zoom factor given to the @code{image} function.
 ## For example,
 ## @example
 ## image_viewer ("eog %s");
 ## @end example
 ## changes the image viewer to the @code{eog} program.
 ##
@@ -51,17 +51,17 @@
 ## my_image_viewer (@var{x}, @var{y}, @var{im}, @var{zoom}, @var{data})
 ## @end example
 ## where @var{x} and @var{y} are the axis of the image, @var{im} is the image
 ## variable, and @var{data} is extra user-supplied data to be passed to
 ## the viewer function.
 ##
 ## With three input arguments it is possible to change the zooming.
 ## Some programs (like @code{xloadimage}) require the zoom factor to be
-## between 0 and 100, and not 0 and 1 like Octave assumes. This is
+## between 0 and 100, and not 0 and 1 like Octave assumes.  This is
 ## solved by setting the third argument to 100.
 ##
 ## @seealso{image, imshow}
 ## @end deftypefn
 
 function [ocmd, ofcn, ozoom] = image_viewer (cmd, fcn, zoom)
 
   persistent view_cmd;
diff --git a/scripts/image/imfinfo.m b/scripts/image/imfinfo.m
--- a/scripts/image/imfinfo.m
+++ b/scripts/image/imfinfo.m
@@ -17,69 +17,69 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{info} =} imfinfo (@var{filename})
 ## @deftypefnx{Function File} {@var{info} =} imfinfo (@var{url})
 ## Read image information from a file.
 ##
 ## @code{imfinfo} returns a structure containing information about the image
-## stored in the file @var{filename}. The output structure contains the
+## stored in the file @var{filename}.  The output structure contains the
 ## following fields.
 ##
 ## @table @samp
 ## @item Filename
 ## The full name of the image file.
 ## @item FileSize
 ## Number of bytes of the image on disk
 ## @item FileModDate
 ## Date of last modification to the file.
 ## @item Height
 ## Image height in pixels.
 ## @item Width
 ## Image Width in pixels.
 ## @item BitDepth
 ## Number of bits per channel per pixel.
 ## @item Format
-## Image format (e.g. @code{"jpeg"}).
+## Image format (e.g., @code{"jpeg"}).
 ## @item LongFormat
 ## Long form image format description.
 ## @item XResolution
 ## X resolution of the image.
 ## @item YResolution
 ## Y resolution of the image.
 ## @item TotalColors
 ## Number of unique colors in the image.
 ## @item TileName
 ## Tile name.
 ## @item AnimationDelay
 ## Time in 1/100ths of a second (0 to 65535) which must expire before displaying
 ## the next image in an animated sequence.
 ## @item AnimationIterations
-## Number of iterations to loop an animation (e.g. Netscape loop extension) for.
+## Number of iterations to loop an animation (e.g., Netscape loop extension) for.
 ## @item ByteOrder
-## Endian option for formats that support it. Is either @code{"little-endian"},
+## Endian option for formats that support it.  Is either @code{"little-endian"},
 ## @code{"big-endian"}, or @code{"undefined"}.
 ## @item Gamma
-## Gamma level of the image. The same color image displayed on two different
-## workstations  may  look  different due to differences in the display monitor.
+## Gamma level of the image.  The same color image displayed on two different
+## workstations may look different due to differences in the display monitor.
 ## @item Matte
 ## @code{true} if the image has transparency.
 ## @item ModulusDepth
 ## Image modulus depth (minimum number of bits required to support red/green/blue
 ## components without loss of accuracy).
 ## @item Quality
 ## JPEG/MIFF/PNG compression level.
 ## @item QuantizeColors
 ## Preferred number of colors in the image.
 ## @item ResolutionUnits
-## Units of image resolution. Is either @code{"pixels per inch"},
+## Units of image resolution.  Is either @code{"pixels per inch"},
 ## @code{"pixels per centimeter"}, or @code{"undefined"}.
 ## @item ColorType
-## Image type. Is either @code{"grayscale"}, @code{"indexed"}, @code{"truecolor"},
+## Image type.  Is either @code{"grayscale"}, @code{"indexed"}, @code{"truecolor"},
 ## or @code{"undefined"}.
 ## @item View
 ## FlashPix viewing parameters.
 ## @end table
 ##
 ## @seealso{imread, imwrite}
 ## @end deftypefn
 
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -35,17 +35,17 @@
 ##
 ## If @var{map} is a valid color map, the image will be shown as an indexed
 ## image using the supplied color map.
 ##
 ## If a file name is given instead of an image, the file will be read and
 ## shown.
 ##
 ## If given, the parameter @var{string_param1} has value
-## @var{value1}. @var{string_param1} can be any of the following:
+## @var{value1}.  @var{string_param1} can be any of the following:
 ## @table @samp
 ## @item "displayrange"
 ## @var{value1} is the display range as described above.
 ## @end table
 ## @seealso{image, imagesc, colormap, gray2ind, rgb2ind}
 ## @end deftypefn
 
 ## Author: Stefan van der Walt  <stefan@sun.ac.za>
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -19,22 +19,22 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} imwrite (@var{img}, @var{filename}, @var{fmt}, @var{p1}, @var{v1}, @dots{})
 ## @deftypefnx {Function File} {} imwrite (@var{img}, @var{map}, @var{filename}, @var{fmt}, @var{p1}, @var{v1}, @dots{})
 ## Write images in various file formats.
 ##
 ## If @var{fmt} is missing, the file extension (if any) of
 ## @var{filename} is used to determine the format.
 ##
-## The parameter-value pairs (@var{p1}, @var{v1}, @dots{}) are optional. Currently
+## The parameter-value pairs (@var{p1}, @var{v1}, @dots{}) are optional.  Currently
 ## the following options are supported for @t{JPEG} images
 ##
 ## @table @samp
 ## @item Quality
-## Sets the quality of the compression. The corresponding value should be an
+## Sets the quality of the compression.  The corresponding value should be an
 ## integer between 0 and 100, with larger values meaning higher visual quality
 ## and less compression.
 ## @end table
 ##
 ## @seealso{imread, imfinfo}
 ## @end deftypefn
 
 function imwrite (varargin)
diff --git a/scripts/image/jet.m b/scripts/image/jet.m
--- a/scripts/image/jet.m
+++ b/scripts/image/jet.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} jet (@var{n})
-## Create color colormap. This colormap is dark blue through blue, cyan, 
-## green, yellow, red to dark red. The argument @var{n} should be a scalar. 
+## Create color colormap.  This colormap is dark blue through blue, cyan, 
+## green, yellow, red to dark red.  The argument @var{n} should be a scalar. 
 ## If it is omitted, the length of the current colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = jet (number)
 
diff --git a/scripts/image/prism.m b/scripts/image/prism.m
--- a/scripts/image/prism.m
+++ b/scripts/image/prism.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} prism (@var{n})
-## Create color colormap. This colormap cycles trough red, orange, yellow,
-## green, blue and violet. The argument @var{n} should be a scalar.  If it
+## Create color colormap.  This colormap cycles trough red, orange, yellow,
+## green, blue and violet.  The argument @var{n} should be a scalar.  If it
 ## is omitted, the length of the current colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = prism (number)
 
diff --git a/scripts/image/rainbow.m b/scripts/image/rainbow.m
--- a/scripts/image/rainbow.m
+++ b/scripts/image/rainbow.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rainbow (@var{n})
-## Create color colormap. This colormap is red through orange, yellow, green, 
-## blue to violet. The argument @var{n} should be a scalar.  If it
+## Create color colormap.  This colormap is red through orange, yellow, green, 
+## blue to violet.  The argument @var{n} should be a scalar.  If it
 ## is omitted, the length of the current colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = rainbow (number)
 ## this colormap is not part of matlab, it is like the prism
diff --git a/scripts/image/spring.m b/scripts/image/spring.m
--- a/scripts/image/spring.m
+++ b/scripts/image/spring.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} spring (@var{n})
-## Create color colormap. This colormap is magenta to yellow.
+## Create color colormap.  This colormap is magenta to yellow.
 ## The argument @var{n} should be a scalar.  If it
 ## is omitted, the length of the current colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = spring (number)
diff --git a/scripts/image/summer.m b/scripts/image/summer.m
--- a/scripts/image/summer.m
+++ b/scripts/image/summer.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} summer (@var{n})
-## Create color colormap. This colormap is green to yellow.
+## Create color colormap.  This colormap is green to yellow.
 ## The argument @var{n} should be a scalar.  If it
 ## is omitted, the length of the current colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Date:  06/03/2000
 function map = summer (number)
diff --git a/scripts/image/winter.m b/scripts/image/winter.m
--- a/scripts/image/winter.m
+++ b/scripts/image/winter.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} winter (@var{n})
-## Create color colormap. This colormap is blue to green.
+## Create color colormap.  This colormap is blue to green.
 ## The argument @var{n} should be a scalar.  If it
 ## is omitted, the length of the current colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = winter (number)
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -13,19 +13,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dlmwrite (@var{file}, @var{a})
-## @deftypefnx {Function File} {} dmlwrite (@var{file}, @var{a}, @var{delim}, @var{r}, @var{c})
-## @deftypefnx {Function File} {} dmlwrite (@var{file}, @var{a}, @var{key}, @var{val} @dots{})
-## @deftypefnx {Function File} {} dmlwrite (@var{file}, @var{a}, "-append", @dots{})
+## @deftypefnx {Function File} {} dlmwrite (@var{file}, @var{a}, @var{delim}, @var{r}, @var{c})
+## @deftypefnx {Function File} {} dlmwrite (@var{file}, @var{a}, @var{key}, @var{val} @dots{})
+## @deftypefnx {Function File} {} dlmwrite (@var{file}, @var{a}, "-append", @dots{})
 ## Write the matrix @var{a} to the named file using delimiters.
 ##
 ## The parameter @var{delim} specifies the delimiter to use to separate
 ## values on a row.
 ##
 ## The value of @var{r} specifies the number of delimiter-only lines to
 ## add to the start of the file.
 ##
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -14,20 +14,20 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cond (@var{a},@var{p})
-## Compute the @var{p}-norm condition number of a matrix. @code{cond (@var{a})} is
+## Compute the @var{p}-norm condition number of a matrix.  @code{cond (@var{a})} is
 ## defined as @code{norm (@var{a}, @var{p}) * norm (inv (@var{a}), @var{p})}.
 ## By default @code{@var{p}=2} is used which implies a (relatively slow)
-## singular value decomposition. Other possible selections are 
+## singular value decomposition.  Other possible selections are 
 ## @code{@var{p}= 1, Inf, inf, 'Inf', 'fro'} which are generally faster.
 ## @seealso{norm, inv, det, svd, rank}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = cond (a, p)
 
diff --git a/scripts/linear-algebra/condest.m b/scripts/linear-algebra/condest.m
--- a/scripts/linear-algebra/condest.m
+++ b/scripts/linear-algebra/condest.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File} {[@var{est}, @var{v}] =} condest (@var{a}, @var{t}) 
 ## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@var{a}, @var{solve}, @var{solve_t}, @var{t})
 ## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@var{apply}, @var{apply_t}, @var{solve}, @var{solve_t}, @var{n}, @var{t})
 ##
 ## Estimate the 1-norm condition number of a matrix @var{A}
 ## using @var{t} test vectors using a randomized 1-norm estimator.
 ## If @var{t} exceeds 5, then only 5 test vectors are used.
 ##
-## If the matrix is not explicit, e.g. when  estimating the condition 
+## If the matrix is not explicit, e.g., when estimating the condition 
 ## number of @var{a} given an LU factorization, @code{condest} uses the 
 ## following functions:
 ##
 ## @table @var
 ## @item apply
 ## @code{A*x} for a matrix @code{x} of size @var{n} by @var{t}.
 ## @item apply_t
 ## @code{A'*x} for a matrix @code{x} of size @var{n} by @var{t}.
@@ -42,17 +42,17 @@
 ##
 ## The implicit version requires an explicit dimension @var{n}.
 ##
 ## @code{condest} uses a randomized algorithm to approximate
 ## the 1-norms.
 ##
 ## @code{condest} returns the 1-norm condition estimate @var{est} and
 ## a vector @var{v} satisfying @code{norm (A*v, 1) == norm (A, 1) * norm
-## (@var{v}, 1) / @var{est}}. When @var{est} is large, @var{v} is an
+## (@var{v}, 1) / @var{est}}.  When @var{est} is large, @var{v} is an
 ## approximate null vector.
 ##
 ## References: 
 ## @itemize
 ## @item Nicholas J. Higham and Franoise Tisseur, "A Block Algorithm
 ## for Matrix 1-Norm Estimation, with an Application to 1-Norm
 ## Pseudospectra." SIMAX vol 21, no 4, pp 1185-1201.
 ## @url{http://dx.doi.org/10.1137/S0895479899356080}
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -25,17 +25,17 @@
 ## @example
 ## @group
 ## cross ([1,1,0], [0,1,1])
 ##      @result{} [ 1; -1; 1 ]
 ## @end group
 ## @end example
 ##
 ## If @var{x} and @var{y} are matrices, the cross product is applied 
-## along the first dimension with 3 elements. The optional argument 
+## along the first dimension with 3 elements.  The optional argument 
 ## @var{dim} is used to force the cross product to be calculated along
 ## the dimension defined by @var{dim}.
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 15 October 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/linear-algebra/dot.m b/scripts/linear-algebra/dot.m
--- a/scripts/linear-algebra/dot.m
+++ b/scripts/linear-algebra/dot.m
@@ -14,19 +14,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dot (@var{x}, @var{y}, @var{dim})
-## Computes the dot product of two vectors. If @var{x} and @var{y}
+## Computes the dot product of two vectors.  If @var{x} and @var{y}
 ## are matrices, calculate the dot-product along the first 
-## non-singleton dimension. If the optional argument @var{dim} is
+## non-singleton dimension.  If the optional argument @var{dim} is
 ## given, calculate the dot-product along this dimension.
 ## @end deftypefn
 
 ## Author: jwe
 
 function z = dot (x, y, dim)
 
   if (nargin != 2 && nargin != 3)
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -17,17 +17,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{u}, @var{h}, @var{nu}] =} krylov (@var{a}, @var{v}, @var{k}, @var{eps1}, @var{pflg})
 ## Construct an orthogonal basis @var{u} of block Krylov subspace
 ##
 ## @example
-## [v a*v a^2*v ... a^(k+1)*v]
+## [v a*v a^2*v @dots{} a^(k+1)*v]
 ## @end example
 ##
 ## @noindent
 ## Using Householder reflections to guard against loss of orthogonality.
 ##
 ## If @var{v} is a vector, then @var{h} contains the Hessenberg matrix
 ## such that @code{a*u == u*h+rk*ek'}, in which @code{rk =
 ## a*u(:,k)-u*h(:,k)}, and @code{ek'} is the vector
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -16,24 +16,24 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{est}, @var{v}, @var{w}, @var{iter}] =} onenormest (@var{a}, @var{t}) 
 ## @deftypefnx {Function File} {[@var{est}, @var{v}, @var{w}, @var{iter}] =} onenormest (@var{apply}, @var{apply_t}, @var{n}, @var{t})
 ##
 ## Apply Higham and Tisseur's randomized block 1-norm estimator to
-## matrix @var{a} using @var{t} test vectors. If @var{t} exceeds 5, then
+## matrix @var{a} using @var{t} test vectors.  If @var{t} exceeds 5, then
 ## only 5 test vectors are used.
 ##
-## If the matrix is not explicit, e.g. when estimating the norm of 
+## If the matrix is not explicit, e.g., when estimating the norm of 
 ## @code{inv (@var{A})} given an LU factorization, @code{onenormest} applies 
 ## @var{A} and its conjugate transpose through a pair of functions 
 ## @var{apply} and @var{apply_t}, respectively, to a dense matrix of size 
-## @var{n} by @var{t}. The implicit version requires an explicit dimension 
+## @var{n} by @var{t}.  The implicit version requires an explicit dimension 
 ## @var{n}.
 ##
 ## Returns the norm estimate @var{est}, two vectors @var{v} and
 ## @var{w} related by norm
 ## @code{(@var{w}, 1) = @var{est} * norm (@var{v}, 1)},
 ## and the number of iterations @var{iter}.  The number of
 ## iterations is limited to 10 and is at least 2.
 ##
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -15,17 +15,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rank (@var{a}, @var{tol})
 ## Compute the rank of @var{a}, using the singular value decomposition.
-## The rank is taken to be the number  of singular values of @var{a} that
+## The rank is taken to be the number of singular values of @var{a} that
 ## are greater than the specified tolerance @var{tol}.  If the second
 ## argument is omitted, it is taken to be
 ##
 ## @example
 ## tol = max (size (@var{a})) * sigma(1) * eps;
 ## @end example
 ##
 ## @noindent
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{r}, @var{k}] =} rref (@var{a}, @var{tol})
 ##
-## Returns the reduced row echelon form of @var{a}. @var{tol} defaults
+## Returns the reduced row echelon form of @var{a}.  @var{tol} defaults
 ## to @code{eps * max (size (@var{a})) * norm (@var{a}, inf)}.
 ##
 ## Called with two return arguments, @var{k} returns the vector of
 ## "bound variables", which are those columns on which elimination 
 ## has been performed.
 ##
 ## @end deftypefn
 
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -27,17 +27,17 @@
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##  /   \
-##  | n |    n (n-1) (n-2) ... (n-k+1)
+##  | n |    n (n-1) (n-2) @dots{} (n-k+1)
 ##  |   |  = -------------------------
 ##  | k |               k!
 ##  \   /
 ## @end group
 ## @end example
 ## @end ifnottex
 ##
 ## For example,
diff --git a/scripts/miscellaneous/bunzip2.m b/scripts/miscellaneous/bunzip2.m
--- a/scripts/miscellaneous/bunzip2.m
+++ b/scripts/miscellaneous/bunzip2.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} bunzip2 (@var{bzfile}, @var{dir})
-## Unpack the bzip2 archive @var{bzfile} to the directory @var{dir}. If
+## Unpack the bzip2 archive @var{bzfile} to the directory @var{dir}.  If
 ## @var{dir} is not specified, it defaults to the current directory.
 ## @seealso{unpack, bzip2, tar, untar, gzip, gunzip, zip, unzip}
 ## @end deftypefn
 
 ## Author: Bill Denney <denney@seas.upenn.edu>
 
 function varargout = bunzip2 (files, outputdir)
 
diff --git a/scripts/miscellaneous/bzip2.m b/scripts/miscellaneous/bzip2.m
--- a/scripts/miscellaneous/bzip2.m
+++ b/scripts/miscellaneous/bzip2.m
@@ -17,17 +17,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{entries} =} bzip2 (@var{files})
 ## @deftypefnx {Function File} {@var{entries} =} bzip2 (@var{files}, @var{outdir})
 ## Compress the list of files specified in @var{files}.
 ## Each file is compressed separately and a new file with a '.bz2' extension
-## is created. The original files are not touched.  Existing compressed files 
+## is created.  The original files are not touched.  Existing compressed files 
 ## are silently overwritten.If @var{outdir} is defined the compressed versions 
 ## of the files are placed in this directory.
 ## @seealso{bunzip2, gzip, zip, tar}
 ## @end deftypefn
 
 function entries = bzip2 (varargin)
 
   if (nargin == 1 || nargin == 2)
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -17,21 +17,21 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} compare_versions (@var{v1}, @var{v2}, @var{operator})
 ## Compares to version strings using the given @var{operator}.
 ##
 ## This function assumes that versions @var{v1} and @var{v2} are
 ## arbitrarily long strings made of numeric and period characters
-## possibly followed by an arbitrary string (e.g. "1.2.3", "0.3",
+## possibly followed by an arbitrary string (e.g., "1.2.3", "0.3",
 ## "0.1.2+", or "1.2.3.4-test1").
 ##
 ## The version is first split into the numeric and the character parts
-## then the parts are padded to be the same length (i.e. "1.1" would be
+## then the parts are padded to be the same length (i.e., "1.1" would be
 ## padded to be like "1.1.0" when being compared with "1.1.1", and
 ## separately, the character parts of the strings are padded with
 ## nulls).
 ##
 ## The operator can be any logical operator from the set
 ##
 ## @itemize @bullet
 ## @item
@@ -53,17 +53,17 @@
 ## "!="
 ## not equal
 ## @item
 ## "~="
 ## not equal
 ## @end itemize
 ##
 ## Note that version "1.1-test2" would compare as greater than
-## "1.1-test10". Also, since the numeric part is compared first, "a"
+## "1.1-test10".  Also, since the numeric part is compared first, "a"
 ## compares less than "1a" because the second string starts with a
 ## numeric part even though double("a") is greater than double("1").
 ## @end deftypefn
 
 ## Author: Bill Denney <denney@seas.upenn.edu>
 
 ## FIXME?: This allows a single equal sign "=" to indicate equality, do
 ## we want to require a double equal since that is the boolean operator?
diff --git a/scripts/miscellaneous/copyfile.m b/scripts/miscellaneous/copyfile.m
--- a/scripts/miscellaneous/copyfile.m
+++ b/scripts/miscellaneous/copyfile.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{status}, @var{msg}, @var{msgid}] =} copyfile (@var{f1}, @var{f2}, @var{force})
 ## Copy the file @var{f1} to the new name @var{f2}.  The name @var{f1}
 ## may contain globbing patterns.  If @var{f1} expands to multiple file
-## names, @var{f2} must be a directory. If @var{force} is given and equals
+## names, @var{f2} must be a directory.  If @var{force} is given and equals
 ## the string "f" the copy operation will be forced.
 ##
 ## If successful, @var{status} is 1, with @var{msg} and @var{msgid} empty\n\
 ## character strings.  Otherwise, @var{status} is 0, @var{msg} contains a\n\
 ## system-dependent error message, and @var{msgid} contains a unique\n\
 ## message identifier.\n\
 ## @seealso{glob, movefile}
 ## @end deftypefn
diff --git a/scripts/miscellaneous/debug.m b/scripts/miscellaneous/debug.m
--- a/scripts/miscellaneous/debug.m
+++ b/scripts/miscellaneous/debug.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} debug ()
-## Summary of the debugging commands. The debugging commands that are
+## Summary of the debugging commands.  The debugging commands that are
 ## available in Octave are
 ##
 ## @table @code
 ## @item keyboard
 ## Force entry into debug mode.
 ##
 ## @item dbstop
 ## Add a breakpoint.
@@ -64,17 +64,17 @@
 ##
 ## @item debug_on_interrupt
 ## Flag whether to enter debug mode in case Octave encounters an interupt.
 ## 
 ## @end table
 ##
 ## @noindent
 ## when Octave encounters a breakpoint or other reason to enter debug
-## mode, the prompt changes to @code{"debug>"}. The workspace of the function
+## mode, the prompt changes to @code{"debug>"}.  The workspace of the function
 ## where the breakpoint was encountered becomes available and any Octave
 ## command that works within that workspace may be executed.
 ##
 ## @seealso{dbstop, dbclear, dbstatus, dbcont, dbstack, dbstep, dbtype,
 ## dbup, dbdown, dbquit, debug_on_error, debug_on_warning,
 ## debug_on_interrupt}
 ## @end deftypefn
 
diff --git a/scripts/miscellaneous/flops.m b/scripts/miscellaneous/flops.m
--- a/scripts/miscellaneous/flops.m
+++ b/scripts/miscellaneous/flops.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} flops ()
-## This function is provided for @sc{Matlab} compatibility, but it doesn't
+## This function is provided for @sc{matlab} compatibility, but it doesn't
 ## actually do anything.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = flops ()
 
   if (nargin > 1)
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -27,18 +27,20 @@
 ## @result{} ans = 5
 ## @end group
 ## @end example
 ##
 ## Note that the function call in the previous example is equivalent to
 ## the expression
 ##
 ## @example
+## @group
 ## i1 = @{1,2@}; i2 = "fd"; i3 = @{3@}; i4= "b";
 ## ss(i1@{:@}).(i2)(i3@{:@}).(i4)
+## @end group
 ## @end example
 ## @seealso{setfield, rmfield, isfield, isstruct, fieldnames, struct}
 ## @end deftypefn
 
 ## Author: Etienne Grossmann <etienne@cs.uky.edu>
 
 function s = getfield (s, varargin)
 
diff --git a/scripts/miscellaneous/gunzip.m b/scripts/miscellaneous/gunzip.m
--- a/scripts/miscellaneous/gunzip.m
+++ b/scripts/miscellaneous/gunzip.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} gunzip (@var{gzfile}, @var{dir})
-## Unpack the gzip archive @var{gzfile} to the directory @var{dir}. If
-## @var{dir} is not specified, it defaults to the current directory. If
+## Unpack the gzip archive @var{gzfile} to the directory @var{dir}.  If
+## @var{dir} is not specified, it defaults to the current directory.  If
 ## the @var{gzfile} is a directory, all files in the directory will be
 ## recursively gunzipped.
 ## @seealso{unpack, bunzip2, tar, untar, gzip, gunzip, zip, unzip}
 ## @end deftypefn
 
 ## Author: Bill Denney <denney@seas.upenn.edu>
 
 function varargout = gunzip (files, outputdir)
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -16,18 +16,18 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{entries} =} gzip (@var{files})
 ## @deftypefnx {Function File} {@var{entries} =} gzip (@var{files}, @var{outdir})
 ## Compress the list of files and/or directories specified in @var{files}.
 ## Each file is compressed separately and a new file with a '.gz' extension
-## is created. The original files are not touched. Existing compressed
-## files are silently overwritten. If @var{outdir} is defined the compressed 
+## is created.  The original files are not touched.  Existing compressed
+## files are silently overwritten.  If @var{outdir} is defined the compressed 
 ## versions of the files are placed in this directory.
 ## @seealso{gunzip, bzip2, zip, tar}
 ## @end deftypefn
 
 function entries = gzip (varargin)
   if (nargin == 1 || nargin == 2) && (nargout <= 1)
     if nargout == 0
       __xzip__ ("gzip", "gz", "gzip -r %s", varargin{:});
diff --git a/scripts/miscellaneous/intwarning.m b/scripts/miscellaneous/intwarning.m
--- a/scripts/miscellaneous/intwarning.m
+++ b/scripts/miscellaneous/intwarning.m
@@ -53,19 +53,21 @@
 ## a structure array.
 ## @end table
 ##
 ## The original state of the integer warnings can be restored by passing
 ## the structure array returned by @code{intwarning} to a later call to
 ## @code{intwarning}.  For example
 ##
 ## @example
+## @group
 ## s = intwarning ("off");
 ## @dots{}
 ## intwarning (s);
+## @end group
 ## @end example
 ## @seealso{warning}
 ## @end deftypefn
 
 function y = intwarning (x)
 
   if (nargin != 1)
     print_usage ();
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -42,17 +42,17 @@
 ## @item "disable"
 ## Future tests for the specified license of @var{feature} return 0.
 ## @end table
 ##
 ## @deftypefnx {Function File} {@var{retval} =} license ("checkout", @var{feature})
 ## Check out a license for @var{feature}, returning 1 on success and 0
 ## on failure.
 ##
-## This function is provided for compatibility with @sc{Matlab}.
+## This function is provided for compatibility with @sc{matlab}.
 ## @seealso{ver, version}
 ## @end deftypefn
 
 ## Author: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
 function retval = license (varargin)
 
   persistent __octave_licenses__;
diff --git a/scripts/miscellaneous/ls.m b/scripts/miscellaneous/ls.m
--- a/scripts/miscellaneous/ls.m
+++ b/scripts/miscellaneous/ls.m
@@ -16,20 +16,22 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deffn {Command} ls options
 ## List directory contents.  For example,
 ## 
 ## @example
+## @group
 ## ls -l
 ##      @print{} total 12
 ##      @print{} -rw-r--r--   1 jwe  users  4488 Aug 19 04:02 foo.m
 ##      @print{} -rw-r--r--   1 jwe  users  1315 Aug 17 23:14 bar.m
+## @end group
 ## @end example
 ## 
 ## The @code{dir} and @code{ls} commands are implemented by calling your
 ## system's directory listing command, so the available options may vary
 ## from system to system.
 ## @seealso{dir, stat, readdir, glob, filesep, ls_command}
 ## @end deffn
 
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -59,16 +59,17 @@
 ## (or .mex if --mex is specified) unless linking
 ## a stand-alone executable.
 ##
 ## @item -p VAR
 ## @itemx --print VAR
 ## Print the configuration variable VAR.  Recognized variables are: 
 ##
 ## @example             
+## @group
 ##    ALL_CFLAGS                FFTW_LIBS     
 ##    ALL_CXXFLAGS              FLIBS       
 ##    ALL_FFLAGS                FPICFLAG      
 ##    ALL_LDFLAGS               INCFLAGS      
 ##    BLAS_LIBS                 LDFLAGS             
 ##    CC                        LD_CXX              
 ##    CFLAGS                    LD_STATIC_FLAG
 ##    CPICFLAG                  LFLAGS              
@@ -79,16 +80,17 @@
 ##    DEPEND_EXTRA_SED_PATTERN  LIBS        
 ##    DEPEND_FLAGS              OCTAVE_LIBS   
 ##    DL_LD                     RDYNAMIC_FLAG 
 ##    DL_LDFLAGS                RLD_FLAG      
 ##    F2C                       SED         
 ##    F2CFLAGS                  XTRA_CFLAGS   
 ##    F77                       XTRA_CXXFLAGS 
 ##    FFLAGS
+## @end group
 ## @end example
 ##
 ## @item --link-stand-alone
 ## Link a stand-alone executable file.
 ##
 ## @item --mex
 ## Assume we are creating a MEX file.  Set the default output extension 
 ## to ".mex".
@@ -97,26 +99,28 @@
 ## @itemx --strip
 ## Strip the output file.
 ##
 ## @item -v
 ## @itemx --verbose
 ## Echo commands as they are executed.
 ##
 ## @item file
-## The file to compile or link. Recognised file types are
+## The file to compile or link.  Recognised file types are
 ##
 ## @example
+## @group
 ##                   .c    C source
 ##                   .cc   C++ source
 ##                   .C    C++ source
 ##                   .cpp  C++ source
 ##                   .f    Fortran source
 ##                   .F    Fortran source
 ##                   .o    object file
+## @end group
 ## @end example
 ##
 ## @end table
 ## @end deftypefn
 
 function mkoctfile (varargin)
 
   bindir = octave_config_info ("bindir");
diff --git a/scripts/miscellaneous/namelengthmax.m b/scripts/miscellaneous/namelengthmax.m
--- a/scripts/miscellaneous/namelengthmax.m
+++ b/scripts/miscellaneous/namelengthmax.m
@@ -13,27 +13,27 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} namelengthmax ()
-## Returns the @sc{Matlab} compatible maximum variable name length.  Octave is
+## Returns the @sc{matlab} compatible maximum variable name length.  Octave is
 ## capable of storing strings up to 
 ## @iftex
 ## @tex
 ## $2^{31} - 1$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ## @code{2 ^ 31 - 1}
 ## @end ifnottex
-## in length.  However for @sc{Matlab} compatibility all variable, function
+## in length.  However for @sc{matlab} compatibility all variable, function
 ## and structure field names should be shorter than the length supplied by
-## @code{namelengthmax}.  In particular variables stored to a @sc{Matlab} file
+## @code{namelengthmax}.  In particular variables stored to a @sc{matlab} file
 ## format will have their names truncated to this length.
 ## @end deftypefn
 
 function n = namelengthmax ()
   n = 63;
 endfunction
diff --git a/scripts/miscellaneous/pack.m b/scripts/miscellaneous/pack.m
--- a/scripts/miscellaneous/pack.m
+++ b/scripts/miscellaneous/pack.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} pack ()
-## This function is provided for compatibility with @sc{Matlab}, but it
+## This function is provided for compatibility with @sc{matlab}, but it
 ## doesn't actually do anything.
 ## @end deftypefn
 
 ## Author: jwe
 
 function pack ()
 
 endfunction
diff --git a/scripts/miscellaneous/perl.m b/scripts/miscellaneous/perl.m
--- a/scripts/miscellaneous/perl.m
+++ b/scripts/miscellaneous/perl.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{output}, @var{status}] =} perl (@var{scriptfile})
-## @deftypefnx {Function File} {[@var{output}, @var{status}] =} perl (@var{scriptfile}, @var{argument1}, @var{argument2}, ...)
+## @deftypefnx {Function File} {[@var{output}, @var{status}] =} perl (@var{scriptfile}, @var{argument1}, @var{argument2}, @dots{})
 ## Invoke perl script @var{scriptfile} with possibly a list of
 ## command line arguments.
 ## Returns output in @var{output} and status
 ## in @var{status}.
 ## @seealso{system}
 ## @end deftypefn
 
 function [output, status] = perl (script = "-e ''", varargin)
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -27,18 +27,20 @@
 ## oo(1,2).fd(3).b == 6
 ## @result{} ans = 1
 ## @end group
 ## @end example
 ##
 ## Note that this function could be written
 ##
 ## @example
+## @group
 ## i1 = @{1,2@}; i2 = "fd"; i3 = @{3@}; i4 = "b";
 ## oo(i1@{:@}).(i2)(i3@{:@}).(i4) == 6;
+## @end group
 ## @end example
 ## @seealso{getfield, rmfield, isfield, isstruct, fieldnames, struct}
 ## @end deftypefn
 
 ## Author:  Etienne Grossmann <etienne@cs.uky.edu>
 
 function obj = setfield (obj, varargin)
    field = "obj";
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{files} =} unpack (@var{file}, @var{dir})
 ## @deftypefnx {Function File} {@var{files} =} unpack (@var{file}, @var{dir}, @var{filetype})
 ## Unpack the archive @var{file} based on its extension to the directory
 ## @var{dir}.  If @var{file} is a cellstr, then all files will be
 ## handled individually.  If @var{dir} is not specified, it defaults to
 ## the current directory.  It returns a list of @var{files}
-## unpacked. If a directory is in the file list, then the
+## unpacked.  If a directory is in the file list, then the
 ## @var{filetype} to unpack must also be specified.
 ##
 ## The @var{files} includes the entire path to the output files.
 ## @seealso{bunzip2, tar, untar, gzip, gunzip, zip, unzip}
 ## @end deftypefn
 
 ## Author: Bill Denney <denney@seas.upenn.edu>
 
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -30,77 +30,87 @@
 ## attempted.  By default, the @code{Octave:array-to-vector} warning is
 ## disabled.
 ## 
 ## @item Octave:assign-as-truth-value
 ## If the @code{Octave:assign-as-truth-value} warning is
 ## enabled, a warning is issued for statements like
 ## 
 ## @example
+## @group
 ## if (s = t)
 ##   @dots{}
+## @end group
 ## @end example
 ## 
 ## @noindent
 ## since such statements are not common, and it is likely that the intent
 ## was to write
 ## 
 ## @example
+## @group
 ## if (s == t)
 ##   @dots{}
+## @end group
 ## @end example
 ## 
 ## @noindent
 ## instead.
 ## 
 ## There are times when it is useful to write code that contains
 ## assignments within the condition of a @code{while} or @code{if}
 ## statement.  For example, statements like
 ## 
 ## @example
+## @group
 ## while (c = getc())
 ##   @dots{}
+## @end group
 ## @end example
 ## 
 ## @noindent
 ## are common in C programming.
 ## 
 ## It is possible to avoid all warnings about such statements by
 ## disabling the @code{Octave:assign-as-truth-value} warning,
 ## but that may also let real errors like
 ## 
 ## @example
+## @group
 ## if (x = 1)  # intended to test (x == 1)!
 ##   @dots{}
+## @end group
 ## @end example
 ## 
 ## @noindent
 ## slip by.
 ## 
 ## In such cases, it is possible suppress errors for specific statements by
 ## writing them with an extra set of parentheses.  For example, writing the
 ## previous example as
 ## 
 ## @example
+## @group
 ## while ((c = getc()))
 ##   @dots{}
+## @end group
 ## @end example
 ## 
 ## @noindent
 ## will prevent the warning from being printed for this statement, while
 ## allowing Octave to warn about other assignments used in conditional
 ## contexts.
 ## 
 ## By default, the @code{Octave:assign-as-truth-value} warning is enabled.
 ## 
 ## @item Octave:associativity-change
 ## If the @code{Octave:associativity-change} warning is
 ## enabled, Octave will warn about possible changes in the meaning of
 ## some code due to changes in associativity for some operators.
-## Associativity changes have typically been made for @sc{Matlab}
+## Associativity changes have typically been made for @sc{matlab}
 ## compatibility.  By default, the @code{Octave:associativity-change}
 ## warning is enabled.
 ## 
 ## @item Octave:divide-by-zero
 ## If the @code{Octave:divide-by-zero} warning is enabled, a
 ## warning is issued when Octave encounters a division by zero.  By
 ## default, the @code{Octave:divide-by-zero} warning is enabled.
 ## 
@@ -137,17 +147,17 @@
 ## 
 ## @item Octave:imag-to-real
 ## If the @code{Octave:imag-to-real} warning is enabled, a warning is
 ## printed for implicit conversions of complex numbers to real numbers.
 ## By default, the @code{Octave:imag-to-real} warning is disabled.
 ## 
 ## @item Octave:matlab-incompatible
 ## Print warnings for Octave language features that may cause
-## compatibility problems with @sc{Matlab}.
+## compatibility problems with @sc{matlab}.
 ## 
 ## @item Octave:missing-semicolon
 ## If the @code{Octave:missing-semicolon} warning is enabled, Octave
 ## will warn when statements in function definitions don't end in
 ## semicolons.  By default the @code{Octave:missing-semicolon} warning
 ## is disabled.
 ## 
 ## @item Octave:neg-dim-as-zero
@@ -175,17 +185,17 @@
 ## @end example
 ## elicits a warning if the @code{Octave:num-to-str} warning is
 ## enabled.  By default, the @code{Octave:num-to-str} warning is enabled.
 ## 
 ## @item Octave:precedence-change
 ## If the @code{Octave:precedence-change} warning is enabled, Octave
 ## will warn about possible changes in the meaning of some code due to
 ## changes in precedence for some operators.  Precedence changes have
-## typically been made for @sc{Matlab} compatibility.  By default, the
+## typically been made for @sc{matlab} compatibility.  By default, the
 ## @code{Octave:precedence-change} warning is enabled.
 ## 
 ## @item Octave:reload-forces-clear
 ## If several functions have been loaded from the same file, Octave must
 ## clear all the functions before any one of them can be reloaded.  If
 ## the @code{Octave:reload-forces-clear} warning is enabled, Octave will
 ## warn you when this happens, and print a list of the additional
 ## functions that it is forced to clear.  By default, the
diff --git a/scripts/miscellaneous/zip.m b/scripts/miscellaneous/zip.m
--- a/scripts/miscellaneous/zip.m
+++ b/scripts/miscellaneous/zip.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{entries} =} zip (@var{zipfile}, @var{files})
 ## @deftypefnx {Function File} {@var{entries} =} zip (@var{zipfile}, @var{files}, @var{rootdir})
 ## Compress the list of files and/or directories specified in @var{files} 
-## into the archive @var{zipfiles} in the same directory. If @var{rootdir} 
+## into the archive @var{zipfiles} in the same directory.  If @var{rootdir} 
 ## is defined the @var{files} is located relative to @var{rootdir} rather 
 ## than the current directory
 ## @seealso{unzip,tar}
 ## @end deftypefn
 
 ## Author: Sylvain Pelissier <sylvain.pelissier@gmail.com>
 
 function entries = zip (zipfile, files, rootdir)
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -18,55 +18,55 @@
 ##
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} {} fsolve (@var{fcn}, @var{x0}, @var{options})
 ## @deftypefnx{Function File} {[@var{x}, @var{fvec}, @var{info}, @var{output}, @var{fjac}]} = fsolve (@var{fcn}, @dots{})
 ## Solve a system of nonlinear equations defined by the function @var{fcn}.
 ## @var{fcn} should accepts a vector (array) defining the unknown variables,
-## and return a vector of left-hand sides of the equations. Right-hand sides
+## and return a vector of left-hand sides of the equations.  Right-hand sides
 ## are defined to be zeros.
 ## In other words, this function attempts to determine a vector @var{x} such 
 ## that @code{@var{fcn} (@var{x})} gives (approximately) all zeros.
-## @var{x0} determines a starting guess. The shape of @var{x0} is preserved
+## @var{x0} determines a starting guess.  The shape of @var{x0} is preserved
 ## in all calls to @var{fcn}, but otherwise it is treated as a column vector.
 ## @var{options} is a structure specifying additional options.
 ## Currently, @code{fsolve} recognizes these options:
 ## @code{"FunValCheck"}, @code{"OutputFcn"}, @code{"TolX"},
 ## @code{"TolFun"}, @code{"MaxIter"}, @code{"MaxFunEvals"}, 
 ## @code{"Jacobian"}, @code{"Updating"} and @code{"ComplexEqn"}.
 ##
 ## If @code{"Jacobian"} is @code{"on"}, it specifies that @var{fcn},
 ## called with 2 output arguments, also returns the Jacobian matrix
 ## of right-hand sides at the requested point.  @code{"TolX"} specifies
 ## the termination tolerance in the unknown variables, while 
-## @code{"TolFun"} is a tolerance for equations. Default is @code{1e-7}
+## @code{"TolFun"} is a tolerance for equations.  Default is @code{1e-7}
 ## for both @code{"TolX"} and @code{"TolFun"}.
 ## If @code{"Updating"} is "on", the function will attempt to use Broyden
 ## updates to update the Jacobian, in order to reduce the amount of jacobian
 ## calculations.
 ## If your user function always calculates the Jacobian (regardless of number
 ## of output arguments), this option provides no advantage and should be set to
 ## false.
 ## 
 ## @code{"ComplexEqn"} is @code{"on"}, @code{fsolve} will attempt to solve
 ## complex equations in complex variables, assuming that the equations posess a
-## complex derivative (i.e. are holomorphic). If this is not what you want, 
+## complex derivative (i.e., are holomorphic).  If this is not what you want, 
 ## should unpack the real and imaginary parts of the system to get a real
 ## system.
 ##
 ## For description of the other options, see @code{optimset}.
 ##
 ## On return, @var{fval} contains the value of the function @var{fcn}
 ## evaluated at @var{x}, and @var{info} may be one of the following values:
 ## 
 ## @table @asis
 ## @item 1
-## Converged to a solution point. Relative residual error is less than specified
+## Converged to a solution point.  Relative residual error is less than specified
 ## by TolFun.
 ## @item 2
 ## Last relative step size was less that TolX.
 ## @item 3
 ## Last relative decrease in residual was less than TolF. 
 ## @item 0
 ## Iteration limit exceeded.
 ## @item -3
@@ -75,27 +75,28 @@
 ## 
 ## Note: If you only have a single nonlinear equation of one variable, using 
 ## @code{fzero} is usually a much better idea.
 ## @seealso{fzero, optimset}
 ##
 ## Note about user-supplied jacobians:
 ## As an inherent property of the algorithm, jacobian is always requested for a
 ## solution vector whose residual vector is already known, and it is the last
-## accepted successful step. Often this will be one of the last two calls, but
-## not always. If the savings by reusing intermediate results from residual
+## accepted successful step.  Often this will be one of the last two calls, but
+## not always.  If the savings by reusing intermediate results from residual
 ## calculation in jacobian calculation are significant, the best strategy is to
 ## employ OutputFcn: After a vector is evaluated for residuals, if OutputFcn is
 ## called with that vector, then the intermediate results should be saved for
 ## future jacobian evaluation, and should be kept until a jacobian evaluation
 ## is requested or until outputfcn is called with a different vector, in which
-## case they should be dropped in favor of this most recent vector. A short
+## case they should be dropped in favor of this most recent vector.  A short
 ## example how this can be achieved follows:
 ##
 ## @example
+## @group
 ## function [fvec, fjac] = my_optim_func (x, optimvalues, state)
 ## persistent sav = [], sav0 = [];
 ## if (nargin == 1)
 ##   ## evaluation call
 ##   if (nargout == 1)
 ##     sav0.x = x; # mark saved vector
 ##     ## calculate fvec, save results to sav0.
 ##   elseif (nargout == 2)
@@ -105,19 +106,20 @@
 ##   ## outputfcn call.
 ##   if (all (x == sav0.x))
 ##     sav = sav0;
 ##   endif
 ##   ## maybe output iteration status etc.
 ## endif
 ## endfunction
 ##
-## ## ....
+## ## @dots{}.
 ## 
 ## fsolve (@@my_optim_func, x0, optimset ("OutputFcn", @@my_optim_func, @dots{}))
+## @end group
 ## @end example
 ###
 ## @end deftypefn
 
 ## PKG_ADD: __all_opts__ ("fsolve");
 
 function [x, fvec, info, output, fjac] = fsolve (fcn, x0, options = struct ())
 
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -15,19 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File}{[@var{x}, @var{fval}, @var{info}, @var{output}] =} fzero (@var{fun}, @var{x0}, @var{options})
-## Find a zero point of a univariate function. @var{fun} should be a function
-## handle or name. @var{x0} specifies a starting point. @var{options} is a
-## structure specifying additional options. Currently, @code{fzero}
+## Find a zero point of a univariate function.  @var{fun} should be a function
+## handle or name.  @var{x0} specifies a starting point.  @var{options} is a
+## structure specifying additional options.  Currently, @code{fzero}
 ## recognizes these options: @code{"FunValCheck"}, @code{"OutputFcn"},
 ## @code{"TolX"}, @code{"MaxIter"}, @code{"MaxFunEvals"}. 
 ## For description of these options, see @ref{doc-optimset,,optimset}.
 ## 
 ## On exit, the function returns @var{x}, the approximate zero point
 ## and @var{fval}, the function value thereof.
 ## @var{info} is an exit flag that can have these values:
 ## @itemize
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -67,17 +67,17 @@
 ## @end example
 ## @end ifnottex
 ## 
 ## subject to
 ## 
 ## @iftex
 ## @tex
 ## $$
-##  Ax [ = | \leq | \geq ] b \qquad  LB \leq x \leq UB
+##  Ax [ = | \leq | \geq ] b \qquad LB \leq x \leq UB
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ## @example
 ## @group
 ## A*x [ "=" | "<=" | ">=" ] b
 ##   x >= LB
@@ -251,19 +251,19 @@
 ## CPLEX LP format to the file @file{"outpb.lp"}.  There is currently no
 ## way to change the name of the output file.
 ## @end table
 ## 
 ## Real parameters:
 ## 
 ## @table @code
 ## @item relax (@code{LPX_K_RELAX}, default: 0.07)
-## Relaxation parameter used in the ratio test. If it is zero, the textbook
-## ratio test is used. If it is non-zero (should be positive), Harris'
-## two-pass ratio test is used. In the latter case on the first pass of the
+## Relaxation parameter used in the ratio test.  If it is zero, the textbook
+## ratio test is used.  If it is non-zero (should be positive), Harris'
+## two-pass ratio test is used.  In the latter case on the first pass of the
 ## ratio test basic variables (in the case of primal simplex) or reduced
 ## costs of non-basic variables (in the case of dual simplex) are allowed
 ## to slightly violate their bounds, but not more than
 ## @code{relax*tolbnd} or @code{relax*toldj (thus, @code{relax} is a
 ## percentage of @code{tolbnd} or @code{toldj}}.
 ## 
 ## @item tolbnd (@code{LPX_K_TOLBND}, default: 10e-7)
 ## Relative tolerance used to check if the current basic solution is primal
@@ -281,30 +281,30 @@
 ## have a detailed understanding of its purpose.
 ## 
 ## @item objll (@code{LPX_K_OBJLL}, default: -DBL_MAX)
 ## Lower limit of the objective function.  If on the phase II the objective
 ## function reaches this limit and continues decreasing, the solver stops
 ## the search.  This parameter is used in the dual simplex method only.
 ## 
 ## @item objul (@code{LPX_K_OBJUL}, default: +DBL_MAX)
-## Upper limit of the objective function. If on the phase II the objective
+## Upper limit of the objective function.  If on the phase II the objective
 ## function reaches this limit and continues increasing, the solver stops
 ## the search.  This parameter is used in the dual simplex only.
 ## 
 ## @item tmlim (@code{LPX_K_TMLIM}, default: -1.0)
-## Searching time limit, in seconds. If this value is positive, it is
+## Searching time limit, in seconds.  If this value is positive, it is
 ## decreased each time when one simplex iteration has been performed by the
 ## amount of time spent for the iteration, and reaching zero value signals
 ## the solver to stop the search.  Negative value means no time limit.
 ## 
 ## @item outdly (@code{LPX_K_OUTDLY}, default: 0.0)
-## Output delay, in seconds. This parameter specifies how long the solver
+## Output delay, in seconds.  This parameter specifies how long the solver
 ## should delay sending information about the solution to the standard
-## output. Non-positive value means no delay.
+## output.  Non-positive value means no delay.
 ## 
 ## @item tolint (@code{LPX_K_TOLINT}, default: 10e-5)
 ## Relative tolerance used to check if the current basic solution is integer
 ## feasible.  It is not recommended that you change this parameter unless
 ## you have a detailed understanding of its purpose.
 ## 
 ## @item tolobj (@code{LPX_K_TOLOBJ}, default: 10e-7)
 ## Relative tolerance used to check if the value of the objective function
@@ -413,17 +413,17 @@
 ## ub = [];
 ## ctype = "UUU";
 ## vartype = "CCC";
 ## s = -1;
 ## 
 ## param.msglev = 1;
 ## param.itlim = 100;
 ## 
-## [xmin, fmin, status, extra] = ...
+## [xmin, fmin, status, extra] = @dots{}
 ##    glpk (c, a, b, lb, ub, ctype, vartype, s, param);
 ## @end group
 ## @end example
 ## @end deftypefn
 
 ## Author: Nicolo' Giorgetti <giorgetti@dii.unisi.it>
 ## Adapted-by: jwe
 
diff --git a/scripts/optimization/glpkmex.m b/scripts/optimization/glpkmex.m
--- a/scripts/optimization/glpkmex.m
+++ b/scripts/optimization/glpkmex.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{xopt}, @var{fmin}, @var{status}, @var{extra}] =} glpkmex (@var{sense}, @var{c}, @var{a}, @var{b}, @var{ctype}, @var{lb}, @var{ub}, @var{vartype}, @var{param}, @var{lpsolver}, @var{save_pb})
-## This function is provided for compatibility with the old @sc{Matlab}
+## This function is provided for compatibility with the old @sc{matlab}
 ## interface to the GNU GLPK library.  For Octave code, you should use
 ## the @code{glpk} function instead.
 ## @end deftypefn
 
 function [xopt, fopt, status, extra] = glpkmex (varargin)
 
   ## If there is no input output the version and syntax
   if (nargin < 4 || nargin > 11)
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -22,17 +22,17 @@
 ## @deftypefn {Function File} {@var{x} =} lsqnonneg (@var{c}, @var{d})
 ## @deftypefnx {Function File} {@var{x} =} lsqnonneg (@var{c}, @var{d}, @var{x0})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}, @var{lambda}] =} lsqnonneg (@dots{})
 ## Minimize @code{norm (@var{c}*@var{x}-d)} subject to @code{@var{x} >=
-## 0}. @var{c} and @var{d} must be real.  @var{x0} is an optional
+## 0}.  @var{c} and @var{d} must be real.  @var{x0} is an optional
 ## initial guess for @var{x}.
 ##
 ## Outputs:
 ## @itemize @bullet
 ## @item resnorm
 ##
 ## The squared 2-norm of the residual: norm(@var{c}*@var{x}-@var{d})^2
 ## @item residual
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -25,35 +25,39 @@
 ## $$
 ##  \min_x {1 \over 2} x^T H x + x^T q
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##
 ## @example
+## @group
 ##      min 0.5 x'*H*x + x'*q
 ##       x
+## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## subject to
 ## @iftex
 ## @tex
 ## $$
 ##  Ax = b \qquad lb \leq x \leq ub \qquad A_{lb} \leq A_{in} \leq A_{ub}
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##
 ## @example
+## @group
 ##      A*x = b
 ##      lb <= x <= ub
 ##      A_lb <= A_in*x <= A_ub
+## @end group
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
 ## using a null-space active-set method.
 ##
 ## Any bound (@var{A}, @var{b}, @var{lb}, @var{ub}, @var{A_lb},
 ## @var{A_ub}) may be set to the empty matrix (@code{[]}) if not
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -24,35 +24,39 @@
 ## $$
 ## \min_x \phi (x)
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##
 ## @example
+## @group
 ##      min phi (x)
 ##       x
+## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## subject to
 ## @iftex
 ## @tex
 ## $$
 ##  g(x) = 0 \qquad h(x) \geq 0 \qquad lb \leq x \leq ub
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##
 ## @example
+## @group
 ##      g(x)  = 0
 ##      h(x) >= 0
 ##      lb <= x <= ub
+## @end group
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
 ## using a successive quadratic programming method.
 ##
 ## The first argument is the initial guess for the vector @var{x}.
 ##
@@ -121,36 +125,39 @@
 ##  \Bigg( {\partial f(x) \over \partial x_1}, 
 ##         {\partial f(x) \over \partial x_2}, \ldots,
 ##         {\partial f(x) \over \partial x_N} \Bigg)^T
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ## @example
+## @group
 ##                 [ d f(x)   d f(x)        d f(x) ]
 ##     transpose ( [ ------   -----   ...   ------ ] )
 ##                 [  dx_1     dx_2          dx_N  ]
+## @end group
 ## @end example
 ## @end ifnottex
 ##
 ## The fifth and sixth arguments are vectors containing lower and upper bounds
-## on @var{x}. These must be consistent with equality and inequality
-## constraints @var{g} and @var{h}. If the bounds are not specified, or are
+## on @var{x}.  These must be consistent with equality and inequality
+## constraints @var{g} and @var{h}.  If the bounds are not specified, or are
 ## empty, they are set to -@var{realmax} and @var{realmax} by default.
 ##
-## The seventh argument is max. number of iterations. If not specified,
+## The seventh argument is max. number of iterations.  If not specified,
 ## the default value is 100.
 ##
-## The eighth argument is tolerance for stopping criteria. If not specified,
+## The eighth argument is tolerance for stopping criteria.  If not specified,
 ## the default value is @var{eps}.
 ##
 ## Here is an example of calling @code{sqp}:
 ##
 ## @example
+## @group
 ## function r = g (x)
 ##   r = [ sumsq(x)-10;
 ##         x(2)*x(3)-5*x(4)*x(5); 
 ##         x(1)^3+x(2)^3+1 ];
 ## endfunction
 ##
 ## function obj = phi (x)
 ##   obj = exp(prod(x)) - 0.5*(x(1)^3+x(2)^3+1)^2;
@@ -172,16 +179,17 @@
 ## info = 101
 ## iter = 8
 ## nf = 10
 ## lambda =
 ##     
 ##   -0.0401627
 ##    0.0379578
 ##   -0.0052227
+## @end group
 ## @end example
 ##
 ## The value returned in @var{info} may be one of the following:
 ## @table @asis
 ## @item 101
 ## The algorithm terminated because the norm of the last step was less
 ## than @code{tol * norm (x))} (the value of tol is currently fixed at
 ## @code{sqrt (eps)}---edit @file{sqp.m} to modify this value.
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005, 2006, 2007, 2008, 2009 Sren Hauberg
+## Copyright (C) 2005, 2006, 2007, 2008, 2009 Sren Hauberg
 ## 
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,36 +14,36 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} pkg @var{command} @var{pkg_name}
 ## @deftypefnx {Command} pkg @var{command} @var{option} @var{pkg_name}
-## This command interacts with the package manager. Different actions will
+## This command interacts with the package manager.  Different actions will
 ## be taken depending on the value of @var{command}.
 ##
 ## @table @samp
 ## @item install
 ## Install named packages.  For example,
 ## @example
 ## pkg install image-1.0.0.tar.gz
 ## @end example
 ## @noindent
 ## installs the package found in the file @code{image-1.0.0.tar.gz}.
 ##
 ## The @var{option} variable can contain options that affect the manner
-## in which a package is installed. These options can be one or more of
+## in which a package is installed.  These options can be one or more of
 ##
 ## @table @code
 ## @item -nodeps
-## The package manager will disable the dependency checking. That way it 
+## The package manager will disable the dependency checking.  That way it 
 ## is possible to install a package even if it depends on another package 
-## that's not installed on the system. @strong{Use this option with care.}
+## that's not installed on the system.  @strong{Use this option with care.}
 ##
 ## @item -noauto
 ## The package manager will not automatically load the installed package 
 ## when starting Octave, even if the package requests that it is.
 ##
 ## @item -auto
 ## The package manager will automatically load the installed package when 
 ## starting Octave, even if the package requests that it isn't.
@@ -61,39 +61,39 @@
 ## @end table
 ##
 ## @item uninstall
 ## Uninstall named packages.  For example,
 ## @example
 ## pkg uninstall image
 ## @end example
 ## @noindent
-## removes the @code{image} package from the system. If another installed
+## removes the @code{image} package from the system.  If another installed
 ## package depends on the @code{image} package an error will be issued.
 ## The package can be uninstalled anyway by using the @code{-nodeps} option.
 ## @item load
-## Add named packages to the path. After loading a package it is
-## possible to use the functions provided by the package. For example,
+## Add named packages to the path.  After loading a package it is
+## possible to use the functions provided by the package.  For example,
 ## @example
 ## pkg load image
 ## @end example
 ## @noindent
-## adds the @code{image} package to the path. It is possible to load all
+## adds the @code{image} package to the path.  It is possible to load all
 ## installed packages at once with the command
 ## @example
 ## pkg load all
 ## @end example
 ## @item unload
-## Removes named packages from the path. After unloading a package it is
+## Removes named packages from the path.  After unloading a package it is
 ## no longer possible to use the functions provided by the package.
 ## This command behaves like the @code{load} command.
 ## @item list
-## Show a list of the currently installed packages. By requesting one or two
+## Show a list of the currently installed packages.  By requesting one or two
 ## output argument it is possible to get a list of the currently installed
-## packages. For example,
+## packages.  For example,
 ## @example
 ## installed_packages = pkg list;
 ## @end example
 ## @noindent
 ## returns a cell array containing a structure for each installed package.
 ## The command
 ## @example
 ## [@var{user_packages}, @var{system_packages}] = pkg list
@@ -120,73 +120,73 @@
 ## error, unless a second output is requested:
 ## @example
 ##  [ desc, flag] = pkg ("describe", "secs1d", "image")
 ## @end example
 ## @noindent
 ## @var{flag} will take one of the values "Not installed", "Loaded" or
 ## "Not loaded" for each of the named packages.
 ## @item prefix
-## Set the installation prefix directory. For example,
+## Set the installation prefix directory.  For example,
 ## @example
 ## pkg prefix ~/my_octave_packages
 ## @end example
 ## @noindent
 ## sets the installation prefix to @code{~/my_octave_packages}.
 ## Packages will be installed in this directory.
 ##
 ## It is possible to get the current installation prefix by requesting an
 ## output argument.  For example,
 ## @example
 ## p = pkg prefix
 ## @end example
 ##
 ## The location in which to install the architecture dependent files can be
-## independent specified with an addition argument. For example
+## independent specified with an addition argument.  For example
 ##
 ## @example
 ## pkg prefix ~/my_octave_packages ~/my_octave_packages_for_my_pc
 ## @end example
 ## @item local_list
 ## Set the file in which to look for information on the locally
-## installed packages. Locally installed packages are those that are
-## typically available only to the current user. For example
+## installed packages.  Locally installed packages are those that are
+## typically available only to the current user.  For example
 ## @example
 ## pkg local_list ~/.octave_packages
 ## @end example
 ## It is possible to get the current value of local_list with the following
 ## @example
 ## pkg local_list
 ## @end example
 ## @item global_list
 ## Set the file in which to look for, for information on the globally
-## installed packages. Globally installed packages are those that are
-## typically available to all users. For example
+## installed packages.  Globally installed packages are those that are
+## typically available to all users.  For example
 ## @example
 ## pkg global_list /usr/share/octave/octave_packages
 ## @end example
 ## It is possible to get the current value of global_list with the following
 ## @example
 ## pkg global_list
 ## @end example
 ## @item rebuild
-## Rebuilds the package database from the installed directories. This can 
+## Rebuilds the package database from the installed directories.  This can 
 ## be used in cases where for some reason the package database is corrupted.
 ## It can also take the @code{-auto} and @code{-noauto} options to allow the
-## autolaoding state of a package to be changed. For example
+## autolaoding state of a package to be changed.  For example
 ##
 ## @example
 ## pkg rebuild -noauto image
 ## @end example
 ##
 ## will remove the autoloading status of the image package.
 ## @item build
-## Builds a binary form of a package or packages. The binary file produced
+## Builds a binary form of a package or packages.  The binary file produced
 ## will itself be an Octave package that can be installed normally with
-## @code{pkg}. The form of the command to build a binary package is
+## @code{pkg}.  The form of the command to build a binary package is
 ##
 ## @example
 ## pkg build builddir image-1.0.0.tar.gz @dots{}
 ## @end example
 ##
 ## @noindent
 ## where @code{buiddir} is the name of a directory where the temporary
 ## installation will be produced and the binary packages will be found.
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -21,18 +21,20 @@
 ## Compute isolines (contour lines) of the matrix @var{z}. 
 ## Parameters @var{x}, @var{y} and @var{vn} are optional.
 ##
 ## The return value @var{lev} is a vector of the contour levels.
 ## The return value @var{c} is a 2 by @var{n} matrix containing the
 ## contour lines in the following format
 ##
 ## @example
+## @group
 ## @var{c} = [lev1, x1, x2, @dots{}, levn, x1, x2, @dots{} 
 ##      len1, y1, y2, @dots{}, lenn, y1, y2, @dots{}]
+## @end group
 ## @end example
 ##
 ## @noindent
 ## in which contour line @var{n} has a level (height) of @var{levn} and
 ## length of @var{lenn}.
 ## 
 ## If @var{x} and @var{y} are omitted they are taken as the row/column 
 ## index of @var{z}.  @var{vn} is either a scalar denoting the number of lines 
diff --git a/scripts/plot/contourf.m b/scripts/plot/contourf.m
--- a/scripts/plot/contourf.m
+++ b/scripts/plot/contourf.m
@@ -43,18 +43,20 @@
 ## a default value of 10 contour level is assumed.
 ##
 ## If provided, the filled contours are added to the axes object
 ## @var{ax} instead of the current axis.
 ##
 ## The following example plots filled contours of the @code{peaks}
 ## function.
 ## @example
+## @group
 ## [x, y, z] = peaks (50);
 ## contourf (x, y, z, -7:9)
+## @end group
 ## @end example
 ## @seealso{contour, contourc, patch}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Author: Shai Ayal <shaiay@users.sourceforge.net>
 
 function [c, h] = contourf (varargin)
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -31,19 +31,21 @@
 ##
 ## Called with no return arguments, @code{cylinder} calls directly
 ## @code{surf (@var{x}, @var{y}, @var{z})}.  If an axes handle @var{ax}
 ## is passed as the first argument, the surface is plotted to this set
 ## of axes.
 ##
 ## Examples:
 ## @example
+## @group
 ## disp ("plotting a cone")
 ## [x, y, z] = cylinder (10:-1:0,50);
 ## surf (x, y, z);
+## @end group
 ## @end example
 ## @seealso{sphere}
 ## @end deftypefn
 
 function [xx, yy, zz] = cylinder (varargin)
 
   [ax, args, nargs] = __plt_get_axis_arg__ ((nargout > 0), "cylinder", 
 					    varargin{:});
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -79,28 +79,32 @@
 ## @example
 ## errorbar (@var{x}, @var{y}, @var{ex}, ">")
 ## @end example
 ##
 ## produces an xerrorbar plot of @var{y} versus @var{x} with @var{x}
 ## errorbars drawn from @var{x}-@var{ex} to @var{x}+@var{ex}.
 ##
 ## @example
+## @group
 ## errorbar (@var{x}, @var{y1}, @var{ey}, "~",
 ##           @var{x}, @var{y2}, @var{ly}, @var{uy})
+## @end group
 ## @end example
 ##
 ## produces yerrorbar plots with @var{y1} and @var{y2} versus @var{x}.
 ## Errorbars for @var{y1} are drawn from @var{y1}-@var{ey} to
 ## @var{y1}+@var{ey}, errorbars for @var{y2} from @var{y2}-@var{ly} to
 ## @var{y2}+@var{uy}.
 ##
 ## @example
+## @group
 ## errorbar (@var{x}, @var{y}, @var{lx}, @var{ux},
 ##           @var{ly}, @var{uy}, "~>")
+## @end group
 ## @end example
 ##
 ## produces an xyerrorbar plot of @var{y} versus @var{x} in which
 ## @var{x} errorbars are drawn from @var{x}-@var{lx} to @var{x}+@var{ux}
 ## and @var{y} errorbars from @var{y}-@var{ly} to @var{y}+@var{uy}.
 ## @seealso{semilogxerr, semilogyerr, loglogerr}
 ## @end deftypefn
 
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -26,18 +26,20 @@
 ## The limits of the plot are given by @var{limits} of the form
 ## @code{[@var{xlo}, @var{xhi}]} or @code{[@var{xlo}, @var{xhi},
 ## @var{ylo}, @var{yhi}]}.  @var{tol} is the default tolerance to use for the
 ## plot, and if @var{tol} is an integer it is assumed that it defines the 
 ## number points to use in the plot.  The @var{fmt} argument is passed
 ## to the plot command.
 ##
 ## @example
+## @group
 ##    fplot ("cos", [0, 2*pi])
 ##    fplot ("[cos(x), sin(x)]", [0, 2*pi])
+## @end group
 ## @end example
 ## @seealso{plot}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 function fplot (fn, limits, n, linespec)
   if (nargin < 2 || nargin > 4)
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -151,18 +151,20 @@
 ## @example
 ## plot (b, "*", "markersize", 3)
 ## @end example
 ##
 ## This command will plot the data in the variable @code{b},
 ## with points displayed as @samp{*} with a marker size of 3.
 ##
 ## @example
+## @group
 ## t = 0:0.1:6.3;
 ## plot (t, cos(t), "-;cos(t);", t, sin(t), "+3;sin(t);");
+## @end group
 ## @end example
 ##
 ## This will plot the cosine and sine functions and label them accordingly
 ## in the key.
 ##
 ## If the first argument is an axis handle, then plot into these axes, 
 ## rather than the current axis handle returned by @code{gca}. 
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, bar,
diff --git a/scripts/plot/rose.m b/scripts/plot/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/rose.m
@@ -33,18 +33,20 @@
 ## The optional return value @var{h} provides a list of handles to the 
 ## the parts of the vector field (body, arrow and marker).
 ##
 ## If two output arguments are requested, then rather than plotting the 
 ## histogram, the polar vectors necessary to plot the histogram are 
 ## returned.
 ##
 ## @example
+## @group
 ## [r, t] = rose ([2*randn(1e5,1), pi + 2 * randn(1e5,1)]);
 ## polar (r, t);
+## @end group
 ## @end example
 ##
 ##
 ## @seealso{plot, compass, polar, hist}
 ## @end deftypefn
 
 function [thout, rout] = rose (varargin)
 
diff --git a/scripts/plot/slice.m b/scripts/plot/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/slice.m
@@ -25,17 +25,17 @@
 ## @deftypefnx {Function File} {@var{h} =} slice (@dots{}, @var{method})
 ## Plot slices of 3D data/scalar fields.  Each element of the 3-dimensional 
 ## array @var{v} represents a scalar value at a location given by the
 ## parameters @var{x}, @var{y}, and @var{z}.  The parameters @var{x},
 ## @var{x}, and @var{z} are either 3-dimensional arrays of the same size
 ## as the array @var{v} in the "meshgrid" format or vectors.  The
 ## parameters @var{xi}, etc respect a similar format to @var{x}, etc,
 ## and they represent the points at which the array @var{vi} is
-## interpolated using interp3. The vectors @var{sx}, @var{sy}, and
+## interpolated using interp3.  The vectors @var{sx}, @var{sy}, and
 ## @var{sz} contain points of orthogonal slices of the respective axes.
 ##
 ## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be 
 ## @code{x = 1:size (@var{v}, 2)}, @code{y = 1:size (@var{v}, 1)} and
 ## @code{z = 1:size (@var{v}, 3)}. 
 ##
 ## @var{Method} is one of:
 ##
@@ -52,22 +52,24 @@
 ## @end table
 ##
 ## The default method is @code{"linear"}.
 ## The optional return value @var{h} is a vector of handles to the
 ## surface graphic objects.
 ##
 ## Examples:
 ## @example
+## @group
 ## [x, y, z] = meshgrid (linspace (-8, 8, 32));
 ## v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
 ## slice (x, y, z, v, [], 0, []);
 ## [xi, yi] = meshgrid (linspace (-7, 7));
 ## zi = xi + yi;
 ## slice (x, y, z, v, xi, yi, zi);
+## @end group
 ## @end example
 ## @seealso{interp3, surface, pcolor}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function h = slice (varargin)
 
diff --git a/scripts/plot/stem3.m b/scripts/plot/stem3.m
--- a/scripts/plot/stem3.m
+++ b/scripts/plot/stem3.m
@@ -20,18 +20,20 @@
 ## @deftypefn {Function File} {@var{h} =} stem3 (@var{x}, @var{y}, @var{z}, @var{linespec})
 ## Plot a three-dimensional stem graph and return the handles of the line
 ## and marker objects used to draw the stems as "stem series" object.
 ## The default color is @code{"r"} (red).  The default line style is
 ## @code{"-"} and the default marker is @code{"o"}.
 ##
 ## For example,
 ## @example
+## @group
 ## theta = 0:0.2:6; 
 ## stem3 (cos (theta), sin (theta), theta) 
+## @end group
 ## @end example
 ##
 ## @noindent
 ## plots 31 stems with heights from 0 to 6 lying on a circle.  Color 
 ## definitions with rgb-triples are not valid!
 ## @seealso{bar, barh, stem, plot}
 ## @end deftypefn
 
diff --git a/scripts/plot/surface.m b/scripts/plot/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/surface.m
@@ -23,17 +23,17 @@
 ## @deftypefnx {Function File} {} surface (@var{z}, @var{c})
 ## @deftypefnx {Function File} {} surface (@var{z})
 ## @deftypefnx {Function File} {} surface (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} surface (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} surface (@dots{})
 ## Plot a surface graphic object given matrices @var{x}, and @var{y} from 
 ## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and 
 ## @var{y} coordinates of the surface.  If @var{x} and @var{y} are vectors,
-## then a typical vertex  is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, 
+## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, 
 ## columns of @var{z} correspond to different @var{x} values and rows of 
 ## @var{z} correspond to different @var{y} values.  If @var{x} and @var{y}
 ## are missing, they are constructed from size of the matrix @var{z}.
 ##
 ## Any additional properties passed are assigned to the surface.
 ## @seealso{surf, mesh, patch, line}
 ## @end deftypefn
 
diff --git a/scripts/plot/surfl.m b/scripts/plot/surfl.m
--- a/scripts/plot/surfl.m
+++ b/scripts/plot/surfl.m
@@ -45,19 +45,21 @@
 ## 
 ## The default lighting mode "cdata", changes the cdata property to give the impression
 ## of a lighted surface.  Please note: the alternative "light" mode, which creates a light
 ## object to illuminate the surface is not implemented (yet).
 ##
 ## Example:
 ##
 ## @example
+## @group
 ## colormap(bone);
 ## surfl(peaks);
 ## shading interp;
+## @end group
 ## @end example
 ## @seealso{surf, diffuse, specular, surface}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function retval = surfl (varargin)
 
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -21,18 +21,20 @@
 ## @deftypefnx {Function File} {} surfnorm (@var{z})
 ## @deftypefnx {Function File} {[@var{nx}, @var{ny}, @var{nz}] =} surfnorm (@dots{})
 ## @deftypefnx {Function File} {} surfnorm (@var{h}, @dots{})
 ## Find the vectors normal to a meshgridded surface.  The meshed gridded 
 ## surface is defined by @var{x}, @var{y}, and @var{z}.  If @var{x} and 
 ## @var{y} are not defined, then it is assumed that they are given by
 ##
 ## @example
+## @group
 ## [@var{x}, @var{y}] = meshgrid (1:size(@var{z}, 1), 
 ##                      1:size(@var{z}, 2));
+## @end group
 ## @end example
 ##
 ## If no return arguments are requested, a surface plot with the normal 
 ## vectors to the surface is plotted.  Otherwise the components of the normal
 ## vectors at the mesh gridded points are returned in @var{nx}, @var{ny},
 ## and @var{nz}.
 ##
 ## The normal vectors are calculated by taking the cross product of the 
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -34,23 +34,23 @@
 ##      0    &     0    & \cdots &     1    &         0}\right].
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##
 ## @smallexample
 ##      _                                                        _
-##     |  -c(2)/c(1)   -c(3)/c(1)  ...  -c(N)/c(1)  -c(N+1)/c(1)  |
-##     |       1            0      ...       0             0      |
-##     |       0            1      ...       0             0      |
+##     |  -c(2)/c(1)   -c(3)/c(1)  @dots{}  -c(N)/c(1)  -c(N+1)/c(1)  |
+##     |       1            0      @dots{}       0             0      |
+##     |       0            1      @dots{}       0             0      |
 ## A = |       .            .   .            .             .      |
 ##     |       .            .       .        .             .      |
 ##     |       .            .           .    .             .      |
-##     |_      0            0      ...       1             0     _|
+##     |_      0            0      @dots{}       1             0     _|
 ## @end smallexample
 ## @end ifnottex
 ##
 ## The eigenvalues of the companion matrix are equal to the roots of the
 ## polynomial.
 ## @seealso{poly, roots, residue, conv, deconv, polyval, polyderiv,
 ## polyinteg}
 ## @end deftypefn
diff --git a/scripts/polynomial/convn.m b/scripts/polynomial/convn.m
--- a/scripts/polynomial/convn.m
+++ b/scripts/polynomial/convn.m
@@ -20,23 +20,23 @@
 ## @deftypefn {Function File} {@var{c} =} convn (@var{a}, @var{b}, @var{shape})
 ## @math{N}-dimensional convolution of matrices @var{a} and @var{b}.
 ##
 ## The size of the output is determined by the @var{shape} argument.
 ## This can be any of the following character strings:
 ##
 ## @table @asis
 ## @item "full"
-## The full convolution result is returned. The size out of the output is
-## @code{size (@var{a}) + size (@var{b})-1}. This is the default behaviour.
+## The full convolution result is returned.  The size out of the output is
+## @code{size (@var{a}) + size (@var{b})-1}.  This is the default behaviour.
 ## @item "same"
-## The central part of the convolution result is returned. The size out of the
+## The central part of the convolution result is returned.  The size out of the
 ## output is the same as @var{a}.
 ## @item "valid"
-## The valid part of the convolution is returned. The size of the result is
+## The valid part of the convolution is returned.  The size of the result is
 ## @code{max (size (@var{a}) - size (@var{b})+1, 0)}.
 ## @end table
 ##
 ## @seealso{conv, conv2}
 ## @end deftypefn
 
 function c = convn (a, b, shape = "full")
 
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -19,26 +19,26 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{pp} =} mkpp (@var{x}, @var{p})
 ## @deftypefnx {Function File} {@var{pp} =} mkpp (@var{x}, @var{p}, @var{d})
 ## 
 ## Construct a piece-wise polynomial structure from sample points
 ## @var{x} and coefficients @var{p}.  The i-th row of @var{p},
 ## @code{@var{p} (@var{i},:)}, contains the coefficients for the polynomial
 ## over the @var{i}-th interval, ordered from highest to 
-## lowest. There must be one row for each interval in @var{x}, so 
+## lowest.  There must be one row for each interval in @var{x}, so 
 ## @code{rows (@var{p}) == length (@var{x}) - 1}.  
 ##
 ## You can concatenate multiple polynomials of the same order over the 
 ## same set of intervals using @code{@var{p} = [ @var{p1}; @var{p2}; 
 ## @dots{}; @var{pd} ]}.  In this case, @code{rows (@var{p}) == @var{d} 
 ## * (length (@var{x}) - 1)}.
 ##
 ## @var{d} specifies the shape of the matrix @var{p} for all except the
-## last dimension. If @var{d} is not specified it will be computed as
+## last dimension.  If @var{d} is not specified it will be computed as
 ## @code{round (rows (@var{p}) / (length (@var{x}) - 1))} instead.
 ##
 ## @seealso{unmkpp, ppval, spline}
 ## @end deftypefn
 
 function pp = mkpp (x, P, d)
   if (nargin < 2 || nargin > 3)
     print_usage ();
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -15,25 +15,25 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{pp} =} pchip (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{yi} =} pchip (@var{x}, @var{y}, @var{xi})
 ##
-## Piecewise Cubic Hermite interpolating polynomial. Called with two
+## Piecewise Cubic Hermite interpolating polynomial.  Called with two
 ## arguments, the piece-wise polynomial @var{pp} is returned, that may
 ## later be used with @code{ppval} to evaluate the polynomial at
 ## specific points.
 ##
 ## The variable @var{x} must be a strictly monotonic vector (either
-## increasing or decreasing). While @var{y} can be either a vector or
-## array. In the case where @var{y} is a vector, it must have a length
-## of @var{n}. If @var{y} is an array, then the size of @var{y} must
+## increasing or decreasing).  While @var{y} can be either a vector or
+## array.  In the case where @var{y} is a vector, it must have a length
+## of @var{n}.  If @var{y} is an array, then the size of @var{y} must
 ## have the form
 ## @iftex
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
@@ -43,22 +43,22 @@
 ## @iftex
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
-## and each row in this matrix is then treated separately. Note that this
+## and each row in this matrix is then treated separately.  Note that this
 ## is exactly the opposite treatment than @code{interp1} and is done
 ## for compatibility.
 ##
 ## Called with a third input argument, @code{pchip} evaluates the 
-## piece-wise polynomial at the points @var{xi}. There is an equivalence
+## piece-wise polynomial at the points @var{xi}.  There is an equivalence
 ## between @code{ppval (pchip (@var{x}, @var{y}), @var{xi})} and
 ## @code{pchip (@var{x}, @var{y}, @var{xi})}.
 ##
 ## @seealso{spline, ppval, mkpp, unmkpp}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Date: 9. mar 2001
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -19,20 +19,22 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} poly (@var{a})
 ## If @var{a} is a square @math{N}-by-@math{N} matrix, @code{poly (@var{a})}
 ## is the row vector of the coefficients of @code{det (z * eye (N) - a)},
 ## the characteristic polynomial of @var{a}.  As an example we can use
 ## this to find the eigenvalues of @var{a} as the roots of @code{poly (@var{a})}.
 ## @example
+## @group
 ## roots(poly(eye(3)))
 ## @result{} 1.00000 + 0.00000i
 ## @result{} 1.00000 - 0.00000i
 ## @result{} 1.00000 + 0.00000i
+## @end group
 ## @end example
 ## In real-life examples you should, however, use the @code{eig} function
 ## for computing eigenvalues.
 ##
 ## If @var{x} is a vector, @code{poly (@var{x})} is a vector of coefficients
 ## of the polynomial whose roots are the elements of @var{x}.  That is,
 ## of @var{c} is a polynomial, then the elements of 
 ## @code{@var{d} = roots (poly (@var{c}))} are contained in @var{c}.
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -26,21 +26,23 @@
 ## @example 
 ## sqrt(eps).
 ## @end example
 ##  Note that this is an unstable
 ## algorithm, so don't try it on large polynomials.
 ##
 ## Example
 ## @example
+## @group
 ## polygcd (poly(1:8), poly(3:12)) - poly(3:8)
 ## @result{} [ 0, 0, 0, 0, 0, 0, 0 ]
 ## deconv (poly(1:8), polygcd (poly(1:8), poly(3:12))) ...
 ##   - poly(1:2)
 ## @result{} [ 0, 0, 0 ]
+## @end group
 ## @end example
 ## @seealso{poly, polyinteg, polyderiv, polyreduce, roots, conv, deconv,
 ## residue, filter, polyval, polyvalm}
 ## @end deftypefn
 
 function x = polygcd (b, a, tol)
 
   if (nargin == 2 || nargin == 3)
diff --git a/scripts/polynomial/polyint.m b/scripts/polynomial/polyint.m
--- a/scripts/polynomial/polyint.m
+++ b/scripts/polynomial/polyint.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyint (@var{c}, @var{k})
 ## Return the coefficients of the integral of the polynomial whose
-## coefficients are represented by the vector @var{c}. The variable
+## coefficients are represented by the vector @var{c}.  The variable
 ## @var{k} is the constant of integration, which by default is set to zero.
 ## @seealso{poly, polyderiv, polyreduce, roots, conv, deconv, residue,
 ## filter, polyval, polyvalm}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -22,17 +22,17 @@
 ## Write formatted polynomial
 ## @iftex
 ## @tex
 ## $$ c(x) = c_1 x^n + \ldots + c_n x + c_{n+1} $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ## @example
-##    c(x) = c(1) * x^n + ... + c(n) x + c(n+1)
+##    c(x) = c(1) * x^n + @dots{} + c(n) x + c(n+1)
 ## @end example
 ## @end ifnottex
 ##  and return it as a string or write it to the screen (if
 ##  @var{nargout} is zero).
 ##  @var{x} defaults to the string @code{"s"}.
 ## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
 ## filter, polyderiv, polyinteg}
 ## @end deftypefn
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -13,27 +13,27 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y}=} polyval (@var{p}, @var{x})
-## @deftypefnx {Function File} {@var{y}=} polyval (@var{p}, @var{x}, [], @var{mu})
-## Evaluate the polynomial at of the specified values for @var{x}. When @var{mu}
+## @deftypefn {Function File} {@var{y} =} polyval (@var{p}, @var{x})
+## @deftypefnx {Function File} {@var{y} =} polyval (@var{p}, @var{x}, [], @var{mu})
+## Evaluate the polynomial at of the specified values for @var{x}.  When @var{mu}
 ## is present evaluate the polynomial for (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## If @var{x} is a vector or matrix, the polynomial is evaluated for each of
 ## the elements of @var{x}.
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s})
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s}, @var{mu})
 ## In addition to evaluating the polynomial, the second output 
 ## represents the prediction interval, @var{y} +/- @var{dy}, which
-## contains at least 50% of the future predictions. To calculate the
+## contains at least 50% of the future predictions.  To calculate the
 ## prediction interval, the structured variable @var{s}, originating
 ## form `polyfit', must be present.
 ## @seealso{polyfit, polyvalm, poly, roots, conv, deconv, residue, filter,
 ## polyderiv, polyinteg}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -18,17 +18,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyvalm (@var{c}, @var{x})
 ## Evaluate a polynomial in the matrix sense.
 ##
 ## @code{polyvalm (@var{c}, @var{x})} will evaluate the polynomial in the
-## matrix sense, i.e. matrix multiplication is used instead of element by
+## matrix sense, i.e., matrix multiplication is used instead of element by
 ## element multiplication as is used in polyval.
 ##
 ## The argument @var{x} must be a square matrix.
 ## @seealso{polyval, poly, roots, conv, deconv, residue, filter,
 ## polyderiv, polyinteg}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -29,19 +29,21 @@
 ## {B(s)\over A(s)} = \sum_{m=1}^M {r_m\over (s-p_m)^e_m}
 ##   + \sum_{i=1}^N k_i s^{N-i}.
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##
 ## @example
+## @group
 ##  B(s)    M       r(m)         N
 ##  ---- = SUM -------------  + SUM k(i)*s^(N-i)
 ##  A(s)   m=1 (s-p(m))^e(m)    i=1
+## @end group
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
 ## where @math{M} is the number of poles (the length of the @var{r},
 ## @var{p}, and @var{e}), the @var{k} vector is a polynomial of order @math{N-1}
 ## representing the direct contribution, and the @var{e} vector specifies
 ## the multiplicity of the m-th residue's pole.
@@ -67,19 +69,21 @@
 ## $$
 ## {s^2+s+1\over s^3-5s^2+8s-4} = {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1}
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##
 ## @example
+## @group
 ##         s^2 + s + 1       -2        7        3
 ##    ------------------- = ----- + ------- + -----
 ##    s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)
+## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @deftypefnx {Function File} {[@var{b}, @var{a}] =} residue (@var{r}, @var{p}, @var{k})
 ## @deftypefnx {Function File} {[@var{b}, @var{a}] =} residue (@var{r}, @var{p}, @var{k}, @var{e})
 ## Compute the reconstituted quotient of polynomials,
 ## @var{b}(s)/@var{a}(s), from the partial fraction expansion;
@@ -126,19 +130,21 @@
 ## $$
 ## {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1} + s = {s^4-5s^3+9s^2-3s+1\over s^3-5s^2+8s-4}
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##
 ## @example
+## @group
 ##     -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
 ##    ----- + ------- + ----- + s = --------------------------
 ##    (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4
+## @end group
 ## @end example
 ## @end ifnottex
 ## @seealso{poly, roots, conv, deconv, mpoles, polyval, polyderiv, polyinteg}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: June 1994
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -27,37 +27,39 @@
 ## $$
 ## v_1 z^{N-1} + \cdots + v_{N-1} z + v_N.
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##
 ## @example
-## v(1) * z^(N-1) + ... + v(N-1) * z + v(N)
+## v(1) * z^(N-1) + @dots{} + v(N-1) * z + v(N)
 ## @end example
 ## @end ifnottex
 ##
 ## As an example, the following code finds the roots of the quadratic
 ## polynomial
 ## @iftex
 ## @tex
 ## $$ p(x) = x^2 - 5. $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ## @example
 ## p(x) = x^2 - 5.
 ## @end example
 ## @end ifnottex
 ## @example
+## @group
 ## c = [1, 0, -5];
 ## roots(c)
 ## @result{}  2.2361
 ## @result{} -2.2361
+## @end group
 ## @end example
 ## Note that the true result is
 ## @iftex
 ## @tex
 ## $\pm \sqrt{5}$
 ## @end tex
 ## @end iftex
 ## @ifnottex
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -21,25 +21,25 @@
 ## @deftypefn {Function File} {@var{pp} =} spline (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{yi} =} spline (@var{x}, @var{y}, @var{xi})
 ##
 ## Return the cubic spline interpolant of @var{y} at points @var{x}. 
 ## If called with two arguments, @code{spline} returns the piece-wise
 ## polynomial @var{pp} that may later be used with @code{ppval} to
 ## evaluate the polynomial at specific points.
 ## If called with a third input argument, @code{spline} evaluates the 
-## spline at the points @var{xi}. There is an equivalence
+## spline at the points @var{xi}.  There is an equivalence
 ## between @code{ppval (spline (@var{x}, @var{y}), @var{xi})} and
 ## @code{spline (@var{x}, @var{y}, @var{xi})}.
 ##
 ## The variable @var{x} must be a vector of length @var{n}, and @var{y}
-## can be either a vector or array. In the case where @var{y} is a
+## can be either a vector or array.  In the case where @var{y} is a
 ## vector, it can have a length of either @var{n} or @code{@var{n} + 2}.
 ## If the length of @var{y} is @var{n}, then the 'not-a-knot' end
-## condition is used. If the length of @var{y} is @code{@var{n} + 2},
+## condition is used.  If the length of @var{y} is @code{@var{n} + 2},
 ## then the first and last values of the vector @var{y} are the values
 ## of the first derivative of the cubic spline at the end-points.
 ##
 ## If @var{y} is an array, then the size of @var{y} must have the form
 ## @iftex
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
@@ -61,17 +61,17 @@
 ## @iftex
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
-## and each row of this matrix is then treated separately. Note that this
+## and each row of this matrix is then treated separately.  Note that this
 ## is exactly the opposite treatment than @code{interp1} and is done
 ## for compatibility.
 ## @seealso{ppval, mkpp, unmkpp}
 ## @end deftypefn
 
 ## This code is based on csape.m from octave-forge, but has been
 ## modified to use the sparse solver code in octave that itself allows
 ## special casing of tri-diagonal matrices, modified for NDArrays and
diff --git a/scripts/polynomial/unmkpp.m b/scripts/polynomial/unmkpp.m
--- a/scripts/polynomial/unmkpp.m
+++ b/scripts/polynomial/unmkpp.m
@@ -21,21 +21,21 @@
 ##
 ## Extract the components of a piece-wise polynomial structure @var{pp}.
 ## These are as follows:
 ##
 ## @table @asis
 ## @item @var{x}
 ## Sample points.
 ## @item @var{p}
-## Polynomial coefficients for points in sample interval. @code{@var{p}
+## Polynomial coefficients for points in sample interval.  @code{@var{p}
 ## (@var{i}, :)} contains the coefficients for the polynomial over
-## interval @var{i} ordered from highest to lowest. If @code{@var{d} >
+## interval @var{i} ordered from highest to lowest.  If @code{@var{d} >
 ## 1}, @code{@var{p} (@var{r}, @var{i}, :)} contains the coefficients for 
-## the r-th polynomial defined on interval @var{i}. However, this is 
+## the r-th polynomial defined on interval @var{i}.  However, this is 
 ## stored as a 2-D array such that @code{@var{c} = reshape (@var{p} (:,
 ## @var{j}), @var{n}, @var{d})} gives @code{@var{c} (@var{i},  @var{r})}
 ## is the j-th coefficient of the r-th polynomial over the i-th interval.
 ## @item @var{n}
 ## Number of polynomial pieces.
 ## @item @var{k}
 ## Order of the polynomial plus 1.
 ## @item @var{d}
diff --git a/scripts/set/intersect.m b/scripts/set/intersect.m
--- a/scripts/set/intersect.m
+++ b/scripts/set/intersect.m
@@ -17,17 +17,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} intersect (@var{a}, @var{b})
 ## @deftypefnx {Function File} {[@var{c}, @var{ia}, @var{ib}] =} intersect (@var{a}, @var{b})
 ##
 ## Return the elements in both @var{a} and @var{b}, sorted in ascending
-## order. If @var{a} and @var{b} are both column vectors return a column
+## order.  If @var{a} and @var{b} are both column vectors return a column
 ## vector, otherwise return a row vector.
 ##
 ## Return index vectors @var{ia} and @var{ib} such that @code{a(ia)==c} and
 ## @code{b(ib)==c}.
 ##
 ## @end deftypefn
 ## @seealso{unique, union, setxor, setdiff, ismember}
 
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{tf}, @var{a_idx}] =} ismember (@var{A}, @var{S}) 
 ## @deftypefnx {Function File} {[@var{tf}, @var{a_idx}] =} ismember (@var{A}, @var{S}, "rows")
 ## Return a matrix @var{tf} the same shape as @var{A} which has 1 if 
-## @code{A(i,j)} is in @var{S} or 0 if it isn't. If a second output argument 
+## @code{A(i,j)} is in @var{S} or 0 if it isn't.  If a second output argument 
 ## is requested, the indexes into @var{S} of the matching elements are
 ## also returned. 
 ##
 ## @example
 ## @group
 ## a = [3, 10, 1];
 ## s = [0:9];
 ## [tf, a_idx] = residue (a, s);
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -15,17 +15,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} setdiff (@var{a}, @var{b})
 ## @deftypefnx {Function File} {} setdiff (@var{a}, @var{b}, "rows")
-## @deftypefnx {Function File} {[@var{c}, @var{i}] = } setdiff (@var{a}, @var{b})
+## @deftypefnx {Function File} {[@var{c}, @var{i}] =} setdiff (@var{a}, @var{b})
 ## Return the elements in @var{a} that are not in @var{b}, sorted in
 ## ascending order.  If @var{a} and @var{b} are both column vectors
 ## return a column vector, otherwise return a row vector.
 ##
 ## Given the optional third argument @samp{"rows"}, return the rows in
 ## @var{a} that are not in @var{b}, sorted in ascending order by rows.
 ##
 ## If requested, return @var{i} such that @code{c = a(i)}.
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -17,17 +17,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} setxor (@var{a}, @var{b})
 ## @deftypefnx {Function File} {} setxor (@var{a}, @var{b}, 'rows')
 ##
 ## Return the elements exclusive to @var{a} or @var{b}, sorted in ascending
-## order. If @var{a} and @var{b} are both column vectors return a column
+## order.  If @var{a} and @var{b} are both column vectors return a column
 ## vector, otherwise return a row vector.
 ##
 ## @deftypefnx {Function File} {[@var{c}, @var{ia}, @var{ib}] =} setxor (@var{a}, @var{b})
 ##
 ## Return index vectors @var{ia} and @var{ib} such that @code{a == c(ia)} and
 ## @code{b == c(ib)}.
 ## 
 ## @seealso{unique, union, intersect, setdiff, ismember}
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -18,32 +18,34 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{a}, @var{b}] =} arch_fit (@var{y}, @var{x}, @var{p}, @var{iter}, @var{gamma}, @var{a0}, @var{b0})
 ## Fit an ARCH regression model to the time series @var{y} using the
 ## scoring algorithm in Engle's original ARCH paper.  The model is
 ##
 ## @example
-## y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
-## h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(p+1) * e(t-p)^2
+## @group
+## y(t) = b(1) * x(t,1) + @dots{} + b(k) * x(t,k) + e(t),
+## h(t) = a(1) + a(2) * e(t-1)^2 + @dots{} + a(p+1) * e(t-p)^2
+## @end group
 ## @end example
 ##
 ## @noindent
 ## in which @math{e(t)} is @math{N(0, h(t))}, given a time-series vector
 ## @var{y} up to time @math{t-1} and a matrix of (ordinary) regressors
 ## @var{x} up to @math{t}.  The order of the regression of the residual
 ## variance is specified by @var{p}.
 ##
 ## If invoked as @code{arch_fit (@var{y}, @var{k}, @var{p})} with a
 ## positive integer @var{k}, fit an ARCH(@var{k}, @var{p}) process,
 ## i.e., do the above with the @math{t}-th row of @var{x} given by
 ##
 ## @example
-## [1, y(t-1), ..., y(t-k)]
+## [1, y(t-1), @dots{}, y(t-k)]
 ## @end example
 ##
 ## Optionally, one can specify the number of iterations @var{iter}, the
 ## updating factor @var{gamma}, and initial values @math{a0} and
 ## @math{b0} for the scoring algorithm.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -17,18 +17,20 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} arma_rnd (@var{a}, @var{b}, @var{v}, @var{t}, @var{n})
 ## Return a simulation of the ARMA model
 ##
 ## @example
-## x(n) = a(1) * x(n-1) + ... + a(k) * x(n-k)
-##      + e(n) + b(1) * e(n-1) + ... + b(l) * e(n-l)
+## @group
+## x(n) = a(1) * x(n-1) + @dots{} + a(k) * x(n-k)
+##      + e(n) + b(1) * e(n-1) + @dots{} + b(l) * e(n-l)
+## @end group
 ## @end example
 ##
 ## @noindent
 ## in which @var{k} is the length of vector @var{a}, @var{l} is the
 ## length of vector @var{b} and @var{e} is gaussian white noise with
 ## variance @var{v}.  The function returns a vector of length @var{t}.
 ##
 ## The optional parameter @var{n} gives the number of dummy
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -17,17 +17,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} bartlett (@var{m})
 ## Return the filter coefficients of a Bartlett (triangular) window of
 ## length @var{m}.
 ##
-## For a definition of the Bartlett window, see e.g. A. V. Oppenheim &
+## For a definition of the Bartlett window, see e.g., A. V. Oppenheim &
 ## R. W. Schafer, @cite{Discrete-Time Signal Processing}.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Coefficients of the Bartlett (triangular) window
 
 function c = bartlett (m)
 
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} blackman (@var{m})
 ## Return the filter coefficients of a Blackman window of length @var{m}.
 ##
-## For a definition of the  Blackman window, see e.g. A. V. Oppenheim &
+## For a definition of the Blackman window, see e.g., A. V. Oppenheim &
 ## R. W. Schafer, @cite{Discrete-Time Signal Processing}.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Coefficients of the Blackman window
 
 function c = blackman (m)
 
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -27,17 +27,17 @@
 ## If @var{v} is a vector of @math{N} elements corresponding to @math{N}
 ## time samples spaced of @math{Dt} each, then @code{fftshift (fft
 ## (@var{v}))} corresponds to frequencies
 ##
 ## @example
 ## f = ((1:N) - ceil(N/2)) / N / Dt
 ## @end example
 ##
-## If @var{v} is a matrix, the same holds for rows and columns. If 
+## If @var{v} is a matrix, the same holds for rows and columns.  If 
 ## @var{v} is an array, then the same holds along each dimension.
 ##
 ## The optional @var{dim} argument can be used to limit the dimension
 ## along which the permutation occurs.
 ## @end deftypefn
 
 ## Author: Vincent Cautaerts <vincent@comf5.comm.eng.osaka-u.ac.jp>
 ## Created: July 1997
diff --git a/scripts/signal/filter2.m b/scripts/signal/filter2.m
--- a/scripts/signal/filter2.m
+++ b/scripts/signal/filter2.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} filter2 (@var{b}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} filter2 (@var{b}, @var{x}, @var{shape})
-## Apply the 2-D FIR filter @var{b} to @var{x}. If the argument
+## Apply the 2-D FIR filter @var{b} to @var{x}.  If the argument
 ## @var{shape} is specified, return an array of the desired shape.
 ## Possible values are: 
 ##
 ## @table @asis
 ## @item 'full'
 ## pad @var{x} with zeros on all sides before filtering.
 ## @item 'same'
 ## unpadded @var{x} (default)
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hamming (@var{m})
 ## Return the filter coefficients of a Hamming window of length @var{m}.
 ##
-## For a definition of the Hamming window, see e.g. A. V. Oppenheim &
+## For a definition of the Hamming window, see e.g., A. V. Oppenheim &
 ## R. W. Schafer, @cite{Discrete-Time Signal Processing}.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Coefficients of the Hamming window
 
 function c = hamming (m)
 
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hanning (@var{m})
 ## Return the filter coefficients of a Hanning window of length @var{m}.
 ##
-## For a definition of this window type, see e.g. A. V. Oppenheim &
+## For a definition of this window type, see e.g., A. V. Oppenheim &
 ## R. W. Schafer, @cite{Discrete-Time Signal Processing}.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Coefficients of the Hanning window
 
 function c = hanning (m)
 
diff --git a/scripts/signal/rectangle_lw.m b/scripts/signal/rectangle_lw.m
--- a/scripts/signal/rectangle_lw.m
+++ b/scripts/signal/rectangle_lw.m
@@ -14,17 +14,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rectangle_lw (@var{n}, @var{b})
-## Rectangular lag window. Subfunction used for spectral density
+## Rectangular lag window.  Subfunction used for spectral density
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Rectangular lag window
 
 function retval = rectangle_lw (n, b)
 
diff --git a/scripts/signal/triangle_lw.m b/scripts/signal/triangle_lw.m
--- a/scripts/signal/triangle_lw.m
+++ b/scripts/signal/triangle_lw.m
@@ -14,17 +14,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} triangle_lw (@var{n}, @var{b})
-## Triangular lag window. Subfunction used for spectral density
+## Triangular lag window.  Subfunction used for spectral density
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Triangular lag window
 
 function retval = triangle_lw (n, b)
 
diff --git a/scripts/signal/yulewalker.m b/scripts/signal/yulewalker.m
--- a/scripts/signal/yulewalker.m
+++ b/scripts/signal/yulewalker.m
@@ -15,17 +15,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{a}, @var{v}] =} yulewalker (@var{c})
 ## Fit an AR (p)-model with Yule-Walker estimates given a vector @var{c}
-## of autocovariances @code{[gamma_0, ..., gamma_p]}.
+## of autocovariances @code{[gamma_0, @dots{}, gamma_p]}.
 ##
 ## Returns the AR coefficients, @var{a}, and the variance of white
 ## noise, @var{v}.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Fit AR model by Yule-Walker method
 
diff --git a/scripts/sparse/colperm.m b/scripts/sparse/colperm.m
--- a/scripts/sparse/colperm.m
+++ b/scripts/sparse/colperm.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{p} =} colperm (@var{s})
 ## Returns the column permutations such that the columns of
 ## @code{@var{s} (:, @var{p})} are ordered in terms of increase number
-## of non-zero elements. If @var{s} is symmetric, then @var{p} is chosen
+## of non-zero elements.  If @var{s} is symmetric, then @var{p} is chosen
 ## such that @code{@var{s} (@var{p}, @var{p})} orders the rows and
 ## columns with increasing number of non zeros elements.
 ## @end deftypefn
 
 function p = colperm (s)
 
   if (nargin != 1)
     print_usage ();
diff --git a/scripts/sparse/normest.m b/scripts/sparse/normest.m
--- a/scripts/sparse/normest.m
+++ b/scripts/sparse/normest.m
@@ -14,22 +14,22 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{n}, @var{c}] =} normest (@var{a}, @var{tol})
 ## Estimate the 2-norm of the matrix @var{a} using a power series
-## analysis. This is typically used for large matrices, where the cost
+## analysis.  This is typically used for large matrices, where the cost
 ## of calculating the @code{norm (@var{a})} is prohibitive and an approximation
 ## to the 2-norm is acceptable.
 ##
-## @var{tol} is the tolerance to which the 2-norm is calculated. By default
-## @var{tol} is 1e-6. @var{c} returns the number of iterations needed for
+## @var{tol} is the tolerance to which the 2-norm is calculated.  By default
+## @var{tol} is 1e-6.  @var{c} returns the number of iterations needed for
 ## @code{normest} to converge.
 ## @end deftypefn
 
 function [e1, c] = normest (A, tol)
   if (nargin < 2)
     tol = 1e-6;
   endif
   if (isa (A, "single"))
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -16,103 +16,103 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{x} =} pcg (@var{a}, @var{b}, @var{tol}, @var{maxit}, @var{m1}, @var{m2}, @var{x0}, @dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}, @var{eigest}] =} pcg (@dots{})
 ##
 ## Solves the linear system of equations @code{@var{a} * @var{x} =
-## @var{b}} by means of the  Preconditioned Conjugate Gradient iterative
-## method. The input arguments are
+## @var{b}} by means of the Preconditioned Conjugate Gradient iterative
+## method.  The input arguments are
 ##
 ## @itemize
 ## @item
 ## @var{a} can be either a square (preferably sparse) matrix or a
 ## function handle, inline function or string containing the name
-## of a function which computes @code{@var{a} * @var{x}}. In principle
+## of a function which computes @code{@var{a} * @var{x}}.  In principle
 ## @var{a} should be symmetric and positive definite; if @code{pcg}
 ## finds @var{a} to not be positive definite, you will get a warning
 ## message and the @var{flag} output parameter will be set.
 ## 
 ## @item
 ## @var{b} is the right hand side vector.
 ## 
 ## @item
 ## @var{tol} is the required relative tolerance for the residual error,
-## @code{@var{b} - @var{a} * @var{x}}. The iteration stops if @code{norm
+## @code{@var{b} - @var{a} * @var{x}}.  The iteration stops if @code{norm
 ## (@var{b} - @var{a} * @var{x}) <= @var{tol} * norm (@var{b} - @var{a} *
-## @var{x0})}. If @var{tol} is empty or is omitted, the function sets
+## @var{x0})}.  If @var{tol} is empty or is omitted, the function sets
 ## @code{@var{tol} = 1e-6} by default.
 ## 
 ## @item
 ## @var{maxit} is the maximum allowable number of iterations; if
 ## @code{[]} is supplied for @code{maxit}, or @code{pcg} has less
 ## arguments, a default value equal to 20 is used.
 ## 
 ## @item
 ## @var{m} = @var{m1} * @var{m2} is the (left) preconditioning matrix, so that the iteration is
 ## (theoretically) equivalent to solving by @code{pcg} @code{@var{P} *
 ## @var{x} = @var{m} \ @var{b}}, with @code{@var{P} = @var{m} \ @var{a}}.
 ## Note that a proper choice of the preconditioner may dramatically
-## improve the overall performance of the method. Instead of matrices
+## improve the overall performance of the method.  Instead of matrices
 ## @var{m1} and @var{m2}, the user may pass two functions which return 
 ## the results of applying the inverse of @var{m1} and @var{m2} to 
 ## a vector (usually this is the preferred way of using the preconditioner). 
 ## If @code{[]} is supplied for @var{m1}, or @var{m1} is omitted, no 
-## preconditioning is applied. If @var{m2} is omitted, @var{m} = @var{m1}
+## preconditioning is applied.  If @var{m2} is omitted, @var{m} = @var{m1}
 ## will be used as preconditioner.
 ## 
 ## @item
-## @var{x0} is the initial guess. If @var{x0} is empty or omitted, the 
+## @var{x0} is the initial guess.  If @var{x0} is empty or omitted, the 
 ## function sets @var{x0} to a zero vector by default.
 ## @end itemize
 ## 
 ## The arguments which follow @var{x0} are treated as parameters, and
 ## passed in a proper way to any of the functions (@var{a} or @var{m})
-## which are passed to @code{pcg}. See the examples below for further
-## details. The output arguments are
+## which are passed to @code{pcg}.  See the examples below for further
+## details.  The output arguments are
 ##
 ## @itemize
 ## @item
 ## @var{x} is the computed approximation to the solution of
 ## @code{@var{a} * @var{x} = @var{b}}.
 ## 
 ## @item
-## @var{flag} reports on the convergence. @code{@var{flag} = 0} means
+## @var{flag} reports on the convergence.  @code{@var{flag} = 0} means
 ## the solution converged and the tolerance criterion given by @var{tol}
-## is satisfied. @code{@var{flag} = 1} means that the @var{maxit} limit
-## for the iteration count was reached. @code{@var{flag} = 3} reports that
+## is satisfied.  @code{@var{flag} = 1} means that the @var{maxit} limit
+## for the iteration count was reached.  @code{@var{flag} = 3} reports that
 ## the (preconditioned) matrix was found not positive definite.
 ## 
 ## @item
 ## @var{relres} is the ratio of the final residual to its initial value,
 ## measured in the Euclidean norm.
 ## 
 ## @item
 ## @var{iter} is the actual number of iterations performed.
 ##
 ## @item 
 ## @var{resvec} describes the convergence history of the method.
 ## @code{@var{resvec} (i,1)} is the Euclidean norm of the residual, and
 ## @code{@var{resvec} (i,2)} is the preconditioned residual norm,
 ## after the (@var{i}-1)-th iteration, @code{@var{i} =
-## 1, 2, @dots{}, @var{iter}+1}. The preconditioned residual norm
+## 1, 2, @dots{}, @var{iter}+1}.  The preconditioned residual norm
 ## is defined as
 ## @code{norm (@var{r}) ^ 2 = @var{r}' * (@var{m} \ @var{r})} where
 ## @code{@var{r} = @var{b} - @var{a} * @var{x}}, see also the
-## description of @var{m}. If @var{eigest} is not required, only
+## description of @var{m}.  If @var{eigest} is not required, only
 ## @code{@var{resvec} (:,1)} is returned.
 ## 
 ## @item
 ## @var{eigest} returns the estimate for the smallest @code{@var{eigest}
 ## (1)} and largest @code{@var{eigest} (2)} eigenvalues of the
-## preconditioned matrix @code{@var{P} = @var{m} \ @var{a}}. In 
+## preconditioned matrix @code{@var{P} = @var{m} \ @var{a}}.  In 
 ## particular, if no preconditioning is used, the estimates for the
-## extreme eigenvalues of @var{a} are returned. @code{@var{eigest} (1)}
+## extreme eigenvalues of @var{a} are returned.  @code{@var{eigest} (1)}
 ## is an overestimate and @code{@var{eigest} (2)} is an underestimate, 
 ## so that @code{@var{eigest} (2) / @var{eigest} (1)} is a lower bound
 ## for @code{cond (@var{P}, 2)}, which nevertheless in the limit should
 ## theoretically be equal to the actual value of the condition number. 
 ## The method which computes @var{eigest} works only for symmetric positive
 ## definite @var{a} and @var{m}, and the user is responsible for
 ## verifying this assumption. 
 ## @end itemize
@@ -157,17 +157,17 @@
 ## @sc{Example 4:} @code{pcg} with a preconditioner: @var{l} * @var{u}.
 ## Faster than @sc{Example 3} since lower and upper triangular matrices 
 ## are easier to invert
 ##
 ## @example
 ## x = pcg (a, b, 1.e-6, 500, l, u);
 ## @end example
 ##
-## @sc{Example 5:} Preconditioned iteration, with full diagnostics. The
+## @sc{Example 5:} Preconditioned iteration, with full diagnostics.  The
 ## preconditioner (quite strange, because even the original matrix
 ## @var{a} is trivial) is defined as a function
 ## 
 ## @example
 ## @group
 ##   function y = apply_m (x)
 ##     k = floor (length (x) - 2);
 ##     y = x;
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -16,74 +16,74 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{x} =} pcr (@var{a}, @var{b}, @var{tol}, @var{maxit}, @var{m}, @var{x0}, @dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} pcr (@dots{})
 ## 
 ## Solves the linear system of equations @code{@var{a} * @var{x} =
-## @var{b}} by means of the  Preconditioned Conjugate Residuals iterative
-## method. The input arguments are
+## @var{b}} by means of the Preconditioned Conjugate Residuals iterative
+## method.  The input arguments are
 ##
 ## @itemize
 ## @item
 ## @var{a} can be either a square (preferably sparse) matrix or a
 ## function handle, inline function or string containing the name
-## of a function which computes @code{@var{a} * @var{x}}. In principle
+## of a function which computes @code{@var{a} * @var{x}}.  In principle
 ## @var{a} should be symmetric and non-singular; if @code{pcr}
 ## finds @var{a} to be numerically singular, you will get a warning
 ## message and the @var{flag} output parameter will be set.
 ## 
 ## @item
 ## @var{b} is the right hand side vector.
 ## 
 ## @item
 ## @var{tol} is the required relative tolerance for the residual error,
-## @code{@var{b} - @var{a} * @var{x}}. The iteration stops if @code{norm
+## @code{@var{b} - @var{a} * @var{x}}.  The iteration stops if @code{norm
 ## (@var{b} - @var{a} * @var{x}) <= @var{tol} * norm (@var{b} - @var{a} *
-## @var{x0})}. If @var{tol} is empty or is omitted, the function sets
+## @var{x0})}.  If @var{tol} is empty or is omitted, the function sets
 ## @code{@var{tol} = 1e-6} by default.
 ## 
 ## @item
 ## @var{maxit} is the maximum allowable number of iterations; if
 ## @code{[]} is supplied for @code{maxit}, or @code{pcr} has less
 ## arguments, a default value equal to 20 is used.
 ##
 ## @item
 ## @var{m} is the (left) preconditioning matrix, so that the iteration is
 ## (theoretically) equivalent to solving by @code{pcr} @code{@var{P} *
 ## @var{x} = @var{m} \ @var{b}}, with @code{@var{P} = @var{m} \ @var{a}}.
 ## Note that a proper choice of the preconditioner may dramatically
-## improve the overall performance of the method. Instead of matrix
+## improve the overall performance of the method.  Instead of matrix
 ## @var{m}, the user may pass a function which returns the results of 
 ## applying the inverse of @var{m} to a vector (usually this is the
-## preferred way of using the preconditioner). If @code{[]} is supplied
+## preferred way of using the preconditioner).  If @code{[]} is supplied
 ## for @var{m}, or @var{m} is omitted, no preconditioning is applied.
 ## 
 ## @item
-## @var{x0} is the initial guess. If @var{x0} is empty or omitted, the 
+## @var{x0} is the initial guess.  If @var{x0} is empty or omitted, the 
 ## function sets @var{x0} to a zero vector by default.
 ## @end itemize
 ## 
 ## The arguments which follow @var{x0} are treated as parameters, and
 ## passed in a proper way to any of the functions (@var{a} or @var{m})
-## which are passed to @code{pcr}. See the examples below for further
-## details. The output arguments are
+## which are passed to @code{pcr}.  See the examples below for further
+## details.  The output arguments are
 ##
 ## @itemize
 ## @item
 ## @var{x} is the computed approximation to the solution of
 ## @code{@var{a} * @var{x} = @var{b}}.
 ## 
 ## @item
-## @var{flag} reports on the convergence. @code{@var{flag} = 0} means
+## @var{flag} reports on the convergence.  @code{@var{flag} = 0} means
 ## the solution converged and the tolerance criterion given by @var{tol}
-## is satisfied. @code{@var{flag} = 1} means that the @var{maxit} limit
-## for the iteration count was reached. @code{@var{flag} = 3} reports t
+## is satisfied.  @code{@var{flag} = 1} means that the @var{maxit} limit
+## for the iteration count was reached.  @code{@var{flag} = 3} reports t
 ## @code{pcr} breakdown, see [1] for details.
 ## 
 ## @item
 ## @var{relres} is the ratio of the final residual to its initial value,
 ## measured in the Euclidean norm.
 ## 
 ## @item
 ## @var{iter} is the actual number of iterations performed.
@@ -120,17 +120,17 @@
 ##   function y = apply_a (x) 
 ##     y = [1:10]'.*x; 
 ##   endfunction
 ## 
 ##   x = pcr ("apply_a", b)
 ## @end group
 ## @end example
 ## 
-## @sc{Example 3:}  Preconditioned iteration, with full diagnostics. The
+## @sc{Example 3:}  Preconditioned iteration, with full diagnostics.  The
 ## preconditioner (quite strange, because even the original matrix
 ## @var{a} is trivial) is defined as a function
 ## 
 ## @example
 ## @group
 ##   function y = apply_m (x)		
 ##     k = floor (length(x)-2); 
 ##     y = x; 
diff --git a/scripts/sparse/spalloc.m b/scripts/sparse/spalloc.m
--- a/scripts/sparse/spalloc.m
+++ b/scripts/sparse/spalloc.m
@@ -13,34 +13,36 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{s} =} spalloc (@var{r}, @var{c}, @var{nz})
-## Returns an empty sparse matrix of size @var{r}-by-@var{c}. As Octave
+## Returns an empty sparse matrix of size @var{r}-by-@var{c}.  As Octave
 ## resizes sparse matrices at the first opportunity, so that no additional 
-## space is needed, the argument @var{nz} is ignored. This function is 
+## space is needed, the argument @var{nz} is ignored.  This function is 
 ## provided only for compatibility reasons.
 ##
 ## It should be noted that this means that code like
 ##
 ## @example
+## @group
 ## k = 5;
 ## nz = r * k;
 ## s = spalloc (r, c, nz)
 ## for j = 1:c
 ##   idx = randperm (r);
 ##   s (:, j) = [zeros(r - k, 1); rand(k, 1)] (idx);
 ## endfor
+## @end group
 ## @end example
 ##
-## will reallocate memory at each step. It is therefore vitally important
+## will reallocate memory at each step.  It is therefore vitally important
 ## that code like this is vectorized as much as possible.
 ## @seealso{sparse, nzmax}
 ## @end deftypefn
 
 function s = spalloc (r, c, nz)
 
   if (nargin < 2)
     print_usage ();
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -13,42 +13,46 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{s} =} spaugment (@var{a}, @var{c})
-## Creates the augmented matrix of @var{a}. This is given by
+## Creates the augmented matrix of @var{a}.  This is given by
 ##
 ## @example
+## @group
 ## [@var{c} * eye(@var{m}, @var{m}),@var{a}; @var{a}', zeros(@var{n},
 ## @var{n})]
+## @end group
 ## @end example
 ##
 ## @noindent
 ## This is related to the leasted squared solution of 
 ## @code{@var{a} \\ @var{b}}, by
 ## 
 ## @example
+## @group
 ## @var{s} * [ @var{r} / @var{c}; x] = [@var{b}, zeros(@var{n},
 ## columns(@var{b})]
+## @end group
 ## @end example
 ##
 ## @noindent
 ## where @var{r} is the residual error
 ##
 ## @example
 ## @var{r} = @var{b} - @var{a} * @var{x}
 ## @end example
 ##
 ## As the matrix @var{s} is symmetric indefinite it can be factorized
 ## with @code{lu}, and the minimum norm solution can therefore be found
-## without the need for a @code{qr} factorization. As the residual
+## without the need for a @code{qr} factorization.  As the residual
 ## error will be @code{zeros (@var{m}, @var{m})} for under determined
 ## problems, and example can be 
 ##
 ## @example
 ## @group
 ## m = 11; n = 10; mn = max(m ,n);
 ## a = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
 ##              [-1, 0, 1], m, n);
diff --git a/scripts/sparse/spconvert.m b/scripts/sparse/spconvert.m
--- a/scripts/sparse/spconvert.m
+++ b/scripts/sparse/spconvert.m
@@ -14,20 +14,20 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{x} =} spconvert (@var{m})
 ## This function converts for a simple sparse matrix format easily
-## produced by other programs into Octave's internal sparse format. The
+## produced by other programs into Octave's internal sparse format.  The
 ## input @var{x} is either a 3 or 4 column real matrix, containing
 ## the row, column, real and imaginary parts of the elements of the
-## sparse matrix. An element with a zero real and imaginary part can
+## sparse matrix.  An element with a zero real and imaginary part can
 ## be used to force a particular matrix size.
 ## @end deftypefn
 
 function s = spconvert (m)
 
   if (issparse (m))
     s = m;
   else
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -16,24 +16,24 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{b}, @var{c}] =} spdiags (@var{a})
 ## @deftypefnx {Function File} {@var{b} =} spdiags (@var{a}, @var{c})
 ## @deftypefnx {Function File} {@var{b} =} spdiags (@var{v}, @var{c}, @var{a})
 ## @deftypefnx {Function File} {@var{b} =} spdiags (@var{v}, @var{c}, @var{m}, @var{n})
-## A generalization of the function @code{diag}. Called with a single
+## A generalization of the function @code{diag}.  Called with a single
 ## input argument, the non-zero diagonals @var{c} of @var{A} are extracted.
 ## With two arguments the diagonals to extract are given by the vector 
 ## @var{c}.
 ##
 ## The other two forms of @code{spdiags} modify the input matrix by
-## replacing the diagonals. They use the columns of @var{v} to replace
-## the columns represented by the vector @var{c}. If the sparse matrix
+## replacing the diagonals.  They use the columns of @var{v} to replace
+## the columns represented by the vector @var{c}.  If the sparse matrix
 ## @var{a} is defined then the diagonals of this matrix are replaced.
 ## Otherwise a matrix of @var{m} by @var{n} is created with the
 ## diagonals given by @var{v}.
 ##
 ## Negative values of @var{c} represent diagonals below the main
 ## diagonal, and positive values of @var{c} diagonals above the main
 ## diagonal.
 ##
diff --git a/scripts/sparse/speye.m b/scripts/sparse/speye.m
--- a/scripts/sparse/speye.m
+++ b/scripts/sparse/speye.m
@@ -15,23 +15,23 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} speye (@var{m})
 ## @deftypefnx {Function File} {@var{y} =} speye (@var{m}, @var{n})
 ## @deftypefnx {Function File} {@var{y} =} speye (@var{sz})
-## Returns a sparse identity matrix. This is significantly more
+## Returns a sparse identity matrix.  This is significantly more
 ## efficient than @code{sparse (eye (@var{m}))} as the full matrix
 ## is not constructed.
 ##
 ## Called with a single argument a square matrix of size @var{m} by
-## @var{m} is created. Otherwise a matrix of @var{m} by @var{n} is
-## created. If called with a single vector argument, this argument 
+## @var{m} is created.  Otherwise a matrix of @var{m} by @var{n} is
+## created.  If called with a single vector argument, this argument 
 ## is taken to be the size of the matrix to create.
 ## @end deftypefn
 
 function s = speye (m, n)
   if (nargin == 1)
     if (isvector (m) && length(m) == 2)
       n = m(2);
       m = m(1);
diff --git a/scripts/sparse/spfun.m b/scripts/sparse/spfun.m
--- a/scripts/sparse/spfun.m
+++ b/scripts/sparse/spfun.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} spfun (@var{f},@var{x})
 ## Compute @code{f(@var{x})} for the non-zero values of @var{x}.
 ## This results in a sparse matrix with the same structure as 
-## @var{x}. The function @var{f} can be passed as a string, a
+## @var{x}.  The function @var{f} can be passed as a string, a
 ## function handle or an inline function.
 ## @end deftypefn
 
 function t = spfun (f, s)
 
   if (nargin != 2)
     print_usage ();
   endif
diff --git a/scripts/sparse/sphcat.m b/scripts/sparse/sphcat.m
--- a/scripts/sparse/sphcat.m
+++ b/scripts/sparse/sphcat.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} sphcat (@var{a1}, @var{a2}, @dots{}, @var{aN})
-## Return the horizontal concatenation of sparse matrices. This function
+## Return the horizontal concatenation of sparse matrices.  This function
 ## is obselete and @code{horzcat} should be used.
 ## @seealso {spvcat, vertcat, horzcat, cat}
 ## @end deftypefn
 
 function y = sphcat (varargin)
 
   persistent sphcat_warned = false;
 
diff --git a/scripts/sparse/spones.m b/scripts/sparse/spones.m
--- a/scripts/sparse/spones.m
+++ b/scripts/sparse/spones.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} spones (@var{x})
-## Replace the non-zero entries of @var{x} with ones. This creates a
+## Replace the non-zero entries of @var{x} with ones.  This creates a
 ## sparse matrix with the same structure as @var{x}.
 ## @end deftypefn
 
 function s = spones (s)
 
   if (nargin != 1)
     print_usage ();
   endif
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -17,22 +17,22 @@
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sprand (@var{m}, @var{n}, @var{d})
 ## @deftypefnx {Function File} {} sprand (@var{s})
-## Generate a random sparse matrix. The size of the matrix will be
+## Generate a random sparse matrix.  The size of the matrix will be
 ## @var{m} by @var{n}, with a density of values given by @var{d}.
 ## @var{d} should be between 0 and 1. Values will be uniformly
 ## distributed between 0 and 1.
 ##
-## Note: sometimes the actual density  may be a bit smaller than @var{d}. 
+## Note: sometimes the actual density may be a bit smaller than @var{d}. 
 ## This is unlikely to happen for large really sparse matrices.
 ##
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero.
 ## @seealso{sprandn}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -17,22 +17,22 @@
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sprandn (@var{m}, @var{n}, @var{d})
 ## @deftypefnx {Function File} {} sprandn (@var{s})
-## Generate a random sparse matrix. The size of the matrix will be
+## Generate a random sparse matrix.  The size of the matrix will be
 ## @var{m} by @var{n}, with a density of values given by @var{d}.
 ## @var{d} should be between 0 and 1. Values will be normally
 ## distributed with mean of zero and variance 1.
 ##
-## Note: sometimes the actual density  may be a bit smaller than @var{d}. 
+## Note: sometimes the actual density may be a bit smaller than @var{d}. 
 ## This is unlikely to happen for large really sparse matrices.
 ##
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero.
 ## @seealso{sprand}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -14,22 +14,22 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sprandsym (@var{n}, @var{d})
 ## @deftypefnx {Function File} {} sprandsym (@var{s})
-## Generate a symmetric random sparse matrix. The size of the matrix will be
+## Generate a symmetric random sparse matrix.  The size of the matrix will be
 ## @var{n} by @var{n}, with a density of values given by @var{d}.
 ## @var{d} should be between 0 and 1. Values will be normally
 ## distributed with mean of zero and variance 1.
 ##
-## Note: sometimes the actual density  may be a bit smaller than @var{d}. 
+## Note: sometimes the actual density may be a bit smaller than @var{d}. 
 ## This is unlikely to happen for large really sparse matrices.
 ##
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero in its lower
 ## triangular part.
 ## @seealso{sprand, sprandn}
 ## @end deftypefn
 
diff --git a/scripts/sparse/spvcat.m b/scripts/sparse/spvcat.m
--- a/scripts/sparse/spvcat.m
+++ b/scripts/sparse/spvcat.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} spvcat (@var{a1}, @var{a2}, @dots{}, @var{aN})
-## Return the vertical concatenation of sparse matrices. This function
+## Return the vertical concatenation of sparse matrices.  This function
 ## is obselete and @code{vertcat} should be used
 ## @seealso{sphcat, vertcat, horzcat, cat}
 ## @end deftypefn
 
 function y = spvcat (varargin)
 
   persistent spvcat_warned = false;
 
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -16,19 +16,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} spy (@var{x})
 ## @deftypefnx {Function File} {} spy (@dots{}, @var{markersize})
 ## @deftypefnx {Function File} {} spy (@dots{}, @var{line_spec})
-## Plot the sparsity pattern of the sparse matrix @var{x}. If the argument
+## Plot the sparsity pattern of the sparse matrix @var{x}.  If the argument
 ## @var{markersize} is given as an scalar value, it is used to determine the
-## point size in the plot. If the string @var{line_spec} is given it is
+## point size in the plot.  If the string @var{line_spec} is given it is
 ## passed to @code{plot} and determines the appearance of the plot.
 ## @seealso{plot}
 ## @end deftypefn
 
 function spy (x, varargin) 
 
   if (nargin < 1)
     print_usage ();
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
old mode 100755
new mode 100644
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -15,61 +15,61 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{s} =} svds (@var{a})
 ## @deftypefnx {Function File} {@var{s} =} svds (@var{a}, @var{k})
 ## @deftypefnx {Function File} {@var{s} =} svds (@var{a}, @var{k}, @var{sigma})
 ## @deftypefnx {Function File} {@var{s} =} svds (@var{a}, @var{k}, @var{sigma}, @var{opts})
 ## @deftypefnx {Function File} {[@var{u}, @var{s}, @var{v}, @var{flag}] =} svds (@dots{})
 ##
-## Find a few singular values of the matrix @var{a}. The singular values
+## Find a few singular values of the matrix @var{a}.  The singular values
 ## are calculated using 
 ##
 ## @example
 ## @group
 ## [@var{m}, @var{n}] = size(@var{a})
 ## @var{s} = eigs([sparse(@var{m}, @var{m}), @var{a}; @dots{}
 ##                 @var{a}', sparse(@var{n}, @var{n})])
 ## @end group
 ## @end example
 ##
 ## The eigenvalues returned by @code{eigs} correspond to the singular
-## values of @var{a}. The number of singular values to calculate is given
+## values of @var{a}.  The number of singular values to calculate is given
 ## by @var{k}, whose default value is 6.
 ## 
 ## The argument @var{sigma} can be used to specify which singular values
-## to find. @var{sigma} can be either the string 'L', the default, in 
-## which case the largest singular values of @var{a} are found. Otherwise
+## to find.  @var{sigma} can be either the string 'L', the default, in 
+## which case the largest singular values of @var{a} are found.  Otherwise
 ## @var{sigma} should be a real scalar, in which case the singular values
-## closest to @var{sigma} are found. Note that for relatively small values
+## closest to @var{sigma} are found.  Note that for relatively small values
 ## of @var{sigma}, there is the chance that the requested number of singular
-## values are not returned. In that case @var{sigma} should be increased.
+## values are not returned.  In that case @var{sigma} should be increased.
 ##
 ## If @var{opts} is given, then it is a structure that defines options
-## that @code{svds} will pass to @var{eigs}. The possible fields of this
-## structure are therefore determined by @code{eigs}. By default three
+## that @code{svds} will pass to @var{eigs}.  The possible fields of this
+## structure are therefore determined by @code{eigs}.  By default three
 ## fields of this structure are set by @code{svds}.
 ##
 ## @table @code
 ## @item tol
-## The required convergence tolerance for the singular values. @code{eigs}
-## is passed @var{tol} divided by @code{sqrt(2)}. The default value is 
+## The required convergence tolerance for the singular values.  @code{eigs}
+## is passed @var{tol} divided by @code{sqrt(2)}.  The default value is 
 ## 1e-10.
 ##
 ## @item maxit
-## The maximum number of iterations. The defaut is 300.
+## The maximum number of iterations.  The defaut is 300.
 ##
 ## @item disp
-## The level of diagnostic printout. If @code{disp} is 0 then there is no
-## printout. The default value is 0.
+## The level of diagnostic printout.  If @code{disp} is 0 then there is no
+## printout.  The default value is 0.
 ## @end table
 ##
 ## If more than one output argument is given, then @code{svds} also
-## calculates the left and right singular vectors of @var{a}. @var{flag}
-## is used to signal the convergence of @code{svds}. If @code{svds} 
+## calculates the left and right singular vectors of @var{a}.  @var{flag}
+## is used to signal the convergence of @code{svds}.  If @code{svds} 
 ## converges to the desired tolerance, then @var{flag} given by
 ##
 ## @example
 ## @group
 ## norm (@var{a} * @var{v} - @var{u} * @var{s}, 1) <= @dots{}
 ##         @var{tol} * norm (@var{a}, 1)
 ## @end group
 ## @end example
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} treelayout (@var{Tree})
 ## @deftypefnx {Function File} {} treelayout (@var{Tree}, @var{permutation})
-## treelayout lays out a tree or a forest. The first argument @var{Tree} is a vector of
+## treelayout lays out a tree or a forest.  The first argument @var{Tree} is a vector of
 ## predecessors, optional parameter @var{permutation} is an optional postorder permutation.
 ## The complexity of the algorithm is O(n) in
 ## terms of time and memory requirements.
 ## @seealso{etreeplot, gplot,treeplot}
 ## @end deftypefn
 
 function [x_coordinate, y_coordinate, height, s] = treelayout (tree, permutation)
   if (nargin < 1 || nargin > 2 || nargout > 4)
diff --git a/scripts/sparse/treeplot.m b/scripts/sparse/treeplot.m
--- a/scripts/sparse/treeplot.m
+++ b/scripts/sparse/treeplot.m
@@ -14,19 +14,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} treeplot (@var{tree})
 ## @deftypefnx {Function File} {} treeplot (@var{tree}, @var{line_style}, @var{edge_style})
-## Produces a graph of tree or forest. The first argument is vector of
+## Produces a graph of tree or forest.  The first argument is vector of
 ## predecessors, optional parameters @var{line_style} and @var{edge_style}
-## define the output style. The complexity of the algorithm is O(n) in
+## define the output style.  The complexity of the algorithm is O(n) in
 ## terms of is time and memory requirements.
 ## @seealso{etreeplot, gplot}
 ## @end deftypefn
 
 function treeplot (tree, node_s, edge_s)
 
   if (nargin < 1 || nargin > 3 || nargout > 0)
     print_usage ();
diff --git a/scripts/specfun/bessel.m b/scripts/specfun/bessel.m
--- a/scripts/specfun/bessel.m
+++ b/scripts/specfun/bessel.m
@@ -21,42 +21,42 @@
 ## @deftypefnx {Loadable Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})
 ## @deftypefnx {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})
 ## @deftypefnx {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})
 ## @deftypefnx {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})
 ## Compute Bessel or Hankel functions of various kinds:
 ## 
 ## @table @code
 ## @item besselj
-## Bessel functions of the first kind. If the argument @var{opt} is supplied, 
+## Bessel functions of the first kind.  If the argument @var{opt} is supplied, 
 ## the result is multiplied by @code{exp(-abs(imag(x)))}.
 ## @item bessely
-## Bessel functions of the second kind. If the argument @var{opt} is supplied,
+## Bessel functions of the second kind.  If the argument @var{opt} is supplied,
 ## the result is multiplied by @code{exp(-abs(imag(x)))}.
 ## @item besseli
 ## Modified Bessel functions of the first kind.  If the argument @var{opt} is supplied,
 ## the result is multiplied by @code{exp(-abs(real(x)))}.
 ## @item besselk
 ## Modified Bessel functions of the second kind.  If the argument @var{opt} is supplied,
 ## the result is multiplied by @code{exp(x)}.
 ## @item besselh
 ## Compute Hankel functions of the first (@var{k} = 1) or second (@var{k}
-## = 2) kind. If the argument @var{opt} is supplied, the result is multiplied by
+## = 2) kind.  If the argument @var{opt} is supplied, the result is multiplied by
 ## @code{exp (-I*@var{x})} for @var{k} = 1 or @code{exp (I*@var{x})} for
 ## @var{k} = 2.
 ## @end table
 ## 
 ## If @var{alpha} is a scalar, the result is the same size as @var{x}.
 ## If @var{x} is a scalar, the result is the same size as @var{alpha}.
 ## If @var{alpha} is a row vector and @var{x} is a column vector, the
 ## result is a matrix with @code{length (@var{x})} rows and
 ## @code{length (@var{alpha})} columns.  Otherwise, @var{alpha} and
 ## @var{x} must conform and the result will be the same size.
 ## 
-## The value of @var{alpha} must be real. The value of @var{x} may be
+## The value of @var{alpha} must be real.  The value of @var{x} may be
 ## complex.
 ## 
 ## If requested, @var{ierr} contains the following status information
 ## and is the same size as the result.
 ## 
 ## @enumerate 0
 ## @item
 ## Normal return.
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -15,21 +15,21 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{p} =} factor (@var{q})
 ## @deftypefnx {Function File} {[@var{p}, @var{n}] =} factor (@var{q})
 ##
-## Return prime factorization of @var{q}. That is @code{prod (@var{p})
-## == @var{q}}. If @code{@var{q} == 1}, returns 1. 
+## Return prime factorization of @var{q}.  That is @code{prod (@var{p})
+## == @var{q}}.  If @code{@var{q} == 1}, returns 1. 
 ##
 ## With two output arguments, returns the unique primes @var{p} and
-## their multiplicities. That is @code{prod (@var{p} .^ @var{n}) ==
+## their multiplicities.  That is @code{prod (@var{p} .^ @var{n}) ==
 ## @var{q}}.
 ## 
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 
 ## 2002-01-28 Paul Kienzle
 ## * remove recursion; only check existing primes for multiplicity > 1
diff --git a/scripts/specfun/factorial.m b/scripts/specfun/factorial.m
--- a/scripts/specfun/factorial.m
+++ b/scripts/specfun/factorial.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} factorial (@var{n})
-## Return the factorial of @var{n}. If @var{n} is scalar, this is
+## Return the factorial of @var{n}.  If @var{n} is scalar, this is
 ## equivalent to @code{prod (1:@var{n})}.  If @var{n} is an array,
 ## the factorial of the elements of the array are returned.
 ## @end deftypefn
 
 function x = factorial (n)
   if (nargin != 1)
     print_usage ();
   elseif (any (n(:) < 0 | n(:) != round (n(:))))
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -16,19 +16,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{l} =} legendre (@var{n}, @var{x})
 ## @deftypefnx {Function File} {@var{l} =} legendre (@var{n}, @var{x}, @var{normalization})
 ## Compute the Legendre function of degree @var{n} and order 
-## @var{m} = 0 ... N.  The optional argument, @var{normalization}, 
+## @var{m} = 0 @dots{} N.  The optional argument, @var{normalization}, 
 ## may be one of @code{"unnorm"}, @code{"sch"}, or @code{"norm"}.
-## The default is @code{"unnorm"}. The value of @var{n} must be a 
+## The default is @code{"unnorm"}.  The value of @var{n} must be a 
 ## non-negative scalar integer.  
 ##
 ## If the optional argument @var{normalization} is missing or is
 ## @code{"unnorm"}, compute the Legendre function of degree @var{n} and
 ## order @var{m} and return all values for @var{m} = 0 @dots{} @var{n}.
 ## The return value has one dimension more than @var{x}.
 ##
 ## The Legendre Function of degree @var{n} and order @var{m}:
diff --git a/scripts/specfun/nchoosek.m b/scripts/specfun/nchoosek.m
--- a/scripts/specfun/nchoosek.m
+++ b/scripts/specfun/nchoosek.m
@@ -32,26 +32,26 @@
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##  /   \
-##  | n |    n (n-1) (n-2) ... (n-k+1)       n!
+##  | n |    n (n-1) (n-2) @dots{} (n-k+1)       n!
 ##  |   |  = ------------------------- =  ---------
 ##  | k |               k!                k! (n-k)!
 ##  \   /
 ## @end group
 ## @end example
 ## @end ifnottex
 ##
 ## If @var{n} is a vector generate all combinations of the elements
-## of @var{n}, taken @var{k} at a time, one row per combination. The 
+## of @var{n}, taken @var{k} at a time, one row per combination.  The 
 ## resulting @var{c} has size @code{[nchoosek (length (@var{n}), 
 ## @var{k}), @var{k}]}.
 ##
 ## @code{nchoosek} works only for nonnegative integer arguments; use
 ## @code{bincoeff} for non-integer scalar arguments and for using vector
 ## arguments to compute many coefficients at once.
 ##
 ## @seealso{bincoeff}
diff --git a/scripts/specfun/perms.m b/scripts/specfun/perms.m
--- a/scripts/specfun/perms.m
+++ b/scripts/specfun/perms.m
@@ -14,28 +14,30 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} perms (@var{v})
 ##
-## Generate all permutations of @var{v}, one row per permutation. The
+## Generate all permutations of @var{v}, one row per permutation.  The
 ## result has size @code{factorial (@var{n}) * @var{n}}, where @var{n}
 ## is the length of @var{v}.
 ##
 ## As an example, @code{perms([1, 2, 3])} returns the matrix
 ## @example
+## @group
 ##   1   2   3
 ##   2   1   3
 ##   1   3   2
 ##   2   3   1
 ##   3   1   2
 ##   3   2   1
+## @end group
 ## @end example
 ## @end deftypefn
 
 function A = perms (v)
   if (nargin != 1)
     print_usage ();
   endif
   v = v(:);
diff --git a/scripts/specfun/reallog.m b/scripts/specfun/reallog.m
--- a/scripts/specfun/reallog.m
+++ b/scripts/specfun/reallog.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} reallog (@var{x})
-## Return the real natural logarithm of @var{x}. If any element results in the
+## Return the real natural logarithm of @var{x}.  If any element results in the
 ## return value being complex @code{reallog} produces an error.
 ## @seealso{log, realsqrt, realpow}
 ## @end deftypefn
 
 function y = reallog (x)
   if (nargin != 1)
     print_usage ();
   elseif (iscomplex (x) || any (x(:) < 0))
diff --git a/scripts/specfun/realpow.m b/scripts/specfun/realpow.m
--- a/scripts/specfun/realpow.m
+++ b/scripts/specfun/realpow.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} realpow (@var{x}, @var{y})
-## Return the element by element power operator. This is equivalent to
+## Return the element by element power operator.  This is equivalent to
 ## @code{@var{x} .^ @var{y}}, except that if the return value
 ## is complex @code{realpow} produces an error.
 ## @seealso{reallog, realsqrt}
 ## @end deftypefn
 
 function z = realpow (x, y)
   if (nargin != 2)
     print_usage ();
diff --git a/scripts/specfun/realsqrt.m b/scripts/specfun/realsqrt.m
--- a/scripts/specfun/realsqrt.m
+++ b/scripts/specfun/realsqrt.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} realsqrt (@var{x})
-## Return the real sqrt of @var{x}. If any element results in the
+## Return the real sqrt of @var{x}.  If any element results in the
 ## return value being complex @code{realsqrt} produces an error.
 ## @seealso{sqrt, reallog, realpow}
 ## @end deftypefn
 
 function y = realsqrt (x)
   if (nargin != 1)
     print_usage ();
   elseif (iscomplex (x) || any (x(:) < 0))
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -17,19 +17,19 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hadamard (@var{n})
-## Construct a Hadamard matrix @var{Hn} of size @var{n}-by-@var{n}. The 
+## Construct a Hadamard matrix @var{Hn} of size @var{n}-by-@var{n}.  The 
 ## size @var{n} must be of the form @code{2 ^ @var{k} * @var{p}} in which
-## @var{p} is one of 1, 12, 20 or 28. The returned matrix is normalized,
+## @var{p} is one of 1, 12, 20 or 28.  The returned matrix is normalized,
 ## meaning @code{Hn(:,1) == 1} and @code{H(1,:) == 1}.
 ##
 ## Some of the properties of Hadamard matrices are:
 ##
 ## @itemize @bullet
 ## @item
 ## @code{kron (@var{Hm}, @var{Hn})} is a Hadamard matrix of size 
 ## @var{m}-by-@var{n}.
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -32,29 +32,33 @@
 ## where
 ## $$
 ##   p(k) = -1^k \left( \matrix{ k+n-1 \cr k-1 } \right)
 ##               \left( \matrix{ n \cr k } \right)
 ##$$
 ## @end tex
 ## @ifnottex
 ## @example
+## @group
 ##
 ##             (i+j)         /n+i-1\  /n+j-1\   /i+j-2\ 2
 ##  A(i,j) = -1      (i+j-1)(       )(       ) (       )
 ##                           \ n-j /  \ n-i /   \ i-2 /
 ##
 ##         = p(i) p(j) / (i+j-1)
 ##
+## @end group
 ## @end example
 ## where
 ## @example
+## @group
 ##              k  /k+n-1\   /n\
 ##     p(k) = -1  (       ) (   )
 ##                 \ k-1 /   \k/
+## @end group
 ## @end example
 ## @end ifnottex
 ##
 ## The validity of this formula can easily be checked by expanding 
 ## the binomial coefficients in both formulas as factorials.  It can 
 ## be derived more directly via the theory of Cauchy matrices: 
 ## see J. W. Demmel, Applied Numerical Linear Algebra, page 92.
 ##
diff --git a/scripts/special-matrix/pascal.m b/scripts/special-matrix/pascal.m
--- a/scripts/special-matrix/pascal.m
+++ b/scripts/special-matrix/pascal.m
@@ -16,19 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} pascal (@var{n}, @var{t})
 ##
 ## Return the Pascal matrix of order @var{n} if @code{@var{t} = 0}.
 ## @var{t} defaults to 0. Return lower triangular Cholesky factor of 
-## the Pascal matrix if @code{@var{t} = 1}. This matrix is its own
+## the Pascal matrix if @code{@var{t} = 1}.  This matrix is its own
 ## inverse, that is @code{pascal (@var{n}, 1) ^ 2 == eye (@var{n})}.
-## If @code{@var{t} = 2}, return a transposed and  permuted version of
+## If @code{@var{t} = 2}, return a transposed and permuted version of
 ## @code{pascal (@var{n}, 1)}, which is the cube-root of the identity
 ## matrix.  That is @code{pascal (@var{n}, 2) ^ 3 == eye (@var{n})}.
 ##
 ## @seealso{hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz
 ##           hadamard, wilkinson, compan, rosser}
 ## @end deftypefn
 
 ## Author: Peter Ekberg
diff --git a/scripts/statistics/base/histc.m b/scripts/statistics/base/histc.m
--- a/scripts/statistics/base/histc.m
+++ b/scripts/statistics/base/histc.m
@@ -15,33 +15,33 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{n} =} histc (@var{y}, @var{edges})
 ## @deftypefnx {Function File} {@var{n} =} histc (@var{y}, @var{edges}, @var{dim})
-## @deftypefnx {Function File} {[@var{n}, @var{idx}] =} histc (...)
+## @deftypefnx {Function File} {[@var{n}, @var{idx}] =} histc (@dots{})
 ## Produce histogram counts.
 ##
 ## When @var{y} is a vector, the function counts the number of elements of
-## @var{y} that fall in the histogram bins defined by @var{edges}. This must be
+## @var{y} that fall in the histogram bins defined by @var{edges}.  This must be
 ## a vector of monotonically non-decreasing values that define the edges of the
-## histogram bins. So, @code{@var{n} (k)} contains the number of elements in
+## histogram bins.  So, @code{@var{n} (k)} contains the number of elements in
 ## @var{y} for which @code{@var{edges} (k) <= @var{y} < @var{edges} (k+1)}.
 ## The final element of @var{n} contains the number of elements of @var{y}
 ## that was equal to the last element of @var{edges}.
 ##
 ## When @var{y} is a @math{N}-dimensional array, the same operation as above is
-## repeated along dimension @var{dim}. If this argument is given, the operation
+## repeated along dimension @var{dim}.  If this argument is given, the operation
 ## is performed along the first non-singleton dimension.
 ##
 ## If a second output argument is requested an index matrix is also returned.
-## The @var{idx} matrix has same size as @var{y}. Each element of @var{idx}
+## The @var{idx} matrix has same size as @var{y}.  Each element of @var{idx}
 ## contains the index of the histogram bin in which the corresponding element
 ## of @var{y} was counted.
 ##
 ## @seealso{hist}
 ## @end deftypefn
 
 function [n, idx] = histc (data, edges, dim)
   ## Check input
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -18,17 +18,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} iqr (@var{x}, @var{dim})
 ## If @var{x} is a vector, return the interquartile range, i.e., the
 ## difference between the upper and lower quartile, of the input data.
 ##
 ## If @var{x} is a matrix, do the above for first non-singleton
-## dimension of @var{x}. If the option @var{dim} argument is given,
+## dimension of @var{x}.  If the option @var{dim} argument is given,
 ## then operate along this dimension.
 ## @end deftypefn
 
 ## Author KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Interquartile range
 
 function y = iqr (x, dim)
 
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -35,19 +35,21 @@
 ##
 ## @iftex
 ## @tex
 ## $$ \tau = {1 \over n(n-1)} \sum_{i,j} {\rm sign}(q_i-q_j) {\rm sign}(r_i-r_j) $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ## @example
+## @group
 ##          1    
 ## tau = -------   SUM sign (q(i) - q(j)) * sign (r(i) - r(j))
 ##       n (n-1)   i,j
+## @end group
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
 ## in which the
 ## @iftex
 ## @tex
 ## $q_i$ and $r_i$
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -32,17 +32,17 @@
 ##
 ## @example
 ## kurtosis (x) = N^(-1) std(x)^(-4) sum ((x - mean(x)).^4) - 3
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
 ## of @var{x}.  If @var{x} is a matrix, return the kurtosis over the
-## first non-singleton dimension. The optional argument @var{dim}
+## first non-singleton dimension.  The optional argument @var{dim}
 ## can be given to force the kurtosis to be given over that 
 ## dimension.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 29 July 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/statistics/base/meansq.m b/scripts/statistics/base/meansq.m
--- a/scripts/statistics/base/meansq.m
+++ b/scripts/statistics/base/meansq.m
@@ -18,17 +18,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} meansq (@var{x})
 ## @deftypefnx {Function File} {} meansq (@var{x}, @var{dim})
 ## For vector arguments, return the mean square of the values.
 ## For matrix arguments, return a row vector containing the mean square
-## of each column. With the optional @var{dim} argument, returns the
+## of each column.  With the optional @var{dim} argument, returns the
 ## mean squared of the values along this dimension.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute mean square
 
 function y = meansq (x, dim)
 
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -15,17 +15,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} median (@var{x}, @var{dim})
 ## If @var{x} is a vector, compute the median value of the elements of
-## @var{x}. If the elements of @var{x} are sorted, the median is defined
+## @var{x}.  If the elements of @var{x} are sorted, the median is defined
 ## as
 ## @iftex
 ## @tex
 ## $$
 ## {\rm median} (x) =
 ##   \cases{x(\lceil N/2\rceil), & $N$ odd;\cr
 ##           (x(N/2)+x(N/2+1))/2, & $N$ even.}
 ## $$
@@ -37,17 +37,17 @@
 ## @group
 ##             x(ceil(N/2)),             N odd
 ## median(x) =
 ##             (x(N/2) + x((N/2)+1))/2,  N even
 ## @end group
 ## @end example
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the median value for each
-## column and return them in a row vector. If the optional @var{dim}
+## column and return them in a row vector.  If the optional @var{dim}
 ## argument is given, operate along this dimension.
 ## @seealso{std, mean}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = median (a, dim)
 
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -13,24 +13,24 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{m}, @var{f}, @var{c}] =} mode (@var{x}, @var{dim})
-## Count the most frequently appearing value. @code{mode} counts the 
+## Count the most frequently appearing value.  @code{mode} counts the 
 ## frequency along the first non-singleton dimension and if two or more
 ## values have te same frequency returns the smallest of the two in
-## @var{m}. The dimension along which to count can be specified by the
+## @var{m}.  The dimension along which to count can be specified by the
 ## @var{dim} parameter.
 ##
 ## The variable @var{f} counts the frequency of each of the most frequently 
-## occurring elements. The cell array @var{c} contains all of the elements
+## occurring elements.  The cell array @var{c} contains all of the elements
 ## with the maximum frequency .
 ## @end deftypefn
 
 function [m, f, c] = mode (x, dim)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
diff --git a/scripts/statistics/base/prctile.m b/scripts/statistics/base/prctile.m
--- a/scripts/statistics/base/prctile.m
+++ b/scripts/statistics/base/prctile.m
@@ -14,27 +14,27 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} prctile (@var{x}, @var{p})
 ## @deftypefnx {Function File} {@var{q} =} prctile (@var{x}, @var{p}, @var{dim})
-## For a sample @var{x}, compute the the quantiles, @var{y}, corresponding
-## to the cumulative probability values, P, in percent. All non-numeric
+## For a sample @var{x}, compute the quantiles, @var{y}, corresponding
+## to the cumulative probability values, P, in percent.  All non-numeric
 ## values (NaNs) of X are ignored.
 ## 
-## If @var{x} is a matrix, compute the the percentiles for each column and
+## If @var{x} is a matrix, compute the percentiles for each column and
 ## return them in a matrix, such that the i-th row of @var{y} contains the 
 ## @var{p}(i)th percentiles of each column of @var{x}.
 ## 
 ## The optional argument @var{dim} determines the dimension along which
-## the percentiles are calculated. If @var{dim} is omitted, and @var{x} is
-## a vector or matrix, it defaults to 1 (column wise quantiles). In the 
+## the percentiles are calculated.  If @var{dim} is omitted, and @var{x} is
+## a vector or matrix, it defaults to 1 (column wise quantiles).  In the 
 ## instance that @var{x} is a N-d array, @var{dim} defaults to the first 
 ## dimension whose size greater than unity.
 ## 
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Description: Matlab style prctile function.
 
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -16,31 +16,31 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{q} =} quantile (@var{x}, @var{p})
 ## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim})
 ## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim}, @var{method})
 ## For a sample, @var{x}, calculate the quantiles, @var{q}, corresponding to
-## the cumulative probability values in @var{p}. All non-numeric values (NaNs) of
+## the cumulative probability values in @var{p}.  All non-numeric values (NaNs) of
 ## @var{x} are ignored.
 ##
 ## If @var{x} is a matrix, compute the quantiles for each column and
 ## return them in a matrix, such that the i-th row of @var{q} contains
 ## the @var{p}(i)th quantiles of each column of @var{x}.
 ## 
 ## The optional argument @var{dim} determines the dimension along which 
-## the percentiles are calculated. If @var{dim} is omitted, and @var{x} is
-## a vector or matrix, it defaults to 1 (column wise quantiles). In the 
+## the percentiles are calculated.  If @var{dim} is omitted, and @var{x} is
+## a vector or matrix, it defaults to 1 (column wise quantiles).  In the 
 ## instance that @var{x} is a N-d array, @var{dim} defaults to the first 
 ## dimension whose size greater than unity.
 ## 
 ## The methods available to calculate sample quantiles are the nine methods
-## used by R (http://www.r-project.org/). The default value is METHOD = 5.
+## used by R (http://www.r-project.org/).  The default value is METHOD = 5.
 ## 
 ## Discontinuous sample quantile methods 1, 2, and 3
 ## 
 ## @enumerate 1
 ## @item Method 1: Inverse of empirical distribution function.
 ## @item Method 2: Similar to method 1 but with averaging at discontinuities.
 ## @item Method 3: SAS definition: nearest even order statistic.
 ## @end enumerate
@@ -49,26 +49,26 @@
 ## interpolation function respecting each methods' representative cdf.
 ## 
 ## @enumerate 4
 ## @item Method 4: p(k) = k / n. That is, linear interpolation of the empirical cdf.
 ## @item Method 5: p(k) = (k - 0.5) / n. That is a piecewise linear function where 
 ## the knots are the values midway through the steps of the empirical cdf. 
 ## @item Method 6: p(k) = k / (n + 1).
 ## @item Method 7: p(k) = (k - 1) / (n - 1).
-## @item Method 8: p(k) = (k - 1/3) / (n + 1/3). The resulting quantile estimates 
+## @item Method 8: p(k) = (k - 1/3) / (n + 1/3).  The resulting quantile estimates 
 ## are approximately median-unbiased regardless of the distribution of @var{x}.
-## @item Method 9: p(k) = (k - 3/8) / (n + 1/4). The resulting quantile estimates 
+## @item Method 9: p(k) = (k - 3/8) / (n + 1/4).  The resulting quantile estimates 
 ## are approximately unbiased for the expected order statistics if @var{x} is 
 ## normally distributed.
 ## @end enumerate
 ## 
 ## Hyndman and Fan (1996) recommend method 8.  Maxima, S, and R
 ## (versions prior to 2.0.0) use 7 as their default.  Minitab and SPSS
-## use method 6.  Matlab uses method 5.
+## use method 6.  @sc{matlab} uses method 5.
 ## 
 ## References:
 ## 
 ## @itemize @bullet
 ## @item Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New
 ## S Language. Wadsworth & Brooks/Cole.
 ##
 ## @item Hyndman, R. J. and Fan, Y. (1996) Sample quantiles in
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -15,17 +15,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ranks (@var{x}, @var{dim})
 ## Return the ranks of @var{x} along the first non-singleton dimension
-## adjust for ties. If the optional argument @var{dim} is
+## adjust for ties.  If the optional argument @var{dim} is
 ## given, operate along this dimension.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute ranks
 
 ## This code was rather ugly, since it didn't use sort due to the
 ## fact of how to deal with ties. Now it does use sort and its
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} run_count (@var{x}, @var{n})
 ## Count the upward runs along the first non-singleton dimension of
 ## @var{x} of length 1, 2, @dots{}, @var{n}-1 and greater than or equal 
-## to @var{n}. If the optional argument @var{dim} is given operate
+## to @var{n}.  If the optional argument @var{dim} is given operate
 ## along this dimension
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Count upward runs
 
 function retval = run_count (x, n, dim)
 
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -32,17 +32,17 @@
 ##
 ## @example
 ## skewness (x) = N^(-1) std(x)^(-3) sum ((x - mean(x)).^3)
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
 ## of @var{x}.  If @var{x} is a matrix, return the skewness along the
-## first non-singleton dimension of the matrix. If the optional
+## first non-singleton dimension of the matrix.  If the optional
 ## @var{dim} argument is given, operate along this dimension.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 29 July 1994
 ## Adapted-By: jwe
 
 function retval = skewness (x, dim)
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -37,17 +37,17 @@
 ## @group
 ## std (x) = sqrt (sumsq (x - mean (x)) / (n - 1))
 ## @end group
 ## @end example
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the standard deviation for
 ## each column and return them in a row vector.
 ##
-## The argument @var{opt} determines the type of normalization to use. Valid values
+## The argument @var{opt} determines the type of normalization to use.  Valid values
 ## are
 ##
 ## @table @asis 
 ## @item 0:
 ##   normalizes with @math{N-1}, provides the square root of best unbiased estimator of 
 ##   the variance [default]
 ## @item 1:
 ##   normalizes with @math{N}, this provides the square root of the second moment around 
diff --git a/scripts/statistics/base/studentize.m b/scripts/statistics/base/studentize.m
--- a/scripts/statistics/base/studentize.m
+++ b/scripts/statistics/base/studentize.m
@@ -18,17 +18,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} studentize (@var{x}, @var{dim})
 ## If @var{x} is a vector, subtract its mean and divide by its standard
 ## deviation.
 ##
 ## If @var{x} is a matrix, do the above along the first non-singleton
-## dimension. If the optional argument @var{dim} is given then operate
+## dimension.  If the optional argument @var{dim} is given then operate
 ## along this dimension.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Subtract mean and divide by standard deviation
 
 function t = studentize (x, dim)
 
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -18,20 +18,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} discrete_rnd (@var{n}, @var{v}, @var{p})
 ## @deftypefnx {Function File} {} discrete_rnd (@var{v}, @var{p}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} discrete_rnd (@var{v}, @var{p}, @var{sz})
 ## Generate a row vector containing a random sample of size @var{n} from
 ## the univariate distribution which assumes the values in @var{v} with
-## probabilities @var{p}. @var{n} must be a scalar.
+## probabilities @var{p}.  @var{n} must be a scalar.
 ##
 ## If @var{r} and @var{c} are given create a matrix with @var{r} rows and
-## @var{c} columns. Or if @var{sz} is a vector, create a matrix of size
+## @var{c} columns.  Or if @var{sz} is a vector, create a matrix of size
 ## @var{sz}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from a discrete distribution
 
 function rnd = discrete_rnd (v, p, r, c)
 
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/distributions/empirical_rnd.m
--- a/scripts/statistics/distributions/empirical_rnd.m
+++ b/scripts/statistics/distributions/empirical_rnd.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} empirical_rnd (@var{n}, @var{data})
 ## @deftypefnx {Function File} {} empirical_rnd (@var{data}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} empirical_rnd (@var{data}, @var{sz})
 ## Generate a bootstrap sample of size @var{n} from the empirical
 ## distribution obtained from the univariate sample @var{data}.
 ##
 ## If @var{r} and @var{c} are given create a matrix with @var{r} rows and
-## @var{c} columns. Or if @var{sz} is a vector, create a matrix of size
+## @var{c} columns.  Or if @var{sz} is a vector, create a matrix of size
 ## @var{sz}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Bootstrap samples from the empirical distribution
 
 function rnd = empirical_rnd (data, r, c)
 
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} exprnd (@var{lambda}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} exprnd (@var{lambda}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the
 ## exponential distribution with mean @var{lambda}, which must be a
-## scalar or of size @var{r} by @var{c}. Or if @var{sz} is a vector, 
+## scalar or of size @var{r} by @var{c}.  Or if @var{sz} is a vector, 
 ## create a matrix of size @var{sz}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the size of @var{lambda}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the exponential distribution
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} geornd (@var{p}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} geornd (@var{p}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the
 ## geometric distribution with parameter @var{p}, which must be a scalar
 ## or of size @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are given create a matrix with @var{r} rows and
-## @var{c} columns. Or if @var{sz} is a vector, create a matrix of size
+## @var{c} columns.  Or if @var{sz} is a vector, create a matrix of size
 ## @var{sz}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the geometric distribution
 
 function rnd = geornd (p, r, c)
 
diff --git a/scripts/statistics/distributions/hygepdf.m b/scripts/statistics/distributions/hygepdf.m
--- a/scripts/statistics/distributions/hygepdf.m
+++ b/scripts/statistics/distributions/hygepdf.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hygepdf (@var{x}, @var{t}, @var{m}, @var{n})
 ## Compute the probability density function (PDF) at @var{x} of the
 ## hypergeometric distribution with parameters @var{t}, @var{m}, and
-## @var{n}. This is the probability of obtaining @var{x} marked items
+## @var{n}.  This is the probability of obtaining @var{x} marked items
 ## when randomly drawing a sample of size @var{n} without replacement
 ## from a population of total size @var{t} containing @var{m} marked items.
 ##
 ## The arguments must be of common size or scalar.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the hypergeometric distribution
diff --git a/scripts/statistics/distributions/hygernd.m b/scripts/statistics/distributions/hygernd.m
--- a/scripts/statistics/distributions/hygernd.m
+++ b/scripts/statistics/distributions/hygernd.m
@@ -23,17 +23,17 @@
 ## Return an @var{r} by @var{c} matrix of random samples from the
 ## hypergeometric distribution with parameters @var{t}, @var{m},
 ## and @var{n}.
 ##
 ## The parameters @var{t}, @var{m}, and @var{n} must positive integers
 ## with @var{m} and @var{n} not greater than @var{t}.
 ##
 ## The parameter @var{sz} must be scalar or a vector of matrix
-## dimensions. If @var{sz} is scalar, then a @var{sz} by @var{sz}
+## dimensions.  If @var{sz} is scalar, then a @var{sz} by @var{sz}
 ## matrix of random samples is generated.
 ## @end deftypefn
 
 function rnd = hygernd (t, m, n, r, c)
 
   if (nargin == 5)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("hygernd: r must be a positive integer");
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -22,19 +22,21 @@
 ## Return the CDF at @var{x} of the Kolmogorov-Smirnov distribution,
 ## @iftex
 ## @tex
 ## $$ Q(x) = \sum_{k=-\infty}^\infty (-1)^k \exp(-2 k^2 x^2) $$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ## @example
+## @group
 ##          Inf
 ## Q(x) =   SUM    (-1)^k exp(-2 k^2 x^2)
 ##        k = -Inf
+## @end group
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
 ## for @var{x} > 0.
 ##
 ## The optional parameter @var{tol} specifies the precision up to which
 ## the series should be evaluated;  the default is @var{tol} = @code{eps}.
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ b/scripts/statistics/distributions/logistic_rnd.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} logistic_rnd (@var{r}, @var{c})
 ## @deftypefnx {Function File} {} logistic_rnd (@var{sz})
 ## Return an @var{r} by @var{c} matrix of random numbers from the
-## logistic distribution. Or if @var{sz} is a vector, create a matrix of
+## logistic distribution.  Or if @var{sz} is a vector, create a matrix of
 ## @var{sz}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the logistic distribution
 
 function rnd = logistic_rnd (r, c)
 
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
--- a/scripts/statistics/distributions/lognrnd.m
+++ b/scripts/statistics/distributions/lognrnd.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} lognrnd (@var{mu}, @var{sigma}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} lognrnd (@var{mu}, @var{sigma}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the
-## lognormal distribution with parameters @var{mu} and @var{sigma}. Both
+## lognormal distribution with parameters @var{mu} and @var{sigma}.  Both
 ## @var{mu} and @var{sigma} must be scalar or of size @var{r} by @var{c}.
 ## Or if @var{sz} is a vector, create a matrix of size @var{sz}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{mu} and @var{sigma}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
diff --git a/scripts/statistics/distributions/nbinrnd.m b/scripts/statistics/distributions/nbinrnd.m
--- a/scripts/statistics/distributions/nbinrnd.m
+++ b/scripts/statistics/distributions/nbinrnd.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nbinrnd (@var{n}, @var{p}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} nbinrnd (@var{n}, @var{p}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the Pascal
 ## (negative binomial) distribution with parameters @var{n} and @var{p}.
 ## Both @var{n} and @var{p} must be scalar or of size @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
-## the common size of @var{n} and @var{p}. Or if @var{sz} is a vector, 
+## the common size of @var{n} and @var{p}.  Or if @var{sz} is a vector, 
 ## create a matrix of size @var{sz}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Pascal distribution
 
 function rnd = nbinrnd (n, p, r, c)
 
diff --git a/scripts/statistics/distributions/stdnormal_inv.m b/scripts/statistics/distributions/stdnormal_inv.m
--- a/scripts/statistics/distributions/stdnormal_inv.m
+++ b/scripts/statistics/distributions/stdnormal_inv.m
@@ -14,17 +14,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} stdnormal_inv (@var{x})
-## For each component of @var{x}, compute compute the quantile (the
+## For each component of @var{x}, compute the quantile (the
 ## inverse of the CDF) at @var{x} of the standard normal distribution.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the standard normal distribution
 
 function inv = stdnormal_inv (x)
 
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
--- a/scripts/statistics/distributions/trnd.m
+++ b/scripts/statistics/distributions/trnd.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} trnd (@var{n}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} trnd (@var{n}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the t
 ## (Student) distribution with @var{n} degrees of freedom.  @var{n} must
-## be a scalar or of size @var{r} by @var{c}. Or if @var{sz} is a
+## be a scalar or of size @var{r} by @var{c}.  Or if @var{sz} is a
 ## vector create a matrix of size @var{sz}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the size of @var{n}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the t distribution
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
--- a/scripts/statistics/distributions/wblrnd.m
+++ b/scripts/statistics/distributions/wblrnd.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} wblrnd (@var{scale}, @var{shape}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} wblrnd (@var{scale}, @var{shape}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the
 ## Weibull distribution with parameters @var{scale} and @var{shape}
-## which must be scalar or of size @var{r} by @var{c}. Or if @var{sz}
+## which must be scalar or of size @var{r} by @var{c}.  Or if @var{sz}
 ## is a vector return a matrix of size @var{sz}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{alpha} and @var{sigma}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Weibull distribution
diff --git a/scripts/statistics/distributions/wienrnd.m b/scripts/statistics/distributions/wienrnd.m
--- a/scripts/statistics/distributions/wienrnd.m
+++ b/scripts/statistics/distributions/wienrnd.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} wienrnd (@var{t}, @var{d}, @var{n})
 ## Return a simulated realization of the @var{d}-dimensional Wiener Process
 ## on the interval [0, @var{t}].  If @var{d} is omitted, @var{d} = 1 is
-## used. The first column of the return matrix contains time, the
+## used.  The first column of the return matrix contains time, the
 ## remaining columns contain the Wiener process.
 ##
 ## The optional parameter @var{n} gives the number of summands used for
 ## simulating the process over an interval of length 1.  If @var{n} is
 ## omitted, @var{n} = 1000 is used.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
--- a/scripts/statistics/models/logistic_regression.m
+++ b/scripts/statistics/models/logistic_regression.m
@@ -29,32 +29,34 @@
 ## @example
 ## [theta, beta] = logistic_regression (y, x)
 ## @end example
 ##
 ## @noindent
 ## fits the model
 ##
 ## @example
-## logit (gamma_i (x)) = theta_i - beta' * x,   i = 1...k-1
+## logit (gamma_i (x)) = theta_i - beta' * x,   i = 1 @dots{} k-1
 ## @end example
 ##
 ## The number of ordinal categories, @var{k}, is taken to be the number
 ## of distinct values of @code{round (@var{y})}.  If @var{k} equals 2,
 ## @var{y} is binary and the model is ordinary logistic regression.  The
 ## matrix @var{x} is assumed to have full column rank.
 ##
 ## Given @var{y} only, @code{theta = logistic_regression (y)}
 ## fits the model with baseline logit odds only.
 ##
 ## The full form is
 ##
 ## @example
+## @group
 ## [theta, beta, dev, dl, d2l, gamma]
 ##    = logistic_regression (y, x, print, theta, beta)
+## @end group
 ## @end example
 ##
 ## @noindent
 ## in which all output arguments and all input arguments except @var{y}
 ## are optional.
 ##
 ## Setting @var{print} to 1 requests summary information about the fitted
 ## model to be displayed.  Setting @var{print} to 2 requests information
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{pval}, @var{f}, @var{df_b}, @var{df_w}] =} anova (@var{y}, @var{g})
 ## Perform a one-way analysis of variance (ANOVA).  The goal is to test
 ## whether the population means of data taken from @var{k} different
 ## groups are all equal.
 ##
 ## Data may be given in a single vector @var{y} with groups specified by
 ## a corresponding vector of group labels @var{g} (e.g., numbers from 1
-## to @var{k}). This is the general form which does not impose any
+## to @var{k}).  This is the general form which does not impose any
 ## restriction on the number of data in each group or the group labels.
 ##
 ## If @var{y} is a matrix and @var{g} is omitted, each column of @var{y}
 ## is treated as a group.  This form is only appropriate for balanced
 ## ANOVA in which the numbers of samples from each group are all equal.
 ##
 ## Under the null of constant means, the statistic @var{f} follows an F
 ## distribution with @var{df_b} and @var{df_w} degrees of freedom.
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -27,17 +27,17 @@
 ## @code{">"} (greater than 0), or @code{"<"} (less than 0).  The
 ## default is the two-sided case.
 ##
 ## The optional argument string @var{method} specifies on which
 ## correlation coefficient the test should be based.  If @var{method} is
 ## @code{"pearson"} (default), the (usual) Pearson's product moment
 ## correlation coefficient is used.  In this case, the data should come
 ## from a bivariate normal distribution.  Otherwise, the other two
-## methods offer nonparametric alternatives. If @var{method} is
+## methods offer nonparametric alternatives.  If @var{method} is
 ## @code{"kendall"}, then Kendall's rank correlation tau is used.  If
 ## @var{method} is @code{"spearman"}, then Spearman's rank correlation
 ## rho is used.  Only the first character is necessary.
 ##
 ## The output is a structure with the following elements:
 ##
 ## @table @var
 ## @item pval
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -15,17 +15,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{pval}, @var{ks}] =} kolmogorov_smirnov_test (@var{x}, @var{dist}, @var{params}, @var{alt})
 ## Perform a Kolmogorov-Smirnov test of the null hypothesis that the
-## sample @var{x} comes from the (continuous) distribution dist. I.e.,
+## sample @var{x} comes from the (continuous) distribution dist.  I.e.,
 ## if F and G are the CDFs corresponding to the sample and dist,
 ## respectively, then the null is that F == G.
 ##
 ## The optional argument @var{params} contains a list of parameters of
 ## @var{dist}.  For example, to test whether a sample @var{x} comes from
 ## a uniform distribution on [2,4], use
 ##
 ## @example
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -31,17 +31,17 @@
 ##
 ## If the data contains ties (some value appears more than once)
 ## @var{k} is divided by
 ## 
 ## 1 - @var{sum_ties} / (@var{n}^3 - @var{n})
 ##
 ## where @var{sum_ties} is the sum of @var{t}^2 - @var{t} over each group
 ## of ties where @var{t} is the number of ties in the group and @var{n}
-## is the total number of values in the input data. For more info on
+## is the total number of values in the input data.  For more info on
 ## this adjustment see "Use of Ranks in One-Criterion Variance Analysis"
 ## in Journal of the American Statistical Association, Vol. 47,
 ## No. 260 (Dec 1952) by William H. Kruskal and W. Allen Wallis.
 ##
 ## The p-value (1 minus the CDF of this distribution at @var{k}) is
 ## returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -14,17 +14,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} manova (@var{y}, @var{g})
-## Perform a one-way multivariate analysis of variance (MANOVA). The
+## Perform a one-way multivariate analysis of variance (MANOVA).  The
 ## goal is to test whether the p-dimensional population means of data
 ## taken from @var{k} different groups are all equal.  All data are
 ## assumed drawn independently from p-dimensional normal distributions
 ## with the same covariance matrix.
 ##
 ## The data matrix is given by @var{y}.  As usual, rows are observations
 ## and columns are variables.  The vector @var{g} specifies the
 ## corresponding group labels (e.g., numbers from 1 to @var{k}).
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -17,32 +17,36 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} base2dec (@var{s}, @var{b})
 ## Convert @var{s} from a string of digits of base @var{b} into an
 ## integer.
 ##
 ## @example
+## @group
 ## base2dec ("11120", 3)
 ##      @result{} 123
+## @end group
 ## @end example
 ##
 ## If @var{s} is a matrix, returns a column vector with one value per
 ## row of @var{s}.  If a row contains invalid symbols then the
 ## corresponding value will be NaN.  Rows are right-justified before
 ## converting so that trailing spaces are ignored.
 ##
 ## If @var{b} is a string, the characters of @var{b} are used as the
 ## symbols for the digits of @var{s}.  Space (' ') may not be used as a
 ## symbol.
 ##
 ## @example
+## @group
 ## base2dec ("yyyzx", "xyz")
 ##      @result{} 123
+## @end group
 ## @end example
 ## @seealso{dec2base, dec2bin, bin2dec, hex2dec, dec2hex}
 ## @end deftypefn
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
 ## Adapted-by: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 
 function out = base2dec (d, base)
diff --git a/scripts/strings/bin2dec.m b/scripts/strings/bin2dec.m
--- a/scripts/strings/bin2dec.m
+++ b/scripts/strings/bin2dec.m
@@ -17,18 +17,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} bin2dec (@var{s})
 ## Return the decimal number corresponding to the binary number stored
 ## in the string @var{s}.  For example,
 ##
 ## @example
+## @group
 ## bin2dec ("1110")
 ##      @result{} 14
+## @end group
 ## @end example
 ##
 ## If @var{s} is a string matrix, returns a column vector of converted
 ## numbers, one per row of @var{s}.  Invalid rows evaluate to NaN.
 ## @seealso{dec2hex, base2dec, dec2base, hex2dec, dec2bin}
 ## @end deftypefn
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -17,30 +17,34 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dec2base (@var{n}, @var{b}, @var{len})
 ## Return a string of symbols in base @var{b} corresponding to
 ## the nonnegative integer @var{n}.
 ##
 ## @example
+## @group
 ## dec2base (123, 3)
 ##      @result{} "11120"
+## @end group
 ## @end example
 ##
 ## If @var{n} is a vector, return a string matrix with one row per value,
 ## padded with leading zeros to the width of the largest value.
 ##
 ## If @var{b} is a string then the characters of @var{b} are used as
 ## the symbols for the digits of @var{n}.  Space (' ') may not be used
 ## as a symbol.
 ##
 ## @example
+## @group
 ## dec2base (123, "aei")
 ##      @result{} "eeeia"
+## @end group
 ## @end example
 ##
 ## The optional third argument, @var{len}, specifies the minimum
 ## number of digits in the result.
 ## @seealso{base2dec, dec2bin, bin2dec, hex2dec, dec2hex}
 ## @end deftypefn
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
diff --git a/scripts/strings/dec2bin.m b/scripts/strings/dec2bin.m
--- a/scripts/strings/dec2bin.m
+++ b/scripts/strings/dec2bin.m
@@ -18,18 +18,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dec2bin (@var{n}, @var{len})
 ## Return a binary number corresponding to the nonnegative decimal number
 ## @var{n}, as a string of ones and zeros.  For example,
 ##
 ## @example
+## @group
 ## dec2bin (14)
 ##      @result{} "1110"
+## @end group
 ## @end example
 ##
 ## If @var{n} is a vector, returns a string matrix, one row per value,
 ## padded with leading zeros to the width of the largest value.
 ##
 ## The optional second argument, @var{len}, specifies the minimum
 ## number of digits in the result.
 ## @seealso{bin2dec, dec2base, base2dec, hex2dec, dec2hex}
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -18,18 +18,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dec2hex (@var{n}, @var{len})
 ## Return the hexadecimal string corresponding to the nonnegative 
 ## integer @var{n}.  For example,
 ##
 ## @example
+## @group
 ## dec2hex (2748)
 ##      @result{} "ABC"
+## @end group
 ## @end example
 ##
 ## If @var{n} is a vector, returns a string matrix, one row per value,
 ## padded with leading zeros to the width of the largest value.
 ##
 ## The optional second argument, @var{len}, specifies the minimum
 ## number of digits in the result.
 ## @seealso{hex2dec, dec2base, base2dec, bin2dec, dec2bin}
diff --git a/scripts/strings/hex2dec.m b/scripts/strings/hex2dec.m
--- a/scripts/strings/hex2dec.m
+++ b/scripts/strings/hex2dec.m
@@ -17,20 +17,22 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hex2dec (@var{s})
 ## Return the integer corresponding to the hexadecimal number stored
 ## in the string @var{s}.  For example,
 ##
 ## @example
+## @group
 ## hex2dec ("12B")
 ##      @result{} 299
 ## hex2dec ("12b")
 ##      @result{} 299
+## @end group
 ## @end example
 ##
 ## If @var{s} is a string matrix, returns a column vector of converted
 ## numbers, one per row of @var{s}.  Invalid rows evaluate to NaN.
 ## @seealso{dec2hex, base2dec, dec2base, bin2dec, dec2bin}
 ## @end deftypefn
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -19,18 +19,20 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} index (@var{s}, @var{t})
 ## @deftypefnx {Function File} {} index (@var{s}, @var{t}, @var{direction})
 ## Return the position of the first occurrence of the string @var{t} in the
 ## string @var{s}, or 0 if no occurrence is found.  For example,
 ##
 ## @example
+## @group
 ## index ("Teststring", "t")
 ##      @result{} 4
+## @end group
 ## @end example
 ##
 ## If @var{direction} is @samp{"first"}, return the first element found.
 ## If @var{direction} is @samp{"last"}, return the last element found.
 ## The @code{rindex} function is equivalent to @code{index} with
 ## @var{direction} set to @samp{"last"}.
 ##
 ## @strong{Caution:}  This function does not work for arrays of
diff --git a/scripts/strings/rindex.m b/scripts/strings/rindex.m
--- a/scripts/strings/rindex.m
+++ b/scripts/strings/rindex.m
@@ -19,18 +19,20 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rindex (@var{s}, @var{t})
 ## Return the position of the last occurrence of the character string
 ## @var{t} in the character string @var{s}, or 0 if no occurrence is
 ## found.  For example,
 ##
 ## @example
+## @group
 ## rindex ("Teststring", "t")
 ##      @result{} 6
+## @end group
 ## @end example
 ##
 ## @strong{Caution:}  This function does not work for arrays of
 ## character strings.
 ## @seealso{find, index}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
diff --git a/scripts/strings/strcmpi.m b/scripts/strings/strcmpi.m
--- a/scripts/strings/strcmpi.m
+++ b/scripts/strings/strcmpi.m
@@ -22,17 +22,17 @@
 ## arrays) @var{s1} and @var{s2} are the same, and 0 otherwise.
 ##
 ## If either @var{s1} or @var{s2} is a cell array of strings, then an array
 ## of the same size is returned, containing the values described above for
 ## every member of the cell array.  The other argument may also be a cell
 ## array of strings (of the same size or with only one element), char matrix
 ## or character string.
 ##
-## @strong{Caution:} For compatibility with @sc{Matlab}, Octave's strcmpi
+## @strong{Caution:} For compatibility with @sc{matlab}, Octave's strcmpi
 ## function returns 1 if the character strings are equal, and 0 otherwise.
 ## This is just the opposite of the corresponding C library function.
 ## @seealso{strcmp, strncmp, strncmpi}
 ## @end deftypefn
 
 ## Author: Bill Lash <lash@tellabs.com>
 ## Adapted-by: jwe
 
diff --git a/scripts/strings/strncmpi.m b/scripts/strings/strncmpi.m
--- a/scripts/strings/strncmpi.m
+++ b/scripts/strings/strncmpi.m
@@ -23,17 +23,17 @@
 ## 0 otherwise.
 ##
 ## If either @var{s1} or @var{s2} is a cell array of strings, then an array
 ## of the same size is returned, containing the values described above for
 ## every member of the cell array.  The other argument may also be a cell
 ## array of strings (of the same size or with only one element), char matrix
 ## or character string.
 ##
-## @strong{Caution:} For compatibility with @sc{Matlab}, Octave's strncmpi
+## @strong{Caution:} For compatibility with @sc{matlab}, Octave's strncmpi
 ## function returns 1 if the character strings are equal, and 0 otherwise.
 ## This is just the opposite of the corresponding C library function.
 ## @seealso{strcmp, strcmpi, strncmp}
 ## @end deftypefn
 
 function retval = strncmpi (s1, s2, n)
 
   if (nargin == 3)
diff --git a/scripts/strings/strrep.m b/scripts/strings/strrep.m
--- a/scripts/strings/strrep.m
+++ b/scripts/strings/strrep.m
@@ -18,18 +18,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strrep (@var{s}, @var{x}, @var{y})
 ## Replace all occurrences of the substring @var{x} of the string @var{s}
 ## with the string @var{y} and return the result.  For example,
 ##
 ## @example
+## @group
 ## strrep ("This is a test string", "is", "&%$")
 ##      @result{} "Th&%$ &%$ a test string"
+## @end group
 ## @end example
 ## @seealso{regexprep, strfind, findstr}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 11 November 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -24,18 +24,20 @@
 ##
 ## If @var{offset} is negative, extraction starts that far from the end of
 ## the string.  If @var{len} is omitted, the substring extends to the end
 ## of S.
 ##
 ## For example,
 ##
 ## @example
+## @group
 ## substr ("This is a test string", 6, 9)
 ##      @result{} "is a test"
+## @end group
 ## @end example
 ##
 ## This function is patterned after AWK.  You can get the same result by
 ## @code{@var{s}(@var{offset} : (@var{offset} + @var{len} - 1))}.
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -18,30 +18,30 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} assert (@var{cond})
 ## @deftypefnx {Function File} {} assert (@var{cond}, @var{errmsg}, @dots{})
 ## @deftypefnx {Function File} {} assert (@var{cond}, @{var{msg_id}, @var{errmsg}, @dots{})
 ## @deftypefnx {Function File} {} assert (@var{observed},@var{expected})
 ## @deftypefnx {Function File} {} assert (@var{observed},@var{expected},@var{tol})
 ##
-## Produces an error if the condition is not met. @code{assert} can be
+## Produces an error if the condition is not met.  @code{assert} can be
 ## called in three different ways.
 ##
 ## @table @code
 ## @item assert (@var{cond})
 ## @itemx assert (@var{cond}, @var{errmsg}, @dots{})
 ## @itemx assert (@var{cond}, @var{msg_id}, @var{errmsg}, @dots{})
 ## Called with a single argument @var{cond}, @code{assert} produces an
-## error if @var{cond} is zero. If called with a single argument a
-## generic error message. With more than one argument, the additional
+## error if @var{cond} is zero.  If called with a single argument a
+## generic error message.  With more than one argument, the additional
 ## arguments are passed to the @code{error} function.
 ##
 ## @item assert (@var{observed}, @var{expected})
-## Produce an error if observed is not the same as expected. Note that 
+## Produce an error if observed is not the same as expected.  Note that 
 ## observed and expected can be strings, scalars, vectors, matrices, 
 ## lists or structures.
 ##
 ## @item assert(@var{observed}, @var{expected}, @var{tol})
 ## Accept a tolerance when comparing numbers. 
 ## If @var{tol} is positive use it as an absolute tolerance, will produce an error if
 ## @code{abs(@var{observed} - @var{expected}) > abs(@var{tol})}.
 ## If @var{tol} is negative use it as a relative tolerance, will produce an error if
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -17,60 +17,64 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} demo ('@var{name}',@var{n})
 ##
 ## Runs any examples associated with the function '@var{name}'.  
 ## Examples are stored in the script file, or in a file with the same 
 ## name but no extension somewhere on your path.  To keep them separate 
-## from the usual script code, all lines are prefixed by @code{%!}. Each
+## from the usual script code, all lines are prefixed by @code{%!}.  Each
 ## example is introduced by the keyword 'demo' flush left to the prefix,
 ## with no intervening spaces.  The remainder of the example can contain 
-## arbitrary Octave code. For example:
+## arbitrary Octave code.  For example:
 ##
 ## @example
+## @group
 ##    %!demo
 ##    %! t=0:0.01:2*pi; x = sin(t);
 ##    %! plot(t,x)
 ##    %! %-------------------------------------------------
 ##    %! % the figure window shows one cycle of a sine wave
+## @end group
 ## @end example
 ##
 ## Note that the code is displayed before it is executed, so a simple
 ## comment at the end suffices.  It is generally not necessary to use
 ## disp or printf within the demo.
 ##
 ## Demos are run in a function environment with no access to external
-## variables. This means that all demos in your function must use
-## separate initialization code. Alternatively, you can combine your
+## variables.  This means that all demos in your function must use
+## separate initialization code.  Alternatively, you can combine your
 ## demos into one huge demo, with the code:
 ##
 ## @example
 ##    %! input("Press <enter> to continue: ","s");
 ## @end example
 ##
 ## between the sections, but this is discouraged.  Other techniques
 ## include using multiple plots by saying figure between each, or
 ## using subplot to put multiple plots in the same window.
 ##
 ## Also, since demo evaluates inside a function context, you cannot
 ## define new functions inside a demo.  Instead you will have to
 ## use @code{eval(example('function',n))} to see them.  Because eval only
 ## evaluates one line, or one statement if the statement crosses
 ## multiple lines, you must wrap your demo in "if 1 <demo stuff> endif"
-## with the 'if' on the same line as 'demo'. For example,
+## with the 'if' on the same line as 'demo'.  For example,
 ##
 ## @example
+## @group
 ##   %!demo if 1
 ##   %!  function y=f(x)
 ##   %!    y=x;
 ##   %!  endfunction
 ##   %!  f(3)
 ##   %! endif
+## @end group
 ## @end example
 ## @seealso{test, example}
 ## @end deftypefn
 
 ## FIXME: modify subplot so that gnuplot_has_multiplot == 0 causes it to
 ## use the current figure window but pause if not plotting in the
 ## first subplot.
 
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} example ('@var{name}',@var{n})
 ## @deftypefnx {Function File} {[@var{x}, @var{idx}] =} example ('@var{name}',@var{n})
 ##
 ##  Display the code for example @var{n} associated with the function 
-## '@var{name}', but do not run it. If @var{n} is not given, all examples 
+## '@var{name}', but do not run it.  If @var{n} is not given, all examples 
 ## are displayed.
 ##
 ## Called with output arguments, the examples are returned in the form of
 ## a string @var{x}, with @var{idx} indicating the ending position of the 
 ## various examples.
 ##
 ## See @code{demo} for a complete explanation.
 ## @seealso{demo, test}
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -19,28 +19,30 @@
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} fail (@var{code},@var{pattern})
 ## @deftypefnx {Function File} {} fail (@var{code},'warning',@var{pattern})
 ##
 ## Return true if @var{code} fails with an error message matching
-## @var{pattern}, otherwise produce an error. Note that @var{code}
+## @var{pattern}, otherwise produce an error.  Note that @var{code}
 ## is a string and if @var{code} runs successfully, the error produced is:
 ##
 ## @example
 ##           expected error but got none  
 ## @end example
 ##
 ## If the code fails with a different error, the message produced is:
 ##
 ## @example
+## @group
 ##           expected <pattern>
 ##           but got <text of actual error>
+## @end group
 ## @end example
 ##
 ## The angle brackets are not part of the output.
 ##
 ## Called with three arguments, the behavior is similar to 
 ## @code{fail(@var{code}, @var{pattern})}, but produces an error if no 
 ## warning is given during code execution or if the code fails.
 ##
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -28,39 +28,39 @@
 ## execution times of the two expressions will be compared.  Called 
 ## without output arguments the results are presented graphically.
 ##
 ## @table @code
 ## @item @var{f}
 ## The expression to evaluate.
 ##
 ## @item @var{max_n}
-## The maximum test length to run. Default value is 100.  Alternatively,
+## The maximum test length to run.  Default value is 100.  Alternatively,
 ## use @code{[min_n,max_n]} or for complete control, @code{[n1,n2,@dots{},nk]}.
 ##
 ## @item @var{init}
 ## Initialization expression for function argument values.  Use @var{k} 
 ## for the test number and @var{n} for the size of the test.  This should
 ## compute values for all variables listed in args.  Note that init will
 ## be evaluated first for @math{k = 0}, so things which are constant throughout
-## the test can be computed then. The default value is @code{@var{x} =
+## the test can be computed then.  The default value is @code{@var{x} =
 ## randn (@var{n}, 1);}.
 ##
 ## @item @var{f2}
 ## An alternative expression to evaluate, so the speed of the two
-## can be compared. Default is @code{[]}.
+## can be compared.  Default is @code{[]}.
 ##
 ## @item @var{tol}
 ## If @var{tol} is @code{Inf}, then no comparison will be made between the
 ## results of expression @var{f} and expression @var{f2}.  Otherwise,
 ## expression @var{f} should produce a value @var{v} and expression @var{f2} 
 ## should produce a value @var{v2}, and these shall be compared using 
-## @code{assert(@var{v},@var{v2},@var{tol})}. If @var{tol} is positive,
-## the tolerance is assumed to be absolute. If @var{tol} is negative,
-## the tolerance is assumed to be relative. The default is @code{eps}.
+## @code{assert(@var{v},@var{v2},@var{tol})}.  If @var{tol} is positive,
+## the tolerance is assumed to be absolute.  If @var{tol} is negative,
+## the tolerance is assumed to be relative.  The default is @code{eps}.
 ##
 ## @item @var{order}
 ## The time complexity of the expression @code{O(a n^p)}.  This
 ## is a structure with fields @code{a} and @code{p}.
 ##
 ## @item @var{n}
 ## The values @var{n} for which the expression was calculated and
 ## the execution time was greater than zero.
@@ -88,18 +88,20 @@
 ##
 ## @example
 ## speed ("for i = 1:n, y@{i@} = x(i); end", "", [1000,10000])
 ## @end example
 ##
 ## but it is if you preallocate the cell array @code{y}:
 ##
 ## @example
+## @group
 ## speed ("for i = 1:n, y@{i@} = x(i); end", ...
 ##        "x = rand (n, 1); y = cell (size (x));", [1000, 10000])
+## @end group
 ## @end example
 ##
 ## An attempt is made to approximate the cost of the individual 
 ## operations, but it is wildly inaccurate.  You can improve the
 ## stability somewhat by doing more work for each @code{n}.  For
 ## example:
 ##
 ## @example
@@ -109,42 +111,46 @@
 ## When comparing a new and original expression, the line on the
 ## speedup ratio graph should be larger than 1 if the new expression
 ## is faster.  Better algorithms have a shallow slope.  Generally, 
 ## vectorizing an algorithm will not change the slope of the execution 
 ## time graph, but it will shift it relative to the original.  For
 ## example:
 ##
 ## @example
+## @group
 ## speed ("v = sum (x)", "", [10000, 100000], ...
 ##        "v = 0; for i = 1:length (x), v += x(i); end")
+## @end group
 ## @end example
 ## 
 ## A more complex example, if you had an original version of @code{xcorr}
 ## using for loops and another version using an FFT, you could compare the
 ## run speed for various lags as follows, or for a fixed lag with varying
 ## vector lengths as follows:
 ##
 ## @example
+## @group
 ## speed ("v = xcorr (x, n)", "x = rand (128, 1);", 100,
 ##        "v2 = xcorr_orig (x, n)", -100*eps)
 ## speed ("v = xcorr (x, 15)", "x = rand (20+n, 1);", 100,
 ##        "v2 = xcorr_orig (x, n)", -100*eps)
+## @end group
 ## @end example
 ##
 ## Assuming one of the two versions is in @var{xcorr_orig}, this
 ## would compare their speed and their output values.  Note that the
 ## FFT version is not exact, so we specify an acceptable tolerance on
 ## the comparison @code{100*eps}, and the errors should be computed
 ## relatively, as @code{abs((@var{x} - @var{y})./@var{y})} rather than 
 ## absolutely as @code{abs(@var{x} - @var{y})}.
 ##
-## Type @code{example('speed')} to see some real examples. Note for 
+## Type @code{example('speed')} to see some real examples.  Note for 
 ## obscure reasons, you can't run examples 1 and 2 directly using 
-## @code{demo('speed')}. Instead use, @code{eval(example('speed',1))}
+## @code{demo('speed')}.  Instead use, @code{eval(example('speed',1))}
 ## and @code{eval(example('speed',2))}.
 ## @end deftypefn
 
 ## FIXME: consider two dimensional speedup surfaces for functions like kron.
 function [__order, __test_n, __tnew, __torig] ...
       = speed (__f1, __init, __max_n, __f2, __tol)
 
   if (nargin < 1 || nargin > 6)
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {} test @var{name} quiet|normal|verbose
 ## @deftypefnx {Function File} {} test ('@var{name}', 'quiet|normal|verbose', @var{fid})
 ## @deftypefnx {Function File} {} test ([], 'explain', @var{fid})
 ## @deftypefnx {Function File} {@var{success} =} test (@dots{})
 ## @deftypefnx {Function File} {[@var{n}, @var{max}] =} test (@dots{})
 ## @deftypefnx {Function File} {[@var{code}, @var{idx}] =} test ('@var{name}','grabdemo')
 ##
 ## Perform tests from the first file in the loadpath matching @var{name}.
-## @code{test} can be called as a command or as a function. Called with 
+## @code{test} can be called as a command or as a function.  Called with 
 ## a single argument @var{name}, the tests are run interactively and stop
 ## after the first error is encountered.
 ##
 ## With a second argument the tests which are performed and the amount of
 ## output is selected.
 ##
 ## @table @asis
 ## @item 'quiet'
@@ -40,31 +40,31 @@
 ## @item 'normal'
 ## Report all tests as they happen, but don't do tests which require 
 ## user interaction.
 ##
 ## @item 'verbose'
 ## Do tests which require user interaction.
 ## @end table
 ##
-## The argument @var{fid} can be used to allow batch processing. Errors
+## The argument @var{fid} can be used to allow batch processing.  Errors
 ## can be written to the already open file defined by @var{fid}, and 
 ## hopefully when Octave crashes this file will tell you what was happening
-## when it did. You can use @code{stdout} if you want to see the results as
+## when it did.  You can use @code{stdout} if you want to see the results as
 ## they happen.  You can also give a file name rather than an @var{fid}, in
 ## which case the contents of the file will be replaced with the log from 
 ## the current test.
 ##
 ## Called with a single output argument @var{success}, @code{test} returns
-## true if all of the tests were successful. Called with two output arguments
+## true if all of the tests were successful.  Called with two output arguments
 ## @var{n} and @var{max}, the number of successful tests and the total number
 ## of tests in the file @var{name} are returned.
 ##
 ## If the second argument is the string 'grabdemo', the contents of the demo
-## blocks are extracted but not executed. Code for all code blocks is
+## blocks are extracted but not executed.  Code for all code blocks is
 ## concatenated and returned as @var{code} with @var{idx} being a vector of
 ## positions of the ends of the demo blocks.
 ##
 ## If the second argument is 'explain', then @var{name} is ignored and an
 ## explanation of the line markers used is written to the file @var{fid}.
 ## @seealso{error, assert, fail, demo, example}
 ## @end deftypefn
 
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -15,25 +15,25 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{str} =} datestr (@var{date}, [@var{f}, [@var{p}]])
 ## Format the given date/time according to the format @code{f} and return
-## the result in @var{str}. @var{date} is a serial date number (see
+## the result in @var{str}.  @var{date} is a serial date number (see
 ## @code{datenum}) or a date vector (see @code{datevec}).  The value of
 ## @var{date} may also be a string or cell array of strings.
 ##
 ## @var{f} can be an integer which corresponds to one of the codes in
 ## the table below, or a date format string.
 ##
 ## @var{p} is the year at the start of the century in which two-digit years
-## are to be interpreted in. If not specified, it defaults to the current
+## are to be interpreted in.  If not specified, it defaults to the current
 ## year minus 50.
 ##
 ## For example, the date 730736.65149 (2000-09-07 15:38:09.0934) would be
 ## formatted as follows:
 ##
 ## @multitable @columnfractions 0.1 0.45 0.35
 ## @headitem Code @tab Format @tab Example
 ## @item  0 @tab dd-mmm-yyyy HH:MM:SS   @tab 07-Sep-2000 15:38:09
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -17,19 +17,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} datetick (@var{form})
 ## @deftypefnx {Function File} {} datetick (@var{axis}, @var{form})
 ## @deftypefnx {Function File} {} datetick (@dots{}, "keeplimits")
 ## @deftypefnx {Function File} {} datetick (@dots{}, "keepticks")
 ## @deftypefnx {Function File} {} datetick (@dots{ax}, @dots{})
-## Adds date formatted tick labels to an axis. The axis the apply the
+## Adds date formatted tick labels to an axis.  The axis the apply the
 ## ticks to is determined by @var{axis} that can take the values "x",
-## "y" or "z". The default value is "x". The formatting of the labels is
+## "y" or "z".  The default value is "x".  The formatting of the labels is
 ## determined by the variable @var{form}, that can either be a string in
 ## the format needed by @code{dateform}, or a positive integer that can
 ## be accepted by @code{datestr}.
 ## @seealso{datenum, datestr}
 ## @end deftypefn
 
 function datetick (varargin)
 
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -27,17 +27,17 @@
 ##
 ## A date vector is a row vector with six members, representing the year,
 ## month, day, hour, minute, and seconds respectively.
 ##
 ## @var{f} is the format string used to interpret date strings
 ## (see @code{datestr}).
 ##
 ## @var{p} is the year at the start of the century in which two-digit years
-## are to be interpreted in. If not specified, it defaults to the current
+## are to be interpreted in.  If not specified, it defaults to the current
 ## year minus 50.
 ## @seealso{datenum, datestr, date, clock, now}
 ## @end deftypefn
 
 ## Algorithm: Peter Baum (http://vsg.cape.com/~pbaum/date/date0.htm)
 
 ## Author: pkienzle <pkienzle@users.sf.net>
 ## Modified: bdenney <bill@givebillmoney.com>
diff --git a/scripts/time/etime.m b/scripts/time/etime.m
--- a/scripts/time/etime.m
+++ b/scripts/time/etime.m
@@ -17,19 +17,21 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} etime (@var{t1}, @var{t2})
 ## Return the difference (in seconds) between two time values returned from
 ## @code{clock}.  For example:
 ##
 ## @example
+## @group
 ## t0 = clock ();
-## # many computations later...
+## # many computations later@dots{}
 ## elapsed_time = etime (clock (), t0);
+## @end group
 ## @end example
 ##
 ## @noindent
 ## will set the variable @code{elapsed_time} to the number of seconds since
 ## the variable @code{t0} was set.
 ## @seealso{tic, toc, clock, cputime}
 ## @end deftypefn
 
