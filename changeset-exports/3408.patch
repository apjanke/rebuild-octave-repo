# HG changeset patch
# User jwe
# Date 947147366 0
#      Thu Jan 06 08:29:26 2000 +0000
# Node ID ae7adbb591e822babc7d746b6b9f327d5c87b2bc
# Parent  5e0a0b1cba437a52577cdbf9d727bbb193a24652
[project @ 2000-01-06 08:29:11 by jwe]

diff --git a/scripts/audio/lin2mu.m b/scripts/audio/lin2mu.m
--- a/scripts/audio/lin2mu.m
+++ b/scripts/audio/lin2mu.m
@@ -18,17 +18,17 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} lin2mu (@var{x})
 ## If the vector @var{x} represents mono audio data in 8- or 16-bit
 ## linear encoding, @code{lin2mu (@var{x})} is the corresponding mu-law
 ## encoding.
 ## @end deftypefn
-## @seealso{mu2lin, loadaudio, saveaudio, playaudio, setaudio, record}
+## @seealso{mu2lin, loadaudio, saveaudio, playaudio, setaudio, and record}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
 
 function y = lin2mu (x)
 
   if (nargin != 1)
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -25,17 +25,17 @@
 ## The extension @var{ext} determines how the data in the audio file is
 ## interpreted;  the extensions @file{lin} (default) and @file{raw}
 ## correspond to linear, the extensions @file{au}, @file{mu}, or @file{snd}
 ## to mu-law encoding.
 ## 
 ## The argument @var{bps} can be either 8 (default) or 16, and specifies
 ## the number of bits per sample used in the audio file.
 ## @end deftypefn
-## @seealso{lin2mu, mu2lin, saveaudio, playaudio, setaudio, record}
+## @seealso{lin2mu, mu2lin, saveaudio, playaudio, setaudio, and record}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 10 April 1994
 ## Adapted-By: jwe
 
 function X = loadaudio (name, ext, bit)
 
   if (nargin == 0 || nargin > 3)
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mu2lin (@var{x}, @var{bps})
 ## If the vector @var{x} represents mono audio data in mu-law encoding,
 ## @code{mu2lin} converts it to linear encoding.  The optional argument
 ## @var{bps} specifies whether the input data uses 8 bit per sample
 ## (default) or 16 bit.
 ## @end deftypefn
-## @seealso{lin2mu, loadaudio, saveaudio, playaudio, setaudio, record}
+## @seealso{lin2mu, loadaudio, saveaudio, playaudio, setaudio, and record}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 18 October 1994
 ## Adapted-By: jwe
 
 function y = mu2lin (x, bit)
 
   if (nargin == 1)
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -18,17 +18,17 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} playaudio (@var{name}, @var{ext})
 ## @deftypefnx {Function File} {} playaudio (@var{x})
 ## Plays the audio file @file{@var{name}.@var{ext}} or the audio data
 ## stored in the vector @var{x}.
 ## @end deftypefn
-## @seealso{lin2mu, mu2lin, loadaudio, saveaudio, setaudio, record}
+## @seealso{lin2mu, mu2lin, loadaudio, saveaudio, setaudio, and record}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 11 April 1994
 ## Adapted-By: jwe
 
 function playaudio (name, ext)
 
   usage_msg = "playaudio (name [, ext])  or  playaudio (X)";
diff --git a/scripts/audio/record.m b/scripts/audio/record.m
--- a/scripts/audio/record.m
+++ b/scripts/audio/record.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} record (@var{sec}, @var{sampling_rate})
 ## Records @var{sec} seconds of audio input into the vector @var{x}.  The
 ## default value for @var{sampling_rate} is 8000 samples per second, or
 ## 8kHz.  The program waits until the user types @key{RET} and then
 ## immediately starts to record.
 ## @end deftypefn
-## @seealso{lin2mu, mu2lin, loadaudio, saveaudio, playaudio, setaudio}
+## @seealso{lin2mu, mu2lin, loadaudio, saveaudio, playaudio, and setaudio}
 
 ## usage:  X = record (sec [, sampling_rate])
 ##
 ## Records sec seconds of audio into the vector X.
 ## The default value for the sampling_rate is 8000, ie. 8kHz.
 ## The program waits for you to hit the ENTER key, then the recording
 ## starts immediatly.
 
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*- 
 ## @deftypefn {Function File} {} saveaudio (@var{name}, @var{x}, @var{ext}, @var{bps})
 ## Saves a vector @var{x} of audio data to the file
 ## @file{@var{name}.@var{ext}}.  The optional parameters @var{ext} and
 ## @var{bps} determine the encoding and the number of bits per sample used
 ## in the audio file (see @code{loadaudio});  defaults are @file{lin} and
 ## 8, respectively.
 ## @end deftypefn
-## @seealso{lin2mu, mu2lin, loadaudio, playaudio, setaudio, record}
+## @seealso{lin2mu, mu2lin, loadaudio, playaudio, setaudio, and record}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 5 September 1994
 ## Adapted-By: jwe
 
 function saveaudio (name, X, ext, bit)
 
   if (nargin < 2 || nargin > 4)
diff --git a/scripts/control/are.m b/scripts/control/are.m
--- a/scripts/control/are.m
+++ b/scripts/control/are.m
@@ -53,17 +53,17 @@
 ## @var{x}: solution of the ARE.
 ## 
 ## @strong{Method}
 ## Laub's Schur method (IEEE Transactions on
 ## Automatic Control, 1979) is applied to the appropriate Hamiltonian
 ## matrix.
 ## 
 ## @end deftypefn
-## @seealso{balance, dare}
+## @seealso{balance and dare}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 
 function x = are (a, b, c, opt)
 
   if (nargin == 3 || nargin == 4)
     if (nargin == 4)
diff --git a/scripts/control/dare.m b/scripts/control/dare.m
--- a/scripts/control/dare.m
+++ b/scripts/control/dare.m
@@ -63,17 +63,17 @@
 ## Generalized eigenvalue approach (Van Dooren; SIAM J.
 ##  Sci. Stat. Comput., Vol 2) applied  to the appropriate symplectic pencil.
 ## 
 ##  See also: Ran and Rodman, "Stable Hermitian Solutions of Discrete
 ##  Algebraic Riccati Equations," Mathematics of Control, Signals and
 ##  Systems, Vol 5, no 2 (1992)  pp 165-194.
 ## 
 ## @end deftypefn
-## @seealso{balance, are}
+## @seealso{balance and are}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function x = dare (a, b, c, r, opt)
 
   if (nargin == 4 | nargin == 5)
diff --git a/scripts/control/impulse.m b/scripts/control/impulse.m
--- a/scripts/control/impulse.m
+++ b/scripts/control/impulse.m
@@ -36,17 +36,17 @@
 ## the number of data values.
 ## 
 ##  Both parameters @var{tstop} and @var{n} can be omitted and will be
 ##  computed from the eigenvalues of the A-Matrix.
 ## @end table
 ## @strong{Outputs}
 ## @var{y}, @var{t}: impulse response
 ## @end deftypefn
-## @seealso{step, stepimp}
+## @seealso{step and stepimp}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 ## modified by
 
 function [y, t] = impulse (sys, inp, tstop, n)
 
diff --git a/scripts/control/is_controllable.m b/scripts/control/is_controllable.m
--- a/scripts/control/is_controllable.m
+++ b/scripts/control/is_controllable.m
@@ -31,33 +31,36 @@
 ## @item tol
 ## optional roundoff paramter.  default value: @code{10*eps}
 ## @end table
 ## 
 ## @strong{Outputs}
 ## @table @var
 ## @item retval
 ## Logical flag; returns true (1) if the system @var{sys} or the
-## pair (@var{a},@var{b}) is controllable, whichever was passed as input arguments.
+## pair (@var{a},@var{b}) is controllable, whichever was passed as input
+## arguments.
 ## @item U
 ##  U is an orthogonal basis of the controllable subspace. 
 ## @end table
 ## 
 ## @strong{Method}
 ## Controllability is determined by applying Arnoldi iteration with
 ## complete re-orthogonalization to obtain an orthogonal basis of the
 ## Krylov subspace
 ## @example
 ## span ([b,a*b,...,a^@{n-1@}*b]).
 ## @end example
-## The Arnoldi iteration is executed with @code{krylov} if the system has a single input; otherwise a block Arnoldi iteration is performed with @code{krylovb}.
+## The Arnoldi iteration is executed with @code{krylov} if the system
+## has a single input; otherwise a block Arnoldi iteration is performed
+## with @code{krylovb}.
 ## 
 ## @end deftypefn
 ## @seealso{size, rows, columns, length, is_matrix, is_scalar, is_vector
-## is_observable, is_stabilizable, is_detectable, krylov, krylovb}
+## is_observable, is_stabilizable, is_detectable, krylov, and krylovb}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for packed systems
 
 function [retval, U] = is_controllable (a, b, tol)
 
diff --git a/scripts/control/is_detectable.m b/scripts/control/is_detectable.m
--- a/scripts/control/is_detectable.m
+++ b/scripts/control/is_detectable.m
@@ -19,23 +19,24 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { [@var{retval}, @var{U}] =} is_detectable (@var{a}, @var{c}@{, @var{tol}@})
 ## @deftypefnx {Function File } { [@var{retval}, @var{U}] =} is_detectable (@var{sys}@{, @var{tol}@})
 ## Test for detactability (observability of unstable modes) of (@var{a},@var{c}).  
 ## 
 ##  Returns 1 if the system @var{a} or the pair (@var{a},@var{c})is 
 ##  detectable, 0 if not.
 ## 
-## @strong{See} @code{is_stabilizable} for detailed description of arguments and
-## computational method.
+## @strong{See} @code{is_stabilizable} for detailed description of
+## arguments and computational method.
 ## 
 ##  Default: tol = 10*norm(a,'fro')*eps 
 ## 
 ## @end deftypefn
-## @seealso{is_stabilizable, size, rows, columns, length, is_matrix, is_scalar, is_vector}
+## @seealso{is_stabilizable, size, rows, columns, length, is_matrix,
+## is_scalar, and is_vector}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
 function [retval, U] = is_detectable (a, c, tol)
 
   if( nargin < 1) 
diff --git a/scripts/control/is_observable.m b/scripts/control/is_observable.m
--- a/scripts/control/is_observable.m
+++ b/scripts/control/is_observable.m
@@ -24,17 +24,17 @@
 ##  Default: tol = 10*norm(a,'fro')*eps
 ## 
 ##  Returns 1 if the system @var{sys} or the pair (@var{a},@var{c}) is 
 ##  observable, 0 if not.
 ## 
 ## @strong{See} @code{is_controllable} for detailed description of arguments
 ## and default values.
 ## @end deftypefn
-## @seealso{size, rows, columns, length, is_matrix, is_scalar, is_vector}
+## @seealso{size, rows, columns, length, is_matrix, is_scalar, and is_vector}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
 function [retval, U] = is_observable (a, c, tol)
 
   if( nargin < 1) 
diff --git a/scripts/control/is_stable.m b/scripts/control/is_stable.m
--- a/scripts/control/is_stable.m
+++ b/scripts/control/is_stable.m
@@ -33,17 +33,17 @@
 ## stable if eig(a) in unit circle
 ## 
 ## @item @var{dflg} == 0
 ## stable if eig(a) in open LHP (default)
 ## @end table
 ## @end table
 ## @end deftypefn
 ## @seealso{size, rows, columns, length, is_matrix, is_scalar, is_vector
-##     is_observable, is_stabilizable, is_detectable, krylov, krylovb}
+## is_observable, is_stabilizable, is_detectable, krylov, and krylovb}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for systems
 ## Updated to simpler form by a.s.hodel 1998
 
 function retval = is_stable (a, tol, disc)
 
diff --git a/scripts/control/lqg.m b/scripts/control/lqg.m
--- a/scripts/control/lqg.m
+++ b/scripts/control/lqg.m
@@ -10,17 +10,17 @@
 ## Octave is distributed in the hope that it will be useful, but WITHOUT 
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 ## for more details.
 ## 
 ## You should have received a copy of the GNU General Public License 
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
+
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{K}, @var{Q}, @var{P}, @var{Ee}, @var{Er}] =} lqg(@var{sys}, @var{Sigw}, @var{Sigv}, @var{Q}, @var{R}, @var{in_idx})
 ## Design a linear-quadratic-gaussian optimal controller for the system
 ## @example
 ## dx/dt = A x + B u + G w       [w]=N(0,[Sigw 0    ])
 ##     y = C x + v               [v]  (    0   Sigv ])
 ## @end example
 ## or
@@ -28,42 +28,45 @@
 ## x(k+1) = A x(k) + B u(k) + G w(k)       [w]=N(0,[Sigw 0    ])
 ##   y(k) = C x(k) + v(k)                  [v]  (    0   Sigv ])
 ## @end example
 ## 
 ## @strong{Inputs}
 ## @table @var
 ## @item  sys
 ## system data structure
-## @item  Sigw, Sigv
+## @item  Sigw
+## @itemx  Sigv
 ## intensities of independent Gaussian noise processes (as above)
-## @item  Q, R
+## @item  Q
+## @itemx  R
 ## state, control weighting respectively.  Control ARE is
 ## @item  in_idx
 ## indices of controlled inputs
 ## 
 ##      default: last dim(R) inputs are assumed to be controlled inputs, all
 ##               others are assumed to be noise inputs.
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item    K
-## system data structure format LQG optimal controller
-## (Obtain A,B,C matrices with @code{sys2ss}, @code{sys2tf}, or @code{sys2zp} as appropriate)
+## system data structure format LQG optimal controller (Obtain A,B,C
+## matrices with @code{sys2ss}, @code{sys2tf}, or @code{sys2zp} as
+## appropriate)
 ## @item    P
 ## Solution of control (state feedback) algebraic Riccati equation
 ## @item    Q
 ## Solution of estimation algebraic Riccati equation
 ## @item    Ee
 ## estimator poles
 ## @item    Es
 ## controller poles
 ## @end table
 ## @end deftypefn
-## @seealso{h2syn, lqe, lqr}
+## @seealso{h2syn, lqe, and lqr}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## revised for new system format August 1996
 
 function [K, Q1, P1, Ee, Er] = lqg (sys, Sigw, Sigv, Q, R, input_list)
 
   if ( (nargin < 5) | (nargin > 6))
diff --git a/scripts/control/polyout.m b/scripts/control/polyout.m
--- a/scripts/control/polyout.m
+++ b/scripts/control/polyout.m
@@ -12,26 +12,26 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } { @var{y} =} polyout ( @var{c}@{, @var{x}@})
+## @deftypefn {Function File} {@var{y} =} polyout (@var{c}@{, @var{x}@})
 ## write formatted polynomial 
 ## @example
 ##    c(x) = c(1) * x^n + ... + c(n) x + c(n+1)
 ## @end example
 ##  to string @var{y} or to the screen (if @var{y} is omitted)
 ##  @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
 ## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue, 
-## filter, polyderiv, polyinteg}
+## filter, polyderiv, and polyinteg}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: May 1995
 ## Nov 1998: Correctly handles complex coefficients
   
 function y = polyout (c, x)
 
   if (nargin < 1 ) || (nargin > 2) || (nargout < 0 ) || (nargout > 1)
diff --git a/scripts/control/step.m b/scripts/control/step.m
--- a/scripts/control/step.m
+++ b/scripts/control/step.m
@@ -38,17 +38,17 @@
 ##  Both parameters @var{tstop} and @var{n} can be omitted and will be
 ##  computed from the eigenvalues of the A-Matrix.
 ## @end table
 ## @strong{Outputs}
 ## @var{y}, @var{t}: impulse response
 ## 
 ## When invoked with the output paramter y the plot is not displayed.  
 ## @end deftypefn
-## @seealso{impulse, stepimp}
+## @seealso{impulse and stepimp}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 30, 1997
 ## based on lsim.m of Scottedward Hodel
 
 function [y, t] = step (sys, inp, tstop, n)
 
   if((nargin < 1) || (nargin > 4))
diff --git a/scripts/control/stepimp.m b/scripts/control/stepimp.m
--- a/scripts/control/stepimp.m
+++ b/scripts/control/stepimp.m
@@ -24,17 +24,17 @@
 ## 
 ## Produces a plot or the response data for system sys.
 ## 
 ## Limited argument checking; "do not attempt to do this at home".
 ## Used internally in @code{impulse}, @code{step}. Use @code{step}
 ## or @code{impulse} instead.
 ## 
 ## @end deftypefn
-## @seealso{step, impulse}
+## @seealso{step and impulse}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 
 function [y, t] = stepimp (sitype, sys, inp, tstop, n)
 
   if (sitype == 1)         IMPULSE = 0;
diff --git a/scripts/control/sysdimensions.m b/scripts/control/sysdimensions.m
--- a/scripts/control/sysdimensions.m
+++ b/scripts/control/sysdimensions.m
@@ -58,17 +58,17 @@
 ##  number of system outputs
 ## @item  yd
 ##  binary vector; @var{yd}(@var{ii}) is nonzero if output @var{ii} is
 ## discrete.
 ## @math{yd(ii) = 0} if output @var{ii} is continous
 ## @end table
 ## 
 ## @end deftypefn
-## @seealso{sysgetsignals, sysgettsam}
+## @seealso{sysgetsignals and sysgettsam}
 
 function [n, nz, m, p, yd] = sysdimensions (sys, opt)
 
   if(nargout > 5 | nargin < 1 | nargin > 2)
     usage("[n,nz,m,p[,yd]] = sysdimensions(sys{,opt})");
   elseif(!is_struct(sys))
     usage("[n,nz,m,p] = sysdimensions(sys)");
   elseif(nargin == 1)
diff --git a/scripts/control/sysupdate.m b/scripts/control/sysupdate.m
--- a/scripts/control/sysupdate.m
+++ b/scripts/control/sysupdate.m
@@ -40,17 +40,17 @@
 ## 
 ## @strong{Outputs}
 ## @var{retsys}: contains union of data in sys and requested data.
 ## If requested data in sys is already up to date then retsys=sys.
 ## 
 ## Conversion to @code{tf} or @code{zp} exits with an error if the system is 
 ##  mixed continuous/digital.
 ## @end deftypefn
-## seealso{tf2sys, ss2sys, zp2sys, sysout, sys2ss, sys2tf, sys2zp}
+## @seealso{tf2sys, ss2sys, zp2sys, sysout, sys2ss, sys2tf, and sys2zp}
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 9, 1996
 
 function sys = sysupdate (sys, opt)
 
   ## check for correct number of inputs 
   if (nargin != 2)
diff --git a/scripts/control/tfout.m b/scripts/control/tfout.m
--- a/scripts/control/tfout.m
+++ b/scripts/control/tfout.m
@@ -10,24 +10,24 @@
 ## Octave is distributed in the hope that it will be useful, but WITHOUT 
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 ## for more details.
 ## 
 ## You should have received a copy of the GNU General Public License 
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
+
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { } tfout (@var{num}, @var{denom}@{, @var{x}@})
-##  print formatted transfer function @math{n(s)/d(s) } to the screen
-##  @var{x} defaults to the string @code{"s"}
+## Print formatted transfer function @math{n(s)/d(s) } to the screen.
+## @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
 ## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue, 
-## filter, polyderiv, polyinteg, polyout}
+## filter, polyderiv, polyinteg, and polyout}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function tfout (num, denom, x)
   
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
diff --git a/scripts/control/ugain.m b/scripts/control/ugain.m
--- a/scripts/control/ugain.m
+++ b/scripts/control/ugain.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{outsys} =} ugain(n)
 ##  Creates a system with unity gain, no states.
 ##  This trivial system is sometimes needed to create arbitrary
 ##  complex systems from simple systems with buildssic.
 ##  Watch out if you are forming sampled systems since "ugain"
 ##  does not contain a sampling period.  
 ## @end deftypefn
-## @seealso{hinfdemo (MIMO H_infinty example, Boeing 707-321 aircraft model)}
+## @seealso{hinfdemo and jet707}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: April 1998
 
 function outsys = ugain (n)
 
   if((nargin != 1) || (nargout > 1))
     usage("outsys = ugain(n)")
diff --git a/scripts/control/zpout.m b/scripts/control/zpout.m
--- a/scripts/control/zpout.m
+++ b/scripts/control/zpout.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { } zpout (@var{zer}, @var{pol}, @var{k}@{, @var{x}@})
 ##  print formatted zero-pole form to the screen.  
 ## @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
 ## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue, 
-## filter, polyderiv, polyinteg, polyout} 
+## filter, polyderiv, polyinteg, and polyout} 
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function zpout (zer, pol, k, x)
 
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
diff --git a/scripts/elfun/gcd.m b/scripts/elfun/gcd.m
--- a/scripts/elfun/gcd.m
+++ b/scripts/elfun/gcd.m
@@ -35,17 +35,17 @@
 ## 
 ## An optional second return value, @var{v}
 ## contains an integer vector such that
 ## 
 ## @example
 ## g = v(1) * a(k) + ... + v(k) * a(k)
 ## @end example
 ## @end deftypefn
-## @seealso{lcm, min, max, ceil, floor}
+## @seealso{lcm, min, max, ceil, and floor}
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function [g, v] = gcd (a, ...)
 
   if (nargin == 0)
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -28,17 +28,17 @@
 ## 
 ## @noindent
 ## is the same as
 ## 
 ## @example
 ## lcm ([a1, ..., ak]).
 ## @end example
 ## @end deftypefn
-## @seealso{gcd, min, max, ceil, floor}  
+## @seealso{gcd, min, max, ceil, and floor}  
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function l = lcm (a, ...)
 
   if (nargin == 0)
diff --git a/scripts/finance/nper.m b/scripts/finance/nper.m
--- a/scripts/finance/nper.m
+++ b/scripts/finance/nper.m
@@ -24,17 +24,17 @@
 ## lump-sum payment of @var{l} made at the end of the amortization time. With
 ## the optional string argument `method', one can specify whether
 ## payments are made at the end ("e", default) or at the beginning ("b")
 ## of each period.
 ##
 ## Note that the rate r is not specified in percent, i.e., one has to
 ## write 0.05 rather than 5 %.
 ## @end deftypefn
-## @seealso{pv, pmt, rate, npv}
+## @seealso{pv, pmt, rate, and npv}
   
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Number of payments needed for amortizing a loan
 
 function n = nper (r, p, a, l, m)
   
   if ((nargin < 3) || (nargin > 5))
     usage ("nper (r, p, a [, l] [, method])");
diff --git a/scripts/finance/npv.m b/scripts/finance/npv.m
--- a/scripts/finance/npv.m
+++ b/scripts/finance/npv.m
@@ -23,17 +23,17 @@
 ## length as @var{p}.
 ##
 ## With the optional scalar argument @var{i}, one can specify an initial
 ## investment.
 ##
 ## Note that rates are not specified in percent, i.e., one has to write
 ## 0.05 rather than 5 %.
 ## @end deftypefn
-## @seealso{irr, pv}
+## @seealso{irr and pv}
   
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Net present value of a series of payments
 
 function v = npv (r, p, i)
   
   if ((nargin < 2) || (nargin > 3))
     usage ("npv (r, p [, i]");
diff --git a/scripts/finance/pmt.m b/scripts/finance/pmt.m
--- a/scripts/finance/pmt.m
+++ b/scripts/finance/pmt.m
@@ -19,17 +19,17 @@
 ## Compute the amount of periodic payment necessary to amortize a loan
 ## of amount a with interest rate @var{r} in @var{n} periods.
 ##
 ## With the optional scalar argument l, one can specify an initial
 ## lump-sum payment. With the optional string argument `method', one can
 ## specify whether payments are made at the end ("e", default) or at the
 ## beginning ("b") of each period.
 ## @end deftypefn
-## @seealso{pv, nper, rate}
+## @seealso{pv, nper, and rate}
   
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Amount of periodic payment needed to amortize a loan
 
 function p = pmt (r, n, a, l, m)
   
   if ((nargin < 3) || (nargin > 5))
     usage ("pmt (r, n, a [, l] [, method])");
diff --git a/scripts/finance/pv.m b/scripts/finance/pv.m
--- a/scripts/finance/pv.m
+++ b/scripts/finance/pv.m
@@ -24,17 +24,17 @@
 ##
 ## With the optional string argument `method', one can specify whether
 ## payments are made at the end ("e", default) or at the beginning ("b")
 ## of each period.
 ##
 ## Note that the rate r is not specified in percent, i.e., one has to
 ## write 0.05 rather than 5 %.
 ## @end deftypefn
-## @seealso{pmt, nper, rate, npv}
+## @seealso{pmt, nper, rate, and npv}
   
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Present value of an investment
 
 function v = pv (r, n, p, l, m)
   
   if ((nargin < 3) || (nargin > 5))
     usage ("pv (r, n, p [, l] [, method])");
diff --git a/scripts/finance/rate.m b/scripts/finance/rate.m
--- a/scripts/finance/rate.m
+++ b/scripts/finance/rate.m
@@ -19,17 +19,17 @@
 ## Computes the rate of return on an investment of present value @var{v} which
 ## pays @var{p} in @var{n} consecutive periods.
 ##
 ## With the optional scalar argument @var{l}, one can specify an additional
 ## lump-sum payment made at the end of @var{n} periods. With the optional
 ## string argument @var{`method'}, one can specify whether payments are made
 ## at the end ("e", default) or at the beginning ("b") of each period.
 ## @end deftypefn
-## @seealso{pv, pmt, nper, npv}
+## @seealso{pv, pmt, nper, and npv}
   
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Rate of return of an investment
   
 function r = rate (n, p, v, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("rate (n, p, v [, l] [, method])");
diff --git a/scripts/general/columns.m b/scripts/general/columns.m
--- a/scripts/general/columns.m
+++ b/scripts/general/columns.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} columns (@var{a})
 ## Return the number of columns of @var{a}.
 ## @end deftypefn
-## @seealso{size, rows, length, is_scalar, is_vector, is_matrix}
+## @seealso{size, rows, length, is_scalar, is_vector, and is_matrix}
 
 ## Author: jwe
 
 function nc = columns (x)
 
   if (nargin != 1)
     usage ("columns (x)");
   endif
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -25,17 +25,17 @@
 ## @example
 ## @group
 ## fliplr ([1, 2; 3, 4])
 ##      @result{}  2  1
 ##          4  3
 ## @end group
 ## @end example
 ## @end deftypefn
-## @seealso{flipud, rot90}
+## @seealso{flipud and rot90}
 
 ## Author: jwe
 
 function y = fliplr (x)
 
   if (nargin != 1)
     usage ("fliplr (x)");
   endif
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -25,17 +25,17 @@
 ## @example
 ## @group
 ## flipud ([1, 2; 3, 4])
 ##      @result{}  3  4
 ##          1  2
 ## @end group
 ## @end example
 ## @end deftypefn
-## @seealso{fliplr, rot90}
+## @seealso{fliplr and rot90}
 
 ## Author: jwe
 
 function y = flipud (x)
 
   if (nargin != 1)
     usage ("flipud (x)");
   endif
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} int2str (@var{n})
 ## @deftypefnx {Function File} {} num2str (@var{x})
 ## Convert a number to a string.  These functions are not very flexible,
 ## but are provided for compatibility with @sc{Matlab}.  For better control
 ## over the results, use @code{sprintf} (@pxref{Formatted Output}).
 ## @end deftypefn
-## @seealso{sprintf, num2str}
+## @seealso{sprintf and num2str}
 
 ## Author: jwe
 
 function retval = int2str (x)
 
   ## XXX FIXME XXX -- this will fail for very large values.
 
   if (nargin == 1)
diff --git a/scripts/general/is_scalar.m b/scripts/general/is_scalar.m
--- a/scripts/general/is_scalar.m
+++ b/scripts/general/is_scalar.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} is_scalar (@var{a})
 ## Return 1 if @var{a} is a scalar.  Otherwise, return 0.
 ## @end deftypefn
-## @seealso{size, rows, columns, length, is_scalar, is_matrix}
+## @seealso{size, rows, columns, length, is_scalar, and is_matrix}
 
 ## Author: jwe
 
 function retval = is_scalar (x)
 
   retval = 0;
 
   if (nargin == 1)
diff --git a/scripts/general/is_square.m b/scripts/general/is_square.m
--- a/scripts/general/is_square.m
+++ b/scripts/general/is_square.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} is_square (@var{x})
 ## If @var{x} is a square matrix, then return the dimension of @var{x}.
 ## Otherwise, return 0.
 ## @end deftypefn
-## @seealso{size, rows, columns, length, is_matrix, is_scalar, is_vector}
+## @seealso{size, rows, columns, length, is_matrix, is_scalar, and is_vector}
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function retval = is_square (x)
 
   retval = 0;
diff --git a/scripts/general/is_symmetric.m b/scripts/general/is_symmetric.m
--- a/scripts/general/is_symmetric.m
+++ b/scripts/general/is_symmetric.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} is_symmetric (@var{x}, @var{tol})
 ## If @var{x} is symmetric within the tolerance specified by @var{tol}, 
 ## then return the dimension of @var{x}.  Otherwise, return 0.  If
 ## @var{tol} is omitted, use a tolerance equal to the machine precision.
 ## @end deftypefn
 ## @seealso{size, rows, columns, length, is_matrix, is_scalar,
-## is_square, is_vector}
+## is_square, and is_vector}
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function retval = is_symmetric (x,tol)
 
   if (nargin == 1 || nargin == 2)
diff --git a/scripts/general/is_vector.m b/scripts/general/is_vector.m
--- a/scripts/general/is_vector.m
+++ b/scripts/general/is_vector.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} is_vector (@var{a})
 ## Return 1 if @var{a} is a vector.  Otherwise, return 0.
 ## @end deftypefn
-## @seealso{size, rows, columns, length, is_scalar, is_matrix}
+## @seealso{size, rows, columns, length, is_scalar, and is_matrix}
 
 ## Author: jwe
 
 function retval = is_vector (x)
 
   retval = 0;
 
   if (nargin == 1)
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} int2str (@var{n})
 ## @deftypefnx {Function File} {} num2str (@var{x})
 ## Convert a number to a string.  These functions are not very flexible,
 ## but are provided for compatibility with @sc{Matlab}.  For better control
 ## over the results, use @code{sprintf} (@pxref{Formatted Output}).
 ## @end deftypefn
-## @seealso{sprintf, int2str}
+## @seealso{sprintf and int2str}
 
 ## Author: jwe
 
 function retval = num2str (x)
 
   if (nargin == 1)
     if (rows (x) == 1 && columns (x) == 1)
       retval = sprintf ("%g", x);
diff --git a/scripts/general/reshape.m b/scripts/general/reshape.m
--- a/scripts/general/reshape.m
+++ b/scripts/general/reshape.m
@@ -44,17 +44,17 @@
 ## @end group
 ## @end example
 ## 
 ## @noindent
 ## but it is somewhat less cryptic to use @code{reshape} instead of the
 ## colon operator.  Note that the total number of elements in the original
 ## matrix must match the total number of elements in the new matrix.
 ## @end deftypefn
-## @seealso{`:', do_fortran_indexing}
+## @seealso{`:' and do_fortran_indexing}
 
 ## Author: jwe
 
 function retval = reshape (a, m, n)
 
   if (nargin == 2 && prod (size (m)) == 2)
     n = m(2);
     m = m(1);
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -42,17 +42,17 @@
 ## rot90 ([1, 2; 3, 4], -1)
 ## @equiv{}
 ## rot90 ([1, 2; 3, 4], 3)
 ## @equiv{}
 ## rot90 ([1, 2; 3, 4], 7)
 ## @end group
 ## @end example
 ## @end deftypefn
-## @seealso{flipud, fliplr}
+## @seealso{flipud and fliplr}
 
 ## Author: jwe
 
 function y = rot90 (x, k)
 
   if (nargin < 2)
     k = 1;
   endif
diff --git a/scripts/general/rows.m b/scripts/general/rows.m
--- a/scripts/general/rows.m
+++ b/scripts/general/rows.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rows (@var{a})
 ## Return the number of rows of @var{a}.
 ## @end deftypefn
-## @seealso{size, columns, length, is_scalar, is_vector, is_matrix}
+## @seealso{size, columns, length, is_scalar, is_vector, and is_matrix}
 
 ## Author: jwe
 
 function nr = rows (x)
 
   if (nargin != 1)
     usage ("rows (x)");
   endif
diff --git a/scripts/general/tril.m b/scripts/general/tril.m
--- a/scripts/general/tril.m
+++ b/scripts/general/tril.m
@@ -55,17 +55,17 @@
 ## @group
 ## tril (ones (3), 1)
 ##      @result{}  1  1  0
 ##          1  1  1
 ##          1  1  1
 ## @end group
 ## @end example
 ## @end deftypefn
-## @seealso{triu, diag}
+## @seealso{triu and diag}
 
 ## Author: jwe
 
 function retval = tril (x, k)
 
   if (nargin > 0)
     [nr, nc] = size (x);
     retval = zeros (nr, nc);
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -18,17 +18,17 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cond (@var{a})
 ## Compute the (two-norm) condition number of a matrix. @code{cond (a)} is
 ## defined as @code{norm (a) * norm (inv (a))}, and is computed via a
 ## singular value decomposition.
 ## @end deftypefn
-## @seealso{norm, svd, rank}
+## @seealso{norm, svd, and rank}
 
 ## Author: jwe
 
 function retval = cond (a)
 
   if (nargin == 1)
     [nr, nc] = size (a);
     if (nr == 0 && nc == 0)
diff --git a/scripts/linear-algebra/norm.m b/scripts/linear-algebra/norm.m
--- a/scripts/linear-algebra/norm.m
+++ b/scripts/linear-algebra/norm.m
@@ -48,17 +48,17 @@
 ## 
 ## @item @var{p} = @code{-Inf}
 ## @code{min (abs (@var{a}))}.
 ## 
 ## @item other
 ## p-norm of @var{a}, @code{(sum (abs (@var{a}) .^ @var{p})) ^ (1/@var{p})}.
 ## @end table
 ## @end deftypefn
-## @seealso{cond, svd}
+## @seealso{cond and svd}
 
 ## Author: jwe
 
 function retval = norm (x, p)
 
   if (nargin < 1 || nargin > 2)
     error ("usage: norm (x [, p])");
   endif
diff --git a/scripts/miscellaneous/etime.m b/scripts/miscellaneous/etime.m
--- a/scripts/miscellaneous/etime.m
+++ b/scripts/miscellaneous/etime.m
@@ -27,17 +27,17 @@
 ## # many computations later...
 ## elapsed_time = etime (clock (), t0);
 ## @end example
 ## 
 ## @noindent
 ## will set the variable @code{elapsed_time} to the number of seconds since
 ## the variable @code{t0} was set.
 ## @end deftypefn
-## @seealso{tic, toc, clock, cputime}
+## @seealso{tic, toc, clock, and cputime}
 
 ## Author: jwe
 
 function secs = etime (t1, t0)
 
   if (nargin != 2)
     usage ("etime (t1, t0)");
   endif
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {} menu (@var{title}, @var{opt1}, @dots{})
 ## Print a title string followed by a series of options.  Each option will
 ## be printed along with a number.  The return value is the number of the
 ## option selected by the user.  This function is useful for interactive
 ## programs.  There is no limit to the number of options that may be passed
 ## in, but it may be confusing to present more than will fit easily on one
 ## screen.
 ## @end deftypefn
-## @seealso{disp, printf, input}
+## @seealso{disp, printf, and input}
 
 ## Author: jwe
 
 function num = menu (t, ...)
 
   if (nargin < 2)
     usage ("menu (title, opt1, ...)");
   endif
diff --git a/scripts/plot/__pltopt1__.m b/scripts/plot/__pltopt1__.m
--- a/scripts/plot/__pltopt1__.m
+++ b/scripts/plot/__pltopt1__.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{fmt} =} __pltopt1__ (@var{caller}, @var{opt})
 ##
 ## Really decode plot option strings.
 ## @end deftypefn
-## @seealso{ __pltopt__}
+## @seealso{__pltopt__}
 
 ## Author: Rick Niles <niles@axp745.gsfc.nasa.gov>
 ## Adapted-By: jwe
 ## Maintainer: jwe
 
 function fmt = __pltopt1__ (caller, opt)
 
   set_color = 0;
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -38,17 +38,17 @@
 ## [xb, yb] = bar (x, y);
 ## plot (xb, yb);
 ## @end example
 ## 
 ## @noindent
 ## are equivalent.
 ## @end deftypefn
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## stairs, gplot, gsplot, replot, xlabel, ylabel, title}
+## stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function [xb, yb] = bar (x, y)
 
   if (nargin == 1)
     if (is_vector (x))
       len = 3 * length (x) + 1;
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} contour (@var{z}, @var{n}, @var{x}, @var{y})
 ## Make a contour plot of the three-dimensional surface described by
 ## @var{z}.  Someone needs to improve @code{gnuplot}'s contour routines
 ## before this will be very useful.
 ## @end deftypefn
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title}
+## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function contour (z, n, x, y)
 
   if (nargin == 1)
     n = 10;
   endif
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} grid (@var{arg})
 ## For two-dimensional plotting, force the display of a grid on the plot.
 ## The argument may be either @code{"on"} or @code{"off"}.  If it is
 ## omitted, @code{"on"} is assumed.
 ## @end deftypefn
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title}
+## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function grid (x)
 
   if (nargin == 0)
     gset grid;
   elseif (nargin == 1)
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} loglog (@var{args})
 ## Make a two-dimensional plot using log scales for both axes.  See the
 ## description of @code{plot} for a description of the arguments that
 ## @code{loglog} will accept.
 ## @end deftypefn
 ## @seealso{plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
-## gplot, gsplot, replot, xlabel, ylabel, title}
+## gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function loglog (...)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -22,17 +22,17 @@
 ## Plot a mesh given matrices @code{x}, and @var{y} from @code{meshdom} and
 ## a matrix @var{z} corresponding to the @var{x} and @var{y} coordinates of
 ## the mesh.  If @var{x} and @var{y} are vectors, then a typical vertex
 ## is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns of @var{z}
 ## correspond to different @var{x} values and rows of @var{z} correspond
 ## to different @var{y} values.
 ## @end deftypefn
 ## @seealso{plot, semilogx, semilogy, loglog, polar, meshgrid, meshdom,
-## contour, bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title}
+## contour, bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function mesh (x, y, z)
 
   ## XXX FIXME XXX -- the plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/meshgrid.m b/scripts/plot/meshgrid.m
--- a/scripts/plot/meshgrid.m
+++ b/scripts/plot/meshgrid.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{xx}, @var{yy}] =} meshgrid (@var{x}, @var{y})
 ## @deftypefnx {Function File {[@var{xx}, @var{yy}] =} meshgrid (@var{x})
 ## Given vectors of @var{x} and @var{y} coordinates, return two matrices corresponding
 ## to the @var{x} and @var{y} coordinates of a mesh.  The rows of @var{xx} are copies of @var{x},
 ## and the columns of @var{yy} are copies of @var{y}.
 ## @end deftypefn
 ## @seealso{sombrero, plot, semilogx, semilogy, loglog, polar, mesh, meshdom, contour,
-## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title}
+## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function [xx, yy] = meshgrid (x, y)
 
   if (nargin == 1)
     y = x;
   endif
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -151,17 +151,17 @@
 ## @example
 ## plot (b, "*")
 ## @end example
 ## 
 ## This command will plot the data in the variable @code{b} will be plotted
 ## with points displayed as @samp{*}.
 ## @end deftypefn
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__
-## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title}
+## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function plot (...)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polar (@var{theta}, @var{rho}, @var{fmt})
 ## Make a two-dimensional plot given polar the coordinates @var{theta} and
 ## @var{rho}.
 ##
 ## The optional third argument specifies the line type.
 ## @end deftypefn
 ## @seealso{plot, semilogx, semilogy, loglog, mesh, contour, bar,
-## stairs, gplot, gsplot, replot, xlabel, ylabel, title}
+## stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function polar (x1, x2, fmt)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogx (@var{args})
 ## Make a two-dimensional plot using a log scale for the @var{x} axis.  See
 ## the description of @code{plot} for a description of the arguments
 ## that @code{semilogx} will accept.
 ## @end deftypefn
 ## @seealso{plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
-## gplot, gsplot, replot, xlabel, ylabel, title}
+## gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function semilogx (...)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogy (@var{args})
 ## Make a two-dimensional plot using a log scale for the @var{y} axis.  See
 ## the description of @code{plot} for a description of the arguments
 ## that @code{semilogy} will accept.
 ## @end deftypefn
 ## @seealso{plot, semilogx, loglog, polar, mesh, contour, bar, stairs,
-## gplot, gsplot, replot, xlabel, ylabel, title}
+## gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function semilogy (...)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/shg.m b/scripts/plot/shg.m
--- a/scripts/plot/shg.m
+++ b/scripts/plot/shg.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*- 
 ## @deftypefn {Function File} {} shg
 ##
 ## Show the graph window.  Currently, this is the same as executing
 ## replot without any arguments.
 ## 
 ## @end deftypefn 
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, gplot, gsplot, replot, xlabel, ylabel}
+## bar, stairs, gplot, gsplot, replot, xlabel, and ylabel}
 
 ## Author: jwe
 
 function shg ()
 
   if (nargin != 0)
     warning ("shg: ignoring extra arguments");
   endif
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -38,17 +38,17 @@
 ## [xs, ys] = stairs (x, y);
 ## plot (xs, ys);
 ## @end example
 ## 
 ## @noindent
 ## are equivalent.
 ## @end deftypefn
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, gplot, gsplot, replot, xlabel, ylabel, title}
+## bar, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function [xs, ys] = stairs (x, y)
 
 
   if (nargin == 1)
     if (is_vector (x))
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -18,17 +18,17 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} title (@var{string})
 ## Specify a title for a plot.  If you already have a plot displayed, use
 ## the command @code{replot} to redisplay it with the new title.
 ## @end deftypefn
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, gplot, gsplot, replot, xlabel, ylabel}
+## bar, stairs, gplot, gsplot, replot, xlabel, and ylabel}
 
 ## Author: jwe
 
 function title (text)
 
   if (nargin != 1)
     usage ("title (text)");
   endif
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {} xlabel (@var{string})
 ## @deftypefnx {Function File} {} ylabel (@var{string})
 ## @deftypefnx {Function File} {} zlabel (@var{string})
 ## Specify x, y, and z axis labels for the plot.  If you already have a plot
 ## displayed, use the command @code{replot} to redisplay it with the new
 ## labels.
 ## @end deftypefn
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, gplot, gsplot, replot, ylabel, title}
+## bar, stairs, gplot, gsplot, replot, ylabel, and title}
 
 ## Author: jwe
 
 function xlabel (text)
 
   if (nargin != 1)
     usage ("xlabel (text)");
   endif
diff --git a/scripts/set/complement.m b/scripts/set/complement.m
--- a/scripts/set/complement.m
+++ b/scripts/set/complement.m
@@ -23,19 +23,18 @@
 ## example,
 ## 
 ## @example
 ## @group
 ## complement ([ 1, 2, 3 ], [ 2, 3, 5 ])
 ##      @result{} 5
 ## @end group
 ## @end example
-##
+## @end deftypefn
 ## @seealso{create_set, union, and intersection}
-## @end deftypefn
 
 ## Author: jwe
 
 function y = complement (a, b)
 
   if (nargin != 2)
     usage ("complement(a,b)");
   endif
diff --git a/scripts/set/create_set.m b/scripts/set/create_set.m
--- a/scripts/set/create_set.m
+++ b/scripts/set/create_set.m
@@ -23,19 +23,18 @@
 ## ascending order.  For example,
 ## 
 ## @example
 ## @group
 ## create_set ([ 1, 2; 3, 4; 4, 2 ])
 ##      @result{} [ 1, 2, 3, 4 ]
 ## @end group
 ## @end example
-##
+## @end deftypefn
 ## @seealso{union, intersection, and complement}
-## @end deftypefn
 
 ## Author: jwe
 
 function y = create_set(x)
 
   if ( nargin != 1)
     usage ("create_set(x)");
   endif
diff --git a/scripts/set/intersection.m b/scripts/set/intersection.m
--- a/scripts/set/intersection.m
+++ b/scripts/set/intersection.m
@@ -23,19 +23,18 @@
 ## For example,
 ## 
 ## @example
 ## @group
 ## intersection ([ 1, 2, 3 ], [ 2, 3, 5 ])
 ##      @result{} [ 2, 3 ]
 ## @end group
 ## @end example
-##
+## @end deftypefn
 ## @seealso{create_set, union, and complement}
-## @end deftypefn
 
 ## Author: jwe
 
 function y = intersection(a,b)
 
   if (nargin != 2)
     usage ("intersection(a,b)");
   endif
diff --git a/scripts/specfun/erfinv.m b/scripts/specfun/erfinv.m
--- a/scripts/specfun/erfinv.m
+++ b/scripts/specfun/erfinv.m
@@ -13,17 +13,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} erfinv (@var{z})
 ## Computes the inverse of the error function,
 ## @end deftypefn
-## @seealso{erf, erfc}
+## @seealso{erf and erfc}
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 27 September 1994
 ## Adapted-By: jwe
 
 function [y, iterations] = erfinv (x)
   
   if (nargin != 1)
diff --git a/scripts/specfun/gammai.m b/scripts/specfun/gammai.m
--- a/scripts/specfun/gammai.m
+++ b/scripts/specfun/gammai.m
@@ -39,17 +39,17 @@
 ## @end ifinfo
 ## 
 ## If @var{a} is scalar, then @code{gammai (@var{a}, @var{x})} is returned
 ## for each element of @var{x} and vice versa.
 ## 
 ## If neither @var{a} nor @var{x} is scalar, the sizes of @var{a} and
 ## @var{x} must agree, and @var{gammai} is applied element-by-element.
 ## @end deftypefn
-## @seealso{gamma, lgamma}
+## @seealso{gamma and lgamma}
 
 ## Author: jwe
 ## Created: 30 Jan 1998
 
 function retval = gammai (a, x)
 
   if (nargin == 2)
     retval = gammainc (x, a);
diff --git a/scripts/specfun/log2.m b/scripts/specfun/log2.m
--- a/scripts/specfun/log2.m
+++ b/scripts/specfun/log2.m
@@ -23,17 +23,17 @@
 ## @tex
 ##  $1/2 <= |f| < 1$ and $x = f \cdot 2^e$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##  1/2 <= abs(f) < 1 and x = f * 2^e.
 ## @end ifinfo
 ## @end deftypefn
-## @seealso{log, log10, logspace, exp}
+## @seealso{log, log10, logspace, and exp}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
 
 function [f, e] = log2 (x)
 
   if (nargin != 1)
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -39,17 +39,17 @@
 ## @example
 ## @group
 ## H (i, j) = c (i+j-1),  i+j-1 <= m;
 ## H (i, j) = r (i+j-m),  otherwise
 ## @end group
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
-## @seealso{vander, sylvester_matrix, hilb, invhilb, toeplitz}
+## @seealso{vander, sylvester_matrix, hilb, invhilb, and toeplitz}
 
 ## Author: jwe
 
 function retval = hankel (c, r)
 
   if (nargin == 1)
     r = zeros (size (c));
   elseif (nargin != 2)
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -38,17 +38,17 @@
 ## @end iftex
 ## @ifinfo
 ## 
 ## @example
 ## H (i, j) = 1 / (i + j - 1)
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
-## @seealso{hankel, vander, sylvester_matrix, invhilb, toeplitz}
+## @seealso{hankel, vander, sylvester_matrix, invhilb, and toeplitz}
 
 ## Author: jwe
 
 function retval = hilb (n)
 
 
   if (nargin != 1)
     usage ("hilb (n)");
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} invhilb (@var{n})
 ## Return the inverse of a Hilbert matrix of order @var{n}.  This is exact.
 ## Compare with the numerical calculation of @code{inverse (hilb (n))},
 ## which suffers from the ill-conditioning of the Hilbert matrix, and the
 ## finite precision of your computer's floating point arithmetic.
 ## @end deftypefn
-## @seealso{hankel, vander, sylvester_matrix, hilb, toeplitz}
+## @seealso{hankel, vander, sylvester_matrix, hilb, and toeplitz}
 
 ## Author: jwe
 
 function retval = invhilb (n)
 
   if (nargin != 1)
     usage ("invhilb (n)");
   endif
diff --git a/scripts/special-matrix/sylvester_matrix.m b/scripts/special-matrix/sylvester_matrix.m
--- a/scripts/special-matrix/sylvester_matrix.m
+++ b/scripts/special-matrix/sylvester_matrix.m
@@ -24,17 +24,17 @@
 ## @tex
 ## $n = 2^k$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## n = 2^k.
 ## @end ifinfo
 ## @end deftypefn
-## @seealso{hankel, vander, hilb, invhilb, toeplitz}
+## @seealso{hankel, vander, hilb, invhilb, and toeplitz}
 
 ## Author: jwe
 
 function retval = sylvester_matrix (k)
 
   if (nargin != 1)
     usage ("sylvester_matrix (n)");
   endif
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -48,17 +48,17 @@
 ##  .                       .
 ##  .                       .
 ## 
 ## c(n) c(n-1) c(n-2) ...  c(0)
 ## @end group
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
-## @seealso{hankel, vander, sylvester_matrix, hilb, invhib}
+## @seealso{hankel, vander, sylvester_matrix, hilb, and invhib}
 
 ## Author: jwe
 
 function retval = toeplitz (c, r)
 
   if (nargin == 1)
     r = c;
   elseif (nargin != 2)
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -42,17 +42,17 @@
 ##  .           .      .    .
 ##  .           .      .    .
 ##                  
 ## c(n)^n ... c(n)^2  c(n)  1
 ## @end group
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
-## @seealso{hankel, sylvester_matrix, hilb, invhilb, toeplitz}
+## @seealso{hankel, sylvester_matrix, hilb, invhilb, and toeplitz}
 
 ## Author: jwe
 
 function retval = vander (c)
 
   if (nargin != 1)
     usage ("vander (c)");
   endif
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -38,17 +38,17 @@
 ## median(x) = 
 ##             (x(N/2) + x((N/2)+1))/2,  N even
 ## @end group
 ## @end example
 ## @end ifinfo
 ## If @var{x} is a matrix, compute the median value for each
 ## column and return them in a row vector.
 ## @end deftypefn
-## @seealso{std, mean}
+## @seealso{std and mean}
 
 ## Author: jwe
 
 function retval = median (a)
 
   if (nargin != 1)
     usage ("median (a)");
   endif
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -34,17 +34,17 @@
 ## @group
 ## std (x) = sqrt (sumsq (x - mean (x)) / (n - 1))
 ## @end group
 ## @end example
 ## @end ifinfo
 ## If @var{x} is a matrix, compute the standard deviation for
 ## each column and return them in a row vector.
 ## @end deftypefn
-## @seealso{mean, median}
+## @seealso{mean and median}
 
 ## Author: jwe
 
 function retval = std (a)
 
   if (nargin != 1)
     usage ("std (a)");
   endif
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,14 @@
+2000-01-06  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* help.cc (display_help_text): Also strip out leading spaces
+	before Texinfo @-commands before sending doc string to makeinfo.
+	(display_help_text): Improve format of `See also' string.
+
 2000-01-05  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* help.cc (display_help_text): Pass a definition for @seealso
 	through the filter.
 
 1999-12-22  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* lex.l (Vwarn_single_quote_string): New variable.
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -606,17 +606,17 @@ display_help_text (ostream& os, const st
 
       if (cols > 64)
 	cols -= 7;
 
       if (cols > 80)
 	cols = 72;
 
       ostrstream buf;
-      buf << "sed 's/^[#%]+ *//' | makeinfo"
+      buf << "sed -e 's/^[#%]+ *//' -e 's/^ *@/@/' | makeinfo"
 	  << " -D \"VERSION " << OCTAVE_VERSION << "\""
 	  << " -D \"OCTAVEHOME " << OCTAVE_PREFIX << "\""
 	  << " -D \"TARGETHOSTTYPE " << CANONICAL_HOST_TYPE << "\""
 	  << " --fill-column " << cols
 	  << " --no-warn"
 	  << " --no-validate"
 	  << " --no-headers"
 	  << " --force"
@@ -628,16 +628,18 @@ display_help_text (ostream& os, const st
 
       oprocstream filter (cmd);
 
       delete [] cmd;
 
       if (filter)
 	{
 	  filter << "@macro seealso {args}\n"
+		 << "\n"
+		 << "@noindent\n"
 		 << "See also: \\args\\.\n"
                  << "@end macro\n";
 
 	  filter << msg.substr (pos+1);
 
 	  filter.close ();
 
 	  ifstream tmp_file (tmp_file_name.c_str ());
