# HG changeset patch
# User Rik <rik@octave.org>
# Date 1361854896 28800
#      Mon Feb 25 21:01:36 2013 -0800
# Node ID 3cce6b4e0f7c21ab8a2363d5a5ac223fbbe8f431
# Parent  3b791008b88eaaeff57e734707c35a6f8a918145
Update gnuplot plotting scripts for faster or more modern synta

* scripts/plot/__gnuplot_drawnow__.m: Use default values in function header.
Check number of arguments to function immediately.  Use single quotes to
avoid lots of backslashing.  Use strtok() to replace hand-coded functionality.
Initialize persistent variables in declaration (10% faster).

* scripts/plot/gnuplot_binary.in: Replace tabs with spaces.  Simplify input
validation.  Add %!test block.

* scripts/plot/private/__gnuplot_get_var__.m: Use default values in function
header.  Use "*char" in fread to automatically convert to char variable.

* scripts/plot/private/__gnuplot_ginput__.m: Check immediately for required
version of gnuplot.  Use "*char" in fread to automatically convert to char
variable.  Use fputs in place of fprintf to match rest of code.

* scripts/plot/private/__gnuplot_has_feature__.m: Initialize persistent varibles
in declaration.  Use false () rather than logical (zeros()) construction.

* scripts/plot/private/__gnuplot_has_terminal__.m: Use strtok() to replace
hand-coded functionality

* scripts/plot/private/__gnuplot_print__.m: Replace sprintf calls with direct
string char matrix concatenation (2.4x faster) where possible.  Replace for
loop with multiple argument form of set().  Use single quotes to avoid lots
of backslashing.

* scripts/plot/private/__gnuplot_version__.m: Use single quotes to avoid lots
of backslashing.

diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -18,41 +18,41 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __gnuplot_drawnow__ (@var{h}, @var{term}, @var{file}, @var{mono}, @var{debug_file})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
-function __gnuplot_drawnow__ (h, term, file, mono, debug_file)
+function __gnuplot_drawnow__ (h, term, file, mono = false, debug_file)
 
-  if (nargin < 4)
-    mono = false;
+  if (nargin < 1 || nargin > 5 || nargin == 2)
+    print_usage ();
   endif
 
   if (nargin >= 3 && nargin <= 5)
     ## Produce various output formats, or redirect gnuplot stream to a
     ## debug file.
     plot_stream = [];
     fid = [];
     default_plot_stream = get (h, "__plot_stream__");
     unwind_protect
       plot_stream = __gnuplot_open_stream__ (2, h);
       gnuplot_supports_term = __gnuplot_has_terminal__ (term, plot_stream);
       if (gnuplot_supports_term)
-        enhanced = gnuplot_set_term (plot_stream (1), true, h, term, file);
+        enhanced = gnuplot_set_term (plot_stream(1), true, h, term, file);
         __go_draw_figure__ (h, plot_stream(1), enhanced, mono);
         if (nargin == 5)
           fid = fopen (debug_file, "wb");
           enhanced = gnuplot_set_term (fid, true, h, term, file);
           __go_draw_figure__ (h, fid, enhanced, mono);
         endif
       else
-        error ("__gnuplot_drawnow__: the gnuplot terminal, \"%s\", is not available",
+        error ('__gnuplot_drawnow__: the gnuplot terminal, "%s", is not available',
                gnuplot_trim_term (term));
       endif
     unwind_protect_cleanup
       set (h, "__plot_stream__", default_plot_stream);
       if (! isempty (plot_stream))
         pclose (plot_stream(1));
         if (numel (plot_stream) > 1)
           pclose (plot_stream(2));
@@ -60,71 +60,67 @@ function __gnuplot_drawnow__ (h, term, f
         if (numel (plot_stream) > 2)
           waitpid (plot_stream(3));
         endif
       endif
       if (! isempty (fid))
         fclose (fid);
       endif
     end_unwind_protect
-  elseif (nargin == 1)
+  else  # nargin == 1
     ##  Graphics terminal for display.
     plot_stream = get (h, "__plot_stream__");
     if (isempty (plot_stream))
       plot_stream = __gnuplot_open_stream__ (2, h);
       new_stream = true;
     else
       new_stream = false;
     endif
     term = gnuplot_default_term (plot_stream);
     if (strcmp (term, "dumb"))
       ## popen2 eats stdout of gnuplot, use temporary file instead
       dumb_tmp_file = tmpnam ();
-      enhanced = gnuplot_set_term (plot_stream (1), new_stream, h, ...
+      enhanced = gnuplot_set_term (plot_stream(1), new_stream, h,
                                    term, dumb_tmp_file);
     else
-      enhanced = gnuplot_set_term (plot_stream (1), new_stream, h, term);
+      enhanced = gnuplot_set_term (plot_stream(1), new_stream, h, term);
     endif
-    __go_draw_figure__ (h, plot_stream (1), enhanced, mono);
-    fflush (plot_stream (1));
+    __go_draw_figure__ (h, plot_stream(1), enhanced, mono);
+    fflush (plot_stream(1));
     if (strcmp (term, "dumb"))
       fid = -1;
       while (fid < 0)
         pause (0.1);
         fid = fopen (dumb_tmp_file, 'r');
       endwhile
       ## reprint the plot on screen
       [a, count] = fscanf (fid, '%c', Inf);
       fclose (fid);
-      if (count>0)
-        if (a(1)==12)
-          ## avoid ^L at the beginning
-          a = a(2:end);
+      if (count > 0)
+        if (a(1) == 12)
+          a = a(2:end);  # avoid ^L at the beginning
         endif
         puts (a);
       endif
       unlink (dumb_tmp_file);
     endif
-  else
-    print_usage ();
   endif
 
 endfunction
 
 function enhanced = gnuplot_set_term (plot_stream, new_stream, h, term, file)
   ## Generate the gnuplot "set terminal <term> ..." command.
   ## When "term" originates from print.m, it may include other options.
   if (nargin < 4)
     ## This supports the gnuplot graphics toolkit.
     term = gnuplot_default_term (plot_stream);
     opts_str = "";
   else
-    ## Get the one word terminal id and save the remaining as options to
-    ## be passed on to gnuplot.  The terminal may respect the graphics
-    ## toolkit.
+    ## Get the one word terminal id and save the remaining as options to be
+    ## passed on to gnuplot.  The terminal may respect the graphics toolkit.
     [term, opts_str] = gnuplot_trim_term (term);
     term = lower (term);
     if (strcmp (term, "lua"))
       ## Replace "lua tikz" with just "tikz"
       term = "tikz";
       opts_str = strrep (opts_str, "tikz", "");
     endif
   endif
@@ -144,33 +140,33 @@ function enhanced = gnuplot_set_term (pl
       enh_str = "";
     endif
 
     if (! isempty (h) && isfigure (h))
 
       ## Generate gnuplot title string for plot windows.
       if (output_to_screen (term) && ! strcmp (term, "dumb"))
         fig.numbertitle = get (h, "numbertitle");
-        fig.name = strrep (get (h, "name"), "\"", "\\\"");
+        fig.name = strrep (get (h, "name"), '"', '\"');
         if (strcmp (get (h, "numbertitle"), "on"))
           title_str = sprintf ("Figure %d", h);
         else
           title_str = "";
         endif
         if (! isempty (fig.name) && ! isempty (title_str))
           title_str = sprintf ("%s: %s", title_str, fig.name);
         elseif (! isempty (fig.name) && isempty (title_str))
           title_str = fig.name;
         endif
         if (! isempty (title_str))
-          title_str = sprintf ("title \"%s\"", title_str);
+          title_str = sprintf ('title "%s"', title_str);
         endif
         if (strcmp (term, "aqua"))
           ## Adjust axes-label and tick-label spacing.
-          opts_str = sprintf ("%s font \"%s,%d\"", opts_str,
+          opts_str = sprintf ('%s font "%s,%d"', opts_str,
                               get (0, "defaultaxesfontname"),
                               get (0, "defaultaxesfontsize") / 1.5);
         endif
       else
         title_str = "";
       endif
 
       if (! (any (strfind (opts_str, " size ") > 0)
@@ -190,49 +186,49 @@ function enhanced = gnuplot_set_term (pl
                                       "pbm", "png", "pngcairo", "svg"}))))
           ## Convert to inches
           gnuplot_pos = gnuplot_pos / 72;
           gnuplot_size = gnuplot_size / 72;
         endif
         if (all (gnuplot_size > 0))
           terminals_with_size = {"canvas", "emf", "epslatex", "fig", ...
                                  "gif", "jpeg", "latex", "pbm", "pdf", ...
-                                 "pdfcairo", "postscript", "png", "pngcairo", ...
-                                 "pstex", "pslatex", "svg", "tikz"};
+                                 "pdfcairo", "postscript", "png", ...
+                                 "pngcairo", "pstex", "pslatex", "svg", "tikz"};
           if (__gnuplot_has_feature__ ("windows_figure_position"))
             terminals_with_size{end+1} = "windows";
           endif
           if (__gnuplot_has_feature__ ("x11_figure_position"))
             terminals_with_size{end+1} = "x11";
           endif
           if (__gnuplot_has_feature__ ("wxt_figure_size"))
             terminals_with_size{end+1} = "wxt";
           endif
           switch (term)
-          case terminals_with_size
-            size_str = sprintf ("size %.12g,%.12g", gnuplot_size);
-          case "tikz"
-            size_str = sprintf ("size %gin,%gin", gnuplot_size);
-          case "dumb"
-            new_stream = 1;
-            if (! isempty (getenv ("COLUMNS")) && ! isempty (getenv ("LINES")))
-              ## Let dumb use full text screen size (minus prompt lines).
-              n = sprintf ("%i", -2 - length (find (sprintf ("%s", PS1) == "\n")));
-              ## n = the number of times \n appears in PS1
-              size_str = ["size ", getenv("COLUMNS"), ",", getenv("LINES"), n];
-            else
-              ## Use the gnuplot default.
+            case terminals_with_size
+              size_str = sprintf ("size %.12g,%.12g", gnuplot_size);
+            case "tikz"
+              size_str = sprintf ("size %gin,%gin", gnuplot_size);
+            case "dumb"
+              new_stream = 1;
+              if (! isempty (getenv ("COLUMNS")) && ! isempty (getenv ("LINES")))
+                ## Let dumb use full text screen size (minus prompt lines).
+                n = sprintf ("%i", -2 - length (find (sprintf ("%s", PS1) == "\n")));
+                ## n = the number of times \n appears in PS1
+                size_str = ["size ", getenv("COLUMNS"), ",", getenv("LINES"), n];
+              else
+                ## Use the gnuplot default.
+                size_str = "";
+              endif
+            case {"aqua", "fig", "corel"}
+              size_str = sprintf ("size %g %g", gnuplot_size);
+            case "dxf"
               size_str = "";
-            endif
-          case {"aqua", "fig", "corel"}
-            size_str = sprintf ("size %g %g", gnuplot_size);
-          case "dxf"
-            size_str = "";
-          otherwise
-            size_str = "";
+            otherwise
+              size_str = "";
           endswitch
           if ((strncmpi (term, "x11", 3)
                && __gnuplot_has_feature__ ("x11_figure_position"))
               || (strcmpi (term, "windows")
                   && __gnuplot_has_feature__ ("windows_figure_position")))
             ## X11/Windows allows the window to be positioned as well.
             units = get (0, "units");
             unwind_protect
@@ -264,52 +260,52 @@ function enhanced = gnuplot_set_term (pl
       elseif (! isfigure (h))
         disp ("gnuplot_set_term: not a figure handle");
       endif
       title_str = "";
       size_str = "";
     endif
 
     ## Set the gnuplot terminal (type, enhanced, title, options & size).
-    term_str = sprintf ("set terminal %s", term);
+    term_str = ["set terminal " term];
     if (! isempty (enh_str))
-      term_str = sprintf ("%s %s", term_str, enh_str);
+      term_str = [term_str " " enh_str];
     endif
     if (! isempty (title_str))
-      term_str = sprintf ("%s %s", term_str, title_str);
+      term_str = [term_str " " title_str];
     endif
     if (isempty (strfind (term, "corel")))
       if (! isempty (size_str) && new_stream)
         ## size_str comes after other options to permit specification of
         ## the canvas size for terminals cdr/corel.
-        term_str = sprintf ("%s %s", term_str, size_str);
+        term_str = [term_str " " size_str];
       endif
       if (nargin > 3 && ischar (opts_str))
         ## Options must go last.
-        term_str = sprintf ("%s %s", term_str, opts_str);
+        term_str = [term_str " " opts_str];
       endif
     else
       if (nargin > 3 && ischar (opts_str))
         ## Options must go last.
-        term_str = sprintf ("%s %s", term_str, opts_str);
+        term_str = [term_str " " opts_str];
       endif
       if (! isempty (size_str) && new_stream)
         ## size_str comes after other options to permit specification of
         ## the canvas size for terminals cdr/corel.
-        term_str = sprintf ("%s %s", term_str, size_str);
+        term_str = [term_str " " size_str];
       endif
     endif
     if (! __gnuplot_has_feature__ ("has_termoption_dashed"))
       ## If "set termoption dashed" isn't available add "dashed" option
       ## to the "set terminal ..." command, if it is supported.
       if (any (strcmpi (term, {"aqua", "cgm", "eepic", "emf", "epslatex", \
                                "fig", "pcl5", "mp", "next", "openstep", "pdf", \
                                "pdfcairo", "pngcairo", "postscript", \
                                "pslatex", "pstext", "svg", "tgif", "x11"})))
-        term_str = sprintf ("%s dashed", term_str);
+        term_str = [term_str " dashed"];
       endif
     end
 
     ## Work around the gnuplot feature of growing the x11 window and
     ## flickering window (x11, windows, & wxt) when the mouse and
     ## multiplot are set in gnuplot.
     fputs (plot_stream, "unset multiplot;\n");
     flickering_terms = {"x11", "windows", "wxt", "dumb"};
@@ -338,17 +334,17 @@ function enhanced = gnuplot_set_term (pl
     ## gnuplot will pick up the GNUTERM environment variable itself
     ## so no need to set the terminal type if not also setting the
     ## figure title, enhanced mode, or position.
   endif
 
 endfunction
 
 function term = gnuplot_default_term (plot_stream)
-  term = getenv ("GNUTERM");
+  term = lower (getenv ("GNUTERM"));
   ## If not specified, guess the terminal type.
   if (isempty (term) || ! __gnuplot_has_terminal__ (term, plot_stream))
     if (isguirunning () && __gnuplot_has_terminal__ ("qt", plot_stream))
       term = "qt";
     elseif (ismac ())
       term = "aqua";
     elseif (! isunix ())
       term = "windows";
@@ -357,45 +353,41 @@ function term = gnuplot_default_term (pl
     else
       term = "dumb";
     endif
   endif
 endfunction
 
 function [term, opts] = gnuplot_trim_term (string)
   ## Extract the terminal type and terminal options (from print.m)
-  string = deblank (string);
-  n = strfind (string, ' ');
-  if (isempty (n))
-    term = string;
-    opts = "";
-  else
-    term = string(1:(n-1));
-    opts = string((n+1):end);
+  string = strtrim (string);
+  [term, opts] = strtok (string, ' ');
+  if (! isempty (opts))
+    opts(1) = "";  # trim extra space from strtok
   endif
 endfunction
 
 function have_enhanced = gnuplot_is_enhanced_term (plot_stream, term)
-  persistent enhanced_terminals;
-  if (isempty (enhanced_terminals))
-    ## Don't include pstex, pslatex or epslatex here as the TeX commands
-    ## should not be interpreted in that case.
-    enhanced_terminals = {"aqua", "canvas", "dumb", "emf", "gif", "jpeg", ...
-                          "pdf", "pdfcairo", "pm", "png", "pngcairo", ...
-                          "postscript", "qt", "svg", "windows", "wxt", "x11"};
-  endif
+  ## Don't include pstex, pslatex or epslatex here as the TeX commands
+  ## should not be interpreted in that case.
+  persistent enhanced_terminals = {"aqua", "canvas", "dumb", "emf", "gif", ...
+                                   "jpeg", "pdf", "pdfcairo", "pm", "png", ...
+                                   "pngcairo", "postscript", "qt", "svg",  ...
+                                   "windows", "wxt", "x11"};
+
   if (nargin < 2)
     ## Determine the default gnuplot terminal.
     term = gnuplot_default_term (plot_stream);
   endif
-  have_enhanced = any (strncmp (enhanced_terminals, term, min (numel (term), 3)));
+  have_enhanced = any (strcmp (term, enhanced_terminals));
 endfunction
 
 function ret = output_to_screen (term)
-  ret = any (strcmpi ({"aqua", "dumb", "pm", "qt", "windows", "wxt", "x11"}, term));
+  ret = any (strcmpi (term, 
+                     {"aqua", "dumb", "pm", "qt", "windows", "wxt", "x11"}));
 endfunction
 
 function retval = have_non_legend_axes (h)
   retval = false;
   all_axes = findall (h, "type", "axes");
   if (! isempty (all_axes))
     n_all_axes = numel (all_axes);
     all_axes_tags = get (all_axes, "tag");
diff --git a/scripts/plot/gnuplot_binary.in b/scripts/plot/gnuplot_binary.in
--- a/scripts/plot/gnuplot_binary.in
+++ b/scripts/plot/gnuplot_binary.in
@@ -17,45 +17,49 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Loadable Function} {[@var{prog}, @var{args}] =} gnuplot_binary ()
 ## @deftypefnx {Loadable Function} {[@var{old_prog}, @var{old_args}] =} gnuplot_binary (@var{new_prog}, @var{arg1}, @dots{})
 ## Query or set the name of the program invoked by the plot command
 ## when the graphics toolkit is set to "gnuplot".  Additional arguments to
 ## pass to the external plotting program may also be given.
-## The default value is @code{"gnuplot"} without additional arguments.
+## The default value is @code{"gnuplot"} with no additional arguments.
 ## @xref{Installation}.
+## @seealso{graphics_toolkit}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [prog, args] = gnuplot_binary (new_prog, varargin)
 
   persistent gp_binary = %OCTAVE_CONF_GNUPLOT%;
   persistent gp_args = {};
 
   if (nargout > 0 || nargin == 0)
     prog = gp_binary;
     args = gp_args;
   endif
 
   if (nargin == 1)
-    if (ischar (new_prog))
-      if (! isempty (new_prog))
-	gp_binary = new_prog;
-      else
-	error ("gnuplot_binary: value must not be empty");
-      endif
-    else
-      error ("gnuplot_binary: expecting program to be a character string");
+    if (! ischar (new_prog) || isempty (new_prog))
+      error ("gnuplot_binary: NEW_PROG must be a non-empty string");
     endif
+    gp_binary = new_prog;
   endif
 
   if (nargin > 1)
-    if (iscellstr (varargin))
-      gp_args = varargin;
-    else
-      error ("gnuplot_binary: expecting arguments to be character strings");
+    if (! iscellstr (varargin))
+      error ("gnuplot_binary: arguments must be character strings");
     endif
+    gp_args = varargin;
   endif
 
 endfunction
+
+
+%!test
+%! orig_val = gnuplot_binary ();
+%! old_val = gnuplot_binary ("X");
+%! assert (orig_val, old_val);
+%! assert (gnuplot_binary (), "X");
+%! gnuplot_binary (orig_val);
+%! assert (gnuplot_binary (), orig_val);
diff --git a/scripts/plot/private/__gnuplot_get_var__.m b/scripts/plot/private/__gnuplot_get_var__.m
--- a/scripts/plot/private/__gnuplot_get_var__.m
+++ b/scripts/plot/private/__gnuplot_get_var__.m
@@ -19,27 +19,21 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{value} =} __gnuplot_get_var__ (@var{h}, @var{name}, @var{fmt})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2009-02-07
 
-function gp_var_value = __gnuplot_get_var__ (h, gp_var_name, fmt)
+function gp_var_value = __gnuplot_get_var__ (h, gp_var_name, fmt = "")
 
-  if (nargin == 0)
-    h = gcf ();
-  endif
   if (nargin < 2)
     print_usage ();
   endif
-  if (nargin < 3)
-    fmt = '';
-  endif
 
   if (numel (h) == 1 && isfigure (h))
     if (isempty (get (gcf, "__plot_stream__")))
       ostream = __gnuplot_open_stream__ (2, h);
     else
       ostream = get (h, "__plot_stream__");
     endif
   else
@@ -60,42 +54,42 @@ function gp_var_value = __gnuplot_get_va
   endif
 
   if (use_mkfifo)
     gpin_name = tmpnam ();
 
     ## Mode: 6*8*8 ==  0600
     [err, msg] = mkfifo (gpin_name, 6*8*8);
 
-    if (err != 0)
-      error ("__gnuplot_get_var__: Can not make fifo (%s)", msg);
+    if (err)
+      error ("__gnuplot_get_var__: Can not make FIFO (%s)", msg);
     endif
   endif
 
   gp_var_name = strtrim (gp_var_name);
   n = min (strfind (gp_var_name, " "), strfind (gp_var_name, ",")) - 1;
   if (isempty (n))
     n = numel (gp_var_name);
   endif
 
   unwind_protect
 
     ## Notes: Variables may be undefined if user closes gnuplot by "q"
-    ## or Alt-F4. Further, this abrupt close also requires the leading
+    ## or Alt-F4.  Further, this abrupt close also requires the leading
     ## "\n" on the next line.
     if (use_mkfifo)
       fprintf (ostream, "\nset print \"%s\";\n", gpin_name);
       fflush (ostream);
       [gpin, err] = fopen (gpin_name, "r");
-      if (err != 0)
+      if (err)
         ## Try a second time, and then give an error.
         [gpin, err] = fopen (gpin_name, "r");
       endif
-      if (err != 0)
-        error ("__gnuplot_get_var__: can not open fifo");
+      if (err)
+        error ("__gnuplot_get_var__: can not open FIFO");
       endif
       gp_cmd = sprintf ("\nif (exists(\"%s\")) print %s; else print NaN\n",
                         gp_var_name(1:n), gp_var_name);
       fputs (ostream, gp_cmd);
 
       ## Close output file, to force it to be flushed
       fputs (ostream, "set print;\n");
       fflush (ostream);
@@ -121,30 +115,29 @@ function gp_var_value = __gnuplot_get_va
       fputs (ostream, gp_cmd);
       fflush (ostream);
       ## Direct gnuplot to print to <STDERR>
       fputs (ostream, "set print;\n");
       fflush (ostream);
 
       str = {};
       while (isempty (str))
-        str = char (fread (istream)');
+        str = fread (istream, "*char")';
         if (isempty (str))
           sleep (0.05);
         else
           str = regexp (str, 'OCTAVE:.*', "match");
           str = str{end}(8:end);
         endif
         fclear (istream);
       endwhile
     endif
 
     ## Strip out EOLs and the continuation character "|"
-    str(str=="\n") = "";
-    str(str=="\r") = "";
+    str(str=="\n" | str=="\r") = "";
     n_continue = strfind (str, " \\ ");
     if (! isempty (n_continue))
       str(n_continue+1) = "";
     endif
 
     if (isempty (fmt))
       gp_var_value = strtrim (str);
     else
diff --git a/scripts/plot/private/__gnuplot_ginput__.m b/scripts/plot/private/__gnuplot_ginput__.m
--- a/scripts/plot/private/__gnuplot_ginput__.m
+++ b/scripts/plot/private/__gnuplot_ginput__.m
@@ -26,52 +26,52 @@
 
 ## This file initially bore the copyright statement
 ## Petr Mikulik
 ## History: June 2006; August 2005; June 2004; April 2004
 ## License: public domain
 
 function [x, y, button] = __gnuplot_ginput__ (f, n)
 
+  if (compare_versions (__gnuplot_version__ (), "4.0", "<="))
+    error ("ginput: version %s of gnuplot not supported", gnuplot_version ());
+  endif
+
   ostream = get (f, "__plot_stream__");
   if (numel (ostream) < 1)
     error ("ginput: stream to gnuplot not open");
   elseif (ispc ())
     if (numel (ostream) == 1)
       error ("ginput: Need mkfifo that is not implemented under Windows");
     endif
     use_mkfifo = false;
     istream = ostream(2);
     ostream = ostream(1);
   else
     use_mkfifo = true;
     ostream = ostream(1);
   endif
 
-  if (compare_versions (__gnuplot_version__ (), "4.0", "<="))
-    error ("ginput: version %s of gnuplot not supported", gnuplot_version ());
-  endif
-
   if (nargin == 1)
     x = zeros (100, 1);
     y = zeros (100, 1);
     button = zeros (100, 1);
   else
     x = zeros (n, 1);
     y = zeros (n, 1);
     button = zeros (n, 1);
   endif
 
   if (use_mkfifo)
     gpin_name = tmpnam ();
 
     ##Mode: 6*8*8 ==  0600
     [err, msg] = mkfifo (gpin_name, 6*8*8);
 
-    if (err != 0)
+    if (err)
       error ("ginput: Can not open fifo (%s)", msg);
     endif
   endif
 
   unwind_protect
 
     k = 0;
     while (true)
@@ -79,42 +79,42 @@ function [x, y, button] = __gnuplot_ginp
 
       ## Notes: MOUSE_* can be undefined if user closes gnuplot by "q"
       ## or Alt-F4. Further, this abrupt close also requires the leading
       ## "\n" on the next line.
       if (use_mkfifo)
         fprintf (ostream, "set print \"%s\";\n", gpin_name);
         fflush (ostream);
         [gpin, err] = fopen (gpin_name, "r");
-        if (err != 0)
-          error ("ginput: Can not open fifo (%s)", msg);
+        if (err)
+          error ("ginput: Can not open FIFO (%s)", msg);
         endif
         fputs (ostream, "pause mouse any;\n\n");
         fputs (ostream, "\nif (exists(\"MOUSE_KEY\") && exists(\"MOUSE_X\")) print MOUSE_X, MOUSE_Y, MOUSE_KEY; else print \"0 0 -1\"\n");
 
         ## Close output file, to force it to be flushed
         fputs (ostream, "set print;\n");
         fflush (ostream);
 
         ## Now read from fifo.
         [x(k), y(k), button(k), count] = fscanf (gpin, "%f %f %d", "C");
         fclose (gpin);
       else
-        fprintf (ostream, "set print \"-\";\n");
+        fputs (ostream, "set print \"-\";\n");
         fflush (ostream);
         fputs (ostream, "pause mouse any;\n\n");
         fputs (ostream, "\nif (exists(\"MOUSE_KEY\") && exists(\"MOUSE_X\")) print \"OCTAVE: \", MOUSE_X, MOUSE_Y, MOUSE_KEY; else print \"0 0 -1\"\n");
 
         ## Close output file, to force it to be flushed
         fputs (ostream, "set print;\n");
         fflush (ostream);
 
         str = {};
         while (isempty (str))
-          str = char (fread (istream)');
+          str = fread (istream, "*char")';
           if (isempty (str))
             sleep (0.05);
           else
             str = regexp (str, 'OCTAVE:\s+[-+.\d]+\s+[-+.\d]+\s+\d*', 'match');
           endif
           fclear (istream);
         endwhile
         [x(k), y(k), button(k), count] = sscanf (str{end}(8:end), "%f %f %d", "C");
diff --git a/scripts/plot/private/__gnuplot_has_feature__.m b/scripts/plot/private/__gnuplot_has_feature__.m
--- a/scripts/plot/private/__gnuplot_has_feature__.m
+++ b/scripts/plot/private/__gnuplot_has_feature__.m
@@ -20,44 +20,45 @@
 ## @deftypefn {Function File} {@var{has_feature} =} __gnuplot_has_feature__ (@var{feature})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2009-01-27
 
 function res = __gnuplot_has_feature__ (feature)
-  persistent features has_features
-  features = {"x11_figure_position",
-              "wxt_figure_size",
-              "transparent_patches",
-              "transparent_surface",
-              "epslatex_implies_eps_filesuffix",
-              "epslatexstandalone_terminal",
-              "screen_coordinates_for_{lrtb}margin",
-              "variable_GPVAL_TERMINALS",
-              "key_has_font_properties",
-              "windows_figure_position",
-              "has_termoption_dashed"};
+  persistent features = {"x11_figure_position",
+                         "wxt_figure_size",
+                         "transparent_patches",
+                         "transparent_surface",
+                         "epslatex_implies_eps_filesuffix",
+                         "epslatexstandalone_terminal",
+                         "screen_coordinates_for_{lrtb}margin",
+                         "variable_GPVAL_TERMINALS",
+                         "key_has_font_properties",
+                         "windows_figure_position",
+                         "has_termoption_dashed"};
+  persistent has_features;
 
   if (isempty (has_features))
     try
       gnuplot_version = __gnuplot_version__ ();
     catch
       ## Don't throw an error if gnuplot isn't installed
       gnuplot_version = "0.0.0";
     end_try_catch
     versions = {"4.2.5", "4.4", "4.4", "4.4", "4.2", "4.2", "4.4", "4.4", "4.4", "4.4", "4.3"};
     operators = {">=", ">=", ">=", ">=", ">=", ">=", ">=", ">=", ">=", ">=", ">="};
-    have_features = logical (zeros (size (features)));
+    have_features = false (size (features));
     for n = 1 : numel (have_features)
       has_features(n) = compare_versions (gnuplot_version, versions{n}, operators{n});
     endfor
   endif
 
   n = find (strcmpi (feature, features));
   if (isempty (n))
     res = NaN;
   else
     res = has_features(n);
   endif
+
 endfunction
 
diff --git a/scripts/plot/private/__gnuplot_has_terminal__.m b/scripts/plot/private/__gnuplot_has_terminal__.m
--- a/scripts/plot/private/__gnuplot_has_terminal__.m
+++ b/scripts/plot/private/__gnuplot_has_terminal__.m
@@ -20,21 +20,20 @@
 ## @deftypefn {Function File} {@var{has_terminal} =} __gnuplot_has_terminal__ (@var{terminal})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-09-13
 
 function gnuplot_supports_term = __gnuplot_has_terminal__ (term, plot_stream)
-  term = deblank (term);
-  n = find (term == " ", 1);
-  if (! isempty (n))
-    term = term(1:n-1);
-  endif
+
+  term = strtrim (term);
+  term = lower (strtok (term, " "));
+
   if (__gnuplot_has_feature__ ("variable_GPVAL_TERMINALS"))
     if (nargin < 2)
       plot_stream = __gnuplot_open_stream__ (2);
     endif
     available_terminals = __gnuplot_get_var__ (plot_stream, "GPVAL_TERMINALS");
     available_terminals = regexp (available_terminals, '\w+', "match");
     if (nargin < 2 && ! isempty (plot_stream))
       pclose (plot_stream(1));
@@ -54,11 +53,13 @@ function gnuplot_supports_term = __gnupl
                            "gpic", "hp2623A", "hp2648", "hp500c", ...
                            "hpgl", "hpljii", "hppj", "imagen", "jpeg", ...
                            "latex", "mf", "mif", "mp", "pbm", "pdf", ...
                            "pm", "png", "postscript", "pslatex", ...
                            "pstex", "pstricks", "qms", "regis", "rgip", ...
                            "svg", "texdraw", "tgif", "tkcanvas", ...
                            "tpic", "windows", "x11", "xlib", "xterm"};
   endif
-  gnuplot_supports_term = any (strcmpi (available_terminals, term));
+
+  gnuplot_supports_term = any (strcmp (term, available_terminals));
+
 endfunction
 
diff --git a/scripts/plot/private/__gnuplot_print__.m b/scripts/plot/private/__gnuplot_print__.m
--- a/scripts/plot/private/__gnuplot_print__.m
+++ b/scripts/plot/private/__gnuplot_print__.m
@@ -46,25 +46,25 @@ function opts = __gnuplot_print__ (opts)
   ## the font spec given in "set terminal ..."
   gp_opts = font_spec (opts);
 
   pipeline = "";
 
   switch (lower (opts.devopt))
   case {"eps", "eps2", "epsc", "epsc2"}
     if (any (strcmp (opts.devopt, {"eps", "epsc"})))
-      gp_opts = sprintf ("%s level1", gp_opts);
+      gp_opts = [gp_opts " level1"];
     endif
     if (opts.tight_flag || ! isempty (opts.preview))
       tmp_file = strcat (tmpnam (), ".eps");
       eps_drawnow (opts, tmp_file, gp_opts);
       if (dos_shell)
-        cleanup = sprintf (" & del %s", strrep (tmp_file, '/', '\'));
+        cleanup = [" & del " strrep(tmp_file, '/', '\')];
       else
-        cleanup = sprintf (" ; rm %s", tmp_file);
+        cleanup = [" ; rm " tmp_file];
       endif
       pipeline = {sprintf("%s %s",
                           opts.epstool_cmd (opts, tmp_file, opts.name),
                           cleanup)};
     else
       eps_drawnow (opts, opts.name, gp_opts);
     endif
   case {"epslatex", "pslatex", "pstex", "epslatexstandalone"}
@@ -84,65 +84,65 @@ function opts = __gnuplot_print__ (opts)
       term = sprintf ("%s ",
                       strrep (opts.devopt, "standalone", " standalone"));
     else
       term = sprintf ("%s ", opts.devopt);
     endif
     if (__gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
       suffix = "tex";
     else
-      %% Gnuplot 4.0 wants a ".eps" suffix.
+      ## Gnuplot 4.0 wants a ".eps" suffix.
       suffix = "eps";
     endif
-    local_drawnow (sprintf ("%s %s", term, gp_opts),
+    local_drawnow ([term " " gp_opts],
                    strcat (name, ".", suffix), opts);
   case "tikz"
     if (__gnuplot_has_terminal__ ("tikz"))
-      local_drawnow (sprintf ("lua tikz %s", gp_opts), opts.name, opts);
+      local_drawnow (["lua tikz " gp_opts], opts.name, opts);
     else
       error (sprintf ("print:no%soutput", opts.devopt),
              "print.m: '%s' output is not available for gnuplot-%s",
              upper (opts.devopt), __gnuplot_version__ ());
     endif
   case "svg"
-    local_drawnow (sprintf ("svg dynamic %s", gp_opts), opts.name, opts);
+    local_drawnow (["svg dynamic " gp_opts], opts.name, opts);
   case {"aifm", "corel", "eepic", "emf", "fig"}
-    local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts);
+    local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
   case {"pdfcairo", "pngcairo"}
     if (__gnuplot_has_terminal__ (opts.devopt))
-      local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts);
+      local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
     else
       error (sprintf ("print:no%soutput", opts.devopt),
              "print.m: '%s' output is not available for gnuplot-%s",
              upper (opts.devopt), __gnuplot_version__ ());
     endif
   case {"canvas", "dxf", "hpgl", "mf", "gif", "pstricks", "texdraw"}
-    local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts);
+    local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
   case opts.ghostscript.device
     gp_opts = font_spec (opts, "devopt", "eps");
     opts.ghostscript.output = opts.name;
     opts.ghostscript.source = strcat (tmpnam (), ".eps");
     eps_drawnow (opts, opts.ghostscript.source, gp_opts);
     [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
     if (opts.send_to_printer || isempty (opts.name))
       cmd_lpr = opts.lpr_cmd (opts);
-      cmd = sprintf ("%s | %s", cmd_gs, cmd_lpr);
+      cmd = [cmd_gs " | " cmd_lpr];
     else
-      cmd = sprintf ("%s", cmd_gs);
+      cmd = cmd_gs;
     endif
     if (dos_shell)
       cmd = sprintf ("%s & del %s", cmd, strrep (opts.ghostscript.source, '/', '\'));
     else
       cmd = sprintf ("%s ; rm %s", cmd, opts.ghostscript.source);
     endif
     if (! isempty (cmd_cleanup))
       if (dos_shell)
-        pipeline = {sprintf("%s & %s", cmd, cmd_cleanup)};
+        pipeline = {[cmd " & " cmd_cleanup]};
       else
-        pipeline = {sprintf("%s ; %s", cmd, cmd_cleanup)};
+        pipeline = {[cmd " ; " cmd_cleanup]};
       endif
     else
       pipeline = {cmd};
     endif
   otherwise
     error (sprintf ("print:no%soutput", opts.devopt),
            "print.m: %s output is not available for the Gnuplot graphics toolkit",
            upper (opts.devopt));
@@ -165,24 +165,21 @@ function opts = __gnuplot_print__ (opts)
     endif
   endfor
 
 endfunction
 
 function eps_drawnow (opts, epsfile, gp_opts)
   [h, fontsize] = get_figure_text_objs (opts);
   unwind_protect
-    for n = 1:numel (h)
-      set (h(n), "fontsize", 2 * fontsize{n});
-    endfor
-    local_drawnow (sprintf ("postscript eps %s", gp_opts), epsfile, opts);
+    fontsize_2x = cellfun (@(x) 2*x, fontsize, "uniformoutput", false);
+    set (h, {"fontsize"}, fontsize_2x);
+    local_drawnow (["postscript eps " gp_opts], epsfile, opts);
   unwind_protect_cleanup
-    for n = 1:numel (h)
-      set (h(n), "fontsize", fontsize{n});
-    endfor
+    set (h, {"fontsize"}, fontsize);
   end_unwind_protect
 endfunction
 
 function local_drawnow (term, file, opts)
   if (opts.use_color < 0)
     mono = true;
   else
     mono = false;
@@ -198,81 +195,81 @@ endfunction
 function f = font_spec (opts, varargin)
   for n = 1:2:numel (varargin)
     opts.(varargin{n}) = varargin{n+1};
   endfor
   f = "";
   switch (opts.devopt)
   case "cgm"
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("font ""%s,%d""", opts.font, opts.fontsize);
+      f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("font ""%s""", opts.font);
+      f = sprintf ('font "%s"', opts.font);
     elseif (! isempty (opts.fontsize))
       f = sprintf ("%d", opts.fontsize);
     endif
   case {"eps", "eps2", "epsc", "epsc2"}
     ## Gnuplot renders fonts as half their specification, which
     ## results in a tight spacing for the axes-labels and tick-labels.
     ## Compensate for the half scale. This will produce the proper
     ## spacing for the requested fontsize.
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("font ""%s,%d""", opts.font, 2 * opts.fontsize);
+      f = sprintf ('font "%s,%d"', opts.font, 2 * opts.fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("font ""%s""", opts.font);
+      f = sprintf ('font "%s"', opts.font);
     elseif (! isempty (opts.fontsize))
       f = sprintf ("%d", 2 * opts.fontsize);
     endif
   case "svg"
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
       fontsize = round (opts.fontsize * 0.75);
-      f = sprintf ("fname ""%s"" fsize %d", opts.font, fontsize);
+      f = sprintf ('fname "%s" fsize %d', opts.font, fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("fname ""%s""", opts.font);
+      f = sprintf ('fname "%s"', opts.font);
     elseif (! isempty (opts.fontsize))
       fontsize = round (opts.fontsize * 0.75);
       f = sprintf ("%s fsize %d", f, fontsize);
     endif
   case "pdf"
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("font ""%s,%d""", opts.font, opts.fontsize);
+      f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("font ""%s""", opts.font);
+      f = sprintf ('font "%s"', opts.font);
     elseif (! isempty (opts.fontsize))
       f = sprintf ("fsize %d", f, opts.fontsize);
     endif
   case {"pdfcairo", "pngcairo"}
     if (! isempty (opts.font))
-      f = sprintf ("font ""%s""", opts.font);
+      f = sprintf ('font "%s"', opts.font);
     endif
   case {"epslatex", "epslatexstandalone"}
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("font ""%s,%d""", opts.font, opts.fontsize);
+      f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("font ""%s""", opts.font);
+      f = sprintf ('font "%s"', opts.font);
     elseif (! isempty (opts.fontsize))
       f = sprintf ("%d", opts.fontsize);
     endif
   case "pslatex"
     if (! isempty (opts.fontsize))
       f = sprintf ("%d", opts.fontsize);
     endif
   case {"gif", "jpeg", "png"}
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("font ""%s ,%d""", opts.font, opts.fontsize);
+      f = sprintf ('font "%s ,%d"', opts.font, opts.fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("font ""%s""", opts.font);
+      f = sprintf ('font "%s"', opts.font);
     elseif (! isempty (opts.fontsize))
-      f = sprintf ("font ""%d""", opts.fontsize);
+      f = sprintf ('font "%d"', opts.fontsize);
     endif
   case "emf"
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("""%s"" %d", opts.font, opts.fontsize);
+      f = sprintf ('"%s" %d', opts.font, opts.fontsize);
     elseif (! isempty (opts.font))
-      f = sprintf ("""%s""", opts.font);
+      f = sprintf ('"%s"', opts.font);
     elseif (! isempty (opts.fontsize))
       f = sprintf ("%d", opts.fontsize);
     endif
   case "canvas"
     if (! isempty (opts.fontsize))
       f = sprintf ("fsize %d", opts.fontsize);
     endif
   case {"aifm", "corel"}
diff --git a/scripts/plot/private/__gnuplot_version__.m b/scripts/plot/private/__gnuplot_version__.m
--- a/scripts/plot/private/__gnuplot_version__.m
+++ b/scripts/plot/private/__gnuplot_version__.m
@@ -25,22 +25,22 @@
 ## attempt to handle the case of the user switching to different
 ## versions of gnuplot during the same session.
 
 function version = __gnuplot_version__ ()
 
   persistent __version__ = "";
 
   if (isempty (__version__))
-    [status, output] = system (sprintf ("\"%s\" --version", gnuplot_binary ()));
+    [status, output] = system (sprintf ('"%s" --version', gnuplot_binary ()));
     if (status != 0)
       ## This message ends in a newline so that the traceback messages
       ## are skipped and people might actually see the message, read it,
-      ## comprehend it, actually take the advice it gives, and stop
-      ## asking us why plotting fails when gnuplot is not found.
+      ## comprehend it, take the advice it gives, and stop asking us
+      ## why plotting fails when gnuplot is not found.
       error ("you must have gnuplot installed to display graphics; if you have gnuplot installed in a non-standard location, see the 'gnuplot_binary' function\n");
     endif
     output = strrep (output, "gnuplot", "");
     output = strrep (output, "patchlevel", ".");
     output = strrep (output, "\n", "");
     output = strrep (output, "\r", "");
     __version__ = strrep (output, " ", "");
   endif
