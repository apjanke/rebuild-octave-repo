# HG changeset patch
# User jwe
# Date 1175789343 0
#      Thu Apr 05 16:09:03 2007 +0000
# Node ID 76a1a953533da6dd9e34b987d63a37b9225a205c
# Parent  5fa513371ddecaa4b99f6553e27e774c31aa71b3
[project @ 2007-04-05 16:09:03 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,29 @@
+2007-04-05  John W. Eaton  <jwe@octave.org>
+
+	* testfun/speed.m: Use "strcat (...)" instead of "[...]".
+	Plotting fixes.  Style fixes.
+
+	* testfun/test.m: Use "strcat (...)" instead of "[...]".
+	Style fixes.
+
+	* testfun/fail.m: No need to check for evalin and lastwarn.
+	Style fixes.
+
+	* testfun/demo.m, testfun/example.m: Style fixes.
+	Use "strcat (...)" instead of "[...]".
+	Use format specifiers in calls to warning.
+
+	* testfun/assert.m: Use "numel (x)" instead of "prod (size (x))".
+	Use "strcat (...)" instead of "[...]".
+	Use "x(end)" instead of "x(length (x))".
+	Check NA before NaN.
+	Style fixes.
+
 2007-03-29  John W. Eaton  <jwe@octave.org>
 
 	* plot/stem.m (stem, set_default_values): Use RGB triple for color.
 
 2007-03-27  John W. Eaton  <jwe@octave.org>
 
 	* Makefile.in, audio/Makefile.in, control/Makefile.in,
 	control/base/Makefile.in, control/hinf/Makefile.in,
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -41,157 +41,172 @@
 ## @end table
 ## @seealso{test}
 ## @end deftypefn
 
 ## TODO: Output throttling: don't print out the entire 100x100 matrix,
 ## TODO: but instead give a summary; don't print out the whole list, just
 ## TODO: say what the first different element is, etc.  To do this, make
 ## TODO: the message generation type specific.
-function assert(cond, expected, tol)
+
+function assert (cond, expected, tol)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin < 3)
     tol = 0;
   endif
 
-  if exist("argn") == 0, argn=" "; endif
-  in = deblank(argn(1,:));
-  for i=2:rows(argn)
-    in = [in, ",", deblank(argn(i,:))];
+  if (exist ("argn") == 0)
+    argn = " ";
+  endif
+
+  in = deblank (argn(1,:));
+  for i = 2:rows (argn)
+    in = strcat (in, ",", deblank (argn(i,:)));
   end
-  in = ["(",in,")"];
+  in = strcat ("(", in, ")");
 
   coda = "";
   iserror = 0;
   if (nargin == 1)
-    if (!isnumeric(cond) || !all(cond(:)))
+    if (! isnumeric (cond) || ! all (cond(:)))
       error ("assert %s failed", in); # say which elements failed?
     endif
   
-  elseif (is_list(cond))
-    if (!is_list(expected) || length(cond) != length(expected))
+  elseif (is_list (cond))
+    if (! is_list (expected) || length (cond) != length (expected))
       iserror = 1;
     else
       try
-	for i=1:length(cond)
-	  assert(nth(cond,i),nth(expected,i));
+	for i = 1:length (cond)
+	  assert (nth (cond, i), nth (expected, i));
 	endfor
       catch
 	iserror = 1;
       end
     endif
 
   elseif (ischar (expected))
-    iserror = (!ischar (cond) || !strcmp (cond, expected));
+    iserror = (! ischar (cond) || ! strcmp (cond, expected));
 
-  elseif (iscell(expected))
-    if (!iscell (cond) || any(size(cond)!=size(expected)))
+  elseif (iscell (expected))
+    if (! iscell (cond) || any (size (cond) != size (expected)))
       iserror = 1;
     else
       try
-	for i=1:length(expected(:))
-	  assert(cond{i},expected{i},tol);
+	for i = 1:length (expected(:))
+	  assert (cond{i}, expected{i}, tol);
 	endfor
       catch
 	iserror = 1;
       end
     endif
 
   elseif (isstruct (expected))
-    if (!isstruct (cond) || any(size(cond) != size(expected))
-	|| rows(struct_elements(cond)) != rows(struct_elements(expected)))
+    if (! isstruct (cond) || any (size (cond) != size (expected))
+	|| rows(struct_elements (cond)) != rows (struct_elements (expected)))
       iserror = 1;
     else
       try
-	empty=prod(size(cond))==0;
-	normal=prod(size(cond))==1;
-	for [v,k] = cond
-	  if !struct_contains(expected,k), error; endif
-	  if empty, v = cell(1,0); endif
-	  if normal, v = {v}; else v = v(:)'; endif
-	  assert(v,{expected.(k)},tol)
+	empty = numel (cond) == 0;
+	normal = numel (cond) == 1;
+	for [v, k] = cond
+	  if (! struct_contains (expected, k))
+	    error ();
+	  endif
+	  if (empty)
+	    v = cell (1, 0);
+	  endif
+	  if (normal)
+	    v = {v};
+	  else
+	    v = v(:)';
+	  endif
+	  assert (v, {expected.(k)}, tol);
 	endfor
       catch
 	iserror = 1;
       end
     endif
 
   elseif (ndims (cond) != ndims (expected)
 	  || any (size (cond) != size (expected)))
     iserror = 1;
     coda = "Dimensions don't match";
 
-  elseif tol==0 && !strcmp(typeinfo(cond),typeinfo(expected))
+  elseif (tol == 0 && ! strcmp (typeinfo (cond), typeinfo (expected)))
     iserror = 1;
-    coda = ["Type ",typeinfo(cond)," != ",typeinfo(expected)];
+    coda = strcat ("Type ", typeinfo (cond), " != ", typeinfo (expected));
 
   else # numeric
-    A=cond(:); B=expected(:);
+    A = cond(:);
+    B = expected(:);
     ## Check exceptional values
-    if any(isnan(A) != isnan(B))
+    if (any (isna (A) != isna (B)))
+      iserror = 1;
+      coda = "NAs don't match";
+    elseif (any (isnan (A) != isnan (B)))
       iserror = 1;
       coda = "NaNs don't match";
-    elseif any(isna(A) != isna(B))
-      iserror = 1;
-      coda = "NAs don't match";
-      ## Try to avoid problems comparing strange values like Inf+NaNi.
-    elseif (any(isinf(A) != isinf(B))
-	    || any(A(isinf(A) & !isnan(A)) != B(isinf(B) & !isnan(B))))
+### Try to avoid problems comparing strange values like Inf+NaNi.
+    elseif (any (isinf (A) != isinf (B))
+	    || any (A(isinf (A) & ! isnan (A)) != B(isinf (B) & ! isnan (B))))
       iserror = 1;
       coda = "Infs don't match";
     else
       ## Check normal values
-      A = A(finite(A)); B=B(finite(B));
-      if tol == 0,
-        err = any(A != B);
+      A = A(finite (A));
+      B = B(finite (B));
+      if (tol == 0)
+        err = any (A != B);
 	errtype = "values do not match";
-      elseif tol >= 0,
-	err = max(abs(A-B));
+      elseif (tol >= 0)
+	err = max (abs (A - B));
 	errtype = "maximum absolute error %g exceeds tolerance %g";
       else 
-	abserr = max(abs(A(B==0)));
-	A = A(B!=0); B = B(B!=0);
-	relerr = max(abs(A-B)./abs(B));
-	err = max([abserr;relerr]);
+	abserr = max (abs (A(B == 0)));
+	A = A(B != 0);
+	B = B(B != 0);
+	relerr = max (abs (A - B) ./ abs (B));
+	err = max ([abserr; relerr]);
 	errtype = "maximum relative error %g exceeds tolerance %g";
       endif
-      if err > abs(tol)
+      if (err > abs (tol))
 	iserror = 1;
-	coda = sprintf(errtype,err,abs(tol));
+	coda = sprintf (errtype, err, abs (tol));
       endif
     endif
   endif
 
-  if (!iserror)
+  if (! iserror)
     return;
   endif
 
   ## pretty print the "expected but got" info,
   ## trimming leading and trailing "\n"
   str = disp (expected);
-  idx = find(str!="\n");
-  if (!isempty(idx))
-    str = str(idx(1):idx(length(idx)));
+  idx = find (str != "\n");
+  if (! isempty (idx))
+    str = str(idx(1):idx(end));
   endif
   str2 = disp (cond);
-  idx = find(str2!="\n");
-  if (!isempty(idx))
-    str2 = str2(idx(1):idx(length(idx)));
+  idx = find (str2 != "\n");
+  if (! isempty (idx))
+    str2 = str2 (idx(1):idx(end));
   endif
-  msg = ["assert ",in," expected\n", str, "\nbut got\n", str2];
-  if (!isempty(coda))
-    msg = [ msg, "\n", coda ];
+  msg = strcat ("assert ", in, " expected\n", str, "\nbut got\n", str2);
+  if (! isempty (coda))
+    msg = strcat (msg, "\n", coda);
   endif
-  error("%s",msg);
-  ## disp(msg);
-  ## error("assertion failed");
+  error ("%s", msg);
+  ## disp (msg);
+  ## error ("assertion failed");
 endfunction
 
 ## empty
 %!assert([])
 %!assert(zeros(3,0),zeros(3,0))
 %!error assert(zeros(3,0),zeros(0,2))
 %!error assert(zeros(3,0),[])
 %!fail("assert(zeros(2,0,2),zeros(2,0))", "Dimensions don't match")
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -70,58 +70,58 @@
 ## @end deftypefn
 
 ## TODO: modify subplot so that gnuplot_has_multiplot == 0 causes it to
 ## TODO: use the current figure window but pause if not plotting in the
 ## TODO: first subplot.
 
 ## PKG_ADD: mark_as_command demo
 
-function demo(name, n)
+function demo (name, n)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin < 2)
     n = 0;
   endif
 
-  [code, idx] = test (name, 'grabdemo');
-  if (length(idx) == 0)
-    warning(["demo not available for ", name]);
+  [code, idx] = test (name, "grabdemo");
+  if (length (idx) == 0)
+    warning ("demo not available for %s", name);
     return;
-  elseif (n >= length(idx))
-    warning(sprintf("only %d demos available for %s", length(idx)-1, name));
+  elseif (n >= length (idx))
+    warning ("only %d demos available for %s", length (idx) - 1, name);
     return;
   endif
 
 
   if (n > 0)
     doidx = n;
   else
-    doidx = [ 1 : length(idx)-1 ];
+    doidx = 1:length(idx)-1;
   endif
-  for i=1:length(doidx)
+  for i = 1:length (doidx)
     ## Pause between demos
     if (i > 1)
-      input("Press <enter> to continue: ","s");
+      input ("Press <enter> to continue: ", "s");
     endif
 
     ## Process each demo without failing
     try
-      block = code( idx(doidx(i)) : idx(doidx(i)+1) -1 );
+      block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
       ## Use an environment without variables
-      eval(["function __demo__()\n", block, "\nendfunction"]);
+      eval (strcat ("function __demo__()\n", block, "\nendfunction"));
       ## Display the code that will be executed before executing it
-      printf("%s example %d:%s\n\n", name, doidx(i), block);
+      printf ("%s example %d:%s\n\n", name, doidx(i), block);
       __demo__;
     catch
       ## Let the programmer know which demo failed.
-      printf("%s example %d: failed\n%s", name, doidx(i), __error_text__);
+      printf ("%s example %d: failed\n%s", name, doidx(i), __error_text__);
     end_try_catch
     clear __demo__;
   endfor
 
 endfunction
 
 %!demo
 %! t=0:0.01:2*pi; x = sin(t);
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -28,55 +28,55 @@
 ## various examples.
 ##
 ## See @code{demo} for a complete explanation.
 ## @seealso{demo, test}
 ## @end deftypefn
 
 ## PKG_ADD: mark_as_command example
 
-function [code_r, idx_r] = example(name, n)
+function [code_r, idx_r] = example (name, n)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
   if (nargin < 2)
     n = 0;
   endif
 
-  [code, idx] = test (name, 'grabdemo');
+  [code, idx] = test (name, "grabdemo");
   if (nargout > 0)
     if (n > 0)
-      if (n <= length(idx))
-      	code_r = code(idx(n) : idx(n+1)-1);
+      if (n <= length (idx))
+      	code_r = code(idx(n):idx(n+1)-1);
       	idx_r = [1, length(code_r)+1];
       else
 	code_r = "";
 	idx_r = [];
       endif
     else
       code_r = code;
       idx_r = idx;
     endif
   else
     if (n > 0)
       doidx = n;
     else
-      doidx = [ 1:length(idx)-1 ];
+      doidx = 1:length(idx)-1;
     endif
-    if (length(idx) == 0)
-      warning(["example not available for ", name]);
+    if (length (idx) == 0)
+      warning ("example not available for %s", name);
     elseif (n >= length(idx))
-      warning(sprintf("only %d examples available for %s", length(idx)-1, name));
+      warning ("only %d examples available for %s", length(idx)-1, name);
       doidx = [];
     endif
 
     for i=1:length(doidx)
-      block = code( idx(doidx(i)) : idx(doidx(i)+1) -1 );
-      printf("%s example %d:%s\n\n", name, doidx(i), block);
+      block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
+      printf ("%s example %d:%s\n\n", name, doidx(i), block);
     endfor
   endif
 
 endfunction
 
 %!## warning: don't modify the demos without modifying the tests!
 %!demo
 %! example('example');
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -1,8 +1,25 @@
+## Copyright (C) 2005 Paul Kienzle
+##
+## This program is free software; you can redistribute it and/or modify
+## it under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2 of the License, or
+## (at your option) any later version.
+##
+## This program is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with this program; if not, write to the Free Software
+## Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+## 02110-1301  USA
+
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} fail (@var{code},@var{pattern})
 ## @deftypefnx {Function File} {} fail (@var{code},'warning',@var{pattern})
 ##
 ## Return true if @var{code} fails with an error message matching
 ## @var{pattern}, otherwise produce an error. Note that @var{code}
 ## is a string and if @var{code} runs successfully, the error produced is:
 ##
@@ -24,78 +41,87 @@
 ## warning is given during code execution or if the code fails.
 ##
 ## @end deftypefn
 
 ## This program is public domain
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 ## PKG_ADD mark_as_command fail
-function ret=fail(code,pattern,warning_pattern)
-  if nargin < 1 || nargin > 3
+
+function ret = fail (code, pattern, warning_pattern)
+
+  if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   ## sort out arguments
-  test_warning =  (nargin > 1 && strcmp(pattern,'warning'));
-  if nargin == 3
+  test_warning = (nargin > 1 && strcmp (pattern, "warning"));
+  if (nargin == 3)
     pattern = warning_pattern;
-  elseif nargin == 1 || (nargin==2 && test_warning)
+  elseif (nargin == 1 || (nargin==2 && test_warning))
     pattern = "";
   endif
-  if isempty(pattern), pattern = "."; endif  # match any nonempty message
+
+  ## match any nonempty message
+  if (isempty (pattern))
+    pattern = ".";
+  endif
 
   ## allow assert(fail())
-  if nargout, ret=1; endif  
-
-  ## don't test failure if evalin doesn't exist
-  if !exist('evalin') || !exist('lastwarn'), return; endif
+  if (nargout)
+    ret = 1;
+  endif  
 
-  if test_warning
+  if (test_warning)
     ## perform the warning test
-    lastwarn();  # clear old warnings
-    state = warning("query","quiet"); # make sure warnings are turned on
-    warning("on","quiet");
+    lastwarn ();  # clear old warnings
+    state = warning ("query", "quiet"); # make sure warnings are turned on
+    warning ("on", "quiet");
     try
       ## printf("lastwarn before %s: %s\n",code,lastwarn);
-      evalin("caller",sprintf("%s;",code));
+      evalin ("caller", sprintf ("%s;", code));
       ## printf("lastwarn after %s: %s\n",code,lastwarn);
-      err = lastwarn;  # retrieve new warnings
-      warning(state.state,"quiet");
-      if isempty(err), 
-        msg = sprintf("expected warning <%s> but got none", pattern); 
+      err = lastwarn ();  # retrieve new warnings
+      warning (state.state, "quiet");
+      if (isempty (err))
+        msg = sprintf ("expected warning <%s> but got none", pattern); 
       else
-        err([1:9,end]) = [];  # transform "warning: ...\n" to "..."
-        if !isempty(regexp(err,pattern,"once")), return; end
-        msg = sprintf("expected warning <%s>\nbut got <%s>", pattern,err);
+        err([1:9, end]) = [];  # transform "warning: ...\n" to "..."
+        if (! isempty (regexp (err, pattern, "once")))
+	  return;
+	endif
+        msg = sprintf ("expected warning <%s>\nbut got <%s>", pattern, err);
       endif
     catch
-      warning(state.state,"quiet");
+      warning (state.state, "quiet");
       err = lasterr;
-      err([1:7,end]) = [];  # transform "error: ...\n", to "..."
-      msg = sprintf("expected warning <%s> but got error <%s>", pattern, err);
+      err([1:7, end]) = [];  # transform "error: ...\n", to "..."
+      msg = sprintf ("expected warning <%s> but got error <%s>", pattern, err);
     end
       
   else
     ## perform the error test
     try
-      evalin("caller",sprintf("%s;",code));
-      msg = sprintf("expected error <%s> but got none", pattern);
+      evalin ("caller", sprintf ("%s;", code));
+      msg = sprintf ("expected error <%s> but got none", pattern);
     catch
-      err=lasterr;
-      if (strcmp(err(1:7),"error:"))
-         err([1:6,end]) = []; # transform "error: ...\n", to "..."
+      err = lasterr ();
+      if (strcmp (err(1:7), "error:"))
+         err([1:6, end]) = []; # transform "error: ...\n", to "..."
       endif
-      if !isempty(regexp(err,pattern,"once")), return; end
-      msg = sprintf("expected error <%s>\nbut got <%s>",pattern,err);
+      if (! isempty (regexp (err, pattern, "once")))
+	return;
+      endif
+      msg = sprintf ("expected error <%s>\nbut got <%s>", pattern, err);
     end
   endif
 
   ## if we get here, then code didn't fail or error didn't match
-  error(msg);
+  error (msg);
 endfunction
 
 %!fail ('[1,2]*[2,3]','nonconformant')
 %!fail ("fail('[1,2]*[2;3]','nonconformant')","expected error <nonconformant> but got none")
 %!fail ("fail('[1,2]*[2,3]','usage:')","expected error <usage:>\nbut got.*nonconformant")
 %!fail ("warning('test warning')",'warning','test warning');
 
 %!# fail ("warning('next test')",'warning','next test');  ## only allowed one warning test?!?
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -138,165 +138,183 @@
 ## Type @code{example('speed')} to see some real examples. Note for 
 ## obscure reasons, you can't run examples 1 and 2 directly using 
 ## @code{demo('speed')}. Instead use, @code{eval(example('speed',1))}
 ## and @code{eval(example('speed',2))}.
 ## @end deftypefn
 
 ## TODO: consider two dimensional speedup surfaces for functions like kron.
 function [__order, __test_n, __tnew, __torig] ...
-	= speed (__f1, __init, __max_n, __f2, __tol)
-  if nargin < 1 || nargin > 6, 
+      = speed (__f1, __init, __max_n, __f2, __tol)
+
+  if (nargin < 1 || nargin > 6)
     print_usage ();
   endif
-  if nargin < 2 || isempty(__init), 
+
+  if (nargin < 2 || isempty (__init))
     __init = "x = randn(n, 1);";
   endif
-  if nargin < 3 || isempty(__max_n), __max_n = 100; endif
-  if nargin < 4, __f2 = []; endif
-  if nargin < 5 || isempty(__tol), __tol = eps; endif
+
+  if (nargin < 3 || isempty (__max_n))
+    __max_n = 100;
+  endif
+
+  if (nargin < 4)
+    __f2 = [];
+  endif
+
+  if (nargin < 5 || isempty (__tol))
+    __tol = eps;
+  endif
 
   __numtests = 15;
 
   ## Let user specify range of n
-  if isscalar(__max_n)
+  if (isscalar (__max_n))
     __min_n = 1;
-    assert(__max_n > __min_n);
-    __test_n = logspace(0,log10(__max_n),__numtests);
-  elseif length(__max_n) == 2
+    assert (__max_n > __min_n);
+    __test_n = logspace (0, log10 (__max_n), __numtests);
+  elseif (length (__max_n) == 2)
     __min_n = __max_n(1);
     __max_n = __max_n(2);
-    assert(__min_n >= 1);
-    __test_n = logspace(log10(__min_n),log10(__max_n),__numtests);
+    assert (__min_n >= 1);
+    __test_n = logspace (log10 (__min_n), log10 (__max_n), __numtests);
   else
     __test_n = __max_n;
   endif
-  __test_n = unique(round(__test_n)); # Force n to be an integer
-  assert(__test_n >= 1);
+  __test_n = unique (round (__test_n)); # Force n to be an integer
+  assert (__test_n >= 1);
 
-  __torig = __tnew = zeros (size(__test_n)) ;
+  __torig = __tnew = zeros (size (__test_n));
 
-  disp (["testing ", __f1, "\ninit: ", __init]);
+  disp (strcat ("testing ", __f1, "\ninit: ", __init));
 
   ## make sure the functions are freshly loaded by evaluating them at
   ## test_n(1); first have to initialize the args though.
-  n=1; k=0;
-  eval ([__init, ";"]);
-  if !isempty(__f2), eval ([__f2, ";"]); endif
-  eval ([__f1, ";"]);
+  n = 1;
+  k = 0;
+  eval (strcat (__init, ";"));
+  if (! isempty (__f2))
+    eval (strcat (__f2, ";"));
+  endif
+  eval (strcat (__f1, ";"));
 
   ## run the tests
-  for k=1:length(__test_n)
-    n=__test_n(k);
-    eval ([__init, ";"]);
+  for k = 1:length (__test_n)
+    n = __test_n(k);
+    eval (strcat (__init, ";"));
     
-    printf ("n%i=%i  ",k, n) ; fflush(1);
-    eval (["__t=time();", __f1, "; __v1=ans; __t = time()-__t;"]);
+    printf ("n%i=%i  ",k, n);
+    fflush (stdout);
+    eval (strcat ("__t=time();", __f1, "; __v1=ans; __t = time()-__t;"));
     if (__t < 0.25)
-      eval (["__t2=time();", __f1, "; __t2 = time()-__t2;"]);
-      eval (["__t3=time();", __f1, "; __t3 = time()-__t3;"]);
-      __t = min([__t,__t2,__t3]);
+      eval (strcat ("__t2=time();", __f1, "; __t2 = time()-__t2;"));
+      eval (strcat ("__t3=time();", __f1, "; __t3 = time()-__t3;"));
+      __t = min ([__t, __t2, __t3]);
     endif
     __tnew(k) = __t;
 
-    if !isempty(__f2)
-      eval (["__t=time();", __f2, "; __v2=ans; __t = time()-__t;"]);
+    if (! isempty (__f2))
+      eval (strcat ("__t=time();", __f2, "; __v2=ans; __t = time()-__t;"));
       if (__t < 0.25)
-      	eval (["__t2=time();", __f2, "; __t2 = time()-__t2;"]);
-      	eval (["__t3=time();", __f2, "; __t3 = time()-__t3;"]);
+      	eval (strcat ("__t2=time();", __f2, "; __t2 = time()-__t2;"));
+      	eval (strcat ("__t3=time();", __f2, "; __t3 = time()-__t3;"));
       endif
       __torig(k) = __t;
-      if !isinf(__tol)
-      	assert(__v1,__v2,__tol);
+      if (! isinf(__tol))
+      	assert (__v1, __v2, __tol);
       endif
     endif
-    
   endfor
   
   ## Drop times of zero
-  if !isempty(__f2)
-    zidx = ( __tnew < 100*eps |  __torig < 100*eps ) ;
+  if (! isempty (__f2))
+    zidx = (__tnew < 100*eps |  __torig < 100*eps);
     __test_n(zidx) = [];
     __tnew(zidx) = [];
     __torig(zidx) = [];
   else
-    zidx = ( __tnew < 100*eps ) ;
+    zidx = (__tnew < 100*eps);
     __test_n(zidx) = [];
     __tnew(zidx) = [];
   endif
-   
+
   ## Approximate time complexity and return it if requested
-  tailidx = [ceil(length(__test_n)/2):length(__test_n)];
-  p = polyfit(log(__test_n(tailidx)),log(__tnew(tailidx)), 1);
-  if nargout > 0, 
+  tailidx = ceil(length(__test_n)/2):length(__test_n);
+  p = polyfit (log (__test_n(tailidx)), log (__tnew(tailidx)), 1);
+  if (nargout > 0) 
     __order.p = p(1);
-    __order.a = exp(p(2));
+    __order.a = exp (p(2));
   endif
-  
 
   ## Plot the data if no output is requested.
   doplot = (nargout == 0);
   
   if (doplot)
     figure;
   endif
 
-  if doplot && !isempty(__f2)
-    subplot(121);
-    hold on;
-    xlabel("test length");
-    title (__f1);
-    ylabel("speedup ratio");
-    semilogx ( __test_n, __torig./__tnew, 
-	      ["-*r;", strrep(__f1,";","."), "/", strrep(__f2,";","."), ";"],
+  if (doplot && ! isempty (__f2))
+    subplot (1, 2, 1);
+    semilogx (__test_n, __torig./__tnew, 
+	      strcat ("-*r;", strrep (__f1, ";", "."), "/",
+		      strrep (__f2, ";", "."), ";"),
 	       __test_n, __tnew./__torig,
-	      ["-*g;", strrep(__f2,";","."), "/", strrep(__f1,";","."), ";"]);
-    subplot (122);
-    hold on;
-    xlabel("test length");
+	      strcat ("-*g;", strrep (__f2, ";", "."), "/",
+		      strrep (__f1, ";", "."), ";"));
+    xlabel ("test length");
+    title (__f1);
+    ylabel ("speedup ratio");
+
+    subplot (1, 2, 2);
+    loglog (__test_n, __tnew*1000,
+	    strcat ("*-g;", strrep (__f1, ";", "."), ";" ), 
+	    __test_n, __torig*1000,
+	    strcat ("*-r;", strrep (__f2,";","."), ";"));
+  
+    xlabel ("test length");
     ylabel ("best execution time (ms)");
-    title (["init: ", __init]);
-    loglog ( __test_n, __tnew*1000, ["*-g;", strrep(__f1,";","."), ";" ], 
-	     __test_n, __torig*1000, ["*-r;", strrep(__f2,";","."), ";"])
-  
+    title (strcat ("init: ", __init));
+
     ratio = mean (__torig ./ __tnew);
-    printf ("\n\nMean runtime ratio = %.3g for '%s' vs '%s'\n", ...
+    printf ("\n\nMean runtime ratio = %.3g for '%s' vs '%s'\n",
             ratio, __f2, __f1);
 
-  elseif doplot
+  elseif (doplot)
 
-    subplot(111);
-    hold on;
-    xlabel("test length");
+    loglog (__test_n, __tnew*1000, "*-g;execution time;");
+    xlabel ("test length");
     ylabel ("best execution time (ms)");
-    title ([__f1, "  init: ", __init]);
-    loglog ( __test_n, __tnew*1000, "*-g;execution time;");
+    title (strcat (__f1, "  init: ", __init));
 
   endif
 
-  if doplot
+  if (doplot)
 
     ## Plot time complexity approximation (using milliseconds).
-    order = sprintf("O(n^%g)",round(10*p(1))/10);
-    v = polyval(p,log(__test_n(tailidx)));
-    hold on; 
-    loglog(__test_n(tailidx), exp(v)*1000, sprintf("b;%s;",order)); 
-    hold off;
+    order = sprintf ("O(n^%g)", round (10*p(1))/10);
+    v = polyval (p, log (__test_n(tailidx)));
+
+    loglog (__test_n(tailidx), exp(v)*1000, sprintf ("b;%s;", order)); 
 
     ## Get base time to 1 digit of accuracy
-    dt = exp(p(2));
-    dt = floor(dt/10^floor(log10(dt)))*10^floor(log10(dt));
-    if log10(dt) >= -0.5, time = sprintf("%g s", dt);
-    elseif log10(dt) >= -3.5, time = sprintf("%g ms", dt*1e3);
-    elseif log10(dt) >= -6.5, time = sprintf("%g us", dt*1e6);
-    else time = sprintf("%g ns", dt*1e9);
+    dt = exp (p(2));
+    dt = floor (dt/10^floor(log10(dt)))*10^floor(log10(dt));
+    if (log10 (dt) >= -0.5)
+      time = sprintf ("%g s", dt);
+    elseif (log10 (dt) >= -3.5)
+      time = sprintf ("%g ms", dt*1e3);
+    elseif (log10 (dt) >= -6.5)
+      time = sprintf ("%g us", dt*1e6);
+    else
+      time = sprintf ("%g ns", dt*1e9);
     endif
 
     ## Display nicely formatted complexity.
-    printf ("\nFor %s:\n",__f1);
+    printf ("\nFor %s:\n", __f1);
     printf ("  asymptotic power: %s\n", order);
     printf ("  approximate time per operation: %s\n", time); 
 
   endif
 
 endfunction
 
 %!demo if 1
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -76,163 +76,175 @@
 
 function [__ret1, __ret2] = test (__name, __flag, __fid)
   ## information from test will be introduced by "key" 
   persistent __signal_fail =  "!!!!! ";
   persistent __signal_empty = "????? ";
   persistent __signal_block = "  ***** ";
   persistent __signal_file =  ">>>>> ";
 
-  if (nargin < 2 || isempty(__flag))
+  if (nargin < 2 || isempty (__flag))
     __flag = "quiet";
   endif
-  if (nargin < 3) 
+  if (nargin < 3)
     __fid = []; 
   endif
-  if (nargin < 1 || nargin > 3 ...
-      || (!ischar(__name) && !isempty(__name)) || !ischar(__flag))
+  if (nargin < 1 || nargin > 3
+      || (! ischar (__name) && ! isempty (__name)) || ! ischar (__flag))
     print_usage ();
   endif
-  if (isempty(__name) && (nargin != 3 || !strcmp(__flag, "explain")))
+  if (isempty (__name) && (nargin != 3 || ! strcmp (__flag, "explain")))
     print_usage ();
   endif
-  __batch = (!isempty(__fid));
+  __batch = (! isempty (__fid));
 
   ## decide if error messages should be collected
   __close_fid = 0;
   if (__batch)
-    if (ischar(__fid))
-      __fid = fopen(__fid, "wt");
-      if __fid < 0, error("could not open log file"); endif
+    if (ischar (__fid))
+      __fid = fopen (__fid, "wt");
+      if (__fid < 0)
+	error ("could not open log file");
+      endif
       __close_fid = 1;
     endif
     fprintf (__fid, "%sprocessing %s\n", __signal_file, __name);
     fflush (__fid);
   else
     __fid = stdout;
   endif
 
-  if (strcmp(__flag, "normal"))
+  if (strcmp (__flag, "normal"))
     __grabdemo = 0;
     __rundemo = 0;
     __verbose = __batch;
-  elseif (strcmp(__flag, "quiet"))
+  elseif (strcmp (__flag, "quiet"))
     __grabdemo = 0;
     __rundemo = 0;
     __verbose = 0;
-  elseif (strcmp(__flag, "verbose"))
+  elseif (strcmp (__flag, "verbose"))
     __grabdemo = 0;
     __rundemo = 1;
     __verbose = 1;
-  elseif (strcmp(__flag, "grabdemo"))
+  elseif (strcmp (__flag, "grabdemo"))
     __grabdemo = 1;
     __rundemo = 0;
     __verbose = 0;
     __demo_code = "";
     __demo_idx = 1;
-  elseif (strcmp(__flag, "explain"))
-    fprintf (__fid, "# %s new test file\n",__signal_file);
-    fprintf (__fid, "# %s no tests in file\n",__signal_empty);
-    fprintf (__fid, "# %s test had an unexpected result\n",__signal_fail);
-    fprintf (__fid, "# %s code for the test\n",__signal_block);
+  elseif (strcmp (__flag, "explain"))
+    fprintf (__fid, "# %s new test file\n", __signal_file);
+    fprintf (__fid, "# %s no tests in file\n", __signal_empty);
+    fprintf (__fid, "# %s test had an unexpected result\n", __signal_fail);
+    fprintf (__fid, "# %s code for the test\n", __signal_block);
     fprintf (__fid, "# Search for the unexpected results in the file\n");
     fprintf (__fid, "# then page back to find the file name which caused it.\n");
     fprintf (__fid, "# The result may be an unexpected failure (in which\n");
     fprintf (__fid, "# case an error will be reported) or an unexpected\n");
     fprintf (__fid, "# success (in which case no error will be reported).\n");
     fflush (__fid);
-    if (__close_fid) fclose(__fid); endif
+    if (__close_fid)
+      fclose(__fid);
+    endif
     return;
   else
-    error("test unknown flag '%s'", __flag);
+    error ("test unknown flag '%s'", __flag);
   endif
 
   ## locate the file to test
   __file = file_in_loadpath (__name, "all");
   if (isempty (__file))
-    __file = file_in_loadpath ([__name, ".m"], "all");
+    __file = file_in_loadpath (strcat (__name, ".m"), "all");
   endif
   if (isempty (__file))
-    __file = file_in_loadpath ([__name, ".cc"], "all");
+    __file = file_in_loadpath (strcat (__name, ".cc"), "all");
   endif
   if (iscell (__file))
       ## If repeats, return first in path.
     if (isempty (__file))
       __file = "";
     else
       __file = __file{1};
     endif
   endif
   if (isempty (__file))
     if (__grabdemo)
       __ret1 = "";
       __ret2 = [];
     else
-      fprintf(__fid, "%s%s does not exist in path\n", __signal_empty, __name);
+      fprintf (__fid, "%s%s does not exist in path\n", __signal_empty, __name);
       fflush (__fid);
-      if (nargout > 0) __ret1 = __ret2 = 0; endif
+      if (nargout > 0)
+	__ret1 = __ret2 = 0;
+      endif
     endif
-    if (__close_fid) fclose(__fid); endif
+    if (__close_fid)
+      fclose(__fid);
+    endif
     return;
   endif
 
   ## grab the test code from the file
   __body = __extract_test_code (__file);
 
   if (isempty (__body))
     if (__grabdemo)
       __ret1 = "";
       __ret2 = [];
     else
-      fprintf(__fid, "%s%s has no tests available\n", __signal_empty, __file);
+      fprintf (__fid, "%s%s has no tests available\n", __signal_empty, __file);
       fflush (__fid);
-      if (nargout > 0) __ret1 = __ret2 = 0; endif
+      if (nargout > 0)
+	__ret1 = __ret2 = 0;
+      endif
     endif
-    if (__close_fid) fclose(__fid); endif
+    if (__close_fid)
+      fclose(__fid);
+    endif
     return;
   else
     ## add a dummy comment block to the end for ease of indexing
     if (__body (length(__body)) == "\n")
-      __body = sprintf("\n%s#", __body); 
+      __body = sprintf ("\n%s#", __body); 
     else
-      __body = sprintf("\n%s\n#", __body); 
+      __body = sprintf ("\n%s\n#", __body); 
     endif
   endif
 
   ## chop it up into blocks for evaluation
-  __lineidx = find(__body == "\n");
-  __blockidx = __lineidx(find(!isspace(__body(__lineidx+1))))+1;
+  __lineidx = find (__body == "\n");
+  __blockidx = __lineidx(find (! isspace (__body(__lineidx+1))))+1;
 
   ## ready to start tests ... if in batch mode, tell us what is happening
   if (__verbose)
-    disp ([ __signal_file, __file ]);
+    disp (strcat ( __signal_file, __file));
   endif
 
   ## assume all tests will pass
   __all_success = 1;
 
   ## process each block separately, initially with no shared variables
   __tests = __successes = 0;
   __shared = " ";
   __shared_r = " ";
   __clear = "";
-  for __i=1:length(__blockidx)-1
+  for __i = 1:length(__blockidx)-1
 
     ## extract the block
     __block = __body(__blockidx(__i):__blockidx(__i+1)-2);
 
     ## let the user/logfile know what is happening
     if (__verbose)
       fprintf (__fid, "%s%s\n", __signal_block, __block);
       fflush (__fid);
     endif
 
     ## split __block into __type and __code
-    __idx = find(!isletter(__block));
-    if (isempty(__idx))
+    __idx = find (! isletter (__block));
+    if (isempty (__idx))
       __type = __block;
       __code = "";
     else
       __type = __block(1:__idx(1)-1);
       __code = __block(__idx(1):length(__block));
     endif
 
     ## assume the block will succeed;
@@ -246,313 +258,325 @@ function [__ret1, __ret2] = test (__name
     ## types and skips those which aren't demo blocks.
     __isdemo = strcmp (__type, "demo");
     if (__grabdemo || __isdemo)
       __istest = 0;
 
       if (__grabdemo && __isdemo)
 	if (isempty(__demo_code))
 	  __demo_code = __code;
-	  __demo_idx = [ 1, length(__demo_code)+1 ];
+	  __demo_idx = [1, length(__demo_code)+1];
 	else
 	  __demo_code = strcat(__demo_code, __code);
-	  __demo_idx = [ __demo_idx, length(__demo_code)+1 ];
+	  __demo_idx = [__demo_idx, length(__demo_code)+1];
 	endif
 
       elseif (__rundemo && __isdemo)
       	try
 	  ## process the code in an environment without variables
-      	  eval(sprintf("function __test__()\n%s\nendfunction",__code));
+      	  eval (sprintf ("function __test__()\n%s\nendfunction", __code));
 	  __test__;
-	  input("Press <enter> to continue: ","s");
+	  input ("Press <enter> to continue: ", "s");
       	catch
 	  __success = 0;
-	  __msg = sprintf("%sdemo failed\n%s",  __signal_fail, __error_text__);
+	  __msg = sprintf ("%sdemo failed\n%s",  __signal_fail, __error_text__);
       	end_try_catch
       	clear __test__;
 
       endif
       __code = ""; # code already processed
       
     ## SHARED
     elseif strcmp (__type, "shared")
       __istest = 0;
 
       ## separate initialization code from variables
-      __idx = find(__code == "\n");
-      if (isempty(__idx))
+      __idx = find (__code == "\n");
+      if (isempty (__idx))
 	__vars = __code;
 	__code = "";
       else
       	__vars = __code (1:__idx(1)-1);
       	__code = __code (__idx(1):length(__code));
       endif
       
       ## strip comments off the variables
-      __idx = find(__vars=="%" | __vars == "#");
-      if (!isempty(__idx))
+      __idx = find (__vars=="%" | __vars == "#");
+      if (! isempty (__idx))
 	__vars = __vars(1:__idx(1)-1);
       endif
       
       ## assign default values to variables
       try
-	__vars = deblank(__vars);
-	if (!isempty(__vars))
-	  eval([strrep(__vars,",","=[];"), "=[];"]);
+	__vars = deblank (__vars);
+	if (! isempty (__vars))
+	  eval (strcat (strrep (__vars, ",", "=[];"), "=[];"));
 	  __shared = __vars;
-	  __shared_r = ["[ ", __vars, "] = "];
+	  __shared_r = strcat ("[ ", __vars, "] = ");
       	else
 	  __shared = " ";
 	  __shared_r = " ";
       	endif
       catch
 	__code = "";  # couldn't declare, so don't initialize
 	__success = 0;
-	__msg = sprintf("%sshared variable initialization failed\n", ...
-		        __signal_fail);
+	__msg = sprintf ("%sshared variable initialization failed\n",
+		         __signal_fail);
       end_try_catch
 
       ## clear shared function definitions
-      eval(__clear,""); __clear="";
+      eval (__clear, "");
+      __clear = "";
       
       ## initialization code will be evaluated below
     
     ## FUNCTION
-    elseif strcmp (__type, "function")
+    elseif (strcmp (__type, "function"))
       __istest = 0;
       persistent __fn = 0;
-      __name_position = function_name(__block);
-      if isempty(__name_position)
+      __name_position = function_name (__block);
+      if (isempty (__name_position))
         __success = 0;
-        __msg = sprintf("%stest failed: missing function name\n", ...
-			__signal_fail);
+        __msg = sprintf ("%stest failed: missing function name\n",
+			 __signal_fail);
       else
         __name = __block(__name_position(1):__name_position(2));
         __code = __block;
         try
           eval(__code); ## Define the function
-          __clear = sprintf("%sclear %s;\n",__clear,__name);
+          __clear = sprintf ("%sclear %s;\n", __clear, __name);
         catch
           __success = 0;
-          __msg = sprintf("%stest failed: syntax error\n%s", ...
-			  __signal_fail, __error_text__);
+          __msg = sprintf ("%stest failed: syntax error\n%s",
+			   __signal_fail, __error_text__);
         end_try_catch
       endif
       __code = "";
       
 
     ## ASSERT/FAIL
-    elseif strcmp (__type, "assert") || strcmp (__type, "fail")
+    elseif (strcmp (__type, "assert") || strcmp (__type, "fail"))
       __istest = 1;
       __code = __block; # put the keyword back on the code
       ## the code will be evaluated below as a test block
       
     ## ERROR/WARNING
-    elseif strcmp (__type, "error") || strcmp(__type, "warning")
+    elseif (strcmp (__type, "error") || strcmp(__type, "warning"))
       __istest = 1;
-      __warning = strcmp(__type, "warning");
-      [__pattern, __code] = getpattern(__code);
+      __warning = strcmp (__type, "warning");
+      [__pattern, __code] = getpattern (__code);
       try
-      	eval(sprintf("function __test__(%s)\n%s\nendfunction", ...
-		     __shared, __code));
+      	eval (sprintf ("function __test__(%s)\n%s\nendfunction",
+		       __shared, __code));
       catch
       	__success = 0;
-      	__msg = sprintf("%stest failed: syntax error\n%s", ...
-			__signal_fail, __error_text__);
+      	__msg = sprintf ("%stest failed: syntax error\n%s",
+			 __signal_fail, __error_text__);
       end_try_catch
       
       if (__success)
         __success = 0;
-	__warnstate = warning("query","quiet");
-	warning("on","quiet");
+	__warnstate = warning ("query", "quiet");
+	warning ("on", "quiet");
       	try
- 	  eval(sprintf("__test__(%s);", __shared));
-	  __err = trimerr(lastwarn,"warning");
-          warning(__warnstate.state,"quiet");
+ 	  eval (sprintf ("__test__(%s);", __shared));
+	  __err = trimerr (lastwarn, "warning");
+          warning (__warnstate.state, "quiet");
 
-          if !__warning,
-       	    __msg = sprintf("%sexpected <%s> but got no error\n", ...
- 			    __signal_fail, __pattern);
-          elseif isempty(__err)
-            __msg = sprintf("%sexpected <%s> but got no warning\n", ...
-			    __signal_fail,__pattern);
-          elseif isempty(regexp(__err,__pattern,"once"))
-            __msg = sprintf("%sexpected <%s> but got %s\n", ...
+          if (! __warning)
+       	    __msg = sprintf ("%sexpected <%s> but got no error\n",
+ 			     __signal_fail, __pattern);
+          elseif (isempty (__err))
+            __msg = sprintf ("%sexpected <%s> but got no warning\n",
+			     __signal_fail, __pattern);
+          elseif (isempty (regexp (__err, __pattern, "once")))
+            __msg = sprintf ("%sexpected <%s> but got %s\n",
  			     __signal_fail, __pattern, __err);
           else
             __success = 1;
           endif
 
       	catch
-	  __err = trimerr(lasterr,"error");
-          warning(__warnstate.state,"quiet");
-          if __warning,
-            __msg = sprintf("%sexpected warning <%s> but got error %s\n", ...
-			    __signal_fail, __pattern, __err);
-	  elseif isempty(regexp(__err,__pattern,"once"))
-            __msg = sprintf("%sexpected <%s> but got %s\n", ...
-			    __signal_fail, __pattern, __err);
+	  __err = trimerr (lasterr, "error");
+          warning (__warnstate.state, "quiet");
+          if (__warning)
+            __msg = sprintf ("%sexpected warning <%s> but got error %s\n",
+			     __signal_fail, __pattern, __err);
+	  elseif (isempty (regexp (__err, __pattern, "once")))
+            __msg = sprintf ("%sexpected <%s> but got %s\n",
+			     __signal_fail, __pattern, __err);
           else
 	    __success = 1;
           endif
       	end_try_catch
       	clear __test__;
       endif
       __code = ""; # code already processed
       
     ## TEST
-    elseif strcmp(__type, "test")
+    elseif (strcmp (__type, "test"))
       __istest = 1;
       ## code will be evaluated below
       
     ## comment block
-    elseif strcmp (__block(1:1), "#")
+    elseif (strcmp (__block(1:1), "#"))
       __istest = 0;
       __code = ""; # skip the code
 
     else
     ## unknown block
       __istest = 1;
       __success = 0;
-      __msg = sprintf("%sunknown test type!\n", __signal_fail);
+      __msg = sprintf ("%sunknown test type!\n", __signal_fail);
       __code = ""; # skip the code
     endif
 
     ## evaluate code for test, shared, and assert.
-    if (!isempty(__code))
+    if (! isempty(__code))
       try
-      	eval(sprintf("function %s__test__(%s)\n%s\nendfunction", ...
-	      __shared_r,__shared, __code));
-	eval(sprintf("%s__test__(%s);", __shared_r, __shared));
+      	eval (sprintf ("function %s__test__(%s)\n%s\nendfunction",
+		       __shared_r,__shared, __code));
+	eval (sprintf ("%s__test__(%s);", __shared_r, __shared));
       catch
 	__success = 0;
-	__msg = sprintf("%stest failed\n%s", __signal_fail, __error_text__);
-	if isempty(__error_text__), 
-	  error("empty error text, probably Ctrl-C --- aborting"); 
+	__msg = sprintf ("%stest failed\n%s", __signal_fail, __error_text__);
+	if (isempty (__error_text__))
+	  error ("empty error text, probably Ctrl-C --- aborting"); 
 	endif
       end_try_catch
       clear __test__;
     endif
     
     ## All done.  Remember if we were successful and print any messages
-    if (!isempty(__msg))
+    if (! isempty (__msg))
       ## make sure the user knows what caused the error
-      if (!__verbose)
+      if (! __verbose)
       	fprintf (__fid, "%s%s\n", __signal_block, __block);
 	fflush (__fid);
       endif
       fputs (__fid, __msg);
       fflush (__fid);
       ## show the variable context
-      if (!strcmp(__type, "error") && !all(__shared==" "))
-	fputs(__fid, "shared variables ");
-	eval (sprintf("fdisp(__fid,bundle(%s));", __shared)); 
+      if (! strcmp (__type, "error") && ! all (__shared == " "))
+	fputs (__fid, "shared variables ");
+	eval (sprintf ("fdisp(__fid,bundle(%s));", __shared)); 
 	fflush (__fid);
       endif
     endif
     if (__success == 0)
       __all_success = 0;
       	## stop after one error if not in batch mode
-      if (!__batch)
-    	if (nargout > 0) __ret1 = __ret2 = 0; endif
-	if (__close_fid) fclose(__fid); endif
+      if (! __batch)
+    	if (nargout > 0)
+	  __ret1 = __ret2 = 0;
+	endif
+	if (__close_fid)
+	  fclose(__fid);
+	endif
       	return;
       endif
     endif
     __tests += __istest;
-    __successes += __success*__istest;
+    __successes += __success * __istest;
   endfor
-  eval(__clear,"");
+  eval (__clear, "");
 
   if (nargout == 0)
-    printf("PASSES %d out of %d tests\n",__successes,__tests);
+    printf ("PASSES %d out of %d tests\n", __successes, __tests);
   elseif (__grabdemo)
     __ret1 = __demo_code;
     __ret2 = __demo_idx;
-  elseif nargout == 1
+  elseif (nargout == 1)
     __ret1 = __all_success; 
   else
     __ret1 = __successes;
     __ret2 = __tests;
   endif
 endfunction
 
 ## create structure with fieldnames the name of the input variables
-function s = varstruct(varargin)
-  for i=1:nargin
-    s.(deblank(argn(i,:))) = varargin{i};
+function s = varstruct (varargin)
+  for i = 1:nargin
+    s.(deblank (argn(i,:))) = varargin{i};
   endfor
 endfunction
 
 ## find [start,end] of fn in 'function [a,b] = fn'
-function pos = function_name(def)
+function pos = function_name (def)
   pos = [];
 
   ## Find the end of the name
-  right = find(def=='(', 1);
-  if isempty(right), return; endif
-  right = find(def(1:right-1) != ' ', 1, "last");
+  right = find (def == "(", 1);
+  if (isempty (right))
+    return;
+  endif
+  right = find (def(1:right-1) != " ", 1, "last");
 
   ## Find the beginning of the name
-  left = max([find(def(1:right)==' ', 1, "last"),find(def(1:right)=='=', 1, "last")]);
-  if isempty(left), return; endif
+  left = max ([find(def(1:right)==" ", 1, "last"), ...
+	       find(def(1:right)=="=", 1, "last")]);
+  if (isempty (left))
+    return;
+  endif
   left++;
 
   ## Return the end points of the name
-  pos = [left,right];
+  pos = [left, right];
 endfunction
 
 ## strip <pattern> from '<pattern> code'
-function [pattern,rest] = getpattern(str)
-  pattern = '.';
+function [pattern, rest] = getpattern (str)
+  pattern = ".";
   rest = str; 
-  str = trimleft(str);
-  if !isempty(str) && str(1) == '<'
-    close = index(str,'>');
-    if close,
+  str = trimleft (str);
+  if (! isempty (str) && str(1) == "<")
+    close = index (str, ">");
+    if (close)
       pattern = str(2:close-1);
       rest = str(close+1:end);
     endif
   endif
 endfunction
 
 ## strip '.*prefix:' from '.*prefix: msg\n' and strip trailing blanks
-function msg = trimerr(msg,prefix)
-  idx = index(msg,[prefix,':']);
-  if (idx > 0), msg(1:idx+length(prefix)) = []; end
-  msg = trimleft(deblank(msg));
+function msg = trimerr (msg, prefix)
+  idx = index (msg, strcat (prefix, ":"));
+  if (idx > 0)
+    msg(1:idx+length(prefix)) = [];
+  endif
+  msg = trimleft (deblank (msg));
 endfunction
 
 ## strip leading blanks from string
-function str = trimleft(str)
-  idx = find(isspace(str));
-  leading = find(idx == [1:length(idx)]);
-  if !isempty(leading)
+function str = trimleft (str)
+  idx = find (isspace (str));
+  leading = find (idx == 1:length(idx));
+  if (! isempty (leading))
     str = str(leading(end)+1:end);
   endif
 endfunction
 
 ## make a structure out of the named variables
 ## (based on Etienne Grossmann's tar function)
-function s = bundle(varargin)
-  for i=1:nargin
-    s.(deblank(argn(i,:))) = varargin{i};
+function s = bundle (varargin)
+  for i = 1:nargin
+    s.(deblank (argn(i,:))) = varargin{i};
   end
 endfunction
 
 function body = __extract_test_code (nm)
   fid = fopen (nm, "rt");
   body = [];
   if (fid >= 0)
-    while (! feof(fid))
+    while (! feof (fid))
       ln = fgetl (fid);
-      if (length(ln) >= 2 && strcmp (ln(1:2), "%!"))
+      if (length (ln) >= 2 && strcmp (ln(1:2), "%!"))
         body = [body, "\n"];
         if (length(ln) > 2)
-          body = [body, ln(3:end)];
+          body = strcat (body, ln(3:end));
         endif
       endif
     endwhile
     fclose (fid);
   endif
 endfunction
 
 ### example from toeplitz
