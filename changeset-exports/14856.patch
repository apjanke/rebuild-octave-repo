# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1341878446 25200
#      Mon Jul 09 17:00:46 2012 -0700
# Node ID c3fd61c59e9c6e816fa8ecfbe13c5c58602087cb
# Parent  1b48b209a8d64ce92261a7c7898a7cd9013a82e8
maint: Use Octave coding conventions for cuddling parentheses in doc directory

* OctaveFAQ.texi, basics.txi, container.txi, contrib.txi, diagperm.txi,
diffeq.txi, dynamic.txi, errors.txi, eval.txi, expr.txi, func.txi,
geometry.txi, interp.txi, intro.txi, numbers.txi, oop.txi, plot.txi, poly.txi,
quad.txi, set.txi, sparse.txi, stmt.txi, testfun.txi, vectorize.txi,
refcard.tex: Use Octave coding conventions for cuddling parentheses.

diff --git a/doc/faq/OctaveFAQ.texi b/doc/faq/OctaveFAQ.texi
--- a/doc/faq/OctaveFAQ.texi
+++ b/doc/faq/OctaveFAQ.texi
@@ -449,17 +449,17 @@ function defined in a @file{.m} file is 
 @node Coherent syntax
 @section Coherent syntax
 
 Indexing other things than variables is possible, as in:
 @example
 @group
 octave:1> [3 1 4 1 5 9](3)
 ans = 4
-octave:2> cos([0 pi pi/4 7])(3)
+octave:2> cos ([0 pi pi/4 7])(3)
 ans = 0.70711
 @end group
 @end example
 
 @node Exclamation mark as not operator
 @section Exclamation mark as not operator
 
 The exclamation mark @samp{!} (aka ``Bang!'') is a negation operator, just
@@ -866,30 +866,30 @@ The major differences between Octave 3.4
 @itemize @bullet
 @item Nested Functions
 
 Octave has limited support for nested functions. That is
 
 @example
 @group
 function y = foo (x)
-  y = bar(x)
+  y = bar (x)
   function y = bar (x)
     y = @dots{};
   end
 end
 @end group
 @end example
 
 is equivalent to
 
 @example
 @group
 function y = foo (x)
-   y = bar(x)
+   y = bar (x)
 end
 function y = bar (x)
    y = @dots{};
 end
 @end group
 @end example
 
 The main difference with @sc{Matlab} is a matter of scope. While nested
@@ -1060,17 +1060,17 @@ are different in @sc{Matlab}. This is re
 there is too much code out there that relies on this behaviour to change
 it. Prefer the || and && operators in if statements if possible. If you
 need to use code written for @sc{Matlab} that depends on this buggy
 behaviour, you can enable it since Octave 3.4.0 with the following
 command:
 
 @example
 @group
-  do_braindead_shortcircuit_evaluation(1)
+  do_braindead_shortcircuit_evaluation (1)
 @end group
 @end example
 
 Note that the difference with @sc{Matlab} is also significant when
 either argument is a function with side effects or if the first argument
 is a scalar and the second argument is an empty matrix. For example,
 note the difference between
 
@@ -1097,17 +1097,17 @@ Another case that is documented in the @
 @end example
 
 Also @sc{Matlab} requires the operands of && and || to be scalar values
 but Octave does not (it just applies the rule that for an operand to be
 considered true, every element of the object must be nonzero or
 logically true).
 
 Finally, note the inconsistence of thinking of the condition of an if
-statement as being equivalent to @code{all(X(:))} when @var{X} is a
+statement as being equivalent to @code{all (X(:))} when @var{X} is a
 matrix.  This is true for all cases EXCEPT empty matrices:
 
 @example
 @group
   if ([0, 1]) == if (all ([0, 1]))   ==>  i.e., condition is false.
   if ([1, 1]) == if (all ([1, 1]))   ==>  i.e., condition is true.
 @end group
 @end example
@@ -1142,57 +1142,57 @@ result for these cases.
 
 In the case of under- or over-determined matrices, Octave continues to
 use a minimum norm solution, whereas @sc{Matlab} uses an approach that
 is equivalent to
 
 @example
 @group
 function x = mldivide (A, b)
-  [Q, R, E] = qr(A);
+  [Q, R, E] = qr (A);
   x = [A \ b, E(:, 1:m) * (R(:, 1:m) \ (Q' * b))]
 end
 @end group
 @end example
 
 @noindent
 While this approach is certainly faster and uses less memory than
 Octave's minimum norm approach, this approach seems to be inferior in
 other ways.
 
 A numerical question arises: how big can the null space component
 become, relative to the minimum-norm solution? Can it be nicely bounded,
 or can it be arbitrarily big? Consider this example:
-
+OctaveFAQ.texi
 @example
 @group
 m = 10;
 n = 10000;
-A = ones(m, n) + 1e-6 * randn(m,n);
-b = ones(m, 1) + 1e-6 * randn(m,1);
-norm(A \ b)
+A = ones (m, n) + 1e-6 * randn (m,n);
+b = ones (m, 1) + 1e-6 * randn (m,1);
+norm (A \ b)
 @end group
 @end example
 
 @noindent
 while Octave's minimum-norm values are around 3e-2, @sc{Matlab}'s
 results are 50-times larger. For another issue, try this code:
 
 @example
 @group
 m = 5;
 n = 100;
-j = floor(m * rand(1, n)) + 1;
-b = ones(m, 1);
-A = zeros(m, n);
-A(sub2ind(size(A),j,1:n)) = 1;
+j = floor (m * rand (1, n)) + 1;
+b = ones (m, 1);
+A = zeros (m, n);
+A(sub2ind (size (A),j,1:n)) = 1;
 x = A \ b;
-[dummy,p] = sort(rand(1,n));
-y = A(:,p)\b;
-norm(x(p)-y)
+[dummy,p] = sort (rand (1,n));
+y = A(:,p) \ b;
+norm (x(p)-y)
 @end group
 @end example
 
 @noindent
 It shows that unlike in Octave, mldivide in @sc{Matlab} is not invariant
 with respect to column permutations. If there are multiple columns of
 the same norm, permuting columns of the matrix gets you different
 result than permuting the solution vector. This will surprise many
@@ -1277,20 +1277,20 @@ compared to
 @end example
 
 Typing Ctrl-C in the first case returns the user directly to the
 prompt, and the variable "a" is not reset to the saved value. In the
 second case the variable "a" is reset correctly.  Therefore @sc{Matlab}
 gives no safe way of temporarily changing global variables.
 
 @item
-Indexing can be applied to all objects in Octave and not just
+Indexing can be applied to all objects in Octave and not just a
 variable. Therefore @code{sin(x)(1:10);} for example is perfectly valid
 in Octave but not @sc{Matlab}. To do the same in @sc{Matlab} you must do
-@code{y = sin(x); y = y([1:10]);}
+@code{y = sin (x); y = y([1:10]);}
 
 @item
 Octave has the operators "++", "--", "-=", "+=", "*=", etc.  As
 @sc{Matlab} doesn't, if you are sharing code these should be avoided.
 
 @item
 Character strings in Octave can be denoted with double or single
 quotes. There is a subtle difference between the two in that escaped
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -1018,20 +1018,20 @@ character, @samp{#}, or the percent symb
 end of the line.  Any text following the sharp sign or percent symbol is
 ignored by the Octave interpreter and not executed.  The following example
 shows whole line and partial line comments.
 
 @example
 @group
 function countdown
   # Count down for main rocket engines 
-  disp(3);
-  disp(2);
-  disp(1);
-  disp("Blast Off!");  # Rocket leaves pad
+  disp (3);
+  disp (2);
+  disp (1);
+  disp ("Blast Off!");  # Rocket leaves pad
 endfunction
 @end group
 @end example
 
 @node Block Comments
 @subsection Block Comments
 @cindex block comments
 @cindex multi-line comments
@@ -1041,29 +1041,29 @@ endfunction
 Entire blocks of code can be commented by enclosing the code between 
 matching @samp{#@{} and @samp{#@}} or @samp{%@{} and @samp{%@}} markers.  
 For example,
 
 @example
 @group
 function quick_countdown
   # Count down for main rocket engines 
-  disp(3);
+  disp (3);
  #@{
-  disp(2);
-  disp(1);
+  disp (2);
+  disp (1);
  #@}
-  disp("Blast Off!");  # Rocket leaves pad
+  disp ("Blast Off!");  # Rocket leaves pad
 endfunction
 @end group
 @end example
 
 @noindent
 will produce a very quick countdown from '3' to 'Blast Off' as the
-lines "@code{disp(2);}" and "@code{disp(1);}" won't be executed.
+lines "@code{disp (2);}" and "@code{disp (1);}" won't be executed.
 
 The block comment markers must appear alone as the only characters on a line
 (excepting whitespace) in order to be parsed correctly.
 
 @node Comments and the Help System
 @subsection Comments and the Help System
 @cindex documenting functions
 @cindex documenting user scripts
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -303,46 +303,46 @@ x.a
 @end group
 @end example
 
 Here is another example, using this comma separated list on the
 left-hand side of an assignment:
 
 @example
 @group
-[x.a] = deal("new string1", "new string2");
+[x.a] = deal ("new string1", "new string2");
  x(1).a
      @result{} ans = new string1
  x(2).a
      @result{} ans = new string2
 @end group
 @end example
 
 Just as for numerical arrays, it is possible to use vectors as indices
 (@pxref{Index Expressions}):
 
 @example
 @group
 x(3:4) = x(1:2);
-[x([1,3]).a] = deal("other string1", "other string2");
+[x([1,3]).a] = deal ("other string1", "other string2");
 x.a
      @result{}
         ans = other string1
         ans = new string2
         ans = other string2
         ans = new string2
 @end group
 @end example
 
 The function @code{size} will return the size of the structure.  For
 the example above
 
 @example
 @group
-size(x)
+size (x)
      @result{} ans =
 
           1   4
 @end group
 @end example
 
 Elements can be deleted from a structure array in a similar manner to a
 numerical array, by assigning the elements to an empty matrix.  For
@@ -600,20 +600,20 @@ function.
 
 @DOCSTRING(celldisp)
 
 To test if an object is a cell array, use the @code{iscell}
 function.  For example:
 
 @example
 @group
-iscell(c)
+iscell (c)
      @result{} ans = 1
 
-iscell(3)
+iscell (3)
      @result{} ans = 0
 
 @end group
 @end example
 
 @DOCSTRING(iscell)
 
 @node Creating Cell Arrays
@@ -626,17 +626,17 @@ then fill it with data.
 
 The @code{cell} function returns a cell array of a given size, containing
 empty matrices.  This function is similar to the @code{zeros}
 function for creating new numerical arrays.  The following example creates
 a 2-by-2 cell array containing empty matrices
 
 @example
 @group
-c = cell(2,2)
+c = cell (2,2)
      @result{} c =
          
          @{
            [1,1] = [](0x0)
            [2,1] = [](0x0)
            [1,2] = [](0x0)
            [2,2] = [](0x0)
          @}
@@ -647,19 +647,19 @@ Just like numerical arrays, cell arrays 
 @code{cell} function accepts any number of positive integers to describe
 the size of the returned cell array.  It is also possible to set the size
 of the cell array through a vector of positive integers.  In the
 following example two cell arrays of equal size are created, and the size
 of the first one is displayed
 
 @example
 @group
-c1 = cell(3, 4, 5);
-c2 = cell( [3, 4, 5] );
-size(c1)
+c1 = cell (3, 4, 5);
+c2 = cell ( [3, 4, 5] );
+size (c1)
      @result{} ans =
          3   4   5
 @end group
 @end example
 
 @noindent
 As can be seen, the @ref{doc-size, @code{size}} function also works
 for cell arrays.  As do other functions describing the size of an
@@ -761,17 +761,17 @@ c([1, 2], :) = c([2, 1], :)
 Accessing multiple elements of a cell array with the @samp{@{} and
 @samp{@}} operators will result in a comma-separated list of all the
 requested elements (@pxref{Comma Separated Lists}).  Using the
 @samp{@{} and @samp{@}} operators the first two rows in the above
 example can be swapped back like this:
 
 @example
 @group
-[c@{[1,2], :@}] = deal(c@{[2, 1], :@})
+[c@{[1,2], :@}] = deal (c@{[2, 1], :@})
      @result{} = 
         @{
           [1,1] =  1
           [2,1] =  4
           [1,2] =  2
           [2,2] =  5
           [1,3] =  3
           [2,3] =  6
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -326,17 +326,17 @@ Always use a specific end-of-block state
 @code{endswitch}) rather than generic @code{end}.
 
 Enclose the @code{if}, @code{while}, @code{until} and @code{switch}
 conditions in parentheses, like in C:
 
 @example
 @group
 if (isvector (a))
-  s = sum(a);
+  s = sum (a);
 endif
 @end group
 @end example
 
 @noindent
 Do not do this, however, with the iteration counter portion of a
 @code{for} statement.  Write:
 
diff --git a/doc/interpreter/diagperm.txi b/doc/interpreter/diagperm.txi
--- a/doc/interpreter/diagperm.txi
+++ b/doc/interpreter/diagperm.txi
@@ -88,17 +88,17 @@ Example:
 @result{}
 Diagonal Matrix
 
    1   0   0   0
    0   2   0   0
    0   0   3   0
    0   0   0   4
 
-  diag(1:3,5,3)
+  diag (1:3,5,3)
 
 @result{}
 Diagonal Matrix
 
    1   0   0
    0   2   0
    0   0   3
    0   0   0
@@ -549,23 +549,23 @@ Inf * full (eye (3))
    Inf   NaN   NaN
    NaN   Inf   NaN
    NaN   NaN   Inf
 
 @end example
 
 @example
 @group
-diag(1:3) * [NaN; 1; 1]
+diag (1:3) * [NaN; 1; 1]
 @result{}
    NaN
      2
      3
 
-sparse(1:3,1:3,1:3) * [NaN; 1; 1]
+sparse (1:3,1:3,1:3) * [NaN; 1; 1]
 @result{}
    NaN
      2
      3
 [1,0,0;0,2,0;0,0,3] * [NaN; 1; 1]
 @result{}
    NaN
    NaN
diff --git a/doc/interpreter/diffeq.txi b/doc/interpreter/diffeq.txi
--- a/doc/interpreter/diffeq.txi
+++ b/doc/interpreter/diffeq.txi
@@ -95,18 +95,18 @@ y = lsode ("f", x0, t);
 @end example
 
 If you try this, you will see that the value of the result changes
 dramatically between @var{t} = 0 and 5, and again around @var{t} = 305.
 A more efficient set of output points might be
 
 @example
 @group
-t = [0, logspace (-1, log10(303), 150), \
-        logspace (log10(304), log10(500), 150)];
+t = [0, logspace(-1, log10(303), 150), \
+        logspace(log10(304), log10(500), 150)];
 @end group
 @end example
 
 See Alan C. Hindmarsh, @cite{ODEPACK, A Systematized Collection of ODE
 Solvers}, in Scientific Computing, R. S. Stepleman, editor, (1983) for
 more information about the inner workings of @code{lsode}.
 
 @node Differential-Algebraic Equations
diff --git a/doc/interpreter/dynamic.txi b/doc/interpreter/dynamic.txi
--- a/doc/interpreter/dynamic.txi
+++ b/doc/interpreter/dynamic.txi
@@ -546,17 +546,17 @@ int nel = sm.nelem ();
 @end example
 
 @noindent
 returns the number of non-zero elements.  If the user really requires the
 number of elements in the matrix, including the non-zero elements, they
 should use @code{numel} rather than @code{nelem}.  Note that for very
 large matrices, where the product of the two dimensions is larger than
 the representation of an unsigned int, then @code{numel} can overflow.
-An example is @code{speye(1e6)} which will create a matrix with a million
+An example is @code{speye (1e6)} which will create a matrix with a million
 rows and columns, but only a million non-zero elements.  Therefore the
 number of rows by the number of columns in this case is more than two
 hundred times the maximum value that can be represented by an unsigned int.
 The use of @code{numel} should therefore be avoided useless it is known
 it won't overflow.
 
 Extreme care must be take with the elem method and the "()" operator,
 which perform basically the same function.  The reason is that if a
@@ -896,19 +896,19 @@ passing a function to an oct-file.
 
 The first argument to this demonstration is the user supplied function
 and the following arguments are all passed to the user function.
 
 @example
 @group
 funcdemo (@@sin,1)
 @result{} 0.84147
-funcdemo (@@(x) sin(x), 1)
+funcdemo (@@(x) sin (x), 1)
 @result{} 0.84147
-funcdemo (inline ("sin(x)"), 1)
+funcdemo (inline ("sin (x)"), 1)
 @result{} 0.84147
 funcdemo ("sin",1)
 @result{} 0.84147
 funcdemo (@@atan2, 1, 1)
 @result{} 0.78540
 @end group
 @end example
 
@@ -1003,17 +1003,17 @@ external Fortran function, including pas
 as exception handling.  An example of the behavior of this function is
 
 @example
 @group
 [b, s] = fortdemo (1:3)
 @result{}
   b = 1.00000   0.50000   0.33333
   s = There are   3 values in the input vector
-[b, s] = fortdemo(0:3)
+[b, s] = fortdemo (0:3)
 error: fortsub:divide by zero
 error: exception encountered in Fortran subroutine fortsub_
 error: fortdemo: error in Fortran
 @end group
 @end example
 
 @node Allocating Local Memory in Oct-Files
 @subsection Allocating Local Memory in Oct-Files
@@ -1081,17 +1081,17 @@ methods are automatically released when 
 writing an oct-file, to allow Octave to treat the user typing @kbd{Control-C},
 the @w{@code{OCTAVE_QUIT}} macro is supplied.  For example:
 
 @example
 @group
 for (octave_idx_type i = 0; i < a.nelem (); i++)
   @{
     OCTAVE_QUIT;
-    b.elem(i) = 2. * a.elem(i);
+    b.elem (i) = 2. * a.elem (i);
   @}
 @end group
 @end example
 
 The presence of the @w{@code{OCTAVE_QUIT}} macro in the inner loop allows
 Octave to treat the user request with the @kbd{Control-C}.  Without this macro,
 the user must either wait for the function to return before the interrupt is
 processed, or press @kbd{Control-C} three times to force Octave to exit.
@@ -1190,19 +1190,19 @@ the compiler.  Finally, the Octave test 
 access to the source code of the oct-file and not just the compiled code
 as the tests are stripped from the compiled code.  An example in an
 oct-file might be
 
 @example
 @group
 /*
 
-%!error (sin())
-%!error (sin(1,1))
-%!assert (sin([1,2]),[sin(1),sin(2)])
+%!error (sin ())
+%!error (sin (1,1))
+%!assert (sin ([1,2]),[sin(1),sin(2)])
 
 */
 @end group
 @end example
 
 @c @node Application Programming Interface for Oct-Files
 @c @subsection Application Programming Interface for Oct-Files
 @c 
@@ -1366,17 +1366,17 @@ exists the generic function @code{mxGetD
 that perform the same operation on all matrix types.  For example:
 
 @example
 @group
 mxArray *m;
 mwSize *dims;
 UINT32_T *pr;
 
-dims = (mwSize *) mxMalloc (2 * sizeof(mwSize));
+dims = (mwSize *) mxMalloc (2 * sizeof (mwSize));
 dims[0] = 2;
 dims[1] = 2;
 m = mxCreateNumericArray (2, dims, mxUINT32_CLASS, mxREAL);
 pr =  = (UINT32_T *) mxGetData (m);
 @end group
 @end example
 
 There are also the functions @code{mxSetPr}, etc., that perform the
@@ -1398,18 +1398,18 @@ below.
 @EXAMPLEFILE(mypow2.c)
 @end example
 
 @noindent
 with an example of its use
 
 @example
 @group
-b = randn(4,1) + 1i * randn(4,1);
-all(b.^2 == mypow2(b))
+b = randn (4,1) + 1i * randn (4,1);
+all (b.^2 == mypow2 (b))
 @result{} 1
 @end group
 @end example
 
 
 The example above uses the functions @code{mxGetDimensions},
 @code{mxGetNumberOfElements}, and @code{mxGetNumberOfDimensions} to work
 with the dimensions of multi-dimensional arrays.  The functions
@@ -1429,17 +1429,17 @@ file @file{mystring.c}, as seen below.
 @EXAMPLEFILE(mystring.c)
 @end example
 
 @noindent
 An example of its expected output is
 
 @example
 @group
-mystring(["First String"; "Second String"])
+mystring (["First String"; "Second String"])
 @result{} s1 = Second String
         First String
 @end group
 @end example
 
 Other functions in the mex interface for handling character strings are
 @code{mxCreateString}, @code{mxArrayToString}, and
 @code{mxCreateCharMatrixFromStrings}.  In a mex-file, a character string
@@ -1544,17 +1544,17 @@ found in the file @file{mystruct.c}, as 
 @EXAMPLEFILE(mystruct.c)
 @end example
 
 An example of the behavior of this function within Octave is then
 
 @example
 a(1).f1 = "f11"; a(1).f2 = "f12"; 
 a(2).f1 = "f21"; a(2).f2 = "f22";
-b = mystruct(a)
+b = mystruct (a)
 @result{} field f1(0) = f11
     field f1(1) = f21
     field f2(0) = f12
     field f2(1) = f22
     b =
     @{
       this =
     
@@ -1646,18 +1646,18 @@ using @code{mexCallMATLAB}.  An example 
 @EXAMPLEFILE(myfeval.c)
 @end example
 
 If this code is in the file @file{myfeval.c}, and is compiled to
 @file{myfeval.mex}, then an example of its use is
 
 @example
 @group
-myfeval("sin", 1)
-a = myfeval("sin", 1)
+myfeval ("sin", 1)
+a = myfeval ("sin", 1)
 @result{} Hello, World!
     I have 2 inputs and 1 outputs
     I'm going to call the interpreter function sin
     a =  0.84147
 @end group
 @end example
 
 Note that it is not possible to use function handles or inline functions
diff --git a/doc/interpreter/errors.txi b/doc/interpreter/errors.txi
--- a/doc/interpreter/errors.txi
+++ b/doc/interpreter/errors.txi
@@ -58,17 +58,17 @@ described in @ref{The @code{try} Stateme
 The most common use of errors is for checking input arguments to
 functions.  The following example calls the @code{error} function if
 the function @code{f} is called without any input arguments.
 
 @example
 @group
 function f (arg1)
   if (nargin == 0)
-    error("not enough input arguments");
+    error ("not enough input arguments");
   endif
 endfunction
 @end group
 @end example
 
 When the @code{error} function is called, it prints the given message
 and returns to the Octave prompt.  This means that no code following
 a call to @code{error} will be executed.
diff --git a/doc/interpreter/eval.txi b/doc/interpreter/eval.txi
--- a/doc/interpreter/eval.txi
+++ b/doc/interpreter/eval.txi
@@ -122,18 +122,18 @@ endfunction
 @end example
 
 With @code{evalin}, you could write @code{save} as follows:
 
 @example
 @group
 function save (file, name1, name2)
   f = open_save_file (file);
-  save_var(f, name1, evalin ("caller", name1));
-  save_var(f, name2, evalin ("caller", name2));
+  save_var (f, name1, evalin ("caller", name1));
+  save_var (f, name2, evalin ("caller", name2));
 endfunction
 @end group
 @end example
 
 @noindent
 Here, @samp{caller} is the @code{create_data} function and @code{name1}
 is the string @code{"x"}, which evaluates simply as the value of @code{x}.
 
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -253,17 +253,17 @@ operation and judicious use of it can re
 looping over individual array elements which is a slow operation.
 
 Consider the following example which creates a 10-element row vector
 @math{a} containing the values
 @tex
 $a_i = \sqrt{i}$.
 @end tex
 @ifnottex
-a(i) = sqrt(i).
+a(i) = sqrt (i).
 @end ifnottex
 
 @example
 @group
 for i = 1:10
   a(i) = sqrt (i);
 endfor
 @end group
@@ -767,18 +767,18 @@ True if @var{x} is not equal to @var{y}.
 @end table
 
 For complex numbers, the following ordering is defined:
 @var{z1} < @var{z2}
 iff
 
 @example
 @group
-  abs(@var{z1}) < abs(@var{z2}) 
-  || (abs(@var{z1}) == abs(@var{z2}) && arg(@var{z1}) < arg(@var{z2}))
+  abs (@var{z1}) < abs (@var{z2}) 
+  || (abs (@var{z1}) == abs (@var{z2}) && arg (@var{z1}) < arg (@var{z2}))
 @end group
 @end example
 
 This is consistent with the ordering used by @dfn{max}, @dfn{min} and
 @dfn{sort}, but is not consistent with @sc{matlab}, which only compares the real
 parts.
 
 String comparisons may also be performed with the @code{strcmp}
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -767,17 +767,17 @@ a list of directories distributed with O
 working directory.  To see your current load path call the @code{path}
 function without any input or output arguments.
 
 It is possible to add or remove directories to or from the load path
 using @code{addpath} and @code{rmpath}.  As an example, the following
 code adds @samp{~/Octave} to the load path.
 
 @example
-addpath("~/Octave")
+addpath ("~/Octave")
 @end example
 
 @noindent
 After this the directory @samp{~/Octave} will be searched for functions.
  
 @DOCSTRING(addpath)
 
 @DOCSTRING(genpath)
@@ -1395,17 +1395,17 @@ environment.
 @node Inline Functions
 @subsection Inline Functions
 
 An inline function is created from a string containing the function
 body using the @code{inline} function.  The following code defines the
 function @math{f(x) = x^2 + 2}.
 
 @example
-f = inline("x^2 + 2");
+f = inline ("x^2 + 2");
 @end example
 
 @noindent
 After this it is possible to evaluate @math{f} at any @math{x} by
 writing @code{f(x)}.
 
 @DOCSTRING(inline)
 
@@ -1425,17 +1425,17 @@ it can also be called without the parent
 @example
 my_command hello world
 @end example
 
 @noindent
 is equivalent to 
 
 @example
-my_command("hello", "world")
+my_command ("hello", "world")
 @end example
 
 @noindent
 The general form of a command call is
 
 @example
 @var{cmdname} @var{arg1} @var{arg2} @dots{}
 @end example
diff --git a/doc/interpreter/geometry.txi b/doc/interpreter/geometry.txi
--- a/doc/interpreter/geometry.txi
+++ b/doc/interpreter/geometry.txi
@@ -67,17 +67,17 @@ An example of a Delaunay triangulation o
 @group
 rand ("state", 2);
 x = rand (10, 1);
 y = rand (10, 1);
 T = delaunay (x, y);
 X = [ x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1)) ];
 Y = [ y(T(:,1)); y(T(:,2)); y(T(:,3)); y(T(:,1)) ];
 axis ([0, 1, 0, 1]);
-plot(X, Y, "b", x, y, "r*");
+plot (X, Y, "b", x, y, "r*");
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:delaunay}.
 
 @float Figure,fig:delaunay
@@ -167,28 +167,28 @@ sum (@var{beta}(1:@var{N}+1)) == 1
 @end example
 
 @noindent
 is imposed, and we can therefore write the above as
 
 @example
 @group
 @var{p} - @var{t}(end, :) = @var{beta}(1:end-1) * (@var{t}(1:end-1, :)
-      - ones(@var{N}, 1) * @var{t}(end, :)
+      - ones (@var{N}, 1) * @var{t}(end, :)
 @end group
 @end example
 
 @noindent
 Solving for @var{beta} we can then write
 
 @example
 @group
 @var{beta}(1:end-1) = (@var{p} - @var{t}(end, :)) / (@var{t}(1:end-1, :)
-      - ones(@var{N}, 1) * @var{t}(end, :))
-@var{beta}(end) = sum(@var{beta}(1:end-1))
+      - ones (@var{N}, 1) * @var{t}(end, :))
+@var{beta}(end) = sum (@var{beta}(1:end-1))
 @end group
 @end example
 
 @noindent
 which gives the formula for the conversion of the Cartesian coordinates
 of the point @var{p} to the Barycentric coordinates @var{beta}.  An
 important property of the Barycentric coordinates is that for all points
 in the N-simplex
@@ -293,19 +293,19 @@ simplices of the Delaunay tessellation.
 @DOCSTRING(voronoi)
 
 @DOCSTRING(voronoin)
 
 An example of the use of @code{voronoi} is
 
 @example
 @group
-rand("state",9);
-x = rand(10,1);
-y = rand(10,1);
+rand ("state",9);
+x = rand (10,1);
+y = rand (10,1);
 tri = delaunay (x, y);
 [vx, vy] = voronoi (x, y, tri);
 triplot (tri, x, y, "b");
 hold on;
 plot (vx, vy, "r");
 @end group
 @end example
 
@@ -331,17 +331,17 @@ with the @code{polyarea} and @code{inpol
 An example of the use of @code{polyarea} might be 
 
 @example
 @group
 rand ("state", 2);
 x = rand (10, 1);
 y = rand (10, 1);
 [c, f] = voronoin ([x, y]);
-af = zeros (size(f));
+af = zeros (size (f));
 for i = 1 : length (f)
   af(i) = polyarea (c (f @{i, :@}, 1), c (f @{i, :@}, 2));
 endfor
 @end group
 @end example
 
 Facets of the Voronoi diagram with a vertex at infinity have infinity
 area.  A simplified version of @code{polyarea} for rectangles is
@@ -356,17 +356,17 @@ An example of the use of @code{inpolygon
 @example
 @group
 randn ("state", 2);
 x = randn (100, 1);
 y = randn (100, 1);
 vx = cos (pi * [-1 : 0.1: 1]);
 vy = sin (pi * [-1 : 0.1 : 1]);
 in = inpolygon (x, y, vx, vy);
-plot(vx, vy, x(in), y(in), "r+", x(!in), y(!in), "bo");
+plot (vx, vy, x(in), y(in), "r+", x(!in), y(!in), "bo");
 axis ([-2, 2, -2, 2]);
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:inpolygon}.
 
@@ -429,22 +429,22 @@ interpolation are @code{griddata}, @code
 @DOCSTRING(griddata3)
 
 @DOCSTRING(griddatan)
 
 An example of the use of the @code{griddata} function is
 
 @example
 @group
-rand("state",1);
-x=2*rand(1000,1)-1;
-y=2*rand(size(x))-1;
-z=sin(2*(x.^2+y.^2));
-[xx,yy]=meshgrid(linspace(-1,1,32));
-griddata(x,y,z,xx,yy);
+rand ("state", 1);
+x = 2*rand (1000,1) - 1;
+y = 2*rand (size (x)) - 1;
+z = sin (2*(x.^2+y.^2));
+[xx,yy] = meshgrid (linspace (-1,1,32));
+griddata (x,y,z,xx,yy);
 @end group
 @end example
 
 @noindent
 that interpolates from a random scattering of points, to a uniform
 grid. 
 @ifnotinfo
 The output of the above can be seen in @ref{fig:griddata}.
diff --git a/doc/interpreter/interp.txi b/doc/interpreter/interp.txi
--- a/doc/interpreter/interp.txi
+++ b/doc/interpreter/interp.txi
@@ -45,27 +45,27 @@ discontinuous, then 'pchip' interpolatio
 This can be demonstrated by the code
 
 @example
 @group
 t = -2:2;
 dt = 1;
 ti =-2:0.025:2;
 dti = 0.025;
-y = sign(t);
-ys = interp1(t,y,ti,'spline');
-yp = interp1(t,y,ti,'pchip');
-ddys = diff(diff(ys)./dti)./dti;
-ddyp = diff(diff(yp)./dti)./dti;
-figure(1);
-plot (ti, ys,'r-', ti, yp,'g-');
-legend('spline','pchip',4);
-figure(2);
-plot (ti, ddys,'r+', ti, ddyp,'g*');
-legend('spline','pchip');
+y = sign (t);
+ys = interp1 (t,y,ti,'spline');
+yp = interp1 (t,y,ti,'pchip');
+ddys = diff (diff (ys)./dti) ./ dti;
+ddyp = diff (diff (yp)./dti) ./ dti;
+figure (1);
+plot (ti,ys,'r-', ti,yp,'g-');
+legend ('spline', 'pchip', 4);
+figure (2);
+plot (ti,ddys,'r+', ti,ddyp,'g*');
+legend ('spline', 'pchip');
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:interpderiv1} and
 @ref{fig:interpderiv2}.
 
@@ -102,19 +102,19 @@ points.  An example of the use of @code{
 
 @example
 @group
 t = 0 : 0.3 : pi; dt = t(2)-t(1);
 n = length (t); k = 100;
 ti = t(1) + [0 : k-1]*dt*n/k;
 y = sin (4*t + 0.3) .* cos (3*t - 0.1);
 yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
-plot (ti, yp, 'g', ti, interp1(t, y, ti, 'spline'), 'b', ...
+plot (ti, yp, 'g', ti, interp1 (t, y, ti, 'spline'), 'b', ...
       ti, interpft (y, k), 'c', t, y, 'r+');
-legend ('sin(4t+0.3)cos(3t-0.1','spline','interpft','data');
+legend ('sin(4t+0.3)cos(3t-0.1', 'spline', 'interpft', 'data');
 @end group
 @end example
 
 @noindent
 @ifinfo
 which demonstrates the poor behavior of Fourier interpolation for non-periodic
 functions.
 @end ifinfo
@@ -159,19 +159,19 @@ Consider the example,
 @example
 @group
 x = y = z = -1:1;
 f = @@(x,y,z) x.^2 - y - z.^2;
 [xx, yy, zz] = meshgrid (x, y, z);
 v = f (xx,yy,zz);
 xi = yi = zi = -1:0.1:1;
 [xxi, yyi, zzi] = meshgrid (xi, yi, zi);
-vi = interp3(x, y, z, v, xxi, yyi, zzi, 'spline');
+vi = interp3 (x, y, z, v, xxi, yyi, zzi, 'spline');
 [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
-vi2 = interpn(x, y, z, v, xxi, yyi, zzi, 'spline');
+vi2 = interpn (x, y, z, v, xxi, yyi, zzi, 'spline');
 mesh (zi, yi, squeeze (vi2(1,:,:)));
 @end group
 @end example
 
 @noindent
 where @code{vi} and @code{vi2} are identical.  The reversal of the
 dimensions is treated in the @code{meshgrid} and @code{ndgrid} functions
 respectively.
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -99,17 +99,17 @@ e     = -1
 @end display
 @end ifnottex
 
 @noindent
 type the following which will evaluate to @code{-1} within the
 tolerance of the calculation. 
 
 @example
-octave:1> exp(i*pi)
+octave:1> exp (i*pi)
 @end example
 
 @subsection Creating a Matrix
 
 Vectors and matrices are the basic building blocks for numerical analysis.  
 To create a new matrix and store it in a variable so that you can
 refer to it later, type the command
 
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -565,17 +565,17 @@ can't be represented using the chosen in
 not possible to represent the result of @math{10 - 20} when using
 unsigned integers.  Octave makes sure that the result of integer
 computations is the integer that is closest to the true result.  So, the
 result of @math{10 - 20} when using unsigned integers is zero.
 
 When doing integer division Octave will round the result to the nearest
 integer.  This is different from most programming languages, where the
 result is often floored to the nearest integer.  So, the result of
-@code{int32(5) ./ int32(8)} is @code{1}.
+@code{int32 (5) ./ int32 (8)} is @code{1}.
 
 @DOCSTRING(idivide)
 
 @node Bit Manipulations
 @section Bit Manipulations
 
 Octave provides a number of functions for the manipulation of numeric
 values on a bit by bit basis.  The basic functions to set and obtain the
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -179,17 +179,17 @@ An example of a display method for the p
 @example
 @group
 @EXAMPLEFILE(@polynomial/display.m)
 @end group
 @end example
 
 @noindent
 Note that in the display method, it makes sense to start the method
-with the line @code{fprintf("%s =", inputname(1))} to be consistent
+with the line @code{fprintf ("%s =", inputname (1))} to be consistent
 with the rest of Octave and print the variable name to be displayed
 when displaying the class. 
 
 To be consistent with the Octave graphic handle classes, a class
 should also define the @code{get} and @code{set} methods.  The
 @code{get} method should accept one or two arguments, and given one
 argument of the appropriate class it should return a structure with
 all of the properties of the class.  For example:
@@ -312,17 +312,17 @@ look like
 
 @noindent
 which is a fairly generic @code{end} method that has a behavior similar to
 the @code{end} keyword for Octave Array classes.  It can then be used as 
 follows:
 
 @example
 @group
-p = polynomial([1,2,3,4]);
+p = polynomial ([1,2,3,4]);
 p(end-1)
   @result{} 3
 @end group
 @end example
 
 Objects can also be used as the index in a subscripted expression themselves
 and this is controlled with the @code{subsindex} function.
 
@@ -349,17 +349,17 @@ a call to subsasgn:
 
 @noindent
 and the corresponding method looking like this:
 
 @example
 @group
   function x = subsasgn (x, ss, val)
     @dots{}
-    x.myfield(ss.subs@{1@}) = val;
+    x.myfield (ss.subs@{1@}) = val;
   endfunction
 @end group
 @end example
 
 The problem is that on entry to the subsasgn method, @code{x} is still
 referenced from the caller's scope, which means that the method will 
 first need to unshare (copy) @code{x} and @code{x.myfield} before performing
 the assignment.  Upon completing the call, unless an error occurs,
@@ -721,25 +721,25 @@ Note that we have used the polynomial fi
 the filter coefficients.
 
 Once we have the class constructor and display method, we may create
 an object by calling the class constructor.  We may also check the
 class type and examine the underlying structure.
 
 @example
 @group
-octave:1> f=FIRfilter(polynomial([1 1 1]/3))
+octave:1> f = FIRfilter (polynomial ([1 1 1]/3))
 f.polynomial = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
-octave:2> class(f)
+octave:2> class (f)
 ans = FIRfilter
-octave:3> isa(f,"FIRfilter")
+octave:3> isa (f,"FIRfilter")
 ans =  1
-octave:4> isa(f,"polynomial")
+octave:4> isa (f,"polynomial")
 ans =  1
-octave:5> struct(f)
+octave:5> struct (f)
 ans = 
 @{
 polynomial = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
 @}
 @end group
 @end example
 
 We only need to define a method to actually process data with our
@@ -754,34 +754,34 @@ to access the fields.  The @code{subsref
 @end group
 @end example
 
 The "()" case allows us to filter data using the polynomial provided
 to the constructor.
 
 @example
 @group
-octave:2> f=FIRfilter(polynomial([1 1 1]/3));
-octave:3> x=ones(5,1);
-octave:4> y=f(x)
+octave:2> f = FIRfilter (polynomial ([1 1 1]/3));
+octave:3> x = ones (5,1);
+octave:4> y = f(x)
 y =
 
    0.33333
    0.66667
    1.00000
    1.00000
    1.00000
 @end group
 @end example
 
 The "." case allows us to view the contents of the polynomial field.
 
 @example
 @group
-octave:1> f=FIRfilter(polynomial([1 1 1]/3));
+octave:1> f = FIRfilter (polynomial ([1 1 1]/3));
 octave:2> f.polynomial
 ans = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
 @end group
 @end example
 
 In order to change the contents of the object, we need to define a
 @code{subsasgn} method.  For example, we may make the polynomial field
 publicly writable.
@@ -791,23 +791,22 @@ publicly writable.
 @EXAMPLEFILE(@FIRfilter/subsasgn.m)
 @end group
 @end example
 
 So that
 
 @example
 @group
-octave:6> f=FIRfilter ();
-octave:7> f.polynomial = polynomial([1 2 3]);
+octave:6> f = FIRfilter ();
+octave:7> f.polynomial = polynomial ([1 2 3]);
 f.polynomial = 1 + 2 * X + 3 * X ^ 2
 @end group
 @end example
 
-
 Defining the FIRfilter class as a child of the polynomial class
 implies that and FIRfilter object may be used any place that a
 polynomial may be used.  This is not a normal use of a filter, so that
 aggregation may be a more sensible design approach.  In this case, the
 polynomial is simply a field in the class structure.  A class
 constructor for this case might be
 
 @example
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -806,21 +806,21 @@ width 0.6pt \tabskip=0pt\cr
 @caption{Available special characters in @TeX{} mode}
 @end float
 
 A complete example showing the capabilities of the extended text is
 
 @example
 @group
 x = 0:0.01:3;
-plot(x,erf(x));
+plot (x, erf (x));
 hold on;
-plot(x,x,"r");
-axis([0, 3, 0, 1]);
-text(0.65, 0.6175, strcat('\leftarrow x = @{2/\surd\pi',
+plot (x,x,"r");
+axis ([0, 3, 0, 1]);
+text (0.65, 0.6175, strcat ('\leftarrow x = @{2/\surd\pi',
 ' @{\fontsize@{16@}\int_@{\fontsize@{8@}0@}^@{\fontsize@{8@}x@}@}',
 ' e^@{-t^2@} dt@} = 0.6175'))
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:extendedtext}
@@ -2605,17 +2605,17 @@ endfunction
 
 @noindent
 where @code{src} gives a handle to the source of the callback, and
 @code{code} gives some event specific data.  This can then be associated
 with an object either at the objects creation or later with the
 @code{set} function.  For example,
 
 @example
-plot (x, "DeleteFcn", @@(s, e) disp("Window Deleted"))
+plot (x, "DeleteFcn", @@(s, e) disp ("Window Deleted"))
 @end example
 
 @noindent
 where at the moment that the plot is deleted, the message "Window
 Deleted" will be displayed.
 
 Additional user arguments can be passed to callback functions, and will
 be passed after the 2 default arguments.  For example:
diff --git a/doc/interpreter/poly.txi b/doc/interpreter/poly.txi
--- a/doc/interpreter/poly.txi
+++ b/doc/interpreter/poly.txi
@@ -49,18 +49,18 @@ p(x) = @var{c}(1) x^@var{N} + @dots{} + 
 @node Evaluating Polynomials
 @section Evaluating Polynomials
 
 The value of a polynomial represented by the vector @var{c} can be evaluated
 at the point @var{x} very easily, as the following example shows:
 
 @example
 @group
-N = length(c)-1;
-val = dot( x.^(N:-1:0), c );
+N = length (c) - 1;
+val = dot (x.^(N:-1:0), c);
 @end group
 @end example
 
 @noindent
 While the above example shows how easy it is to compute the value of a
 polynomial, it isn't the most stable algorithm.  With larger polynomials
 you should use more elegant algorithms, such as Horner's Method, which
 is exactly what the Octave function @code{polyval} does.
@@ -109,18 +109,18 @@ for a definition), and then finding its 
 Octave comes with functions for computing the derivative and the integral
 of a polynomial.  The functions @code{polyder} and @code{polyint}
 both return new polynomials describing the result.  As an example we'll
 compute the definite integral of @math{p(x) = x^2 + 1} from 0 to 3.
 
 @example
 @group
 c = [1, 0, 1];
-integral = polyint(c);
-area = polyval(integral, 3) - polyval(integral, 0)
+integral = polyint (c);
+area = polyval (integral, 3) - polyval (integral, 0)
 @result{} 12
 @end group
 @end example
 
 @DOCSTRING(polyder)
 
 @DOCSTRING(polyint)
 
@@ -356,20 +356,20 @@ quadratic into one function.  Each of th
 on adjoined intervals.
 
 @example
 @group
 x = [-2, -1, 1, 2];
 p = [ 0,  1, 0;
       1, -2, 1;
       0, -1, 1 ];
-pp = mkpp(x, p);
-xi = linspace(-2, 2, 50);
-yi = ppval(pp, xi);
-plot(xi, yi);
+pp = mkpp (x, p);
+xi = linspace (-2, 2, 50);
+yi = ppval (pp, xi);
+plot (xi, yi);
 @end group
 @end example
 
 @DOCSTRING(mkpp)
 
 @DOCSTRING(unmkpp)
 
 @DOCSTRING(ppval)
diff --git a/doc/interpreter/quad.txi b/doc/interpreter/quad.txi
--- a/doc/interpreter/quad.txi
+++ b/doc/interpreter/quad.txi
@@ -333,17 +333,17 @@ using @math{n} points by
 @tex
 $$
  \int_0^1 \int_0^1 f(x,y) d x d y \approx \sum_{i=1}^n \sum_{j=1}^n q_i q_j f(r_i, r_j),
 $$
 @end tex
 @ifnottex
 the sum over @code{i=1:n} and @code{j=1:n} of @code{q(i)*q(j)*f(r(i),r(j))},
 @end ifnottex
-where @math{q} and @math{r} is as returned by @code{colloc(n)}.  The
+where @math{q} and @math{r} is as returned by @code{colloc (n)}.  The
 generalization to more than two variables is straight forward.  The
 following code computes the studied integral using @math{n=8} points.
 
 @example
 @group
 f = @@(x,y) sin (pi*x*y') .* sqrt (x*y');
 n = 8;
 [t, ~, ~, q] = colloc (n);
diff --git a/doc/interpreter/set.txi b/doc/interpreter/set.txi
--- a/doc/interpreter/set.txi
+++ b/doc/interpreter/set.txi
@@ -35,17 +35,17 @@ represented as a vector of numbers.
 Octave supports the basic set operations.  That is, Octave can compute
 the union, intersection, and difference of two sets.
 Octave also supports the @emph{Exclusive Or} set operation, and
 membership determination.  The functions for set operations all work in
 pretty much the same way.  As an example, assume that @code{x} and
 @code{y} contains two sets, then
 
 @example
-union(x, y)
+union (x, y)
 @end example
 
 @noindent
 computes the union of the two sets.
 
 @DOCSTRING(ismember)
 
 @DOCSTRING(union)
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -101,17 +101,17 @@ In fact, the column index contains one m
 columns, with the first element always being zero.  The advantage of
 this is a simplification in the code, in that there is no special case
 for the first or last columns.  A short example, demonstrating this in
 C is.
 
 @example
 @group
   for (j = 0; j < nc; j++)
-    for (i = cidx (j); i < cidx(j+1); i++)
+    for (i = cidx(j); i < cidx(j+1); i++)
        printf ("non-zero element (%i,%i) is %d\n", 
            ridx(i), j, data(i));
 @end group
 @end example
 
 A clear understanding might be had by considering an example of how the
 above applies to an example matrix.  Consider the matrix
 
@@ -207,17 +207,17 @@ creates an @var{r}-by-@var{c} sparse mat
 elements of @var{d}.
 
 Other functions of interest that directly create sparse matrices, are
 @dfn{diag} or its generalization @dfn{spdiags}, that can take the
 definition of the diagonals of the matrix and create the sparse matrix 
 that corresponds to this.  For example,
 
 @example
-s = diag (sparse(randn(1,n)), -1);
+s = diag (sparse (randn (1,n)), -1);
 @end example
 
 @noindent
 creates a sparse (@var{n}+1)-by-(@var{n}+1) sparse matrix with a single
 diagonal defined.
 
 @DOCSTRING(spdiags)
 
@@ -343,32 +343,32 @@ determines the means to solve the equati
 matrix as discussed in @ref{Sparse Linear Algebra}.  Octave probes the
 matrix type when the div (/) or ldiv (\) operator is first used with
 the matrix and then caches the type.  However the @dfn{matrix_type}
 function can be used to determine the type of the sparse matrix prior
 to use of the div or ldiv operators.  For example,
 
 @example
 @group
-a = tril (sprandn(1024, 1024, 0.02), -1) ...
-    + speye(1024); 
+a = tril (sprandn (1024, 1024, 0.02), -1) ...
+    + speye (1024); 
 matrix_type (a);
 ans = Lower
 @end group
 @end example
 
 @noindent
 shows that Octave correctly determines the matrix type for lower
 triangular matrices.  @dfn{matrix_type} can also be used to force
 the type of a matrix to be a particular type.  For example:
 
 @example
 @group
 a = matrix_type (tril (sprandn (1024, ...
-   1024, 0.02), -1) + speye(1024), 'Lower');
+   1024, 0.02), -1) + speye (1024), "Lower");
 @end group
 @end example
 
 This allows the cost of determining the matrix type to be
 avoided.  However, incorrectly defining the matrix type will result in
 incorrect results from solutions of linear equations, and so it is
 entirely the responsibility of the user to correctly identify the
 matrix type
@@ -393,20 +393,20 @@ ji-th node) of the sparse adjacency matr
 is then associated with a set of coordinates, then the @dfn{gplot}
 command can be used to graphically display the interconnections
 between nodes.
 
 As a trivial example of the use of @dfn{gplot} consider the example,
 
 @example
 @group
-A = sparse([2,6,1,3,2,4,3,5,4,6,1,5],
+A = sparse ([2,6,1,3,2,4,3,5,4,6,1,5],
     [1,1,2,2,3,3,4,4,5,5,6,6],1,6,6);
 xy = [0,4,8,6,4,2;5,0,5,7,5,7]';
-gplot(A,xy)
+gplot (A,xy)
 @end group
 @end example
 
 @noindent
 which creates an adjacency matrix @code{A} where node 1 is connected
 to nodes 2 and 6, node 2 with nodes 1 and 3, etc.  The coordinates of
 the nodes are given in the n-by-2 matrix @code{xy}.
 @ifset htmltex 
@@ -417,18 +417,18 @@ the nodes are given in the n-by-2 matrix
 @caption{Simple use of the @dfn{gplot} command.}
 @end float
 @end ifset
 
 The dependencies between the nodes of a Cholesky@tie{}factorization can be
 calculated in linear time without explicitly needing to calculate the
 Cholesky@tie{}factorization by the @code{etree} command.  This command
 returns the elimination tree of the matrix and can be displayed
-graphically by the command @code{treeplot(etree(A))} if @code{A} is
-symmetric or @code{treeplot(etree(A+A'))} otherwise.
+graphically by the command @code{treeplot (etree (A))} if @code{A} is
+symmetric or @code{treeplot (etree (A+A'))} otherwise.
 
 @DOCSTRING(spy)
 
 @DOCSTRING(etree)
 
 @DOCSTRING(etreeplot)
 
 @DOCSTRING(gplot)
@@ -514,17 +514,17 @@ Therefore, there is a certain density of
 where it no longer makes sense to store it as a sparse matrix, but rather
 as a full matrix.  For this reason operators and functions that have a 
 high probability of returning a full matrix will always return one.  For
 example adding a scalar constant to a sparse matrix will almost always
 make it a full matrix, and so the example,
 
 @example
 @group
-speye(3) + 0
+speye (3) + 0
 @result{}   1  0  0
   0  1  0
   0  0  1
 @end group
 @end example
 
 @noindent
 returns a full matrix as can be seen. 
@@ -536,27 +536,27 @@ amount of storage used is larger than th
 equivalent.  Therefore @code{speye (2) * 1} will return a full matrix as
 the memory used is smaller for the full version than the sparse version.
 
 As all of the mixed operators and functions between full and sparse 
 matrices exist, in general this does not cause any problems.  However,
 one area where it does cause a problem is where a sparse matrix is
 promoted to a full matrix, where subsequent operations would resparsify
 the matrix.  Such cases are rare, but can be artificially created, for
-example @code{(fliplr(speye(3)) + speye(3)) - speye(3)} gives a full
+example @code{(fliplr (speye (3)) + speye (3)) - speye (3)} gives a full
 matrix when it should give a sparse one.  In general, where such cases 
 occur, they impose only a small memory penalty.
 
 There is however one known case where this behavior of Octave's
 sparse matrices will cause a problem.  That is in the handling of the
 @dfn{diag} function.  Whether @dfn{diag} returns a sparse or full matrix
 depending on the type of its input arguments.  So 
 
 @example
- a = diag (sparse([1,2,3]), -1);
+ a = diag (sparse ([1,2,3]), -1);
 @end example
 
 @noindent
 should return a sparse matrix.  To ensure this actually happens, the
 @dfn{sparse} function, and other functions based on it like @dfn{speye}, 
 always returns a sparse matrix, even if the memory used will be larger 
 than its full representation.
 
@@ -650,17 +650,17 @@ positive definite matrix.
 @float Figure,fig:simplematrix
 @center @image{spmatrix,4in}
 @caption{Structure of simple sparse matrix.}
 @end float
 
 The standard Cholesky@tie{}factorization of this matrix can be
 obtained by the same command that would be used for a full
 matrix.  This can be visualized with the command 
-@code{r = chol(A); spy(r);}.
+@code{r = chol (A); spy (r);}.
 @xref{fig:simplechol}.
 The original matrix had 
 @ifinfo
 @ifnothtml
 43
 @end ifnothtml
 @end ifinfo
 @ifset htmltex
@@ -677,47 +677,47 @@ 10200,
 @end ifset
 with only half of the symmetric matrix being stored.  This
 is a significant level of fill in, and although not an issue
 for such a small test case, can represents a large overhead 
 in working with other sparse matrices.
 
 The appropriate sparsity preserving permutation of the original
 matrix is given by @dfn{symamd} and the factorization using this
-reordering can be visualized using the command @code{q = symamd(A);
-r = chol(A(q,q)); spy(r)}.  This gives 
+reordering can be visualized using the command @code{q = symamd (A);
+r = chol (A(q,q)); spy (r)}.  This gives 
 @ifinfo
 @ifnothtml
 29
 @end ifnothtml
 @end ifinfo
 @ifset htmltex
 399
 @end ifset
 non-zero terms which is a significant improvement.
 
 The Cholesky@tie{}factorization itself can be used to determine the
 appropriate sparsity preserving reordering of the matrix during the
 factorization, In that case this might be obtained with three return
-arguments as r@code{[r, p, q] = chol(A); spy(r)}.
+arguments as @code{[r, p, q] = chol (A); spy (r)}.
 
 @float Figure,fig:simplechol
 @center @image{spchol,4in}
 @caption{Structure of the un-permuted Cholesky@tie{}factorization of the above matrix.}
 @end float
 
 @float Figure,fig:simplecholperm
 @center @image{spcholperm,4in}
 @caption{Structure of the permuted Cholesky@tie{}factorization of the above matrix.}
 @end float
 
 In the case of an asymmetric matrix, the appropriate sparsity
 preserving permutation is @dfn{colamd} and the factorization using
 this reordering can be visualized using the command
-@code{q = colamd(A); [l, u, p] = lu(A(:,q)); spy(l+u)}.
+@code{q = colamd (A); [l, u, p] = lu (A(:,q)); spy (l+u)}.
 
 Finally, Octave implicitly reorders the matrix when using the div (/)
 and ldiv (\) operators, and so no the user does not need to explicitly
 reorder the matrix to maximize performance.
 
 @DOCSTRING(amd)
 
 @DOCSTRING(ccolamd)
@@ -943,33 +943,33 @@ vertices @code{nodes} and simplices @cod
 
 The following example creates a simple rectangular 2-D electrically
 conductive medium with 10 V and 20 V imposed on opposite sides 
 (Dirichlet boundary conditions).  All other edges are electrically
 isolated.
 
 @example
 @group
-   node_y= [1;1.2;1.5;1.8;2]*ones(1,11);
-   node_x= ones(5,1)*[1,1.05,1.1,1.2, ...
+   node_y = [1;1.2;1.5;1.8;2]*ones(1,11);
+   node_x = ones(5,1)*[1,1.05,1.1,1.2, ...
              1.3,1.5,1.7,1.8,1.9,1.95,2];
-   nodes= [node_x(:), node_y(:)];
+   nodes = [node_x(:), node_y(:)];
 
-   [h,w]= size(node_x);
-   elems= [];
-   for idx= 1:w-1
-     widx= (idx-1)*h;
-     elems= [elems; ...
+   [h,w] = size (node_x);
+   elems = [];
+   for idx = 1:w-1
+     widx = (idx-1)*h;
+     elems = [elems; ...
        widx+[(1:h-1);(2:h);h+(1:h-1)]'; ...
        widx+[(2:h);h+(2:h);h+(1:h-1)]' ]; 
    endfor
 
-   E= size(elems,1); # No. of simplices
-   N= size(nodes,1); # No. of vertices
-   D= size(elems,2); # dimensions+1
+   E = size (elems,1); # No. of simplices
+   N = size (nodes,1); # No. of vertices
+   D = size (elems,2); # dimensions+1
 @end group
 @end example
 
 This creates a N-by-2 matrix @code{nodes} and a E-by-3 matrix
 @code{elems} with values, which define finite element triangles:
 
 @example
 @group
@@ -996,42 +996,42 @@ as constant on each simplex (represented
 Based on the finite element geometry, we first calculate a system (or
 stiffness) matrix for each simplex (represented as 3-by-3 elements on the
 diagonal of the element-wise system matrix @code{SE}.  Based on @code{SE} 
 and a N-by-DE connectivity matrix @code{C}, representing the connections 
 between simplices and vertices, the global connectivity matrix @code{S} is
 calculated.
 
 @example
-  # Element conductivity
-  conductivity= [1*ones(1,16), ...
+  ## Element conductivity
+  conductivity = [1*ones(1,16), ...
          2*ones(1,48), 1*ones(1,16)];
 
-  # Connectivity matrix
+  ## Connectivity matrix
   C = sparse ((1:D*E), reshape (elems', ...
          D*E, 1), 1, D*E, N);
 
-  # Calculate system matrix
+  ## Calculate system matrix
   Siidx = floor ([0:D*E-1]'/D) * D * ...
          ones(1,D) + ones(D*E,1)*(1:D) ;
-  Sjidx = [1:D*E]'*ones(1,D);
-  Sdata = zeros(D*E,D);
-  dfact = factorial(D-1);
-  for j=1:E
-     a = inv([ones(D,1), ... 
+  Sjidx = [1:D*E]'*ones (1,D);
+  Sdata = zeros (D*E,D);
+  dfact = factorial (D-1);
+  for j = 1:E
+     a = inv ([ones(D,1), ... 
          nodes(elems(j,:), :)]);
      const = conductivity(j) * 2 / ...
-         dfact / abs(det(a));
+         dfact / abs (det (a));
      Sdata(D*(j-1)+(1:D),:) = const * ...
          a(2:D,:)' * a(2:D,:);
   endfor
-  # Element-wise system matrix
-  SE= sparse(Siidx,Sjidx,Sdata);
-  # Global system matrix
-  S= C'* SE *C;
+  ## Element-wise system matrix
+  SE = sparse(Siidx,Sjidx,Sdata);
+  ## Global system matrix
+  S = C'* SE *C;
 @end example
 
 The system matrix acts like the conductivity 
 @tex
 $S$ 
 @end tex
 @ifnottex
 @code{S}
@@ -1042,33 +1042,33 @@ in Ohm's law
 @end tex
 @ifnottex
 @code{S * V = I}.
 @end ifnottex
 Based on the Dirichlet and Neumann boundary conditions, we are able to 
 solve for the voltages at each vertex @code{V}. 
 
 @example
-  # Dirichlet boundary conditions
-  D_nodes=[1:5, 51:55]; 
-  D_value=[10*ones(1,5), 20*ones(1,5)]; 
+  ## Dirichlet boundary conditions
+  D_nodes = [1:5, 51:55]; 
+  D_value = [10*ones(1,5), 20*ones(1,5)]; 
 
-  V= zeros(N,1);
+  V = zeros (N,1);
   V(D_nodes) = D_value;
   idx = 1:N; # vertices without Dirichlet 
              # boundary condns
   idx(D_nodes) = [];
 
-  # Neumann boundary conditions.  Note that
-  # N_value must be normalized by the
-  # boundary length and element conductivity
-  N_nodes=[];
-  N_value=[];
+  ## Neumann boundary conditions.  Note that
+  ## N_value must be normalized by the
+  ## boundary length and element conductivity
+  N_nodes = [];
+  N_value = [];
 
-  Q = zeros(N,1);
+  Q = zeros (N,1);
   Q(N_nodes) = N_value;
 
   V(idx) = S(idx,idx) \ ( Q(idx) - ...
             S(idx,D_nodes) * V(D_nodes));
 @end example
 
 Finally, in order to display the solution, we show each solved voltage 
 value in the z-axis for each simplex vertex.
@@ -1077,18 +1077,18 @@ value in the z-axis for each simplex ver
 @end ifset
 
 @example
 @group
   elemx = elems(:,[1,2,3,1])';
   xelems = reshape (nodes(elemx, 1), 4, E);
   yelems = reshape (nodes(elemx, 2), 4, E);
   velems = reshape (V(elemx), 4, E);
-  plot3 (xelems,yelems,velems,'k'); 
-  print ('grid.eps');
+  plot3 (xelems,yelems,velems,"k"); 
+  print "grid.eps";
 @end group
 @end example
 
 
 @ifset htmltex
 @float Figure,fig:femmodel
 @center @image{grid,4in}
 @caption{Example finite element model the showing triangular elements. 
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -555,47 +555,47 @@ next value in the range is assigned to t
 loop body is executed again.  This process continues until there are no
 more elements to assign.
 
 Within Octave is it also possible to iterate over matrices or cell arrays
 using the @code{for} statement.  For example consider
 
 @example
 @group
-disp("Loop over a matrix")
+disp ("Loop over a matrix")
 for i = [1,3;2,4]
   i
 endfor
-disp("Loop over a cell array")
+disp ("Loop over a cell array")
 for i = @{1,"two";"three",4@}
   i
 endfor
 @end group 
 @end example
 
 @noindent
 In this case the variable @code{i} takes on the value of the columns of
 the matrix or cell matrix.  So the first loop iterates twice, producing
 two column vectors @code{[1;2]}, followed by @code{[3;4]}, and likewise
 for the loop over the cell array.  This can be extended to loops over
 multi-dimensional arrays.  For example:
 
 @example
 @group
-a = [1,3;2,4]; c = cat(3, a, 2*a);
+a = [1,3;2,4]; c = cat (3, a, 2*a);
 for i = c
   i
 endfor
 @end group 
 @end example
 
 @noindent
 In the above case, the multi-dimensional matrix @var{c} is reshaped to a
-two-dimensional matrix as @code{reshape (c, rows(c),
-prod(size(c)(2:end)))} and then the same behavior as a loop over a two
+two-dimensional matrix as @code{reshape (c, rows (c),
+prod (size (c)(2:end)))} and then the same behavior as a loop over a two
 dimensional matrix is produced.
 
 Although it is possible to rewrite all @code{for} loops as @code{while}
 loops, the Octave language has both statements because often a
 @code{for} loop is both less work to type and more natural to think of.
 Counting the number of iterations is very common in loops and it can be
 easier to think of this counting as part of looping rather than as
 something to do inside the loop.
diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -67,17 +67,17 @@ produces a correct value.  A real test m
 @example
 @group
 %!test
 %! @var{a} = [1, 2, 3; 4, 5, 6]; B = [1; 2];
 %! expect = [ @var{a} ; 2*@var{a} ];
 %! get = kron (@var{b}, @var{a});
 %! if (any (size (expect) != size (get)))
 %!   error ("wrong size: expected %d,%d but got %d,%d",
-%!          size(expect), size(get));
+%!          size (expect), size (get));
 %! elseif (any (any (expect != get)))
 %!   error ("didn't get what was expected.");
 %! endif
 @end group
 @end example
 
 To make the process easier, use the @code{assert} function.  For example,
 with @code{assert} the previous test is reduced to:
diff --git a/doc/interpreter/vectorize.txi b/doc/interpreter/vectorize.txi
--- a/doc/interpreter/vectorize.txi
+++ b/doc/interpreter/vectorize.txi
@@ -655,17 +655,17 @@ users of Octave and their solutions.
 @itemize @bullet
 @item
 For a vector @code{A}, the following loop
 
 @example
 @group
 n = length (A);
 B = zeros (n, 2);
-for i = 1:length(A)
+for i = 1:length (A)
   ## this will be two columns, the first is the difference and
   ## the second the mean of the two elements used for the diff.
   B(i,:) = [A(i+1)-A(i), (A(i+1) + A(i))/2)];
 endfor
 @end group
 @end example
 
 @noindent
diff --git a/doc/refcard/refcard.tex b/doc/refcard/refcard.tex
--- a/doc/refcard/refcard.tex
+++ b/doc/refcard/refcard.tex
@@ -674,27 +674,27 @@ realmin&minimum representable value\cr
 \char'136\ \ .\char'136&exponentiation\cr
 \endsec
 
 \vfill\eject
 
 \sec Paths and Packages;
 path&display the current Octave function path.\cr
 pathdef&display the default path.\cr
-addpath({\it dir})&add a directory to the path.\cr
+addpath ({\it dir})&add a directory to the path.\cr
 EXEC\_PATH&manipulate the Octave executable path.\cr
 pkg list&display installed packages.\cr
 pkg load {\it pack}&Load an installed package.\cr
 \endsec
 
 \sec Cells and Structures;
 {\it{var}}.{\it{field}} = ...&set a field of a structure.\cr
 {\it{var}}$\{${\it{idx}}$\}$ = ...&set an element of a cell array.\cr
-cellfun({\it f}, {\it c})&apply a function to elements of cell array.\cr
-fieldnames({\it s})&returns the fields of a structure.\cr
+cellfun ({\it f}, {\it c})&apply a function to elements of cell array.\cr
+fieldnames ({\it s})&returns the fields of a structure.\cr
 \endsec
 
 \widesec Statements;
 for {\it identifier} = {\it expr} {\it stmt-list} endfor\cr
 \hfill\vbox{\hsize=\idnwid\rm\vskip0.25ex
   Execute {\it stmt-list} once for each column of {\it expr}.  The
   variable {\it identifier} is set to the value of the current column
   during each iteration.}\cr\cr
@@ -798,20 +798,20 @@ logspace ({\it b}, {\it l}, {\it n})&cre
   elements\cr
 eye ({\it n}, {\it m})&create {\it n\/} by {\it m\/} identity matrix\cr
 ones ({\it n}, {\it m})&create {\it n\/} by {\it m\/} matrix of ones\cr
 zeros ({\it n}, {\it m})&create {\it n\/} by {\it m\/} matrix of zeros\cr
 rand ({\it n}, {\it m})&create {\it n\/} by {\it m\/} matrix of random
   values\cr 
 \endsec
 
-% sin({\it a}) cos({\it a}) tan({\it a})&trigonometric functions\cr
-% asin({\it a}) acos({\it a}) atan({\it a})&inverse trigonometric functions\cr
-% sinh({\it a}) cosh({\it a}) tanh({\it a})&hyperbolic trig functions\cr
-% asinh({\it a}) acosh({\it a}) atanh({\it a})&inverse hyperbolic trig
+% sin ({\it a}) cos({\it a}) tan({\it a})&trigonometric functions\cr
+% asin ({\it a}) acos({\it a}) atan({\it a})&inverse trigonometric functions\cr
+% sinh ({\it a}) cosh({\it a}) tanh({\it a})&hyperbolic trig functions\cr
+% asinh ({\it a}) acosh({\it a}) atanh({\it a})&inverse hyperbolic trig
 % functions\cr\cr 
 
 \sec Linear Algebra;
 chol ({\it a})&Cholesky factorization\cr
 det ({\it a})&compute the determinant of a matrix\cr
 eig ({\it a})&eigenvalues and eigenvectors\cr
 expm ({\it a})&compute the exponential of a matrix\cr
 hess ({\it a})&compute Hessenberg decomposition\cr
