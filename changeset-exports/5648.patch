# HG changeset patch
# User dbateman
# Date 1141849058 0
#      Wed Mar 08 20:17:38 2006 +0000
# Node ID 69a4f320d95a24745627f532094249b0e3ad8cee
# Parent  9e3a2d1e5e725d2cd58604bc22cc7c4f9ac0a6d1
[project @ 2006-03-08 20:17:37 by dbateman]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,16 @@
+2006-03-08  David Bateman  <dbateman@free.fr>
+
+	* configure.in: Update the test for CXSPARSE for new upstream release.
+	(OCTAVE_VERSION, OCTAVE_HOSTTYPE, OCTAVE_HOME,TEXINFO_UMFPACK, 
+	TEXINFO_COLAMD, TEXINFO_CHOLMOD): New variables for texinfo 
+	documentation.
+	(AC_CONFIG_FILES): Add doc/conf.texi and doc/interpreter/images/Makefile.
+	
 2006-03-02  Kurt Hornik  <Kurt.Hornik@wu-wien.ac.at>
 
 	* emacs/octave-mod.el (octave-indent-for-comment): Make the code
 	match the comments.
 
 2006-03-02  John W. Eaton  <jwe@octave.org>
 
 	* octMakefile.in (ALL_SUBDIRS): Delete.
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -24,17 +24,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT
-AC_REVISION($Revision: 1.500 $)
+AC_REVISION($Revision: 1.501 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -413,16 +413,27 @@ case "$canonical_host_type" in
   *-*-linux*)
     AC_CHECK_LIB(m, sin, , , -lc)
   ;;
   *)
     AC_CHECK_LIB(m, sin)
   ;;
 esac
 
+### Extract versioning information from src/version.h, etc
+AC_MSG_CHECKING(for octave version)
+OCTAVE_VERSION=`cat src/version.h | grep "^#define OCTAVE_VERSION" | \
+  sed -e 's/^.*OCTAVE_VERSION \"//' -e 's/\"//'`
+AC_MSG_RESULT($OCTAVE_VERSION)
+AC_SUBST(OCTAVE_VERSION)
+OCTAVE_HOME=$prefix
+AC_SUBST(OCTAVE_HOME)
+OCTAVE_HOSTTYPE=$canonical_host_type
+AC_SUBST(OCTAVE_HOSTTYPE)
+
 ### Check for pcre/regex library.
 AC_SUBST(REGEX_LIBS)
 WITH_PCRE_CONFIG=no
 AC_CHECK_HEADER(pcre.h, WITH_PCRE=yes, WITH_PCRE=no)
 if test $WITH_PCRE = no ; then
   AC_CHECK_PROG(WITH_PCRE_CONFIG, pcre-config, yes, no)
   if test $WITH_PCRE_CONFIG = yes ; then
     WITH_PCRE=yes
@@ -784,47 +795,51 @@ if test "$with_umfpack" = yes && test "$
             UMFPACK_LIBS="-lumfpack -lcblas"; with_umfpack=yes], [], $AMD_LIBS -lcblas $BLAS_LIBS)], $AMD_LIBS $BLAS_LIBS $FLIBS)], $AMD_LIBS)
 
     if test "$with_umfpack" = yes; then
       AC_DEFINE(HAVE_UMFPACK, 1, [Define if the UMFPACK library is used.])
       OLD_LIBS=$LIBS
       LIBS="$LIBS $UMFPACK_LIBS $AMD_LIBS $BLAS_LIBS $FLIBS"
       OCTAVE_UMFPACK_SEPERATE_SPLIT
       LIBS=$OLD_LIBS
+      TEXINFO_UMFPACK="@set HAVE_UMFPACK"
       warn_umfpack=
     fi
     break])
 fi
 
 if test -n "$warn_umfpack"; then
   AC_MSG_WARN($warn_umfpack)
 fi
+AC_SUBST(TEXINFO_UMFPACK)
 
 COLAMD_LIBS=
 AC_SUBST(COLAMD_LIBS)
 
 AC_ARG_WITH(colamd,
   [  --without-colamd        don't use COLAMD, disable some sparse functionality],
   with_colamd=$withval, with_colamd=yes)
 
 if test "$with_colamd" = yes; then
   warn_colamd="COLAMD not found. This will result in some lack of functionality for sparse matrices."
   with_colamd=no
   AC_CHECK_HEADERS([ufsparse/colamd.h colamd/colamd.h colamd.h], [
     AC_CHECK_LIB(colamd, colamd, [COLAMD_LIBS="-lcolamd"; with_colamd=yes])
     if test "$with_colamd" = yes; then
       AC_DEFINE(HAVE_COLAMD, 1, [Define if the COLAMD library is used.])
+      TEXINFO_COLAMD="@set HAVE_COLAMD"
       warn_colamd=
     fi
     break])
 fi 
 
 if test -n "$warn_colamd"; then
   AC_MSG_WARN($warn_colamd)
 fi
+AC_SUBST(TEXINFO_COLAMD)
 
 CCOLAMD_LIBS=
 AC_SUBST(CCOLAMD_LIBS)
 
 AC_ARG_WITH(ccolamd,
   [  --without-ccolamd       don't use CCOLAMD, disable some sparse functionality],
   with_ccolamd=$withval, with_ccolamd=yes)
 
@@ -875,37 +890,39 @@ if test "$with_cholmod" = yes && test "$
         AC_CHECK_LIB(cholmod, cholmod_start, [CHOLMOD_LIBS="-lcholmod -cblas"; 
 	  with_cholmod=yes], [],
           $AMD_LIBS $COLAMD_LIBS $CCOLAMD_LIBS $BLAS_LIBS $FLIBS)],
 	$AMD_LIBS $COLAMD_LIBS $CCOLAMD_LIBS $BLAS_LIBS $FLIBS)
     fi
 
     if test "$with_cholmod" = yes; then
       AC_DEFINE(HAVE_CHOLMOD, 1, [Define if the CHOLMOD library is used.])
+      TEXINFO_CHOLMOD="@set HAVE_CHOLMOD"
       warn_cholmod=
     fi
     break])
 fi 
 
 if test -n "$warn_cholmod"; then
   AC_MSG_WARN($warn_cholmod)
 fi
+AC_SUBST(TEXINFO_CHOLMOD)
 
 CXSPARSE_LIBS=
 AC_SUBST(CXSPARSE_LIBS)
 
 AC_ARG_WITH(cxsparse,
-  [  --without-cxsparse        don't use CXSparse, disable some sparse functionality],
+  [  --without-cxsparse       don't use CXSparse, disable some sparse functionality],
   with_cxsparse=$withval, with_cxsparse=yes)
 
 if test "$with_cxsparse" = yes; then
   warn_cxsparse="CXSparse not found. This will result in some lack of functionality for sparse matrices."
   with_cxsparse=no
-  AC_CHECK_HEADERS([ufsparse/cxs.h cxsparse/cxs.h cxs.h], [
-    AC_CHECK_LIB(cxsparse, cs_sqr_di, [CXSPARSE_LIBS="-lcxsparse"; with_cxsparse=yes])
+  AC_CHECK_HEADERS([ufsparse/cs.h cxsparse/cs.h cs.h], [
+    AC_CHECK_LIB(cxsparse, cs_di_sqr, [CXSPARSE_LIBS="-lcxsparse"; with_cxsparse=yes])
     if test "$with_cxsparse" = yes; then
       AC_DEFINE(HAVE_CXSPARSE, 1, [Define if the CXSparse library is used.])
       warn_cxsparse=
     fi
     break])
 fi
 
 if test -n "$warn_cxsparse"; then
@@ -1785,20 +1802,20 @@ typedef int sig_atomic_t;
 #endif
 
 #include "oct-types.h"
 ])
 
 ### Do the substitutions in all the Makefiles.
 
 AC_CONFIG_FILES([Makefile octMakefile Makeconf test/Makefile \
-  dlfcn/Makefile doc/Makefile doc/faq/Makefile \
-  doc/interpreter/Makefile doc/liboctave/Makefile \
-  doc/refcard/Makefile emacs/Makefile examples/Makefile \
-  liboctave/Makefile liboctave/oct-types.h \
+  dlfcn/Makefile doc/Makefile doc/conf.texi doc/faq/Makefile \
+  doc/interpreter/Makefile doc/interpreter/images/Makefile \
+  doc/liboctave/Makefile doc/refcard/Makefile emacs/Makefile \
+  examples/Makefile liboctave/Makefile liboctave/oct-types.h \
   src/Makefile libcruft/Makefile libcruft/Makerules \
   libcruft/amos/Makefile libcruft/blas/Makefile \
   libcruft/daspk/Makefile libcruft/dasrt/Makefile 
   libcruft/dassl/Makefile libcruft/fftpack/Makefile \
   libcruft/lapack/Makefile libcruft/minpack/Makefile \
   libcruft/misc/Makefile libcruft/odepack/Makefile \
   libcruft/ordered-qz/Makefile libcruft/quadpack/Makefile \
   libcruft/ranlib/Makefile libcruft/slatec-fn/Makefile \
diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,21 @@
+2006-03-08  David Bateman  <dbateman@free.fr>
+
+	* conf.texi: Remove.
+	* conf.texi.in: New file, for autoconf'ed version of conf.texi.
+	* Makefile.in: replace conf.texi with conf.texi.in in DISTFILES
+	* interpreter/Makefile.in: build in subdir IMAGEDIR, add stamps for
+	image files. Copy png-files to HTML directory. Build pdf files from
+	eps files using epsffit, gs, grep, basename, head and awk.
+	* octave.texi: Update sparse sub-sections.
+	* sparse.txi: Updates for current state of sparse code.
+	* interpreter/images/Makefile.in: New file.
+	* interpreter/images/sparseimages.m: New file to build sparse images.
+
 2006-03-07  David Bateman  <dbateman@free.fr>
 
 	* liboctave/dae.texi, liboctave/factor.texi, liboctave/nleqn.texi,
 	liboctave/quad.texi, liboctave/matvec.texi, liboctave/nlfunc.texi,
 	liboctave/diffeq.texi, liboctave/array.texi, liboctave/range.texi,
 	liboctave/optim.texi: Fix some syntax problems for texinfo.tex 4.8.
 
 2006-03-06  Keith Goodman  <kwgoodman@gmail.com>
diff --git a/doc/Makefile.in b/doc/Makefile.in
--- a/doc/Makefile.in
+++ b/doc/Makefile.in
@@ -15,17 +15,17 @@ VPATH = @srcdir@
 include $(TOPDIR)/Makeconf
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 
 SOURCES =
 
-DISTFILES = Makefile.in ChangeLog conf.texi texinfo.tex 
+DISTFILES = Makefile.in ChangeLog conf.texi.in texinfo.tex 
 
 SUBDIRS = faq interpreter liboctave refcard
 
 DISTSUBDIRS = $(SUBDIRS)
 
 all: $(SUBDIRS)
 .PHONY: all
 
diff --git a/doc/conf.texi b/doc/conf.texi
deleted file mode 100644
--- a/doc/conf.texi
+++ /dev/null
@@ -1,7 +0,0 @@
-@c Copyright (C) 1996, 1997 John W. Eaton
-@c This is part of the Octave manual.
-@c For copying conditions, see the file gpl.texi.
-
-@set VERSION 2.1.x
-@set OCTAVEHOME /usr/local
-@set TARGETHOSTTYPE i586-pc-linux-gnu
diff --git a/doc/conf.texi.in b/doc/conf.texi.in
new file mode 100644
--- /dev/null
+++ b/doc/conf.texi.in
@@ -0,0 +1,10 @@
+@c Copyright (C) 1996, 1997 John W. Eaton
+@c This is part of the Octave manual.
+@c For copying conditions, see the file gpl.texi.
+
+@set VERSION @OCTAVE_VERSION@
+@set OCTAVEHOME @OCTAVE_HOME@
+@set TARGETHOSTTYPE @OCTAVE_HOSTTYPE@
+@TEXINFO_COLAMD@
+@TEXINFO_CHOLMOD@
+@TEXINFO_UMFPACK@
diff --git a/doc/interpreter/Makefile.in b/doc/interpreter/Makefile.in
--- a/doc/interpreter/Makefile.in
+++ b/doc/interpreter/Makefile.in
@@ -13,16 +13,19 @@ top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 
 include $(TOPDIR)/Makeconf
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 
+IMAGEDIR = images
+STAMPS = stamp-png stamp-eps stamp-pdf stamp-txt
+
 SUB_SOURCE := arith.txi audio.txi basics.txi bugs.txi \
 	container.txi control.txi cp-idx.txi data.txi \
 	debug.txi diffeq.txi emacs.txi errors.txi eval.txi \
 	expr.txi finance.txi fn-idx.txi func.txi gpl.txi \
 	grammar.txi image.txi install.txi intro.txi io.txi \
 	linalg.txi matrix.txi nonlin.txi numbers.txi \
 	op-idx.txi optim.txi plot.txi poly.txi preface.txi \
 	quad.txi quaternion.txi set.txi signal.txi sparse.txi stats.txi \
@@ -77,48 +80,69 @@ scripts-DOCSTRINGS:
 
 %.texi : %.txi
 	@echo making $@ from $<
 	@./munge-texi \
 	  -d $(TOPDIR)/src/DOCSTRINGS \
 	  -d $(TOPDIR)/scripts/DOCSTRINGS < $< > $@.t
 	@$(top_srcdir)/move-if-change $@.t $@
 
-octave.info: $(TEXINFO)
-	-$(MAKEINFO) -I$(srcdir) -I$(srcdir)/.. $<
+octave.info: stamp-txt $(TEXINFO)
+	-$(MAKEINFO) -I$(srcdir) -I$(srcdir)/.. $(MAIN_TEXINFO)
 
-octave.dvi: $(TEXINFO)
-	-TEXINPUTS="$(srcdir):$(srcdir)/..:$(TEXINPUTS):" $(TEXI2DVI) $<
+octave.dvi: stamp-eps $(TEXINFO)
+	-TEXINPUTS="$(srcdir):$(srcdir)/..:$(TEXINPUTS):" $(TEXI2DVI) $(MAIN_TEXINFO)
 
 octave.ps: octave.dvi
 	-dvips -o $@ $<
 
-octave.pdf: $(TEXINFO)
-	-TEXINPUTS="$(srcdir):$(srcdir)/..:$(TEXINPUTS):" $(TEXI2PDF) $<
+octave.pdf: stamp-pdf $(TEXINFO)
+	-TEXINPUTS="$(srcdir):$(srcdir)/..:$(TEXINPUTS):" $(TEXI2PDF) $(MAIN_TEXINFO)
 
 ../../INSTALL.OCTAVE: install.texi
 	rm -f INSTALL
 	-$(MAKEINFO) -D INSTALLONLY \
 	  --no-validate --no-headers --no-split --output INSTALL \
 	  -I$(srcdir) -I$(srcdir)/.. $<
 	mv INSTALL ../../INSTALL.OCTAVE
 
 ../../BUGS: bugs.texi
 	rm -f BUGS
 	-$(MAKEINFO) -D BUGSONLY \
 	  --no-validate --no-headers --no-split --output BUGS \
 	  -I$(srcdir) -I$(srcdir)/.. $<
 	mv BUGS ../../BUGS
 
-HTML/index.html: $(TEXINFO)
-	-$(MAKEINFO) --html --ifinfo --output=HTML -I . -I $(srcdir)/.. $<
+HTML/index.html: stamp-png $(TEXINFO)
+	$(INSTALL_DATA) *.png ./HTML
+	-$(MAKEINFO) --html --ifinfo --output=HTML -I . -I $(srcdir)/.. $(MAIN_TEXINFO)
 
 check: all
 .PHONY: check
 
+stamp-png:
+	make -C $(IMAGEDIR) png
+	touch $@
+
+stamp-eps:
+	make -C $(IMAGEDIR) eps
+	touch $@
+
+stamp-pdf: stamp-eps
+	for F in $(wildcard *.eps); do \
+	  G=`basename $$F .eps`.pdf; \
+	  gs -dBATCH -dEPSCrop -dNOPAUSE -q -sDEVICE=pdfwrite \
+	    -sOutputFile=$$G $$F; \
+	done
+	touch $@
+
+stamp-txt:
+	make -C $(IMAGEDIR) txt
+	touch $@
+
 install install-strip: all
 	$(top_srcdir)/mkinstalldirs $(DESTDIR)$(man1dir) $(DESTDIR)$(infodir)
 	@if test -d $(DESTDIR)$(man1dir); then \
 	  for f in $(MAN_BASE); do \
 	    rm -f $(DESTDIR)$(man1dir)/$$f$(man1ext); \
 	    echo "installing $(srcdir)/$$f.1 in $(DESTDIR)$(man1dir)"; \
 	    $(INSTALL_DATA) $(srcdir)/$$f.1 $(DESTDIR)$(man1dir)/$$f$(man1ext); \
 	  done ; \
@@ -170,17 +194,18 @@ spell: $(SPELL)
 .PHONY: spell
 
 mostlyclean clean:
 	rm -f octave.cp octave.fn octave.in \
 	octave.ky octave.op octave.pg octave.rd octave.tp octave.vr \
 	octave.cps octave.fns octave.ins octave.kys octave.ops \
 	octave.pgs octave.rds octave.tps octave.vrs octave.aux \
 	octave.log octave.toc \
-	munge-texi$(BUILD_EXEEXT) munge-texi.o
+	munge-texi$(BUILD_EXEEXT) munge-texi.o $(STAMPS) \
+	*.eps *.png *.txt *.pdf
 .PHONY: mostlyclean clean
 
 distclean: clean
 	rm -f Makefile 
 .PHONY: distclean
 
 maintainer-clean: distclean clean-texi
 	rm -f tags TAGS $(FORMATTED)
diff --git a/doc/interpreter/images/Makefile.in b/doc/interpreter/images/Makefile.in
new file mode 100644
--- /dev/null
+++ b/doc/interpreter/images/Makefile.in
@@ -0,0 +1,68 @@
+TOPDIR = ../../..
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+
+include $(TOPDIR)/Makeconf
+
+SOURCES = $(wildcard *.m)
+
+FUNCTIONS = $(SOURCES:.m=)
+
+DISTFILES = Makefile.in $(SOURCES)
+
+OCTAVE_BINARY = $(TOPDIR)/src/octave
+
+OCTAVE_SCRIPT_PATH = .//:$(TOPDIR)/src//:$(TOPDIR)/scripts//
+
+ifeq ($(SHARED_LIBS), true)
+  OCTAVE_LD_LIBRARY_PATH = $(TOPDIR)/src:$(TOPDIR)/liboctave:$(TOPDIR)/libcruft
+  ifeq ($(@library_path_var@),)
+    XLD_LIBRARY_PATH = $(OCTAVE_LD_LIBRARY_PATH)
+  else
+    XLD_LIBRARY_PATH = $(OCTAVE_LD_LIBRARY_PATH):$(@library_path_var@)
+  endif
+  SET_LD_LIBRARY_PATH = @library_path_var@="$(XLD_LIBRARY_PATH)"
+endif
+
+all: png eps pdf txt
+.PHONY: all
+
+png eps pdf txt:
+	for F in $(FUNCTIONS); do \
+	  $(SET_LD_LIBRARY_PATH) $(OCTAVE_BINARY) \
+	    -f -q -H -p $(OCTAVE_SCRIPT_PATH) --eval "$$F ('../','$@')"; \
+	done
+.PHONY: png eps pdf txt
+
+install install-strip:
+
+.PHONY: install install-strip
+
+uninstall:
+.PHONY: uninstall
+
+tags: $(SOURCES)
+	ctags $(SOURCES)
+
+TAGS: $(SOURCES)
+	etags $(SOURCES)
+
+clean:
+.PHONY: clean
+
+mostlyclean:
+.PHONY: mostlyclean
+
+distclean: clean
+	rm -f Makefile
+.PHONY: distclean
+
+maintainer-clean: distclean
+	rm -f tags TAGS
+.PHONY: maintainer-clean
+
+dist:
+	ln $(DISTFILES) ../../../`cat ../../../.fname`/doc/interpreter/images
+.PHONY: dist
diff --git a/doc/interpreter/images/sparseimages.m b/doc/interpreter/images/sparseimages.m
new file mode 100644
--- /dev/null
+++ b/doc/interpreter/images/sparseimages.m
@@ -0,0 +1,177 @@
+function sparseimages(dirc,typ)
+  plot(1) # FIXME bypass 2.9.4 bug!!
+  if (strcmp(typ,"txt"))
+    txtimages(15,dirc,typ);
+  else
+    otherimages(200,dirc,typ);
+    gplotimages("gplot",dirc,typ);
+    femimages("grid",dirc,typ);
+  endif
+endfunction
+
+function gplotimages(nm,dirc,typ)
+  A = sparse([2,6,1,3,2,4,3,5,4,6,1,5],
+	     [1,1,2,2,3,3,4,4,5,5,6,6],1,6,6);
+  xy = [0,4,8,6,4,2;5,0,5,7,5,7]';
+  gplot(A,xy)
+  print(strcat(dirc,filesep,nm,".",typ),strcat("-d",typ))
+endfunction
+
+function txtimages(n,dirc,typ)
+  a = 10*speye(n) + sparse(1:n,ceil([1:n]/2),1,n,n) + ...
+      sparse(ceil([1:n]/2),1:n,1,n,n);
+  printsparse(a,strcat(dirc,filesep,"spmatrix.",typ));
+  if (!isempty(findstr(octave_config_info ("DEFS"),"HAVE_COLAMD")) &&
+      !isempty(findstr(octave_config_info ("DEFS"),"HAVE_CHOLMOD")))
+    r1 = chol(a);
+    printsparse(r1,strcat(dirc,filesep,"spchol.",typ));
+    [r2,p2,q2]=chol(a);
+    printsparse(r2,strcat(dirc,filesep,"spcholperm.",typ));
+    printf("Text NNZ: Matrix %d, Chol %d, PermChol %d\n",nnz(a),nnz(r1),nnz(r2));
+  endif
+endfunction
+
+function otherimages(n,dirc,typ)
+  a = 10*speye(n) + sparse(1:n,ceil([1:n]/2),1,n,n) + ...
+      sparse(ceil([1:n]/2),1:n,1,n,n);
+  spy(a);
+  axis("ij")
+  print(strcat(dirc,filesep,"spmatrix.",typ),strcat("-d",typ))
+  if (!isempty(findstr(octave_config_info ("DEFS"),"HAVE_COLAMD")) &&
+      !isempty(findstr(octave_config_info ("DEFS"),"HAVE_CHOLMOD")))
+    r1 = chol(a);
+    spy(r1);
+    axis("ij")
+    print(strcat(dirc,filesep,"spchol.",typ),strcat("-d",typ))
+    [r2,p2,q2]=chol(a);
+    spy(r2);
+    axis("ij")
+    print(strcat(dirc,filesep,"spcholperm.",typ),strcat("-d",typ))
+    printf("Image NNZ: Matrix %d, Chol %d, PermChol %d\n",nnz(a),nnz(r1),nnz(r2));
+    axis("xy")
+  endif
+endfunction
+
+function printsparse(a,nm)
+  fid = fopen (nm,"wt");
+  for i = 1:size(a,1)
+    if (rem(i,5) == 0)
+      fprintf (fid,"         %2d - ", i);
+    else
+      fprintf (fid,"            | ");
+    endif
+    for j = 1:size(a,2)
+      if (a(i,j) == 0)
+	fprintf(fid,"  ")
+      else
+	fprintf(fid," *")
+      endif
+    endfor
+    fprintf(fid,"\n")
+  endfor
+  fprintf(fid,"            |-");
+  for j=1:size(a,2)
+    if (rem(j,5)==0)
+      fprintf(fid,"-|");
+    else
+      fprintf(fid,"--");
+    endif
+  endfor
+  fprintf(fid,"\n")
+  fprintf(fid,"              ");
+  for j=1:size(a,2)
+    if (rem(j,5)==0)
+      fprintf(fid,"%2d",j);
+    else
+      fprintf(fid,"  ");
+    endif
+  endfor
+  fclose(fid);
+endfunction
+
+function femimages (nm,dirc,typ)
+  if (!isempty(findstr(octave_config_info ("DEFS"),"HAVE_COLAMD")) &&
+      !isempty(findstr(octave_config_info ("DEFS"),"HAVE_CHOLMOD")) &&
+      !isempty(findstr(octave_config_info ("DEFS"),"HAVE_UMFPACK")))
+    ## build a rectangle
+    node_y = [1;1.2;1.5;1.8;2]*ones(1,11);
+    node_x = ones(5,1)*[1,1.05,1.1,1.2,1.3,1.5,1.7,1.8,1.9,1.95,2];
+    nodes = [node_x(:), node_y(:)];
+
+    [h,w] = size(node_x);
+    elems = [];
+    for idx = 1:w-1
+      widx = (idx-1)*h;
+      elems = [elems; widx+[(1:h-1);(2:h);h+(1:h-1)]']; 
+      elems = [elems; widx+[(2:h);h+(2:h);h+(1:h-1)]']; 
+    endfor
+
+    E = size(elems,1);  #No. of elements
+    N = size(nodes,1);  #No. of elements
+    D = size(elems,2);  #dimentions+1
+
+    ## Plot FEM Geometry
+    elemx = elems(:,[1,2,3,1])';
+    xelems = reshape( nodes(elemx, 1), 4, E);
+    yelems = reshape( nodes(elemx, 2), 4, E);
+
+    ## Set element conductivity
+    conductivity = [1*ones(1,16),2*ones(1,48),1*ones(1,16)];
+
+    ## Dirichlet boundary conditions
+    D_nodes = [1:5, 51:55]; 
+    D_value = [10*ones(1,5), 20*ones(1,5)]; 
+  
+    ## Neumann boundary conditions
+    ## Note that N_value must be normalized by the boundary
+    ##   length and element conductivity
+    N_nodes = [];
+    N_value = [];
+
+    ## Calculate connectivity matrix
+    C = sparse((1:D*E), reshape(elems',D*E,1),1, D*E, N);
+
+    ## Calculate stiffness matrix
+    Siidx = floor([0:D*E-1]'/D)*D*ones(1,D) + ones(D*E,1)*(1:D) ;
+    Sjidx = [1:D*E]'*ones(1,D);
+    Sdata = zeros(D*E,D);
+    dfact = prod(2:(D-1));
+    for j = 1:E
+      a = inv([ ones(D,1), nodes( elems(j,:), : ) ]);
+      const = conductivity(j)*2/dfact/abs(det(a));
+      Sdata(D*(j-1)+(1:D),:)= const * a(2:D,:)'*a(2:D,:);
+    endfor
+
+    ## Element-wise system matrix
+    SE = sparse(Siidx,Sjidx,Sdata);
+    ## Global system matrix
+    S = C'* SE *C;
+
+    ## Set Dirichlet boundary
+    V = zeros(N,1);
+    V(D_nodes) = D_value;
+    idx = 1:N;
+    idx(D_nodes) = [];
+
+    ## Set Neumann boundary
+    Q = zeros(N,1);
+    Q(N_nodes) = N_value; # FIXME
+
+    V(idx) = S(idx,idx)\( Q(idx) - S(idx,D_nodes)*V(D_nodes) );
+
+    velems = reshape( V(elemx), 4, E);
+
+    sz = size(xelems,2);
+    ## FIXME How can I do this without a gnuplot specific commands? plot3 anyone?
+    unwind_protect
+      __gnuplot_set__  parametric;
+      __gnuplot_raw__ ("set nohidden3d;\n");
+      tmp = [([xelems; NaN*ones(1,sz)])(:), ([yelems; NaN*ones(1,sz)])(:), ([velems; NaN*ones(1,sz)])(:)];
+      __gnuplot_splot__(tmp);
+      __gnuplot_raw__ ("set view 80,10;\n")
+      print(strcat(dirc,filesep,nm,".",typ),strcat("-d",typ))
+    unwind_protect_cleanup
+      __gnuplot_set__ noparametric; 
+    end_unwind_protect
+  endif
+endfunction
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -383,19 +383,19 @@ Linear Algebra
 
 * Basic Matrix Functions::      
 * Matrix Factorizations::       
 * Functions of a Matrix::       
 
 Sparse Matrices
 
 * Basics::
-* Graph Theory::
 * Sparse Linear Algebra::
 * Iterative Techniques::
+* Real Life Example::
 * Oct-Files::
 * Function Reference::
 
 Quadrature
 
 * Functions of One Variable::   
 * Orthogonal Collocation::      
 
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -1,25 +1,32 @@
 @c Copyright (C) 2004, 2005 David Bateman
 @c This is part of the Octave manual.
 @c For copying conditions, see the file gpl.texi.
 
+@ifhtml
+@set htmltex
+@end ifhtml
+@iftex
+@set htmltex
+@end iftex
+
 @node Sparse Matrices 
 @chapter Sparse Matrices
 
 @menu
 * Basics:: The Creation and Manipulation of Sparse Matrices
-* Graph Theory:: Graphs are their use with Sparse Matrices
 * Sparse Linear Algebra:: Linear Algebra on Sparse Matrices
 * Iterative Techniques:: Iterative Techniques applied to Sparse Matrices
+* Real Life Example:: Real Life Example of the use of Sparse Matrices
 * Oct-Files:: Using Sparse Matrices in Oct-files
 * Function Reference:: Documentation from the Specific Sparse Functions
 @end menu
 
-@node Basics, Graph Theory, Sparse Matrices, Sparse Matrices
+@node Basics, Sparse Linear Algebra, Sparse Matrices, Sparse Matrices
 @section The Creation and Manipulation of Sparse Matrices
 
 The size of mathematical problems that can be treated at any particular
 time is generally limited by the available computing resources. Both,
 the speed of the computer and its available memory place limitation on
 the problem size. 
 
 There are many classes of mathematical problems which give rise to
@@ -31,71 +38,69 @@ matrix, but it also means that operation
 take advantage of the a-priori knowledge of the positions of the
 non-zero elements to accelerate their calculations.
 
 A matrix type that stores only the non-zero elements is generally called
 sparse. It is the purpose of this document to discuss the basics of the
 storage and creation of sparse matrices and the fundamental operations
 on them.
 
-THIS DOCUMENT STILL HAS LARGE BLANKS. PLEASE FILL THEM IN. LOOK FOR
-THE TAG "WRITE ME"
-
 @menu
 * Storage:: Storage of Sparse Matrices
 * Creation:: Creating Sparse Matrices
+* Information:: Finding out Information about Sparse Matrices
 * Operators and Functions:: Basic Operators and Functions on Sparse Matrices
-* Information:: Finding out Information about Sparse Matrices
 @end menu
 
 @node Storage, Creation, Basics, Basics
 @subsection Storage of Sparse Matrices
 
 It is not strictly speaking necessary for the user to understand how
 sparse matrices are stored. However, such an understanding will help
 to get an understanding of the size of sparse matrices. Understanding
 the storage technique is also necessary for those users wishing to 
 create their own oct-files. 
 
 There are many different means of storing sparse matrix data. What all
-of the methods have in common is that they attempt to reduce the compelxity
+of the methods have in common is that they attempt to reduce the complexity
 and storage given a-priori knowledge of the particular class of problems
 that will be solved. A good summary of the available techniques for storing
 sparse matrix is given by Saad @footnote{Youcef Saad "SPARSKIT: A basic toolkit
 for sparse matrix computation", 1994,
 @url{ftp://ftp.cs.umn.edu/dept/sparse/SPARSKIT2/DOC/paper.ps}}.
 With full matrices, knowledge of the point of an element of the matrix
 within the matrix is implied by its position in the computers memory. 
 However, this is not the case for sparse matrices, and so the positions
 of the non-zero elements of the matrix must equally be stored. 
 
 An obvious way to do this is by storing the elements of the matrix as
 triplets, with two elements being their position in the array 
 (rows and column) and the third being the data itself. This is conceptually
 easy to grasp, but requires more storage than is strictly needed.
 
-The storage technique used within Octave is compressed column
+The storage technique used within Octave is the compressed column
 format.  In this format the position of each element in a row and the
 data are stored as previously. However, if we assume that all elements
 in the same column are stored adjacent in the computers memory, then
 we only need to store information on the number of non-zero elements
 in each column, rather than their positions. Thus assuming that the
 matrix has more non-zero elements than there are columns in the
 matrix, we win in terms of the amount of memory used.
 
 In fact, the column index contains one more element than the number of
 columns, with the first element always being zero. The advantage of
-this is a simplication in the code, in that their is no special case
+this is a simplification in the code, in that their is no special case
 for the first or last columns. A short example, demonstrating this in
 C is.
 
 @example
   for (j = 0; j < nc; j++)
     for (i = cidx (j); i < cidx(j+1); i++)
-       printf ("non-zero element (%i,%i) is %d\n", ridx(i), j, data(i));
+       printf ("non-zero element (%i,%i) is %d\n", 
+	   ridx(i), j, data(i));
 @end example
 
 A clear understanding might be had by considering an example of how the
 above applies to an example matrix. Consider the matrix
 
 @example
 @group
     1   2   0  0
@@ -123,35 +128,38 @@ contents of these three vectors for the 
 @group
   @var{cidx} = [0, 1, 2, 2, 4]
   @var{ridx} = [0, 0, 1, 2]
   @var{data} = [1, 2, 3, 4]
 @end group
 @end example
 
 Note that this is the representation of these elements with the first row
-and column assumed to start at zero. Thus the number of elements in the 
+and column assumed to start at zero, while in Octave itself the row and 
+column indexing starts at one. Thus the number of elements in the 
 @var{i}-th column is given by @code{@var{cidx} (@var{i} + 1) - 
 @var{cidx} (@var{i})}.
 
-It should be noted that compressed row formats are equally possible. However,
-in the context of mixed operations between mixed sparse and dense matrices,
-it makes sense that the elements of the sparse matrices are in the same
-order as the dense matrices. Octave stores dense matrices in column
-major ordering, and so sparse matrices are equally stored in this manner.
+Although Octave uses a compressed column format, it should be noted
+that compressed row formats are equally possible. However, in the
+context of mixed operations between mixed sparse and dense matrices,
+it makes sense that the elements of the sparse matrices are in the
+same order as the dense matrices. Octave stores dense matrices in
+column major ordering, and so sparse matrices are equally stored in
+this manner.
 
 A further constraint on the sparse matrix storage used by Octave is that 
 all elements in the rows are stored in increasing order of their row
 index, which makes certain operations faster. However, it imposes
 the need to sort the elements on the creation of sparse matrices. Having
 dis-ordered elements is potentially an advantage in that it makes operations
 such as concatenating two sparse matrices together easier and faster, however
 it adds complexity and speed problems elsewhere.
 
-@node Creation, Operators and Functions, Storage, Basics
+@node Creation, Information, Storage, Basics
 @subsection Creating Sparse Matrices
 
 There are several means to create sparse matrix.
 
 @table @asis
 @item Returned from a function
 There are many functions that directly return sparse matrices. These include
 @dfn{speye}, @dfn{sprand}, @dfn{spdiag}, etc.
@@ -189,17 +197,17 @@ that corresponds to this. For example
 @example
 s = diag (sparse(randn(1,n)), -1);
 @end example
 
 creates a sparse (@var{n}+1)-by-(@var{n}+1) sparse matrix with a single
 diagonal defined.
 
 The recommended way for the user to create a sparse matrix, is to create 
-two vectors contain the row and column index of the data and a third
+two vectors containing the row and column index of the data and a third
 vector of the same size containing the data to be stored. For example
 
 @example
  function x = foo (r, j)
   idx = randperm (r);
   x = ([zeros(r-2,1); rand(2,1)])(idx);
  endfunction
 
@@ -241,48 +249,211 @@ s = spconvert ([1 2 3 4; 1 3 4 4; 1 2 3 
 An example of creating and filling a matrix might be
 
 @example
 k = 5;
 nz = r * k;
 s = spalloc (r, c, nz)
 for j = 1:c
   idx = randperm (r);
-  s (:, j) = [zeros(r - k, 1); rand(k, 1)] (idx);
+  s (:, j) = [zeros(r - k, 1); ...
+        rand(k, 1)] (idx);
 endfor
 @end example
 
 It should be noted, that due to the way that the Octave
 assignment functions are written that the assignment will reallocate
 the memory used by the sparse matrix at each iteration of the above loop. 
 Therefore the @dfn{spalloc} function ignores the @var{nz} argument and 
 does not preassign the memory for the matrix. Therefore, it is vitally
-important that code using to above structure should be as vectorized
-much as possible to minimize the number of assignments and reduce the
+important that code using to above structure should be vectorized
+as much as possible to minimize the number of assignments and reduce the
 number of memory allocations.
 
 The above problem can be avoided in oct-files. However, the
 construction of a sparse matrix from an oct-file is more complex than
 can be discussed in this brief introduction, and you are referred to
 section @ref{Oct-Files}, to have a full description of the techniques
 involved.
 
-@node Operators and Functions, Information, Creation, Basics
+@node Information, Operators and Functions, Creation, Basics
+@subsection Finding out Information about Sparse Matrices
+
+There are a number of functions that allow information concerning
+sparse matrices to be obtained. The most basic of these is
+@dfn{issparse} that identifies whether a particular Octave object is
+in fact a sparse matrix.
+
+Another very basic function is @dfn{nnz} that returns the number of
+non-zero entries there are in a sparse matrix, while the function
+@dfn{nzmax} returns the amount of storage allocated to the sparse
+matrix. Note that Octave tends to crop unused memory at the first
+opportunity for sparse objects. There are some cases of user created
+sparse objects where the value returned by @dfn{nzmaz} will not be
+the same as @dfn{nnz}, but in general they will give the same
+result. The function @dfn{spstats} returns some basic statistics on
+the columns of a sparse matrix including the number of elements, the
+mean and the variance of each column.
+
+When solving linear equations involving sparse matrices Octave
+determines the means to solve the equation based on the type of the
+matrix as discussed in @ref{Sparse Linear Algebra}. Octave probes the
+matrix type when the div (/) or ldiv (\) operator is first used with
+the matrix and then caches the type. However the @dfn{matrix_type}
+function can be used to determine the type of the sparse matrix prior
+to use of the div or ldiv operators. For example
+
+@example
+a = tril (sprandn(1024, 1024, 0.02), -1) ...
+    + speye(1024); 
+matrix_type (a);
+ans = Lower
+@end example
+
+show that Octave correctly determines the matrix type for lower
+triangular matrices. @dfn{matrix_type} can also be used to force
+the type of a matrix to be a particular type. For example
+
+@example
+a = matrix_type (tril (sprandn (1024, ...
+   1024, 0.02), -1) + speye(1024), 'Lower');
+@end example
+
+This allows the cost of determining the matrix type to be
+avoided. However, incorrectly defining the matrix type will result in
+incorrect results from solutions of linear equations, and so it is
+entirely the responsibility of the user to correctly identify the
+matrix type
+
+There are several graphical means of finding out information about
+sparse matrices. The first is the @dfn{spy} command, which displays
+the structure of the non-zero elements of the
+matrix. @xref{fig:spmatrix}, for an exaple of the use of
+@dfn{spy}.More advanced graphical information can be obtained with the
+@dfn{treeplot}, @dfn{etreeplot} and @dfn{gplot} commands.
+
+@float Figure,fig:spmatrix
+@ifinfo
+@example
+@include spmatrix.txt
+@end example
+@end ifinfo
+@ifset htmltex
+@image{spmatrix,8cm}
+@end ifset
+@caption{Structure of simple sparse matrix.}
+@end float
+
+One use of sparse matrices is in graph theory, where the
+interconnections between nodes is represented as an adjacency
+matrix. That is, if the i-th node in a graph is connected to the j-th
+node. Then the ij-th node (and in the case of undirected graphs the
+ji-th node) of the sparse adjacency matrix is non-zero. If each node
+is then associated with a set of co-ordinates, then the @dfn{gplot}
+command can be used to graphically display the interconnections
+between nodes.
+
+As a trivial example of the use of @dfn{gplot}, consider the example
+
+@example
+A = sparse([2,6,1,3,2,4,3,5,4,6,1,5],
+    [1,1,2,2,3,3,4,4,5,5,6,6],1,6,6);
+xy = [0,4,8,6,4,2;5,0,5,7,5,7]';
+gplot(A,xy)
+@end example
+
+which creates an adjacency matrix @code{A} where node 1 is connected
+to nodes 2 and 6, node 2 with nodes 1 and 3, etc. The co-ordinates of
+the nodes are given in the n-by-2 matrix @code{xy}.
+@ifset htmltex 
+@xref{fig:gplot}.
+
+@float Figure,fig:gplot
+@image{gplot,8cm}
+@caption{Simple use of the @dfn{gplot} command.}
+@end float
+@end ifset
+
+The dependencies between the nodes of a Cholesky factorization can be
+calculated in linear time without explicitly needing to calculate the
+Cholesky factorization by the @code{etree} command. This command
+returns the elimination tree of the matrix and can be displayed
+graphically by the command @code{treeplot(etree(A))} if @code{A} is
+symmetric or @code{treeplot(etree(A+A'))} otherwise.
+
+@node Operators and Functions, , Information, Basics
 @subsection Basic Operators and Functions on Sparse Matrices
 
 @menu
-* Functions:: Operators and Functions
+* Functions:: Sparse Functions
 * ReturnType:: The Return Types of Operators and Functions
 * MathConsiderations:: Mathematical Considerations
 @end menu
 
 @node Functions, ReturnType, Operators and Functions, Operators and Functions
-@subsubsection Operators and Functions
+@subsubsection Sparse Functions
+
+An important consideration in the use of the sparse functions of
+Octave is that many of the internal functions of Octave, such as
+@dfn{diag}, can not accept sparse matrices as an input. The sparse
+implementation in Octave therefore uses the @dfn{dispatch}
+function to overload the normal Octave functions with equivalent
+functions that work with sparse matrices. However, at any time the
+sparse matrix specific version of the function can be used by
+explicitly calling its function name. 
+
+The table below lists all of the sparse functions of Octave
+together (with possible future extensions that are currently
+unimplemented, listed last). Note that in this specific sparse forms
+of the functions are typically the same as the general versions with a
+@dfn{sp} prefix. In the table below, and the rest of this article
+the specific sparse versions of the functions are used.
+
+@table @asis
+@item Generate sparse matrices:
+  @dfn{spalloc}, @dfn{spdiags}, @dfn{speye}, @dfn{sprand}, 
+  @dfn{sprandn}, @dfn{sprandsym}
+
+@item Sparse matrix conversion:
+  @dfn{full}, @dfn{sparse}, @dfn{spconvert}, @dfn{spfind}
+
+@item Manipulate sparse matrices
+  @dfn{issparse}, @dfn{nnz}, @dfn{nonzeros}, @dfn{nzmax},
+  @dfn{spfun}, @dfn{spones}, @dfn{spy},
 
-WRITE ME
+@item Graph Theory:
+  @dfn{etree}, @dfn{etreeplot}, @dfn{gplot}, 
+  @dfn{treeplot}, (treelayout)
+
+@item Sparse matrix reordering:
+  @dfn{ccolamd}, @dfn{colamd}, @dfn{colperm}, 
+  @dfn{csymamd}, @dfn{dmperm}, @dfn{symamd}, @dfn{randperm}, (symrcm)
+
+@item Linear algebra:
+  @dfn{matrix\_type}, @dfn{spchol}, @dfn{cpcholinv}, 
+  @dfn{spchol2inv}, @dfn{spdet}, @dfn{spinv}, @dfn{spkron},
+  @dfn{splchol}, @dfn{splu}, @dfn{spqr}, (condest, eigs, normest, 
+  sprank, svds, spaugment)
+
+@item Iterative techniques:
+  @dfn{luinc}, (bicg, bicgstab, cholinc, cgs, gmres, lsqr, minres, 
+  pcg, pcr, qmr, symmlq)
+
+@item Miscellaneous:
+  @dfn{spparms}, @dfn{symbfact}, @dfn{spstats}, 
+  @dfn{spprod}, @dfn{spcumsum}, @dfn{spsum},
+  @dfn{spsumsq}, @dfn{spmin}, @dfn{spmax}, @dfn{spatan2}, 
+  @dfn{spdiag}
+@end table
+
+In addition all of the standard Octave mapper functions (ie. basic
+math functions that take a single argument) such as @dfn{abs}, etc
+can accept sparse matrices. The reader is referred to the documentation
+supplied with these functions within Octave itself for further
+details.
 
 @node ReturnType, MathConsiderations, Functions, Operators and Functions
 @subsubsection The Return Types of Operators and Functions
 
 The two basic reasons to use sparse matrices are to reduce the memory 
 usage and to not have to do calculations on zero elements. The two are
 closely related in that the computation time on a sparse matrix operator
 or function is roughly linear with the number of non-zero elements.
@@ -306,22 +477,22 @@ test the amount of memory occupied by th
 amount of storage used is larger than the amount used by the full 
 equivalent. Therefore @code{speye (2) * 1} will return a full matrix as
 the memory used is smaller for the full version than the sparse version.
 
 As all of the mixed operators and functions between full and sparse 
 matrices exist, in general this does not cause any problems. However,
 one area where it does cause a problem is where a sparse matrix is
 promoted to a full matrix, where subsequent operations would resparsify
-the matrix. Such cases as rare, but can be artificially created, for
+the matrix. Such cases are rare, but can be artificially created, for
 example @code{(fliplr(speye(3)) + speye(3)) - speye(3)} gives a full
 matrix when it should give a sparse one. In general, where such cases 
 occur, they impose only a small memory penalty.
 
-There is however one known case where this behaviour of Octave's
+There is however one known case where this behavior of Octave's
 sparse matrices will cause a problem. That is in the handling of the
 @dfn{diag} function. Whether @dfn{diag} returns a sparse or full matrix
 depending on the type of its input arguments. So 
 
 @example
  a = diag (sparse([1,2,3]), -1);
 @end example
 
@@ -360,126 +531,213 @@ is infinity, and so @code{@var{s} .^ -2}
 
 For the "./" operator @code{@var{s} ./ 2} has no problems, but 
 @code{2 ./ @var{s}} involves a large number of infinity terms as well
 and is equally a full matrix. The case of @code{@var{s} ./ @var{s}}
 involves terms like @code{0 ./ 0} which is a @code{NaN} and so this
 is equally a full matrix with the zero elements of @var{s} filled with
 @code{NaN} values.
 
-The above behaviour is consistent with full matrices, but is not 
+The above behavior is consistent with full matrices, but is not 
 consistent with sparse implementations in other products.
 
 A particular problem of sparse matrices comes about due to the fact that
 as the zeros are not stored, the sign-bit of these zeros is equally not
 stored. In certain cases the sign-bit of zero is important. For example
 
 @example
  a = 0 ./ [-1, 1; 1, -1];
  b = 1 ./ a
  @result{} -Inf            Inf
      Inf           -Inf
  c = 1 ./ sparse (a)
  @result{}  Inf            Inf
      Inf            Inf
 @end example
  
-To correct this behaviour would mean that zero elements with a negative
+To correct this behavior would mean that zero elements with a negative
 sign-bit would need to be stored in the matrix to ensure that their 
 sign-bit was respected. This is not done at this time, for reasons of
 efficient, and so the user is warned that calculations where the sign-bit
 of zero is important must not be done using sparse matrices.
 
-In general any function or operator used on a sparse matrix will result
-in a sparse matrix with the same or a larger number of non-zero elements
-than the original matrix. This is particularly true for the important
-case of sparse matrix factorizations.
+In general any function or operator used on a sparse matrix will
+result in a sparse matrix with the same or a larger number of non-zero
+elements than the original matrix. This is particularly true for the
+important case of sparse matrix factorizations. The usual way to
+address this is to reorder the matrix, such that its factorization is
+sparser than the factorization of the original matrix. That is the
+factorization of @code{L * U = P * S * Q} has sparser terms @code{L}
+and @code{U} than the equivalent factorization @code{L * U = S}.
+
+Several functions are available to reorder depending on the type of the
+matrix to be factorized. If the matrix is symmetric positive-definite,
+then @dfn{symamd} or @dfn{csymamd} should be used. Otherwise
+@dfn{colamd} or @dfn{ccolamd} should be used. For completeness
+the reordering functions @dfn{colperm} and @dfn{randperm} are
+also available.
+
+@xref{fig:simplematrix}, for an example of the structure of a simple 
+positive definite matrix.
 
+@float Figure,fig:simplematrix
+@ifinfo
+@example
+@include spmatrix.txt
+@end example
+@end ifinfo
+@ifset htmltex
+@image{spmatrix,8cm}
+@end ifset
+@caption{Structure of simple sparse matrix.}
+@end float
 
-Also discuss issues of fill-in. Discuss symamd etc, and mention randperm
-that is included  elsewhere in the docs...
-
-WRITE ME
+The standard Cholesky factorization of this matrix, can be
+obtained by the same command that would be used for a full
+matrix. This can be visualized with the command @code{r =
+chol(A); spy(r);}, @xref{fig:simplechol}. The original matrix
+had 
+@ifinfo
+@ifnothtml
+43
+@end ifnothtml
+@end ifinfo
+@ifset htmltex
+598
+@end ifset
+non-zero terms, while this Cholesky factorization has
+@ifinfo
+@ifnothtml
+71,
+@end ifnothtml
+@end ifinfo
+@ifset htmltex
+10200,
+@end ifset
+with only half of the symmetric matrix being stored. This
+is a significant level of fill in, and although not an issue
+for such a small test case, can represents a large overhead 
+in working with other sparse matrices.
 
-@node Information, , Operators and Functions, Basics
-@subsection Finding out Information about Sparse Matrices
+The appropriate sparsity preserving permutation of the original
+matrix is given by @dfn{symamd} and the factorization using this
+reordering can be visualized using the command @code{q = symamd(A);
+r = chol(A(q,q)); spy(r)}. This gives 
+@ifinfo
+@ifnothtml
+29
+@end ifnothtml
+@end ifinfo
+@ifset htmltex
+399
+@end ifset
+non-zero terms which is a significant improvement.
 
-Talk about the spy, spstats, nnz, spparms, etc function
-
-WRITE ME
+The Cholesky factorization itself can be used to determine the
+appropriate sparsity preserving reordering of the matrix during the
+factorization, In that case this might be obtained with three return
+arguments as r@code{[r, p, q] = chol(A); spy(r)}.
 
-@node Graph Theory, Sparse Linear Algebra, Basics, Sparse Matrices
-@section Graphs are their use with Sparse Matrices
+@ifset HAVE_CHOLMOD
+@ifset HAVE_COLAMD
+@float Figure,fig:simplechol
+@ifinfo
+@example
+@include spchol.txt
+@end example
+@end ifinfo
+@ifset htmltex
+@image{spchol,8cm}
+@end ifset
+@caption{Structure of the un-permuted Cholesky factorization of the above matrix.}
+@end float
 
-Someone who knows more about this than me should write this...
+@float Figure,fig:simplecholperm
+@ifinfo
+@example
+@include spcholperm.txt
+@end example
+@end ifinfo
+@ifset htmltex
+@image{spcholperm,8cm}
+@end ifset
+@caption{Structure of the permuted Cholesky factorization of the above matrix.}
+@end float
+@end ifset
+@end ifset
 
-WRITE ME
+In the case of an asymmetric matrix, the appropriate sparsity
+preserving permutation is @dfn{colamd} and the factorization using
+this reordering can be visualized using the command @code{q =
+colamd(A); [l, u, p] = lu(A(:,q)); spy(l+u)}.
 
-@node Sparse Linear Algebra, Iterative Techniques, Graph Theory, Sparse Matrices
+Finally, Octave implicitly reorders the matrix when using the div (/)
+and ldiv (\) operators, and so no the user does not need to explicitly
+reorder the matrix to maximize performance.
+
+@node Sparse Linear Algebra, Iterative Techniques, Basics, Sparse Matrices
 @section Linear Algebra on Sparse Matrices
 
 Octave includes a poly-morphic solver for sparse matrices, where 
 the exact solver used to factorize the matrix, depends on the properties
-of the sparse matrix itself. The cost of determining the matrix type
+of the sparse matrix itself. Generally, the cost of determining the matrix type
 is small relative to the cost of factorizing the matrix itself, but in any
 case the matrix type is cached once it is calculated, so that it is not
 re-determined each time it is used in a linear equation.
 
 The selection tree for how the linear equation is solve is
 
 @enumerate 1
-@item If the matrix is not square go to 9.
-
-@item If the matrix is diagonal, solve directly and goto 9
+@item If the matrix is diagonal, solve directly and goto 8
 
 @item If the matrix is a permuted diagonal, solve directly taking into
-account the permutations. Goto 9
+account the permutations. Goto 8
 
-@item If the matrix is banded and if the band density is less than that
-given by @code{spparms ("bandden")} continue, else goto 5.
+@item If the matrix is square, banded and if the band density is less
+than that given by @code{spparms ("bandden")} continue, else goto 4.
 
 @enumerate a
 @item If the matrix is tridiagonal and the right-hand side is not sparse 
-continue, else goto 4b.
+continue, else goto 3b.
 
 @enumerate
 @item If the matrix is hermitian, with a positive real diagonal, attempt
       Cholesky factorization using @sc{Lapack} xPTSV.
 
 @item If the above failed or the matrix is not hermitian with a positive
       real diagonal use Gaussian elimination with pivoting using 
-      @sc{Lapack} xGTSV, and goto 9.
+      @sc{Lapack} xGTSV, and goto 8.
 @end enumerate
 
 @item If the matrix is hermitian with a positive real diagonal, attempt
       Cholesky factorization using @sc{Lapack} xPBTRF.
 
 @item if the above failed or the matrix is not hermitian with a positive
       real diagonal use Gaussian elimination with pivoting using 
-      @sc{Lapack} xGBTRF, and goto 9.
+      @sc{Lapack} xGBTRF, and goto 8.
 @end enumerate
 
 @item If the matrix is upper or lower triangular perform a sparse forward
-or backward subsitution, and goto 9
+or backward substitution, and goto 8
 
 @item If the matrix is a upper triangular matrix with column permutations
 or lower triangular matrix with row permutations, perform a sparse forward 
-or backward subsitution, and goto 9
+or backward substitution, and goto 8
 
-@item If the matrix is hermitian with a real positive diagonal, attempt
+@item If the matrix is square, hermitian with a real positive diagonal, attempt
 sparse Cholesky factorization using CHOLMOD.
 
 @item If the sparse Cholesky factorization failed or the matrix is not
-hermitian with a real positive diagonal, factorize using UMFPACK.
+hermitian with a real positive diagonal, and the matrix is square, factorize 
+using UMFPACK.
 
 @item If the matrix is not square, or any of the previous solvers flags
-a singular or near singular matrix, find a minimum norm solution
-
-FIXME: QR solvers not yet written.
-
+a singular or near singular matrix, find a minimum norm solution using
+CXSPARSE@footnote{CHOLMOD, UMFPACK and CXSPARSE are written by Tim Davis
+and are available at http://www.cise.ufl.edu/research/sparse/}.
 @end enumerate
 
 The band density is defined as the number of non-zero values in the matrix
 divided by the number of non-zero values in the matrix. The banded matrix
 solvers can be entirely disabled by using @dfn{spparms} to set @code{bandden}
 to 1 (i.e. @code{spparms ("bandden", 1)}).
 
 All of the solvers above, expect the banded solvers, calculate an
@@ -494,22 +752,282 @@ In cases where, this might be a problem 
 the banded solvers as above, at a significant cost in terms of speed.
 
 The user can force the type of the matrix with the @code{matrix_type}
 function. This overcomes the cost of discovering the type of the matrix.
 However, it should be noted incorrectly identifying the type of the matrix
 will lead to unpredictable results, and so @code{matrix_type} should be
 used with care.
 
-@node Iterative Techniques, Oct-Files, Sparse Linear Algebra, Sparse Matrices
+@node Iterative Techniques, Real Life Example, Sparse Linear Algebra, Sparse Matrices
 @section Iterative Techniques applied to sparse matrices
 
-WRITE ME
+WRITE ME OR DELETE ME IF THERE ARE NO ITERATIVE SOLVERS IN OCTAVE 3.0
+
+@node Real Life Example, Oct-Files, Iterative Techniques, Sparse Matrices
+@section Real Life Example of the use of Sparse Matrices
+
+A common application for sparse matrices is in the solution of Finite
+Element Models. Finite element models allow numerical solution of
+partial differential equations that do not have closed form solutions,
+typically because of the complex shape of the domain.
+
+In order to motivate this application, we consider the boundary value
+Laplace equation. This system can model scalar potential fields, such
+as heat or electrical potential. Given a medium 
+@iftex
+@tex
+$\Omega$ 
+@end tex
+@end iftex
+@ifinfo
+Omega
+@end ifinfo
+with boundary
+@iftex
+@tex
+$\partial\Omega$ 
+@end tex
+@end iftex
+@ifinfo
+dOmega
+@end ifinfo
+. At all points on the 
+@iftex
+@tex
+$\partial\Omega$ 
+@end tex
+@end iftex
+@ifinfo
+dOmega
+@end ifinfo
+the boundary conditions are known, and we wish to calculate the potential in
+@iftex
+@tex
+$\Omega$ 
+@end tex
+@end iftex
+@ifinfo
+Omega
+@end ifinfo
+. Boundary conditions may specify the potential (Dirichlet
+boundary condition), its normal derivative across the boundary
+(Neumann boundary condition), or a weighted sum of the potential and
+its derivative (Cauchy boundary condition).
+
+In a thermal model, we want to calculate the temperature in
+@iftex
+@tex
+$\Omega$ 
+@end tex
+@end iftex
+@ifinfo
+Omega
+@end ifinfo
+and know the boundary temperature (Dirichlet condition)
+or heat flux (from which we can calculate the Neumann condition
+by dividing by the thermal conductivity  at the boundary). Similarly, 
+in an electrical model, we want to calculate the voltage in
+@iftex
+@tex
+$\Omega$ 
+@end tex
+@end iftex
+@ifinfo
+Omega
+@end ifinfo
+and know the boundary voltage (Dirichlet) or current
+(Neumann condition after diving by the electrical conductivity).
+In an electrical model, it is common for much of the boundary
+to be electrically isolated; this is a Neumann boundary condition
+with the current equal to zero.
+
+The simplest finite element models will divide 
+@iftex
+@tex
+$\Omega$ 
+@end tex
+@end iftex
+@ifinfo
+Omega
+@end ifinfo
+into simplexes (triangles in 2D, pyramids in 3D).
+@ifset htmltex
+We take as an 3D example a cylindrical liquid filled tank with a small 
+non-conductive ball from the EIDORS project@footnote{EIDORS - Electrical 
+Impedance Tomography and Diffuse optical Tomography Reconstruction Software 
+@url{http://eidors3d.sourceforge.net}}. This is model is designed to reflect
+an application of electrical  impedance tomography, where current patterns
+are applied to such a tank in order to  image the internal conductivity
+distribution. In order to describe the FEM geometry, we have a matrix of 
+vertices @code{nodes} and simplices @code{elems}.
+@end ifset
+
+The following example creates a simple rectangular 2D electrically
+conductive medium with 10 V and 20 V imposed on opposite sides 
+(Dirichlet boundary conditions). All other edges are electrically
+isolated.
+
+@example
+   node_y= [1;1.2;1.5;1.8;2]*ones(1,11);
+   node_x= ones(5,1)*[1,1.05,1.1,1.2, ...
+             1.3,1.5,1.7,1.8,1.9,1.95,2];
+   nodes= [node_x(:), node_y(:)];
+
+   [h,w]= size(node_x);
+   elems= [];
+   for idx= 1:w-1
+     widx= (idx-1)*h;
+     elems= [elems; ...
+       widx+[(1:h-1);(2:h);h+(1:h-1)]'; ...
+       widx+[(2:h);h+(2:h);h+(1:h-1)]' ]; 
+   endfor
+
+   E= size(elems,1); # No. of simplices
+   N= size(nodes,1); # No. of vertices
+   D= size(elems,2); # dimensions+1
+@end example
+
+This creates a N-by-2 matrix @code{nodes} and a E-by-3 matrix
+@code{elems} with values, which define finite element triangles:
 
-@node Oct-Files, Function Reference, Iterative Techniques, Sparse Matrices
+@example
+  nodes(1:7,:)'
+    1.00 1.00 1.00 1.00 1.00 1.05 1.05 ...
+    1.00 1.20 1.50 1.80 2.00 1.00 1.20 ...
+
+  elems(1:7,:)'
+    1    2    3    4    2    3    4 ...
+    2    3    4    5    7    8    9 ...
+    6    7    8    9    6    7    8 ...
+@end example
+
+Using a first order FEM, we approximate the electrical conductivity 
+distribution in 
+@iftex
+@tex
+$\Omega$ 
+@end tex
+@end iftex
+@ifinfo
+Omega
+@end ifinfo
+as constant on each simplex (represented by the vector @code{conductivity}).
+Based on the finite element geometry, we first calculate a system (or
+stiffness) matrix for each simplex (represented as 3-by-3 elements on the
+diagonal of the element-wise system matrix @code{SE}. Based on @code{SE} 
+and a N-by-DE connectivity matrix @code{C}, representing the connections 
+between simplices and vectices, the global connectivity matrix @code{S} is
+calculated.
+
+@example
+  # Element conductivity
+  conductivity= [1*ones(1,16), ...
+         2*ones(1,48), 1*ones(1,16)];
+
+  # Connectivity matrix
+  C = sparse ((1:D*E), reshape (elems', ...
+         D*E, 1), 1, D*E, N);
+
+  # Calculate system matrix
+  Siidx = floor ([0:D*E-1]'/D) * D * ...
+         ones(1,D) + ones(D*E,1)*(1:D) ;
+  Sjidx = [1:D*E]'*ones(1,D);
+  Sdata = zeros(D*E,D);
+  dfact = factorial(D-1);
+  for j=1:E
+     a = inv([ones(D,1), ... 
+         nodes(elems(j,:), :)]);
+     const = conductivity(j) * 2 / ...
+         dfact / abs(det(a));
+     Sdata(D*(j-1)+(1:D),:) = const * ...
+         a(2:D,:)' * a(2:D,:);
+  endfor
+  # Element-wise system matrix
+  SE= sparse(Siidx,Sjidx,Sdata);
+  # Global system matrix
+  S= C'* SE *C;
+@end example
+
+The system matrix acts like the conductivity 
+@iftex
+@tex
+$S$ 
+@end tex
+@end iftex
+@ifinfo
+@code{S}
+@end ifinfo
+in Ohm's law 
+@iftex
+@tex
+$SV = I$. 
+@end tex
+@end iftex
+@ifinfo
+@code{S * V = I}.
+@end ifinfo
+Based on the Dirichlet and Neumann boundary conditions, we are able to 
+solve for the voltages at each vertex @code{V}. 
+
+@example
+  # Dirichlet boundary conditions
+  D_nodes=[1:5, 51:55]; 
+  D_value=[10*ones(1,5), 20*ones(1,5)]; 
+
+  V= zeros(N,1);
+  V(D_nodes) = D_value;
+  idx = 1:N; # vertices without Dirichlet 
+             # boundary condns
+  idx(D_nodes) = [];
+
+  # Neumann boundary conditions. Note that
+  # N_value must be normalized by the
+  # boundary length and element conductivity
+  N_nodes=[];
+  N_value=[];
+
+  Q = zeros(N,1);
+  Q(N_nodes) = N_value;
+
+  V(idx) = S(idx,idx) \ ( Q(idx) - ...
+            S(idx,D_nodes) * V(D_nodes));
+@end example
+
+Finally, in order to display the solution, we show each solved voltage 
+value in the z-axis for each simplex vertex.
+@ifset htmltex
+@xref{fig:femmodel}.
+@end ifset
+
+@example
+  elemx = elems(:,[1,2,3,1])';
+  xelems = reshape (nodes(elemx, 1), 4, E);
+  yelems = reshape (nodes(elemx, 2), 4, E);
+  velems = reshape (V(elemx), 4, E);
+  plot3 (xelems,yelems,velems,'k'); 
+  print ('grid.eps');
+@end example
+
+
+@ifset htmltex
+@ifset HAVE_CHOLMOD
+@ifset HAVE_UMFPACK
+@ifset HAVE_COLAMD
+@float Figure,fig:femmodel
+@image{grid,8cm}
+@caption{Example finite element model the showing triangular elements. 
+The height of each vertex corresponds to the solution value.}
+@end float
+@end ifset
+@end ifset
+@end ifset
+@end ifset
+
+@node Oct-Files, Function Reference, Real Life Example, Sparse Matrices
 @section Using Sparse Matrices in Oct-files
 
 An oct-file is a means of writing an Octave function in a compilable
 language like C++, rather than as a script file. This results in a
 significant acceleration in the code.  It is not the purpose of this
 section to discuss how to write an oct-file, or discuss what they
 are. There are already two @footnote{Paul Thomas "Dal Segno al Coda 
 - The octave dynamically linked function cookbook", 
@@ -523,24 +1041,24 @@ entirely in C++.
 
 There are three classes of sparse objects that are of interest to the
 user.
 
 @table @asis
 @item SparseMatrix
 A double precision sparse matrix class
 @item SparseComplexMatrix
-A Complex sparse matrix class
+A complex sparse matrix class
 @item SparseBoolMatrix
-A boolen sparse matrix class
+A boolean sparse matrix class
 @end table
 
 All of these classes inherit from the @code{Sparse<T>} template class,
 and so all have similar capabilities and usage. The @code{Sparse<T>}
-class was based on Octave @code{Array<T>} class, and so users familar
+class was based on Octave @code{Array<T>} class, and so users familiar
 with Octave's Array classes will be comfortable with the use of
 the sparse classes.
 
 The sparse classes will not be entirely described in this section, due
 to their similar with the existing Array classes. However, there are a
 few differences due the different nature of sparse objects, and these
 will be described. Firstly, although it is fundamentally possible to
 have N-dimensional sparse objects, the Octave sparse classes do
@@ -594,17 +1112,17 @@ code like
       std::cerr << " (" << i << "," << j << "): " << sm(i,j) 
                 << std::endl;
 @end example
 
 is a great way of turning the sparse matrix into a dense one, and a
 very slow way at that since it reallocates the sparse object at each
 zero element in the matrix.
 
-An easy way of preventing the above from hapening is to create a temporary
+An easy way of preventing the above from happening is to create a temporary
 constant version of the sparse matrix. Note that only the container for
 the sparse matrix will be copied, while the actual representation of the
 data will be shared between the two versions of the sparse matrix. So this
 is not a costly operation. For example, the above would become
 
 @example
   SparseMatrix sm;
   @dots{}
@@ -612,22 +1130,22 @@ is not a costly operation. For example, 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       std::cerr << " (" << i << "," << j << "): " << tmp(i,j) 
                 << std::endl;
 @end example
 
 Finally, as the sparse types aren't just represented as a contiguous
 block of memory, the @code{fortran_vec} method of the @code{Array<T>}
-is not available. It is however replaced by three seperate methods
+is not available. It is however replaced by three separate methods
 @code{ridx}, @code{cidx} and @code{data}, that access the raw compressed
 column format that the Octave sparse matrices are stored in.
 Additionally, these methods can be used in a manner similar to @code{elem},
 to allow the matrix to be accessed or filled. However, in that case it is
-up to the user to repect the sparse matrix compressed column format
+up to the user to respect the sparse matrix compressed column format
 discussed previous.
 
 @node OctCreation, OctUse, OctDifferences, Oct-Files
 @subsection Creating Spare Matrices in Oct-Files
 
 The user has several alternatives in how to create a sparse matrix.
 They can first create the data as three vectors representing the
 row and column indexes and the data, and from those create the matrix.
@@ -835,138 +1353,140 @@ following example
 @end example
 
 The conversion to an octave-value is handled by the sparse
 @code{octave_value} constructors, and so no special care is needed.
 
 @node Function Reference, , Oct-Files, Sparse Matrices
 @section Function Reference
 
-@iftex
+@ifset htmltex
 @subsection Functions by Category
 @subsubsection Generate sparse matrix
 @table @asis
-@item spdiags
+@item @ref{spdiags}
 A generalization of the function `spdiag'.
-@item speye
+@item @ref{speye}
 Returns a sparse identity matrix.
-@item sprand
+@item @ref{sprand}
 Generate a random sparse matrix.
-@item sprandn
+@item @ref{sprandn}
 Generate a random sparse matrix.
-@item sprandsym
-@emph{Not implemented}
+@item @ref{sprandsym}
+Generate a symmetric random sparse matrix.
 @end table
 @subsubsection Sparse matrix conversion
 @table @asis
-@item full
+@item @ref{full}
 returns a full storage matrix from a sparse one See also: sparse
-@item sparse
+@item @ref{sparse}
 SPARSE: create a sparse matrix
-@item spconvert
+@item @ref{spconvert}
 This function converts for a simple sparse matrix format easily produced by other programs into Octave's internal sparse format.
-@item spfind
+@item @ref{spfind}
 SPFIND: a sparse version of the find operator 1.
 @end table
 @subsubsection Manipulate sparse matrices
 @table @asis
-@item issparse
+@item @ref{issparse}
 Return 1 if the value of the expression EXPR is a sparse matrix.
-@item nnz
+@item @ref{nnz}
 returns number of non zero elements in SM See also: sparse
-@item nonzeros
+@item @ref{nonzeros}
 Returns a vector of the non-zero values of the sparse matrix S
-@item nzmax
+@item @ref{nzmax}
 Returns the amount of storage allocated to the sparse matrix SM.
-@item spalloc
+@item @ref{spalloc}
 Returns an empty sparse matrix of size R-by-C.
-@item spfun
+@item @ref{spfun}
 Compute `f(X)' for the non-zero values of X This results in a sparse matrix with the same structure as X.
-@item spones
+@item @ref{spones}
 Replace the non-zero entries of X with ones.
-@item spy
+@item @ref{spy}
 Plot the sparsity pattern of the sparse matrix X
 @end table
 @subsubsection Graph Theory
 @table @asis
-@item etree
+@item @ref{etree}
 Returns the elimination tree for the matrix S.
-@item etreeplot
+@item @ref{etreeplot}
 Plots the elimination tree of the matrix @var{s} or @code{@var{s}+@var{s}'}
 if @var{s} in non-symmetric.
-@item gplot
+@item @ref{gplot}
 Plots a graph defined by @var{A} and @var{xy} in the graph theory sense.
 @item treelayout
 @emph{Not implemented}
-@item treeplot
+@item @ref{treeplot}
 Produces a graph of a tree or forest.
 @end table
 @subsubsection Sparse matrix reordering
 @table @asis
-@item ccolamd
+@item @ref{ccolamd}
 Constrained column approximate minimum degree permutation.
-@item colamd
+@item @ref{colamd}
 Column approximate minimum degree permutation.
-@item colperm
+@item @ref{colperm}
 Returns the column permutations such that the columns of `S (:, P)' are ordered in terms of increase number of non-zero elements.
-@item csymamd
+@item @ref{csymamd}
 For a symmetric positive definite matrix S, returns the permutation vector p such that `S (P, P)' tends to have a sparser Cholesky factor than S.
-@item dmperm
+@item @ref{dmperm}
 Perform a Deulmage-Mendelsohn permutation on the sparse matrix S.
-@item symamd
+@item @ref{symamd}
 For a symmetric positive definite matrix S, returns the permutation vector p such that `S (P, P)' tends to have a sparser Cholesky factor than S.
 @item symrcm
-Returns the Reverse Cuthill McKee reordering of the sparse matrix S.
+@emph{Not implemented}
 @end table
 @subsubsection Linear algebra
 @table @asis
 @item cholinc
 @emph{Not implemented}
 @item condest
 @emph{Not implemented}
 @item eigs
 @emph{Not implemented}
-@item matrix_type
+@item @ref{matrix_type}
 Identify the matrix type or mark a matrix as a particular type.
 @item normest
 @emph{Not implemented}
-@item spchol
+@item @ref{spchol}
 Compute the Cholesky factor, R, of the symmetric positive definite.
-@item spcholinv
+@item @ref{spcholinv}
 Use the Cholesky factorization to compute the inverse of the
 sparse symmetric positive definite matrix A.
-@item spchol2inv
+@item @ref{spchol2inv}
 Invert a sparse symmetric, positive definite square matrix from its
 Cholesky decomposition, U.
-@item spdet
+@item @ref{spdet}
 Compute the determinant of sparse matrix A using UMFPACK.
-@item spinv
+@item @ref{spinv}
 Compute the inverse of the square matrix A.
-@item spkron
+@item @ref{spkron}
 Form the kronecker product of two sparse matrices.
-@item splchol
+@item @ref{splchol}
 Compute the Cholesky factor, L, of the symmetric positive definite.
-@item splu
+@item @ref{splu}
 Compute the LU decomposition of the sparse matrix A, using subroutines from UMFPACK.
+@item @ref{spqr}
+Compute the sparse QR factorization of @var{a}, using CSPARSE.
 @item sprank
 @emph{Not implemented}
 @item svds
 @emph{Not implemented}
 @end table
 @subsubsection Iterative techniques
 @table @asis
 @item bicg
 @emph{Not implemented}
 @item bicgstab
 @emph{Not implemented}
 @item cgs
 @emph{Not implemented}
 @item gmres
 @emph{Not implemented}
-@item luinc
+@item @ref{luinc}
 Produce the incomplete LU factorization of the sparse matrix A.
 @item lsqr
 @emph{Not implemented}
 @item minres
 @emph{Not implemented}
 @item pcg
 @emph{Not implemented}
 @item pcr
@@ -975,44 +1495,44 @@ Produce the incomplete LU factorization 
 @emph{Not implemented}
 @item symmlq
 @emph{Not implemented}
 @end table
 @subsubsection Miscellaneous
 @table @asis
 @item spaugment
 @emph{Not implemented}
-@item spparms
+@item @ref{spparms}
 Sets or displays the parameters used by the sparse solvers and factorization functions.
-@item symbfact
+@item @ref{symbfact}
 Performs a symbolic factorization analysis on the sparse matrix S.
-@item spstats
+@item @ref{spstats}
 Return the stats for the non-zero elements of the sparse matrix S COUNT is the number of non-zeros in each column, MEAN is the mean of the non-zeros in each column, and VAR is the variance of the non-zeros in each column
-@item spprod
+@item @ref{spprod}
 Product of elements along dimension DIM.
-@item spcumprod
+@item @ref{spcumprod}
 Cumulative product of elements along dimension DIM.
-@item spcumsum
+@item @ref{spcumsum}
 Cumulative sum of elements along dimension DIM.
-@item spsum
+@item @ref{spsum}
 Sum of elements along dimension DIM.
-@item spsumsq
+@item @ref{spsumsq}
 Sum of squares of elements along dimension DIM.
-@item spmin
+@item @ref{spmin}
 For a vector argument, return the minimum value.
-@item spmax
+@item @ref{spmax}
 For a vector argument, return the maximum value.
-@item spatan2
+@item @ref{spatan2}
 Compute atan (Y / X) for corresponding sparse matrix elements of Y and X.
-@item spdiag
+@item @ref{spdiag}
 Return a diagonal matrix with the sparse vector V on diagonal K.
 @end table
 
 @subsection Functions Alphabetically
-@end iftex
+@end ifset
 
 @menu
 * ccolamd::	Constrained column approximate minimum degree permutation.
 * colamd::	Column approximate minimum degree permutation.
 * colperm::	Returns the column permutations such that the columns of `S
 		(:, P)' are ordered in terms of increase number of non-zero
 		elements.
 * csymamd::	For a symmetric positive definite matrix S, returns the
@@ -1068,32 +1588,32 @@ Return a diagonal matrix with the sparse
 * splu::	Compute the LU decomposition of the sparse matrix A, using
 		subroutines from UMFPACK.
 * spmax::	For a vector argument, return the maximum value.
 * spmin::	For a vector argument, return the minimum value.
 * spones::	Replace the non-zero entries of X with ones.
 * spparms::	Sets or displays the parameters used by the sparse solvers
 		and factorization functions.
 * spprod::	Product of elements along dimension DIM.
+* spqr::	Compute the sparse QR factorization of @var{a}, using CSPARSE.
 * sprand::	Generate a random sparse matrix.
 * sprandn::	Generate a random sparse matrix.
+* sprandsym::	Generate a symmetric random sparse matrix.
 * spstats::	Return the stats for the non-zero elements of the sparse
 		matrix S COUNT is the number of non-zeros in each column,
 		MEAN is the mean of the non-zeros in each column, and VAR
 		is the variance of the non-zeros in each column
 * spsum::	Sum of elements along dimension DIM.
 * spsumsq::	Sum of squares of elements along dimension DIM.
 * spy:: 	Plot the sparsity pattern of the sparse matrix X
 * symamd::	For a symmetric positive definite matrix S, returns the
 		permutation vector p such that `S (P, P)' tends to have a
 		sparser Cholesky factor than S.
 * symbfact::	Performs a symbolic factorization analysis on the sparse
 		matrix S.
-* symrcm::	Returns the Reverse Cuthill McKee reordering of the sparse
-		matrix S.
 * treeplot::	Produces a graph of a tree or forest.
 @end menu
 
 @node colamd, ccolamd, , Function Reference
 @subsubsection colamd
 
 @DOCSTRING(colamd)
 
@@ -1277,32 +1797,42 @@ Return a diagonal matrix with the sparse
 
 @DOCSTRING(spones)
 
 @node spparms, spprod, spones, Function Reference
 @subsubsection spparms
 
 @DOCSTRING(spparms)
 
-@node spprod, sprand, spparms, Function Reference
+@node spprod, spqr, spparms, Function Reference
 @subsubsection spprod
 
 @DOCSTRING(spprod)
 
-@node sprand, sprandn, spprod, Function Reference
+@node spqr, sprand, spprod, Function Reference
+@subsubsection spqr
+
+@DOCSTRING(spqr)
+
+@node sprand, sprandn, spqr, Function Reference
 @subsubsection sprand
 
 @DOCSTRING(sprand)
 
-@node sprandn, spstats, sprand, Function Reference
+@node sprandn, sprandsym, sprand, Function Reference
 @subsubsection sprandn
 
 @DOCSTRING(sprandn)
 
-@node spstats, spsum, sprandn, Function Reference
+@node sprandsym, spstats, sprandn, Function Reference
+@subsubsection sprandsym
+
+@DOCSTRING(sprandsym)
+
+@node spstats, spsum, sprandsym, Function Reference
 @subsubsection spstats
 
 @DOCSTRING(spstats)
 
 @node spsum, spsumsq, spstats, Function Reference
 @subsubsection spsum
 
 @DOCSTRING(spsum)
@@ -1317,26 +1847,21 @@ Return a diagonal matrix with the sparse
 
 @DOCSTRING(spy)
 
 @node symamd, symbfact, spy, Function Reference
 @subsubsection symamd
 
 @DOCSTRING(symamd)
 
-@node symbfact, symrcm, symamd, Function Reference
+@node symbfact, treeplot, symamd, Function Reference
 @subsubsection symbfact
 
 @DOCSTRING(symbfact)
 
-@node symrcm, treeplot, symbfact, Function Reference
-@subsubsection symrcm
-
-@DOCSTRING(symrcm)
-
-@node treeplot, ,symrcm, Function Reference
+@node treeplot, ,symbfact, Function Reference
 @subsubsection treeplot
 
 @DOCSTRING(treeplot)
 
 @c Local Variables: ***
 @c Mode: texinfo ***
 @c End: ***
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -544,28 +544,38 @@ SparseComplexMatrix::matrix_value (void)
 SparseComplexMatrix
 SparseComplexMatrix::hermitian (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz = nzmax ();
   SparseComplexMatrix retval (nc, nr, nz);
 
-  retval.cidx(0) = 0;
-  for (octave_idx_type i = 0, iidx = 0; i < nr; i++)
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, w, nr + 1);
+  for (octave_idx_type i = 0; i < nr; i++)
+    w[i] = 0;
+  for (octave_idx_type i = 0; i < nz; i++)
+    w[ridx(i)]++;
+  nz = 0;
+  for (octave_idx_type i = 0; i < nr; i++)
     {
-      for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-	  if (ridx(k) == i)
-	    {
-	      retval.data(iidx) = conj (data(k));
-	      retval.ridx(iidx++) = j;
-	    }
-      retval.cidx(i+1) = iidx;
+      retval.xcidx(i) = nz;
+      nz += w[i];
+      w[i] = retval.xcidx(i);
     }
+  retval.xcidx(nr) = nz;
+  w[nr] = nz;
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
+      {
+	octave_idx_type q = w [ridx(k)]++;
+	retval.xridx (q) = j;
+	retval.xdata (q) = conj (data (k));
+      }
 
   return retval;
 }
 
 SparseComplexMatrix
 conj (const SparseComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,22 @@
+2006-03-08  David Bateman  <dbateman@free.fr>
+
+	* SparseCmplxQR.cc: Updates for new upstream CXSPARSE release. Fix for
+	g++ 4.x stl_vector.h issue with C99 double _Complex type.
+	* SparseCmplxQR.h:  Updates for new upstream CXSPARSE release.
+	* SparseQR.cc: ditto.
+	* SparseQR.h: ditto.
+	* oct-sparse.h: ditto.
+	* sparse-base-chol.cc (sparse_base_chol<>::sparse_base_chol_rep::init):
+	Declare info variable as volatile.
+
+	* Sparse.cc (Sparse<T>::transpose (void) const): Accelerate algorithm.
+	* CSparse.cc (SparseComplexMatrix::transpose (void) const): ditto.
+	
 2006-03-01  John W. Eaton  <jwe@octave.org>
 
 	* CMatrix.cc (ComplexMatrix::determinant):
 	Scale result by factors of 2, not 10.
 	* dMatrix.cc (Matrix::determinant): Likewise.
 
 	* dbleDET.h (DET::DET): Use initializer list.
 	(DET::coefficient2, DET::coefficient10, DET::exponent2,
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -1029,31 +1029,41 @@ Sparse<T>::insert (const Sparse<T>& a, c
 template <class T>
 Sparse<T>
 Sparse<T>::transpose (void) const
 {
   assert (ndims () == 2);
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = nnz ();
   Sparse<T> retval (nc, nr, nz);
 
-  retval.cidx(0) = 0;
-  for (octave_idx_type i = 0, iidx = 0; i < nr; i++)
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, w, nr + 1);
+  for (octave_idx_type i = 0; i < nr; i++)
+    w[i] = 0;
+  for (octave_idx_type i = 0; i < nz; i++)
+    w[ridx(i)]++;
+  nz = 0;
+  for (octave_idx_type i = 0; i < nr; i++)
     {
-      for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-	  if (ridx(k) == i)
-	    {
-	      retval.data(iidx) = data(k);
-	      retval.ridx(iidx++) = j;
-	    }
-      retval.cidx(i+1) = iidx;
+      retval.xcidx(i) = nz;
+      nz += w[i];
+      w[i] = retval.xcidx(i);
     }
+  retval.xcidx(nr) = nz;
+  w[nr] = nz;
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
+      {
+	octave_idx_type q = w [ridx(k)]++;
+	retval.xridx (q) = j;
+	retval.xdata (q) = data (k);
+      }
 
   return retval;
 }
 
 template <class T>
 void
 Sparse<T>::clear_index (void)
 {
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -22,67 +22,73 @@ Boston, MA 02110-1301, USA.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 #include <vector>
 
 #include "lo-error.h"
 #include "SparseCmplxQR.h"
 
+// Why did g++ 4.x stl_vector.h make
+//   OCTAVE_LOCAL_BUFFER (double _Complex, buf, n)
+// an error ?
+#define OCTAVE_C99_COMPLEX(buf, n) \
+  OCTAVE_LOCAL_BUFFER (double, buf ## tmp, (2 * (n))); \
+  double _Complex *buf = reinterpret_cast<double _Complex *> (buf ## tmp);
+
 SparseComplexQR::SparseComplexQR_rep::SparseComplexQR_rep 
 (const SparseComplexMatrix& a, int order)
 {
 #ifdef HAVE_CXSPARSE
-  // cast away const on A, with full knowledge that CSparse won't touch it
-  CXSPARSE_ZNAME (cs) A;
+  CXSPARSE_ZNAME () A;
   A.nzmax = a.nnz ();
   A.m = a.rows ();
   A.n = a.cols ();
   nrows = A.m;
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
   A.x = const_cast<double _Complex *>(reinterpret_cast<const double _Complex *> 
 				      (a.data ()));
   A.nz = -1;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-  S = CXSPARSE_ZNAME (cs_sqr) (&A, order, 1);
-  N = CXSPARSE_ZNAME (cs_qr) (&A, S);
+  S = CXSPARSE_ZNAME (_sqr) (&A, order, 1);
+  N = CXSPARSE_ZNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   if (!N)
     (*current_liboctave_error_handler)
       ("SparseComplexQR: sparse matrix QR factorization filled");
   count = 1;
 #else
   (*current_liboctave_error_handler)
     ("SparseComplexQR: sparse matrix QR factorization not implemented");
 #endif
 }
 
 SparseComplexQR::SparseComplexQR_rep::~SparseComplexQR_rep (void)
 {
 #ifdef HAVE_CXSPARSE
-  CXSPARSE_ZNAME (cs_sfree) (S);
-  CXSPARSE_ZNAME (cs_nfree) (N);
+  CXSPARSE_ZNAME (_sfree) (S);
+  CXSPARSE_ZNAME (_nfree) (N);
 #endif
 }
 
 SparseComplexMatrix 
 SparseComplexQR::SparseComplexQR_rep::V (void) const
 {
 #ifdef HAVE_CXSPARSE
   // Drop zeros from V and sort
   // XXX FIXME XXX Is the double transpose to sort necessary?
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-  CXSPARSE_ZNAME (cs_dropzeros) (N->L);
-  CXSPARSE_ZNAME (cs) *D = CXSPARSE_ZNAME (cs_transpose) (N->L, 1);
-  CXSPARSE_ZNAME (cs_spfree) (N->L);
-  N->L = CXSPARSE_ZNAME (cs_transpose) (D, 1);
-  CXSPARSE_ZNAME (cs_spfree) (D);
+  CXSPARSE_ZNAME (_dropzeros) (N->L);
+  CXSPARSE_ZNAME () *D = CXSPARSE_ZNAME (_transpose) (N->L, 1);
+  CXSPARSE_ZNAME (_spfree) (N->L);
+  N->L = CXSPARSE_ZNAME (_transpose) (D, 1);
+  CXSPARSE_ZNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
   octave_idx_type nc = N->L->n;
   octave_idx_type nz = N->L->nzmax;
   SparseComplexMatrix ret (N->L->m, nc, nz);
   for (octave_idx_type j = 0; j < nc+1; j++)
     ret.xcidx (j) = N->L->p[j];
   for (octave_idx_type j = 0; j < nz; j++)
@@ -124,21 +130,21 @@ SparseComplexQR::SparseComplexQR_rep::P 
 
 SparseComplexMatrix 
 SparseComplexQR::SparseComplexQR_rep::R (const bool econ) const
 {
 #ifdef HAVE_CXSPARSE
   // Drop zeros from R and sort
   // XXX FIXME XXX Is the double transpose to sort necessary?
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-  CXSPARSE_ZNAME (cs_dropzeros) (N->U);
-  CXSPARSE_ZNAME (cs) *D = CXSPARSE_ZNAME (cs_transpose) (N->U, 1);
-  CXSPARSE_ZNAME (cs_spfree) (N->U);
-  N->U = CXSPARSE_ZNAME (cs_transpose) (D, 1);
-  CXSPARSE_ZNAME (cs_spfree) (D);
+  CXSPARSE_ZNAME (_dropzeros) (N->U);
+  CXSPARSE_ZNAME () *D = CXSPARSE_ZNAME (_transpose) (N->U, 1);
+  CXSPARSE_ZNAME (_spfree) (N->U);
+  N->U = CXSPARSE_ZNAME (_transpose) (D, 1);
+  CXSPARSE_ZNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
   octave_idx_type nc = N->U->n;
   octave_idx_type nz = N->U->nzmax;
   SparseComplexMatrix ret ((econ ? (nc > nrows ? nrows : nc) : nrows), nc, nz);
   for (octave_idx_type j = 0; j < nc+1; j++)
     ret.xcidx (j) = N->U->p[j];
   for (octave_idx_type j = 0; j < nz; j++)
@@ -169,24 +175,24 @@ SparseComplexQR::SparseComplexQR_rep::C 
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
 	{
 	  OCTAVE_QUIT;
 	  volatile octave_idx_type nm = (nr < nc ? nr : nc);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_ipvec) (b_nr, S->Pinv, bvec + idx,
+	  CXSPARSE_ZNAME (_ipvec) (b_nr, S->Pinv, bvec + idx,
 				     reinterpret_cast<double _Complex *>(buf));
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type i = 0; i < nm; i++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (cs_happly) 
+	      CXSPARSE_ZNAME (_happly) 
 		(N->L, i, N->B[i], reinterpret_cast<double _Complex *>(buf));
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  for (octave_idx_type i = 0; i < b_nr; i++)
 	    vec[i+idx] = buf[i];
 	}
     }
   return ret;
@@ -215,79 +221,78 @@ qrsolve(const SparseComplexMatrix&a, con
       if (! q.ok ())
 	{
 	  info = -1;
 	  return ComplexMatrix();
 	}
       x.resize(nc, b_nc);
       double _Complex *vec = reinterpret_cast<double _Complex *>
 	(x.fortran_vec());
-      OCTAVE_LOCAL_BUFFER (double _Complex, buf, q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_ipvec) 
+	  CXSPARSE_ZNAME (_ipvec) 
 	    (nr, q.S()->Pinv, reinterpret_cast<double _Complex *>(Xx), buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_usolve) (q.N()->U, buf);
-	  CXSPARSE_ZNAME (cs_ipvec) (nc, q.S()->Q, buf, vec + idx);
+	  CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+	  CXSPARSE_ZNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	}
     }
   else
     {
       SparseComplexMatrix at = a.hermitian();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
 	{
 	  info = -1;
 	  return ComplexMatrix();
 	}
       x.resize(nc, b_nc);
       double _Complex *vec = reinterpret_cast<double _Complex *>
 	(x.fortran_vec());
-      OCTAVE_LOCAL_BUFFER (double _Complex, buf, 
-			   nc > q.S()->m2 ? nc : q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_pvec)
+	  CXSPARSE_ZNAME (_pvec)
 	    (nr, q.S()->Q, reinterpret_cast<double _Complex *>(Xx), buf);
-	  CXSPARSE_ZNAME (cs_utsolve) (q.N()->U, buf);
+	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-	      CXSPARSE_ZNAME (cs_happly) 
+	      CXSPARSE_ZNAME (_happly) 
 		(q.N()->L, j, reinterpret_cast<double _Complex *>(B)[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_pvec) (nc, q.S()->Pinv, buf, vec + idx);
+	  CXSPARSE_ZNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	}
     }
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
@@ -316,36 +321,36 @@ qrsolve(const SparseComplexMatrix&a, con
 	  info = -1;
 	  return SparseComplexMatrix();
 	}
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double _Complex, buf, q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_ipvec) 
+	  CXSPARSE_ZNAME (_ipvec) 
 	    (nr, q.S()->Pinv, reinterpret_cast<double _Complex *>(Xx), buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_usolve) (q.N()->U, buf);
-	  CXSPARSE_ZNAME (cs_ipvec) (nc, q.S()->Q, buf, 
+	  CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+	  CXSPARSE_ZNAME (_ipvec) (nc, q.S()->Q, buf, 
 				     reinterpret_cast<double _Complex *>(Xx));
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      Complex tmp = Xx[j];
 	      if (tmp != 0.0)
 		{
@@ -373,41 +378,40 @@ qrsolve(const SparseComplexMatrix&a, con
 	  info = -1;
 	  return SparseComplexMatrix();
 	}
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double _Complex, buf,
-			   nc > q.S()->m2 ? nc : q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_pvec)
+	  CXSPARSE_ZNAME (_pvec)
 	    (nr, q.S()->Q, reinterpret_cast<double _Complex *>(Xx), buf);
-	  CXSPARSE_ZNAME (cs_utsolve) (q.N()->U, buf);
+	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (cs_happly) 
+	      CXSPARSE_ZNAME (_happly) 
 		(q.N()->L, j, reinterpret_cast<double _Complex *>(B)[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_pvec) (nc, q.S()->Pinv, buf, 
+	  CXSPARSE_ZNAME (_pvec) (nc, q.S()->Pinv, buf, 
 				     reinterpret_cast<double _Complex *>(Xx));
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      Complex tmp = Xx[j];
 	      if (tmp != 0.0)
 		{
@@ -456,72 +460,71 @@ qrsolve(const SparseComplexMatrix&a, con
       if (! q.ok ())
 	{
 	  info = -1;
 	  return ComplexMatrix();
 	}
       x.resize(nc, b_nc);
       double _Complex *vec = reinterpret_cast<double _Complex *>
 	(x.fortran_vec());
-      OCTAVE_LOCAL_BUFFER (double _Complex, buf, q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
 	   i++, idx+=nc, bidx+=b_nr)
 	{
 	  OCTAVE_QUIT;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
+	  CXSPARSE_ZNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_usolve) (q.N()->U, buf);
-	  CXSPARSE_ZNAME (cs_ipvec) (nc, q.S()->Q, buf, vec + idx);
+	  CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+	  CXSPARSE_ZNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	}
     }
   else
     {
       SparseComplexMatrix at = a.hermitian();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
 	{
 	  info = -1;
 	  return ComplexMatrix();
 	}
       x.resize(nc, b_nc);
       double _Complex *vec = reinterpret_cast<double _Complex *>
 	(x.fortran_vec());
-      OCTAVE_LOCAL_BUFFER (double _Complex, buf,
-			   nc > q.S()->m2 ? nc : q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
 	   i++, idx+=nc, bidx+=b_nr)
 	{
 	  OCTAVE_QUIT;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_pvec) (nr, q.S()->Q, bvec + bidx, buf);
-	  CXSPARSE_ZNAME (cs_utsolve) (q.N()->U, buf);
+	  CXSPARSE_ZNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
+	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (cs_happly) 
+	      CXSPARSE_ZNAME (_happly) 
 		(q.N()->L, j, reinterpret_cast<double _Complex *>(B)[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_pvec) (nc, q.S()->Pinv, buf, vec + idx);
+	  CXSPARSE_ZNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	}
     }
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
@@ -550,36 +553,36 @@ qrsolve(const SparseComplexMatrix&a, con
 	  info = -1;
 	  return SparseComplexMatrix();
 	}
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double _Complex, buf, q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_ipvec) 
+	  CXSPARSE_ZNAME (_ipvec) 
 	    (nr, q.S()->Pinv, reinterpret_cast<double _Complex *>(Xx), buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_usolve) (q.N()->U, buf);
-	  CXSPARSE_ZNAME (cs_ipvec) (nc, q.S()->Q, buf, 
+	  CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+	  CXSPARSE_ZNAME (_ipvec) (nc, q.S()->Q, buf, 
 				     reinterpret_cast<double _Complex *>(Xx));
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      Complex tmp = Xx[j];
 	      if (tmp != 0.0)
 		{
@@ -607,41 +610,40 @@ qrsolve(const SparseComplexMatrix&a, con
 	  info = -1;
 	  return SparseComplexMatrix();
 	}
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double _Complex, buf,
-			   nc > q.S()->m2 ? nc : q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_pvec)
+	  CXSPARSE_ZNAME (_pvec)
 	    (nr, q.S()->Q, reinterpret_cast<double _Complex *>(Xx), buf);
-	  CXSPARSE_ZNAME (cs_utsolve) (q.N()->U, buf);
+	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_ZNAME (cs_happly) 
+	      CXSPARSE_ZNAME (_happly) 
 		(q.N()->L, j, reinterpret_cast<double _Complex *>(B)[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_ZNAME (cs_pvec) (nc, q.S()->Pinv, buf, 
+	  CXSPARSE_ZNAME (_pvec) (nc, q.S()->Pinv, buf, 
 				     reinterpret_cast<double _Complex *>(Xx));
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      Complex tmp = Xx[j];
 	      if (tmp != 0.0)
 		{
diff --git a/liboctave/SparseCmplxQR.h b/liboctave/SparseCmplxQR.h
--- a/liboctave/SparseCmplxQR.h
+++ b/liboctave/SparseCmplxQR.h
@@ -26,19 +26,19 @@ Boston, MA 02110-1301, USA.
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "dSparse.h"
 #include "CSparse.h"
 #include "oct-sparse.h"
 
 #ifdef IDX_TYPE_LONG
-#define CXSPARSE_ZNAME(name) name ## _cl
+#define CXSPARSE_ZNAME(name) cs_cl ## name
 #else
-#define CXSPARSE_ZNAME(name) name ## _ci
+#define CXSPARSE_ZNAME(name) cs_ci ## name
 #endif
 
 class
 SparseComplexQR
 {
 protected:
   class SparseComplexQR_rep
   {
@@ -60,19 +60,19 @@ protected:
     SparseComplexMatrix R (const bool econ) const;
 
     ComplexMatrix C (const ComplexMatrix &b) const;
 
     int count;
 
     octave_idx_type nrows;
 #ifdef HAVE_CXSPARSE
-    CXSPARSE_ZNAME (css) *S;
+    CXSPARSE_ZNAME (s) *S;
 
-    CXSPARSE_ZNAME (csn) *N;
+    CXSPARSE_ZNAME (n) *N;
 #endif
   };
 private:
   SparseComplexQR_rep *rep;
 
 public:  
   SparseComplexQR (void) : 
     rep (new SparseComplexQR_rep (SparseComplexMatrix(), -1)) { }
@@ -126,19 +126,19 @@ public:
 				octave_idx_type &info);
 
   friend SparseComplexMatrix qrsolve (const SparseComplexMatrix &a, 
 				      const SparseComplexMatrix &b,
 				      octave_idx_type &info);
 
 protected:
 #ifdef HAVE_CXSPARSE
-  CXSPARSE_ZNAME (css) * S (void) { return rep->S; }
+  CXSPARSE_ZNAME (s) * S (void) { return rep->S; }
 
-  CXSPARSE_ZNAME (csn) * N (void) { return rep->N; }
+  CXSPARSE_ZNAME (n) * N (void) { return rep->N; }
 #endif
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -25,61 +25,61 @@ Boston, MA 02110-1301, USA.
 #include <vector>
 
 #include "lo-error.h"
 #include "SparseQR.h"
 
 SparseQR::SparseQR_rep::SparseQR_rep (const SparseMatrix& a, int order)
 {
 #ifdef HAVE_CXSPARSE
-  CXSPARSE_DNAME (cs) A;
+  CXSPARSE_DNAME () A;
   A.nzmax = a.nzmax ();
   A.m = a.rows ();
   A.n = a.cols ();
   nrows = A.m;
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
   A.x = const_cast<double *>(a.data ());
   A.nz = -1;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-  S = CXSPARSE_DNAME (cs_sqr) (&A, order, 1);
-  N = CXSPARSE_DNAME (cs_qr) (&A, S);
+  S = CXSPARSE_DNAME (_sqr) (&A, order, 1);
+  N = CXSPARSE_DNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   if (!N)
     (*current_liboctave_error_handler)
       ("SparseQR: sparse matrix QR factorization filled");
   count = 1;
 #else
   (*current_liboctave_error_handler)
     ("SparseQR: sparse matrix QR factorization not implemented");
 #endif
 }
 
 SparseQR::SparseQR_rep::~SparseQR_rep (void)
 {
 #ifdef HAVE_CXSPARSE
-  CXSPARSE_DNAME (cs_sfree) (S);
-  CXSPARSE_DNAME (cs_nfree) (N);
+  CXSPARSE_DNAME (_sfree) (S);
+  CXSPARSE_DNAME (_nfree) (N);
 #endif
 }
 
 SparseMatrix 
 SparseQR::SparseQR_rep::V (void) const
 {
 #ifdef HAVE_CXSPARSE
   // Drop zeros from V and sort
   // XXX FIXME XXX Is the double transpose to sort necessary?
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-  CXSPARSE_DNAME (cs_dropzeros) (N->L);
-  CXSPARSE_DNAME (cs) *D = CXSPARSE_DNAME (cs_transpose) (N->L, 1);
-  CXSPARSE_DNAME (cs_spfree) (N->L);
-  N->L = CXSPARSE_DNAME (cs_transpose) (D, 1);
-  CXSPARSE_DNAME (cs_spfree) (D);
+  CXSPARSE_DNAME (_dropzeros) (N->L);
+  CXSPARSE_DNAME () *D = CXSPARSE_DNAME (_transpose) (N->L, 1);
+  CXSPARSE_DNAME (_spfree) (N->L);
+  N->L = CXSPARSE_DNAME (_transpose) (D, 1);
+  CXSPARSE_DNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
   octave_idx_type nc = N->L->n;
   octave_idx_type nz = N->L->nzmax;
   SparseMatrix ret (N->L->m, nc, nz);
   for (octave_idx_type j = 0; j < nc+1; j++)
     ret.xcidx (j) = N->L->p[j];
   for (octave_idx_type j = 0; j < nz; j++)
@@ -121,21 +121,21 @@ SparseQR::SparseQR_rep::P (void) const
 
 SparseMatrix 
 SparseQR::SparseQR_rep::R (const bool econ) const
 {
 #ifdef HAVE_CXSPARSE
   // Drop zeros from R and sort
   // XXX FIXME XXX Is the double transpose to sort necessary?
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-  CXSPARSE_DNAME (cs_dropzeros) (N->U);
-  CXSPARSE_DNAME (cs) *D = CXSPARSE_DNAME (cs_transpose) (N->U, 1);
-  CXSPARSE_DNAME (cs_spfree) (N->U);
-  N->U = CXSPARSE_DNAME (cs_transpose) (D, 1);
-  CXSPARSE_DNAME (cs_spfree) (D);
+  CXSPARSE_DNAME (_dropzeros) (N->U);
+  CXSPARSE_DNAME () *D = CXSPARSE_DNAME (_transpose) (N->U, 1);
+  CXSPARSE_DNAME (_spfree) (N->U);
+  N->U = CXSPARSE_DNAME (_transpose) (D, 1);
+  CXSPARSE_DNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
   octave_idx_type nc = N->U->n;
   octave_idx_type nz = N->U->nzmax;
 
   SparseMatrix ret ((econ ? (nc > nrows ? nrows : nc) : nrows), nc, nz);
 
   for (octave_idx_type j = 0; j < nc+1; j++)
@@ -167,26 +167,24 @@ SparseQR::SparseQR_rep::C (const Matrix 
   else
     {
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
 	{
 	  OCTAVE_QUIT;
 	  volatile octave_idx_type nm = (nr < nc ? nr : nc);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  // cast away const on bvec, with full knowledge that CSparse 
-	  // won't touch it
-	  CXSPARSE_DNAME (cs_ipvec) (b_nr, S->Pinv, bvec + idx, buf);
+	  CXSPARSE_DNAME (_ipvec) (b_nr, S->Pinv, bvec + idx, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  for (volatile octave_idx_type i = 0; i < nm; i++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (N->L, i, N->B[i], buf);
+	      CXSPARSE_DNAME (_happly) (N->L, i, N->B[i], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  for (octave_idx_type i = 0; i < b_nr; i++)
 	    vec[i+idx] = buf[i];
 	}
     }
   return ret;
 #else
@@ -220,30 +218,28 @@ qrsolve(const SparseMatrix&a, const Matr
       x.resize(nc, b_nc);
       double *vec = x.fortran_vec();
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
 	   i++, idx+=nc, bidx+=b_nr)
 	{
 	  OCTAVE_QUIT;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  // cast away const on bvec, with full knowledge that CSparse 
-	  // won't touch it
-	  CXSPARSE_DNAME (cs_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
+	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_usolve) (q.N()->U, buf);
-	  CXSPARSE_DNAME (cs_ipvec) (nc, q.S()->Q, buf, vec + idx);
+	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	}
     }
   else
     {
       SparseMatrix at = a.hermitian();
       SparseQR q (at, 2);
       if (! q.ok ())
@@ -254,30 +250,28 @@ qrsolve(const SparseMatrix&a, const Matr
       x.resize(nc, b_nc);
       double *vec = x.fortran_vec();
       OCTAVE_LOCAL_BUFFER (double, buf, nc > q.S()->m2 ? nc : q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
 	   i++, idx+=nc, bidx+=b_nr)
 	{
 	  OCTAVE_QUIT;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  // cast away const on bvec, with full knowledge that CSparse 
-	  // won't touch it
-	  CXSPARSE_DNAME (cs_pvec) (nr, q.S()->Q, bvec + bidx, buf);
-	  CXSPARSE_DNAME (cs_utsolve) (q.N()->U, buf);
+	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
+	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_pvec) (nc, q.S()->Pinv, buf, vec + idx);
+	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	}
     }
 
   return x;
 #else
   return Matrix ();
 #endif
@@ -313,28 +307,28 @@ qrsolve(const SparseMatrix&a, const Spar
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_ipvec) (nr, q.S()->Pinv, Xx, buf);
+	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_usolve) (q.N()->U, buf);
-	  CXSPARSE_DNAME (cs_ipvec) (nc, q.S()->Q, buf, Xx);
+	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double tmp = Xx[j];
 	      if (tmp != 0.0)
 		{
 		  if (ii == x_nz)
@@ -368,28 +362,28 @@ qrsolve(const SparseMatrix&a, const Spar
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nc > q.S()->m2 ? nc : q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_pvec) (nr, q.S()->Q, Xx, buf);
-	  CXSPARSE_DNAME (cs_utsolve) (q.N()->U, buf);
+	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
+	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_pvec) (nc, q.S()->Pinv, buf, Xx);
+	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double tmp = Xx[j];
 	      if (tmp != 0.0)
 		{
 		  if (ii == x_nz)
@@ -447,41 +441,41 @@ qrsolve(const SparseMatrix&a, const Comp
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    {
 	      Complex c = b.xelem (j,i);
 	      Xx[j] = std::real (c);
 	      Xz[j] = std::imag (c);
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_ipvec) (nr, q.S()->Pinv, Xx, buf);
+	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_usolve) (q.N()->U, buf);
-	  CXSPARSE_DNAME (cs_ipvec) (nc, q.S()->Q, buf, Xx);
+	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
 
-	  CXSPARSE_DNAME (cs_ipvec) (nr, q.S()->Pinv, Xz, buf);
+	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_usolve) (q.N()->U, buf);
-	  CXSPARSE_DNAME (cs_ipvec) (nc, q.S()->Q, buf, Xz);
+	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xz);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    vec[j+idx] = Complex (Xx[j], Xz[j]);
 	}
     }
   else
     {
       SparseMatrix at = a.hermitian();
@@ -501,40 +495,40 @@ qrsolve(const SparseMatrix&a, const Comp
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    {
 	      Complex c = b.xelem (j,i);
 	      Xx[j] = std::real (c);
 	      Xz[j] = std::imag (c);
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_pvec) (nr, q.S()->Q, Xx, buf);
-	  CXSPARSE_DNAME (cs_utsolve) (q.N()->U, buf);
+	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
+	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_pvec) (nc, q.S()->Pinv, buf, Xx);
-	  CXSPARSE_DNAME (cs_pvec) (nr, q.S()->Q, Xz, buf);
-	  CXSPARSE_DNAME (cs_utsolve) (q.N()->U, buf);
+	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
+	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_pvec) (nc, q.S()->Pinv, buf, Xz);
+	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xz);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    vec[j+idx] = Complex (Xx[j], Xz[j]);
 	}
     }
 
   return x;
 #else
@@ -577,40 +571,40 @@ qrsolve(const SparseMatrix&a, const Spar
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    {
 	      Complex c = b.xelem (j,i);
 	      Xx[j] = std::real (c);
 	      Xz[j] = std::imag (c);
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_ipvec) (nr, q.S()->Pinv, Xx, buf);
+	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_usolve) (q.N()->U, buf);
-	  CXSPARSE_DNAME (cs_ipvec) (nc, q.S()->Q, buf, Xx);
-	  CXSPARSE_DNAME (cs_ipvec) (nr, q.S()->Pinv, Xz, buf);
+	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
+	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_usolve) (q.N()->U, buf);
-	  CXSPARSE_DNAME (cs_ipvec) (nc, q.S()->Q, buf, Xz);
+	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xz);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      Complex tmp = Complex (Xx[j], Xz[j]);
 	      if (tmp != 0.0)
 		{
 		  if (ii == x_nz)
@@ -649,40 +643,40 @@ qrsolve(const SparseMatrix&a, const Spar
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    {
 	      Complex c = b.xelem (j,i);
 	      Xx[j] = std::real (c);
 	      Xz[j] = std::imag (c);
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_pvec) (nr, q.S()->Q, Xx, buf);
-	  CXSPARSE_DNAME (cs_utsolve) (q.N()->U, buf);
+	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
+	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_pvec) (nc, q.S()->Pinv, buf, Xx);
-	  CXSPARSE_DNAME (cs_pvec) (nr, q.S()->Q, Xz, buf);
-	  CXSPARSE_DNAME (cs_utsolve) (q.N()->U, buf);
+	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
+	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	      CXSPARSE_DNAME (cs_happly) (q.N()->L, j, q.N()->B[j], buf);
+	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-	  CXSPARSE_DNAME (cs_pvec) (nc, q.S()->Pinv, buf, Xz);
+	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xz);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      Complex tmp = Complex (Xx[j], Xz[j]);
 	      if (tmp != 0.0)
 		{
 		  if (ii == x_nz)
diff --git a/liboctave/SparseQR.h b/liboctave/SparseQR.h
--- a/liboctave/SparseQR.h
+++ b/liboctave/SparseQR.h
@@ -26,19 +26,19 @@ Boston, MA 02110-1301, USA.
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "dSparse.h"
 #include "CSparse.h"
 #include "oct-sparse.h"
 
 #ifdef IDX_TYPE_LONG
-#define CXSPARSE_DNAME(name) name ## _dl
+#define CXSPARSE_DNAME(name) cs_dl ## name
 #else
-#define CXSPARSE_DNAME(name) name ## _di
+#define CXSPARSE_DNAME(name) cs_di ## name
 #endif
 
 class
 SparseQR
 {
 protected:
   class SparseQR_rep
   {
@@ -60,19 +60,19 @@ protected:
     SparseMatrix R (const bool econ) const;
 
     Matrix C (const Matrix &b) const;
 
     int count;
 
     octave_idx_type nrows;
 #ifdef HAVE_CXSPARSE
-    CXSPARSE_DNAME (css) *S;
+    CXSPARSE_DNAME (s) *S;
 
-    CXSPARSE_DNAME (csn) *N;
+    CXSPARSE_DNAME (n) *N;
 #endif
   };
 private:
   SparseQR_rep *rep;
 
 public:  
   SparseQR (void) : rep (new SparseQR_rep (SparseMatrix(), -1)) { }
 
@@ -122,19 +122,19 @@ public:
 				octave_idx_type &info);
 
   friend SparseComplexMatrix qrsolve (const SparseMatrix &a, 
 				      const SparseComplexMatrix &b,
 				      octave_idx_type &info);
 
 protected:
 #ifdef HAVE_CXSPARSE
-  CXSPARSE_DNAME (css) * S (void) { return rep->S; }
+  CXSPARSE_DNAME (s) * S (void) { return rep->S; }
 
-  CXSPARSE_DNAME (csn) * N (void) { return rep->N; }
+  CXSPARSE_DNAME (n) * N (void) { return rep->N; }
 #endif
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/oct-sparse.h b/liboctave/oct-sparse.h
--- a/liboctave/oct-sparse.h
+++ b/liboctave/oct-sparse.h
@@ -67,22 +67,22 @@ extern "C" {
 #if defined (HAVE_UFSPARSE_CHOLMOD_H)
 #include <ufsparse/cholmod.h>
 #elif defined (HAVE_UMFPACK_CHOLMOD_H)
 #include <cholmod/cholmod.h>
 #elif defined (HAVE_CHOLMOD_H)
 #include <cholmod.h>
 #endif
 
-#if defined (HAVE_UFSPARSE_CXS_H)
-#include <ufsparse/cxs.h>
-#elif defined (HAVE_CXSPARSE_CXS_H)
-#include <cxsparse/cxs.h>
-#elif defined (HAVE_CXS_H)
-#include <cxs.h>
+#if defined (HAVE_UFSPARSE_CS_H)
+#include <ufsparse/cs.h>
+#elif defined (HAVE_CXSPARSE_CS_H)
+#include <cxsparse/cs.h>
+#elif defined (HAVE_CS_H)
+#include <cs.h>
 #endif
 
 #if (defined (HAVE_UFSPARSE_CHOLMOD_H) \
      || defined (HAVE_UMFPACK_CHOLMOD_H) \
      || defined (HAVE_CHOLMOD_H))
 #ifdef IDX_TYPE_LONG
 #define CHOLMOD_NAME(name) cholmod_l_ ## name
 #else
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -76,17 +76,17 @@ sparse_base_chol<chol_type, chol_elt, p_
 }
 #endif
 
 template <class chol_type, class chol_elt, class p_type>
 octave_idx_type
 sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::init 
   (const chol_type& a, bool natural)
 {
-  octave_idx_type info = 0;
+  volatile octave_idx_type info = 0;
 #ifdef HAVE_CHOLMOD
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) 
 	("SparseCHOL requires square matrix");
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,14 @@
+2006-03-08  David Bateman  <dbateman@free.fr>
+
+	* ov-mapper.cc (SPARSE_MAPPER_LOOP_2): Change nnz to nz to remove 
+	shadowed variable warning.
+	* DLD-FUNCTIONS/spqr.cc: Update for new upstream CXSPARSE release.
+
 2006-03-06  John W. Eaton  <jwe@octave.org>
 
 	* help.cc (display_help_text): Force linebreak with @sp.
 
 2006-03-06  Keith Goodman  <kwgoodman@gmail.com>
  
 	* bitfcns.cc, data.cc, debug.cc, file-io.cc, help.cc,
 	load-save.cc, mappers.cc, ov-cell.cc, ov-fcn-inline.cc,
diff --git a/src/DLD-FUNCTIONS/spqr.cc b/src/DLD-FUNCTIONS/spqr.cc
--- a/src/DLD-FUNCTIONS/spqr.cc
+++ b/src/DLD-FUNCTIONS/spqr.cc
@@ -32,19 +32,19 @@ Boston, MA 02110-1301, USA.
 
 #include "oct-sparse.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "SparseQR.h"
 #include "SparseCmplxQR.h"
 
 #ifdef IDX_TYPE_LONG
-#define CSSPARSE_NAME(name) name ## _dl
+#define CXSPARSE_NAME(name) cs_dl ## name
 #else
-#define CSSPARSE_NAME(name) name ## _di
+#define CXSPARSE_NAME(name) cs_di ## name
 #endif
 
 // PKG_ADD: dispatch ("qr", "spqr", "sparse matrix");
 // PKG_ADD: dispatch ("qr", "spqr", "sparse complex matrix");
 // PKG_ADD: dispatch ("qr", "spqr", "sparse bool matrix");
 DEFUN_DLD (spqr, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{r} =} spqr (@var{a})\n\
@@ -224,17 +224,17 @@ put_int (octave_idx_type *p, octave_idx_
   for (octave_idx_type i = 0; i < n; i++)
     ret.xelem(i) = p[i] + 1;
   return ret;
 }
 
 DEFUN_DLD (dmperm, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} dmperm (@var{s})\n\
-@deftypefnx {Loadable Function} {[@var{p}. @var{q}. @var{r}, @var{s}] =} dmperm (@var{s})\n\
+@deftypefnx {Loadable Function} {[@var{p}, @var{q}, @var{r}, @var{s}] =} dmperm (@var{s})\n\
 \n\
 @cindex Dulmage-Mendelsohn decomposition\n\
 Perform a Deulmage-Mendelsohn permutation on the sparse matrix @var{s}.\n\
 With a single output argument @dfn{dmperm} performs the row permutations\n\
 @var{p} such that @code{@var{s} (@var{p},:)} has no zero elements on the\n\
 diagonal.\n\
 \n\
 Called with two or more output arguments, returns the row and column\n\
@@ -258,17 +258,17 @@ 16(4):303-324, 1990.\n\
       return retval;
     }
 
   octave_value arg = args(0);
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
   SparseMatrix m;
   SparseComplexMatrix cm;
-  CSSPARSE_NAME (cs) csm;
+  CXSPARSE_NAME () csm;
   csm.m = nr;
   csm.n = nc;
   csm.x = NULL;
   csm.nz = -1;
 
   if (arg.is_real_type ())
     {
       m = arg.sparse_matrix_value ();
@@ -283,30 +283,30 @@ 16(4):303-324, 1990.\n\
       csm.p = cm.xcidx ();
       csm.i = cm.xridx ();
     }
 
   if (!error_state)
     {
       if (nargout <= 1)
 	{
-	  octave_idx_type *jmatch = CSSPARSE_NAME (cs_maxtrans) (&csm);
+	  octave_idx_type *jmatch = CXSPARSE_NAME (_maxtrans) (&csm);
 	  retval(0) = put_int (jmatch + nr, nc);
-	  CSSPARSE_NAME (cs_free) (jmatch);
+	  CXSPARSE_NAME (_free) (jmatch);
 	}
       else
 	{
-	  CSSPARSE_NAME (csd) *dm = CSSPARSE_NAME(cs_dmperm) (&csm);
+	  CXSPARSE_NAME (d) *dm = CXSPARSE_NAME(_dmperm) (&csm);
 	  //retval(5) = put_int (dm->rr, 5);
 	  //retval(4) = put_int (dm->cc, 5);
 	  retval(3) = put_int (dm->S, dm->nb+1);
 	  retval(2) = put_int (dm->R, dm->nb+1);
 	  retval(1) = put_int (dm->Q, nc);
 	  retval(0) = put_int (dm->P, nr);
-	  CSSPARSE_NAME (cs_dfree) (dm);
+	  CXSPARSE_NAME (_dfree) (dm);
 	}
     }
 #else
   error ("dmperm: not available in this version of Octave");
 #endif
 
   return retval;
 }
diff --git a/src/ov-mapper.cc b/src/ov-mapper.cc
--- a/src/ov-mapper.cc
+++ b/src/ov-mapper.cc
@@ -165,21 +165,21 @@ any_element_greater_than (const SparseMa
 		  return retval; \
 	      } \
 	  \
 	  result.maybe_compress (true);	\
           retval = R; \
 	} \
       else \
 	{ \
-	  octave_idx_type nnz = M.nnz (); \
+	  octave_idx_type nz = M.nnz (); \
 	  octave_idx_type nr = M.rows (); \
 	  octave_idx_type nc = M.cols (); \
 	  \
-	  T result (nr, nc, nnz); \
+	  T result (nr, nc, nz); \
 	  ET zero = ET (0.); \
 	  octave_idx_type ii = 0; \
 	  result.cidx (ii) = 0; \
 	  \
 	  for (octave_idx_type j = 0; j < nc; j++) \
 	    { \
 	      for (octave_idx_type i = M.cidx(j); i < M.cidx (j+1); i++) \
 		{ \
diff --git a/test/ChangeLog b/test/ChangeLog
--- a/test/ChangeLog
+++ b/test/ChangeLog
@@ -1,8 +1,12 @@
+2006-03-08  David Bateman  <dbateman@free.fr>
+
+	* test_system.m: Fix recursive rmdir test for recent change.
+
 2006-02-20  David Bateman  <dbateman@free.fr>
 
 	* build_spase_tests.sh: Add tests for ldiv tests for rectangular
 	diagonal, permuted diagonal, triangular and permuted triangular
 	matrices.
 
 2006-02-09  David Bateman  <dbateman@free.fr>
 
diff --git a/test/test_system.m b/test/test_system.m
--- a/test/test_system.m
+++ b/test/test_system.m
@@ -240,17 +240,21 @@
 
 %% test/octave.test/system/mkdir-2.m
 %!error <... mkdir:.*> mkdir ("foo", 1);
 
 %% test/octave.test/system/rmdir-1.m
 %!error <... rmdir:.*> rmdir ();
 
 %% test/octave.test/system/rmdir-2.m
-%!assert(!rmdir ("foo", 1));
+%!test
+%! crr = confirm_recursive_rmdir;
+%! confirm_recursive_rmdir = 0;
+%! assert(!rmdir ("foo", "s"));
+%! confirm_recursive_rmdir = crr;
 
 %% XXX FIXME XXX This test messes up the path it seems!! Why?
 %% test/octave.test/system/umask-1.m
 %!#test
 %! umask (0);
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! s1 = stat (nm);
