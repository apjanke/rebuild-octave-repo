# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1294637584 28800
#      Sun Jan 09 21:33:04 2011 -0800
# Node ID 1740012184f99e5f2e127a8d23228d5025b83aab
# Parent  994e2a93a8e211904fdcd0a4e19d5821072bb05b
Use uppercase for variable names in error() strings to match Info documentation.  Only m-files done.

diff --git a/scripts/@ftp/ftp.m b/scripts/@ftp/ftp.m
--- a/scripts/@ftp/ftp.m
+++ b/scripts/@ftp/ftp.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{f}} = ftp (@var{host})
-## @deftypefnx {Function File} {@var{f}} = ftp (@var{host}, @var{username}, @var{password})
+## @deftypefn  {Function File} {@var{f} =} ftp (@var{host})
+## @deftypefnx {Function File} {@var{f} =} ftp (@var{host}, @var{username}, @var{password})
 ## Connect to the FTP server @var{host} with @var{username} and @var{password}.
 ## If @var{username} and @var{password} are not specified, user "anonymous"
 ## with no password is used.  The returned FTP object @var{f} represents the
 ## established FTP connection.
 ## @end deftypefn
 
 function obj = ftp (host, username = "anonymous", password = "")
   if (nargin == 0)
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,122 @@
+2011-01-09  Rik  <octave@nomad.inbox5.com>
+
+	* audio/lin2mu.m, audio/loadaudio.m, audio/mu2lin.m, audio/saveaudio.m,
+	audio/wavwrite.m, deprecated/split.m, deprecated/values.m,
+	general/accumarray.m, general/bitcmp.m, general/cell2mat.m,
+	general/circshift.m, general/curl.m, general/divergence.m,
+	general/genvarname.m, general/interpft.m, general/interpn.m,
+	general/nextpow2.m, general/polyarea.m, general/repmat.m,
+	general/rot90.m, general/rotdim.m, general/shiftdim.m,
+	general/strerror.m, general/trapz.m, geometry/griddata.m,
+	geometry/griddata3.m, geometry/griddatan.m, geometry/rectint.m,
+	image/brighten.m, image/colormap.m, image/contrast.m, image/imagesc.m,
+	image/imfinfo.m, image/imread.m, linear-algebra/commutation_matrix.m,
+	linear-algebra/condest.m, linear-algebra/cross.m,
+	linear-algebra/duplication_matrix.m, linear-algebra/isdefinite.m,
+	linear-algebra/vech.m, miscellaneous/bincoeff.m, miscellaneous/cast.m,
+	miscellaneous/compare_versions.m, miscellaneous/fileparts.m,
+	miscellaneous/license.m, miscellaneous/private/__xzip__.m,
+	miscellaneous/substruct.m, miscellaneous/unpack.m, miscellaneous/xor.m,
+	optimization/sqp.m, pkg/get_forge_pkg.m, plot/backend.m,
+	plot/contourc.m, plot/cylinder.m, plot/hidden.m, plot/hold.m,
+	plot/orient.m, plot/private/__interp_cube__.m, plot/refreshdata.m,
+	plot/subplot.m, plot/surface.m, plot/surfnorm.m, plot/text.m,
+	plot/uimenu.m, polynomial/mkpp.m, polynomial/pchip.m,
+	polynomial/polyfit.m, polynomial/ppval.m, signal/arch_fit.m,
+	signal/arch_rnd.m, signal/arch_test.m, signal/arma_rnd.m,
+	signal/autoreg_matrix.m, signal/bartlett.m, signal/blackman.m,
+	signal/diffpara.m, signal/durbinlevinson.m, signal/fftfilt.m,
+	signal/fractdiff.m, signal/hamming.m, signal/hanning.m, signal/hurst.m,
+	signal/sinetone.m, signal/synthesis.m, signal/unwrap.m,
+	sparse/spaugment.m, specfun/factor.m, specfun/factorial.m,
+	specfun/legendre.m, specfun/nthroot.m, specfun/primes.m,
+	special-matrix/hadamard.m, special-matrix/magic.m,
+	statistics/distributions/betacdf.m, statistics/distributions/betainv.m,
+	statistics/distributions/betapdf.m, statistics/distributions/betarnd.m,
+	statistics/distributions/binocdf.m, statistics/distributions/binoinv.m,
+	statistics/distributions/binopdf.m, statistics/distributions/binornd.m,
+	statistics/distributions/cauchy_cdf.m,
+	statistics/distributions/cauchy_inv.m,
+	statistics/distributions/cauchy_pdf.m,
+	statistics/distributions/cauchy_rnd.m,
+	statistics/distributions/chi2cdf.m, statistics/distributions/chi2inv.m,
+	statistics/distributions/chi2pdf.m, statistics/distributions/chi2rnd.m,
+	statistics/distributions/discrete_cdf.m,
+	statistics/distributions/discrete_inv.m,
+	statistics/distributions/discrete_pdf.m,
+	statistics/distributions/discrete_rnd.m,
+	statistics/distributions/empirical_cdf.m,
+	statistics/distributions/empirical_inv.m,
+	statistics/distributions/empirical_pdf.m,
+	statistics/distributions/empirical_rnd.m,
+	statistics/distributions/expcdf.m, statistics/distributions/expinv.m,
+	statistics/distributions/exppdf.m, statistics/distributions/exprnd.m,
+	statistics/distributions/fcdf.m, statistics/distributions/finv.m,
+	statistics/distributions/fpdf.m, statistics/distributions/frnd.m,
+	statistics/distributions/gamcdf.m, statistics/distributions/gaminv.m,
+	statistics/distributions/gampdf.m, statistics/distributions/gamrnd.m,
+	statistics/distributions/geocdf.m, statistics/distributions/geoinv.m,
+	statistics/distributions/geopdf.m, statistics/distributions/geornd.m,
+	statistics/distributions/hygecdf.m, statistics/distributions/hygeinv.m,
+	statistics/distributions/hygepdf.m, statistics/distributions/hygernd.m,
+	statistics/distributions/kolmogorov_smirnov_cdf.m,
+	statistics/distributions/laplace_rnd.m,
+	statistics/distributions/logistic_rnd.m,
+	statistics/distributions/logncdf.m, statistics/distributions/logninv.m,
+	statistics/distributions/lognpdf.m, statistics/distributions/lognrnd.m,
+	statistics/distributions/nbincdf.m, statistics/distributions/nbininv.m,
+	statistics/distributions/nbinpdf.m, statistics/distributions/nbinrnd.m,
+	statistics/distributions/normcdf.m, statistics/distributions/norminv.m,
+	statistics/distributions/normpdf.m, statistics/distributions/normrnd.m,
+	statistics/distributions/poisscdf.m,
+	statistics/distributions/poissinv.m,
+	statistics/distributions/poisspdf.m,
+	statistics/distributions/poissrnd.m,
+	statistics/distributions/stdnormal_cdf.m,
+	statistics/distributions/stdnormal_rnd.m,
+	statistics/distributions/tcdf.m, statistics/distributions/tinv.m,
+	statistics/distributions/tpdf.m, statistics/distributions/trnd.m,
+	statistics/distributions/unidrnd.m, statistics/distributions/unifcdf.m,
+	statistics/distributions/unifinv.m, statistics/distributions/unifpdf.m,
+	statistics/distributions/unifrnd.m, statistics/distributions/wblcdf.m,
+	statistics/distributions/wblinv.m, statistics/distributions/wblpdf.m,
+	statistics/distributions/wblrnd.m, statistics/distributions/wienrnd.m,
+	statistics/models/logistic_regression.m, statistics/tests/anova.m,
+	statistics/tests/chisquare_test_homogeneity.m,
+	statistics/tests/cor_test.m, statistics/tests/f_test_regression.m,
+	statistics/tests/hotelling_test.m, statistics/tests/hotelling_test_2.m,
+	statistics/tests/kolmogorov_smirnov_test.m,
+	statistics/tests/kolmogorov_smirnov_test_2.m,
+	statistics/tests/manova.m, statistics/tests/mcnemar_test.m,
+	statistics/tests/prop_test_2.m, statistics/tests/sign_test.m,
+	statistics/tests/t_test.m, statistics/tests/t_test_2.m,
+	statistics/tests/t_test_regression.m, statistics/tests/u_test.m,
+	statistics/tests/var_test.m, statistics/tests/welch_test.m,
+	statistics/tests/wilcoxon_test.m, statistics/tests/z_test.m,
+	statistics/tests/z_test_2.m, strings/blanks.m, strings/index.m,
+	strings/strtrunc.m, strings/validatestring.m, time/addtodate.m,
+	time/datenum.m, time/datetick.m, time/datevec.m: Use uppercase for
+	variable names in error() strings to match Info documentation.
+
+	* general/interp2.m, image/imshow.m, image/ind2rgb.m,
+	image/saveimage.m, io/dlmwrite.m, io/strread.m, io/textscan.m,
+	linear-algebra/expm.m, linear-algebra/krylov.m, linear-algebra/logm.m,
+	miscellaneous/delete.m, miscellaneous/run.m, plot/__marching_cube__.m,
+	sparse/bicgstab.m, sparse/cgs.m, strings/strmatch.m,
+	testfun/rundemos.m, testfun/runtests.m: Rewrite error string
+
+	* @ftp/ftp.m, help/gen_doc_cache.m, miscellaneous/unix.m,
+	plot/__gnuplot_open_stream__.m, plot/private/__add_default_menu__.m,
+	polynomial/ppder.m, polynomial/ppint.m, polynomial/ppjumps.m,
+	signal/periodogram.m: Correct use of @deftypefn macro
+
+	* miscellaneous/paren.m: Space @deffnx macro for readability
+
 2011-01-09  Rik  <octave@nomad.inbox5.com>
 
 	* general/arrayfun.m, general/blkdiag.m, general/structfun.m,
 	image/imagesc.m, linear-algebra/cond.m, linear-algebra/condest.m,
 	linear-algebra/expm.m, linear-algebra/logm.m,
 	linear-algebra/onenormest.m, linear-algebra/qzhess.m,
 	optimization/glpk.m, optimization/glpkmex.m, polynomial/poly.m,
 	sparse/gplot.m, sparse/pcg.m, sparse/pcr.m, sparse/spaugment.m,
diff --git a/scripts/audio/lin2mu.m b/scripts/audio/lin2mu.m
--- a/scripts/audio/lin2mu.m
+++ b/scripts/audio/lin2mu.m
@@ -43,17 +43,17 @@ function y = lin2mu (x, n)
     elseif (range <= 128)
       n = 8;
       warning ("lin2mu: no precision specified, so using %d", n);
     else
       n = 16;
     endif
   elseif (nargin == 2)
     if (n != 0 && n != 8 && n != 16)
-      error ("lin2mu: n must be either 0, 8 or 16");
+      error ("lin2mu: N must be either 0, 8 or 16");
     endif
   else
     print_usage ();
   endif
 
   ## Transform real and n-bit format to 16-bit.
   if (n == 0)
     ## [-1,1] -> [-32768, 32768]
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -45,17 +45,17 @@ function X = loadaudio (name, ext, bps)
 
   if (nargin == 1)
     ext = "lin";
   endif
 
   if (nargin < 3)
     bps = 8;
   elseif (bps != 8 && bps != 16)
-    error ("loadaudio: bps must be either 8 or 16");
+    error ("loadaudio: BPS must be either 8 or 16");
   endif
 
   name = [name, ".", ext];
   num = fopen (name, "rb");
 
   if (strcmp (ext, "lin") || strcmp (ext, "raw") || strcmp (ext, "pcm"))
     if (bps == 8)
       [Y, c] = fread (num, inf, "uchar");
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -32,17 +32,17 @@
 
 function y = mu2lin (x, n)
 
   if (nargin == 1)
     ## COMPATIBILITY -- n defaults to 8 for Octave, 0 for Matlab
     n = 8;
   elseif (nargin == 2)
     if (n != 0 && n != 8 && n != 16)
-      error ("mu2lin: n must be either 0, 8, or 16");
+      error ("mu2lin: N must be either 0, 8, or 16");
     endif
   else
     print_usage ();
   endif
 
   ulaw = [32124, 31100, 30076, 29052, 28028, 27004, 25980, 24956, \
           23932, 22908, 21884, 20860, 19836, 18812, 17788, 16764, \
           15996, 15484, 14972, 14460, 13948, 13436, 12924, 12412, \
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -39,17 +39,17 @@ function saveaudio (name, x, ext, bps)
 
   if (nargin == 2)
     ext = "lin";
   endif
 
   if (nargin < 4)
     bps = 8;
   elseif (bps != 8 && bps != 16)
-    error ("saveaudio: bps must be either 8 or 16");
+    error ("saveaudio: BPS must be either 8 or 16");
   endif
 
   [nr, nc] = size (x);
   if (nc != 1)
     if (nr == 1)
       x = x';
       nr = nc;
     else
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -92,17 +92,17 @@ function wavwrite (y, varargin)
   [n, channels] = size(y);
 
   ## size of data chunk
   ck_size = n*channels*(bits_per_sample/8);
   
   ## open file for writing binary
 
   if (! ischar (filename))
-    error ("wavwrite: expecting filename to be a character string");
+    error ("wavwrite: expecting FILENAME to be a character string");
   endif
     
   [fid, msg] = fopen (filename, "wb");
   if (fid < 0)
     error ("wavwrite: %s", msg);
   endif
   
   ## write RIFF/WAVE header
diff --git a/scripts/deprecated/split.m b/scripts/deprecated/split.m
--- a/scripts/deprecated/split.m
+++ b/scripts/deprecated/split.m
@@ -72,17 +72,17 @@ function m = split (s, t, n)
 
       if (l_s == 0)
         m = "";
         return;
       elseif (l_t == 0)
         m = s';
         return;
       elseif (l_s < l_t)
-        error ("split: s must not be shorter than t");
+        error ("split: S must not be shorter than T");
       endif
 
       if (min (size (s)) != 1 || min (size (t)) != 1)
         error("split: multi-line strings are not supported");
       endif
 
       ind = findstr (s, t, 0);
       if (length (ind) == 0)
@@ -102,17 +102,17 @@ function m = split (s, t, n)
       m = repmat (" ", m_rows, m_cols);
 
       ## Copy the strings to the matrix.
       for i = 1:length (ind)
         tmp = ind2(i):(ind(i)-1);
         m(i,1:length(tmp)) = s(tmp);
       endfor
     else
-      error ("split: both s and t must be strings");
+      error ("split: both S and T must be strings");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!assert(all (all (split ("Test string", "t") == ["Tes "; " s  "; "ring"])));
diff --git a/scripts/deprecated/values.m b/scripts/deprecated/values.m
--- a/scripts/deprecated/values.m
+++ b/scripts/deprecated/values.m
@@ -40,17 +40,17 @@ function v = values (x)
              "values is obsolete and will be removed from a future version of Octave; please use unique instead");
   endif
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! (isvector (x)))
-    error ("values: x must be a vector");
+    error ("values: X must be a vector");
   endif
 
   i = any (isnan (x));
   ## HACK!
   x = x(find(!isnan (x)));
   n = length (x);
   x = reshape (x, n, 1);
   s = sort (x);
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -88,17 +88,17 @@ function A = accumarray (subs, vals, sz 
     issparse = false;
   endif
 
   if (issparse)
 
     ## Sparse case. Avoid linearizing the subscripts, because it could overflow.
 
     if (fillval != 0)
-      error ("accumarray: fillval must be zero in the sparse case");
+      error ("accumarray: FILLVAL must be zero in the sparse case");
     endif
 
     ## Ensure subscripts are a two-column matrix.
     if (iscell (subs))
       subs = [subs{:}];
     endif
 
     ## Validate dimensions.
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -38,17 +38,17 @@
 
 function C = bitcmp (A, k)
   
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin == 2 && (! isscalar (k) || (floor (k) != k)))
-    error ("bitcmp: k must be a scalar integer");
+    error ("bitcmp: K must be a scalar integer");
   endif
 
   if (isa (A, "double"))
     bmax = bitmax;
     amax = ceil (log2 (bmax));
   else
     if (isa (A, "uint8"))
       amax = 8;
diff --git a/scripts/general/cell2mat.m b/scripts/general/cell2mat.m
--- a/scripts/general/cell2mat.m
+++ b/scripts/general/cell2mat.m
@@ -28,17 +28,17 @@
 
 function m = cell2mat (c)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! iscell (c))
-    error ("cell2mat: c is not a cell array");
+    error ("cell2mat: C is not a cell array");
   endif
   
   nb = numel (c);
 
   if (nb == 0)
     m = [];
   else
 
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -50,21 +50,21 @@ function y = circshift (x, n)
   if (nargin == 2)
     if (isempty (x))
       y = x;
     else
       nd = ndims (x);
       sz = size (x);
 
       if (! isvector (n) && length (n) > nd)
-        error ("circshift: n must be a vector, no longer than the number of dimension in x");
+        error ("circshift: N must be a vector, no longer than the number of dimension in X");
       endif
     
       if (any (n != floor (n)))
-        error ("circshift: all values of n must be integers");
+        error ("circshift: all values of N must be integers");
       endif
 
       idx = cell ();
       for i = 1:length (n);
         nn = n(i);
         if (nn < 0)
           while (sz(i) <= -nn)
             nn = nn + sz(i);
diff --git a/scripts/general/curl.m b/scripts/general/curl.m
--- a/scripts/general/curl.m
+++ b/scripts/general/curl.m
@@ -71,22 +71,22 @@ function varargout = curl (varargin)
     dy = varargin{2}(:,1,1)(:);
     dz = varargin{3}(1,1,:)(:);
   else
     print_usage();
   endif
     
   if ((nargin == 4) || (nargin == 2))
     if (!size_equal (varargin{fidx}, varargin{fidx + 1}))
-      error ("curl: size of x and y must match.");
+      error ("curl: size of X and Y must match.");
     elseif (ndims (varargin{fidx}) != 2)
-      error ("curl: expected two-dimensional matrices x and y.");
+      error ("curl: expected two-dimensional matrices X and Y.");
     elseif ((length (dx) != columns (varargin{fidx}))
          || (length (dy) != rows (varargin{fidx})))
-      error ("curl: size of dx and dy must match the respective dimension of x and y");
+      error ("curl: size of dx and dy must match the respective dimension of X and Y");
     endif
 
     dFx_dy = gradient (varargin{fidx}.', dy, dx).';
     dFy_dx = gradient (varargin{fidx + 1}, dx, dy);
     rot_z = dFy_dx - dFx_dy;
     av = rot_z / 2;
     if (nargout == 0)
       av
@@ -96,23 +96,23 @@ function varargout = curl (varargin)
       varargout{1} = rot_z;
       varargout{2} = av;
     else
       error ("curl: number of output arguments must be 1 or 2.")
     endif
 
   elseif ((nargin == 6) || (nargin == 3))
     if (!size_equal (varargin{fidx}, varargin{fidx + 1}, varargin{fidx + 2}))
-      error ("curl: size of x, y, and z must match")
+      error ("curl: size of X, Y, and Z must match")
     elseif (ndims (varargin{fidx}) != 3)
-      error ("curl: expected two-dimensional matrices x, y, and z.");
+      error ("curl: expected two-dimensional matrices X, Y, and Z.");
     elseif ((length (dx) != size (varargin{fidx}, 2))
          || (length (dy) != size (varargin{fidx}, 1))
          || (length (dz) != size (varargin{fidx}, 3)))
-      error ("curl: size of dx, dy, and dz must match the respective dimesion of x, y, and z.");
+      error ("curl: size of dx, dy, and dz must match the respective dimesion of X, Y, and Z.");
     endif
 
     [~, dFx_dy, dFx_dz] = gradient (varargin{fidx}, dx, dy, dz);
     [dFy_dx, ~, dFy_dz] = gradient (varargin{fidx + 1}, dx, dy, dz);
     [dFz_dx, dFz_dy] = gradient (varargin{fidx + 2}, dx, dy, dz);
     rot_x = dFz_dy - dFy_dz;
     rot_y = dFx_dz - dFz_dx;
     rot_z = dFy_dx - dFx_dy;
diff --git a/scripts/general/divergence.m b/scripts/general/divergence.m
--- a/scripts/general/divergence.m
+++ b/scripts/general/divergence.m
@@ -68,35 +68,35 @@ function retval = divergence (varargin)
     dy = varargin{2}(:,1,1)(:);
     dz = varargin{3}(1,1,:)(:);
   else
     print_usage();
   endif
     
   if ((nargin == 4) || (nargin == 2))
     if (!size_equal (varargin{fidx},varargin{fidx + 1}))
-      error ("divergence: size of x and y must match.");
+      error ("divergence: size of X and Y must match.");
     elseif (ndims (varargin{fidx}) != 2)
-      error ("divergence: expected two-dimensional matrices x and y.");
+      error ("divergence: expected two-dimensional matrices X and Y.");
     elseif ((length (dx) != columns (varargin{fidx})) || (length (dy) != rows (varargin{fidx})))
-      error ("divergence: size of dx and dy must match the respective dimension of x and y");
+      error ("divergence: size of dx and dy must match the respective dimension of X and Y");
     endif
 
     retval = gradient(varargin{fidx}, dx, dy);
     retval += gradient(varargin{fidx + 1}.', dy, dx).';
     
   elseif ((nargin == 6) || (nargin == 3))
     if (!size_equal (varargin{fidx},varargin{fidx + 1},varargin{fidx + 2}))
-      error ("divergence: size of x, y, and z must match")
+      error ("divergence: size of X, Y, and Z must match")
     elseif (ndims (varargin{fidx}) != 3)
-      error ("divergence: expected two-dimensional matrices x, y, and z.");
+      error ("divergence: expected two-dimensional matrices X, Y, and Z.");
     elseif ((length (dx) != size (varargin{fidx}, 2))
          || (length (dy) != size (varargin{fidx}, 1))
          || (length (dz) != size (varargin{fidx}, 3)))
-      error ("divergence: size of dx, dy, and dz must match the respective dimesion of x, y, and z.");
+      error ("divergence: size of dx, dy, and dz must match the respective dimesion of X, Y, and Z.");
     endif
 
     ## x-direction
     retval = gradient (varargin{fidx}, dx, dy, dz);
     ## y-direction
     retval += shiftdim (gradient (shiftdim (varargin{fidx + 1}, 2), dy), 1);
     ## z-direction
     retval += shiftdim (gradient (shiftdim (varargin{fidx + 2}, 1), dz), 2);
diff --git a/scripts/general/genvarname.m b/scripts/general/genvarname.m
--- a/scripts/general/genvarname.m
+++ b/scripts/general/genvarname.m
@@ -104,25 +104,25 @@ function varname = genvarname (str, excl
   if (nargin < 2)
     exclusions = {};
   elseif (ischar (exclusions))
     if (rows (exclusions) != 1)
       error ("genvarname: if more than one exclusion is given, it must be a cellstr");
     endif
     exclusions = {exclusions};
   elseif (! iscellstr (exclusions))
-    error ("genvarname: exclusions must be a string or a cellstr");
+    error ("genvarname: EXCLUSIONS must be a string or a cellstr");
   endif
   if (ischar (str))
     if (rows (str) != 1)
-      error ("genvarname: if more than one str is given, it must be a cellstr");
+      error ("genvarname: if more than one STR is given, it must be a cellstr");
     endif
     str = {str};
   elseif (! iscellstr (str))
-    error ("genvarname: str must be a string or a cellstr");
+    error ("genvarname: STR must be a string or a cellstr");
   endif
 
   validchars = cstrcat ("A":"Z", "a":"z", "0":"9", "_");
 
   varname = cell (size (str));
   for i = 1:numel (str)
     ## Perform any modifications to the varname to make sure that it is
     ## a valid variable name.
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -130,70 +130,70 @@ function ZI = interp2 (varargin)
     case 7
         [X, Y, Z, XI, YI, method, extrapval] = deal (varargin{:});
     otherwise
       print_usage ();
   endswitch
 
   ## Type checking.
   if (!ismatrix (Z))
-    error ("interp2: expected matrix Z"); 
+    error ("interp2: Z must be a matrix"); 
   endif
   if (!isempty (n) && !isscalar (n))
-    error ("interp2: expected scalar n"); 
+    error ("interp2: N must be a scalar"); 
   endif
   if (!ischar (method))
-    error ("interp2: expected string 'method'"); 
+    error ("interp2: METHOD must be a string"); 
   endif
   if (ischar (extrapval) || strcmp (extrapval, "extrap"))
     extrapval = [];
   elseif (!isscalar (extrapval))
-    error ("interp2: expected n extrapval");
+    error ("interp2: EXTRAPVAL must be a scalar");
   endif
 
   ## Define X, Y, XI, YI if needed
   [zr, zc] = size (Z);
   if (isempty (X))
     X = 1:zc; 
     Y = 1:zr;
   endif
   if (! isnumeric (X) || ! isnumeric (Y))
-    error ("interp2: expected numeric X, Y"); 
+    error ("interp2: X, Y must be numeric matrices"); 
   endif
   if (! isempty (n))
     p = 2^n; 
     XI = (p:p*zc)/p; 
     YI = (p:p*zr)'/p; 
   endif
   if (! isnumeric (XI) || ! isnumeric (YI))
-    error ("interp2: expected numeric XI, YI"); 
+    error ("interp2: XI, YI must be numeric"); 
   endif
 
 
   if (strcmp (method, "linear") || strcmp (method, "nearest") ...
       || strcmp (method, "pchip"))
 
     ## If X and Y vectors produce a grid from them
     if (isvector (X) && isvector (Y))
       X = X(:); Y = Y(:);
     elseif (size_equal (X, Y))
       X = X(1,:)'; Y = Y(:,1);
     else
       error ("interp2: X and Y must be matrices of same size");
     endif
     if (columns (Z) != length (X) || rows (Z) != length (Y))
-      error ("interp2: X and Y size must match Z dimensions");
+      error ("interp2: X and Y size must match the dimensions of Z");
     endif
 
     ## If Xi and Yi are vectors of different orientation build a grid
     if ((rows (XI) == 1 && columns (YI) == 1)
         || (columns (XI) == 1 && rows (YI) == 1))
       [XI, YI] = meshgrid (XI, YI);
     elseif (! size_equal (XI, YI))
-      error ("interp2: XI and YI must be matrices of same size");
+      error ("interp2: XI and YI must be matrices of equal size");
     endif
 
     ## if XI, YI are vectors, X and Y should share their orientation.
     if (rows (XI) == 1)
       if (rows (X) != 1)
         X = X.';
       endif
       if (rows (Y) != 1)
@@ -322,31 +322,31 @@ function ZI = interp2 (varargin)
 
   else
 
     ## Check dimensions of X and Y
     if (isvector (X) && isvector (Y))
       X = X(:).';
       Y = Y(:);
       if (!isequal ([length(Y), length(X)], size(Z)))
-        error ("interp2: X and Y size must match Z dimensions");
+        error ("interp2: X and Y size must match the dimensions of Z");
       endif
     elseif (!size_equal (X, Y))
-      error ("interp2: X and Y must be matrices of same size");
+      error ("interp2: X and Y must be matrices of equal size");
       if (! size_equal (X, Z))
-        error ("interp2: X and Y size must match Z dimensions");
+        error ("interp2: X and Y size must match the dimensions of Z");
       endif
     endif
 
     ## Check dimensions of XI and YI
     if (isvector (XI) && isvector (YI))
       XI = XI(:).';
       YI = YI(:);
     elseif (! size_equal (XI, YI))
-      error ("interp2: XI and YI must be matrices of same size");
+      error ("interp2: XI and YI must be matrices of equal size");
     endif
 
     ## FIXME bicubic/__splinen__ don't handle arbitrary XI, YI.
     if (strcmp (method, "cubic"))
       ## Please remove the dummy zero when bicubic is fixed.
       if (0 && isgriddata (XI) && isgriddata (YI'))
         ZI = bicubic (X, Y, Z, XI (1, :), YI (:, 1), extrapval);
       elseif (isgriddata (X) && isgriddata (Y'))
@@ -401,17 +401,17 @@ function ZI = interp2 (varargin)
     elseif (strcmp (method, "spline"))
       if (isgriddata (XI) && isgriddata (YI'))
         ZI = __splinen__ ({Y(:,1).', X(1,:)}, Z, {YI(:,1), XI(1,:)}, extrapval, 
                         "spline");
       else
         error ("interp2: input data must have `meshgrid' format");
       endif
     else
-      error ("interp2: interpolation method not recognized");
+      error ("interp2: interpolation METHOD not recognized");
     endif
 
   endif
 endfunction
 
 function b = isgriddata (X)
   d1 = diff (X, 1, 1);
   b = all (d1 (:) == 0);
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -50,17 +50,17 @@ function z = interpft (x, n, dim)
     if (isvector (x) && size (x, 1) == 1)
       dim = 2;
     else
       dim = 1;
     endif
   endif
 
   if (! isscalar (n))
-    error ("interpft: n must be an integer scalar");
+    error ("interpft: N must be an integer scalar");
   endif
 
   nd = ndims (x);
 
   if (dim < 1 || dim > nd)
     error ("interpft: integrating over invalid dimension");
   endif
 
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -87,17 +87,17 @@ function vi = interpn (varargin)
   endif
 
   if (nargs < 3)
     v = varargin{1};
     m = 1;
     if (nargs == 2)
       m = varargin{2};
       if (! isnumeric (m) || ! isscalar (m) || floor (m) != m)
-        error ("interpn: m is expected to be a integer scalar");
+        error ("interpn: M is expected to be a integer scalar");
       endif
     endif
     sz = size (v);
     nd = ndims (v);
     x = cell (1, nd);
     y = cell (1, nd);
     for i = 1 : nd;
       x{i} = 1 : sz(i);
@@ -194,17 +194,17 @@ function vi = interpn (varargin)
         idx {i} = q;
       endfor
       vi = vi (cellfun (@(x) sub2ind (size(vi), x{:}), idx));
       vi = reshape (vi, size(y{1}));
     endif
   elseif (strcmp (method, "cubic")) 
     error ("interpn: cubic interpolation not yet implemented");
   else
-    error ("interpn: unrecognized interpolation method");
+    error ("interpn: unrecognized interpolation METHOD");
   endif
 
 endfunction
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,4]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -37,17 +37,17 @@
 
 function n = nextpow2 (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! (isscalar (x) || isvector (x)))
-    error ("nextpow2: x must be a scalar or a vector");
+    error ("nextpow2: X must be a scalar or a vector");
   endif
 
   t = length (x);
   if (t > 1)
     x = t;
   endif
 
   [f, n] = log2 (abs (x));
diff --git a/scripts/general/polyarea.m b/scripts/general/polyarea.m
--- a/scripts/general/polyarea.m
+++ b/scripts/general/polyarea.m
@@ -52,17 +52,17 @@ function a = polyarea (x, y, dim)
     print_usage ();
   elseif (size_equal (x, y))
     if (nargin == 2)
       a = abs (sum (x .* (shift (y, -1) - shift (y, 1)))) / 2;
     else
       a = abs (sum (x .* (shift (y, -1, dim) - shift (y, 1, dim)), dim)) / 2;
     endif
   else
-    error ("polyarea: x and y must have the same shape");
+    error ("polyarea: X and Y must have the same shape");
   endif
 endfunction
 
 %!shared x, y
 %! x = [1;1;3;3;1];
 %! y = [1;3;3;1;1];
 %!assert (polyarea(x,y), 4, eps)
 %!assert (polyarea([x,x],[y,y]), [4,4], eps)
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -33,17 +33,17 @@
 function x = repmat (A, m, n)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin == 3)
     if (! (isscalar (m) && isscalar (n)))
-      error ("repmat: with 3 arguments m and n must be scalar");
+      error ("repmat: with 3 arguments M and N must be scalar");
     endif
     idx = [m, n];
   else 
     if (isscalar (m))
       idx = [m, m];
       n = m;
     elseif (isvector (m) && length (m) > 1)
       ## Ensure that we have a row vector
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -60,17 +60,17 @@ function B = rot90 (A, k)
       k = 1;
     endif
 
     if (ndims (A) > 2)
       error ("rot90: Only works with 2-D arrays");
     endif
 
     if (imag (k) != 0 || fix (k) != k)
-      error ("rot90: k must be an integer");
+      error ("rot90: K must be an integer");
     endif
 
     k = rem (k, 4);
 
     if (k < 0)
       k = k + 4;
     endif
 
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -84,17 +84,17 @@ function y = rotdim (x, n, plane)
       plane = [1, 2];
     elseif (length (plane) < 2)
       plane = [1, plane];
     endif
   else
     if (! (isvector (plane) && length (plane) == 2
            && all (plane == round (plane)) && all (plane > 0)
            && all (plane < (nd + 1)) && plane(1) != plane(2)))
-      error ("rotdim: plane must be a 2 element integer vector defining a valid plane");
+      error ("rotdim: PLANE must be a 2 element integer vector defining a valid PLANE");
     endif
   endif
 
   n = rem (n, 4);
   if (n < 0)
     n = n + 4;
   endif
   if (n == 0)
diff --git a/scripts/general/shiftdim.m b/scripts/general/shiftdim.m
--- a/scripts/general/shiftdim.m
+++ b/scripts/general/shiftdim.m
@@ -60,17 +60,17 @@ function [y, ns]  = shiftdim (x, n)
     ## Find the first singleton dimension.
     n = 0;
     while (n < nd && orig_dims(n+1) == 1)
       n++;
     endwhile
   endif
 
   if (! isscalar (n) || floor (n) != n)
-    error ("shiftdim: n must be a scalar integer");
+    error ("shiftdim: N must be a scalar integer");
   endif
 
   if (n >= nd)
     n = rem (n, nd);
   endif
 
   if (n < 0)
     singleton_dims = ones (1, -n);
diff --git a/scripts/general/strerror.m b/scripts/general/strerror.m
--- a/scripts/general/strerror.m
+++ b/scripts/general/strerror.m
@@ -54,13 +54,13 @@ function msg = strerror (name, num)
     elseif (num == 4)
       msg = "iteration limit exceeded\n";
     else
       error ("strerror: unrecognized error code for fsolve");
     endif
 
   else
 
-    error ("strerror: unrecognized function name");
+    error ("strerror: unrecognized function NAME");
 
   endif
 
 endfunction
diff --git a/scripts/general/trapz.m b/scripts/general/trapz.m
--- a/scripts/general/trapz.m
+++ b/scripts/general/trapz.m
@@ -80,17 +80,17 @@ function z = trapz (x, y, dim)
   idx2 = idx1;
   idx1{dim} = 2 : n;    
   idx2{dim} = 1 : (n - 1);
 
   if (! have_x)
     z = 0.5 * sum (x(idx1{:}) + x(idx2{:}), dim);
   else
     if (! size_equal (x, y))
-      error ("trapz: x and y must have same shape");
+      error ("trapz: X and Y must have same shape");
     endif
     z = 0.5 * sum ((x(idx1{:}) - x(idx2{:})) .* 
                    (y(idx1{:}) + y(idx2{:})), dim);
   endif
 endfunction
 
 %!assert (trapz(1:5), 12)
 %!assert (trapz(0:0.5:2,1:5), 6)
diff --git a/scripts/geometry/griddata.m b/scripts/geometry/griddata.m
--- a/scripts/geometry/griddata.m
+++ b/scripts/geometry/griddata.m
@@ -50,29 +50,29 @@ function [rx, ry, rz] = griddata (x, y, 
   if (ischar (method))
     method = tolower (method);
   endif
 
   if (isvector (x) && isvector (y) && all ([numel(y), numel(x)] == size (z)))
     [x, y] = meshgrid (x, y);
   elseif (! all (size (x) == size (y) & size (x) == size (z)))
     if (isvector (z))
-      error ("griddata: x, y, and z, be vectors of same length.");
+      error ("griddata: X, Y, and Z, be vectors of same length.");
     else
-      error ("griddata: lengths of x, y must match the columns and rows of z.");
+      error ("griddata: lengths of X, Y must match the columns and rows of Z.");
     endif
   endif
 
   ## Meshgrid xi and yi if they are a row and column vector.
   if (rows (xi) == 1 && columns (yi) == 1)
     [xi, yi] = meshgrid (xi, yi);
   endif
 
   if (! size_equal (xi, yi))
-    error ("griddata: xi and yi must be vectors or matrices of same size");
+    error ("griddata: XI and YI must be vectors or matrices of same size");
   endif
 
   [nr, nc] = size (xi);
 
   x = x(:);
   y = y(:);
   z = z(:);
 
@@ -121,17 +121,17 @@ function [rx, ry, rz] = griddata (x, y, 
     ## Calculate D of plane equation
     ## Ax+By+Cz+D = 0;
     D = -(N(:,1) .* x1 + N(:,2) .* y1 + N(:,3) .* z1);
 
     ## Calculate zi by solving plane equation for xi, yi.
     zi(valid) = -(N(:,1).*xi(:)(valid) + N(:,2).*yi(:)(valid) + D) ./ N(:,3);
 
   else
-    error ("griddata: unknown interpolation method");
+    error ("griddata: unknown interpolation METHOD");
   endif
 
   if (nargout == 3)
     rx = xi;
     ry = yi;
     rz = zi;
   elseif (nargout == 1)
     rx = zi;
diff --git a/scripts/geometry/griddata3.m b/scripts/geometry/griddata3.m
--- a/scripts/geometry/griddata3.m
+++ b/scripts/geometry/griddata3.m
@@ -32,28 +32,28 @@
 
 function vi = griddata3 (x, y, z, v, xi, yi, zi, method, varargin)
         
   if (nargin < 7)
     print_usage ();
   endif
 
   if (!all (size (x) == size (y) & size (x) == size(z) & size(x) == size (v)))
-    error ("griddata3: x, y, z, and v must be vectors of same length");
+    error ("griddata3: X, Y, Z, and V must be vectors of same length");
   endif
 
   ## meshgrid xi, yi and zi if they are vectors unless they
   ## are vectors of the same length 
   if (isvector (xi) && isvector (yi) && isvector (zi)
       && (numel (xi) != numel (yi) || numel (xi) != numel (zi)))
     [xi, yi, zi] = meshgrid (xi, yi, zi);
   endif
 
   if (any (size(xi) != size(yi)) || any (size(xi) != size(zi)))
-    error ("griddata3: xi, yi and zi must be vectors or matrices of same size");
+    error ("griddata3: XI, YI and ZI must be vectors or matrices of same size");
   endif
 
   vi = griddatan ([x(:), y(:), z(:)], v(:), [xi(:), yi(:), zi(:)], varargin{:});
   vi = reshape (vi, size (xi));
 endfunction
 
 %!testif HAVE_QHULL
 %! rand('state', 0);
diff --git a/scripts/geometry/griddatan.m b/scripts/geometry/griddatan.m
--- a/scripts/geometry/griddatan.m
+++ b/scripts/geometry/griddatan.m
@@ -75,17 +75,17 @@ function yi = griddatan (x, y, xi, metho
     ## assign x,y for each point of simplex
     xt =  reshape (x(tri(tri_list,:),:), [nr_t, n+1, n]);
     yt = y(tri(tri_list,:));
 
     ## Use barycentric coordinate of point to calculate yi
     yi(valid) = sum (y(tri(tri_list,:)) .* bary_list, 2);
 
   else
-    error ("griddatan: unknown interpolation method");
+    error ("griddatan: unknown interpolation METHOD");
   endif
 
 endfunction
 
 %!testif HAVE_QHULL
 %! [xx,yy] = meshgrid(linspace(-1,1,32));
 %! xi = [xx(:), yy(:)];
 %! x = (2 * rand(100,2) - 1);
diff --git a/scripts/geometry/rectint.m b/scripts/geometry/rectint.m
--- a/scripts/geometry/rectint.m
+++ b/scripts/geometry/rectint.m
@@ -35,19 +35,19 @@
 
 function area = rectint (a, b)
         
   if (nargin != 2)
     print_usage ();
   elseif (ndims (a) != 2 || ndims (b) != 2)
     error ("rectint: expecting arguments to be 2-d arrays");
   elseif (columns (a) != 4)
-    error ("rectint: a must have 4 columns");
+    error ("rectint: A must have 4 columns");
   elseif (columns (b) != 4)
-    error ("rectint: b must have 4 columns");
+    error ("rectint: B must have 4 columns");
   elseif any ([a(:,3:4);b(:,3:4)](:) < 0)
     error ("rectint: all widths and heights must be > 0");
   endif
 
   ## This runs faster if the number of rows of a is greater than the
   ## number of rows of b.  Swap them and transpose to make it run
   ## faster.
   swapinputs = false ();
diff --git a/scripts/help/gen_doc_cache.m b/scripts/help/gen_doc_cache.m
--- a/scripts/help/gen_doc_cache.m
+++ b/scripts/help/gen_doc_cache.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} gen_doc_cache (@var{out_file}, @var{directory})
+## @deftypefn {Function File} {} gen_doc_cache (@var{out_file}, @var{directory})
 ## Generate documentation caches for all functions in a given directory.
 ##
 ## A documentation cache is generated for all functions in @var{directory}. 
 ## The
 ## resulting cache is saved in the file @var{out_file}.
 ## The cache is used to speed up @code{lookfor}.
 ##
 ## If no directory is given (or it is the empty matrix), a cache for builtin
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
--- a/scripts/image/brighten.m
+++ b/scripts/image/brighten.m
@@ -49,17 +49,17 @@ function rmap = brighten (arg1, beta)
     else
       error ("brighten: first argument must be an Nx3 matrix or a handle");
     endif
   else
     print_usage ();
   endif
 
   if (! isscalar (beta) || beta <= -1 || beta >= 1)
-    error ("brighten: beta must be a scalar in the range (-1,1)");
+    error ("brighten: BETA must be a scalar in the range (-1,1)");
   endif
 
   if (beta > 0)
     gamma = 1 - beta;
   else
     gamma = 1 / (1 + beta);
   endif
 
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -51,20 +51,20 @@ function cmap = colormap (map)
         map = jet (64);
       else
         map = feval (map);
       endif
     endif
 
     if (! isempty (map))
       if (columns (map) != 3)
-        error ("colormap: map must have 3 columns: [R,G,B]");
+        error ("colormap: MAP must have 3 columns: [R,G,B]");
       endif
       if (min (min (map)) < 0 || max (max (map)) > 1)
-        error ("colormap: map must have values in [0,1]");
+        error ("colormap: MAP must have values in [0,1]");
       endif
       ## Set the new color map
       set (gcf (), "colormap", map);
     endif
 
   endif
 
   ## Return current color map.
diff --git a/scripts/image/contrast.m b/scripts/image/contrast.m
--- a/scripts/image/contrast.m
+++ b/scripts/image/contrast.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 function map = contrast (x, n)
 
   if (nargin == 1)
     n = rows (colormap);
   elseif (nargin == 2)
     if (! isscalar (n))
-      error ("contrast: n must be a scalar");
+      error ("contrast: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   x = x(:);
   minx = min (x);
   map = find (diff (sort ([round(n * ((x - minx) ./ (max(x) - minx))); [0:n]'])));
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -110,12 +110,12 @@ function ret = __imagesc__ (ax, x, y, A,
 
   ret = image (ax, x, y, A);
   set (ret, "cdatamapping", "scaled")
 
   ## use given limits or guess them from the matrix
   if (length (limits) == 2 && limits(2) >= limits(1))
     set (ax, "clim", limits);
   elseif (! isempty (limits))
-    error ("imagesc: expected data limits to be [lo, hi]");
+    error ("imagesc: expected data LIMITS to be [lo, hi]");
   endif
 
 endfunction
diff --git a/scripts/image/imfinfo.m b/scripts/image/imfinfo.m
--- a/scripts/image/imfinfo.m
+++ b/scripts/image/imfinfo.m
@@ -110,17 +110,17 @@
 
 function info = imfinfo (filename)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   if (!ischar (filename))
-    error ("imfinfo: filename must be a string");
+    error ("imfinfo: FILENAME must be a string");
   endif
 
   filename = tilde_expand (filename);
 
   delete_file = false;
 
   unwind_protect
 
diff --git a/scripts/image/imread.m b/scripts/image/imread.m
--- a/scripts/image/imread.m
+++ b/scripts/image/imread.m
@@ -37,17 +37,17 @@
 
 function varargout = imread (filename, varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   if (! ischar (filename))
-    error ("imread: filename must be a string");
+    error ("imread: FILENAME must be a string");
   endif
 
   filename = tilde_expand (filename);
 
   fn = file_in_path (IMAGE_PATH, filename);
 
   if (isempty (fn))
     error ("imread: cannot find %s", filename);
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -67,17 +67,17 @@ function h = imshow (im, varargin)
     [im, map] = imread (im);
     indexed = true;
     colormap (map);
   endif
 
   nd = ndims (im);
 
   if (! ((isnumeric (im) || islogical (im)) && (nd == 2 || nd == 3)))
-    error ("imshow: first argument must be an image or the filename of an image");
+    error ("imshow: IM must be an image or the filename of an image");
   endif
 
   if (nd == 2)
     if (! indexed)
       colormap (gray ());
     endif
   elseif (size (im, 3) == 3)
     if (ismember (class (im), {"uint8", "uint16", "double", "single"}))
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -37,22 +37,22 @@ function [R, G, B] = ind2rgb (x, map)
   if (nargin < 1 || nargin > 2)
     print_usage ();
   elseif (nargin == 1)
     map = colormap ();
   endif
 
   ## Check if X is an indexed image.
   if (ndims (x) != 2 || any (x(:) != round (x(:))) || min (x(:)) < 1)
-    error ("ind2rgb: first input argument must be an indexed image");
+    error ("ind2rgb: X must be an indexed image");
   endif
   
   ## Check the color map.
   if (ndims (map) != 2 || columns (map) != 3)
-    error ("ind2rgb: second input argument must be a color map");
+    error ("ind2rgb: MAP must be a valid colormap");
   endif
 
   ## Do we have enough colors in the color map?
   maxidx = max (x(:));
   rm = rows (map);
   if (rm < maxidx)
     ## Pad with the last color in the map.
     pad = repmat (map(end,:), maxidx-rm, 1);
diff --git a/scripts/image/saveimage.m b/scripts/image/saveimage.m
--- a/scripts/image/saveimage.m
+++ b/scripts/image/saveimage.m
@@ -87,35 +87,35 @@ function saveimage (fname, img, fmt, map
     else
       map = colormap ();
     endif
   endif
 
   [map_nr, map_nc] = size (map);
 
   if (map_nc != 3)
-    error ("saveimage: colormap should be an N x 3 matrix");
+    error ("saveimage: MAP must be an N x 3 matrix");
   endif
 
   if (nargin < 3)
     fmt = "img";
   elseif (! ischar (fmt))
-    error ("saveimage: image format specification must be a string");
+    error ("saveimage: FMT specification must be a string");
   elseif (! (strcmp (fmt, "img")
              || strcmp (fmt, "ppm")
              || strcmp (fmt, "ps")))
     error ("saveimage: unsupported image format specification");
   endif
 
   if (! ismatrix (img))
-    warning ("image variable is not a matrix");
+    warning ("IMG variable is not a matrix");
   endif
 
   if (! ischar (fname))
-    error ("saveimage: fname name must be a string");
+    error ("saveimage: FNAME must be a string");
   endif
 
   ## If we just want Octave image format, save and return.
 
   if (strcmp (fmt, "img"))
     save ("-text", fname, "map", "img");
     return;
   endif
@@ -220,17 +220,17 @@ function saveimage (fname, img, fmt, map
       fprintf (fid, "\n");
       fclose (fid);
 
     endif
 
   elseif (strcmp (fmt, "ps") == 1)
 
     if (! grey)
-      error ("saveimage: must have a greyscale color map for conversion to PostScript");
+      error ("saveimage: must have a greyscale colormap for conversion to PostScript");
     endif
 
     bps = 8;
     dpi = 300;
     pagewid = 612;
     pagehgt = 762;
     MARGIN = 0.95;
     devpix = dpi / 72.0 + 0.5;
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -156,17 +156,17 @@ function dlmwrite (file, M, varargin)
   endwhile
 
   if (ischar (file))
     [fid, msg] = fopen (file, opentype);
   elseif (isscalar (file) && isnumeric (file))
     fid = file;
     msg = "invalid file number";
   else
-    error ("dlmwrite: file must be a string file ID");
+    error ("dlmwrite: FILE must be a filename string or numeric FID");
   endif
 
   if (fid < 0)
     error (msg);
   else
     if (r > 0)
       fprintf (fid, "%s",
                repmat ([repmat(delim, 1, c + columns(M)-1), newline], 1, r));
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -101,17 +101,17 @@
 
 function varargout = strread (str, format = "%f", varargin)
   ## Check input
   if (nargin < 1)
     print_usage ();
   endif
  
   if (!ischar (str) || !ischar (format))
-    error ("strread: first and second input arguments must be strings");
+    error ("strread: STR and FORMAT arguments must be strings");
   endif
 
   ## Parse options
   comment_flag = false;
   numeric_fill_value = 0;
   white_spaces = " \n\r\t\b";
   delimiter_str = "";
   for n = 1:2:length (varargin)
@@ -152,17 +152,17 @@ function varargout = strread (str, forma
   ## Parse format string
   idx = strfind (format, "%")';
   specif = format ([idx, idx+1]);
   nspecif = length (idx);
   idx_star = strfind (format, "%*");
   nfields = length (idx) - length (idx_star);
 
   if (max (nargout, 1) != nfields)
-    error ("strread: the number of output variables must match that of format specifiers");
+    error ("strread: the number of output variables must match that specified byFORMAT");
   endif
 
   ## Remove comments
   if (comment_flag)
     cstart = strfind (str, comment_specif{1});
     cstop  = strfind (str, comment_specif{2});
     if (length (cstart) > 0)
       ## Ignore nested openers.
@@ -227,17 +227,17 @@ function varargout = strread (str, forma
         varargout {k} = data.';
         k++;
       case {"%*", "%*s"}
         ## skip the word
       otherwise
         ## Ensure descriptive content is consistent
         if (numel (unique (data)) > 1
             || ! strcmpi (unique (data), fmt_words{m}))
-          error ("strread: format does not match data")
+          error ("strread: FORMAT does not match data")
         endif
     endswitch
   endfor
 endfunction
 
 function out = split_by (text, sep)
   sep = union (sep, "\n");
   pat = sprintf ("[^%s]+", sep);
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -72,17 +72,17 @@ function [C, p] = textscan (fid, format,
     args{end+1} = "emptyvalue";
     args{end+1} = NaN;
   endif
 
   if (isa (fid, "double") && fid > 0 || ischar (fid))
     if (ischar (format))
       if (ischar (fid))
         if (nargout == 2)
-          error ("textscan: cannot provide postion information for character input")
+          error ("textscan: cannot provide position information for character input")
         endif
         str = fid;
       else
         ## Maybe skip header lines
         headerlines = find (strcmpi (args, "headerlines"), 1);
         if (! isempty (headerlines))
           fskipl (fid, headerlines);
           args(headerlines:headerlines+1) = [];
@@ -109,20 +109,20 @@ function [C, p] = textscan (fid, format,
         C = cellfun (@(x) x(1:nlines), C, "uniformoutput", false);
       endif
 
       if (nargout == 2)
         p = ftell (fid);
       endif
 
     else
-      error ("textscan: second input must be a format specification");
+      error ("textscan: FORMAT must be a valid specification");
     endif
   else
-    error ("textscan: expecting first argument to be a file id or character string");
+    error ("textscan: first argument must be a file id or character string");
   endif
 
 endfunction
 
 %!test
 %! str = "1,  2,  3,  4\n 5,  ,  ,  8\n 9, 10, 11, 12";
 %! fmtstr = "%f %d %f %s";
 %! c = textscan (str, fmtstr, 2, "delimiter", ",", "emptyvalue", -Inf);
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -73,22 +73,22 @@
 ## Adapted-By: jwe
 
 function k = commutation_matrix (m, n)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   else
     if (! (isscalar (m) && m == round (m) && m > 0))
-      error ("commutation_matrix: m must be a positive integer");
+      error ("commutation_matrix: M must be a positive integer");
     endif
     if (nargin == 1)
       n = m;
     elseif (! (isscalar (n) && n == round (n) && n > 0))
-      error ("commutation_matrix: n must be a positive integer");
+      error ("commutation_matrix: N must be a positive integer");
     endif
   endif
 
   ## It is clearly possible to make this a LOT faster!
   k = zeros (m * n, m * n);
   for i = 1 : m
     for j = 1 : n
       k ((i - 1) * n + j, (j - 1) * m + i) = 1;
diff --git a/scripts/linear-algebra/condest.m b/scripts/linear-algebra/condest.m
--- a/scripts/linear-algebra/condest.m
+++ b/scripts/linear-algebra/condest.m
@@ -139,17 +139,17 @@ function [est, v] = condest (varargin)
         solve = varargin{2};
         solve_t = varargin{3};
         have_solve = true;
         if (nargin > 3)
           t = varargin{4};
           have_t = true;
         endif
       else
-        error ("condest: must supply both solve and solve_t");
+        error ("condest: must supply both SOLVE and SOLVE_T");
       endif
     endif
   elseif (nargin > 4)
     apply = varargin{1};
     apply_t = varargin{2};
     solve = varargin{3};
     solve_t = varargin{4};
     have_solve = true;
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -62,17 +62,17 @@ function z = cross (x, y, dim)
 
   if (nargin == 2)
      dim = find (size (x) == 3, 1);
      if (isempty (dim)) 
        error ("cross: must have at least one dimension with 3 elements");
      endif
    else
      if (size (x, dim) != 3)
-       error ("cross: dimension dim must have 3 elements");
+       error ("cross: dimension DIM must have 3 elements");
      endif
   endif
 
   nd = ndims (x);
   sz = size (x);
   idx2 = idx3 = idx1 = {':'}(ones (1, nd));
   idx1(dim) = 1;
   idx2(dim) = 2;
@@ -82,12 +82,12 @@ function z = cross (x, y, dim)
     x1 = x(idx1{:});
     x2 = x(idx2{:});
     x3 = x(idx3{:});
     y1 = y(idx1{:});
     y2 = y(idx2{:});
     y3 = y(idx3{:});
     z = cat (dim, (x2.*y3 - x3.*y2), (x3.*y1 - x1.*y3), (x1.*y2 - x2.*y1));
   else
-    error ("cross: x and y must have the same dimensions");
+    error ("cross: X and Y must have the same dimensions");
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -65,17 +65,17 @@
 
 function d = duplication_matrix (n)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! (isscalar (n) && n == round (n) && n > 0))
-    error ("duplication_matrix: n must be a positive integer");
+    error ("duplication_matrix: N must be a positive integer");
   endif
 
   d = zeros (n * n, n * (n + 1) / 2);
 
   ## It is clearly possible to make this a LOT faster!
   count = 0;
   for j = 1 : n
     d ((j - 1) * n + j, count + j) = 1;
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -68,17 +68,17 @@
 ## @code{Dq(A)}
 ## @end ifnottex
 ## is ill-conditioned.
 ## @end deftypefn
 
 function r = expm (A)
 
   if (! ismatrix (A) || ! issquare (A))
-    error ("expm: input must be a square matrix");
+    error ("expm: A must be a square matrix");
   endif
 
   if (isscalar (A))
     r = exp (A);
     return
   elseif (strfind (typeinfo (A), "diagonal matrix"))
     r = diag (exp (diag (A)));
     return
diff --git a/scripts/linear-algebra/isdefinite.m b/scripts/linear-algebra/isdefinite.m
--- a/scripts/linear-algebra/isdefinite.m
+++ b/scripts/linear-algebra/isdefinite.m
@@ -33,17 +33,17 @@
 
 function retval = isdefinite (x, tol)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (! ishermitian (x))
-    error ("isdefinite: x must be a hermitian matrix");
+    error ("isdefinite: X must be a hermitian matrix");
   endif
 
   if (! isfloat (x))
     x = double (x);
   endif
 
   if (nargin == 1)
     tol = 100 * eps(class (x)) * norm (x, "fro");
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -88,17 +88,17 @@ function [Uret, H, nu] = krylov (A, V, k
 
   [m, kb] = size (V);
   if (m != na)
     error ("krylov: A(%d x %d), V(%d x %d): argument dimensions do not match",
           na, na, m, kb)
   endif
 
   if (! isscalar (k))
-    error ("krylov: third argument must be a scalar integer");
+    error ("krylov: K must be a scalar integer");
   endif
 
   Vnrm = norm (V, Inf);
 
   ## check for trivial solution.
   if (Vnrm == 0)
     Uret = [];
     H = [];
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -41,17 +41,17 @@
 
 function [s, iters] = logm (A, opt_iters = 100)
  
   if (nargin == 0 || nargin > 2)
     print_usage ();
   endif
 
   if (! issquare (A))
-    error ("logm: argument must be a square matrix");
+    error ("logm: A must be a square matrix");
   endif
 
   [u, s] = schur (A);
 
   if (isreal (A))
     [u, s] = rsf2csf (u, s);
   endif
 
@@ -134,13 +134,13 @@ function [x, w] = gauss_legendre (n)
   x = diag (D);
   w = 2*(V(1,:)'.^2);
 endfunction
 
 
 %!assert(norm(logm([1 -1;0 1]) - [0 -1; 0 0]) < 1e-5);
 %!assert(norm(expm(logm([-1 2 ; 4 -1])) - [-1 2 ; 4 -1]) < 1e-5);
 %!assert(logm([1 -1 -1;0 1 -1; 0 0 1]), [0 -1 -1.5; 0 0 -1; 0 0 0], 1e-5);
-%!
+
 %% Test input validation
 %!error logm ();
 %!error logm (1, 2, 3);
-%!error <logm: argument must be a square matrix> logm([1 0;0 1; 2 2]);
+%!error <logm: A must be a square matrix> logm([1 0;0 1; 2 2]);
diff --git a/scripts/linear-algebra/vech.m b/scripts/linear-algebra/vech.m
--- a/scripts/linear-algebra/vech.m
+++ b/scripts/linear-algebra/vech.m
@@ -34,17 +34,17 @@
 
 function v = vech (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! issquare (x))
-    error ("vech: x must be square");
+    error ("vech: X must be square");
   endif
 
   n = rows (x);
   slices = cellslices (x(:), (1:n) + n*(0:n-1), n*(1:n));
   v = vertcat (slices{:});
 
 endfunction
 
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -61,17 +61,17 @@
 function b = bincoeff (n, k)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   [retval, n, k] = common_size (n, k);
   if (retval > 0)
-    error ("bincoeff: n and k must be of common size or scalars");
+    error ("bincoeff: N and K must be of common size or scalars");
   endif
 
   sz = size (n);
   b   = zeros (sz);
 
   ind = (! (k >= 0) | (k != real (round (k))) | isnan (n));
   b(ind) = NaN;
   
diff --git a/scripts/miscellaneous/cast.m b/scripts/miscellaneous/cast.m
--- a/scripts/miscellaneous/cast.m
+++ b/scripts/miscellaneous/cast.m
@@ -31,15 +31,15 @@ function retval = cast (val, typ)
       if (any (strcmp (typ, {"int8"; "uint8"; "int16"; "uint16";
                              "int32"; "uint32"; "int64"; "uint64";
                              "double"; "single"; "logical"; "char"})))
         retval = feval (typ, val);
       else
         error ("cast: type name `%s' is not a built-in type", typ);
       endif
     else
-      error ("cast: expecting type name as second argument");
+      error ("cast: expecting TYPE name as second argument");
     endif
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -84,19 +84,19 @@ function out = compare_versions (v1, v2,
   if (! (ischar (v1) && ischar (v2)))
     error ("compare_versions: both version numbers must be strings");
   elseif (size (v1, 1) != 1 || size (v2, 1) != 1)
     error ("compare_versions: version numbers must be a single row");
   endif
 
   ## check and make sure that the operator is valid
   if (! ischar (operator))
-    error ("compare_versions: operator must be a character string");
+    error ("compare_versions: OPERATOR must be a character string");
   elseif (numel (operator) > 2)
-    error("compare_versions: operator cannot be more than 2 characters long");
+    error("compare_versions: OPERATOR cannot be more than 2 characters long");
   endif
 
   ## trim off any character data that is not part of a normal version
   ## number
   numbers = "0123456789.";
 
   v1firstchar = find (! ismember (v1, numbers), 1);
   v2firstchar = find (! ismember (v2, numbers), 1);
@@ -161,19 +161,19 @@ function out = compare_versions (v1, v2,
   if any (ismember (operator, ">"))
     gt_op = true;
   else
     gt_op = false;
   endif
 
   ## Make sure that we don't have conflicting operators.
   if (gt_op && lt_op)
-    error ("compare_versions: operator cannot contain both greater and less than symbols");
+    error ("compare_versions: OPERATOR cannot contain both greater and less than symbols");
   elseif ((gt_op || lt_op) && not_op)
-    error ("compare_versions: operator cannot contain not and greater than or less than symbols");
+    error ("compare_versions: OPERATOR cannot contain not and greater than or less than symbols");
   endif
 
   ## Compare the versions (making sure that they're the same shape)
   vcmp = v1n(:) - v2n(:);
   vcmp = [vcmp; (v1c - v2c)(:)];
   if (lt_op)
     ## so that we only need to check for the output being greater than 1
     vcmp = -vcmp;
diff --git a/scripts/miscellaneous/delete.m b/scripts/miscellaneous/delete.m
--- a/scripts/miscellaneous/delete.m
+++ b/scripts/miscellaneous/delete.m
@@ -42,15 +42,15 @@ function delete (arg)
         if (err)
           warning ("delete: %s: %s", file, msg);
         endif
       endfor
     elseif (all (ishandle (arg(:))))
       ## Delete a graphics object.
       __go_delete__ (arg);
     else
-      error ("delete: expecting argument to be a filename or graphics handle");
+      error ("delete: first argument must be a filename or graphics handle");
     endif
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/fileparts.m b/scripts/miscellaneous/fileparts.m
--- a/scripts/miscellaneous/fileparts.m
+++ b/scripts/miscellaneous/fileparts.m
@@ -46,17 +46,17 @@ function [directory, name, extension, ve
       name = filename(ds+1:es-1);
       if (es > 0 && es <= length (filename))
         extension = filename(es:end);
       else
         extension = "";
       endif
       version = "";
     else
-      error ("fileparts: expecting filename argument to be a string");
+      error ("fileparts: expecting FILENAME argument to be a string");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!test
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -151,17 +151,17 @@ function retval = license (varargin)
         retval = found && __octave_licenses__{p,3};
       else
         if (found)
           if (strcmp (varargin{3}, "enable"))
             __octave_licenses__{p,3} = true;
           elseif (strcmp (varargin{3}, "disable"))
             __octave_licenses__{p,3} = false;
           else
-            error ("toggle must be either `enable' of `disable'");
+            error ("TOGGLE must be either `enable' of `disable'");
           endif
         else
           error ("feature `%s' not found", feature);
         endif
       endif
 
     elseif (strcmp (varargin{1}, "checkout"))
 
diff --git a/scripts/miscellaneous/paren.m b/scripts/miscellaneous/paren.m
--- a/scripts/miscellaneous/paren.m
+++ b/scripts/miscellaneous/paren.m
@@ -12,12 +12,12 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deffn {Operator} (
+## @deffn  {Operator} (
 ## @deffnx {Operator} )
 ## Array index or function argument delimeter.
 ## @end deffn
diff --git a/scripts/miscellaneous/private/__xzip__.m b/scripts/miscellaneous/private/__xzip__.m
--- a/scripts/miscellaneous/private/__xzip__.m
+++ b/scripts/miscellaneous/private/__xzip__.m
@@ -30,17 +30,17 @@
 ## are not touched. Existing compressed files are silently overwritten. 
 ## This is an internal function. Do not use directly.
 
 function entries = __xzip__ (commandname, extension, 
                              commandtemplate, files, outdir)
 
   if (nargin == 4 || nargin == 5)
     if (! ischar (extension) || length (extension) == 0)
-      error ("__xzip__: extension has to be a string with finite length");
+      error ("__xzip__: EXTENSION has to be a string with finite length");
     endif
     
     if (nargin == 5 && ! exist (outdir, "dir"))
       error ("__xzip__: output directory does not exist");
     endif
 
     if (ischar (files))
       files = cellstr (files);
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -34,17 +34,17 @@ function run (script)
 
   [d, f, ext] = fileparts (script);
   if (! isempty (d))
     if (exist (d, "dir"))
       wd = pwd ();
       unwind_protect
         cd (d);
         if (! exist (cstrcat (f, ext), "file"))
-          error ("run: file must exist and be a valid Octave script file");
+          error ("run: file SCRIPT must exist and be a valid Octave scriptfile");
         endif
         evalin ("caller", sprintf ("source (\"%s%s\");", f, ext),
                 "rethrow (lasterror ())");
       unwind_protect_cleanup
         cd (wd);
       end_unwind_protect
     else
       error ("run: the path %s doesn't exist", d);
diff --git a/scripts/miscellaneous/substruct.m b/scripts/miscellaneous/substruct.m
--- a/scripts/miscellaneous/substruct.m
+++ b/scripts/miscellaneous/substruct.m
@@ -54,22 +54,22 @@ function retval = substruct (varargin)
     typ = varargin(1:2:nargs);
     sub = varargin(2:2:nargs);
     braces = strcmp (typ, "()") | strcmp (typ, "{}");
     dots = strcmp (typ, ".");
     if (all (braces | dots))
       cells = cellfun ("isclass", sub, "cell");
       chars = cellfun ("isclass", sub, "char");
       if (any (braces &! cells))
-        error ("substruct: for type == () or {}, subs must be a cell array");
+        error ("substruct: for TYPE == () or {}, SUBS must be a cell array");
       elseif (any (dots &! chars))
-        error ("substruct: for type == ., subs must be a character string");
+        error ("substruct: for TYPE == ., SUBS must be a character string");
       endif
     else
-      error ("substruct: expecting type to be one of \"()\", \"{}\", or \".\"");
+      error ("substruct: expecting TYPE to be one of \"()\", \"{}\", or \".\"");
     endif
 
     retval = struct ("type", typ, "subs", sub);
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/unix.m b/scripts/miscellaneous/unix.m
--- a/scripts/miscellaneous/unix.m
+++ b/scripts/miscellaneous/unix.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{status}, @var{text}]} unix (@var{command})
-## @deftypefnx {Function File} {[@var{status}, @var{text}]} unix (@var{command}, "-echo")
+## @deftypefn  {Function File} {[@var{status}, @var{text}] =} unix (@var{command})
+## @deftypefnx {Function File} {[@var{status}, @var{text}] =} unix (@var{command}, "-echo")
 ## Execute a system command if running under a Unix-like operating
 ## system, otherwise do nothing.  Return the exit status of the program
 ## in @var{status} and any output sent to the standard output in
 ## @var{text}.  If the optional second argument @code{"-echo"} is given,
 ## then also send the output from the command to the standard output.
 ## @seealso{isunix, ispc, system}
 ## @end deftypefn
 
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -37,19 +37,19 @@ function filelist = unpack (file, dir = 
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (ischar (file))
     if (isdir (file))
       if (isempty (filetype))
-        error ("unpack: filetype must be given for a directory");
+        error ("unpack: FILETYPE must be given for a directory");
       elseif (! any (strcmpi (filetype, "gunzip")))
-        error ("unpack: filetype must be gunzip for a directory");
+        error ("unpack: FILETYPE must be gunzip for a directory");
       endif
     else
       [pathstr, name, ext] = fileparts (file);
 
       ## Check to see if it's .tar.gz, .tar.Z, etc.
       if (any (strcmpi ({".gz" ".Z" ".bz2" ".bz"}, ext)))
         [tmppathstr, tmpname, tmpext] = fileparts (name);
         if (strcmpi (tmpext, ".tar"))
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -31,17 +31,17 @@
 
 function z = xor (x, y)
 
   if (nargin == 2)
     if (isscalar (x) || isscalar (y) || size_equal (x, y))
       ## Typecast to logicals is necessary for other numeric types.
       z = logical (x) != logical (y);
     else
-      error ("xor: x and y must be of common size or scalars");
+      error ("xor: X and Y must be of common size or scalars");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!assert((xor ([1, 1, 0, 0], [0, 1, 0, 1]) == [1, 0, 0, 1]
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -360,17 +360,17 @@ function [x, obj, info, iter, nf, lambda
     endif
   endif
 
   tol = sqrt (eps);
   if (nargin > 7 && ! isempty (tolerance))
     if (isscalar (tolerance) && tolerance > 0)
       tol = tolerance;
     else
-      error ("sqp: invalid value for tolerance");
+      error ("sqp: invalid value for TOLERANCE");
     endif
   endif
 
   ## Initialize variables for search loop
   ## Seed x with initial guess and evaluate objective function, constraints,
   ## and gradients at initial value x0.
   ##
   ## obj_fun   -- objective function
diff --git a/scripts/pkg/get_forge_pkg.m b/scripts/pkg/get_forge_pkg.m
--- a/scripts/pkg/get_forge_pkg.m
+++ b/scripts/pkg/get_forge_pkg.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 function [ver, url] = get_forge_pkg (name)
   if (nargin != 1)
     print_usage ();
   endif
   ## Verify that name is valid.
   if (! (ischar (name) && rows (name) == 1 && ndims (name) == 2))
-    error ("get_forge_pkg: package name must be a string");
+    error ("get_forge_pkg: package NAME must be a string");
   elseif (! all (isalnum (name) | name == "-" | name == "." | name == "_"))
     error ("get_forge_pkg: invalid package name: %s", name);
   endif
 
   name = tolower (name);
 
   ## Try to download package's index page.
   [html, succ] = urlread (sprintf ("http://octave.sourceforge.net/%s/index.html", name));
@@ -61,17 +61,17 @@ function [ver, url] = get_forge_pkg (nam
     endif
   else
     ## Try get the list of all packages.
     [html, succ] = urlread ("http://octave.sourceforge.net/packages.php");
     if (succ)
       t = regexp (html, "<div class=""package"" id=""(\\w+)"">", "tokens");
       t = horzcat (t{:});
       if (any (strcmp (t, name)))
-        error ("get_forge_pkg: package name exists, but index page not available");
+        error ("get_forge_pkg: package NAME exists, but index page not available");
       else
         ## Try a simplistic method to determine close names.
         dist = cellfun (@(n) length (setdiff (name, n)), t);
         [~, i] = min (dist);
         error ("get_forge_pkg: package not found: ""%s"". Maybe you meant ""%s?""", name, t{i});
       endif
     else
       error ("get_forge_pkg: could not read URL, please verify internet connection");
diff --git a/scripts/plot/__gnuplot_open_stream__.m b/scripts/plot/__gnuplot_open_stream__.m
--- a/scripts/plot/__gnuplot_open_stream__.m
+++ b/scripts/plot/__gnuplot_open_stream__.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{stream}} __gnuplot_open_stream__ (@var{npipes}, @var{h})
+## @deftypefn {Function File} {@var{stream} =} __gnuplot_open_stream__ (@var{npipes}, @var{h})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2009-04-11
 
 function plot_stream = __gnuplot_open_stream__ (npipes, h)
   [prog, args] = gnuplot_binary ();
diff --git a/scripts/plot/__marching_cube__.m b/scripts/plot/__marching_cube__.m
--- a/scripts/plot/__marching_cube__.m
+++ b/scripts/plot/__marching_cube__.m
@@ -95,34 +95,34 @@ function [T, p, col] = __marching_cube__
   endif
    
   if ((nargin != 5 && nargin != 6) || (nargout != 2 && nargout != 3))
     print_usage ();
   endif
   
   if (!ismatrix (xx) || !ismatrix (yy) || !ismatrix (zz) || !ismatrix (c) || ...
     ndims (xx) != 3 || ndims (yy) != 3 || ndims (zz) != 3 || ndims (c) != 3)
-    error ("__marching_cube__: xx, yy, zz, c have to be matrizes of dim 3");
+    error ("__marching_cube__: XX, YY, ZZ, C must be matrices of dim 3");
   endif
   
   if (!size_equal (xx, yy, zz, c))
-    error ("__marching_cube__: xx, yy, zz, c are not the same size");
+    error ("__marching_cube__: XX, YY, ZZ, C must be of equal size");
   endif
   
   if (any (size (xx) < [2 2 2]))
-    error ("__marching_cube__: grid size has to be at least 2x2x2");
+    error ("__marching_cube__: grid size must be at least 2x2x2");
   endif
   
   if (!isscalar (iso))
-    error ("__marching_cube__: iso needs to be scalar value");
+    error ("__marching_cube__: ISO must be scalar value");
   endif
 
   if (nargin == 6)
     if ( !ismatrix (colors) || ndims (colors) != 3 || size (colors) != size (c) )
-      error ( "color has to be matrix of dim 3 and of same size as c" );
+      error ( "COLORS must be a matrix of dim 3 and of same size as C" );
     endif
     calc_cols = true;
     lindex = 5;
   endif
   
   n = size (c) - 1;
   
   ## phase I: assign information to each voxel which edges are intersected by
diff --git a/scripts/plot/backend.m b/scripts/plot/backend.m
--- a/scripts/plot/backend.m
+++ b/scripts/plot/backend.m
@@ -32,26 +32,26 @@ function backend (varargin)
 
   name = "";
   hlist = [];
 
   if (nargin == 1)
     if (ischar (varargin{1}))
       name = varargin{1};
     else
-      error ("backend: invalid backend name");
+      error ("backend: invalid backend NAME");
     endif
   elseif (nargin == 2)
     if (isnumeric (varargin{1}) && ischar (varargin{2}))
       hlist = varargin{1};
       name = varargin{2};
     elseif (ischar (varargin{2}))
       error ("backend: invalid handle list");
     else
-      error ("backend: invalid backend name");
+      error ("backend: invalid backend NAME");
     endif
   else
     print_usage ();
   endif
 
   if (! any (strcmp (available_backends (), name)))
     feval (["__init_", name, "__"]);
     if (! any (strcmp (available_backends (), name)))
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -81,17 +81,17 @@ function [cout, lev] = contourc (varargi
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
   else
     print_usage ();
   endif
 
   if (!ismatrix (z) || isvector (z) || isscalar (z))
-    error ("contourc: z argument must be a matrix");
+    error ("contourc: Z argument must be a matrix");
   endif
 
   if (isscalar (vn))
     vv = linspace (min (z(:)), max (z(:)), vn+2)(2:end-1);
   else
     vv = unique (sort (vn));
   endif
 
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -60,17 +60,17 @@ function [xx, yy, zz] = cylinder (vararg
   elseif (nargs == 2)
     r = args{1};
     n = args{2};
   else
     print_usage ();
   endif
 
   if (length (r) < 2)
-    error ("cylinder: length(r) must be larger than 2")
+    error ("cylinder: length(R) must be larger than 2")
   endif
 
   phi = linspace (0, 2*pi, n+1);
   idx = 1:length(r);
   [phi, idx] = meshgrid(phi, idx);
   z = (idx - 1) / (length(r) - 1);
   r = r(idx);
   [x, y] = pol2cart (phi, r);
diff --git a/scripts/plot/hidden.m b/scripts/plot/hidden.m
--- a/scripts/plot/hidden.m
+++ b/scripts/plot/hidden.m
@@ -28,20 +28,20 @@
 function retval = hidden (mode)
 
   if (nargin == 0)
     mode = "swap";
   elseif (nargin == 1);
     if (ischar (mode))
       mode = tolower (mode);
       if (! strcmp (mode, "on") && ! strcmp (mode, "off"))
-        error ("hidden: mode expected to be 'on' or 'off'");
+        error ("hidden: MODE expected to be 'on' or 'off'");
       endif
     else
-      error ("hidden: expecting mode to be a string");
+      error ("hidden: expecting MODE to be a string");
     endif
   else
     print_usage ();
   endif
 
   for h = get (gca (), "children");
     htype = lower (get (h, "type"));
     if (strcmp (htype, "surface"))
diff --git a/scripts/plot/hold.m b/scripts/plot/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/hold.m
@@ -72,17 +72,17 @@ function hold (varargin)
       if (strcmpi (state, "off"))
         turn_hold_off = true;
       elseif (strcmpi (state, "all"))
         turn_hold_off = false;
         hold_all = true;
       elseif (strcmpi (state, "on"))
         turn_hold_off = false;
       else
-        error ("hold: invalid hold state");
+        error ("hold: invalid hold STATE");
       endif
     endif
   else
     print_usage ();
   endif
 
   if (turn_hold_off)
     set (ax, "nextplot", "replace");
diff --git a/scripts/plot/orient.m b/scripts/plot/orient.m
--- a/scripts/plot/orient.m
+++ b/scripts/plot/orient.m
@@ -57,17 +57,17 @@ function retval = orient (varargin)
         set (cf, "papersize", papersize([2, 1]));
         set (cf, "paperposition", paperposition([2, 1, 4, 3]));
       endif
     elseif (strcmpi (varargin{1}, 'tall'))
       orient ("portrait")
       papersize = get (cf, "papersize");
       set (cf, "paperposition", [0.25, 0.25, (papersize - 0.5)]);
     else
-      error ("orient: unknown orientation");
+      error ("orient: unknown ORIENTATION");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!shared papersize, paperposition, tallpaperposition, hfig
diff --git a/scripts/plot/private/__add_default_menu__.m b/scripts/plot/private/__add_default_menu__.m
--- a/scripts/plot/private/__add_default_menu__.m
+++ b/scripts/plot/private/__add_default_menu__.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} __add_default_menu__ (fig)
+## @deftypefn  {Function File} {} __add_default_menu__ (@var{fig})
 ## Adds default menu to figure. All uimenu handles have
 ## set their property "handlevisibility" to "off".
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function __add_default_menu__ (fig)
 
diff --git a/scripts/plot/private/__interp_cube__.m b/scripts/plot/private/__interp_cube__.m
--- a/scripts/plot/private/__interp_cube__.m
+++ b/scripts/plot/private/__interp_cube__.m
@@ -29,20 +29,20 @@ function [Vxyz, idx, frac] = __interp_cu
     x = squeeze (x(1,:,1))(:);
     y = squeeze (y(:,1,1))(:);
     z = squeeze (z(1,1,:))(:);
   elseif (isvector (x) && isvector (y) && isvector (z) )
     x = x(:);
     y = y(:);
     z = z(:);
   else
-    error("__interp_cube__: x, y, z have wrong dimensions");
+    error("__interp_cube__: X, Y, Z have wrong dimensions");
   endif
   if (size (val) != [length(x), length(y), length(z)])
-    error ("__interp_cube__: val has wrong dimensions");
+    error ("__interp_cube__: VAL has wrong dimensions");
   endif
   if (size (v, 2) != 3)
     error ( "v has to be N*3 matrix");
   endif
   if (!ischar (req))
    error ("__interp_cube__: Invalid request parameter use 'values', 'normals' or 'normals8'");
   endif
   if (isempty (v))
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/refreshdata.m
@@ -63,17 +63,17 @@ function refreshdata (h, workspace)
       error ("refreshdata: expecting a list of figure handles");
     endif
     if (nargin < 2)
       workspace = "base";
     else
       if (   !ischar (workspace) 
           || !(strcmpi (workspace, "base")
           || strcmpi (workspace, "caller")))
-        error ("refreshdata: expecting workspace to be \"base\" or ""caller\"");
+        error ("refreshdata: expecting WORKSPACE to be \"base\" or ""caller\"");
       else
         workspace = tolower (workspace);
       endif
     endif
   endif
 
   h = findall (h);
   objs = [];
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -78,42 +78,42 @@ function h = subplot (rows, cols, index,
         print_usage ();
       endswitch
     endfor
   endif
 
   if (nargin == 1)
 
     if (! (isscalar (rows) && rows >= 0))
-      error ("subplot: input rcn has to be a positive scalar");
+      error ("subplot: input RCN has to be a positive scalar");
     endif
 
     tmp = rows;
     index = rem (tmp, 10);
     tmp = (tmp - index) / 10;
     cols = rem (tmp, 10);
     tmp = (tmp - cols) / 10;
     rows = rem (tmp, 10);
 
   elseif (! (isscalar (cols) && isscalar (rows)))
-    error ("subplot: cols, and rows must be scalars");
+    error ("subplot: COLS, and ROWS must be scalars");
   elseif (any (index < 1) || any (index > rows*cols))
-    error ("subplot: index value must be greater than 1 and less than rows*cols")
+    error ("subplot: INDEX value must be greater than 1 and less than ROWS*COLS")
   endif
 
   cols = round (cols);
   rows = round (rows);
   index = round (index);
 
   if (index > cols*rows)
-    error ("subplot: index must be less than cols*rows");
+    error ("subplot: INDEX must be less than COLS*ROWS");
   endif
 
   if (cols < 1 || rows < 1 || index < 1)
-    error ("subplot: cols,rows,index must be be positive");
+    error ("subplot: COLS,ROWS,INDEX must be be positive");
   endif
 
   units = get (0, "defaultaxesunits");
   unwind_protect
     set (0, "defaultaxesunits", "normalized")
     pos = subplot_position (rows, cols, index, "position", units);
 
     cf = gcf ();
diff --git a/scripts/plot/surface.m b/scripts/plot/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/surface.m
@@ -77,70 +77,70 @@ function [h, bad_usage] = __surface__ (a
     bad_usage = true;
   elseif (firststring == 5)
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     c = varargin{4};
 
     if (! size_equal (z, c))
-      error ("surface: z and c must have the same size");
+      error ("surface: Z and C must have the same size");
     endif
     if (isvector (x) && isvector (y) && ismatrix (z))
       if (rows (z) == length (y) && columns (z) == length (x))
         x = x(:)';
         y = y(:);
       else
-        error ("surface: rows (z) must be the same as length (y) and columns (z) must be the same as length (x)");
+        error ("surface: rows (Z) must be the same as length (Y) and columns (Z) must be the same as length (X)");
       endif
     elseif (ismatrix (x) && ismatrix (y) && ismatrix (z))
       if (! size_equal (x, y, z))
-        error ("surface: x, y, and z must have the same dimensions");
+        error ("surface: X, Y, and Z must have the same dimensions");
       endif
     else
-      error ("surface: x and y must be vectors and z must be a matrix");
+      error ("surface: X and Y must be vectors and Z must be a matrix");
     endif
   elseif (firststring == 4)
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     c = z;
     if (isvector (x) && isvector (y) && ismatrix (z))
       if (rows (z) == length (y) && columns (z) == length (x))
         x = x(:)';
         y = y(:);
       else
-        error ("surface: rows (z) must be the same as length (y) and columns (z) must be the same as length (x)");
+        error ("surface: rows (Z) must be the same as length (Y) and columns (Z) must be the same as length (X)");
       endif
     elseif (ismatrix (x) && ismatrix (y) && ismatrix (z))
       if (! size_equal (x, y, z))
-        error ("surface: x, y, and z must have the same dimensions");
+        error ("surface: X, Y, and Z must have the same dimensions");
       endif
     else
-      error ("surface: x and y must be vectors and z must be a matrix");
+      error ("surface: X and Y must be vectors and Z must be a matrix");
     endif
   elseif (firststring == 3)    
     z = varargin{1};
     c = varargin{2};
     if (ismatrix (z) && !isvector (z) && !isscalar (z))
       [nr, nc] = size (z);
       x = 1:nc;
       y = (1:nr)';
     else
-      error ("surface: z argument must be a matrix");
+      error ("surface: Z argument must be a matrix");
     endif
   elseif (firststring == 2)    
     z = varargin{1};
     c = z;
     if (ismatrix (z) && !isvector (z) && !isscalar (z))
       [nr, nc] = size (z);
       x = 1:nc;
       y = (1:nr)';
     else
-      error ("surface: z argument must be a matrix");
+      error ("surface: Z argument must be a matrix");
     endif
   else
     bad_usage = true;
   endif
 
   if (! bad_usage)
     ## Make a default surface object.
     other_args = {};
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -67,20 +67,20 @@ function [Nx, Ny, Nz] = surfnorm (vararg
   else
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     ioff = 4;
   endif
 
   if (!ismatrix (z) || isvector (z) || isscalar (z))
-    error ("surfnorm: z argument must be a matrix");
+    error ("surfnorm: Z argument must be a matrix");
   endif
   if (! size_equal (x, y, z))
-    error ("surfnorm: x, y, and z must have the same dimensions");
+    error ("surfnorm: X, Y, and Z must have the same dimensions");
   endif 
 
   ## Make life easier, and avoid having to do the extrapolation later, do
   ## a simpler linear extrapolation here. This is approximative, and works
   ## badly for closed surfaces like spheres.
   xx = [2 .* x(:,1) - x(:,2), x, 2 .* x(:,end) - x(:,end-1)];
   xx = [2 .* xx(1,:) - xx(2,:); xx; 2 .* xx(end,:) - xx(end-1,:)];
   yy = [2 .* y(:,1) - y(:,2), y, 2 .* y(:,end) - y(:,end-1)];
diff --git a/scripts/plot/text.m b/scripts/plot/text.m
--- a/scripts/plot/text.m
+++ b/scripts/plot/text.m
@@ -52,17 +52,17 @@ function h = text (varargin)
       if (ischar (label))
         label = cellstr (label);
       endif
       n = numel (label);
       nx = numel (x);
       ny = numel (y);
       nz = numel (z);
     else
-      error ("text: expecting label to be a character string or cell array of character strings");
+      error ("text: expecting LABEL to be a character string or cell array of character strings");
     endif
   else
     x = y = z = 0;
     nx = ny = nz = 1;
     label = {""};
     n = 1;
   endif
 
@@ -83,17 +83,17 @@ function h = text (varargin)
       elseif (n == nx)
         for i = 1:nx
           tmp(i) = __go_text__ (ca, "string", label{i},
                                 varargin{:},
                                 "position", pos(i,:));
         endfor
         __request_drawnow__ ();
       else
-        error ("text: dimension mismatch for coordinates and label");
+        error ("text: dimension mismatch for coordinates and LABEL");
       endif
     else
       error ("text: dimension mismatch for coordinates");
     endif
 
     if (nargout > 0)
       h = tmp;
     endif
diff --git a/scripts/plot/uimenu.m b/scripts/plot/uimenu.m
--- a/scripts/plot/uimenu.m
+++ b/scripts/plot/uimenu.m
@@ -83,17 +83,17 @@ function hui = uimenu (varargin)
   if (ishandle (args{1}))
     h = args{1};
     args(1) = [];
   else
     h = gcf ();
   endif
 
   if (rem (length (args), 2))
-    error ("uimenu: expecting property/value pairs");
+    error ("uimenu: expecting PROPERTY/VALUE pairs");
   endif
 
   tmp = __go_uimenu__ (h, args{:});
 
   if (nargout > 0)
     hui = tmp;
   endif
 
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -54,17 +54,17 @@ function pp = mkpp (x, P, d)
       d = prod (size (P)(1:nd-1));
     endif
   endif
   pp.d = d;
   pp.P = P = reshape (P, prod (d), [], k);
   pp.orient = 0;
 
   if (size (P, 2) != n)
-    error ("mkpp: num intervals in x doesn't match num polynomials in P");
+    error ("mkpp: num intervals in X doesn't match num polynomials in P");
   endif
 endfunction
 
 %!demo # linear interpolation
 %! x=linspace(0,pi,5)'; 
 %! t=[sin(x),cos(x)];
 %! m=diff(t)./(x(2)-x(1)); 
 %! b=t(1:4,:);
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -86,21 +86,21 @@ function ret = pchip (x, y, xi)
   endif
 
   h = diff (x);
   if (all (h < 0))
     x = fliplr (x);
     h = diff (x);
     y = fliplr (y);
   elseif (any (h <= 0))
-    error("pchip: x must be strictly monotonic");
+    error("pchip: X must be strictly monotonic");
   endif
 
   if (columns (y) != n)
-    error("pchip: size of x and y must match");
+    error("pchip: size of X and Y must match");
   endif
 
   f1 = y(:,1:n-1);
 
   ## Compute derivatives.
   d = __pchip_deriv__ (x, y, 2);
   d1 = d(:,1:n-1);
   d2 = d(:,2:n);
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -69,21 +69,21 @@ function [p, s, mu] = polyfit (x, y, n)
 
   if (nargout > 2)
     ## Normalized the x values.
     mu = [mean(x), std(x)];
     x = (x - mu(1)) / mu(2);
   endif
 
   if (! size_equal (x, y))
-    error ("polyfit: x and y must be vectors of the same size");
+    error ("polyfit: X and Y must be vectors of the same size");
   endif
 
   if (! (isscalar (n) && n >= 0 && ! isinf (n) && n == round (n)))
-    error ("polyfit: n must be a nonnegative integer");
+    error ("polyfit: N must be a nonnegative integer");
   endif
 
   y_is_row_vector = (rows (y) == 1);
 
   ## Reshape x & y into column vectors.
   l = numel (x);
   x = x(:);
   y = y(:);
diff --git a/scripts/polynomial/ppder.m b/scripts/polynomial/ppder.m
--- a/scripts/polynomial/ppder.m
+++ b/scripts/polynomial/ppder.m
@@ -12,27 +12,27 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this software; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {ppd =} ppder (pp)
+## @deftypefn {Function File} {@var{ppd} =} ppder (@var{pp})
 ## Computes the piecewise derivative of a piecewise polynomial struct @var{pp}.
 ## @seealso{mkpp,ppval}
 ## @end deftypefn
 
 function ppd = ppder (pp)
   if (nargin != 1)
     print_usage ();
   endif
   if (! isstruct (pp))
-    error ("ppder: expects a pp structure");
+    error ("ppder: PP must be a structure");
   endif
 
   [x, p, n, k, d] = unmkpp (pp);
   p = reshape (p, [], k);
   if (k <= 1)
     pd = zeros (rows (p), 1);
     k = 1;
   else
diff --git a/scripts/polynomial/ppint.m b/scripts/polynomial/ppint.m
--- a/scripts/polynomial/ppint.m
+++ b/scripts/polynomial/ppint.m
@@ -12,28 +12,28 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this software; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {ppd =} ppint (pp, c)
+## @deftypefn {Function File} {@var{ppi} =} ppint (@var{pp}, @var{c})
 ## Computes the antiderivative of a piecewise polynomial struct @var{pp}.
 ## @var{c}, if given, is the constant of integration.
 ## @seealso{mkpp,ppval}
 ## @end deftypefn
 
 function ppi = ppint (pp, c)
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
   if (! isstruct (pp))
-    error ("ppint: expects a pp structure");
+    error ("ppint: PP must be a structure");
   endif
 
   [x, p, n, k, d] = unmkpp (pp);
   p = reshape (p, [], k);
   
   ## Get piecewise antiderivatives
   pi = p / diag (k:-1:1);
   k += 1;
@@ -47,9 +47,8 @@ function ppi = ppint (pp, c)
 
   ## Adjust constants so the the result is continuous.
 
   jumps = reshape (ppjumps (ppi), prod (d), n-1);
   ppi.P(:,2:n,k) -= cumsum (jumps, 2);
 
 endfunction
 
-
diff --git a/scripts/polynomial/ppjumps.m b/scripts/polynomial/ppjumps.m
--- a/scripts/polynomial/ppjumps.m
+++ b/scripts/polynomial/ppjumps.m
@@ -12,28 +12,28 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this software; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {ppd =} ppjumps (pp)
+## @deftypefn {Function File} {@var{jumps} =} ppjumps (@var{pp})
 ## Evaluates the boundary jumps of a piecewise polynomial.
 ## If there are n intervals, and the dimensionality of pp is d,
 ## the resulting array has dimensions @code{[d, n-1]}.
 ## @end deftypefn
 
 function jumps = ppjumps (pp)
   if (nargin != 1)
     print_usage ();
   endif
   if (! isstruct (pp))
-    error ("ppjumps: expects a pp structure");
+    error ("ppjumps: PP must be a structure");
   endif
 
   ## Extract info.
   x = pp.x;
   P = pp.P;
   d = pp.d;
   [nd, n, k] = size (P);
 
@@ -47,8 +47,10 @@ function jumps = ppjumps (pp)
     llim .*= dx;
     llim += P(:,1:n-1,i);
   endfor
 
   rlim = P(:,2:n,k); # limits from the right
   jumps = reshape (rlim - llim, [d, n-1]);
 
 endfunction
+
+
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -31,17 +31,17 @@
 ## @end deftypefn 
 
 function yi = ppval (pp, xi)
 
   if (nargin != 2)
     print_usage ();
   endif
   if (! isstruct (pp))
-    error ("ppval: expects a pp structure");
+    error ("ppval: PP must be a structure");
   endif
 
   ## Extract info.
   x = pp.x;
   P = pp.P;
   d = pp.d;
   k = size (P, 3);
   nd = size (P, 1);
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -53,26 +53,26 @@
 
 function [a, b] = arch_fit (y, x, p, iter, gamma, a0, b0)
 
   if ((nargin < 3) || (nargin == 6) || (nargin > 7))
     print_usage ();
   endif
 
   if (! (isvector (y)))
-    error ("arch_fit: y must be a vector");
+    error ("arch_fit: Y must be a vector");
   endif
 
   T   = length (y);
   y   = reshape (y, T, 1);
   [rx, cx] = size (x);
   if ((rx == 1) && (cx == 1))
     x = autoreg_matrix (y, x);
   elseif (! (rx == T))
-    error ("arch_fit: either rows (x) == length (y), or x is a scalar");
+    error ("arch_fit: either rows (X) == length (Y), or X is a scalar");
   endif
 
   [T, k] = size (x);
 
   if (nargin == 7)
     a   = a0;
     b   = b0;
     e   = y - x * b;
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -43,24 +43,24 @@
 
 function y = arch_rnd (a, b, t)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (! ((min (size (a)) == 1) && (min (size (b)) == 1)))
-    error ("arch_rnd: a and b must both be scalars or vectors");
+    error ("arch_rnd: A and B must both be scalars or vectors");
   endif
   if (! (isscalar (t) && (t > 0) && (rem (t, 1) == 0)))
     error ("arch_rnd: T must be a positive integer");
   endif
 
   if (! (a(1) > 0))
-    error ("arch_rnd: a(1) must be positive");
+    error ("arch_rnd: A(1) must be positive");
   endif
   ## perhaps add a test for the roots of a(z) here ...
 
   la = length (a);
   a  = reshape (a, 1, la);
   if (la == 1)
     a  = [a, 0];
     la = la + 1;
diff --git a/scripts/signal/arch_test.m b/scripts/signal/arch_test.m
--- a/scripts/signal/arch_test.m
+++ b/scripts/signal/arch_test.m
@@ -68,28 +68,28 @@
 
 function [pval, lm] = arch_test (y, x, p)
 
   if (nargin != 3)
     error ("arch_test: 3 input arguments required");
   endif
 
   if (! (isvector (y)))
-    error ("arch_test: y must be a vector");
+    error ("arch_test: Y must be a vector");
   endif
   T   = length (y);
   y   = reshape (y, T, 1);
   [rx, cx] = size (x);
   if ((rx == 1) && (cx == 1))
     x = autoreg_matrix (y, x);
   elseif (! (rx == T))
-    error ("arch_test: either rows(X) == length(y), or X is a scalar");
+    error ("arch_test: either rows(X) == length(Y), or X is a scalar");
   endif
   if (! (isscalar(p) && (rem(p, 1) == 0) && (p > 0)))
-    error ("arch_test: p must be a positive integer");
+    error ("arch_test: P must be a positive integer");
   endif
 
   [b, v_b, e] = ols (y, x);
   Z    = autoreg_matrix (e.^2, p);
   f    = e.^2 / v_b - ones (T, 1);
   f    = Z' * f;
   lm   = f' * inv (Z'*Z) * f / 2;
   pval = 1 - chi2cdf (lm, p);
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -43,28 +43,28 @@
 ## Description: Simulate an ARMA process
 
 function x = arma_rnd (a, b, v, t, n)
 
   if (nargin == 4)
     n = 100;
   elseif (nargin == 5)
     if (!isscalar (n))
-      error ("arma_rnd: n must be a scalar");
+      error ("arma_rnd: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if ((min (size (a)) > 1) || (min (size (b)) > 1))
-    error ("arma_rnd: a and b must not be matrices");
+    error ("arma_rnd: A and B must not be matrices");
   endif
 
   if (!isscalar (t))
-    error ("arma_rnd: t must be a scalar");
+    error ("arma_rnd: T must be a scalar");
   endif
 
   ar = length (a);
   br = length (b);
 
   a = reshape (a, ar, 1);
   b = reshape (b, br, 1);
 
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -32,17 +32,17 @@
 
 function X = autoreg_matrix (y, k)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (! (isvector (y)))
-    error ("autoreg_matrix: y must be a vector");
+    error ("autoreg_matrix: Y must be a vector");
   endif
 
   T = length (y);
   y = reshape (y, T, 1);
   X = ones (T, k+1);
   for j = 1 : k;
     X(:, j+1) = [(zeros (j, 1)); y(1:T-j)];
   endfor
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -31,17 +31,17 @@
 
 function c = bartlett (m)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! (isscalar (m) && (m == round (m)) && (m > 0)))
-    error ("bartlett: m has to be an integer > 0");
+    error ("bartlett: M has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     n = fix (m / 2);
     c = [2*(0:n)/m, 2-2*(n+1:m)/m]';
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -30,17 +30,17 @@
 
 function c = blackman (m)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! (isscalar (m) && (m == round (m)) && (m > 0)))
-    error ("blackman: m has to be an integer > 0");
+    error ("blackman: M has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     k = (0 : m)' / m;
     c = 0.42 - 0.5 * cos (2 * pi * k) + 0.08 * cos (4 * pi * k);
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -57,17 +57,17 @@ function [d, dd] = diffpara (x, a, b)
       b = 1.5 * sqrt (n);
     elseif (nargin == 2)
       b = a;
       a = 1;
     endif
   endif
 
   if (! (isscalar (a) && isscalar (b)))
-    error ("diffpara: a and b must be scalars");
+    error ("diffpara: A and B must be scalars");
   endif
 
   dd = zeros (b - a + 1, k);
 
   for l = 1:k
 
     w = 2 * pi * (1 : n-1) / n;
 
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -46,21 +46,21 @@ function [newphi, newv] = durbinlevinson
   newphi = 0;
   newv = 0;
 
   if (nargin == 3)
 
     t = length (oldphi) + 1;
 
     if (length (c) < t+1)
-      error ("durbinlevinson: c too small");
+      error ("durbinlevinson: C too small");
     endif
 
     if (oldv == 0)
-      error ("durbinlevinson: oldv = 0");
+      error ("durbinlevinson: OLDV = 0");
     endif
 
     if (rows (oldphi) > 1)
       oldphi = oldphi';
     endif
 
     newphi = zeros (1, t);
     newphi(1) = (c(t+1) - oldphi * c(2:t)) / oldv;
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -50,32 +50,32 @@ function y = fftfilt (b, x, n)
   if (transpose)
     x = x.';
   endif
 
   [r_x, c_x] = size (x);
   [r_b, c_b] = size (b);
 
   if min ([r_b, c_b]) != 1
-    error ("fftfilt: b should be a vector");
+    error ("fftfilt: B should be a vector");
   endif
 
   l_b = r_b * c_b;
   b = reshape (b, l_b, 1);
 
   if (nargin == 2)
     ## Use FFT with the smallest power of 2 which is >= length (x) +
     ## length (b) - 1 as number of points ...
     n = 2 ^ (ceil (log (r_x + l_b - 1) / log (2)));
     B = fft (b, n);
     y = ifft (fft (x, n) .* B(:,ones (1, c_x)));
   else
     ## Use overlap-add method ...
     if (! (isscalar (n)))
-      error ("fftfilt: n has to be a scalar");
+      error ("fftfilt: N has to be a scalar");
     endif
     n = 2 ^ (ceil (log (max ([n, l_b])) / log (2)));
     L = n - l_b + 1;
     B = fft (b, n);
     B = B(:,ones (c_x,1));
     R = ceil (r_x / L);
     y = zeros (r_x, c_x);
     for r = 1:R;
diff --git a/scripts/signal/fractdiff.m b/scripts/signal/fractdiff.m
--- a/scripts/signal/fractdiff.m
+++ b/scripts/signal/fractdiff.m
@@ -30,21 +30,21 @@ function retval = fractdiff (x, d)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   N = 100;
 
   if (! isvector (x))
-    error ("fractdiff: x must be a vector");
+    error ("fractdiff: X must be a vector");
   endif
 
   if (! isscalar (d))
-    error ("fractdiff: d must be a scalar");
+    error ("fractdiff: D must be a scalar");
   endif
 
 
   if (d >= 1)
     for k = 1 : d
       x = x(2 : length (x)) - x(1 : length (x) - 1);
     endfor
   endif
@@ -58,13 +58,13 @@ function retval = fractdiff (x, d)
       w = real (gamma (-d+n) ./ gamma (-d) ./ gamma (n+1));
       retval = fftfilt (w, x);
       retval = retval(1 : length (x));
     else
       retval = x;
     endif
 
   else
-    error ("fractdiff: d must be > -1");
+    error ("fractdiff: D must be > -1");
 
   endif
 
 endfunction
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -30,17 +30,17 @@
 
 function c = hamming (m)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! (isscalar (m) && (m == round (m)) && (m > 0)))
-    error ("hamming: m has to be an integer > 0");
+    error ("hamming: M has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     c = 0.54 - 0.46 * cos (2 * pi * (0:m)' / m);
   endif
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -30,17 +30,17 @@
 
 function c = hanning (m)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! (isscalar (m) && (m == round (m)) && (m > 0)))
-    error ("hanning: m has to be an integer > 0");
+    error ("hanning: M has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     c = 0.5 - 0.5 * cos (2 * pi * (0 : m)' / m);
   endif
diff --git a/scripts/signal/hurst.m b/scripts/signal/hurst.m
--- a/scripts/signal/hurst.m
+++ b/scripts/signal/hurst.m
@@ -29,17 +29,17 @@
 
 function H = hurst (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (isscalar (x))
-    error ("hurst: x must not be a scalar");
+    error ("hurst: X must not be a scalar");
   elseif (isvector (x))
     x = reshape (x, length (x), 1);
   endif
 
   [xr, xc] = size (x);
 
   s = std (x);
   w = cumsum (x - mean (x));
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -14,17 +14,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[Pxx,w]} = periodogram (@var{x})
+## @deftypefn {Function File} {[Pxx,w] =} periodogram (@var{x})
 ## For a data matrix @var{x} from a sample of size @var{n}, return the
 ## periodogram. w returns the angular frequency.
 ##
 ##   [Pxx,w] = periodogram (@var{x}).
 ##
 ##   [Pxx,w] = periodogram (@var{x},win).
 ##
 ##   [Pxx,w] = periodogram (@var{x},win,nfft).
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -41,21 +41,21 @@ function retval = sinetone (freq, rate, 
   elseif (nargin == 3)
     ampl = 64;
   elseif ((nargin < 1) || (nargin > 4))
     print_usage ();
   endif
 
   [err, freq, ampl] = common_size (freq, ampl);
   if (err || ! isvector (freq))
-    error ("sinetone: freq and ampl must be vectors of common size");
+    error ("sinetone: FREQ and AMPL must be vectors of common size");
   endif
 
   if (! (isscalar (rate) && isscalar (sec)))
-    error ("sinetone: rate and sec must be scalars");
+    error ("sinetone: RATE and SEC must be scalars");
   endif
 
   n = length (freq);
   ns = round (rate * sec);
 
   retval = zeros (ns, n);
 
   for k = 1:n
diff --git a/scripts/signal/synthesis.m b/scripts/signal/synthesis.m
--- a/scripts/signal/synthesis.m
+++ b/scripts/signal/synthesis.m
@@ -36,17 +36,17 @@
 function x = synthesis (y, c)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   [nr, nc] = size (c);
   if (nr * nc != 3)
-    error ("synthesis: c must contain exactly 3 elements");
+    error ("synthesis: C must contain exactly 3 elements");
   endif
 
   w_size = c(1);
   inc    = c(2);
   w_type = c(3);
 
   if (w_type == 1)
     w_coeff = hanning (w_size);
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -32,17 +32,17 @@
 
 function retval = unwrap (x, tol, dim)
         
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (!isnumeric(x))
-    error ("unwrap: x must be a numeric matrix or vector");
+    error ("unwrap: X must be a numeric matrix or vector");
   endif
 
   if (nargin < 2 || isempty (tol))
     tol = pi;
   endif
 
   ## Don't let anyone use a negative value for TOL.
   tol = abs (tol);
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -42,36 +42,36 @@
 ## The value @var{resvec} is a vector of @var{relres} for each iteration.
 ##
 ## @end deftypefn
 
 function [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, maxit, M1, M2, x0)
 
   if (nargin < 2 || nargin > 7 || nargout > 5)
     print_usage ();
-  elseif (!isnumeric (A) || rows (A) != columns (A))
-    error ("bicgstab: the first argument must be a n-by-n matrix");
+  elseif (!(isnumeric (A) && issquare (A)))
+    error ("bicgstab: A must be a square numeric matrix");
   elseif (!isvector (b))
-    error ("bicgstab: b must be a vector");
+    error ("bicgstab: B must be a vector");
   elseif (!any (b))
-    error ("bicgstab: b shuldn't be a vector of zeros");
+    error ("bicgstab: B must not be a vector of all zeros");
   elseif (rows (A) != rows (b))
-    error ("bicgstab: the first and second argument must have the same number of rows");
+    error ("bicgstab: A and B must have the same number of rows");
   elseif (nargin > 2 && !isscalar (tol))
-    error ("bicgstab: tol must be a scalar");
+    error ("bicgstab: TOL must be a scalar");
   elseif (nargin > 3 && !isscalar (maxit))
-    error ("bicgstab: maxit must be a scalar");
+    error ("bicgstab: MAXIT must be a scalar");
   elseif (nargin > 4 && ismatrix (M1) && (rows (M1) != rows (A) || columns (M1) != columns (A)))
     error ("bicgstab: M1 must have the same number of rows and columns as A");
   elseif (nargin > 5 && (!ismatrix (M2) || rows (M2) != rows (A) || columns (M2) != columns (A)))
     error ("bicgstab: M2 must have the same number of rows and columns as A");
   elseif (nargin > 6 && !isvector (x0))
-    error ("bicgstab: x0 must be a vector");
+    error ("bicgstab: X0 must be a vector");
   elseif (nargin > 6 && rows (x0) != rows (b))
-    error ("bicgstab: x0 must have the same number of rows as b");
+    error ("bicgstab: X0 must have the same number of rows as B");
   endif
 
   ## Default tolerance.
   if (nargin < 3)
     tol = 1e-6;
   endif
 
   ## Default maximum number of iteration.
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -32,34 +32,34 @@
 ## The @var{x0} is initial guess, default value is zeros(N,1).
 ##
 ## @end deftypefn
 
 function [x, flag, relres, iter, resvec] = cgs (A, b, tol, maxit, M1, M2, x0)
 
   if (nargin < 2 || nargin > 7 || nargout > 5)
     print_usage ();
-  elseif (!isnumeric (A) || rows (A) != columns (A))
-    error ("cgs: first argument must be a n-by-n matrix");
+  elseif (!(isnumeric (A) && issquare (A)))
+    error ("cgs: A must be a square numeric matrix");
   elseif (!isvector (b))
-    error ("cgs: b must be a vector");
+    error ("cgs: B must be a vector");
   elseif (rows (A) != rows (b))
-    error ("cgs: first and second argument must have the same number of rows");
+    error ("cgs: A and B must have the same number of rows");
   elseif (nargin > 2 && !isscalar (tol))
-    error ("cgs: tol must be a scalar");
+    error ("cgs: TOL must be a scalar");
   elseif (nargin > 3 && !isscalar (maxit))
-    error ("cgs: maxit must be a scalar");
+    error ("cgs: MAXIT must be a scalar");
   elseif (nargin > 4 && ismatrix (M1) && (rows (M1) != rows (A) || columns (M1) != columns (A)))
     error ("cgs: M1 must have the same number of rows and columns as A");
   elseif (nargin > 5 && (!ismatrix (M2) || rows (M2) != rows (A) || columns (M2) != columns (A)))
     error ("cgs: M2 must have the same number of rows and columns as A");
   elseif (nargin > 6 && !isvector (x0))
-    error ("cgs: x0 must be a vector");
+    error ("cgs: X0 must be a vector");
   elseif (nargin > 6 && rows (x0) != rows (b))
-    error ("cgs: x0 must have the same number of rows as b");
+    error ("cgs: X0 must have the same number of rows as B");
   endif
 
   ## Default tolerance.
   if (nargin < 3)
     tol = 1e-6;
   endif
 
   ## Default maximum number of iteration.
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -79,17 +79,17 @@ function s = spaugment (A, c)
     else
       if (ndims (A) != 2)
         error ("spaugment: expecting 2-dimenisional matrix")
       else
         c = max (abs (A(:))) / 1000;
       endif
     endif
   elseif (!isscalar (c))
-    error ("spaugment: c must be a scalar");
+    error ("spaugment: C must be a scalar");
   endif
 
   [m, n] = size (A);
   s = [ c * speye(m, m), A; A', sparse(n, n)];
 endfunction
 
 %!testif HAVE_UMFPACK
 %! m = 11; n = 10; mn = max(m ,n);
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -39,17 +39,17 @@
 
 function [x, n] = factor (q)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   if (! isscalar (q) || q != fix (q))
-    error ("factor: q must be a scalar integer");
+    error ("factor: Q must be a scalar integer");
   endif
 
   ## Special case of no primes less than sqrt(q).
   if (q < 4)
     x = q;
     n = 1;
     return;
   endif 
diff --git a/scripts/specfun/factorial.m b/scripts/specfun/factorial.m
--- a/scripts/specfun/factorial.m
+++ b/scripts/specfun/factorial.m
@@ -25,17 +25,17 @@
 ## @code{gamma}.
 ## @seealso{prod, gamma}
 ## @end deftypefn
 
 function x = factorial (n)
   if (nargin != 1)
     print_usage ();
   elseif (any (n(:) < 0 | n(:) != round (n(:))))
-    error ("factorial: n must all be nonnegative integers");
+    error ("factorial: N must all be nonnegative integers");
   endif
   x = round (gamma (n+1));
 endfunction
 
 %!assert (factorial(5), prod(1:5))
 %!assert (factorial([1,2;3,4]), [1,2;6,24])
 %!assert (factorial(70), exp(sum(log(1:70))), -128*eps)
 %!fail ('factorial(5.5)', "must all be nonnegative integers")
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -169,17 +169,17 @@ function retval = legendre (n, x, normal
   switch (normalization)
     case "norm"
       scale = sqrt (n+0.5);
     case "sch"
       scale = sqrt (2);
     case "unnorm"
       scale = 1;
     otherwise
-      error ('legendre: expecting normalization option to be "norm", "sch", or "unnorm"');
+      error ('legendre: expecting NORMALIZATION option to be "norm", "sch", or "unnorm"');
   endswitch
 
   if (rows (x) != 1)
     x = x';
   endif
   scale = scale * ones (1, numel (x));
 
   ## Based on the recurrence relation below
diff --git a/scripts/specfun/nthroot.m b/scripts/specfun/nthroot.m
--- a/scripts/specfun/nthroot.m
+++ b/scripts/specfun/nthroot.m
@@ -42,31 +42,31 @@
 
 function y = nthroot (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (! isscalar (n))
-    error ("nthroot: n must be a nonzero scalar");
+    error ("nthroot: N must be a nonzero scalar");
   endif
 
   if (n == 3)
     y = cbrt (x);
   elseif (n == -3)
     y = 1 ./ cbrt (x);
   elseif (n < 0)
     y = 1 ./ nthroot (x, -n);
   else
     ## Compute using power.
     if (n == round (n) && mod (n, 2) == 1)
       y = abs (x) .^ (1/n) .* sign (x);
     elseif (any (x(:) < 0))
-      error ("nthroot: if x contains negative values, n must be an odd integer");
+      error ("nthroot: if X contains negative values, N must be an odd integer");
     else
       y = x .^ (1/n);
     endif
 
     if (finite (n) && n > 0 && n == round (n))
       ## Correction.
       y = ((n-1)*y + x ./ (y.^(n-1))) / n;
       y = merge (finite (y), y, x);
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -32,27 +32,27 @@
 ## @end tex
 ## @ifnottex
 ## k*log(5*k).
 ## @end ifnottex
 ## @seealso{list_primes, isprime}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
-## Author: Francesco Potort
+## Author: Francesco Potort
 ## Author: Dirk Laurie
 
 function x = primes (n)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! isscalar (n))
-    error ("primes: n must be a scalar");
+    error ("primes: N must be a scalar");
   endif
 
   if (n > 100000)
     ## Optimization: 1/6 less memory, and much faster (asymptotically)
     ## 100000 happens to be the cross-over point for Paul's machine;
     ## below this the more direct code below is faster.  At the limit
     ## of memory in Paul's machine, this saves .7 seconds out of 7 for
     ## n = 3e6.  Hardly worthwhile, but Dirk reports better numbers.
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -88,17 +88,17 @@ function h = hadamard (n)
       h = 1;
     case 3
       h = h12 ();
     case 5
       h = h20 ();
     case 7
       h = hnormalize (h28 ());
     otherwise
-      error ("hadamard: n must be 2^k*p, for p = 1, 12, 20 or 28");
+      error ("hadamard: N must be 2^k*p, for p = 1, 12, 20 or 28");
   endswitch
 
   ## Build H(2^k*n) from kron(H(2^k),H(n)).
   h2 = [1,1;1,-1];
   while (true)
     if (floor (k/2) != k/2)
       h = kron (h2, h); 
     endif
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -26,17 +26,17 @@
 
 function A = magic(n)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (n != floor (n) || n < 0 || n == 2)
-    error ("magic: n must be an positive integer not equal to 2");
+    error ("magic: N must be an positive integer not equal to 2");
   endif
 
   if (n == 0)
 
     A = [];
 
   elseif (mod (n, 2) == 1)
 
diff --git a/scripts/statistics/distributions/betacdf.m b/scripts/statistics/distributions/betacdf.m
--- a/scripts/statistics/distributions/betacdf.m
+++ b/scripts/statistics/distributions/betacdf.m
@@ -30,17 +30,17 @@ function cdf = betacdf (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
-      error ("betacdf: x, a and b must be of common size or scalar");
+      error ("betacdf: X, A and B must be of common size or scalar");
     endif
   endif
 
   sz = size(x);
   cdf = zeros (sz);
 
   k = find (!(a > 0) | !(b > 0) | isnan (x));
   if (any (k))
diff --git a/scripts/statistics/distributions/betainv.m b/scripts/statistics/distributions/betainv.m
--- a/scripts/statistics/distributions/betainv.m
+++ b/scripts/statistics/distributions/betainv.m
@@ -30,17 +30,17 @@ function inv = betainv (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
-      error ("betainv: x, a and b must be of common size or scalars");
+      error ("betainv: X, A and B must be of common size or scalars");
     endif
   endif
   
   sz = size (x);
   inv = zeros (sz);
 
   k = find ((x < 0) | (x > 1) | !(a > 0) | !(b > 0) | isnan (x));
   if (any (k))
diff --git a/scripts/statistics/distributions/betapdf.m b/scripts/statistics/distributions/betapdf.m
--- a/scripts/statistics/distributions/betapdf.m
+++ b/scripts/statistics/distributions/betapdf.m
@@ -30,17 +30,17 @@ function pdf = betapdf (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
   
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
-      error ("betapdf: x, a and b must be of common size or scalar");
+      error ("betapdf: X, A and B must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   pdf = zeros (sz);
 
   k = find (!(a > 0) | !(b > 0) | isnan (x));
   if (any (k))
diff --git a/scripts/statistics/distributions/betarnd.m b/scripts/statistics/distributions/betarnd.m
--- a/scripts/statistics/distributions/betarnd.m
+++ b/scripts/statistics/distributions/betarnd.m
@@ -32,46 +32,46 @@
 ## Description: Random deviates from the Beta distribution
 
 function rnd = betarnd (a, b, r, c)
 
   if (nargin > 1)
     if (!isscalar(a) || !isscalar(b)) 
       [retval, a, b] = common_size (a, b);
       if (retval > 0)
-        error ("betarnd: a and b must be of common size or scalar");
+        error ("betarnd: A and B must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("betarnd: r must be a positive integer");
+      error ("betarnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("betarnd: c must be a positive integer");
+      error ("betarnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (a) != 1)
         && (length (size (a)) != length (sz) || any (size (a) != sz)))
-      error ("betarnd: a and b must be scalar or of size [r,c]");
+      error ("betarnd: A and B must be scalar or of size [R,C]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("betarnd: r must be a positive integer or vector");
+      error ("betarnd: R must be a positive integer or vector");
     endif
 
     if (any (size (a) != 1)
         && (length (size (a)) != length (sz) || any (size (a) != sz)))
-      error ("betarnd: a and b must be scalar or of size sz");
+      error ("betarnd: A and B must be scalar or of size SZ");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
     print_usage ();
   endif
 
   if (isscalar(a) && isscalar(b))
diff --git a/scripts/statistics/distributions/binocdf.m b/scripts/statistics/distributions/binocdf.m
--- a/scripts/statistics/distributions/binocdf.m
+++ b/scripts/statistics/distributions/binocdf.m
@@ -29,17 +29,17 @@ function cdf = binocdf (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar (n) || !isscalar (p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
-      error ("binocdf: x, n and p must be of common size or scalar");
+      error ("binocdf: X, N and P must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   cdf = zeros (sz);
 
   k = find (isnan (x) | !(n >= 0) | (n != round (n))
             | !(p >= 0) | !(p <= 1));
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
--- a/scripts/statistics/distributions/binoinv.m
+++ b/scripts/statistics/distributions/binoinv.m
@@ -29,17 +29,17 @@ function inv = binoinv (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar (n) || !isscalar (p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
-      error ("binoinv: x, n and p must be of common size or scalars");
+      error ("binoinv: X, N and P must be of common size or scalars");
     endif
   endif
   
   sz = size (x);
   inv = zeros (sz);
 
   k = find (!(x >= 0) | !(x <= 1) | !(n >= 0) | (n != round (n))
             | !(p >= 0) | !(p <= 1));
diff --git a/scripts/statistics/distributions/binopdf.m b/scripts/statistics/distributions/binopdf.m
--- a/scripts/statistics/distributions/binopdf.m
+++ b/scripts/statistics/distributions/binopdf.m
@@ -30,17 +30,17 @@ function pdf = binopdf (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (! isscalar (n) || ! isscalar (p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
-      error ("binopdf: x, n and p must be of common size or scalar");
+      error ("binopdf: X, N and P must be of common size or scalar");
     endif
   endif
 
   k = ((x >= 0) & (x <= n)
        & (x == round (x)) & (n == round (n))
        & (p >= 0) & (p <= 1));
 
   pdf = zeros (size (x));
diff --git a/scripts/statistics/distributions/binornd.m b/scripts/statistics/distributions/binornd.m
--- a/scripts/statistics/distributions/binornd.m
+++ b/scripts/statistics/distributions/binornd.m
@@ -32,46 +32,46 @@
 ## Description: Random deviates from the binomial distribution
 
 function rnd = binornd (n, p, r, c)
 
   if (nargin > 1)
     if (!isscalar(n) || !isscalar(p)) 
       [retval, n, p] = common_size (n, p);
       if (retval > 0)
-        error ("binornd: n and p must be of common size or scalar");
+        error ("binornd: N and P must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("binornd: r must be a positive integer");
+      error ("binornd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("binornd: c must be a positive integer");
+      error ("binornd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (n) != 1)
         && (length (size (n)) != length (sz) || any (size (n) != sz)))
-      error ("binornd: n and must be scalar or of size [r, c]");
+      error ("binornd: N and must be scalar or of size [R, C]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("binornd: r must be a positive integer or vector");
+      error ("binornd: R must be a positive integer or vector");
     endif
 
     if (any (size (n) != 1)
         && (length (size (n)) != length (sz) || any (size (n) != sz)))
-      error ("binornd: n and must be scalar or of size sz");
+      error ("binornd: N and must be scalar or of size SZ");
     endif
   elseif (nargin == 2)
     sz = size(n);
   else
     print_usage ();
   endif
 
   if (isscalar (n) && isscalar (p))
diff --git a/scripts/statistics/distributions/cauchy_cdf.m b/scripts/statistics/distributions/cauchy_cdf.m
--- a/scripts/statistics/distributions/cauchy_cdf.m
+++ b/scripts/statistics/distributions/cauchy_cdf.m
@@ -37,17 +37,17 @@ function cdf = cauchy_cdf (x, location, 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
   if (!isscalar (location) || !isscalar (scale)) 
     [retval, x, location, scale] = common_size (x, location, scale);
     if (retval > 0)
-      error ("cauchy_cdf: x, location and scale must be of common size or scalar");
+      error ("cauchy_cdf: X, LOCATION and SCALE must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   cdf = NaN (sz);
 
   k = find ((x > -Inf) & (x < Inf) & (location > -Inf) &
             (location < Inf) & (scale > 0) & (scale < Inf));
diff --git a/scripts/statistics/distributions/cauchy_inv.m b/scripts/statistics/distributions/cauchy_inv.m
--- a/scripts/statistics/distributions/cauchy_inv.m
+++ b/scripts/statistics/distributions/cauchy_inv.m
@@ -37,17 +37,17 @@ function inv = cauchy_inv (x, location, 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
   if (!isscalar (location) || !isscalar (scale)) 
     [retval, x, location, scale] = common_size (x, location, scale);
     if (retval > 0)
-      error ("cauchy_inv: x, location and scale must be of common size or scalar");
+      error ("cauchy_inv: X, LOCATION and SCALE must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   inv = NaN (sz);
 
   ok = ((location > -Inf) & (location < Inf) &
        (scale > 0) & (scale < Inf));
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ b/scripts/statistics/distributions/cauchy_pdf.m
@@ -37,17 +37,17 @@ function pdf = cauchy_pdf (x, location, 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
   if (!isscalar (location) || !isscalar (scale)) 
     [retval, x, location, scale] = common_size (x, location, scale);
     if (retval > 0)
-      error ("cauchy_pdf: x, location and scale must be of common size or scalar");
+      error ("cauchy_pdf: X, LOCATION and SCALE must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   pdf = NaN (sz);
 
   k = find ((x > -Inf) & (x < Inf) & (location > -Inf) &
             (location < Inf) & (scale > 0) & (scale < Inf));
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -32,48 +32,48 @@
 ## Description: Random deviates from the Cauchy distribution
 
 function rnd = cauchy_rnd (location, scale, r, c)
 
   if (nargin > 1)
     if (!isscalar (location) || !isscalar (scale)) 
       [retval, location, scale] = common_size (location, scale);
       if (retval > 0)
-        error ("cauchy_rnd: location and scale must be of common size or scalar");
+        error ("cauchy_rnd: LOCATION and SCALE must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("cauchy_rnd: r must be a positive integer");
+      error ("cauchy_rnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("cauchy_rnd: c must be a positive integer");
+      error ("cauchy_rnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (location) != 1)
         && (length (size (location)) != length (sz)
             || any (size (location) != sz)))
-      error ("cauchy_rnd: location and scale must be scalar or of size [r, c]");
+      error ("cauchy_rnd: LOCATION and SCALE must be scalar or of size [R, C]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("cauchy_rnd: r must be a positive integer or vector");
+      error ("cauchy_rnd: R must be a positive integer or vector");
     endif
 
     if (any (size (location) != 1)
         && (length (size (location)) != length (sz)
         || any (size (location) != sz)))
-      error ("cauchy_rnd: location and scale must be scalar or of size sz");
+      error ("cauchy_rnd: LOCATION and SCALE must be scalar or of size SZ");
     endif
   elseif (nargin == 2)
     sz = size(location);
   else
     print_usage ();
   endif
 
   if (isscalar (location) && isscalar (scale)) 
diff --git a/scripts/statistics/distributions/chi2cdf.m b/scripts/statistics/distributions/chi2cdf.m
--- a/scripts/statistics/distributions/chi2cdf.m
+++ b/scripts/statistics/distributions/chi2cdf.m
@@ -30,15 +30,15 @@ function cdf = chi2cdf (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
-      error ("chi2cdf: x and n must be of common size or scalar");
+      error ("chi2cdf: X and N must be of common size or scalar");
     endif
   endif
 
   cdf = gamcdf (x, n / 2, 2);
 
 endfunction
diff --git a/scripts/statistics/distributions/chi2inv.m b/scripts/statistics/distributions/chi2inv.m
--- a/scripts/statistics/distributions/chi2inv.m
+++ b/scripts/statistics/distributions/chi2inv.m
@@ -30,15 +30,15 @@ function inv = chi2inv (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
-      error ("chi2inv: x and n must be of common size or scalar");
+      error ("chi2inv: X and N must be of common size or scalar");
     endif
   endif
 
   inv = gaminv (x, n / 2, 2);
 
 endfunction
diff --git a/scripts/statistics/distributions/chi2pdf.m b/scripts/statistics/distributions/chi2pdf.m
--- a/scripts/statistics/distributions/chi2pdf.m
+++ b/scripts/statistics/distributions/chi2pdf.m
@@ -30,15 +30,15 @@ function pdf = chi2pdf (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
-      error ("chi2pdf: x and n must be of common size or scalar");
+      error ("chi2pdf: X and N must be of common size or scalar");
     endif
   endif
 
   pdf = gampdf (x, n / 2, 2);
 
 endfunction
diff --git a/scripts/statistics/distributions/chi2rnd.m b/scripts/statistics/distributions/chi2rnd.m
--- a/scripts/statistics/distributions/chi2rnd.m
+++ b/scripts/statistics/distributions/chi2rnd.m
@@ -29,39 +29,39 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the chi-square distribution
 
 function rnd = chi2rnd (n, r, c)
 
   if (nargin == 3)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("chi2rnd: r must be a positive integer");
+      error ("chi2rnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("chi2rnd: c must be a positive integer");
+      error ("chi2rnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (n) != 1)
         && (length (size (n)) != length (sz) || any (size (n) != sz)))
-      error ("chi2rnd: n must be scalar or of size [r, c]");
+      error ("chi2rnd: N must be scalar or of size [R, C]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("chi2rnd: r must be a positive integer or vector");
+      error ("chi2rnd: R must be a positive integer or vector");
     endif
 
     if (any (size (n) != 1)
         && (length (size (n)) != length (sz) || any (size (n) != sz)))
-      error ("chi2rnd: n must be scalar or of size sz");
+      error ("chi2rnd: N must be scalar or of size SZ");
     endif
   elseif (nargin == 1)
     sz = size(n);
   else
     print_usage ();
   endif
 
   if (isscalar (n))
diff --git a/scripts/statistics/distributions/discrete_cdf.m b/scripts/statistics/distributions/discrete_cdf.m
--- a/scripts/statistics/distributions/discrete_cdf.m
+++ b/scripts/statistics/distributions/discrete_cdf.m
@@ -27,21 +27,21 @@ function cdf = discrete_cdf (x, v, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   sz = size (x);
 
   if (! isvector (v))
-    error ("discrete_cdf: v must be a vector");
+    error ("discrete_cdf: V must be a vector");
   elseif (! isvector (p) || (length (p) != length (v)))
-    error ("discrete_cdf: p must be a vector with length (v) elements");
+    error ("discrete_cdf: P must be a vector with length (V) elements");
   elseif (! (all (p >= 0) && any (p)))
-    error ("discrete_cdf: p must be a nonzero, nonnegative vector");
+    error ("discrete_cdf: P must be a nonzero, nonnegative vector");
   endif
 
   n = numel (x);
   m = length (v);
   x = reshape (x, n, 1);
   v = reshape (v, 1, m);
   p = reshape (p / sum (p), m, 1);
 
diff --git a/scripts/statistics/distributions/discrete_inv.m b/scripts/statistics/distributions/discrete_inv.m
--- a/scripts/statistics/distributions/discrete_inv.m
+++ b/scripts/statistics/distributions/discrete_inv.m
@@ -31,21 +31,21 @@ function inv = discrete_inv (x, v, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   sz = size (x);
 
   if (! isvector (v))
-    error ("discrete_inv: v must be a vector");
+    error ("discrete_inv: V must be a vector");
   elseif (! isvector (p) || (length (p) != length (v)))
-    error ("discrete_inv: p must be a vector with length (v) elements");
+    error ("discrete_inv: P must be a vector with length (V) elements");
   elseif (! (all (p >= 0) && any (p)))
-    error ("discrete_inv: p must be a nonzero, nonnegative vector");
+    error ("discrete_inv: P must be a nonzero, nonnegative vector");
   endif
 
   n = numel (x);
   x = reshape (x, 1, n);
   m = length (v);
   [v, idx] = sort (v);
   p = reshape (cumsum (p (idx) / sum (p)), m, 1);
 
diff --git a/scripts/statistics/distributions/discrete_pdf.m b/scripts/statistics/distributions/discrete_pdf.m
--- a/scripts/statistics/distributions/discrete_pdf.m
+++ b/scripts/statistics/distributions/discrete_pdf.m
@@ -31,21 +31,21 @@ function pdf = discrete_pdf (x, v, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   sz = size (x);
 
   if (! isvector (v))
-    error ("discrete_pdf: v must be a vector");
+    error ("discrete_pdf: V must be a vector");
   elseif (! isvector (p) || (length (p) != length (v)))
-    error ("discrete_pdf: p must be a vector with length (v) elements");
+    error ("discrete_pdf: P must be a vector with length (V) elements");
   elseif (! (all (p >= 0) && any (p)))
-    error ("discrete_pdf: p must be a nonzero, nonnegative vector");
+    error ("discrete_pdf: P must be a nonzero, nonnegative vector");
   endif
 
   n = numel (x);
   m = length (v);
   x = reshape (x, n, 1);
   v = reshape (v, 1, m);
   p = reshape (p / sum (p), m, 1);
 
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -32,20 +32,20 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from a discrete distribution
 
 function rnd = discrete_rnd (v, p, r, c)
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("discrete_rnd: r must be a positive integer");
+      error ("discrete_rnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("discrete_rnd: c must be a positive integer");
+      error ("discrete_rnd: C must be a positive integer");
     endif
     sz = [r, c];
   elseif (nargin == 3)
     ## A potential problem happens here if all args are scalar, as
     ## we can't distiguish between the command syntax. Thankfully this
     ## case doesn't make much sense. So we assume the first syntax
     ## if the first arg is scalar
 
@@ -54,25 +54,25 @@ function rnd = discrete_rnd (v, p, r, c)
       v = p;
       p = r;
     else
       if (isscalar (r) && (r > 0))
         sz = [r, r];
       elseif (isvector(r) && all (r > 0))
         sz = r(:)';
       else
-        error ("discrete_rnd: r must be a positive integer or vector");
+        error ("discrete_rnd: R must be a positive integer or vector");
       endif
     endif
   else
     print_usage ();
   endif
 
   if (! isvector (v))
-    error ("discrete_rnd: v must be a vector");
+    error ("discrete_rnd: V must be a vector");
   elseif (! isvector (p) || (length (p) != length (v)))
-    error ("discrete_rnd: p must be a vector with length (v) elements");
+    error ("discrete_rnd: P must be a vector with length (V) elements");
   elseif (! (all (p >= 0) && any (p)))
-    error ("discrete_rnd: p must be a nonzero, nonnegative vector");
+    error ("discrete_rnd: P must be a nonzero, nonnegative vector");
   endif
 
   rnd = v (lookup (cumsum (p (1 : end-1)) / sum(p), rand (sz)) + 1); 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_cdf.m b/scripts/statistics/distributions/empirical_cdf.m
--- a/scripts/statistics/distributions/empirical_cdf.m
+++ b/scripts/statistics/distributions/empirical_cdf.m
@@ -28,14 +28,14 @@
 
 function cdf = empirical_cdf (x, data)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (! isvector (data))
-    error ("empirical_cdf: data must be a vector");
+    error ("empirical_cdf: DATA must be a vector");
   endif
 
   cdf = discrete_cdf (x, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_inv.m b/scripts/statistics/distributions/empirical_inv.m
--- a/scripts/statistics/distributions/empirical_inv.m
+++ b/scripts/statistics/distributions/empirical_inv.m
@@ -28,14 +28,14 @@
 
 function inv = empirical_inv (x, data)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (! isvector (data))
-    error ("empirical_inv: data must be a vector");
+    error ("empirical_inv: DATA must be a vector");
   endif
 
   inv = discrete_inv (x, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_pdf.m b/scripts/statistics/distributions/empirical_pdf.m
--- a/scripts/statistics/distributions/empirical_pdf.m
+++ b/scripts/statistics/distributions/empirical_pdf.m
@@ -28,14 +28,14 @@
 
 function pdf = empirical_pdf (x, data)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (! isvector (data))
-    error ("empirical_pdf: data must be a vector");
+    error ("empirical_pdf: DATA must be a vector");
   endif
 
   pdf = discrete_pdf (x, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/distributions/empirical_rnd.m
--- a/scripts/statistics/distributions/empirical_rnd.m
+++ b/scripts/statistics/distributions/empirical_rnd.m
@@ -40,14 +40,14 @@ function rnd = empirical_rnd (data, r, c
       data = r;
       r = 1;
     endif
   elseif (nargin != 3)
     print_usage ();
   endif
 
   if (! isvector (data))
-    error ("empirical_rnd: data must be a vector");
+    error ("empirical_rnd: DATA must be a vector");
   endif
 
   rnd = discrete_rnd (data, ones (size (data)) / length (data), r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/expcdf.m b/scripts/statistics/distributions/expcdf.m
--- a/scripts/statistics/distributions/expcdf.m
+++ b/scripts/statistics/distributions/expcdf.m
@@ -32,17 +32,17 @@ function cdf = expcdf (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (x) && !isscalar(lambda))
     [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
-      error ("expcdf: x and lambda must be of common size or scalar");
+      error ("expcdf: X and LAMBDA must be of common size or scalar");
     endif
   endif
 
   if (isscalar (x))
     sz = size (lambda);
   else
     sz = size (x);
   endif
diff --git a/scripts/statistics/distributions/expinv.m b/scripts/statistics/distributions/expinv.m
--- a/scripts/statistics/distributions/expinv.m
+++ b/scripts/statistics/distributions/expinv.m
@@ -30,17 +30,17 @@ function inv = expinv (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (x) && !isscalar(lambda))
     [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
-      error ("expinv: x and lambda must be of common size or scalar");
+      error ("expinv: X and LAMBDA must be of common size or scalar");
     endif
   endif
 
   if (isscalar (x))
     sz = size (lambda);
   else
     sz = size (x);
   endif
diff --git a/scripts/statistics/distributions/exppdf.m b/scripts/statistics/distributions/exppdf.m
--- a/scripts/statistics/distributions/exppdf.m
+++ b/scripts/statistics/distributions/exppdf.m
@@ -29,17 +29,17 @@ function pdf = exppdf (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (x) && !isscalar(lambda))
     [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
-      error ("exppdf: x and lambda must be of common size or scalar");
+      error ("exppdf: X and LAMBDA must be of common size or scalar");
     endif
   endif
 
   if (isscalar (x))
     sz = size (lambda);
   else
     sz = size (x);
   endif
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -30,39 +30,39 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the exponential distribution
 
 function rnd = exprnd (lambda, r, c)
 
   if (nargin == 3)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("exprnd: r must be a positive integer");
+      error ("exprnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("exprnd: c must be a positive integer");
+      error ("exprnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (lambda) != 1)
         && (length (size (lambda)) != length (sz) || any (size (lambda) != sz)))
-      error ("exprnd: lambda must be scalar or of size [r, c]");
+      error ("exprnd: LAMBDA must be scalar or of size [R, C]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("exprnd: r must be a positive integer or vector");
+      error ("exprnd: R must be a positive integer or vector");
     endif
 
     if (any (size (lambda) != 1)
         && ((length (size (lambda)) != length (sz)) || any (size (lambda) != sz)))
-      error ("exprnd: lambda must be scalar or of size sz");
+      error ("exprnd: LAMBDA must be scalar or of size SZ");
     endif
   elseif (nargin == 1)
     sz = size (lambda);
   else
     print_usage ();
   endif
 
 
diff --git a/scripts/statistics/distributions/fcdf.m b/scripts/statistics/distributions/fcdf.m
--- a/scripts/statistics/distributions/fcdf.m
+++ b/scripts/statistics/distributions/fcdf.m
@@ -30,17 +30,17 @@ function cdf = fcdf (x, m, n)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar (m) || !isscalar (n))
     [retval, x, m, n] = common_size (x, m, n);
     if (retval > 0)
-      error ("fcdf: x, m and n must be of common size or scalar");
+      error ("fcdf: X, M and N must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   cdf = zeros (sz);
 
   k = find (!(m > 0) | !(n > 0) | isnan (x));
   if (any (k))
diff --git a/scripts/statistics/distributions/finv.m b/scripts/statistics/distributions/finv.m
--- a/scripts/statistics/distributions/finv.m
+++ b/scripts/statistics/distributions/finv.m
@@ -30,17 +30,17 @@ function inv = finv (x, m, n)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar (m) || !isscalar (n))
     [retval, x, m, n] = common_size (x, m, n);
     if (retval > 0)
-      error ("finv: x, m and n must be of common size or scalar");
+      error ("finv: X, M and N must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   inv = zeros (sz);
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(m > 0) | !(n > 0));
   if (any (k))
diff --git a/scripts/statistics/distributions/fpdf.m b/scripts/statistics/distributions/fpdf.m
--- a/scripts/statistics/distributions/fpdf.m
+++ b/scripts/statistics/distributions/fpdf.m
@@ -30,17 +30,17 @@ function pdf = fpdf (x, m, n)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar (m) || !isscalar (n))
     [retval, x, m, n] = common_size (x, m, n);
     if (retval > 0)
-      error ("fpdf: x, m and n must be of common size or scalar");
+      error ("fpdf: X, M and N must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   pdf = zeros (sz);
 
   k = find (isnan (x) | !(m > 0) | !(n > 0));
   if (any (k))
diff --git a/scripts/statistics/distributions/frnd.m b/scripts/statistics/distributions/frnd.m
--- a/scripts/statistics/distributions/frnd.m
+++ b/scripts/statistics/distributions/frnd.m
@@ -33,47 +33,47 @@
 ## Description: Random deviates from the F distribution
 
 function rnd = frnd (m, n, r, c)
 
   if (nargin > 1)
     if (!isscalar(m) || !isscalar(n)) 
       [retval, m, n] = common_size (m, n);
       if (retval > 0)
-        error ("frnd: m and n must be of common size or scalar");
+        error ("frnd: M and N must be of common size or scalar");
       endif
     endif
   endif
 
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("frnd: r must be a positive integer");
+      error ("frnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("frnd: c must be a positive integer");
+      error ("frnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (m) != 1)
         && ((length (size (m)) != length (sz)) || any (size (m) != sz)))
-      error ("frnd: m and n must be scalar or of size [r,c]");
+      error ("frnd: M and N must be scalar or of size [R,C]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("frnd: r must be a positive integer or vector");
+      error ("frnd: R must be a positive integer or vector");
     endif
 
     if (any (size (m) != 1)
         && ((length (size (m)) != length (sz)) || any (size (m) != sz)))
-      error ("frnd: m and n must be scalar or of size sz");
+      error ("frnd: M and N must be scalar or of size SZ");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
     print_usage ();
   endif
 
 
diff --git a/scripts/statistics/distributions/gamcdf.m b/scripts/statistics/distributions/gamcdf.m
--- a/scripts/statistics/distributions/gamcdf.m
+++ b/scripts/statistics/distributions/gamcdf.m
@@ -31,17 +31,17 @@ function cdf = gamcdf (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
-      error ("gamcdf: x, a and b must be of common size or scalars");
+      error ("gamcdf: X, A and B must be of common size or scalars");
     endif
   endif
 
   sz = size (x);
   cdf = zeros (sz);
 
   k = find (!(a > 0) | !(b > 0) | isnan (x));
   if (any (k))
diff --git a/scripts/statistics/distributions/gaminv.m b/scripts/statistics/distributions/gaminv.m
--- a/scripts/statistics/distributions/gaminv.m
+++ b/scripts/statistics/distributions/gaminv.m
@@ -31,17 +31,17 @@ function inv = gaminv (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
-      error ("gaminv: x, a and b must be of common size or scalars");
+      error ("gaminv: X, A and B must be of common size or scalars");
     endif
   endif
 
   sz = size (x);
   inv = zeros (sz);
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(a > 0) | !(b > 0));
   if (any (k))
diff --git a/scripts/statistics/distributions/gampdf.m b/scripts/statistics/distributions/gampdf.m
--- a/scripts/statistics/distributions/gampdf.m
+++ b/scripts/statistics/distributions/gampdf.m
@@ -31,17 +31,17 @@ function pdf = gampdf (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
-      error ("gampdf: x, a and b must be of common size or scalars");
+      error ("gampdf: X, A and B must be of common size or scalars");
     endif
   endif
 
   sz = size(x);
   pdf = zeros (sz);
 
   k = find (!(a > 0) | !(b > 0) | isnan (x));
   if (any (k))
diff --git a/scripts/statistics/distributions/gamrnd.m b/scripts/statistics/distributions/gamrnd.m
--- a/scripts/statistics/distributions/gamrnd.m
+++ b/scripts/statistics/distributions/gamrnd.m
@@ -33,46 +33,46 @@
 ## Description: Random deviates from the Gamma distribution
 
 function rnd = gamrnd (a, b, r, c)
 
   if (nargin > 1)
     if (!isscalar(a) || !isscalar(b)) 
       [retval, a, b] = common_size (a, b);
       if (retval > 0)
-        error ("gamrnd: a and b must be of common size or scalar");
+        error ("gamrnd: A and B must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("gamrnd: r must be a positive integer");
+      error ("gamrnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("gamrnd: c must be a positive integer");
+      error ("gamrnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (a) != 1)
         && (length (size (a)) != length (sz) || any (size (a) != sz)))
-      error ("gamrnd: a and b must be scalar or of size [r, c]");
+      error ("gamrnd: A and B must be scalar or of size [R, C]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("gamrnd: r must be a positive integer or vector");
+      error ("gamrnd: R must be a positive integer or vector");
     endif
 
     if (any (size (a) != 1)
         && (length (size (a)) != length (sz) || any (size (a) != sz)))
-      error ("gamrnd: a and b must be scalar or of size sz");
+      error ("gamrnd: A and B must be scalar or of size SZ");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
     print_usage ();
   endif
 
   rnd = zeros (sz);
diff --git a/scripts/statistics/distributions/geocdf.m b/scripts/statistics/distributions/geocdf.m
--- a/scripts/statistics/distributions/geocdf.m
+++ b/scripts/statistics/distributions/geocdf.m
@@ -29,17 +29,17 @@ function cdf = geocdf (x, p)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (x) && !isscalar (p))
     [retval, x, p] = common_size (x, p);
     if (retval > 0)
-      error ("geocdf: x and p must be of common size or scalar");
+      error ("geocdf: X and P must be of common size or scalar");
     endif
   endif
 
   cdf = zeros (size (x));
 
   k = find (isnan (x) | !(p >= 0) | !(p <= 1));
   if (any (k))
     cdf(k) = NaN;
diff --git a/scripts/statistics/distributions/geoinv.m b/scripts/statistics/distributions/geoinv.m
--- a/scripts/statistics/distributions/geoinv.m
+++ b/scripts/statistics/distributions/geoinv.m
@@ -29,17 +29,17 @@ function inv = geoinv (x, p)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (x) && !isscalar (p))
     [retval, x, p] = common_size (x, p);
     if (retval > 0)
-      error ("geoinv: x and p must be of common size or scalar");
+      error ("geoinv: X and P must be of common size or scalar");
     endif
   endif
 
   inv = zeros (size (x));
 
   k = find (!(x >= 0) | !(x <= 1) | !(p >= 0) | !(p <= 1));
   if (any (k))
     inv(k) = NaN;
diff --git a/scripts/statistics/distributions/geopdf.m b/scripts/statistics/distributions/geopdf.m
--- a/scripts/statistics/distributions/geopdf.m
+++ b/scripts/statistics/distributions/geopdf.m
@@ -29,17 +29,17 @@ function pdf = geopdf (x, p)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (x) && !isscalar (p))
     [retval, x, p] = common_size (x, p);
     if (retval > 0)
-      error ("geopdf: x and p must be of common size or scalar");
+      error ("geopdf: X and P must be of common size or scalar");
     endif
   endif
 
   pdf = zeros (size (x));
 
   k = find (isnan (x) | !(p >= 0) | !(p <= 1));
   if (any (k))
     pdf(k) = NaN;
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -30,39 +30,39 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the geometric distribution
 
 function rnd = geornd (p, r, c)
 
   if (nargin == 3)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("geornd: r must be a positive integer");
+      error ("geornd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("geornd: c must be a positive integer");
+      error ("geornd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (p) != 1)
         && ((length (size (p)) != length (sz)) || any (size (p) != sz)))
-      error ("geornd: p must be scalar or of size [r, c]");
+      error ("geornd: P must be scalar or of size [R, C]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("geornd: r must be a positive integer or vector");
+      error ("geornd: R must be a positive integer or vector");
     endif
 
     if (any (size (p) != 1)
         && ((length (size (p)) != length (sz)) || any (size (p) != sz)))
-      error ("geornd: n must be scalar or of size sz");
+      error ("geornd: n must be scalar or of size SZ");
     endif
   elseif (nargin == 1)
     sz = size(n);
   elseif (nargin != 1)
     print_usage ();
   endif
 
 
diff --git a/scripts/statistics/distributions/hygecdf.m b/scripts/statistics/distributions/hygecdf.m
--- a/scripts/statistics/distributions/hygecdf.m
+++ b/scripts/statistics/distributions/hygecdf.m
@@ -34,17 +34,17 @@
 
 function cdf = hygecdf (x, t, m, n)
 
   if (nargin != 4)
     print_usage ();
   endif
 
   if (!isscalar (t) || !isscalar (m) || !isscalar (n))
-    error ("hygecdf: t, m and n must all be positive integers");
+    error ("hygecdf: T, M and N must all be positive integers");
   endif
 
   if (t < 0 || m < 0 || n <= 0 || t != round (t) || m != round (m)
       || n != round (n) || m > t || n > t)
     cdf = NaN (size (x))
   else
     cdf = discrete_cdf (x, 0 : n, hygepdf (0 : n, t, m, n));
   endif
diff --git a/scripts/statistics/distributions/hygeinv.m b/scripts/statistics/distributions/hygeinv.m
--- a/scripts/statistics/distributions/hygeinv.m
+++ b/scripts/statistics/distributions/hygeinv.m
@@ -31,17 +31,17 @@
 
 function inv = hygeinv (x, t, m, n)
 
   if (nargin != 4)
     print_usage ();
   endif
 
   if (!isscalar (t) || !isscalar (m) || !isscalar (n))
-    error ("hygeinv: t, m and n must all be positive integers");
+    error ("hygeinv: T, M and N must all be positive integers");
   endif
 
   if (t < 0 || m < 0 || n <= 0 || t != round (t) || m != round (m)
       || n != round (n) || m > t || n > t)
     inv = NaN (size (x))
   else
     inv = discrete_inv (x, 0 : n, hygepdf (0 : n, t, m, n));
   endif
diff --git a/scripts/statistics/distributions/hygepdf.m b/scripts/statistics/distributions/hygepdf.m
--- a/scripts/statistics/distributions/hygepdf.m
+++ b/scripts/statistics/distributions/hygepdf.m
@@ -34,17 +34,17 @@ function pdf = hygepdf (x, t, m, n)
 
   if (nargin != 4)
     print_usage ();
   endif
 
   if (!isscalar (t) || !isscalar (m) || !isscalar (n))
     [retval, x, t, m, n] = common_size (x, t, m, n);
     if (retval > 0)
-      error ("hygepdf: x, t, m, and n must be of common size or scalar");
+      error ("hygepdf: X, T, M, and N must be of common size or scalar");
     endif
   endif
 
   pdf = zeros (size (x));
 
   ## everything in i1 gives NaN
   i1 = ((t < 0) | (m < 0) | (n <= 0) | (t != round (t)) |
         (m != round (m)) | (n != round (n)) | (m > t) | (n > t));
diff --git a/scripts/statistics/distributions/hygernd.m b/scripts/statistics/distributions/hygernd.m
--- a/scripts/statistics/distributions/hygernd.m
+++ b/scripts/statistics/distributions/hygernd.m
@@ -31,44 +31,44 @@
 ## dimensions.  If @var{sz} is scalar, then a @var{sz} by @var{sz}
 ## matrix of random samples is generated.
 ## @end deftypefn
 
 function rnd = hygernd (t, m, n, r, c)
 
   if (nargin == 5)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("hygernd: r must be a positive integer");
+      error ("hygernd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("hygernd: c must be a positive integer");
+      error ("hygernd: C must be a positive integer");
     endif
     sz = [r, c];
   elseif (nargin == 4)
     if (isvector (r) && all (r > 0) && all (r == round (r)))
       if (isscalar (r))
         sz = [r, r];
       else
         sz = r(:)';
       endif
     else
-      error ("hygernd: r must be a vector of positive integers");
+      error ("hygernd: R must be a vector of positive integers");
     endif
   elseif (nargin != 3)
     print_usage ();
   endif
 
   if (! isscalar (t) || ! isscalar (m) || ! isscalar (n))
     [retval, t, m, n] = common_size (t, m, n);
     if (retval > 0)
-      error ("hygernd: t, m and n must be of common size or scalar");
+      error ("hygernd: T, M and N must be of common size or scalar");
     endif
     if (nargin > 3)
       if (any (sz != size (t)))
-        error ("hygernd: t, m and n must have the same size as implied by r and c or must be scalar");
+        error ("hygernd: T, M and N must have the same size as implied by R and C or must be scalar");
       endif
     else
       sz = size (t);
     endif
   elseif (nargin == 3)
     sz = 1;
   endif
 
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -53,17 +53,17 @@ function cdf = kolmogorov_smirnov_cdf (x
   if (nargin == 1)
     if (isa (x, "single"))
       tol = eps ("single");
     else
       tol = eps;
     endif
   else
     if (! (isscalar (tol) && (tol > 0)))
-      error ("kolmogorov_smirnov_cdf: tol must be a positive scalar");
+      error ("kolmogorov_smirnov_cdf: TOL must be a positive scalar");
     endif
   endif
 
   n = numel (x);
   if (n == 0)
     error ("kolmogorov_smirnov_cdf: X must not be empty");
   endif
 
diff --git a/scripts/statistics/distributions/laplace_rnd.m b/scripts/statistics/distributions/laplace_rnd.m
--- a/scripts/statistics/distributions/laplace_rnd.m
+++ b/scripts/statistics/distributions/laplace_rnd.m
@@ -27,29 +27,29 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Laplace distribution
 
 function rnd = laplace_rnd (r, c)
 
   if (nargin == 2)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("laplace_rnd: r must be a positive integer");
+      error ("laplace_rnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("laplace_rnd: c must be a positive integer");
+      error ("laplace_rnd: C must be a positive integer");
     endif
     sz = [r, c];
   elseif (nargin == 1)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("laplace_rnd: r must be a positive integer or vector");
+      error ("laplace_rnd: R must be a positive integer or vector");
     endif
   else
     print_usage ();
   endif
 
   tmp = rand (sz);
   rnd = ((tmp < 1/2) .* log (2 * tmp)
          - (tmp > 1/2) .* log (2 * (1 - tmp)));
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ b/scripts/statistics/distributions/logistic_rnd.m
@@ -28,29 +28,29 @@
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the logistic distribution
 
 function rnd = logistic_rnd (r, c)
 
 
   if (nargin == 2)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("logistic_rnd: r must be a positive integer");
+      error ("logistic_rnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("logistic_rnd: c must be a positive integer");
+      error ("logistic_rnd: C must be a positive integer");
     endif
     sz = [r, c];
   elseif (nargin == 1)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("logistic_rnd: r must be a positive integer or vector");
+      error ("logistic_rnd: R must be a positive integer or vector");
     endif
   else
     print_usage ();
   endif
 
   rnd = - log (1 ./ rand (sz) - 1);
 
 endfunction
diff --git a/scripts/statistics/distributions/logncdf.m b/scripts/statistics/distributions/logncdf.m
--- a/scripts/statistics/distributions/logncdf.m
+++ b/scripts/statistics/distributions/logncdf.m
@@ -44,17 +44,17 @@ function cdf = logncdf (x, mu, sigma)
   ## The following "straightforward" implementation unfortunately does
   ## not work (because exp (Inf) -> NaN etc):
   ## cdf = normal_cdf (log (x), log (mu), sigma);
   ## Hence ...
 
   if (!isscalar (mu) || !isscalar (sigma))
     [retval, x, mu, sigma] = common_size (x, mu, sigma);
     if (retval > 0)
-      error ("logncdf: x, mu and sigma must be of common size or scalars");
+      error ("logncdf: X, MU and SIGMA must be of common size or scalars");
     endif
   endif
 
   cdf = zeros (size (x));
 
   k = find (isnan (x) | !(sigma > 0) | !(sigma < Inf));
   if (any (k))
     cdf(k) = NaN;
diff --git a/scripts/statistics/distributions/logninv.m b/scripts/statistics/distributions/logninv.m
--- a/scripts/statistics/distributions/logninv.m
+++ b/scripts/statistics/distributions/logninv.m
@@ -44,17 +44,17 @@ function inv = logninv (x, mu, sigma)
   ## The following "straightforward" implementation unfortunately does
   ## not work (because exp (Inf) -> NaN):
   ## inv = exp (norminv (x, mu, sigma));
   ## Hence ...
 
   if (!isscalar (mu) || !isscalar (sigma))
     [retval, x, mu, sigma] = common_size (x, mu, sigma);
     if (retval > 0)
-      error ("logninv: x, mu and sigma must be of common size or scalars");
+      error ("logninv: X, MU and SIGMA must be of common size or scalars");
     endif
   endif
 
   inv = zeros (size (x));
 
   k = find (!(x >= 0) | !(x <= 1) | !(sigma > 0) | !(sigma < Inf));
   if (any (k))
     inv(k) = NaN;
diff --git a/scripts/statistics/distributions/lognpdf.m b/scripts/statistics/distributions/lognpdf.m
--- a/scripts/statistics/distributions/lognpdf.m
+++ b/scripts/statistics/distributions/lognpdf.m
@@ -44,17 +44,17 @@ function pdf = lognpdf (x, mu, sigma)
   ## The following "straightforward" implementation unfortunately does
   ## not work for the special cases (Inf, ...)
   ## pdf = (x > 0) ./ x .* normpdf (log (x), mu, sigma);
   ## Hence ...
 
   if (!isscalar (mu) || !isscalar (sigma))
     [retval, x, mu, sigma] = common_size (x, mu, sigma);
     if (retval > 0)
-      error ("lognpdf: x, mu and sigma must be of common size or scalars");
+      error ("lognpdf: X, MU and SIGMA must be of common size or scalars");
     endif
   endif
 
   pdf = zeros (size (x));
 
   k = find (isnan (x) | !(sigma > 0) | !(sigma < Inf));
   if (any (k))
     pdf(k) = NaN;
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
--- a/scripts/statistics/distributions/lognrnd.m
+++ b/scripts/statistics/distributions/lognrnd.m
@@ -32,47 +32,47 @@
 ## Description: Random deviates from the log normal distribution
 
 function rnd = lognrnd (mu, sigma, r, c)
 
   if (nargin > 1)
     if (!isscalar(mu) || !isscalar(sigma)) 
       [retval, mu, sigma] = common_size (mu, sigma);
       if (retval > 0)
-        error ("lognrnd: mu and sigma must be of common size or scalar");
+        error ("lognrnd: MU and SIGMA must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("lognrnd: r must be a positive integer");
+      error ("lognrnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("lognrnd: c must be a positive integer");
+      error ("lognrnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (mu) != 1)
         && ((length (size (mu)) != length (sz)) || any (size (mu) != sz)))
-      error ("lognrnd: mu and sigma must be scalar or of size [r, c]");
+      error ("lognrnd: MU and SIGMA must be scalar or of size [R, C]");
     endif
 
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("lognrnd: r must be a positive integer or vector");
+      error ("lognrnd: R must be a positive integer or vector");
     endif
 
     if (any (size (mu) != 1)
         && ((length (size (mu)) != length (sz)) || any (size (mu) != sz)))
-      error ("lognrnd: mu and sigma must be scalar or of size sz");
+      error ("lognrnd: MU and SIGMA must be scalar or of size SZ");
     endif
   elseif (nargin == 2)
     sz = size(mu);
   else
     print_usage ();
   endif
 
   if (isscalar (mu) && isscalar (sigma))
diff --git a/scripts/statistics/distributions/nbincdf.m b/scripts/statistics/distributions/nbincdf.m
--- a/scripts/statistics/distributions/nbincdf.m
+++ b/scripts/statistics/distributions/nbincdf.m
@@ -33,17 +33,17 @@ function cdf = nbincdf (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar(n) || !isscalar(p)) 
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
-      error ("nbincdf: x, n and p must be of common size or scalar");
+      error ("nbincdf: X, N and P must be of common size or scalar");
     endif
   endif
   
   cdf = zeros (size (x));
 
   k = find (isnan (x) | (n < 1) | (n == Inf) | (n != round (n))
             | (p < 0) | (p > 1));
   if (any (k))
diff --git a/scripts/statistics/distributions/nbininv.m b/scripts/statistics/distributions/nbininv.m
--- a/scripts/statistics/distributions/nbininv.m
+++ b/scripts/statistics/distributions/nbininv.m
@@ -34,17 +34,17 @@ function inv = nbininv (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar(n) || !isscalar(p)) 
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
-      error ("nbininv: x, n and p must be of common size or scalar");
+      error ("nbininv: X, N and P must be of common size or scalar");
     endif
   endif
 
   inv = zeros (size (x));
 
   k = find (isnan (x) | (x < 0) | (x > 1) | (n < 1) | (n == Inf)
             | (n != round (n)) | (p < 0) | (p > 1));
   if (any (k))
diff --git a/scripts/statistics/distributions/nbinpdf.m b/scripts/statistics/distributions/nbinpdf.m
--- a/scripts/statistics/distributions/nbinpdf.m
+++ b/scripts/statistics/distributions/nbinpdf.m
@@ -34,17 +34,17 @@ function pdf = nbinpdf (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (!isscalar(n) || !isscalar(p)) 
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
-      error ("nbinpdf: x, n and p must be of common size or scalar");
+      error ("nbinpdf: X, N and P must be of common size or scalar");
     endif
   endif
 
   pdf = zeros (size (x));
 
   k = find (isnan (x) | (n < 1) | (n == Inf) | (n != round (n))
             | (p < 0) | (p > 1));
   if (any (k))
diff --git a/scripts/statistics/distributions/nbinrnd.m b/scripts/statistics/distributions/nbinrnd.m
--- a/scripts/statistics/distributions/nbinrnd.m
+++ b/scripts/statistics/distributions/nbinrnd.m
@@ -32,47 +32,47 @@
 ## Description: Random deviates from the Pascal distribution
 
 function rnd = nbinrnd (n, p, r, c)
 
   if (nargin > 1)
     if (!isscalar(n) || !isscalar(p)) 
       [retval, n, p] = common_size (n, p);
       if (retval > 0)
-        error ("nbinrnd: n and p must be of common size or scalar");
+        error ("nbinrnd: N and P must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("nbinrnd: r must be a positive integer");
+      error ("nbinrnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("nbinrnd: c must be a positive integer");
+      error ("nbinrnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (n) != 1)
         && ((length (size (n)) != length (sz)) || any (size (n) != sz)))
-      error ("nbinrnd: n and p must be scalar or of size [r, c]");
+      error ("nbinrnd: N and P must be scalar or of size [R, C]");
     endif
 
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("nbinrnd: r must be a positive integer or vector");
+      error ("nbinrnd: R must be a positive integer or vector");
     endif
 
     if (any (size (n) != 1)
         && ((length (size (n)) != length (sz)) || any (size (n) != sz)))
-      error ("nbinrnd: n and p must be scalar or of size sz");
+      error ("nbinrnd: N and P must be scalar or of size SZ");
     endif
   elseif (nargin == 2)
     sz = size(n);
   else
     print_usage ();
   endif
 
   if (isscalar (n) && isscalar (p))
diff --git a/scripts/statistics/distributions/normcdf.m b/scripts/statistics/distributions/normcdf.m
--- a/scripts/statistics/distributions/normcdf.m
+++ b/scripts/statistics/distributions/normcdf.m
@@ -37,17 +37,17 @@ function cdf = normcdf (x, m, s)
   if (nargin == 1)
     m = 0;
     s = 1;
   endif
 
   if (!isscalar (m) || !isscalar (s))
     [retval, x, m, s] = common_size (x, m, s);
     if (retval > 0)
-      error ("normcdf: x, m and s must be of common size or scalar");
+      error ("normcdf: X, M and S must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   cdf = zeros (sz);
 
   if (isscalar (m) && isscalar(s))
     if (find (isinf (m) | isnan (m) | !(s >= 0) | !(s < Inf)))
diff --git a/scripts/statistics/distributions/norminv.m b/scripts/statistics/distributions/norminv.m
--- a/scripts/statistics/distributions/norminv.m
+++ b/scripts/statistics/distributions/norminv.m
@@ -37,17 +37,17 @@ function inv = norminv (x, m, s)
   if (nargin == 1)
     m = 0;
     s = 1;
   endif
 
   if (!isscalar (m) || !isscalar (s))
     [retval, x, m, s] = common_size (x, m, s);
     if (retval > 0)
-      error ("norminv: x, m and s must be of common size or scalars");
+      error ("norminv: X, M and S must be of common size or scalars");
     endif
   endif
 
   sz = size (x);
   inv = zeros (sz);
 
   if (isscalar (m) && isscalar (s))
     if (find (isinf (m) | isnan (m) | !(s > 0) | !(s < Inf)))
diff --git a/scripts/statistics/distributions/normpdf.m b/scripts/statistics/distributions/normpdf.m
--- a/scripts/statistics/distributions/normpdf.m
+++ b/scripts/statistics/distributions/normpdf.m
@@ -37,17 +37,17 @@ function pdf = normpdf (x, m, s)
   if (nargin == 1)
     m = 0;
     s = 1;
   endif
 
   if (!isscalar (m) || !isscalar (s))
     [retval, x, m, s] = common_size (x, m, s);
     if (retval > 0)
-      error ("normpdf: x, m and s must be of common size or scalars");
+      error ("normpdf: X, M and S must be of common size or scalars");
     endif
   endif
 
   sz = size (x);
   pdf = zeros (sz);
 
   if (isscalar (m) && isscalar (s))
     if (find (isinf (m) | isnan (m) | !(s >= 0) | !(s < Inf)))
diff --git a/scripts/statistics/distributions/normrnd.m b/scripts/statistics/distributions/normrnd.m
--- a/scripts/statistics/distributions/normrnd.m
+++ b/scripts/statistics/distributions/normrnd.m
@@ -32,46 +32,46 @@
 ## Description: Random deviates from the normal distribution
 
 function rnd = normrnd (m, s, r, c)
 
   if (nargin > 1)
     if (!isscalar (m) || !isscalar (s)) 
       [retval, m, s] = common_size (m, s);
       if (retval > 0)
-        error ("normrnd: m and s must be of common size or scalar");
+        error ("normrnd: M and S must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("normrnd: r must be a positive integer");
+      error ("normrnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("normrnd: c must be a positive integer");
+      error ("normrnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (m) != 1)
         && (length (size (m)) != length (sz) || any (size (m) != sz)))
-      error ("normrnd: m and s must be scalar or of size [r, c]");
+      error ("normrnd: M and S must be scalar or of size [R, C]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("normrnd: r must be a positive integer or vector");
+      error ("normrnd: R must be a positive integer or vector");
     endif
 
     if (any (size (m) != 1)
         && (length (size (m)) != length (sz) || any (size (m) != sz)))
-      error ("normrnd: m and s must be scalar or of size sz");
+      error ("normrnd: M and S must be scalar or of size SZ");
     endif
   elseif (nargin == 2)
     sz = size(m);
   else
     print_usage ();
   endif
 
   if (isscalar (m) && isscalar (s))
diff --git a/scripts/statistics/distributions/poisscdf.m b/scripts/statistics/distributions/poisscdf.m
--- a/scripts/statistics/distributions/poisscdf.m
+++ b/scripts/statistics/distributions/poisscdf.m
@@ -30,17 +30,17 @@ function cdf = poisscdf (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (lambda))
     [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
-      error ("poisscdf: x and lambda must be of common size or scalar");
+      error ("poisscdf: X and LAMBDA must be of common size or scalar");
     endif
   endif
 
   cdf = zeros (size (x));
 
   k = find (isnan (x) | !(lambda > 0));
   if (any (k))
     cdf(k) = NaN;
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
--- a/scripts/statistics/distributions/poissinv.m
+++ b/scripts/statistics/distributions/poissinv.m
@@ -30,17 +30,17 @@ function inv = poissinv (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (lambda))
     [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
-      error ("poissinv: x and lambda must be of common size or scalar");
+      error ("poissinv: X and LAMBDA must be of common size or scalar");
     endif
   endif
 
   inv = zeros (size (x));
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(lambda > 0));
   if (any (k))
     inv(k) = NaN;
diff --git a/scripts/statistics/distributions/poisspdf.m b/scripts/statistics/distributions/poisspdf.m
--- a/scripts/statistics/distributions/poisspdf.m
+++ b/scripts/statistics/distributions/poisspdf.m
@@ -29,17 +29,17 @@ function pdf = poisspdf (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (lambda))
     [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
-      error ("poisspdf: x and lambda must be of common size or scalar");
+      error ("poisspdf: X and LAMBDA must be of common size or scalar");
     endif
   endif
 
   pdf = zeros (size (x));
 
   k = find (!(lambda > 0) | isnan (x));
   if (any (k))
     pdf(k) = NaN;
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
--- a/scripts/statistics/distributions/poissrnd.m
+++ b/scripts/statistics/distributions/poissrnd.m
@@ -28,39 +28,39 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Poisson distribution
 
 function rnd = poissrnd (lambda, r, c)
 
   if (nargin == 3)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("poissrnd: r must be a positive integer");
+      error ("poissrnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("poissrnd: c must be a positive integer");
+      error ("poissrnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (lambda) != 1)
         && ((length (size (lambda)) != length (sz)) || any (size (lambda) != sz)))
-      error ("poissrnd: lambda must be scalar or of size [r, c]");
+      error ("poissrnd: LAMBDA must be scalar or of size [R, C]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("poissrnd: r must be a positive integer or vector");
+      error ("poissrnd: R must be a positive integer or vector");
     endif
 
     if (any (size (lambda) != 1)
         && ((length (size (lambda)) != length (sz)) || any (size (lambda) != sz)))
-      error ("poissrnd: lambda must be scalar or of size sz");
+      error ("poissrnd: LAMBDA must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size (lambda);
   else
     print_usage ();
   endif
 
   if (isscalar (lambda))
diff --git a/scripts/statistics/distributions/stdnormal_cdf.m b/scripts/statistics/distributions/stdnormal_cdf.m
--- a/scripts/statistics/distributions/stdnormal_cdf.m
+++ b/scripts/statistics/distributions/stdnormal_cdf.m
@@ -29,17 +29,17 @@
 function cdf = stdnormal_cdf (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   sz = size (x);
   if (numel(x) == 0)
-    error ("stdnormal_cdf: x must not be empty");
+    error ("stdnormal_cdf: X must not be empty");
   endif
 
   cdf = erfc (x / (-sqrt(2))) / 2;
 
 endfunction
 
 
 
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ b/scripts/statistics/distributions/stdnormal_rnd.m
@@ -30,27 +30,27 @@
 function rnd = stdnormal_rnd (r, c)
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   if (nargin == 2)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("stdnormal_rnd: r must be a positive integer");
+      error ("stdnormal_rnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("stdnormal_rnd: c must be a positive integer");
+      error ("stdnormal_rnd: C must be a positive integer");
     endif
     sz = [r, c];
   else
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("stdnormal_rnd: r must be a positive integer or vector");
+      error ("stdnormal_rnd: R must be a positive integer or vector");
     endif
   endif
 
   rnd = randn (sz);
 
 endfunction
diff --git a/scripts/statistics/distributions/tcdf.m b/scripts/statistics/distributions/tcdf.m
--- a/scripts/statistics/distributions/tcdf.m
+++ b/scripts/statistics/distributions/tcdf.m
@@ -30,17 +30,17 @@ function cdf = tcdf (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
-      error ("tcdf: x and n must be of common size or scalar");
+      error ("tcdf: X and N must be of common size or scalar");
     endif
   endif
 
   cdf = zeros (size (x));
 
   k = find (isnan (x) | !(n > 0));
   if (any (k))
     cdf(k) = NaN;
diff --git a/scripts/statistics/distributions/tinv.m b/scripts/statistics/distributions/tinv.m
--- a/scripts/statistics/distributions/tinv.m
+++ b/scripts/statistics/distributions/tinv.m
@@ -36,17 +36,17 @@ function inv = tinv (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
-      error ("tinv: x and n must be of common size or scalar");
+      error ("tinv: X and N must be of common size or scalar");
     endif
   endif
 
   inv = zeros (size (x));
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(n > 0));
   if (any (k))
     inv(k) = NaN;
diff --git a/scripts/statistics/distributions/tpdf.m b/scripts/statistics/distributions/tpdf.m
--- a/scripts/statistics/distributions/tpdf.m
+++ b/scripts/statistics/distributions/tpdf.m
@@ -30,17 +30,17 @@ function pdf = tpdf (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
-      error ("tpdf: x and n must be of common size or scalar");
+      error ("tpdf: X and N must be of common size or scalar");
     endif
   endif
 
   pdf = zeros (size (x));
 
   k = find (isnan (x) | !(n > 0) | !(n < Inf));
   if (any (k))
     pdf(k) = NaN;
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
--- a/scripts/statistics/distributions/trnd.m
+++ b/scripts/statistics/distributions/trnd.m
@@ -30,39 +30,39 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the t distribution
 
 function rnd = trnd (n, r, c)
 
   if (nargin == 3)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("trnd: r must be a positive integer");
+      error ("trnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("trnd: c must be a positive integer");
+      error ("trnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (n) != 1)
         && ((length (size (n)) != length (sz)) || any (size (n) != sz)))
-      error ("trnd: n must be scalar or of size sz");
+      error ("trnd: N must be scalar or of size SZ");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("trnd: r must be a positive integer or vector");
+      error ("trnd: R must be a positive integer or vector");
     endif
 
     if (any (size (n) != 1)
         && ((length (size (n)) != length (sz)) || any (size (n) != sz)))
-      error ("trnd: n must be scalar or of size sz");
+      error ("trnd: N must be scalar or of size SZ");
     endif
   elseif (nargin == 1)
     sz = size (n);
   else
     print_usage ();
   endif
 
   if (isscalar (n))
diff --git a/scripts/statistics/distributions/unidrnd.m b/scripts/statistics/distributions/unidrnd.m
--- a/scripts/statistics/distributions/unidrnd.m
+++ b/scripts/statistics/distributions/unidrnd.m
@@ -44,17 +44,17 @@ function retval = unidrnd (n, varargin)
   elseif (nargin > 2)
     for i = 1:nargin-1
       if (! isscalar (varargin{i}))
         error ("unidrnd: expecting scalar dimensions");
       endif
     endfor
     dims = [varargin{:}];
   else
-    error ("unidrnd: Usage unirnd (n, ...)");
+    print_usage ();
   endif
   if (isscalar (n)
       || (length (size (n)) == length (dims) && all (size (n) == dims)))
     retval = ceil (rand (dims) .* n);
   else
     error ("unidrnd: dimension mismatch");
   endif
 endfunction
diff --git a/scripts/statistics/distributions/unifcdf.m b/scripts/statistics/distributions/unifcdf.m
--- a/scripts/statistics/distributions/unifcdf.m
+++ b/scripts/statistics/distributions/unifcdf.m
@@ -36,17 +36,17 @@ function cdf = unifcdf (x, a, b)
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
-      error ("unifcdf: x, a and b must be of common size or scalar");
+      error ("unifcdf: X, A and B must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   cdf = zeros (sz);
 
   k = find (isnan (x) | !(a < b));
   if (any (k))
diff --git a/scripts/statistics/distributions/unifinv.m b/scripts/statistics/distributions/unifinv.m
--- a/scripts/statistics/distributions/unifinv.m
+++ b/scripts/statistics/distributions/unifinv.m
@@ -36,17 +36,17 @@ function inv = unifinv (x, a, b)
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
-      error ("unifinv: x, a and b must be of common size or scalar");
+      error ("unifinv: X, A and B must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   inv = zeros (sz);
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(a < b));
   if (any (k))
diff --git a/scripts/statistics/distributions/unifpdf.m b/scripts/statistics/distributions/unifpdf.m
--- a/scripts/statistics/distributions/unifpdf.m
+++ b/scripts/statistics/distributions/unifpdf.m
@@ -36,17 +36,17 @@ function pdf = unifpdf (x, a, b)
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
-      error ("unifpdf: x, a and b must be of common size or scalars");
+      error ("unifpdf: X, A and B must be of common size or scalars");
     endif
   endif
 
   sz = size (x);
   pdf = zeros (sz);
 
   k = find (isnan (x) | !(a < b));
   if (any (k))
diff --git a/scripts/statistics/distributions/unifrnd.m b/scripts/statistics/distributions/unifrnd.m
--- a/scripts/statistics/distributions/unifrnd.m
+++ b/scripts/statistics/distributions/unifrnd.m
@@ -31,46 +31,46 @@
 ## Description: Random deviates from the uniform distribution
 
 function rnd = unifrnd (a, b, r, c)
 
   if (nargin > 1)
     if (!isscalar(a) || !isscalar(b)) 
       [retval, a, b] = common_size (a, b);
       if (retval > 0)
-        error ("unifrnd: a and b must be of common size or scalar");
+        error ("unifrnd: A and B must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("unifrnd: r must be a positive integer");
+      error ("unifrnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("unifrnd: c must be a positive integer");
+      error ("unifrnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (a) != 1)
         && (length (size (a)) != length (sz) || any (size (a) != sz)))
-      error ("unifrnd: a and b must be scalar or of size [r, c]");
+      error ("unifrnd: A and B must be scalar or of size [R, C]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("unifrnd: r must be a positive integer or vector");
+      error ("unifrnd: R must be a positive integer or vector");
     endif
 
     if (any (size (a) != 1)
         && (length (size (a)) != length (sz) || any (size (a) != sz)))
-      error ("unifrnd: a and b must be scalar or of size sz");
+      error ("unifrnd: A and B must be scalar or of size SZ");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
     print_usage ();
   endif
 
   if (isscalar(a) && isscalar(b))
diff --git a/scripts/statistics/distributions/wblcdf.m b/scripts/statistics/distributions/wblcdf.m
--- a/scripts/statistics/distributions/wblcdf.m
+++ b/scripts/statistics/distributions/wblcdf.m
@@ -51,17 +51,17 @@ function cdf = wblcdf (x, scale, shape)
 
   if (nargin < 2)
     scale = 1;
   endif
 
   if (!isscalar (shape) || !isscalar (scale))
     [retval, x, shape, scale] = common_size (x, shape, scale);
     if (retval > 0)
-      error ("wblcdf: x, scale and shape must be of common size or scalar");
+      error ("wblcdf: X, SCALE and SHAPE must be of common size or scalar");
     endif
   endif
 
   cdf = NaN (size (x));
 
   ok = ((shape > 0) & (shape < Inf) & (scale > 0) & (scale < Inf));
 
   k = find ((x <= 0) & ok);
diff --git a/scripts/statistics/distributions/wblinv.m b/scripts/statistics/distributions/wblinv.m
--- a/scripts/statistics/distributions/wblinv.m
+++ b/scripts/statistics/distributions/wblinv.m
@@ -38,17 +38,17 @@ function inv = wblinv (x, scale, shape)
 
   if (nargin < 2)
     scale = 1;
   endif
 
   if (!isscalar (scale) || !isscalar (shape))
     [retval, x, scale, shape] = common_size (x, scale, shape);
     if (retval > 0)
-      error ("wblinv: x, scale and shape must be of common size or scalar");
+      error ("wblinv: X, SCALE and SHAPE must be of common size or scalar");
     endif
   endif
 
   inv = NaN (size (x));
 
   ok = ((scale > 0) & (scale < Inf) & (shape > 0) & (shape < Inf));
 
   k = find ((x == 0) & ok);
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
--- a/scripts/statistics/distributions/wblpdf.m
+++ b/scripts/statistics/distributions/wblpdf.m
@@ -50,17 +50,17 @@ function pdf = wblpdf (x, scale, shape)
 
   if (nargin < 2)
     scale = 1;
   endif
 
   if (!isscalar (scale) || !isscalar (shape))
     [retval, x, scale, shape] = common_size (x, scale, shape);
     if (retval > 0)
-      error ("wblpdf: x, scale and shape must be of common size or scalar");
+      error ("wblpdf: X, SCALE and SHAPE must be of common size or scalar");
     endif
   endif
 
   pdf = NaN (size (x));
   ok = ((scale > 0) & (scale < Inf) & (shape > 0) & (shape < Inf));
 
   k = find ((x > -Inf) & (x <= 0) & ok);
   if (any (k))
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
--- a/scripts/statistics/distributions/wblrnd.m
+++ b/scripts/statistics/distributions/wblrnd.m
@@ -32,48 +32,48 @@
 ## Description: Random deviates from the Weibull distribution
 
 function rnd = wblrnd (scale, shape, r, c)
 
   if (nargin > 1)
     if (!isscalar(scale) || !isscalar(shape)) 
       [retval, scale, shape] = common_size (scale, shape);
       if (retval > 0)
-        error ("wblrnd: scale and shape must be of common size or scalar");
+        error ("wblrnd: SCALE and SHAPE must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
-      error ("wblrnd: r must be a positive integer");
+      error ("wblrnd: R must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
-      error ("wblrnd: c must be a positive integer");
+      error ("wblrnd: C must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (scale) != 1)
         && ((length (size (scale)) != length (sz))
             || any (size (scale) != sz)))
-      error ("wblrnd: scale and shape must be scalar or of size [r, c]");
+      error ("wblrnd: SCALE and SHAPE must be scalar or of size [R, C]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
-      error ("wblrnd: r must be a positive integer or vector");
+      error ("wblrnd: R must be a positive integer or vector");
     endif
 
     if (any (size (scale) != 1)
         && ((length (size (scale)) != length (sz))
             || any (size (scale) != sz)))
-      error ("wblrnd: scale and shape must be scalar or of size sz");
+      error ("wblrnd: SCALE and SHAPE must be scalar or of size SZ");
     endif
   elseif (nargin == 2)
     sz = size(scale);
   else
     print_usage ();
   endif
 
   if (isscalar (scale) && isscalar (shape))
diff --git a/scripts/statistics/distributions/wienrnd.m b/scripts/statistics/distributions/wienrnd.m
--- a/scripts/statistics/distributions/wienrnd.m
+++ b/scripts/statistics/distributions/wienrnd.m
@@ -38,17 +38,17 @@ function retval = wienrnd (t, d, n)
     n = 1000;
   elseif (nargin == 2)
     n = 1000;
   elseif (nargin > 3)
     print_usage ();
   endif
 
   if (!isscalar (t) || !isscalar (d) || !isscalar (n))
-    error ("wienrnd: t, d and n must all be positive integers");
+    error ("wienrnd: T, D and N must all be positive integers");
   endif
 
   retval = randn (n * t, d);
   retval = cumsum (retval) / sqrt (n);
 
   retval = [((1: n*t)' / n), retval];
 
 endfunction
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
--- a/scripts/statistics/models/logistic_regression.m
+++ b/scripts/statistics/models/logistic_regression.m
@@ -91,17 +91,17 @@ function [theta, beta, dev, dl, d2l, p] 
   ## check input
   y = round (vec (y));
   [my, ny] = size (y);
   if (nargin < 2)
     x = zeros (my, 0);
   endif;
   [mx, nx] = size (x);
   if (mx != my)
-    error ("logistic_regression: x and y must have the same number of observations");
+    error ("logistic_regression: X and Y must have the same number of observations");
   endif
 
   ## initial calculations
   x = -x;
   tol = 1e-6; incr = 10; decr = 2;
   ymin = min (y); ymax = max (y); yrange = ymax - ymin;
   z  = (y * ones (1, yrange)) == ((y * 0 + 1) * (ymin : (ymax - 1)));
   z1 = (y * ones (1, yrange)) == ((y * 0 + 1) * ((ymin + 1) : ymax));
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -46,28 +46,28 @@
 ## Description: One-way analysis of variance (ANOVA)
 
 function [pval, f, df_b, df_w] = anova (y, g)
 
   if ((nargin < 1) || (nargin > 2))
     print_usage ();
   elseif (nargin == 1)
     if (isvector (y))
-      error ("anova: for `anova (y)', y must not be a vector");
+      error ("anova: for `anova (Y)', Y must not be a vector");
     endif
     [group_count, k] = size (y);
     n = group_count * k;
     group_mean = mean (y);
   else
     if (! isvector (y))
-      error ("anova: for `anova (y, g)', y must be a vector");
+      error ("anova: for `anova (Y, G)', Y must be a vector");
     endif
     n = length (y);
     if (! isvector (g) || (length (g) != n))
-      error ("anova: g must be a vector of the same length as y");
+      error ("anova: G must be a vector of the same length as Y");
     endif
     s = sort (g);
     i = find (s (2 : n) > s(1 : (n-1)));
     k = length (i) + 1;
     if (k == 1)
       error ("anova: there should be at least 2 groups");
     else
       group_label = s ([1, (reshape (i, 1, k-1) + 1)]);
diff --git a/scripts/statistics/tests/chisquare_test_homogeneity.m b/scripts/statistics/tests/chisquare_test_homogeneity.m
--- a/scripts/statistics/tests/chisquare_test_homogeneity.m
+++ b/scripts/statistics/tests/chisquare_test_homogeneity.m
@@ -39,22 +39,22 @@
 
 function [pval, chisq, df] = chisquare_test_homogeneity (x, y, c)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (! (isvector(x) && isvector(y) && isvector(c)))
-    error ("chisquare_test_homogeneity: x, y and c must be vectors");
+    error ("chisquare_test_homogeneity: X, Y and C must be vectors");
   endif
   ## Now test c for strictly increasing entries
   df = length (c);
   if (any ((c(2 : df) - c(1 : (df - 1))) <= 0))
-    error ("chisquare_test_homogeneity: c must be increasing");
+    error ("chisquare_test_homogeneity: C must be increasing");
   endif
 
   c     = [(reshape (c, 1, df)), Inf];
   l_x   = length (x);
   x     = reshape (x, l_x, 1);
   n_x   = sum (x * ones (1, df+1) < ones (l_x, 1) * c);
   l_y   = length (y);
   y     = reshape (y, l_y, 1);
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -74,17 +74,17 @@ function t = cor_test (x, y, alt, method
 
   if (!isvector (x) || !isvector (y) || length (x) != length (y))
     error ("cor_test: X and Y must be vectors of the same length");
   endif
 
   if (nargin < 3)
     alt = "!=";
   elseif (! ischar (alt))
-    error ("cor_test: alt must be a string");
+    error ("cor_test: ALT must be a string");
   endif
 
   if (nargin < 4)
     method = "pearson";
   elseif (! ischar (method))
     error ("cor_test: METHOD must be a string");
   endif
 
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
--- a/scripts/statistics/tests/f_test_regression.m
+++ b/scripts/statistics/tests/f_test_regression.m
@@ -39,29 +39,29 @@
 function [pval, f, df_num, df_den] = f_test_regression (y, x, rr, r)
 
   if (nargin < 3 || nargin > 4)
     print_usage ();
   endif
 
   [T, k] = size (x);
   if (! (isvector (y) && (length (y) == T)))
-    error ("f_test_regression: y must be a vector of length rows (X)");
+    error ("f_test_regression: Y must be a vector of length rows (X)");
   endif
   y = reshape (y, T, 1);
 
   [q, c_R ] = size (rr);
   if (c_R != k)
-    error ("f_test_regression: rr must have as many columns as x");
+    error ("f_test_regression: RR must have as many columns as X");
   endif
 
   if (nargin == 4)
     s_r = size (r);
     if ((min (s_r) != 1) || (max (s_r) != q))
-      error ("f_test_regression: r must be a vector of length rows (rr)");
+      error ("f_test_regression: R must be a vector of length rows (RR)");
     endif
     r = reshape (r, q, 1);
   else
     r = zeros (q, 1);
   endif
 
   df_num = q;
   df_den = T - k;
diff --git a/scripts/statistics/tests/hotelling_test.m b/scripts/statistics/tests/hotelling_test.m
--- a/scripts/statistics/tests/hotelling_test.m
+++ b/scripts/statistics/tests/hotelling_test.m
@@ -39,32 +39,32 @@
 function [pval, Tsq] = hotelling_test (x, m)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (isvector (x))
     if (! isscalar (m))
-      error ("hotelling_test: if x is a vector, m must be a scalar");
+      error ("hotelling_test: if X is a vector, M must be a scalar");
     endif
     n = length (x);
     p = 1;
   elseif (ismatrix (x))
     [n, p] = size (x);
     if (n <= p)
-      error ("hotelling_test: x must have more rows than columns");
+      error ("hotelling_test: X must have more rows than columns");
     endif
     if (isvector (m) && length (m) == p)
       m = reshape (m, 1, p);
     else
-      error ("hotelling_test: if x is a matrix, m must be a vector of length columns (x)");
+      error ("hotelling_test: if X is a matrix, M must be a vector of length columns (X)");
     endif
   else
-    error ("hotelling_test: x must be a matrix or vector");
+    error ("hotelling_test: X must be a matrix or vector");
   endif
 
   d    = mean (x) - m;
   Tsq  = n * d * (cov (x) \ d');
   pval = 1 - f_cdf ((n-p) * Tsq / (p * (n-1)), p, n-p);
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
diff --git a/scripts/statistics/tests/hotelling_test_2.m b/scripts/statistics/tests/hotelling_test_2.m
--- a/scripts/statistics/tests/hotelling_test_2.m
+++ b/scripts/statistics/tests/hotelling_test_2.m
@@ -54,29 +54,29 @@ function [pval, Tsq] = hotelling_test_2 
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (isvector (x))
     n_x = length (x);
     if (! isvector (y))
-      error ("hotelling_test_2: if x is a vector, y must also be a vector");
+      error ("hotelling_test_2: if X is a vector, Y must also be a vector");
     else
       n_y = length (y);
       p   = 1;
     endif
   elseif (ismatrix (x))
     [n_x, p] = size (x);
     [n_y, q] = size (y);
     if (p != q)
-      error ("hotelling_test_2: x and y must have the same number of columns");
+      error ("hotelling_test_2: X and Y must have the same number of columns");
     endif
   else
-    error ("hotelling_test_2: x and y must be matrices (or vectors)");
+    error ("hotelling_test_2: X and Y must be matrices (or vectors)");
   endif
 
   d    = mean (x) - mean (y);
   S    = ((n_x - 1) * cov (x) + (n_y - 1) * cov (y)) / (n_x + n_y - 2);
   Tsq  = (n_x * n_y / (n_x + n_y)) * d * (S \ d');
   pval = 1 - f_cdf ((n_x + n_y - p - 1) * Tsq / (p * (n_x + n_y - 2)),
                     p, n_x + n_y - p - 1);
 
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -56,17 +56,17 @@
 
 function [pval, ks] = kolmogorov_smirnov_test (x, dist, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
   if (! isvector (x))
-    error ("kolmogorov_smirnov_test: x must be a vector");
+    error ("kolmogorov_smirnov_test: X must be a vector");
   endif
 
   n = length (x);
   s = sort (x);
   try
     f = str2func (sprintf ("%scdf", dist));
   catch
     try
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -48,24 +48,24 @@
 
 function [pval, ks, d] = kolmogorov_smirnov_test_2 (x, y, alt)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
-    error ("kolmogorov_smirnov_test_2: both x and y must be vectors");
+    error ("kolmogorov_smirnov_test_2: both X and Y must be vectors");
   endif
 
   if (nargin == 2)
     alt = "!=";
   else
     if (! ischar (alt))
-      error ("kolmogorov_smirnov_test_2: alt must be a string");
+      error ("kolmogorov_smirnov_test_2: ALT must be a string");
     endif
   endif
 
   n_x = length (x);
   n_y = length (y);
   n   = n_x * n_y / (n_x + n_y);
   x   = reshape (x, n_x, 1);
   y   = reshape (y, n_y, 1);
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -49,17 +49,17 @@ function manova (x, g)
 
   if (isvector (x))
     error ("manova: Y must not be a vector");
   endif
 
   [n, p] = size (x);
 
   if (!isvector (g) || (length (g) != n))
-    error ("manova: g must be a vector of length rows (Y)");
+    error ("manova: G must be a vector of length rows (Y)");
   endif
 
   s = sort (g);
   i = find (s (2:n) > s(1:(n-1)));
   k = length (i) + 1;
 
   if (k == 1)
     error ("manova: there should be at least 2 groups");
diff --git a/scripts/statistics/tests/mcnemar_test.m b/scripts/statistics/tests/mcnemar_test.m
--- a/scripts/statistics/tests/mcnemar_test.m
+++ b/scripts/statistics/tests/mcnemar_test.m
@@ -37,19 +37,19 @@
 
 function [pval, chisq, df] = mcnemar_test (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! (min (size (x)) > 1) && issquare (x))
-    error ("mcnemar_test: x must be a square matrix of size > 1");
+    error ("mcnemar_test: X must be a square matrix of size > 1");
   elseif (! (all (all (x >= 0)) && all (all (x == round (x)))))
-    error ("mcnemar_test: all entries of x must be nonnegative integers");
+    error ("mcnemar_test: all entries of X must be nonnegative integers");
   endif
 
   r = rows (x);
   df = r * (r - 1) / 2;
   if (r == 2)
     num = max (abs (x - x') - 1, 0) .^ 2;
   else
     num = abs (x - x') .^ 2;
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
--- a/scripts/statistics/tests/prop_test_2.m
+++ b/scripts/statistics/tests/prop_test_2.m
@@ -57,17 +57,17 @@ function [pval, z] = prop_test_2 (x1, n1
 
   cdf = stdnormal_cdf (z);
 
   if (nargin == 4)
     alt  = "!=";
   endif
 
   if (! ischar (alt))
-    error ("prop_test_2: alt must be a string");
+    error ("prop_test_2: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
   else
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -45,32 +45,32 @@
 
 function [pval, b, n] = sign_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y) && (length (x) == length (y))))
-    error ("sign_test: x and y must be vectors of the same length");
+    error ("sign_test: X and Y must be vectors of the same length");
   endif
 
   n   = length (x);
   x   = reshape (x, 1, n);
   y   = reshape (y, 1, n);
   n   = sum (x != y);
   b   = sum (x > y);
   cdf = binomial_cdf (b, n, 1/2);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! ischar (alt))
-    error ("sign_test: alt must be a string");
+    error ("sign_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
   else
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -44,33 +44,33 @@
 
 function [pval, t, df] = t_test (x, m, alt)
 
   if ((nargin < 2) || (nargin > 3))
     print_usage ();
   endif
 
   if (! isvector (x))
-    error ("t_test: x must be a vector");
+    error ("t_test: X must be a vector");
   endif
   if (! isscalar (m))
-    error ("t_test: m must be a scalar");
+    error ("t_test: M must be a scalar");
   endif
 
   n   = length (x);
   df  = n - 1;
   t   = sqrt (n) * (sum (x) / n - m) / std (x);
   cdf = tcdf (t, df);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! ischar (alt))
-    error ("t_test: alt must be a string");
+    error ("t_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
   else
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -44,34 +44,34 @@
 
 function [pval, t, df] = t_test_2 (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
         print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
-    error ("t_test_2: both x and y must be vectors");
+    error ("t_test_2: both X and Y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   df   = n_x + n_y - 2;
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
   v    = sumsq (x - mu_x) + sumsq (y - mu_y);
   t    = (mu_x - mu_y) * sqrt ((n_x * n_y * df) / (v * (n_x + n_y)));
   cdf  = tcdf (t, df);
 
   if (nargin == 2)
     alt = "!=";
   endif
 
   if (! ischar (alt))
-    error ("t_test_2: alt must be a string");
+    error ("t_test_2: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
   else
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -54,28 +54,28 @@ function [pval, t, df] = t_test_regressi
     else
       alt = "!=";
     endif
   elseif (! (nargin == 5))
     print_usage ();
   endif
 
   if (! isscalar (r))
-    error ("t_test_regression: r must be a scalar");
+    error ("t_test_regression: R must be a scalar");
   elseif (! ischar (alt))
-    error ("t_test_regression: alt must be a string");
+    error ("t_test_regression: ALT must be a string");
   endif
 
   [T, k] = size (x);
   if (! (isvector (y) && (length (y) == T)))
-    error ("t_test_regression: y must be a vector of length rows (X)");
+    error ("t_test_regression: Y must be a vector of length rows (X)");
   endif
   s      = size (rr);
   if (! ((max (s) == k) && (min (s) == 1)))
-    error ("t_test_regression: rr must be a vector of length columns (X)");
+    error ("t_test_regression: RR must be a vector of length columns (X)");
   endif
 
   rr     = reshape (rr, 1, k);
   y      = reshape (y, T, 1);
   [b, v] = ols (y, x);
   df     = T - k;
   t      = (rr * b - r) / sqrt (v * rr * inv (x' * x) * rr');
   cdf    = tcdf (t, df);
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -46,33 +46,33 @@
 
 function [pval, z] = u_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
-    error ("u_test: both x and y must be vectors");
+    error ("u_test: both X and Y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   r    = ranks ([(reshape (x, 1, n_x)), (reshape (y, 1, n_y))]);
   z    = (sum (r(1 : n_x)) - n_x * (n_x + n_y + 1) / 2) ...
            / sqrt (n_x * n_y * (n_x + n_y + 1) / 12);
 
   cdf  = stdnormal_cdf (z);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! ischar (alt))
-    error("u_test: alt must be a string");
+    error("u_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = cdf;
   elseif (strcmp (alt, "<"))
     pval = 1 - cdf;
   else
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
--- a/scripts/statistics/tests/var_test.m
+++ b/scripts/statistics/tests/var_test.m
@@ -44,30 +44,30 @@
 
 function [pval, f, df_num, df_den] = var_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
-    error ("var_test: both x and y must be vectors");
+    error ("var_test: both X and Y must be vectors");
   endif
 
   df_num = length (x) - 1;
   df_den = length (y) - 1;
   f      = var (x) / var (y);
   cdf    = f_cdf (f, df_num, df_den);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! ischar (alt))
-    error ("var_test: alt must be a string");
+    error ("var_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
--- a/scripts/statistics/tests/welch_test.m
+++ b/scripts/statistics/tests/welch_test.m
@@ -43,17 +43,17 @@
 
 function [pval, t, df] = welch_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
-    error ("welch_test: both x and y must be vectors");
+    error ("welch_test: both X and Y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
   v_x  = sumsq (x - mu_x) / (n_x * (n_x - 1));
   v_y  = sumsq (y - mu_y) / (n_y * (n_y - 1));
@@ -62,17 +62,17 @@ function [pval, t, df] = welch_test (x, 
   t    = (mu_x - mu_y) / sqrt (v_x + v_y);
   cdf  = tcdf (t, df);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! ischar (alt))
-    error ("welch_test: alt must be a string");
+    error ("welch_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -45,17 +45,17 @@
 
 function [pval, z] = wilcoxon_test (x, y, alt)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y) && (length (x) == length (y))))
-    error ("wilcoxon_test: x and y must be vectors of the same length");
+    error ("wilcoxon_test: X and Y must be vectors of the same length");
   endif
 
   n = length (x);
   x = reshape (x, 1, n);
   y = reshape (y, 1, n);
   d = x - y;
   d = d (find (d != 0));
   n = length (d);
@@ -69,17 +69,17 @@ function [pval, z] = wilcoxon_test (x, y
 
   cdf = stdnormal_cdf (z);
 
   if (nargin == 2)
     alt = "!=";
   endif
 
   if (! ischar (alt))
-    error("wilcoxon_test: alt must be a string");
+    error("wilcoxon_test: ALT must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("wilcoxon_test: option %s not recognized", alt);
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -44,35 +44,35 @@
 
 function [pval, z] = z_test (x, m, v, alt)
 
   if ((nargin < 3) || (nargin > 4))
     print_usage ();
   endif
 
   if (! isvector (x))
-    error ("z_test: x must be a vector");
+    error ("z_test: X must be a vector");
   endif
   if (! isscalar (m))
-    error ("z_test: m must be a scalar");
+    error ("z_test: M must be a scalar");
   endif
   if (! (isscalar (v) && (v > 0)))
-    error ("z_test: v must be a positive scalar");
+    error ("z_test: V must be a positive scalar");
   endif
 
   n = length (x);
   z = sqrt (n/v) * (sum (x) / n - m);
   cdf = stdnormal_cdf (z);
 
   if (nargin == 3)
     alt = "!=";
   endif
 
   if (! ischar (alt))
-    error ("z_test: alt must be a string");
+    error ("z_test: ALT must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("z_test: option %s not recognized", alt);
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -44,35 +44,35 @@
 
 function [pval, z] = z_test_2 (x, y, v_x, v_y, alt)
 
   if ((nargin < 4) || (nargin > 5))
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
-    error("z_test_2: both x and y must be vectors");
+    error("z_test_2: both X and Y must be vectors");
   elseif (! (isscalar (v_x) && (v_x > 0)
              && isscalar (v_y) && (v_y > 0)))
-    error ("z_test_2: both v_x and v_y must be positive scalars");
+    error ("z_test_2: both V_X and V_Y must be positive scalars");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
   z    = (mu_x - mu_y) / sqrt (v_x / n_x + v_y / n_y);
   cdf  = stdnormal_cdf (z);
 
   if (nargin == 4)
     alt = "!=";
   endif
 
   if (! ischar (alt))
-    error ("z_test_2: alt must be a string");
+    error ("z_test_2: ALT must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("z_test_2: option %s not recognized", alt);
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -37,17 +37,17 @@
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function s = blanks (n)
 
   if (nargin != 1)
     print_usage ();
   elseif (! (isscalar (n) && n == round (n)))
-    error ("blanks: n must be a non-negative integer");
+    error ("blanks: N must be a non-negative integer");
   endif
 
   ## If 1:n is empty, the following expression will create an empty
   ## character string.  Otherwise, it will create a row vector.
   s(1:n) = " ";
 
 endfunction
 
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -69,17 +69,17 @@ function n = index (s, t, direction)
     endif
   elseif (strcmp (direction, "first"))
     if (iscell (f))
       n = cellfun (@max, f);
     else
       n = f(1);
     endif
   else
-    error ("index: direction must be either \"first\" or \"last\"");
+    error ("index: DIRECTION must be either \"first\" or \"last\"");
   endif
 endfunction
 
 ## Test the function out
 %!assert(index("astringbstringcstring", "s"), 2)
 %!assert(index("astringbstringcstring", "st"), 2)
 %!assert(index("astringbstringcstring", "str"), 2)
 %!assert(index("astringbstringcstring", "string"), 2)
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -48,17 +48,17 @@
 
 function idx = strmatch (s, A, exact)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (! ischar (s))
-    error ("strmatch: first argument must be a string");
+    error ("strmatch: S must be a string");
   endif
   
   ## Truncate trailing whitespace.
   s = strtrimr (s);
 
   len = length (s);
 
   exact = nargin == 3 && ischar (exact) && strcmp (exact, "exact");
@@ -82,17 +82,17 @@ function idx = strmatch (s, A, exact)
       match = all (bsxfun (@eq, A(:,1:len), s), 2);
       if (exact)
         AA = A(:,len+1:nc);
         match &= all (AA == "\0" | AA == " ", 2);
       endif
       idx = find (match);
     endif
   else
-    error ("strmatch: second argument must be a string or cell array of strings");
+    error ("strmatch: A must be a string or cell array of strings");
   endif
     
 endfunction 
 
 ## Removes nuls and blanks from the end of the array
 function s = strtrimr (s)
   blnks = s == "\0" | s == " ";
   i = find (blnks, 1, "last");
diff --git a/scripts/strings/strtrunc.m b/scripts/strings/strtrunc.m
--- a/scripts/strings/strtrunc.m
+++ b/scripts/strings/strtrunc.m
@@ -38,17 +38,17 @@ function s = strtrunc (s, n)
     s_was_char = false;
   endif
 
   if (iscellstr (s))
     for i = 1:(numel (s))
       s{i} = s{i}(:,1:(min (n, columns (s{i}))));
     endfor
   else
-    error ("strtrunc: s must be a character string or a cell array of strings");
+    error ("strtrunc: S must be a character string or a cell array of strings");
   endif
 
   if (s_was_char)
     s = s{:};
   endif
 
 endfunction
 
diff --git a/scripts/strings/validatestring.m b/scripts/strings/validatestring.m
--- a/scripts/strings/validatestring.m
+++ b/scripts/strings/validatestring.m
@@ -69,31 +69,31 @@ function str = validatestring (str, stra
         funcname = varargin{i};
         funcnameset = true;
       endif
     endif
   endfor
 
   ## Check the inputs
   if (! ischar (str))
-    error ("validatestring: str must be a character string");
+    error ("validatestring: STR must be a character string");
   elseif (rows (str) != 1)
-    error ("validatestring: str must have only one row");
+    error ("validatestring: STR must have only one row");
   elseif (! iscellstr (strarray))
-    error ("validatestring: strarray must be a cellstr");
+    error ("validatestring: STRARRAY must be a cellstr");
   elseif (! ischar (funcname))
-    error ("validatestring: funcname must be a character string");
+    error ("validatestring: FUNCNAME must be a character string");
   elseif (! isempty (funcname) && (rows (funcname) != 1))
-    error ("validatestring: funcname must be exactly one row");
+    error ("validatestring: FUNCNAME must be exactly one row");
   elseif (! ischar (varname))
-    error ("validatestring: varname must be a character string");
+    error ("validatestring: VARNAME must be a character string");
   elseif (! isempty (varname) && (rows (varname) != 1))
-    error ("validatestring: varname must be exactly one row");
+    error ("validatestring: VARNAME must be exactly one row");
   elseif (position < 0)
-    error ("validatestring: position must be >= 0");
+    error ("validatestring: POSITION must be >= 0");
   endif
 
   ## make the part of the error that will use funcname, varname, and
   ## position
   errstr = "";
   if (! isempty (funcname))
     errstr = sprintf ("Function: %s ", funcname);
   endif
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -29,17 +29,17 @@ function rundemos (directory)
   elseif (nargin == 1)
     if (is_absolute_filename (directory))
       dirs = {directory};
     else
       fullname = find_dir_in_path (directory);
       if (! isempty (fullname))
         dirs = {fullname};
       else
-        error ("rundemos: expecting argument to be a directory name");
+        error ("rundemos: DIRECTORY argument must be a valid pathname");
       endif
     endif
   else
     print_usage ();
   endif
 
   for i = 1:numel (dirs)
     d = dirs{i};
diff --git a/scripts/testfun/runtests.m b/scripts/testfun/runtests.m
--- a/scripts/testfun/runtests.m
+++ b/scripts/testfun/runtests.m
@@ -30,17 +30,17 @@ function runtests (directory)
   elseif (nargin == 1)
     if (is_absolute_filename (directory))
       dirs = {directory};
     else
       fullname = find_dir_in_path (directory);
       if (! isempty (fullname))
         dirs = {fullname};
       else
-        error ("runtests: expecting argument to be a directory name");
+        error ("runtests: DIRECTORY argument must be a valid pathname");
       endif
     endif
   else
     print_usage ();
   endif
 
   for i = 1:numel (dirs)
     d = dirs{i};
diff --git a/scripts/time/addtodate.m b/scripts/time/addtodate.m
--- a/scripts/time/addtodate.m
+++ b/scripts/time/addtodate.m
@@ -29,17 +29,17 @@
 
 function d = addtodate (d, q, f)
 
   if (nargin != 3)
     print_usage ();
   elseif (! (ischar (f) && rows (f) == 1))
     ## FIXME: enhance the function so that it works with cellstrs of the
     ## same size as the output.
-    error ("addtodate: f must be a single row character string");
+    error ("addtodate: F must be a single row character string");
   endif
 
   if (numel (d) == 1 && numel (q) > 1)
     ## expand d to the size of q if d only has one element to make
     ## addition later eaiser.
     d = d.*ones (size (q));
   endif
 
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -80,17 +80,17 @@ function [days, secs] = datenum (year, m
     [year, month, day, hour, minute, second] = datevec (year, month);
   else
     if (nargin < 6) second = 0; endif
     if (nargin < 5) minute = 0; endif
     if (nargin < 4) hour = 0; endif
     if (nargin == 1)
       nc = columns (year);
       if (nc > 6 || nc < 3)
-        error ("datenum: expected date vector containing [year, month, day, hour, minute, second]");
+        error ("datenum: expected date vector containing [YEAR, MONTH, DAY, HOUR, MINUTE, SECOND]");
       endif
       second = minute = hour = 0;
       if (nc >= 6) second = year(:,6); endif
       if (nc >= 5) minute = year(:,5); endif
       if (nc >= 4) hour = year(:,4); endif
       day = year(:,3);
       month = year(:,2);
       year = year(:,1);
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -112,17 +112,17 @@ function __datetick__ (varargin)
     startdate = varargin{1};
   else
     startdate = [];
   endif
 
   if (! isempty (form))
     if (isnumeric (form))
       if (! isscalar (form) || floor (form) != form || form < 0)
-        error ("datetick: expecting form argument to be a positive integer");
+        error ("datetick: expecting FORM argument to be a positive integer");
       endif
     elseif (! ischar (form))
       error ("datetick: expecting valid date format string");
     endif
   endif
 
   if (keepticks)
     ticks = get (gca (), strcat (ax, "tick"));
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -123,26 +123,26 @@ function [y, m, d, h, mi, s] = datevec (
         for l = 1:nfmt
           [f, rY, ry, fy, fm, fd, fh, fmi, fs] = __date_vfmt2sfmt__ (std_formats{l});
           [found y(k) m(k) d(k) h(k) mi(k) s(k)] = __date_str2vec__ (date{k}, p, f, rY, ry, fy, fm, fd, fh, fmi, fs);
           if (found)
             break;
           endif
         endfor
         if (! found)
-          error ("datevec: none of the standard formats match the date string");
+          error ("datevec: none of the standard formats match the DATE string");
         endif
       endfor
     else
       ## Decipher the format string just once for sake of speed.
       [f, rY, ry, fy, fm, fd, fh, fmi, fs] = __date_vfmt2sfmt__ (f);
       for k = 1:nd
         [found y(k) m(k) d(k) h(k) mi(k) s(k)] = __date_str2vec__ (date{k}, p, f, rY, ry, fy, fm, fd, fh, fmi, fs);
         if (! found)
-          error ("datevec: date not parsed correctly with given format");
+          error ("datevec: DATE not parsed correctly with given format");
         endif
       endfor
     endif
 
   else
 
     date = date(:);
 
