# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1251364773 -7200
#      Thu Aug 27 11:19:33 2009 +0200
# Node ID 7dafdb8b062f673afbed57e4812c93a96f1b0f2c
# Parent  b03062e16c6f1f0584c67a63980226730be00220
refactor comparison ops implementations

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,12 @@
+2009-08-27  Jaroslav Hajek  <highegg@gmail.com>
+
+	* interpreter/expr.txi: Mention complex comparisons change.
+
 2009-08-05  Jaroslav Hajek  <highegg@gmail.com>
 
 	* interpreter/tips.txi: Update.
 
 2009-07-20  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/contributors.in: Add Aleksej Saushev.
 
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -612,16 +612,26 @@ True if @var{x} is greater than @var{y}.
 
 @item @var{x} != @var{y}
 @itemx @var{x} ~= @var{y}
 @opindex !=
 @opindex ~=
 True if @var{x} is not equal to @var{y}.
 @end table
 
+For complex numbers, the following ordering is defined:
+@var{z1} < @var{z2}
+iff
+@example
+  abs(@var{z1}) < abs(@var{z2}) 
+  || (abs(@var{z1}) == abs(@var{z2}) && arg(@var{z1}) < arg(@var{z2}))
+@end example
+This is consistent with the ordering used by @dfn{max}, @dfn{min} and @dfn{sort},
+but is not consistent with Matlab, which only compares the real parts.
+
 String comparisons may also be performed with the @code{strcmp}
 function, not with the comparison operators listed above.
 @xref{Strings}.
 
 @DOCSTRING(isequal)
 
 @DOCSTRING(isequalwithequalnans)
 
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -4060,22 +4060,22 @@ max (const ComplexMatrix& a, const Compl
 	      result (i, j) = xmax (a (i, j), b (i, j));
 	    }
 	}
     }
 
   return result;
 }
 
-MS_CMP_OPS(ComplexMatrix, std::real, Complex, std::real)
+MS_CMP_OPS (ComplexMatrix, Complex)
 MS_BOOL_OPS (ComplexMatrix, Complex)
 
-SM_CMP_OPS(Complex, std::real, ComplexMatrix, std::real)
+SM_CMP_OPS (Complex, ComplexMatrix)
 SM_BOOL_OPS (Complex, ComplexMatrix)
 
-MM_CMP_OPS(ComplexMatrix, std::real, ComplexMatrix, std::real)
+MM_CMP_OPS (ComplexMatrix, ComplexMatrix)
 MM_BOOL_OPS (ComplexMatrix, ComplexMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -1065,23 +1065,23 @@ max (const ComplexNDArray& a, const Comp
     {
       OCTAVE_QUIT;
       result (i) = xmax (a (i), b (i));
     }
 
   return result;
 }
 
-NDS_CMP_OPS(ComplexNDArray, std::real, Complex, std::real)
+NDS_CMP_OPS (ComplexNDArray, Complex)
 NDS_BOOL_OPS (ComplexNDArray, Complex)
 
-SND_CMP_OPS(Complex, std::real, ComplexNDArray, std::real)
+SND_CMP_OPS (Complex, ComplexNDArray)
 SND_BOOL_OPS (Complex, ComplexNDArray)
 
-NDND_CMP_OPS(ComplexNDArray, std::real, ComplexNDArray, std::real)
+NDND_CMP_OPS (ComplexNDArray, ComplexNDArray)
 NDND_BOOL_OPS (ComplexNDArray, ComplexNDArray)
 
 ComplexNDArray& operator *= (ComplexNDArray& a, double s)
 {
   if (a.is_shared ())
     return a = a * s;
   DO_VS_OP2 (Complex, a, *=, s)
   return a;
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,48 @@
+2009-08-27  Jaroslav Hajek  <highegg@gmail.com>
+
+	* mx-inlines.cc (DEFCMPLXCMOP): Remove.
+	* oct-cmplx.h (operator <, operator >): Remove definitions.
+	(DEF_COMPLEXR_COMP): New macro. Instantiate for <, >, <=, >=.
+	* mx-op-defs.h (MM_CMP_OP, MS_CMP_OP, SM_CMP_OP,
+	NDND_CMP_OP, NDS_CMP_OP, SND_CMP_OP): Replace by one-liners. Remove
+	unused parameters.
+	(MM_CMP_OPS, MS_CMP_OPS, SM_CMP_OPS, NDND_CMP_OPS, NDS_CMP_OPS,
+	SND_CMP_OPS): Update.
+	(NDS_CMP_OP1, NDS_CMP_OPS1, NDS_CMP_OP2, NDS_CMP_OPS2,
+	SND_CMP_OP1, SND_CMP_OPS1, SND_CMP_OP2, SND_CMP_OPS2): Remove.
+	* mk-ops.awk: Simplify CMP_OPS branch.
+	* Sparse-op-defs.h (SPARSE_SMSM_CMP_OPS, SPARSE_SMS_CMP_OPS,
+	SPARSE_SSM_CMP_OPS, SPARSE_MSM_CMP_OPS, SPARSE_SMM_CMP_OPS):
+	Update.
+
+	* CNDArray.cc: Update syntax.
+	* boolNDArray.cc: Ditto.
+	* chNDArray.cc: Ditto.
+	* dNDArray.cc: Ditto.
+	* fCNDArray.cc: Ditto.
+	* fNDArray.cc: Ditto.
+
+	* int16NDArray.cc: Ditto.
+	* int32NDArray.cc: Ditto.
+	* int64NDArray.cc: Ditto.
+	* int8NDArray.cc: Ditto.
+	* uint16NDArray.cc: Ditto.
+	* uint32NDArray.cc: Ditto.
+	* uint64NDArray.cc: Ditto.
+	* uint8NDArray.cc: Ditto.
+
+	* CMatrix.cc: Ditto.
+	* boolMatrix.cc: Ditto.
+	* chMatrix.cc: Ditto.
+	* dMatrix.cc: Ditto.
+	* fCMatrix.cc: Ditto.
+	* fMatrix.cc: Ditto.
+
 2009-08-24  Jaroslav Hajek  <highegg@gmail.com>
 
 	* MArray.cc (MArray<T>::product_eq, MArray<T>::quotient_eq): New
 	methods.
 	* MArray2.cc (MArray2<T>::product_eq, MArray2<T>::quotient_eq): Ditto.
 	* MArrayN.cc (MArrayN<T>::product_eq, MArrayN<T>::quotient_eq): Ditto.
 	* MArray-decl.h (MARRAY_OP_ASSIGN_DECLX): New macro.
 	(MARRAY_OP_ASSIGN_DECLS, MARRAY_OP_ASSIGN_FWD_DEFS): Include
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -134,20 +134,20 @@ along with Octave; see the file COPYING.
             r.cidx (j + 1) = nel; \
           } \
         r.maybe_compress (false); \
       } \
     return r; \
   }
 
 #define SPARSE_SMS_CMP_OPS(M, MZ, CM, S, SZ, CS)	\
-  SPARSE_SMS_CMP_OP (mx_el_lt, <,  M, MZ, CM, S, SZ, CS)	\
-  SPARSE_SMS_CMP_OP (mx_el_le, <=, M, MZ, CM, S, SZ, CS)	\
-  SPARSE_SMS_CMP_OP (mx_el_ge, >=, M, MZ, CM, S, SZ, CS)	\
-  SPARSE_SMS_CMP_OP (mx_el_gt, >,  M, MZ, CM, S, SZ, CS)	\
+  SPARSE_SMS_CMP_OP (mx_el_lt, <,  M, MZ,   , S, SZ,   )	\
+  SPARSE_SMS_CMP_OP (mx_el_le, <=, M, MZ,   , S, SZ,   )	\
+  SPARSE_SMS_CMP_OP (mx_el_ge, >=, M, MZ,   , S, SZ,   )	\
+  SPARSE_SMS_CMP_OP (mx_el_gt, >,  M, MZ,   , S, SZ,   )	\
   SPARSE_SMS_CMP_OP (mx_el_eq, ==, M, MZ,   , S, SZ,   )	\
   SPARSE_SMS_CMP_OP (mx_el_ne, !=, M, MZ,   , S, SZ,   )
 
 #define SPARSE_SMS_EQNE_OPS(M, MZ, CM, S, SZ, CS)	\
   SPARSE_SMS_CMP_OP (mx_el_eq, ==, M, MZ,   , S, SZ,   )	\
   SPARSE_SMS_CMP_OP (mx_el_ne, !=, M, MZ,   , S, SZ,   )
 
 #define SPARSE_SMS_BOOL_OP_DECLS(M, S, API) \
@@ -303,20 +303,20 @@ along with Octave; see the file COPYING.
             r.cidx (j + 1) = nel; \
           } \
         r.maybe_compress (false); \
       } \
     return r; \
   }
 
 #define SPARSE_SSM_CMP_OPS(S, SZ, SC, M, MZ, MC)	\
-  SPARSE_SSM_CMP_OP (mx_el_lt, <,  S, SZ, SC, M, MZ, MC)	\
-  SPARSE_SSM_CMP_OP (mx_el_le, <=, S, SZ, SC, M, MZ, MC)	\
-  SPARSE_SSM_CMP_OP (mx_el_ge, >=, S, SZ, SC, M, MZ, MC)	\
-  SPARSE_SSM_CMP_OP (mx_el_gt, >,  S, SZ, SC, M, MZ, MC)	\
+  SPARSE_SSM_CMP_OP (mx_el_lt, <,  S, SZ,   , M, MZ,   )	\
+  SPARSE_SSM_CMP_OP (mx_el_le, <=, S, SZ,   , M, MZ,   )	\
+  SPARSE_SSM_CMP_OP (mx_el_ge, >=, S, SZ,   , M, MZ,   )	\
+  SPARSE_SSM_CMP_OP (mx_el_gt, >,  S, SZ,   , M, MZ,   )	\
   SPARSE_SSM_CMP_OP (mx_el_eq, ==, S, SZ,   , M, MZ,   )	\
   SPARSE_SSM_CMP_OP (mx_el_ne, !=, S, SZ,   , M, MZ,   )
 
 #define SPARSE_SSM_EQNE_OPS(S, SZ, SC, M, MZ, MC)	\
   SPARSE_SSM_CMP_OP (mx_el_eq, ==, S, SZ,   , M, MZ,   )	\
   SPARSE_SSM_CMP_OP (mx_el_ne, !=, S, SZ,   , M, MZ,   )
 
 #define SPARSE_SSM_BOOL_OP_DECLS(S, M, API) \
@@ -900,20 +900,20 @@ along with Octave; see the file COPYING.
       { \
 	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
 	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMSM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)  \
-  SPARSE_SMSM_CMP_OP (mx_el_lt, <,  M1, Z1, C1, M2, Z2, C2) \
-  SPARSE_SMSM_CMP_OP (mx_el_le, <=, M1, Z1, C1, M2, Z2, C2) \
-  SPARSE_SMSM_CMP_OP (mx_el_ge, >=, M1, Z1, C1, M2, Z2, C2) \
-  SPARSE_SMSM_CMP_OP (mx_el_gt, >,  M1, Z1, C1, M2, Z2, C2) \
+  SPARSE_SMSM_CMP_OP (mx_el_lt, <,  M1, Z1,   , M2, Z2,   ) \
+  SPARSE_SMSM_CMP_OP (mx_el_le, <=, M1, Z1,   , M2, Z2,   ) \
+  SPARSE_SMSM_CMP_OP (mx_el_ge, >=, M1, Z1,   , M2, Z2,   ) \
+  SPARSE_SMSM_CMP_OP (mx_el_gt, >,  M1, Z1,   , M2, Z2,   ) \
   SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1, Z1,   , M2, Z2,   ) \
   SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1, Z1,   , M2, Z2,   )
 
 #define SPARSE_SMSM_EQNE_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1, Z1,   , M2, Z2,   ) \
   SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1, Z1,   , M2, Z2,   )
 
 #define SPARSE_SMSM_BOOL_OP_DECLS(M1, M2, API) \
@@ -1217,20 +1217,20 @@ along with Octave; see the file COPYING.
       { \
 	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
 	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_MSM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)  \
-  SPARSE_MSM_CMP_OP (mx_el_lt, <,  M1, C1, M2, C2) \
-  SPARSE_MSM_CMP_OP (mx_el_le, <=, M1, C1, M2, C2) \
-  SPARSE_MSM_CMP_OP (mx_el_ge, >=, M1, C1, M2, C2) \
-  SPARSE_MSM_CMP_OP (mx_el_gt, >,  M1, C1, M2, C2) \
+  SPARSE_MSM_CMP_OP (mx_el_lt, <,  M1,   , M2,   ) \
+  SPARSE_MSM_CMP_OP (mx_el_le, <=, M1,   , M2,   ) \
+  SPARSE_MSM_CMP_OP (mx_el_ge, >=, M1,   , M2,   ) \
+  SPARSE_MSM_CMP_OP (mx_el_gt, >,  M1,   , M2,   ) \
   SPARSE_MSM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
   SPARSE_MSM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
 
 #define SPARSE_MSM_EQNE_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_MSM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
   SPARSE_MSM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
 
 #define SPARSE_MSM_BOOL_OP_DECLS(M1, M2, API) \
@@ -1451,20 +1451,20 @@ along with Octave; see the file COPYING.
       { \
 	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
 	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)  \
-  SPARSE_SMM_CMP_OP (mx_el_lt, <,  M1, C1, M2, C2) \
-  SPARSE_SMM_CMP_OP (mx_el_le, <=, M1, C1, M2, C2) \
-  SPARSE_SMM_CMP_OP (mx_el_ge, >=, M1, C1, M2, C2) \
-  SPARSE_SMM_CMP_OP (mx_el_gt, >,  M1, C1, M2, C2) \
+  SPARSE_SMM_CMP_OP (mx_el_lt, <,  M1,   , M2,   ) \
+  SPARSE_SMM_CMP_OP (mx_el_le, <=, M1,   , M2,   ) \
+  SPARSE_SMM_CMP_OP (mx_el_ge, >=, M1,   , M2,   ) \
+  SPARSE_SMM_CMP_OP (mx_el_gt, >,  M1,   , M2,   ) \
   SPARSE_SMM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
   SPARSE_SMM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
 
 #define SPARSE_SMM_EQNE_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_SMM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
   SPARSE_SMM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
 
 #define SPARSE_SMM_BOOL_OP_DECLS(M1, M2, API) \
diff --git a/liboctave/boolMatrix.cc b/liboctave/boolMatrix.cc
--- a/liboctave/boolMatrix.cc
+++ b/liboctave/boolMatrix.cc
@@ -97,15 +97,15 @@ boolMatrix
 boolMatrix::any (int dim) const
 {
   return do_mx_red_op<boolMatrix, bool> (*this, dim, mx_inline_any);
 }
 
 MM_BOOL_OPS (boolMatrix, boolMatrix)
 MS_BOOL_OPS (boolMatrix, bool)
 SM_BOOL_OPS (bool, boolMatrix)
-MM_CMP_OPS (boolMatrix, , boolMatrix, )
+MM_CMP_OPS (boolMatrix, boolMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -137,23 +137,23 @@ boolNDArray::compute_index (Array<octave
 
 boolNDArray
 boolNDArray::diag (octave_idx_type k) const
 {
   return ArrayN<bool>::diag (k);
 }
 
 NDND_BOOL_OPS (boolNDArray, boolNDArray)
-NDND_CMP_OPS (boolNDArray, , boolNDArray, )
+NDND_CMP_OPS (boolNDArray, boolNDArray)
 
 NDS_BOOL_OPS (boolNDArray, bool)
-NDS_CMP_OPS (boolNDArray, , bool, )
+NDS_CMP_OPS (boolNDArray, bool)
 
 SND_BOOL_OPS (bool, boolNDArray)
-SND_CMP_OPS (bool, , boolNDArray, )
+SND_CMP_OPS (bool, boolNDArray)
 
 boolNDArray& 
 mx_el_and_assign (boolNDArray& a, const boolNDArray& b)
 {
   if (a.is_shared ())
     return a = mx_el_and (a, b);
 
   dim_vector a_dims = a.dims ();
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -209,22 +209,22 @@ charMatrix::all (int dim) const
 }
 
 boolMatrix
 charMatrix::any (int dim) const
 {
   return do_mx_red_op<boolMatrix, char> (*this, dim, mx_inline_any);
 }
 
-MS_CMP_OPS(charMatrix, , char, )
+MS_CMP_OPS (charMatrix, char)
 MS_BOOL_OPS (charMatrix, char)
 
-SM_CMP_OPS(char, , charMatrix, )
+SM_CMP_OPS (char, charMatrix)
 SM_BOOL_OPS (char, charMatrix)
 
-MM_CMP_OPS(charMatrix, , charMatrix, )
+MM_CMP_OPS (charMatrix, charMatrix)
 MM_BOOL_OPS (charMatrix, charMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -201,22 +201,22 @@ charNDArray::smap (mapper fcn) const
       OCTAVE_QUIT;
 
       p[i] = fcn (m[i]);
     }
 
   return result;
 }
 
-NDS_CMP_OPS(charNDArray, , char, )
+NDS_CMP_OPS (charNDArray, char)
 NDS_BOOL_OPS (charNDArray, char)
 
-SND_CMP_OPS(char, , charNDArray, )
+SND_CMP_OPS (char, charNDArray)
 SND_BOOL_OPS (char, charNDArray)
 
-NDND_CMP_OPS(charNDArray, , charNDArray, )
+NDND_CMP_OPS (charNDArray, charNDArray)
 NDND_BOOL_OPS (charNDArray, charNDArray)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -3389,22 +3389,22 @@ max (const Matrix& a, const Matrix& b)
       {
 	OCTAVE_QUIT;
 	result (i, j) = xmax (a (i, j), b (i, j));
       }
 
   return result;
 }
 
-MS_CMP_OPS(Matrix, , double, )
+MS_CMP_OPS (Matrix, double)
 MS_BOOL_OPS (Matrix, double)
 
-SM_CMP_OPS(double, , Matrix, )
+SM_CMP_OPS (double, Matrix)
 SM_BOOL_OPS (double, Matrix)
 
-MM_CMP_OPS(Matrix, , Matrix, )
+MM_CMP_OPS (Matrix, Matrix)
 MM_BOOL_OPS (Matrix, Matrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -1111,22 +1111,22 @@ max (const NDArray& a, const NDArray& b)
     {
       OCTAVE_QUIT;
       result (i) = xmax (a (i), b (i));
     }
 
   return result;
 }
 
-NDS_CMP_OPS(NDArray, , double, )
+NDS_CMP_OPS (NDArray, double)
 NDS_BOOL_OPS (NDArray, double)
 
-SND_CMP_OPS(double, , NDArray, )
+SND_CMP_OPS (double, NDArray)
 SND_BOOL_OPS (double, NDArray)
 
-NDND_CMP_OPS(NDArray, , NDArray, )
+NDND_CMP_OPS (NDArray, NDArray)
 NDND_BOOL_OPS (NDArray, NDArray)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -4053,22 +4053,22 @@ max (const FloatComplexMatrix& a, const 
 	      result (i, j) = xmax (a (i, j), b (i, j));
 	    }
 	}
     }
 
   return result;
 }
 
-MS_CMP_OPS(FloatComplexMatrix, std::real, FloatComplex, std::real)
+MS_CMP_OPS (FloatComplexMatrix, FloatComplex)
 MS_BOOL_OPS (FloatComplexMatrix, FloatComplex)
 
-SM_CMP_OPS(FloatComplex, std::real, FloatComplexMatrix, std::real)
+SM_CMP_OPS (FloatComplex, FloatComplexMatrix)
 SM_BOOL_OPS (FloatComplex, FloatComplexMatrix)
 
-MM_CMP_OPS(FloatComplexMatrix, std::real, FloatComplexMatrix, std::real)
+MM_CMP_OPS (FloatComplexMatrix, FloatComplexMatrix)
 MM_BOOL_OPS (FloatComplexMatrix, FloatComplexMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -1060,23 +1060,23 @@ max (const FloatComplexNDArray& a, const
     {
       OCTAVE_QUIT;
       result (i) = xmax (a (i), b (i));
     }
 
   return result;
 }
 
-NDS_CMP_OPS(FloatComplexNDArray, std::real, FloatComplex, std::real)
+NDS_CMP_OPS (FloatComplexNDArray, FloatComplex)
 NDS_BOOL_OPS (FloatComplexNDArray, FloatComplex)
 
-SND_CMP_OPS(FloatComplex, std::real, FloatComplexNDArray, std::real)
+SND_CMP_OPS (FloatComplex, FloatComplexNDArray)
 SND_BOOL_OPS (FloatComplex, FloatComplexNDArray)
 
-NDND_CMP_OPS(FloatComplexNDArray, std::real, FloatComplexNDArray, std::real)
+NDND_CMP_OPS (FloatComplexNDArray, FloatComplexNDArray)
 NDND_BOOL_OPS (FloatComplexNDArray, FloatComplexNDArray)
 
 FloatComplexNDArray& operator *= (FloatComplexNDArray& a, float s)
 {
   if (a.is_shared ())
     return a = a * s;
   DO_VS_OP2 (FloatComplex, a, *=, s)
   return a;
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -3388,22 +3388,22 @@ max (const FloatMatrix& a, const FloatMa
       {
 	OCTAVE_QUIT;
 	result (i, j) = xmax (a (i, j), b (i, j));
       }
 
   return result;
 }
 
-MS_CMP_OPS(FloatMatrix, , float, )
+MS_CMP_OPS (FloatMatrix, float)
 MS_BOOL_OPS (FloatMatrix, float)
 
-SM_CMP_OPS(float, , FloatMatrix, )
+SM_CMP_OPS (float, FloatMatrix)
 SM_BOOL_OPS (float, FloatMatrix)
 
-MM_CMP_OPS(FloatMatrix, , FloatMatrix, )
+MM_CMP_OPS (FloatMatrix, FloatMatrix)
 MM_BOOL_OPS (FloatMatrix, FloatMatrix)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -1069,22 +1069,22 @@ max (const FloatNDArray& a, const FloatN
     {
       OCTAVE_QUIT;
       result (i) = xmax (a (i), b (i));
     }
 
   return result;
 }
 
-NDS_CMP_OPS(FloatNDArray, , float, )
+NDS_CMP_OPS (FloatNDArray, float)
 NDS_BOOL_OPS (FloatNDArray, float)
 
-SND_CMP_OPS(float, , FloatNDArray, )
+SND_CMP_OPS (float, FloatNDArray)
 SND_BOOL_OPS (float, FloatNDArray)
 
-NDND_CMP_OPS(FloatNDArray, , FloatNDArray, )
+NDND_CMP_OPS (FloatNDArray, FloatNDArray)
 NDND_BOOL_OPS (FloatNDArray, FloatNDArray)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/int16NDArray.cc b/liboctave/int16NDArray.cc
--- a/liboctave/int16NDArray.cc
+++ b/liboctave/int16NDArray.cc
@@ -34,23 +34,23 @@ template class OCTAVE_API intNDArray<oct
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_int16>& a);
 
 template OCTAVE_API
 std::istream&
 operator >> (std::istream& is, intNDArray<octave_int16>& a);
 
-NDS_CMP_OPS (int16NDArray, , octave_int16, )
+NDS_CMP_OPS (int16NDArray, octave_int16)
 NDS_BOOL_OPS (int16NDArray, octave_int16)
 
-SND_CMP_OPS (octave_int16, , int16NDArray, )
+SND_CMP_OPS (octave_int16, int16NDArray)
 SND_BOOL_OPS (octave_int16, int16NDArray)
 
-NDND_CMP_OPS (int16NDArray, , int16NDArray, )
+NDND_CMP_OPS (int16NDArray, int16NDArray)
 NDND_BOOL_OPS (int16NDArray, int16NDArray)
 
 MINMAX_FCNS (int16)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/int32NDArray.cc b/liboctave/int32NDArray.cc
--- a/liboctave/int32NDArray.cc
+++ b/liboctave/int32NDArray.cc
@@ -34,23 +34,23 @@ template class OCTAVE_API intNDArray<oct
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_int32>& a);
 
 template OCTAVE_API
 std::istream&
 operator >> (std::istream& is, intNDArray<octave_int32>& a);
 
-NDS_CMP_OPS (int32NDArray, , octave_int32, )
+NDS_CMP_OPS (int32NDArray, octave_int32)
 NDS_BOOL_OPS (int32NDArray, octave_int32)
 
-SND_CMP_OPS (octave_int32, , int32NDArray, )
+SND_CMP_OPS (octave_int32, int32NDArray)
 SND_BOOL_OPS (octave_int32, int32NDArray)
 
-NDND_CMP_OPS (int32NDArray, , int32NDArray, )
+NDND_CMP_OPS (int32NDArray, int32NDArray)
 NDND_BOOL_OPS (int32NDArray, int32NDArray)
 
 MINMAX_FCNS (int32)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/int64NDArray.cc b/liboctave/int64NDArray.cc
--- a/liboctave/int64NDArray.cc
+++ b/liboctave/int64NDArray.cc
@@ -34,23 +34,23 @@ template class OCTAVE_API intNDArray<oct
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_int64>& a);
 
 template OCTAVE_API
 std::istream&
 operator >> (std::istream& is, intNDArray<octave_int64>& a);
 
-NDS_CMP_OPS (int64NDArray, , octave_int64, )
+NDS_CMP_OPS (int64NDArray, octave_int64)
 NDS_BOOL_OPS (int64NDArray, octave_int64)
 
-SND_CMP_OPS (octave_int64, , int64NDArray, )
+SND_CMP_OPS (octave_int64, int64NDArray)
 SND_BOOL_OPS (octave_int64, int64NDArray)
 
-NDND_CMP_OPS (int64NDArray, , int64NDArray, )
+NDND_CMP_OPS (int64NDArray, int64NDArray)
 NDND_BOOL_OPS (int64NDArray, int64NDArray)
 
 MINMAX_FCNS (int64)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/int8NDArray.cc b/liboctave/int8NDArray.cc
--- a/liboctave/int8NDArray.cc
+++ b/liboctave/int8NDArray.cc
@@ -34,23 +34,23 @@ template class OCTAVE_API intNDArray<oct
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_int8>& a);
 
 template OCTAVE_API
 std::istream&
 operator >> (std::istream& is, intNDArray<octave_int8>& a);
 
-NDS_CMP_OPS (int8NDArray, , octave_int8, )
+NDS_CMP_OPS (int8NDArray, octave_int8)
 NDS_BOOL_OPS (int8NDArray, octave_int8)
 
-SND_CMP_OPS (octave_int8, , int8NDArray, )
+SND_CMP_OPS (octave_int8, int8NDArray)
 SND_BOOL_OPS (octave_int8, int8NDArray)
 
-NDND_CMP_OPS (int8NDArray, , int8NDArray, )
+NDND_CMP_OPS (int8NDArray, int8NDArray)
 NDND_BOOL_OPS (int8NDArray, int8NDArray)
 
 MINMAX_FCNS (int8)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/mk-ops.awk b/liboctave/mk-ops.awk
--- a/liboctave/mk-ops.awk
+++ b/liboctave/mk-ops.awk
@@ -217,48 +217,18 @@ BEGIN {
 		        lhs_type, rhs_type, result_scalar_zero_val) >> cc_file
               else
                 printf ("%s%s_BIN_OPS (%s, %s, %s)\n",
 		        lhs_class, rhs_class, result_type,
 			lhs_type, rhs_type) >> cc_file
             }
 
           if (cmp_ops)
-	    {
-	      if (lhs_class == "S" || rhs_class == "S")
-	        {
-		  if (lhs_core_type)
-		    {
-		      if (rhs_core_type)
-			printf ("%s%s_CMP_OPS2 (%s, %s, %s, %s, %s, %s)\n",
-				lhs_class, rhs_class, lhs_type, lhs_conv,
-				rhs_type, rhs_conv,
-				lhs_core_type, rhs_core_type) >> cc_file
-		      else
-			printf ("%s%s_CMP_OPS1 (%s, %s, %s, %s, %s)\n",
-				lhs_class, rhs_class, lhs_type, lhs_conv,
-				rhs_type, rhs_conv, lhs_core_type) >> cc_file
-		    }
-		  else
-		    {
-		      if (rhs_core_type)
-			printf ("%s%s_CMP_OPS1 (%s, %s, %s, %s, %s)\n",
-				lhs_class, rhs_class, lhs_type, lhs_conv,
-				rhs_type, rhs_conv, rhs_core_type) >> cc_file
-		      else
-			printf ("%s%s_CMP_OPS (%s, %s, %s, %s)\n",
-				lhs_class, rhs_class, lhs_type, lhs_conv,
-				rhs_type, rhs_conv) >> cc_file
-		    }
-		}
-	      else
-		printf ("%s%s_CMP_OPS (%s, %s, %s, %s)\n",
-			lhs_class, rhs_class, lhs_type, lhs_conv,
-			rhs_type, rhs_conv) >> cc_file
-	    }
+	     printf ("%s%s_CMP_OPS (%s, %s)\n",
+		     lhs_class, rhs_class, lhs_type, rhs_type) >> cc_file
 
           if (bool_ops)
             printf ("%s%s_BOOL_OPS (%s, %s)\n", lhs_class, rhs_class,
 	            lhs_type, rhs_type) >> cc_file
 
 
           close (cc_file);
         }
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -99,30 +99,16 @@ inline void F (size_t n, bool *r, X x, c
 
 DEFMXCMPOP (mx_inline_lt, <)
 DEFMXCMPOP (mx_inline_le, <=)
 DEFMXCMPOP (mx_inline_gt, >)
 DEFMXCMPOP (mx_inline_ge, >=)
 DEFMXCMPOP (mx_inline_eq, ==)
 DEFMXCMPOP (mx_inline_ne, !=)
 
-// For compatibility with certain loserware, cmp ops on complex nums only
-// compare real parts, although "sort" defines ordering on complex numbers!
-
-#define DEFCMPLXCMOP(F, OP) \
-template <class X, class Y> \
-inline void F (size_t n, bool *r, const std::complex<X> *x, const Y *y) \
-{ for (size_t i = 0; i < n; i++) r[i] = real (x[i]) OP real (y[i]); } \
-template <class X, class Y> \
-inline void F (size_t n, bool *r, const std::complex<X> *x, Y y) \
-{ for (size_t i = 0; i < n; i++) r[i] = real (x[i]) OP y; } \
-template <class X, class Y> \
-inline void F (size_t n, bool *r, X x, const std::complex<Y> *y) \
-{ for (size_t i = 0; i < n; i++) r[i] = x OP real (y[i]); }
-
 // Convert to logical value, for logical op purposes.
 template <class T> inline bool logical_value (T x) { return x; }
 template <class T> inline bool logical_value (const octave_int<T>& x) 
 { return x.value (); }
 
 // NaNs in real data should generate an error. Doing it on-the-fly is faster.
 
 #define DEFLOGCHKNAN(ARG, ZERO) \
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -112,44 +112,30 @@ along with Octave; see the file COPYING.
   }
 
 #define MS_BIN_OPS(R, M, S) \
   MS_BIN_OP (R, operator +, M, S, mx_inline_add) \
   MS_BIN_OP (R, operator -, M, S, mx_inline_sub) \
   MS_BIN_OP (R, operator *, M, S, mx_inline_mul) \
   MS_BIN_OP (R, operator /, M, S, mx_inline_div)
 
-#define MS_CMP_OP(F, OP, M, MC, S, SC) \
+#define MS_CMP_OP(F, OP, M, S) \
   boolMatrix \
   F (const M& m, const S& s) \
   { \
-    boolMatrix r; \
- \
-    octave_idx_type nr = m.rows (); \
-    octave_idx_type nc = m.cols (); \
- \
-    r.resize (nr, nc); \
- \
-    if (nr > 0 && nc > 0) \
-      { \
-        for (octave_idx_type j = 0; j < nc; j++) \
-          for (octave_idx_type i = 0; i < nr; i++) \
-	    r.elem(i, j) = MC (m.elem(i, j)) OP SC (s); \
-      } \
- \
-    return r; \
+    return do_ms_binary_op<boolMatrix, M, S> (m, s, OP); \
   }
 
-#define MS_CMP_OPS(M, CM, S, CS) \
-  MS_CMP_OP (mx_el_lt, <,  M, CM, S, CS) \
-  MS_CMP_OP (mx_el_le, <=, M, CM, S, CS) \
-  MS_CMP_OP (mx_el_ge, >=, M, CM, S, CS) \
-  MS_CMP_OP (mx_el_gt, >,  M, CM, S, CS) \
-  MS_CMP_OP (mx_el_eq, ==, M,   , S,   ) \
-  MS_CMP_OP (mx_el_ne, !=, M,   , S,   )
+#define MS_CMP_OPS(M, S) \
+  MS_CMP_OP (mx_el_lt, mx_inline_lt, M, S) \
+  MS_CMP_OP (mx_el_le, mx_inline_le, M, S) \
+  MS_CMP_OP (mx_el_ge, mx_inline_ge, M, S) \
+  MS_CMP_OP (mx_el_gt, mx_inline_gt, M, S) \
+  MS_CMP_OP (mx_el_eq, mx_inline_eq, M, S) \
+  MS_CMP_OP (mx_el_ne, mx_inline_ne, M, S)
 
 #define MS_BOOL_OP(F, OP, M, S) \
   boolMatrix \
   F (const M& m, const S& s) \
   { \
     return do_ms_binary_op<boolMatrix, M, S> (m, s, OP); \
   }
 
@@ -167,44 +153,30 @@ along with Octave; see the file COPYING.
   }
 
 #define SM_BIN_OPS(R, S, M) \
   SM_BIN_OP (R, operator +, S, M, mx_inline_add) \
   SM_BIN_OP (R, operator -, S, M, mx_inline_sub) \
   SM_BIN_OP (R, operator *, S, M, mx_inline_mul) \
   SM_BIN_OP (R, operator /, S, M, mx_inline_div)
 
-#define SM_CMP_OP(F, OP, S, SC, M, MC) \
+#define SM_CMP_OP(F, OP, S, M) \
   boolMatrix \
   F (const S& s, const M& m) \
   { \
-    boolMatrix r; \
- \
-    octave_idx_type nr = m.rows (); \
-    octave_idx_type nc = m.cols (); \
- \
-    r.resize (nr, nc); \
- \
-    if (nr > 0 && nc > 0) \
-      { \
-        for (octave_idx_type j = 0; j < nc; j++) \
-          for (octave_idx_type i = 0; i < nr; i++) \
-	    r.elem(i, j) = SC (s) OP MC (m.elem(i, j)); \
-      } \
- \
-    return r; \
+    return do_sm_binary_op<boolMatrix, S, M> (s, m, OP); \
   }
 
-#define SM_CMP_OPS(S, CS, M, CM) \
-  SM_CMP_OP (mx_el_lt, <,  S, CS, M, CM) \
-  SM_CMP_OP (mx_el_le, <=, S, CS, M, CM) \
-  SM_CMP_OP (mx_el_ge, >=, S, CS, M, CM) \
-  SM_CMP_OP (mx_el_gt, >,  S, CS, M, CM) \
-  SM_CMP_OP (mx_el_eq, ==, S,   , M,   ) \
-  SM_CMP_OP (mx_el_ne, !=, S,   , M,   )
+#define SM_CMP_OPS(S, M) \
+  SM_CMP_OP (mx_el_lt, mx_inline_lt, S, M) \
+  SM_CMP_OP (mx_el_le, mx_inline_le, S, M) \
+  SM_CMP_OP (mx_el_ge, mx_inline_ge, S, M) \
+  SM_CMP_OP (mx_el_gt, mx_inline_gt, S, M) \
+  SM_CMP_OP (mx_el_eq, mx_inline_eq, S, M) \
+  SM_CMP_OP (mx_el_ne, mx_inline_ne, S, M)
 
 #define SM_BOOL_OP(F, OP, S, M) \
   boolMatrix \
   F (const S& s, const M& m) \
   { \
     return do_sm_binary_op<boolMatrix, S, M> (s, m, OP); \
   }
 
@@ -222,49 +194,30 @@ along with Octave; see the file COPYING.
   }
 
 #define MM_BIN_OPS(R, M1, M2) \
   MM_BIN_OP (R, operator +, M1, M2, mx_inline_add) \
   MM_BIN_OP (R, operator -, M1, M2, mx_inline_sub) \
   MM_BIN_OP (R, product,    M1, M2, mx_inline_mul) \
   MM_BIN_OP (R, quotient,   M1, M2, mx_inline_div)
 
-#define MM_CMP_OP(F, OP, M1, C1, M2, C2) \
+#define MM_CMP_OP(F, OP, M1, M2) \
   boolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
-    boolMatrix r; \
- \
-    octave_idx_type m1_nr = m1.rows (); \
-    octave_idx_type m1_nc = m1.cols (); \
- \
-    octave_idx_type m2_nr = m2.rows (); \
-    octave_idx_type m2_nc = m2.cols (); \
- \
-    if (m1_nr == m2_nr && m1_nc == m2_nc) \
-      { \
-	r.resize (m1_nr, m1_nc); \
- \
-	for (octave_idx_type j = 0; j < m1_nc; j++) \
-	  for (octave_idx_type i = 0; i < m1_nr; i++) \
-	    r.elem(i, j) = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
-      } \
-    else \
-      gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
- \
-    return r; \
+    return do_mm_binary_op<boolMatrix, M1, M2> (m1, m2, OP, #F); \
   }
 
-#define MM_CMP_OPS(M1, C1, M2, C2) \
-  MM_CMP_OP (mx_el_lt, <,  M1, C1, M2, C2) \
-  MM_CMP_OP (mx_el_le, <=, M1, C1, M2, C2) \
-  MM_CMP_OP (mx_el_ge, >=, M1, C1, M2, C2) \
-  MM_CMP_OP (mx_el_gt, >,  M1, C1, M2, C2) \
-  MM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
-  MM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
+#define MM_CMP_OPS(M1, M2) \
+  MM_CMP_OP (mx_el_lt, mx_inline_lt, M1, M2) \
+  MM_CMP_OP (mx_el_le, mx_inline_le, M1, M2) \
+  MM_CMP_OP (mx_el_ge, mx_inline_ge, M1, M2) \
+  MM_CMP_OP (mx_el_gt, mx_inline_gt, M1, M2) \
+  MM_CMP_OP (mx_el_eq, mx_inline_eq, M1, M2) \
+  MM_CMP_OP (mx_el_ne, mx_inline_ne, M1, M2)
 
 #define MM_BOOL_OP(F, OP, M1, M2) \
   boolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     return do_mm_binary_op<boolMatrix, M1, M2> (m1, m2, OP, #F); \
   }
 
@@ -282,91 +235,30 @@ along with Octave; see the file COPYING.
   }
 
 #define NDS_BIN_OPS(R, ND, S) \
   NDS_BIN_OP (R, operator +, ND, S, mx_inline_add) \
   NDS_BIN_OP (R, operator -, ND, S, mx_inline_sub) \
   NDS_BIN_OP (R, operator *, ND, S, mx_inline_mul) \
   NDS_BIN_OP (R, operator /, ND, S, mx_inline_div)
 
-#define NDS_CMP_OP(F, OP, ND, NDC, S, SC) \
-  boolNDArray \
-  F (const ND& m, const S& s) \
-  { \
-    boolNDArray r (m.dims ()); \
- \
-    octave_idx_type len = m.length (); \
- \
-    if (s == S ()) \
-      { \
-        for (octave_idx_type i = 0; i < len; i++) \
-        r.xelem(i) = NDC (m.elem(i)) OP SC (S ()); \
-      } \
-    else \
-      { \
-        for (octave_idx_type i = 0; i < len; i++) \
-          r.xelem(i) = NDC (m.elem(i)) OP SC (s); \
-      } \
- \
-    return r; \
-  }
-
-#define NDS_CMP_OPS(ND, NDC, S, SC) \
-  NDS_CMP_OP (mx_el_lt, <,  ND, NDC, S, SC) \
-  NDS_CMP_OP (mx_el_le, <=, ND, NDC, S, SC) \
-  NDS_CMP_OP (mx_el_ge, >=, ND, NDC, S, SC) \
-  NDS_CMP_OP (mx_el_gt, >,  ND, NDC, S, SC) \
-  NDS_CMP_OP (mx_el_eq, ==, ND,    , S,   ) \
-  NDS_CMP_OP (mx_el_ne, !=, ND,    , S,   )
-
-#define NDS_CMP_OP1(F, OP, ND, NDC, S, SC, SPEC) \
+#define NDS_CMP_OP(F, OP, ND, S) \
   boolNDArray \
   F (const ND& m, const S& s) \
   { \
-    boolNDArray r (m.dims ()); \
- \
-    octave_idx_type len = m.length (); \
- \
-    for (octave_idx_type i = 0; i < len; i++) \
-      r.elem(i) = operator OP <SPEC> (NDC (m.elem(i)), SC (s)); \
- \
-    return r; \
+    return do_ms_binary_op<boolNDArray, ND, S> (m, s, OP); \
   }
 
-#define NDS_CMP_OPS1(ND, NDC, S, SC, SPEC) \
-  NDS_CMP_OP1 (mx_el_lt, <,  ND, NDC, S, SC, SPEC) \
-  NDS_CMP_OP1 (mx_el_le, <=, ND, NDC, S, SC, SPEC) \
-  NDS_CMP_OP1 (mx_el_ge, >=, ND, NDC, S, SC, SPEC) \
-  NDS_CMP_OP1 (mx_el_gt, >,  ND, NDC, S, SC, SPEC) \
-  NDS_CMP_OP1 (mx_el_eq, ==, ND,    , S,   , SPEC) \
-  NDS_CMP_OP1 (mx_el_ne, !=, ND,    , S,   , SPEC)
-
-#define NDS_CMP_OP2(F, OP, ND, NDC, S, SC, SPEC1, SPEC2) \
-  boolNDArray \
-  F (const ND& m, const S& s) \
-  { \
-    boolNDArray r; \
- \
-    octave_idx_type len = m.length (); \
- \
-    r.resize (m.dims ()); \
- \
-    for (octave_idx_type i = 0; i < len; i++) \
-      r.elem(i) = operator OP <SPEC1,SPEC2> (NDC (m.elem(i)), SC (s)); \
- \
-    return r; \
-  }
-
-#define NDS_CMP_OPS2(ND, NDC, S, SC, SPEC1, SPEC2) \
-  NDS_CMP_OP2 (mx_el_lt, <,  ND, NDC, S, SC, SPEC1, SPEC2) \
-  NDS_CMP_OP2 (mx_el_le, <=, ND, NDC, S, SC, SPEC1, SPEC2) \
-  NDS_CMP_OP2 (mx_el_ge, >=, ND, NDC, S, SC, SPEC1, SPEC2) \
-  NDS_CMP_OP2 (mx_el_gt, >,  ND, NDC, S, SC, SPEC1, SPEC2) \
-  NDS_CMP_OP2 (mx_el_eq, ==, ND,    , S,   , SPEC1, SPEC2) \
-  NDS_CMP_OP2 (mx_el_ne, !=, ND,    , S,   , SPEC1, SPEC2)
+#define NDS_CMP_OPS(ND, S) \
+  NDS_CMP_OP (mx_el_lt, mx_inline_lt, ND, S) \
+  NDS_CMP_OP (mx_el_le, mx_inline_le, ND, S) \
+  NDS_CMP_OP (mx_el_ge, mx_inline_ge, ND, S) \
+  NDS_CMP_OP (mx_el_gt, mx_inline_gt, ND, S) \
+  NDS_CMP_OP (mx_el_eq, mx_inline_eq, ND, S) \
+  NDS_CMP_OP (mx_el_ne, mx_inline_ne, ND, S)
 
 #define NDS_BOOL_OP(F, OP, ND, S) \
   boolNDArray \
   F (const ND& m, const S& s) \
   { \
     return do_ms_binary_op<boolNDArray, ND, S> (m, s, OP); \
   }
 
@@ -388,89 +280,30 @@ along with Octave; see the file COPYING.
   }
 
 #define SND_BIN_OPS(R, S, ND) \
   SND_BIN_OP (R, operator +, S, ND, mx_inline_add) \
   SND_BIN_OP (R, operator -, S, ND, mx_inline_sub) \
   SND_BIN_OP (R, operator *, S, ND, mx_inline_mul) \
   SND_BIN_OP (R, operator /, S, ND, mx_inline_div)
 
-#define SND_CMP_OP(F, OP, S, SC, ND, NDC) \
-  boolNDArray \
-  F (const S& s, const ND& m) \
-  { \
-    boolNDArray r (m.dims ()); \
- \
-    octave_idx_type len = m.length (); \
- \
-    if (s == S ()) \
-      { \
-        for (octave_idx_type i = 0; i < len; i++) \
-        r.xelem(i) = SC (S ()) OP NDC (m.elem(i)); \
-      } \
-    else \
-      { \
-        for (octave_idx_type i = 0; i < len; i++) \
-          r.xelem(i) = SC (s) OP NDC (m.elem(i)); \
-      } \
- \
-    return r; \
-  }
-
-#define SND_CMP_OPS(S, CS, ND, CND) \
-  SND_CMP_OP (mx_el_lt, <,  S, CS, ND, CND) \
-  SND_CMP_OP (mx_el_le, <=, S, CS, ND, CND) \
-  SND_CMP_OP (mx_el_ge, >=, S, CS, ND, CND) \
-  SND_CMP_OP (mx_el_gt, >,  S, CS, ND, CND) \
-  SND_CMP_OP (mx_el_eq, ==, S,   , ND,    ) \
-  SND_CMP_OP (mx_el_ne, !=, S,   , ND,    )
-
-#define SND_CMP_OP1(F, OP, S, SC, ND, NDC, SPEC) \
+#define SND_CMP_OP(F, OP, S, ND) \
   boolNDArray \
   F (const S& s, const ND& m) \
   { \
-    boolNDArray r (m.dims ()); \
- \
-    octave_idx_type len = m.length (); \
- \
-    for (octave_idx_type i = 0; i < len; i++) \
-      r.elem(i) = operator OP <SPEC> (SC (s), NDC (m.elem(i))); \
- \
-    return r; \
+    return do_sm_binary_op<boolNDArray, S, ND> (s, m, OP); \
   }
 
-#define SND_CMP_OPS1(S, CS, ND, CND, SPEC) \
-  SND_CMP_OP1 (mx_el_lt, <,  S, CS, ND, CND, SPEC) \
-  SND_CMP_OP1 (mx_el_le, <=, S, CS, ND, CND, SPEC) \
-  SND_CMP_OP1 (mx_el_ge, >=, S, CS, ND, CND, SPEC) \
-  SND_CMP_OP1 (mx_el_gt, >,  S, CS, ND, CND, SPEC) \
-  SND_CMP_OP1 (mx_el_eq, ==, S,   , ND,    , SPEC) \
-  SND_CMP_OP1 (mx_el_ne, !=, S,   , ND,    , SPEC)
-
-#define SND_CMP_OP2(F, OP, S, SC, ND, NDC, SPEC1, SPEC2) \
-  boolNDArray \
-  F (const S& s, const ND& m) \
-  { \
-    boolNDArray r (m.dims ()); \
- \
-    octave_idx_type len = m.length (); \
- \
-    for (octave_idx_type i = 0; i < len; i++) \
-      r.elem(i) = operator OP <SPEC1, SPEC2> (SC (s), NDC (m.elem(i))); \
- \
-    return r; \
-  }
-
-#define SND_CMP_OPS2(S, CS, ND, CND, SPEC1, SPEC2) \
-  SND_CMP_OP2 (mx_el_lt, <,  S, CS, ND, CND, SPEC1, SPEC2) \
-  SND_CMP_OP2 (mx_el_le, <=, S, CS, ND, CND, SPEC1, SPEC2) \
-  SND_CMP_OP2 (mx_el_ge, >=, S, CS, ND, CND, SPEC1, SPEC2) \
-  SND_CMP_OP2 (mx_el_gt, >,  S, CS, ND, CND, SPEC1, SPEC2) \
-  SND_CMP_OP2 (mx_el_eq, ==, S,   , ND,    , SPEC1, SPEC2) \
-  SND_CMP_OP2 (mx_el_ne, !=, S,   , ND,    , SPEC1, SPEC2)
+#define SND_CMP_OPS(S, ND) \
+  SND_CMP_OP (mx_el_lt, mx_inline_lt, S, ND) \
+  SND_CMP_OP (mx_el_le, mx_inline_le, S, ND) \
+  SND_CMP_OP (mx_el_ge, mx_inline_ge, S, ND) \
+  SND_CMP_OP (mx_el_gt, mx_inline_gt, S, ND) \
+  SND_CMP_OP (mx_el_eq, mx_inline_eq, S, ND) \
+  SND_CMP_OP (mx_el_ne, mx_inline_ne, S, ND)
 
 #define SND_BOOL_OP(F, OP, S, ND) \
   boolNDArray \
   F (const S& s, const ND& m) \
   { \
     return do_sm_binary_op<boolNDArray, S, ND> (s, m, OP); \
   }
 
@@ -492,45 +325,30 @@ along with Octave; see the file COPYING.
   }
 
 #define NDND_BIN_OPS(R, ND1, ND2) \
   NDND_BIN_OP (R, operator +, ND1, ND2, mx_inline_add) \
   NDND_BIN_OP (R, operator -, ND1, ND2, mx_inline_sub) \
   NDND_BIN_OP (R, product,    ND1, ND2, mx_inline_mul) \
   NDND_BIN_OP (R, quotient,   ND1, ND2, mx_inline_div)
 
-#define NDND_CMP_OP(F, OP, ND1, C1, ND2, C2) \
+#define NDND_CMP_OP(F, OP, ND1, ND2) \
   boolNDArray \
   F (const ND1& m1, const ND2& m2) \
   { \
-    boolNDArray r; \
- \
-    dim_vector m1_dims = m1.dims (); \
-    dim_vector m2_dims = m2.dims (); \
- \
-    if (m1_dims == m2_dims) \
-      { \
-	r = boolNDArray (m1_dims); \
- \
-	for (octave_idx_type i = 0; i < m1.length (); i++) \
-	  r.xelem(i) = C1 (m1.elem(i)) OP C2 (m2.elem(i)); \
-      } \
-    else \
-      gripe_nonconformant (#F, m1_dims, m2_dims); \
- \
-    return r; \
+    return do_mm_binary_op<boolNDArray, ND1, ND2> (m1, m2, OP, #F); \
   }
 
-#define NDND_CMP_OPS(ND1, C1, ND2, C2) \
-  NDND_CMP_OP (mx_el_lt, <,  ND1, C1, ND2, C2) \
-  NDND_CMP_OP (mx_el_le, <=, ND1, C1, ND2, C2) \
-  NDND_CMP_OP (mx_el_ge, >=, ND1, C1, ND2, C2) \
-  NDND_CMP_OP (mx_el_gt, >,  ND1, C1, ND2, C2) \
-  NDND_CMP_OP (mx_el_eq, ==, ND1,   , ND2,   ) \
-  NDND_CMP_OP (mx_el_ne, !=, ND1,   , ND2,   )
+#define NDND_CMP_OPS(ND1, ND2) \
+  NDND_CMP_OP (mx_el_lt, mx_inline_lt, ND1, ND2) \
+  NDND_CMP_OP (mx_el_le, mx_inline_le, ND1, ND2) \
+  NDND_CMP_OP (mx_el_ge, mx_inline_ge, ND1, ND2) \
+  NDND_CMP_OP (mx_el_gt, mx_inline_gt, ND1, ND2) \
+  NDND_CMP_OP (mx_el_eq, mx_inline_eq, ND1, ND2) \
+  NDND_CMP_OP (mx_el_ne, mx_inline_ne, ND1, ND2)
 
 #define NDND_BOOL_OP(F, OP, ND1, ND2) \
   boolNDArray \
   F (const ND1& m1, const ND2& m2) \
   { \
     return do_mm_binary_op<boolNDArray, ND1, ND2> (m1, m2, OP, #F); \
   }
 
diff --git a/liboctave/oct-cmplx.h b/liboctave/oct-cmplx.h
--- a/liboctave/oct-cmplx.h
+++ b/liboctave/oct-cmplx.h
@@ -24,33 +24,47 @@ along with Octave; see the file COPYING.
 #if !defined (octave_oct_cmplx_h)
 #define octave_oct_cmplx_h 1
 
 #include <complex>
 
 typedef std::complex<double> Complex;
 typedef std::complex<float> FloatComplex;
 
-// The default comparison of complex number is to compare by abs, then by arg.
-// FIXME: this could be speeded up significantly.
-template <class T>
-inline bool operator < (const std::complex<T>& a,
-                        const std::complex<T>& b)
-{
-  T ax = std::abs (a), bx = std::abs (b);
-  return ax < bx || (ax == bx && std::arg (a) < std::arg (b));
-}
+// For complex-complex and complex-real comparisons, we use the following ordering:
+// compare absolute values first; if they match, compare phase angles.
+// This is partially inconsistent with M*b, which compares complex numbers only
+// by their real parts; OTOH, it uses the same definition for max/min and sort.
+// The abs/arg comparison is definitely more useful (the other one is emulated rather
+// trivially), so let's be consistent and use that all over.
 
-template <class T>
-inline bool operator > (const std::complex<T>& a,
-                        const std::complex<T>& b)
-{
-  T ax = std::abs (a), bx = std::abs (b);
-  return ax > bx || (ax == bx && std::arg (a) > std::arg (b));
-}
+#define DEF_COMPLEXR_COMP(OP, OPS) \
+template <class T> \
+inline bool operator OP (const std::complex<T>& a, const std::complex<T>& b) \
+{ \
+  T ax = std::abs (a), bx = std::abs (b); \
+  return ax OPS bx || (ax == bx && std::arg (a) OP std::arg (b)); \
+} \
+template <class T> \
+inline bool operator OP (const std::complex<T>& a, T b) \
+{ \
+  T ax = std::abs (a); \
+  return ax OPS b || (ax == b && std::arg (a) OP 0); \
+} \
+template <class T> \
+inline bool operator OP (T a, const std::complex<T>& b) \
+{ \
+  T bx = std::abs (b); \
+  return a OPS bx || (a == bx && 0 OP std::arg (b)); \
+} \
+
+DEF_COMPLEXR_COMP (>, >)
+DEF_COMPLEXR_COMP (<, <)
+DEF_COMPLEXR_COMP (<=, <=)
+DEF_COMPLEXR_COMP (>=, >=)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/uint16NDArray.cc b/liboctave/uint16NDArray.cc
--- a/liboctave/uint16NDArray.cc
+++ b/liboctave/uint16NDArray.cc
@@ -34,23 +34,23 @@ template class OCTAVE_API intNDArray<oct
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_uint16>& a);
 
 template OCTAVE_API
 std::istream&
 operator >> (std::istream& is, intNDArray<octave_uint16>& a);
 
-NDS_CMP_OPS (uint16NDArray, , octave_uint16, )
+NDS_CMP_OPS (uint16NDArray, octave_uint16)
 NDS_BOOL_OPS (uint16NDArray, octave_uint16)
 
-SND_CMP_OPS (octave_uint16, , uint16NDArray, )
+SND_CMP_OPS (octave_uint16, uint16NDArray)
 SND_BOOL_OPS (octave_uint16, uint16NDArray)
 
-NDND_CMP_OPS (uint16NDArray, , uint16NDArray, )
+NDND_CMP_OPS (uint16NDArray, uint16NDArray)
 NDND_BOOL_OPS (uint16NDArray, uint16NDArray)
 
 MINMAX_FCNS (uint16)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/uint32NDArray.cc b/liboctave/uint32NDArray.cc
--- a/liboctave/uint32NDArray.cc
+++ b/liboctave/uint32NDArray.cc
@@ -34,23 +34,23 @@ template class OCTAVE_API intNDArray<oct
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_uint32>& a);
 
 template OCTAVE_API
 std::istream&
 operator >> (std::istream& is, intNDArray<octave_uint32>& a);
 
-NDS_CMP_OPS (uint32NDArray, , octave_uint32, )
+NDS_CMP_OPS (uint32NDArray, octave_uint32)
 NDS_BOOL_OPS (uint32NDArray, octave_uint32)
 
-SND_CMP_OPS (octave_uint32, , uint32NDArray, )
+SND_CMP_OPS (octave_uint32, uint32NDArray)
 SND_BOOL_OPS (octave_uint32, uint32NDArray)
 
-NDND_CMP_OPS (uint32NDArray, , uint32NDArray, )
+NDND_CMP_OPS (uint32NDArray, uint32NDArray)
 NDND_BOOL_OPS (uint32NDArray, uint32NDArray)
 
 MINMAX_FCNS (uint32)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/uint64NDArray.cc b/liboctave/uint64NDArray.cc
--- a/liboctave/uint64NDArray.cc
+++ b/liboctave/uint64NDArray.cc
@@ -34,23 +34,23 @@ template class OCTAVE_API intNDArray<oct
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_uint64>& a);
 
 template OCTAVE_API
 std::istream&
 operator >> (std::istream& is, intNDArray<octave_uint64>& a);
 
-NDS_CMP_OPS (uint64NDArray, , octave_uint64, )
+NDS_CMP_OPS (uint64NDArray, octave_uint64)
 NDS_BOOL_OPS (uint64NDArray, octave_uint64)
 
-SND_CMP_OPS (octave_uint64, , uint64NDArray, )
+SND_CMP_OPS (octave_uint64, uint64NDArray)
 SND_BOOL_OPS (octave_uint64, uint64NDArray)
 
-NDND_CMP_OPS (uint64NDArray, , uint64NDArray, )
+NDND_CMP_OPS (uint64NDArray, uint64NDArray)
 NDND_BOOL_OPS (uint64NDArray, uint64NDArray)
 
 MINMAX_FCNS (uint64)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/uint8NDArray.cc b/liboctave/uint8NDArray.cc
--- a/liboctave/uint8NDArray.cc
+++ b/liboctave/uint8NDArray.cc
@@ -34,23 +34,23 @@ template class OCTAVE_API intNDArray<oct
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_uint8>& a);
 
 template OCTAVE_API
 std::istream&
 operator >> (std::istream& is, intNDArray<octave_uint8>& a);
 
-NDS_CMP_OPS (uint8NDArray, , octave_uint8, )
+NDS_CMP_OPS (uint8NDArray, octave_uint8)
 NDS_BOOL_OPS (uint8NDArray, octave_uint8)
 
-SND_CMP_OPS (octave_uint8, , uint8NDArray, )
+SND_CMP_OPS (octave_uint8, uint8NDArray)
 SND_BOOL_OPS (octave_uint8, uint8NDArray)
 
-NDND_CMP_OPS (uint8NDArray, , uint8NDArray, )
+NDND_CMP_OPS (uint8NDArray, uint8NDArray)
 NDND_BOOL_OPS (uint8NDArray, uint8NDArray)
 
 MINMAX_FCNS (uint8)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
