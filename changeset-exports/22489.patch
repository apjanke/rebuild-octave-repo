# HG changeset patch
# User Rik <rik@octave.org>
# Date 1473894316 25200
#      Wed Sep 14 16:05:16 2016 -0700
# Node ID 93ea313301f948a2a6eac38e885d5bd971ae5440
# Parent  a666e3ee6af861c2354d28c4235ea03d61d12457
test: Add bug ids (<#####>) to BIST tests.

* bsxfun.cc, cellfun.cc, conv2.cc, data.cc, ellipj.cc, error.cc, file-io.cc,
graphics.cc, hash.cc, mappers.cc, max.cc, rand.cc, regexp.cc, symtab.cc,
chol.cc, gzip.cc, symbfact.cc, ov-cx-diag.cc, ov-fcn-handle.cc, ov-java.cc,
Sparse.cc, accumarray.m, bitset.m, fieldnames.m, inputParser.m, interp2.m,
interpft.m, num2str.m, postpad.m, prepad.m, rat.m, rectint.m, image.m,
imread.m, imwrite.m, importdata.m, strread.m, textread.m, orderfields.m, qp.m,
axis.m, legend.m, hist.m, residue.m, setdiff.m, fftshift.m, ifftshift.m,
nthroot.m, magic.m, median.m, quantile.m, base2dec.m, strsplit.m, datestr.m,
datevec.m:
test: Add bug ids (<#####>) to BIST tests.

diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -805,20 +805,20 @@ dimensionality as the other array.
 %!         assert (bsxfun (fun, f_type (x), f_type (y)), ...
 %!                 fun (f_type (x), f_type (y)));
 %!         assert (bsxfun (fun, f_type(y), f_type(x)), ...
 %!                 fun (f_type (y), f_type (x)));
 %!     endfor
 %!   endfor
 %! endfor
 
-## Automatic broadcasting with zero length dimensions (bug #47085)
-%!assert ([1 2 3] .+ zeros (0, 3), zeros (0, 3))
-%!assert (rand (3, 3, 1) .+ rand (3, 3, 0), zeros (3, 3, 0))
+## Automatic broadcasting with zero length dimensions
+%!assert <47085> ([1 2 3] .+ zeros (0, 3), zeros (0, 3))
+%!assert <47085> (rand (3, 3, 1) .+ rand (3, 3, 0), zeros (3, 3, 0))
 
-## In-place broadcasting with zero length dimensions (bug #47085)
-%!test
+## In-place broadcasting with zero length dimensions
+%!test <47085>
 %! a = zeros (0, 3);
 %! a .+= [1 2 3];
 %! assert (a, zeros (0, 3));
 
 */
 
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -974,21 +974,20 @@ v = cellfun (@@det, a); # faster
 %!assert (cellfun (@factorial,{-1,3},"ErrorHandler",@(x,y) NaN), [NaN,6])
 %!assert (cellfun (@(x) x(2),{[1],[1,2]},"ErrorHandler",@(x,y) NaN), [NaN,2])
 %!test
 %! [a,b,c] = cellfun (@fileparts, {fullfile("a","b","c.d"), fullfile("e","f","g.h")}, "UniformOutput", false);
 %! assert (a, {fullfile("a","b"), fullfile("e","f")});
 %! assert (b, {"c", "g"});
 %! assert (c, {".d", ".h"});
 
-## Tests for bug #40467
-%!assert (cellfun (@isreal, {1 inf nan []}), [true, true, true, true])
-%!assert (cellfun (@isreal, {1 inf nan []}, "UniformOutput", false), {true, true, true, true})
-%!assert (cellfun (@iscomplex, {1 inf nan []}), [false, false, false, false])
-%!assert (cellfun (@iscomplex, {1 inf nan []}, "UniformOutput", false), {false, false, false, false})
+%!assert <40467> (cellfun (@isreal, {1 inf nan []}), [true, true, true, true])
+%!assert <40467> (cellfun (@isreal, {1 inf nan []}, "UniformOutput", false), {true, true, true, true})
+%!assert <40467> (cellfun (@iscomplex, {1 inf nan []}), [false, false, false, false])
+%!assert <40467> (cellfun (@iscomplex, {1 inf nan []}, "UniformOutput", false), {false, false, false, false})
 
 %!error cellfun (1)
 %!error cellfun ("isclass", 1)
 %!error cellfun ("size", 1)
 %!error cellfun (@sin, {[]}, "BadParam", false)
 %!error cellfun (@sin, {[]}, "UniformOuput")
 %!error cellfun (@sin, {[]}, "ErrorHandler")
 */
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -250,20 +250,24 @@ When the third argument is a matrix, ret
 %!assert (conv2 (A,B, "same"), C(3:5,3:6))
 %!assert (conv2 (A,B, "valid"), zeros (0, 0))
 %!assert (size (conv2 (B,A, "valid")), [3 2])
 
 %% Clear shared variables so they are not reported for tests below
 %!shared
 
 %% Test cases from Bug #34893
-%!assert (conv2 ([1:5;1:5], [1:2], "same"), [4 7 10 13 10; 4 7 10 13 10])
-%!assert (conv2 ([1:5;1:5]', [1:2]', "same"), [4 7 10 13 10; 4 7 10 13 10]')
-%!assert (conv2 ([1:5;1:5], [1:2], "valid"), [4 7 10 13; 4 7 10 13])
-%!assert (conv2 ([1:5;1:5]', [1:2]', "valid"), [4 7 10 13; 4 7 10 13]')
+%!assert <34893> (conv2 ([1:5;1:5], [1:2], "same"),
+%!                [4 7 10 13 10; 4 7 10 13 10])
+%!assert <34893> (conv2 ([1:5;1:5]', [1:2]', "same"),
+%!                [4 7 10 13 10; 4 7 10 13 10]')
+%!assert <34893> (conv2 ([1:5;1:5], [1:2], "valid"),
+%!                [4 7 10 13; 4 7 10 13])
+%!assert <34893> (conv2 ([1:5;1:5]', [1:2]', "valid"),
+%!                [4 7 10 13; 4 7 10 13]')
 
 %!test
 %! rand ("seed", 42);
 %! x = rand (100);
 %! y = ones (5);
 %! A = conv2 (x, y)(5:end-4,5:end-4);
 %! B = conv2 (x, y, "valid");
 %! assert (B, A);   # Yes, this test is for *exact* equivalence.
@@ -372,18 +376,17 @@ The size of the result is @code{max (siz
           retval = convn (a, b, ct);
         }
     }
 
   return retval;
 }
 
 /*
-## Check for bug #39314
-%!test
+%!test <39314>
 %! v = reshape ([1 2], [1 1 2]);
 %! assert (convn (v, v), reshape ([1 4 4], [1 1 3]));
 %! assert (convn (v, v, "same"), reshape ([4 4], [1 1 2]));
 %! assert (convn (v, v, "valid"), 4);
 
 ## The following test may look weird since we are using the output
 ## of convn to test itself.  However, because calculations are done
 ## differently based on the shape option, it will help to catch some
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -553,18 +553,17 @@ and @var{e} is an integer.  If
 %! assert (f, [0,-0.5; 0.5,-0.5; Inf,-Inf]);
 %! assert (e(1:2,:), [0,1;2,3]);
 
 %!test
 %! [f, e] = log2 (complex (zeros (3, 2), [0,-1; 2,-4; Inf,-Inf]));
 %! assert (f, complex (zeros (3, 2), [0,-0.5; 0.5,-0.5; Inf,-Inf]));
 %! assert (e(1:2,:), [0,1; 2,3]);
 
-# bug #42583
-%!assert (all (log2 (pow2 (-1074:1023)) == -1074:1023))
+%!assert <42583> (all (log2 (pow2 (-1074:1023)) == -1074:1023))
 */
 
 DEFUN (rem, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} rem (@var{x}, @var{y})
 Return the remainder of the division @code{@var{x} / @var{y}}.
 
 The remainder is computed using the expression
@@ -720,22 +719,20 @@ periodic, @code{mod} is a better choice.
 %! y = rem (sparse ([11 11 11 11]), xs);
 %! assert (nnz (y), 3);
 %! assert (y, sparse (rem (11, 0:3)));
 %!test
 %! y = rem (sparse ([0 0 0 0]), xs);
 %! assert (nnz (y), 1);
 %! assert (y, sparse ([NaN 0 0 0]));
 
-## Bug #45587
-%!assert (signbit (rem (-0, 1)))
-%!assert (! signbit (rem (0, 1)))
-
-## bug #42627
-%!assert (rem (0.94, 0.01), 0.0)
+%!assert <45587> (signbit (rem (-0, 1)))
+%!assert <45587> (! signbit (rem (0, 1)))
+
+%!assert <42627> (rem (0.94, 0.01), 0.0)
 
 %!error rem (uint (8), int8 (5))
 %!error rem (uint8 ([1, 2]), uint8 ([3, 4, 5]))
 %!error rem ()
 %!error rem (1, 2, 3)
 %!error rem ([1, 2], [3, 4, 5])
 %!error rem (i, 1)
 */
@@ -901,22 +898,20 @@ negative numbers or when the values are 
 %!assert (mod (uint8 (5), 4), uint8 (1))
 %!assert (mod (5, uint8 (4)), uint8 (1))
 %!assert (mod (uint8 ([1:5]), 4), uint8 ([1,2,3,0,1]))
 
 ## non-integer real numbers
 %!assert (mod (2.1, 0.1), 0)
 %!assert (mod (2.1, 0.2), 0.1, eps)
 
-## Bug #45587
-%!assert (signbit (mod (-0, 0)))
-%!assert (! signbit (mod (0, -0)))
-
-## Bug #42627
-%!assert (mod (0.94, 0.01), 0.0)
+%!assert <45587> (signbit (mod (-0, 0)))
+%!assert <45587> (! signbit (mod (0, -0)))
+
+%!assert <42627> (mod (0.94, 0.01), 0.0)
 */
 
 // FIXME: Macros NATIVE_REDUCTION_1 and NATIVE_REDUCTION seem to be unused.
 //        Checked 1/23/2016.  They should probably be removed for clarity.
 // FIXME: Need to convert reduction functions of this file for single precision
 
 #define NATIVE_REDUCTION_1(FCN, TYPE, DIM)              \
   (arg.is_ ## TYPE ## _type ())                         \
@@ -1419,20 +1414,19 @@ Given a matrix argument, instead of a ve
 %!assert (diag (int8 ([1; 2; 3]), 2), int8 ([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]))
 %!assert (diag (int8 ([1; 2; 3]),-1), int8 ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]))
 %!assert (diag (int8 ([1; 2; 3]),-2), int8 ([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]))
 
 %!assert (diag (int8 ([1, 0, 0; 0, 2, 0; 0, 0, 3])), int8 ([1; 2; 3]))
 %!assert (diag (int8 ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), int8 ([1; 2; 3]))
 %!assert (diag (int8 ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), int8 ([1; 2; 3]))
 
-## bug #37411
-%!assert (diag (diag ([5, 2, 3])(:,1)), diag([5 0 0 ]))
-%!assert (diag (diag ([5, 2, 3])(:,1), 2),  [0 0 5 0 0; zeros(4, 5)])
-%!assert (diag (diag ([5, 2, 3])(:,1), -2), [[0 0 5 0 0]', zeros(5, 4)])
+%!assert <37411> (diag (diag ([5, 2, 3])(:,1)), diag([5 0 0 ]))
+%!assert <37411> (diag (diag ([5, 2, 3])(:,1), 2),  [0 0 5 0 0; zeros(4, 5)])
+%!assert <37411> (diag (diag ([5, 2, 3])(:,1), -2), [[0 0 5 0 0]', zeros(5, 4)])
 
 ## Test non-square size
 %!assert (diag ([1,2,3], 6, 3), [1 0 0; 0 2 0; 0 0 3; 0 0 0; 0 0 0; 0 0 0])
 %!assert (diag (1, 2, 3), [1,0,0; 0,0,0])
 %!assert (diag ({1}, 2, 3), {1,[],[]; [],[],[]})
 %!assert (diag ({1,2}, 3, 4), {1,[],[],[]; [],2,[],[]; [],[],[],[]})
 
 ## Test out-of-range diagonals
@@ -4255,17 +4249,17 @@ val = ones (m,n, "uint8")
 %!assert (size (ones (3, 4, 5, "int8")), [3, 4, 5])
 */
 
 /*
 ## Tests for bug #47298
 ## Matlab requires the size to be a row vector.  In that logic, it supports
 ## n to be a 1x0 vector (returns 0x0) but not a 0x1 vector.  Octave supports
 ## any vector and therefore must support 0x1, 1x0, and 0x0x1 (but not 0x1x1).
-%!test
+%!test <47298>
 %! funcs = {@zeros, @ones, @inf, @nan, @NA, @i, @pi, @e};
 %! for idx = 1:numel (funcs)
 %!   func = funcs{idx};
 %!   assert (func (zeros (1, 0)), zeros (0, 0));
 %!   assert (func (zeros (0, 1)), zeros (0, 0));
 %!   assert (func (zeros (0, 1, 1)), zeros (0, 0));
 %!   fail ([func2str(func) " ([])"]);
 %!   fail ([func2str(func) " (zeros (0, 0, 1))"]);
@@ -5752,18 +5746,18 @@ compute the norms of each column and ret
 %!assert (norm (q, "fro", "rows"), sqrt (sumsq (q, 2)), sqrt (eps))
 %!assert (norm (q, "fro", "cols"), sqrt (sumsq (q, 1)), sqrt (eps))
 %!assert (norm (q, 3, "cols"), sum (q.^3, 1).^(1/3), sqrt (eps))
 %!assert (norm (q, "inf", "rows"), norm (q, Inf, "rows"))
 %!assert (norm (q, "inf", "cols"), norm (q, Inf, "cols"))
 %!assert (norm (q, [], "rows"), norm (q, 2, "rows"))
 %!assert (norm (q, [], "cols"), norm (q, 2, "cols"))
 
-%!test
-%! ## Test for norm returning NaN on sparse matrix (bug #30631)
+%!test <30631>
+%! ## Test for norm returning NaN on sparse matrix
 %! A = sparse (2,2);
 %! A(2,1) = 1;
 %! assert (norm (A), 1);
 */
 
 static octave_value
 unary_op_defun_body (octave_value::unary_op op,
                      const octave_value_list& args)
diff --git a/libinterp/corefcn/ellipj.cc b/libinterp/corefcn/ellipj.cc
--- a/libinterp/corefcn/ellipj.cc
+++ b/libinterp/corefcn/ellipj.cc
@@ -811,18 +811,18 @@ and 16.15), Dover, 1965.
 %!       0.9840560289645665155;
 %!       0.9307281387786906491;
 %!       0.8868188839812167635 ];
 %! [sn,cn,dn] = ellipj (u,m);
 %! assert (sn, S, 8*eps);
 %! assert (cn, C, 8*eps);
 %! assert (dn, D, 8*eps);
 
-%!test
-%! ## Test continuity of dn when cn is near zero (bug #43344)
+%!test <43344>
+%! ## Test continuity of dn when cn is near zero
 %! m = 0.5;
 %! u = ellipke (0.5);
 %! x = [-1e-3, -1e-12, 0, 1e-12, 1e-3];
 %! [~, ~, dn] = ellipj (u + x, m);
 %! D = 1/sqrt (2) * ones (size (x));
 %! assert (dn, D, 1e-6);
 
 %!error ellipj ()
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1724,19 +1724,17 @@ disable escape sequence expansion use a 
       if (nargout > 0)
         retval = prev_msg;
     }
 
   return retval;
 }
 
 /*
-## Test for (bug #45753)
-
-%!test
+%!test <45753>
 %! warning ("error");
 %! assert (! isempty (help ("warning")));
 */
 
 octave_value_list
 set_warning_state (const std::string& id, const std::string& state)
 {
   octave_value_list args;
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1741,88 +1741,87 @@ as the name of the function when reporti
 
 ## FIXME: This test fails (4/14/16)
 ### Test incomplete first data line
 #%!test
 #%! R = textscan (['Empty1' char(10)], 'Empty%d %f');
 #%! assert (R{1}, int32 (1));
 #%! assert (isempty (R{2}), true);
 
-## bug #37023
-%!test
+%!test <37023>
 %! data = textscan ("   1. 1 \n 2 3\n", '%f %f');
 %! assert (data{1}, [1; 2], 1e-15);
 %! assert (data{2}, [1; 3], 1e-15);
 
-## Whitespace test (bug #37333) using delimiter ";"
-%!test
+## Whitespace test using delimiter ";"
+%!test <37333>
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = "C:/code/meas;";
 %! tc{1, end+1} = " C:/code/sim;";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";");
 %! for k = 1:max (numel (c{1}), numel (tc))
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   rh = strtrim (rh);
 %!   assert (strcmp (lh, rh));
 %! endfor
 
-## Whitespace test (bug #37333), adding multipleDelimsAsOne true arg
-%!test
+## Whitespace test, adding multipleDelimsAsOne true arg
+%!test <37333>
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = " C:/code/meas;";
 %! tc{1, end+1} = "C:/code/sim;;";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";", "multipleDelimsAsOne", 1);
 %! for k = 1:max (numel (c{1}), numel (tc))
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   rh = strtrim (rh);
 %!   assert (strcmp (lh, rh));
 %! endfor
 
 ## Whitespace test (bug #37333), adding multipleDelimsAsOne false arg
-%!test
+%!test <37333>
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = " C:/code/meas;";
 %! tc{1, end+1} = "C:/code/sim;;";
 %! tc{1, end+1} = "";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";", "multipleDelimsAsOne", 0);
 %! for k = 1:max (numel (c{1}), numel (tc))
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   rh = strtrim (rh);
 %!   assert (strcmp (lh, rh));
 %! endfor
 
 ## Whitespace test (bug #37333) whitespace "" arg
-%!test
+%!test <37333>
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = " C:/code/meas;";
 %! tc{1, end+1} = "C:/code/sim;";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";", "whitespace", "");
 %! for k = 1:max (numel (c{1}), numel (tc))
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   assert (strcmp (lh, rh));
 %! endfor
 
 ## Whitespace test (bug #37333), whitespace " " arg
-%!test
+%!test <37333>
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = " C:/code/meas;";
 %! tc{1, end+1} = "C:/code/sim;";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";", "whitespace", " ");
 %! for k = 1:max (numel (c{1}), numel (tc))
 %!   lh = c{1}{k};
@@ -1930,31 +1929,29 @@ as the name of the function when reporti
 %! msg1 = "textscan: EndOfLine must be at most one character or '\\r\\n'";
 %! try
 %!   C = textscan (fid, "%f", "EndOfLine", 33);
 %! end_try_catch;
 %! fclose (fid);
 %! unlink (f);
 %! assert (msg1, lasterr);
 
-## Bug #41824
-%!assert (textscan ("123", "", "whitespace", " "){:}, 123);
-
-## Bug #42343-1, just test supplied emptyvalue
-%!assert (textscan (",NaN", "", "delimiter", "," ,"emptyValue" ,Inf),
-%!        {Inf, NaN})
-
-## Bug #42343-2, test padding with supplied emptyvalue
-%!test
+%!assert <41824> (textscan ("123", "", "whitespace", " "){:}, 123);
+
+## just test supplied emptyvalue
+%!assert <42343> (textscan (",NaN", "", "delimiter", "," ,"emptyValue" ,Inf),
+%!                {Inf, NaN})
+
+## test padding with supplied emptyvalue
+%!test <42343>
 %! c = textscan (",1,,4\nInf,  ,NaN\n", "", "delimiter", ",",
 %!               "emptyvalue", -10);
 %! assert (cell2mat (c), [-10, 1, -10, 4; Inf, -10, NaN, -10]);
 
-## Bug #42528
-%!test
+%!test <42528>
 %! assert (textscan ("1i", ""){1},  0+1i);
 %! C = textscan ("3, 2-4i, NaN\n -i, 1, 23.4+2.2i\n 1+1 1+1j", "",
 %!               "delimiter", ",");
 %! assert (cell2mat (C), [3+0i, 2-4i, NaN+0i; 0-i,  1+0i, 23.4+2.2i; 1 1 1+1i]);
 
 %!test
 %! ## TreatAsEmpty
 %! C = textscan ("1,2,3,NN,5,6\n", "%d%d%d%f", "delimiter", ",",
@@ -1975,18 +1972,17 @@ as the name of the function when reporti
 ## Single-quoted escape sequences
 %!test
 %! str = "11\t12\t13\r21\t22\t23";
 %! c = textscan (str, "", "delimiter", '\t', "EndOfLine", '\r');
 %! assert (c{1}', [11, 21]);
 %! assert (c{2}', [12, 22]);
 %! assert (c{3}', [13, 23]);
 
-## Bug #44750
-%!test
+%!test <44750>
 %! c = textscan ("/home/foo/", "%s", "delimiter", "/",
 %!               "MultipleDelimsAsOne", 1);
 %! assert (c{1}, {"home"; "foo"});
 
 ## FIXME: Test still fails (4/13/2016)?
 ## Allow cuddling %sliteral, but warn it is ambiguous
 #%!test
 #%! C = textscan ("abcxyz51\nxyz83\n##xyz101", "%s xyz %d");
@@ -1996,18 +1992,18 @@ as the name of the function when reporti
 ### Literals are not delimiters.
 
 ## Test for false positives in check for non-supported format specifiers
 %!test
 %! c = textscan ("Total: 32.5 % (of cm values)",
 %!               "Total: %f %% (of cm values)");
 %! assert (c{1}, 32.5, 1e-5);
 
-## Test various forms of string format specifiers (bug #45712)
-%!test
+## Test various forms of string format specifiers
+%!test <45712>
 %! str = "14 :1 z:2 z:3 z:5 z:11";
 %! C = textscan (str, "%f %s %*s %3s %*3s %f", "delimiter", ":");
 %! assert (C, {14, {"1 z"}, {"3 z"}, 11});
 
 ## Bit width, fixed width conversion specifiers
 %!test
 %! str2 = "123456789012345 ";
 %! str2 = [str2 str2 str2 str2 str2 str2 str2 str2];
@@ -2086,18 +2082,17 @@ as the name of the function when reporti
 ## [..] and [^..] containing delimiters
 %!test
 %! cr = "ab cd efguv wx1Any\na ce gx yz2Trailing\n   3Junk";
 %! C = textscan (cr, "%[ abcdefg] %*[^0123456789] %s", "delimiter", " \n",
 %!                   "whitespace", "");
 %! assert (C{1}, {"ab cd efg"; "a ce g"; "   "});
 %! assert (C{2}, {"1Any"; "2Trailing"; "3Junk"});
 
-## Bug #36464
-%!assert (textscan ("1 2 3 4 5 6", "%*n%n%*[^\n]"){1}, 2);
+%!assert <36464> (textscan ("1 2 3 4 5 6", "%*n%n%*[^\n]"){1}, 2);
 
 ## test %[]] and %[^]]
 %!test
 %! assert (textscan ("345]", "%*[123456]%[]]"){1}{1}, "]");
 %! assert (textscan ("345]", "%*[^]]%s"){1}{1}, "]");
 
 ## Test that "-i" checks the next two characters
 %!test
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -6963,17 +6963,17 @@ axes::properties::calc_ticks_and_lims (a
         {
           tmp_mticks(n*i+j) = tmp_ticks(i) + d * (j+1);
         }
     }
   mticks = tmp_mticks;
 }
 
 /*
-%!test  # Bug #45356
+%!test <45356>
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot (1:10);
 %!   xlim ([4.75, 8.5]);
 %!   tics = get (gca, "xtick");
 %!   assert (tics, [5 6 7 8]);
 %! unwind_protect_cleanup
 %!   close (hf);
diff --git a/libinterp/corefcn/hash.cc b/libinterp/corefcn/hash.cc
--- a/libinterp/corefcn/hash.cc
+++ b/libinterp/corefcn/hash.cc
@@ -193,29 +193,29 @@ hash ("md5", fileread (file));
 %!assert (hash ("sha384", ""),
 %!        ["38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc", ...
 %!         "7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b"]);
 %!assert (hash ("sha512", ""),
 %!        ["cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a", ...
 %!         "921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47", ...
 %!         "417a81a538327af927da3e"]);
 
-## Test special character behavior (bug #31689)
-%!assert (hash ("md2", "abc\0"), "5a636d615002a7874ac1c9e9a43361f7")
-%!assert (hash ("md4", "abc\0"), "0ee5201897ecb206c4eaba1d2da5224d")
-%!assert (hash ("md5", "abc\0"), "147a664a2ca9410911e61986d3f0d52a")
-%!assert (hash ("sha1", "abc\0"), "686483805ac47ca14e03514f7481a7973b401762")
-%!assert (hash ("sha224", "abc\0"),
+## Test special character behavior
+%!assert <31689> (hash ("md2", "abc\0"), "5a636d615002a7874ac1c9e9a43361f7")
+%!assert <31689> (hash ("md4", "abc\0"), "0ee5201897ecb206c4eaba1d2da5224d")
+%!assert <31689> (hash ("md5", "abc\0"), "147a664a2ca9410911e61986d3f0d52a")
+%!assert <31689> (hash ("sha1", "abc\0"), "686483805ac47ca14e03514f7481a7973b401762")
+%!assert <31689> (hash ("sha224", "abc\0"),
 %!        "fbc8e47920e108bb1d0b631d18b36ae9b1549d28362aa15ebe960cfb");
-%!assert (hash ("sha256", "abc\0"),
+%!assert <31689> (hash ("sha256", "abc\0"),
 %!        "dc1114cd074914bd872cc1f9a23ec910ea2203bc79779ab2e17da25782a624fc");
-%!assert (hash ("sha384", "abc\0"),
+%!assert <31689> (hash ("sha384", "abc\0"),
 %!        ["eba81f2dfba4ec60d3f786c89d91b08e6c0b63d55986874378e385", ...
 %!         "e6fac587cce7a520ca9437290fe626cbf75c855e17"]);
-%!assert (hash ("sha512", "abc\0"),
+%!assert <31689> (hash ("sha512", "abc\0"),
 %!        ["7ce05eda233e545a2d5c626862a5ddaafb09b9d8ec3bec08aa458b", ...
 %!         "7c9e7d939d84a57d5a20d8a9002983aabae2457b19c50ba326bf5b", ...
 %!         "081f75b41342f42c3383"]);
 
 ## Test equivalence to deprecated md5sum offering file hashing
 %!test
 %! tfile = tempname ();
 %! fid = fopen (tfile, "wb");
diff --git a/libinterp/corefcn/mappers.cc b/libinterp/corefcn/mappers.cc
--- a/libinterp/corefcn/mappers.cc
+++ b/libinterp/corefcn/mappers.cc
@@ -123,17 +123,17 @@ Compute the inverse cosine in radians fo
 %! exp = [rval - ival*i, rval + ival*i, rval - ival*i];
 %! assert (obs, exp, 2*eps);
 %! assert (acos ([2 0]),  [ival*i, pi/2], 2*eps);
 %! assert (acos ([2 0i]), [ival*i, pi/2], 2*eps);
 
 ## Test large magnitude arguments (bug #45507)
 ## FIXME: Test fails with older versions of libm. Try to detect and work
 ##        around this, or wait until working version of libm is widespread?
-%!xtest
+%!xtest <45507>
 %! x = [1, -1, i, -i] .* 1e150;
 %! v = [0, pi, pi/2, pi/2];
 %! assert (real (acos (x)), v);
 
 %!error acos ()
 %!error acos (1, 2)
 */
 
@@ -170,17 +170,17 @@ Compute the inverse hyperbolic cosine fo
 %! re = single (2.99822295029797);
 %! im = single (pi/2);
 %! assert (acosh (single (10i)), re + i*im, 5*eps ("single"));
 %! assert (acosh (single (-10i)), re - i*im, 5*eps ("single"));
 
 ## Test large magnitude arguments (bug #45507)
 ## FIXME: Test fails with older versions of libm. Try to detect and work
 ##        around this, or wait until working version of libm is widespread?
-%!xtest
+%!xtest <45507>
 %! x = [1, -1, i, -i] .* 1e150;
 %! v = [0, pi, pi/2, -pi/2];
 %! assert (imag (acosh (x)), v);
 
 %!error acosh ()
 %!error acosh (1, 2)
 */
 
@@ -291,17 +291,17 @@ Compute the inverse sine in radians for 
 %! exp = [-rval + ival*i, -rval - ival*i, -rval + ival*i];
 %! assert (obs, exp, 2*eps);
 %! assert (asin ([2 0]),  [rval - ival*i, 0], 2*eps);
 %! assert (asin ([2 0i]), [rval - ival*i, 0], 2*eps);
 
 ## Test large magnitude arguments (bug #45507)
 ## FIXME: Test fails with older versions of libm. Try to detect and work
 ##        around this, or wait until working version of libm is widespread?
-%!xtest
+%!xtest <45507>
 %! x = [1, -1, i, -i] .* 1e150;
 %! v = [pi/2, -pi/2, 0, -0];
 %! assert (real (asin (x)), v);
 
 %!error asin ()
 %!error asin (1, 2)
 */
 
@@ -327,17 +327,17 @@ Compute the inverse hyperbolic sine for 
 %!test
 %! v = single ([0, pi/2*i, 0, -pi/2*i]);
 %! x = single ([0, i, 0, -i]);
 %! assert (asinh (x), v,  sqrt (eps ("single")));
 
 ## Test large magnitude arguments (bug #45507)
 ## FIXME: Test fails with older versions of libm. Try to detect and work
 ##        around this, or wait until working version of libm is widespread?
-%!xtest
+%!xtest <45507>
 %! x = [1, -1, i, -i] .* 1e150;
 %! v = [0, 0, pi/2, -pi/2];
 %! assert (imag (asinh (x)), v);
 
 %!error asinh ()
 %!error asinh (1, 2)
 */
 
@@ -365,17 +365,17 @@ Compute the inverse tangent in radians f
 %! assert (atan (x), v, sqrt (eps));
 
 %!test
 %! v = single ([0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0]);
 %! x = single ([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
 %! assert (atan (x), v, sqrt (eps ("single")));
 
 ## Test large magnitude arguments (bug #44310, bug #45507)
-%!test
+%!test <44310>
 %! x = [1, -1, i, -i] .* 1e150;
 %! v = [pi/2, -pi/2, pi/2, -pi/2];
 %! assert (real (atan (x)), v);
 %! assert (imag (atan (x)), [0, 0, 0, 0], eps);
 
 %!error atan ()
 %!error atan (1, 2)
 */
@@ -400,17 +400,17 @@ Compute the inverse hyperbolic tangent f
 %! assert (atanh (x), v, sqrt (eps));
 
 %!test
 %! v = single ([0, 0]);
 %! x = single ([0, 0]);
 %! assert (atanh (x), v, sqrt (eps ("single")));
 
 ## Test large magnitude arguments (bug #44310, bug #45507)
-%!test
+%!test <44310>
 %! x = [1, -1, i, -i] .* 1e150;
 %! v = [pi/2, pi/2, pi/2, -pi/2];
 %! assert (imag (atanh (x)), v);
 %! assert (real (atanh (x)), [0, 0, 0, 0], eps);
 
 %!error atanh ()
 %!error atanh (1, 2)
 */
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -860,18 +860,19 @@ the first index of the maximum value(s).
 %!test
 %! x = sparse ([1, 2, 3, 4]);  y = fliplr (x);
 %! assert (max (x, y), sparse ([4 3 3 4]));
 %! assert (max (x, 3), sparse ([3 3 3 4]));
 %! assert (max (2, x), sparse ([2 2 3 4]));
 %! assert (max (x, 2.1i), sparse ([2.1i 2.1i 3 4]));
 
 ## Test for bug #40743
-%!assert (max (zeros (1,0), ones (1,1)), zeros (1,0))
-%!assert (max (sparse (zeros (1,0)), sparse (ones (1,1))), sparse (zeros (1,0)))
+%!assert <40743> (max (zeros (1,0), ones (1,1)), zeros (1,0))
+%!assert <40743> (max (sparse (zeros (1,0)), sparse (ones (1,1))),
+                  sparse (zeros (1,0)))
 
 %!error max ()
 %!error max (1, 2, 3, 4)
 %!error <DIM must be a valid dimension> max ([1 2; 3 4], [], -3)
 %!warning <second argument is ignored> max ([1 2 3 4], 2, 2);
 %!error <wrong type argument 'cell'> max ({1 2 3 4})
 %!error <cannot compute max \(cell, scalar\)> max ({1, 2, 3}, 2)
 
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -1160,18 +1160,18 @@ likely.
   // Now create an array object with a cached idx_vector.
   return ovl (new octave_matrix (r, idx_vector (idx)));
 }
 
 /*
 %!assert (sort (randperm (20)), 1:20)
 %!assert (length (randperm (20,10)), 10)
 
-## Test biggish N (bug #39378)
-%!assert (length (randperm (30000^2, 100000)), 100000)
+## Test biggish N
+%!assert <39378> (length (randperm (30000^2, 100000)), 100000)
 
 %!test
 %! rand ("seed", 0);
 %! for i = 1:100
 %!   p = randperm (305, 30);
 %!   assert (length (unique (p)), 30);
 %! endfor
 */
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -982,18 +982,18 @@ are zero or more @qcode{'b'} characters 
 %! assert (nm.last{1}, 'Davis');
 %! assert (nm.last{2}, 'Rogers');
 
 ## Tests for named tokens
 %!test
 %! ## Parenthesis in named token (ie (int)) causes a problem
 %! assert (regexp ('qwe int asd', ['(?<typestr>(int))'], 'names'), struct ('typestr', 'int'));
 
-%!test
-%! ## Mix of named and unnamed tokens can cause segfault (bug #35683)
+%!test <35683>
+%! ## Mix of named and unnamed tokens can cause segfault
 %! str = "abcde";
 %! ptn = '(?<T1>a)(\w+)(?<T2>d\w+)';
 %! tokens = regexp (str, ptn, "names");
 %! assert (isstruct (tokens) && numel (tokens) == 1);
 %! assert (tokens.T1, "a");
 %! assert (tokens.T2, "de");
 
 %!assert (regexp ("abc\nabc", '.'), [1:7])
@@ -1118,17 +1118,18 @@ are zero or more @qcode{'b'} characters 
 %!test
 %! [a, b] = regexp (str, "[o]+", "match", "split");
 %! assert (a, {"oo"});
 %! assert (b, {"f", " bar"});
 
 %!assert (regexp ("\n", '\n'), 1)
 %!assert (regexp ("\n", "\n"), 1)
 
-%!test  # Bug #45407, escape sequences are silently converted
+# Test escape sequences are silently converted
+%!test <45407> 
 %! assert (regexprep ('s', 's', 'x\.y'), 'x.y');
 %! assert (regexprep ('s', '(s)', 'x\$1y'), 'x$1y');
 %! assert (regexprep ('s', '(s)', 'x\\$1y'), 'x\sy');
 
 */
 
 DEFUN (regexpi, args, nargout,
        doc: /* -*- texinfo -*-
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1910,17 +1910,17 @@ Undocumented internal function.
 
 /*
 bug #34497: 'clear -f' does not work for command line functions
 
 This test relies on bar being a core function that is implemented in an m-file.
 If the first assert fails, this is no longer the case and the tests need to be
 updated to use some other function.
 
-%!assert (! strcmp (which ("bar"), ""))
+%!assert <34497> (! strcmp (which ("bar"), ""))
 
 %!function x = bar ()
 %!  x = 5;
 %!endfunction
 %!test
 %! assert (bar == 5);
 %! assert (strcmp (which ("bar"), ""));
 %! clear -f bar;
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -336,18 +336,17 @@ sparse matrices.
 %! assert (qd, sparse (eye (2)))
 %! assert (qv, [1 2])
 %!
 %! [rv, pv, qv] = chol (a, "Vector"); # check case sensitivity
 %! assert (r, rv, eps)
 %! assert (pd, pv)
 %! assert (qv, [1 2])
 
-%!testif HAVE_CHOLMOD
-%! ## Bug #42587
+%!testif HAVE_CHOLMOD <42587>
 %! A = sparse ([1 0 8;0 1 8;8 8 1]);
 %! [Q, p] = chol (A);
 %! assert (p != 0);
 
 %!error chol ()
 %!error <matrix must be positive definite> chol ([1, 2; 3, 4])
 %!error <requires square matrix> chol ([1, 2; 3, 4; 5, 6])
 %!error <optional arguments must be strings> chol (1, 2)
diff --git a/libinterp/dldfcn/gzip.cc b/libinterp/dldfcn/gzip.cc
--- a/libinterp/dldfcn/gzip.cc
+++ b/libinterp/dldfcn/gzip.cc
@@ -711,17 +711,17 @@ The optional output @var{filelist} is a 
 %!
 %!  md5_z = hash ("md5", fileread (z_file));
 %!  unlink_or_error (z_file);
 %!  uz_z_filelist = z.unzip (z_z_file);
 %!  assert (uz_z_filelist, {z_file}) # bug #48598
 %!  assert (exist (z_z_file), 2) # bug #48597
 %!  assert (hash ("md5", fileread (z_file)), md5_z)
 %!endfunction
-%!xtest run_test_function (@test_z_z)
+%!xtest run_test_function (@test_z_z) <48597>
 
 %!function test_xzip_dir (test_dir, z) # bug #43431
 %!  fpaths = fullfile (test_dir, {"test1", "test2", "test3"});
 %!  md5s = cell (1, 3);
 %!  for idx = 1:numel(fpaths)
 %!    create_file (fpaths{idx}, rand (100, 1));
 %!    md5s(idx) = hash ("md5", fileread (fpaths{idx}));
 %!  endfor
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -396,18 +396,18 @@ cleanup:
 %! assert (r, sparse (triu (true (3))));
 
 %!testif HAVE_CHOLMOD
 %! ## Test MODE "lower"
 %! A = sparse (magic (3));
 %! [~, ~, ~, ~, l] = symbfact (A, "sym", "lower");
 %! assert (l, sparse (tril (true (3))));
 
-%!testif HAVE_CHOLMOD
-%! ## Bug #42587, singular matrix
+%!testif HAVE_CHOLMOD <42587>
+%! ## singular matrix
 %! A = sparse ([1 0 8;0 1 8;8 8 1]);
 %! [count, h, parent, post, r] = symbfact (A);
 
 ## Test input validation
 %!testif HAVE_CHOLMOD
 %! fail ("symbfact ()");
 %! fail ("symbfact (1,2,3,4)");
 %! fail ("symbfact ({1})", "wrong type argument 'cell'");
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -247,13 +247,10 @@ octave_complex_diag_matrix::chk_valid_sc
 {
   bool retval = val.is_complex_scalar () || val.is_real_scalar ();
   if (retval)
     x = val.complex_value ();
   return retval;
 }
 
 /*
-
-%% bug #36368
-%!assert (diag ([1+i, 1-i])^2 , diag ([2i, -2i]), 4*eps)
-
+%!assert <36368> (diag ([1+i, 1-i])^2 , diag ([2i, -2i]), 4*eps)
 */
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1296,17 +1296,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 
   warn_load ("hdf5");
 
   return false;
 #endif
 }
 
 /*
-%!test
+%!test <33857>
 %! a = 2;
 %! f = @(x) a + x;
 %! g = @(x) 2 * x;
 %! hm = @version;
 %! hdld = @svd;
 %! hbi = @log2;
 %! f2 = f;
 %! g2 = g;
@@ -1317,17 +1317,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 %! if (isfield (__octave_config_info__, "HAVE_HDF5")
 %!     && __octave_config_info__ ("HAVE_HDF5"))
 %!   modes(end+1) = "-hdf5";
 %! endif
 %! for i = 1:numel (modes)
 %!   mode = modes{i};
 %!   nm = tempname ();
 %!   unwind_protect
-%!     f2 (1); # bug #33857
+%!     f2 (1);
 %!     save (mode, nm, "f2", "g2", "hm2", "hdld2", "hbi2");
 %!     clear f2 g2 hm2 hdld2 hbi2
 %!     load (nm);
 %!     assert (f (2), f2 (2));
 %!     assert (g (2), g2 (2));
 %!     assert (g (3), g2 (3));
 %!     unlink (nm);
 %!     save (mode, nm, "f2", "g2", "hm2", "hdld2", "hbi2");
@@ -1348,18 +1348,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 %!function [f2, g2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (n, nm)
 %!  if (n == 0)
 %!    load (nm);
 %!  else
 %!    [f2, g2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (n - 1, nm);
 %!  endif
 %!endfunction
 
-Test for bug #35876
-%!test
+%!test <35876>
 %! a = 2;
 %! f = @(x) a + x;
 %! g = @(x) 2 * x;
 %! hm = @version;
 %! hdld = @svd;
 %! hbi = @log2;
 %! f2 = f;
 %! g2 = g;
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -3217,37 +3217,37 @@ Return true if @var{x} is a Java object.
 ## Note that uint8 is casted to int8.
 %!testif HAVE_JAVA
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", [90 100 255], 255), 2);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", uint8 ([90 100 255]), uint8 (255)) < 0);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", uint8 ([90 100 128]), uint8 (128)) < 0);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", uint8 ([90 100 127]), uint8 (127)), 2);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", uint16 ([90 100 128]), uint16 (128)), 2);
 
-## Check we can create objects that wrap java literals (bug #38821).
-%!testif HAVE_JAVA
+## Check we can create objects that wrap java literals
+%!testif HAVE_JAVA <38821>
 %! assert (class (javaObject ("java.lang.Byte",     uint8 (1))), "java.lang.Byte");
 %! assert (class (javaObject ("java.lang.Byte",      int8 (1))), "java.lang.Byte");
 %! assert (class (javaObject ("java.lang.Short",   uint16 (1))), "java.lang.Short");
 %! assert (class (javaObject ("java.lang.Short",    int16 (1))), "java.lang.Short");
 %! assert (class (javaObject ("java.lang.Integer", uint32 (1))), "java.lang.Integer");
 %! assert (class (javaObject ("java.lang.Integer",  int32 (1))), "java.lang.Integer");
 %! assert (class (javaObject ("java.lang.Long",    uint64 (1))), "java.lang.Long");
 %! assert (class (javaObject ("java.lang.Long",     int64 (1))), "java.lang.Long");
 
-## Test for automatic conversion of specific numeric classes (bug #48013)
-%!testif HAVE_JAVA
+## Test for automatic conversion of specific numeric classes
+%!testif HAVE_JAVA <48013>
 %! assert (javaMethod ("valueOf", "java.lang.Byte",     int8 (1)), 1)
 %! assert (javaMethod ("valueOf", "java.lang.Short",   int16 (1)), 1)
 %! assert (javaMethod ("valueOf", "java.lang.Integer", int32 (1)), 1)
 %! assert (javaMethod ("valueOf", "java.lang.Long",    int64 (1)), 1)
 %! assert (javaMethod ("valueOf", "java.lang.Float",  single (1)), 1)
 %! assert (javaMethod ("valueOf", "java.lang.Double", double (1)), 1)
 %! assert (class (javaMethod ("valueOf", "java.math.BigDecimal", double (1))), "java.math.BigDecimal")
 %! assert (class (javaMethod ("valueOf", "java.math.BigInteger",  int64 (1))), "java.math.BigInteger")
 
-## Automatic conversion from string cell array into String[] (bug #45290)
-%!testif HAVE_JAVA
+## Automatic conversion from string cell array into String[]
+%!testif HAVE_JAVA <45290>
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "aaa"), 0);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "zzz"), 3);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "hhh") < 0);
 */
 
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -2949,51 +2949,48 @@ read_sparse_matrix (std::istream& is, Sp
 %!test test_sparse_slice ([2 2], 21, 4);
 %!test test_sparse_slice ([2 2], 22, []);
 %!test test_sparse_slice ([2 2], 22, 1);
 %!test test_sparse_slice ([2 2], 22, 2);
 %!test test_sparse_slice ([2 2], 22, [2,2]);
 %!test test_sparse_slice ([2 2], 22, 3);
 %!test test_sparse_slice ([2 2], 22, 4);
 
-bug #35570:
-
-%!assert (speye (3,1)(3:-1:1), sparse ([0; 0; 1]))
-
-## Test removing columns (bug #36656)
-
-%!test
+%!assert <35570> (speye (3,1)(3:-1:1), sparse ([0; 0; 1]))
+
+## Test removing columns
+%!test <36656>
 %! s = sparse (magic (5));
 %! s(:,2:4) = [];
 %! assert (s, sparse (magic (5)(:, [1,5])));
 
 %!test
 %! s = sparse ([], [], [], 1, 1);
 %! s(1,:) = [];
 %! assert (s, sparse ([], [], [], 0, 1));
 
 ## Test (bug #37321)
-%!test a=sparse (0,0); assert (all (a) == sparse ([1]));
-%!test a=sparse (0,1); assert (all (a) == sparse ([1]));
-%!test a=sparse (1,0); assert (all (a) == sparse ([1]));
-%!test a=sparse (1,0); assert (all (a,2) == sparse ([1]));
-%!test a=sparse (1,0); assert (size (all (a,1)), [1 0]);
-%!test a=sparse (1,1);
+%!test <37321> a=sparse (0,0); assert (all (a) == sparse ([1]));
+%!test <37321> a=sparse (0,1); assert (all (a) == sparse ([1]));
+%!test <37321> a=sparse (1,0); assert (all (a) == sparse ([1]));
+%!test <37321> a=sparse (1,0); assert (all (a,2) == sparse ([1]));
+%!test <37321> a=sparse (1,0); assert (size (all (a,1)), [1 0]);
+%!test <37321> a=sparse (1,1);
 %! assert (all (a) == sparse ([0]));
 %! assert (size (all (a)), [1 1]);
-%!test a=sparse (2,1);
+%!test <37321> a=sparse (2,1);
 %! assert (all (a) == sparse ([0]));
 %! assert (size (all (a)), [1 1]);
-%!test a=sparse (1,2);
+%!test <37321> a=sparse (1,2);
 %! assert (all (a) == sparse ([0]));
 %! assert (size (all (a)), [1 1]);
-%!test a=sparse (2,2); assert (isequal (all (a), sparse ([0 0])));
-
-## Test assigning row to a column slice (bug #45589)
-%!test
+%!test <37321> a=sparse (2,2); assert (isequal (all (a), sparse ([0 0])));
+
+## Test assigning row to a column slice
+%!test <45589>
 %! a = sparse (magic (3));
 %! b = a;
 %! a(1,:) = 1:3;
 %! b(1,:) = (1:3)';
 %! assert (a, b);
 
 */
 
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -428,18 +428,18 @@ endfunction
 %! subsc = num2cell (subs, 1);
 %! vals = rand (2000, 1);
 %! assert (accumarray (subsc, vals, [], @max),
 %!         accumarray (subs, vals, [], @max));
 
 %!error (accumarray (1:5))
 %!error (accumarray ([1,2,3],1:2))
 
-## Handle empty arrays (bug #47287)
-%!test
+## Handle empty arrays
+%!test <47287>
 %! ## min, max, and sum are special cases within accumarray so test them.
 %! funcs = {@(x) length (x) > 1, @min, @max, @sum};
 %! for idx = 1:numel (funcs)
 %!   assert (accumarray (zeros (0, 1), [], [0 1] , funcs{idx}), zeros (0, 1));
 %!   assert (accumarray (zeros (0, 1), [], [1 0] , funcs{idx}), zeros (1, 0));
 %!   assert (accumarray (zeros (0, 1), [], [] , funcs{idx}), zeros (0, 1));
 %! endfor
 
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -96,18 +96,18 @@ endfunction
 %! pfx = {"", "u"};
 %! for i = 1:2
 %!   for prec = [8, 16, 32, 64]
 %!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
 %!     assert (bitset (fcn ([0, 10]), [3, 3]), fcn ([4, 14]));
 %!   endfor
 %! endfor
 
-## Bug #36458
-%!assert (bitset (uint8 ([1, 2;3 4]), 1, [0 1; 0 1]), uint8 ([0, 3; 2 5]))
+%!assert <36458> (bitset (uint8 ([1, 2;3 4]), 1, [0 1; 0 1]),
+%!                uint8 ([0, 3; 2 5]))
 
 %!error bitset (1)
 %!error bitset (1, 2, 3, 4)
 %!error <A must be .= 0> bitset (-1, 2)
 %!error <invalid class char> bitset ("1", 2)
 %!error <N must be in the range \[1,53\]> bitset (0, 0)
 %!error <N must be in the range \[1,53\]> bitset (0, 55)
 %!error <N must be in the range \[1,24\]> bitset (single (0), 0)
diff --git a/scripts/general/fieldnames.m b/scripts/general/fieldnames.m
--- a/scripts/general/fieldnames.m
+++ b/scripts/general/fieldnames.m
@@ -41,21 +41,21 @@ function names = fieldnames (obj)
   if (nargin != 1)
     print_usage ();
   endif
 
   if (isstruct (obj) || isobject (obj))
     ## Call internal C++ function for structs or Octave objects
     names = __fieldnames__ (obj);
   elseif (isjava (obj) || ischar (obj))
-    ## FIXME: Function prototype that excepts java obj exists, but doesn't
+    ## FIXME: Function prototype that accepts java obj exists, but doesn't
     ##        work if obj is java.lang.String.  Convert obj to classname.
     ## FIXME: this is now working for objects whose class is in the dynamic
     ##        classpath but will continue to fail if such classnames are used
-    ##        instead (see bug #42710)
+    ##        instead (see bug #42710).
     if (isa (obj, "java.lang.String"))
       obj = class (obj);
     endif
     names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
     names = ostrsplit (names_str, ';');
   else
     error ("fieldnames: Invalid input argument");
   endif
diff --git a/scripts/general/inputParser.m b/scripts/general/inputParser.m
--- a/scripts/general/inputParser.m
+++ b/scripts/general/inputParser.m
@@ -633,18 +633,18 @@ endclassdef
 ## check normal use, but give values different than defaults
 %!test
 %! p2 = create_p2 ();
 %! parse (p2, "file", "foo", 80, "line", "circle", "verbose");
 %! r = p2.Results;
 %! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
 %!         {"file", "foo", 80,    true,      "circle"});
 
-## We must not perform validation of default values (bug #45837)
-%!test
+## We must not perform validation of default values
+%!test <45837>
 %! p = inputParser;
 %! p.addParameter ("Dir", [], @ischar);
 %! p.parse ();
 %! assert (p.Results.Dir, []);
 
 %!test
 %! p = inputParser;
 %! p.addParameter ("positive", -1, @(x) x > 5);
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -534,19 +534,19 @@ endfunction
 %! y = [2,3]';
 %! assert (interp2 (x,y,A,x,y,"linear"), A);
 %! assert (interp2 (x,y,A,x,y,"nearest"), A);
 
 %!test  # for Matlab-compatible rounding for 'nearest'
 %! X = meshgrid (1:4);
 %! assert (interp2 (X, 2.5, 2.5, "nearest"), 3);
 
-## re-order monotonically decreasing (bug #41838).
-%!assert (interp2 ([1 2 3], [3 2 1], magic (3), 2.5, 3), 3.5)
-%!assert (interp2 ([3 2 1], [1 2 3], magic (3), 1.5, 1), 3.5)
+## re-order monotonically decreasing
+%!assert <41838> (interp2 ([1 2 3], [3 2 1], magic (3), 2.5, 3), 3.5)
+%!assert <41838> (interp2 ([3 2 1], [1 2 3], magic (3), 1.5, 1), 3.5)
 
 %!shared z, zout, tol
 %! z = [1 3 5; 3 5 7; 5 7 9];
 %! zout = [1 2 3 4 5; 2 3 4 5 6; 3 4 5 6 7; 4 5 6 7 8; 5 6 7 8 9];
 %! tol = 2 * eps;
 %!
 %!assert (interp2 (z), zout, tol)
 %!assert (interp2 (z, "linear"), zout, tol)
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -117,18 +117,18 @@ endfunction
 %! legend ("sin(4t+0.3)cos(3t-0.1)", "spline", "interpft", "data");
 
 %!shared n,y
 %! x = [0:10]';  y = sin(x);  n = length (x);
 %!assert (interpft (y, n), y, 20*eps)
 %!assert (interpft (y', n), y', 20*eps)
 %!assert (interpft ([y,y],n), [y,y], 20*eps)
 
-## Test case with complex input from bug #39566
-%!test
+## Test case with complex input
+%!test <39566>
 %! x = (1 + j) * [1:4]';
 %! y = ifft ([15 + 15*j; -6; -1.5 - 1.5*j; 0; -1.5 - 1.5*j; -6*j]);
 %! assert (interpft (x, 6), y, 10*eps);
 
 ## Test for correct spectral symmetry with even/odd lengths
 %!assert (max (abs (imag (interpft ([1:8], 20)))), 0, 20*eps)
 %!assert (max (abs (imag (interpft ([1:8], 21)))), 0, 21*eps)
 %!assert (max (abs (imag (interpft ([1:9], 20)))), 0, 20*eps)
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -110,17 +110,17 @@ function retval = num2str (x, arg)
           ndgt = min (ndgt, 16);      # Cap significant digits at 16
           fmt = sprintf ("%%%d.%dg", ndgt+7, ndgt);
         else
           ## Integer input
           ndgt += 3;
           if (any (! valid))
             ndgt = max (ndgt, 5);     # Allow space for Inf/NaN
           endif
-          ## FIXME: Integers should be masked to show only 16 significant digits
+          ## FIXME: Integers must be masked to show only 16 significant digits
           ##        See test case for bug #36133 below
           fmt = sprintf ("%%%d.0f", ndgt);
         endif
       else
         ## Logical input
         fmt = "%3d";
       endif
     endif
@@ -155,17 +155,17 @@ function retval = num2str (x, arg)
       if (any (x(valid_real & valid_imag) != fix (x(valid_real & valid_imag))))
         ## Floating point input
         ndgt = max (ndgt + 5, 5);   # Keep at least 5 significant digits
         ndgt = min (ndgt, 16);      # Cap significant digits at 16
         fmt = sprintf ("%%%d.%dg%%-+%d.%dgi", ndgt+7, ndgt, ndgt+7, ndgt);
       else
         ## Integer input
         ndgt += 3;
-        ## FIXME: Integers should be masked to show only 16 significant digits
+        ## FIXME: Integers must be masked to show only 16 significant digits
         ##        See test case for bug #36133 below
         fmt = sprintf ("%%%d.0f%%-+%d.0fi", ndgt, ndgt);
       endif
     endif
 
     ## Manipulate the complex value to have real values in the odd
     ## columns and imaginary values in the even columns.
     nd = ndims (x);
@@ -241,21 +241,20 @@ endfunction
 ## Clear shared variables
 %!shared
 
 ## FIXME: Integers greater than flintmax() - 1 should be masked to show just
 ##        16 digits of precision.
 %!test <36133>
 %! assert (num2str (1e23), "100000000000000000000000");
 
-## Test for bug #44864, extra rows generated from newlines in format
-%!assert (rows (num2str (magic (3), "%3d %3d %3d\n")), 3)
+## Test for extra rows generated from newlines in format
+%!assert <44864> (rows (num2str (magic (3), "%3d %3d %3d\n")), 3)
 
-## Test for bug #45174
-%!assert (num2str ([65 66 67], "%s"), "ABC")
+%!assert <45174> (num2str ([65 66 67], "%s"), "ABC")
 
 %!error num2str ()
 %!error num2str (1, 2, 3)
 %!error <X must be a numeric> num2str ({1})
 %!error <PRECISION must be a scalar integer .= 0> num2str (1, {1})
 %!error <PRECISION must be a scalar integer .= 0> num2str (1, ones (2))
 %!error <PRECISION must be a scalar integer .= 0> num2str (1, -1)
 %!error <PRECISION must be a scalar integer .= 0> num2str (1, 1.5)
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -100,16 +100,16 @@ endfunction
 %!assert (postpad ([1,2], 2, 2, 1), [1,2;2,2])
 %!assert (postpad ([1;2], 2, 2, 3), reshape ([1;2;2;2], 2, 1, 2))
 %!assert (postpad ([1,2], 2, 2, 3), reshape ([1,2,2,2], 1, 2, 2))
 
 %!assert (postpad ([1 2], 2), [1 2])
 %!assert (postpad ([1; 2], 2), [1; 2])
 %!assert (postpad ([1; 2], 2, 3, 2), [1 3; 2 3])
 
-%! ## Test with string concatenation (bug #44162)
-%!assert (postpad ("Octave", 16, "x"), "Octavexxxxxxxxxx")
+%! ## Test with string concatenation
+%!assert <44162> (postpad ("Octave", 16, "x"), "Octavexxxxxxxxxx")
 %!assert (postpad ("Octave", 4), "Octa")
 
 %!error postpad ()
 %!error postpad (1)
 %!error postpad (1,2,3,4,5)
 
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -103,18 +103,18 @@ endfunction
 %!assert (prepad ([1; 2], 2), [1; 2])
 %!assert (prepad ([1; 2], 2, 3, 2), [3 1; 3 2])
 
 %!assert (prepad ([1,2], 2, 2, 1), [2,2;1,2])
 
 %!assert (prepad ([1,2], 2, 2, 3), reshape ([2,2,1,2], 1, 2, 2))
 %!assert (prepad ([1;2], 2, 2, 3), reshape ([2;2;1;2], 2, 1, 2))
 
-%! ## Test with string concatenation (bug #44162)
-%!assert (prepad ("Octave", 16, "x"), "xxxxxxxxxxOctave")
+%! ## Test with string concatenation
+%!assert <44162> (prepad ("Octave", 16, "x"), "xxxxxxxxxxOctave")
 %!assert (prepad ("Octave", 4), "tave")
 
 ## FIXME: We need tests for multidimensional arrays.
 
 %!error prepad ()
 %!error prepad (1)
 %!error prepad (1,2,3,4,5)
 %!error <C must be empty or a scalar> prepad ([1,2], 2, ones (2))
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -154,14 +154,13 @@ function [n,d] = rat (x,tol)
 endfunction
 
 
 %!test
 %! [n, d] = rat ([0.5, 0.3, 1/3]);
 %! assert (n, [1, 3, 1]);
 %! assert (d, [2, 10, 3]);
 
-## bug #43374
-%!assert (eval (rat (0.75)), [0.75])
+%!assert <43374> (eval (rat (0.75)), [0.75])
 
 %!error rat ()
 %!error rat (1, 2, 3)
 
diff --git a/scripts/geometry/rectint.m b/scripts/geometry/rectint.m
--- a/scripts/geometry/rectint.m
+++ b/scripts/geometry/rectint.m
@@ -89,21 +89,20 @@ endfunction
 ## no overlap - shared corner
 %!assert (rectint ([0 0 1 1], [1 1 2 2]), 0)
 ## no overlap - shared edge
 %!assert (rectint ([0 0 1 1], [0 1 2 2]), 0)
 ## Correct orientation of output
 %!assert (rectint ([0 0 1 1;0.5 0.5 1 1;-1 -1 2 2], [1 1 2 2]), [0;0.25;0])
 %!assert (rectint ([1 1 2 2], [0 0 1 1;0.5 0.5 1 1;-1 -1 2 2]), [0 0.25 0])
 
-## bug #44904
-%!assert (rectint ([0 0 5 5], [6 6 5 5]), 0)
-%!assert (rectint ([0 0 5 5], [0 6 5 5]), 0)
-%!assert (rectint ([0 0 5 5], [6 0 5 5]), 0)
-%!assert (rectint ([0 0 0 5 5 5], [0 0 6 5 5 5]), 0)
+%!assert <44904> (rectint ([0 0 5 5], [6 6 5 5]), 0)
+%!assert <44904> (rectint ([0 0 5 5], [0 6 5 5]), 0)
+%!assert <44904> (rectint ([0 0 5 5], [6 0 5 5]), 0)
+%!assert <44904> (rectint ([0 0 0 5 5 5], [0 0 6 5 5 5]), 0)
 
 ## Test volumes
 %!shared r1, r2, r3, r4, r5
 %! r1 = [  5   3 0  7   5 2];
 %! r2 = [  2   5 0  4   2 2];
 %! r3 = [ 10   7 0 10   3 2];
 %! r4 = [ 10  -5 0  5   7 2];
 %! r5 = [-10   0 0 40  11 2];
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -222,18 +222,18 @@ endfunction
 %! subplot (2,2,3);
 %!  h = image (x, -y, img);
 %!  title ("image (x, -y, img)");
 %!  ylabel ("limits = [-5.5, 5.5]");
 %! subplot (2,2,4);
 %!  h = image (-x, -y, img);
 %!  title ("image (-x, -y, img)");
 
-%!test
-%! ## test hidden properties x/ydatamode (bug #42121)
+## test hidden properties x/ydatamode
+%!test <42121>
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   nx = 64; ny = 64;
 %!   cdata = rand (ny, nx)*127;
 %!   hi = image (cdata);             # x/ydatamode is auto
 %!   assert (get (hi, "xdata"), [1 nx]);
 %!   assert (get (hi, "ydata"), [1 ny]);
 %!   set (hi, "cdata", cdata(1:2:end, 1:2:end));
diff --git a/scripts/image/imread.m b/scripts/image/imread.m
--- a/scripts/image/imread.m
+++ b/scripts/image/imread.m
@@ -199,17 +199,17 @@ endfunction
 %!   assert (imread (fname(1:end-4), "jpg", extra_inputs{:}), {fname, extra_inputs{:}});
 %! unwind_protect_cleanup
 %!   fclose (fid);
 %!   unlink (fname);
 %!   imformats (def_fmt);
 %! end_unwind_protect
 
 ## Test for bug #41584 (some GM coders report saturated channels as binary)
-%!testif HAVE_MAGICK
+%!testif HAVE_MAGICK <41584>
 %! im = zeros ([16 16 3], "uint8");
 %! im(:,:,1) = 255;
 %! im(:,:,3) = repmat (0:16:255, [16 1]);
 %! [r, cmap, a] = write_and_read (im, "png");
 %! assert (class (r), "uint8");
 %! assert (isempty (cmap));
 %! assert (isempty (a));
 
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -224,17 +224,17 @@ endfunction
 %!    unwind_protect_cleanup
 %!      fclose (fid);
 %!    end_unwind_protect
 %!  unwind_protect_cleanup
 %!    unlink (filename);
 %!  end_unwind_protect
 %!endfunction
 
-## BMP images must be saved uncompressed by default (bug #45565)
-%!testif HAVE_MAGICK
+## BMP images must be saved uncompressed by default
+%!testif HAVE_MAGICK <45565>
 %! assert (get_bmp_compression ("", [], "BMP"), 0);
 %! assert (get_bmp_compression ("", [], "bmp"), 0);
 %! assert (get_bmp_compression (".BMP"), 0);
 %! assert (get_bmp_compression (".bmp"), 0);
 %! assert (get_bmp_compression (".bmp", [], "bmp"), 0);
 %! assert (get_bmp_compression ("", gray (256), "bmp"), 0);
 %! assert (get_bmp_compression (".bmp", gray (256), "Compression", "rle"), 1);
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -514,18 +514,18 @@ endfunction
 %! fputs (fid, "3.1\t-7.2\t0\r0.012\t6.5\t128");
 %! fclose (fid);
 %! [a,d,h] = importdata (fn, '\t');
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, "\t");
 %! assert (h, 0);
 
-%!test
-%! ## Distinguish double from complex when no delimiter is supplied (bug #43393)
+%!test <43393>
+%! ## Distinguish double from complex when no delimiter is supplied
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
 %! fputs (fid, "2.0000e+02   4.0000e-04");
 %! fclose (fid);
 %! [a, d, h] = importdata (fn);
 %! unlink (fn);
 %! assert (a, [2e2, 4e-4]);
 %! assert (d, " ");
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -902,24 +902,23 @@ endfunction
 %! assert (b, {"a"; "b"; "c"});
 %! [a, b] = strread ("10 a 20 b\n 30 c 40\n", "%d %s", 4);
 %! assert (a, int32 ([10; 20; 30; 40]));
 %! assert (b, {"a"; "b"; "c"; ""});
 %! [a, b] = strread ("10 a 20 b\n 30 c 40", "%d %s", 1);
 %! assert (a, int32 (10));
 %! assert (b, {"a"});
 
-## Bug #33536
-%!test
+%!test <33536>
 %! [a, b, c] = strread ("1,,2", "%s%s%s", "delimiter", ",");
 %! assert (a{1}, "1");
 %! assert (b{1}, "");
 %! assert (c{1}, "2");
 
-## Bug #33536
+%!test <33536>
 %!test
 %! a = strread ("[SomeText]", "[%s", "delimiter", "]");
 %! assert (a{1}, "SomeText");
 
 %!test
 %! dat = "Data file.\r\n=  =  =  =  =\r\nCOMPANY    : <Company name>\r\n";
 %! a = strread (dat, "%s", "delimiter", "\n", "whitespace", "", "endofline", "\r\n");
 %! assert (a{2}, "=  =  =  =  =");
@@ -964,19 +963,18 @@ endfunction
 %!test
 %! str = "11, 12, 13,, 15\n21,, 23, 24, 25\n,, 33, 34, 35";
 %! [a b c d] = strread (str, "%f %f %f %f", "delimiter", ",", "multipledelimsasone", 1, "endofline", "\n");
 %! assert (a', [11, 21, NaN]);
 %! assert (b', [12, 23, 33]);
 %! assert (c', [13, 24, 34]);
 %! assert (d', [15, 25, 35]);
 
-## Bug #44750
-%!assert (strread ('/home/foo/','%s','delimiter','/','MultipleDelimsAsOne',1),
-%!        {"home"; "foo"})
+%!assert <44750> (strread ('/home/foo/','%s','delimiter','/','MultipleDelimsAsOne',1),
+%!                {"home"; "foo"})
 
 ## delimiter as sq_string and dq_string
 %!assert (strread ("1\n2\n3", "%d", "delimiter", "\n"),
 %!        strread ("1\n2\n3", "%d", "delimiter", '\n'))
 
 ## whitespace as sq_string and dq_string
 %!assert (strread ("1\b2\r3\b4\t5", "%d", "whitespace", "\b\r\n\t"),
 %!        strread ("1\b2\r3\b4\t5", "%d", "whitespace", '\b\r\n\t'))
@@ -1022,56 +1020,54 @@ endfunction
 %! assert (a{1}, '1');
 %! assert (b, NaN);
 
 %!test
 %! [a, b] = strread (["Empty" char(10)], "Empty%f %f");
 %! assert (a, NaN);
 %! assert (b, NaN);
 
-## Bug #35999
-%!test
+%!test <35999>
 %! [a, b, c] = strread ("", "%f");
 %! assert (isempty (a));
 %! assert (isempty (b));
 %! assert (isempty (c));
 
-## Bug #37023
-%!test
+%!test <37023>
 %! [a, b] = strread (" 1. 1 \n  2 3 \n", "%f %f", "endofline", "\n");
 %! assert (a, [1; 2], 1e-15);
 %! assert (b, [1; 3], 1e-15);
 
 ## Test for no output arg (interactive use)
 %!assert (strread (",2,,4\n5,,7,", "", "delimiter", ","),
 %!        [NaN; 2; NaN; 4; 5; NaN; 7])
 
 ## Test #1 bug #42609
-%!test
+%!test <42609>
 %! [a, b, c] = strread ("1 2 3\n4 5 6\n7 8 9\n", "%f %f %f\n");
 %! assert (a, [1; 4; 7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
 ## Test #2 bug #42609
-%!test
+%!test <42609>
 %! [a, b, c] = strread ("1 2\n3\n4 5\n6\n7 8\n9\n", "%f %f\n%f");
 %! assert (a, [1;4;7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
 ## Test #3 bug #42609
-%!test
+%!test <42609>
 %! [a, b, c] = strread ("1 2 3\n4 5 6\n7 8 9\n", '%f %f %f\n');
 %! assert (a, [1; 4; 7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
 ## Test #4 bug #42609
-%!test
+%!test <42609>
 %! [a, b, c] = strread ("1 2\n3\n4 5\n6\n7 8\n9\n", '%f %f\n%f');
 %! assert (a, [1;4;7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
 ## Unsupported format specifiers
 %!error <format specifiers are not supported> strread ("a", "%c")
 %!error <format specifiers are not supported> strread ("a", "%*c %d")
@@ -1089,18 +1085,18 @@ endfunction
 %!error <format specifiers are not supported> strread ("a", "%*u32 %d")
 
 ## Illegal format specifiers
 %!error <no valid format conversion specifiers> strread ("1.0", "%z")
 
 ## Test for false positives in check for non-supported format specifiers
 %!assert (strread ("Total: 32.5 % (of cm values)","Total: %f % (of cm values)"), 32.5, 1e-5)
 
-## Test various forms of string format specifiers (bug #45712)
-%!test
+## Test various forms of string format specifiers
+%!test <45712>
 %! str = "14 :1 z:2 z:3 z:5 z:11";
 %! [a, b, c, d] = strread (str, "%f %s %*s %3s %*3s %f", "delimiter", ":");
 %! assert ({a, b, c, d}, {14, {"1 z"}, {"3 z"}, 11});
 
 ## Allow cuddling %sliteral but warn that it is ambiguous
 %!warning <Ambiguous '%s' specifier immediately before literal in column 1>
 %! [a, b] = strread ("abcxyz51\nxyz83\n##xyz101", "%s xyz %d");
 %! assert (a([1 3]), {"abc"; "##"});
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -471,31 +471,31 @@ endfunction
 #%! d = rand (1, 4);
 #%! fprintf (fid, ",2,,4\n5,\n");
 #%! fclose (fid);
 #%! A = textread (f, "", "delimiter", ",");
 #%! unlink (f);
 #%! assert (A, [0 2 0 4; 5 0 0 0], 1e-6);
 
 ### Test endofline
-#%!test
+#%!test <45046>
 #%! f = tempname ();
 #%! fid = fopen (f, "w");
 #%! fprintf (fid, "a\rb\rc");
 #%! fclose (fid);
 #%! ## Test EOL detection
 #%! d = textread (f, "%s");
 #%! assert (d, {"a";"b";"c"});
 #%! ## Test explicit EOL specification (bug #45046)
 #%! d = textread (f, "%s", "endofline", "\r");
 #%! assert (d, {"a"; "b"; "c"});
 #%! unlink (f);
 
-### Properly process single-quoted EOL args (bug #46477)
-#%!test
+### Properly process single-quoted EOL args
+#%!test <46477>
 #%! f = tempname ();
 #%! fid = fopen (f, "w");
 #%! fprintf (fid, "hello, world!");
 #%! fclose (fid);
 #%! [a, b] = textread (f, "%s%s", "endofline", '\n');
 #%! assert (a{1}, "hello,");
 #%! assert (b{1}, "world!");
 
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -210,18 +210,18 @@ endfunction
 %! aa.y = 3;
 %! aa(2).x = {4, 5};
 %! bb.y = {6, 7};
 %! bb.x = 8;
 %! aa(2) = orderfields (bb, aa);
 %! assert (aa(2).x, 8);
 %! assert (aa(2).y{1}, 6);
 
-## Corner case of empty struct, bug #40224
-%!assert (orderfields (struct ()), struct ())
+## Corner case of empty struct
+%!assert <40224> (orderfields (struct ()), struct ())
 %!test
 %! s(2,2).a = 1;
 %! s(1,1).b = 2;
 %! s = resize (s, [1 0]);
 %! s2 = orderfields (s, {"b", "a"});
 %! assert (fieldnames (s2), {"b"; "a"});
 %! assert (size_equal (s, s2));
 
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -415,18 +415,18 @@ function [x, obj, INFO, lambda] = qp (x0
   if (isargout (3))
     INFO.solveiter = iter;
     INFO.info = info;
   endif
 
 endfunction
 
 
-## Test infeasible initial guess (bug #40536)
-%!testif HAVE_GLPK
+## Test infeasible initial guess
+%!testif HAVE_GLPK <40536>
 %!
 %! H = 1;  q = 0;                # objective: x -> 0.5 x^2
 %! A = 1;  lb = 1;  ub = +inf;   # constraint: x >= 1
 %! x0 = 0;                       # infeasible initial guess
 %!
 %! [x, obj_qp, INFO, lambda] = qp (x0, H, q, [], [], [], [], lb, A, ub);
 %!
 %! assert (isstruct (INFO) && isfield (INFO, "info") && (INFO.info == 0));
diff --git a/scripts/plot/appearance/axis.m b/scripts/plot/appearance/axis.m
--- a/scripts/plot/appearance/axis.m
+++ b/scripts/plot/appearance/axis.m
@@ -630,18 +630,17 @@ endfunction
 %!   loglog (a, -a);
 %!   axis tight;
 %!   assert (axis (), [1e-5, 10, -10, -1e-5]);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 ## Test 'axis tight' with differently oriented, differently numbered data vecs
-## Bug #40036.
-%!test
+%!test <40036>
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   Z = peaks (linspace (-3, 3, 49), linspace (-2, 2, 29));
 %!   surf (Z);
 %!   axis tight;
 %!   assert (axis (), [1 49 1 29 min(Z(:)) max(Z(:))]);
 %! unwind_protect_cleanup
 %!   close (hf);
diff --git a/scripts/plot/appearance/legend.m b/scripts/plot/appearance/legend.m
--- a/scripts/plot/appearance/legend.m
+++ b/scripts/plot/appearance/legend.m
@@ -1614,18 +1614,17 @@ endfunction
 %!   print (filename);
 %!   unlink (filename);
 %!   assert (get (h, "position"), position);
 %! unwind_protect_cleanup
 %!   close (h);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
-%!test
-%! ## bug #42035
+%!test <42035>
 %! h = figure ("visible", "off");
 %! unwind_protect
 %!   hax1 = subplot (1,2,1);
 %!   plot (1:10);
 %!   hax2 = subplot (1,2,2);
 %!   plot (1:10);
 %!   hleg1 = legend (hax1, "foo");
 %!   assert (get (hleg1, "userdata").handle, hax1);
diff --git a/scripts/plot/draw/hist.m b/scripts/plot/draw/hist.m
--- a/scripts/plot/draw/hist.m
+++ b/scripts/plot/draw/hist.m
@@ -213,22 +213,20 @@ endfunction
 %!   assert (sum (hist ([1:n], n)), n);
 %!   assert (sum (hist ([1:n], [2:n-1])), n);
 %!   assert (sum (hist ([1:n], [1:n])), n);
 %!   assert (sum (hist ([1:n], 29)), n);
 %!   assert (sum (hist ([1:n], 30)), n);
 %! endfor
 %!assert (hist (1,1), 1)
 %!assert (size (hist (randn (750,240), 200)), [200,240])
-## Test bug #42394
-%!assert (isempty (hist (rand (10,2), 0:5, 1)), false)
-%!assert (isempty (hist (rand (10,2), 0:5, [1 1])), false)
+%!assert <42394> (isempty (hist (rand (10,2), 0:5, 1)), false)
+%!assert <42394> (isempty (hist (rand (10,2), 0:5, [1 1])), false)
 
-## Test bug #47707
-%!test
+%!test <47707>
 %! y = [1  9  2  2  9  3  8  9  1  7  1  1  3  2  4  4  8  2  1  9  4  1 ...
 %!      2  3  1  1  6  5  5  3  9  9  1  1  8  7  7  2  4  1];
 %! [n, x] = hist (y, 10);
 %! [nn, xx] = hist (uint8 (y), 10);
 %! assert (nn, n)
 %! assert (xx, x)
 %!
 %! ## test again with N > 30 because there's a special case for it
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -410,17 +410,17 @@ endfunction
 %! assert (r, r1, 1e-12);
 %! assert (p, p1, 1e-12);
 %! assert (isempty (k));
 %! assert (e, [1; 2]);
 %! [br, ar] = residue (r, p, k);
 %! assert (br, b, 1e-12);
 %! assert (ar, a, 1e-12);
 
-## The following test is due to Bernard Grung (bug #34266)
+## The following test is due to Bernard Grung
 %!test <34266>
 %! z1 =  7.0372976777e6;
 %! p1 = -3.1415926536e9;
 %! p2 = -4.9964813512e8;
 %! r1 = -(1 + z1/p1)/(1 - p1/p2)/p2/p1;
 %! r2 = -(1 + z1/p2)/(1 - p2/p1)/p2/p1;
 %! r3 = (1 + (p2 + p1)/p2/p1*z1)/p2/p1;
 %! r4 = z1/p2/p1;
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -109,21 +109,21 @@ endfunction
 
 %!test
 %! a = [3, 1, 4, 1, 5];
 %! b = [1, 2, 3, 4];
 %! [c, ia] = setdiff (a, b');
 %! assert (c, [5]);
 %! assert (c, a(ia));
 
-## Test output orientation compatibility (bug #42577)
-%!assert (setdiff ([1:5], 2), [1,3,4,5])
-%!assert (setdiff ([1:5]', 2), [1;3;4;5])
-%!assert (setdiff ([1:5], [2:3]), [1,4,5])
-%!assert (setdiff ([1:5], [2:3]'), [1,4,5])
-%!assert (setdiff ([1:5]', [2:3]), [1;4;5])
-%!assert (setdiff ([1:5]', [2:3]'), [1;4;5])
+## Test output orientation compatibility
+%!assert <42577> (setdiff ([1:5], 2), [1,3,4,5])
+%!assert <42577> (setdiff ([1:5]', 2), [1;3;4;5])
+%!assert <42577> (setdiff ([1:5], [2:3]), [1,4,5])
+%!assert <42577> (setdiff ([1:5], [2:3]'), [1,4,5])
+%!assert <42577> (setdiff ([1:5]', [2:3]), [1;4;5])
+%!assert <42577> (setdiff ([1:5]', [2:3]'), [1;4;5])
 
 %!test
 %! a = rand (3,3,3);
 %! b = a(1);
 %! assert (setdiff (a, b), sort (a(2:end)'));
 
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -133,18 +133,18 @@ endfunction
 %! assert (fftshift (y,2), x);
 
 %!test
 %! x = "abcdefg";
 %! y = fftshift (x);
 %! assert (y, "efgabcd");
 %! assert (fftshift (y), "bcdefga");
 
-## Test N-dimensional input (bug #45207)
-%!test
+## Test N-dimensional input
+%!test <45207>
 %! x = [0:3];
 %! x = x + x' + reshape (x, [1 1 4]);
 %! y1 = [4 5 2 3; 5 6 3 4; 2 3 0 1; 3 4 1 2];
 %! y = fftshift (x);
 %! assert (y, reshape ([y1 + 2, y1 + 3, y1, y1 + 1], [4 4 4]));
 %! assert (fftshift (y), x);
 
 ## Test input validation
diff --git a/scripts/signal/ifftshift.m b/scripts/signal/ifftshift.m
--- a/scripts/signal/ifftshift.m
+++ b/scripts/signal/ifftshift.m
@@ -118,18 +118,18 @@ endfunction
 %! assert (ifftshift (y,2), x);
 
 %!test
 %! x = "efgabcd";
 %! y = ifftshift (x);
 %! assert (y, "abcdefg");
 %! assert (ifftshift (y), "defgabc");
 
-## Test N-dimensional input (bug #45207)
-%!test
+## Test N-dimensional input
+%!test <45207>
 %! x = [0:3];
 %! x = x + x' + reshape (x, [1 1 4]);
 %! y1 = [4 5 2 3; 5 6 3 4; 2 3 0 1; 3 4 1 2];
 %! y = ifftshift (x);
 %! assert (y, reshape ([y1 + 2, y1 + 3, y1, y1 + 1], [4 4 4]));
 %! assert (ifftshift (y), x);
 
 ## Test input validation
diff --git a/scripts/specfun/nthroot.m b/scripts/specfun/nthroot.m
--- a/scripts/specfun/nthroot.m
+++ b/scripts/specfun/nthroot.m
@@ -88,18 +88,18 @@ endfunction
 
 
 %!assert (nthroot (-32, 5), -2)
 %!assert (nthroot (81, 4), 3)
 %!assert (nthroot (Inf, 4), Inf)
 %!assert (nthroot (-Inf, 7), -Inf)
 %!assert (nthroot (-Inf, -7), 0)
 
-## Bug #43492.  This should not generate a division by zero warning
-%!test
+## This should not generate a division by zero warning
+%!test <43492>
 %! warnmsg = lastwarn ();
 %! assert (nthroot (0, 2), 0);
 %! assert (lastwarn (), warnmsg);
 
 ## Test input validation
 %!error nthroot ()
 %!error nthroot (1)
 %!error nthroot (1,2,3)
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -80,20 +80,20 @@ endfunction
 
 
 %!test
 %! for i = 3:30
 %!   A = magic (i);
 %!   assert (norm(diff([sum(diag(A)),sum(diag(flipud(A))),sum(A),sum(A')])),0);
 %! endfor
 
-## Not a magic square but we must return something (bug #46672)
+## Not a magic square but we must return something (bug #46672).
 ## While one day we may change the actual return of magic (2),
 ## this properties still must be true.
-%!test
+%!test <46672>
 %! m = magic (2);
 %! assert (size (m), [2 2]);
 %! assert (unique (m), [1; 2; 3; 4]);
 
 %!assert (magic (2), [4 3; 1 2])
 %!assert (isempty (magic (-1)))
 %!assert (isempty (magic (0)))
 %!assert (magic (1), 1)
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -106,25 +106,25 @@ endfunction
 %! assert (median (y) == median (y2) && median (y) == 4);
 %! assert (median ([x2, 2*x2]), [3.5, 7]);
 %! assert (median ([y2, 3*y2]), [4, 12]);
 
 %!assert (median (single ([1,2,3])), single (2))
 %!assert (median ([1,2,NaN;4,5,6;NaN,8,9]), [NaN, 5, NaN])
 %!assert (median ([1,2], 3), [1,2])
 
-## Test multidimensional arrays (bug #35679)
+## Test multidimensional arrays
 %!shared a, b, x, y
 %! rand ("seed", 2);
 %! a = rand (2,3,4,5);
 %! b = rand (3,4,6,5);
 %! x = sort (a, 4);
 %! y = sort (b, 3);
-%!assert (median (a, 4), x(:, :, :, 3))
-%!assert (median (b, 3), (y(:, :, 3, :) + y(:, :, 4, :))/2)
+%!assert <35679> (median (a, 4), x(:, :, :, 3))
+%!assert <35679> (median (b, 3), (y(:, :, 3, :) + y(:, :, 4, :))/2)
 
 ## Test non-floating point types
 %!assert (median ([true, false]), true)
 %!assert (median (uint8 ([1, 3])), uint8 (2))
 %!assert (median (int8 ([1, 3, 4])), int8 (3))
 %!assert (median (single ([1, 3, 4])), single (3))
 %!assert (median (single ([1, 3, NaN])), single (NaN))
 
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -316,18 +316,17 @@ endfunction
 %! sx = [2, 3, 4];
 %! x = rand (sx);
 %! dim = 2;
 %! p = 0.5;
 %! yobs = quantile (x, p, dim);
 %! yexp = median (x, dim);
 %! assert (yobs, yexp);
 
-## Bug #45455
-%!assert (quantile ([1 3 2], 0.5, 1), [1 3 2])
+%!assert <45455> (quantile ([1 3 2], 0.5, 1), [1 3 2])
 
 ## Test input validation
 %!error quantile ()
 %!error quantile (1, 2, 3, 4, 5)
 %!error quantile (['A'; 'B'], 10)
 %!error quantile (1:10, [true, false])
 %!error quantile (1:10, ones (2,2))
 %!error quantile (1, 1, 1.5)
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -116,18 +116,17 @@ function out = base2dec (s, base)
 endfunction
 
 
 %!assert (base2dec ("11120", 3), 123)
 %!assert (base2dec ("yyyzx", "xyz"), 123)
 %!assert (base2dec ("-1", 2), NaN)
 %!assert (base2dec ({"A1", "1A"}, 16), [161; 26])
 
-## Bug #35621
-%!assert (base2dec (["0"; "1"], 2), [0; 1])
+%!assert <35621> (base2dec (["0"; "1"], 2), [0; 1])
 
 ## Test input validation
 %!error base2dec ()
 %!error base2dec ("11120")
 %!error base2dec ("11120", 3, 4)
 %!error base2dec ("11120", "1231")
 %!error base2dec ("11120", "12 3")
 %!error base2dec ("11120", ones (2))
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -292,22 +292,20 @@ endfunction
 %! assert (m, {" \t "});
 
 ## Compatibility
 %! assert (strsplit ("", "a"), {""});
 %! assert (strsplit ("a", "a"), {"", ""});
 %! assert (strsplit ("aa", "a"), {"", ""});
 %! assert (strsplit ("aaa", "a"), {"", ""});
 
-## Bug #44641
-%!assert (strsplit ("xxx<yyy", "<"), {"xxx", "yyy"})
-%!assert (strsplit ('xxx\yyy', '\'), {"xxx", "yyy"})
+%!assert <44641> (strsplit ("xxx<yyy", "<"), {"xxx", "yyy"})
+%!assert <44641> (strsplit ('xxx\yyy', '\'), {"xxx", "yyy"})
 
-## Bug #47403
-%!assert (strsplit ('xxx+yyy', '+'), {"xxx", "yyy"})
+%!assert <47403> (strsplit ('xxx+yyy', '+'), {"xxx", "yyy"})
 
 ## Test input validation
 %!error strsplit ()
 %!error strsplit ("abc", "b", true, 4)
 %!error <invalid parameter name, 'foo'> strsplit ("abc", "b", "foo", "true")
 %!error <S and DEL must be string values> strsplit (123, "b")
 %!error <COLLAPSEDELIMITERS must be a scalar value> strsplit ("abc", "def", "collapsedelimiters", ones (3,3))
 %!error <Invalid DELIMITERTYPE> strsplit ("abc", "b", "delimitertype", "foobar")
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -319,17 +319,17 @@ endfunction
 ## Accommodate this, although no other UNIX-based OS does this.
 %!test
 %! obs = toupper (datestr (testtime,14));
 %! assert (obs, " 2:33:17 AM");
 %!assert (datestr (testtime,15), "02:33")
 %!test
 %! obs = toupper (datestr (testtime,16));
 %! assert (obs, " 2:33 AM");
-%!test  # bug #48071
+%!test <48071>
 %! testtime2 = testtime;
 %! testtime2(4) = 15;
 %! obs = toupper (datestr (testtime2,16));
 %! assert (obs, " 3:33 PM");
 %!assert (datestr (testtime,17), "Q4-05")
 %!assert (datestr (testtime,18), "Q4")
 %!assert (datestr (testtime,19), "18/12")
 %!assert (datestr (testtime,20), "18/12/05")
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -356,18 +356,18 @@ endfunction
 %!        [2015,6,1,11,7,12.102])
 %!assert (datevec ("06/01/2015 3:07:12.1 PM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
 %!        [2015,6,1,15,7,12.1])
 %!assert (datevec ("06/01/2015 3:07:12.12 AM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
 %!        [2015,6,1,3,7,12.12])
 %!assert (datevec ("06/01/2015 3:07:12.12 PM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
 %!        [2015,6,1,15,7,12.12])
 
-## Test structure of return value (bug #42334)
-%!test
+## Test structure of return value
+%!test <42334>
 %! [~, ~, d] = datevec ([1 2; 3 4]);
 %! assert (d, [1 2; 3 4]);
 
 ## Other tests
 %!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]')
 %!test
 %! t = linspace (-2e5, 2e5, 10993);
 %! assert (all (abs (datenum (datevec (t)) - t') < 1e-5));
