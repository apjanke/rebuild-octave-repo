# HG changeset patch
# User jwe
# Date 909692882 0
#      Thu Oct 29 20:28:02 1998 +0000
# Node ID 44d82b369c782a2660b01e7a3c34e8d819a22124
# Parent  72bb6379d8a3f8a18073d16443fb1ffabe347c5f
[project @ 1998-10-29 20:27:57 by jwe]

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -38,212 +38,239 @@ Summary of changes for version 2.1.x:
       is_complex  -- tell whether a variable is complex
       rehash      -- re-initialize the cache of directories in LOADPATH
       graw        -- send a string to the gnuplot subprocess
 
   * New functions from Kurt Hornik's Octave-ci package:
 
     In finance (new directory):
 
-      fv
-      fvl
-      irr
-      nper
-      npv
-      pmt
-      pv
-      pvl
-      rate
-      vol
+      fv    -- future value of an investment
+      fvl   -- future value of an initial lump sum investment
+      irr   -- internal rate of return of an investment
+      nper  -- number of payments needed for amortizing a loan
+      npv   -- net present value of a series of payments
+      pmt   -- amount of periodic payment needed to amortize a loan
+      pv    -- present value of an investment
+      pvl   -- present value of an investment that pays off at the end
+      rate  -- rate of return of an investment
+      vol   -- volatility of financial time series data
 
     In linear-algebra:
 
-      dmult
+      dmult -- rescale the rows of a matrix
 
     In signal:
 
-      arch_fit
-      arch_rnd
-      arch_test
-      arma_rnd
-      autocor
-      autocov
-      autoreg_matrix
-      bartlett
-      blackman
-      diffpara
-      durbinlevinson
-      fractdiff
-      hamming
-      hanning
-      hurst
-      periodogram
-      rectangle_lw
-      rectangle_sw
-      sinetone
-      sinewave
-      spectral_adf
-      spectral_xdf
-      spencer
-      stft
-      synthesis
-      triangle_lw
-      triangle_sw
-      yulewalker
+      arch_fit       -- fit an ARCH regression model
+      arch_rnd       -- simulate an ARCH process
+      arch_test      -- test for conditional heteroscedascity
+      arma_rnd       -- simulate an ARMA process
+      autocor        -- compute autocorrelations
+      autocov        -- compute autocovariances
+      autoreg_matrix -- design matrix for autoregressions
+      bartlett       -- coefficients of the Bartlett (triangular) window
+      blackman       -- coefficients of the Blackman window
+      diffpara       -- estimate the fractional differencing parameter
+      durbinlevinson -- perform one step of the Durbin-Levinson algorithm
+      fractdiff      -- compute fractional differences
+      hamming        -- coefficients of the Hamming window
+      hanning        -- coefficients of the Hanning window
+      hurst          -- estimate the Hurst parameter
+      periodogram    -- compute the periodogram
+      rectangle_lw   -- rectangular lag window
+      rectangle_sw   -- rectangular spectral window
+      sinetone       -- compute a sine tone
+      sinewave       -- compute a sine wave
+      spectral_adf   -- spectral density estimation
+      spectral_xdf   -- spectral density estimation
+      spencer        -- apply Spencer's 15-point MA filter
+      stft           -- short-term Fourier transform
+      synthesis      -- recover a signal from its short-term Fourier transform
+      triangle_lw    -- triangular lag window
+      triangle_sw    -- triangular spectral window
+      yulewalker     -- fit AR model by Yule-Walker method
 
     In statistics/base (new directory):
 
-      center
-      cloglog
-      cor
-      cov
-      cut
-      iqr
-      kendall
-      logit
-      mean
-      meansq
-      moment
-      ppplot
-      probit
-      qqplot
-      range
-      ranks
-      run_count
-      spearman
-      statistics
-      studentize
-      table
-      values
-      var
+      center     -- center by subtracting means
+      cloglog    -- complementary log-log function
+      cor        -- compute correlations
+      cov        -- compute covariances
+      cut        -- cut data into intervals
+      iqr        -- interquartile range
+      kendall    -- kendall's rank correlation tau
+      logit      -- logit transformation
+      mean       -- compute arithmetic, geometric, and harmonic mean
+      meansq     -- compute mean square
+      moment     -- compute moments
+      ppplot     -- perform a PP-plot (probability plot)
+      probit     -- probit transformation
+      qqplot     -- perform a QQ-plot (quantile plot)
+      range      -- compute range
+      ranks      -- compute ranks
+      run_count  -- count upward runs
+      spearman   -- spearman's rank correlation rho
+      statistics -- compute basic statistics
+      studentize -- subtract mean and divide by standard deviation
+      table      -- cross tabulation
+      values     -- extract unique elements
+      var        -- compute variance
 
     In statistics/distributions (new directory):
 
-      beta_cdf
-      beta_inv
-      beta_pdf
-      beta_rnd
-      binomial_cdf
-      binomial_inv
-      binomial_pdf
-      binomial_rnd
-      cauchy_cdf
-      cauchy_inv
-      cauchy_pdf
-      cauchy_rnd
-      chisquare_cdf
-      chisquare_inv
-      chisquare_pdf
-      chisquare_rnd
-      discrete_cdf
-      discrete_inv
-      discrete_pdf
-      discrete_rnd
-      empirical_cdf
-      empirical_inv
-      empirical_pdf
-      empirical_rnd
-      exponential_cdf
-      exponential_inv
-      exponential_pdf
-      exponential_rnd
-      f_cdf
-      f_inv
-      f_pdf
-      f_rnd
-      gamma_cdf
-      gamma_inv
-      gamma_pdf
-      gamma_rnd
-      geometric_cdf
-      geometric_inv
-      geometric_pdf
-      geometric_rnd
-      hypergeometric_cdf
-      hypergeometric_inv
-      hypergeometric_pdf
-      hypergeometric_rnd
-      kolmogorov_smirnov_cdf
-      laplace_cdf
-      laplace_inv
-      laplace_pdf
-      laplace_rnd
-      logistic_cdf
-      logistic_inv
-      logistic_pdf
-      logistic_rnd
-      lognormal_cdf
-      lognormal_inv
-      lognormal_pdf
-      lognormal_rnd
-      normal_cdf
-      normal_inv
-      normal_pdf
-      normal_rnd
-      pascal_cdf
-      pascal_inv
-      pascal_pdf
-      pascal_rnd
-      poisson_cdf
-      poisson_inv
-      poisson_pdf
-      poisson_rnd
-      stdnormal_cdf
-      stdnormal_inv
-      stdnormal_pdf
-      stdnormal_rnd
-      t_cdf
-      t_inv
-      t_pdf
-      t_rnd
-      uniform_cdf
-      uniform_inv
-      uniform_pdf
-      uniform_rnd
-      weibull_cdf
-      weibull_inv
-      weibull_pdf
-      weibull_rnd
-      wiener_rnd
+      beta_cdf           -- CDF of the Beta distribution
+      beta_inv           -- Quantile function of the Beta distribution
+      beta_pdf           -- PDF of the Beta distribution
+      beta_rnd           -- Random deviates from the Beta distribution
+
+      binomial_cdf       -- CDF of the binomial distribution
+      binomial_inv       -- Quantile function of the binomial distribution
+      binomial_pdf       -- PDF of the binomial distribution
+      binomial_rnd       -- Random deviates from the binomial distribution
+
+      cauchy_cdf         -- CDF of the Cauchy distribution
+      cauchy_inv         -- Quantile function of the Cauchy distribution
+      cauchy_pdf         -- PDF of the Cauchy distribution
+      cauchy_rnd         -- Random deviates from the Cauchy distribution
+
+      chisquare_cdf      -- CDF of the chi-square distribution
+      chisquare_inv      -- Quantile function of the chi-square distribution
+      chisquare_pdf      -- PDF of the chi-sqaure distribution
+      chisquare_rnd      -- Random deviates from the chi-square distribution
+
+      discrete_cdf       -- CDF of a discrete distribution
+      discrete_inv       -- Quantile function of a discrete distribution
+      discrete_pdf       -- PDF of a discrete distribution
+      discrete_rnd       -- Random deviates from a discrete distribution
+
+      empirical_cdf      -- CDF of the empirical distribution
+      empirical_inv      -- Quantile function of the empirical distribution
+      empirical_pdf      -- PDF of the empirical distribution
+      empirical_rnd      -- Bootstrap samples from the empirical distribution
+
+      exponential_cdf    -- CDF of the exponential distribution
+      exponential_inv    -- Quantile function of the exponential distribution
+      exponential_pdf    -- PDF of the exponential distribution
+      exponential_rnd    -- Random deviates from the exponential distribution
+
+      f_cdf              -- CDF of the F distribution
+      f_inv              -- Quantile function of the F distribution
+      f_pdf              -- PDF of the F distribution
+      f_rnd              -- Random deviates from the F distribution
+
+      gamma_cdf          -- CDF of the Gamma distribution
+      gamma_inv          -- Quantile function of the Gamma distribution
+      gamma_pdf          -- PDF of the Gamma distribution
+      gamma_rnd          -- Random deviates from the Gamma distribution
+
+      geometric_cdf      -- CDF of the geometric distribution
+      geometric_inv      -- Quantile function of the geometric distribution
+      geometric_pdf      -- PDF of the geometric distribution
+      geometric_rnd      -- Random deviates from the geometric distribution
+
+      hypergeometric_cdf -- CDF of the hypergeometric distribution
+      hypergeometric_inv -- Random deviates from hypergeometric distribution
+      hypergeometric_pdf -- PDF of the hypergeometric distribution
+      hypergeometric_rnd -- Random deviates from hypergeometric distribution
+
+      kolmogorov_smirnov_cdf -- CDF of the Kolmogorov-Smirnov distribution
+
+      laplace_cdf        -- CDF of the Laplace distribution
+      laplace_inv        -- Quantile function of the Laplace distribution
+      laplace_pdf        -- PDF of the Laplace distribution
+      laplace_rnd        -- Random deviates from the Laplace distribution
+
+      logistic_cdf       -- CDF of the logistic distribution
+      logistic_inv       -- Quantile function of the logistic distribution
+      logistic_pdf       -- PDF of the logistic distribution
+      logistic_rnd       -- Random deviates from the logistic distribution
+
+      lognormal_cdf      -- CDF of the log normal distribution
+      lognormal_inv      -- Quantile function of the log normal distribution
+      lognormal_pdf      -- PDF of the log normal distribution
+      lognormal_rnd      -- Random deviates from the log normal distribution
+
+      normal_cdf         -- CDF of the normal distribution
+      normal_inv         -- Quantile function of the normal distribution
+      normal_pdf         -- PDF of the normal distribution
+      normal_rnd         -- Random deviates from the normal distribution
+
+      pascal_cdf         -- CDF of the Pascal (negative binomial) distribution
+      pascal_inv         -- Quantile function of the Pascal distribution
+      pascal_pdf         -- PDF of the Pascal (negative binomial) distribution
+      pascal_rnd         -- Random deviates from the Pascal distribution
+
+      poisson_cdf        -- CDF of the Poisson distribution
+      poisson_inv        -- Quantile function of the Poisson distribution
+      poisson_pdf        -- PDF of the Poisson distribution
+      poisson_rnd        -- Random deviates from the Poisson distribution
+
+      stdnormal_cdf      -- CDF of the standard normal distribution
+      stdnormal_inv      -- Quantile function of standard normal distribution
+      stdnormal_pdf      -- PDF of the standard normal distribution
+      stdnormal_rnd      -- Random deviates from standard normal distribution
+
+      t_cdf              -- CDF of the t distribution
+      t_inv              -- Quantile function of the t distribution
+      t_pdf              -- PDF of the t distribution
+      t_rnd              -- Random deviates from the t distribution
+
+      uniform_cdf        -- CDF of the uniform distribution
+      uniform_inv        -- Quantile function of the uniform distribution
+      uniform_pdf        -- PDF of the uniform distribution
+      uniform_rnd        -- Random deviates from the uniform distribution
+
+      weibull_cdf        -- CDF of the Weibull distribution
+      weibull_inv        -- Quantile function of the Weibull distribution
+      weibull_pdf        -- PDF of the Weibull distribution
+      weibull_rnd        -- Random deviates from the Weibull distribution
+
+      wiener_rnd         -- Simulate a Wiener process
 
     In statistics/models (new directory):
 
-      logistic_regression
-      logistic_regression_derivatives
-      logistic_regression_likelihood
+      logistic_regression             -- ordinal logistic regression
+      logistic_regression_derivatives -- derivates of log-likelihood
+                                         in logistic regression
+      logistic_regression_likelihood  -- likelihood in logistic regression
 
     In statistics/tests (new directory):
 
-      anova
-      bartlett_test
-      chisquare_test_homogeneity
-      chisquare_test_independence
-      cor_test
-      f_test_regression
-      hotelling_test
-      hotelling_test_2
-      kolmogorov_smirnov_test
-      kolmogorov_smirnov_test_2
-      kruskal_wallis_test
-      manova
-      mcnemar_test
-      prop_test_2
-      run_test
-      sign_test
-      t_test
-      t_test_2
-      t_test_regression
-      u_test
-      var_test
-      welch_test
-      wilcoxon_test
-      z_test
-      z_test_2
+      anova                       -- one-way analysis of variance
+      bartlett_test               -- bartlett test for homogeneity of variances
+      chisquare_test_homogeneity  -- chi-square test for homogeneity
+      chisquare_test_independence -- chi-square test for independence
+      cor_test                    -- test for zero correlation
+      f_test_regression           -- test linear hypotheses in linear
+                                     regression model
+      hotelling_test              -- test for mean of a multivariate normal
+      hotelling_test_2            -- compare means of two multivariate normals
+      kolmogorov_smirnov_test     -- one-sample Kolmogorov-Smirnov test
+      kolmogorov_smirnov_test_2   -- two-sample Kolmogorov-Smirnov test
+      kruskal_wallis_test         -- kruskal-Wallis test
+      manova                      -- one-way multivariate analysis of variance
+      mcnemar_test                -- mcnemar's test for symmetry
+      prop_test_2                 -- compare two proportions
+      run_test                    -- run test for independence
+      sign_test                   -- sign test
+      t_test                      -- student's one-sample t test 
+      t_test_2                    -- student's two-sample t test
+      t_test_regression           -- test one linear hypothesis in linear
+                                     regression model
+      u_test                      -- mann-Whitney U-test
+      var_test                    -- f test to compare two variances
+      welch_test                  -- welch two-sample t test
+      wilcoxon_test               -- wilcoxon signed-rank test
+      z_test                      -- test for mean of a normal sample with
+                                     known variance
+      z_test_2                    -- compare means of two normal samples with
+                                     known variances
 
-  * The load command now accepts the option -append to save the
+  * The save command now accepts the option -append to save the
     variables at the end of the file, leaving the existing contents.
 
   * New command-line option --no-history (also available using the
     single character option -H) inhibits saving command history.
 
   * The mkoctfile script now accepts -DDEF options and passes them on
     to the C and C++ compilers.
 
diff --git a/doc/interpreter/preface.texi b/doc/interpreter/preface.texi
--- a/doc/interpreter/preface.texi
+++ b/doc/interpreter/preface.texi
@@ -127,17 +127,17 @@ number of lines in a single call.  He al
 incompatibilities and bugs.
 
 @item
 Mark Odegard @email{meo@@sugarland.unocal.com} provided the initial
 implementation of @code{fread}, @code{fwrite}, @code{feof}, and
 @code{ferror}.
 
 @item
-Tony Richardson @email{tony@@guts.biomed.uakron.edu} wrote Octave's
+Tony Richardson @email{arichard@stark.cc.oh.us} wrote Octave's
 image processing functions as well as most of the original polynomial
 functions.
 
 @item
 R. Bruce Tenison @email{Bruce.Tenison@@eng.auburn.edu} wrote the
 @code{hess} and @code{schur} functions.
 
 @item
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,10 +1,23 @@
 Wed Oct 28 11:51:14 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* general/is_square.m: 
+
+	* general/isempty.m, general/is_matrix.m: Delete.
+
+	* general/is_symmetric: Delete special case for strings.  Whether
+	the conversion is valid should depend on implicit_str_to_num_ok.
+
+	* general/is_square.m: If arg is not a matrix, don't check size,
+	just return 0.
+	* general/is_symmetric: Likewise.
+	* general/is_vector.m: Likewise.
+	* general/is_scalar.m: Likewise.
+
 	* general/length.m: Delete.
 
 Fri Oct 23 00:21:55 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* configure.in: Add finance/Makefile, statistics/base/Makefile,
 	statistics/distributions/Makefile, statistics/models/Makefile, 
 	and statistics/tests/Makefile to the list of files to create.
 
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -24,17 +24,17 @@
 ##
 ## If length (x) > l, elements from the end of x are removed
 ## until a vector of length l is obtained.
 
 function y = postpad (x, l, c)
 
   ## Author:
   ##  Tony Richardson
-  ##  amr@mpl.ucsd.edu
+  ##  arichard@stark.cc.oh.us
   ##  June 1994
 
   if (nargin == 2)
     c = 0;
   elseif (nargin < 2 || nargin > 3)
     usage ("postpad (x, l) or postpad (x, l, c)");
   endif
 
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -24,17 +24,17 @@
 ##
 ## If length (x) > l, elements from the beginning of x are removed
 ## until a vector of length l is obtained.
 
 function y = prepad (x, l, c)
 
   ## Author:
   ##  Tony Richardson
-  ##  amr@mpl.ucsd.edu
+  ##  arichard@stark.cc.oh.us
   ##  June 1994
 
   if (nargin == 2)
     c = 0;
   elseif (nargin < 2 || nargin > 3)
     usage ("prepad (x, l) or prepad (x, l, c)");
   endif
 
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -24,17 +24,17 @@
 ## intensities respectively.  All entries should be between 0 and 1
 ## inclusive. The new colormap is returned.
 ##
 ## colormap ("default") restores the default colormap (a gray scale
 ## colormap with 64 entries). The default colormap is returned.
 ##
 ## colormap with no arguments returns the current colormap.
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function cmap = colormap (map)
 
   global __current_color_map__ = gray ();
 
   if (nargin > 1)
diff --git a/scripts/image/gray.m b/scripts/image/gray.m
--- a/scripts/image/gray.m
+++ b/scripts/image/gray.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## Colormap.
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function map = gray (number)
 
   if (nargin == 0)
     number = 64;
   elseif (nargin > 1)
diff --git a/scripts/image/gray2ind.m b/scripts/image/gray2ind.m
--- a/scripts/image/gray2ind.m
+++ b/scripts/image/gray2ind.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## Image format conversion
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [X, map] = gray2ind (I, n)
 
   if (nargin < 1 || nargin > 2)
     usage ("gray2ind (I, n)");
   elseif (nargin == 1)
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -22,17 +22,17 @@
 ## image (x) displays a matrix as a color image. The elements of x are
 ## indices into the current colormap and should have values between 1
 ## and the length of the colormap.
 ##
 ## image (x, zoom) changes the zoom factor.  The default value is 4.
 ##
 ## SEE ALSO: imshow, imagesc, colormap.
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function image (x, zoom)
 
   if (nargin == 0)
     ## Load Bobbie Jo Richardson (Born 3/16/94)
     x = loadimage ("default.img");
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -22,17 +22,17 @@
 ## imagesc(x) displays a scaled version of the matrix x.  The matrix is
 ## scaled so that its entries are indices into the current colormap.
 ## The scaled matrix is returned.
 ##
 ## imagesc (x, zoom) sets the magnification, the default value is 4.
 ##
 ## SEE ALSO: image, imshow
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function x = imagesc (x, zoom)
 
   if (nargin < 1 || nargin > 2)
     usage ("image (matrix, [zoom])");
   elseif (nargin == 1)
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -24,17 +24,17 @@
 ## imshow (X, map) displays an indexed image using the specified colormap.
 ##
 ## imshow (I, n) displays a gray scale intensity image.
 ##
 ## imshow (R, G, B) displays an RGB image.
 ##
 ## SEE ALSO: image, imagesc, colormap, gray2ind, rgb2ind.
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function imshow (a1, a2, a3)
 
   if (nargin < 0 || nargin > 3)
     usage ("imshow (args)");
   elseif (nargin == 2)
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -23,17 +23,17 @@
 ## image.  The current colormap is used to determine the intensities.
 ## The intensity values lie between 0 and 1 inclusive.
 ##
 ## Y = ind2gray (X, map) uses the specified colormap instead of the
 ## current one in the conversion process.
 ##
 ## SEE ALSO: gray2ind, rgb2ntsc, image, colormap
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function Y = ind2gray (X, map)
 
   if (nargin < 1 || nargin > 2)
     usage ("ind2gray (X, map)");
   elseif (nargin == 1)
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -20,17 +20,17 @@
 ## Convert an indexed image to red, green, and blue color components.
 ##
 ## [R G B] = ind2rgb(X) uses the current colormap for the conversion.
 ##
 ## [R G B] = ind2rgb(X,map) uses the specified colormap.
 ##
 ## SEE ALSO: rgb2ind, image, imshow, ind2gray, gray2ind.
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [R, G, B] = ind2rgb (X, map)
 
   if (nargin < 1 || nargin > 2)
     usage ("ind2rgb (X, map)");
   elseif (nargin == 1)
diff --git a/scripts/image/loadimage.m b/scripts/image/loadimage.m
--- a/scripts/image/loadimage.m
+++ b/scripts/image/loadimage.m
@@ -20,17 +20,17 @@
 ## Load an image file.
 ##
 ## [img, map] = loadimage (img_file) loads an image and it's associated
 ## color map from file img_file.  The image must be in stored in
 ## octave's image format.
 ##
 ## SEE ALSO: saveimage, load, save
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [img_retval, map_retval] = loadimage (filename)
 
   if (nargin != 1)
     usage ("[img, map] = loadimage (filename)");
   elseif (! isstr (filename))
diff --git a/scripts/image/ntsc2rgb.m b/scripts/image/ntsc2rgb.m
--- a/scripts/image/ntsc2rgb.m
+++ b/scripts/image/ntsc2rgb.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## Image format conversion.
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function rgb = ntsc2rgb (yiq)
 
   if (nargin != 1)
     usage ("ntsc2rgb (yiq)");
   endif
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## Colormap.
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function map = ocean (number)
 
   if (nargin == 0)
     number = 64;
   elseif (nargin == 1)
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -20,17 +20,17 @@
 ## Convert and RGB image to an octave indexed image.
 ##
 ## [X, map] = rgb2ind (R, G, B)
 ##
 ## SEE ALSO: ind2rgb, rgb2ntsc.
 ##
 ## Bugs: The color map may have duplicate entries.
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [X, map] = rgb2ind (R, G, B)
 
   if (nargin != 3)
     usage ("[X, map] = rgb2ind (R, G, B)");
   endif
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## Image format conversion.
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function yiq = rgb2ntsc (rgb)
 
   if (nargin != 1)
     usage ("rgb2ntsc (rgb)");
   endif
diff --git a/scripts/image/saveimage.m b/scripts/image/saveimage.m
--- a/scripts/image/saveimage.m
+++ b/scripts/image/saveimage.m
@@ -47,17 +47,17 @@
 ##   George Phillips <phillips@cs.ubc.ca>
 ##   Department of Computer Science
 ##   University of British Columbia
 ##
 ## and is part of the portable bitmap utilities,
 ##
 ## SEE ALSO: loadimage, save, load, colormap
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 ## Rewritten by jwe to avoid using octoppm and pbm routines so that
 ## people who don't have the the pbm stuff installed can still use this
 ## function.
 ##
 ## The conversion to PostScript is based on pnmtops.c, which is part of
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -37,17 +37,17 @@
 ##        |       .            .           .    .             .      |
 ##        |_      0            0      ...       1             0     _|
 ##
 ## The eigenvalues of the companion matrix are equal to the roots of the
 ## polynomial.
 ##
 ## SEE ALSO: poly, roots, residue, conv, deconv, polyval, polyderiv, polyinteg
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function A = compan (c)
 
   if (nargin != 1)
     usage ("compan (vector)");
   endif
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -24,17 +24,17 @@
 ## y = conv (a, b) returns a vector of length equal to length (a) +
 ## length (b) -1.
 ##
 ## If a and b are polynomial coefficient vectors, conv returns the
 ## coefficients of the product polynomial.
 ##
 ## SEE ALSO: deconv, poly, roots, residue, polyval, polyderiv, polyinteg
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = conv (a, b)
 
   if (nargin != 2)
     usage ("conv(a, b)");
   endif
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -26,17 +26,17 @@
 ##
 ## If y and a are polynomial coefficient vectors, b will contain the
 ## coefficients of the polynomial quotient and r will be a remander
 ## polynomial of lowest order.
 ##
 ## SEE ALSO: conv, poly, roots, residue, polyval, polyderiv,
 ## polyinteg
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [b, r] = deconv (y, a)
 
   if (nargin != 2)
     usage ("deconv (y, a)");
   endif
diff --git a/scripts/polynomial/polyderiv.m b/scripts/polynomial/polyderiv.m
--- a/scripts/polynomial/polyderiv.m
+++ b/scripts/polynomial/polyderiv.m
@@ -20,17 +20,17 @@
 ## usage: polyderiv (p)
 ##
 ## Returns the coefficients of the derivative of the polynomial whose
 ## coefficients are given by vector p.
 ##
 ## SEE ALSO: poly, polyinteg, polyreduce, roots, conv, deconv, residue,
 ##           filter, polyval, polyvalm
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function q = polyderiv (p)
 
   if (nargin != 1)
     usage ("polyderiv (vector)");
   endif
diff --git a/scripts/polynomial/polyinteg.m b/scripts/polynomial/polyinteg.m
--- a/scripts/polynomial/polyinteg.m
+++ b/scripts/polynomial/polyinteg.m
@@ -22,17 +22,17 @@
 ## Returns the coefficients of the integral the polynomial whose coefficients
 ## are represented by the vector p.
 ##
 ## The constant of integration is zero.
 ##
 ## SEE ALSO: poly, polyderiv, polyreduce, roots, conv, deconv, residue,
 ##           filter, polyval, polyvalm
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function p = polyinteg (p)
 
   if(nargin != 1)
     usage ("polyinteg (vector)");
   endif
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -20,17 +20,17 @@
 ## usage: polyreduce(c)
 ##
 ## Reduces a polynomial coefficient vector to a minimum number of terms,
 ## i.e. it strips off any leading zeros.
 ##
 ## SEE ALSO: poly, roots, conv, deconv, residue, filter, polyval, polyvalm,
 ##           polyderiv, polyinteg
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function p = polyreduce (p)
 
   if (nargin != 1)
     usage ("polyreduce (p)");
   endif
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -30,17 +30,17 @@
 ## polyval(c,x) will evaluate the polynomial at the specified value of x.
 ##
 ## If x is a vector or matrix, the polynomial is evaluated at each of the
 ## elements of x.
 ##
 ## SEE ALSO: polyvalm, poly, roots, conv, deconv, residue, filter,
 ##           polyderiv, polyinteg
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = polyval (c, x)
 
   if (nargin != 2)
     usage ("polyval (c, x)");
   endif
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -31,17 +31,17 @@
 ## multiplication is used instead of element by element multiplication as is
 ## used in polyval.
 ##
 ## X must be a square matrix.
 ##
 ## SEE ALSO: polyval, poly, roots, conv, deconv, residue, filter,
 ##           polyderiv, polyinteg
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = polyvalm (c, x)
 
   if (nargin != 2)
     usage ("polyvalm (c, x)");
   endif
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -57,17 +57,17 @@
 ##  which implies the following partial fraction expansion
 ##
 ##        s^2 + s + 1         -2       7        3
 ##    ------------------- = ----- + ------- + -----
 ##    s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)
 ##
 ## SEE ALSO: poly, roots, conv, deconv, polyval, polyderiv, polyinteg
 
-## Author: Tony Richardson <amr@mpl.ucsd.edu>
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [r, p, k, e] = residue (b, a, toler)
 
   ## Here's the method used to find the residues.
   ## The partial fraction expansion can be written as:
   ##
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,39 @@
+Thu Oct 29 09:27:04 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* ov-list.cc (Fsplice): Use new octave_value::int_value function here.
+	(octave_list::do_index_op): Likewise.
+	(octave_list::assign): Likewise.
+	* toplev.cc (Fquit): Likewise.
+	* syscalls.cc (Fwaitpid): Likewise.
+	(Ffcntl): Likewise.
+	* file-io.cc (do_fread): Likewise.
+	(do_fwrite): Likewise.
+	* data.cc (make_diag): Likewise.
+	(Fsize): Likewise.
+	(get_dimensions): Likewise.
+	(Flinspace): 
+
+	* ov-base.cc (octave_base_value::int_value): New function.
+	(octave_base_value::nint_value): Ditto.
+	* ov.h (octave_value::int_value): Ditto.
+	(octave_value::nint_value): Ditto.
+
+	* ov-list.cc (octave_list::assign): Fix off-by-one error.
+
 Wed Oct 28 11:01:37 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* load-save.cc (read_mat_ascii_data): Try harder to convert file
+	name to valid variable name.
+
+	* data.cc (Fisempty, Fis_matrix): New functions.
+
+	* ov-str-mat.h (octave_char_matrix_str::is_matrix_type): New function.
+
 	* OPERATORS/op-list.cc: New file.
 	* Makefile.in (OP_XSRC): Add it to the list.
 
 	* ov-list.cc (octave_list::assign): New function.
 
 	* ov-typeinfo.h (octave_value_typeinfo::assignany_ops):
 	New data member.
 	* ov-typeinfo.cc (octave_value_info::register_assignany_op,
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -440,25 +440,24 @@ make_diag (const octave_value& arg)
   return retval;
 }
 
 static octave_value
 make_diag (const octave_value& a, const octave_value& b)
 {
   octave_value retval;
 
-  double tmp = b.double_value ();
+  int k = b.nint_value ();
 
   if (error_state)
     {
       error ("diag: invalid second argument");      
       return retval;
     }
 
-  int k = NINT (tmp);
   int n = ABS (k) + 1;
 
   if (a.is_real_type ())
     {
       if (a.is_scalar_type ())
 	{
 	  double d = a.double_value ();
 
@@ -649,17 +648,17 @@ m = size (x, 2): return number of column
       else if (nargout == 2)
 	{
 	  retval(1) = static_cast<double> (nc);
 	  retval(0) = static_cast<double> (nr);
 	}
     }
   else if (nargin == 2 && nargout < 2)
     {
-      int nd = NINT (args(1).double_value ());
+      int nd = args(1).nint_value ();
 
       if (error_state)
 	error ("size: expecting scalar as second argument");
       else
 	{
 	  if (nd == 1)
 	    retval(0) = static_cast<double> (args(0).rows ());
 	  else if (nd == 2)
@@ -762,16 +761,56 @@ DEFUN (is_complex, args, ,
   if (args.length () == 1)
     retval = args(0).is_complex_type () ? 1.0 : 0.0;
   else
     print_usage ("is_complex");
 
   return retval;
 }
 
+DEFUN (isempty, args, ,
+  "isempty (x): return nonzero if x is an empty matrix or empty list")
+{
+  double retval = 0.0;
+
+  if (args.length () == 1)
+    {
+      octave_value arg = args(0);
+
+      if (arg.is_matrix_type ())
+	retval = static_cast<double> (arg.rows () == 0 || arg.columns () == 0);
+      else if (arg.is_list ())
+	retval = static_cast<double> (arg.length () == 0);
+    }
+  else
+    print_usage ("isempty");
+
+  return retval;
+}
+
+DEFUN (is_matrix, args, ,
+  "is_matrix (x): return nonzero if x can be considered a matrix")
+{
+  double retval = 0.0;
+
+  if (args.length () == 1)
+    {
+      octave_value arg = args(0);
+
+      if (arg.is_scalar_type ())
+	retval = 1.0;
+      else if (arg.is_matrix_type ())
+	retval = static_cast<double> (arg.rows () >= 1 && arg.columns () >= 1);
+    }
+  else
+    print_usage ("is_matrix");
+
+  return retval;
+}
+
 DEFUN (is_struct, args, ,
   "is_struct (x): return nonzero if x is a structure")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_map () ? 1.0 : 0.0;
   else
@@ -858,18 +897,17 @@ check_dimensions (int& nr, int& nc, cons
 }
 
 static void
 get_dimensions (const octave_value& a, const char *warn_for,
 		int& nr, int& nc)
 {
   if (a.is_scalar_type ())
     {
-      double tmp = a.double_value ();
-      nr = nc = NINT (tmp);
+      nr = nc = a.nint_value ();
     }
   else
     {
       nr = a.rows ();
       nc = a.columns ();
 
       if ((nr == 1 && nc == 2) || (nr == 2 && nc == 1))
 	{
@@ -887,18 +925,18 @@ get_dimensions (const octave_value& a, c
 
   check_dimensions (nr, nc, warn_for); // May set error_state.
 }
 
 static void
 get_dimensions (const octave_value& a, const octave_value& b,
 		const char *warn_for, int& nr, int& nc)
 {
-  nr = (a.is_empty ()) ? 0 : NINT (a.double_value ());
-  nc = (b.is_empty ()) ? 0 : NINT (b.double_value ());
+  nr = a.is_empty () ? 0 : a.nint_value ();
+  nc = b.is_empty () ? 0 : b.nint_value ();
 
   if (error_state)
     error ("%s: expecting two scalar arguments", warn_for);
   else
     check_dimensions (nr, nc, warn_for); // May set error_state.
 }
 
 static octave_value
@@ -1079,22 +1117,17 @@ See also: logspace")
 
   if (nargin != 2 && nargin != 3)
     {
       print_usage ("linspace");
       return retval;
     }
 
   if (nargin == 3)
-    {
-      double n = args(2).double_value ();
-
-      if (! error_state)
-	npoints = NINT (n);
-    }
+    npoints = args(2).nint_value ();
 
   if (! error_state)
     {
       if (npoints > 1)
 	{
 	  octave_value arg_1 = args(0);
 	  octave_value arg_2 = args(1);
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -875,42 +875,35 @@ do_fread (octave_stream& os, const octav
 
       if (! error_state)
 	{
 	  oct_data_conv::data_type dt
 	    = oct_data_conv::string_to_data_type (prec);
 
 	  if (! error_state)
 	    {
-	      double dskip = skip_arg.double_value ();
+	      int skip = skip_arg.int_value (true);
 
 	      if (! error_state)
 		{
-		  if (D_NINT (dskip) == dskip)
+		  string arch = arch_arg.string_value ();
+
+		  if (! error_state)
 		    {
-		      int skip = NINT (dskip);
-
-		      string arch = arch_arg.string_value ();
+		      oct_mach_info::float_format flt_fmt
+			= oct_mach_info::string_to_float_format (arch);
 
 		      if (! error_state)
-			{
-			  oct_mach_info::float_format flt_fmt
-			    = oct_mach_info::string_to_float_format (arch);
-
-			  if (! error_state)
-			    retval = os.read (size, dt, skip, flt_fmt, count);
-			}
-		      else
-			::error ("fread: architecture type must be a string");
+			retval = os.read (size, dt, skip, flt_fmt, count);
 		    }
 		  else
-		    ::error ("fread: skip must be an integer");
+		    ::error ("fread: architecture type must be a string");
 		}
 	      else
-		::error ("fread: invalid skip specified");
+		::error ("fread: skip must be an integer");
 	    }
 	  else
 	    ::error ("fread: invalid data type specified");
 	}
       else
 	::error ("fread: precision must be a string");
     }
   else
@@ -1017,43 +1010,38 @@ do_fwrite (octave_stream& os, const octa
 
   if (! error_state)
     {
       oct_data_conv::data_type dt
 	= oct_data_conv::string_to_data_type (prec);
 
       if (! error_state)
 	{
-	  double dskip = skip_arg.double_value ();
+	  int skip = skip_arg.int_value (true);
 
 	  if (! error_state)
 	    {
-	      if (D_NINT (dskip) == dskip)
+	      string arch = arch_arg.string_value ();
+
+	      if (! error_state)
 		{
-		  int skip = NINT (dskip);
-
-		  string arch = arch_arg.string_value ();
+		  oct_mach_info::float_format flt_fmt
+		    = oct_mach_info::string_to_float_format (arch);
 
 		  if (! error_state)
-		    {
-		      oct_mach_info::float_format flt_fmt
-			= oct_mach_info::string_to_float_format (arch);
-
-		      if (! error_state)
-			retval = os.write (data, dt, skip, flt_fmt);
-		    }
-		  else
-		    ::error ("fwrite: architecture type must be a string");
+		    retval = os.write (data, dt, skip, flt_fmt);
 		}
 	      else
-		::error ("fwrite: skip must be an integer");
+		::error ("fwrite: architecture type must be a string");
 	    }
 	  else
-	    ::error ("fwrite: invalid skip specified");
+	    ::error ("fwrite: skip must be an integer");
 	}
+      else
+	::error ("fwrite: invalid precision specified");
     }
   else
     ::error ("fwrite: precision must be a string");
 
   return retval;
 }
 
 DEFUN (fwrite, args, ,
@@ -1336,40 +1324,38 @@ be interpreted as an octal number); othe
 printed.")
 {
   octave_value_list retval;
 
   int status = 0;
 
   if (args.length () == 1)
     {
-      double dmask = args(0).double_value ();
+      int mask = args(0).int_value (true);
 
-      if (error_state)
+      if (! error_state)
 	{
-	  status = -1;
-	  ::error ("umask: expecting integer argument");
-	}
-      else
-	{
-	  int mask = NINT (dmask);
-
-	  if (mask != dmask || mask < 0)
+	  if (mask < 0)
 	    {
 	      status = -1;
 	      ::error ("umask: MASK must be a positive integer value");
 	    }
 	  else
 	    {
 	      int oct_mask = convert (mask, 8, 10);
 
 	      if (! error_state)
 		status = convert (file_ops::umask (oct_mask), 10, 8);
 	    }
 	}
+      else
+	{
+	  status = -1;
+	  ::error ("umask: expecting integer argument");
+	}
     }
   else
     print_usage ("umask");
 
   if (status >= 0)
     retval(0) = static_cast<double> (status);
 
   return retval;
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1023,23 +1023,28 @@ get_lines_and_columns (istream& is, cons
 static char *
 read_mat_ascii_data (istream& is, const string& filename,
 		     octave_value& tc)
 {
   char *name = 0;
 
   string varname;
 
-  size_t pos = filename.find ('.');
+  size_t pos = filename.rfind ('/');
 
   if (pos != NPOS)
-    varname = filename.substr (0, pos);
+    varname = filename.substr (pos+1);
   else
     varname = filename;
 
+  pos = varname.find ('.');
+
+  if (pos != NPOS)
+    varname = varname.substr (0, pos);
+
   if (valid_identifier (varname.c_str ()))
     {
       int nr = 0;
       int nc = 0;
 
       get_lines_and_columns (is, filename, nr, nc);
 
       if (! error_state && nr > 0 && nc > 0)
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -162,16 +162,62 @@ octave_base_value::columns (void) const
 int
 octave_base_value::length (void) const
 {
   int retval = -1;
   gripe_wrong_type_arg ("octave_base_value::length ()", type_name ());
   return retval;
 }
 
+int
+octave_base_value::int_value (bool require_int, bool frc_str_conv) const
+{
+  int retval = 0;
+
+  double d = double_value (frc_str_conv);
+
+  if (! error_state)
+    {
+      if (require_int && D_NINT (d) != d)
+	{
+	  error ("conversion to integer value failed");
+	  return retval;
+	}
+
+      retval = static_cast<int> (d);
+    }
+  else
+    gripe_wrong_type_arg ("octave_base_value::int_value ()", type_name ());
+
+  return retval;
+}
+
+int
+octave_base_value::nint_value (bool frc_str_conv) const
+{
+  int retval = 0;
+
+  double d = double_value (frc_str_conv);
+
+  if (! error_state)
+    {
+      if (xisnan (d))
+	{
+	  error ("conversion of NaN to integer value failed");
+	  return retval;
+	}
+
+      retval = NINT (d);
+    }
+  else
+    gripe_wrong_type_arg ("octave_base_value::nint_value ()", type_name ());
+
+  return retval;
+}
+
 double
 octave_base_value::double_value (bool) const
 {
   double retval = octave_NaN;
   gripe_wrong_type_arg ("octave_base_value::double_value ()", type_name ());
   return retval;
 }
 
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -142,16 +142,20 @@ public:
 
   bool is_zero_by_zero (void) const
     { return (rows () == 0 && columns () == 0); }
 
   bool is_constant (void) const { return false; }
 
   bool is_function (void) const { return false; }
 
+  int int_value (bool = false, bool = false) const;
+
+  int nint_value (bool = false) const;
+
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
     { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -49,64 +49,54 @@ octave_list::t_name ("list");
 
 octave_value
 octave_list::do_index_op (const octave_value_list& idx)
 {
   octave_value retval;
 
   if (idx.length () == 1)
     {
-      double d = idx(0).double_value ();
+      int i = idx(0).int_value (true);
 
       if (! error_state)
 	{
-	  if (D_NINT (d) == d)
-	    {
-	      int n = lst.length ();
-
-	      int i = static_cast<int> (d);
+	  int n = lst.length ();
 
-	      if (i > 0 && i <= n)
-		retval = lst(i-1);
-	      else
-		error ("list index = %d out of range", i);
-	    }
+	  if (i > 0 && i <= n)
+	    retval = lst(i-1);
 	  else
-	    error ("list index must be an integer");
+	    error ("list index = %d out of range", i);
 	}
+      else
+	error ("list index must be an integer");
     }
   else
     error ("lists may only be indexed by a single scalar");
 
   return retval;
 }
 
 void
 octave_list::assign (const octave_value_list& idx, const octave_value& rhs)
 {
   if (idx.length () == 1)
     {
-      double d = idx(0).double_value ();
+      int i = idx(0).int_value (true);
 
       if (! error_state)
 	{
-	  if (D_NINT (d) == d)
-	    {
-	      int n = lst.length ();
-
-	      int i = static_cast<int> (d);
+	  int n = lst.length ();
 
-	      if (i > 0 && (Vresize_on_range_error || i <= n))
-		lst(i) = rhs;
-	      else
-		error ("list index = %d out of range", i);
-	    }
+	  if (i > 0 && (Vresize_on_range_error || i <= n))
+	    lst(i-1) = rhs;
 	  else
-	    error ("list index must be an integer");
+	    error ("list index = %d out of range", i);
 	}
+      else
+	error ("list index must be an integer");
     }
   else
     error ("lists may only be indexed by a single scalar");
 }
 
 void
 octave_list::print (ostream& os, bool) const
 {
@@ -239,60 +229,48 @@ contents of LIST_2 (if any).  If LENGTH 
   int nargin = args.length ();
 
   if (nargin > 1 && nargin < 5)
     {
       octave_value_list list_1 = args(0).list_value ();
 
       if (! error_state)
 	{
-	  double d_offset = args(1).double_value ();
+	  int offset = args(1).int_value (true);
 
 	  if (! error_state)
 	    {
-	      if (D_NINT (d_offset) == d_offset)
-		{
-		  int offset = static_cast<int> (d_offset) - 1;
+	      offset--;
+
+	      int length = 0;
+
+	      octave_value_list list_2;
 
-		  int length = 0;
+	      if (nargin < 3)
+		length = list_1.length () - offset;
+	      else
+		{
+		  length = args(2).int_value (true);
 
-		  if (nargin < 3)
-		    length = list_1.length () - offset;
-		  else
+		  if (! error_state)
 		    {
-		      double d_length = args(2).double_value ();
+		      if (nargin == 4)
+			{
+			  list_2 = args(3).list_value ();
 
-		      if (error_state)
-			return retval;
-		      else
-			{
-			  if (D_NINT (d_length) == d_length)
-			    length = static_cast<int> (d_length);
-			  else
-			    error ("splice: LENGTH must be an integer");
+			  if (error_state)
+			    error ("splice: fourth argument must be a list");
 			}
 		    }
-
-		  octave_value_list list_2;
-
-		  if (nargin == 4)
-		    {
-		      list_2 = args(3).list_value ();
+		  else
+		    error ("splice: LENGTH must be an integer");
+		}
 
-		      if (error_state)
-			{
-			  error ("splice: fourth argument must be a list");
-			  return retval;
-			}
-		    }
-
-		  retval = list_1.splice (offset, length, list_2);
-		}
-	      else
-		error ("splice: OFFSET must be an integer");
+	      if (! error_state)
+		retval = list_1.splice (offset, length, list_2);
 	    }
 	  else
 	    error ("splice: OFFSET must be an integer");
 	}
       else
 	error ("splice: first argument must be a list");      
     }
   else
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -32,16 +32,17 @@ Software Foundation, 59 Temple Place - S
 #include <string>
 
 class ostream;
 
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "error.h"
+#include "ov.h"
 #include "ov-ch-mat.h"
 #include "ov-typeinfo.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
@@ -86,16 +87,18 @@ public:
   octave_value do_index_op (const octave_value_list& idx);
 
   void assign (const octave_value_list& idx, const charMatrix& rhs);
 
   bool is_string (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
+  bool is_matrix_type (void) const { return Vimplicit_str_to_num_ok; }
+
   bool valid_as_scalar_index (void) const;
   bool valid_as_zero_index (void) const;
 
   Matrix matrix_value (bool = false) const;
 
   string_vector all_strings (void) const;
 
   string string_value (void) const;
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -355,16 +355,22 @@ public:
 
   virtual bool is_function (void) const
     { return rep->is_function (); }
 
   // Values.
 
   octave_value eval (void) { return *this; }
 
+  virtual int int_value (bool req_int = false, bool frc_str_conv = false) const
+    { return rep->int_value (req_int, frc_str_conv); }
+
+  virtual int nint_value (bool frc_str_conv = false) const
+    { return rep->nint_value (frc_str_conv); }
+
   virtual double double_value (bool frc_str_conv = false) const
     { return rep->double_value (frc_str_conv); }
 
   virtual double scalar_value (bool frc_str_conv = false) const
     { return rep->scalar_value (frc_str_conv); }
 
   virtual Matrix matrix_value (bool frc_str_conv = false) const
     { return rep->matrix_value (frc_str_conv); }
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -214,44 +214,37 @@ STATUS is nonzero and MSG contains a sys
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 3)
     {
-      double d_fid = args(0).double_value ();
-      double d_req = args(1).double_value ();
-      double d_arg = args(2).double_value ();
+      int fid = args(0).int_value (true);
+      int req = args(1).int_value (true);
+      int arg = args(2).int_value (true);
 
-      if (! error_state
-	  && D_NINT (d_fid) == d_fid
-	  && D_NINT (d_req) == d_req
-	  && D_NINT (d_arg) == d_arg)
+      if (! error_state)
 	{
-	  int fid = NINT (d_fid);
-	  int req = NINT (d_req);
-	  int arg = NINT (d_arg);
-
 	  // XXX FIXME XXX -- Need better checking here?
 	  if (fid < 0)
 	    error ("fcntl: invalid file id");
 	  else
 	    {
 	      string msg;
 
 	      int status = octave_syscalls::fcntl (fid, req, arg, msg);
 
 	      retval(0) = static_cast<double> (status);
 	      retval(1) = msg;
 	    }
 	}
       else
-	error ("fcntl: file id must be an integer");
+	error ("fcntl: file id, request, and argument must be integers");
     }
   else
     print_usage ("fcntl");
 
   return retval;
 }
 
 DEFUN (fork, args, ,
@@ -658,57 +651,47 @@ error message.")
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      double pid_num = args(0).double_value ();
+      pid_t pid = args(0).int_value (true);
   
       if (! error_state)
 	{
-	  if (D_NINT (pid_num) != pid_num)
-	    error ("waitpid: PID must be an integer value");
-	  else
-	    {
-	      pid_t pid = (pid_t) pid_num;
-
-	      int options = 0;
-
-	      if (args.length () == 2)
-		{
-		  double options_num = args(1).double_value ();
+	  int options = 0;
 
-		  if (! error_state)
-		    {
-		      if (D_NINT (options_num) != options_num)
-			error ("waitpid: PID must be an integer value");
-		      else
-			{
-			  options = NINT (options_num);
-			  if (options < 0 || options > 3)
-			    error ("waitpid: invalid OPTIONS value specified");
-			}
-		    }
-		}
+	  if (args.length () == 2)
+	    {
+	      options = args(1).int_value (true);
 
 	      if (! error_state)
 		{
-		  string msg;
+		  if (options < 0 || options > 3)
+		    error ("waitpid: invalid OPTIONS value specified");
+		}
+	      else
+		error ("waitpid: OPTIONS must be in integer");
+	    }
 
-		  pid_t status
-		    = octave_syscalls::waitpid (pid, options, msg);
+	  if (! error_state)
+	    {
+	      string msg;
 
-		  retval(0) = static_cast<double> (status);
-		  retval(1) = msg;
-		}
+	      pid_t status = octave_syscalls::waitpid (pid, options, msg);
+
+	      retval(0) = static_cast<double> (status);
+	      retval(1) = msg;
 	    }
 	}
+      else
+	error ("waitpid: PID must be an integer value");
     }
   else
     print_usage ("waitpid");
 
   return retval;
 }
 
 #if !defined (O_NONBLOCK) && defined (O_NDELAY)
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -253,22 +253,20 @@ STATUS should be an integer value.  If S
   if (nargout == 0)
     {
       int exit_status = 0;
 
       quitting_gracefully = true;
 
       if (args.length () > 0)
 	{
-	  // XXX FIXME XXX -- need a safe uniform way to do this.
+	  int tmp = args(0).nint_value ();
 
-	  double tmp = args(0).double_value ();
-
-	  if (! error_state && ! xisnan (tmp))
-	    exit_status = NINT (tmp);
+	  if (! error_state)
+	    exit_status = tmp;
 	}
 
       clean_up_and_exit (exit_status);
     }
   else
     error ("quit: invalid number of output arguments");
 
   return retval;
diff --git a/src/version.h b/src/version.h
--- a/src/version.h
+++ b/src/version.h
@@ -18,17 +18,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_version_h)
 #define octave_version_h 1
 
-#define OCTAVE_VERSION "2.1.7"
+#define OCTAVE_VERSION "2.1.8"
 
 #define OCTAVE_COPYRIGHT \
   "Copyright (C) 1996, 1997, 1998 John W. Eaton."
 
 #define OCTAVE_NAME_AND_VERSION \
   "Octave, version " OCTAVE_VERSION " (" TARGET_HOST_TYPE ")"
 
 #define OCTAVE_NAME_VERSION_AND_COPYRIGHT \
diff --git a/test/octave.test/number/is_matrix-5.m b/test/octave.test/number/is_matrix-5.m
--- a/test/octave.test/number/is_matrix-5.m
+++ b/test/octave.test/number/is_matrix-5.m
@@ -1,1 +1,5 @@
-is_matrix ("t")
+implicit_str_to_num_ok = 0;
+t1 = ! is_matrix ("t");
+implicit_str_to_num_ok = 1;
+t2 = is_matrix ("t");
+t1 && t2
diff --git a/test/octave.test/number/is_matrix-6.m b/test/octave.test/number/is_matrix-6.m
--- a/test/octave.test/number/is_matrix-6.m
+++ b/test/octave.test/number/is_matrix-6.m
@@ -1,1 +1,5 @@
-is_matrix ("test")
+implicit_str_to_num_ok = 0;
+t1 = ! is_matrix ("test");
+implicit_str_to_num_ok = 1;
+t2 = is_matrix ("test");
+t1 && t2
diff --git a/test/octave.test/number/is_matrix-7.m b/test/octave.test/number/is_matrix-7.m
--- a/test/octave.test/number/is_matrix-7.m
+++ b/test/octave.test/number/is_matrix-7.m
@@ -1,1 +1,5 @@
-is_matrix (["test"; "ing"])
+implicit_str_to_num_ok = 0;
+t1 = ! is_matrix (["test"; "ing"]);
+implicit_str_to_num_ok = 1;
+t2 = is_matrix (["test"; "ing"]);
+t1 && t2
diff --git a/test/octave.test/number/is_scalar-5.m b/test/octave.test/number/is_scalar-5.m
--- a/test/octave.test/number/is_scalar-5.m
+++ b/test/octave.test/number/is_scalar-5.m
@@ -1,1 +1,5 @@
-is_scalar ("t")
+implicit_str_to_num_ok = 0;
+t1 = ! is_scalar ("t");
+implicit_str_to_num_ok = 1;
+t2 = is_scalar ("t");
+t1 && t2
diff --git a/test/octave.test/number/is_square-5.m b/test/octave.test/number/is_square-5.m
--- a/test/octave.test/number/is_square-5.m
+++ b/test/octave.test/number/is_square-5.m
@@ -1,1 +1,5 @@
-is_square ("t")
+implicit_str_to_num_ok = 0;
+t1 = ! is_square ("t");
+implicit_str_to_num_ok = 1;
+t2 = (is_square ("t") == 1);
+t1 && t2
diff --git a/test/octave.test/number/is_square-7.m b/test/octave.test/number/is_square-7.m
--- a/test/octave.test/number/is_square-7.m
+++ b/test/octave.test/number/is_square-7.m
@@ -1,1 +1,5 @@
-is_square (["test"; "ing"; "1"; "2"]) == 4
+implicit_str_to_num_ok = 0;
+t1 = ! is_square (["test"; "ing"; "1"; "2"]);
+implicit_str_to_num_ok = 1;
+t2 = (is_square (["test"; "ing"; "1"; "2"]) == 4);
+t1 && t2
diff --git a/test/octave.test/number/is_symmetric-5.m b/test/octave.test/number/is_symmetric-5.m
--- a/test/octave.test/number/is_symmetric-5.m
+++ b/test/octave.test/number/is_symmetric-5.m
@@ -1,1 +1,5 @@
-is_symmetric ("t")
+implicit_str_to_num_ok = 0;
+t1 = ! is_symmetric ("t");
+implicit_str_to_num_ok = 1;
+t2 = (is_symmetric ("t") == 1);
+t1 && t2
diff --git a/test/octave.test/number/is_symmetric-7.m b/test/octave.test/number/is_symmetric-7.m
--- a/test/octave.test/number/is_symmetric-7.m
+++ b/test/octave.test/number/is_symmetric-7.m
@@ -1,1 +1,5 @@
-is_symmetric (["te"; "et"]) == 2
+implicit_str_to_num_ok = 0;
+t1 = ! is_symmetric (["te"; "et"]);
+implicit_str_to_num_ok = 1;
+t2 = (is_symmetric (["te"; "et"]) == 2);
+t1 && t2
diff --git a/test/octave.test/number/is_vector-5.m b/test/octave.test/number/is_vector-5.m
--- a/test/octave.test/number/is_vector-5.m
+++ b/test/octave.test/number/is_vector-5.m
@@ -1,1 +1,5 @@
-is_vector ("t")
+implicit_str_to_num_ok = 0;
+t1 = ! is_vector ("t");
+implicit_str_to_num_ok = 1;
+t2 = is_vector ("t");
+t1 && t2
diff --git a/test/octave.test/number/is_vector-6.m b/test/octave.test/number/is_vector-6.m
--- a/test/octave.test/number/is_vector-6.m
+++ b/test/octave.test/number/is_vector-6.m
@@ -1,1 +1,5 @@
-is_vector ("test")
+implicit_str_to_num_ok = 0;
+t1 = ! is_vector ("test");
+implicit_str_to_num_ok = 1;
+t2 = is_vector ("test");
+t1 && t2
diff --git a/test/octave.test/number/number.exp b/test/octave.test/number/number.exp
--- a/test/octave.test/number/number.exp
+++ b/test/octave.test/number/number.exp
@@ -26,21 +26,21 @@ set test is_matrix-7
 set prog_output "ans = 1"
 do_test is_matrix-7.m
 
 set test is_matrix-8
 set prog_output "ans = 0"
 do_test is_matrix-8.m
 
 set test is_matrix-9
-set prog_output "error:.*"
+set prog_output "\n... is_matrix:.*"
 do_test is_matrix-9.m
 
 set test is_matrix-10
-set prog_output "error:.*"
+set prog_output "\n... is_matrix:.*"
 do_test is_matrix-10.m
 
 set test is_vector-1
 set prog_output "ans = 1"
 do_test is_vector-1.m
 
 set test is_vector-2
 set prog_output "ans = 1"
