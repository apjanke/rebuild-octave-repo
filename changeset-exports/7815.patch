# HG changeset patch
# User David Bateman <dbateman@free.fr>
# Date 1211929415 -7200
#      Wed May 28 01:03:35 2008 +0200
# Node ID a41df65f3f001e82210e1363eee39c91bb204e0f
# Parent  87865ed7405f5b6f63c8475ec53382c12eaa70a4
Add some single precision test code and fix resulting bugs

diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,12 @@
+2008-06-02  David Bateman  <dbateman@free.fr>
+
+	* libcruft/xsgmainc.f: Replace DLGAMS with ALGAMS.
+
 2008-05-30  Thomas Treichl  <Thomas.Treichl@gmx.net>
 
 	* quadpack/qk15i.f: Delete extraneous semicolons.
 
 2008-05-21  David Bateman  <dbateman@free.fr>
 
 	* odepack/slsode.f, odepack/sintdy.f: Replace the use of xerrwv
 	with xerrwd and rumach with d1mach(4).
diff --git a/libcruft/slatec-fn/xsgmainc.f b/libcruft/slatec-fn/xsgmainc.f
--- a/libcruft/slatec-fn/xsgmainc.f
+++ b/libcruft/slatec-fn/xsgmainc.f
@@ -48,17 +48,17 @@ C
       AEPS = A - AINTA
 C
 C      IF (X.GT.0.E0) GO TO 20
 C      GAMIT = 0.0E0
 C      IF (AINTA.GT.0.E0 .OR. AEPS.NE.0.E0) GAMIT = GAMR(A+1.0E0)
 C      RETURN
 C
  20   IF (X.GT.1.E0) GO TO 30
-      IF (A.GE.(-0.5E0) .OR. AEPS.NE.0.E0) CALL DLGAMS (A+1.0E0, ALGAP1,
+      IF (A.GE.(-0.5E0) .OR. AEPS.NE.0.E0) CALL ALGAMS (A+1.0E0, ALGAP1,
      1  SGNGAM)
 C      GAMIT = R9GMIT (A, X, ALGAP1, SGNGAM, ALX)
       result = exp (a*alx + log (R9GMIT (A, X, ALGAP1, SGNGAM, ALX)))
       RETURN
 C
  30   IF (A.LT.X) GO TO 40
       T = R9LGIT (A, X, ALNGAM(A+1.0E0))
       IF (T.LT.BOT) CALL XERCLR
@@ -68,17 +68,17 @@ C      GAMIT = EXP (T)
 C
  40   ALNG = R9LGIC (A, X, ALX)
 C
 C EVALUATE GAMIT IN TERMS OF LOG (DGAMIC (A, X))
 C
       H = 1.0E0
       IF (AEPS.EQ.0.E0 .AND. AINTA.LE.0.E0) GO TO 50
 C
-      CALL DLGAMS (A+1.0E0, ALGAP1, SGNGAM)
+      CALL ALGAMS (A+1.0E0, ALGAP1, SGNGAM)
       T = LOG (ABS(A)) + ALNG - ALGAP1
       IF (T.GT.ALNEPS) GO TO 60
 C
       IF (T.GT.(-ALNEPS)) H = 1.0E0 - SGA * SGNGAM * EXP(T)
       IF (ABS(H).GT.SQEPS) GO TO 50
 C
       CALL XERCLR
       CALL XERMSG ('SLATEC', 'XGMAINC', 'RESULT LT HALF PRECISION', 1,
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,13 @@
+2008-06-02  David Bateman  <dbateman@free.fr>
+
+	* general/interp1q.m: Remove spaces between functions and args in
+	[]. Fix test code to actually test interp1q.
+
 2008-06-02  Jaroslav Hajek <highegg@gmail.com>
 
 	* strings/strcat.m: Add tests.
 
 2008-06-02  Kim Hansen  <kimhanse@gmail.com>
 
 	* strings/mat2str.m: Change is_complex to iscomplex, add tests, add
 	missing ;
diff --git a/scripts/general/interp1q.m b/scripts/general/interp1q.m
--- a/scripts/general/interp1q.m
+++ b/scripts/general/interp1q.m
@@ -48,23 +48,25 @@ function yi = interp1q (x, y, xi)
   yi = NA (size(xi, 1), size (y, 2));
   xi = xi (range);
   dy = y (2 : ny, :) - y (1 : ny - 1, :);
   dx = x (2 : nx) - x (1 : nx - 1);
   idx = lookup (x, xi, "lr");
   s = (xi - x (idx)) ./ dx (idx);
   yi (range, :) = s (:, ones (1, nc)) .* dy (idx, :) + y (idx, :);
   if (length (szx) == 2 && any (szx == 1))
-    yi = reshape (yi, [max (szx), szy (2 : end)]);
+    yi = reshape (yi, [max(szx), szy(2:end)]);
   else
     yi = reshape (yi, [szx, szy(2:end)]);
   endif
 endfunction
 
-%!shared xp, yp, xi
+%!shared xp, yp, xi, yi
 %! xp=[0:2:10].';      yp = sin(2*pi*xp/5);
 %! xi = [-1; 0; 2.2; 4; 6.6; 10; 11];
-%!assert (interp1(xp, yp, [min(xp)-1; max(xp)+1]), [NA; NA]);
-%!assert (interp1(xp,yp,xp), yp, 100*eps);
-%!assert (isempty(interp1(xp,yp,[])));
-%!assert (interp1(xp,[yp,yp],xi), [interp1(xp,yp,xi),interp1(xp,yp,xi)]);
-%!assert (interp1(xp,yp,[xi,xi]), [interp1(xp,yp,xi),interp1(xp,yp,xi)]);
-%!assert (interp1(xp,[yp,yp],[xi,xi]), [interp1(xp,yp,xi),interp1(xp,yp,xi)]);
+%! yi = interp1 (xp,yp,xi);
+%!assert (interp1q(xp, yp, [min(xp)-1; max(xp)+1]), [NA; NA]);
+%!assert (interp1q(xp,yp,xp), yp, 100*eps);
+%!assert (isempty(interp1q(xp,yp,[])));
+%!assert (interp1q(xp,yp,xi), yi);
+%!assert (interp1q(xp,[yp,yp],xi), [yi, yi]);
+%!assert (interp1q(xp,yp,[xi,xi]), [yi, yi]);
+%!assert (interp1q(xp,[yp,yp],[xi,xi]), cat (3, [yi, yi], [yi, yi]));
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -276,13 +276,62 @@ compatible dimensions.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
+
+%% test/octave.test/arith/betainc-1.m
+%!test
+%! a=[1, 1.5, 2, 3];
+%! b=[4, 3, 2, 1];
+%! v1=betainc(1,a,b);
+%! v2=[1,1,1,1];
+%! x = [.2, .4, .6, .8];
+%! v3=betainc(x, a, b);
+%! v4 = 1-betainc(1.-x, b, a);
+%! assert(v1, v2, sqrt(eps));
+%! assert(v3, v4, sqrt(eps));
+
+%% Single precision
+%!test
+%! a=single ([1, 1.5, 2, 3]);
+%! b=single ([4, 3, 2, 1]);
+%! v1=betainc(1,a,b);
+%! v2=single ([1,1,1,1]);
+%! x = single ([.2, .4, .6, .8]);
+%! v3=betainc(x, a, b);
+%! v4 = 1-betainc(1.-x, b, a);
+%! assert(v1, v2, sqrt(eps ('single')));
+%! assert(v3, v4, sqrt(eps ('single')));
+
+%% Mixed double/single precision
+%!test
+%! a=single ([1, 1.5, 2, 3]);
+%! b=[4, 3, 2, 1];
+%! v1=betainc(1,a,b);
+%! v2=single ([1,1,1,1]);
+%! x = [.2, .4, .6, .8];
+%! v3=betainc(x, a, b);
+%! v4 = 1-betainc(1.-x, b, a);
+%! assert(v1, v2, sqrt(eps ('single')));
+%! assert(v3, v4, sqrt(eps ('single')));
+
+%% test/octave.test/arith/betainc-2.m
+%!error <Invalid call to betainc.*> betainc();
+
+%% test/octave.test/arith/betainc-3.m
+%!error <Invalid call to betainc.*> betainc(1);
+
+%% test/octave.test/arith/betainc-4.m
+%!error <Invalid call to betainc.*> betainc(1,2);
+
+*/
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
 
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -172,13 +172,31 @@ If neither @var{x} nor @var{a} is scalar
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
+
+%!test
+%! a = [.5 .5 .5 .5 .5];
+%! x = [0 1 2 3 4];
+%! v1 = sqrt(pi)*erf(x)./gamma(a);
+%! v3 = gammainc(x.*x,a);
+%! assert(v1, v3, sqrt(eps));
+
+%!test
+%! a = single ([.5 .5 .5 .5 .5]);
+%! x = single([0 1 2 3 4]);
+%! v1 = sqrt(pi('single'))*erf(x)./gamma(a);
+%! v3 = gammainc(x.*x,a);
+%! assert(v1, v3, sqrt(eps('single')));
+
+*/
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
 
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -21,30 +21,38 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "dNDArray.h"
 #include "CNDArray.h"
+#include "fNDArray.h"
+#include "fCNDArray.h"
 #include "lo-mappers.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
 // FIXME -- should probably handle Inf, NaN.
 
 static inline bool
 is_integer_value (double x)
 {
   return x == std::floor (x);
 }
 
+static inline bool
+is_integer_value (float x)
+{
+  return x == std::floor (x);
+}
+
 DEFUN_DLD (gcd, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{g} =} gcd (@var{a1}, @dots{})\n\
 @deftypefnx {Loadable Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @dots{})\n\
 \n\
 If a single argument is given then compute the greatest common divisor of\n\
 the elements of this argument. Otherwise if more than one argument is\n\
 given all arguments must be the same size or scalar. In this case the\n\
@@ -94,16 +102,17 @@ all of the values of @var{v1}, @dots{} i
 
   if (nargin == 0)
     {
       print_usage ();
       return retval;
     }
 
   bool all_args_scalar = true;
+  bool any_single = false;
 
   dim_vector dv(1);
 
   for (int i = 0; i < nargin; i++)
     {
       if (! args(i).is_scalar_type ())
 	{
 	  if (! args(i).is_matrix_type ())
@@ -121,19 +130,206 @@ all of the values of @var{v1}, @dots{} i
 	    {
 	      if (dv != args(i).dims ())
 		{
 		  error ("gcd: all arguments must be the same size or scalar");
 		  return retval;
 		}
 	    }
 	}
+      if (!any_single && args(i).is_single_type ())
+	any_single = true;
     }
 
-  if (nargin == 1)
+  if (any_single)
+    {
+      if (nargin == 1)
+	{
+	  FloatNDArray gg = args(0).float_array_value ();
+
+	  int nel = dv.numel ();
+
+	  FloatNDArray v (dv);
+
+	  FloatRowVector x (3);
+	  FloatRowVector y (3);
+
+	  float g = std::abs (gg(0));
+
+	  if (! is_integer_value (g))
+	    {
+	      error ("gcd: all arguments must be integer");
+	      return retval;
+	    }
+
+	  v(0) = signum (gg(0));
+      
+	  for (int k = 1; k < nel; k++)
+	    {
+	      x(0) = g;
+	      x(1) = 1;
+	      x(2) = 0;
+
+	      y(0) = std::abs (gg(k));
+	      y(1) = 0;
+	      y(2) = 1;
+
+	      if (! is_integer_value (y(0)))
+		{
+		  error ("gcd: all arguments must be integer");
+		  return retval;
+		}
+
+	      while (y(0) > 0)
+		{
+		  FloatRowVector r = x - y * std::floor (x(0) / y(0));
+		  x = y;
+		  y = r;
+		}
+
+	      g = x(0);
+
+	      for (int i = 0; i < k; i++) 
+		v(i) *= x(1);
+
+	      v(k) = x(2) * signum (gg(k));
+	    }
+
+	  retval (1) = v;
+	  retval (0) = g;
+	}
+      else if (all_args_scalar && nargout < 3)
+	{
+	  float g = args(0).float_value ();
+
+	  if (error_state || ! is_integer_value (g))
+	    {
+	      error ("gcd: all arguments must be integer");
+	      return retval;
+	    }
+
+	  FloatRowVector v (nargin, 0);
+	  FloatRowVector x (3);
+	  FloatRowVector y (3);
+
+	  v(0) = signum (g);
+
+	  g = std::abs(g);
+      
+	  for (int k = 1; k < nargin; k++)
+	    {
+	      x(0) = g;
+	      x(1) = 1;
+	      x(2) = 0;
+
+	      y(0) = args(k).float_value ();
+	      y(1) = 0;
+	      y(2) = 1;
+
+	      float sgn = signum (y(0));
+
+	      y(0) = std::abs (y(0));
+
+	      if (error_state || ! is_integer_value (g))
+		{
+		  error ("gcd: all arguments must be integer");
+		  return retval;
+		}
+
+	      while (y(0) > 0)
+		{
+		  FloatRowVector r = x - y * std::floor (x(0) / y(0));
+		  x = y;
+		  y = r;
+		}
+
+	      g = x(0);
+
+	      for (int i = 0; i < k; i++) 
+		v(i) *= x(1);
+
+	      v(k) = x(2) * sgn;
+	    }
+
+	  retval (1) = v;
+	  retval (0) = g;
+	}
+      else
+	{
+	  // FIXME -- we need to handle a possible mixture of scalar and
+	  // array values here.
+
+	  FloatNDArray g = args(0).float_array_value ();
+
+	  OCTAVE_LOCAL_BUFFER (FloatNDArray, v, nargin);
+
+	  int nel = dv.numel ();
+
+	  v[0].resize(dv);
+
+	  for (int i = 0; i < nel; i++)
+	    {
+	      v[0](i) = signum (g(i));
+	      g(i) = std::abs (g(i));
+
+	      if (! is_integer_value (g(i)))
+		{
+		  error ("gcd: all arguments must be integer");
+		  return retval;
+		}
+	    }
+
+	  FloatRowVector x (3);
+	  FloatRowVector y (3);
+
+	  for (int k = 1; k < nargin; k++)
+	    {
+	      FloatNDArray gnew = args(k).float_array_value ();
+
+	      v[k].resize(dv);
+
+	      for (int n = 0; n < nel; n++)
+		{
+		  x(0) = g(n);
+		  x(1) = 1;
+		  x(2) = 0;
+
+		  y(0) = std::abs (gnew(n));
+		  y(1) = 0;
+		  y(2) = 1; 
+
+		  if (! is_integer_value (y(0)))
+		    {
+		      error ("gcd: all arguments must be integer");
+		      return retval;
+		    }
+
+		  while (y(0) > 0)
+		    {
+		      FloatRowVector r = x - y * std::floor (x(0) / y(0));
+		      x = y;
+		      y = r;
+		    }
+
+		  g(n) = x(0);
+
+		  for (int i = 0; i < k; i++) 
+		    v[i](n) *= x(1);
+
+		  v[k](n) = x(2) * signum (gnew(n));
+		}
+	    }
+
+	  for (int k = 0; k < nargin; k++)
+	    retval(1+k) = v[k];
+
+	  retval (0) = g;
+	}
+    }
+  else if (nargin == 1)
     {
       NDArray gg = args(0).array_value ();
 
       int nel = dv.numel ();
 
       NDArray v (dv);
 
       RowVector x (3);
@@ -310,12 +506,27 @@ all of the values of @var{v1}, @dots{} i
 
       retval (0) = g;
     }
 
   return retval;
 }
 
 /*
+
+%!assert(gcd (200, 300, 50, 35), gcd ([200, 300, 50, 35]))
+%!assert(gcd ([200, 300, 50, 35]), 5);
+%!assert(gcd (single(200), single(300), single(50), single(35)), gcd (single([200, 300, 50, 35])))
+%!assert(gcd (single([200, 300, 50, 35])), single(5));
+
+%!error <Invalid call to gcd.*> gcd ();
+
+%!test
+%! s.a = 1;
+%! fail("gcd (s)");
+
+ */
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -697,18 +697,40 @@ and @var{x}.  The result is in range -pi
 }
 
 /*
 %!assert (size (atan2 (zeros (0, 2), zeros (0, 2))), [0, 2])
 %!assert (size (atan2 (rand (2, 3, 4), zeros (2, 3, 4))), [2, 3, 4])
 %!assert (size (atan2 (rand (2, 3, 4), 1)), [2, 3, 4])
 %!assert (size (atan2 (1, rand (2, 3, 4))), [2, 3, 4])
 %!assert (size (atan2 (1, 2)), [1, 1])
+
+%!test
+%! rt2 = sqrt (2);
+%! rt3 = sqrt (3);
+%! v = [0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0];
+%! y = [0, rt3, 1, rt3, -rt3, -1, -rt3, 0];
+%! x = [1, 3, 1, 1, 1, 1, 3, 1];
+%! assert(atan2 (y, x), v, sqrt (eps));
+
+%!test
+%! rt2 = sqrt (2);
+%! rt3 = sqrt (3);
+%! v = single([0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0]);
+%! y = single([0, rt3, 1, rt3, -rt3, -1, -rt3, 0]);
+%! x = single([1, 3, 1, 1, 1, 1, 3, 1]);
+%! assert(atan2 (y, x), v, sqrt (eps('single')));
+
+%!error <Invalid call to atan2.*> atan2 ();
+%!error <Invalid call to atan2.*> atan2 (1, 2, 3);
+
 */
 
+
+
 DEFUN (hypot, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} hypot (@var{x}, @var{y})\n\
 Compute square-root of the squares of @var{x} and @var{y}\n\
 element-by-element. This equivalent to @code{sqrt (@var{x}.^ 2 + @var{y}\n\
 .^ 2)}, but calculated in a manner that avoids overflows for large\n\
 values of @var{x} or @var{y}.\n\
 @end deftypefn")
@@ -1244,26 +1266,29 @@ sign as @var{x}.  If @var{y} is zero, th
 
 #define NATIVE_REDUCTION(FCN) \
  \
   octave_value retval; \
  \
   int nargin = args.length (); \
  \
   bool isnative = false; \
+  bool isdouble = false; \
   \
   if (nargin > 1 && args(nargin - 1).is_string ()) \
     { \
       std::string str = args(nargin - 1).string_value (); \
       \
       if (! error_state) \
 	{ \
 	  if (str == "native") \
 	    isnative = true; \
-	  else if (str != "double") /* Ignore double as no single type */ \
+	  else if (str == "double") \
+            isdouble = true; \
+          else \
 	    error ("sum: unrecognized string argument"); \
           nargin --; \
 	} \
     } \
   \
   if (nargin == 1 || nargin == 2) \
     { \
       octave_value arg = args(0); \
@@ -1303,17 +1328,17 @@ sign as @var{x}.  If @var{y} is zero, th
                       else if NATIVE_REDUCTION_1 (FCN, int16, dim) \
                       else if NATIVE_REDUCTION_1 (FCN, int32, dim) \
                       else if NATIVE_REDUCTION_1 (FCN, int64, dim) \
                       else if NATIVE_REDUCTION_1 (FCN, bool, dim) \
                       else if (arg.is_char_matrix ()) \
                         { \
 			  error (#FCN, ": invalid char type"); \
 			} \
-		      else if (arg.is_single_type ()) \
+		      else if (!isdouble && arg.is_single_type ()) \
                         { \
 	                  if (arg.is_complex_type ()) \
 		            { \
 		              FloatComplexNDArray tmp = \
 				arg.float_complex_array_value (); \
                               \
 		              if (! error_state) \
 		                retval = tmp.FCN (dim); \
@@ -1341,17 +1366,17 @@ sign as @var{x}.  If @var{y} is zero, th
 		            retval = tmp.FCN (dim); \
 		        } \
                       else \
 		        { \
 		          gripe_wrong_type_arg (#FCN, arg); \
 		          return retval; \
 		        } \
                     } \
-		  else if (arg.is_single_type ()) \
+		  else if (!isdouble && arg.is_single_type ()) \
 		    { \
 	              if (arg.is_real_type ()) \
 		        { \
 		          FloatNDArray tmp = arg.float_array_value (); \
                           \
 		          if (! error_state) \
 		            retval = tmp.FCN (dim); \
 		        } \
@@ -1484,30 +1509,74 @@ products).\n\
 As a special case, if @var{x} is a vector and @var{dim} is omitted,\n\
 return the cumulative product of the elements as a vector with the\n\
 same orientation as @var{x}.\n\
 @end deftypefn")
 {
   DATA_REDUCTION (cumprod);
 }
 
+/*
+
+%!assert (cumprod ([1, 2, 3]), [1, 2, 6]);
+%!assert (cumprod ([-1; -2; -3]), [-1; 2; -6]);
+%!assert (cumprod ([i, 2+i, -3+2i, 4]), [i, -1+2i, -1-8i, -4-32i]);
+%!assert (cumprod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [1, 2, 3; i, 4i, 9i; -1+i, -8+8i, -27+27i]);
+
+%!assert (cumprod (single([1, 2, 3])), single([1, 2, 6]));
+%!assert (cumprod (single([-1; -2; -3])), single([-1; 2; -6]));
+%!assert (cumprod (single([i, 2+i, -3+2i, 4])), single([i, -1+2i, -1-8i, -4-32i]));
+%!assert (cumprod (single([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single([1, 2, 3; i, 4i, 9i; -1+i, -8+8i, -27+27i]));
+
+%!error <Invalid call to cumprod.*> cumprod ();
+
+%!assert (cumprod ([2, 3; 4, 5], 1), [2, 3; 8, 15]);
+%!assert (cumprod ([2, 3; 4, 5], 2), [2, 6; 4, 20]);
+
+%!assert (cumprod (single([2, 3; 4, 5]), 1), single([2, 3; 8, 15]));
+%!assert (cumprod (single([2, 3; 4, 5]), 2), single([2, 6; 4, 20]));
+
+ */
+
 DEFUN (cumsum, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cumsum (@var{x}, @var{dim})\n\
 Cumulative sum of elements along dimension @var{dim}.  If @var{dim}\n\
 is omitted, it defaults to 1 (column-wise cumulative sums).\n\
 \n\
 As a special case, if @var{x} is a vector and @var{dim} is omitted,\n\
 return the cumulative sum of the elements as a vector with the\n\
 same orientation as @var{x}.\n\
 @end deftypefn")
 {
   DATA_REDUCTION (cumsum);
 }
 
+/*
+
+%!assert (cumsum ([1, 2, 3]), [1, 3, 6]);
+%!assert (cumsum ([-1; -2; -3]), [-1; -3; -6]);
+%!assert (cumsum ([i, 2+i, -3+2i, 4]), [i, 2+2i, -1+4i, 3+4i]);
+%!assert (cumsum ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [1, 2, 3; 1+i, 2+2i, 3+3i; 2+2i, 4+4i, 6+6i]);
+
+%!assert (cumsum (single([1, 2, 3])), single([1, 3, 6]));
+%!assert (cumsum (single([-1; -2; -3])), single([-1; -3; -6]));
+%!assert (cumsum (single([i, 2+i, -3+2i, 4])), single([i, 2+2i, -1+4i, 3+4i]));
+%!assert (cumsum (single([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single([1, 2, 3; 1+i, 2+2i, 3+3i; 2+2i, 4+4i, 6+6i]));
+
+%!error <Invalid call to cumsum.*> cumsum ();
+
+%!assert (cumsum ([1, 2; 3, 4], 1), [1, 2; 4, 6]);
+%!assert (cumsum ([1, 2; 3, 4], 2), [1, 3; 3, 7]);
+
+%!assert (cumsum (single([1, 2; 3, 4]), 1), single([1, 2; 4, 6]));
+%!assert (cumsum (single([1, 2; 3, 4]), 2), single([1, 3; 3, 7]));
+
+ */
+
 DEFUN (diag, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} diag (@var{v}, @var{k})\n\
 Return a diagonal matrix with vector @var{v} on diagonal @var{k}.  The\n\
 second argument is optional.  If it is positive, the vector is placed on\n\
 the @var{k}-th super-diagonal.  If it is negative, it is placed on the\n\
 @var{-k}-th sub-diagonal.  The default value of @var{k} is 0, and the\n\
 vector is placed on the main diagonal.  For example,\n\
@@ -1593,16 +1662,62 @@ omitted, it defaults to 1 (column-wise p
 \n\
 As a special case, if @var{x} is a vector and @var{dim} is omitted,\n\
 return the product of the elements.\n\
 @end deftypefn")
 {
   DATA_REDUCTION (prod);
 }
 
+/*
+
+%!assert (prod ([1, 2, 3]), 6);
+%!assert (prod ([-1; -2; -3]), -6);
+%!assert (prod ([i, 2+i, -3+2i, 4]), -4 - 32i);
+%!assert (prod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [-1+i, -8+8i, -27+27i]);
+
+%!assert (prod (single([1, 2, 3])), single(6));
+%!assert (prod (single([-1; -2; -3])), single(-6));
+%!assert (prod (single([i, 2+i, -3+2i, 4])), single(-4 - 32i));
+%!assert (prod (single([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single([-1+i, -8+8i, -27+27i]));
+
+%!error <Invalid call to prod.*> prod ();
+
+%!assert (prod ([1, 2; 3, 4], 1), [3, 8]);
+%!assert (prod ([1, 2; 3, 4], 2), [2; 12]);
+%!assert (prod (zeros (1, 0)), 1);
+%!assert (prod (zeros (1, 0), 1), zeros (1, 0));
+%!assert (prod (zeros (1, 0), 2), 1);
+%!assert (prod (zeros (0, 1)), 1);
+%!assert (prod (zeros (0, 1), 1), 1);
+%!assert (prod (zeros (0, 1), 2), zeros (0, 1));
+%!assert (prod (zeros (2, 0)), zeros (1, 0));
+%!assert (prod (zeros (2, 0), 1), zeros (1, 0));
+%!assert (prod (zeros (2, 0), 2), [1; 1]);
+%!assert (prod (zeros (0, 2)), [1, 1]);
+%!assert (prod (zeros (0, 2), 1), [1, 1]);
+%!assert (prod (zeros (0, 2), 2), zeros(0, 1));
+
+%!assert (prod (single([1, 2; 3, 4]), 1), single([3, 8]));
+%!assert (prod (single([1, 2; 3, 4]), 2), single([2; 12]));
+%!assert (prod (zeros (1, 0, 'single')), single(1));
+%!assert (prod (zeros (1, 0, 'single'), 1), zeros (1, 0, 'single'));
+%!assert (prod (zeros (1, 0, 'single'), 2), single(1));
+%!assert (prod (zeros (0, 1, 'single')), single(1));
+%!assert (prod (zeros (0, 1, 'single'), 1), single(1));
+%!assert (prod (zeros (0, 1, 'single'), 2), zeros (0, 1, 'single'));
+%!assert (prod (zeros (2, 0, 'single')), zeros (1, 0, 'single'));
+%!assert (prod (zeros (2, 0, 'single'), 1), zeros (1, 0, 'single'));
+%!assert (prod (zeros (2, 0, 'single'), 2), single([1; 1]));
+%!assert (prod (zeros (0, 2, 'single')), single([1, 1]));
+%!assert (prod (zeros (0, 2, 'single'), 1), single([1, 1]));
+%!assert (prod (zeros (0, 2, 'single'), 2), zeros(0, 1, 'single'));
+
+ */
+
 static octave_value
 do_cat (const octave_value_list& args, std::string fname)
 {
   octave_value retval;
 
   int n_args = args.length (); 
 
   if (n_args == 1)
@@ -2275,16 +2390,68 @@ sum ([true, true], 'native')\n\
 
 /*
 
 %!assert (sum([true,true]), 2)
 %!assert (sum([true,true],'native'), true)
 %!assert (sum(int8([127,10,-20])), 117);
 %!assert (sum(int8([127,10,-20]),'native'), int8(107));
 
+%!assert(sum ([1, 2, 3]), 6)
+%!assert(sum ([-1; -2; -3]), -6);
+%!assert(sum ([i, 2+i, -3+2i, 4]), 3+4i);
+%!assert(sum ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [2+2i, 4+4i, 6+6i]);
+
+%!assert(sum (single([1, 2, 3])), single(6))
+%!assert(sum (single([-1; -2; -3])), single(-6));
+%!assert(sum (single([i, 2+i, -3+2i, 4])), single(3+4i));
+%!assert(sum (single([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single([2+2i, 4+4i, 6+6i]));
+
+%!error <Invalid call to sum.*> sum ();
+
+%!assert (sum ([1, 2; 3, 4], 1), [4, 6]);
+%!assert (sum ([1, 2; 3, 4], 2), [3; 7]);
+%!assert (sum (zeros (1, 0)), 0);
+%!assert (sum (zeros (1, 0), 1), zeros(1, 0));
+%!assert (sum (zeros (1, 0), 2), 0);
+%!assert (sum (zeros (0, 1)), 0);
+%!assert (sum (zeros (0, 1), 1), 0);
+%!assert (sum (zeros (0, 1), 2), zeros(0, 1));
+%!assert (sum (zeros (2, 0)),  zeros(1, 0));
+%!assert (sum (zeros (2, 0), 1), zeros(1, 0));
+%!assert (sum (zeros (2, 0), 2),  [0; 0]);
+%!assert (sum (zeros (0, 2)), [0, 0]);
+%!assert (sum (zeros (0, 2), 1), [0, 0]);
+%!assert (sum (zeros (0, 2), 2), zeros(0, 1));
+%!assert (sum (zeros (2, 2, 0, 3)), zeros(1, 2, 0, 3));
+%!assert (sum (zeros (2, 2, 0, 3), 2), zeros(2, 1, 0, 3));
+%!assert (sum (zeros (2, 2, 0, 3), 3), zeros(2, 2, 1, 3));
+%!assert (sum (zeros (2, 2, 0, 3), 4), zeros(2, 2, 0));
+%!assert (sum (zeros (2, 2, 0, 3), 7), zeros(2, 2, 0, 3));
+
+%!assert (sum (single([1, 2; 3, 4]), 1), single([4, 6]));
+%!assert (sum (single([1, 2; 3, 4]), 2), single([3; 7]));
+%!assert (sum (zeros (1, 0, 'single')), single(0));
+%!assert (sum (zeros (1, 0, 'single'), 1), zeros(1, 0, 'single'));
+%!assert (sum (zeros (1, 0, 'single'), 2), single(0));
+%!assert (sum (zeros (0, 1, 'single')), single(0));
+%!assert (sum (zeros (0, 1, 'single'), 1), single(0));
+%!assert (sum (zeros (0, 1, 'single'), 2), zeros(0, 1, 'single'));
+%!assert (sum (zeros (2, 0, 'single')),  zeros(1, 0, 'single'));
+%!assert (sum (zeros (2, 0, 'single'), 1), zeros(1, 0, 'single'));
+%!assert (sum (zeros (2, 0, 'single'), 2),  single([0; 0]));
+%!assert (sum (zeros (0, 2, 'single')), single([0, 0]));
+%!assert (sum (zeros (0, 2, 'single'), 1), single([0, 0]));
+%!assert (sum (zeros (0, 2, 'single'), 2), zeros(0, 1, 'single'));
+%!assert (sum (zeros (2, 2, 0, 3, 'single')), zeros(1, 2, 0, 3, 'single'));
+%!assert (sum (zeros (2, 2, 0, 3, 'single'), 2), zeros(2, 1, 0, 3, 'single'));
+%!assert (sum (zeros (2, 2, 0, 3, 'single'), 3), zeros(2, 2, 1, 3, 'single'));
+%!assert (sum (zeros (2, 2, 0, 3, 'single'), 4), zeros(2, 2, 0, 'single'));
+%!assert (sum (zeros (2, 2, 0, 3, 'single'), 7), zeros(2, 2, 0, 3, 'single'));
+
 */
 
 DEFUN (sumsq, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sumsq (@var{x}, @var{dim})\n\
 Sum of squares of elements along dimension @var{dim}.  If @var{dim}\n\
 is omitted, it defaults to 1 (column-wise sum of squares).\n\
 \n\
@@ -2296,16 +2463,36 @@ This function is conceptually equivalent
 sum (x .* conj (x), dim)\n\
 @end example\n\
 but it uses less memory and avoids calling conj if @var{x} is real.\n\
 @end deftypefn")
 {
   DATA_REDUCTION (sumsq);
 }
 
+/*
+
+%!assert(sumsq ([1, 2, 3]), 14)
+%!assert(sumsq ([-1; -2; 4i]), 21);
+%!assert(sumsq ([1, 2, 3; 2, 3, 4; 4i, 6i, 2]), [21, 49, 29]);
+
+%!assert(sumsq (single([1, 2, 3])), single(14))
+%!assert(sumsq (single([-1; -2; 4i])), single(21));
+%!assert(sumsq (single([1, 2, 3; 2, 3, 4; 4i, 6i, 2])), single([21, 49, 29]));
+
+%!error <Invalid call to sumsq.*> sumsq ();
+
+%!assert (sumsq ([1, 2; 3, 4], 1), [10, 20]);
+%!assert (sumsq ([1, 2; 3, 4], 2), [5; 25]);
+
+%!assert (sumsq (single([1, 2; 3, 4]), 1), single([10, 20]));
+%!assert (sumsq (single([1, 2; 3, 4]), 2), single([5; 25]));
+
+ */
+
 DEFUN (islogical, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} islogical (@var{x})\n\
 Return true if @var{x} is a logical object.\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -2314,16 +2501,30 @@ Return true if @var{x} is a logical obje
   else
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (isbool, islogical);
 
+/*
+
+%!assert (islogical(true), true)
+%!assert (islogical(false), true)
+%!assert (islogical([true, false]), true)
+%!assert (islogical(1), false)
+%!assert (islogical(1i), false)
+%!assert (islogical([1,1]), false)
+%!assert (islogical(single(1)), false)
+%!assert (islogical(single(1i)), false)
+%!assert (islogical(single([1,1])), false)
+
+ */
+
 DEFUN (isinteger, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isinteger (@var{x})\n\
 Return true if @var{x} is an integer object (int8, uint8, int16, etc.).\n\
 Note that @code{isinteger (14)} is false because numeric constants in\n\
 are double precision floating point values.\n\
 @seealso{isreal, isnumeric, class, isa}\n\
 @end deftypefn")
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -63,47 +63,103 @@ abs (3 + 4i)\n\
   if (args.length () == 1)
     retval = args(0).abs ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(abs (1), 1);
+%!assert(abs (-3.5), 3.5);
+%!assert(abs (3+4i), 5);
+%!assert(abs (3-4i), 5);
+%!assert(abs ([1.1, 3i; 3+4i, -3-4i]), [1.1, 3; 5, 5]);
+
+%!assert(abs (single(1)), single(1));
+%!assert(abs (single(-3.5)), single(3.5));
+%!assert(abs (single(3+4i)), single(5));
+%!assert(abs (single(3-4i)), single(5));
+%!assert(abs (single([1.1, 3i; 3+4i, -3-4i])), single([1.1, 3; 5, 5]));
+
+%!error abs ();
+%!error abs (1, 2);
+
+ */
+
 DEFUN (acos, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acos (@var{x})\n\
 Compute the inverse cosine of each element of @var{x}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).acos ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!test
+%! rt2 = sqrt (2);
+%! rt3 = sqrt (3);
+%! v = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
+%! x = [1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1];
+%! assert(acos (x), v, sqrt(eps));
+
+%!test
+%! rt2 = sqrt (2);
+%! rt3 = sqrt (3);
+%! v = single ([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
+%! x = single ([1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1]);
+%! assert(acos (x), v, sqrt(eps('single')));
+
+%!error acos ();
+%!error acos (1, 2);
+
+*/
 
 DEFUN (acosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acosh (@var{x})\n\
 Compute the inverse hyperbolic cosine of each element of @var{x}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).acosh ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!test
+%! v = [0, pi/2*i, pi*i, pi/2*i];
+%! x = [1, 0, -1, 0];
+%! assert(acosh (x), v, sqrt(eps));
+
+%!test
+%! v = single([0, pi/2*i, pi*i, pi/2*i]);
+%! x = single([1, 0, -1, 0]);
+%! assert(acosh (x), v, sqrt (eps('single')));
+
+%!error acosh ();
+%!error acosh (1, 2);
+
+*/
+
 DEFUN (angle, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} angle (@var{z})\n\
 See arg.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -144,16 +200,35 @@ arg (3 + 4i)\n\
   if (args.length () == 1)
     retval = args(0).arg ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(arg (1), 0);
+%!assert(arg (i), pi/2);
+%!assert(arg (-1), pi);
+%!assert(arg (-i), -pi/2);
+%!assert(arg ([1, i; -1, -i]), [0, pi/2; pi, -pi/2]);
+
+%!assert(arg (single(1)), single(0));
+%!assert(arg (single(i)), single(pi/2));
+%!assert(arg (single(-1)), single(pi));
+%!assert(arg (single(-i)), single(-pi/2));
+%!assert(arg (single([1, i; -1, -i])), single([0, pi/2; pi, -pi/2]));
+
+%!error arg ();
+%!error arg (1, 2);
+
+*/
+
 DEFUN (asin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asin (@var{x})\n\
 Compute the inverse sine of each element of @var{x}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -185,62 +260,136 @@ Compute the inverse hyperbolic sine of e
   if (args.length () == 1)
     retval = args(0).asinh ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!test
+%! v = [0, pi/2*i, 0, -pi/2*i];
+%! x = [0, i, 0, -i];
+%! assert(asinh (x), v,  sqrt (eps));
+
+%!test
+%! v = single([0, pi/2*i, 0, -pi/2*i]);
+%! x = single([0, i, 0, -i]);
+%! assert(asinh (x), v,  sqrt (eps('single')));
+
+%!error asinh ();
+%!error asinh (1, 2);
+
+*/
+
 DEFUN (atan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan (@var{x})\n\
 Compute the inverse tangent of each element of @var{x}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).atan ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!test
+%! rt2 = sqrt (2);
+%! rt3 = sqrt (3);
+%! v = [0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0];
+%! x = [0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0];
+%! assert(atan (x), v, sqrt (eps));
+
+%!test
+%! rt2 = sqrt (2);
+%! rt3 = sqrt (3);
+%! v = single([0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0]);
+%! x = single([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
+%! assert(atan (x), v, sqrt (eps('single')));
+
+%!error atan ();
+%!error atan (1, 2);
+
+ */
+
 DEFUN (atanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atanh (@var{x})\n\
 Compute the inverse hyperbolic tangent of each element of @var{x}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).atanh ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!test
+%! v = [0, 0];
+%! x = [0, 0];
+%! assert(atanh (x), v, sqrt (eps));
+
+%!test
+%! v = single([0, 0]);
+%! x = single([0, 0]);
+%! assert(atanh (x), v, sqrt (eps('single')));
+
+%!error atanh ();
+%!error atanh (1, 2);
+
+*/
+
 DEFUN (ceil, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ceil (@var{x})\n\
 Return the smallest integer not less than @var{x}.  If @var{x} is\n\
 complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).ceil ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%% double precision
+%!assert(ceil ([2, 1.1, -1.1, -1]), [2, 2, -1, -1]);
+
+%% compelx double precison 
+%!assert(ceil ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 2+2i, -1-i, -1-i]);
+
+%% single precision
+%!assert(ceil (single([2, 1.1, -1.1, -1])), single([2, 2, -1, -1]));
+
+%% compelx single preci
+%!assert(ceil (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single([2+2i, 2+2i, -1-i, -1-i]));
+
+%!error ceil ();
+%!error ceil (1, 2);
+
+*/
+
 DEFUN (conj, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} conj (@var{z})\n\
 Return the complex conjugate of @var{z}, defined as\n\
 @iftex\n\
 @tex\n\
 $\\bar{z} = x - iy$.\n\
 @end tex\n\
@@ -255,46 +404,103 @@ Return the complex conjugate of @var{z},
   if (args.length () == 1)
     retval = args(0).conj ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(conj (1), 1);
+%!assert(conj (i), -i)
+%!assert(conj (1+i), 1-i)
+%!assert(conj (1-i), 1+i)
+%!assert(conj ([-1, -i; -1+i, -1-i]), [-1, i; -1-i, -1+i]);
+
+%!assert(conj (single(1)), single(1));
+%!assert(conj (single(i)), single(-i))
+%!assert(conj (single(1+i)), single(1-i))
+%!assert(conj (single(1-i)), single(1+i))
+%!assert(conj (single([-1, -i; -1+i, -1-i])), single([-1, i; -1-i, -1+i]));
+
+%!error conj ();
+%!error conj (1, 2);
+
+*/
+
 DEFUN (cos, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cos (@var{x})\n\
 Compute the cosine of each element of @var{x}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).cos ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!test
+%! rt2 = sqrt (2);
+%! rt3 = sqrt (3);
+%! x = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
+%! v = [1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1];
+%! assert(cos (x), v, sqrt (eps));
+
+%!test
+%! rt2 = sqrt (2);
+%! rt3 = sqrt (3);
+%! x = single([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
+%! v = single([1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1]);
+%! assert(cos (x), v, sqrt (eps('single')));
+
+%!error cos ();
+%!error cos (1, 2);
+
+ */
+
 DEFUN (cosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cosh (@var{x})\n\
 Compute the hyperbolic cosine of each element of @var{x}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).cosh ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!test
+%! x = [0, pi/2*i, pi*i, 3*pi/2*i];
+%! v = [1, 0, -1, 0];
+%! assert(cosh (x), v, sqrt (eps));
+
+%!test
+%! x = single([0, pi/2*i, pi*i, 3*pi/2*i]);
+%! v = single([1, 0, -1, 0]);
+%! assert(cosh (x), v, sqrt (eps ('single')));
+
+%!error cosh ();
+%!error cosh (1, 2);
+
+*/
+
 DEFUN (erf, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erf (@var{z})\n\
 Computes the error function,\n\
 @iftex\n\
 @tex\n\
 $$\n\
  {\\rm erf} (z) = {2 \\over \\sqrt{\\pi}}\\int_0^z e^{-t^2} dt\n\
@@ -324,16 +530,38 @@ erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
 }
 
 /*
 
 %!test
 %! a = -1i*sqrt(-1/(6.4187*6.4187));
 %! assert (erf(a), erf(real(a)));
 
+%!test
+%! x=[0,.5,1];
+%! v=[0, .520499877813047, .842700792949715];
+%! assert(all(abs(erf(x)-v)<1.e-10) &&  all(abs(erf(-x)+v)<1.e-10) && all(abs(erfc(x)+v-1)<1.e-10) && all(abs(erfinv(v)-x)<1.e-10));
+
+%!test
+%! a = -1i*sqrt(single (-1/(6.4187*6.4187)));
+%! assert (erf(a), erf(real(a)));
+
+%!test
+%! x=single ([0,.5,1]);
+%! v=single ([0, .520499877813047, .842700792949715]);
+%! assert(all(abs(erf(x)-v)<1.e-6) &&  all(abs(erf(-x)+v)<1.e-6) && all(abs(erfc(x)+v-1)<1.e-6) && all(abs(erfinv(v)-x)<1.e-6));
+
+%% test/octave.test/arith/erf-2.m
+%!error erf();
+
+%% test/octave.test/arith/erf-3.m
+%!error erf(1,2);
+
+
+
 */
 
 DEFUN (erfc, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfc (@var{z})\n\
 Computes the complementary error function,\n\
 @iftex\n\
 @tex\n\
@@ -374,16 +602,31 @@ see @ref{Linear Algebra}.\n\
   if (args.length () == 1)
     retval = args(0).exp ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(exp ([0, 1, -1, -1000]), [1, e, 1/e, 0], sqrt (eps));
+%!assert(exp (1+i), e * (cos (1) + sin (1) * i), sqrt (eps));
+%!assert(exp (single([0, 1, -1, -1000])), single([1, e, 1/e, 0]), sqrt (eps('single')));
+%!assert(exp (single(1+i)), single (e * (cos (1) + sin (1) * i)), sqrt (eps('single')));
+
+%!error exp ();
+%!error exp (1, 2);
+
+%!assert(exp (Inf) == Inf && exp (-Inf) == 0 && isnan (exp (NaN)));
+%!assert(exp (Inf ('single')) == Inf('single') && exp (-Inf('single')) == 0 && isnan (exp (NaN('single'))));
+
+*/
+
 DEFUN (expm1, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} expm1 (@var{x})\n\
 Compute exp (@var{x}) - 1 accurately in neighbourhood of zero.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -440,16 +683,27 @@ Truncate @var{x} toward zero.  If @var{x
   if (args.length () == 1)
     retval = args(0).fix ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(fix ([1.1, 1, -1.1, -1]), [1, 1, -1, -1]);
+%!assert(fix ([1.1+1.1i, 1+i, -1.1-1.1i, -1-i]), [1+i, 1+i, -1-i, -1-i]);
+%!assert(fix (single([1.1, 1, -1.1, -1])), single([1, 1, -1, -1]));
+%!assert(fix (single([1.1+1.1i, 1+i, -1.1-1.1i, -1-i])), single([1+i, 1+i, -1-i, -1-i]));
+
+%!error fix ();
+%!error fix (1, 2);
+
+*/
 
 DEFUN (floor, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} floor (@var{x})\n\
 Return the largest integer not greater than @var{x}.  If @var{x} is\n\
 complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.\n\
 @end deftypefn")
 {
@@ -457,16 +711,28 @@ complex, return @code{floor (real (@var{
   if (args.length () == 1)
     retval = args(0).floor ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(floor ([2, 1.1, -1.1, -1]), [2, 1, -2, -1]);
+%!assert(floor ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 1+i, -2-2i, -1-i]);
+%!assert(floor (single ([2, 1.1, -1.1, -1])), single ([2, 1, -2, -1]));
+%!assert(floor (single([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single([2+2i, 1+i, -2-2i, -1-i]));
+
+%!error floor ();
+%!error floor (1, 2);
+
+*/
+
 DEFUN (gamma, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} gamma (@var{z})\n\
 Computes the Gamma function,\n\
 @iftex\n\
 @tex\n\
 $$\n\
  \\Gamma (z) = \\int_0^\\infty t^{z-1} e^{-t} dt.\n\
@@ -496,16 +762,33 @@ gamma (z) = | t^(z-1) exp (-t) dt.\n\
 }
 
 /*
 
 %!test
 %! a = -1i*sqrt(-1/(6.4187*6.4187));
 %! assert (gamma(a), gamma(real(a)));
 
+%!test
+%! x = [.5, 1, 1.5, 2, 3, 4, 5];
+%! v = [sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24];
+%! assert(gamma(x), v, sqrt(eps))
+
+%!test
+%! a = single(-1i*sqrt(-1/(6.4187*6.4187)));
+%! assert (gamma(a), gamma(real(a)));
+
+%!test
+%! x = single([.5, 1, 1.5, 2, 3, 4, 5]);
+%! v = single([sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24]);
+%! assert(gamma(x), v, sqrt(eps('single')))
+
+%!error gamma();
+%!error gamma(1,2);
+
 */
 
 DEFUN (imag, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} imag (@var{z})\n\
 Return the imaginary part of @var{z} as a real number.\n\
 @seealso{real, conj}\n\
 @end deftypefn")
@@ -514,16 +797,33 @@ Return the imaginary part of @var{z} as 
   if (args.length () == 1)
     retval = args(0).imag ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(imag (1), 0);
+%!assert(imag (i), 1);
+%!assert(imag (1+i), 1);
+%!assert(imag ([i, 1; 1, i]), eye (2));
+
+%!assert(imag (single(1)), single(0));
+%!assert(imag (single(i)), single(1));
+%!assert(imag (single(1+i)), single(1));
+%!assert(imag (single([i, 1; 1, i])), eye (2,'single'));
+
+%!error imag ();
+%!error imag (1, 2);
+
+ */
+
 DEFUNX ("isalnum", Fisalnum, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalnum (@var{s})\n\
 Return 1 for characters that are letters or digits (@code{isalpha\n\
 (@var{s})} or @code{isdigit (@var{s})} is true).\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -838,16 +1138,33 @@ Return the natural logarithm of the gamm
 }
 
 /*
 
 %!test
 %! a = -1i*sqrt(-1/(6.4187*6.4187));
 %! assert (lgamma(a), lgamma(real(a)));
 
+%!test
+%! x = [.5, 1, 1.5, 2, 3, 4, 5];
+%! v = [sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24];
+%! assert(lgamma(x), log(v), sqrt(eps))
+
+%!test
+%! a = single(-1i*sqrt(-1/(6.4187*6.4187)));
+%! assert (lgamma(a), lgamma(real(a)));
+
+%!test
+%! x = single([.5, 1, 1.5, 2, 3, 4, 5]);
+%! v = single([sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24]);
+%! assert(lgamma(x), log(v), sqrt(eps ('single')))
+
+%!error lgamma();
+%!error lgamma(1,2);
+
 */
 
 DEFUN (log, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log (@var{x})\n\
 Compute the natural logarithm for each element of @var{x}.  To compute the\n\
 matrix logarithm, see @ref{Linear Algebra}.\n\
 @seealso{log2, log10, logspace, exp}\n\
@@ -857,32 +1174,55 @@ matrix logarithm, see @ref{Linear Algebr
   if (args.length () == 1)
     retval = args(0).log ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(log ([1, e, e^2]), [0, 1, 2], sqrt (eps));
+%!assert(log ([-0.5, -1.5, -2.5]), log([0.5, 1.5, 2.5]) + pi*1i, sqrt (eps));
+
+%!assert(log (single([1, e, e^2])), single([0, 1, 2]), sqrt (eps));
+%!assert(log (single([-0.5, -1.5, -2.5])), single(log([0.5, 1.5, 2.5]) + pi*1i), sqrt (eps));
+
+%!error log ();
+%!error log (1, 2);
+
+ */
+
 DEFUN (log10, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
 Compute the base-10 logarithm for each element of @var{x}.\n\
 @seealso{log, log2, logspace, exp}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).log10 ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(log10 ([0.01, 0.1, 1, 10, 100]), [-2, -1, 0, 1, 2], sqrt (eps));
+%!assert(log10 (single([0.01, 0.1, 1, 10, 100])), single([-2, -1, 0, 1, 2]), sqrt (eps ('single')));
+
+%!error log10 ();
+%!error log10 (1, 2);
+
+*/
+
 DEFUN (log1p, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log1p (@var{x})\n\
 Compute log (1 + @var{x}) accurately in neighbourhood of zero.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -904,16 +1244,33 @@ Return the real part of @var{z}.\n\
   if (args.length () == 1)
     retval = args(0).real ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(real (1), 1);
+%!assert(real (i), 0);
+%!assert(real (1+i), 1);
+%!assert(real ([1, i; i, 1]), eye (2));
+
+%!assert(real (single(1)), single(1));
+%!assert(real (single(i)), single(0));
+%!assert(real (single(1+i)), single(1));
+%!assert(real (single([1, i; i, 1])), eye (2,'single'));
+
+%!error real ();
+%!error real (1, 2);
+
+*/
+
 DEFUN (round, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} round (@var{x})\n\
 Return the integer nearest to @var{x}.  If @var{x} is complex, return\n\
 @code{round (real (@var{x})) + round (imag (@var{x})) * I}.\n\
 @seealso{rem}\n\
 @end deftypefn")
 {
@@ -921,16 +1278,39 @@ Return the integer nearest to @var{x}.  
   if (args.length () == 1)
     retval = args(0).round ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(round (1), 1);
+%!assert(round (1.1), 1);
+%!assert(round (5.5), 6);
+%!assert(round (i), i);
+%!assert(round (2.5+3.5i), 3+4i);
+%!assert(round (-2.6), -3);
+%!assert(round ([1.1, -2.4; -3.7, 7.1]), [1, -2; -4, 7]);
+
+%!assert(round (single(1)), single(1));
+%!assert(round (single(1.1)), single(1));
+%!assert(round (single(5.5)), single(6));
+%!assert(round (single(i)), single(i));
+%!assert(round (single(2.5+3.5i)), single(3+4i));
+%!assert(round (single(-2.6)), single(-3));
+%!assert(round (single([1.1, -2.4; -3.7, 7.1])), single([1, -2; -4, 7]));
+
+%!error round ();
+%!error round (1, 2);
+
+*/
+
 DEFUN (roundb, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} roundb (@var{x})\n\
 Return the integer nearest to @var{x}. If there are two nearest\n\
 integers, return the even one (banker's rounding). If @var{x} is complex,\n\
 return @code{roundb (real (@var{x})) + roundb (imag (@var{x})) * I}.\n\
 @seealso{rem}\n\
 @end deftypefn")
@@ -971,46 +1351,101 @@ For complex arguments, @code{sign} retur
   if (args.length () == 1)
     retval = args(0).signum ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(sign (-2) , -1);
+%!assert(sign (3), 1);
+%!assert(sign (0), 0);
+%!assert(sign ([1, -pi; e, 0]), [1, -1; 1, 0]);
+
+%!assert(sign (single(-2)) , single(-1));
+%!assert(sign (single(3)), single(1));
+%!assert(sign (single(0)), single(0));
+%!assert(sign (single([1, -pi; e, 0])), single([1, -1; 1, 0]));
+
+%!error sign ();
+%!error sign (1, 2);
+
+*/
+
 DEFUN (sin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sin (@var{x})\n\
 Compute the sine of each element of @var{x}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).sin ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!test
+%! rt2 = sqrt (2);
+%! rt3 = sqrt (3);
+%! x = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
+%! v = [0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0];
+%! assert(sin (x), v, sqrt (eps));
+
+%!test
+%! rt2 = sqrt (2);
+%! rt3 = sqrt (3);
+%! x = single([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
+%! v = single([0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0]);
+%! assert(sin (x), v, sqrt (eps('single')));
+
+%!error sin ();
+%!error sin (1, 2);
+
+*/
+
 DEFUN (sinh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sinh (@var{x})\n\
 Compute the hyperbolic sine of each element of @var{x}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).sinh ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!test
+%! x = [0, pi/2*i, pi*i, 3*pi/2*i];
+%! v = [0, i, 0, -i];
+%! assert(sinh (x), v, sqrt (eps));
+
+%!test
+%! x = single([0, pi/2*i, pi*i, 3*pi/2*i]);
+%! v = single([0, i, 0, -i]);
+%! assert(sinh (x), v, sqrt (eps('single')));
+
+%!error sinh ();
+%!error sinh (1, 2);
+
+ */
+
 DEFUN (sqrt, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sqrt (@var{x})\n\
 Compute the square root of @var{x}.  If @var{x} is negative, a complex\n\
 result is returned.  To compute the matrix square root, see\n\
 @ref{Linear Algebra}.\n\
 @end deftypefn")
 {
@@ -1018,46 +1453,101 @@ result is returned.  To compute the matr
   if (args.length () == 1)
     retval = args(0).sqrt ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert(sqrt (4), 2)
+%!assert(sqrt (-1), i)
+%!assert(sqrt (1+i), exp (0.5 * log (1+i)), sqrt (eps));
+%!assert(sqrt([4, -4; i, 1-i]), [2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))], sqrt(eps));
+
+%!assert(sqrt (single(4)), single(2))
+%!assert(sqrt (single(-1)), single(i))
+%!assert(sqrt (single(1+i)), single(exp (0.5 * log (1+i))), sqrt (eps('single')));
+%!assert(sqrt(single([4, -4; i, 1-i])), single([2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))]), sqrt(eps('single')));
+
+%!error sqrt ();
+%!error sqrt (1, 2);
+
+*/
+
 DEFUN (tan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tan (@var{z})\n\
 Compute tangent of each element of @var{x}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).tan ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!test
+%! rt2 = sqrt (2);
+%! rt3 = sqrt (3);
+%! x = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
+%! v = [0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0];
+%! assert(tan (x), v,  sqrt (eps));
+
+%!test
+%! rt2 = sqrt (2);
+%! rt3 = sqrt (3);
+%! x = single([0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
+%! v = single([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
+%! assert(tan (x), v,  sqrt (eps('single')));
+
+%!error tan ();
+%!error tan (1, 2);
+
+*/
+
 DEFUN (tanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tanh (@var{x})\n\
 Compute hyperbolic tangent of each element of @var{x}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).tanh ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!test
+%! x = [0, pi*i];
+%! v = [0, 0];
+%! assert(tanh (x), v, sqrt (eps));
+
+%!test
+%! x = single([0, pi*i]);
+%! v = single([0, 0]);
+%! assert(tanh (x), v, sqrt (eps('single')));
+
+%!error tanh ();
+%!error tanh (1, 2);
+
+*/
+
 DEFUNX ("toascii", Ftoascii, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} toascii (@var{s})\n\
 Return ASCII representation of @var{s} in a matrix.  For example,\n\
 \n\
 @example\n\
 @group\n\
 toascii (\"ASCII\")\n\
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -294,61 +294,61 @@ octave_float_scalar::as_mxArray (void) c
     return octave_value (FCN (scalar)); \
   }
 
 #define CD_SCALAR_MAPPER(MAP, RFCN, CFCN, L1, L2) \
   octave_value \
   octave_float_scalar::MAP (void) const \
   { \
     return (scalar < L1 || scalar > L2 \
-            ? octave_value (CFCN (Complex (scalar))) \
+            ? octave_value (CFCN (FloatComplex (scalar))) \
 	    : octave_value (RFCN (scalar))); \
   }
 
 static float
 xconj (float x)
 {
   return x;
 }
 
-SCALAR_MAPPER (erf, ::erf)
-SCALAR_MAPPER (erfc, ::erfc)
+SCALAR_MAPPER (erf, ::erff)
+SCALAR_MAPPER (erfc, ::erfcf)
 SCALAR_MAPPER (gamma, xgamma)
-CD_SCALAR_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Inf)
-SCALAR_MAPPER (abs, ::fabs)
-SCALAR_MAPPER (acos, ::acos)
-CD_SCALAR_MAPPER (acosh, ::acosh, ::acosh, 1.0, octave_Inf)
+CD_SCALAR_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Float_Inf)
+SCALAR_MAPPER (abs, ::fabsf)
+SCALAR_MAPPER (acos, ::acosf)
+CD_SCALAR_MAPPER (acosh, ::acoshf, ::acosh, 1.0, octave_Float_Inf)
 SCALAR_MAPPER (angle, ::arg)
 SCALAR_MAPPER (arg, ::arg)
-CD_SCALAR_MAPPER (asin, ::asin, ::asin, -1.0, 1.0)
-SCALAR_MAPPER (asinh, ::asinh)
-SCALAR_MAPPER (atan, ::atan)
-CD_SCALAR_MAPPER (atanh, ::atanh, ::atanh, -1.0, 1.0)
-SCALAR_MAPPER (ceil, ::ceil)
+CD_SCALAR_MAPPER (asin, ::asinf, ::asin, -1.0, 1.0)
+SCALAR_MAPPER (asinh, ::asinhf)
+SCALAR_MAPPER (atan, ::atanf)
+CD_SCALAR_MAPPER (atanh, ::atanhf, ::atanh, -1.0, 1.0)
+SCALAR_MAPPER (ceil, ::ceilf)
 SCALAR_MAPPER (conj, xconj)
-SCALAR_MAPPER (cos, ::cos)
-SCALAR_MAPPER (cosh, ::cosh)
-SCALAR_MAPPER (exp, ::exp)
-SCALAR_MAPPER (expm1, ::expm1)
+SCALAR_MAPPER (cos, ::cosf)
+SCALAR_MAPPER (cosh, ::coshf)
+SCALAR_MAPPER (exp, ::expf)
+SCALAR_MAPPER (expm1, ::expm1f)
 SCALAR_MAPPER (fix, ::fix)
-SCALAR_MAPPER (floor, ::floor)
+SCALAR_MAPPER (floor, ::floorf)
 SCALAR_MAPPER (imag, ::imag)
-CD_SCALAR_MAPPER (log, ::log, std::log, 0.0, octave_Inf)
-CD_SCALAR_MAPPER (log2, xlog2, xlog2, 0.0, octave_Inf)
-CD_SCALAR_MAPPER (log10, ::log10, std::log10, 0.0, octave_Inf)
-CD_SCALAR_MAPPER (log1p, ::log1p, ::log1p, -1.0, octave_Inf)
+CD_SCALAR_MAPPER (log, ::logf, std::log, 0.0, octave_Float_Inf)
+CD_SCALAR_MAPPER (log2, xlog2, xlog2, 0.0, octave_Float_Inf)
+CD_SCALAR_MAPPER (log10, ::log10f, std::log10, 0.0, octave_Float_Inf)
+CD_SCALAR_MAPPER (log1p, ::log1pf, ::log1p, -1.0, octave_Float_Inf)
 SCALAR_MAPPER (real, ::real)
 SCALAR_MAPPER (round, xround)
 SCALAR_MAPPER (roundb, xroundb)
 SCALAR_MAPPER (signum, ::signum)
-SCALAR_MAPPER (sin, ::sin)
-SCALAR_MAPPER (sinh, ::sinh)
-CD_SCALAR_MAPPER (sqrt, ::sqrt, std::sqrt, 0.0, octave_Inf)
-SCALAR_MAPPER (tan, ::tan)
-SCALAR_MAPPER (tanh, ::tanh)
+SCALAR_MAPPER (sin, ::sinf)
+SCALAR_MAPPER (sinh, ::sinhf)
+CD_SCALAR_MAPPER (sqrt, ::sqrtf, std::sqrt, 0.0, octave_Float_Inf)
+SCALAR_MAPPER (tan, ::tanf)
+SCALAR_MAPPER (tanh, ::tanhf)
 SCALAR_MAPPER (finite, xfinite)
 SCALAR_MAPPER (isinf, xisinf)
 SCALAR_MAPPER (isna, octave_is_NA)
 SCALAR_MAPPER (isnan, xisnan)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-flt-complex.cc b/src/ov-flt-complex.cc
--- a/src/ov-flt-complex.cc
+++ b/src/ov-flt-complex.cc
@@ -445,18 +445,18 @@ xreal (const FloatComplex& x)
       } \
     else \
       { \
         error ("%s: not defined for complex arguments", #MAP); \
         return octave_value (); \
       } \
   }
 
-SCALAR_MAPPER (erf, ::erf)
-SCALAR_MAPPER (erfc, ::erfc)
+SCALAR_MAPPER (erf, ::erff)
+SCALAR_MAPPER (erfc, ::erfcf)
 SCALAR_MAPPER (gamma, xgamma)
 CD_SCALAR_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Inf)
 
 COMPLEX_MAPPER (abs, xabs)
 COMPLEX_MAPPER (acos, ::acos)
 COMPLEX_MAPPER (acosh, ::acosh)
 COMPLEX_MAPPER (angle, std::arg)
 COMPLEX_MAPPER (arg, std::arg)
@@ -464,24 +464,24 @@ COMPLEX_MAPPER (asin, ::asin)
 COMPLEX_MAPPER (asinh, ::asinh)
 COMPLEX_MAPPER (atan, ::atan)
 COMPLEX_MAPPER (atanh, ::atanh)
 COMPLEX_MAPPER (ceil, ::ceil)
 COMPLEX_MAPPER (conj, std::conj)
 COMPLEX_MAPPER (cos, std::cos)
 COMPLEX_MAPPER (cosh, std::cosh)
 COMPLEX_MAPPER (exp, std::exp)
-COMPLEX_MAPPER (expm1, ::expm1)
+COMPLEX_MAPPER (expm1, ::expm1f)
 COMPLEX_MAPPER (fix, ::fix)
 COMPLEX_MAPPER (floor, ::floor)
 COMPLEX_MAPPER (imag, ximag)
 COMPLEX_MAPPER (log, std::log)
 COMPLEX_MAPPER (log2, xlog2)
 COMPLEX_MAPPER (log10, std::log10)
-COMPLEX_MAPPER (log1p, ::log1p)
+COMPLEX_MAPPER (log1p, ::log1pf)
 COMPLEX_MAPPER (real, xreal)
 COMPLEX_MAPPER (round, xround)
 COMPLEX_MAPPER (roundb, xroundb)
 COMPLEX_MAPPER (signum, ::signum)
 COMPLEX_MAPPER (sin, std::sin)
 COMPLEX_MAPPER (sinh, std::sinh)
 COMPLEX_MAPPER (sqrt, std::sqrt)
 COMPLEX_MAPPER (tan, std::tan)
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -763,17 +763,17 @@ any_element_greater_than (const FloatNDA
     return matrix.map (cmap); \
   }
 
 #define DARRAY_MAPPER(MAP, AMAP, FCN) \
   octave_value \
   octave_float_complex_matrix::MAP (void) const \
   { \
     static FloatComplexNDArray::dmapper dmap = ximag; \
-    NDArray m = matrix.map (dmap); \
+    FloatNDArray m = matrix.map (dmap); \
     if (m.all_elements_are_zero ()) \
       { \
 	dmap = xreal; \
 	m = matrix.map (dmap); \
         static AMAP cmap = FCN; \
         return m.map (cmap); \
       } \
     else \
@@ -803,19 +803,19 @@ any_element_greater_than (const FloatNDA
       } \
     else \
       { \
         /*error ("%s: not defined for complex arguments", #MAP); */	\
         return octave_value (m); \
       } \
   }
 
-DARRAY_MAPPER (erf, NDArray::dmapper, ::erf)
-DARRAY_MAPPER (erfc, NDArray::dmapper, ::erfc)
-DARRAY_MAPPER (gamma, NDArray::dmapper, xgamma)
+DARRAY_MAPPER (erf, FloatNDArray::dmapper, ::erff)
+DARRAY_MAPPER (erfc, FloatNDArray::dmapper, ::erfcf)
+DARRAY_MAPPER (gamma, FloatNDArray::dmapper, xgamma)
 CD_ARRAY_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Inf)
 
 ARRAY_MAPPER (abs, FloatComplexNDArray::dmapper, xabs)
 ARRAY_MAPPER (acos, FloatComplexNDArray::cmapper, ::acos)
 ARRAY_MAPPER (acosh, FloatComplexNDArray::cmapper, ::acosh)
 ARRAY_MAPPER (angle, FloatComplexNDArray::dmapper, std::arg)
 ARRAY_MAPPER (arg, FloatComplexNDArray::dmapper, std::arg)
 ARRAY_MAPPER (asin, FloatComplexNDArray::cmapper, ::asin)
diff --git a/src/ov-flt-cx-mat.h b/src/ov-flt-cx-mat.h
--- a/src/ov-flt-cx-mat.h
+++ b/src/ov-flt-cx-mat.h
@@ -91,17 +91,17 @@ public:
   void assign (const octave_value_list& idx, const FloatComplexNDArray& rhs);
 
   void assign (const octave_value_list& idx, const FloatNDArray& rhs);
 
   bool is_complex_matrix (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
-  bool is_double_type (void) const { return true; }
+  bool is_single_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   bool valid_as_scalar_index (void) const;
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -757,46 +757,46 @@ static float
 xconj (float x)
 {
   return x;
 }
 
 ARRAY_MAPPER (erf, FloatNDArray::dmapper, ::erff)
 ARRAY_MAPPER (erfc, FloatNDArray::dmapper, ::erfcf)
 ARRAY_MAPPER (gamma, FloatNDArray::dmapper, xgamma)
-CD_ARRAY_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Inf)
+CD_ARRAY_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Float_Inf)
 ARRAY_MAPPER (abs, FloatNDArray::dmapper, ::fabsf)
 ARRAY_MAPPER (acos, FloatNDArray::dmapper, ::acosf)
-CD_ARRAY_MAPPER (acosh, ::acoshf, ::acosh, 1.0, octave_Inf)
+CD_ARRAY_MAPPER (acosh, ::acoshf, ::acosh, 1.0, octave_Float_Inf)
 ARRAY_MAPPER (angle, FloatNDArray::dmapper, ::arg)
 ARRAY_MAPPER (arg, FloatNDArray::dmapper, ::arg)
 CD_ARRAY_MAPPER (asin, ::asinf, ::asin, -1.0, 1.0)
 ARRAY_MAPPER (asinh, FloatNDArray::dmapper,::asinhf)
 ARRAY_MAPPER (atan, FloatNDArray::dmapper, ::atanf)
 CD_ARRAY_MAPPER (atanh, ::atanhf, ::atanh, -1.0, 1.0)
 ARRAY_MAPPER (ceil, FloatNDArray::dmapper, ::ceilf)
 ARRAY_MAPPER (conj, FloatNDArray::dmapper, xconj)
 ARRAY_MAPPER (cos, FloatNDArray::dmapper, ::cosf)
 ARRAY_MAPPER (cosh, FloatNDArray::dmapper, ::coshf)
 ARRAY_MAPPER (exp, FloatNDArray::dmapper, ::expf)
 ARRAY_MAPPER (expm1, FloatNDArray::dmapper, ::expm1f)
 ARRAY_MAPPER (fix, FloatNDArray::dmapper, ::fix)
 ARRAY_MAPPER (floor, FloatNDArray::dmapper, ::floorf)
 ARRAY_MAPPER (imag, FloatNDArray::dmapper, ::imag)
-CD_ARRAY_MAPPER (log, ::logf, std::log, 0.0, octave_Inf)
-CD_ARRAY_MAPPER (log2, xlog2, xlog2, 0.0, octave_Inf)
-CD_ARRAY_MAPPER (log10, ::log10f, std::log10, 0.0, octave_Inf)
-CD_ARRAY_MAPPER (log1p, ::log1pf, ::log1pf, -1.0, octave_Inf)
+CD_ARRAY_MAPPER (log, ::logf, std::log, 0.0, octave_Float_Inf)
+CD_ARRAY_MAPPER (log2, xlog2, xlog2, 0.0, octave_Float_Inf)
+CD_ARRAY_MAPPER (log10, ::log10f, std::log10, 0.0, octave_Float_Inf)
+CD_ARRAY_MAPPER (log1p, ::log1pf, ::log1pf, -1.0, octave_Float_Inf)
 ARRAY_MAPPER (real, FloatNDArray::dmapper, ::real)
 ARRAY_MAPPER (round, FloatNDArray::dmapper, xround)
 ARRAY_MAPPER (roundb, FloatNDArray::dmapper, xroundb)
 ARRAY_MAPPER (signum, FloatNDArray::dmapper, ::signum)
 ARRAY_MAPPER (sin, FloatNDArray::dmapper, ::sinf)
 ARRAY_MAPPER (sinh, FloatNDArray::dmapper, ::sinhf)
-CD_ARRAY_MAPPER (sqrt, ::sqrtf, std::sqrt, 0.0, octave_Inf)
+CD_ARRAY_MAPPER (sqrt, ::sqrtf, std::sqrt, 0.0, octave_Float_Inf)
 ARRAY_MAPPER (tan, FloatNDArray::dmapper, ::tanf)
 ARRAY_MAPPER (tanh, FloatNDArray::dmapper, ::tanhf)
 ARRAY_MAPPER (finite, FloatNDArray::bmapper, xfinite)
 ARRAY_MAPPER (isinf, FloatNDArray::bmapper, xisinf)
 ARRAY_MAPPER (isna, FloatNDArray::bmapper, octave_is_NA)
 ARRAY_MAPPER (isnan, FloatNDArray::bmapper, xisnan)
 
 DEFUN (single, args, ,
diff --git a/test/ChangeLog b/test/ChangeLog
--- a/test/ChangeLog
+++ b/test/ChangeLog
@@ -1,10 +1,14 @@
 2008-06-02  David Bateman  <dbateman@free.fr>
 
+	* test_arith.m: Delete and move tests close to function
+	definitions.
+	* test_func.m: Also test for single precision return values.
+
 	* test_infnan.m, test_linalg.m, test_matrix.m, test_number.m):
 	Delet and move tests close to function definitions.
 	* test_range.m: Also test single precision examples.
 
 2008-05-19  Bill Denney  <bill@denney.ws>
 
 	* test_args.m: Update format to allow running "test test_args" 
 	and add default argument tests.
diff --git a/test/test_arith.m b/test/test_arith.m
deleted file mode 100644
--- a/test/test_arith.m
+++ /dev/null
@@ -1,525 +0,0 @@
-## Copyright (C) 2006, 2007 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-%% Automatically generated from DejaGNU files
-
-
-%% test/octave.test/arith/betainc-1.m
-%!test
-%! a=[1, 1.5, 2, 3];
-%! b=[4, 3, 2, 1];
-%! v1=betainc(1,a,b);
-%! v2=[1,1,1,1];
-%! x = [.2, .4, .6, .8];
-%! v3=betainc(x, a, b);
-%! v4 = 1-betainc(1.-x, b, a);
-%! assert(all(abs(v1-v2)<sqrt(eps)) && all(abs(v3-v4)<sqrt(eps)));
-
-%% test/octave.test/arith/betainc-2.m
-%!error <Invalid call to betainc.*> betainc();
-
-%% test/octave.test/arith/betainc-3.m
-%!error <Invalid call to betainc.*> betainc(1);
-
-%% test/octave.test/arith/betainc-4.m
-%!error <Invalid call to betainc.*> betainc(1,2);
-
-%% test/octave.test/arith/ceil-1.m
-%!assert(all (ceil ([2, 1.1, -1.1, -1]) == [2, 2, -1, -1]));
-
-%% test/octave.test/arith/ceil-2.m
-%!assert(all (ceil ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]) == [2+2i, 2+2i, -1-i, -1-i]));
-
-%% test/octave.test/arith/ceil-3.m
-%!error ceil ();
-
-%% test/octave.test/arith/ceil-4.m
-%!error ceil (1, 2);
-
-%% test/octave.test/arith/erf-1.m
-%!test
-%! x=[0,.5,1];
-%! v=[0, .520499877813047, .842700792949715];
-%! assert(all(abs(erf(x)-v)<1.e-10) &&  all(abs(erf(-x)+v)<1.e-10) && all(abs(erfc(x)+v-1)<1.e-10) && all(abs(erfinv(v)-x)<1.e-10));
-
-%% test/octave.test/arith/erf-2.m
-%!error erf();
-
-%% test/octave.test/arith/erf-3.m
-%!error erf(1,2);
-
-%% test/octave.test/arith/exp-1.m
-%!assert(all (abs (exp ([0, 1, -1, -1000]) - [1, e, 1/e, 0]) < sqrt (eps)));
-
-%% test/octave.test/arith/exp-2.m
-%!assert(abs (exp (1+i) - e * (cos (1) + sin (1) * i)) < sqrt (eps));
-
-%% test/octave.test/arith/exp-3.m
-%!error exp ();
-
-%% test/octave.test/arith/exp-4.m
-%!error exp (1, 2);
-
-%% test/octave.test/arith/exp-5.m
-%!assert(exp (Inf) == Inf && exp (-Inf) == 0 && isnan (exp (NaN)));
-
-%% test/octave.test/arith/fix-1.m
-%!assert(all (fix ([1.1, 1, -1.1, -1]) == [1, 1, -1, -1]));
-
-%% test/octave.test/arith/fix-2.m
-%!assert(all (fix ([1.1+1.1i, 1+i, -1.1-1.1i, -1-i]) == [1+i, 1+i, -1-i, -1-i]));
-
-%% test/octave.test/arith/fix-3.m
-%!error fix ();
-
-%% test/octave.test/arith/fix-4.m
-%!error fix (1, 2);
-
-%% test/octave.test/arith/floor-1.m
-%!assert(all (floor ([2, 1.1, -1.1, -1]) == [2, 1, -2, -1]));
-
-%% test/octave.test/arith/floor-2.m
-%!assert(all (floor ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]) == [2+2i, 1+i, -2-2i, -1-i]));
-
-%% test/octave.test/arith/floor-3.m
-%!error floor ();
-
-%% test/octave.test/arith/floor-4.m
-%!error floor (1, 2);
-
-%% test/octave.test/arith/gamma-1.m
-%!test
-%! x = [.5, 1, 1.5, 2, 3, 4, 5];
-%! v = [sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24];
-%! assert(all(abs(gamma(x) - v) < sqrt(eps)) && all(abs(lgamma(x) - log(v)) < sqrt(eps))
-%! );
-
-%% test/octave.test/arith/gamma-2.m
-%!error gamma();
-
-%% test/octave.test/arith/gamma-3.m
-%!error gamma(1,2);
-
-%% test/octave.test/arith/gammainc-1.m
-%!test
-%! a = [.5 .5 .5 .5 .5];
-%! x = [0 1 2 3 4];
-%! v1 = sqrt(pi)*erf(x)./gamma(a);
-%! v3 = gammainc(x.*x,a);
-%! assert(all (abs(v1 - v3) < sqrt(eps)));
-
-%% test/octave.test/arith/gcd-1.m
-%!assert((gcd (200, 300, 50, 35) == gcd ([200, 300, 50, 35])
-%! && gcd ([200, 300, 50, 35]) == 5));
-
-%% test/octave.test/arith/gcd-2.m
-%!error <Invalid call to gcd.*> gcd ();
-
-%% test/octave.test/arith/gcd-3.m
-%!test
-%! s.a = 1;
-%! fail("gcd (s)");
-
-%% test/octave.test/arith/round-1.m
-%!assert((round (1) == 1 && round (1.1) == 1 && round (5.5) == 6
-%! && round (i) == i && round (2.5+3.5i) == 3+4i && round (-2.6) == -3));
-
-%% test/octave.test/arith/round-2.m
-%!assert(all (all (round ([1.1, -2.4; -3.7, 7.1]) == [1, -2; -4, 7])));
-
-%% test/octave.test/arith/round-3.m
-%!error round ();
-
-%% test/octave.test/arith/round-4.m
-%!error round (1, 2);
-
-%% test/octave.test/arith/sign-1.m
-%!assert(sign (-2) == -1 && sign (3) == 1 && sign (0) == 0);
-
-%% test/octave.test/arith/sign-2.m
-%!assert(all (all (sign ([1, -pi; e, 0]) == [1, -1; 1, 0])));
-
-%% test/octave.test/arith/sign-3.m
-%!error sign ();
-
-%% test/octave.test/arith/sign-4.m
-%!error sign (1, 2);
-
-%% test/octave.test/arith/sqrt-1.m
-%!assert((sqrt (4) == 2 && sqrt (-1) == i
-%! && abs (sqrt (1+i) - exp (0.5 * log (1+i))) < sqrt (eps)));
-
-%% test/octave.test/arith/sqrt-2.m
-%!test
-%! t1 = exp (0.5 * log (i));
-%! t2 = exp (0.5 * log (1-i));
-%! assert(all (all (abs (sqrt ([4, -4; i, 1-i]) - [2, 2i; t1, t2]) < sqrt (eps))));
-
-%% test/octave.test/arith/sqrt-3.m
-%!error sqrt ();
-
-%% test/octave.test/arith/sqrt-4.m
-%!error sqrt (1, 2);
-
-%% test/octave.test/arith/abs-1.m
-%!assert(abs (1) == 1 && abs (-3.5) == 3.5 && abs (3+4i) == 5 && abs (3-4i) == 5);
-
-%% test/octave.test/arith/abs-2.m
-%!assert(all (all (abs ([1.1, 3i; 3+4i, -3-4i]) == [1.1, 3; 5, 5])));
-
-%% test/octave.test/arith/abs-3.m
-%!error abs ();
-
-%% test/octave.test/arith/abs-4.m
-%!error abs (1, 2);
-
-%% test/octave.test/arith/arg-1.m
-%!assert(arg (1) == 0 && arg (i) == pi/2 && arg (-1) == pi && arg (-i) == -pi/2);
-
-%% test/octave.test/arith/arg-2.m
-%!assert(all (all (arg ([1, i; -1, -i]) == [0, pi/2; pi, -pi/2])));
-
-%% test/octave.test/arith/arg-3.m
-%!error arg ();
-
-%% test/octave.test/arith/arg-4.m
-%!error arg (1, 2);
-
-%% test/octave.test/arith/conj-1.m
-%!assert(conj (1) == 1 && conj (i) == -i && conj (1+i) == 1-i && conj (1-i) == 1+i);
-
-%% test/octave.test/arith/conj-2.m
-%!assert(all (all (conj ([-1, -i; -1+i, -1-i]) == [-1, i; -1-i, -1+i])));
-
-%% test/octave.test/arith/conj-3.m
-%!error conj ();
-
-%% test/octave.test/arith/conj-4.m
-%!error conj (1, 2);
-
-%% test/octave.test/arith/imag-1.m
-%!assert(imag (1) == 0 && imag (i) == 1 && imag (1+i) == 1);
-
-%% test/octave.test/arith/imag-2.m
-%!assert(all (all (imag ([i, 1; 1, i]) == eye (2))));
-
-%% test/octave.test/arith/imag-3.m
-%!error imag ();
-
-%% test/octave.test/arith/imag-4.m
-%!error imag (1, 2);
-
-%% test/octave.test/arith/real-1.m
-%!assert(real (1) == 1 && real (i) == 0 && real (1+i) == 1);
-
-%% test/octave.test/arith/real-2.m
-%!assert(all (all (real ([1, i; i, 1]) == eye (2))));
-
-%% test/octave.test/arith/real-3.m
-%!error real ();
-
-%% test/octave.test/arith/real-4.m
-%!error real (1, 2);
-
-%% test/octave.test/arith/log-1.m
-%!assert(all (abs (log ([1, e, e^2]) - [0, 1, 2]) < sqrt (eps)));
-
-%% test/octave.test/arith/log-2.m
-%!error log ();
-
-%% test/octave.test/arith/log-3.m
-%!error log (1, 2);
-
-%% test/octave.test/arith/log10-1.m
-%!assert(all (abs (log10 ([0.01, 0.1, 1, 10, 100]) - [-2, -1, 0, 1, 2]) < sqrt (eps)));
-
-%% test/octave.test/arith/log10-2.m
-%!error log10 ();
-
-%% test/octave.test/arith/log10-3.m
-%!error log10 (1, 2);
-
-%% test/octave.test/arith/sin-1.m
-%!test
-%! rt2 = sqrt (2);
-%! rt3 = sqrt (3);
-%! x = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
-%! v = [0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0];
-%! assert(all (abs (sin (x) - v) < sqrt (eps)));
-
-%% test/octave.test/arith/sin-2.m
-%!error sin ();
-
-%% test/octave.test/arith/sin-3.m
-%!error sin (1, 2);
-
-%% test/octave.test/arith/cos-1.m
-%!test
-%! rt2 = sqrt (2);
-%! rt3 = sqrt (3);
-%! x = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
-%! v = [1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1];
-%! assert(all (abs (cos (x) - v) < sqrt (eps)));
-
-%% test/octave.test/arith/cos-2.m
-%!error cos ();
-
-%% test/octave.test/arith/cos-3.m
-%!error cos (1, 2);
-
-%% test/octave.test/arith/tan-1.m
-%!test
-%! rt2 = sqrt (2);
-%! rt3 = sqrt (3);
-%! x = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
-%! v = [0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0];
-%! assert(all (abs (tan (x) - v) < sqrt (eps)));
-
-%% test/octave.test/arith/tan-2.m
-%!error tan ();
-
-%% test/octave.test/arith/tan-3.m
-%!error tan (1, 2);
-
-%% test/octave.test/arith/acos-1.m
-%!test
-%! rt2 = sqrt (2);
-%! rt3 = sqrt (3);
-%! v = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
-%! x = [1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1];
-%! assert(all (abs (acos (x) - v) < sqrt (eps))
-%! 
-%! );
-
-%% test/octave.test/arith/acos-2.m
-%!error acos ();
-
-%% test/octave.test/arith/acos-3.m
-%!error acos (1, 2);
-
-%% test/octave.test/arith/atan-1.m
-%!test
-%! rt2 = sqrt (2);
-%! rt3 = sqrt (3);
-%! v = [0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0];
-%! x = [0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0];
-%! assert(all (abs (atan (x) - v) < sqrt (eps))
-%! 
-%! );
-
-%% test/octave.test/arith/atan-2.m
-%!error atan ();
-
-%% test/octave.test/arith/atan-3.m
-%!error atan (1, 2);
-
-%% test/octave.test/arith/sinh-1.m
-%!test
-%! x = [0, pi/2*i, pi*i, 3*pi/2*i];
-%! v = [0, i, 0, -i];
-%! assert(all (abs (sinh (x) - v) < sqrt (eps)));
-
-%% test/octave.test/arith/sinh-2.m
-%!error sinh ();
-
-%% test/octave.test/arith/sinh-3.m
-%!error sinh (1, 2);
-
-%% test/octave.test/arith/cosh-1.m
-%!test
-%! x = [0, pi/2*i, pi*i, 3*pi/2*i];
-%! v = [1, 0, -1, 0];
-%! assert(all (abs (cosh (x) - v) < sqrt (eps)));
-
-%% test/octave.test/arith/cosh-2.m
-%!error cosh ();
-
-%% test/octave.test/arith/cosh-3.m
-%!error cosh (1, 2);
-
-%% test/octave.test/arith/tanh-1.m
-%!test
-%! x = [0, pi*i];
-%! v = [0, 0];
-%! assert(all (abs (tanh (x) - v) < sqrt (eps)));
-
-%% test/octave.test/arith/tanh-2.m
-%!error tanh ();
-
-%% test/octave.test/arith/tanh-3.m
-%!error tanh (1, 2);
-
-%% test/octave.test/arith/asinh-1.m
-%!test
-%! v = [0, pi/2*i, 0, -pi/2*i];
-%! x = [0, i, 0, -i];
-%! assert(all (abs (asinh (x) - v) < sqrt (eps))
-%! );
-
-%% test/octave.test/arith/asinh-2.m
-%!error asinh ();
-
-%% test/octave.test/arith/asinh-3.m
-%!error asinh (1, 2);
-
-%% test/octave.test/arith/acosh-1.m
-%!test
-%! v = [0, pi/2*i, pi*i, pi/2*i];
-%! x = [1, 0, -1, 0];
-%! assert(all (abs (acosh (x) - v) < sqrt (eps))
-%! );
-
-%% test/octave.test/arith/acosh-2.m
-%!error acosh ();
-
-%% test/octave.test/arith/acosh-3.m
-%!error acosh (1, 2);
-
-%% test/octave.test/arith/atanh-1.m
-%!test
-%! v = [0, 0];
-%! x = [0, 0];
-%! assert(all (abs (atanh (x) - v) < sqrt (eps))
-%! );
-
-%% test/octave.test/arith/atanh-2.m
-%!error atanh ();
-
-%% test/octave.test/arith/atanh-3.m
-%!error atanh (1, 2);
-
-%% test/octave.test/arith/atan2-1.m
-%!test
-%! rt2 = sqrt (2);
-%! rt3 = sqrt (3);
-%! v = [0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0];
-%! y = [0, rt3, 1, rt3, -rt3, -1, -rt3, 0];
-%! x = [1, 3, 1, 1, 1, 1, 3, 1];
-%! assert(all (abs (atan2 (y, x) - v) < sqrt (eps))
-%! );
-
-%% test/octave.test/arith/atan2-2.m
-%!error <Invalid call to atan2.*> atan2 ();
-
-%% test/octave.test/arith/atan2-3.m
-%!error <Invalid call to atan2.*> atan2 (1, 2, 3);
-
-%% test/octave.test/arith/sum-1.m
-%!assert((sum ([1, 2, 3]) == 6 && sum ([-1; -2; -3]) == -6
-%! && sum ([i, 2+i, -3+2i, 4]) == 3+4i));
-
-%% test/octave.test/arith/sum-2.m
-%!assert(all (all (sum ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]) == [2+2i, 4+4i, 6+6i])));
-
-%% test/octave.test/arith/sum-3.m
-%!error <Invalid call to sum.*> sum ();
-
-%% test/octave.test/arith/sum-4.m
-%!assert (all (sum ([1, 2; 3, 4], 1) == [4, 6]));
-%!assert (all (sum ([1, 2; 3, 4], 2) == [3; 7]));
-%!assert (sum (zeros (1, 0)) == 0);
-%!assert (all (size (sum (zeros (1, 0), 1)) == [1, 0]));
-%!assert (sum (zeros (1, 0), 2) == 0);
-%!assert (sum (zeros (0, 1)) == 0);
-%!assert (sum (zeros (0, 1), 1) == 0);
-%!assert (all (size (sum (zeros (0, 1), 2)) == [0, 1]));
-%!assert (all (size (sum (zeros (2, 0))) == [1, 0]));
-%!assert (all (size (sum (zeros (2, 0), 1)) == [1, 0]));
-%!assert (all (sum (zeros (2, 0), 2) == [0; 0]));
-%!assert (all (sum (zeros (0, 2)) == [0, 0]));
-%!assert (all (sum (zeros (0, 2), 1) == [0, 0]));
-%!assert (all (size (sum (zeros (0, 2), 2)) == [0, 1]));
-%!assert (all (size (sum (zeros (2, 2, 0, 3))) == [1, 2, 0, 3]));
-%!assert (all (size (sum (zeros (2, 2, 0, 3), 2)) == [2, 1, 0, 3]));
-%!assert (all (size (sum (zeros (2, 2, 0, 3), 3)) == [2, 2, 1, 3]));
-%!assert (all (size (sum (zeros (2, 2, 0, 3), 4)) == [2, 2, 0]));
-%!assert (all (size (sum (zeros (2, 2, 0, 3), 7)) == [2, 2, 0, 3]));
-
-%% test/octave.test/arith/prod-1.m
-%!assert (prod ([1, 2, 3]) == 6 && prod ([-1; -2; -3]) == -6);
-%!assert (prod ([i, 2+i, -3+2i, 4]) == -4-32i);
-
-%% test/octave.test/arith/prod-2.m
-%!assert(all (all (prod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])
-%! == [-1+i, -8+8i, -27+27i])));
-
-%% test/octave.test/arith/prod-3.m
-%!error <Invalid call to prod.*> prod ();
-
-%% test/octave.test/arith/prod-4.m
-%!assert (all (prod ([1, 2; 3, 4], 1) == [3, 8]));
-%!assert (all (prod ([1, 2; 3, 4], 2) == [2; 12]));
-%!assert (prod (zeros (1, 0)) == 1);
-%!assert (all (size (prod (zeros (1, 0), 1)) == [1, 0]));
-%!assert (prod (zeros (1, 0), 2) == 1);
-%!assert (prod (zeros (0, 1)) == 1);
-%!assert (prod (zeros (0, 1), 1) == 1);
-%!assert (all (size (prod (zeros (0, 1), 2)) == [0, 1]));
-%!assert (all (size (prod (zeros (2, 0))) == [1, 0]));
-%!assert (all (size (prod (zeros (2, 0), 1)) == [1, 0]));
-%!assert (all (prod (zeros (2, 0), 2) == [1; 1]));
-%!assert (all (prod (zeros (0, 2)) == [1, 1]));
-%!assert (all (prod (zeros (0, 2), 1) == [1, 1]));
-%!assert (all (size (prod (zeros (0, 2), 2)) == [0, 1]));
-
-%% test/octave.test/arith/cumsum-1.m
-%!assert (cumsum ([1, 2, 3]) == [1, 3, 6]);
-%!assert (cumsum ([-1; -2; -3]) == [-1; -3; -6]);
-%!assert (cumsum ([i, 2+i, -3+2i, 4]) == [i, 2+2i, -1+4i, 3+4i]);
-
-%% test/octave.test/arith/cumsum-2.m
-%!assert(all (all (cumsum ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])
-%! == [1, 2, 3; 1+i, 2+2i, 3+3i; 2+2i, 4+4i, 6+6i])));
-
-%% test/octave.test/arith/cumsum-3.m
-%!error <Invalid call to cumsum.*> cumsum ();
-
-%% test/octave.test/arith/cumsum-4.m
-%!assert (all (cumsum ([1, 2; 3, 4], 1) == [1, 2; 4, 6]));
-%!assert (all (cumsum ([1, 2; 3, 4], 2) == [1, 3; 3, 7]));
-
-%% test/octave.test/arith/cumprod-1.m
-%!assert (cumprod ([1, 2, 3]) == [1, 2, 6]);
-%!assert (cumprod ([-1; -2; -3]) == [-1; 2; -6]);
-%!assert (cumprod ([i, 2+i, -3+2i, 4]) == [i, -1+2i, -1-8i, -4-32i]);
-
-%% test/octave.test/arith/cumprod-2.m
-%!assert(all (all (cumprod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])
-%! == [1, 2, 3; i, 4i, 9i; -1+i, -8+8i, -27+27i])));
-
-%% test/octave.test/arith/cumprod-3.m
-%!error <Invalid call to cumprod.*> cumprod ();
-
-%% test/octave.test/arith/cumprod-4.m
-%!assert (all (cumprod ([2, 3; 4, 5], 1) == [2, 3; 8, 15]));
-%!assert (all (cumprod ([2, 3; 4, 5], 2) == [2, 6; 4, 20]));
-
-%% test/octave.test/arith/sumsq-1.m
-%!assert(sumsq ([1, 2, 3]) == 14 && sumsq ([-1; -2; 4i]) == 21);
-
-%% test/octave.test/arith/sumsq-2.m
-%!assert(all (all (sumsq ([1, 2, 3; 2, 3, 4; 4i, 6i, 2]) == [21, 49, 29])));
-
-%% test/octave.test/arith/sumsq-3.m
-%!error <Invalid call to sumsq.*> sumsq ();
-
-%% test/octave.test/arith/sumsq-4.m
-%!assert (all (sumsq ([1, 2; 3, 4], 1) == [10, 20]));
-%!assert (all (sumsq ([1, 2; 3, 4], 2) == [5; 25]));
-
-
diff --git a/test/test_func.m b/test/test_func.m
--- a/test/test_func.m
+++ b/test/test_func.m
@@ -20,19 +20,20 @@
 ## dimensions alone (squeeze, triu, etc.) work for all objects and 
 ## preserve type. Even if the object is an empty matrix. This code is
 ## not to check that the function itself returns teh correct result,
 ## just that the results are consistent for all types.
 
 %!function __fntestfunc__ (fn, mn, varargin)
 %!  typ = {'double', 'complex', 'logical', 'sparse', 'complex sparse', ...
 %!         'logical sparse', 'int8', 'int16', 'int32', 'int64', 'uint8', ...
-%!         'uint16', 'uint32', 'uint64', 'char', 'cell', 'struct'};
+%!         'uint16', 'uint32', 'uint64', 'char', 'cell', 'struct', ...
+%!         'single', 'single complex'};
 %!
-%!  cmplx = [2, 5];
+%!  cmplx = [2, 5, 18];
 %!  nlogical = [3, 6];
 %!  ninteger = [7, 8, 9, 10, 11, 12, 13, 14];
 %!  nsparse = [4, 5, 6];
 %!  skip = {};
 %!
 %!  if (length (varargin) > 0 && iscell (varargin{1}))
 %!    skip = varargin{1};
 %!    varargin(1) = [];
