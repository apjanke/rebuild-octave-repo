# HG changeset patch
# User Rik <rik@octave.org>
# Date 1375665188 25200
#      Sun Aug 04 18:13:08 2013 -0700
# Node ID abf384f5d2438e2a0c6eb4db5215fd6094e70c13
# Parent  4bb7ae3219014f8a6a7f1f0402f86f89cd797099
maint: Remove unneeded input validation from internal fcns in private/ directories.

* scripts/general/private/__isequal__.m,
scripts/general/private/__splinen__.m,
scripts/image/private/__imwrite__.m,
scripts/image/private/ind2x.m,
scripts/miscellaneous/private/__xzip__.m,
scripts/miscellaneous/private/display_info_file.m,
scripts/pkg/private/describe.m,
scripts/pkg/private/get_forge_pkg.m,
scripts/pkg/private/unload_packages.m,
scripts/plot/private/__actual_axis_position__.m,
scripts/plot/private/__add_datasource__.m,
scripts/plot/private/__clabel__.m,
scripts/plot/private/__errcomm__.m,
scripts/plot/private/__errplot__.m,
scripts/plot/private/__fltk_print__.m,
scripts/plot/private/__gnuplot_get_var__.m,
scripts/plot/private/__go_draw_axes__.m,
scripts/plot/private/__go_draw_figure__.m,
scripts/plot/private/__interp_cube__.m,
scripts/plot/private/__line__.m,
scripts/plot/private/__next_line_color__.m,
scripts/plot/private/__next_line_style__.m,
scripts/plot/private/__plt__.m,
scripts/plot/private/__pltopt__.m,
scripts/signal/private/rectangle_lw.m,
scripts/signal/private/rectangle_sw.m,
scripts/signal/private/triangle_lw.m,
scripts/signal/private/triangle_sw.m,
scripts/sparse/private/__sprand_impl__.m,
scripts/statistics/models/private/logistic_regression_derivatives.m,
scripts/statistics/models/private/logistic_regression_likelihood.m:
Remove unneeded input validation from internal fcns in private/ directories.

diff --git a/scripts/general/private/__isequal__.m b/scripts/general/private/__isequal__.m
--- a/scripts/general/private/__isequal__.m
+++ b/scripts/general/private/__isequal__.m
@@ -43,20 +43,16 @@
 ##    a. struct     compare each member by name, not by order (recursive)
 ##    b. cell/list  compare each member by order (recursive)
 ##    c. char       compare each member with strcmp
 ##    d. <other>    compare each nonzero member, and assume NaN == NaN
 ##                  if nans_compare_equal is nonzero.
 
 function t = __isequal__ (nans_compare_equal, x, varargin)
 
-  if (nargin < 3)
-    print_usage ();
-  endif
-
   l_v = nargin - 2;
 
   ## Generic tests.
 
   ## All arguments must either be of the same class or they must be
   ## numeric values.
   t = (all (strcmp (class (x),
                     cellfun ("class", varargin, "uniformoutput", false)))
diff --git a/scripts/general/private/__splinen__.m b/scripts/general/private/__splinen__.m
--- a/scripts/general/private/__splinen__.m
+++ b/scripts/general/private/__splinen__.m
@@ -21,24 +21,21 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{yi} =} __splinen__ (@var{x}, @var{y}, @var{xi})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## FIXME: Allow arbitrary grids..
 
 function yi = __splinen__ (x, y, xi, extrapval, f)
-  if (nargin != 5)
-    error ("__splinen__: Incorrect number of arguments");
-  endif
   ## ND isvector function.
   isvec = @(x) numel (x) == length (x);
   if (!iscell (x) || length (x) < ndims (y) || any (! cellfun (isvec, x))
       || !iscell (xi) || length (xi) < ndims (y) || any (! cellfun (isvec, xi)))
-    error ("__splinen__: %s: non gridded data or dimensions inconsistent", f);
+    error ("__splinen__: %s: non-gridded data or dimensions inconsistent", f);
   endif
   yi = y;
   for i = length (x):-1:1
     yi = permute (spline (x{i}, yi, xi{i}(:)), [length(x),1:length(x)-1]);
   endfor
 
   [xi{:}] = ndgrid (cellfun (@(x) x(:), xi, "uniformoutput", false){:});
   idx = zeros (size (xi{1}));
diff --git a/scripts/image/private/__imwrite__.m b/scripts/image/private/__imwrite__.m
--- a/scripts/image/private/__imwrite__.m
+++ b/scripts/image/private/__imwrite__.m
@@ -26,69 +26,62 @@ function __imwrite__ (img, varargin)
 
   if (nargin < 2 || ! (isnumeric (img) || islogical (img)))
     print_usage ("imwrite");
   endif
 
   [filename, ext, map, param_list] = imwrite_filename (varargin{:});
 
   if (rem (numel (param_list), 2) != 0)
-    error ("imwrite: no pair for all arguments (even number left)");
+    error ("imwrite: no pair for all arguments (odd number left)");
   endif
 
   ## set default for options
-  options        = struct ("writemode", "overwrite",
-                           "quality",   75);
+  options = struct ("writemode", "overwrite", "quality", 75);
 
   for idx = 1:2:numel (param_list)
 
     switch (tolower (param_list{idx}))
 
       case "writemode",
         options.writemode = param_list{idx+1};
-        if (! ischar (options.writemode) ||
-            ! any (strcmpi (options.writemode, {"append", "overwrite"})))
-          error ("imwrite: value for %s option must be \"append\" or \"overwrite\"",
+        if (! ischar (options.writemode)
+            || ! any (strcmpi (options.writemode, {"append", "overwrite"})))
+          error ('imwrite: value for %s option must be "append" or "overwrite"',
                  param_list{idx});
         endif
         options.writemode = tolower (options.writemode);
 
       case "quality",
         options.quality = param_list{idx+1};
-        if (! isnumeric (options.quality) || ! isscalar (options.quality) ||
-            options.quality < 0 || options.quality > 100)
+        if (! isnumeric (options.quality) || ! isscalar (options.quality)
+            || options.quality < 0 || options.quality > 100)
           error ("imwrite: value for %s option must be a scalar between 0 and 100",
                  param_list{idx});
         endif
         options.quality = round (options.quality);
 
       otherwise
         error ("imwrite: invalid PARAMETER `%s'", varargin{idx});
 
     endswitch
   endfor
 
-  if (isempty (img))
-    error ("imwrite: invalid empty image");
-  elseif (issparse (img) || issparse (map))
-    error ("imwrite: sparse images not supported");
-  endif
-
   if (! isempty (map))
     if (! iscolormap (map))
       error ("imwrite: invalid MAP for indexed image");
     elseif (ndims (img) != 2 && ndims (img) != 4)
       error ("imwrite: indexed image must have 2 or 4 dimensions (found %i)", ndims (img));
     endif
     ## FIXME: we should really be writing indexed images but that needs
     ##        to be implemented in  __magick_write__(). So we convert
     ##        them to RGB and write them "normally".
     warned = false;
     if (! warned)
-      warning ("imwrite: saving of indexed images is not yet implemented. Will save a RGB image.");
+      warning ("imwrite: saving of indexed images is not yet implemented.  Will save an RGB image.");
       warned = true;
     endif
     img = ind2rgb (img, map);
     map = [];
   endif
 
   if (ndims (img) > 4)
     error ("imwrite: invalid %d-dimensional image data", ndims (img));
@@ -98,8 +91,9 @@ function __imwrite__ (img, varargin)
     ## but CMYK means length 4 in the 3rd dimension.
     error ("imwrite: IMG 3rd dimension must be 1 or 3");
   endif
 
   ## FIXME: do we need to convert the image class?
   __magick_write__ (filename, ext, img, map, options);
 
 endfunction
+
diff --git a/scripts/image/private/ind2x.m b/scripts/image/private/ind2x.m
--- a/scripts/image/private/ind2x.m
+++ b/scripts/image/private/ind2x.m
@@ -17,18 +17,18 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## private function for the ind2XXX functions which have a lot of code in common
 
 function [x, map] = ind2x (caller, x, map)
 
   ## Check if X is an indexed image.
-  ## an indexed image is defined has having only 2D, and that's how matlab
-  ## behaves. But we want to support ND images, so we will allow up to 4D
+  ## an indexed image is defined has having only 2D, and that's how Matlab
+  ## behaves.  But we want to support ND images, so we will allow up to 4D
   ## and check that the 3rd is a singleton
   if (all (ndims (x) != [2 4]) || size (x, 3) != 1 || issparse (x) ||
       (isfloat (x) && ! isindex (x)) ||
       ! any (strcmp (class (x), {"uint8", "uint16", "single", "double"})))
     error ("%s: X must be an indexed image", caller);
   endif
 
   ## Check if map is a valid colormap.
@@ -46,14 +46,14 @@ function [x, map] = ind2x (caller, x, ma
       x = single (x);
     endif
     x      += 1;
     maxidx += 1;
   endif
 
   num_colors = rows (map);
   if (num_colors < maxidx)
-    ## Pad with the last color in the map for matlab compatibility
+    ## Pad with the last color in the map for Matlab compatibility
     pad = repmat (map(end,:), maxidx - num_colors, 1);
     map(end+1:maxidx, :) = pad;
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/private/__xzip__.m b/scripts/miscellaneous/private/__xzip__.m
--- a/scripts/miscellaneous/private/__xzip__.m
+++ b/scripts/miscellaneous/private/__xzip__.m
@@ -28,24 +28,16 @@
 ## is compressed separately and a new file with the extension @var{extension}
 ## is created and placed into the directory @var{outdir}. The original files
 ## are not touched. Existing compressed files are silently overwritten.
 ## This is an internal function. Do not use directly.
 
 function entries = __xzip__ (commandname, extension,
                              commandtemplate, files, outdir)
 
-  if (nargin != 4 && nargin != 5)
-    print_usage ();
-  endif
-
-  if (! ischar (extension) || length (extension) == 0)
-    error ("__xzip__: EXTENSION must be a string with finite length");
-  endif
-
   if (nargin == 5 && ! exist (outdir, "dir"))
     error ("__xzip__: OUTDIR output directory does not exist");
   endif
 
   if (ischar (files))
     files = cellstr (files);
   endif
   if (! iscellstr (files))
diff --git a/scripts/miscellaneous/private/display_info_file.m b/scripts/miscellaneous/private/display_info_file.m
--- a/scripts/miscellaneous/private/display_info_file.m
+++ b/scripts/miscellaneous/private/display_info_file.m
@@ -16,20 +16,16 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## news() and citation() are very much alike. They both do the same thing, just
 ## for different files. This function does all the work.
 
 function display_info_file (func, package, file)
 
-  if (nargin != 3)
-    print_usage ();
-  endif
-
   if (! ischar (package))
     error ("%s: PACKAGE must be a string", func);
   endif
 
   if (strcmpi (package, "octave"))
     octetcdir = octave_config_info ("octetcdir");
     filepath  = fullfile (octetcdir, file);
   else
diff --git a/scripts/pkg/private/describe.m b/scripts/pkg/private/describe.m
--- a/scripts/pkg/private/describe.m
+++ b/scripts/pkg/private/describe.m
@@ -24,17 +24,16 @@
 
 function [pkg_desc_list, flag] = describe (pkgnames, verbose,
                                            local_list, global_list)
 
   ## Get the list of installed packages.
   installed_pkgs_lst = installed_packages(local_list, global_list);
   num_packages = length (installed_pkgs_lst);
 
-
   describe_all = false;
   if (any (strcmp ("all", pkgnames)))
     describe_all = true;
     flag(1:num_packages) = {"Not Loaded"};
     num_pkgnames = num_packages;
   else
     num_pkgnames = length (pkgnames);
     flag(1:num_pkgnames) = {"Not installed"};
diff --git a/scripts/pkg/private/get_forge_pkg.m b/scripts/pkg/private/get_forge_pkg.m
--- a/scripts/pkg/private/get_forge_pkg.m
+++ b/scripts/pkg/private/get_forge_pkg.m
@@ -21,19 +21,17 @@
 ## @deftypefn {Function File} {[@var{ver}, @var{url}] =} get_forge_pkg (@var{name})
 ## Try to discover the current version of an OctaveForge package from the web,
 ## using a working internet connection and the urlread function.
 ## If two output arguments are requested, also return an address from which
 ## to download the file.
 ## @end deftypefn
 
 function [ver, url] = get_forge_pkg (name)
-  if (nargin != 1)
-    print_usage ();
-  endif
+
   ## Verify that name is valid.
   if (! (ischar (name) && rows (name) == 1 && ndims (name) == 2))
     error ("get_forge_pkg: package NAME must be a string");
   elseif (! all (isalnum (name) | name == "-" | name == "." | name == "_"))
     error ("get_forge_pkg: invalid package name: %s", name);
   endif
 
   name = tolower (name);
diff --git a/scripts/pkg/private/unload_packages.m b/scripts/pkg/private/unload_packages.m
--- a/scripts/pkg/private/unload_packages.m
+++ b/scripts/pkg/private/unload_packages.m
@@ -68,14 +68,13 @@ function unload_packages (files, handle_
   endfor
 
   ## Unload the packages.
   for i = 1:length (archdirs)
     d = archdirs{i};
     idx = strcmp (p, d);
     if (any (idx))
       rmpath (d);
-      ## FIXME: We should also check if we need to remove items from
-      ## EXEC_PATH.
+      ## FIXME: We should also check if we need to remove items from EXEC_PATH.
     endif
   endfor
 endfunction
 
diff --git a/scripts/plot/private/__actual_axis_position__.m b/scripts/plot/private/__actual_axis_position__.m
--- a/scripts/plot/private/__actual_axis_position__.m
+++ b/scripts/plot/private/__actual_axis_position__.m
@@ -55,18 +55,18 @@ function pos = __actual_axis_position__ 
 
   if (strcmp (axis_obj.plotboxaspectratiomode, "manual")
       || strcmp (axis_obj.dataaspectratiomode, "manual"))
     ## When using {rltb}margin, Gnuplot does not handle the specified
     ## aspect ratio properly, so handle it here.
     if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
       aspect_ratio_2d = axis_obj.plotboxaspectratio(1:2);
     else
-      ## FIXME -- this works for "axis square", but has not been
-      ##          thoroughly tested for other aspect ratios.
+      ## FIXME: This works for "axis square", but has not been
+      ##        thoroughly tested for other aspect ratios.
       aspect_ratio_2d = [max(axis_obj.plotboxaspectratio(1:2)), ...
                              axis_obj.plotboxaspectratio(3)/sqrt(2)];
     endif
     orig_aspect_ratio_2d = pos_in_pixels(3:4);
     rel_aspect_ratio_2d =  aspect_ratio_2d ./ orig_aspect_ratio_2d;
     rel_aspect_ratio_2d = rel_aspect_ratio_2d ./ max (rel_aspect_ratio_2d);
     if (rel_aspect_ratio_2d(1) < rel_aspect_ratio_2d(2));
       dx = (1.0 - rel_aspect_ratio_2d(1)) * pos_in_pixels(3);
diff --git a/scripts/plot/private/__add_datasource__.m b/scripts/plot/private/__add_datasource__.m
--- a/scripts/plot/private/__add_datasource__.m
+++ b/scripts/plot/private/__add_datasource__.m
@@ -18,20 +18,16 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{newargs} =} __add_datasource__ (@var{fcn}, @var{h}, @var{data}, @var{varargin})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function newargs = __add_datasource__ (fcn, h, data, varargin)
 
-  if (nargin < 3)
-    error ("__add_datasource__: a minimum of 3 inputs are required");
-  endif
-
   if (ischar (data))
     data = {data};
   endif
 
   for i = 1 : numel (data)
     addproperty (strcat (data{i}, "datasource"), h, "string", "");
   endfor
 
diff --git a/scripts/plot/private/__clabel__.m b/scripts/plot/private/__clabel__.m
--- a/scripts/plot/private/__clabel__.m
+++ b/scripts/plot/private/__clabel__.m
@@ -17,17 +17,18 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{h} =} __clabel__ (@var{c}, @var{v}, @var{hparent}, @var{label_spacing}, @var{z}, @var{varargin})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function h = __clabel__ (c, v, hparent, label_spacing, z, varargin)
-  ## FIXME
+
+  ## FIXME: Why assume?  Can get position in points directly from axis.
   ## Assume that the plot size is 4 by 3 inches.
   lims = axis ();
   xspacing = 72 * 4 / abs (lims(1) - lims(2));
   yspacing = 72 * 3 / abs (lims(3) - lims(4));
 
   if (isscalar (hparent) && ishandle (hparent)
       && strcmp (get (hparent, "type"), "hggroup"))
     x = get (hparent, "xdata");
@@ -84,18 +85,18 @@ function h = __clabel__ (c, v, hparent, 
     for i = 1 : ntag
       tagpos = pos(i);
 
       while (j1 < clen && cumd(j1) < tagpos)
         j1++;
       endwhile
       tpos = sum (c(:,i1+j1-1:i1+j1), 2) ./ 2;
 
-      if (tpos(1) != xmin &&  tpos(1) != xmax
-          && tpos(2) != ymin &&  tpos(2) != ymax)
+      if (   tpos(1) != xmin && tpos(1) != xmax
+          && tpos(2) != ymin && tpos(2) != ymax)
         trot = 180 / pi * atan2 (diff (c(2,i1+j1-1:i1+j1)),
                                  diff (c(1,i1+j1-1:i1+j1)));
 
         if (ischar (z))
           ht = text (tpos(1), tpos(2), clev, tlabel, "rotation", trot,
                      "parent", hparent, "horizontalalignment", "center",
                      "userdata", clev, varargin{:});
         elseif (!isempty (z))
diff --git a/scripts/plot/private/__errcomm__.m b/scripts/plot/private/__errcomm__.m
--- a/scripts/plot/private/__errcomm__.m
+++ b/scripts/plot/private/__errcomm__.m
@@ -12,28 +12,28 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} __errcomm__ (@var{caller}, @var{p}, @dots{})
+## @deftypefn {Function File} {} __errcomm__ (@var{caller}, @var{hax}, @dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Created: 20.02.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
-function retval = __errcomm__ (caller, p, varargin)
+function retval = __errcomm__ (caller, hax, varargin)
 
   if (nargin < 4)
-    print_usage ();
+    print_usage (caller);
   endif
 
   nargs = length (varargin);
   retval = [];
   k = 1;
   data = cell (6,1);
   while (k <= nargs)
     a = varargin{k++};
@@ -45,34 +45,34 @@ function retval = __errcomm__ (caller, p
       usage ("%s (...)", caller);
     endif
     sz = size (a);
     ndata = 1;
     data{ndata} = a;
     while (k <= nargs)
       a = varargin{k++};
       if (ischar (a) || iscellstr (a))
-        retval = [retval; __errplot__(a, p, data{1:ndata})];
+        retval = [retval; __errplot__(a, hax, data{1:ndata})];
         break;
       elseif (isvector (a))
         a = a(:);
       elseif (ismatrix (a))
         ;
       else
-        error ("wrong argument types");
+        error ("%s: wrong argument types", caller);
       endif
       if (size (a) != sz)
-        error ("argument sizes do not match");
+        error ("%s: argument sizes do not match", caller);
       endif
       data{++ndata} = a;
       if (ndata > 6)
-        error ("too many arguments to a plot");
+        error ("%s: too many arguments to plot", caller);
       endif
     endwhile
   endwhile
 
   if (! (ischar (a) || iscellstr (a)))
-    retval = [retval; __errplot__("~", p, data{1:ndata})];
+    retval = [retval; __errplot__("~", hax, data{1:ndata})];
   endif
 
   drawnow ();
 
 endfunction
diff --git a/scripts/plot/private/__errplot__.m b/scripts/plot/private/__errplot__.m
--- a/scripts/plot/private/__errplot__.m
+++ b/scripts/plot/private/__errplot__.m
@@ -12,29 +12,25 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{h} =} __errplot__ (@var{fstr}, @var{p}, @dots{})
+## @deftypefn {Function File} {@var{h} =} __errplot__ (@var{fstr}, @var{hax}, @dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Created: 18.7.2000
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
-function h = __errplot__ (fstr, p, varargin)
-
-  if (nargin < 4 || nargin > 8) # at least two data arguments needed
-    print_usage ();
-  endif
+function h = __errplot__ (fstr, hax, varargin)
 
   [fmt, valid] = __pltopt__ ("__errplot__", fstr);
 
   [len, nplots] = size (varargin{1});
   h = [];
 
   for i = 1:nplots
     ## Set the plot type based on linestyle.
@@ -50,17 +46,17 @@ function h = __errplot__ (fstr, p, varar
     elseif (strcmp (fmt.errorstyle, "#~"))
       ifmt = "boxy";
     elseif (strcmp (fmt.errorstyle, "#~>"))
       ifmt = "boxxy";
     else
       ifmt = "yerr";
     endif
 
-    hg = hggroup ("parent", p);
+    hg = hggroup ("parent", hax);
     h = [h; hg];
     args = __add_datasource__ ("__errplot__", hg,
                                {"x", "y", "l", "u", "xl", "xu"});
 
     if (isempty (fmt.color))
       fmt.color = __next_line_color__ ();
     endif
     if (isempty (fmt.marker) && isempty (fmt.linestyle))
diff --git a/scripts/plot/private/__fltk_print__.m b/scripts/plot/private/__fltk_print__.m
--- a/scripts/plot/private/__fltk_print__.m
+++ b/scripts/plot/private/__fltk_print__.m
@@ -37,17 +37,17 @@ function opts = __fltk_print__ (opts)
   endif
 
   gl2ps_device = {};
   pipeline = {};
   switch (lower (opts.devopt))
     case {"eps", "eps2", "epsc", "epsc2"}
       ## format GL2PS_EPS
       gl2ps_device = {"eps"};
-      ## FIXME - use epstool to tighten bbox and provide preview.
+      ## FIXME: use epstool to tighten bbox and provide preview.
       pipeline = {opts.epstool_cmd(opts, "-", opts.name)};
     case {"epslatex", "pslatex", "pdflatex", "epslatexstandalone", ...
           "pslatexstandalone", "pdflatexstandalone"}
       ## format GL2PS_TEX
       n = find (opts.devopt == "l", 1);
       suffix = opts.devopt(1:n-1);
       dot = find (opts.name == ".", 1, "last");
       if ((! isempty (dot))
@@ -62,17 +62,17 @@ function opts = __fltk_print__ (opts)
       else
         error ("print:invalid-suffix", 
                "invalid suffix '%s' for device '%s'.",
                opts.name(dot:end), lower (opts.devopt));
       endif
       gl2ps_device = {sprintf("%snotxt", lower (suffix))};
       gl2ps_device{2} = "tex";
       if (dos_shell)
-        ## FIXME - this will only work on MinGW with the MSYS shell
+        ## FIXME: this will only work on MinGW with the MSYS shell
         pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
         pipeline{2} = sprintf ("cat > %s.tex", name);
       else
         pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
         pipeline{2} = sprintf ("cat > %s.tex", name);
       endif
     case "tikz"
       ## format GL2PS_PGF
diff --git a/scripts/plot/private/__gnuplot_get_var__.m b/scripts/plot/private/__gnuplot_get_var__.m
--- a/scripts/plot/private/__gnuplot_get_var__.m
+++ b/scripts/plot/private/__gnuplot_get_var__.m
@@ -21,20 +21,16 @@
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2009-02-07
 
 function gp_var_value = __gnuplot_get_var__ (h, gp_var_name, fmt = "")
 
-  if (nargin < 2)
-    print_usage ();
-  endif
-
   if (numel (h) == 1 && isfigure (h))
     if (isempty (get (gcf, "__plot_stream__")))
       ostream = __gnuplot_open_stream__ (2, h);
     else
       ostream = get (h, "__plot_stream__");
     endif
   else
     ostream = h;
@@ -51,17 +47,17 @@ function gp_var_value = __gnuplot_get_va
   else
     use_mkfifo = true;
     ostream = ostream(1);
   endif
 
   if (use_mkfifo)
     gpin_name = tmpnam ();
 
-    ## Mode: 6*8*8 ==  0600
+    ## Mode: 0600 == 6*8*8
     [err, msg] = mkfifo (gpin_name, 6*8*8);
 
     if (err)
       error ("__gnuplot_get_var__: Can not make FIFO (%s)", msg);
     endif
   endif
 
   gp_var_name = strtrim (gp_var_name);
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -21,1740 +21,1734 @@
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function __go_draw_axes__ (h, plot_stream, enhanced, mono,
                            bg_is_set, fg_is_set, hlgnd)
 
-  if (nargin >= 4 && nargin <= 7)
+  showhiddenhandles = get (0, "showhiddenhandles");
+  unwind_protect
+    set (0, "showhiddenhandles", "on");
+    axis_obj = __get__ (h);
+  unwind_protect_cleanup
+    set (0, "showhiddenhandles", showhiddenhandles);
+  end_unwind_protect
+
+  parent_figure_obj = get (axis_obj.parent);
+  gnuplot_term = __gnuplot_get_var__ (axis_obj.parent, "GPVAL_TERM");
+
+  ## Set to false for plotyy axes.
+  ymirror = true;
+  if (isfield (axis_obj, "__plotyy_axes__"))
+    if (all (ishandle (axis_obj.__plotyy_axes__)))
+      ymirror = false;
+    else
+      h = axis_obj.__plotyy_axes__;
+      h = h(ishandle (h));
+      h = h(isprop (h, "__plotyy_axes__"));
+      rmappdata (h, "__plotyy_axes__");
+    endif
+  endif
+
+  nd = __calc_dimensions__ (h);
+
+  if (strcmp (axis_obj.dataaspectratiomode, "manual")
+      && strcmp (axis_obj.xlimmode, "manual")
+      && strcmp (axis_obj.ylimmode, "manual"))
+    ## All can't be "manual"
+    axis_obj.plotboxaspectratiomode = "auto";
+  endif
 
-    showhiddenhandles = get (0, "showhiddenhandles");
-    unwind_protect
-      set (0, "showhiddenhandles", "on");
-      axis_obj = __get__ (h);
-    unwind_protect_cleanup
-      set (0, "showhiddenhandles", showhiddenhandles);
-    end_unwind_protect
+  if (strcmp (axis_obj.dataaspectratiomode, "manual")
+      && strcmp (axis_obj.xlimmode, "manual")
+      && strcmp (axis_obj.ylimmode, "manual")
+      && (nd == 2 || all (mod (axis_obj.view, 90) == 0)))
+    ## FIXME - adjust plotboxaspectratio to respect other
+    fpos = get (axis_obj.parent, "position");
+    apos = axis_obj.position;
+  endif
+
+  pos = __actual_axis_position__ (h);
+
+  if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
+    dr = axis_obj.dataaspectratio;
+    if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
+      dr = dr(1) / dr(2);
+    else
+      ## FIXME - need to properly implement 3D
+      dr = mean (dr(1:2)) / dr(3);
+    endif
+  else
+    dr = 1;
+  endif
+
+  if (strcmp (axis_obj.activepositionproperty, "position"))
+    if (__gnuplot_has_feature__ ("screen_coordinates_for_{lrtb}margin"))
+      if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
+        x = [1, 1];
+      else
+        ## 3D plots need to be sized down to fit in the window.
+        x = 1.0 ./ sqrt ([2, 2.5]);
+      endif
+      fprintf (plot_stream, "set tmargin screen %.15g;\n",
+               pos(2)+pos(4)/2+x(2)*pos(4)/2);
+      fprintf (plot_stream, "set bmargin screen %.15g;\n",
+               pos(2)+pos(4)/2-x(2)*pos(4)/2);
+      fprintf (plot_stream, "set lmargin screen %.15g;\n",
+               pos(1)+pos(3)/2-x(1)*pos(3)/2);
+      fprintf (plot_stream, "set rmargin screen %.15g;\n",
+               pos(1)+pos(3)/2+x(1)*pos(3)/2);
+      sz_str = "";
+    else
+      fprintf (plot_stream, "set tmargin 0;\n");
+      fprintf (plot_stream, "set bmargin 0;\n");
+      fprintf (plot_stream, "set lmargin 0;\n");
+      fprintf (plot_stream, "set rmargin 0;\n");
 
-    parent_figure_obj = get (axis_obj.parent);
-    gnuplot_term = __gnuplot_get_var__ (axis_obj.parent, "GPVAL_TERM");
+      if (nd == 3 && all (axis_obj.view == [0, 90]))
+        ## FIXME -- Kludge to allow colorbar to be added to a pcolor() plot
+        pos(3:4) = pos(3:4) * 1.4;
+        pos(1:2) = pos(1:2) - pos(3:4) * 0.125;
+      endif
+
+      fprintf (plot_stream, "set origin %.15g, %.15g;\n", pos(1), pos(2));
+
+      if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
+        sz_str = sprintf ("set size ratio %.15g", -dr);
+      else
+        sz_str = "set size noratio";
+      endif
+      sz_str = sprintf ("%s %.15g, %.15g;\n", sz_str, pos(3), pos(4));
+    endif
+  else ## activepositionproperty == outerposition
+    fprintf (plot_stream, "unset tmargin;\n");
+    fprintf (plot_stream, "unset bmargin;\n");
+    fprintf (plot_stream, "unset lmargin;\n");
+    fprintf (plot_stream, "unset rmargin;\n");
+    fprintf (plot_stream, "set origin %g, %g;\n", pos(1:2));
+    sz_str = "";
+    if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
+      sz_str = sprintf ("ratio %g", -dr);
+    else
+      sz_str = "noratio";
+    endif
+    sz_str = sprintf ("set size %s %g, %g;\n", sz_str, pos(3:4));
+  endif
+  if (! isempty (sz_str))
+    fputs (plot_stream, sz_str);
+  endif
 
-    ## Set to false for plotyy axes.
-    ymirror = true;
-    if (isfield (axis_obj, "__plotyy_axes__"))
-      if (all (ishandle (axis_obj.__plotyy_axes__)))
-        ymirror = false;
+  ## Reset all labels, axis-labels, tick-labels, and title
+  ## FIXME - We should have an function to initialize the axis.
+  ##         Presently, this is dispersed in this function.
+  fputs (plot_stream, "unset label;\n");
+  fputs (plot_stream, "unset xtics;\n");
+  fputs (plot_stream, "unset ytics;\n");
+  fputs (plot_stream, "unset ztics;\n");
+  fputs (plot_stream, "unset x2tics;\n");
+  fputs (plot_stream, "unset x2tics;\n");
+
+  if (! isempty (axis_obj.title))
+    t = get (axis_obj.title);
+    if (isempty (t.string))
+      fputs (plot_stream, "unset title;\n");
+    else
+      [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
+      fontspec = create_fontspec (f, s, gnuplot_term);
+      fprintf (plot_stream, "set title \"%s\" %s %s;\n",
+               undo_string_escapes (tt), fontspec,
+               __do_enhanced_option__ (enhanced, t));
+    endif
+  endif
+
+  if (! isempty (axis_obj.xlabel))
+    t = get (axis_obj.xlabel);
+    angle = t.rotation;
+    colorspec = get_text_colorspec (axis_obj.xcolor, mono);
+    if (isempty (t.string))
+      fprintf (plot_stream, "unset xlabel;\n");
+      fprintf (plot_stream, "unset x2label;\n");
+    else
+      [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
+      fontspec = create_fontspec (f, s, gnuplot_term);
+      if (strcmpi (axis_obj.xaxislocation, "top"))
+        fprintf (plot_stream, "set x2label \"%s\" %s %s %s",
+                 undo_string_escapes (tt), colorspec, fontspec,
+                 __do_enhanced_option__ (enhanced, t));
       else
-        h = axis_obj.__plotyy_axes__;
-        h = h(ishandle (h));
-        h = h(isprop (h, "__plotyy_axes__"));
-        rmappdata (h, "__plotyy_axes__");
+        fprintf (plot_stream, "set xlabel \"%s\" %s %s %s",
+                 undo_string_escapes (tt), colorspec, fontspec,
+                 __do_enhanced_option__ (enhanced, t));
+      endif
+      fprintf (plot_stream, " rotate by %f;\n", angle);
+      if (strcmpi (axis_obj.xaxislocation, "top"))
+        fprintf (plot_stream, "unset xlabel;\n");
+      else
+        fprintf (plot_stream, "unset x2label;\n");
       endif
     endif
-
-    nd = __calc_dimensions__ (h);
-
-    if (strcmp (axis_obj.dataaspectratiomode, "manual")
-        && strcmp (axis_obj.xlimmode, "manual")
-        && strcmp (axis_obj.ylimmode, "manual"))
-      ## All can't be "manual"
-      axis_obj.plotboxaspectratiomode = "auto";
-    endif
-
-    if (strcmp (axis_obj.dataaspectratiomode, "manual")
-        && strcmp (axis_obj.xlimmode, "manual")
-        && strcmp (axis_obj.ylimmode, "manual")
-        && (nd == 2 || all (mod (axis_obj.view, 90) == 0)))
-      ## FIXME - adjust plotboxaspectratio to respect other
-      fpos = get (axis_obj.parent, "position");
-      apos = axis_obj.position;
-    endif
-
-    pos = __actual_axis_position__ (h);
+  endif
 
-    if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
-      dr = axis_obj.dataaspectratio;
-      if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
-        dr = dr(1) / dr(2);
-      else
-        ## FIXME - need to properly implement 3D
-        dr = mean (dr(1:2)) / dr(3);
-      endif
+  if (! isempty (axis_obj.ylabel))
+    t = get (axis_obj.ylabel);
+    angle = t.rotation;
+    colorspec = get_text_colorspec (axis_obj.ycolor, mono);
+    if (isempty (t.string))
+      fprintf (plot_stream, "unset ylabel;\n");
+      fprintf (plot_stream, "unset y2label;\n");
     else
-      dr = 1;
-    endif
-
-    if (strcmp (axis_obj.activepositionproperty, "position"))
-      if (__gnuplot_has_feature__ ("screen_coordinates_for_{lrtb}margin"))
-        if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
-          x = [1, 1];
-        else
-          ## 3D plots need to be sized down to fit in the window.
-          x = 1.0 ./ sqrt ([2, 2.5]);
-        endif
-        fprintf (plot_stream, "set tmargin screen %.15g;\n",
-                 pos(2)+pos(4)/2+x(2)*pos(4)/2);
-        fprintf (plot_stream, "set bmargin screen %.15g;\n",
-                 pos(2)+pos(4)/2-x(2)*pos(4)/2);
-        fprintf (plot_stream, "set lmargin screen %.15g;\n",
-                 pos(1)+pos(3)/2-x(1)*pos(3)/2);
-        fprintf (plot_stream, "set rmargin screen %.15g;\n",
-                 pos(1)+pos(3)/2+x(1)*pos(3)/2);
-        sz_str = "";
+      [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
+      fontspec = create_fontspec (f, s, gnuplot_term);
+      if (strcmpi (axis_obj.yaxislocation, "right"))
+        fprintf (plot_stream, "set y2label \"%s\" %s %s %s",
+                 undo_string_escapes (tt), colorspec, fontspec,
+                 __do_enhanced_option__ (enhanced, t));
       else
-        fprintf (plot_stream, "set tmargin 0;\n");
-        fprintf (plot_stream, "set bmargin 0;\n");
-        fprintf (plot_stream, "set lmargin 0;\n");
-        fprintf (plot_stream, "set rmargin 0;\n");
-
-        if (nd == 3 && all (axis_obj.view == [0, 90]))
-          ## FIXME -- Kludge to allow colorbar to be added to a pcolor() plot
-          pos(3:4) = pos(3:4) * 1.4;
-          pos(1:2) = pos(1:2) - pos(3:4) * 0.125;
-        endif
-
-        fprintf (plot_stream, "set origin %.15g, %.15g;\n", pos(1), pos(2));
-
-        if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
-          sz_str = sprintf ("set size ratio %.15g", -dr);
-        else
-          sz_str = "set size noratio";
-        endif
-        sz_str = sprintf ("%s %.15g, %.15g;\n", sz_str, pos(3), pos(4));
-      endif
-    else ## activepositionproperty == outerposition
-      fprintf (plot_stream, "unset tmargin;\n");
-      fprintf (plot_stream, "unset bmargin;\n");
-      fprintf (plot_stream, "unset lmargin;\n");
-      fprintf (plot_stream, "unset rmargin;\n");
-      fprintf (plot_stream, "set origin %g, %g;\n", pos(1:2));
-      sz_str = "";
-      if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
-        sz_str = sprintf ("ratio %g", -dr);
-      else
-        sz_str = "noratio";
-      endif
-      sz_str = sprintf ("set size %s %g, %g;\n", sz_str, pos(3:4));
-    endif
-    if (! isempty (sz_str))
-      fputs (plot_stream, sz_str);
-    endif
-
-    ## Reset all labels, axis-labels, tick-labels, and title
-    ## FIXME - We should have an function to initialize the axis.
-    ##         Presently, this is dispersed in this function.
-    fputs (plot_stream, "unset label;\n");
-    fputs (plot_stream, "unset xtics;\n");
-    fputs (plot_stream, "unset ytics;\n");
-    fputs (plot_stream, "unset ztics;\n");
-    fputs (plot_stream, "unset x2tics;\n");
-    fputs (plot_stream, "unset x2tics;\n");
-
-    if (! isempty (axis_obj.title))
-      t = get (axis_obj.title);
-      if (isempty (t.string))
-        fputs (plot_stream, "unset title;\n");
-      else
-        [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
-        fontspec = create_fontspec (f, s, gnuplot_term);
-        fprintf (plot_stream, "set title \"%s\" %s %s;\n",
-                 undo_string_escapes (tt), fontspec,
+        fprintf (plot_stream, "set ylabel \"%s\" %s %s %s",
+                 undo_string_escapes (tt), colorspec, fontspec,
                  __do_enhanced_option__ (enhanced, t));
       endif
-    endif
-
-    if (! isempty (axis_obj.xlabel))
-      t = get (axis_obj.xlabel);
-      angle = t.rotation;
-      colorspec = get_text_colorspec (axis_obj.xcolor, mono);
-      if (isempty (t.string))
-        fprintf (plot_stream, "unset xlabel;\n");
-        fprintf (plot_stream, "unset x2label;\n");
+      fprintf (plot_stream, " rotate by %f;\n", angle);
+      if (strcmpi (axis_obj.yaxislocation, "right"))
+        fprintf (plot_stream, "unset ylabel;\n");
       else
-        [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
-        fontspec = create_fontspec (f, s, gnuplot_term);
-        if (strcmpi (axis_obj.xaxislocation, "top"))
-          fprintf (plot_stream, "set x2label \"%s\" %s %s %s",
-                   undo_string_escapes (tt), colorspec, fontspec,
-                   __do_enhanced_option__ (enhanced, t));
-        else
-          fprintf (plot_stream, "set xlabel \"%s\" %s %s %s",
-                   undo_string_escapes (tt), colorspec, fontspec,
-                   __do_enhanced_option__ (enhanced, t));
-        endif
-        fprintf (plot_stream, " rotate by %f;\n", angle);
-        if (strcmpi (axis_obj.xaxislocation, "top"))
-          fprintf (plot_stream, "unset xlabel;\n");
-        else
-          fprintf (plot_stream, "unset x2label;\n");
-        endif
+        fprintf (plot_stream, "unset y2label;\n");
       endif
     endif
+  endif
 
-    if (! isempty (axis_obj.ylabel))
-      t = get (axis_obj.ylabel);
-      angle = t.rotation;
-      colorspec = get_text_colorspec (axis_obj.ycolor, mono);
-      if (isempty (t.string))
-        fprintf (plot_stream, "unset ylabel;\n");
-        fprintf (plot_stream, "unset y2label;\n");
-      else
-        [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
-        fontspec = create_fontspec (f, s, gnuplot_term);
-        if (strcmpi (axis_obj.yaxislocation, "right"))
-          fprintf (plot_stream, "set y2label \"%s\" %s %s %s",
-                   undo_string_escapes (tt), colorspec, fontspec,
-                   __do_enhanced_option__ (enhanced, t));
-        else
-          fprintf (plot_stream, "set ylabel \"%s\" %s %s %s",
-                   undo_string_escapes (tt), colorspec, fontspec,
-                   __do_enhanced_option__ (enhanced, t));
-        endif
-        fprintf (plot_stream, " rotate by %f;\n", angle);
-        if (strcmpi (axis_obj.yaxislocation, "right"))
-          fprintf (plot_stream, "unset ylabel;\n");
-        else
-          fprintf (plot_stream, "unset y2label;\n");
-        endif
-      endif
-    endif
-
-    if (! isempty (axis_obj.zlabel))
-      t = get (axis_obj.zlabel);
-      angle = t.rotation;
-      colorspec = get_text_colorspec (axis_obj.zcolor, mono);
-      if (isempty (t.string))
-        fputs (plot_stream, "unset zlabel;\n");
-      else
-        [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
-        fontspec = create_fontspec (f, s, gnuplot_term);
-        fprintf (plot_stream, "set zlabel \"%s\" %s %s %s",
-                 undo_string_escapes (tt), colorspec, fontspec,
-                 __do_enhanced_option__ (enhanced, t));
-        fprintf (plot_stream, " rotate by %f;\n", angle);
-      endif
-    endif
-
-    if (strcmpi (axis_obj.xaxislocation, "top"))
-      xaxisloc = "x2";
-      xaxisloc_using = "x2";
+  if (! isempty (axis_obj.zlabel))
+    t = get (axis_obj.zlabel);
+    angle = t.rotation;
+    colorspec = get_text_colorspec (axis_obj.zcolor, mono);
+    if (isempty (t.string))
+      fputs (plot_stream, "unset zlabel;\n");
     else
-      xaxisloc = "x";
-      xaxisloc_using = "x1";
-      if (strcmpi (axis_obj.xaxislocation, "zero"))
-        fputs (plot_stream, "set xzeroaxis;\n");
-      endif
+      [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
+      fontspec = create_fontspec (f, s, gnuplot_term);
+      fprintf (plot_stream, "set zlabel \"%s\" %s %s %s",
+               undo_string_escapes (tt), colorspec, fontspec,
+               __do_enhanced_option__ (enhanced, t));
+      fprintf (plot_stream, " rotate by %f;\n", angle);
+    endif
+  endif
+
+  if (strcmpi (axis_obj.xaxislocation, "top"))
+    xaxisloc = "x2";
+    xaxisloc_using = "x2";
+  else
+    xaxisloc = "x";
+    xaxisloc_using = "x1";
+    if (strcmpi (axis_obj.xaxislocation, "zero"))
+      fputs (plot_stream, "set xzeroaxis;\n");
     endif
-    if (strcmpi (axis_obj.yaxislocation, "right"))
-      yaxisloc = "y2";
-      yaxisloc_using = "y2";
-    else
-      yaxisloc = "y";
-      yaxisloc_using = "y1";
-      if (strcmpi (axis_obj.yaxislocation, "zero"))
-        fputs (plot_stream, "set yzeroaxis;\n");
-      endif
+  endif
+  if (strcmpi (axis_obj.yaxislocation, "right"))
+    yaxisloc = "y2";
+    yaxisloc_using = "y2";
+  else
+    yaxisloc = "y";
+    yaxisloc_using = "y1";
+    if (strcmpi (axis_obj.yaxislocation, "zero"))
+      fputs (plot_stream, "set yzeroaxis;\n");
     endif
+  endif
 
-    have_grid = false;
+  have_grid = false;
+
+  if (strcmpi (axis_obj.xgrid, "on"))
+    have_grid = true;
+    fprintf (plot_stream, "set grid %stics;\n", xaxisloc);
+  else
+    fprintf (plot_stream, "set grid no%stics;\n", xaxisloc);
+  endif
 
-    if (strcmpi (axis_obj.xgrid, "on"))
-      have_grid = true;
-      fprintf (plot_stream, "set grid %stics;\n", xaxisloc);
-    else
-      fprintf (plot_stream, "set grid no%stics;\n", xaxisloc);
-    endif
+  if (strcmpi (axis_obj.ygrid, "on"))
+    have_grid = true;
+    fprintf (plot_stream, "set grid %stics;\n", yaxisloc);
+  else
+    fprintf (plot_stream, "set grid no%stics;\n", yaxisloc);
+  endif
+
+  if (strcmpi (axis_obj.zgrid, "on"))
+    have_grid = true;
+    fputs (plot_stream, "set grid ztics;\n");
+  else
+    fputs (plot_stream, "set grid noztics;\n");
+  endif
 
-    if (strcmpi (axis_obj.ygrid, "on"))
-      have_grid = true;
-      fprintf (plot_stream, "set grid %stics;\n", yaxisloc);
+  if (strcmpi (axis_obj.xminorgrid, "on"))
+    have_grid = true;
+    if (strcmp (axis_obj.xscale, "log"))
+      m = 10;
     else
-      fprintf (plot_stream, "set grid no%stics;\n", yaxisloc);
+      m = 5;
     endif
+    fprintf (plot_stream, "set m%stics %d;\n", xaxisloc, m);
+    fprintf (plot_stream, "set grid m%stics;\n", xaxisloc);
+  else
+    fprintf (plot_stream, "set grid nom%stics;\n", xaxisloc);
+  endif
 
-    if (strcmpi (axis_obj.zgrid, "on"))
-      have_grid = true;
-      fputs (plot_stream, "set grid ztics;\n");
+  if (strcmpi (axis_obj.yminorgrid, "on"))
+    have_grid = true;
+    if (strcmp (axis_obj.yscale, "log"))
+      m = 10;
     else
-      fputs (plot_stream, "set grid noztics;\n");
+      m = 5;
     endif
+    fprintf (plot_stream, "set m%stics %d;\n", yaxisloc, m);
+    fprintf (plot_stream, "set grid m%stics;\n", yaxisloc);
+  else
+    fprintf (plot_stream, "set grid nom%stics;\n", yaxisloc);
+  endif
 
-    if (strcmpi (axis_obj.xminorgrid, "on"))
-      have_grid = true;
-      if (strcmp (axis_obj.xscale, "log"))
-        m = 10;
-      else
-        m = 5;
-      endif
-      fprintf (plot_stream, "set m%stics %d;\n", xaxisloc, m);
-      fprintf (plot_stream, "set grid m%stics;\n", xaxisloc);
+  if (strcmpi (axis_obj.zminorgrid, "on"))
+    have_grid = true;
+    if (strcmp (axis_obj.zscale, "log"))
+      m = 10;
     else
-      fprintf (plot_stream, "set grid nom%stics;\n", xaxisloc);
+      m = 5;
     endif
+    fprintf (plot_stream, "set mztics %d;\n", m);
+    fputs (plot_stream, "set grid mztics;\n");
+  else
+    fputs (plot_stream, "set grid nomztics;\n");
+  endif
+
+  ## The grid front/back/layerdefault option also controls the
+  ## appearance of tics, so it is used even if the grid is absent.
+  if (strcmpi (axis_obj.layer, "top"))
+    fputs (plot_stream, "set grid front;\n");
+    fputs (plot_stream, "set border front;\n");
+  else
+    fputs (plot_stream, "set grid layerdefault;\n");
+    ## FIXME -- the gnuplot help says that "layerdefault" should work
+    ## for set border too, but it fails for me with gnuplot 4.2.5.  So
+    ## use "back" instead.
+    fputs (plot_stream, "set border back;\n");
+  endif
+
+  fprintf (plot_stream, "set grid linewidth %f, linewidth %f;\n",
+           axis_obj.linewidth, axis_obj.linewidth);
+
+  if (! have_grid)
+    fputs (plot_stream, "unset grid;\n");
+  endif
 
-    if (strcmpi (axis_obj.yminorgrid, "on"))
-      have_grid = true;
-      if (strcmp (axis_obj.yscale, "log"))
-        m = 10;
-      else
-        m = 5;
-      endif
-      fprintf (plot_stream, "set m%stics %d;\n", yaxisloc, m);
-      fprintf (plot_stream, "set grid m%stics;\n", yaxisloc);
-    else
-      fprintf (plot_stream, "set grid nom%stics;\n", yaxisloc);
+  xlogscale = strcmpi (axis_obj.xscale, "log");
+  ylogscale = strcmpi (axis_obj.yscale, "log");
+  zlogscale = strcmpi (axis_obj.zscale, "log");
+
+  ## Detect logscale and negative lims
+  if (xlogscale && all (axis_obj.xlim < 0))
+    axis_obj.xsgn = -1;
+    if (strcmp (axis_obj.xdir, "reverse"))
+      axis_obj.xdir = "normal";
+    elseif (strcmp (axis_obj.xdir, "normal"))
+      axis_obj.xdir = "reverse";
     endif
-
-    if (strcmpi (axis_obj.zminorgrid, "on"))
-      have_grid = true;
-      if (strcmp (axis_obj.zscale, "log"))
-        m = 10;
-      else
-        m = 5;
-      endif
-      fprintf (plot_stream, "set mztics %d;\n", m);
-      fputs (plot_stream, "set grid mztics;\n");
-    else
-      fputs (plot_stream, "set grid nomztics;\n");
+    axis_obj.xtick = -flip (axis_obj.xtick);
+    axis_obj.xticklabel = flip (axis_obj.xticklabel);
+    axis_obj.xlim = -flip (axis_obj.xlim);
+  else
+    axis_obj.xsgn = 1;
+  endif
+  if (ylogscale && all (axis_obj.ylim < 0))
+    axis_obj.ysgn = -1;
+    if (strcmp (axis_obj.ydir, "reverse"))
+      axis_obj.ydir = "normal";
+    elseif (strcmp (axis_obj.ydir, "normal"))
+      axis_obj.ydir = "reverse";
     endif
+    axis_obj.ytick = -flip (axis_obj.ytick);
+    axis_obj.yticklabel = flip (axis_obj.yticklabel);
+    axis_obj.ylim = -flip (axis_obj.ylim);
+  else
+    axis_obj.ysgn = 1;
+  endif
+  if (zlogscale && all (axis_obj.zlim < 0))
+    axis_obj.zsgn = -1;
+    if (strcmp (axis_obj.zdir, "reverse"))
+      axis_obj.zdir = "normal";
+    elseif (strcmp (axis_obj.zdir, "normal"))
+      axis_obj.zdir = "reverse";
+    endif
+    axis_obj.ztick = -flip (axis_obj.ztick);
+    axis_obj.zticklabel = flip (axis_obj.zticklabel);
+    axis_obj.zlim = -flip (axis_obj.zlim);
+  else
+    axis_obj.zsgn = 1;
+  endif
 
-    ## The grid front/back/layerdefault option also controls the
-    ## appearance of tics, so it is used even if the grid is absent.
-    if (strcmpi (axis_obj.layer, "top"))
-      fputs (plot_stream, "set grid front;\n");
-      fputs (plot_stream, "set border front;\n");
-    else
-      fputs (plot_stream, "set grid layerdefault;\n");
-      ## FIXME -- the gnuplot help says that "layerdefault" should work
-      ## for set border too, but it fails for me with gnuplot 4.2.5.  So
-      ## use "back" instead.
-      fputs (plot_stream, "set border back;\n");
-    endif
+  xlim = axis_obj.xlim;
+  ylim = axis_obj.ylim;
+  zlim = axis_obj.zlim;
+  clim = axis_obj.clim;
+
+  do_tics (axis_obj, plot_stream, ymirror, mono, gnuplot_term);
 
-    fprintf (plot_stream, "set grid linewidth %f, linewidth %f;\n",
-             axis_obj.linewidth, axis_obj.linewidth);
-
-    if (! have_grid)
-      fputs (plot_stream, "unset grid;\n");
-    endif
-
-    xlogscale = strcmpi (axis_obj.xscale, "log");
-    ylogscale = strcmpi (axis_obj.yscale, "log");
-    zlogscale = strcmpi (axis_obj.zscale, "log");
+  fputs (plot_stream, "unset logscale;\n");
+  if (xlogscale)
+    fprintf (plot_stream, "set logscale %s;\n", xaxisloc);
+  endif
+  if (ylogscale)
+    fprintf (plot_stream, "set logscale %s;\n", yaxisloc);
+  endif
+  if (zlogscale)
+    fputs (plot_stream, "set logscale z;\n");
+  endif
 
-    ## Detect logscale and negative lims
-    if (xlogscale && all (axis_obj.xlim < 0))
-      axis_obj.xsgn = -1;
-      if (strcmp (axis_obj.xdir, "reverse"))
-        axis_obj.xdir = "normal";
-      elseif (strcmp (axis_obj.xdir, "normal"))
-        axis_obj.xdir = "reverse";
-      endif
-      axis_obj.xtick = -flip (axis_obj.xtick);
-      axis_obj.xticklabel = flip (axis_obj.xticklabel);
-      axis_obj.xlim = -flip (axis_obj.xlim);
-    else
-      axis_obj.xsgn = 1;
-    endif
-    if (ylogscale && all (axis_obj.ylim < 0))
-      axis_obj.ysgn = -1;
-      if (strcmp (axis_obj.ydir, "reverse"))
-        axis_obj.ydir = "normal";
-      elseif (strcmp (axis_obj.ydir, "normal"))
-        axis_obj.ydir = "reverse";
-      endif
-      axis_obj.ytick = -flip (axis_obj.ytick);
-      axis_obj.yticklabel = flip (axis_obj.yticklabel);
-      axis_obj.ylim = -flip (axis_obj.ylim);
-    else
-      axis_obj.ysgn = 1;
+  xautoscale = strcmpi (axis_obj.xlimmode, "auto");
+  yautoscale = strcmpi (axis_obj.ylimmode, "auto");
+  zautoscale = strcmpi (axis_obj.zlimmode, "auto");
+  cautoscale = strcmpi (axis_obj.climmode, "auto");
+  cdatadirect = false;
+  truecolor = false;
+
+  fputs (plot_stream, "set clip two;\n");
+
+  kids = axis_obj.children;
+  ## Remove the axis labels and title from the children, and
+  ## preserved the original order.
+  [jnk, k] = setdiff (kids, [axis_obj.xlabel; axis_obj.ylabel; ...
+                             axis_obj.zlabel; axis_obj.title]);
+  kids = kids (sort (k));
+
+  if (nd == 3)
+    fputs (plot_stream, "set parametric;\n");
+    fputs (plot_stream, "set style data lines;\n");
+    fputs (plot_stream, "set surface;\n");
+    fputs (plot_stream, "unset contour;\n");
+  endif
+
+  data_idx = 0;
+  data = cell ();
+  is_image_data = [];
+  hidden_removal = NaN;
+  view_map = false;
+
+  if (! cautoscale && clim(1) == clim(2))
+    clim(2)++;
+  endif
+  addedcmap = [];
+
+  ximg_data = {};
+  ximg_data_idx = 0;
+
+  while (! isempty (kids))
+
+    obj = get (kids(end));
+
+    if (isfield (obj, "xdata"))
+      obj.xdata = double (obj.xdata);
+    end
+    if (isfield (obj, "ydata"))
+      obj.ydata = double (obj.ydata);
+    end
+    if (isfield (obj, "zdata"))
+      obj.zdata = double (obj.zdata);
+    end
+
+    if (isfield (obj, "units"))
+      units = obj.units;
+      unwind_protect
+        set (kids(end), "units", "data");
+        obj = get (kids(end));
+      unwind_protect_cleanup
+        set (kids(end), "units", units);
+      end_unwind_protect
     endif
-    if (zlogscale && all (axis_obj.zlim < 0))
-      axis_obj.zsgn = -1;
-      if (strcmp (axis_obj.zdir, "reverse"))
-        axis_obj.zdir = "normal";
-      elseif (strcmp (axis_obj.zdir, "normal"))
-        axis_obj.zdir = "reverse";
-      endif
-      axis_obj.ztick = -flip (axis_obj.ztick);
-      axis_obj.zticklabel = flip (axis_obj.zticklabel);
-      axis_obj.zlim = -flip (axis_obj.zlim);
-    else
-      axis_obj.zsgn = 1;
-    endif
+    kids = kids(1:(end-1));
 
-    xlim = axis_obj.xlim;
-    ylim = axis_obj.ylim;
-    zlim = axis_obj.zlim;
-    clim = axis_obj.clim;
-
-    do_tics (axis_obj, plot_stream, ymirror, mono, gnuplot_term);
-
-    fputs (plot_stream, "unset logscale;\n");
-    if (xlogscale)
-      fprintf (plot_stream, "set logscale %s;\n", xaxisloc);
-    endif
-    if (ylogscale)
-      fprintf (plot_stream, "set logscale %s;\n", yaxisloc);
-    endif
-    if (zlogscale)
-      fputs (plot_stream, "set logscale z;\n");
+    if (strcmp (obj.visible, "off"))
+      continue;
     endif
 
-    xautoscale = strcmpi (axis_obj.xlimmode, "auto");
-    yautoscale = strcmpi (axis_obj.ylimmode, "auto");
-    zautoscale = strcmpi (axis_obj.zlimmode, "auto");
-    cautoscale = strcmpi (axis_obj.climmode, "auto");
-    cdatadirect = false;
-    truecolor = false;
-
-    fputs (plot_stream, "set clip two;\n");
-
-    kids = axis_obj.children;
-    ## Remove the axis labels and title from the children, and
-    ## preserved the original order.
-    [jnk, k] = setdiff (kids, [axis_obj.xlabel; axis_obj.ylabel; ...
-                               axis_obj.zlabel; axis_obj.title]);
-    kids = kids (sort (k));
-
-    if (nd == 3)
-      fputs (plot_stream, "set parametric;\n");
-      fputs (plot_stream, "set style data lines;\n");
-      fputs (plot_stream, "set surface;\n");
-      fputs (plot_stream, "unset contour;\n");
+    if (xlogscale && isfield (obj, "xdata"))
+      obj.xdata = axis_obj.xsgn * obj.xdata;
+      obj.xdata(obj.xdata<=0) = NaN;
+    endif
+    if (ylogscale && isfield (obj, "ydata"))
+      obj.ydata = axis_obj.ysgn * obj.ydata;
+      obj.ydata(obj.ydata<=0) = NaN;
+    endif
+    if (zlogscale && isfield (obj, "zdata"))
+      obj.zdata = axis_obj.zsgn * obj.zdata;
+      obj.zdata(obj.zdata<=0) = NaN;
     endif
 
-    data_idx = 0;
-    data = cell ();
-    is_image_data = [];
-    hidden_removal = NaN;
-    view_map = false;
+    ## Check for facecolor interpolation for surfaces.
+    doing_interp_color = ...
+       isfield (obj, "facecolor") && strncmp (obj.facecolor, "interp", 6);
 
-    if (! cautoscale && clim(1) == clim(2))
-      clim(2)++;
-    endif
-    addedcmap = [];
-
-    ximg_data = {};
-    ximg_data_idx = 0;
-
-    while (! isempty (kids))
-
-      obj = get (kids(end));
+    switch (obj.type)
+      case "image"
+        img_data = obj.cdata;
+        img_xdata = obj.xdata;
+        img_ydata = obj.ydata;
 
-      if (isfield (obj, "xdata"))
-        obj.xdata = double (obj.xdata);
-      end
-      if (isfield (obj, "ydata"))
-        obj.ydata = double (obj.ydata);
-      end
-      if (isfield (obj, "zdata"))
-        obj.zdata = double (obj.zdata);
-      end
+        if (ndims (img_data) == 3)
+          truecolor = true;
+        elseif (strcmpi (obj.cdatamapping, "direct"))
+          cdatadirect = true;
+        endif
+        data_idx++;
+        is_image_data(data_idx) = true;
+        parametric(data_idx) = false;
+        have_cdata(data_idx) = false;
+        have_3d_patch(data_idx) = false;
 
-      if (isfield (obj, "units"))
-        units = obj.units;
-        unwind_protect
-          set (kids(end), "units", "data");
-          obj = get (kids(end));
-        unwind_protect_cleanup
-          set (kids(end), "units", units);
-        end_unwind_protect
-      endif
-      kids = kids(1:(end-1));
-
-      if (strcmp (obj.visible, "off"))
-        continue;
-      endif
+        if (img_xdata(2) < img_xdata(1))
+          img_xdata = img_xdata(2:-1:1);
+          img_data = img_data(:,end:-1:1,:);
+        elseif (img_xdata(1) == img_xdata(2))
+          img_xdata = img_xdata(1) + [0, columns(img_data)-1];
+        endif
+        if (img_ydata(2) < img_ydata(1))
+          img_ydata = img_ydata(2:-1:1);
+          img_data = img_data(end:-1:1,:,:);
+        elseif (img_ydata(1) == img_ydata(2))
+          img_ydata = img_ydata(1) + [0, rows(img_data)-1];
+        endif
 
-      if (xlogscale && isfield (obj, "xdata"))
-        obj.xdata = axis_obj.xsgn * obj.xdata;
-        obj.xdata(obj.xdata<=0) = NaN;
-      endif
-      if (ylogscale && isfield (obj, "ydata"))
-        obj.ydata = axis_obj.ysgn * obj.ydata;
-        obj.ydata(obj.ydata<=0) = NaN;
-      endif
-      if (zlogscale && isfield (obj, "zdata"))
-        obj.zdata = axis_obj.zsgn * obj.zdata;
-        obj.zdata(obj.zdata<=0) = NaN;
-      endif
+        [y_dim, x_dim] = size (img_data(:,:,1));
+        if (x_dim > 1)
+          dx = abs (img_xdata(2)-img_xdata(1))/(x_dim-1);
+        else
+          x_dim = 2;
+          img_data = [img_data, img_data];
+          dx = abs (img_xdata(2)-img_xdata(1));
+        endif
+        if (y_dim > 1)
+          dy = abs (img_ydata(2)-img_ydata(1))/(y_dim-1);
+        else
+          y_dim = 2;
+          img_data = [img_data; img_data];
+          dy = abs (img_ydata(2)-img_ydata(1));
+        endif
 
-      ## Check for facecolor interpolation for surfaces.
-      doing_interp_color = ...
-         isfield (obj, "facecolor") && strncmp (obj.facecolor, "interp", 6);
+        x_origin = min (img_xdata);
+        y_origin = min (img_ydata);
 
-      switch (obj.type)
-        case "image"
-          img_data = obj.cdata;
-          img_xdata = obj.xdata;
-          img_ydata = obj.ydata;
+        if (ndims (img_data) == 3)
+          data{data_idx} = permute (img_data, [3, 1, 2])(:);
+          format = "1:2:3";
+          imagetype = "rgbimage";
+        else
+          data{data_idx} = img_data(:);
+          format = "1";
+          imagetype = "image";
+        endif
 
-          if (ndims (img_data) == 3)
-            truecolor = true;
-          elseif (strcmpi (obj.cdatamapping, "direct"))
-            cdatadirect = true;
-          endif
-          data_idx++;
-          is_image_data(data_idx) = true;
-          parametric(data_idx) = false;
-          have_cdata(data_idx) = false;
-          have_3d_patch(data_idx) = false;
+        titlespec{data_idx} = "title \"\"";
+        usingclause{data_idx} = sprintf ("binary array=%dx%d scan=yx origin=(%.15g,%.15g) dx=%.15g dy=%.15g using %s",
+            x_dim, y_dim, x_origin, y_origin, dx, dy, format);
+        withclause{data_idx} = sprintf ("with %s;", imagetype);
 
-          if (img_xdata(2) < img_xdata(1))
-            img_xdata = img_xdata(2:-1:1);
-            img_data = img_data(:,end:-1:1,:);
-          elseif (img_xdata(1) == img_xdata(2))
-            img_xdata = img_xdata(1) + [0, columns(img_data)-1];
-          endif
-          if (img_ydata(2) < img_ydata(1))
-            img_ydata = img_ydata(2:-1:1);
-            img_data = img_data(end:-1:1,:,:);
-          elseif (img_ydata(1) == img_ydata(2))
-            img_ydata = img_ydata(1) + [0, rows(img_data)-1];
-          endif
-
-          [y_dim, x_dim] = size (img_data(:,:,1));
-          if (x_dim > 1)
-            dx = abs (img_xdata(2)-img_xdata(1))/(x_dim-1);
-          else
-            x_dim = 2;
-            img_data = [img_data, img_data];
-            dx = abs (img_xdata(2)-img_xdata(1));
-          endif
-          if (y_dim > 1)
-            dy = abs (img_ydata(2)-img_ydata(1))/(y_dim-1);
+      case "line"
+        if (strncmp (obj.linestyle, "none", 4)
+            && (! isfield (obj, "marker")
+                || (isfield (obj, "marker")
+                    && strncmp (obj.marker, "none", 4))))
+          continue;
+        endif
+        data_idx++;
+        is_image_data(data_idx) = false;
+        parametric(data_idx) = true;
+        have_cdata(data_idx) = false;
+        have_3d_patch(data_idx) = false;
+        if (isempty (obj.displayname))
+          titlespec{data_idx} = "title \"\"";
+        else
+          tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
+          titlespec{data_idx} = ['title "' tmp '"'];
+        endif
+        usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
+        errbars = "";
+        if (nd == 3)
+          xdat = obj.xdata(:);
+          ydat = obj.ydata(:);
+          if (! isempty (obj.zdata))
+            zdat = obj.zdata(:);
           else
-            y_dim = 2;
-            img_data = [img_data; img_data];
-            dy = abs (img_ydata(2)-img_ydata(1));
-          endif
-
-          x_origin = min (img_xdata);
-          y_origin = min (img_ydata);
-
-          if (ndims (img_data) == 3)
-            data{data_idx} = permute (img_data, [3, 1, 2])(:);
-            format = "1:2:3";
-            imagetype = "rgbimage";
-          else
-            data{data_idx} = img_data(:);
-            format = "1";
-            imagetype = "image";
-          endif
-
-          titlespec{data_idx} = "title \"\"";
-          usingclause{data_idx} = sprintf ("binary array=%dx%d scan=yx origin=(%.15g,%.15g) dx=%.15g dy=%.15g using %s",
-              x_dim, y_dim, x_origin, y_origin, dx, dy, format);
-          withclause{data_idx} = sprintf ("with %s;", imagetype);
-
-        case "line"
-          if (strncmp (obj.linestyle, "none", 4)
-              && (! isfield (obj, "marker")
-                  || (isfield (obj, "marker")
-                      && strncmp (obj.marker, "none", 4))))
-            continue;
-          endif
-          data_idx++;
-          is_image_data(data_idx) = false;
-          parametric(data_idx) = true;
-          have_cdata(data_idx) = false;
-          have_3d_patch(data_idx) = false;
-          if (isempty (obj.displayname))
-            titlespec{data_idx} = "title \"\"";
-          else
-            tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
-            titlespec{data_idx} = ['title "' tmp '"'];
+            zdat = zeros (size (xdat));
           endif
-          usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
-          errbars = "";
-          if (nd == 3)
-            xdat = obj.xdata(:);
-            ydat = obj.ydata(:);
-            if (! isempty (obj.zdata))
-              zdat = obj.zdata(:);
-            else
-              zdat = zeros (size (xdat));
-            endif
-            data{data_idx} = [xdat, ydat, zdat]';
-            usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", numel (xdat));
-            ## fputs (plot_stream, "set parametric;\n");
-          else
-            xdat = obj.xdata(:);
-            ydat = obj.ydata(:);
-            data{data_idx} = [xdat, ydat]';
-            usingclause{data_idx} = sprintf ("record=%d using ($1):($2) axes %s%s",
-                                            rows (xdat), xaxisloc_using, yaxisloc_using);
-          endif
+          data{data_idx} = [xdat, ydat, zdat]';
+          usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", numel (xdat));
+          ## fputs (plot_stream, "set parametric;\n");
+        else
+          xdat = obj.xdata(:);
+          ydat = obj.ydata(:);
+          data{data_idx} = [xdat, ydat]';
+          usingclause{data_idx} = sprintf ("record=%d using ($1):($2) axes %s%s",
+                                          rows (xdat), xaxisloc_using, yaxisloc_using);
+        endif
 
-          style = do_linestyle_command (obj, obj.color, data_idx, mono,
-                                        plot_stream, errbars);
+        style = do_linestyle_command (obj, obj.color, data_idx, mono,
+                                      plot_stream, errbars);
 
-          withclause{data_idx} = sprintf ("with %s linestyle %d",
-                                          style{1}, data_idx);
+        withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                        style{1}, data_idx);
 
-          if (length (style) > 1)
-            data_idx++;
-            is_image_data(data_idx) = is_image_data(data_idx - 1);
-            parametric(data_idx) = parametric(data_idx - 1);
-            have_cdata(data_idx) = have_cdata(data_idx - 1);
-            have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-            titlespec{data_idx} = "title \"\"";
-            usingclause{data_idx} = usingclause{data_idx - 1};
-            data{data_idx} = data{data_idx - 1};
-            withclause{data_idx} = sprintf ("with %s linestyle %d",
-                                          style{2}, data_idx);
-          endif
-          if (length (style) > 2)
-            data_idx++;
-            is_image_data(data_idx) = is_image_data(data_idx - 1);
-            parametric(data_idx) = parametric(data_idx - 1);
-            have_cdata(data_idx) = have_cdata(data_idx - 1);
-            have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-            titlespec{data_idx} = "title \"\"";
-            usingclause{data_idx} = usingclause{data_idx - 1};
-            data{data_idx} = data{data_idx - 1};
-            withclause{data_idx} = sprintf ("with %s linestyle %d",
-                                          style{3}, data_idx);
-          endif
+        if (length (style) > 1)
+          data_idx++;
+          is_image_data(data_idx) = is_image_data(data_idx - 1);
+          parametric(data_idx) = parametric(data_idx - 1);
+          have_cdata(data_idx) = have_cdata(data_idx - 1);
+          have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+          titlespec{data_idx} = "title \"\"";
+          usingclause{data_idx} = usingclause{data_idx - 1};
+          data{data_idx} = data{data_idx - 1};
+          withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                        style{2}, data_idx);
+        endif
+        if (length (style) > 2)
+          data_idx++;
+          is_image_data(data_idx) = is_image_data(data_idx - 1);
+          parametric(data_idx) = parametric(data_idx - 1);
+          have_cdata(data_idx) = have_cdata(data_idx - 1);
+          have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+          titlespec{data_idx} = "title \"\"";
+          usingclause{data_idx} = usingclause{data_idx - 1};
+          data{data_idx} = data{data_idx - 1};
+          withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                        style{3}, data_idx);
+        endif
 
-       case "patch"
-         cmap = parent_figure_obj.colormap;
-         [nr, nc] = size (obj.xdata);
+     case "patch"
+       cmap = parent_figure_obj.colormap;
+       [nr, nc] = size (obj.xdata);
 
-         if (! isempty (obj.cdata))
-           cdat = obj.cdata;
-           if (strcmpi (obj.cdatamapping, "direct"))
-             cdatadirect = true;
+       if (! isempty (obj.cdata))
+         cdat = obj.cdata;
+         if (strcmpi (obj.cdatamapping, "direct"))
+           cdatadirect = true;
+         endif
+       else
+         cdat = [];
+       endif
+
+       data_3d_idx = NaN;
+       for i = 1:nc
+         xcol = obj.xdata(:,i);
+         ycol = obj.ydata(:,i);
+         if (nd == 3)
+           if (! isempty (obj.zdata))
+             zcol = obj.zdata(:,i);
+           else
+             zcol = zeros (size (xcol));
            endif
-         else
-           cdat = [];
          endif
 
-         data_3d_idx = NaN;
-         for i = 1:nc
-           xcol = obj.xdata(:,i);
-           ycol = obj.ydata(:,i);
-           if (nd == 3)
-             if (! isempty (obj.zdata))
-               zcol = obj.zdata(:,i);
-             else
-               zcol = zeros (size (xcol));
-             endif
-           endif
-
-           if (! isnan (xcol) && ! isnan (ycol))
-             ## Is the patch closed or not
-             if (strncmp (obj.facecolor, "none", 4))
-               hidden_removal = false;
-             else
+         if (! isnan (xcol) && ! isnan (ycol))
+           ## Is the patch closed or not
+           if (strncmp (obj.facecolor, "none", 4))
+             hidden_removal = false;
+           else
 
-               if (isnan (hidden_removal))
-                 hidden_removal = true;
-               endif
-               if (nd == 3)
-                 if (numel (xcol) > 3)
-                   error ("__go_draw_axes__: gnuplot (as of v4.2) only supports 3D filled triangular patches");
-                 else
-                   if (isnan (data_3d_idx))
-                     data_idx++;
-                     data_3d_idx = data_idx;
-                     is_image_data(data_idx) = false;
-                     parametric(data_idx) = false;
-                     have_cdata(data_idx) = true;
-                     have_3d_patch(data_idx) = true;
-                     withclause{data_3d_idx} = sprintf ("with pm3d");
-                     usingclause{data_3d_idx} =  "using 1:2:3:4";
-                     data{data_3d_idx} = [];
-                   endif
-                   local_idx = data_3d_idx;
-                   ccdat = NaN;
+             if (isnan (hidden_removal))
+               hidden_removal = true;
+             endif
+             if (nd == 3)
+               if (numel (xcol) > 3)
+                 error ("__go_draw_axes__: gnuplot (as of v4.2) only supports 3D filled triangular patches");
+               else
+                 if (isnan (data_3d_idx))
+                   data_idx++;
+                   data_3d_idx = data_idx;
+                   is_image_data(data_idx) = false;
+                   parametric(data_idx) = false;
+                   have_cdata(data_idx) = true;
+                   have_3d_patch(data_idx) = true;
+                   withclause{data_3d_idx} = sprintf ("with pm3d");
+                   usingclause{data_3d_idx} =  "using 1:2:3:4";
+                   data{data_3d_idx} = [];
                  endif
-               else
-                 data_idx++;
-                 local_idx = data_idx;
-                 is_image_data(data_idx) = false;
-                 parametric(data_idx) = false;
-                 have_cdata(data_idx) = false;
-                 have_3d_patch(data_idx) = false;
-               endif
-
-               if (i > 1 || isempty (obj.displayname))
-                 titlespec{local_idx} = "title \"\"";
-               else
-                 tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
-                 titlespec{local_idx} = ['title "' tmp '"'];
+                 local_idx = data_3d_idx;
+                 ccdat = NaN;
                endif
-               if (isfield (obj, "facecolor"))
-                 if ((strncmp (obj.facecolor, "flat", 4)
-                     || strncmp (obj.facecolor, "interp", 6))
-                     && isfield (obj, "cdata"))
-                   if (ndims (obj.cdata) == 2
-                       && (columns (obj.cdata) == nc
-                           && (rows (obj.cdata) == 1
-                               || rows (obj.cdata) == 3)))
-                     ccol = cdat (:, i);
-                   elseif (ndims (obj.cdata) == 2
-                       && (rows (obj.cdata) == nc
-                           && (columns (obj.cdata) == 1
-                               || columns (obj.cdata) == 3)))
-                     ccol = cdat (i, :);
-                   elseif (ndims (obj.cdata) == 3)
-                     ccol = permute (cdat (:, i, :), [1, 3, 2]);
-                   else
-                     ccol = cdat;
-                   endif
-                   if (strncmp (obj.facecolor, "flat", 4))
-                     if (isequal (size (ccol), [1, 3]))
-                       ## RGB Triplet
-                       color = ccol;
-                     elseif (nd == 3 && numel (xcol) == 3)
-                       ccdat = ccol;
-                     else
-                       if (cdatadirect)
-                         r = round (ccol);
-                       else
-                         r = 1 + round ((rows (cmap) - 1)
-                                        * (ccol - clim(1))/(clim(2) - clim(1)));
-                       endif
-                       r = max (1, min (r, rows (cmap)));
-                       color = cmap(r, :);
-                     endif
-                   elseif (strncmp (obj.facecolor, "interp", 6))
-                     if (nd == 3 && numel (xcol) == 3)
-                       ccdat = ccol;
-                       if (! isvector (ccdat))
-                         tmp = rows (cmap) + rows (addedcmap) + ...
-                              [1 : rows(ccdat)];
-                         addedcmap = [addedcmap; ccdat];
-                         ccdat = tmp(:);
-                       else
-                         ccdat = ccdat(:);
-                       endif
-                     else
-                       if (sum (diff (ccol)))
-                         warning ("\"interp\" not supported, using 1st entry of cdata");
-                       endif
-                       if (cdatadirect)
-                         r = round (ccol);
-                       else
-                         r = 1 + round ((rows (cmap) - 1)
-                                        * (ccol - clim(1))/(clim(2) - clim(1)));
-                       endif
-                       r = max (1, min (r, rows (cmap)));
-                       color = cmap(r(1),:);
-                     endif
-                   endif
-                 elseif (isnumeric (obj.facecolor))
-                   color = obj.facecolor;
-                 else
-                   color = [0, 1, 0];
-                 endif
-               else
-                 color = [0, 1, 0];
-               endif
-
-               if (nd == 3 && numel (xcol) == 3)
-                 if (isnan (ccdat))
-                   ccdat = (rows (cmap) + rows (addedcmap) + 1) * ones(3, 1);
-                   addedcmap = [addedcmap; reshape(color, 1, 3)];
-                 endif
-                 data{data_3d_idx} = [data{data_3d_idx}, ...
-                                      [[xcol; xcol(end)], [ycol; ycol(end)], ...
-                                      [zcol; zcol(end)], [ccdat; ccdat(end)]]'];
-               else
-                 if (mono)
-                   colorspec = "";
-                 elseif (__gnuplot_has_feature__ ("transparent_patches")
-                         && isscalar (obj.facealpha))
-                   colorspec = sprintf ("lc rgb \"#%02x%02x%02x\" fillstyle transparent solid %f",
-                                      round (255*color), obj.facealpha);
-                 else
-                   colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-                                        round (255*color));
-                 endif
-
-                 withclause{data_idx} = sprintf ("with filledcurve %s",
-                                               colorspec);
-                 data{data_idx} = [xcol, ycol]';
-                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2)",
-                                                  numel (xcol));
-               endif
-             endif
-           endif
-
-           ## patch outline
-           if (!(strncmp (obj.edgecolor, "none", 4)
-                  && (strncmp (obj.marker, "none", 4)
-                      || (strncmp (obj.markeredgecolor, "none", 4)
-                          && strncmp (obj.markerfacecolor, "none", 4)))))
-
-             data_idx++;
-             is_image_data(data_idx) = false;
-             parametric(data_idx) = false;
-             have_cdata(data_idx) = false;
-             have_3d_patch(data_idx) = false;
-             titlespec{data_idx} = "title \"\"";
-             usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
-
-             if (isfield (obj, "markersize"))
-               mdat = obj.markersize / 3;
+             else
+               data_idx++;
+               local_idx = data_idx;
+               is_image_data(data_idx) = false;
+               parametric(data_idx) = false;
+               have_cdata(data_idx) = false;
+               have_3d_patch(data_idx) = false;
              endif
 
-             if (isfield (obj, "edgecolor"))
-               ## FIXME
-               ## This is the wrong thing to do as edgecolor, markeredgecolor
-               ## and markerfacecolor can have different values and we should
-               ## treat them seperately. However, the below allow the scatter
-               ## functions to work as expected, where only one of these values
-               ## is set
-               if (strncmp (obj.edgecolor, "none", 4))
-                 if (strncmp (obj.markeredgecolor, "none", 4))
-                   ec = obj.markerfacecolor;
-                 else
-                   ec = obj.markeredgecolor;
-                 endif
-               else
-                 ec = obj.edgecolor;
-               endif
-
-               if ((strncmp (ec, "flat", 4)
-                    || strncmp (ec, "interp", 6))
+             if (i > 1 || isempty (obj.displayname))
+               titlespec{local_idx} = "title \"\"";
+             else
+               tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
+               titlespec{local_idx} = ['title "' tmp '"'];
+             endif
+             if (isfield (obj, "facecolor"))
+               if ((strncmp (obj.facecolor, "flat", 4)
+                   || strncmp (obj.facecolor, "interp", 6))
                    && isfield (obj, "cdata"))
                  if (ndims (obj.cdata) == 2
                      && (columns (obj.cdata) == nc
                          && (rows (obj.cdata) == 1
                              || rows (obj.cdata) == 3)))
                    ccol = cdat (:, i);
                  elseif (ndims (obj.cdata) == 2
-                         && (rows (obj.cdata) == nc
-                             && (columns (obj.cdata) == 1
-                                 || columns (obj.cdata) == 3)))
+                     && (rows (obj.cdata) == nc
+                         && (columns (obj.cdata) == 1
+                             || columns (obj.cdata) == 3)))
                    ccol = cdat (i, :);
                  elseif (ndims (obj.cdata) == 3)
                    ccol = permute (cdat (:, i, :), [1, 3, 2]);
                  else
                    ccol = cdat;
                  endif
-                 if (strncmp (ec, "flat", 4))
-                   if (numel (ccol) == 3)
+                 if (strncmp (obj.facecolor, "flat", 4))
+                   if (isequal (size (ccol), [1, 3]))
+                     ## RGB Triplet
                      color = ccol;
+                   elseif (nd == 3 && numel (xcol) == 3)
+                     ccdat = ccol;
                    else
-                     if (isscalar (ccol))
-                       ccol = repmat (ccol, numel (xcol), 1);
+                     if (cdatadirect)
+                       r = round (ccol);
+                     else
+                       r = 1 + round ((rows (cmap) - 1)
+                                      * (ccol - clim(1))/(clim(2) - clim(1)));
                      endif
-                     color = "flat";
-                     have_cdata(data_idx) = true;
+                     r = max (1, min (r, rows (cmap)));
+                     color = cmap(r, :);
                    endif
-                 elseif (strncmp (ec, "interp", 6))
-                   if (numel (ccol) == 3)
-                     warning ("\"interp\" not supported, using 1st entry of cdata");
-                     color = ccol(1,:);
+                 elseif (strncmp (obj.facecolor, "interp", 6))
+                   if (nd == 3 && numel (xcol) == 3)
+                     ccdat = ccol;
+                     if (! isvector (ccdat))
+                       tmp = rows (cmap) + rows (addedcmap) + ...
+                            [1 : rows(ccdat)];
+                       addedcmap = [addedcmap; ccdat];
+                       ccdat = tmp(:);
+                     else
+                       ccdat = ccdat(:);
+                     endif
                    else
-                     if (isscalar (ccol))
-                       ccol = repmat (ccol, numel (xcol), 1);
+                     if (sum (diff (ccol)))
+                       warning ("\"interp\" not supported, using 1st entry of cdata");
                      endif
-                     color = "interp";
-                     have_cdata(data_idx) = true;
+                     if (cdatadirect)
+                       r = round (ccol);
+                     else
+                       r = 1 + round ((rows (cmap) - 1)
+                                      * (ccol - clim(1))/(clim(2) - clim(1)));
+                     endif
+                     r = max (1, min (r, rows (cmap)));
+                     color = cmap(r(1),:);
                    endif
                  endif
-               elseif (isnumeric (ec))
-                 color = ec;
+               elseif (isnumeric (obj.facecolor))
+                 color = obj.facecolor;
                else
-                 color = [0, 0, 0];
+                 color = [0, 1, 0];
                endif
              else
-               color = [0, 0, 0];
+               color = [0, 1, 0];
              endif
 
-             if (isfield (obj, "linestyle"))
-               switch (obj.linestyle)
-                 case "-"
-                   lt = "lt 1";
-                 case "--"
-                   lt = "lt 2";
-                 case ":"
-                   lt = "lt 3";
-                 case "-."
-                   lt = "lt 6";
-                 case "none"
-                   lt = "";
-                 otherwise
-                   lt = "";
-               endswitch
+             if (nd == 3 && numel (xcol) == 3)
+               if (isnan (ccdat))
+                 ccdat = (rows (cmap) + rows (addedcmap) + 1) * ones(3, 1);
+                 addedcmap = [addedcmap; reshape(color, 1, 3)];
+               endif
+               data{data_3d_idx} = [data{data_3d_idx}, ...
+                                    [[xcol; xcol(end)], [ycol; ycol(end)], ...
+                                    [zcol; zcol(end)], [ccdat; ccdat(end)]]'];
              else
-               lt = "";
-             endif
-
-             if (isfield (obj, "linewidth"))
-               lw = sprintf ("linewidth %f", obj.linewidth);
-             else
-               lw  = "";
-             endif
-
-             [pt, pt2, obj] = gnuplot_pointtype (obj);
-             if (! isempty (pt))
-               pt = sprintf ("pointtype %s", pt);
-             endif
-             if (! isempty (pt2))
-               pt2 = sprintf ("pointtype %s", pt2);
-             endif
-
-             if (mono)
-               colorspec = "";
-             else
-               if (ischar (color))
-                 colorspec = "palette";
+               if (mono)
+                 colorspec = "";
+               elseif (__gnuplot_has_feature__ ("transparent_patches")
+                       && isscalar (obj.facealpha))
+                 colorspec = sprintf ("lc rgb \"#%02x%02x%02x\" fillstyle transparent solid %f",
+                                    round (255*color), obj.facealpha);
                else
                  colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
                                       round (255*color));
                endif
+
+               withclause{data_idx} = sprintf ("with filledcurve %s",
+                                             colorspec);
+               data{data_idx} = [xcol, ycol]';
+               usingclause{data_idx} = sprintf ("record=%d using ($1):($2)",
+                                                numel (xcol));
+             endif
+           endif
+         endif
+
+         ## patch outline
+         if (!(strncmp (obj.edgecolor, "none", 4)
+                && (strncmp (obj.marker, "none", 4)
+                    || (strncmp (obj.markeredgecolor, "none", 4)
+                        && strncmp (obj.markerfacecolor, "none", 4)))))
+
+           data_idx++;
+           is_image_data(data_idx) = false;
+           parametric(data_idx) = false;
+           have_cdata(data_idx) = false;
+           have_3d_patch(data_idx) = false;
+           titlespec{data_idx} = "title \"\"";
+           usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
+
+           if (isfield (obj, "markersize"))
+             mdat = obj.markersize / 3;
+           endif
+
+           if (isfield (obj, "edgecolor"))
+             ## FIXME
+             ## This is the wrong thing to do as edgecolor, markeredgecolor
+             ## and markerfacecolor can have different values and we should
+             ## treat them seperately. However, the below allow the scatter
+             ## functions to work as expected, where only one of these values
+             ## is set
+             if (strncmp (obj.edgecolor, "none", 4))
+               if (strncmp (obj.markeredgecolor, "none", 4))
+                 ec = obj.markerfacecolor;
+               else
+                 ec = obj.markeredgecolor;
+               endif
+             else
+               ec = obj.edgecolor;
              endif
 
-             sidx = 1;
-             if (isempty (lt))
-               style = "";
+             if ((strncmp (ec, "flat", 4)
+                  || strncmp (ec, "interp", 6))
+                 && isfield (obj, "cdata"))
+               if (ndims (obj.cdata) == 2
+                   && (columns (obj.cdata) == nc
+                       && (rows (obj.cdata) == 1
+                           || rows (obj.cdata) == 3)))
+                 ccol = cdat (:, i);
+               elseif (ndims (obj.cdata) == 2
+                       && (rows (obj.cdata) == nc
+                           && (columns (obj.cdata) == 1
+                               || columns (obj.cdata) == 3)))
+                 ccol = cdat (i, :);
+               elseif (ndims (obj.cdata) == 3)
+                 ccol = permute (cdat (:, i, :), [1, 3, 2]);
+               else
+                 ccol = cdat;
+               endif
+               if (strncmp (ec, "flat", 4))
+                 if (numel (ccol) == 3)
+                   color = ccol;
+                 else
+                   if (isscalar (ccol))
+                     ccol = repmat (ccol, numel (xcol), 1);
+                   endif
+                   color = "flat";
+                   have_cdata(data_idx) = true;
+                 endif
+               elseif (strncmp (ec, "interp", 6))
+                 if (numel (ccol) == 3)
+                   warning ("\"interp\" not supported, using 1st entry of cdata");
+                   color = ccol(1,:);
+                 else
+                   if (isscalar (ccol))
+                     ccol = repmat (ccol, numel (xcol), 1);
+                   endif
+                   color = "interp";
+                   have_cdata(data_idx) = true;
+                 endif
+               endif
+             elseif (isnumeric (ec))
+               color = ec;
              else
-               style = "lines";
+               color = [0, 0, 0];
              endif
-             tmpwith = {};
+           else
+             color = [0, 0, 0];
+           endif
+
+           if (isfield (obj, "linestyle"))
+             switch (obj.linestyle)
+               case "-"
+                 lt = "lt 1";
+               case "--"
+                 lt = "lt 2";
+               case ":"
+                 lt = "lt 3";
+               case "-."
+                 lt = "lt 6";
+               case "none"
+                 lt = "";
+               otherwise
+                 lt = "";
+             endswitch
+           else
+             lt = "";
+           endif
+
+           if (isfield (obj, "linewidth"))
+             lw = sprintf ("linewidth %f", obj.linewidth);
+           else
+             lw  = "";
+           endif
 
-             facesame = true;
-             if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor")
-                 && !strncmp (obj.markerfacecolor, "none", 4))
-               if (strncmp (obj.markerfacecolor, "auto", 4)
-                   || ! isnumeric (obj.markerfacecolor)
-                   || (isnumeric (obj.markerfacecolor)
-                       && isequal (color, obj.markerfacecolor)))
+           [pt, pt2, obj] = gnuplot_pointtype (obj);
+           if (! isempty (pt))
+             pt = sprintf ("pointtype %s", pt);
+           endif
+           if (! isempty (pt2))
+             pt2 = sprintf ("pointtype %s", pt2);
+           endif
+
+           if (mono)
+             colorspec = "";
+           else
+             if (ischar (color))
+               colorspec = "palette";
+             else
+               colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                    round (255*color));
+             endif
+           endif
+
+           sidx = 1;
+           if (isempty (lt))
+             style = "";
+           else
+             style = "lines";
+           endif
+           tmpwith = {};
+
+           facesame = true;
+           if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor")
+               && !strncmp (obj.markerfacecolor, "none", 4))
+             if (strncmp (obj.markerfacecolor, "auto", 4)
+                 || ! isnumeric (obj.markerfacecolor)
+                 || (isnumeric (obj.markerfacecolor)
+                     && isequal (color, obj.markerfacecolor)))
+               style = strcat (style, "points");
+               if (isfield (obj, "markersize"))
+                 if (length (mdat) == nc)
+                   m = mdat(i);
+                 else
+                   m = mdat;
+                 endif
+                 ps = sprintf ("pointsize %f", m / 3);
+               else
+                 ps = "";
+               endif
+
+               tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
+                                        style, lw, pt2, lt, ps,
+                                        colorspec);
+             else
+               facesame = false;
+               if (! isempty (style))
+                 tmpwith{sidx} = sprintf ("with %s %s %s %s",
+                                          style, lw, lt,
+                                          colorspec);
+                 sidx ++;
+               endif
+               if (isnumeric (obj.markerfacecolor) && ! mono)
+                 colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                      round (255*obj.markerfacecolor));
+               endif
+               style = "points";
+               if (isfield (obj, "markersize"))
+                 if (length (mdat) == nc)
+                   m = mdat(i);
+                 else
+                   m = mdat;
+                 endif
+                 ps = sprintf ("pointsize %f", m / 3);
+               else
+                 ps = "";
+               endif
+               tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
+                                        style, lw, pt2, lt, ps,
+                                        colorspec);
+             endif
+           endif
+
+           if (isfield (obj, "markeredgecolor")
+               && !strncmp (obj.markeredgecolor, "none", 4))
+             if (facesame && !isempty (pt)
+                 && (strncmp (obj.markeredgecolor, "auto", 4)
+                     || ! isnumeric (obj.markeredgecolor)
+                     || (isnumeric (obj.markeredgecolor)
+                         && isequal (color, obj.markeredgecolor))))
+               if (sidx == 1 && ((length (style) == 5
+                        && strncmp (style, "lines", 5))
+                       || isempty (style)))
                  style = strcat (style, "points");
                  if (isfield (obj, "markersize"))
                    if (length (mdat) == nc)
                      m = mdat(i);
                    else
                      m = mdat;
                    endif
                    ps = sprintf ("pointsize %f", m / 3);
                  else
                    ps = "";
                  endif
-
                  tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-                                          style, lw, pt2, lt, ps,
+                                          style, lw, pt, lt, ps,
                                           colorspec);
-               else
-                 facesame = false;
-                 if (! isempty (style))
+               endif
+             else
+               if (!isempty (style))
+                 if (length (tmpwith) < sidx || isempty (tmpwith{sidx}))
                    tmpwith{sidx} = sprintf ("with %s %s %s %s",
                                             style, lw, lt,
                                             colorspec);
-                   sidx ++;
                  endif
-                 if (isnumeric (obj.markerfacecolor) && ! mono)
-                   colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-                                        round (255*obj.markerfacecolor));
+                 sidx ++;
+               endif
+
+               if (!isempty (pt))
+                 if (! mono)
+                   if (strncmp (obj.markeredgecolor, "auto", 4))
+                     colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                          round (255*color));
+                   elseif (isnumeric (obj.markeredgecolor) && ! mono)
+                     colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                          round (255*obj.markeredgecolor));
+                   endif
                  endif
                  style = "points";
                  if (isfield (obj, "markersize"))
                    if (length (mdat) == nc)
                      m = mdat(i);
                    else
                      m = mdat;
                    endif
                    ps = sprintf ("pointsize %f", m / 3);
                  else
                    ps = "";
                  endif
                  tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-                                          style, lw, pt2, lt, ps,
+                                          style, lw, pt, lt, ps,
                                           colorspec);
                endif
              endif
-
-             if (isfield (obj, "markeredgecolor")
-                 && !strncmp (obj.markeredgecolor, "none", 4))
-               if (facesame && !isempty (pt)
-                   && (strncmp (obj.markeredgecolor, "auto", 4)
-                       || ! isnumeric (obj.markeredgecolor)
-                       || (isnumeric (obj.markeredgecolor)
-                           && isequal (color, obj.markeredgecolor))))
-                 if (sidx == 1 && ((length (style) == 5
-                          && strncmp (style, "lines", 5))
-                         || isempty (style)))
-                   style = strcat (style, "points");
-                   if (isfield (obj, "markersize"))
-                     if (length (mdat) == nc)
-                       m = mdat(i);
-                     else
-                       m = mdat;
-                     endif
-                     ps = sprintf ("pointsize %f", m / 3);
-                   else
-                     ps = "";
-                   endif
-                   tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-                                            style, lw, pt, lt, ps,
-                                            colorspec);
-                 endif
-               else
-                 if (!isempty (style))
-                   if (length (tmpwith) < sidx || isempty (tmpwith{sidx}))
-                     tmpwith{sidx} = sprintf ("with %s %s %s %s",
-                                              style, lw, lt,
-                                              colorspec);
-                   endif
-                   sidx ++;
-                 endif
-
-                 if (!isempty (pt))
-                   if (! mono)
-                     if (strncmp (obj.markeredgecolor, "auto", 4))
-                       colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-                                            round (255*color));
-                     elseif (isnumeric (obj.markeredgecolor) && ! mono)
-                       colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-                                            round (255*obj.markeredgecolor));
-                     endif
-                   endif
-                   style = "points";
-                   if (isfield (obj, "markersize"))
-                     if (length (mdat) == nc)
-                       m = mdat(i);
-                     else
-                       m = mdat;
-                     endif
-                     ps = sprintf ("pointsize %f", m / 3);
-                   else
-                     ps = "";
-                   endif
-                   tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-                                            style, lw, pt, lt, ps,
-                                            colorspec);
-                 endif
-               endif
-             endif
+           endif
 
-             if (isempty (tmpwith))
-               withclause{data_idx} = sprintf ("with %s %s %s %s %s",
-                                               style, lw, pt, lt,
-                                               colorspec);
-             else
-               withclause{data_idx} = tmpwith{1};
-             endif
-             if (nd == 3)
-               if (ischar (color))
-                 if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
-                   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
-                                     [zcol; zcol(1)], [ccol; ccol(1)]]';
-                 else
-                   data{data_idx} = [xcol, ycol, zcol, ccol]';
-                 endif
-                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3):($4)", columns (data{data_idx}));
+           if (isempty (tmpwith))
+             withclause{data_idx} = sprintf ("with %s %s %s %s %s",
+                                             style, lw, pt, lt,
+                                             colorspec);
+           else
+             withclause{data_idx} = tmpwith{1};
+           endif
+           if (nd == 3)
+             if (ischar (color))
+               if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
+                 data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
+                                   [zcol; zcol(1)], [ccol; ccol(1)]]';
                else
-                 if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
-                   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
-                                     [zcol; zcol(1)]]';
-                 else
-                   data{data_idx} = [xcol, ycol, zcol]';
-                 endif
-                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", columns (data{data_idx}));
+                 data{data_idx} = [xcol, ycol, zcol, ccol]';
                endif
+               usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3):($4)", columns (data{data_idx}));
              else
-               if (ischar (color))
-                 if (! isnan (xcol) && ! isnan (ycol))
-                   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
-                                     [ccol; ccol(1)]]';
-                 else
-                   data{data_idx} = [xcol, ycol, ccol]';
-                 endif
-                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", columns (data{data_idx}));
+               if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
+                 data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
+                                   [zcol; zcol(1)]]';
                else
-                 if (! isnan (xcol) && ! isnan (ycol))
-                   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)]]';
-                 else
-                   data{data_idx} = [xcol, ycol]';
-                 endif
-                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2)", columns (data{data_idx}));
+                 data{data_idx} = [xcol, ycol, zcol]';
                endif
+               usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", columns (data{data_idx}));
              endif
-
-             if (length (tmpwith) > 1)
-               data_idx++;
-               is_image_data(data_idx) = is_image_data(data_idx - 1);
-               parametric(data_idx) = parametric(data_idx - 1);
-               have_cdata(data_idx) = have_cdata(data_idx - 1);
-               have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-               titlespec{data_idx} = "title \"\"";
-               usingclause{data_idx} = usingclause{data_idx - 1};
-               data{data_idx} = data{data_idx - 1};
-               withclause{data_idx} = tmpwith{2};
-             endif
-             if (length (tmpwith) > 2)
-               data_idx++;
-               is_image_data(data_idx) = is_image_data(data_idx - 1);
-               parametric(data_idx) = parametric(data_idx - 1);
-               have_cdata(data_idx) = have_cdata(data_idx - 1);
-               have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-               titlespec{data_idx} = "title \"\"";
-               usingclause{data_idx} = usingclause{data_idx - 1};
-               data{data_idx} = data{data_idx - 1};
-               withclause{data_idx} = tmpwith{3};
+           else
+             if (ischar (color))
+               if (! isnan (xcol) && ! isnan (ycol))
+                 data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
+                                   [ccol; ccol(1)]]';
+               else
+                 data{data_idx} = [xcol, ycol, ccol]';
+               endif
+               usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", columns (data{data_idx}));
+             else
+               if (! isnan (xcol) && ! isnan (ycol))
+                 data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)]]';
+               else
+                 data{data_idx} = [xcol, ycol]';
+               endif
+               usingclause{data_idx} = sprintf ("record=%d using ($1):($2)", columns (data{data_idx}));
              endif
            endif
-         endfor
 
-        case "surface"
-          view_map = true;
-          if (! (strncmp (obj.edgecolor, "none", 4)
-                 && strncmp (obj.facecolor, "none", 4)))
-            data_idx++;
-            is_image_data(data_idx) = false;
-            parametric(data_idx) = false;
-            have_cdata(data_idx) = true;
-            have_3d_patch(data_idx) = false;
-            style = do_linestyle_command (obj, obj.edgecolor,
-                                          data_idx, mono,
-                                          plot_stream);
+           if (length (tmpwith) > 1)
+             data_idx++;
+             is_image_data(data_idx) = is_image_data(data_idx - 1);
+             parametric(data_idx) = parametric(data_idx - 1);
+             have_cdata(data_idx) = have_cdata(data_idx - 1);
+             have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+             titlespec{data_idx} = "title \"\"";
+             usingclause{data_idx} = usingclause{data_idx - 1};
+             data{data_idx} = data{data_idx - 1};
+             withclause{data_idx} = tmpwith{2};
+           endif
+           if (length (tmpwith) > 2)
+             data_idx++;
+             is_image_data(data_idx) = is_image_data(data_idx - 1);
+             parametric(data_idx) = parametric(data_idx - 1);
+             have_cdata(data_idx) = have_cdata(data_idx - 1);
+             have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+             titlespec{data_idx} = "title \"\"";
+             usingclause{data_idx} = usingclause{data_idx - 1};
+             data{data_idx} = data{data_idx - 1};
+             withclause{data_idx} = tmpwith{3};
+           endif
+         endif
+       endfor
 
-            if (isempty (obj.displayname))
-              titlespec{data_idx} = "title \"\"";
-            else
-              tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
-              titlespec{data_idx} = ['title "' tmp '"'];
-            endif
-            withclause{data_idx} = sprintf ("with pm3d linestyle %d",
-                                            data_idx);
-            withpm3d = true;
-            pm3didx = data_idx;
-
-            xdat = obj.xdata;
-            ydat = obj.ydata;
-            zdat = obj.zdata;
-            cdat = obj.cdata;
+      case "surface"
+        view_map = true;
+        if (! (strncmp (obj.edgecolor, "none", 4)
+               && strncmp (obj.facecolor, "none", 4)))
+          data_idx++;
+          is_image_data(data_idx) = false;
+          parametric(data_idx) = false;
+          have_cdata(data_idx) = true;
+          have_3d_patch(data_idx) = false;
+          style = do_linestyle_command (obj, obj.edgecolor,
+                                        data_idx, mono,
+                                        plot_stream);
 
-            err = false;
-            if (! size_equal (zdat, cdat))
-              err = true;
-            endif
-            if (isvector (xdat) && isvector (ydat) && ismatrix (zdat))
-              if (rows (zdat) == length (ydat)
-                  && columns (zdat) == length (xdat))
-                [xdat, ydat] = meshgrid (xdat, ydat);
-              else
-                err = true;
-              endif
-            elseif (ismatrix (xdat) && ismatrix (ydat) && ismatrix (zdat))
-              if (! size_equal (xdat, ydat, zdat))
-                err = true;
-              endif
+          if (isempty (obj.displayname))
+            titlespec{data_idx} = "title \"\"";
+          else
+            tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
+            titlespec{data_idx} = ['title "' tmp '"'];
+          endif
+          withclause{data_idx} = sprintf ("with pm3d linestyle %d",
+                                          data_idx);
+          withpm3d = true;
+          pm3didx = data_idx;
+
+          xdat = obj.xdata;
+          ydat = obj.ydata;
+          zdat = obj.zdata;
+          cdat = obj.cdata;
+
+          err = false;
+          if (! size_equal (zdat, cdat))
+            err = true;
+          endif
+          if (isvector (xdat) && isvector (ydat) && ismatrix (zdat))
+            if (rows (zdat) == length (ydat)
+                && columns (zdat) == length (xdat))
+              [xdat, ydat] = meshgrid (xdat, ydat);
             else
               err = true;
             endif
-            if (err)
-              error ("__go_draw_axes__: invalid grid data");
+          elseif (ismatrix (xdat) && ismatrix (ydat) && ismatrix (zdat))
+            if (! size_equal (xdat, ydat, zdat))
+              err = true;
             endif
-            xlen = columns (zdat);
-            ylen = rows (zdat);
-            if (xlen == columns (xdat) && xlen == columns (ydat)
-                && ylen == rows (xdat) && ylen == rows (ydat))
-              len = 4 * xlen;
-              zz = zeros (ylen, len);
-              k = 1;
-              for kk = 1:4:len
-                zz(:,kk)   = xdat(:,k);
-                zz(:,kk+1) = ydat(:,k);
-                zz(:,kk+2) = zdat(:,k);
-                zz(:,kk+3) = cdat(:,k);
-                k++;
-              endfor
-              data{data_idx} = zz.';
-            endif
+          else
+            err = true;
+          endif
+          if (err)
+            error ("__go_draw_axes__: invalid grid data");
+          endif
+          xlen = columns (zdat);
+          ylen = rows (zdat);
+          if (xlen == columns (xdat) && xlen == columns (ydat)
+              && ylen == rows (xdat) && ylen == rows (ydat))
+            len = 4 * xlen;
+            zz = zeros (ylen, len);
+            k = 1;
+            for kk = 1:4:len
+              zz(:,kk)   = xdat(:,k);
+              zz(:,kk+1) = ydat(:,k);
+              zz(:,kk+2) = zdat(:,k);
+              zz(:,kk+3) = cdat(:,k);
+              k++;
+            endfor
+            data{data_idx} = zz.';
+          endif
 
-            if (doing_interp_color)
-              interp_str = "interpolate 0, 0";
-            else
-              ## No interpolation of facecolors.
-              interp_str = "";
-            endif
-            usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3):($4)", ylen, xlen);
+          if (doing_interp_color)
+            interp_str = "interpolate 0, 0";
+          else
+            ## No interpolation of facecolors.
+            interp_str = "";
+          endif
+          usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3):($4)", ylen, xlen);
 
-            flat_interp_face = (strncmp (obj.facecolor, "flat", 4)
-                                || strncmp (obj.facecolor, "interp", 6));
-            flat_interp_edge = (strncmp (obj.edgecolor, "flat", 4)
-                                || strncmp (obj.edgecolor, "interp", 6));
+          flat_interp_face = (strncmp (obj.facecolor, "flat", 4)
+                              || strncmp (obj.facecolor, "interp", 6));
+          flat_interp_edge = (strncmp (obj.edgecolor, "flat", 4)
+                              || strncmp (obj.edgecolor, "interp", 6));
 
-            facecolor_none_or_white = (strncmp (obj.facecolor, "none", 4)
-                                       || (isnumeric (obj.facecolor)
-                                           && all (obj.facecolor == 1)));
-            hidden_removal = false;
-            fputs (plot_stream, "set style increment default;\n");
-            if (flat_interp_edge && facecolor_none_or_white)
-              withpm3d = false;
-              withclause{data_idx} = sprintf ("with %s palette", style {1});
-              fputs (plot_stream, "unset pm3d\n");
-              if (all (obj.facecolor == 1))
-                hidden_removal = true;
-              endif
-            elseif (facecolor_none_or_white)
-              if (all (obj.facecolor == 1))
-                hidden_removal = true;
-              endif
-              fputs (plot_stream,"unset pm3d;\n");
-              fputs (plot_stream,"set style increment user;\n");
-              withpm3d = false;
-              withclause{data_idx} = sprintf ("with %s linestyle %d",
-                                              style{1}, data_idx);
-              fputs (plot_stream, "unset pm3d\n");
+          facecolor_none_or_white = (strncmp (obj.facecolor, "none", 4)
+                                     || (isnumeric (obj.facecolor)
+                                         && all (obj.facecolor == 1)));
+          hidden_removal = false;
+          fputs (plot_stream, "set style increment default;\n");
+          if (flat_interp_edge && facecolor_none_or_white)
+            withpm3d = false;
+            withclause{data_idx} = sprintf ("with %s palette", style {1});
+            fputs (plot_stream, "unset pm3d\n");
+            if (all (obj.facecolor == 1))
+              hidden_removal = true;
             endif
+          elseif (facecolor_none_or_white)
+            if (all (obj.facecolor == 1))
+              hidden_removal = true;
+            endif
+            fputs (plot_stream,"unset pm3d;\n");
+            fputs (plot_stream,"set style increment user;\n");
+            withpm3d = false;
+            withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                            style{1}, data_idx);
+            fputs (plot_stream, "unset pm3d\n");
+          endif
 
-            if (doing_interp_color)
-              ## "depthorder" interferes with interpolation of colors.
-              dord = "scansautomatic";
-            else
-              dord = "depthorder";
-            endif
+          if (doing_interp_color)
+            ## "depthorder" interferes with interpolation of colors.
+            dord = "scansautomatic";
+          else
+            dord = "depthorder";
+          endif
 
-            if (flat_interp_face && strncmp (obj.edgecolor, "flat", 4))
-              fprintf (plot_stream, "set pm3d explicit at s %s %s corners2color c3;\n",
+          if (flat_interp_face && strncmp (obj.edgecolor, "flat", 4))
+            fprintf (plot_stream, "set pm3d explicit at s %s %s corners2color c3;\n",
+                     interp_str, dord);
+          elseif (!facecolor_none_or_white)
+            if (strncmp (obj.edgecolor, "none", 4))
+              if (__gnuplot_has_feature__ ("transparent_surface")
+                  && isscalar (obj.facealpha))
+                fprintf (plot_stream,
+                         "set style fill transparent solid %f;\n",
+                         obj.facealpha);
+              endif
+              fprintf (plot_stream, "set pm3d explicit at s %s corners2color c3;\n",
                        interp_str, dord);
-            elseif (!facecolor_none_or_white)
-              if (strncmp (obj.edgecolor, "none", 4))
-                if (__gnuplot_has_feature__ ("transparent_surface")
-                    && isscalar (obj.facealpha))
-                  fprintf (plot_stream,
-                           "set style fill transparent solid %f;\n",
-                           obj.facealpha);
-                endif
-                fprintf (plot_stream, "set pm3d explicit at s %s corners2color c3;\n",
-                         interp_str, dord);
-              else
-                fprintf (plot_stream, "set pm3d explicit at s hidden3d %d %s %s corners2color c3;\n",
-                         data_idx, interp_str, dord);
+            else
+              fprintf (plot_stream, "set pm3d explicit at s hidden3d %d %s %s corners2color c3;\n",
+                       data_idx, interp_str, dord);
 
-                if (__gnuplot_has_feature__ ("transparent_surface")
-                    && isscalar (obj.facealpha))
-                  fprintf (plot_stream,
-                           "set style fill transparent solid %f;\n",
-                           obj.facealpha);
-                endif
+              if (__gnuplot_has_feature__ ("transparent_surface")
+                  && isscalar (obj.facealpha))
+                fprintf (plot_stream,
+                         "set style fill transparent solid %f;\n",
+                         obj.facealpha);
               endif
             endif
+          endif
 
-            zz = [];
-            if (length (style) > 1)
+          zz = [];
+          if (length (style) > 1)
+            len = 3 * xlen;
+            zz = zeros (ylen, len);
+            k = 1;
+            for kk = 1:3:len
+              zz(:,kk)   = xdat(:,k);
+              zz(:,kk+1) = ydat(:,k);
+              zz(:,kk+2) = zdat(:,k);
+              k++;
+            endfor
+            zz = zz.';
+
+            data_idx++;
+            is_image_data(data_idx) = is_image_data(data_idx - 1);
+            parametric(data_idx) = parametric(data_idx - 1);
+            have_cdata(data_idx) = false;
+            have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+            titlespec{data_idx} = "title \"\"";
+            usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
+            data{data_idx} = zz;
+            withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                            style{2}, data_idx);
+
+          endif
+          if (length (style) > 2)
+            data_idx++;
+            is_image_data(data_idx) = is_image_data(data_idx - 1);
+            parametric(data_idx) = parametric(data_idx - 1);
+            have_cdata(data_idx) = false;
+            have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+            titlespec{data_idx} = "title \"\"";
+            usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
+            data{data_idx} = zz;
+            withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                            style{3}, data_idx);
+          endif
+          if (withpm3d && strncmp (style {1}, "linespoints", 11))
+            if (isempty (zz))
               len = 3 * xlen;
               zz = zeros (ylen, len);
               k = 1;
               for kk = 1:3:len
                 zz(:,kk)   = xdat(:,k);
                 zz(:,kk+1) = ydat(:,k);
                 zz(:,kk+2) = zdat(:,k);
                 k++;
               endfor
               zz = zz.';
-
-              data_idx++;
-              is_image_data(data_idx) = is_image_data(data_idx - 1);
-              parametric(data_idx) = parametric(data_idx - 1);
-              have_cdata(data_idx) = false;
-              have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-              titlespec{data_idx} = "title \"\"";
-              usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
-              data{data_idx} = zz;
-              withclause{data_idx} = sprintf ("with %s linestyle %d",
-                                              style{2}, data_idx);
+            endif
+            data_idx++;
+            is_image_data(data_idx) = is_image_data(data_idx - 1);
+            parametric(data_idx) = parametric(data_idx - 1);
+            have_cdata(data_idx) = false;
+            have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+            titlespec{data_idx} = "title \"\"";
+            usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
+            data{data_idx} = zz;
+            withclause{data_idx} = sprintf ("with points linestyle %d",
+                                            pm3didx);
+          endif
+        endif
 
-            endif
-            if (length (style) > 2)
-              data_idx++;
-              is_image_data(data_idx) = is_image_data(data_idx - 1);
-              parametric(data_idx) = parametric(data_idx - 1);
-              have_cdata(data_idx) = false;
-              have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-              titlespec{data_idx} = "title \"\"";
-              usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
-              data{data_idx} = zz;
-              withclause{data_idx} = sprintf ("with %s linestyle %d",
-                                              style{3}, data_idx);
-            endif
-            if (withpm3d && strncmp (style {1}, "linespoints", 11))
-              if (isempty (zz))
-                len = 3 * xlen;
-                zz = zeros (ylen, len);
-                k = 1;
-                for kk = 1:3:len
-                  zz(:,kk)   = xdat(:,k);
-                  zz(:,kk+1) = ydat(:,k);
-                  zz(:,kk+2) = zdat(:,k);
-                  k++;
-                endfor
-                zz = zz.';
-              endif
-              data_idx++;
-              is_image_data(data_idx) = is_image_data(data_idx - 1);
-              parametric(data_idx) = parametric(data_idx - 1);
-              have_cdata(data_idx) = false;
-              have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-              titlespec{data_idx} = "title \"\"";
-              usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
-              data{data_idx} = zz;
-              withclause{data_idx} = sprintf ("with points linestyle %d",
-                                              pm3didx);
-            endif
-          endif
+      case "text"
+        [label, f, s] = __maybe_munge_text__ (enhanced, obj, "string");
+        fontspec = create_fontspec (f, s, gnuplot_term);
+        lpos = obj.position;
+        halign = obj.horizontalalignment;
+        valign = obj.verticalalignment;
+        angle = obj.rotation;
+        units = obj.units;
+        color = obj.color;
+        if (strcmpi (units, "normalized"))
+          units = "graph";
+        elseif (strcmp (axis_obj.yaxislocation, "right")
+                && strcmp (units, "data"))
+          units = "second";
+        else
+          units = "";
+        endif
+
+        if (isnumeric (color))
+          colorspec = get_text_colorspec (color, mono);
+        endif
 
-        case "text"
-          [label, f, s] = __maybe_munge_text__ (enhanced, obj, "string");
-          fontspec = create_fontspec (f, s, gnuplot_term);
-          lpos = obj.position;
-          halign = obj.horizontalalignment;
-          valign = obj.verticalalignment;
-          angle = obj.rotation;
-          units = obj.units;
-          color = obj.color;
-          if (strcmpi (units, "normalized"))
-            units = "graph";
-          elseif (strcmp (axis_obj.yaxislocation, "right")
-                  && strcmp (units, "data"))
-            units = "second";
-          else
-            units = "";
-          endif
-
-          if (isnumeric (color))
-            colorspec = get_text_colorspec (color, mono);
-          endif
+        if (ischar (obj.string))
+          num_lines = rows (obj.string);
+        else
+          num_lines = numel (obj.string);
+        endif
+        switch (valign)
+          ## Text offset in characters. Relies on gnuplot for font metrics.
+          case "top"
+            dy = -0.5;
+          case "cap"
+            dy = -0.5;
+          case "middle"
+            dy = 0.5 * (num_lines - 1);
+          case "baseline"
+            dy = 0.5 + (num_lines - 1);
+          case "bottom"
+            dy = 0.5 + (num_lines - 1);
+        endswitch
+        ## Gnuplot's Character units are different for x/y and vary with
+        ## fontsize. The aspect ratio of 1:1.7 was determined by experiment
+        ## to work for eps/ps/etc. For the MacOS aqua terminal a value of 2.5
+        ## is needed. However, the difference is barely noticable.
+        dx_and_dy = [(-dy * sind (angle)), (dy * cosd (angle))] .* [1.7 1];
 
-          if (ischar (obj.string))
-            num_lines = rows (obj.string);
-          else
-            num_lines = numel (obj.string);
-          endif
-          switch (valign)
-            ## Text offset in characters. Relies on gnuplot for font metrics.
-            case "top"
-              dy = -0.5;
-            case "cap"
-              dy = -0.5;
-            case "middle"
-              dy = 0.5 * (num_lines - 1);
-            case "baseline"
-              dy = 0.5 + (num_lines - 1);
-            case "bottom"
-              dy = 0.5 + (num_lines - 1);
-          endswitch
-          ## Gnuplot's Character units are different for x/y and vary with
-          ## fontsize. The aspect ratio of 1:1.7 was determined by experiment
-          ## to work for eps/ps/etc. For the MacOS aqua terminal a value of 2.5
-          ## is needed. However, the difference is barely noticable.
-          dx_and_dy = [(-dy * sind (angle)), (dy * cosd (angle))] .* [1.7 1];
+        ## FIXME: Multiline text produced the gnuplot
+        ##        "warning: ft_render: skipping glyph"
+        if (nd == 3)
+          ## This produces the desired vertical alignment in 3D.
+          fprintf (plot_stream,
+                   "set label \"%s\" at %s %.15e,%.15e,%.15e %s rotate by %f offset character %f,%f %s %s front %s;\n",
+                   undo_string_escapes (label), units, lpos(1),
+                   lpos(2), lpos(3), halign, angle, dx_and_dy, fontspec,
+                   __do_enhanced_option__ (enhanced, obj), colorspec);
+        else
+          fprintf (plot_stream,
+                   "set label \"%s\" at %s %.15e,%.15e %s rotate by %f offset character %f,%f %s %s front %s;\n",
+                   undo_string_escapes (label), units,
+                   lpos(1), lpos(2), halign, angle, dx_and_dy, fontspec,
+                   __do_enhanced_option__ (enhanced, obj), colorspec);
+        endif
+
+      case "hggroup"
+        ## Push group children into the kid list.
+        if (isempty (kids))
+          kids = obj.children;
+        elseif (! isempty (obj.children))
+          kids = [kids; obj.children];
+        endif
+
+      otherwise
+        error ("__go_draw_axes__: unknown object class, %s",
+               obj.type);
+    endswitch
+
+  endwhile
 
-          ## FIXME: Multiline text produced the gnuplot
-          ##        "warning: ft_render: skipping glyph"
-          if (nd == 3)
-            ## This produces the desired vertical alignment in 3D.
-            fprintf (plot_stream,
-                     "set label \"%s\" at %s %.15e,%.15e,%.15e %s rotate by %f offset character %f,%f %s %s front %s;\n",
-                     undo_string_escapes (label), units, lpos(1),
-                     lpos(2), lpos(3), halign, angle, dx_and_dy, fontspec,
-                     __do_enhanced_option__ (enhanced, obj), colorspec);
-          else
-            fprintf (plot_stream,
-                     "set label \"%s\" at %s %.15e,%.15e %s rotate by %f offset character %f,%f %s %s front %s;\n",
-                     undo_string_escapes (label), units,
-                     lpos(1), lpos(2), halign, angle, dx_and_dy, fontspec,
-                     __do_enhanced_option__ (enhanced, obj), colorspec);
-          endif
+  ## This is need to prevent warnings for rotations in 3D plots, while
+  ## allowing colorbars with contours.
+  if (nd == 2 || (data_idx > 1 && !view_map))
+    fputs (plot_stream, "set pm3d implicit;\n");
+  else
+    fputs (plot_stream, "set pm3d explicit;\n");
+  endif
 
-        case "hggroup"
-          ## Push group children into the kid list.
-          if (isempty (kids))
-            kids = obj.children;
-          elseif (! isempty (obj.children))
-            kids = [kids; obj.children];
-          endif
+  if (isnan (hidden_removal) || hidden_removal)
+    fputs (plot_stream, "set hidden3d;\n");
+  else
+    fputs (plot_stream, "unset hidden3d;\n");
+  endif
+
+  have_data = (! (isempty (data) || all (cellfun ("isempty", data))));
 
-        otherwise
-          error ("__go_draw_axes__: unknown object class, %s",
-                 obj.type);
-      endswitch
-
-    endwhile
+  ## Note we don't use the [xy]2range of gnuplot as we don't use the
+  ## dual axis plotting features of gnuplot.
+  if (isempty (xlim))
+    return;
+  endif
+  if (strcmpi (axis_obj.xdir, "reverse"))
+    xdir = "reverse";
+  else
+    xdir = "noreverse";
+  endif
+  fprintf (plot_stream, "set xrange [%.15e:%.15e] %s;\n", xlim, xdir);
+  if (strcmpi (axis_obj.xaxislocation, "top"))
+    fprintf (plot_stream, "set x2range [%.15e:%.15e] %s;\n", xlim, xdir);
+  endif
 
-    ## This is need to prevent warnings for rotations in 3D plots, while
-    ## allowing colorbars with contours.
-    if (nd == 2 || (data_idx > 1 && !view_map))
-      fputs (plot_stream, "set pm3d implicit;\n");
-    else
-      fputs (plot_stream, "set pm3d explicit;\n");
-    endif
+  if (isempty (ylim))
+    return;
+  endif
+  if (strcmpi (axis_obj.ydir, "reverse"))
+    ydir = "reverse";
+  else
+    ydir = "noreverse";
+  endif
+  fprintf (plot_stream, "set yrange [%.15e:%.15e] %s;\n", ylim, ydir);
+  if (strcmpi (axis_obj.yaxislocation, "right"))
+    fprintf (plot_stream, "set y2range [%.15e:%.15e] %s;\n", ylim, ydir);
+  endif
 
-    if (isnan (hidden_removal) || hidden_removal)
-      fputs (plot_stream, "set hidden3d;\n");
-    else
-      fputs (plot_stream, "unset hidden3d;\n");
-    endif
-
-    have_data = (! (isempty (data) || all (cellfun ("isempty", data))));
-
-    ## Note we don't use the [xy]2range of gnuplot as we don't use the
-    ## dual axis plotting features of gnuplot.
-    if (isempty (xlim))
+  if (nd == 3)
+    if (isempty (zlim))
       return;
     endif
-    if (strcmpi (axis_obj.xdir, "reverse"))
-      xdir = "reverse";
+    if (strcmpi (axis_obj.zdir, "reverse"))
+      zdir = "reverse";
     else
-      xdir = "noreverse";
-    endif
-    fprintf (plot_stream, "set xrange [%.15e:%.15e] %s;\n", xlim, xdir);
-    if (strcmpi (axis_obj.xaxislocation, "top"))
-      fprintf (plot_stream, "set x2range [%.15e:%.15e] %s;\n", xlim, xdir);
-    endif
-
-    if (isempty (ylim))
-      return;
+      zdir = "noreverse";
     endif
-    if (strcmpi (axis_obj.ydir, "reverse"))
-      ydir = "reverse";
-    else
-      ydir = "noreverse";
-    endif
-    fprintf (plot_stream, "set yrange [%.15e:%.15e] %s;\n", ylim, ydir);
-    if (strcmpi (axis_obj.yaxislocation, "right"))
-      fprintf (plot_stream, "set y2range [%.15e:%.15e] %s;\n", ylim, ydir);
-    endif
+    fprintf (plot_stream, "set zrange [%.15e:%.15e] %s;\n", zlim, zdir);
+  endif
 
-    if (nd == 3)
-      if (isempty (zlim))
-        return;
-      endif
-      if (strcmpi (axis_obj.zdir, "reverse"))
-        zdir = "reverse";
+  cmap = parent_figure_obj.colormap;
+  cmap_sz = rows (cmap);
+  if (! any (isinf (clim)))
+    if (truecolor || ! cdatadirect)
+      if (rows (addedcmap) > 0)
+        for i = 1:data_idx
+          if (have_3d_patch(i))
+            data{i}(end,:) = clim(2) * (data{i}(end, :) - 0.5) / cmap_sz;
+           endif
+        endfor
+        fprintf (plot_stream, "set cbrange [%.15e:%.15e];\n", clim(1), clim(2) *
+                 (cmap_sz + rows (addedcmap)) / cmap_sz);
       else
-        zdir = "noreverse";
-      endif
-      fprintf (plot_stream, "set zrange [%.15e:%.15e] %s;\n", zlim, zdir);
-    endif
-
-    cmap = parent_figure_obj.colormap;
-    cmap_sz = rows (cmap);
-    if (! any (isinf (clim)))
-      if (truecolor || ! cdatadirect)
-        if (rows (addedcmap) > 0)
-          for i = 1:data_idx
-            if (have_3d_patch(i))
-              data{i}(end,:) = clim(2) * (data{i}(end, :) - 0.5) / cmap_sz;
-             endif
-          endfor
-          fprintf (plot_stream, "set cbrange [%.15e:%.15e];\n", clim(1), clim(2) *
-                   (cmap_sz + rows (addedcmap)) / cmap_sz);
-        else
-          fprintf (plot_stream, "set cbrange [%.15e:%.15e];\n", clim);
-        endif
-      else
-        fprintf (plot_stream, "set cbrange [1:%d];\n", cmap_sz +
-                 rows (addedcmap));
-      endif
-    endif
-
-    if (strcmpi (axis_obj.box, "on"))
-      if (nd == 3)
-        fputs (plot_stream, "set border 4095;\n");
-      else
-        fputs (plot_stream, "set border 431;\n");
+        fprintf (plot_stream, "set cbrange [%.15e:%.15e];\n", clim);
       endif
     else
-      if (nd == 3)
-        fputs (plot_stream, "set border 895;\n");
-      elseif (! isempty (axis_obj.ytick))
-        if (strcmpi (axis_obj.yaxislocation, "right"))
-          fprintf (plot_stream, "unset ytics; set y2tics %s nomirror\n",
+      fprintf (plot_stream, "set cbrange [1:%d];\n", cmap_sz +
+               rows (addedcmap));
+    endif
+  endif
+
+  if (strcmpi (axis_obj.box, "on"))
+    if (nd == 3)
+      fputs (plot_stream, "set border 4095;\n");
+    else
+      fputs (plot_stream, "set border 431;\n");
+    endif
+  else
+    if (nd == 3)
+      fputs (plot_stream, "set border 895;\n");
+    elseif (! isempty (axis_obj.ytick))
+      if (strcmpi (axis_obj.yaxislocation, "right"))
+        fprintf (plot_stream, "unset ytics; set y2tics %s nomirror\n",
+                 axis_obj.tickdir);
+        if (strcmpi (axis_obj.xaxislocation, "top"))
+          fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "set border 12;\n");
+        elseif (strcmpi (axis_obj.xaxislocation, "bottom"))
+          fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "set border 9;\n");
+        else # xaxislocation == zero
+          fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
                    axis_obj.tickdir);
-          if (strcmpi (axis_obj.xaxislocation, "top"))
-            fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 12;\n");
-          elseif (strcmpi (axis_obj.xaxislocation, "bottom"))
-            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 9;\n");
-          else # xaxislocation == zero
-            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 8;\n");
-            fprintf (plot_stream, "set xzeroaxis lt -1 lw %f;\n",
-                     axis_obj.linewidth);
-          endif
-        elseif (strcmpi (axis_obj.yaxislocation, "left"))
-          fprintf (plot_stream, "unset y2tics; set ytics %s nomirror\n",
+          fputs (plot_stream, "set border 8;\n");
+          fprintf (plot_stream, "set xzeroaxis lt -1 lw %f;\n",
+                   axis_obj.linewidth);
+        endif
+      elseif (strcmpi (axis_obj.yaxislocation, "left"))
+        fprintf (plot_stream, "unset y2tics; set ytics %s nomirror\n",
+                 axis_obj.tickdir);
+        if (strcmpi (axis_obj.xaxislocation, "top"))
+          fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "set border 6;\n");
+        elseif (strcmpi (axis_obj.xaxislocation, "bottom"))
+          fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
                    axis_obj.tickdir);
-          if (strcmpi (axis_obj.xaxislocation, "top"))
-            fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 6;\n");
-          elseif (strcmpi (axis_obj.xaxislocation, "bottom"))
-            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 3;\n");
-          else # xaxislocation == zero
-            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 2;\n");
-            fprintf (plot_stream, "set xzeroaxis lt -1 lw %f;\n",
-                     axis_obj.linewidth);
-          endif
-        else # yaxislocation == zero
+          fputs (plot_stream, "set border 3;\n");
+        else # xaxislocation == zero
+          fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "set border 2;\n");
+          fprintf (plot_stream, "set xzeroaxis lt -1 lw %f;\n",
+                   axis_obj.linewidth);
+        endif
+      else # yaxislocation == zero
+        fprintf (plot_stream, "unset y2tics; set ytics %s nomirror\n",
+                 axis_obj.tickdir);
+        if (strcmpi (axis_obj.xaxislocation, "top"))
+          fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "set border 4;\n");
+        elseif (strcmpi (axis_obj.xaxislocation, "bottom"))
+          fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "set border 1;\n");
+        else # xaxislocation == zero
           fprintf (plot_stream, "unset y2tics; set ytics %s nomirror\n",
                    axis_obj.tickdir);
-          if (strcmpi (axis_obj.xaxislocation, "top"))
-            fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 4;\n");
-          elseif (strcmpi (axis_obj.xaxislocation, "bottom"))
-            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 1;\n");
-          else # xaxislocation == zero
-            fprintf (plot_stream, "unset y2tics; set ytics %s nomirror\n",
-                     axis_obj.tickdir);
-            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "unset border;\n");
-            fprintf (plot_stream, "set xzeroaxis lt -1 lw %f;\n",
-                     axis_obj.linewidth);
-          endif
-          fprintf (plot_stream, "set yzeroaxis lt -1 lw %f;\n",
+          fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "unset border;\n");
+          fprintf (plot_stream, "set xzeroaxis lt -1 lw %f;\n",
                    axis_obj.linewidth);
         endif
+        fprintf (plot_stream, "set yzeroaxis lt -1 lw %f;\n",
+                 axis_obj.linewidth);
+      endif
+    endif
+  endif
+
+  if (strcmpi (axis_obj.visible, "off"))
+    fputs (plot_stream, "unset border; unset tics\n");
+  else
+    fprintf (plot_stream, "set border lw %f;\n", axis_obj.linewidth);
+  endif
+
+  if (! isempty (hlgnd) && ! isempty (hlgnd.children)
+      && any (strcmpi (get (hlgnd.children, "visible"), "on")))
+    if (strcmpi (hlgnd.box, "on"))
+      box = "box";
+    else
+      box = "nobox";
+    endif
+    if (strcmpi (hlgnd.orientation, "vertical"))
+      horzvert = "vertical";
+    else
+      horzvert = "horizontal";
+    endif
+    if (strcmpi (hlgnd.textposition, "right"))
+      reverse = "reverse";
+    else
+      reverse = "noreverse";
+    endif
+    inout = "inside";
+    keypos = hlgnd.location;
+    if (ischar (keypos))
+      keypos = lower (keypos);
+      keyout = strfind (keypos, "outside");
+      if (! isempty (keyout))
+        inout = "outside";
+        keypos = keypos(1:keyout-1);
       endif
     endif
-
-    if (strcmpi (axis_obj.visible, "off"))
-      fputs (plot_stream, "unset border; unset tics\n");
+    switch (keypos)
+      case "north"
+        pos = "center top";
+      case "south"
+        pos = "center bottom";
+      case "east"
+        pos = "right center";
+      case "west"
+        pos = "left center";
+      case "northeast"
+        pos = "right top";
+      case "northwest"
+        pos = "left top";
+      case "southeast"
+        pos = "right bottom";
+      case "southwest"
+        pos = "left bottom";
+      case "best"
+        pos = "";
+        warning ("legend: 'Best' not yet implemented for location specifier.\n");
+        ## Least conflict with data in plot.
+        ## Least unused space outside plot.
+      otherwise
+        pos = "";
+    endswitch
+    if (__gnuplot_has_feature__ ("key_has_font_properties"))
+      [fontname, fontsize] = get_fontname_and_size (hlgnd);
+      fontspec = create_fontspec (fontname, fontsize, gnuplot_term);
     else
-      fprintf (plot_stream, "set border lw %f;\n", axis_obj.linewidth);
+      fontspec = "";
+    endif
+    textcolors = get (findobj (hlgnd.children, "type", "text"), "color");
+    if (iscell (textcolors))
+      textcolors = cell2mat (textcolors);
+      textcolors = unique (textcolors, "rows");
     endif
+    if (rows (textcolors) > 1)
+      ## Gnuplot is unable to assign arbitrary colors to each text entry
+      ## for the key/legend.  But, the text color can be set to match the
+      ## color of the plot object.
+      colorspec = "textcolor variable";
+    else
+      colorspec = get_text_colorspec (textcolors, mono);
+    endif
+    fprintf (plot_stream, "set key %s %s;\nset key %s %s %s %s %s;\n",
+             inout, pos, box, reverse, horzvert, fontspec, colorspec);
+  else
+    fputs (plot_stream, "unset key;\n");
+  endif
+  fputs (plot_stream, "set style data lines;\n");
 
-    if (! isempty (hlgnd) && ! isempty (hlgnd.children)
-        && any (strcmpi (get (hlgnd.children, "visible"), "on")))
-      if (strcmpi (hlgnd.box, "on"))
-        box = "box";
+  cmap = [cmap; addedcmap];
+  cmap_sz = cmap_sz + rows (addedcmap);
+  if (length (cmap) > 0)
+    fprintf (plot_stream,
+             "set palette positive color model RGB maxcolors %i;\n",
+             cmap_sz);
+    fprintf (plot_stream,
+             "set palette file \"-\" binary record=%d using 1:2:3:4;\n",
+             cmap_sz);
+    fwrite (plot_stream, [1:cmap_sz; cmap.'], "float32");
+    fwrite (plot_stream, "\n");
+  endif
+
+  fputs (plot_stream, "unset colorbox;\n");
+
+  if (have_data)
+    if (nd == 2)
+      plot_cmd = "plot";
+    else
+      plot_cmd = "splot";
+      rot_x = 90 - axis_obj.view(2);
+      rot_z = axis_obj.view(1);
+      while (rot_z < 0)
+        rot_z += 360;
+      endwhile
+      fputs (plot_stream, "set ticslevel 0;\n");
+      if (view_map && rot_x == 0 && rot_z == 0)
+        fputs (plot_stream, "set view map;\n");
       else
-        box = "nobox";
+        fprintf (plot_stream, "set view %.15g, %.15g;\n", rot_x, rot_z);
       endif
-      if (strcmpi (hlgnd.orientation, "vertical"))
-        horzvert = "vertical";
-      else
-        horzvert = "horizontal";
-      endif
-      if (strcmpi (hlgnd.textposition, "right"))
-        reverse = "reverse";
-      else
-        reverse = "noreverse";
-      endif
-      inout = "inside";
-      keypos = hlgnd.location;
-      if (ischar (keypos))
-        keypos = lower (keypos);
-        keyout = strfind (keypos, "outside");
-        if (! isempty (keyout))
-          inout = "outside";
-          keypos = keypos(1:keyout-1);
+    endif
+    if (have_3d_patch (1))
+      fputs (plot_stream, "set pm3d depthorder\n");
+      fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
+               usingclause{1}, titlespec{1}, withclause{1});
+    elseif (is_image_data (1))
+      if (numel (is_image_data) > 1 && is_image_data(2))
+        ## Remove terminating semicolon
+        n = max (strfind (withclause{1}, ";"));
+        if (! isempty (n))
+          withclause{1} = withclause{1}(1:n-1);
         endif
       endif
-      switch (keypos)
-        case "north"
-          pos = "center top";
-        case "south"
-          pos = "center bottom";
-        case "east"
-          pos = "right center";
-        case "west"
-          pos = "left center";
-        case "northeast"
-          pos = "right top";
-        case "northwest"
-          pos = "left top";
-        case "southeast"
-          pos = "right bottom";
-        case "southwest"
-          pos = "left bottom";
-        case "best"
-          pos = "";
-          warning ("legend: 'Best' not yet implemented for location specifier.\n");
-          ## Least conflict with data in plot.
-          ## Least unused space outside plot.
-        otherwise
-          pos = "";
-      endswitch
-      if (__gnuplot_has_feature__ ("key_has_font_properties"))
-        [fontname, fontsize] = get_fontname_and_size (hlgnd);
-        fontspec = create_fontspec (fontname, fontsize, gnuplot_term);
-      else
-        fontspec = "";
-      endif
-      textcolors = get (findobj (hlgnd.children, "type", "text"), "color");
-      if (iscell (textcolors))
-        textcolors = cell2mat (textcolors);
-        textcolors = unique (textcolors, "rows");
-      endif
-      if (rows (textcolors) > 1)
-        ## Gnuplot is unable to assign arbitrary colors to each text entry
-        ## for the key/legend.  But, the text color can be set to match the
-        ## color of the plot object.
-        colorspec = "textcolor variable";
-      else
-        colorspec = get_text_colorspec (textcolors, mono);
-      endif
-      fprintf (plot_stream, "set key %s %s;\nset key %s %s %s %s %s;\n",
-               inout, pos, box, reverse, horzvert, fontspec, colorspec);
+      fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
+               usingclause{1}, titlespec{1}, withclause{1});
     else
-      fputs (plot_stream, "unset key;\n");
-    endif
-    fputs (plot_stream, "set style data lines;\n");
-
-    cmap = [cmap; addedcmap];
-    cmap_sz = cmap_sz + rows (addedcmap);
-    if (length (cmap) > 0)
-      fprintf (plot_stream,
-               "set palette positive color model RGB maxcolors %i;\n",
-               cmap_sz);
-      fprintf (plot_stream,
-               "set palette file \"-\" binary record=%d using 1:2:3:4;\n",
-               cmap_sz);
-      fwrite (plot_stream, [1:cmap_sz; cmap.'], "float32");
-      fwrite (plot_stream, "\n");
+      fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
+               usingclause{1}, titlespec{1}, withclause{1});
     endif
-
-    fputs (plot_stream, "unset colorbox;\n");
-
-    if (have_data)
-      if (nd == 2)
-        plot_cmd = "plot";
-      else
-        plot_cmd = "splot";
-        rot_x = 90 - axis_obj.view(2);
-        rot_z = axis_obj.view(1);
-        while (rot_z < 0)
-          rot_z += 360;
-        endwhile
-        fputs (plot_stream, "set ticslevel 0;\n");
-        if (view_map && rot_x == 0 && rot_z == 0)
-          fputs (plot_stream, "set view map;\n");
-        else
-          fprintf (plot_stream, "set view %.15g, %.15g;\n", rot_x, rot_z);
-        endif
-      endif
-      if (have_3d_patch (1))
-        fputs (plot_stream, "set pm3d depthorder\n");
-        fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
-                 usingclause{1}, titlespec{1}, withclause{1});
-      elseif (is_image_data (1))
-        if (numel (is_image_data) > 1 && is_image_data(2))
-          ## Remove terminating semicolon
-          n = max (strfind (withclause{1}, ";"));
-          if (! isempty (n))
-            withclause{1} = withclause{1}(1:n-1);
-          endif
-        endif
-        fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
-                 usingclause{1}, titlespec{1}, withclause{1});
-      else
-        fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
-                 usingclause{1}, titlespec{1}, withclause{1});
-      endif
-      for i = 2:data_idx
-        if (have_3d_patch (i))
-          fprintf (plot_stream, ", \"-\" %s %s %s \\\n",
-                   usingclause{i}, titlespec{i}, withclause{i});
-        elseif (is_image_data (i))
-          if (! is_image_data (i-1))
-            fputs (plot_stream, "; ");
-            if (bg_is_set)
-              fputs (plot_stream, "unset obj 1; \\\n");
-              bg_is_set = false;
-            endif
-            if (fg_is_set)
-              fputs (plot_stream, "unset obj 2; \\\n");
-              fg_is_set = false;
-            endif
-            if (numel (is_image_data) > i && is_image_data(i+1))
-              ## Remove terminating semicolon
-              n = max (strfind (withclause{i}, ";"));
-              if (! isempty (n))
-                withclause{i} = withclause{i}(1:n-1);
-              endif
-            endif
-            fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
-                     usingclause{i}, titlespec{i}, withclause{i});
-          else
-            ## For consecutive images continue with the same plot command
-            fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", ",",
-                     usingclause{i}, titlespec{i}, withclause{i});
-          endif
-        elseif (is_image_data (i-1))
+    for i = 2:data_idx
+      if (have_3d_patch (i))
+        fprintf (plot_stream, ", \"-\" %s %s %s \\\n",
+                 usingclause{i}, titlespec{i}, withclause{i});
+      elseif (is_image_data (i))
+        if (! is_image_data (i-1))
+          fputs (plot_stream, "; ");
           if (bg_is_set)
             fputs (plot_stream, "unset obj 1; \\\n");
             bg_is_set = false;
           endif
           if (fg_is_set)
             fputs (plot_stream, "unset obj 2; \\\n");
             fg_is_set = false;
           endif
-          fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
+          if (numel (is_image_data) > i && is_image_data(i+1))
+            ## Remove terminating semicolon
+            n = max (strfind (withclause{i}, ";"));
+            if (! isempty (n))
+              withclause{i} = withclause{i}(1:n-1);
+            endif
+          endif
+          fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
                    usingclause{i}, titlespec{i}, withclause{i});
         else
-          fprintf (plot_stream, ", \"-\" binary format='%%float64' %s %s %s \\\n",
+          ## For consecutive images continue with the same plot command
+          fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", ",",
                    usingclause{i}, titlespec{i}, withclause{i});
         endif
-      endfor
-      fputs (plot_stream, ";\n");
-      for i = 1:data_idx
-        if (have_3d_patch (i))
-          ## Can't write 3d patch data as binary as can't plot more than
-          ## a single patch at a time and have to plot all patches together
-          ## so that the gnuplot depth ordering is done correctly
-          for j = 1 : 4 : columns (data{i})
-            if (j != 1)
-              fputs (plot_stream, "\n\n");
-            endif
-            fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j).');
-            fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n\n", data{i}(:,j+1).');
-            fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+2).');
-            fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+3).');
-          endfor
-          fputs (plot_stream, "e\n");
-        elseif (is_image_data(i))
-          fwrite (plot_stream, data{i}, "float32");
-        else
-          __gnuplot_write_data__ (plot_stream, data{i}, nd, parametric(i),
-                                  have_cdata(i));
+      elseif (is_image_data (i-1))
+        if (bg_is_set)
+          fputs (plot_stream, "unset obj 1; \\\n");
+          bg_is_set = false;
+        endif
+        if (fg_is_set)
+          fputs (plot_stream, "unset obj 2; \\\n");
+          fg_is_set = false;
         endif
-      endfor
-    else
-      fputs (plot_stream, "plot \"-\";\nInf Inf\ne\n");
-    endif
-
-    ## Needed to allow mouse rotation with pcolor.
-    if (view_map)
-      fputs (plot_stream, "unset view;\n");
-    endif
+        fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
+                 usingclause{i}, titlespec{i}, withclause{i});
+      else
+        fprintf (plot_stream, ", \"-\" binary format='%%float64' %s %s %s \\\n",
+                 usingclause{i}, titlespec{i}, withclause{i});
+      endif
+    endfor
+    fputs (plot_stream, ";\n");
+    for i = 1:data_idx
+      if (have_3d_patch (i))
+        ## Can't write 3d patch data as binary as can't plot more than
+        ## a single patch at a time and have to plot all patches together
+        ## so that the gnuplot depth ordering is done correctly
+        for j = 1 : 4 : columns (data{i})
+          if (j != 1)
+            fputs (plot_stream, "\n\n");
+          endif
+          fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j).');
+          fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n\n", data{i}(:,j+1).');
+          fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+2).');
+          fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+3).');
+        endfor
+        fputs (plot_stream, "e\n");
+      elseif (is_image_data(i))
+        fwrite (plot_stream, data{i}, "float32");
+      else
+        __gnuplot_write_data__ (plot_stream, data{i}, nd, parametric(i),
+                                have_cdata(i));
+      endif
+    endfor
+  else
+    fputs (plot_stream, "plot \"-\";\nInf Inf\ne\n");
+  endif
 
-    if (bg_is_set)
-      fputs (plot_stream, "unset obj 1;\n");
-      bg_is_set = false;
-    endif
+  ## Needed to allow mouse rotation with pcolor.
+  if (view_map)
+    fputs (plot_stream, "unset view;\n");
+  endif
 
-    fflush (plot_stream);
+  if (bg_is_set)
+    fputs (plot_stream, "unset obj 1;\n");
+    bg_is_set = false;
+  endif
 
-  else
-    print_usage ();
-  endif
+  fflush (plot_stream);
 
 endfunction
 
 function x = flip (x)
   if (rows (x) == 1)
     x = fliplr (x);
   elseif (columns (x) == 1 || ischar (x))
     x = flipud (x);
diff --git a/scripts/plot/private/__go_draw_figure__.m b/scripts/plot/private/__go_draw_figure__.m
--- a/scripts/plot/private/__go_draw_figure__.m
+++ b/scripts/plot/private/__go_draw_figure__.m
@@ -20,191 +20,187 @@
 ## @deftypefn {Function File} {} __go_draw_figure__ (@var{h}, @var{plot_stream}, @var{enhanced}, @var{mono})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function __go_draw_figure__ (h, plot_stream, enhanced, mono)
 
-  if (nargin == 4)
-    htype = get (h, "type");
-    if (strcmp (htype, "figure"))
-      ## Get complete list of children.
-      kids = allchild (h);
-      nkids = length (kids);
+  htype = get (h, "type");
+  if (strcmp (htype, "figure"))
+    ## Get complete list of children.
+    kids = allchild (h);
+    nkids = length (kids);
 
-      if (nkids > 0)
-        fputs (plot_stream, "\nreset;\n");
-        fputs (plot_stream, "set autoscale keepfix;\n");
-        fputs (plot_stream, "set origin 0, 0\n");
-        fputs (plot_stream, "set size 1, 1\n");
-        bg = get (h, "color");
-        if (isnumeric (bg))
-          fprintf (plot_stream, "set obj 1 rectangle from screen 0,0 to screen 1,1 behind fc rgb \"#%02x%02x%02x\"\n", 255 * bg);
-          bg_is_set = true;
-        else
-          bg_is_set = false;
-        endif
-        fg_was_set = false;
+    if (nkids > 0)
+      fputs (plot_stream, "\nreset;\n");
+      fputs (plot_stream, "set autoscale keepfix;\n");
+      fputs (plot_stream, "set origin 0, 0\n");
+      fputs (plot_stream, "set size 1, 1\n");
+      bg = get (h, "color");
+      if (isnumeric (bg))
+        fprintf (plot_stream, "set obj 1 rectangle from screen 0,0 to screen 1,1 behind fc rgb \"#%02x%02x%02x\"\n", 255 * bg);
+        bg_is_set = true;
+      else
+        bg_is_set = false;
+      endif
+      fg_was_set = false;
 
-        for i = nkids:-1:1
-          type = get (kids(i), "type");
-          switch (type)
-            case "axes"
-              if (strcmpi (get (kids (i), "tag"), "legend"))
-                ## This is so ugly. If there was a way of getting
-                ## gnuplot to give us the text extents of strings
-                ## then we could get rid of this mess.
-                lh = getfield (get (kids(i), "userdata"), "handle");
-                if (isscalar (lh))
-                  ## We have a legend with a single parent. It'll be handled
-                  ## below as a gnuplot key to the axis it corresponds to
-                  continue;
-                else
-                  ca = lh(1);
-                  ## Rely upon listener to convert axes position
-                  ## to "normalized" units.
-                  legend_axes_units = get (kids(i), "units");
-                  legend_axes_position = get (kids(i), "position");
-                  legend_axes_outerposition = get (kids(i), "outerposition");
-                  legend_axes_box = get (kids(i), "box");
-                  legend_axes_ylim = get (kids(i), "ylim");
-                  orig_axes_units = get (ca, "units");
-                  hlgnd = get (kids(i));
+      for i = nkids:-1:1
+        type = get (kids(i), "type");
+        switch (type)
+          case "axes"
+            if (strcmpi (get (kids (i), "tag"), "legend"))
+              ## This is so ugly. If there was a way of getting
+              ## gnuplot to give us the text extents of strings
+              ## then we could get rid of this mess.
+              lh = getfield (get (kids(i), "userdata"), "handle");
+              if (isscalar (lh))
+                ## We have a legend with a single parent. It'll be handled
+                ## below as a gnuplot key to the axis it corresponds to
+                continue;
+              else
+                ca = lh(1);
+                ## Rely upon listener to convert axes position
+                ## to "normalized" units.
+                legend_axes_units = get (kids(i), "units");
+                legend_axes_position = get (kids(i), "position");
+                legend_axes_outerposition = get (kids(i), "outerposition");
+                legend_axes_box = get (kids(i), "box");
+                legend_axes_ylim = get (kids(i), "ylim");
+                orig_axes_units = get (ca, "units");
+                hlgnd = get (kids(i));
 
-                  unwind_protect
-                    set (ca, "units", "normalized");
-                    set (kids(i), "units", "normalized", "box", "off",
-                         "ylim", [-2, -1], "position", get (ca(1), "position"),
-                         "outerposition", get (ca(1), "outerposition"));
+                unwind_protect
+                  set (ca, "units", "normalized");
+                  set (kids(i), "units", "normalized", "box", "off",
+                       "ylim", [-2, -1], "position", get (ca(1), "position"),
+                       "outerposition", get (ca(1), "outerposition"));
 
-                    ## Create a new set of lines with the appropriate
-                    ## displaynames, etc
-                    toberm = [];
-                    hobj = get (kids(i), "children");
-                    for j = numel (hobj) : -1 : 1
-                      if (! strcmp (get (hobj(j), "type"), "text"))
+                  ## Create a new set of lines with the appropriate
+                  ## displaynames, etc
+                  toberm = [];
+                  hobj = get (kids(i), "children");
+                  for j = numel (hobj) : -1 : 1
+                    if (! strcmp (get (hobj(j), "type"), "text"))
+                      continue;
+                    endif
+                    displayname = get (hobj(j), "string");
+                    ll = [];
+                    lm = [];
+                    for k = numel (hobj) : -1 : 1
+                      if (! strcmp (get (hobj(k), "type"), "line"))
                         continue;
                       endif
-                      displayname = get (hobj(j), "string");
-                      ll = [];
-                      lm = [];
-                      for k = numel (hobj) : -1 : 1
-                        if (! strcmp (get (hobj(k), "type"), "line"))
-                          continue;
-                        endif
-                        if (get (hobj(j), "userdata")
-                            != get (hobj(k), "userdata"))
-                          continue;
-                        endif
-                        if (! strcmp (get (hobj(k), "linestyle"), "none"))
-                          ll = hobj(k);
-                        endif
-                        if (! strcmp (get (hobj(k), "marker"), "none"))
-                          lm = hobj(k);
-                        endif
-                      endfor
-
-                      if (! isempty (ll))
-                        if (!isempty (lm))
-                          toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(lm,"color"), "linestyle", get(ll,"linestyle"), "marker", get(lm,"marker"), "markeredgecolor", get(lm,"markeredgecolor"), "markerfacecolor", get(lm,"markerfacecolor"), "markersize", get (lm, "markersize"), "displayname", displayname, "parent", kids(i))];
-                        else
-                          toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(ll,"color"), "linestyle", get(ll,"linestyle"), "marker", "none", "displayname", displayname, "parent", kids(i))];
-                        endif
-                      elseif (! isempty (lm))
-                        toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(lm,"color"), "linestyle", "none", "marker", get(lm,"marker"), "markeredgecolor", get(lm,"markeredgecolor"), "markerfacecolor", get(lm,"markerfacecolor"), "markersize", get (lm, "markersize"), "displayname", displayname, "parent", kids(i))];
+                      if (get (hobj(j), "userdata")
+                          != get (hobj(k), "userdata"))
+                        continue;
+                      endif
+                      if (! strcmp (get (hobj(k), "linestyle"), "none"))
+                        ll = hobj(k);
+                      endif
+                      if (! strcmp (get (hobj(k), "marker"), "none"))
+                        lm = hobj(k);
                       endif
                     endfor
-                    if (bg_is_set)
-                      fprintf (plot_stream, "set border linecolor rgb \"#%02x%02x%02x\"\n", 255 * (1 - bg));
+
+                    if (! isempty (ll))
+                      if (!isempty (lm))
+                        toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(lm,"color"), "linestyle", get(ll,"linestyle"), "marker", get(lm,"marker"), "markeredgecolor", get(lm,"markeredgecolor"), "markerfacecolor", get(lm,"markerfacecolor"), "markersize", get (lm, "markersize"), "displayname", displayname, "parent", kids(i))];
+                      else
+                        toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(ll,"color"), "linestyle", get(ll,"linestyle"), "marker", "none", "displayname", displayname, "parent", kids(i))];
+                      endif
+                    elseif (! isempty (lm))
+                      toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(lm,"color"), "linestyle", "none", "marker", get(lm,"marker"), "markeredgecolor", get(lm,"markeredgecolor"), "markerfacecolor", get(lm,"markerfacecolor"), "markersize", get (lm, "markersize"), "displayname", displayname, "parent", kids(i))];
                     endif
-                    __go_draw_axes__ (kids(i), plot_stream, enhanced, mono,
-                                      bg_is_set, false, hlgnd);
-                  unwind_protect_cleanup
-                    ## Return axes "units" and "position" back to
-                    ## their original values.
-                    set (ca, "units", orig_axes_units);
-                    set (kids(i), "units", legend_axes_units,
-                         "box", legend_axes_box,
-                         "ylim", legend_axes_ylim,
-                         "position", legend_axes_position,
-                         "outerposition", legend_axes_outerposition);
-                    delete (toberm);
-                    bg_is_set = false;
-                  end_unwind_protect
-                endif
-              else
-                ## Rely upon listener to convert axes position
-                ## to "normalized" units.
-                orig_axes_units = get (kids(i), "units");
-                orig_axes_position = get (kids(i), "position");
-                unwind_protect
-                  set (kids(i), "units", "normalized");
-                  fg = get (kids(i), "color");
-                  if (isnumeric (fg) && strcmp (get (kids(i), "visible"), "on"))
-                    fprintf (plot_stream, "set obj 2 rectangle from graph 0,0 to graph 1,1 behind fc rgb \"#%02x%02x%02x\"\n", 255 * fg);
-                    fg_is_set = true;
-                    fg_was_set = true;
-                  elseif (fg_was_set)
-                    fprintf (plot_stream, "unset obj 2\n");
-                    fg_is_set = false;
-                    fg_was_set = false;
-                  else
-                    fg_is_set = false;
-                  endif
+                  endfor
                   if (bg_is_set)
                     fprintf (plot_stream, "set border linecolor rgb \"#%02x%02x%02x\"\n", 255 * (1 - bg));
                   endif
-                  ## Find if this axes has an associated legend axes and pass it
-                  ## to __go_draw_axes__
-                  hlegend = [];
-                  fkids = get (h, "children");
-                  for j = 1 : numel (fkids)
-                    if (ishandle (fkids (j))
-                        && strcmp (get (fkids (j), "type"), "axes")
-                        && (strcmp (get (fkids (j), "tag"), "legend")))
-                      udata = get (fkids (j), "userdata");
-                      if (isscalar (udata.handle)
-                          && ! isempty (intersect (udata.handle, kids (i))))
-                        hlegend = get (fkids (j));
-                        break;
-                      endif
-                    endif
-                  endfor
                   __go_draw_axes__ (kids(i), plot_stream, enhanced, mono,
-                                    bg_is_set, fg_is_set, hlegend);
+                                    bg_is_set, false, hlgnd);
                 unwind_protect_cleanup
                   ## Return axes "units" and "position" back to
                   ## their original values.
-                  set (kids(i), "units", orig_axes_units);
-                  set (kids(i), "position", orig_axes_position);
+                  set (ca, "units", orig_axes_units);
+                  set (kids(i), "units", legend_axes_units,
+                       "box", legend_axes_box,
+                       "ylim", legend_axes_ylim,
+                       "position", legend_axes_position,
+                       "outerposition", legend_axes_outerposition);
+                  delete (toberm);
                   bg_is_set = false;
-                  fg_is_set = false;
                 end_unwind_protect
               endif
-            case "uimenu"
-              ## ignore uimenu objects
-              kids(i) = [];
-            otherwise
-              error ("__go_draw_figure__: unknown object class, %s", type);
-          endswitch
-        endfor
-        if (isempty (kids))
-          fputs (plot_stream, "\nreset; clear;\n");
-          fflush (plot_stream);
-        else
-          fputs (plot_stream, "\nunset multiplot;\n");
-        endif
-      else
+            else
+              ## Rely upon listener to convert axes position
+              ## to "normalized" units.
+              orig_axes_units = get (kids(i), "units");
+              orig_axes_position = get (kids(i), "position");
+              unwind_protect
+                set (kids(i), "units", "normalized");
+                fg = get (kids(i), "color");
+                if (isnumeric (fg) && strcmp (get (kids(i), "visible"), "on"))
+                  fprintf (plot_stream, "set obj 2 rectangle from graph 0,0 to graph 1,1 behind fc rgb \"#%02x%02x%02x\"\n", 255 * fg);
+                  fg_is_set = true;
+                  fg_was_set = true;
+                elseif (fg_was_set)
+                  fprintf (plot_stream, "unset obj 2\n");
+                  fg_is_set = false;
+                  fg_was_set = false;
+                else
+                  fg_is_set = false;
+                endif
+                if (bg_is_set)
+                  fprintf (plot_stream, "set border linecolor rgb \"#%02x%02x%02x\"\n", 255 * (1 - bg));
+                endif
+                ## Find if this axes has an associated legend axes and pass it
+                ## to __go_draw_axes__
+                hlegend = [];
+                fkids = get (h, "children");
+                for j = 1 : numel (fkids)
+                  if (ishandle (fkids (j))
+                      && strcmp (get (fkids (j), "type"), "axes")
+                      && (strcmp (get (fkids (j), "tag"), "legend")))
+                    udata = get (fkids (j), "userdata");
+                    if (isscalar (udata.handle)
+                        && ! isempty (intersect (udata.handle, kids (i))))
+                      hlegend = get (fkids (j));
+                      break;
+                    endif
+                  endif
+                endfor
+                __go_draw_axes__ (kids(i), plot_stream, enhanced, mono,
+                                  bg_is_set, fg_is_set, hlegend);
+              unwind_protect_cleanup
+                ## Return axes "units" and "position" back to
+                ## their original values.
+                set (kids(i), "units", orig_axes_units);
+                set (kids(i), "position", orig_axes_position);
+                bg_is_set = false;
+                fg_is_set = false;
+              end_unwind_protect
+            endif
+          case "uimenu"
+            ## ignore uimenu objects
+            kids(i) = [];
+          otherwise
+            error ("__go_draw_figure__: unknown object class, %s", type);
+        endswitch
+      endfor
+      if (isempty (kids))
         fputs (plot_stream, "\nreset; clear;\n");
         fflush (plot_stream);
+      else
+        fputs (plot_stream, "\nunset multiplot;\n");
       endif
     else
-      error ("__go_draw_figure__: expecting figure object, found '%s'",
-             htype);
+      fputs (plot_stream, "\nreset; clear;\n");
+      fflush (plot_stream);
     endif
   else
-    print_usage ();
+    error ("__go_draw_figure__: expecting figure object, found '%s'",
+           htype);
   endif
 
 endfunction
 
diff --git a/scripts/plot/private/__interp_cube__.m b/scripts/plot/private/__interp_cube__.m
--- a/scripts/plot/private/__interp_cube__.m
+++ b/scripts/plot/private/__interp_cube__.m
@@ -19,45 +19,43 @@
 ## Author: Martin Helm <martin@mhelm.de>
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{vxyz}, @var{idx}, @var{frac}] =} __interp_cube__ (@var{x}, @var{y}, @var{z}, @var{val}, @var{v})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function [Vxyz, idx, frac] = __interp_cube__ (x, y, z, val, v, req = "values" )
-  if (ismatrix (x) && ndims (x) == 3 && ismatrix (y) && ndims (y) == 3 ...
+  if (ismatrix (x) && ndims (x) == 3 && ismatrix (y) && ndims (y) == 3
        && ismatrix (z) && ndims (z) == 3 && size_equal (x, y, z, val))
     x = squeeze (x(1,:,1))(:);
     y = squeeze (y(:,1,1))(:);
     z = squeeze (z(1,1,:))(:);
-  elseif (isvector (x) && isvector (y) && isvector (z) )
+  elseif (isvector (x) && isvector (y) && isvector (z))
     x = x(:);
     y = y(:);
     z = z(:);
   else
     error ("__interp_cube__: X, Y, Z have wrong dimensions");
   endif
   if (size (val) != [length(x), length(y), length(z)])
     error ("__interp_cube__: VAL has wrong dimensions");
   endif
   if (columns (v) != 3)
-    error ( "v has to be N*3 matrix");
+    error ( "V has to be Nx3 matrix");
   endif
-  if (!ischar (req))
-   error ("__interp_cube__: Invalid request parameter use 'values', 'normals' or 'normals8'");
-  endif
+  ##if (!ischar (req))
+  ## error ('__interp_cube__: Invalid request parameter use "values", "normals" or "normals8"');
+  ##endif
   if (isempty (v))
     Vxyz = idx = frac = [];
     return
   endif
 
   switch (req)
-    case "values"
-      [Vxyz, idx, frac] = interp_cube_trilin (x, y, z, val, v);
     case "normals"
       [idx, frac] = cube_idx (x, y, z, v);
 
       dx = x(2:end) - x(1:end-1);
       dy = y(2:end) - y(1:end-1);
       dz = z(2:end) - z(1:end-1);
       dx = 0.5 .* [dx;dx(end)](idx(:,2));
       dy = 0.5 .* [dy;dy(end)](idx(:,1));
@@ -91,18 +89,20 @@ function [Vxyz, idx, frac] = __interp_cu
       dx = x(2:end) - x(1:end-1);
       dy = y(2:end) - y(1:end-1);
       dz = z(2:end) - z(1:end-1);
       dx = [dx;dx(end)](idx(:,2));
       dy = [dy;dy(end)](idx(:,1));
       dz = [dz;dz(end)](idx(:,3));
       [Dx, Dy, Dz, idx, frac] = interp_cube_trilin_grad (x, y, z, val, v);
       Vxyz = [Dx./dx, Dy./dy, Dz./dz];
+    case "values"
+      [Vxyz, idx, frac] = interp_cube_trilin (x, y, z, val, v);
    otherwise
-     error ("__interp_cube__: Invalid request type '%s', use 'values', 'normals' or 'normals8'", req);
+     error ('__interp_cube__: Invalid request type "%s", use "values", "normals" or "normals8"', req);
   endswitch
 endfunction
 
 function [Vxyz, idx, frac] = interp_cube_trilin (x, y, z, val, v)
   [idx, frac] = cube_idx (x(:), y(:), z(:), v);
   sval = size (val);
   i000 = sub2ind (sval, idx(:, 1), idx(:, 2), idx(:, 3));
   i100 = sub2ind (sval, idx(:, 1)+1, idx(:, 2), idx(:, 3));
diff --git a/scripts/plot/private/__line__.m b/scripts/plot/private/__line__.m
--- a/scripts/plot/private/__line__.m
+++ b/scripts/plot/private/__line__.m
@@ -24,20 +24,16 @@
 ## __line__ (p, x, y, z)
 ## Create line object from x, y, and z with parent p.
 ## Return handle to line object.
 
 ## Author: jwe
 
 function h = __line__ (p, varargin)
 
-  if (nargin < 1)
-    print_usage ();
-  endif
-
   nvargs = numel (varargin);
 
   if (nvargs > 1 && ! ischar (varargin{1}) && ! ischar (varargin{2}))
     if (nvargs > 2 && ! ischar (varargin{3}))
       num_data_args = 3;
     else
       num_data_args = 2;
     endif
diff --git a/scripts/plot/private/__next_line_color__.m b/scripts/plot/private/__next_line_color__.m
--- a/scripts/plot/private/__next_line_color__.m
+++ b/scripts/plot/private/__next_line_color__.m
@@ -26,20 +26,16 @@
 
 ## Author: Carl Osterwisch
 ## Author: jwe
 
 function rgb = __next_line_color__ (reset)
 
   persistent reset_colors = true;
 
-  if (nargin > 1)
-    print_usage ();
-  endif
-
   if (nargin == 1)
     ## Indicates whether the next call will increment or not
     reset_colors = reset;
   else
     ## Find and return the next line color
     ca = gca ();
     colorOrder = get (ca, "ColorOrder");
     if (reset_colors)
diff --git a/scripts/plot/private/__next_line_style__.m b/scripts/plot/private/__next_line_style__.m
--- a/scripts/plot/private/__next_line_style__.m
+++ b/scripts/plot/private/__next_line_style__.m
@@ -23,20 +23,16 @@
 
 ## Return the next line style in the rotation.
 
 
 function [linestyle, marker] = __next_line_style__ (reset)
 
   persistent reset_style = true;
 
-  if (nargin > 1)
-    print_usage ();
-  endif
-
   if (nargin == 1)
     ## Indicates whether the next call will increment or not
     reset_style = reset;
   else
     ## Find and return the next line style
     ca = gca ();
     style_rotation = get (ca, "linestyleorder");
     if (ischar (style_rotation))
diff --git a/scripts/plot/private/__plt__.m b/scripts/plot/private/__plt__.m
--- a/scripts/plot/private/__plt__.m
+++ b/scripts/plot/private/__plt__.m
@@ -153,20 +153,16 @@ function [hlgnd, tlgnd, setlgnd] = __plt
       tlgnd = {tlgnd{:}, key};
       setlgnd = true;
     endif
   endfor
 endfunction
 
 function retval = __plt1__ (h, x1, options, properties = {})
 
-  if (nargin < 2 || nargin > 4)
-    print_usage ();
-  endif
-
   if (nargin < 3 || isempty (options))
     options = __default_plot_options__ ();
   endif
 
   if (! isstruct (options))
     error ("__plt1__: options must be a struct array");
   endif
 
@@ -190,20 +186,16 @@ function retval = __plt1__ (h, x1, optio
   endif
 
   retval = __plt2__ (h, x1, x2, options, properties);
 
 endfunction
 
 function retval = __plt2__ (h, x1, x2, options, properties = {})
 
-  if (nargin < 3 || nargin > 5)
-    print_usage ();
-  endif
-
   if (nargin < 4 || isempty (options))
     options = __default_plot_options__ ();
   endif
 
   if (! isstruct (options))
     error ("__plt2__: options must be a struct array");
   endif
 
diff --git a/scripts/plot/private/__pltopt__.m b/scripts/plot/private/__pltopt__.m
--- a/scripts/plot/private/__pltopt__.m
+++ b/scripts/plot/private/__pltopt__.m
@@ -89,59 +89,51 @@
 
 ## Author: jwe
 
 function [options, valid] = __pltopt__ (caller, opt, err_on_invalid)
 
   valid = true;
   options =  __default_plot_options__ ();
 
-  if ((nargin == 2 || nargin == 3) && (nargout == 1 || nargout == 2))
-    if (nargin == 2)
-      err_on_invalid = true;
-    endif
-    if (ischar (opt))
-      nel = rows (opt);
-    elseif (iscellstr (opt))
-      nel = numel (opt);
-    else
-      error ("__pltopt__: expecting argument to be character string or cell array of character strings");
+  if (nargin == 2)
+    err_on_invalid = true;
+  endif
+  if (ischar (opt))
+    nel = rows (opt);
+  elseif (iscellstr (opt))
+    nel = numel (opt);
+  else
+    error ("__pltopt__: argument must be a character string or cell array of character strings");
+  endif
+  if (ischar (opt))
+    opt = cellstr (opt);
+  endif
+  for i = nel:-1:1
+    [options(i), valid] = __pltopt1__ (caller, opt{i}, err_on_invalid);
+    if (! err_on_invalid && ! valid)
+      return;
     endif
-    if (ischar (opt))
-      opt = cellstr (opt);
-    endif
-    for i = nel:-1:1
-      [options(i), valid] = __pltopt1__ (caller, opt{i}, err_on_invalid);
-      if (! err_on_invalid && ! valid)
-        return;
-      endif
-    endfor
-  else
-    print_usage ();
-  endif
+  endfor
 
 endfunction
 
 ## Really decode plot option strings.
 
 ## Author: Rick Niles <niles@axp745.gsfc.nasa.gov>
 ## Adapted-By: jwe
 ## Maintainer: jwe
 
 function [options, valid] = __pltopt1__ (caller, opt, err_on_invalid)
 
   options = __default_plot_options__ ();
   valid = true;
 
   more_opts = 1;
 
-  if (nargin != 2 && nargin != 3)
-    print_usage ();
-  endif
-
   if (! ischar (opt))
     return;
   endif
 
   have_linestyle = false;
   have_marker = false;
 
   ## If called by __errplot__, extract the linestyle before proceeding.
@@ -179,17 +171,17 @@ function [options, valid] = __pltopt1__ 
               || topt == ">" || topt == "<" || topt == "p"
               || topt == "h" || topt == "@")
         have_marker = true;
         ## Backward compatibility.  Leave undocumented.
         if (topt == "@")
           topt = "+";
         endif
         options.marker = topt;
-### Numeric color specs for backward compatibility.  Leave undocumented.
+      ## Numeric color specs for backward compatibility.  Leave undocumented.
       elseif (topt == "k" || topt == "0")
         options.color = [0, 0, 0];
       elseif (topt == "r" || topt == "1")
         options.color = [1, 0, 0];
       elseif (topt == "g" || topt == "2")
         options.color = [0, 1, 0];
       elseif (topt == "b" || topt == "3")
         options.color = [0, 0, 1];
diff --git a/scripts/signal/private/rectangle_lw.m b/scripts/signal/private/rectangle_lw.m
--- a/scripts/signal/private/rectangle_lw.m
+++ b/scripts/signal/private/rectangle_lw.m
@@ -22,18 +22,14 @@
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Rectangular lag window
 
 function retval = rectangle_lw (n, b)
 
-  if (nargin != 2)
-    print_usage ();
-  endif
-
   retval = zeros (n, 1);
   t = floor (1 / b);
 
   retval(1:t, 1) = ones (t, 1);
 
 endfunction
diff --git a/scripts/signal/private/rectangle_sw.m b/scripts/signal/private/rectangle_sw.m
--- a/scripts/signal/private/rectangle_sw.m
+++ b/scripts/signal/private/rectangle_sw.m
@@ -22,20 +22,16 @@
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Rectangular spectral window
 
 function retval = rectangle_sw (n, b)
 
-  if (nargin != 2)
-    print_usage ();
-  endif
-
   retval = zeros (n, 1);
   retval(1) = 2 / b + 1;
 
   l = (2:n)' - 1;
   l = 2 * pi * l / n;
 
   retval(2:n) = sin ((2/b + 1) * l / 2) ./ sin (l / 2);
 
diff --git a/scripts/signal/private/triangle_lw.m b/scripts/signal/private/triangle_lw.m
--- a/scripts/signal/private/triangle_lw.m
+++ b/scripts/signal/private/triangle_lw.m
@@ -22,17 +22,13 @@
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Triangular lag window
 
 function retval = triangle_lw (n, b)
 
-  if (nargin != 2)
-    print_usage ();
-  endif
-
   retval = 1 - (0 : n-1)' * b;
   retval = max ([retval'; (zeros (1, n))])';
 
 endfunction
 
diff --git a/scripts/signal/private/triangle_sw.m b/scripts/signal/private/triangle_sw.m
--- a/scripts/signal/private/triangle_sw.m
+++ b/scripts/signal/private/triangle_sw.m
@@ -22,20 +22,16 @@
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Triangular spectral window
 
 function retval = triangle_sw (n, b)
 
-  if (nargin != 2)
-    print_usage ();
-  endif
-
   retval = zeros (n,1);
   retval(1) = 1 / b;
 
   l = (2:n)' - 1;
   l = 2 * pi * l / n;
 
   retval(2:n) = b * (sin (l / (2*b)) ./ sin (l / 2)).^2;
 
diff --git a/scripts/sparse/private/__sprand_impl__.m b/scripts/sparse/private/__sprand_impl__.m
--- a/scripts/sparse/private/__sprand_impl__.m
+++ b/scripts/sparse/private/__sprand_impl__.m
@@ -70,12 +70,11 @@ function S = __sprand_impl__ (varargin)
     k = min (length (idx), k);
     j = floor ((idx(1:k) - 1) / m);
     i = idx(1:k) - j * m;
   else
     idx = randperm (mn, k);
     [i, j] = ind2sub ([m, n], idx);
   endif
 
-
   S = sparse (i, j, randfun (k, 1), m, n);
 
 endfunction
diff --git a/scripts/statistics/models/private/logistic_regression_derivatives.m b/scripts/statistics/models/private/logistic_regression_derivatives.m
--- a/scripts/statistics/models/private/logistic_regression_derivatives.m
+++ b/scripts/statistics/models/private/logistic_regression_derivatives.m
@@ -25,20 +25,16 @@
 ## @end deftypefn
 
 ## Author: Gordon K. Smyth <gks@maths.uq.oz.au>
 ## Adapted-By: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Derivates of log-likelihood in logistic regression
 
 function [dl, d2l] = logistic_regression_derivatives (x, z, z1, g, g1, p)
 
-  if (nargin != 6)
-    print_usage ();
-  endif
-
   ## first derivative
   v = g .* (1 - g) ./ p; v1 = g1 .* (1 - g1) ./ p;
   dlogp = [(diag (v) * z - diag (v1) * z1), (diag (v - v1) * x)];
   dl = sum (dlogp)';
 
   ## second derivative
   w = v .* (1 - 2 * g); w1 = v1 .* (1 - 2 * g1);
   d2l = [z, x]' * diag (w) * [z, x] - [z1, x]' * diag (w1) * [z1, x] ...
diff --git a/scripts/statistics/models/private/logistic_regression_likelihood.m b/scripts/statistics/models/private/logistic_regression_likelihood.m
--- a/scripts/statistics/models/private/logistic_regression_likelihood.m
+++ b/scripts/statistics/models/private/logistic_regression_likelihood.m
@@ -24,20 +24,16 @@
 ## @end deftypefn
 
 ## Author: Gordon K. Smyth <gks@maths.uq.oz.au>
 ## Adapted-By: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Likelihood in logistic regression
 
 function [g, g1, p, dev] = logistic_regression_likelihood (y, x, beta, z, z1)
 
-  if (nargin != 5)
-    print_usage ();
-  endif
-
   e = exp ([z, x] * beta); e1 = exp ([z1, x] * beta);
   g = e ./ (1 + e); g1 = e1 ./ (1 + e1);
   g = max (y == max (y), g); g1 = min (y > min (y), g1);
 
   p = g - g1;
   dev = -2 * sum (log (p));
 
 endfunction
