# HG changeset patch
# User dbateman
# Date 1146684768 0
#      Wed May 03 19:32:48 2006 +0000
# Node ID 6b9cec830d729e4298c0cf0c469b81caac5f1d38
# Parent  70f7659d0fb9aa6da8203aa9bcd5ba747c53980d
[project @ 2006-05-03 19:32:46 by dbateman]

diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,14 @@
+2006-05-03  David Bateman  <dbateman@free.fr>
+
+	* lapack/dpocon.f, lapack/zpocon.f, lapack/dpotrs.f, 
+	lapack/zpotrs.f, lapack/dtrcon.f, lapack/ztrcon.f,
+	lapack/dtrtrs.f, lapack/ztrtrs.f: New files.
+
 2006-04-29  John W. Eaton  <jwe@octave.org>
 
 	* misc/lo-error.c (set_liboctave_warning_with_id_handler,
 	liboctave_warning_with_id): New functions.
 	(current_liboctave_warning_with_id_handler): New variable.
 	* misc/lo-error.h (liboctave_warning_with_id_handler): New typedef.
 	(current_liboctave_warning_with_id_handler, liboctave_warning_with_id
 	set_liboctave_warning_with_id_handler): Provide decls.
diff --git a/libcruft/lapack/dpocon.f b/libcruft/lapack/dpocon.f
new file mode 100644
--- /dev/null
+++ b/libcruft/lapack/dpocon.f
@@ -0,0 +1,173 @@
+      SUBROUTINE DPOCON( UPLO, N, A, LDA, ANORM, RCOND, WORK, IWORK,
+     $                   INFO )
+*
+*  -- LAPACK routine (version 3.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
+*     Courant Institute, Argonne National Lab, and Rice University
+*     March 31, 1993
+*
+*     .. Scalar Arguments ..
+      CHARACTER          UPLO
+      INTEGER            INFO, LDA, N
+      DOUBLE PRECISION   ANORM, RCOND
+*     ..
+*     .. Array Arguments ..
+      INTEGER            IWORK( * )
+      DOUBLE PRECISION   A( LDA, * ), WORK( * )
+*     ..
+*
+*  Purpose
+*  =======
+*
+*  DPOCON estimates the reciprocal of the condition number (in the
+*  1-norm) of a real symmetric positive definite matrix using the
+*  Cholesky factorization A = U**T*U or A = L*L**T computed by DPOTRF.
+*
+*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
+*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
+*
+*  Arguments
+*  =========
+*
+*  UPLO    (input) CHARACTER*1
+*          = 'U':  Upper triangle of A is stored;
+*          = 'L':  Lower triangle of A is stored.
+*
+*  N       (input) INTEGER
+*          The order of the matrix A.  N >= 0.
+*
+*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
+*          The triangular factor U or L from the Cholesky factorization
+*          A = U**T*U or A = L*L**T, as computed by DPOTRF.
+*
+*  LDA     (input) INTEGER
+*          The leading dimension of the array A.  LDA >= max(1,N).
+*
+*  ANORM   (input) DOUBLE PRECISION
+*          The 1-norm (or infinity-norm) of the symmetric matrix A.
+*
+*  RCOND   (output) DOUBLE PRECISION
+*          The reciprocal of the condition number of the matrix A,
+*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
+*          estimate of the 1-norm of inv(A) computed in this routine.
+*
+*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
+*
+*  IWORK   (workspace) INTEGER array, dimension (N)
+*
+*  INFO    (output) INTEGER
+*          = 0:  successful exit
+*          < 0:  if INFO = -i, the i-th argument had an illegal value
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      DOUBLE PRECISION   ONE, ZERO
+      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            UPPER
+      CHARACTER          NORMIN
+      INTEGER            IX, KASE
+      DOUBLE PRECISION   AINVNM, SCALE, SCALEL, SCALEU, SMLNUM
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            IDAMAX
+      DOUBLE PRECISION   DLAMCH
+      EXTERNAL           LSAME, IDAMAX, DLAMCH
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           DLACON, DLATRS, DRSCL, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters.
+*
+      INFO = 0
+      UPPER = LSAME( UPLO, 'U' )
+      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -2
+      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
+         INFO = -4
+      ELSE IF( ANORM.LT.ZERO ) THEN
+         INFO = -5
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'DPOCON', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      RCOND = ZERO
+      IF( N.EQ.0 ) THEN
+         RCOND = ONE
+         RETURN
+      ELSE IF( ANORM.EQ.ZERO ) THEN
+         RETURN
+      END IF
+*
+      SMLNUM = DLAMCH( 'Safe minimum' )
+*
+*     Estimate the 1-norm of inv(A).
+*
+      KASE = 0
+      NORMIN = 'N'
+   10 CONTINUE
+      CALL DLACON( N, WORK( N+1 ), WORK, IWORK, AINVNM, KASE )
+      IF( KASE.NE.0 ) THEN
+         IF( UPPER ) THEN
+*
+*           Multiply by inv(U').
+*
+            CALL DLATRS( 'Upper', 'Transpose', 'Non-unit', NORMIN, N, A,
+     $                   LDA, WORK, SCALEL, WORK( 2*N+1 ), INFO )
+            NORMIN = 'Y'
+*
+*           Multiply by inv(U).
+*
+            CALL DLATRS( 'Upper', 'No transpose', 'Non-unit', NORMIN, N,
+     $                   A, LDA, WORK, SCALEU, WORK( 2*N+1 ), INFO )
+         ELSE
+*
+*           Multiply by inv(L).
+*
+            CALL DLATRS( 'Lower', 'No transpose', 'Non-unit', NORMIN, N,
+     $                   A, LDA, WORK, SCALEL, WORK( 2*N+1 ), INFO )
+            NORMIN = 'Y'
+*
+*           Multiply by inv(L').
+*
+            CALL DLATRS( 'Lower', 'Transpose', 'Non-unit', NORMIN, N, A,
+     $                   LDA, WORK, SCALEU, WORK( 2*N+1 ), INFO )
+         END IF
+*
+*        Multiply by 1/SCALE if doing so will not cause overflow.
+*
+         SCALE = SCALEL*SCALEU
+         IF( SCALE.NE.ONE ) THEN
+            IX = IDAMAX( N, WORK, 1 )
+            IF( SCALE.LT.ABS( WORK( IX ) )*SMLNUM .OR. SCALE.EQ.ZERO )
+     $         GO TO 20
+            CALL DRSCL( N, SCALE, WORK, 1 )
+         END IF
+         GO TO 10
+      END IF
+*
+*     Compute the estimate of the reciprocal condition number.
+*
+      IF( AINVNM.NE.ZERO )
+     $   RCOND = ( ONE / AINVNM ) / ANORM
+*
+   20 CONTINUE
+      RETURN
+*
+*     End of DPOCON
+*
+      END
diff --git a/libcruft/lapack/dpotrs.f b/libcruft/lapack/dpotrs.f
new file mode 100644
--- /dev/null
+++ b/libcruft/lapack/dpotrs.f
@@ -0,0 +1,133 @@
+      SUBROUTINE DPOTRS( UPLO, N, NRHS, A, LDA, B, LDB, INFO )
+*
+*  -- LAPACK routine (version 3.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
+*     Courant Institute, Argonne National Lab, and Rice University
+*     March 31, 1993
+*
+*     .. Scalar Arguments ..
+      CHARACTER          UPLO
+      INTEGER            INFO, LDA, LDB, N, NRHS
+*     ..
+*     .. Array Arguments ..
+      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
+*     ..
+*
+*  Purpose
+*  =======
+*
+*  DPOTRS solves a system of linear equations A*X = B with a symmetric
+*  positive definite matrix A using the Cholesky factorization
+*  A = U**T*U or A = L*L**T computed by DPOTRF.
+*
+*  Arguments
+*  =========
+*
+*  UPLO    (input) CHARACTER*1
+*          = 'U':  Upper triangle of A is stored;
+*          = 'L':  Lower triangle of A is stored.
+*
+*  N       (input) INTEGER
+*          The order of the matrix A.  N >= 0.
+*
+*  NRHS    (input) INTEGER
+*          The number of right hand sides, i.e., the number of columns
+*          of the matrix B.  NRHS >= 0.
+*
+*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
+*          The triangular factor U or L from the Cholesky factorization
+*          A = U**T*U or A = L*L**T, as computed by DPOTRF.
+*
+*  LDA     (input) INTEGER
+*          The leading dimension of the array A.  LDA >= max(1,N).
+*
+*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
+*          On entry, the right hand side matrix B.
+*          On exit, the solution matrix X.
+*
+*  LDB     (input) INTEGER
+*          The leading dimension of the array B.  LDB >= max(1,N).
+*
+*  INFO    (output) INTEGER
+*          = 0:  successful exit
+*          < 0:  if INFO = -i, the i-th argument had an illegal value
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      DOUBLE PRECISION   ONE
+      PARAMETER          ( ONE = 1.0D+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            UPPER
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           DTRSM, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters.
+*
+      INFO = 0
+      UPPER = LSAME( UPLO, 'U' )
+      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -2
+      ELSE IF( NRHS.LT.0 ) THEN
+         INFO = -3
+      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
+         INFO = -5
+      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
+         INFO = -7
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'DPOTRS', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 .OR. NRHS.EQ.0 )
+     $   RETURN
+*
+      IF( UPPER ) THEN
+*
+*        Solve A*X = B where A = U'*U.
+*
+*        Solve U'*X = B, overwriting B with X.
+*
+         CALL DTRSM( 'Left', 'Upper', 'Transpose', 'Non-unit', N, NRHS,
+     $               ONE, A, LDA, B, LDB )
+*
+*        Solve U*X = B, overwriting B with X.
+*
+         CALL DTRSM( 'Left', 'Upper', 'No transpose', 'Non-unit', N,
+     $               NRHS, ONE, A, LDA, B, LDB )
+      ELSE
+*
+*        Solve A*X = B where A = L*L'.
+*
+*        Solve L*X = B, overwriting B with X.
+*
+         CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Non-unit', N,
+     $               NRHS, ONE, A, LDA, B, LDB )
+*
+*        Solve L'*X = B, overwriting B with X.
+*
+         CALL DTRSM( 'Left', 'Lower', 'Transpose', 'Non-unit', N, NRHS,
+     $               ONE, A, LDA, B, LDB )
+      END IF
+*
+      RETURN
+*
+*     End of DPOTRS
+*
+      END
diff --git a/libcruft/lapack/dtrcon.f b/libcruft/lapack/dtrcon.f
new file mode 100644
--- /dev/null
+++ b/libcruft/lapack/dtrcon.f
@@ -0,0 +1,193 @@
+      SUBROUTINE DTRCON( NORM, UPLO, DIAG, N, A, LDA, RCOND, WORK,
+     $                   IWORK, INFO )
+*
+*  -- LAPACK routine (version 3.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
+*     Courant Institute, Argonne National Lab, and Rice University
+*     March 31, 1993
+*
+*     .. Scalar Arguments ..
+      CHARACTER          DIAG, NORM, UPLO
+      INTEGER            INFO, LDA, N
+      DOUBLE PRECISION   RCOND
+*     ..
+*     .. Array Arguments ..
+      INTEGER            IWORK( * )
+      DOUBLE PRECISION   A( LDA, * ), WORK( * )
+*     ..
+*
+*  Purpose
+*  =======
+*
+*  DTRCON estimates the reciprocal of the condition number of a
+*  triangular matrix A, in either the 1-norm or the infinity-norm.
+*
+*  The norm of A is computed and an estimate is obtained for
+*  norm(inv(A)), then the reciprocal of the condition number is
+*  computed as
+*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
+*
+*  Arguments
+*  =========
+*
+*  NORM    (input) CHARACTER*1
+*          Specifies whether the 1-norm condition number or the
+*          infinity-norm condition number is required:
+*          = '1' or 'O':  1-norm;
+*          = 'I':         Infinity-norm.
+*
+*  UPLO    (input) CHARACTER*1
+*          = 'U':  A is upper triangular;
+*          = 'L':  A is lower triangular.
+*
+*  DIAG    (input) CHARACTER*1
+*          = 'N':  A is non-unit triangular;
+*          = 'U':  A is unit triangular.
+*
+*  N       (input) INTEGER
+*          The order of the matrix A.  N >= 0.
+*
+*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
+*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
+*          upper triangular part of the array A contains the upper
+*          triangular matrix, and the strictly lower triangular part of
+*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
+*          triangular part of the array A contains the lower triangular
+*          matrix, and the strictly upper triangular part of A is not
+*          referenced.  If DIAG = 'U', the diagonal elements of A are
+*          also not referenced and are assumed to be 1.
+*
+*  LDA     (input) INTEGER
+*          The leading dimension of the array A.  LDA >= max(1,N).
+*
+*  RCOND   (output) DOUBLE PRECISION
+*          The reciprocal of the condition number of the matrix A,
+*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
+*
+*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
+*
+*  IWORK   (workspace) INTEGER array, dimension (N)
+*
+*  INFO    (output) INTEGER
+*          = 0:  successful exit
+*          < 0:  if INFO = -i, the i-th argument had an illegal value
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      DOUBLE PRECISION   ONE, ZERO
+      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            NOUNIT, ONENRM, UPPER
+      CHARACTER          NORMIN
+      INTEGER            IX, KASE, KASE1
+      DOUBLE PRECISION   AINVNM, ANORM, SCALE, SMLNUM, XNORM
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            IDAMAX
+      DOUBLE PRECISION   DLAMCH, DLANTR
+      EXTERNAL           LSAME, IDAMAX, DLAMCH, DLANTR
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           DLACON, DLATRS, DRSCL, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, DBLE, MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters.
+*
+      INFO = 0
+      UPPER = LSAME( UPLO, 'U' )
+      ONENRM = NORM.EQ.'1' .OR. LSAME( NORM, 'O' )
+      NOUNIT = LSAME( DIAG, 'N' )
+*
+      IF( .NOT.ONENRM .AND. .NOT.LSAME( NORM, 'I' ) ) THEN
+         INFO = -1
+      ELSE IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -2
+      ELSE IF( .NOT.NOUNIT .AND. .NOT.LSAME( DIAG, 'U' ) ) THEN
+         INFO = -3
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -4
+      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
+         INFO = -6
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'DTRCON', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 ) THEN
+         RCOND = ONE
+         RETURN
+      END IF
+*
+      RCOND = ZERO
+      SMLNUM = DLAMCH( 'Safe minimum' )*DBLE( MAX( 1, N ) )
+*
+*     Compute the norm of the triangular matrix A.
+*
+      ANORM = DLANTR( NORM, UPLO, DIAG, N, N, A, LDA, WORK )
+*
+*     Continue only if ANORM > 0.
+*
+      IF( ANORM.GT.ZERO ) THEN
+*
+*        Estimate the norm of the inverse of A.
+*
+         AINVNM = ZERO
+         NORMIN = 'N'
+         IF( ONENRM ) THEN
+            KASE1 = 1
+         ELSE
+            KASE1 = 2
+         END IF
+         KASE = 0
+   10    CONTINUE
+         CALL DLACON( N, WORK( N+1 ), WORK, IWORK, AINVNM, KASE )
+         IF( KASE.NE.0 ) THEN
+            IF( KASE.EQ.KASE1 ) THEN
+*
+*              Multiply by inv(A).
+*
+               CALL DLATRS( UPLO, 'No transpose', DIAG, NORMIN, N, A,
+     $                      LDA, WORK, SCALE, WORK( 2*N+1 ), INFO )
+            ELSE
+*
+*              Multiply by inv(A').
+*
+               CALL DLATRS( UPLO, 'Transpose', DIAG, NORMIN, N, A, LDA,
+     $                      WORK, SCALE, WORK( 2*N+1 ), INFO )
+            END IF
+            NORMIN = 'Y'
+*
+*           Multiply by 1/SCALE if doing so will not cause overflow.
+*
+            IF( SCALE.NE.ONE ) THEN
+               IX = IDAMAX( N, WORK, 1 )
+               XNORM = ABS( WORK( IX ) )
+               IF( SCALE.LT.XNORM*SMLNUM .OR. SCALE.EQ.ZERO )
+     $            GO TO 20
+               CALL DRSCL( N, SCALE, WORK, 1 )
+            END IF
+            GO TO 10
+         END IF
+*
+*        Compute the estimate of the reciprocal condition number.
+*
+         IF( AINVNM.NE.ZERO )
+     $      RCOND = ( ONE / ANORM ) / AINVNM
+      END IF
+*
+   20 CONTINUE
+      RETURN
+*
+*     End of DTRCON
+*
+      END
diff --git a/libcruft/lapack/dtrtrs.f b/libcruft/lapack/dtrtrs.f
new file mode 100644
--- /dev/null
+++ b/libcruft/lapack/dtrtrs.f
@@ -0,0 +1,148 @@
+      SUBROUTINE DTRTRS( UPLO, TRANS, DIAG, N, NRHS, A, LDA, B, LDB,
+     $                   INFO )
+*
+*  -- LAPACK routine (version 3.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
+*     Courant Institute, Argonne National Lab, and Rice University
+*     March 31, 1993
+*
+*     .. Scalar Arguments ..
+      CHARACTER          DIAG, TRANS, UPLO
+      INTEGER            INFO, LDA, LDB, N, NRHS
+*     ..
+*     .. Array Arguments ..
+      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
+*     ..
+*
+*  Purpose
+*  =======
+*
+*  DTRTRS solves a triangular system of the form
+*
+*     A * X = B  or  A**T * X = B,
+*
+*  where A is a triangular matrix of order N, and B is an N-by-NRHS
+*  matrix.  A check is made to verify that A is nonsingular.
+*
+*  Arguments
+*  =========
+*
+*  UPLO    (input) CHARACTER*1
+*          = 'U':  A is upper triangular;
+*          = 'L':  A is lower triangular.
+*
+*  TRANS   (input) CHARACTER*1
+*          Specifies the form of the system of equations:
+*          = 'N':  A * X = B  (No transpose)
+*          = 'T':  A**T * X = B  (Transpose)
+*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
+*
+*  DIAG    (input) CHARACTER*1
+*          = 'N':  A is non-unit triangular;
+*          = 'U':  A is unit triangular.
+*
+*  N       (input) INTEGER
+*          The order of the matrix A.  N >= 0.
+*
+*  NRHS    (input) INTEGER
+*          The number of right hand sides, i.e., the number of columns
+*          of the matrix B.  NRHS >= 0.
+*
+*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
+*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
+*          upper triangular part of the array A contains the upper
+*          triangular matrix, and the strictly lower triangular part of
+*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
+*          triangular part of the array A contains the lower triangular
+*          matrix, and the strictly upper triangular part of A is not
+*          referenced.  If DIAG = 'U', the diagonal elements of A are
+*          also not referenced and are assumed to be 1.
+*
+*  LDA     (input) INTEGER
+*          The leading dimension of the array A.  LDA >= max(1,N).
+*
+*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
+*          On entry, the right hand side matrix B.
+*          On exit, if INFO = 0, the solution matrix X.
+*
+*  LDB     (input) INTEGER
+*          The leading dimension of the array B.  LDB >= max(1,N).
+*
+*  INFO    (output) INTEGER
+*          = 0:  successful exit
+*          < 0: if INFO = -i, the i-th argument had an illegal value
+*          > 0: if INFO = i, the i-th diagonal element of A is zero,
+*               indicating that the matrix is singular and the solutions
+*               X have not been computed.
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      DOUBLE PRECISION   ZERO, ONE
+      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            NOUNIT
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           DTRSM, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters.
+*
+      INFO = 0
+      NOUNIT = LSAME( DIAG, 'N' )
+      IF( .NOT.LSAME( UPLO, 'U' ) .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -1
+      ELSE IF( .NOT.LSAME( TRANS, 'N' ) .AND. .NOT.
+     $         LSAME( TRANS, 'T' ) .AND. .NOT.LSAME( TRANS, 'C' ) ) THEN
+         INFO = -2
+      ELSE IF( .NOT.NOUNIT .AND. .NOT.LSAME( DIAG, 'U' ) ) THEN
+         INFO = -3
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -4
+      ELSE IF( NRHS.LT.0 ) THEN
+         INFO = -5
+      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
+         INFO = -7
+      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
+         INFO = -9
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'DTRTRS', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 )
+     $   RETURN
+*
+*     Check for singularity.
+*
+      IF( NOUNIT ) THEN
+         DO 10 INFO = 1, N
+            IF( A( INFO, INFO ).EQ.ZERO )
+     $         RETURN
+   10    CONTINUE
+      END IF
+      INFO = 0
+*
+*     Solve A * x = b  or  A' * x = b.
+*
+      CALL DTRSM( 'Left', UPLO, TRANS, DIAG, N, NRHS, ONE, A, LDA, B,
+     $            LDB )
+*
+      RETURN
+*
+*     End of DTRTRS
+*
+      END
diff --git a/libcruft/lapack/zpocon.f b/libcruft/lapack/zpocon.f
new file mode 100644
--- /dev/null
+++ b/libcruft/lapack/zpocon.f
@@ -0,0 +1,180 @@
+      SUBROUTINE ZPOCON( UPLO, N, A, LDA, ANORM, RCOND, WORK, RWORK,
+     $                   INFO )
+*
+*  -- LAPACK routine (version 3.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
+*     Courant Institute, Argonne National Lab, and Rice University
+*     March 31, 1993
+*
+*     .. Scalar Arguments ..
+      CHARACTER          UPLO
+      INTEGER            INFO, LDA, N
+      DOUBLE PRECISION   ANORM, RCOND
+*     ..
+*     .. Array Arguments ..
+      DOUBLE PRECISION   RWORK( * )
+      COMPLEX*16         A( LDA, * ), WORK( * )
+*     ..
+*
+*  Purpose
+*  =======
+*
+*  ZPOCON estimates the reciprocal of the condition number (in the
+*  1-norm) of a complex Hermitian positive definite matrix using the
+*  Cholesky factorization A = U**H*U or A = L*L**H computed by ZPOTRF.
+*
+*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
+*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
+*
+*  Arguments
+*  =========
+*
+*  UPLO    (input) CHARACTER*1
+*          = 'U':  Upper triangle of A is stored;
+*          = 'L':  Lower triangle of A is stored.
+*
+*  N       (input) INTEGER
+*          The order of the matrix A.  N >= 0.
+*
+*  A       (input) COMPLEX*16 array, dimension (LDA,N)
+*          The triangular factor U or L from the Cholesky factorization
+*          A = U**H*U or A = L*L**H, as computed by ZPOTRF.
+*
+*  LDA     (input) INTEGER
+*          The leading dimension of the array A.  LDA >= max(1,N).
+*
+*  ANORM   (input) DOUBLE PRECISION
+*          The 1-norm (or infinity-norm) of the Hermitian matrix A.
+*
+*  RCOND   (output) DOUBLE PRECISION
+*          The reciprocal of the condition number of the matrix A,
+*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
+*          estimate of the 1-norm of inv(A) computed in this routine.
+*
+*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
+*
+*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
+*
+*  INFO    (output) INTEGER
+*          = 0:  successful exit
+*          < 0:  if INFO = -i, the i-th argument had an illegal value
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      DOUBLE PRECISION   ONE, ZERO
+      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            UPPER
+      CHARACTER          NORMIN
+      INTEGER            IX, KASE
+      DOUBLE PRECISION   AINVNM, SCALE, SCALEL, SCALEU, SMLNUM
+      COMPLEX*16         ZDUM
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            IZAMAX
+      DOUBLE PRECISION   DLAMCH
+      EXTERNAL           LSAME, IZAMAX, DLAMCH
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           XERBLA, ZDRSCL, ZLACON, ZLATRS
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, DBLE, DIMAG, MAX
+*     ..
+*     .. Statement Functions ..
+      DOUBLE PRECISION   CABS1
+*     ..
+*     .. Statement Function definitions ..
+      CABS1( ZDUM ) = ABS( DBLE( ZDUM ) ) + ABS( DIMAG( ZDUM ) )
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters.
+*
+      INFO = 0
+      UPPER = LSAME( UPLO, 'U' )
+      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -2
+      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
+         INFO = -4
+      ELSE IF( ANORM.LT.ZERO ) THEN
+         INFO = -5
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'ZPOCON', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      RCOND = ZERO
+      IF( N.EQ.0 ) THEN
+         RCOND = ONE
+         RETURN
+      ELSE IF( ANORM.EQ.ZERO ) THEN
+         RETURN
+      END IF
+*
+      SMLNUM = DLAMCH( 'Safe minimum' )
+*
+*     Estimate the 1-norm of inv(A).
+*
+      KASE = 0
+      NORMIN = 'N'
+   10 CONTINUE
+      CALL ZLACON( N, WORK( N+1 ), WORK, AINVNM, KASE )
+      IF( KASE.NE.0 ) THEN
+         IF( UPPER ) THEN
+*
+*           Multiply by inv(U').
+*
+            CALL ZLATRS( 'Upper', 'Conjugate transpose', 'Non-unit',
+     $                   NORMIN, N, A, LDA, WORK, SCALEL, RWORK, INFO )
+            NORMIN = 'Y'
+*
+*           Multiply by inv(U).
+*
+            CALL ZLATRS( 'Upper', 'No transpose', 'Non-unit', NORMIN, N,
+     $                   A, LDA, WORK, SCALEU, RWORK, INFO )
+         ELSE
+*
+*           Multiply by inv(L).
+*
+            CALL ZLATRS( 'Lower', 'No transpose', 'Non-unit', NORMIN, N,
+     $                   A, LDA, WORK, SCALEL, RWORK, INFO )
+            NORMIN = 'Y'
+*
+*           Multiply by inv(L').
+*
+            CALL ZLATRS( 'Lower', 'Conjugate transpose', 'Non-unit',
+     $                   NORMIN, N, A, LDA, WORK, SCALEU, RWORK, INFO )
+         END IF
+*
+*        Multiply by 1/SCALE if doing so will not cause overflow.
+*
+         SCALE = SCALEL*SCALEU
+         IF( SCALE.NE.ONE ) THEN
+            IX = IZAMAX( N, WORK, 1 )
+            IF( SCALE.LT.CABS1( WORK( IX ) )*SMLNUM .OR. SCALE.EQ.ZERO )
+     $         GO TO 20
+            CALL ZDRSCL( N, SCALE, WORK, 1 )
+         END IF
+         GO TO 10
+      END IF
+*
+*     Compute the estimate of the reciprocal condition number.
+*
+      IF( AINVNM.NE.ZERO )
+     $   RCOND = ( ONE / AINVNM ) / ANORM
+*
+   20 CONTINUE
+      RETURN
+*
+*     End of ZPOCON
+*
+      END
diff --git a/libcruft/lapack/zpotrs.f b/libcruft/lapack/zpotrs.f
new file mode 100644
--- /dev/null
+++ b/libcruft/lapack/zpotrs.f
@@ -0,0 +1,133 @@
+      SUBROUTINE ZPOTRS( UPLO, N, NRHS, A, LDA, B, LDB, INFO )
+*
+*  -- LAPACK routine (version 3.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
+*     Courant Institute, Argonne National Lab, and Rice University
+*     September 30, 1994
+*
+*     .. Scalar Arguments ..
+      CHARACTER          UPLO
+      INTEGER            INFO, LDA, LDB, N, NRHS
+*     ..
+*     .. Array Arguments ..
+      COMPLEX*16         A( LDA, * ), B( LDB, * )
+*     ..
+*
+*  Purpose
+*  =======
+*
+*  ZPOTRS solves a system of linear equations A*X = B with a Hermitian
+*  positive definite matrix A using the Cholesky factorization
+*  A = U**H*U or A = L*L**H computed by ZPOTRF.
+*
+*  Arguments
+*  =========
+*
+*  UPLO    (input) CHARACTER*1
+*          = 'U':  Upper triangle of A is stored;
+*          = 'L':  Lower triangle of A is stored.
+*
+*  N       (input) INTEGER
+*          The order of the matrix A.  N >= 0.
+*
+*  NRHS    (input) INTEGER
+*          The number of right hand sides, i.e., the number of columns
+*          of the matrix B.  NRHS >= 0.
+*
+*  A       (input) COMPLEX*16 array, dimension (LDA,N)
+*          The triangular factor U or L from the Cholesky factorization
+*          A = U**H*U or A = L*L**H, as computed by ZPOTRF.
+*
+*  LDA     (input) INTEGER
+*          The leading dimension of the array A.  LDA >= max(1,N).
+*
+*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
+*          On entry, the right hand side matrix B.
+*          On exit, the solution matrix X.
+*
+*  LDB     (input) INTEGER
+*          The leading dimension of the array B.  LDB >= max(1,N).
+*
+*  INFO    (output) INTEGER
+*          = 0:  successful exit
+*          < 0:  if INFO = -i, the i-th argument had an illegal value
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      COMPLEX*16         ONE
+      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ) )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            UPPER
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           XERBLA, ZTRSM
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters.
+*
+      INFO = 0
+      UPPER = LSAME( UPLO, 'U' )
+      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -2
+      ELSE IF( NRHS.LT.0 ) THEN
+         INFO = -3
+      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
+         INFO = -5
+      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
+         INFO = -7
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'ZPOTRS', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 .OR. NRHS.EQ.0 )
+     $   RETURN
+*
+      IF( UPPER ) THEN
+*
+*        Solve A*X = B where A = U'*U.
+*
+*        Solve U'*X = B, overwriting B with X.
+*
+         CALL ZTRSM( 'Left', 'Upper', 'Conjugate transpose', 'Non-unit',
+     $               N, NRHS, ONE, A, LDA, B, LDB )
+*
+*        Solve U*X = B, overwriting B with X.
+*
+         CALL ZTRSM( 'Left', 'Upper', 'No transpose', 'Non-unit', N,
+     $               NRHS, ONE, A, LDA, B, LDB )
+      ELSE
+*
+*        Solve A*X = B where A = L*L'.
+*
+*        Solve L*X = B, overwriting B with X.
+*
+         CALL ZTRSM( 'Left', 'Lower', 'No transpose', 'Non-unit', N,
+     $               NRHS, ONE, A, LDA, B, LDB )
+*
+*        Solve L'*X = B, overwriting B with X.
+*
+         CALL ZTRSM( 'Left', 'Lower', 'Conjugate transpose', 'Non-unit',
+     $               N, NRHS, ONE, A, LDA, B, LDB )
+      END IF
+*
+      RETURN
+*
+*     End of ZPOTRS
+*
+      END
diff --git a/libcruft/lapack/ztrcon.f b/libcruft/lapack/ztrcon.f
new file mode 100644
--- /dev/null
+++ b/libcruft/lapack/ztrcon.f
@@ -0,0 +1,200 @@
+      SUBROUTINE ZTRCON( NORM, UPLO, DIAG, N, A, LDA, RCOND, WORK,
+     $                   RWORK, INFO )
+*
+*  -- LAPACK routine (version 3.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
+*     Courant Institute, Argonne National Lab, and Rice University
+*     March 31, 1993
+*
+*     .. Scalar Arguments ..
+      CHARACTER          DIAG, NORM, UPLO
+      INTEGER            INFO, LDA, N
+      DOUBLE PRECISION   RCOND
+*     ..
+*     .. Array Arguments ..
+      DOUBLE PRECISION   RWORK( * )
+      COMPLEX*16         A( LDA, * ), WORK( * )
+*     ..
+*
+*  Purpose
+*  =======
+*
+*  ZTRCON estimates the reciprocal of the condition number of a
+*  triangular matrix A, in either the 1-norm or the infinity-norm.
+*
+*  The norm of A is computed and an estimate is obtained for
+*  norm(inv(A)), then the reciprocal of the condition number is
+*  computed as
+*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
+*
+*  Arguments
+*  =========
+*
+*  NORM    (input) CHARACTER*1
+*          Specifies whether the 1-norm condition number or the
+*          infinity-norm condition number is required:
+*          = '1' or 'O':  1-norm;
+*          = 'I':         Infinity-norm.
+*
+*  UPLO    (input) CHARACTER*1
+*          = 'U':  A is upper triangular;
+*          = 'L':  A is lower triangular.
+*
+*  DIAG    (input) CHARACTER*1
+*          = 'N':  A is non-unit triangular;
+*          = 'U':  A is unit triangular.
+*
+*  N       (input) INTEGER
+*          The order of the matrix A.  N >= 0.
+*
+*  A       (input) COMPLEX*16 array, dimension (LDA,N)
+*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
+*          upper triangular part of the array A contains the upper
+*          triangular matrix, and the strictly lower triangular part of
+*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
+*          triangular part of the array A contains the lower triangular
+*          matrix, and the strictly upper triangular part of A is not
+*          referenced.  If DIAG = 'U', the diagonal elements of A are
+*          also not referenced and are assumed to be 1.
+*
+*  LDA     (input) INTEGER
+*          The leading dimension of the array A.  LDA >= max(1,N).
+*
+*  RCOND   (output) DOUBLE PRECISION
+*          The reciprocal of the condition number of the matrix A,
+*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
+*
+*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
+*
+*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
+*
+*  INFO    (output) INTEGER
+*          = 0:  successful exit
+*          < 0:  if INFO = -i, the i-th argument had an illegal value
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      DOUBLE PRECISION   ONE, ZERO
+      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            NOUNIT, ONENRM, UPPER
+      CHARACTER          NORMIN
+      INTEGER            IX, KASE, KASE1
+      DOUBLE PRECISION   AINVNM, ANORM, SCALE, SMLNUM, XNORM
+      COMPLEX*16         ZDUM
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            IZAMAX
+      DOUBLE PRECISION   DLAMCH, ZLANTR
+      EXTERNAL           LSAME, IZAMAX, DLAMCH, ZLANTR
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           XERBLA, ZDRSCL, ZLACON, ZLATRS
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, DBLE, DIMAG, MAX
+*     ..
+*     .. Statement Functions ..
+      DOUBLE PRECISION   CABS1
+*     ..
+*     .. Statement Function definitions ..
+      CABS1( ZDUM ) = ABS( DBLE( ZDUM ) ) + ABS( DIMAG( ZDUM ) )
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters.
+*
+      INFO = 0
+      UPPER = LSAME( UPLO, 'U' )
+      ONENRM = NORM.EQ.'1' .OR. LSAME( NORM, 'O' )
+      NOUNIT = LSAME( DIAG, 'N' )
+*
+      IF( .NOT.ONENRM .AND. .NOT.LSAME( NORM, 'I' ) ) THEN
+         INFO = -1
+      ELSE IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -2
+      ELSE IF( .NOT.NOUNIT .AND. .NOT.LSAME( DIAG, 'U' ) ) THEN
+         INFO = -3
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -4
+      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
+         INFO = -6
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'ZTRCON', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 ) THEN
+         RCOND = ONE
+         RETURN
+      END IF
+*
+      RCOND = ZERO
+      SMLNUM = DLAMCH( 'Safe minimum' )*DBLE( MAX( 1, N ) )
+*
+*     Compute the norm of the triangular matrix A.
+*
+      ANORM = ZLANTR( NORM, UPLO, DIAG, N, N, A, LDA, RWORK )
+*
+*     Continue only if ANORM > 0.
+*
+      IF( ANORM.GT.ZERO ) THEN
+*
+*        Estimate the norm of the inverse of A.
+*
+         AINVNM = ZERO
+         NORMIN = 'N'
+         IF( ONENRM ) THEN
+            KASE1 = 1
+         ELSE
+            KASE1 = 2
+         END IF
+         KASE = 0
+   10    CONTINUE
+         CALL ZLACON( N, WORK( N+1 ), WORK, AINVNM, KASE )
+         IF( KASE.NE.0 ) THEN
+            IF( KASE.EQ.KASE1 ) THEN
+*
+*              Multiply by inv(A).
+*
+               CALL ZLATRS( UPLO, 'No transpose', DIAG, NORMIN, N, A,
+     $                      LDA, WORK, SCALE, RWORK, INFO )
+            ELSE
+*
+*              Multiply by inv(A').
+*
+               CALL ZLATRS( UPLO, 'Conjugate transpose', DIAG, NORMIN,
+     $                      N, A, LDA, WORK, SCALE, RWORK, INFO )
+            END IF
+            NORMIN = 'Y'
+*
+*           Multiply by 1/SCALE if doing so will not cause overflow.
+*
+            IF( SCALE.NE.ONE ) THEN
+               IX = IZAMAX( N, WORK, 1 )
+               XNORM = CABS1( WORK( IX ) )
+               IF( SCALE.LT.XNORM*SMLNUM .OR. SCALE.EQ.ZERO )
+     $            GO TO 20
+               CALL ZDRSCL( N, SCALE, WORK, 1 )
+            END IF
+            GO TO 10
+         END IF
+*
+*        Compute the estimate of the reciprocal condition number.
+*
+         IF( AINVNM.NE.ZERO )
+     $      RCOND = ( ONE / ANORM ) / AINVNM
+      END IF
+*
+   20 CONTINUE
+      RETURN
+*
+*     End of ZTRCON
+*
+      END
diff --git a/libcruft/lapack/ztrtrs.f b/libcruft/lapack/ztrtrs.f
new file mode 100644
--- /dev/null
+++ b/libcruft/lapack/ztrtrs.f
@@ -0,0 +1,149 @@
+      SUBROUTINE ZTRTRS( UPLO, TRANS, DIAG, N, NRHS, A, LDA, B, LDB,
+     $                   INFO )
+*
+*  -- LAPACK routine (version 3.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
+*     Courant Institute, Argonne National Lab, and Rice University
+*     September 30, 1994
+*
+*     .. Scalar Arguments ..
+      CHARACTER          DIAG, TRANS, UPLO
+      INTEGER            INFO, LDA, LDB, N, NRHS
+*     ..
+*     .. Array Arguments ..
+      COMPLEX*16         A( LDA, * ), B( LDB, * )
+*     ..
+*
+*  Purpose
+*  =======
+*
+*  ZTRTRS solves a triangular system of the form
+*
+*     A * X = B,  A**T * X = B,  or  A**H * X = B,
+*
+*  where A is a triangular matrix of order N, and B is an N-by-NRHS
+*  matrix.  A check is made to verify that A is nonsingular.
+*
+*  Arguments
+*  =========
+*
+*  UPLO    (input) CHARACTER*1
+*          = 'U':  A is upper triangular;
+*          = 'L':  A is lower triangular.
+*
+*  TRANS   (input) CHARACTER*1
+*          Specifies the form of the system of equations:
+*          = 'N':  A * X = B     (No transpose)
+*          = 'T':  A**T * X = B  (Transpose)
+*          = 'C':  A**H * X = B  (Conjugate transpose)
+*
+*  DIAG    (input) CHARACTER*1
+*          = 'N':  A is non-unit triangular;
+*          = 'U':  A is unit triangular.
+*
+*  N       (input) INTEGER
+*          The order of the matrix A.  N >= 0.
+*
+*  NRHS    (input) INTEGER
+*          The number of right hand sides, i.e., the number of columns
+*          of the matrix B.  NRHS >= 0.
+*
+*  A       (input) COMPLEX*16 array, dimension (LDA,N)
+*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
+*          upper triangular part of the array A contains the upper
+*          triangular matrix, and the strictly lower triangular part of
+*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
+*          triangular part of the array A contains the lower triangular
+*          matrix, and the strictly upper triangular part of A is not
+*          referenced.  If DIAG = 'U', the diagonal elements of A are
+*          also not referenced and are assumed to be 1.
+*
+*  LDA     (input) INTEGER
+*          The leading dimension of the array A.  LDA >= max(1,N).
+*
+*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
+*          On entry, the right hand side matrix B.
+*          On exit, if INFO = 0, the solution matrix X.
+*
+*  LDB     (input) INTEGER
+*          The leading dimension of the array B.  LDB >= max(1,N).
+*
+*  INFO    (output) INTEGER
+*          = 0:  successful exit
+*          < 0: if INFO = -i, the i-th argument had an illegal value
+*          > 0: if INFO = i, the i-th diagonal element of A is zero,
+*               indicating that the matrix is singular and the solutions
+*               X have not been computed.
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      COMPLEX*16         ZERO, ONE
+      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ),
+     $                   ONE = ( 1.0D+0, 0.0D+0 ) )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            NOUNIT
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           XERBLA, ZTRSM
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters.
+*
+      INFO = 0
+      NOUNIT = LSAME( DIAG, 'N' )
+      IF( .NOT.LSAME( UPLO, 'U' ) .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -1
+      ELSE IF( .NOT.LSAME( TRANS, 'N' ) .AND. .NOT.
+     $         LSAME( TRANS, 'T' ) .AND. .NOT.LSAME( TRANS, 'C' ) ) THEN
+         INFO = -2
+      ELSE IF( .NOT.NOUNIT .AND. .NOT.LSAME( DIAG, 'U' ) ) THEN
+         INFO = -3
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -4
+      ELSE IF( NRHS.LT.0 ) THEN
+         INFO = -5
+      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
+         INFO = -7
+      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
+         INFO = -9
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'ZTRTRS', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 )
+     $   RETURN
+*
+*     Check for singularity.
+*
+      IF( NOUNIT ) THEN
+         DO 10 INFO = 1, N
+            IF( A( INFO, INFO ).EQ.ZERO )
+     $         RETURN
+   10    CONTINUE
+      END IF
+      INFO = 0
+*
+*     Solve A * x = b,  A**T * x = b,  or  A**H * x = b.
+*
+      CALL ZTRSM( 'Left', UPLO, TRANS, DIAG, N, NRHS, ONE, A, LDA, B,
+     $            LDB )
+*
+      RETURN
+*
+*     End of ZTRTRS
+*
+      END
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -107,16 +107,53 @@ extern "C"
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgelss, ZGELSS) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
 			     Complex*, const octave_idx_type&, Complex*,
 			     const octave_idx_type&, double*, double&, octave_idx_type&,
 			     Complex*, const octave_idx_type&, double*, octave_idx_type&);
 
+  F77_RET_T
+  F77_FUNC (zpotrf, ZPOTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     Complex*, const octave_idx_type&, 
+			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (zpocon, ZPOCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     Complex*, const octave_idx_type&, const double&,
+			     double&, Complex*, double*,
+			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (zpotrs, ZPOTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const octave_idx_type&, const Complex*, 
+			     const octave_idx_type&, Complex*, 
+			     const octave_idx_type&, octave_idx_type&
+			     F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (ztrcon, ZTRCON) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
+			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const Complex*, const octave_idx_type&, double&,
+			     Complex*, double*, octave_idx_type& 
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (ztrtrs, ZTRTRS) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
+			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const octave_idx_type&, const Complex*, 
+			     const octave_idx_type&, Complex*, 
+			     const octave_idx_type&, octave_idx_type&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
+
   // Note that the original complex fft routines were not written for
   // double complex arguments.  They have been modified by adding an
   // implicit double precision (a-h,o-z) statement at the beginning of
   // each subroutine.
 
   F77_RET_T
   F77_FUNC (cffti, CFFTI) (const octave_idx_type&, Complex*);
 
@@ -1486,16 +1523,593 @@ ComplexMatrix::determinant (octave_idx_t
 	    }
 	}
     }
   
   return retval;
 }
 
 ComplexMatrix
+ComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b, 
+			octave_idx_type& info, double& rcond, 
+			solve_singularity_handler sing_handler,
+			bool calc_cond) const
+{
+  ComplexMatrix retval;
+
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr == 0 || nc == 0 || nr != b.rows ())
+    (*current_liboctave_error_handler)
+      ("matrix dimension mismatch solution of linear equations");
+  else
+    {
+      volatile int typ = mattype.type ();
+
+      if (typ == MatrixType::Permuted_Upper ||
+	  typ == MatrixType::Upper)
+	{
+	  octave_idx_type b_nc = b.cols ();
+	  rcond = 1.;
+	  info = 0;
+
+	  if (typ == MatrixType::Permuted_Upper)
+	    {
+	      (*current_liboctave_error_handler)
+		("Permuted triangular matrix not implemented");
+	    }
+	  else
+	    {
+	      const Complex *tmp_data = fortran_vec ();
+
+	      if (calc_cond)
+		{
+		  char norm = '1';
+		  char uplo = 'U';
+		  char dia = 'N';
+
+		  Array<Complex> z (2 * nc);
+		  Complex *pz = z.fortran_vec ();
+		  Array<double> rz (nc);
+		  double *prz = rz.fortran_vec ();
+
+		  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+					     F77_CONST_CHAR_ARG2 (&dia, 1), 
+					     nr, tmp_data, nr, rcond,
+					     pz, prz, info
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (f77_exception_encountered)
+		    (*current_liboctave_error_handler) 
+		      ("unrecoverable error in ztrcon");
+
+		  if (info != 0) 
+		    info = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		    {
+		      info = -2;
+
+		      if (sing_handler)
+			sing_handler (rcond);
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
+		    }
+		}
+
+	      if (info == 0)
+		{
+		  retval = b;
+		  Complex *result = retval.fortran_vec ();
+
+		  char uplo = 'U';
+		  char trans = 'N';
+		  char dia = 'N';
+
+		  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
+					     F77_CONST_CHAR_ARG2 (&trans, 1), 
+					     F77_CONST_CHAR_ARG2 (&dia, 1), 
+					     nr, b_nc, tmp_data, nr,
+					     result, nr, info
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (f77_exception_encountered)
+		    (*current_liboctave_error_handler) 
+		      ("unrecoverable error in dtrtrs");
+		}
+	    }
+	}
+      else
+	(*current_liboctave_error_handler) ("incorrect matrix type");
+    }
+
+  return retval;
+}
+
+ComplexMatrix
+ComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b, 
+			octave_idx_type& info, double& rcond, 
+			solve_singularity_handler sing_handler,
+			bool calc_cond) const
+{
+  ComplexMatrix retval;
+
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr == 0 || nc == 0 || nr != b.rows ())
+    (*current_liboctave_error_handler)
+      ("matrix dimension mismatch solution of linear equations");
+  else
+    {
+      volatile int typ = mattype.type ();
+
+      if (typ == MatrixType::Permuted_Lower ||
+	  typ == MatrixType::Lower)
+	{
+	  octave_idx_type b_nc = b.cols ();
+	  rcond = 1.;
+	  info = 0;
+
+	  if (typ == MatrixType::Permuted_Lower)
+	    {
+	      (*current_liboctave_error_handler)
+		("Permuted triangular matrix not implemented");
+	    }
+	  else
+	    {
+	      const Complex *tmp_data = fortran_vec ();
+
+	      if (calc_cond)
+		{
+		  char norm = '1';
+		  char uplo = 'L';
+		  char dia = 'N';
+
+		  Array<Complex> z (2 * nc);
+		  Complex *pz = z.fortran_vec ();
+		  Array<double> rz (nc);
+		  double *prz = rz.fortran_vec ();
+
+		  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+					     F77_CONST_CHAR_ARG2 (&dia, 1), 
+					     nr, tmp_data, nr, rcond,
+					     pz, prz, info
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (f77_exception_encountered)
+		    (*current_liboctave_error_handler) 
+		      ("unrecoverable error in ztrcon");
+
+		  if (info != 0) 
+		    info = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		    {
+		      info = -2;
+
+		      if (sing_handler)
+			sing_handler (rcond);
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
+		    }
+		}
+
+	      if (info == 0)
+		{
+		  retval = b;
+		  Complex *result = retval.fortran_vec ();
+
+		  char uplo = 'L';
+		  char trans = 'N';
+		  char dia = 'N';
+
+		  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
+					     F77_CONST_CHAR_ARG2 (&trans, 1), 
+					     F77_CONST_CHAR_ARG2 (&dia, 1), 
+					     nr, b_nc, tmp_data, nr,
+					     result, nr, info
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (f77_exception_encountered)
+		    (*current_liboctave_error_handler) 
+		      ("unrecoverable error in dtrtrs");
+		}
+	    }
+	}
+      else
+	(*current_liboctave_error_handler) ("incorrect matrix type");
+    }
+
+  return retval;
+}
+
+ComplexMatrix
+ComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b, 
+		       octave_idx_type& info, double& rcond,
+		       solve_singularity_handler sing_handler,
+		       bool calc_cond) const
+{
+  ComplexMatrix retval;
+
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+    (*current_liboctave_error_handler)
+      ("matrix dimension mismatch in solution of linear equations");
+  else
+    {
+      volatile int typ = mattype.type ();
+ 
+     // Calculate the norm of the matrix, for later use.
+      double anorm = -1.;
+
+      if (typ == MatrixType::Hermitian)
+	{
+	  info = 0;
+	  char job = 'L';
+	  ComplexMatrix atmp = *this;
+	  Complex *tmp_data = atmp.fortran_vec ();
+	  anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+
+	  F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+				     tmp_data, nr, info
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (f77_exception_encountered)
+	    (*current_liboctave_error_handler) 
+	      ("unrecoverable error in zpotrf");
+	  else
+	    {
+	      // Throw-away extra info LAPACK gives so as to not change output.
+	      rcond = 0.0;
+	      if (info != 0) 
+		{
+		  info = -2;
+
+		  mattype.mark_as_unsymmetric ();
+		  typ = MatrixType::Full;
+		}
+	      else 
+		{
+		  if (calc_cond)
+		    {
+		      Array<Complex> z (2 * nc);
+		      Complex *pz = z.fortran_vec ();
+		      Array<double> rz (nc);
+		      double *prz = rz.fortran_vec ();
+
+		      F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+						 nr, tmp_data, nr, anorm,
+						 rcond, pz, prz, info
+						 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+			(*current_liboctave_error_handler) 
+			  ("unrecoverable error in zpocon");
+	      
+		      if (info != 0) 
+			info = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+			{
+			  info = -2;
+
+			  if (sing_handler)
+			    sing_handler (rcond);
+			  else
+			    (*current_liboctave_error_handler)
+			      ("matrix singular to machine precision, rcond = %g",
+			       rcond);
+			}
+		    }
+
+		  if (info == 0)
+		    {
+		      retval = b;
+		      Complex *result = retval.fortran_vec ();
+
+		      octave_idx_type b_nc = b.cols ();
+
+		      F77_XFCN (zpotrs, ZPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+						 nr, b_nc, tmp_data, nr,
+						 result, b.rows(), info
+						 F77_CHAR_ARG_LEN (1)));
+		
+		      if (f77_exception_encountered)
+			(*current_liboctave_error_handler)
+			  ("unrecoverable error in zpotrs");
+		    }
+		  else
+		    {
+		      mattype.mark_as_unsymmetric ();
+		      typ = MatrixType::Full;
+		    }
+		}
+	    }
+	}
+
+      if (typ == MatrixType::Full)
+	{
+	  info = 0;
+
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+	  ComplexMatrix atmp = *this;
+	  Complex *tmp_data = atmp.fortran_vec ();
+
+	  Array<Complex> z (2 * nc);
+	  Complex *pz = z.fortran_vec ();
+	  Array<double> rz (2 * nc);
+	  double *prz = rz.fortran_vec ();
+
+	  // Calculate the norm of the matrix, for later use.
+	  if (anorm < 0.)
+	    anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+
+	  F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+	  if (f77_exception_encountered)
+	    (*current_liboctave_error_handler) 
+	      ("unrecoverable error in zgetrf");
+	  else
+	    {
+	      // Throw-away extra info LAPACK gives so as to not change output.
+	      rcond = 0.0;
+	      if (info != 0) 
+		{ 
+		  info = -2;
+
+		  if (sing_handler)
+		    sing_handler (rcond);
+		  else
+		    (*current_liboctave_error_handler)
+		      ("matrix singular to machine precision");
+
+		  mattype.mark_as_rectangular ();
+		} 
+	      else 
+		{
+		  if (calc_cond)
+		    {
+		      // Now calculate the condition number for 
+		      // non-singular matrix.
+		      char job = '1';
+		      F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+						 nc, tmp_data, nr, anorm, 
+						 rcond, pz, prz, info
+						 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+			(*current_liboctave_error_handler) 
+			  ("unrecoverable error in zgecon");
+
+		      if (info != 0) 
+			info = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+			{
+			  info = -2;
+
+			  if (sing_handler)
+			    sing_handler (rcond);
+			  else
+			    (*current_liboctave_error_handler)
+			      ("matrix singular to machine precision, rcond = %g",
+			       rcond);
+			}
+		    }
+
+		  if (info == 0)
+		    {
+		      retval = b;
+		      Complex *result = retval.fortran_vec ();
+
+		      octave_idx_type b_nc = b.cols ();
+
+		      char job = 'N';
+		      F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+						 nr, b_nc, tmp_data, nr,
+						 pipvt, result, b.rows(), info
+						 F77_CHAR_ARG_LEN (1))); 
+
+		      if (f77_exception_encountered)
+			(*current_liboctave_error_handler)
+			  ("unrecoverable error in zgetrs");
+		    }
+		  else
+		    mattype.mark_as_rectangular ();		    
+		}
+	    }
+	}
+    }
+  
+  return retval;
+}
+
+ComplexMatrix
+ComplexMatrix::solve (MatrixType &typ, const Matrix& b) const
+{
+  octave_idx_type info;
+  double rcond;
+  return solve (typ, b, info, rcond, 0);
+}
+
+ComplexMatrix
+ComplexMatrix::solve (MatrixType &typ, const Matrix& b, 
+		      octave_idx_type& info) const
+{
+  double rcond;
+  return solve (typ, b, info, rcond, 0);
+}
+
+ComplexMatrix
+ComplexMatrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+		      double& rcond) const
+{
+  return solve (typ, b, info, rcond, 0);
+}
+
+ComplexMatrix
+ComplexMatrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
+		      double& rcond, solve_singularity_handler sing_handler,
+		      bool singular_fallback) const
+{
+  ComplexMatrix tmp (b);
+  return solve (typ, tmp, info, rcond, sing_handler, singular_fallback);
+}
+
+ComplexMatrix
+ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b) const
+{
+  octave_idx_type info;
+  double rcond;
+  return solve (typ, b, info, rcond, 0);
+}
+
+ComplexMatrix
+ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b, 
+		      octave_idx_type& info) const
+{
+  double rcond;
+  return solve (typ, b, info, rcond, 0);
+}
+
+ComplexMatrix
+ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b, 
+		      octave_idx_type& info, double& rcond) const
+{
+  return solve (typ, b, info, rcond, 0);
+}
+
+ComplexMatrix
+ComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
+		      octave_idx_type& info, double& rcond,
+		      solve_singularity_handler sing_handler,
+		      bool singular_fallback) const
+{
+  ComplexMatrix retval;
+  int typ = mattype.type ();
+
+  if (typ == MatrixType::Unknown)
+    typ = mattype.type (*this);
+
+  // Only calculate the condition number for LU/Cholesky
+  if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
+    retval = utsolve (mattype, b, info, rcond, sing_handler, false);
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+    retval = ltsolve (mattype, b, info, rcond, sing_handler, false);
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
+    retval = fsolve (mattype, b, info, rcond, sing_handler, true);
+  else if (typ != MatrixType::Rectangular)
+    {
+      (*current_liboctave_error_handler) ("unknown matrix type");
+      return ComplexMatrix ();
+    }
+
+  // Rectangular or one of the above solvers flags a singular matrix
+  if (singular_fallback && mattype.type () == MatrixType::Rectangular)
+    {
+      octave_idx_type rank;
+      retval = lssolve (b, info, rank);
+    }
+
+  return retval;
+}
+
+ComplexColumnVector
+ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b) const
+{
+  octave_idx_type info;
+  double rcond;
+  return solve (typ, ComplexColumnVector (b), info, rcond, 0);
+}
+
+ComplexColumnVector
+ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
+		      octave_idx_type& info) const
+{
+  double rcond;
+  return solve (typ, ComplexColumnVector (b), info, rcond, 0);
+}
+
+ComplexColumnVector
+ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
+		      octave_idx_type& info, double& rcond) const
+{
+  return solve (typ, ComplexColumnVector (b), info, rcond, 0);
+}
+
+ComplexColumnVector
+ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
+		      octave_idx_type& info, double& rcond,
+		      solve_singularity_handler sing_handler) const
+{
+  return solve (typ, ComplexColumnVector (b), info, rcond, sing_handler);
+}
+
+ComplexColumnVector
+ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
+{
+  octave_idx_type info;
+  double rcond;
+  return solve (typ, b, info, rcond, 0);
+}
+
+ComplexColumnVector
+ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
+		      octave_idx_type& info) const
+{
+  double rcond;
+  return solve (typ, b, info, rcond, 0);
+}
+
+ComplexColumnVector
+ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
+		      octave_idx_type& info, double& rcond) const
+{
+  return solve (typ, b, info, rcond, 0);
+}
+
+ComplexColumnVector
+ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
+		      octave_idx_type& info, double& rcond,
+		      solve_singularity_handler sing_handler) const
+{
+
+  ComplexMatrix tmp (b);
+  return solve (typ, tmp, info, rcond, sing_handler).column(static_cast<octave_idx_type> (0));
+}
+
+ComplexMatrix
 ComplexMatrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
@@ -1539,112 +2153,18 @@ ComplexMatrix::solve (const ComplexMatri
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
 		      solve_singularity_handler sing_handler) const
 {
-  ComplexMatrix retval;
-
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
-    (*current_liboctave_error_handler)
-      ("matrix dimension mismatch in solution of linear equations");
-  else
-    {
-      info = 0;
-
-      Array<octave_idx_type> ipvt (nr);
-      octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-      ComplexMatrix atmp = *this;
-      Complex *tmp_data = atmp.fortran_vec ();
-
-      Array<Complex> z (2 * nc);
-      Complex *pz = z.fortran_vec ();
-      Array<double> rz (2 * nc);
-      double *prz = rz.fortran_vec ();
-
-      // Calculate the norm of the matrix, for later use.
-      double anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
-
-      F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in zgetrf");
-      else
-	{
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
-	  if (info != 0) 
-	    { 
-	      info = -2;
-
-	      if (sing_handler)
-		sing_handler (rcond);
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    } 
-	  else 
-	    {
-	      // Now calculate the condition number for non-singular matrix.
-	      char job = '1';
-	      F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					 nc, tmp_data, nr, anorm, 
-					 rcond, pz, prz, info
-					 F77_CHAR_ARG_LEN (1)));
-
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler) 
-		  ("unrecoverable error in zgecon");
-
-	      if (info != 0) 
-		info = -2;
-
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  info = -2;
-
-		  if (sing_handler)
-		    sing_handler (rcond);
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision, rcond = %g",
-		       rcond);
-		}
-	      else
-		{
-		  retval = b;
-		  Complex *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  job = 'N';
-		  F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, b_nc, tmp_data, nr,
-					     pipvt, result, b.rows(), info
-					     F77_CHAR_ARG_LEN (1))); 
-
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler)
-		      ("unrecoverable error in zgetrs");
-		}
-	    }
-	}
-    }
-  
-  return retval;
+  MatrixType mattype (*this);
+  return solve (b, info, rcond, sing_handler);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (ComplexColumnVector (b), info, rcond, 0);
@@ -1653,23 +2173,25 @@ ComplexMatrix::solve (const ColumnVector
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (ComplexColumnVector (b), info, rcond, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const
+ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, 
+		      double& rcond) const
 {
   return solve (ComplexColumnVector (b), info, rcond, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
+ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, 
+		      double& rcond, 
 		      solve_singularity_handler sing_handler) const
 {
   return solve (ComplexColumnVector (b), info, rcond, sing_handler);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b) const
 {
@@ -1692,110 +2214,18 @@ ComplexMatrix::solve (const ComplexColum
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
 		      double& rcond,
 		      solve_singularity_handler sing_handler) const
 {
-  ComplexColumnVector retval;
-
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.length ())
-    (*current_liboctave_error_handler)
-      ("matrix dimension mismatch in solution of linear equations");
-  else
-    {
-      info = 0;
-
-      Array<octave_idx_type> ipvt (nr);
-      octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-      ComplexMatrix atmp = *this;
-      Complex *tmp_data = atmp.fortran_vec ();
-
-      Array<Complex> z (2 * nc);
-      Complex *pz = z.fortran_vec ();
-      Array<double> rz (2 * nc);
-      double *prz = rz.fortran_vec ();
-
-      // Calculate the norm of the matrix, for later use.
-      double anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
-
-      F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in zgetrf");
-      else
-	{
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
-	  if (info != 0) 
-	    { 
-	      info = -2;
-
-	      if (sing_handler)
-		sing_handler (rcond);
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision, rcond = %g",
-		   rcond);
-	    } 
-	  else 
-	    {
-	      // Now calculate the condition number for non-singular matrix.
-	      char job = '1';
-	      F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					 nc, tmp_data, nr, anorm,
-					 rcond, pz, prz, info
-					 F77_CHAR_ARG_LEN (1)));
-
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler) 
-		  ("unrecoverable error in zgecon");
-
-	      if (info != 0) 
-		info = -2;
-
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  info = -2;
-		
-		  if (sing_handler)
-		    sing_handler (rcond);
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision, rcond = %g",
-		       rcond);
-		}
-	      else
-		{
-		  retval = b;
-		  Complex *result = retval.fortran_vec ();
-
-		  job = 'N';
-		  F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, 1, tmp_data, nr, pipvt,
-					     result, b.length(), info
-					     F77_CHAR_ARG_LEN (1))); 
-
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler)
-		      ("unrecoverable error in zgetrs");
-
-		}
-	    }
-	}
-    }
-  return retval;
+  MatrixType mattype (*this);
+  return solve (mattype, b, info, rcond, sing_handler);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const Matrix& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
   return lssolve (ComplexMatrix (b), info, rank);
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -21,16 +21,17 @@ 02110-1301, USA.
 
 */
 
 #if !defined (octave_ComplexMatrix_h)
 #define octave_ComplexMatrix_h 1
 
 #include "MArray2.h"
 #include "MDiagArray2.h"
+#include "MatrixType.h"
 
 #include "mx-defs.h"
 #include "mx-op-defs.h"
 #include "oct-cmplx.h"
 
 class
 ComplexMatrix : public MArray2<Complex>
 {
@@ -145,16 +146,76 @@ public:
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
 
   ComplexDET determinant (void) const;
   ComplexDET determinant (octave_idx_type& info) const;
   ComplexDET determinant (octave_idx_type& info, double& rcond, int calc_cond = 1) const;
 
+private:
+  // Upper triangular matrix solvers
+  ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
+		  octave_idx_type& info, double& rcond, 
+		  solve_singularity_handler sing_handler,
+		  bool calc_cond = false) const;
+
+  // Lower triangular matrix solvers
+  ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
+		  octave_idx_type& info, double& rcond, 
+		  solve_singularity_handler sing_handler,
+		  bool calc_cond = false) const;
+
+  // Full matrix solvers (umfpack/cholesky)
+  ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
+		 octave_idx_type& info, double& rcond, 
+		 solve_singularity_handler sing_handler,
+		 bool calc_cond = false) const;
+
+public:
+  // Generic interface to solver with no probing of type
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b) const;
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
+		       octave_idx_type& info) const;
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
+		       octave_idx_type& info, double& rcond) const;
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+		       double& rcond, solve_singularity_handler sing_handler,
+		       bool singular_fallback = true) const;
+
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+		       octave_idx_type& info) const;
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+		       octave_idx_type& info, double& rcond) const;
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+		       octave_idx_type& info, double& rcond,
+		       solve_singularity_handler sing_handler,
+		       bool singular_fallback = true) const;
+
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+			     octave_idx_type& info) const;
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+			     octave_idx_type& info, double& rcond) const;
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+			     octave_idx_type& info, double& rcond,
+			     solve_singularity_handler sing_handler) const;
+
+  ComplexColumnVector solve (MatrixType &typ, 
+			     const ComplexColumnVector& b) const;
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+			     octave_idx_type& info) const;
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+			     octave_idx_type& info, double& rcond) const;
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+			     octave_idx_type& info, double& rcond,
+			     solve_singularity_handler sing_handler) const;
+
+  // Generic interface to solver with probing of type
   ComplexMatrix solve (const Matrix& b) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
 		       solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -602,37 +602,37 @@ conj (const SparseComplexMatrix& a)
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::inverse (void) const
 {
   octave_idx_type info;
   double rcond;
-  SparseType mattype (*this);
+  MatrixType mattype (*this);
   return inverse (mattype, info, rcond, 0, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::inverse (SparseType& mattype) const
+SparseComplexMatrix::inverse (MatrixType& mattype) const
 {
   octave_idx_type info;
   double rcond;
   return inverse (mattype, info, rcond, 0, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::inverse (SparseType& mattype, octave_idx_type& info) const
+SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   double rcond;
   return inverse (mattype, info, rcond, 0, 0);
 }
 
 SparseComplexMatrix 
-SparseComplexMatrix::dinverse (SparseType &mattyp, octave_idx_type& info, 
+SparseComplexMatrix::dinverse (MatrixType &mattyp, octave_idx_type& info, 
 			double& rcond, const bool,
 			const bool calccond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
@@ -640,20 +640,20 @@ SparseComplexMatrix::dinverse (SparseTyp
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
-      if (typ == SparseType::Diagonal ||
-	  typ == SparseType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal ||
+	  typ == MatrixType::Permuted_Diagonal)
 	{
-	  if (typ == SparseType::Permuted_Diagonal)
+	  if (typ == MatrixType::Permuted_Diagonal)
 	    retval = transpose();
 	  else
 	    retval = *this;
 	      
 	  // Force make_unique to be called
 	  Complex *v = retval.data();
 
 	  if (calccond)
@@ -676,17 +676,17 @@ SparseComplexMatrix::dinverse (SparseTyp
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix 
-SparseComplexMatrix::tinverse (SparseType &mattyp, octave_idx_type& info, 
+SparseComplexMatrix::tinverse (MatrixType &mattyp, octave_idx_type& info, 
 			       double& rcond, const bool,
 			       const bool calccond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
@@ -694,18 +694,18 @@ SparseComplexMatrix::tinverse (SparseTyp
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
-      if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper ||
-	  typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+      if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper ||
+	  typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 
 	  if (calccond)
 	    {
 	      // Calculate the 1-norm of matrix for rcond calculation
 	      for (octave_idx_type j = 0; j < nr; j++)
@@ -713,17 +713,17 @@ SparseComplexMatrix::tinverse (SparseTyp
 		  double atmp = 0.;
 		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		    atmp += std::abs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
-	  if (typ == SparseType::Upper || typ == SparseType::Lower)
+	  if (typ == MatrixType::Upper || typ == MatrixType::Lower)
 	    {
 	      octave_idx_type nz = nnz ();
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseComplexMatrix (nr, nc, nz2);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
@@ -809,17 +809,17 @@ SparseComplexMatrix::tinverse (SparseTyp
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseComplexMatrix (nr, nc, nz2);
 
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
 
 	      octave_idx_type *perm = mattyp.triangular_perm();
-	      if (typ == SparseType::Permuted_Upper)
+	      if (typ == MatrixType::Permuted_Upper)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    rperm[perm[i]] = i;
 		}
 	      else
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    rperm[i] = perm[i];
@@ -914,62 +914,62 @@ SparseComplexMatrix::tinverse (SparseTyp
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::inverse (SparseType& mattype, octave_idx_type& info, 
+SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info, 
 			      double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
   SparseComplexMatrix ret;
 
-  if (typ == SparseType::Unknown)
+  if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
-  if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
+  if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     ret = dinverse (mattype, info, rcond, true, calc_cond);
-  else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
+  else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     ret = tinverse (mattype, info, rcond, true, calc_cond).transpose();
-  else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     ret = transpose().tinverse (mattype, info, rcond, true, calc_cond);
-  else if (typ != SparseType::Rectangular)
+  else if (typ != MatrixType::Rectangular)
     {
       if (mattype.is_hermitian())
 	{
-	  SparseType tmp_typ (SparseType::Upper);
+	  MatrixType tmp_typ (MatrixType::Upper);
 	  SparseComplexCHOL fact (*this, info, false);
 	  rcond = fact.rcond();
 	  if (info == 0)
 	    {
 	      double rcond2;
 	      SparseMatrix Q = fact.Q();
 	      SparseComplexMatrix InvL = fact.L().transpose().
 		tinverse(tmp_typ, info, rcond2, true, false);
 	      ret = Q * InvL.hermitian() * InvL * Q.transpose();
 	    }
 	  else
 	    {
 	      // Matrix is either singular or not positive definite
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Full;
+	      typ = MatrixType::Full;
 	    }
 	}
 
       if (!mattype.is_hermitian())
 	{
 	  octave_idx_type n = rows();
 	  ColumnVector Qinit(n);
 	  for (octave_idx_type i = 0; i < n; i++)
 	    Qinit(i) = i;
 
-	  SparseType tmp_typ (SparseType::Upper);
+	  MatrixType tmp_typ (MatrixType::Upper);
 	  SparseComplexLU fact (*this, Qinit, -1.0, false);
 	  rcond = fact.rcond();
 	  double rcond2;
 	  SparseComplexMatrix InvL = fact.L().transpose().
 	    tinverse(tmp_typ, info, rcond2, true, false);
 	  SparseComplexMatrix InvU = fact.U().
 	    tinverse(tmp_typ, info, rcond2, true, false).transpose();
 	  ret = fact.Pc().transpose() * InvU * InvL * fact.Pr();
@@ -1120,17 +1120,17 @@ SparseComplexMatrix::determinant (octave
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::dsolve (SparseType &mattype, const Matrix& b,
+SparseComplexMatrix::dsolve (MatrixType &mattype, const Matrix& b,
 			     octave_idx_type& err, double& rcond, 
 			     solve_singularity_handler, bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1140,21 +1140,21 @@ SparseComplexMatrix::dsolve (SparseType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Diagonal ||
-	  typ == SparseType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal ||
+	  typ == MatrixType::Permuted_Diagonal)
 	{
 	  retval.resize (nc, b.cols(), Complex(0.,0.));
-	  if (typ == SparseType::Diagonal)
+	  if (typ == MatrixType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 		for (octave_idx_type i = 0; i < nm; i++)
 		  retval(i,j) = b(i,j) / data (i);
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      for (octave_idx_type k = 0; k < nc; k++)
 		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 		  retval(k,j) = b(ridx(i),j) / data (i);
@@ -1178,17 +1178,17 @@ SparseComplexMatrix::dsolve (SparseType 
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::dsolve (SparseType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::dsolve (MatrixType &mattype, const SparseMatrix& b,
 			     octave_idx_type& err, double& rcond, 
 			     solve_singularity_handler,
 			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1199,26 +1199,26 @@ SparseComplexMatrix::dsolve (SparseType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Diagonal ||
-	  typ == SparseType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal ||
+	  typ == MatrixType::Permuted_Diagonal)
 	{
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
-	  if (typ == SparseType::Diagonal)
+	  if (typ == MatrixType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
 		    if (b.ridx(i) >= nm)
 		      break;
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
@@ -1267,17 +1267,17 @@ SparseComplexMatrix::dsolve (SparseType 
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::dsolve (SparseType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::dsolve (MatrixType &mattype, const ComplexMatrix& b,
 			     octave_idx_type& err, double& rcond, 
 			     solve_singularity_handler,
 			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1288,21 +1288,21 @@ SparseComplexMatrix::dsolve (SparseType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Diagonal ||
-	  typ == SparseType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal ||
+	  typ == MatrixType::Permuted_Diagonal)
 	{
 	  retval.resize (nc, b.cols(), Complex(0.,0.));
-	  if (typ == SparseType::Diagonal)
+	  if (typ == MatrixType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      for (octave_idx_type i = 0; i < nm; i++)
 		retval(i,j) = b(i,j) / data (i);
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      for (octave_idx_type k = 0; k < nc; k++)
 		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 		  retval(k,j) = b(ridx(i),j) / data (i);
@@ -1326,17 +1326,17 @@ SparseComplexMatrix::dsolve (SparseType 
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::dsolve (SparseType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::dsolve (MatrixType &mattype, const SparseComplexMatrix& b,
 			     octave_idx_type& err, double& rcond, 
 			     solve_singularity_handler,
 			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1347,26 +1347,26 @@ SparseComplexMatrix::dsolve (SparseType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Diagonal ||
-	  typ == SparseType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal ||
+	  typ == MatrixType::Permuted_Diagonal)
 	{
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
-	  if (typ == SparseType::Diagonal)
+	  if (typ == MatrixType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
 		    if (b.ridx(i) >= nm)
 		      break;
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
@@ -1415,17 +1415,17 @@ SparseComplexMatrix::dsolve (SparseType 
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::utsolve (SparseType &mattype, const Matrix& b,
+SparseComplexMatrix::utsolve (MatrixType &mattype, const Matrix& b,
 			      octave_idx_type& err, double& rcond,
 			      solve_singularity_handler sing_handler,
 			      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1436,18 +1436,18 @@ SparseComplexMatrix::utsolve (SparseType
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Permuted_Upper ||
-	  typ == SparseType::Upper)
+      if (typ == MatrixType::Permuted_Upper ||
+	  typ == MatrixType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
@@ -1457,17 +1457,17 @@ SparseComplexMatrix::utsolve (SparseType
 		  double atmp = 0.;
 		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		    atmp += std::abs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
-	  if (typ == SparseType::Permuted_Upper)
+	  if (typ == MatrixType::Permuted_Upper)
 	    {
 	      retval.resize (nc, b_nc);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
@@ -1649,17 +1649,17 @@ SparseComplexMatrix::utsolve (SparseType
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::utsolve (SparseType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::utsolve (MatrixType &mattype, const SparseMatrix& b,
 			      octave_idx_type& err, double& rcond, 
 			      solve_singularity_handler sing_handler,
 			      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1670,18 +1670,18 @@ SparseComplexMatrix::utsolve (SparseType
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Permuted_Upper ||
-	  typ == SparseType::Upper)
+      if (typ == MatrixType::Permuted_Upper ||
+	  typ == MatrixType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
 	      // Calculate the 1-norm of matrix for rcond calculation
@@ -1697,17 +1697,17 @@ SparseComplexMatrix::utsolve (SparseType
 
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
-	  if (typ == SparseType::Permuted_Upper)
+	  if (typ == MatrixType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
 	      for (octave_idx_type i = 0; i < nc; i++)
 		rperm[perm[i]] = i;
 
@@ -1934,17 +1934,17 @@ SparseComplexMatrix::utsolve (SparseType
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::utsolve (SparseType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
 			      octave_idx_type& err, double& rcond, 
 			      solve_singularity_handler sing_handler,
 			      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1955,18 +1955,18 @@ SparseComplexMatrix::utsolve (SparseType
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Permuted_Upper ||
-	  typ == SparseType::Upper)
+      if (typ == MatrixType::Permuted_Upper ||
+	  typ == MatrixType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
@@ -1976,17 +1976,17 @@ SparseComplexMatrix::utsolve (SparseType
 		  double atmp = 0.;
 		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		    atmp += std::abs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
-	  if (typ == SparseType::Permuted_Upper)
+	  if (typ == MatrixType::Permuted_Upper)
 	    {
 	      retval.resize (nc, b_nc);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
@@ -2168,17 +2168,17 @@ SparseComplexMatrix::utsolve (SparseType
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::utsolve (SparseType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::utsolve (MatrixType &mattype, const SparseComplexMatrix& b,
 			      octave_idx_type& err, double& rcond, 
 			      solve_singularity_handler sing_handler,
 			      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2189,18 +2189,18 @@ SparseComplexMatrix::utsolve (SparseType
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Permuted_Upper ||
-	  typ == SparseType::Upper)
+      if (typ == MatrixType::Permuted_Upper ||
+	  typ == MatrixType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
 	      // Calculate the 1-norm of matrix for rcond calculation
@@ -2216,17 +2216,17 @@ SparseComplexMatrix::utsolve (SparseType
 
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
-	  if (typ == SparseType::Permuted_Upper)
+	  if (typ == MatrixType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
 	      for (octave_idx_type i = 0; i < nc; i++)
 		rperm[perm[i]] = i;
 
@@ -2454,17 +2454,17 @@ SparseComplexMatrix::utsolve (SparseType
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::ltsolve (SparseType &mattype, const Matrix& b, 
+SparseComplexMatrix::ltsolve (MatrixType &mattype, const Matrix& b, 
 			      octave_idx_type& err, double& rcond, 
 			      solve_singularity_handler sing_handler,
 			      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2475,18 +2475,18 @@ SparseComplexMatrix::ltsolve (SparseType
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Permuted_Lower ||
-	  typ == SparseType::Lower)
+      if (typ == MatrixType::Permuted_Lower ||
+	  typ == MatrixType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
@@ -2496,17 +2496,17 @@ SparseComplexMatrix::ltsolve (SparseType
 		  double atmp = 0.;
 		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		    atmp += std::abs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
-	  if (typ == SparseType::Permuted_Lower)
+	  if (typ == MatrixType::Permuted_Lower)
 	    {
 	      retval.resize (nc, b_nc);
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nm; i++)
@@ -2708,17 +2708,17 @@ SparseComplexMatrix::ltsolve (SparseType
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::ltsolve (SparseType &mattype, const SparseMatrix& b, 
+SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b, 
 			      octave_idx_type& err, double& rcond, 
 			      solve_singularity_handler sing_handler,
 			      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2730,18 +2730,18 @@ SparseComplexMatrix::ltsolve (SparseType
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Permuted_Lower ||
-	  typ == SparseType::Lower)
+      if (typ == MatrixType::Permuted_Lower ||
+	  typ == MatrixType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
 	      // Calculate the 1-norm of matrix for rcond calculation
@@ -2757,17 +2757,17 @@ SparseComplexMatrix::ltsolve (SparseType
 
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
-	  if (typ == SparseType::Permuted_Lower)
+	  if (typ == MatrixType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
@@ -3014,17 +3014,17 @@ SparseComplexMatrix::ltsolve (SparseType
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::ltsolve (SparseType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
 			      octave_idx_type& err, double& rcond,
 			      solve_singularity_handler sing_handler,
 			      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3035,18 +3035,18 @@ SparseComplexMatrix::ltsolve (SparseType
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Permuted_Lower ||
-	  typ == SparseType::Lower)
+      if (typ == MatrixType::Permuted_Lower ||
+	  typ == MatrixType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
@@ -3056,17 +3056,17 @@ SparseComplexMatrix::ltsolve (SparseType
 		  double atmp = 0.;
 		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		    atmp += std::abs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
-	  if (typ == SparseType::Permuted_Lower)
+	  if (typ == MatrixType::Permuted_Lower)
 	    {
 	      retval.resize (nc, b_nc);
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nm; i++)
@@ -3272,17 +3272,17 @@ SparseComplexMatrix::ltsolve (SparseType
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::ltsolve (SparseType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseComplexMatrix& b,
 			      octave_idx_type& err, double& rcond, 
 			      solve_singularity_handler sing_handler,
 			      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3293,18 +3293,18 @@ SparseComplexMatrix::ltsolve (SparseType
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Permuted_Lower ||
-	  typ == SparseType::Lower)
+      if (typ == MatrixType::Permuted_Lower ||
+	  typ == MatrixType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
 	      // Calculate the 1-norm of matrix for rcond calculation
@@ -3320,17 +3320,17 @@ SparseComplexMatrix::ltsolve (SparseType
 
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
-	  if (typ == SparseType::Permuted_Lower)
+	  if (typ == MatrixType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
@@ -3577,17 +3577,17 @@ SparseComplexMatrix::ltsolve (SparseType
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::trisolve (SparseType &mattype, const Matrix& b,
+SparseComplexMatrix::trisolve (MatrixType &mattype, const Matrix& b,
 			       octave_idx_type& err, double& rcond,
 			       solve_singularity_handler sing_handler,
 			       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3600,17 +3600,17 @@ SparseComplexMatrix::trisolve (SparseTyp
     (*current_liboctave_error_handler) 
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Tridiagonal_Hermitian)
+      if (typ == MatrixType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
 	      octave_idx_type ii = 0;
 
@@ -3650,23 +3650,23 @@ SparseComplexMatrix::trisolve (SparseTyp
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zptsv");
 	  else if (err != 0)
 	    {
 	      err = 0;
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Tridiagonal;
+	      typ = MatrixType::Tridiagonal;
 	    }
 	  else 
 	    rcond = 1.;
 	}
 
-      if (typ == SparseType::Tridiagonal)
+      if (typ == MatrixType::Tridiagonal)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
 	      octave_idx_type ii = 0;
@@ -3724,25 +3724,25 @@ SparseComplexMatrix::trisolve (SparseTyp
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 
 	    } 
 	  else 
 	    rcond = 1.;
 	}
-      else if (typ != SparseType::Tridiagonal_Hermitian)
+      else if (typ != MatrixType::Tridiagonal_Hermitian)
 	       (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::trisolve (SparseType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::trisolve (MatrixType &mattype, const SparseMatrix& b,
 			       octave_idx_type& err, double& rcond, 
 			       solve_singularity_handler sing_handler,
 			       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3756,18 +3756,18 @@ SparseComplexMatrix::trisolve (SparseTyp
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       // Note can't treat symmetric case as there is no dpttrf function
-      if (typ == SparseType::Tridiagonal ||
-	  typ == SparseType::Tridiagonal_Hermitian)
+      if (typ == MatrixType::Tridiagonal ||
+	  typ == MatrixType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
 	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -3882,25 +3882,25 @@ SparseComplexMatrix::trisolve (SparseTyp
 			  }
 		      retval.xcidx(j+1) = ii;
 		    }
 
 		  retval.maybe_compress ();
 		}
 	    }
 	}
-      else if (typ != SparseType::Tridiagonal_Hermitian)
+      else if (typ != MatrixType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::trisolve (SparseType &mattype, const ComplexMatrix& b,
+SparseComplexMatrix::trisolve (MatrixType &mattype, const ComplexMatrix& b,
 			       octave_idx_type& err, double& rcond, 
 			       solve_singularity_handler sing_handler,
 			       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3913,17 +3913,17 @@ SparseComplexMatrix::trisolve (SparseTyp
     (*current_liboctave_error_handler) 
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Tridiagonal_Hermitian)
+      if (typ == MatrixType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
 	      octave_idx_type ii = 0;
 
@@ -3969,21 +3969,21 @@ SparseComplexMatrix::trisolve (SparseTyp
 	      (*current_liboctave_error_handler) 
 		("unrecoverable error in zptsv");
 	      err = -1;
 	    }
 	  else if (err != 0)
 	    {
 	      err = 0;
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Tridiagonal;
+	      typ = MatrixType::Tridiagonal;
 	    }
 	}
 
-      if (typ == SparseType::Tridiagonal)
+      if (typ == MatrixType::Tridiagonal)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
 	      octave_idx_type ii = 0;
@@ -4044,25 +4044,25 @@ SparseComplexMatrix::trisolve (SparseTyp
 		  sing_handler (rcond);
 		  mattype.mark_as_rectangular ();
 		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 	    }
 	}
-      else if (typ != SparseType::Tridiagonal_Hermitian)
+      else if (typ != MatrixType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::trisolve (SparseType &mattype, 
+SparseComplexMatrix::trisolve (MatrixType &mattype, 
 			       const SparseComplexMatrix& b, 
 			       octave_idx_type& err, double& rcond, 
 			       solve_singularity_handler sing_handler,
 			       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
@@ -4077,18 +4077,18 @@ SparseComplexMatrix::trisolve (SparseTyp
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       // Note can't treat symmetric case as there is no dpttrf function
-      if (typ == SparseType::Tridiagonal ||
-	  typ == SparseType::Tridiagonal_Hermitian)
+      if (typ == MatrixType::Tridiagonal ||
+	  typ == MatrixType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
 	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -4214,25 +4214,25 @@ SparseComplexMatrix::trisolve (SparseTyp
 
 		      retval.xcidx(j+1) = ii;
 		    }
 
 		  retval.maybe_compress ();
 		}
 	    }
 	}
-      else if (typ != SparseType::Tridiagonal_Hermitian)
+      else if (typ != MatrixType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::bsolve (SparseType &mattype, const Matrix& b,
+SparseComplexMatrix::bsolve (MatrixType &mattype, const Matrix& b,
 			     octave_idx_type& err, double& rcond,
 			     solve_singularity_handler sing_handler,
 			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4242,17 +4242,17 @@ SparseComplexMatrix::bsolve (SparseType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Banded_Hermitian)
+      if (typ == MatrixType::Banded_Hermitian)
 	{
 	  octave_idx_type n_lower = mattype.nlower ();
 	  octave_idx_type ldm = n_lower + 1;
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
@@ -4287,17 +4287,17 @@ SparseComplexMatrix::bsolve (SparseType 
 	  else
 	    {
 	      if (err != 0) 
 		{
 		  rcond = 0.0;
 		  // Matrix is not positive definite!! Fall through to
 		  // unsymmetric banded solver.
 		  mattype.mark_as_unsymmetric ();
-		  typ = SparseType::Banded;
+		  typ = MatrixType::Banded;
 		  err = 0;
 		} 
 	      else 
 		{
 		  if (calc_cond)
 		    {
 		      Array<Complex> z (2 * nr);
 		      Complex *pz = z.fortran_vec ();
@@ -4360,17 +4360,17 @@ SparseComplexMatrix::bsolve (SparseType 
 			    ("SparseMatrix::solve solve failed");
 			  err = -1;
 			}
 		    }
 		}
 	    }
 	}
 
-      if (typ == SparseType::Banded)
+      if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  octave_idx_type n_upper = mattype.nupper ();
 	  octave_idx_type n_lower = mattype.nlower ();
 	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
@@ -4488,25 +4488,25 @@ SparseComplexMatrix::bsolve (SparseType 
 		    
 		      if (f77_exception_encountered)
 			(*current_liboctave_error_handler)
 			  ("unrecoverable error in zgbtrs");
 		    }
 		}
 	    }
 	}
-      else if (typ != SparseType::Banded_Hermitian)
+      else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::bsolve (SparseType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::bsolve (MatrixType &mattype, const SparseMatrix& b,
 			     octave_idx_type& err, double& rcond, 
 			     solve_singularity_handler sing_handler,
 			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4516,17 +4516,17 @@ SparseComplexMatrix::bsolve (SparseType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Banded_Hermitian)
+      if (typ == MatrixType::Banded_Hermitian)
 	{
 	  octave_idx_type n_lower = mattype.nlower ();
 	  octave_idx_type ldm = n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
@@ -4560,17 +4560,17 @@ SparseComplexMatrix::bsolve (SparseType 
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zpbtrf");
 	  else
 	    {
 	      if (err != 0) 
 		{
 		  rcond = 0.0;
 		  mattype.mark_as_unsymmetric ();
-		  typ = SparseType::Banded;
+		  typ = MatrixType::Banded;
 		  err = 0;
 		} 
 	      else 
 		{
 		  if (calc_cond)
 		    {
 		      Array<Complex> z (2 * nr);
 		      Complex *pz = z.fortran_vec ();
@@ -4672,17 +4672,17 @@ SparseComplexMatrix::bsolve (SparseType 
 			}
 
 		      retval.maybe_compress ();
 		    }
 		}
 	    }
 	}
 
-      if (typ == SparseType::Banded)
+      if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  octave_idx_type n_upper = mattype.nupper ();
 	  octave_idx_type n_lower = mattype.nlower ();
 	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
@@ -4839,25 +4839,25 @@ SparseComplexMatrix::bsolve (SparseType 
 			  retval.xcidx(j+1) = ii;
 			}
 
 		      retval.maybe_compress ();
 		    }
 		}
 	    }
 	}
-      else if (typ != SparseType::Banded_Hermitian)
+      else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::bsolve (SparseType &mattype, const ComplexMatrix& b, 
+SparseComplexMatrix::bsolve (MatrixType &mattype, const ComplexMatrix& b, 
 			     octave_idx_type& err, double& rcond, 
 			     solve_singularity_handler sing_handler,
 			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4867,17 +4867,17 @@ SparseComplexMatrix::bsolve (SparseType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Banded_Hermitian)
+      if (typ == MatrixType::Banded_Hermitian)
 	{
 	  octave_idx_type n_lower = mattype.nlower ();
 	  octave_idx_type ldm = n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
@@ -4913,17 +4913,17 @@ SparseComplexMatrix::bsolve (SparseType 
 	  else
 	    {
 	      if (err != 0) 
 		{
 		  // Matrix is not positive definite!! Fall through to
 		  // unsymmetric banded solver.
 		  rcond = 0.0;
 		  mattype.mark_as_unsymmetric ();
-		  typ = SparseType::Banded;
+		  typ = MatrixType::Banded;
 		  err = 0;
 		} 
 	      else 
 		{
 		  if (calc_cond)
 		    {
 		      Array<Complex> z (2 * nr);
 		      Complex *pz = z.fortran_vec ();
@@ -4989,17 +4989,17 @@ SparseComplexMatrix::bsolve (SparseType 
 			    ("SparseComplexMatrix::solve solve failed");
 			  err = -1;
 			}
 		    }
 		}
 	    }
 	}
 
-      if (typ == SparseType::Banded)
+      if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  octave_idx_type n_upper = mattype.nupper ();
 	  octave_idx_type n_lower = mattype.nlower ();
 	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
@@ -5116,25 +5116,25 @@ SparseComplexMatrix::bsolve (SparseType 
 			{
 			  (*current_liboctave_error_handler)
 			    ("unrecoverable error in dgbtrs");
 			}
 		    }
 		}
 	    }
 	}
-      else if (typ != SparseType::Banded_Hermitian)
+      else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::bsolve (SparseType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::bsolve (MatrixType &mattype, const SparseComplexMatrix& b,
 			     octave_idx_type& err, double& rcond, 
 			     solve_singularity_handler sing_handler,
 			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -5144,17 +5144,17 @@ SparseComplexMatrix::bsolve (SparseType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Banded_Hermitian)
+      if (typ == MatrixType::Banded_Hermitian)
 	{
 	  octave_idx_type n_lower = mattype.nlower ();
 	  octave_idx_type ldm = n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
@@ -5189,17 +5189,17 @@ SparseComplexMatrix::bsolve (SparseType 
 	      ("unrecoverable error in zpbtrf");
 	  else
 	    {
 	      if (err != 0) 
 		{
 		  // Matrix is not positive definite!! Fall through to
 		  // unsymmetric banded solver.
 		  mattype.mark_as_unsymmetric ();
-		  typ = SparseType::Banded;
+		  typ = MatrixType::Banded;
 
 		  rcond = 0.0;
 		  err = 0;
 		} 
 	      else 
 		{
 		  if (calc_cond)
 		    {
@@ -5308,17 +5308,17 @@ SparseComplexMatrix::bsolve (SparseType 
 			}
 
 		      retval.maybe_compress ();
 		    }
 		}
 	    }
 	}
 
-      if (typ == SparseType::Banded)
+      if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  octave_idx_type n_upper = mattype.nupper ();
 	  octave_idx_type n_lower = mattype.nlower ();
 	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
@@ -5476,17 +5476,17 @@ SparseComplexMatrix::bsolve (SparseType 
 			  retval.xcidx(j+1) = ii;
 			}
 
 		      retval.maybe_compress ();
 		    }
 		}
 	    }
 	}
-      else if (typ != SparseType::Banded_Hermitian)
+      else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 void *
 SparseComplexMatrix::factorize (octave_idx_type& err, double &rcond,
@@ -5600,17 +5600,17 @@ SparseComplexMatrix::factorize (octave_i
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return Numeric;
 }
 
 ComplexMatrix
-SparseComplexMatrix::fsolve (SparseType &mattype, const Matrix& b,
+SparseComplexMatrix::fsolve (MatrixType &mattype, const Matrix& b,
 			     octave_idx_type& err, double& rcond,
 			     solve_singularity_handler sing_handler,
 			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -5620,17 +5620,17 @@ SparseComplexMatrix::fsolve (SparseType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Hermitian)
+      if (typ == MatrixType::Hermitian)
 	{
 #ifdef HAVE_CHOLMOD
 	  cholmod_common Common;
 	  cholmod_common *cm = &Common;
 
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
@@ -5719,17 +5719,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	  else
 	    rcond = 1.;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Full;
+	      typ = MatrixType::Full;
 	    }
 	  else
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
@@ -5767,21 +5767,21 @@ SparseComplexMatrix::fsolve (SparseType 
 	      CHOLMOD_NAME(print_common) (" ", cm);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 #else
 	  (*current_liboctave_warning_handler)
 	    ("CHOLMOD not installed");
 
 	  mattype.mark_as_unsymmetric ();
-	  typ = SparseType::Full;
+	  typ = MatrixType::Full;
 #endif
 	}
 
-      if (typ == SparseType::Full)
+      if (typ == MatrixType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
 				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
@@ -5849,25 +5849,25 @@ SparseComplexMatrix::fsolve (SparseType 
 	    }
 	  else
 	    mattype.mark_as_rectangular ();
 
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
-      else if (typ != SparseType::Hermitian)
+      else if (typ != MatrixType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::fsolve (SparseType &mattype, const SparseMatrix& b, 
+SparseComplexMatrix::fsolve (MatrixType &mattype, const SparseMatrix& b, 
 			     octave_idx_type& err, double& rcond,
 			     solve_singularity_handler sing_handler,
 			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -5877,17 +5877,17 @@ SparseComplexMatrix::fsolve (SparseType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Hermitian)
+      if (typ == MatrixType::Hermitian)
 	{
 #ifdef HAVE_CHOLMOD
 	  cholmod_common Common;
 	  cholmod_common *cm = &Common;
 
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
@@ -5989,17 +5989,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	  else
 	    rcond = 1.;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Full;
+	      typ = MatrixType::Full;
 	    }
 	  else
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
@@ -6043,21 +6043,21 @@ SparseComplexMatrix::fsolve (SparseType 
 	      CHOLMOD_NAME(print_common) (" ", cm);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 #else
 	  (*current_liboctave_warning_handler)
 	    ("CHOLMOD not installed");
 
 	  mattype.mark_as_unsymmetric ();
-	  typ = SparseType::Full;
+	  typ = MatrixType::Full;
 #endif
 	}
 
-      if (typ == SparseType::Full)
+      if (typ == MatrixType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
 				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
@@ -6157,25 +6157,25 @@ SparseComplexMatrix::fsolve (SparseType 
 	    }
 	  else
 	    mattype.mark_as_rectangular ();
 
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
-      else if (typ != SparseType::Hermitian)
+      else if (typ != MatrixType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::fsolve (SparseType &mattype, const ComplexMatrix& b, 
+SparseComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b, 
 			     octave_idx_type& err, double& rcond,
 			     solve_singularity_handler sing_handler,
 			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6185,17 +6185,17 @@ SparseComplexMatrix::fsolve (SparseType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Hermitian)
+      if (typ == MatrixType::Hermitian)
 	{
 #ifdef HAVE_CHOLMOD
 	  cholmod_common Common;
 	  cholmod_common *cm = &Common;
 
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
@@ -6287,17 +6287,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	  else
 	    rcond = 1.;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Full;
+	      typ = MatrixType::Full;
 	    }
 	  else
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
@@ -6335,21 +6335,21 @@ SparseComplexMatrix::fsolve (SparseType 
 	      CHOLMOD_NAME(print_common) (" ", cm);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 #else
 	  (*current_liboctave_warning_handler)
 	    ("CHOLMOD not installed");
 
 	  mattype.mark_as_unsymmetric ();
-	  typ = SparseType::Full;
+	  typ = MatrixType::Full;
 #endif
 	}
 
-      if (typ == SparseType::Full)
+      if (typ == MatrixType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info,
 				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
@@ -6396,25 +6396,25 @@ SparseComplexMatrix::fsolve (SparseType 
 	    }
 	  else
 	    mattype.mark_as_rectangular ();
 
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
-      else if (typ != SparseType::Hermitian)
+      else if (typ != MatrixType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::fsolve (SparseType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::fsolve (MatrixType &mattype, const SparseComplexMatrix& b,
 			     octave_idx_type& err, double& rcond,
 			     solve_singularity_handler sing_handler,
 			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6424,17 +6424,17 @@ SparseComplexMatrix::fsolve (SparseType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Hermitian)
+      if (typ == MatrixType::Hermitian)
 	{
 #ifdef HAVE_CHOLMOD
 	  cholmod_common Common;
 	  cholmod_common *cm = &Common;
 
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
@@ -6536,17 +6536,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	  else
 	    rcond = 1.;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Full;
+	      typ = MatrixType::Full;
 	    }
 	  else
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
@@ -6590,21 +6590,21 @@ SparseComplexMatrix::fsolve (SparseType 
 	      CHOLMOD_NAME(print_common) (" ", cm);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 #else
 	  (*current_liboctave_warning_handler)
 	    ("CHOLMOD not installed");
 
 	  mattype.mark_as_unsymmetric ();
-	  typ = SparseType::Full;
+	  typ = MatrixType::Full;
 #endif
 	}
 
-      if (typ == SparseType::Full)
+      if (typ == MatrixType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info,
 				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
@@ -6699,353 +6699,353 @@ SparseComplexMatrix::fsolve (SparseType 
 	    }
 	  else
 	    mattype.mark_as_rectangular ();
 
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
-      else if (typ != SparseType::Hermitian)
+      else if (typ != MatrixType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const Matrix& b) const
+SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const Matrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b, 
 			    octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const Matrix& b,
+SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b,
 			    octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const Matrix& b,
+SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b,
 			    octave_idx_type& err, double& rcond, 
 			    solve_singularity_handler sing_handler,
 			    bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type (false);
 
-  if (typ == SparseType::Unknown)
+  if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
-  if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
+  if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
+  else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
+  else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Tridiagonal || 
-	   typ == SparseType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal || 
+	   typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Full || typ == SparseType::Hermitian)
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
-  else if (typ != SparseType::Rectangular)
+  else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == SparseType::Rectangular)
+  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseComplexMatrix,
 	Matrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const SparseMatrix& b) const
+SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const SparseMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b, 
 		     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const SparseMatrix& b,
+SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
 		     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const SparseMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b, 
 			    octave_idx_type& err, double& rcond,
 			    solve_singularity_handler sing_handler,
 			    bool singular_fallback) const
 {
   SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
-  if (typ == SparseType::Unknown)
+  if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
-  if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
+  if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
+  else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
+  else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Tridiagonal || 
-	   typ == SparseType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal || 
+	   typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Full || typ == SparseType::Hermitian)
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
-  else if (typ != SparseType::Rectangular)
+  else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == SparseType::Rectangular)
+  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
 	SparseMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const ComplexMatrix& b) const
+SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
 			    octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
 			    octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
 			    octave_idx_type& err, double& rcond, 
 			    solve_singularity_handler sing_handler,
 			    bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type (false);
 
-  if (typ == SparseType::Unknown)
+  if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
-  if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
+  if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
+  else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
+  else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Tridiagonal || 
-	   typ == SparseType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal || 
+	   typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Full || typ == SparseType::Hermitian)
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
-  else if (typ != SparseType::Rectangular)
+  else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == SparseType::Rectangular)
+  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseComplexMatrix,
 	ComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, 
+SparseComplexMatrix::solve (MatrixType &mattype, 
 			    const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b, 
 			    octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b,
+SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
 			    octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b, 
 			    octave_idx_type& err, double& rcond,
 			    solve_singularity_handler sing_handler,
 			    bool singular_fallback) const
 {
   SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
-  if (typ == SparseType::Unknown)
+  if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
-  if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
+  if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
+  else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
+  else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Tridiagonal || 
-	   typ == SparseType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal || 
+	   typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Full || typ == SparseType::Hermitian)
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
-  else if (typ != SparseType::Rectangular)
+  else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == SparseType::Rectangular)
+  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
 	SparseComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (SparseType &mattype, const ColumnVector& b) const
+SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b) const
 {
   octave_idx_type info; double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (SparseType &mattype, const ColumnVector& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b, 
 			    octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (SparseType &mattype, const ColumnVector& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b, 
 			    octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (SparseType &mattype, const ColumnVector& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b, 
 			    octave_idx_type& info, double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
   return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (SparseType &mattype, 
+SparseComplexMatrix::solve (MatrixType &mattype, 
 			    const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (SparseType &mattype, const ComplexColumnVector& b,
+SparseComplexMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
 			    octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (SparseType &mattype, const ComplexColumnVector& b,
+SparseComplexMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
 			    octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (SparseType &mattype, const ComplexColumnVector& b,
+SparseComplexMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
 			    octave_idx_type& info, double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
@@ -7070,17 +7070,17 @@ SparseComplexMatrix::solve (const Matrix
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& err, 
 			    double& rcond, 
 			    solve_singularity_handler sing_handler) const
 {
-  SparseType mattype (*this);
+  MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
@@ -7102,17 +7102,17 @@ SparseComplexMatrix::solve (const Sparse
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b, 
 		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
-  SparseType mattype (*this);
+  MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b, 
 			    octave_idx_type& info) const
 {
   double rcond;
@@ -7126,17 +7126,17 @@ SparseComplexMatrix::solve (const Comple
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b, 
 		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
-  SparseType mattype (*this);
+  MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
@@ -7158,17 +7158,17 @@ SparseComplexMatrix::solve (const Sparse
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b, 
 		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
-  SparseType mattype (*this);
+  MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ColumnVector& b) const
 {
   octave_idx_type info; double rcond;
   return solve (b, info, rcond);
diff --git a/liboctave/CSparse.h b/liboctave/CSparse.h
--- a/liboctave/CSparse.h
+++ b/liboctave/CSparse.h
@@ -29,17 +29,17 @@ Boston, MA 02110-1301, USA.
 #include "dColVector.h"
 #include "CColVector.h"
 #include "oct-cmplx.h"
 
 #include "CmplxDET.h"
 #include "MSparse.h"
 #include "MSparse-defs.h"
 #include "Sparse-op-defs.h"
-#include "SparseType.h"
+#include "MatrixType.h"
 
 class SparseMatrix;
 class SparseBoolMatrix;
 
 class
 SparseComplexMatrix : public MSparse<Complex>
 {
 public:
@@ -116,223 +116,223 @@ public:
 
   SparseComplexMatrix hermitian (void) const;  // complex conjugate transpose
   SparseComplexMatrix transpose (void) const
     { return MSparse<Complex>::transpose (); }
 
   friend SparseComplexMatrix conj (const SparseComplexMatrix& a);
 
 private:
-  SparseComplexMatrix dinverse (SparseType &mattyp, octave_idx_type& info, 
+  SparseComplexMatrix dinverse (MatrixType &mattyp, octave_idx_type& info, 
 				double& rcond, const bool force = false, 
 				const bool calccond = true) const;
 
-  SparseComplexMatrix tinverse (SparseType &mattyp, octave_idx_type& info, 
+  SparseComplexMatrix tinverse (MatrixType &mattyp, octave_idx_type& info, 
 				double& rcond, const bool force = false, 
 				const bool calccond = true) const;
 
 public:
   SparseComplexMatrix inverse (void) const;
-  SparseComplexMatrix inverse (SparseType& mattype) const;
-  SparseComplexMatrix inverse (SparseType& mattype, 
+  SparseComplexMatrix inverse (MatrixType& mattype) const;
+  SparseComplexMatrix inverse (MatrixType& mattype, 
 			       octave_idx_type& info) const;
-  SparseComplexMatrix inverse (SparseType& mattype, octave_idx_type& info, 
+  SparseComplexMatrix inverse (MatrixType& mattype, octave_idx_type& info, 
 			       double& rcond, int force = 0, 
 			       int calc_cond = 1) const;
 
   ComplexDET determinant (void) const;
   ComplexDET determinant (octave_idx_type& info) const;
   ComplexDET determinant (octave_idx_type& info, double& rcond, 
 				int calc_cond = 1) const;
 
 private:
   // Diagonal matrix solvers
-  ComplexMatrix dsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
+  ComplexMatrix dsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  ComplexMatrix dsolve (SparseType &typ, const ComplexMatrix& b, 
+  ComplexMatrix dsolve (MatrixType &typ, const ComplexMatrix& b, 
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler, 
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix dsolve (SparseType &typ, const SparseMatrix& b, 
+  SparseComplexMatrix dsolve (MatrixType &typ, const SparseMatrix& b, 
 		octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix dsolve (SparseType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix dsolve (MatrixType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
   // Upper triangular matrix solvers
-  ComplexMatrix utsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+  ComplexMatrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  ComplexMatrix utsolve (SparseType &typ, const ComplexMatrix& b, 
+  ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b, 
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix utsolve (SparseType &typ, const SparseMatrix& b, 
+  SparseComplexMatrix utsolve (MatrixType &typ, const SparseMatrix& b, 
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix utsolve (SparseType &typ, const SparseComplexMatrix& b, 
+  SparseComplexMatrix utsolve (MatrixType &typ, const SparseComplexMatrix& b, 
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
-  ComplexMatrix ltsolve (SparseType &typ, const Matrix& b, 
+  ComplexMatrix ltsolve (MatrixType &typ, const Matrix& b, 
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  ComplexMatrix ltsolve (SparseType &typ, const ComplexMatrix& b, 
+  ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b, 
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix ltsolve (SparseType &typ, const SparseMatrix& b,
+  SparseComplexMatrix ltsolve (MatrixType &typ, const SparseMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix ltsolve (SparseType &typ, const SparseComplexMatrix& b, 
+  SparseComplexMatrix ltsolve (MatrixType &typ, const SparseComplexMatrix& b, 
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
   // Tridiagonal matrix solvers
-  ComplexMatrix trisolve (SparseType &typ, const Matrix& b,
+  ComplexMatrix trisolve (MatrixType &typ, const Matrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  ComplexMatrix trisolve (SparseType &typ, const ComplexMatrix& b, 
+  ComplexMatrix trisolve (MatrixType &typ, const ComplexMatrix& b, 
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix trisolve (SparseType &typ, const SparseMatrix& b,
+  SparseComplexMatrix trisolve (MatrixType &typ, const SparseMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix trisolve (SparseType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix trisolve (MatrixType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
   // Banded matrix solvers (umfpack/cholesky)
-  ComplexMatrix bsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+  ComplexMatrix bsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  ComplexMatrix bsolve (SparseType &typ, const ComplexMatrix& b, 
+  ComplexMatrix bsolve (MatrixType &typ, const ComplexMatrix& b, 
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix bsolve (SparseType &typ, const SparseMatrix& b, 
+  SparseComplexMatrix bsolve (MatrixType &typ, const SparseMatrix& b, 
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix bsolve (SparseType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix bsolve (MatrixType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
   void * factorize (octave_idx_type& err, double &rcond, Matrix &Control, 
 		Matrix &Info, solve_singularity_handler sing_handler,
 		bool calc_cond) const;
 
-  ComplexMatrix fsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
+  ComplexMatrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  ComplexMatrix fsolve (SparseType &typ, const ComplexMatrix& b, 
+  ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b, 
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix fsolve (SparseType &typ, const SparseMatrix& b, 
+  SparseComplexMatrix fsolve (MatrixType &typ, const SparseMatrix& b, 
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix fsolve (SparseType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix fsolve (MatrixType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
-  ComplexMatrix solve (SparseType &typ, const Matrix& b) const;
-  ComplexMatrix solve (SparseType &typ, const Matrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b) const;
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
 		       octave_idx_type& info) const;
-  ComplexMatrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
 		       double& rcond) const;
-  ComplexMatrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
 		       double& rcond, solve_singularity_handler sing_handler,
 		       bool singular_fallback = true) const;
 
-  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b) const;
-  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
 		       octave_idx_type& info) const;
-  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
 		       octave_idx_type& info, double& rcond) const;
-  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
 		       octave_idx_type& info, double& rcond, 
 		       solve_singularity_handler sing_handler,
 		       bool singular_fallback = true) const;
 
-  SparseComplexMatrix solve (SparseType &typ, const SparseMatrix& b) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b) const;
+  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b, 
 			     octave_idx_type& info) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b, 
 			     octave_idx_type& info, double& rcond) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b, 
 			     octave_idx_type& info, double& rcond, 
 			     solve_singularity_handler sing_handler,
 			     bool singular_fallback = true) const;
 
-  SparseComplexMatrix solve (SparseType &typ, 
+  SparseComplexMatrix solve (MatrixType &typ, 
 			     const SparseComplexMatrix& b) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b, 
 			     octave_idx_type& info) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b, 
 			     octave_idx_type& info, double& rcond) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
 			     octave_idx_type& info, double& rcond, 
 			     solve_singularity_handler sing_handler,
 			     bool singular_fallback = true) const;
 
-  ComplexColumnVector solve (SparseType &typ, const ColumnVector& b) const;
-  ComplexColumnVector solve (SparseType &typ, const ColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
 			     octave_idx_type& info) const;
-  ComplexColumnVector solve (SparseType &typ, const ColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
 			     octave_idx_type& info, double& rcond) const;
-  ComplexColumnVector solve (SparseType &typ, const ColumnVector& b,
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
 			     octave_idx_type& info, double& rcond, 
 			     solve_singularity_handler sing_handler) const;
 
-  ComplexColumnVector solve (SparseType &typ, 
+  ComplexColumnVector solve (MatrixType &typ, 
 			     const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (SparseType &typ, const ComplexColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
 			     octave_idx_type& info) const;
-  ComplexColumnVector solve (SparseType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
 			     octave_idx_type& info, double& rcond) const;
-  ComplexColumnVector solve (SparseType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
 			     octave_idx_type& info, double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   ComplexMatrix solve (const Matrix& b) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, 
 		       double& rcond) const;
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,46 @@
+2006-05-03  David Bateman  <dbateman@free.fr>
+
+	* CMatrix.cc (zpotrf, zpocon, zpotrs, ztrcon, ztrtrs):
+	External declaration of lapack triangular and Cholesky codes.
+	(ComplexMatrix::utsolve, ComplexMatrix::ltsolve, 
+	ComplexMatrix::fsolve): New private solver codes for
+        upper, lower and LU/Cholesky solvers.
+	(ComplexMatrix::solve): New versions for cached matrix
+	type. Adapt old versions to call new versions
+	* CMatrix.h (utsolve, ltsolve, fsolve): Declaration of
+	new solvers.
+	(solve): New versions for cached matrix type.
+	* dMatrix.cc (dpotrf, dpocon, dpotrs, dtrcon, dtrtrs):
+	External declaration of lapack triangular and Cholesky codes.
+	(Matrix::utsolve, Matrix::ltsolve, 
+	Matrix::fsolve): New private solver codes for
+        upper, lower and LU/Cholesky solvers.
+	(Matrix::solve): New versions for cached matrix
+	type. Adapt old versions to call new versions
+	* dMatrix.h (utsolve, ltsolve, fsolve): Declaration of
+	new solvers.
+	(solve): New versions for cached matrix type.
+	* CSparse.cc: Replace all uses of SparseType with MatrixType.
+	* CSparse.h: ditto.
+	* dSparse.cc: ditto.
+	* dSparse.h: ditto.
+	* SparseCmplxCHOL.cc: ditto.
+	* SparsedbleCHOL.cc: ditto.
+	* sparse-dmsolve.cc: ditto.
+	* SparseType.cc, SparseType.h: delete.
+	* MatrixType.cc: New file for class to cache matrix type, based on
+	old SparseType class but caching matrix and sparse types.
+	* MatrixType.h: ditto.
+	* Makefile.in (MATRIX_INC, MATRIX_SRC): Add MatrixType.h and
+	MatrixType.cc respectively. Delete SparseType.h and SparseType.cc
+	respectively.
+	* mx-base.h: Include MatrixTye.h as header file.
+	
 2006-05-01  John W. Eaton  <jwe@octave.org>
 
 	* oct-shlib.h (octave_shlib::octave_shlib, octave_shlib::open):
 	Delete WARN_FUTURE arg.  Change all uses.
 	* oct-shlib.cc (octave_base_shlib::stamp_time): Delete arg.
 	Change all uses.  Use current_liboctave_warning_with_id_handler.
 	(octave_base_shlib::open): Delete arg.  Change all derived classes
 	and uses.
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -34,17 +34,17 @@ MATRIX_INC := Array.h Array2.h Array3.h 
 	CmplxSCHUR.h CmplxSVD.h EIG.h boolMatrix.h boolNDArray.h \
 	chMatrix.h chNDArray.h dColVector.h dDiagMatrix.h dMatrix.h \
 	dNDArray.h dRowVector.h dbleAEPBAL.h dbleCHOL.h dbleDET.h \
 	dbleHESS.h dbleLU.h dbleQR.h dbleQRP.h dbleSCHUR.h dbleSVD.h \
 	boolSparse.h CSparse.h dSparse.h MSparse-defs.h MSparse.h \
 	Sparse.h sparse-base-lu.h SparseCmplxLU.h SparsedbleLU.h \
 	sparse-base-chol.h sparse-dmsolve.cc SparseCmplxCHOL.h \
 	SparsedbleCHOL.h SparseCmplxQR.h SparseQR.h Sparse-op-defs.h \
-	SparseType.h \
+	MatrixType.h \
 	int8NDArray.h uint8NDArray.h int16NDArray.h uint16NDArray.h \
 	int32NDArray.h uint32NDArray.h int64NDArray.h uint64NDArray.h \
 	intNDArray.h
 
 MX_OP_INC := $(shell $(AWK) -f $(srcdir)/mk-ops.awk prefix=mx list_h_files=1 $(srcdir)/mx-ops)
 
 VX_OP_INC := $(shell $(AWK) -f $(srcdir)/mk-ops.awk prefix=vx list_h_files=1 $(srcdir)/vx-ops)
 
@@ -96,17 +96,17 @@ MATRIX_SRC := Array-util.cc CColVector.c
 	CmplxLU.cc CmplxQR.cc CmplxQRP.cc CmplxSCHUR.cc CmplxSVD.cc \
 	EIG.cc boolMatrix.cc boolNDArray.cc chMatrix.cc \
 	chNDArray.cc dColVector.cc dDiagMatrix.cc dMatrix.cc \
 	dNDArray.cc dRowVector.cc dbleAEPBAL.cc dbleCHOL.cc \
 	dbleDET.cc dbleHESS.cc dbleLU.cc dbleQR.cc dbleQRP.cc \
 	dbleSCHUR.cc dbleSVD.cc boolSparse.cc CSparse.cc dSparse.cc \
 	MSparse.cc Sparse.cc SparseCmplxLU.cc SparsedbleLU.cc \
 	SparseCmplxCHOL.cc SparsedbleCHOL.cc \
-	SparseCmplxQR.cc SparseQR.cc SparseType.cc \
+	SparseCmplxQR.cc SparseQR.cc MatrixType.cc \
 	int8NDArray.cc uint8NDArray.cc int16NDArray.cc uint16NDArray.cc \
 	int32NDArray.cc uint32NDArray.cc int64NDArray.cc uint64NDArray.cc 
 
 MX_OP_SRC := $(shell $(AWK) -f $(srcdir)/mk-ops.awk prefix=mx list_cc_files=1 $(srcdir)/mx-ops)
 
 VX_OP_SRC := $(shell $(AWK) -f $(srcdir)/mk-ops.awk prefix=vx list_cc_files=1 $(srcdir)/vx-ops)
 
 SPARSE_MX_OP_SRC := $(shell $(AWK) -f $(srcdir)/sparse-mk-ops.awk prefix=smx list_cc_files=1 $(srcdir)/sparse-mx-ops)
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/MatrixType.cc
@@ -0,0 +1,1199 @@
+/*
+
+Copyright (C) 2006 David Bateman
+Copyright (C) 2006 Andy Adler
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <vector>
+
+#include "MatrixType.h"
+#include "dMatrix.h"
+#include "CMatrix.h"
+#include "dSparse.h"
+#include "CSparse.h"
+#include "oct-spparms.h"
+
+// FIXME There is a large code duplication here
+
+MatrixType::MatrixType (void) : typ (MatrixType::Unknown), full (false),
+				nperm (0)
+{
+  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
+} 
+
+MatrixType::MatrixType (const MatrixType &a) : typ (a.typ), 
+    sp_bandden (a.sp_bandden), bandden (a.bandden), 
+    upper_band (a.upper_band), lower_band (a.lower_band), 
+    dense (a.dense), full (a.full), nperm (a.nperm)
+{ 
+  if (nperm != 0)
+    {
+      perm = new octave_idx_type [nperm];
+      for (octave_idx_type i = 0; i < nperm; i++)
+	perm[i] = a.perm[i];
+    }
+}
+
+MatrixType::MatrixType (const Matrix &a)
+{
+  octave_idx_type nrows = a.rows ();
+  octave_idx_type ncols = a.cols ();
+  nperm = 0;
+  full = true;
+
+  if (ncols == nrows)
+    {
+      bool upper = true;
+      bool lower = true;
+      bool hermitian = true;
+
+      for (octave_idx_type j = 0; j < ncols; j++)
+	{
+	  if (j < nrows)
+	    {
+	      if (a.elem (j,j) == 0.)
+		{
+		  upper = false;
+		  lower = false;
+		  hermitian = false;
+		  break;
+		}
+	      if (a.elem (j,j) < 0.)
+		hermitian = false;
+	    }      
+	  for (octave_idx_type i = 0; i < j; i++)
+	    if (lower && a.elem (i,j) != 0.)
+	      {
+		lower = false;
+		break;
+	      }
+	  for (octave_idx_type i = j+1; i < nrows; i++)
+	    {
+	      if (hermitian && a.elem (i, j) != a.elem (j, i))
+		hermitian = false;
+	      if (upper && a.elem (i,j) != 0)
+		upper = false;
+	    }
+	  if (!upper && !lower && !hermitian)
+	    break;
+	}
+
+      if (upper)
+	typ = MatrixType::Upper;
+      else if (lower)
+	typ = MatrixType::Lower;
+      else if (hermitian)
+	typ = MatrixType::Hermitian;
+      else if (ncols == nrows)
+	typ = MatrixType::Full;
+    }
+  else
+    typ = MatrixType::Rectangular;
+}
+
+MatrixType::MatrixType (const ComplexMatrix &a)
+{
+  octave_idx_type nrows = a.rows ();
+  octave_idx_type ncols = a.cols ();
+  nperm = 0;
+  full = true;
+
+  if (ncols == nrows)
+    {
+      bool upper = true;
+      bool lower = true;
+      bool hermitian = true;
+
+      for (octave_idx_type j = 0; j < ncols; j++)
+	{
+	  if (j < ncols)
+	    {
+	      if (imag(a.elem (j,j)) == 0. && 
+		  real(a.elem (j,j)) == 0.)
+		{
+		  upper = false;
+		  lower = false;
+		  hermitian = false;
+		  break;
+		}
+
+	      if (imag(a.elem (j,j)) != 0. || 
+		  real(a.elem (j,j)) < 0.)
+		    hermitian = false;
+	    }
+	  for (octave_idx_type i = 0; i < j; i++)
+	    if (lower && (real(a.elem (i,j)) != 0 || imag(a.elem (i,j)) != 0))
+	      {
+		lower = false;
+		break;
+	      }
+	  for (octave_idx_type i = j+1; i < nrows; i++)
+	    {
+	      if (hermitian && a.elem (i, j) != conj(a.elem (j, i)))
+		hermitian = false;
+	      if (upper && (real(a.elem (i,j)) != 0 || 
+			    imag(a.elem (i,j)) != 0))
+		upper = false;
+	    }
+	  if (!upper && !lower && !hermitian)
+	    break;
+	}
+
+      if (upper)
+	typ = MatrixType::Upper;
+      else if (lower)
+	typ = MatrixType::Lower;
+      else if (hermitian)
+	typ = MatrixType::Hermitian;
+      else if (ncols == nrows)
+	typ = MatrixType::Full;
+    }
+  else
+    typ = MatrixType::Rectangular;
+}
+
+MatrixType::MatrixType (const SparseMatrix &a)
+{
+  octave_idx_type nrows = a.rows ();
+  octave_idx_type ncols = a.cols ();
+  octave_idx_type nm = (ncols < nrows ? ncols : nrows);
+  octave_idx_type nnz = a.nzmax ();
+  full = false;
+
+  if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
+    (*current_liboctave_warning_handler) 
+      ("Calculating Sparse Matrix Type");
+
+  nperm = 0;
+
+  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
+  bool maybe_hermitian = false;
+  typ = MatrixType::Full;
+
+  if (nnz == nm)
+    {
+      matrix_type tmp_typ = MatrixType::Diagonal;
+      octave_idx_type i;
+      // Maybe the matrix is diagonal
+      for (i = 0; i < nm; i++)
+	{
+	  if (a.cidx(i+1) != a.cidx(i) + 1)
+	    {
+	      tmp_typ = MatrixType::Full;
+	      break;
+	    }
+	  if (a.ridx(i) != i)
+	    {
+	      tmp_typ = MatrixType::Permuted_Diagonal;
+	      break;
+	    }
+	}
+	  
+      if (tmp_typ == MatrixType::Permuted_Diagonal)
+	{
+	  std::vector<bool> found (nrows);
+
+	  for (octave_idx_type j = 0; j < i; j++)
+	    found [j] = true;
+	  for (octave_idx_type j = i; j < nrows; j++)
+	    found [j] = false;
+	      
+	  for (octave_idx_type j = i; j < nm; j++)
+	    {
+	      if ((a.cidx(j+1) > a.cidx(j) + 1)  || 
+		  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
+		{
+		  tmp_typ = MatrixType::Full;
+		  break;
+		}
+	      found [a.ridx(j)] = true;
+	    }
+	}
+      typ = tmp_typ;
+    }
+
+  if (typ == MatrixType::Full)
+    {
+      // Search for banded, upper and lower triangular matrices
+      bool singular = false;
+      upper_band = 0;
+      lower_band = 0;
+      for (octave_idx_type j = 0; j < ncols; j++)
+	{
+	  bool zero_on_diagonal = false;
+	  if (j < nrows)
+	    {
+	      zero_on_diagonal = true;
+	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+		if (a.ridx(i) == j)
+		  {
+		    zero_on_diagonal = false;
+		    break;
+		  }
+	    }
+
+	  if (zero_on_diagonal)
+	    {
+	      singular = true;
+	      break;
+	    }
+
+	  if (a.cidx(j+1) != a.cidx(j))
+	    {
+	      octave_idx_type ru = a.ridx(a.cidx(j));
+	      octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
+
+	      if (j - ru > upper_band)
+		upper_band = j - ru;
+		  
+	      if (rl - j > lower_band)
+		lower_band = rl - j;
+	    }
+	}
+
+      if (!singular)
+	{
+	  bandden = double (nnz) /
+	    (double (ncols) * (double (lower_band) +
+			       double (upper_band)) -
+	     0.5 * double (upper_band + 1) * double (upper_band) -
+	     0.5 * double (lower_band + 1) * double (lower_band));
+
+	  if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
+	    {
+	      if (upper_band == 1 && lower_band == 1)
+		typ = MatrixType::Tridiagonal;
+	      else
+		typ = MatrixType::Banded;
+
+	      octave_idx_type nnz_in_band = 
+		(upper_band + lower_band + 1) * nrows -
+		(1 + upper_band) * upper_band / 2 -
+		(1 + lower_band) * lower_band / 2;
+	      if (nnz_in_band == nnz)
+		dense = true;
+	      else 
+		dense = false;
+	    }
+	  else if (upper_band == 0)
+	    typ = MatrixType::Lower;
+	  else if (lower_band == 0)
+	    typ = MatrixType::Upper;
+
+	  if (upper_band == lower_band && nrows == ncols)
+	    maybe_hermitian = true;
+	}
+
+      if (typ == MatrixType::Full)
+	{
+	  // Search for a permuted triangular matrix, and test if
+	  // permutation is singular
+
+	  // FIXME
+	  // Perhaps this should be based on a dmperm algorithm
+	  bool found = false;
+
+	  nperm = ncols;
+	  perm = new octave_idx_type [ncols];
+
+	  for (octave_idx_type i = 0; i < ncols; i++)
+	    perm [i] = -1;
+
+	  for (octave_idx_type i = 0; i < nm; i++)
+	    {
+	      found = false;
+
+	      for (octave_idx_type j = 0; j < ncols; j++)
+		{
+		  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
+		      (a.ridx(a.cidx(j+1)-1) == i))
+		    {
+		      perm [i] = j;
+		      found = true;
+		      break;
+		    }
+		}
+
+	      if (!found)
+		break;
+	    }
+
+	  if (found)
+	    {
+	      typ = MatrixType::Permuted_Upper;
+	      if (ncols > nrows)
+		{
+		  octave_idx_type k = nrows;
+		  for (octave_idx_type i = 0; i < ncols; i++)
+		    if (perm [i] == -1)
+		      perm[i] = k++;
+		}
+	    }
+	  else if (a.cidx(nm) == a.cidx(ncols))
+	    {
+	      nperm = nrows;
+	      delete [] perm;
+	      perm = new octave_idx_type [nrows];
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
+
+	      for (octave_idx_type i = 0; i < nrows; i++)
+		{
+		  perm [i] = -1;
+		  tmp [i] = -1;
+		}
+
+	      for (octave_idx_type j = 0; j < ncols; j++)
+		for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+		    perm [a.ridx(i)] = j;
+
+	      found = true;
+	      for (octave_idx_type i = 0; i < nm; i++)
+		if (perm[i] == -1)
+		  {
+		    found = false;
+		    break;
+		  }
+		else
+		  {
+		    tmp[perm[i]] = 1;
+		  }
+
+	      if (found)
+		{
+		  octave_idx_type k = ncols;
+		  for (octave_idx_type i = 0; i < nrows; i++)
+		    {
+		      if (tmp[i] == -1)
+			{
+			  if (k < nrows)
+			    {
+			      perm[k++] = i;
+			    }
+			  else
+			    {
+			      found = false;
+			      break;
+			    }
+			}
+		    }
+		}
+
+	      if (found)
+		typ = MatrixType::Permuted_Lower;
+	      else
+		{
+		  delete [] perm;
+		  nperm = 0;
+		}
+	    }
+	  else
+	    {
+	      delete [] perm;
+	      nperm = 0;
+	    }
+	}
+
+      // FIXME
+      // Disable lower under-determined and upper over-determined problems
+      // as being detected, and force to treat as singular. As this seems
+      // to cause issues
+      if (((typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+	   && nrows > ncols) ||
+	  ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
+	   && nrows < ncols))
+	{
+	  typ = MatrixType::Rectangular;
+	  if (typ == MatrixType::Permuted_Upper ||
+	      typ == MatrixType::Permuted_Lower)
+	    delete [] perm;
+	  nperm = 0;
+	}
+
+      if (typ == MatrixType::Full && ncols != nrows)
+	typ = MatrixType::Rectangular;
+
+      if (maybe_hermitian && (typ == MatrixType::Full || 
+			      typ == MatrixType::Tridiagonal || 
+			      typ == MatrixType::Banded))
+	{
+	  // Check for symmetry, with positive real diagonal, which
+	  // has a very good chance of being symmetric positive
+	  // definite..
+	  bool is_herm = true;
+
+	  for (octave_idx_type j = 0; j < ncols; j++)
+	    {
+	      bool diag_positive = false;
+
+	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+		{
+		  octave_idx_type ri = a.ridx(i);
+
+		  if (ri == j)
+		    {
+		      if (a.data(i) == std::abs(a.data(i)))
+			diag_positive = true;
+		      else
+			break;
+		    }
+		  else
+		    {
+		      bool found = false;
+
+		      for (octave_idx_type k = a.cidx(ri); k < a.cidx(ri+1); k++)
+			{
+			  if (a.ridx(k) == j)
+			    {
+			      if (a.data(i) == a.data(k))
+				found = true;
+			      break;
+			    }
+			}
+
+		      if (! found)
+			{
+			  is_herm = false;
+			  break;
+			}
+		    }
+		}
+
+	      if (! diag_positive || ! is_herm)
+		{
+		  is_herm = false;
+		  break;
+		} 
+	    }
+
+	  if (is_herm)
+	    {
+	      if (typ == MatrixType::Full)
+		typ = MatrixType::Hermitian;
+	      else if (typ == MatrixType::Banded)
+		typ = MatrixType::Banded_Hermitian;
+	      else
+		typ = MatrixType::Tridiagonal_Hermitian;
+	    }
+	}
+    }
+}
+
+MatrixType::MatrixType (const SparseComplexMatrix &a)
+{
+  octave_idx_type nrows = a.rows ();
+  octave_idx_type ncols = a.cols ();
+  octave_idx_type nm = (ncols < nrows ? ncols : nrows);
+  octave_idx_type nnz = a.nzmax ();
+  full = false;
+
+  if (Voctave_sparse_controls.get_key ("spumoni") != 0.)  full = true;
+
+    (*current_liboctave_warning_handler) 
+      ("Calculating Sparse Matrix Type");
+
+  nperm = 0;
+
+  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
+  bool maybe_hermitian = false;
+  typ = MatrixType::Full;
+
+  if (nnz == nm)
+    {
+      matrix_type tmp_typ = MatrixType::Diagonal;
+      octave_idx_type i;
+      // Maybe the matrix is diagonal
+      for (i = 0; i < nm; i++)
+	{
+	  if (a.cidx(i+1) != a.cidx(i) + 1)
+	    {
+	      tmp_typ = MatrixType::Full;
+	      break;
+	    }
+	  if (a.ridx(i) != i)
+	    {
+	      tmp_typ = MatrixType::Permuted_Diagonal;
+	      break;
+	    }
+	}
+	  
+      if (tmp_typ == MatrixType::Permuted_Diagonal)
+	{
+	  std::vector<bool> found (nrows);
+
+	  for (octave_idx_type j = 0; j < i; j++)
+	    found [j] = true;
+	  for (octave_idx_type j = i; j < nrows; j++)
+	    found [j] = false;
+	      
+	  for (octave_idx_type j = i; j < nm; j++)
+	    {
+	      if ((a.cidx(j+1) > a.cidx(j) + 1)  || 
+		  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
+		{
+		  tmp_typ = MatrixType::Full;
+		  break;
+		}
+	      found [a.ridx(j)] = true;
+	    }
+	}
+      typ = tmp_typ;
+    }
+
+  if (typ == MatrixType::Full)
+    {
+      // Search for banded, upper and lower triangular matrices
+      bool singular = false;
+      upper_band = 0;
+      lower_band = 0;
+      for (octave_idx_type j = 0; j < ncols; j++)
+	{
+	  bool zero_on_diagonal = false;
+	  if (j < nrows)
+	    {
+	      zero_on_diagonal = true;
+	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+		if (a.ridx(i) == j)
+		  {
+		    zero_on_diagonal = false;
+		    break;
+		  }
+	    }
+
+	  if (zero_on_diagonal)
+	    {
+	      singular = true;
+	      break;
+	    }
+
+	  if (a.cidx(j+1) != a.cidx(j))
+	    {
+	      octave_idx_type ru = a.ridx(a.cidx(j));
+	      octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
+
+	      if (j - ru > upper_band)
+		upper_band = j - ru;
+		  
+	      if (rl - j > lower_band)
+		lower_band = rl - j;
+	    }
+	}
+
+      if (!singular)
+	{
+	  bandden = double (nnz) /
+	    (double (ncols) * (double (lower_band) +
+			       double (upper_band)) -
+	     0.5 * double (upper_band + 1) * double (upper_band) -
+	     0.5 * double (lower_band + 1) * double (lower_band));
+
+	  if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
+	    {
+	      if (upper_band == 1 && lower_band == 1)
+		typ = MatrixType::Tridiagonal;
+	      else
+		typ = MatrixType::Banded;
+
+	      octave_idx_type nnz_in_band = 
+		(upper_band + lower_band + 1) * nrows -
+		(1 + upper_band) * upper_band / 2 -
+		(1 + lower_band) * lower_band / 2;
+	      if (nnz_in_band == nnz)
+		dense = true;
+	      else 
+		dense = false;
+	    }
+	  else if (upper_band == 0)
+	    typ = MatrixType::Lower;
+	  else if (lower_band == 0)
+	    typ = MatrixType::Upper;
+
+	  if (upper_band == lower_band && nrows == ncols)
+	    maybe_hermitian = true;
+	}
+
+      if (typ == MatrixType::Full)
+	{
+	  // Search for a permuted triangular matrix, and test if
+	  // permutation is singular
+
+	  // FIXME
+	  // Perhaps this should be based on a dmperm algorithm
+	  bool found = false;
+
+	  nperm = ncols;
+	  perm = new octave_idx_type [ncols];
+
+	  for (octave_idx_type i = 0; i < ncols; i++)
+	    perm [i] = -1;
+
+	  for (octave_idx_type i = 0; i < nm; i++)
+	    {
+	      found = false;
+
+	      for (octave_idx_type j = 0; j < ncols; j++)
+		{
+		  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
+		      (a.ridx(a.cidx(j+1)-1) == i))
+		    {
+		      perm [i] = j;
+		      found = true;
+		      break;
+		    }
+		}
+
+	      if (!found)
+		break;
+	    }
+
+	  if (found)
+	    {
+	      typ = MatrixType::Permuted_Upper;
+	      if (ncols > nrows)
+		{
+		  octave_idx_type k = nrows;
+		  for (octave_idx_type i = 0; i < ncols; i++)
+		    if (perm [i] == -1)
+		      perm[i] = k++;
+		}
+	    }
+	  else if (a.cidx(nm) == a.cidx(ncols))
+	    {
+	      nperm = nrows;
+	      delete [] perm;
+	      perm = new octave_idx_type [nrows];
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
+
+	      for (octave_idx_type i = 0; i < nrows; i++)
+		{
+		  perm [i] = -1;
+		  tmp [i] = -1;
+		}
+
+	      for (octave_idx_type j = 0; j < ncols; j++)
+		for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+		    perm [a.ridx(i)] = j;
+
+	      found = true;
+	      for (octave_idx_type i = 0; i < nm; i++)
+		if (perm[i] == -1)
+		  {
+		    found = false;
+		    break;
+		  }
+		else
+		  {
+		    tmp[perm[i]] = 1;
+		  }
+
+	      if (found)
+		{
+		  octave_idx_type k = ncols;
+		  for (octave_idx_type i = 0; i < nrows; i++)
+		    {
+		      if (tmp[i] == -1)
+			{
+			  if (k < nrows)
+			    {
+			      perm[k++] = i;
+			    }
+			  else
+			    {
+			      found = false;
+			      break;
+			    }
+			}
+		    }
+		}
+
+	      if (found)
+		typ = MatrixType::Permuted_Lower;
+	      else
+		{
+		  delete [] perm;
+		  nperm = 0;
+		}
+	    }
+	  else
+	    {
+	      delete [] perm;
+	      nperm = 0;
+	    }
+	}
+
+      // FIXME
+      // Disable lower under-determined and upper over-determined problems
+      // as being detected, and force to treat as singular. As this seems
+      // to cause issues
+      if (((typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+	   && nrows > ncols) ||
+	  ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
+	   && nrows < ncols))
+	{
+	  typ = MatrixType::Rectangular;
+	  if (typ == MatrixType::Permuted_Upper ||
+	      typ == MatrixType::Permuted_Lower)
+	    delete [] perm;
+	  nperm = 0;
+	}
+
+      if (typ == MatrixType::Full && ncols != nrows)
+	typ = MatrixType::Rectangular;
+
+      if (maybe_hermitian && (typ == MatrixType::Full || 
+			      typ == MatrixType::Tridiagonal || 
+			      typ == MatrixType::Banded))
+	{
+	  // Check for symmetry, with positive real diagonal, which
+	  // has a very good chance of being symmetric positive
+	  // definite..
+	  bool is_herm = true;
+
+	  for (octave_idx_type j = 0; j < ncols; j++)
+	    {
+	      bool diag_positive = false;
+
+	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+		{
+		  octave_idx_type ri = a.ridx(i);
+
+		  if (ri == j)
+		    {
+		      if (a.data(i) == std::abs(a.data(i)))
+			diag_positive = true;
+		      else
+			break;
+		    }
+		  else
+		    {
+		      bool found = false;
+
+		      for (octave_idx_type k = a.cidx(ri); k < a.cidx(ri+1); k++)
+			{
+			  if (a.ridx(k) == j)
+			    {
+			      if (a.data(i) == conj(a.data(k)))
+				found = true;
+			      break;
+			    }
+			}
+
+		      if (! found)
+			{
+			  is_herm = false;
+			  break;
+			}
+		    }
+		}
+
+	      if (! diag_positive || ! is_herm)
+		{
+		  is_herm = false;
+		  break;
+		} 
+	    }
+
+	  if (is_herm)
+	    {
+	      if (typ == MatrixType::Full)
+		typ = MatrixType::Hermitian;
+	      else if (typ == MatrixType::Banded)
+		typ = MatrixType::Banded_Hermitian;
+	      else
+		typ = MatrixType::Tridiagonal_Hermitian;
+	    }
+	}
+    }
+}
+MatrixType::MatrixType (const matrix_type t, bool _full) : 
+  typ (MatrixType::Unknown), nperm (0)
+{
+  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
+  full = _full;
+
+  if (t == MatrixType::Full || t == MatrixType::Diagonal ||
+      t == MatrixType::Permuted_Diagonal || t == MatrixType::Upper ||
+      t == MatrixType::Lower || t == MatrixType::Tridiagonal ||
+      t == MatrixType::Tridiagonal_Hermitian || t == MatrixType::Rectangular)
+    typ = t;
+  else
+    (*current_liboctave_warning_handler) ("Invalid matrix type");
+}
+
+MatrixType::MatrixType (const matrix_type t, const octave_idx_type np,
+			const octave_idx_type *p, bool _full) : 
+  typ (MatrixType::Unknown), nperm (0)
+{
+  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
+  full = _full;
+
+  if (t == MatrixType::Permuted_Upper || t == MatrixType::Permuted_Lower)
+    {
+      typ = t;
+      nperm = np;
+      perm = new octave_idx_type [nperm];
+      for (octave_idx_type i = 0; i < nperm; i++)
+	perm[i] = p[i];
+    }
+  else
+    (*current_liboctave_warning_handler) ("Invalid matrix type");
+}
+
+MatrixType::MatrixType (const matrix_type t, const octave_idx_type ku,
+			const octave_idx_type kl, bool _full) : 
+  typ (MatrixType::Unknown), nperm (0)
+{
+  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
+  full = _full;
+
+  if (t == MatrixType::Banded || t == MatrixType::Banded_Hermitian)
+    {
+      typ = t;
+      upper_band = ku;
+      lower_band = kl;
+    }
+  else
+    (*current_liboctave_warning_handler) ("Invalid sparse matrix type"); 
+}
+
+MatrixType::~MatrixType (void) 
+{ 
+  if (nperm != 0)
+    {
+      delete [] perm; 
+    }
+}
+
+MatrixType& 
+MatrixType::operator = (const MatrixType& a)
+{
+  if (this != &a)
+    {
+      typ = a.typ;
+      sp_bandden = a.sp_bandden;
+      bandden = a.bandden;
+      upper_band = a.upper_band;
+      lower_band = a.lower_band;
+      dense = a.dense;
+      full = a.full;
+      nperm = a.nperm;
+
+      if (nperm != 0)
+	{
+	  perm = new octave_idx_type [nperm];
+	  for (octave_idx_type i = 0; i < nperm; i++)
+	    perm[i] = a.perm[i];
+	}
+    }
+
+  return *this;
+}
+
+int
+MatrixType::type (bool quiet)
+{
+  if (typ != MatrixType::Unknown && (full ||
+      sp_bandden == Voctave_sparse_controls.get_key ("bandden")))
+    {
+      if (!quiet &&
+	  Voctave_sparse_controls.get_key ("spumoni") != 0.)
+  	(*current_liboctave_warning_handler) 
+  	  ("Using Cached Matrix Type");
+      
+      return typ;
+    }
+
+  if (typ != MatrixType::Unknown && 
+      Voctave_sparse_controls.get_key ("spumoni") != 0.)
+    (*current_liboctave_warning_handler) 
+      ("Invalidating Matrix Type");
+
+  typ = MatrixType::Unknown;
+
+  return typ;
+}
+
+int
+MatrixType::type (const SparseMatrix &a)
+{
+  if (typ != MatrixType::Unknown && (full ||
+      sp_bandden == Voctave_sparse_controls.get_key ("bandden")))
+    {
+      if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
+  	(*current_liboctave_warning_handler) 
+  	  ("Using Cached Matrix Type");
+      
+      return typ;
+    }
+
+  MatrixType tmp_typ (a);
+  typ = tmp_typ.typ;
+  sp_bandden = tmp_typ.sp_bandden;
+  bandden = tmp_typ.bandden;
+  upper_band = tmp_typ.upper_band;
+  lower_band = tmp_typ.lower_band;
+  dense = tmp_typ.dense;
+  full = tmp_typ.full;
+  nperm = tmp_typ.nperm;
+
+  if (nperm != 0)
+    {
+      perm = new octave_idx_type [nperm];
+      for (octave_idx_type i = 0; i < nperm; i++)
+	perm[i] = tmp_typ.perm[i];
+    }
+
+  return typ;
+}
+
+int
+MatrixType::type (const SparseComplexMatrix &a)
+{
+  if (typ != MatrixType::Unknown && (full || 
+      sp_bandden == Voctave_sparse_controls.get_key ("bandden")))
+    {
+      if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
+  	(*current_liboctave_warning_handler) 
+  	  ("Using Cached Matrix Type");
+      
+      return typ;
+    }
+
+  MatrixType tmp_typ (a);
+  typ = tmp_typ.typ;
+  sp_bandden = tmp_typ.sp_bandden;
+  bandden = tmp_typ.bandden;
+  upper_band = tmp_typ.upper_band;
+  lower_band = tmp_typ.lower_band;
+  dense = tmp_typ.dense;
+  full = tmp_typ.full;
+  nperm = tmp_typ.nperm;
+
+  if (nperm != 0)
+    {
+      perm = new octave_idx_type [nperm];
+      for (octave_idx_type i = 0; i < nperm; i++)
+	perm[i] = tmp_typ.perm[i];
+    }
+
+  return typ;
+}
+int
+MatrixType::type (const Matrix &a)
+{
+  if (typ != MatrixType::Unknown)
+    {
+      if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
+  	(*current_liboctave_warning_handler) 
+  	  ("Using Cached Matrix Type");
+      
+      return typ;
+    }
+
+  MatrixType tmp_typ (a);
+  typ = tmp_typ.typ;
+  full = tmp_typ.full;
+  nperm = tmp_typ.nperm;
+
+  if (nperm != 0)
+    {
+      perm = new octave_idx_type [nperm];
+      for (octave_idx_type i = 0; i < nperm; i++)
+	perm[i] = tmp_typ.perm[i];
+    }
+
+  return typ;
+}
+
+int
+MatrixType::type (const ComplexMatrix &a)
+{
+  if (typ != MatrixType::Unknown)
+    {
+      if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
+  	(*current_liboctave_warning_handler) 
+  	  ("Using Cached Matrix Type");
+      
+      return typ;
+    }
+
+  MatrixType tmp_typ (a);
+  typ = tmp_typ.typ;
+  full = tmp_typ.full; 
+  nperm = tmp_typ.nperm;
+
+  if (nperm != 0)
+    {
+      perm = new octave_idx_type [nperm];
+      for (octave_idx_type i = 0; i < nperm; i++)
+	perm[i] = tmp_typ.perm[i];
+    }
+
+  return typ;
+}
+
+void
+MatrixType::info () const
+{
+  if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
+    {
+      if (typ == MatrixType::Unknown)
+	(*current_liboctave_warning_handler) 
+	  ("Unknown Matrix Type");
+      else if (typ == MatrixType::Diagonal)
+	(*current_liboctave_warning_handler) 
+	  ("Diagonal Sparse Matrix");
+      else if (typ == MatrixType::Permuted_Diagonal)
+	(*current_liboctave_warning_handler) 
+	  ("Permuted Diagonal Sparse Matrix");
+      else if (typ == MatrixType::Upper)
+	(*current_liboctave_warning_handler) 
+	  ("Upper Triangular Matrix");
+      else if (typ == MatrixType::Lower)
+	(*current_liboctave_warning_handler) 
+	  ("Lower Triangular Matrix");
+      else if (typ == MatrixType::Permuted_Upper)
+	(*current_liboctave_warning_handler) 
+	  ("Permuted Upper Triangular Matrix");
+      else if (typ == MatrixType::Permuted_Lower)
+	(*current_liboctave_warning_handler) 
+	  ("Permuted Lower Triangular Matrix");
+      else if (typ == MatrixType::Banded)
+	(*current_liboctave_warning_handler) 
+	  ("Banded Sparse Matrix %d-1-%d (Density %f)", lower_band, 
+	   upper_band, bandden);
+      else if (typ == MatrixType::Banded_Hermitian)
+	(*current_liboctave_warning_handler) 
+	  ("Banded Hermitian/Symmetric Sparse Matrix %d-1-%d (Density %f)", 
+	   lower_band, upper_band, bandden);
+      else if (typ == MatrixType::Hermitian)
+	(*current_liboctave_warning_handler) 
+	  ("Hermitian/Symmetric Matrix");
+      else if (typ == MatrixType::Tridiagonal)
+	(*current_liboctave_warning_handler) 
+	  ("Tridiagonal Sparse Matrix");
+      else if (typ == MatrixType::Tridiagonal_Hermitian)
+	(*current_liboctave_warning_handler) 
+	  ("Hermitian/Symmetric Tridiagonal Sparse Matrix");
+      else if (typ == MatrixType::Rectangular)
+	(*current_liboctave_warning_handler) 
+	  ("Rectangular/Singular Matrix");
+      else if (typ == MatrixType::Full)
+	(*current_liboctave_warning_handler) 
+	  ("Full Matrix");
+    }
+}
+
+void
+MatrixType::mark_as_symmetric (void)
+{
+  if (typ == MatrixType::Tridiagonal || 
+      typ == MatrixType::Tridiagonal_Hermitian)
+    typ = MatrixType::Tridiagonal_Hermitian;
+  else if (typ == MatrixType::Banded ||
+	   typ == MatrixType::Banded_Hermitian)
+    typ = MatrixType::Banded_Hermitian;
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian || 
+	   typ == MatrixType::Unknown)
+    typ = MatrixType::Hermitian;
+  else
+    (*current_liboctave_error_handler) 
+      ("Can not mark current matrix type as symmetric");
+}
+
+void
+MatrixType::mark_as_unsymmetric (void)
+{
+  if (typ == MatrixType::Tridiagonal || 
+      typ == MatrixType::Tridiagonal_Hermitian)
+    typ = MatrixType::Tridiagonal;
+  else if (typ == MatrixType::Banded ||
+	   typ == MatrixType::Banded_Hermitian)
+    typ = MatrixType::Banded;
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian || 
+	   typ == MatrixType::Unknown)
+    typ = MatrixType::Full;
+}
+
+void
+MatrixType::mark_as_permuted (const octave_idx_type np, const octave_idx_type *p)
+{
+  nperm = np;
+  perm = new octave_idx_type [nperm];
+  for (octave_idx_type i = 0; i < nperm; i++)
+    perm[i] = p[i];
+
+  if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
+    typ = MatrixType::Permuted_Diagonal;
+  else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
+    typ = MatrixType::Permuted_Upper;
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+    typ = MatrixType::Permuted_Lower;
+  else
+    (*current_liboctave_error_handler) 
+      ("Can not mark current matrix type as symmetric");
+}
+
+void
+MatrixType::mark_as_unpermuted (void)
+{
+  if (nperm)
+    {
+      nperm = 0;
+      delete [] perm;
+    }
+
+  if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
+    typ = MatrixType::Diagonal;
+  else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
+    typ = MatrixType::Upper;
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+    typ = MatrixType::Lower;
+}
+
+MatrixType
+MatrixType::transpose (void) const
+{
+  MatrixType retval (*this);
+  if (typ == MatrixType::Upper)
+    retval.typ = MatrixType::Lower;
+  else if (typ == MatrixType::Permuted_Upper)
+    retval.typ = MatrixType::Permuted_Lower;
+  else if (typ == MatrixType::Lower)
+    retval.typ = MatrixType::Upper;
+  else if (typ == MatrixType::Permuted_Lower)
+    retval.typ = MatrixType::Permuted_Upper;
+  else if (typ == MatrixType::Banded)
+    {
+      retval.upper_band = lower_band;
+      retval.lower_band = upper_band;
+    }
+
+  return retval;
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
+
diff --git a/liboctave/MatrixType.h b/liboctave/MatrixType.h
new file mode 100644
--- /dev/null
+++ b/liboctave/MatrixType.h
@@ -0,0 +1,176 @@
+/*
+
+Copyright (C) 2006 David Bateman
+Copyright (C) 2006 Andy Adler
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.
+
+*/
+
+#if !defined (octave_MatrixType_h)
+#define octave_MatrixType_h
+
+class Matrix;
+class ComplexMatrix;
+class SparseMatrix;
+class SparseComplexMatrix;
+
+class
+MatrixType
+{
+public:
+  enum matrix_type {
+    Unknown = 0,
+    Full,
+    Diagonal,
+    Permuted_Diagonal,
+    Upper,
+    Lower,
+    Permuted_Upper,
+    Permuted_Lower,
+    Banded,
+    Hermitian,
+    Banded_Hermitian,
+    Tridiagonal,
+    Tridiagonal_Hermitian,
+    Rectangular
+  };
+
+  MatrixType (void);
+    
+  MatrixType (const MatrixType &a);
+
+  MatrixType (const Matrix &a);
+
+  MatrixType (const ComplexMatrix &a);
+
+  MatrixType (const SparseMatrix &a);
+
+  MatrixType (const SparseComplexMatrix &a);
+
+  MatrixType (const matrix_type t, bool _full = false);
+
+  MatrixType (const matrix_type t, const octave_idx_type np,
+	      const octave_idx_type *p, bool _full = false);
+
+  MatrixType (const matrix_type t, const octave_idx_type ku, 
+	      const octave_idx_type kl, bool _full = false);
+
+  ~MatrixType (void);
+
+  MatrixType& operator = (const MatrixType& a);
+
+  int type (bool quiet = true);
+
+  int type (const Matrix &a);
+
+  int type (const ComplexMatrix &a);
+
+  int type (const SparseMatrix &a);
+
+  int type (const SparseComplexMatrix &a);
+
+  double band_density (void) const { return bandden; }
+
+  int nupper (void) const { return upper_band; }
+
+  int nlower (void) const { return lower_band; }
+
+  bool is_dense (void) const { return dense; }
+
+  bool is_diagonal (void) const 
+    { return (typ == Diagonal || typ == Permuted_Diagonal); }
+  
+  bool is_upper_triangular (void) const 
+    { return (typ == Upper || typ == Permuted_Upper); }
+
+  bool is_lower_triangular (void) const 
+    { return (typ == Lower || typ == Permuted_Lower); }
+
+   bool is_banded (void)
+    { return (typ == Banded || typ == Banded_Hermitian); }
+  
+  bool is_tridiagonal (void) const
+    { return (typ == Tridiagonal || typ == Tridiagonal_Hermitian); }
+  
+  bool is_hermitian (void) const
+    { return (typ == Banded_Hermitian || typ == Tridiagonal_Hermitian ||
+	      typ == Hermitian); }
+
+  bool is_rectangular (void) const { return (typ == Rectangular); }
+
+  bool is_known (void) const { return (typ != Unknown); }
+
+  bool is_unknown (void) const { return (typ == Unknown); }
+
+  void info (void) const;
+
+  octave_idx_type * triangular_perm (void) const { return perm; }
+
+  void invalidate_type (void) { typ = Unknown; }
+
+  void mark_as_diagonal (void) { typ = Diagonal; }
+
+  void mark_as_permuted_diagonal (void) { typ = Permuted_Diagonal; }
+
+  void mark_as_upper_triangular (void) { typ = Upper; }
+
+  void mark_as_lower_triangular (void) { typ = Lower; }
+
+  void mark_as_tridiagonal (void) {typ = Tridiagonal; }
+
+  void mark_as_banded (const octave_idx_type ku, const octave_idx_type kl)
+    { typ = Banded; upper_band = ku; lower_band = kl; }
+
+  void mark_as_full (void) { typ = Full; }
+
+  void mark_as_rectangular (void) { typ = Rectangular; }
+
+  void mark_as_dense (void) { dense = true; }
+
+  void mark_as_not_dense (void) { dense = false; }
+
+  void mark_as_symmetric (void);
+
+  void mark_as_unsymmetric (void);
+
+  void mark_as_permuted (const octave_idx_type np, const octave_idx_type *p);
+
+  void mark_as_unpermuted (void);
+
+  MatrixType transpose (void) const;
+
+private:
+  void type (int new_typ) { typ = static_cast<matrix_type>(new_typ); }
+
+  matrix_type typ;
+  double sp_bandden;
+  double bandden;
+  octave_idx_type upper_band;
+  octave_idx_type lower_band;
+  bool dense;
+  bool full;
+  octave_idx_type nperm;
+  octave_idx_type *perm;
+};
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/SparseCmplxCHOL.cc b/liboctave/SparseCmplxCHOL.cc
--- a/liboctave/SparseCmplxCHOL.cc
+++ b/liboctave/SparseCmplxCHOL.cc
@@ -37,28 +37,28 @@ SparseComplexMatrix
 chol2inv (const SparseComplexMatrix& r)
 {
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.cols ();
   SparseComplexMatrix retval;
 
   if (r_nr == r_nc)
     {
-      SparseType mattype (r);
+      MatrixType mattype (r);
       int typ = mattype.type (false);
       double rcond;
       octave_idx_type info;
       SparseComplexMatrix rinv;
 
-      if (typ == SparseType::Upper)
+      if (typ == MatrixType::Upper)
 	{
 	  rinv = r.inverse(mattype, info, rcond, true, false);
 	  retval = rinv.transpose() * rinv;
 	}
-      else if (typ == SparseType::Lower)
+      else if (typ == MatrixType::Lower)
 	{
 	  rinv = r.transpose().inverse(mattype, info, rcond, true, false);
 	  retval = rinv.transpose() * rinv;
 	}
       else
 	(*current_liboctave_error_handler) 
 	  ("spchol2inv requires triangular matrix");
     }
diff --git a/liboctave/SparseType.cc b/liboctave/SparseType.cc
deleted file mode 100644
--- a/liboctave/SparseType.cc
+++ /dev/null
@@ -1,1017 +0,0 @@
-/*
-
-Copyright (C) 2004 David Bateman
-Copyright (C) 1998-2004 Andy Adler
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; see the file COPYING.  If not, write to the
-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <vector>
-
-#include "SparseType.h"
-#include "dSparse.h"
-#include "CSparse.h"
-#include "oct-spparms.h"
-
-// FIXME There is a large code duplication here
-
-SparseType::SparseType (void) : typ (SparseType::Unknown), nperm (0)
-{
-  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
-} 
-
-SparseType::SparseType (const SparseType &a) : typ (a.typ), 
-    sp_bandden (a.sp_bandden), bandden (a.bandden), 
-    upper_band (a.upper_band), lower_band (a.lower_band), 
-    dense (a.dense), nperm (a.nperm)
-{ 
-  if (nperm != 0)
-    {
-      perm = new octave_idx_type [nperm];
-      for (octave_idx_type i = 0; i < nperm; i++)
-	perm[i] = a.perm[i];
-    }
-}
-
-SparseType::SparseType (const SparseMatrix &a)
-{
-  octave_idx_type nrows = a.rows ();
-  octave_idx_type ncols = a.cols ();
-  octave_idx_type nm = (ncols < nrows ? ncols : nrows);
-  octave_idx_type nnz = a.nzmax ();
-
-  if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
-    (*current_liboctave_warning_handler) 
-      ("Calculating Sparse Matrix Type");
-
-  nperm = 0;
-
-  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
-  bool maybe_hermitian = false;
-  typ = SparseType::Full;
-
-  if (nnz == nm)
-    {
-      matrix_type tmp_typ = SparseType::Diagonal;
-      octave_idx_type i;
-      // Maybe the matrix is diagonal
-      for (i = 0; i < nm; i++)
-	{
-	  if (a.cidx(i+1) != a.cidx(i) + 1)
-	    {
-	      tmp_typ = SparseType::Full;
-	      break;
-	    }
-	  if (a.ridx(i) != i)
-	    {
-	      tmp_typ = SparseType::Permuted_Diagonal;
-	      break;
-	    }
-	}
-	  
-      if (tmp_typ == SparseType::Permuted_Diagonal)
-	{
-	  std::vector<bool> found (nrows);
-
-	  for (octave_idx_type j = 0; j < i; j++)
-	    found [j] = true;
-	  for (octave_idx_type j = i; j < nrows; j++)
-	    found [j] = false;
-	      
-	  for (octave_idx_type j = i; j < nm; j++)
-	    {
-	      if ((a.cidx(j+1) > a.cidx(j) + 1)  || 
-		  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
-		{
-		  tmp_typ = SparseType::Full;
-		  break;
-		}
-	      found [a.ridx(j)] = true;
-	    }
-	}
-      typ = tmp_typ;
-    }
-
-  if (typ == SparseType::Full)
-    {
-      // Search for banded, upper and lower triangular matrices
-      bool singular = false;
-      upper_band = 0;
-      lower_band = 0;
-      for (octave_idx_type j = 0; j < ncols; j++)
-	{
-	  bool zero_on_diagonal = false;
-	  if (j < nrows)
-	    {
-	      zero_on_diagonal = true;
-	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		if (a.ridx(i) == j)
-		  {
-		    zero_on_diagonal = false;
-		    break;
-		  }
-	    }
-
-	  if (zero_on_diagonal)
-	    {
-	      singular = true;
-	      break;
-	    }
-
-	  if (a.cidx(j+1) != a.cidx(j))
-	    {
-	      octave_idx_type ru = a.ridx(a.cidx(j));
-	      octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
-
-	      if (j - ru > upper_band)
-		upper_band = j - ru;
-		  
-	      if (rl - j > lower_band)
-		lower_band = rl - j;
-	    }
-	}
-
-      if (!singular)
-	{
-	  bandden = double (nnz) /
-	    (double (ncols) * (double (lower_band) +
-			       double (upper_band)) -
-	     0.5 * double (upper_band + 1) * double (upper_band) -
-	     0.5 * double (lower_band + 1) * double (lower_band));
-
-	  if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
-	    {
-	      if (upper_band == 1 && lower_band == 1)
-		typ = SparseType::Tridiagonal;
-	      else
-		typ = SparseType::Banded;
-
-	      octave_idx_type nnz_in_band = 
-		(upper_band + lower_band + 1) * nrows -
-		(1 + upper_band) * upper_band / 2 -
-		(1 + lower_band) * lower_band / 2;
-	      if (nnz_in_band == nnz)
-		dense = true;
-	      else 
-		dense = false;
-	    }
-	  else if (upper_band == 0)
-	    typ = SparseType::Lower;
-	  else if (lower_band == 0)
-	    typ = SparseType::Upper;
-
-	  if (upper_band == lower_band && nrows == ncols)
-	    maybe_hermitian = true;
-	}
-
-      if (typ == SparseType::Full)
-	{
-	  // Search for a permuted triangular matrix, and test if
-	  // permutation is singular
-
-	  // FIXME
-	  // Perhaps this should be based on a dmperm algorithm
-	  bool found = false;
-
-	  nperm = ncols;
-	  perm = new octave_idx_type [ncols];
-
-	  for (octave_idx_type i = 0; i < ncols; i++)
-	    perm [i] = -1;
-
-	  for (octave_idx_type i = 0; i < nm; i++)
-	    {
-	      found = false;
-
-	      for (octave_idx_type j = 0; j < ncols; j++)
-		{
-		  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
-		      (a.ridx(a.cidx(j+1)-1) == i))
-		    {
-		      perm [i] = j;
-		      found = true;
-		      break;
-		    }
-		}
-
-	      if (!found)
-		break;
-	    }
-
-	  if (found)
-	    {
-	      typ = SparseType::Permuted_Upper;
-	      if (ncols > nrows)
-		{
-		  octave_idx_type k = nrows;
-		  for (octave_idx_type i = 0; i < ncols; i++)
-		    if (perm [i] == -1)
-		      perm[i] = k++;
-		}
-	    }
-	  else if (a.cidx(nm) == a.cidx(ncols))
-	    {
-	      nperm = nrows;
-	      delete [] perm;
-	      perm = new octave_idx_type [nrows];
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
-
-	      for (octave_idx_type i = 0; i < nrows; i++)
-		{
-		  perm [i] = -1;
-		  tmp [i] = -1;
-		}
-
-	      for (octave_idx_type j = 0; j < ncols; j++)
-		for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		    perm [a.ridx(i)] = j;
-
-	      found = true;
-	      for (octave_idx_type i = 0; i < nm; i++)
-		if (perm[i] == -1)
-		  {
-		    found = false;
-		    break;
-		  }
-		else
-		  {
-		    tmp[perm[i]] = 1;
-		  }
-
-	      if (found)
-		{
-		  octave_idx_type k = ncols;
-		  for (octave_idx_type i = 0; i < nrows; i++)
-		    {
-		      if (tmp[i] == -1)
-			{
-			  if (k < nrows)
-			    {
-			      perm[k++] = i;
-			    }
-			  else
-			    {
-			      found = false;
-			      break;
-			    }
-			}
-		    }
-		}
-
-	      if (found)
-		typ = SparseType::Permuted_Lower;
-	      else
-		{
-		  delete [] perm;
-		  nperm = 0;
-		}
-	    }
-	  else
-	    {
-	      delete [] perm;
-	      nperm = 0;
-	    }
-	}
-
-      // FIXME
-      // Disable lower under-determined and upper over-determined problems
-      // as being detected, and force to treat as singular. As this seems
-      // to cause issues
-      if (((typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
-	   && nrows > ncols) ||
-	  ((typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
-	   && nrows < ncols))
-	{
-	  typ = SparseType::Rectangular;
-	  if (typ == SparseType::Permuted_Upper ||
-	      typ == SparseType::Permuted_Lower)
-	    delete [] perm;
-	  nperm = 0;
-	}
-
-      if (typ == SparseType::Full && ncols != nrows)
-	typ = SparseType::Rectangular;
-
-      if (maybe_hermitian && (typ == SparseType::Full || 
-			      typ == SparseType::Tridiagonal || 
-			      typ == SparseType::Banded))
-	{
-	  // Check for symmetry, with positive real diagonal, which
-	  // has a very good chance of being symmetric positive
-	  // definite..
-	  bool is_herm = true;
-
-	  for (octave_idx_type j = 0; j < ncols; j++)
-	    {
-	      bool diag_positive = false;
-
-	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		{
-		  octave_idx_type ri = a.ridx(i);
-
-		  if (ri == j)
-		    {
-		      if (a.data(i) == std::abs(a.data(i)))
-			diag_positive = true;
-		      else
-			break;
-		    }
-		  else
-		    {
-		      bool found = false;
-
-		      for (octave_idx_type k = a.cidx(ri); k < a.cidx(ri+1); k++)
-			{
-			  if (a.ridx(k) == j)
-			    {
-			      if (a.data(i) == a.data(k))
-				found = true;
-			      break;
-			    }
-			}
-
-		      if (! found)
-			{
-			  is_herm = false;
-			  break;
-			}
-		    }
-		}
-
-	      if (! diag_positive || ! is_herm)
-		{
-		  is_herm = false;
-		  break;
-		} 
-	    }
-
-	  if (is_herm)
-	    {
-	      if (typ == SparseType::Full)
-		typ = SparseType::Hermitian;
-	      else if (typ == SparseType::Banded)
-		typ = SparseType::Banded_Hermitian;
-	      else
-		typ = SparseType::Tridiagonal_Hermitian;
-	    }
-	}
-    }
-}
-
-SparseType::SparseType (const SparseComplexMatrix &a)
-{
-  octave_idx_type nrows = a.rows ();
-  octave_idx_type ncols = a.cols ();
-  octave_idx_type nm = (ncols < nrows ? ncols : nrows);
-  octave_idx_type nnz = a.nzmax ();
-
-  if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
-    (*current_liboctave_warning_handler) 
-      ("Calculating Sparse Matrix Type");
-
-  nperm = 0;
-
-  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
-  bool maybe_hermitian = false;
-  typ = SparseType::Full;
-
-  if (nnz == nm)
-    {
-      matrix_type tmp_typ = SparseType::Diagonal;
-      octave_idx_type i;
-      // Maybe the matrix is diagonal
-      for (i = 0; i < nm; i++)
-	{
-	  if (a.cidx(i+1) != a.cidx(i) + 1)
-	    {
-	      tmp_typ = SparseType::Full;
-	      break;
-	    }
-	  if (a.ridx(i) != i)
-	    {
-	      tmp_typ = SparseType::Permuted_Diagonal;
-	      break;
-	    }
-	}
-	  
-      if (tmp_typ == SparseType::Permuted_Diagonal)
-	{
-	  std::vector<bool> found (nrows);
-
-	  for (octave_idx_type j = 0; j < i; j++)
-	    found [j] = true;
-	  for (octave_idx_type j = i; j < nrows; j++)
-	    found [j] = false;
-	      
-	  for (octave_idx_type j = i; j < nm; j++)
-	    {
-	      if ((a.cidx(j+1) > a.cidx(j) + 1)  || 
-		  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
-		{
-		  tmp_typ = SparseType::Full;
-		  break;
-		}
-	      found [a.ridx(j)] = true;
-	    }
-	}
-      typ = tmp_typ;
-    }
-
-  if (typ == SparseType::Full)
-    {
-      // Search for banded, upper and lower triangular matrices
-      bool singular = false;
-      upper_band = 0;
-      lower_band = 0;
-      for (octave_idx_type j = 0; j < ncols; j++)
-	{
-	  bool zero_on_diagonal = false;
-	  if (j < nrows)
-	    {
-	      zero_on_diagonal = true;
-	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		if (a.ridx(i) == j)
-		  {
-		    zero_on_diagonal = false;
-		    break;
-		  }
-	    }
-
-	  if (zero_on_diagonal)
-	    {
-	      singular = true;
-	      break;
-	    }
-
-	  if (a.cidx(j+1) != a.cidx(j))
-	    {
-	      octave_idx_type ru = a.ridx(a.cidx(j));
-	      octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
-
-	      if (j - ru > upper_band)
-		upper_band = j - ru;
-		  
-	      if (rl - j > lower_band)
-		lower_band = rl - j;
-	    }
-	}
-
-      if (!singular)
-	{
-	  bandden = double (nnz) /
-	    (double (ncols) * (double (lower_band) +
-			       double (upper_band)) -
-	     0.5 * double (upper_band + 1) * double (upper_band) -
-	     0.5 * double (lower_band + 1) * double (lower_band));
-
-	  if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
-	    {
-	      if (upper_band == 1 && lower_band == 1)
-		typ = SparseType::Tridiagonal;
-	      else
-		typ = SparseType::Banded;
-
-	      octave_idx_type nnz_in_band = 
-		(upper_band + lower_band + 1) * nrows -
-		(1 + upper_band) * upper_band / 2 -
-		(1 + lower_band) * lower_band / 2;
-	      if (nnz_in_band == nnz)
-		dense = true;
-	      else 
-		dense = false;
-	    }
-	  else if (upper_band == 0)
-	    typ = SparseType::Lower;
-	  else if (lower_band == 0)
-	    typ = SparseType::Upper;
-
-	  if (upper_band == lower_band && nrows == ncols)
-	    maybe_hermitian = true;
-	}
-
-      if (typ == SparseType::Full)
-	{
-	  // Search for a permuted triangular matrix, and test if
-	  // permutation is singular
-
-	  // FIXME
-	  // Perhaps this should be based on a dmperm algorithm
-	  bool found = false;
-
-	  nperm = ncols;
-	  perm = new octave_idx_type [ncols];
-
-	  for (octave_idx_type i = 0; i < ncols; i++)
-	    perm [i] = -1;
-
-	  for (octave_idx_type i = 0; i < nm; i++)
-	    {
-	      found = false;
-
-	      for (octave_idx_type j = 0; j < ncols; j++)
-		{
-		  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
-		      (a.ridx(a.cidx(j+1)-1) == i))
-		    {
-		      perm [i] = j;
-		      found = true;
-		      break;
-		    }
-		}
-
-	      if (!found)
-		break;
-	    }
-
-	  if (found)
-	    {
-	      typ = SparseType::Permuted_Upper;
-	      if (ncols > nrows)
-		{
-		  octave_idx_type k = nrows;
-		  for (octave_idx_type i = 0; i < ncols; i++)
-		    if (perm [i] == -1)
-		      perm[i] = k++;
-		}
-	    }
-	  else if (a.cidx(nm) == a.cidx(ncols))
-	    {
-	      nperm = nrows;
-	      delete [] perm;
-	      perm = new octave_idx_type [nrows];
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
-
-	      for (octave_idx_type i = 0; i < nrows; i++)
-		{
-		  perm [i] = -1;
-		  tmp [i] = -1;
-		}
-
-	      for (octave_idx_type j = 0; j < ncols; j++)
-		for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		    perm [a.ridx(i)] = j;
-
-	      found = true;
-	      for (octave_idx_type i = 0; i < nm; i++)
-		if (perm[i] == -1)
-		  {
-		    found = false;
-		    break;
-		  }
-		else
-		  {
-		    tmp[perm[i]] = 1;
-		  }
-
-	      if (found)
-		{
-		  octave_idx_type k = ncols;
-		  for (octave_idx_type i = 0; i < nrows; i++)
-		    {
-		      if (tmp[i] == -1)
-			{
-			  if (k < nrows)
-			    {
-			      perm[k++] = i;
-			    }
-			  else
-			    {
-			      found = false;
-			      break;
-			    }
-			}
-		    }
-		}
-
-	      if (found)
-		typ = SparseType::Permuted_Lower;
-	      else
-		{
-		  delete [] perm;
-		  nperm = 0;
-		}
-	    }
-	  else
-	    {
-	      delete [] perm;
-	      nperm = 0;
-	    }
-	}
-
-      // FIXME
-      // Disable lower under-determined and upper over-determined problems
-      // as being detected, and force to treat as singular. As this seems
-      // to cause issues
-      if (((typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
-	   && nrows > ncols) ||
-	  ((typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
-	   && nrows < ncols))
-	{
-	  typ = SparseType::Rectangular;
-	  if (typ == SparseType::Permuted_Upper ||
-	      typ == SparseType::Permuted_Lower)
-	    delete [] perm;
-	  nperm = 0;
-	}
-
-      if (typ == SparseType::Full && ncols != nrows)
-	typ = SparseType::Rectangular;
-
-      if (maybe_hermitian && (typ == SparseType::Full || 
-			      typ == SparseType::Tridiagonal || 
-			      typ == SparseType::Banded))
-	{
-	  // Check for symmetry, with positive real diagonal, which
-	  // has a very good chance of being symmetric positive
-	  // definite..
-	  bool is_herm = true;
-
-	  for (octave_idx_type j = 0; j < ncols; j++)
-	    {
-	      bool diag_positive = false;
-
-	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		{
-		  octave_idx_type ri = a.ridx(i);
-
-		  if (ri == j)
-		    {
-		      if (a.data(i) == std::abs(a.data(i)))
-			diag_positive = true;
-		      else
-			break;
-		    }
-		  else
-		    {
-		      bool found = false;
-
-		      for (octave_idx_type k = a.cidx(ri); k < a.cidx(ri+1); k++)
-			{
-			  if (a.ridx(k) == j)
-			    {
-			      if (a.data(i) == conj(a.data(k)))
-				found = true;
-			      break;
-			    }
-			}
-
-		      if (! found)
-			{
-			  is_herm = false;
-			  break;
-			}
-		    }
-		}
-
-	      if (! diag_positive || ! is_herm)
-		{
-		  is_herm = false;
-		  break;
-		} 
-	    }
-
-	  if (is_herm)
-	    {
-	      if (typ == SparseType::Full)
-		typ = SparseType::Hermitian;
-	      else if (typ == SparseType::Banded)
-		typ = SparseType::Banded_Hermitian;
-	      else
-		typ = SparseType::Tridiagonal_Hermitian;
-	    }
-	}
-    }
-}
-
-SparseType::SparseType (const matrix_type t) : typ (SparseType::Unknown), 
-					       nperm (0)
-{
-  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
-
-  if (t == SparseType::Full || t == SparseType::Diagonal ||
-      t == SparseType::Permuted_Diagonal || t == SparseType::Upper ||
-      t == SparseType::Lower || t == SparseType::Tridiagonal ||
-      t == SparseType::Tridiagonal_Hermitian || t == SparseType::Rectangular)
-    typ = t;
-  else
-    (*current_liboctave_warning_handler) ("Invalid sparse matrix type");
-}
-
-SparseType::SparseType (const matrix_type t, const octave_idx_type np,
-			const octave_idx_type *p) : typ (SparseType::Unknown), 
-					       nperm (0)
-{
-  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
-
-  if (t == SparseType::Permuted_Upper || t == SparseType::Permuted_Lower)
-    {
-      typ = t;
-      nperm = np;
-      perm = new octave_idx_type [nperm];
-      for (octave_idx_type i = 0; i < nperm; i++)
-	perm[i] = p[i];
-    }
-  else
-    (*current_liboctave_warning_handler) ("Invalid sparse matrix type");
-}
-
-SparseType::SparseType (const matrix_type t, const octave_idx_type ku,
-			const octave_idx_type kl) : typ (SparseType::Unknown), 
-					       nperm (0)
-{
-  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
-
-  if (t == SparseType::Banded || t == SparseType::Banded_Hermitian)
-    {
-      typ = t;
-      upper_band = ku;
-      lower_band = kl;
-    }
-  else
-    (*current_liboctave_warning_handler) ("Invalid sparse matrix type"); 
-}
-
-SparseType::~SparseType (void) 
-{ 
-  if (nperm != 0)
-    {
-      delete [] perm; 
-    }
-}
-
-SparseType& 
-SparseType::operator = (const SparseType& a)
-{
-  if (this != &a)
-    {
-      typ = a.typ;
-      sp_bandden = a.sp_bandden;
-      bandden = a.bandden;
-      upper_band = a.upper_band;
-      lower_band = a.lower_band;
-      dense = a.dense;
-      nperm = a.nperm;
-
-      if (nperm != 0)
-	{
-	  perm = new octave_idx_type [nperm];
-	  for (octave_idx_type i = 0; i < nperm; i++)
-	    perm[i] = a.perm[i];
-	}
-    }
-
-  return *this;
-}
-
-int
-SparseType::type (bool quiet)
-{
-  if (typ != SparseType::Unknown && 
-      sp_bandden == Voctave_sparse_controls.get_key ("bandden"))
-    {
-      if (!quiet &&
-	  Voctave_sparse_controls.get_key ("spumoni") != 0.)
-  	(*current_liboctave_warning_handler) 
-  	  ("Using Cached Sparse Matrix Type");
-      
-      return typ;
-    }
-
-  if (typ != SparseType::Unknown && 
-      Voctave_sparse_controls.get_key ("spumoni") != 0.)
-    (*current_liboctave_warning_handler) 
-      ("Invalidating Sparse Matrix Type");
-
-  typ = SparseType::Unknown;
-
-  return typ;
-}
-
-int
-SparseType::type (const SparseMatrix &a)
-{
-  if (typ != SparseType::Unknown && 
-      sp_bandden == Voctave_sparse_controls.get_key ("bandden"))
-    {
-      if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
-  	(*current_liboctave_warning_handler) 
-  	  ("Using Cached Sparse Matrix Type");
-      
-      return typ;
-    }
-
-  SparseType tmp_typ (a);
-  typ = tmp_typ.typ;
-  sp_bandden = tmp_typ.sp_bandden;
-  bandden = tmp_typ.bandden;
-  upper_band = tmp_typ.upper_band;
-  lower_band = tmp_typ.lower_band;
-  dense = tmp_typ.dense;
-  nperm = tmp_typ.nperm;
-
-  if (nperm != 0)
-    {
-      perm = new octave_idx_type [nperm];
-      for (octave_idx_type i = 0; i < nperm; i++)
-	perm[i] = tmp_typ.perm[i];
-    }
-
-  return typ;
-}
-
-int
-SparseType::type (const SparseComplexMatrix &a)
-{
-  if (typ != SparseType::Unknown && 
-      sp_bandden == Voctave_sparse_controls.get_key ("bandden"))
-    {
-      if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
-  	(*current_liboctave_warning_handler) 
-  	  ("Using Cached Sparse Matrix Type");
-      
-      return typ;
-    }
-
-  SparseType tmp_typ (a);
-  typ = tmp_typ.typ;
-  sp_bandden = tmp_typ.sp_bandden;
-  bandden = tmp_typ.bandden;
-  upper_band = tmp_typ.upper_band;
-  lower_band = tmp_typ.lower_band;
-  dense = tmp_typ.dense;
-  nperm = tmp_typ.nperm;
-
-  if (nperm != 0)
-    {
-      perm = new octave_idx_type [nperm];
-      for (octave_idx_type i = 0; i < nperm; i++)
-	perm[i] = tmp_typ.perm[i];
-    }
-
-  return typ;
-}
-
-void
-SparseType::info (void) const
-{
-  if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
-    {
-      if (typ == SparseType::Unknown)
-	(*current_liboctave_warning_handler) 
-	  ("Unknown Sparse Matrix Type");
-      else if (typ == SparseType::Diagonal)
-	(*current_liboctave_warning_handler) 
-	  ("Diagonal Sparse Matrix");
-      else if (typ == SparseType::Permuted_Diagonal)
-	(*current_liboctave_warning_handler) 
-	  ("Permuted Diagonal Sparse Matrix");
-      else if (typ == SparseType::Upper)
-	(*current_liboctave_warning_handler) 
-	  ("Upper Triangular Sparse Matrix");
-      else if (typ == SparseType::Lower)
-	(*current_liboctave_warning_handler) 
-	  ("Lower Triangular Sparse Matrix");
-      else if (typ == SparseType::Permuted_Upper)
-	(*current_liboctave_warning_handler) 
-	  ("Permuted Upper Triangular Sparse Matrix");
-      else if (typ == SparseType::Permuted_Lower)
-	(*current_liboctave_warning_handler) 
-	  ("Permuted Lower Triangular Sparse Matrix");
-      else if (typ == SparseType::Banded)
-	(*current_liboctave_warning_handler) 
-	  ("Banded Sparse Matrix %d-1-%d (Density %f)", lower_band, 
-	   upper_band, bandden);
-      else if (typ == SparseType::Banded_Hermitian)
-	(*current_liboctave_warning_handler) 
-	  ("Banded Hermitian/Symmetric Sparse Matrix %d-1-%d (Density %f)", 
-	   lower_band, upper_band, bandden);
-      else if (typ == SparseType::Hermitian)
-	(*current_liboctave_warning_handler) 
-	  ("Hermitian/Symmetric Sparse Matrix");
-      else if (typ == SparseType::Tridiagonal)
-	(*current_liboctave_warning_handler) 
-	  ("Tridiagonal Sparse Matrix");
-      else if (typ == SparseType::Tridiagonal_Hermitian)
-	(*current_liboctave_warning_handler) 
-	  ("Hermitian/Symmetric Tridiagonal Sparse Matrix");
-      else if (typ == SparseType::Rectangular)
-	(*current_liboctave_warning_handler) 
-	  ("Rectangular/Singular Sparse Matrix");
-      else if (typ == SparseType::Full)
-	(*current_liboctave_warning_handler) 
-	  ("Full Sparse Matrix");
-    }
-}
-
-void
-SparseType::mark_as_symmetric (void)
-{
-  if (typ == SparseType::Tridiagonal || 
-      typ == SparseType::Tridiagonal_Hermitian)
-    typ = SparseType::Tridiagonal_Hermitian;
-  else if (typ == SparseType::Banded ||
-	   typ == SparseType::Banded_Hermitian)
-    typ = SparseType::Banded_Hermitian;
-  else if (typ == SparseType::Full || typ == SparseType::Hermitian || 
-	   typ == SparseType::Unknown)
-    typ = SparseType::Hermitian;
-  else
-    (*current_liboctave_error_handler) 
-      ("Can not mark current matrix type as symmetric");
-}
-
-void
-SparseType::mark_as_unsymmetric (void)
-{
-  if (typ == SparseType::Tridiagonal || 
-      typ == SparseType::Tridiagonal_Hermitian)
-    typ = SparseType::Tridiagonal;
-  else if (typ == SparseType::Banded ||
-	   typ == SparseType::Banded_Hermitian)
-    typ = SparseType::Banded;
-  else if (typ == SparseType::Full || typ == SparseType::Hermitian || 
-	   typ == SparseType::Unknown)
-    typ = SparseType::Full;
-}
-
-void
-SparseType::mark_as_permuted (const octave_idx_type np, const octave_idx_type *p)
-{
-  nperm = np;
-  perm = new octave_idx_type [nperm];
-  for (octave_idx_type i = 0; i < nperm; i++)
-    perm[i] = p[i];
-
-  if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
-    typ = SparseType::Permuted_Diagonal;
-  else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
-    typ = SparseType::Permuted_Upper;
-  else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
-    typ = SparseType::Permuted_Lower;
-  else
-    (*current_liboctave_error_handler) 
-      ("Can not mark current matrix type as symmetric");
-}
-
-void
-SparseType::mark_as_unpermuted (void)
-{
-  if (nperm)
-    {
-      nperm = 0;
-      delete [] perm;
-    }
-
-  if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
-    typ = SparseType::Diagonal;
-  else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
-    typ = SparseType::Upper;
-  else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
-    typ = SparseType::Lower;
-}
-
-SparseType
-SparseType::transpose (void) const
-{
-  SparseType retval (*this);
-  if (typ == SparseType::Upper)
-    retval.typ = SparseType::Lower;
-  else if (typ == SparseType::Permuted_Upper)
-    retval.typ = SparseType::Permuted_Lower;
-  else if (typ == SparseType::Lower)
-    retval.typ = SparseType::Upper;
-  else if (typ == SparseType::Permuted_Lower)
-    retval.typ = SparseType::Permuted_Upper;
-  else if (typ == SparseType::Banded)
-    {
-      retval.upper_band = lower_band;
-      retval.lower_band = upper_band;
-    }
-
-  return retval;
-}
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
-
diff --git a/liboctave/SparseType.h b/liboctave/SparseType.h
deleted file mode 100644
--- a/liboctave/SparseType.h
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
-
-Copyright (C) 2004 David Bateman
-Copyright (C) 1998-2004 Andy Adler
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; see the file COPYING.  If not, write to the
-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-Boston, MA 02110-1301, USA.
-
-*/
-
-#if !defined (octave_SparseType_h)
-#define octave_SparseType_h
-
-class SparseMatrix;
-class SparseComplexMatrix;
-
-class
-SparseType
-{
-public:
-  enum matrix_type {
-    Unknown = 0,
-    Full,
-    Diagonal,
-    Permuted_Diagonal,
-    Upper,
-    Lower,
-    Permuted_Upper,
-    Permuted_Lower,
-    Banded,
-    Hermitian,
-    Banded_Hermitian,
-    Tridiagonal,
-    Tridiagonal_Hermitian,
-    Rectangular
-  };
-
-  SparseType (void);
-    
-  SparseType (const SparseType &a);
-
-  SparseType (const SparseMatrix &a);
-
-  SparseType (const SparseComplexMatrix &a);
-
-  SparseType (const matrix_type t);
-
-  SparseType (const matrix_type t, const octave_idx_type np,
-	      const octave_idx_type *p);
-
-  SparseType (const matrix_type t, const octave_idx_type ku, 
-	      const octave_idx_type kl);
-
-  ~SparseType (void);
-
-  SparseType& operator = (const SparseType& a);
-
-  int type (bool quiet = true);
-
-  int type (const SparseMatrix &a);
-
-  int type (const SparseComplexMatrix &a);
-
-  double band_density (void) const { return bandden; }
-
-  int nupper (void) const { return upper_band; }
-
-  int nlower (void) const { return lower_band; }
-
-  bool is_dense (void) const { return dense; }
-
-  bool is_diagonal (void) const 
-    { return (typ == Diagonal || typ == Permuted_Diagonal); }
-  
-  bool is_upper_triangular (void) const 
-    { return (typ == Upper || typ == Permuted_Upper); }
-
-  bool is_lower_triangular (void) const 
-    { return (typ == Lower || typ == Permuted_Lower); }
-
-  bool is_banded (void)
-    { return (typ == Banded || typ == Banded_Hermitian); }
-  
-  bool is_tridiagonal (void) const
-    { return (typ == Tridiagonal || typ == Tridiagonal_Hermitian); }
-  
-  bool is_hermitian (void) const
-    { return (typ == Banded_Hermitian || typ == Tridiagonal_Hermitian ||
-	      typ == Hermitian); }
-
-  bool is_rectangular (void) const { return (typ == Rectangular); }
-
-  bool is_known (void) const { return (typ != Unknown); }
-
-  bool is_unknown (void) const { return (typ == Unknown); }
-
-  void info (void) const;
-
-  octave_idx_type * triangular_perm (void) const { return perm; }
-
-  void invalidate_type (void) { typ = Unknown; }
-
-  void mark_as_diagonal (void) { typ = Diagonal; }
-
-  void mark_as_permuted_diagonal (void) { typ = Permuted_Diagonal; }
-
-  void mark_as_upper_triangular (void) { typ = Upper; }
-
-  void mark_as_lower_triangular (void) { typ = Lower; }
-
-  void mark_as_tridiagonal (void) {typ = Tridiagonal; }
-
-  void mark_as_banded (const octave_idx_type ku, const octave_idx_type kl)
-    { typ = Banded; upper_band = ku; lower_band = kl; }
-
-  void mark_as_full (void) { typ = Full; }
-
-  void mark_as_rectangular (void) { typ = Rectangular; }
-
-  void mark_as_dense (void) { dense = true; }
-
-  void mark_as_not_dense (void) { dense = false; }
-
-  void mark_as_symmetric (void);
-
-  void mark_as_unsymmetric (void);
-
-  void mark_as_permuted (const octave_idx_type np, const octave_idx_type *p);
-
-  void mark_as_unpermuted (void);
-
-  SparseType transpose (void) const;
-
-private:
-  void type (int new_typ) { typ = static_cast<matrix_type>(new_typ); }
-
-  matrix_type typ;
-  double sp_bandden;
-  double bandden;
-  octave_idx_type upper_band;
-  octave_idx_type lower_band;
-  bool dense;
-  octave_idx_type nperm;
-  octave_idx_type *perm;
-};
-
-#endif
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/liboctave/SparsedbleCHOL.cc b/liboctave/SparsedbleCHOL.cc
--- a/liboctave/SparsedbleCHOL.cc
+++ b/liboctave/SparsedbleCHOL.cc
@@ -37,28 +37,28 @@ SparseMatrix
 chol2inv (const SparseMatrix& r)
 {
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.cols ();
   SparseMatrix retval;
 
   if (r_nr == r_nc)
     {
-      SparseType mattype (r);
+      MatrixType mattype (r);
       int typ = mattype.type (false);
       double rcond;
       octave_idx_type info;
       SparseMatrix rinv;
 
-      if (typ == SparseType::Upper)
+      if (typ == MatrixType::Upper)
 	{
 	  rinv = r.inverse(mattype, info, rcond, true, false);
 	  retval = rinv.transpose() * rinv;
 	}
-      else if (typ == SparseType::Lower)
+      else if (typ == MatrixType::Lower)
 	{
 	  rinv = r.transpose().inverse(mattype, info, rcond, true, false);
 	  retval = rinv.transpose() * rinv;
 	}
       else
 	(*current_liboctave_error_handler) 
 	  ("spchol2inv requires triangular matrix");
     }
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -103,16 +103,51 @@ extern "C"
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgelss, DGELSS) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
 			     double*, const octave_idx_type&, double*,
 			     const octave_idx_type&, double*, double&, octave_idx_type&,
 			     double*, const octave_idx_type&, octave_idx_type&);
 
+  F77_RET_T
+  F77_FUNC (dpotrf, DPOTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     double *, const octave_idx_type&, 
+			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (dpocon, DPOCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     double*, const octave_idx_type&, const double&,
+			     double&, double*, octave_idx_type*,
+			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
+  F77_RET_T
+  F77_FUNC (dpotrs, DPOTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const octave_idx_type&, const double*, 
+			     const octave_idx_type&, double*, 
+			     const octave_idx_type&, octave_idx_type&
+			     F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (dtrcon, DTRCON) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
+			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const double*, const octave_idx_type&, double&,
+			     double*, octave_idx_type*, octave_idx_type& 
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
+  F77_RET_T
+  F77_FUNC (dtrtrs, DTRTRS) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL, 
+			     F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const octave_idx_type&, const double*, 
+			     const octave_idx_type&, double*, 
+			     const octave_idx_type&, octave_idx_type&
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL
+			     F77_CHAR_ARG_LEN_DECL);
+
   // Note that the original complex fft routines were not written for
   // double complex arguments.  They have been modified by adding an
   // implicit double precision (a-h,o-z) statement at the beginning of
   // each subroutine.
 
   F77_RET_T
   F77_FUNC (cffti, CFFTI) (const octave_idx_type&, Complex*);
 
@@ -1149,16 +1184,579 @@ Matrix::determinant (octave_idx_type& in
 	    }
 	}
     }
 
   return retval;
 }
 
 Matrix
+Matrix::utsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond) const
+{
+  Matrix retval;
+
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr == 0 || nc == 0 || nr != b.rows ())
+    (*current_liboctave_error_handler)
+      ("matrix dimension mismatch solution of linear equations");
+  else
+    {
+      volatile int typ = mattype.type ();
+
+      if (typ == MatrixType::Permuted_Upper ||
+	  typ == MatrixType::Upper)
+	{
+	  octave_idx_type b_nc = b.cols ();
+	  rcond = 1.;
+	  info = 0;
+
+	  if (typ == MatrixType::Permuted_Upper)
+	    {
+	      (*current_liboctave_error_handler)
+		("Permuted triangular matrix not implemented");
+	    }
+	  else
+	    {
+	      const double *tmp_data = fortran_vec ();
+
+	      if (calc_cond)
+		{
+		  char norm = '1';
+		  char uplo = 'U';
+		  char dia = 'N';
+
+		  Array<double> z (3 * nc);
+		  double *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nc);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+					     F77_CONST_CHAR_ARG2 (&dia, 1), 
+					     nr, tmp_data, nr, rcond,
+					     pz, piz, info
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (f77_exception_encountered)
+		    (*current_liboctave_error_handler) 
+		      ("unrecoverable error in dtrcon");
+
+		  if (info != 0) 
+		    info = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		    {
+		      info = -2;
+
+		      if (sing_handler)
+			sing_handler (rcond);
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
+		    }
+		}
+
+	      if (info == 0)
+		{
+		  retval = b;
+		  double *result = retval.fortran_vec ();
+
+		  char uplo = 'U';
+		  char trans = 'N';
+		  char dia = 'N';
+
+		  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
+					     F77_CONST_CHAR_ARG2 (&trans, 1), 
+					     F77_CONST_CHAR_ARG2 (&dia, 1), 
+					     nr, b_nc, tmp_data, nr,
+					     result, nr, info
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (f77_exception_encountered)
+		    (*current_liboctave_error_handler) 
+		      ("unrecoverable error in dtrtrs");
+		}
+	    }
+	}
+      else
+	(*current_liboctave_error_handler) ("incorrect matrix type");
+    }
+
+  return retval;
+}
+
+Matrix
+Matrix::ltsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond) const
+{
+  Matrix retval;
+
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr == 0 || nc == 0 || nr != b.rows ())
+    (*current_liboctave_error_handler)
+      ("matrix dimension mismatch solution of linear equations");
+  else
+    {
+      volatile int typ = mattype.type ();
+
+      if (typ == MatrixType::Permuted_Lower ||
+	  typ == MatrixType::Lower)
+	{
+	  octave_idx_type b_nc = b.cols ();
+	  rcond = 1.;
+	  info = 0;
+
+	  if (typ == MatrixType::Permuted_Lower)
+	    {
+	      (*current_liboctave_error_handler)
+		("Permuted triangular matrix not implemented");
+	    }
+	  else
+	    {
+	      const double *tmp_data = fortran_vec ();
+
+	      if (calc_cond)
+		{
+		  char norm = '1';
+		  char uplo = 'L';
+		  char dia = 'N';
+
+		  Array<double> z (3 * nc);
+		  double *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nc);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+					     F77_CONST_CHAR_ARG2 (&dia, 1), 
+					     nr, tmp_data, nr, rcond,
+					     pz, piz, info
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (f77_exception_encountered)
+		    (*current_liboctave_error_handler) 
+		      ("unrecoverable error in dtrcon");
+
+		  if (info != 0) 
+		    info = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		    {
+		      info = -2;
+
+		      if (sing_handler)
+			sing_handler (rcond);
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
+		    }
+		}
+
+	      if (info == 0)
+		{
+		  retval = b;
+		  double *result = retval.fortran_vec ();
+
+		  char uplo = 'L';
+		  char trans = 'N';
+		  char dia = 'N';
+
+		  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
+					     F77_CONST_CHAR_ARG2 (&trans, 1), 
+					     F77_CONST_CHAR_ARG2 (&dia, 1), 
+					     nr, b_nc, tmp_data, nr,
+					     result, nr, info
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (f77_exception_encountered)
+		    (*current_liboctave_error_handler) 
+		      ("unrecoverable error in dtrtrs");
+		}
+	    }
+	}
+      else
+	(*current_liboctave_error_handler) ("incorrect matrix type");
+    }
+
+  return retval;
+}
+
+Matrix
+Matrix::fsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond) const
+{
+  Matrix retval;
+
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+    (*current_liboctave_error_handler)
+      ("matrix dimension mismatch solution of linear equations");
+  else
+    {
+      volatile int typ = mattype.type ();
+ 
+     // Calculate the norm of the matrix, for later use.
+      double anorm = -1.;
+
+      if (typ == MatrixType::Hermitian)
+	{
+	  info = 0;
+	  char job = 'L';
+	  Matrix atmp = *this;
+	  double *tmp_data = atmp.fortran_vec ();
+	  anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+
+	  F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+				     tmp_data, nr, info
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (f77_exception_encountered)
+	    (*current_liboctave_error_handler) 
+	      ("unrecoverable error in dpotrf");
+	  else
+	    {
+	      // Throw-away extra info LAPACK gives so as to not change output.
+	      rcond = 0.0;
+	      if (info != 0) 
+		{
+		  info = -2;
+
+		  mattype.mark_as_unsymmetric ();
+		  typ = MatrixType::Full;
+		}
+	      else 
+		{
+		  if (calc_cond)
+		    {
+		      Array<double> z (3 * nc);
+		      double *pz = z.fortran_vec ();
+		      Array<octave_idx_type> iz (nc);
+		      octave_idx_type *piz = iz.fortran_vec ();
+
+		      F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+						 nr, tmp_data, nr, anorm,
+						 rcond, pz, piz, info
+						 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+			(*current_liboctave_error_handler) 
+			  ("unrecoverable error in dpocon");
+	      
+		      if (info != 0) 
+			info = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+			{
+			  info = -2;
+
+			  if (sing_handler)
+			    sing_handler (rcond);
+			  else
+			    (*current_liboctave_error_handler)
+			      ("matrix singular to machine precision, rcond = %g",
+			       rcond);
+			}
+		    }
+
+		  if (info == 0)
+		    {
+		      retval = b;
+		      double *result = retval.fortran_vec ();
+
+		      octave_idx_type b_nc = b.cols ();
+
+		      F77_XFCN (dpotrs, DPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+						 nr, b_nc, tmp_data, nr,
+						 result, b.rows(), info
+						 F77_CHAR_ARG_LEN (1)));
+		
+		      if (f77_exception_encountered)
+			(*current_liboctave_error_handler)
+			  ("unrecoverable error in dpotrs");
+		    }
+		  else
+		    {
+		      mattype.mark_as_unsymmetric ();
+		      typ = MatrixType::Full;
+		    }		    
+		}
+	    }
+	}
+
+      if (typ == MatrixType::Full)
+	{
+	  info = 0;
+
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+	  Matrix atmp = *this;
+	  double *tmp_data = atmp.fortran_vec ();
+	  if(anorm < 0.)
+	    anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+
+	  Array<double> z (4 * nc);
+	  double *pz = z.fortran_vec ();
+	  Array<octave_idx_type> iz (nc);
+	  octave_idx_type *piz = iz.fortran_vec ();
+
+	  F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+	  if (f77_exception_encountered)
+	    (*current_liboctave_error_handler) 
+	      ("unrecoverable error in dgetrf");
+	  else
+	    {
+	      // Throw-away extra info LAPACK gives so as to not change output.
+	      rcond = 0.0;
+	      if (info != 0) 
+		{
+		  info = -2;
+
+		  if (sing_handler)
+		    sing_handler (rcond);
+		  else
+		    (*current_liboctave_error_handler)
+		      ("matrix singular to machine precision");
+
+		  mattype.mark_as_rectangular ();
+		}
+	      else 
+		{
+		  if (calc_cond)
+		    {
+		      // Now calculate the condition number for 
+		      // non-singular matrix.
+		      char job = '1';
+		      F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+						 nc, tmp_data, nr, anorm, 
+						 rcond, pz, piz, info
+						 F77_CHAR_ARG_LEN (1)));
+	      
+		      if (f77_exception_encountered)
+			(*current_liboctave_error_handler) 
+			  ("unrecoverable error in dgecon");
+	      
+		      if (info != 0) 
+			info = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+			{
+			  info = -2;
+
+			  if (sing_handler)
+			    sing_handler (rcond);
+			  else
+			    (*current_liboctave_error_handler)
+			      ("matrix singular to machine precision, rcond = %g",
+			       rcond);
+			}
+		    }
+
+		  if (info == 0)
+		    {
+		      retval = b;
+		      double *result = retval.fortran_vec ();
+
+		      octave_idx_type b_nc = b.cols ();
+
+		      char job = 'N';
+		      F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+						 nr, b_nc, tmp_data, nr,
+						 pipvt, result, b.rows(), info
+						 F77_CHAR_ARG_LEN (1)));
+		
+		      if (f77_exception_encountered)
+			(*current_liboctave_error_handler)
+			  ("unrecoverable error in dgetrs");
+		    }
+		  else
+		    mattype.mark_as_rectangular ();
+		}
+	    }
+	}
+      else if (typ != MatrixType::Hermitian)
+	(*current_liboctave_error_handler) ("incorrect matrix type");
+    }
+
+  return retval;
+}
+
+Matrix
+Matrix::solve (MatrixType &typ, const Matrix& b) const
+{
+  octave_idx_type info;
+  double rcond;
+  return solve (typ, b, info, rcond, 0);
+}
+
+Matrix
+Matrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
+	       double& rcond) const
+{
+  return solve (typ, b, info, rcond, 0);
+}
+
+Matrix
+Matrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
+	       double& rcond, solve_singularity_handler sing_handler,
+	       bool singular_fallback) const
+{
+  Matrix retval;
+  int typ = mattype.type ();
+
+  if (typ == MatrixType::Unknown)
+    typ = mattype.type (*this);
+
+  // Only calculate the condition number for LU/Cholesky
+  if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
+    retval = utsolve (mattype, b, info, rcond, sing_handler, false);
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+    retval = ltsolve (mattype, b, info, rcond, sing_handler, false);
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
+    retval = fsolve (mattype, b, info, rcond, sing_handler, true);
+  else if (typ != MatrixType::Rectangular)
+    {
+      (*current_liboctave_error_handler) ("unknown matrix type");
+      return Matrix ();
+    }
+
+  // Rectangular or one of the above solvers flags a singular matrix
+  if (singular_fallback && mattype.type () == MatrixType::Rectangular)
+    {
+      octave_idx_type rank;
+      retval = lssolve (b, info, rank);
+    }
+
+  return retval;
+}
+
+ComplexMatrix
+Matrix::solve (MatrixType &typ, const ComplexMatrix& b) const
+{
+  ComplexMatrix tmp (*this);
+  return tmp.solve (typ, b);
+}
+
+ComplexMatrix
+Matrix::solve (MatrixType &typ, const ComplexMatrix& b, 
+  octave_idx_type& info) const
+{
+  ComplexMatrix tmp (*this);
+  return tmp.solve (typ, b, info);
+}
+
+ComplexMatrix
+Matrix::solve (MatrixType &typ, const ComplexMatrix& b, octave_idx_type& info,
+	       double& rcond) const
+{
+  ComplexMatrix tmp (*this);
+  return tmp.solve (typ, b, info, rcond);
+}
+
+ComplexMatrix
+Matrix::solve (MatrixType &typ, const ComplexMatrix& b, octave_idx_type& info,
+	       double& rcond, solve_singularity_handler sing_handler,
+	       bool singular_fallback) const
+{
+  ComplexMatrix tmp (*this);
+  return tmp.solve (typ, b, info, rcond, sing_handler, singular_fallback);
+}
+
+ColumnVector
+Matrix::solve (MatrixType &typ, const ColumnVector& b) const
+{
+  octave_idx_type info; double rcond;
+  return solve (typ, b, info, rcond);
+}
+
+ColumnVector
+Matrix::solve (MatrixType &typ, const ColumnVector& b, 
+	       octave_idx_type& info) const
+{
+  double rcond;
+  return solve (typ, b, info, rcond);
+}
+
+ColumnVector
+Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
+	       double& rcond) const
+{
+  return solve (typ, b, info, rcond, 0);
+}
+
+ColumnVector
+Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
+	       double& rcond, solve_singularity_handler sing_handler) const
+{
+  Matrix tmp (b);
+  return solve (typ, tmp, info, rcond, sing_handler).column(static_cast<octave_idx_type> (0));
+}
+
+ComplexColumnVector
+Matrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
+{
+  ComplexMatrix tmp (*this);
+  return tmp.solve (typ, b);
+}
+
+ComplexColumnVector
+Matrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
+	       octave_idx_type& info) const
+{
+  ComplexMatrix tmp (*this);
+  return tmp.solve (typ, b, info);
+}
+
+ComplexColumnVector
+Matrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
+	       octave_idx_type& info, double& rcond) const
+{
+  ComplexMatrix tmp (*this);
+  return tmp.solve (typ, b, info, rcond);
+}
+
+ComplexColumnVector
+Matrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
+	       octave_idx_type& info, double& rcond,
+	       solve_singularity_handler sing_handler) const
+{
+  ComplexMatrix tmp (*this);
+  return tmp.solve(typ, b, info, rcond, sing_handler);
+}
+
+Matrix
 Matrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 Matrix
@@ -1170,115 +1768,21 @@ Matrix::solve (const Matrix& b, octave_i
 
 Matrix
 Matrix::solve (const Matrix& b, octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 Matrix
-Matrix::solve (const Matrix& b, octave_idx_type& info, double& rcond,
-	       solve_singularity_handler sing_handler) const
+Matrix::solve (const Matrix& b, octave_idx_type& info,
+	       double& rcond, solve_singularity_handler sing_handler) const
 {
-  Matrix retval;
-
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
-    (*current_liboctave_error_handler)
-      ("matrix dimension mismatch solution of linear equations");
-  else
-    {
-      info = 0;
-
-      Array<octave_idx_type> ipvt (nr);
-      octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-      Matrix atmp = *this;
-      double *tmp_data = atmp.fortran_vec ();
-
-      Array<double> z (4 * nc);
-      double *pz = z.fortran_vec ();
-      Array<octave_idx_type> iz (nc);
-      octave_idx_type *piz = iz.fortran_vec ();
-
-      // Calculate the norm of the matrix, for later use.
-      double anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
-
-      F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in dgetrf");
-      else
-	{
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
-	  if (info != 0) 
-	    {
-	      info = -2;
-
-	      if (sing_handler)
-		sing_handler (rcond);
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    } 
-	  else 
-	    {
-	      // Now calculate the condition number for non-singular matrix.
-	      char job = '1';
-	      F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					 nc, tmp_data, nr, anorm, 
-					 rcond, pz, piz, info
-					 F77_CHAR_ARG_LEN (1)));
-	      
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler) 
-		  ("unrecoverable error in dgecon");
-	      
-	      if (info != 0) 
-		info = -2;
-
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  info = -2;
-
-		  if (sing_handler)
-		    sing_handler (rcond);
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision, rcond = %g",
-		       rcond);
-		}
-	      else
-		{
-		  retval = b;
-		  double *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  job = 'N';
-		  F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, b_nc, tmp_data, nr,
-					     pipvt, result, b.rows(), info
-					     F77_CHAR_ARG_LEN (1)));
-		
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler)
-		      ("unrecoverable error in dgetrs");
-		}
-	    }
-	}
-    }
-
-  return retval;
+  MatrixType mattype (*this);
+  return solve (mattype, b, info, rcond, sing_handler);
 }
 
 ComplexMatrix
 Matrix::solve (const ComplexMatrix& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
@@ -1324,110 +1828,18 @@ Matrix::solve (const ColumnVector& b, oc
 {
   return solve (b, info, rcond, 0);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
 	       solve_singularity_handler sing_handler) const
 {
-  ColumnVector retval;
-
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.length ())
-    (*current_liboctave_error_handler)
-      ("matrix dimension mismatch solution of linear equations");
-  else
-    {
-      info = 0;
-
-      Array<octave_idx_type> ipvt (nr);
-      octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-      Matrix atmp = *this;
-      double *tmp_data = atmp.fortran_vec ();
-
-      Array<double> z (4 * nc);
-      double *pz = z.fortran_vec ();
-      Array<octave_idx_type> iz (nc);
-      octave_idx_type *piz = iz.fortran_vec ();
-
-      // Calculate the norm of the matrix, for later use.
-      double anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
-
-      F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in dgetrf");
-      else
-	{
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
-	  if (info > 0) 
-	    {
-	      info = -2;
-
-	      if (sing_handler)
-		sing_handler (rcond);
-	      else
-		(*current_liboctave_error_handler)
-		  ("matrix singular to machine precision");
-
-	    } 
-	  else 
-	    {
-	      // Now calculate the condition number for non-singular matrix.
-	      char job = '1';
-	      F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					 nc, tmp_data, nr, anorm, 
-					 rcond, pz, piz, info
-					 F77_CHAR_ARG_LEN (1)));
-	      
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler) 
-		  ("unrecoverable error in dgecon");
-
-	      if (info != 0) 
-		info = -2;
-
-	      volatile double rcond_plus_one = rcond + 1.0;
-
-	      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		{
-		  info = -2;
-
-		  if (sing_handler)
-		    sing_handler (rcond);
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision, rcond = %g",
-		       rcond);
-		}
-	      else
-		{
-		  retval = b;
-		  double *result = retval.fortran_vec ();
-
-		  job = 'N';
-		  F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nr, 1, tmp_data, nr, pipvt,
-					     result, b.length(), info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler)
-		      ("unrecoverable error in dgetrs");
-		}
-	    }
-	}
-    }
-  
-  return retval;
+  MatrixType mattype (*this);
+  return solve (mattype, b, info, rcond, sing_handler);
 }
 
 ComplexColumnVector
 Matrix::solve (const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -21,16 +21,17 @@ 02110-1301, USA.
 
 */
 
 #if !defined (octave_Matrix_int_h)
 #define octave_Matrix_int_h 1
 
 #include "MArray2.h"
 #include "MDiagArray2.h"
+#include "MatrixType.h"
 
 #include "mx-defs.h"
 #include "mx-op-defs.h"
 
 class
 Matrix : public MArray2<double>
 {
 public:
@@ -117,16 +118,72 @@ public:
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
 
   DET determinant (void) const;
   DET determinant (octave_idx_type& info) const;
   DET determinant (octave_idx_type& info, double& rcond, int calc_cond = 1) const;
 
+private:
+  // Upper triangular matrix solvers
+  Matrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+		  double& rcond, solve_singularity_handler sing_handler,
+		  bool calc_cond = false) const;
+
+  // Lower triangular matrix solvers
+  Matrix ltsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+		  double& rcond, solve_singularity_handler sing_handler,
+		  bool calc_cond = false) const;
+
+  // Full matrix solvers (lu/cholesky)
+  Matrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+		 double& rcond, solve_singularity_handler sing_handler,
+		 bool calc_cond = false) const;
+
+public:
+  // Generic interface to solver with no probing of type
+  Matrix solve (MatrixType &typ, const Matrix& b) const;
+  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const;
+  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
+		double& rcond) const;
+  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
+		double& rcond, solve_singularity_handler sing_handler,
+		bool singular_fallback = true) const;
+
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+		       octave_idx_type& info) const;
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+		       octave_idx_type& info, double& rcond) const;
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+		       octave_idx_type& info, double& rcond,
+		       solve_singularity_handler sing_handler,
+		       bool singular_fallback = true) const;
+
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+		      octave_idx_type& info) const;
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+		      octave_idx_type& info, double& rcond) const;
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+		      octave_idx_type& info, double& rcond,
+		      solve_singularity_handler sing_handler) const;
+
+  ComplexColumnVector solve (MatrixType &typ, 
+			     const ComplexColumnVector& b) const;
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+			     octave_idx_type& info) const;
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+			     octave_idx_type& info, double& rcond) const;
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+			     octave_idx_type& info, double& rcond,
+			     solve_singularity_handler sing_handler) const;
+
+  // Generic interface to solver with probing of type
   Matrix solve (const Matrix& b) const;
   Matrix solve (const Matrix& b, octave_idx_type& info) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
@@ -143,16 +200,17 @@ public:
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
+  // Singular solvers
   Matrix lssolve (const Matrix& b) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type& rank) const;
 
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
 			 octave_idx_type& rank) const;
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -35,17 +35,17 @@ Boston, MA 02110-1301, USA.
 #include "f77-fcn.h"
 #include "dRowVector.h"
 
 #include "CSparse.h"
 #include "boolSparse.h"
 #include "dSparse.h"
 #include "oct-spparms.h"
 #include "SparsedbleLU.h"
-#include "SparseType.h"
+#include "MatrixType.h"
 #include "oct-sparse.h"
 #include "sparse-util.h"
 #include "SparsedbleCHOL.h"
 #include "SparseQR.h"
 
 #include "oct-sort.h"
 
 // Define whether to use a basic QR solver or one that uses a Dulmange
@@ -679,37 +679,37 @@ atan2 (const SparseMatrix& x, const Spar
   return r;
 }
 
 SparseMatrix
 SparseMatrix::inverse (void) const
 {
   octave_idx_type info;
   double rcond;
-  SparseType mattype (*this);
+  MatrixType mattype (*this);
   return inverse (mattype, info, rcond, 0, 0);
 }
 
 SparseMatrix
-SparseMatrix::inverse (SparseType& mattype) const
+SparseMatrix::inverse (MatrixType& mattype) const
 {
   octave_idx_type info;
   double rcond;
   return inverse (mattype, info, rcond, 0, 0);
 }
 
 SparseMatrix
-SparseMatrix::inverse (SparseType& mattype, octave_idx_type& info) const
+SparseMatrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   double rcond;
   return inverse (mattype, info, rcond, 0, 0);
 }
 
 SparseMatrix 
-SparseMatrix::dinverse (SparseType &mattyp, octave_idx_type& info, 
+SparseMatrix::dinverse (MatrixType &mattyp, octave_idx_type& info, 
 			double& rcond, const bool, 
 			const bool calccond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
@@ -717,20 +717,20 @@ SparseMatrix::dinverse (SparseType &matt
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
-      if (typ == SparseType::Diagonal ||
-	  typ == SparseType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal ||
+	  typ == MatrixType::Permuted_Diagonal)
 	{
-	  if (typ == SparseType::Permuted_Diagonal)
+	  if (typ == MatrixType::Permuted_Diagonal)
 	    retval = transpose();
 	  else
 	    retval = *this;
 	      
 	  // Force make_unique to be called
 	  double *v = retval.data();
 
 	  if (calccond)
@@ -753,17 +753,17 @@ SparseMatrix::dinverse (SparseType &matt
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix 
-SparseMatrix::tinverse (SparseType &mattyp, octave_idx_type& info, 
+SparseMatrix::tinverse (MatrixType &mattyp, octave_idx_type& info, 
 			double& rcond, const bool, 
 			const bool calccond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
@@ -771,18 +771,18 @@ SparseMatrix::tinverse (SparseType &matt
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
-      if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper || 
-	  typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+      if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper || 
+	  typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 
 	  if (calccond)
 	    {
 	      // Calculate the 1-norm of matrix for rcond calculation
 	      for (octave_idx_type j = 0; j < nr; j++)
@@ -790,17 +790,17 @@ SparseMatrix::tinverse (SparseType &matt
 		  double atmp = 0.;
 		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		    atmp += fabs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
-	  if (typ == SparseType::Upper || typ == SparseType::Lower)
+	  if (typ == MatrixType::Upper || typ == MatrixType::Lower)
 	    {
 	      octave_idx_type nz = nnz ();
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseMatrix (nr, nc, nz2);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
@@ -886,17 +886,17 @@ SparseMatrix::tinverse (SparseType &matt
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseMatrix (nr, nc, nz2);
 
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
 	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
 
 	      octave_idx_type *perm = mattyp.triangular_perm();
-	      if (typ == SparseType::Permuted_Upper)
+	      if (typ == MatrixType::Permuted_Upper)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    rperm[perm[i]] = i;
 		}
 	      else
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    rperm[i] = perm[i];
@@ -991,62 +991,62 @@ SparseMatrix::tinverse (SparseType &matt
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::inverse (SparseType &mattype, octave_idx_type& info, 
+SparseMatrix::inverse (MatrixType &mattype, octave_idx_type& info, 
 		       double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
   SparseMatrix ret;
 
-  if (typ == SparseType::Unknown)
+  if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
-  if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
+  if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     ret = dinverse (mattype, info, rcond, true, calc_cond);
-  else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
+  else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     ret = tinverse (mattype, info, rcond, true, calc_cond).transpose();
-  else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     ret = transpose().tinverse (mattype, info, rcond, true, calc_cond);
-  else if (typ != SparseType::Rectangular)
+  else if (typ != MatrixType::Rectangular)
     {
       if (mattype.is_hermitian())
 	{
-	  SparseType tmp_typ (SparseType::Upper);
+	  MatrixType tmp_typ (MatrixType::Upper);
 	  SparseCHOL fact (*this, info, false);
 	  rcond = fact.rcond();
 	  if (info == 0)
 	    {
 	      double rcond2;
 	      SparseMatrix Q = fact.Q();
 	      SparseMatrix InvL = fact.L().transpose().tinverse(tmp_typ,
 					   info, rcond2, true, false);
 	      ret = Q * InvL.transpose() * InvL * Q.transpose();
 	    }
 	  else
 	    {
 	      // Matrix is either singular or not positive definite
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Full;
+	      typ = MatrixType::Full;
 	    }
 	}
 
       if (!mattype.is_hermitian())
 	{
 	  octave_idx_type n = rows();
 	  ColumnVector Qinit(n);
 	  for (octave_idx_type i = 0; i < n; i++)
 	    Qinit(i) = i;
 
-	  SparseType tmp_typ (SparseType::Upper);
+	  MatrixType tmp_typ (MatrixType::Upper);
 	  SparseLU fact (*this, Qinit, -1.0, false);
 	  rcond = fact.rcond();
 	  double rcond2;
 	  SparseMatrix InvL = fact.L().transpose().tinverse(tmp_typ, 
 					   info, rcond2, true, false);
 	  SparseMatrix InvU = fact.U().tinverse(tmp_typ, info, rcond2,
 					   true, false).transpose();
 	  ret = fact.Pc().transpose() * InvU * InvL * fact.Pr();
@@ -1189,17 +1189,17 @@ SparseMatrix::determinant (octave_idx_ty
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return retval;
 }
 
 Matrix
-SparseMatrix::dsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err,
+SparseMatrix::dsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& err,
 		      double& rcond, solve_singularity_handler, 
 		      bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1209,21 +1209,21 @@ SparseMatrix::dsolve (SparseType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Diagonal ||
-	  typ == SparseType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal ||
+	  typ == MatrixType::Permuted_Diagonal)
 	{
 	  retval.resize (nc, b.cols(), 0.);
-	  if (typ == SparseType::Diagonal)
+	  if (typ == MatrixType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      for (octave_idx_type i = 0; i < nm; i++)
 		retval(i,j) = b(i,j) / data (i);
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      for (octave_idx_type k = 0; k < nc; k++)
 		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 		  retval(k,j) = b(ridx(i),j) / data (i);
@@ -1247,17 +1247,17 @@ SparseMatrix::dsolve (SparseType &mattyp
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::dsolve (SparseType &mattype, const SparseMatrix& b, 
+SparseMatrix::dsolve (MatrixType &mattype, const SparseMatrix& b, 
 		      octave_idx_type& err, double& rcond, 
 		      solve_singularity_handler, bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1267,26 +1267,26 @@ SparseMatrix::dsolve (SparseType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Diagonal ||
-	  typ == SparseType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal ||
+	  typ == MatrixType::Permuted_Diagonal)
 	{
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseMatrix (nc, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
-	  if (typ == SparseType::Diagonal)
+	  if (typ == MatrixType::Diagonal)
 	    for (octave_idx_type j = 0; j < b_nc; j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
 		    if (b.ridx(i) >= nm)
 		      break;
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
@@ -1335,17 +1335,17 @@ SparseMatrix::dsolve (SparseType &mattyp
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::dsolve (SparseType &mattype, const ComplexMatrix& b,
+SparseMatrix::dsolve (MatrixType &mattype, const ComplexMatrix& b,
 		      octave_idx_type& err, double& rcond,
 		      solve_singularity_handler, bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1355,21 +1355,21 @@ SparseMatrix::dsolve (SparseType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Diagonal ||
-	  typ == SparseType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal ||
+	  typ == MatrixType::Permuted_Diagonal)
 	{
 	  retval.resize (nc, b.cols(), 0);
-	  if (typ == SparseType::Diagonal)
+	  if (typ == MatrixType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 		for (octave_idx_type i = 0; i < nm; i++)
 		  retval(i,j) = b(i,j) / data (i);
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      for (octave_idx_type k = 0; k < nc; k++)
 		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 		  retval(k,j) = b(ridx(i),j) / data (i);
@@ -1393,17 +1393,17 @@ SparseMatrix::dsolve (SparseType &mattyp
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::dsolve (SparseType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::dsolve (MatrixType &mattype, const SparseComplexMatrix& b,
 		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler, bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1413,26 +1413,26 @@ SparseMatrix::dsolve (SparseType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Diagonal ||
-	  typ == SparseType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal ||
+	  typ == MatrixType::Permuted_Diagonal)
 	{
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
-	  if (typ == SparseType::Diagonal)
+	  if (typ == MatrixType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
 		    if (b.ridx(i) >= nm)
 		      break;
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
@@ -1481,17 +1481,17 @@ SparseMatrix::dsolve (SparseType &mattyp
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::utsolve (SparseType &mattype, const Matrix& b,
+SparseMatrix::utsolve (MatrixType &mattype, const Matrix& b,
 		       octave_idx_type& err, double& rcond,
 		       solve_singularity_handler sing_handler, 
 		       bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1502,18 +1502,18 @@ SparseMatrix::utsolve (SparseType &matty
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Permuted_Upper ||
-	  typ == SparseType::Upper)
+      if (typ == MatrixType::Permuted_Upper ||
+	  typ == MatrixType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
@@ -1523,17 +1523,17 @@ SparseMatrix::utsolve (SparseType &matty
 		  double atmp = 0.;
 		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		    atmp += fabs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
-	  if (typ == SparseType::Permuted_Upper)
+	  if (typ == MatrixType::Permuted_Upper)
 	    {
 	      retval.resize (nc, b_nc);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
@@ -1714,17 +1714,17 @@ SparseMatrix::utsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::utsolve (SparseType &mattype, const SparseMatrix& b,
+SparseMatrix::utsolve (MatrixType &mattype, const SparseMatrix& b,
 		       octave_idx_type& err, double& rcond, 
 		       solve_singularity_handler sing_handler,
 		       bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1735,18 +1735,18 @@ SparseMatrix::utsolve (SparseType &matty
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Permuted_Upper ||
-	  typ == SparseType::Upper)
+      if (typ == MatrixType::Permuted_Upper ||
+	  typ == MatrixType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
 	      // Calculate the 1-norm of matrix for rcond calculation
@@ -1762,17 +1762,17 @@ SparseMatrix::utsolve (SparseType &matty
 
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
-	  if (typ == SparseType::Permuted_Upper)
+	  if (typ == MatrixType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 
 	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
 	      for (octave_idx_type i = 0; i < nc; i++)
 		rperm[perm[i]] = i;
 
@@ -1999,17 +1999,17 @@ SparseMatrix::utsolve (SparseType &matty
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::utsolve (SparseType &mattype, const ComplexMatrix& b, 
+SparseMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b, 
 		       octave_idx_type& err, double& rcond, 
 		       solve_singularity_handler sing_handler,
 		       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2020,18 +2020,18 @@ SparseMatrix::utsolve (SparseType &matty
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Permuted_Upper ||
-	  typ == SparseType::Upper)
+      if (typ == MatrixType::Permuted_Upper ||
+	  typ == MatrixType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
@@ -2041,17 +2041,17 @@ SparseMatrix::utsolve (SparseType &matty
 		  double atmp = 0.;
 		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		    atmp += fabs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
-	  if (typ == SparseType::Permuted_Upper)
+	  if (typ == MatrixType::Permuted_Upper)
 	    {
 	      retval.resize (nc, b_nc);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
@@ -2235,17 +2235,17 @@ SparseMatrix::utsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::utsolve (SparseType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::utsolve (MatrixType &mattype, const SparseComplexMatrix& b,
 		       octave_idx_type& err, double& rcond, 
 		       solve_singularity_handler sing_handler,
 		       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2256,18 +2256,18 @@ SparseMatrix::utsolve (SparseType &matty
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Permuted_Upper ||
-	  typ == SparseType::Upper)
+      if (typ == MatrixType::Permuted_Upper ||
+	  typ == MatrixType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
 	      // Calculate the 1-norm of matrix for rcond calculation
@@ -2283,17 +2283,17 @@ SparseMatrix::utsolve (SparseType &matty
 
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
-	  if (typ == SparseType::Permuted_Upper)
+	  if (typ == MatrixType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
 	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
 	      for (octave_idx_type i = 0; i < nc; i++)
 		rperm[perm[i]] = i;
 
@@ -2523,17 +2523,17 @@ SparseMatrix::utsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::ltsolve (SparseType &mattype, const Matrix& b,
+SparseMatrix::ltsolve (MatrixType &mattype, const Matrix& b,
 		       octave_idx_type& err, double& rcond,
 		       solve_singularity_handler sing_handler,
 		       bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2544,18 +2544,18 @@ SparseMatrix::ltsolve (SparseType &matty
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Permuted_Lower ||
-	  typ == SparseType::Lower)
+      if (typ == MatrixType::Permuted_Lower ||
+	  typ == MatrixType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
@@ -2565,17 +2565,17 @@ SparseMatrix::ltsolve (SparseType &matty
 		  double atmp = 0.;
 		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		    atmp += fabs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
-	  if (typ == SparseType::Permuted_Lower)
+	  if (typ == MatrixType::Permuted_Lower)
 	    {
 	      retval.resize (nc, b_nc);
 	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  if (nc > nr)
@@ -2781,17 +2781,17 @@ SparseMatrix::ltsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::ltsolve (SparseType &mattype, const SparseMatrix& b, 
+SparseMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b, 
 		       octave_idx_type& err, double& rcond, 
 		       solve_singularity_handler sing_handler,
 		       bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2802,18 +2802,18 @@ SparseMatrix::ltsolve (SparseType &matty
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Permuted_Lower ||
-	  typ == SparseType::Lower)
+      if (typ == MatrixType::Permuted_Lower ||
+	  typ == MatrixType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
 	      // Calculate the 1-norm of matrix for rcond calculation
@@ -2829,17 +2829,17 @@ SparseMatrix::ltsolve (SparseType &matty
 
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
-	  if (typ == SparseType::Permuted_Lower)
+	  if (typ == MatrixType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
@@ -3086,17 +3086,17 @@ SparseMatrix::ltsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::ltsolve (SparseType &mattype, const ComplexMatrix& b, 
+SparseMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b, 
 		       octave_idx_type& err, double& rcond, 
 		       solve_singularity_handler sing_handler,
 		       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3107,18 +3107,18 @@ SparseMatrix::ltsolve (SparseType &matty
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Permuted_Lower ||
-	  typ == SparseType::Lower)
+      if (typ == MatrixType::Permuted_Lower ||
+	  typ == MatrixType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
@@ -3128,17 +3128,17 @@ SparseMatrix::ltsolve (SparseType &matty
 		  double atmp = 0.;
 		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		    atmp += fabs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
-	  if (typ == SparseType::Permuted_Lower)
+	  if (typ == MatrixType::Permuted_Lower)
 	    {
 	      retval.resize (nc, b_nc);
 	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nm; i++)
@@ -3345,17 +3345,17 @@ SparseMatrix::ltsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::ltsolve (SparseType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::ltsolve (MatrixType &mattype, const SparseComplexMatrix& b,
 		       octave_idx_type& err, double& rcond, 
 		       solve_singularity_handler sing_handler,
 		       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3366,18 +3366,18 @@ SparseMatrix::ltsolve (SparseType &matty
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Permuted_Lower ||
-	  typ == SparseType::Lower)
+      if (typ == MatrixType::Permuted_Lower ||
+	  typ == MatrixType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 1.;
 
 	  if (calc_cond)
 	    {
 	      // Calculate the 1-norm of matrix for rcond calculation
@@ -3393,17 +3393,17 @@ SparseMatrix::ltsolve (SparseType &matty
 
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
-	  if (typ == SparseType::Permuted_Lower)
+	  if (typ == MatrixType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nm; i++)
 		    cwork[i] = 0.;
@@ -3652,17 +3652,17 @@ SparseMatrix::ltsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::trisolve (SparseType &mattype, const Matrix& b,
+SparseMatrix::trisolve (MatrixType &mattype, const Matrix& b,
 			octave_idx_type& err, double& rcond,
 			solve_singularity_handler sing_handler,
 			bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3675,17 +3675,17 @@ SparseMatrix::trisolve (SparseType &matt
     (*current_liboctave_error_handler) 
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Tridiagonal_Hermitian)
+      if (typ == MatrixType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
 	      octave_idx_type ii = 0;
 
@@ -3725,23 +3725,23 @@ SparseMatrix::trisolve (SparseType &matt
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dptsv");
 	  else if (err != 0)
 	    {
 	      err = 0;
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Tridiagonal;
+	      typ = MatrixType::Tridiagonal;
 	    }
 	  else 
 	    rcond = 1.;
 	}
 
-      if (typ == SparseType::Tridiagonal)
+      if (typ == MatrixType::Tridiagonal)
 	{
 	  OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
 	      octave_idx_type ii = 0;
@@ -3799,25 +3799,25 @@ SparseMatrix::trisolve (SparseType &matt
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 
 	    } 
 	  else 
 	    rcond = 1.;
 	}
-      else if (typ != SparseType::Tridiagonal_Hermitian)
+      else if (typ != MatrixType::Tridiagonal_Hermitian)
 	       (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::trisolve (SparseType &mattype, const SparseMatrix& b, 
+SparseMatrix::trisolve (MatrixType &mattype, const SparseMatrix& b, 
 			octave_idx_type& err, double& rcond, 
 			solve_singularity_handler sing_handler,
 			bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3831,18 +3831,18 @@ SparseMatrix::trisolve (SparseType &matt
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       // Note can't treat symmetric case as there is no dpttrf function
-      if (typ == SparseType::Tridiagonal ||
-	  typ == SparseType::Tridiagonal_Hermitian)
+      if (typ == MatrixType::Tridiagonal ||
+	  typ == MatrixType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
 	  OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -3957,25 +3957,25 @@ SparseMatrix::trisolve (SparseType &matt
 			  }
 		      retval.xcidx(j+1) = ii;
 		    }
 
 		  retval.maybe_compress ();
 		}
 	    }
 	}
-      else if (typ != SparseType::Tridiagonal_Hermitian)
+      else if (typ != MatrixType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::trisolve (SparseType &mattype, const ComplexMatrix& b, 
+SparseMatrix::trisolve (MatrixType &mattype, const ComplexMatrix& b, 
 			octave_idx_type& err, double& rcond, 
 			solve_singularity_handler sing_handler,
 			bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -3988,17 +3988,17 @@ SparseMatrix::trisolve (SparseType &matt
     (*current_liboctave_error_handler) 
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
-      if (typ == SparseType::Tridiagonal_Hermitian)
+      if (typ == MatrixType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
 	      octave_idx_type ii = 0;
 
@@ -4044,21 +4044,21 @@ SparseMatrix::trisolve (SparseType &matt
 	      (*current_liboctave_error_handler) 
 		("unrecoverable error in zptsv");
 	      err = -1;
 	    }
 	  else if (err != 0)
 	    {
 	      err = 0;
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Tridiagonal;
+	      typ = MatrixType::Tridiagonal;
 	    }
 	}
 
-      if (typ == SparseType::Tridiagonal)
+      if (typ == MatrixType::Tridiagonal)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
 	      octave_idx_type ii = 0;
@@ -4119,25 +4119,25 @@ SparseMatrix::trisolve (SparseType &matt
 		  sing_handler (rcond);
 		  mattype.mark_as_rectangular ();
 		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 	    }
 	}
-      else if (typ != SparseType::Tridiagonal_Hermitian)
+      else if (typ != MatrixType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::trisolve (SparseType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::trisolve (MatrixType &mattype, const SparseComplexMatrix& b,
 			octave_idx_type& err, double& rcond, 
 			solve_singularity_handler sing_handler,
 			bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4151,18 +4151,18 @@ SparseMatrix::trisolve (SparseType &matt
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       // Note can't treat symmetric case as there is no dpttrf function
-      if (typ == SparseType::Tridiagonal ||
-	  typ == SparseType::Tridiagonal_Hermitian)
+      if (typ == MatrixType::Tridiagonal ||
+	  typ == MatrixType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
 	  OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -4316,25 +4316,25 @@ SparseMatrix::trisolve (SparseType &matt
 
 		      retval.xcidx(j+1) = ii;
 		    }
 
 		  retval.maybe_compress ();
 		}
 	    }
 	}
-      else if (typ != SparseType::Tridiagonal_Hermitian)
+      else if (typ != MatrixType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::bsolve (SparseType &mattype, const Matrix& b,
+SparseMatrix::bsolve (MatrixType &mattype, const Matrix& b,
 		      octave_idx_type& err, double& rcond,
 		      solve_singularity_handler sing_handler,
 		      bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4344,17 +4344,17 @@ SparseMatrix::bsolve (SparseType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Banded_Hermitian)
+      if (typ == MatrixType::Banded_Hermitian)
 	{
 	  octave_idx_type n_lower = mattype.nlower ();
 	  octave_idx_type ldm = n_lower + 1;
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
@@ -4388,17 +4388,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 	      ("unrecoverable error in dpbtrf");
 	  else
 	    {
 	      if (err != 0) 
 		{
 		  // Matrix is not positive definite!! Fall through to
 		  // unsymmetric banded solver.
 		  mattype.mark_as_unsymmetric ();
-		  typ = SparseType::Banded;
+		  typ = MatrixType::Banded;
 		  rcond = 0.0;
 		  err = 0;
 		} 
 	      else 
 		{
 		  if (calc_cond)
 		    {
 		      Array<double> z (3 * nr);
@@ -4462,17 +4462,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 			    ("SparseMatrix::solve solve failed");
 			  err = -1;
 			}
 		    }
 		}
 	    }
 	}
 
-      if (typ == SparseType::Banded)
+      if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  int n_upper = mattype.nupper ();
 	  int n_lower = mattype.nlower ();
 	  int ldm = n_upper + 2 * n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
@@ -4591,25 +4591,25 @@ SparseMatrix::bsolve (SparseType &mattyp
 		    
 		      if (f77_exception_encountered)
 			(*current_liboctave_error_handler)
 			  ("unrecoverable error in dgbtrs");
 		    }
 		}
 	    }
 	}
-      else if (typ != SparseType::Banded_Hermitian)
+      else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::bsolve (SparseType &mattype, const SparseMatrix& b,
+SparseMatrix::bsolve (MatrixType &mattype, const SparseMatrix& b,
 		      octave_idx_type& err, double& rcond, 
 		      solve_singularity_handler sing_handler,
 		      bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4619,17 +4619,17 @@ SparseMatrix::bsolve (SparseType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Banded_Hermitian)
+      if (typ == MatrixType::Banded_Hermitian)
 	{
 	  int n_lower = mattype.nlower ();
 	  int ldm = n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
@@ -4662,17 +4662,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dpbtrf");
 	  else
 	    {
 	      if (err != 0) 
 		{
 		  mattype.mark_as_unsymmetric ();
-		  typ = SparseType::Banded;
+		  typ = MatrixType::Banded;
 		  rcond = 0.0;
 		  err = 0;
 		} 
 	      else 
 		{
 		  if (calc_cond)
 		    {
 		      Array<double> z (3 * nr);
@@ -4775,17 +4775,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 			}
 
 		      retval.maybe_compress ();
 		    }
 		}
 	    }
 	}
 
-      if (typ == SparseType::Banded)
+      if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  octave_idx_type n_upper = mattype.nupper ();
 	  octave_idx_type n_lower = mattype.nlower ();
 	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
@@ -4942,25 +4942,25 @@ SparseMatrix::bsolve (SparseType &mattyp
 			  retval.xcidx(j+1) = ii;
 			}
 
 		      retval.maybe_compress ();
 		    }
 		}
 	    }
 	}
-      else if (typ != SparseType::Banded_Hermitian)
+      else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::bsolve (SparseType &mattype, const ComplexMatrix& b, 
+SparseMatrix::bsolve (MatrixType &mattype, const ComplexMatrix& b, 
 		      octave_idx_type& err, double& rcond, 
 		      solve_singularity_handler sing_handler,
 		      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -4970,17 +4970,17 @@ SparseMatrix::bsolve (SparseType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Banded_Hermitian)
+      if (typ == MatrixType::Banded_Hermitian)
 	{
 	  octave_idx_type n_lower = mattype.nlower ();
 	  octave_idx_type ldm = n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
@@ -5015,17 +5015,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 	      ("unrecoverable error in dpbtrf");
 	  else
 	    {
 	      if (err != 0) 
 		{
 		  // Matrix is not positive definite!! Fall through to
 		  // unsymmetric banded solver.
 		  mattype.mark_as_unsymmetric ();
-		  typ = SparseType::Banded;
+		  typ = MatrixType::Banded;
 		  rcond = 0.0;
 		  err = 0;
 		} 
 	      else 
 		{
 		  if (calc_cond)
 		    {
 		      Array<double> z (3 * nr);
@@ -5132,17 +5132,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 			  for (octave_idx_type i = 0; i < b_nr; i++)
 			    retval (i, j) = Complex (Bx[i], Bz[i]);
 			}
 		    }
 		}
 	    }
 	}
 
-      if (typ == SparseType::Banded)
+      if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  int n_upper = mattype.nupper ();
 	  int n_lower = mattype.nlower ();
 	  int ldm = n_upper + 2 * n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
@@ -5289,25 +5289,25 @@ SparseMatrix::bsolve (SparseType &mattyp
 
 			  for (octave_idx_type i = 0; i < nr; i++)
 			    retval (i, j) = Complex (Bx[i], Bz[i]);
 			}
 		    }
 		}
 	    }
 	}
-      else if (typ != SparseType::Banded_Hermitian)
+      else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::bsolve (SparseType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::bsolve (MatrixType &mattype, const SparseComplexMatrix& b,
 		      octave_idx_type& err, double& rcond, 
 		      solve_singularity_handler sing_handler,
 		      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -5317,17 +5317,17 @@ SparseMatrix::bsolve (SparseType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Banded_Hermitian)
+      if (typ == MatrixType::Banded_Hermitian)
 	{
 	  int n_lower = mattype.nlower ();
 	  int ldm = n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
@@ -5362,17 +5362,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 	      ("unrecoverable error in dpbtrf");
 	  else
 	    {
 	      if (err != 0) 
 		{
 		  // Matrix is not positive definite!! Fall through to
 		  // unsymmetric banded solver.
 		  mattype.mark_as_unsymmetric ();
-		  typ = SparseType::Banded;
+		  typ = MatrixType::Banded;
 
 		  rcond = 0.0;
 		  err = 0;
 		} 
 	      else 
 		{
 		  if (calc_cond)
 		    {
@@ -5510,17 +5510,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 			}
 
 		      retval.maybe_compress ();
 		    }
 		}
 	    }
 	}
 
-      if (typ == SparseType::Banded)
+      if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  int n_upper = mattype.nupper ();
 	  int n_lower = mattype.nlower ();
 	  int ldm = n_upper + 2 * n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
@@ -5699,17 +5699,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 			  retval.xcidx(j+1) = ii;
 			}
 
 		      retval.maybe_compress ();
 		    }
 		}
 	    }
 	}
-      else if (typ != SparseType::Banded_Hermitian)
+      else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 void *
 SparseMatrix::factorize (octave_idx_type& err, double &rcond, Matrix &Control,
@@ -5819,17 +5819,17 @@ SparseMatrix::factorize (octave_idx_type
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return Numeric;
 }
 
 Matrix
-SparseMatrix::fsolve (SparseType &mattype, const Matrix& b,
+SparseMatrix::fsolve (MatrixType &mattype, const Matrix& b,
 		      octave_idx_type& err, double& rcond, 
 		      solve_singularity_handler sing_handler,
 		      bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -5839,17 +5839,17 @@ SparseMatrix::fsolve (SparseType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Hermitian)
+      if (typ == MatrixType::Hermitian)
 	{
 #ifdef HAVE_CHOLMOD
 	  cholmod_common Common;
 	  cholmod_common *cm = &Common;
 
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
@@ -5940,17 +5940,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	    rcond = 1.0;
 
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Full;
+	      typ = MatrixType::Full;
 	    }
 	  else
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
@@ -5988,21 +5988,21 @@ SparseMatrix::fsolve (SparseType &mattyp
 	      CHOLMOD_NAME(print_common) (" ", cm);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 #else
 	  (*current_liboctave_warning_handler)
 	    ("CHOLMOD not installed");
 
 	  mattype.mark_as_unsymmetric ();
-	  typ = SparseType::Full;
+	  typ = MatrixType::Full;
 #endif
 	}
 
-      if (typ == SparseType::Full)
+      if (typ == MatrixType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = 
 	    factorize (err, rcond, Control, Info, sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
@@ -6042,25 +6042,25 @@ SparseMatrix::fsolve (SparseType &mattyp
 	    }
 	  else
 	    mattype.mark_as_rectangular ();
 
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
-      else if (typ != SparseType::Hermitian)
+      else if (typ != MatrixType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::fsolve (SparseType &mattype, const SparseMatrix& b,
+SparseMatrix::fsolve (MatrixType &mattype, const SparseMatrix& b,
 		      octave_idx_type& err, double& rcond,
 		      solve_singularity_handler sing_handler,
 		      bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6070,17 +6070,17 @@ SparseMatrix::fsolve (SparseType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Hermitian)
+      if (typ == MatrixType::Hermitian)
 	{
 #ifdef HAVE_CHOLMOD
 	  cholmod_common Common;
 	  cholmod_common *cm = &Common;
 
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
@@ -6182,17 +6182,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  else
 	    rcond = 1.;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Full;
+	      typ = MatrixType::Full;
 	    }
 	  else
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
@@ -6235,21 +6235,21 @@ SparseMatrix::fsolve (SparseType &mattyp
 	      CHOLMOD_NAME(print_common) (" ", cm);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 #else
 	  (*current_liboctave_warning_handler)
 	    ("CHOLMOD not installed");
 
 	  mattype.mark_as_unsymmetric ();
-	  typ = SparseType::Full;
+	  typ = MatrixType::Full;
 #endif
 	}
 
-      if (typ == SparseType::Full)
+      if (typ == MatrixType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
 				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
@@ -6321,25 +6321,25 @@ SparseMatrix::fsolve (SparseType &mattyp
 	    }
 	  else
 	    mattype.mark_as_rectangular ();
 
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
-      else if (typ != SparseType::Hermitian)
+      else if (typ != MatrixType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::fsolve (SparseType &mattype, const ComplexMatrix& b, 
+SparseMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b, 
 		      octave_idx_type& err, double& rcond,
 		      solve_singularity_handler sing_handler,
 		      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6349,17 +6349,17 @@ SparseMatrix::fsolve (SparseType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Hermitian)
+      if (typ == MatrixType::Hermitian)
 	{
 #ifdef HAVE_CHOLMOD
 	  cholmod_common Common;
 	  cholmod_common *cm = &Common;
 
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
@@ -6451,17 +6451,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  else
 	    rcond = 1.0;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Full;
+	      typ = MatrixType::Full;
 	    }
 	  else
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
@@ -6499,21 +6499,21 @@ SparseMatrix::fsolve (SparseType &mattyp
 	      CHOLMOD_NAME(print_common) (" ", cm);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 #else
 	  (*current_liboctave_warning_handler)
 	    ("CHOLMOD not installed");
 
 	  mattype.mark_as_unsymmetric ();
-	  typ = SparseType::Full;
+	  typ = MatrixType::Full;
 #endif
 	}
 
-      if (typ == SparseType::Full)
+      if (typ == MatrixType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
 				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
@@ -6572,25 +6572,25 @@ SparseMatrix::fsolve (SparseType &mattyp
 	    }
 	  else
 	    mattype.mark_as_rectangular ();
 
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
-      else if (typ != SparseType::Hermitian)
+      else if (typ != MatrixType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::fsolve (SparseType &mattype, const SparseComplexMatrix& b, 
+SparseMatrix::fsolve (MatrixType &mattype, const SparseComplexMatrix& b, 
 		      octave_idx_type& err, double& rcond,
 		      solve_singularity_handler sing_handler,
 		      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6600,17 +6600,17 @@ SparseMatrix::fsolve (SparseType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == SparseType::Hermitian)
+      if (typ == MatrixType::Hermitian)
 	{
 #ifdef HAVE_CHOLMOD
 	  cholmod_common Common;
 	  cholmod_common *cm = &Common;
 
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
@@ -6712,17 +6712,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  else
 	    rcond = 1.0;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
-	      typ = SparseType::Full;
+	      typ = MatrixType::Full;
 	    }
 	  else
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
@@ -6766,21 +6766,21 @@ SparseMatrix::fsolve (SparseType &mattyp
 	      CHOLMOD_NAME(print_common) (" ", cm);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 #else
 	  (*current_liboctave_warning_handler)
 	    ("CHOLMOD not installed");
 
 	  mattype.mark_as_unsymmetric ();
-	  typ = SparseType::Full;
+	  typ = MatrixType::Full;
 #endif
 	}
 
-      if (typ == SparseType::Full)
+      if (typ == MatrixType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
 				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
@@ -6861,347 +6861,347 @@ SparseMatrix::fsolve (SparseType &mattyp
 	      UMFPACK_DNAME (free_numeric) (&Numeric);
 	    }
 	  else
 	    mattype.mark_as_rectangular ();
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
-      else if (typ != SparseType::Hermitian)
+      else if (typ != MatrixType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 Matrix
-SparseMatrix::solve (SparseType &mattype, const Matrix& b) const
+SparseMatrix::solve (MatrixType &mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (SparseType &mattype, const Matrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const Matrix& b, 
 		     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (SparseType &mattype, const Matrix& b, octave_idx_type& info, 
+SparseMatrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& info, 
 		     double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
+SparseMatrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& err, 
 		     double& rcond, solve_singularity_handler sing_handler,
 		     bool singular_fallback) const
 {
   Matrix retval;
   int typ = mattype.type (false);
 
-  if (typ == SparseType::Unknown)
+  if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for CHOLMOD/UMFPACK
-  if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
+  if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
+  else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
+  else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Tridiagonal || 
-	   typ == SparseType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal || 
+	   typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Full || typ == SparseType::Hermitian)
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
-  else if (typ != SparseType::Rectangular)
+  else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return Matrix ();
     }
 
   // Rectangular or one of the above solvers flags a singular matrix
-  if (singular_fallback && mattype.type (false) == SparseType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<Matrix, SparseMatrix, Matrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::solve (SparseType &mattype, const SparseMatrix& b) const
+SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
-SparseMatrix::solve (SparseType &mattype, const SparseMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b, 
 		     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
-SparseMatrix::solve (SparseType &mattype, const SparseMatrix& b,
+SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
 		     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
-SparseMatrix::solve (SparseType &mattype, const SparseMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b, 
 		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler,
 		     bool singular_fallback) const
 {
   SparseMatrix retval;
   int typ = mattype.type (false);
 
-  if (typ == SparseType::Unknown)
+  if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
-  if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
+  if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
+  else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
+  else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Tridiagonal || 
-	   typ == SparseType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal || 
+	   typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Full || typ == SparseType::Hermitian)
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
-  else if (typ != SparseType::Rectangular)
+  else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseMatrix ();
     }
 
-  if (singular_fallback && mattype.type (false) == SparseType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseMatrix, SparseMatrix, 
 	SparseMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::solve (SparseType &mattype, const ComplexMatrix& b) const
+SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
 			    octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
 		     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
 		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler,
 		     bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type (false);
 
-  if (typ == SparseType::Unknown)
+  if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
-  if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
+  if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
+  else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
+  else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Tridiagonal || 
-	   typ == SparseType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal || 
+	   typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Full || typ == SparseType::Hermitian)
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
-  else if (typ != SparseType::Rectangular)
+  else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == SparseType::Rectangular)
+  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseMatrix, 
 	ComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b) const
+SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b, 
 		     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b,
+SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
 		     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b, 
 		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler,
 		     bool singular_fallback) const
 {
   SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
-  if (typ == SparseType::Unknown)
+  if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
-  if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
+  if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
+  else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+  else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
+  else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Tridiagonal || 
-	   typ == SparseType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal || 
+	   typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == SparseType::Full || typ == SparseType::Hermitian)
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
-  else if (typ != SparseType::Rectangular)
+  else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == SparseType::Rectangular)
+  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseMatrix, 
 	SparseComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ColumnVector
-SparseMatrix::solve (SparseType &mattype, const ColumnVector& b) const
+SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b) const
 {
   octave_idx_type info; double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ColumnVector
-SparseMatrix::solve (SparseType &mattype, const ColumnVector& b, octave_idx_type& info) const
+SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ColumnVector
-SparseMatrix::solve (SparseType &mattype, const ColumnVector& b, octave_idx_type& info, double& rcond) const
+SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b, octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ColumnVector
-SparseMatrix::solve (SparseType &mattype, const ColumnVector& b, octave_idx_type& info, double& rcond,
+SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b, octave_idx_type& info, double& rcond,
 	       solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
   return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
-SparseMatrix::solve (SparseType &mattype, const ComplexColumnVector& b) const
+SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (SparseType &mattype, const ComplexColumnVector& b, octave_idx_type& info) const
+SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (SparseType &mattype, const ComplexColumnVector& b, octave_idx_type& info, 
+SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info, 
 		     double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (SparseType &mattype, const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
+SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
 	       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 Matrix
 SparseMatrix::solve (const Matrix& b) const
@@ -7225,17 +7225,17 @@ SparseMatrix::solve (const Matrix& b, oc
   return solve (b, info, rcond, 0);
 }
 
 Matrix
 SparseMatrix::solve (const Matrix& b, octave_idx_type& err, 
 		     double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
-  SparseType mattype (*this);
+  MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
@@ -7257,17 +7257,17 @@ SparseMatrix::solve (const SparseMatrix&
   return solve (b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b, 
 		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
-  SparseType mattype (*this);
+  MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexMatrix
 SparseMatrix::solve (const ComplexMatrix& b, 
 			    octave_idx_type& info) const
 {
   double rcond;
@@ -7281,17 +7281,17 @@ SparseMatrix::solve (const ComplexMatrix
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (const ComplexMatrix& b, 
 		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
-  SparseType mattype (*this);
+  MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
@@ -7313,17 +7313,17 @@ SparseMatrix::solve (const SparseComplex
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b, 
 		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
-  SparseType mattype (*this);
+  MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ColumnVector
 SparseMatrix::solve (const ColumnVector& b) const
 {
   octave_idx_type info; double rcond;
   return solve (b, info, rcond);
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -28,17 +28,17 @@ Boston, MA 02110-1301, USA.
 #include "CMatrix.h"
 #include "dColVector.h"
 #include "CColVector.h"
 
 #include "dbleDET.h"
 #include "MSparse.h"
 #include "MSparse-defs.h"
 #include "Sparse-op-defs.h"
-#include "SparseType.h"
+#include "MatrixType.h"
 
 class SparseComplexMatrix;
 class SparseBoolMatrix;
 
 class
 SparseMatrix : public MSparse<double>
 {
  public:
@@ -110,217 +110,217 @@ SparseMatrix : public MSparse<double>
 
   SparseMatrix transpose (void) const 
     { 
       return MSparse<double>::transpose (); 
     }
   SparseMatrix hermitian (void) const { return transpose (); }
 
 private:
-  SparseMatrix dinverse (SparseType &mattyp, octave_idx_type& info, 
+  SparseMatrix dinverse (MatrixType &mattyp, octave_idx_type& info, 
 			 double& rcond, const bool force = false, 
 			 const bool calccond = true) const;
 
-  SparseMatrix tinverse (SparseType &mattyp, octave_idx_type& info, 
+  SparseMatrix tinverse (MatrixType &mattyp, octave_idx_type& info, 
 			 double& rcond, const bool force = false, 
 			 const bool calccond = true) const;
 
 public:
   SparseMatrix inverse (void) const;
-  SparseMatrix inverse (SparseType& mattype) const;
-  SparseMatrix inverse (SparseType& mattype, octave_idx_type& info) const;
-  SparseMatrix inverse (SparseType& mattype, octave_idx_type& info, 
+  SparseMatrix inverse (MatrixType& mattype) const;
+  SparseMatrix inverse (MatrixType& mattype, octave_idx_type& info) const;
+  SparseMatrix inverse (MatrixType& mattype, octave_idx_type& info, 
 		        double& rcond, int force = 0, int calc_cond = 1) const;
 
   DET determinant (void) const;
   DET determinant (octave_idx_type& info) const;
   DET determinant (octave_idx_type& info, double& rcond, int calc_cond = 1) const;
 
 private:
   // Diagonal matrix solvers
-  Matrix dsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix dsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  ComplexMatrix dsolve (SparseType &typ, const ComplexMatrix& b,
+  ComplexMatrix dsolve (MatrixType &typ, const ComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler, 
 		bool calc_cond = false) const;
 
-  SparseMatrix dsolve (SparseType &typ, const SparseMatrix& b,
+  SparseMatrix dsolve (MatrixType &typ, const SparseMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix dsolve (SparseType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix dsolve (MatrixType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
   // Upper triangular matrix solvers
-  Matrix utsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  ComplexMatrix utsolve (SparseType &typ, const ComplexMatrix& b,
+  ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseMatrix utsolve (SparseType &typ, const SparseMatrix& b,
+  SparseMatrix utsolve (MatrixType &typ, const SparseMatrix& b,
 		octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix utsolve (SparseType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix utsolve (MatrixType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
-  Matrix ltsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix ltsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  ComplexMatrix ltsolve (SparseType &typ, const ComplexMatrix& b,
+  ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseMatrix ltsolve (SparseType &typ, const SparseMatrix& b,
+  SparseMatrix ltsolve (MatrixType &typ, const SparseMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix ltsolve (SparseType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix ltsolve (MatrixType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
   // Tridiagonal matrix solvers
-  Matrix trisolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix trisolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  ComplexMatrix trisolve (SparseType &typ, const ComplexMatrix& b,
+  ComplexMatrix trisolve (MatrixType &typ, const ComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseMatrix trisolve (SparseType &typ, const SparseMatrix& b,
+  SparseMatrix trisolve (MatrixType &typ, const SparseMatrix& b,
 		octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix trisolve (SparseType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix trisolve (MatrixType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
   // Banded matrix solvers (umfpack/cholesky)
-  Matrix bsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix bsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  ComplexMatrix bsolve (SparseType &typ, const ComplexMatrix& b,
+  ComplexMatrix bsolve (MatrixType &typ, const ComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseMatrix bsolve (SparseType &typ, const SparseMatrix& b,
+  SparseMatrix bsolve (MatrixType &typ, const SparseMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix bsolve (SparseType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix bsolve (MatrixType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
   void * factorize (octave_idx_type& err, double &rcond, Matrix &Control,
 		    Matrix &Info, solve_singularity_handler sing_handler,
 		    bool calc_cond = false) const;
 
-  Matrix fsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  ComplexMatrix fsolve (SparseType &typ, const ComplexMatrix& b,
+  ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseMatrix fsolve (SparseType &typ, const SparseMatrix& b,
+  SparseMatrix fsolve (MatrixType &typ, const SparseMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
-  SparseComplexMatrix fsolve (SparseType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix fsolve (MatrixType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler,
 		bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
-  Matrix solve (SparseType &typ, const Matrix& b) const;
-  Matrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info) const;
-  Matrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
+  Matrix solve (MatrixType &typ, const Matrix& b) const;
+  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const;
+  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
 		double& rcond) const;
-  Matrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler,
 		bool singular_fallback = true) const;
 
-  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b) const;
-  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
 		       octave_idx_type& info) const;
-  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
 		       octave_idx_type& info, double& rcond) const;
-  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b,
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
 		       octave_idx_type& info, double& rcond, 
 		       solve_singularity_handler sing_handler,
 		       bool singular_fallback = true) const;
 
-  SparseMatrix solve (SparseType &typ, const SparseMatrix& b) const;
-  SparseMatrix solve (SparseType &typ, const SparseMatrix& b, 
+  SparseMatrix solve (MatrixType &typ, const SparseMatrix& b) const;
+  SparseMatrix solve (MatrixType &typ, const SparseMatrix& b, 
 		      octave_idx_type& info) const;
-  SparseMatrix solve (SparseType &typ, const SparseMatrix& b,
+  SparseMatrix solve (MatrixType &typ, const SparseMatrix& b,
 		      octave_idx_type& info, double& rcond) const;
-  SparseMatrix solve (SparseType &typ, const SparseMatrix& b,
+  SparseMatrix solve (MatrixType &typ, const SparseMatrix& b,
 		      octave_idx_type& info, double& rcond, 
 		      solve_singularity_handler sing_handler,
 		      bool singular_fallback = true) const;
 
-  SparseComplexMatrix solve (SparseType &typ, 
+  SparseComplexMatrix solve (MatrixType &typ, 
 			     const SparseComplexMatrix& b) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b, 
 			     octave_idx_type& info) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b, 
 			     octave_idx_type& info, double& rcond) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b,
+  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
 			     octave_idx_type& info, double& rcond, 
 			     solve_singularity_handler sing_handler,
 			     bool singular_fallabck = true) const;
 
-  ColumnVector solve (SparseType &typ, const ColumnVector& b) const;
-  ColumnVector solve (SparseType &typ, const ColumnVector& b, 
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
 		      octave_idx_type& info) const;
-  ColumnVector solve (SparseType &typ, const ColumnVector& b, 
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
 		      octave_idx_type& info, double& rcond) const;
-  ColumnVector solve (SparseType &typ, const ColumnVector& b,
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b,
 		      octave_idx_type& info, double& rcond, 
 		      solve_singularity_handler sing_handler) const;
 
-  ComplexColumnVector solve (SparseType &typ, 
+  ComplexColumnVector solve (MatrixType &typ, 
 			     const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (SparseType &typ, const ComplexColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
 			     octave_idx_type& info) const;
-  ComplexColumnVector solve (SparseType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
 			     octave_idx_type& info, double& rcond) const;
-  ComplexColumnVector solve (SparseType &typ, const ComplexColumnVector& b,
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
 			     octave_idx_type& info, double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   Matrix solve (const Matrix& b) const;
   Matrix solve (const Matrix& b, octave_idx_type& info) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
diff --git a/liboctave/mx-base.h b/liboctave/mx-base.h
--- a/liboctave/mx-base.h
+++ b/liboctave/mx-base.h
@@ -19,16 +19,20 @@ along with Octave; see the file COPYING.
 Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 02110-1301, USA.
 
 */
 
 #if !defined (octave_mx_base_h)
 #define octave_mx_base_h 1
 
+// Matrix Type class
+
+#include "MatrixType.h"
+
 // Matrix classes.
 
 #include "boolMatrix.h"
 #include "chMatrix.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
 
 // Column Vector classes.
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -25,17 +25,17 @@ Boston, MA 02110-1301, USA.
 #endif
 
 #include "sparse-base-chol.h"
 #include "sparse-util.h"
 #include "lo-error.h"
 #include "oct-sparse.h"
 #include "oct-spparms.h"
 #include "quit.h"
-#include "SparseType.h"
+#include "MatrixType.h"
 
 #ifdef HAVE_CHOLMOD
 // Can't use CHOLMOD_NAME(drop)(0.0, S, cm). It doesn't treat complex matrices
 template <class chol_type, class chol_elt, class p_type>
 void 
 sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::drop_zeros 
   (const cholmod_sparse* S)
 {
@@ -278,17 +278,17 @@ sparse_base_chol<chol_type, chol_elt, p_
   chol_type retval;
 #ifdef HAVE_CHOLMOD
   cholmod_sparse *m = rep->L();
   octave_idx_type n = m->ncol;
   ColumnVector perms = rep->perm();
   chol_type ret;
   double rcond2;
   octave_idx_type info;
-  SparseType mattype (SparseType::Upper);
+  MatrixType mattype (MatrixType::Upper);
   chol_type linv = L().transpose().inverse(mattype, info, rcond2, 1, 0);
 
   if (perms.length() == n)
     {
       p_type Qc = Q();
       retval = Qc * linv.transpose() * linv * Qc.transpose();
     }
   else
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -26,17 +26,17 @@ Boston, MA 02110-1301, USA.
 
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "MArray2.h"
 #include "MSparse.h"
 #include "SparseQR.h"
 #include "SparseCmplxQR.h"
-#include "SparseType.h"
+#include "MatrixType.h"
 #include "oct-sort.h"
 
 template <class T>
 static MSparse<T>
 dmsolve_extract (const MSparse<T> &A, const octave_idx_type *Pinv, 
 		const octave_idx_type *Q, octave_idx_type rst, 
 		octave_idx_type rend, octave_idx_type cst, 
 		octave_idx_type cend, octave_idx_type maxnz = -1,
@@ -425,17 +425,17 @@ dmsolve (const ST &a, const T &b, octave
 	  !info && !error_state)
 	{
 	  ST m = dmsolve_extract (a, pinv, q, dm->rr [1], dm->rr [2], 
 				  dm->cc [2], dm->cc [3], nnz_remaining, false);
 	  nnz_remaining -= m.nnz();
 	  RT btmp2 = dmsolve_extract (btmp, NULL, NULL, dm->rr [1], dm->rr [2], 
 				      0, b_nc);
 	  double rcond = 0.0;
-	  SparseType mtyp (SparseType::Full);
+	  MatrixType mtyp (MatrixType::Full);
 	  RT mtmp = m.solve (mtyp, btmp2, info, rcond, 
 			     solve_singularity_warning, false);	
 	  if (info != 0)
 	    {
 	      info = 0;
 	      mtmp = qrsolve (m, btmp2, info);
 	    }
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,12 +1,62 @@
 2006-05-03  David Bateman  <dbateman@free.fr>
 
+	* ov-base-mat.h: Add caching of matrix type, and code to supply
+	and copy matrix type.
+	* ov-bool-mat.h: Add caching to constructor.
+	* ov-re-mat.h: ditto.
+	* ov-cx-mat.h: ditto.
+	* ov.cc: Add to the BoolMatrix, Matrix and the ComplexMatrix
+	octave_value constructors, the ability to specify the matrix type.
+	* ov.h: Adapt declaration of above constructors.
+	(MatrixType matrix_type(void) const, MatrixType matrix_type (const
+	MatrixType&)): New functions for probing and setting matrix type.
+	* ov-base.cc (virtual MatrixType matrix_type(void) const, virtual
+	MatrixType matrix_type (const MatrixType&)): New default functions
+	for probing and setting matrix type.
+	* ov-base.h  (virtual MatrixType matrix_type(void) const, virtual
+	MatrixType matrix_type (const MatrixType&)): Declarations.
+	* ov-base-sparse.h: Replace all uses of SparseType with
+	MatrixType. Replace sparse_type function with matrix_type function.
+	* ov-bool-sparse.h: Replace all uses of SparseType with MatrixType.
+	* ov-cx-sparse.h: ditto.
+	* ov-re-sparse.h: ditto.
+	* sparse-xdiv.cc: ditto.
+	* sparse-xdiv.h: ditto.
+	* sparse-xpow.cc: ditto.
+	* DLD-FUNCTIONS/luinc.cc: ditto.
+	* DLD-FUNCTIONS/splu.cc: ditto.
+	* xdiv.cc (xdiv, xleftdiv): Pass the matrix type, simplfy since
+	the matrix solve function now calls lssolve if singular.
+	* xdiv.h (xdvi, xleftdiv): Update the declarations
+	* OPERATORS/op-cm-cm.cc, OPERATORS/op-cm-cs.cc,
+	OPERATORS/op-cm-m.cc, OPERATORS/op-cm-s.cc,
+	OPERATORS/op-cm-scm.cc, OPERATORS/op-cm-sm.cc, 
+	OPERATORS/op-cs-cm.cc, OPERATORS/op-cs-m.cc,
+	OPERATORS/op-m-cm.cc, OPERATORS/op-m-cs.cc, 
+	OPERATORS/op-m-m.cc, OPERATORS/op-m-s.cc, 
+	OPERATORS/op-m-scm.cc, OPERATORS/op-m-sm.cc, 
+	OPERATORS/op-s-cm.cc, OPERATORS/op-s-m.cc, 
+	OPERATORS/op-scm-cm.cc, OPERATORS/op-scm-m.cc, 
+	OPERATORS/op-sm-cm.cc, OPERATORS/op-sm-m.cc: Update use of
+	xdiv and xleftdiv functions to allow matrix type caching.
+	* DLD-FUNCTIONS/matrix_type.cc (Fmatrix_type): Update to allow typing
+	 of Matrix, and ComplexMatrix types. Add new test code for this.
+
 	* DLD-FUNCTIONS/cellfun.cc (Fmat2cell): new function.
 
+	* DLD-FUNCTIONS/regexp.cc (class regexp_elem): New class to store
+	matched element in a std::list.
+	(octregexp_list): Take algorithm from octregexp and construct a 
+	list of matches.
+	(octregexp): Rewrite to use linked list of matches.
+	(Fregexprep): New function, working directly in linked list of
+	matches.
+	
 2006-05-02  John W. Eaton  <jwe@octave.org>
 
 	* lex.l ({CCHAR}): Exit rawcommand mode if returning '\n' token.
 
 2006-05-02  David Bateman  <dbateman@free.fr>
 
 	* DLD-FUNCTIONS/rand.cc (do_rand): Require real scalar for seed.
 
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -25,17 +25,17 @@ Boston, MA 02110-1301, USA.
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "oct-map.h"
 
-#include "SparseType.h"
+#include "MatrixType.h"
 #include "SparseCmplxLU.h"
 #include "SparsedbleLU.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 DEFUN_DLD (luinc, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, '0')\n\
@@ -166,48 +166,48 @@ are the same as for @dfn{lu}.\n\
 		    case 2:
 		      {
 			SparseLU fact (sm, Qinit, thresh, true, droptol,
 				       milu, udiag);
 
 			SparseMatrix P = fact.Pr ();
 			SparseMatrix L = P.transpose () * fact.L ();
 			retval(1) = octave_value (fact.U (),
-				  SparseType (SparseType::Upper));
-			retval(0) = octave_value (L, SparseType 
-						  (SparseType::Permuted_Lower, 
+				  MatrixType (MatrixType::Upper));
+			retval(0) = octave_value (L, MatrixType 
+						  (MatrixType::Permuted_Lower, 
 						   sm_nr, fact.row_perm ()));
 		      }
 		      break;
 
 		    case 3:
 		      {
 			SparseLU fact (sm, Qinit, thresh, true, droptol,
 				       milu, udiag);
 
 			retval(2) = fact.Pr ();
 			retval(1) = octave_value (fact.U (),
-				  SparseType (SparseType::Upper));
+				  MatrixType (MatrixType::Upper));
 			retval(0) = octave_value (fact.L (),
-				  SparseType (SparseType::Lower));
+				  MatrixType (MatrixType::Lower));
 		      }
 		      break;
 
 		    case 4:
 		    default:
 		      {
 			SparseLU fact (sm, Qinit, thresh, false, droptol,
 				       milu, udiag);
 
 			retval(3) = fact.Pc ();
 			retval(2) = fact.Pr ();
 			retval(1) = octave_value (fact.U (),
-				  SparseType (SparseType::Upper));
+				  MatrixType (MatrixType::Upper));
 			retval(0) = octave_value (fact.L (),
-				  SparseType (SparseType::Lower));
+				  MatrixType (MatrixType::Lower));
 		      }
 		      break;
 		    }
 		}
 	    }
 	  else if (args(0).type_name () == "sparse complex matrix") 
 	    {
 	      SparseComplexMatrix sm = 
@@ -228,48 +228,48 @@ are the same as for @dfn{lu}.\n\
 		    case 2:
 		      {
 			SparseComplexLU fact (sm, Qinit, thresh, true, 
 					      droptol, milu, udiag);
 
 			SparseMatrix P = fact.Pr ();
 			SparseComplexMatrix L = P.transpose () * fact.L ();
 			retval(1) = octave_value (fact.U (),
-				  SparseType (SparseType::Upper));
-			retval(0) = octave_value (L, SparseType 
-						  (SparseType::Permuted_Lower, 
+				  MatrixType (MatrixType::Upper));
+			retval(0) = octave_value (L, MatrixType 
+						  (MatrixType::Permuted_Lower, 
 						   sm_nr, fact.row_perm ()));
 		      }
 		      break;
 
 		    case 3:
 		      {
 			SparseComplexLU fact (sm, Qinit, thresh, true,
 					      droptol, milu, udiag);
 
 			retval(2) = fact.Pr ();
 			retval(1) = octave_value (fact.U (),
-				  SparseType (SparseType::Upper));
+				  MatrixType (MatrixType::Upper));
 			retval(0) = octave_value (fact.L (),
-				  SparseType (SparseType::Lower));
+				  MatrixType (MatrixType::Lower));
 		      }
 		      break;
 
 		    case 4:
 		    default:
 		      {
 			SparseComplexLU fact (sm, Qinit, thresh, false,
 					      droptol, milu, udiag);
 
 			retval(3) = fact.Pc ();
 			retval(2) = fact.Pr ();
 			retval(1) = octave_value (fact.U (),
-				  SparseType (SparseType::Upper));
+				  MatrixType (MatrixType::Upper));
 			retval(0) = octave_value (fact.L (),
-				  SparseType (SparseType::Lower));
+				  MatrixType (MatrixType::Lower));
 		      }
 		      break;
 		    }
 		}
 	    }
 	  else
 	    error ("luinc: first argument must be sparse");
 	}
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -25,19 +25,21 @@ 02110-1301, USA.
 #include <config.h>
 #endif
 
 #include <algorithm>
 
 #include "ov.h"
 #include "defun-dld.h"
 #include "error.h"
+#include "ov-re-mat.h"
+#include "ov-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
-#include "SparseType.h"
+#include "MatrixType.h"
 
 DEFUN_DLD (matrix_type, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{type} =} matrix_type (@var{a})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, @var{type})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'upper', @var{perm})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'lower', @var{perm})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'banded', @var{nl}, @var{nu})\n\
@@ -106,98 +108,92 @@ matrix type.\n\
   else if (nargin > 4)
     error ("matrix_type: incorrect number of arguments");
   else
     {
       if (args(0).is_sparse_type ())
 	{
 	  if (nargin == 1)
 	    {
-	      SparseType mattyp;
+	      MatrixType mattyp;
 
 	      if (args(0).type_name () == "sparse complex matrix" ) 
 		{
-		  const octave_sparse_complex_matrix& rep
-		    = dynamic_cast<const octave_sparse_complex_matrix&> (args(0).get_rep ());
-
-		  mattyp = rep.sparse_type ();
+		  mattyp = args(0).matrix_type ();
 
 		  if (mattyp.is_unknown ())
 		    {
 		      SparseComplexMatrix m = 
 			args(0).sparse_complex_matrix_value ();
 		      if (!error_state)
 			{
-			  mattyp = SparseType (m);
-			  rep.sparse_type (mattyp);
+			  mattyp = MatrixType (m);
+			  args(0).matrix_type (mattyp);
 			}
 		    }
 		}
 	      else
 		{
-		  const octave_sparse_matrix& rep
-		    = dynamic_cast<const octave_sparse_matrix&> (args(0).get_rep ());
-
-		  mattyp = rep.sparse_type ();
+		  mattyp = args(0).matrix_type ();
 
 		  if (mattyp.is_unknown ())
 		    {
 		      SparseMatrix m = args(0).sparse_matrix_value ();
 		      if (!error_state)
 			{
-			  mattyp = SparseType (m);
-			  rep.sparse_type (mattyp);
+			  mattyp = MatrixType (m);
+			  args(0).matrix_type (mattyp);
 			}
 		    }
 		}
 
 	      int typ = mattyp.type ();
 
-	      if (typ == SparseType::Diagonal)
+	      if (typ == MatrixType::Diagonal)
 		retval = octave_value ("Diagonal");
-	      else if (typ == SparseType::Permuted_Diagonal)
+	      else if (typ == MatrixType::Permuted_Diagonal)
 		retval = octave_value ("Permuted Diagonal");
-	      else if (typ == SparseType::Upper)
+	      else if (typ == MatrixType::Upper)
 		retval = octave_value ("Upper");
-	      else if (typ == SparseType::Permuted_Upper)
+	      else if (typ == MatrixType::Permuted_Upper)
 		retval = octave_value ("Permuted Upper");
-	      else if (typ == SparseType::Lower)
+	      else if (typ == MatrixType::Lower)
 		retval = octave_value ("Lower");
-	      else if (typ == SparseType::Permuted_Lower)
+	      else if (typ == MatrixType::Permuted_Lower)
 		retval = octave_value ("Permuted Lower");
-	      else if (typ == SparseType::Banded)
+	      else if (typ == MatrixType::Banded)
 		retval = octave_value ("Banded");
-	      else if (typ == SparseType::Banded_Hermitian)
+	      else if (typ == MatrixType::Banded_Hermitian)
 		retval = octave_value ("Banded Positive Definite");
-	      else if (typ == SparseType::Tridiagonal)
+	      else if (typ == MatrixType::Tridiagonal)
 		retval = octave_value ("Tridiagonal");
-	      else if (typ == SparseType::Tridiagonal_Hermitian)
+	      else if (typ == MatrixType::Tridiagonal_Hermitian)
 		retval = octave_value ("Tridiagonal Positive Definite");
-	      else if (typ == SparseType::Hermitian)
+	      else if (typ == MatrixType::Hermitian)
 		retval = octave_value ("Positive Definite");
-	      else if (typ == SparseType::Rectangular)
+	      else if (typ == MatrixType::Rectangular)
 		{
 		  if (args(0).rows() == args(0).columns())
 		    retval = octave_value ("Singular");
 		  else
 		    retval = octave_value ("Rectangular");
 		}
-	      else if (typ == SparseType::Full)
+	      else if (typ == MatrixType::Full)
 		retval = octave_value ("Full");
 	      else
 		// This should never happen!!!
 		retval = octave_value ("Unknown");
 	    }
 	  else
 	    {
 	      // Ok, we're changing the matrix type
 	      std::string str_typ = args(1).string_value ();
 
 	      // FIXME -- why do I have to explicitly call the constructor?
-	      SparseType mattyp = SparseType ();
+	      MatrixType mattyp = MatrixType ();
 
 	      octave_idx_type nl = 0;
 	      octave_idx_type nu = 0;
 	      
 	      if (error_state)
 		error ("Matrix type must be a string");
 	      else
 		{
@@ -295,27 +291,168 @@ matrix type.\n\
 			    retval = octave_value (args(0).sparse_matrix_value (), 
 						   mattyp);
 			}
 		    }
 		}
 	    }
 	}
       else
-	error ("matrix_type: Only sparse matrices treated at the moment");
+	{
+	  if (nargin == 1)
+	    {
+	      MatrixType mattyp;
+
+	      if (args(0).type_name () == "complex matrix" ) 
+		{
+		  mattyp = args(0).matrix_type ();
+
+		  if (mattyp.is_unknown ())
+		    {
+		      ComplexMatrix m = args(0).complex_matrix_value ();
+		      if (!error_state)
+			{
+			  mattyp = MatrixType (m);
+			  args(0).matrix_type (mattyp);
+			}
+		    }
+		}
+	      else
+		{
+		  mattyp = args(0).matrix_type ();
+
+		  if (mattyp.is_unknown ())
+		    {
+		      Matrix m = args(0).matrix_value ();
+		      if (!error_state)
+			{
+			  mattyp = MatrixType (m);
+			  args(0).matrix_type (mattyp);
+			}
+		    }
+		}
+
+	      int typ = mattyp.type ();
+
+	      if (typ == MatrixType::Upper)
+		retval = octave_value ("Upper");
+	      else if (typ == MatrixType::Permuted_Upper)
+		retval = octave_value ("Permuted Upper");
+	      else if (typ == MatrixType::Lower)
+		retval = octave_value ("Lower");
+	      else if (typ == MatrixType::Permuted_Lower)
+		retval = octave_value ("Permuted Lower");
+	      else if (typ == MatrixType::Hermitian)
+		retval = octave_value ("Positive Definite");
+	      else if (typ == MatrixType::Rectangular)
+		{
+		  if (args(0).rows() == args(0).columns())
+		    retval = octave_value ("Singular");
+		  else
+		    retval = octave_value ("Rectangular");
+		}
+	      else if (typ == MatrixType::Full)
+		retval = octave_value ("Full");
+	      else
+		// This should never happen!!!
+		retval = octave_value ("Unknown");
+	    }
+	  else
+	    {
+	      // Ok, we're changing the matrix type
+	      std::string str_typ = args(1).string_value ();
+
+	      // FIXME -- why do I have to explicitly call the constructor?
+	      MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
+
+	      if (error_state)
+		error ("Matrix type must be a string");
+	      else
+		{
+		  // Use STL function to convert to lower case
+		  std::transform (str_typ.begin (), str_typ.end (),
+				  str_typ.begin (), tolower);
+
+		  if (str_typ == "upper")
+		    mattyp.mark_as_upper_triangular ();
+		  else if (str_typ == "lower")
+		    mattyp.mark_as_lower_triangular ();
+		  else if (str_typ == "positive definite")
+		    {
+		      mattyp.mark_as_full ();
+		      mattyp.mark_as_symmetric ();
+		    }
+		  else if (str_typ == "singular")
+		    mattyp.mark_as_rectangular ();
+		  else if (str_typ == "full")
+		    mattyp.mark_as_full ();
+		  else if (str_typ == "unknown")
+		    mattyp.invalidate_type ();
+		  else
+		    error ("matrix_type: Unknown matrix type %s", str_typ.c_str());
+
+		  if (! error_state)
+		    {
+		      if (nargin == 3 && (str_typ == "upper" 
+					  || str_typ == "lower"))
+			{
+			  const ColumnVector perm = 
+			    ColumnVector (args (2).vector_value ());
+
+			  if (error_state)
+			    error ("matrix_type: Invalid permutation vector");
+			  else
+			    {
+			      octave_idx_type len = perm.length ();
+			      dim_vector dv = args(0).dims ();
+			      
+			      if (len != dv(0))
+				error ("matrix_type: Invalid permutation vector");
+			      else
+				{
+				  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+
+				  for (octave_idx_type i = 0; i < len; i++)
+				    p[i] = static_cast<octave_idx_type> (perm (i)) - 1; 
+
+				  if (str_typ == "upper")
+				    mattyp.mark_as_permuted (len, p);
+				  else
+				    mattyp.mark_as_permuted (len, p);
+				}
+			    }
+			}
+		      else if (nargin != 2)
+			error ("matrix_type: Invalid number of arguments");
+
+		      if (! error_state)
+			{
+			  // Set the matrix type
+			  if (args(0).type_name () == "complex matrix" ) 
+			    retval = 
+			      octave_value (args(0).complex_matrix_value (), 
+					    mattyp);
+			  else
+			    retval = octave_value (args(0).matrix_value (), 
+						   mattyp);
+			}
+		    }
+		}
+	    }
+	}
     }
 
   return retval;
 }
 
 /*
 
 ## FIXME
 ## Disable tests for lower under-determined and upper over-determined 
-## matrices and this detection is disabled in SparseType due to issues
+## matrices and this detection is disabled in MatrixType due to issues
 ## of non minimum norm solution being found.
  
 %!assert(matrix_type(speye(10,10)),"Diagonal");
 %!assert(matrix_type(speye(10,10)([2:10,1],:)),"Permuted Diagonal");
 %!assert(matrix_type([[speye(10,10);sparse(1,10)],[1;sparse(9,1);1]]),"Upper");
 %!assert(matrix_type([[speye(10,10);sparse(1,10)],[1;sparse(9,1);1]](:,[2,1,3:11])),"Permuted Upper");
 %!assert(matrix_type([speye(10,10),sparse(10,1);1,sparse(1,9),1]),"Lower");
 %!assert(matrix_type([speye(10,10),sparse(10,1);1,sparse(1,9),1]([2,1,3:11],:)),"Permuted Lower");
@@ -388,15 +525,35 @@ matrix type.\n\
 %!assert(matrix_type([speye(9,11);[1i,sparse(1,8),1i,0]]),"Lower");
 %!assert(matrix_type([speye(9,11);[1i,sparse(1,8),1i,0]]([2,1,3:10],:)),"Permuted Lower");
 %!assert(matrix_type(1i*spdiags(randn(10,4),[-2:1],10,9)),"Rectangular")
 
 %!test
 %! a = matrix_type(spdiags(randn(10,3),[-1,0,1],10,10),"Singular");
 %! assert(matrix_type(a),"Singular");
 
+%!assert(matrix_type(triu(ones(10,10))),"Upper");
+%!assert(matrix_type(triu(ones(10,10),-1)),"Full");
+%!assert(matrix_type(tril(ones(10,10))),"Lower");
+%!assert(matrix_type(tril(ones(10,10),1)),"Full");
+%!assert(matrix_type(10*eye(10,10) + ones(10,10)), "Positive Definite"); 
+%!assert(matrix_type(ones(11,10)),"Rectangular")
+%!test
+%! a = matrix_type(ones(10,10),"Singular");
+%! assert(matrix_type(a),"Singular");
+
+%!assert(matrix_type(triu(1i*ones(10,10))),"Upper");
+%!assert(matrix_type(triu(1i*ones(10,10),-1)),"Full");
+%!assert(matrix_type(tril(1i*ones(10,10))),"Lower");
+%!assert(matrix_type(tril(1i*ones(10,10),1)),"Full");
+%!assert(matrix_type(10*eye(10,10) + 1i*triu(ones(10,10),1) -1i*tril(ones(10,10),-1)), "Positive Definite"); 
+%!assert(matrix_type(ones(11,10)),"Rectangular")
+%!test
+%! a = matrix_type(ones(10,10),"Singular");
+%! assert(matrix_type(a),"Singular");
+
 */
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -15,177 +15,204 @@ for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; see the file COPYING.  If not, write to the
 Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 Boston, MA 02110-1301, USA.
 
 */
 
-// FIXME
-// regexprep should be written as an m-file based on regexp
-
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <algorithm>
 #include <sstream>
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 #include "Cell.h"
 #include "oct-map.h"
 #include "str-vec.h"
+#include "quit.h"
+#include "parse.h"
 
 #ifdef HAVE_PCRE
 #include <pcre.h>
 #else
 #ifdef HAVE_REGEX
 #ifdef __MINGW32__
 #define __restrict
 #endif
 #include <regex.h>
 #endif
 #endif
 
-static octave_value_list
-octregexp (const octave_value_list &args, int nargout, const std::string &nm,
-	   bool case_insensitive)
+// The regexp is constructed as a linked list to avoid resizing the
+// return values in arrays at each new match.
+
+// FIXME don't bother collecting and composing return values the user
+// doesn't want.
+
+class regexp_elem
 {
-  octave_value_list retval;
+public:
+  regexp_elem (const string_vector _named_token, const Cell _t, 
+	       const std::string _m, const Matrix _te, const double _s, 
+	       const double _e) :
+    named_token (_named_token), t (_t), m (_m), te (_te), s (_s), e (_e) { }
+
+  regexp_elem (const regexp_elem &a) : named_token (a.named_token), t (a.t), 
+				       m (a.m), te (a.te), s (a.s), e (a.e)
+				       { }
+
+  string_vector named_token;
+  Cell t;
+  std::string m;
+  Matrix te;
+  double s;
+  double e;
+};
+
+typedef std::list<regexp_elem>::const_iterator const_iterator;
+
+static int
+octregexp_list (const octave_value_list &args, const std::string &nm, 
+		bool case_insensitive, std::list<regexp_elem> &lst, 
+		string_vector &named, int &nopts)
+{
+  int sz = 0;
 #if defined (HAVE_REGEX) || defined (HAVE_PCRE) 
   int nargin = args.length();
-  int nopts = nargin - 2;
   bool once = false;
   bool lineanchors = false;
   bool dotexceptnewline = false;
   bool freespacing = false;
 
+  nopts = nargin - 2;
+
   if (nargin < 2)
     {
       print_usage(nm);
-      return retval;
+      return 0;
     }
 
   std::string buffer = args(0).string_value ();
   if (error_state)
     {
       gripe_wrong_type_arg (nm.c_str(), args(0));
-      return retval;
+      return 0;
     }
 
   std::string pattern = args(1).string_value ();
   if (error_state)
     {
       gripe_wrong_type_arg (nm.c_str(), args(1));
-      return retval;
+      return 0;
     }
 
   for (int i = 2; i < nargin; i++)
     {
       std::string str = args(i).string_value();
       if (error_state)
 	{
 	  error ("%s: optional arguments must be strings", nm.c_str());
 	  break;
 	}
       std::transform (str.begin (), str.end (), str.begin (), tolower);
       if (str.find("once", 0) == 0)
 	{
 	  once = true;
 	  nopts--;
 	}
-#if HAVE_PCRE
-      // Only accept these options with pcre
-      else if (str.find("dotall", 0) == 0)
-	{
-	  dotexceptnewline = false;
-	  nopts--;
-	}
-      else if (str.find("dotexceptnewline", 0) == 0)
-	{
-	  dotexceptnewline = true;
-	  nopts--;
-	}
-      else if (str.find("stringanchors", 0) == 0)
-	{
-	  lineanchors = false;
-	  nopts--;
-	}
-      else if (str.find("lineanchors", 0) == 0)
-	{
-	  lineanchors = true;
-	  nopts--;
-	}
       else if (str.find("matchcase", 0) == 0)
 	{
 	  case_insensitive = false;
 	  nopts--;
 	}
       else if (str.find("ignorecase", 0) == 0)
 	{
 	  case_insensitive = true;
 	  nopts--;
 	}
-      else if (str.find("freespacing", 0) == 0)
+      else if (str.find("dotall", 0) == 0)
 	{
-	  freespacing = true;
+	  dotexceptnewline = false;
+	  nopts--;
+	}
+      else if (str.find("stringanchors", 0) == 0)
+	{
+	  lineanchors = false;
 	  nopts--;
 	}
       else if (str.find("literalspacing", 0) == 0)
 	{
 	  freespacing = false;
 	  nopts--;
 	}
+#if HAVE_PCRE
+      // Only accept these options with pcre
+      else if (str.find("dotexceptnewline", 0) == 0)
+	{
+	  dotexceptnewline = true;
+	  nopts--;
+	}
+      else if (str.find("lineanchors", 0) == 0)
+	{
+	  lineanchors = true;
+	  nopts--;
+	}
+      else if (str.find("freespacing", 0) == 0)
+	{
+	  freespacing = true;
+	  nopts--;
+	}
       else if (str.find("start", 0) && str.find("end", 0) &&
 	       str.find("tokenextents", 0) && str.find("match", 0) &&
 	       str.find("tokens", 0) && str.find("names", 0))
 	error ("%s: unrecognized option", nm.c_str());
 #else
       else if (str.find("names", 0) == 0 ||
 	       str.find("dotexceptnewline", 0) == 0 ||
 	       str.find("lineanchors", 0) == 0 ||
 	       str.find("freespacing", 0) == 0)
-	error ("%s: named tokens not implemented in this version", nm.c_str());
+       error ("%s: %s not implemented in this version", str.c_str(), nm.c_str());
       else if (str.find("start", 0) && str.find("end", 0) &&
 	       str.find("tokenextents", 0) && str.find("match", 0) &&
 	       str.find("tokens", 0))
 	error ("%s: unrecognized option", nm.c_str());
 #endif
     }
 
   if (!error_state)
     {
-      Octave_map nmap;
-      Cell t, m, te;
-      NDArray s, e;
+      Cell t;
+      std::string m;
+      double s, e;
 
       // named tokens "(?<name>...)" are only treated with PCRE not regex.
 #if HAVE_PCRE
       // The syntax of named tokens in pcre is "(?P<name>...)" while we need
       // a syntax "(?<name>...)", so fix that here. Also an expression like
       // "(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)" should
       // be perfectly legal, while pcre does not allow the same named token
       // name on both sides of the alternative. Also fix that here by replacing
       // name tokens by dummy names, and dealing with the dummy names later.
       
       size_t pos = 0;
       size_t new_pos;
-      string_vector named;
       int nnames = 0;
       int inames = 0;
       std::ostringstream buf;
       Array<int> named_idx;
 
-      // Add mode flags
       while ((new_pos = pattern.find ("(?<",pos)) != NPOS)
 	{
 	  size_t tmp_pos = pattern.find_first_of ('>',new_pos);
 
 	  if (tmp_pos == NPOS)
 	    {
 	      error ("syntax error in pattern");
 	      break;
@@ -219,42 +246,41 @@ octregexp (const octave_value_list &args
 	  else
 	    buf << "(?P<n" << inames++;
 	  pos = tmp_pos;
 	}
 
       buf << pattern.substr(pos);
 
       if (error_state)
-	return retval;
+	return 0;
 
       // Compile expression
       pcre *re;
       const char *err;
       int erroffset;
       std::string buf_str = buf.str ();
       re = pcre_compile (buf_str.c_str (),
 			 (case_insensitive ? PCRE_CASELESS : 0) |
 			 (dotexceptnewline ? 0 : PCRE_DOTALL) |
 			 (lineanchors ? PCRE_MULTILINE : 0) |
 			 (freespacing ? PCRE_EXTENDED : 0),
 			 &err, &erroffset, NULL);
     
       if (re == NULL) {
 	error("%s: %s at position %d of expression", nm.c_str(), 
 	      err, erroffset);
-	return retval;
+	return 0;
       }
 
       int subpatterns;
       int namecount;
       int nameentrysize;
       char *nametable;
       int idx = 0;
-      int sz = 0;
 
       pcre_fullinfo(re, NULL, PCRE_INFO_CAPTURECOUNT,  &subpatterns);
       pcre_fullinfo(re, NULL, PCRE_INFO_NAMECOUNT, &namecount);
       pcre_fullinfo(re, NULL, PCRE_INFO_NAMEENTRYSIZE, &nameentrysize);
       pcre_fullinfo(re, NULL, PCRE_INFO_NAMETABLE, &nametable);
 
       OCTAVE_LOCAL_BUFFER(int, ovector, (subpatterns+1)*3);
       OCTAVE_LOCAL_BUFFER(int, nidx, namecount);
@@ -262,216 +288,264 @@ octregexp (const octave_value_list &args
       for (int i = 0; i < namecount; i++)
 	{
 	  // Index of subpattern in first two bytes MSB first of name.
 	  // Extract index.
 	  nidx[i] = (static_cast<int>(nametable[i*nameentrysize])) << 8 |
 	    static_cast<int>(nametable[i*nameentrysize+1]);
 	}
 
-      Cell named_tokens(dim_vector(nnames,1));
-
       while(true)
 	{
+	  OCTAVE_QUIT;
+
 	  int matches = pcre_exec(re, NULL, buffer.c_str(), 
 				  buffer.length(), idx, 
 				  (idx ? PCRE_NOTBOL : 0),
 				  ovector, (subpatterns+1)*3);
 
 	  if (matches < 0 && matches != PCRE_ERROR_NOMATCH)
 	    {
 	      error ("%s: internal error calling pcre_exec", nm.c_str());
 	      pcre_free(re);
-	      return retval;
+	      return 0;
 	    }
 	  else if (matches == PCRE_ERROR_NOMATCH)
 	    break;
 	  else if (ovector[1] <= ovector[0])
 	    break;
 	  else
 	    {
-	      // FIXME Should collect arguments in a linked structure and
-	      // resize and assign the return value a single time to make
-	      // this function O(n) rather than O(n^2) as it currently is.
 	      int pos_match = 0;
-	      s.resize (dim_vector(1, sz+1));
-	      s(sz) = double (ovector[0]+1);
-	      e.resize (dim_vector(1, sz+1));
-	      e(sz) = double (ovector[1]);
-	      te.resize(dim_vector(1, sz+1));
-	      Matrix mat_te(matches-1,2);
+	      Matrix te(matches-1,2);
 	      for (int i = 1; i < matches; i++)
 		{
 		  if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
 		    {
-		      mat_te(pos_match,0) = double (ovector[2*i]+1);
-		      mat_te(pos_match++,1) = double (ovector[2*i+1]);
+		      te(pos_match,0) = double (ovector[2*i]+1);
+		      te(pos_match++,1) = double (ovector[2*i+1]);
 		    }
 		}
-	      mat_te.resize(pos_match,2);
-	      te(sz) = mat_te;
+	      te.resize(pos_match,2);
+	      s = double (ovector[0]+1);
+	      e = double (ovector[1]);
 
 	      const char **listptr;
 	      int status = pcre_get_substring_list(buffer.c_str(), ovector, 
 						   matches, &listptr);
 
 	      if (status == PCRE_ERROR_NOMEMORY) {
 		error("%s: cannot allocate memory in pcre_get_substring_list",
 		      nm.c_str());
 		pcre_free(re);
-		return retval;
+		return 0;
 	      }
 
-	      m.resize (dim_vector(1, sz+1));
-	      m(sz) =  std::string(*listptr);
-
-	      t.resize (dim_vector(1, sz+1));
 	      Cell cell_t (dim_vector(1,pos_match));
 	      pos_match = 0;
 	      for (int i = 1; i < matches; i++)
 		if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
 		  cell_t(pos_match++) = std::string(*(listptr+i));
-	      t(sz) = cell_t;
 
+	      m =  std::string(*listptr);
+	      t = cell_t;
+
+	      string_vector named_tokens(nnames);
 	      if (namecount > 0)
 		for (int i = 1; i < matches; i++)
 		  {
 		    if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)	
 		      {
-			if (sz == 0)
-			  {
-			    named_tokens(named_idx(i-1)) = 
-			      std::string(*(listptr+nidx[i-1]));
-			  }
-			else
-			  {
-			    Cell tmp = named_tokens(named_idx(i-1));
-			    tmp.resize(dim_vector(1,sz+1));
-			    tmp(sz) = std::string(*(listptr+nidx[i-1]));
-			    named_tokens(named_idx(i-1)) = tmp;
-			  }
+			named_tokens(named_idx(i-1)) = 
+			  std::string(*(listptr+nidx[i-1]));
 		      }
 		  }
 
 	      pcre_free_substring_list(listptr);
 
+	      regexp_elem new_elem (named_tokens, t, m, te, s, e);
+	      lst.push_back (new_elem);
+	      idx = ovector[1];
+	      sz++;
+
 	      if (once)
 		break;
 
-	      idx = ovector[1];
-	      sz++;
 	    }
 	}
 
-      for (int i = 0; i < nnames; i++)
-	nmap.assign (named(i), named_tokens(i));
-
       pcre_free(re);
 #else
       regex_t compiled;
       int err=regcomp(&compiled, pattern.c_str(), REG_EXTENDED | 
 		      (case_insensitive ? REG_ICASE : 0));
       if (err)
 	{
 	  int len = regerror(err, &compiled, NULL, 0);
 	  OCTAVE_LOCAL_BUFFER (char, errmsg, len);
 	  regerror(err, &compiled, errmsg, len);
 	  error("%s: %s in pattern (%s)", nm.c_str(), errmsg, 
 		pattern.c_str());
 	  regfree(&compiled);
-	  return retval;
+	  return 0;
 	}
 
       int subexpr = 1;
       int idx = 0;
-      int sz = 0;
       for (unsigned int i=0; i < pattern.length(); i++)
 	  subexpr += ( pattern[i] == '(' ? 1 : 0 );
       OCTAVE_LOCAL_BUFFER (regmatch_t, match, subexpr );
 
       while(true)
 	{
+	  OCTAVE_QUIT; 
+
 	  if (regexec(&compiled, buffer.c_str() + idx, subexpr, 
 		      match, (idx ? REG_NOTBOL : 0)) == 0) 
 	    {
 	      // Count actual matches
 	      int matches = 0;
 	      while (matches < subexpr && match[matches].rm_so >= 0) 
 		matches++;
 
-	      s.resize (dim_vector(1, sz+1));
-	      s(sz) = double (match[0].rm_so+1+idx);
-	      e.resize (dim_vector(1, sz+1));
-	      e(sz) = double (match[0].rm_eo+idx);
-	      te.resize(dim_vector(1, sz+1));
-	      Matrix mat_te(matches-1,2);
+	      s = double (match[0].rm_so+1+idx);
+	      e = double (match[0].rm_eo+idx);
+	      Matrix te(matches-1,2);
 	      for (int i = 1; i < matches; i++)
 		{
-		  mat_te(i-1,0) = double (match[i].rm_so+1+idx);
-		  mat_te(i-1,1) = double (match[i].rm_eo+idx);
+		  te(i-1,0) = double (match[i].rm_so+1+idx);
+		  te(i-1,1) = double (match[i].rm_eo+idx);
 		}
-	      te(sz) = mat_te;
 
-	      m.resize (dim_vector(1, sz+1));
-	      m(sz) =  buffer.substr (match[0].rm_so+idx, 
+	      m =  buffer.substr (match[0].rm_so+idx, 
 					 match[0].rm_eo-match[0].rm_so);
 
-	      t.resize (dim_vector(1, sz+1));
 	      Cell cell_t (dim_vector(1,matches-1));
 	      for (int i = 1; i < matches; i++)
 		cell_t(i-1) = buffer.substr (match[i].rm_so+idx, 
 					     match[i].rm_eo-match[i].rm_so);
-	      t(sz) = cell_t;
+	      t = cell_t;
 
 	      idx += match[0].rm_eo;
+
+	      regexp_elem new_elem (Octave_map(), t, m, te, s, e);
+	      lst.push_back (new_elem);
 	      sz++;
 
 	      if (once)
 		break;
 	    }
 	  else
 	    break;
 	}
       regfree(&compiled);
 #endif
+    }
+#else
+  error ("%s: not available in this version of Octave", nm.c_str());
+#endif
+  return sz;
+}
 
-      retval(5) = nmap;
+static octave_value_list
+octregexp (const octave_value_list &args, int nargout, const std::string &nm,
+	   bool case_insensitive)
+{
+  octave_value_list retval;
+  int nargin = args.length();
+  std::list<regexp_elem> lst;
+  string_vector named;
+  int nopts;
+  int sz = octregexp_list (args, nm, case_insensitive, lst, named, nopts);
+
+  if (! error_state)
+    {
+      // Converted the linked list in the correct form for the return values
+
+      octave_idx_type i = 0;
+#ifdef HAVE_PCRE
+      Octave_map nmap;
+      if (sz == 1)
+	{
+	  for (int j = 0; j < named.length(); j++)
+	    nmap.assign (named(j), lst.begin()->named_token(j));
+	  retval(5) = nmap;
+	}
+      else
+	{
+	  for (int j = 0; j < named.length (); j++)
+	    {
+	      i = 0;
+	      Cell tmp(dim_vector (1, sz));
+	      for (const_iterator p = lst.begin(); p != lst.end(); p++)
+		tmp(i++) = p->named_token(j);
+	      nmap.assign (named(j), octave_value (tmp));
+	    }
+	  retval(5) = nmap;
+	}
+#else
+      retval(5) = Octave_map();
+#endif
+
+      Cell t (dim_vector(1, sz));
+      i = 0;
+      for (const_iterator p = lst.begin(); p != lst.end(); p++)
+	t(i++) = p->t;
       retval(4) = t;
+
+      Cell m (dim_vector(1, sz));
+      i = 0;
+      for (const_iterator p = lst.begin(); p != lst.end(); p++)
+	m(i++) = p->m;
       retval(3) = m;
+
+
+      Cell te (dim_vector(1, sz));
+      i = 0;
+      for (const_iterator p = lst.begin(); p != lst.end(); p++)
+	te(i++) = p->te;
       retval(2) = te;
+
+      NDArray e (dim_vector(1, sz));
+      i = 0;
+      for (const_iterator p = lst.begin(); p != lst.end(); p++)
+	e(i++) = p->e;
       retval(1) = e;
+
+      NDArray s (dim_vector(1, sz));
+      i = 0;
+      for (const_iterator p = lst.begin(); p != lst.end(); p++)
+	s(i++) = p->s;
       retval(0) = s;
 
       // Alter the order of the output arguments
       if (nopts > 0)
 	{
 	  int n = 0;
 	  octave_value_list new_retval;
 	  new_retval.resize(nargout);
 
 	  OCTAVE_LOCAL_BUFFER (int, arg_used, 6);
-	  for (int i = 0; i < 6; i++)
-	    arg_used[i] = false;
+	  for (int j = 0; j < 6; j++)
+	    arg_used[j] = false;
 	  
-	  for (int i = 2; i < nargin; i++)
+	  for (int j = 2; j < nargin; j++)
 	    {
 	      int k = 0;
-	      std::string str = args(i).string_value();
+	      std::string str = args(j).string_value();
 	      std::transform (str.begin (), str.end (), str.begin (), tolower);
 	      if (str.find("once", 0) == 0
-#if HAVE_PCRE
 		  || str.find("stringanchors", 0) == 0
 		  || str.find("lineanchors", 0) == 0
 		  || str.find("matchcase", 0) == 0
 		  || str.find("ignorecase", 0) == 0
 		  || str.find("dotall", 0) == 0
 		  || str.find("dotexceptnewline", 0) == 0
 		  || str.find("literalspacing", 0) == 0
 		  || str.find("freespacing", 0) == 0
-#endif
 	      )
 		continue;
 	      else if (str.find("start", 0) == 0)
 		k = 0;
 	      else if (str.find("end", 0) == 0)
 		k = 1;
 	      else if (str.find("tokenextents", 0) == 0)
 		k = 2;
@@ -487,30 +561,27 @@ octregexp (const octave_value_list &args
 
 	      if (n == nargout)
 		break;
 	    }
 
 	  // Fill in the rest of the arguments
 	  if (n < nargout)
 	    {
-	      for (int i = 0; i < 6; i++)
+	      for (int j = 0; j < 6; j++)
 		{
-		  if (! arg_used[i])
-		    new_retval(n++) = retval(i);
+		  if (! arg_used[j])
+		    new_retval(n++) = retval(j);
 		}
 	    }
 
 	  retval = new_retval;
 	}
     }
 
-#else
-  error ("%s: not available in this version of Octave", nm.c_str());
-#endif
   return retval;
 }
 
 DEFUN_DLD (regexp, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}] =} regexp (@var{str}, @var{pat})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} regexp (@var{str}, @var{pat}, @var{opts}, @dots{})\n\
 \n\
@@ -647,33 +718,33 @@ The pattern is taken literally.\n\
 /*
 
 ## seg-fault test
 %!assert(regexp("abcde","."),[1,2,3,4,5])
 
 ## Check that anchoring of pattern works correctly
 %!assert(regexp('abcabc','^abc'),1);
 %!assert(regexp('abcabc','abc$'),4);
-%!assert(regexp('abcabc','^abc$'),[]);
+%!assert(regexp('abcabc','^abc$'),zeros(1,0));
 
 %!test
 %! [s, e, te, m, t] = regexp(' No Match ', 'f(.*)uck');
-%! assert (s,[])
-%! assert (e,[])
-%! assert (te,{})
-%! assert (m, {})
-%! assert (t, {})
+%! assert (s,zeros(1,0))
+%! assert (e,zeros(1,0))
+%! assert (te,cell(1,0))
+%! assert (m, cell(1,0))
+%! assert (t, cell(1,0))
 
 %!test
 %! [s, e, te, m, t] = regexp(' FiRetrUck ', 'f(.*)uck');
-%! assert (s,[])
-%! assert (e,[])
-%! assert (te,{})
-%! assert (m, {})
-%! assert (t, {})
+%! assert (s,zeros(1,0))
+%! assert (e,zeros(1,0))
+%! assert (te,cell(1,0))
+%! assert (m, cell(1,0))
+%! assert (t, cell(1,0))
 
 %!test
 %! [s, e, te, m, t] = regexp(' firetruck ', 'f(.*)uck');
 %! assert (s,2)
 %! assert (e,10)
 %! assert (te{1},[3,7])
 %! assert (m{1}, 'firetruck')
 %! assert (t{1}{1}, 'iretr')
@@ -792,18 +863,18 @@ The pattern is taken literally.\n\
 %!   assert (regexp("abc\nabc",'(?m)c$'),[3,7])
 %! endif
 
 %!assert (regexp("this word",'s w'),4)
 %!assert (regexp("this word",'s w','literalspacing'),4)
 %!test
 %! if (!isempty(findstr(octave_config_info ("DEFS"),"HAVE_PCRE")))
 %!   assert (regexp("this word",'(?-x)s w','literalspacing'),4)
-%!   assert (regexp("this word",'s w','freespacing'),[])
-%!   assert (regexp("this word",'(?x)s w'),[])
+%!   assert (regexp("this word",'s w','freespacing'),zeros(1,0))
+%!   assert (regexp("this word",'(?x)s w'),zeros(1,0))
 %! endif
 
 %!error regexp('string', 'tri', 'BadArg');
 %!error regexp('string');
 
 */
 
 DEFUN_DLD(regexpi, args, nargout,
@@ -822,25 +893,25 @@ if there are none. See @code{regexp} for
 /*
 
 ## seg-fault test
 %!assert(regexpi("abcde","."),[1,2,3,4,5])
 
 ## Check that anchoring of pattern works correctly
 %!assert(regexpi('abcabc','^abc'),1);
 %!assert(regexpi('abcabc','abc$'),4);
-%!assert(regexpi('abcabc','^abc$'),[]);
+%!assert(regexpi('abcabc','^abc$'),zeros(1,0));
 
 %!test
 %! [s, e, te, m, t] = regexpi(' No Match ', 'f(.*)uck');
-%! assert (s,[])
-%! assert (e,[])
-%! assert (te,{})
-%! assert (m, {})
-%! assert (t, {})
+%! assert (s,zeros(1,0))
+%! assert (e,zeros(1,0))
+%! assert (te,cell(1,0))
+%! assert (m, cell(1,0))
+%! assert (t, cell(1,0))
 
 %!test
 %! [s, e, te, m, t] = regexpi(' FiRetrUck ', 'f(.*)uck');
 %! assert (s,2)
 %! assert (e,10)
 %! assert (te{1},[3,7])
 %! assert (m{1}, 'FiRetrUck')
 %! assert (t{1}{1}, 'iRetr')
@@ -951,22 +1022,309 @@ if there are none. See @code{regexp} for
 %!   assert (regexpi("abc\nabc",'(?m)c$'),[3,7])
 %! endif
 
 %!assert (regexpi("this word",'s w'),4)
 %!assert (regexpi("this word",'s w','literalspacing'),4)
 %!test
 %! if (!isempty(findstr(octave_config_info ("DEFS"),"HAVE_PCRE")))
 %!   assert (regexpi("this word",'(?-x)s w','literalspacing'),4)
-%!   assert (regexpi("this word",'s w','freespacing'),[])
-%!   assert (regexpi("this word",'(?x)s w'),[])
+%!   assert (regexpi("this word",'s w','freespacing'),zeros(1,0))
+%!   assert (regexpi("this word",'(?x)s w'),zeros(1,0))
 %! endif
 
 %!error regexpi('string', 'tri', 'BadArg');
 %!error regexpi('string');
 
 */
 
+DEFUN_DLD(regexprep, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Function File}  @var{string} = regexprep(@var{string}, @var{pat}, @var{repstr}, @var{options})\n\
+Replace matches of @var{pat} in  @var{string} with @var{repstr}.\n\
+\n\
+\n\
+The replacement can contain @code{$i}, which subsubstitutes\n\
+for the ith set of parentheses in the match string.  E.g.,\n\
+@example\n\
+\n\
+   regexprep(\"Bill Dunn\",'(\\w+) (\\w+)','$2, $1')\n\
+\n\
+@end example\n\
+returns \"Dunn, Bill\"\n\
+\n\
+@var{options} may be zero or more of\n\
+@table @samp\n\
+\n\
+@item once\n\
+Replace only the first occurance of @var{pat} in the result.\n\
+\n\
+@item warnings\n\
+This option is present for compatibility but is ignored.\n\
+\n\
+@item ignorecase or matchcase\n\
+Ignore case for the pattern matching (see @code{regexpi}).\n\
+Alternatively, use (?i) or (?-i) in the pattern.\n\
+\n\
+@item lineanchors and stringanchors\n\
+Whether characters ^ and $ match the beginning and ending of lines.\n\
+Alternatively, use (?m) or (?-m) in the pattern.\n\
+\n\
+@item dotexceptnewline and dotall\n\
+Whether . matches newlines in the string.\n\
+Alternatively, use (?s) or (?-s) in the pattern.\n\
+\n\
+@item freespacing or literalspacing\n\
+Whether whitespace and # comments can be used to make the regular expression more readable.\n\
+Alternatively, use (?x) or (?-x) in the pattern.\n\
+\n\
+@end table\n\
+@seealso{regexp,regexpi}\n\
+@end deftypefn")
+{
+  octave_value_list retval;
+
+  int nargin = args.length();
+
+  if (nargin < 3)
+    {
+      print_usage("regexprep");
+      return retval;
+    }
+
+  // Make sure we have string,pattern,replacement
+  const std::string buffer = args(0).string_value ();
+  if (error_state) return retval;
+  const std::string pattern = args(1).string_value ();
+  if (error_state) return retval;
+  const std::string replacement = args(2).string_value ();
+  if (error_state) return retval;
+  
+  // Pack options excluding 'tokenize' and various output
+  // reordering strings into regexp arg list
+  octave_value_list regexpargs(nargin-1,octave_value());
+  regexpargs(0) = args(0);
+  regexpargs(1) = args(1);
+  int len=2;
+  for (int i = 3; i < nargin; i++) 
+    {
+      const std::string opt = args(i).string_value();
+      if (opt != "tokenize" && opt != "start" && opt != "end"
+	  && opt != "tokenextents" && opt != "match" && opt != "tokens"
+	  && opt != "names"  && opt != "warnings") 
+	{
+	  regexpargs(len++) = args(i);
+	}
+    }
+  regexpargs.resize(len);
+  
+  // Identify replacement tokens; build a vector of group numbers in
+  // the replacement string so that we can quickly calculate the size 
+  // of the replacement.
+  int tokens = 0;
+  for (size_t i=1; i < replacement.size(); i++) 
+    {
+      if (replacement[i-1]=='$' && isdigit(replacement[i])) 
+	{
+	  tokens++, i++;
+	}
+    }
+  std::vector<int> token(tokens);
+  int kk = 0;
+  for (size_t i = 1; i < replacement.size(); i++) 
+    {
+      if (replacement[i-1]=='$' && isdigit(replacement[i])) 
+	{
+	  token[kk++] = replacement[i]-'0';
+	  i++;
+	}
+    }
+
+  // Perform replacement
+  std::string rep;
+  if (tokens > 0) 
+    {
+      std::list<regexp_elem> lst;
+      string_vector named;
+      int nopts;
+      int sz = octregexp_list (regexpargs, "regexprep", false, lst, named, 
+			       nopts);
+
+      if (error_state)
+	return retval;
+      if (sz == 0)
+	{
+	  retval(0) = args(0);
+	  return retval;
+	}
+
+      // Determine replacement length
+      const size_t replen = replacement.size() - 2*tokens;
+      int delta = 0;
+      const_iterator p = lst.begin();
+      for (int i = 0; i < sz; i++) 
+	{
+	  OCTAVE_QUIT;
+
+	  const Matrix pairs(p->te);
+	  size_t pairlen = 0;
+	  for (int j = 0; j < tokens; j++) 
+	    {
+	      if (token[j] == 0) 
+		pairlen += static_cast<size_t>(p->e - p->s) + 1;
+	      else if (token[j] <= pairs.rows()) 
+		pairlen += static_cast<size_t>(pairs(token[j]-1,1) - 
+					       pairs(token[j]-1,0)) + 1;
+	    }
+	  delta += static_cast<int>(replen + pairlen) - 
+	    static_cast<int>(p->e - p->s + 1);
+	  p++;
+	}
+      
+      // Build replacement string
+      rep.reserve(buffer.size()+delta);
+      size_t from = 0;
+      p = lst.begin();
+      for (int i=0; i < sz; i++) 
+	{
+	  OCTAVE_QUIT;
+
+	  const Matrix pairs(p->te);
+	  rep.append(&buffer[from], static_cast<size_t>(p->s - 1) - from);
+	  from = static_cast<size_t>(p->e - 1) + 1;
+	  for (size_t j = 1; j < replacement.size(); j++) 
+	    {
+	      if (replacement[j-1]=='$' && isdigit(replacement[j])) 
+		{
+		  int k = replacement[j]-'0';
+		  if (k == 0) 
+		    { 
+		      // replace with entire match
+		      rep.append(&buffer[static_cast<size_t>(p->e - 1)],
+				 static_cast<size_t>(p->e - p->s) + 1);
+		    } 
+		  else if (k <= pairs.rows()) 
+		    {
+		      // replace with group capture
+		      rep.append(&buffer[static_cast<size_t>(pairs(k-1,0)-1)],
+				 static_cast<size_t>(pairs(k-1,1) - 
+						     pairs(k-1,0))+1);
+		    }
+		  else 
+		    {
+		      // replace with nothing
+		    }
+		  j++;
+		} 
+	      else 
+		{
+		  rep.append(1,replacement[j-1]);
+		}
+	      if (j+1 == replacement.size()) 
+		{
+		  rep.append(1,replacement[j]);
+		}
+	    }
+	  p++;
+	}
+      rep.append(&buffer[from],buffer.size()-from);
+    } 
+  else 
+    {
+      std::list<regexp_elem> lst;
+      string_vector named;
+      int nopts;
+      int sz = octregexp_list (regexpargs, "regexprep", false, lst, named, 
+			       nopts);
+
+      if (error_state)
+	return retval;
+      if (sz == 0)
+	{
+	  retval(0) = args(0);
+	  return retval;
+	}
+
+      // Determine replacement length
+      const size_t replen = replacement.size();
+      int delta = 0;
+      const_iterator p = lst.begin();
+      for (int i = 0; i < sz; i++) 
+	{
+          OCTAVE_QUIT;
+	  delta += static_cast<int>(replen) - 
+	    static_cast<int>(p->e - p->s + 1);
+	  p++;
+	}
+
+      // Build replacement string
+      rep.reserve(buffer.size()+delta);
+      size_t from = 0;
+      p = lst.begin();
+      for (int i=0; i < sz; i++) 
+	{
+          OCTAVE_QUIT;
+	  rep.append(&buffer[from], static_cast<size_t>(p->s - 1) - from);
+	  from = static_cast<size_t>(p->e - 1) + 1;
+	  rep.append(replacement);
+	  p++;
+	}
+      rep.append(&buffer[from],buffer.size()-from);
+    }
+  
+  retval(0) = rep;
+  return retval;
+}
+
+/*
+%!test  # Replace with empty
+%! xml = '<!-- This is some XML --> <tag v="hello">some stuff<!-- sample tag--></tag>';
+%! t = regexprep(xml,'<[!?][^>]*>','');
+%! assert(t,' <tag v="hello">some stuff</tag>')
+
+%!test  # Replace with non-empty
+%! xml = '<!-- This is some XML --> <tag v="hello">some stuff<!-- sample tag--></tag>';
+%! t = regexprep(xml,'<[!?][^>]*>','?');
+%! assert(t,'? <tag v="hello">some stuff?</tag>')
+
+%!test  # Check that 'tokenize' is ignored
+%! xml = '<!-- This is some XML --> <tag v="hello">some stuff<!-- sample tag--></tag>';
+%! t = regexprep(xml,'<[!?][^>]*>','','tokenize');
+%! assert(t,' <tag v="hello">some stuff</tag>')
+
+%!test  # Capture replacement
+%! if (!isempty(findstr(octave_config_info ("DEFS"),"HAVE_PCRE")))
+%!   data = "Bob Smith\nDavid Hollerith\nSam Jenkins";
+%!   result = "Smith, Bob\nHollerith, David\nJenkins, Sam";
+%!   t = regexprep(data,'(?m)^(\w+)\s+(\w+)$','$2, $1');
+%!   assert(t,result)
+%! end
+
+# Return the original if no match
+%!assert(regexprep('hello','world','earth'),'hello')
+
+## Test a general replacement
+%!assert(regexprep("a[b]c{d}e-f=g", "[^A-Za-z0-9_]", "_"), "a_b_c_d_e_f_g");
+
+## Make sure it works at the beginning and end
+%!assert(regexprep("a[b]c{d}e-f=g", "a", "_"), "_[b]c{d}e-f=g");
+%!assert(regexprep("a[b]c{d}e-f=g", "g", "_"), "a[b]c{d}e-f=_");
+
+## Options
+%!assert(regexprep("a[b]c{d}e-f=g", "[^A-Za-z0-9_]", "_", "once"), "a_b]c{d}e-f=g");
+%!assert(regexprep("a[b]c{d}e-f=g", "[^A-Z0-9_]", "_", "ignorecase"), "a_b_c_d_e_f_g");
+
+## Option combinations
+%!assert(regexprep("a[b]c{d}e-f=g", "[^A-Z0-9_]", "_", "once", "ignorecase"), "a_b]c{d}e-f=g");
+
+## End conditions on replacement
+%!assert(regexprep("abc","(b)",".$1"),"a.bc");
+%!assert(regexprep("abc","(b)","$1"),"abc");
+%!assert(regexprep("abc","(b)","$1."),"ab.c");
+%!assert(regexprep("abc","(b)","$1.."),"ab..c");
+
+*/
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/splu.cc b/src/DLD-FUNCTIONS/splu.cc
--- a/src/DLD-FUNCTIONS/splu.cc
+++ b/src/DLD-FUNCTIONS/splu.cc
@@ -235,67 +235,67 @@ be square.\n\
 	    case 2:
 	      {
 		SparseLU fact (m, Qinit, thres, true);
 
 		SparseMatrix P = fact.Pr ();
 		SparseMatrix L = P.transpose () * fact.L ();
 		if (have_Qinit)
 		  retval(1) = octave_value (fact.U () * fact.Pc ().transpose (),
-		    SparseType (SparseType::Permuted_Upper, nc, fact.col_perm ()));
+		    MatrixType (MatrixType::Permuted_Upper, nc, fact.col_perm ()));
 		else
 		  retval(1) = octave_value (fact.U (), 
-					    SparseType (SparseType::Upper));
+					    MatrixType (MatrixType::Upper));
 
 		retval(0) = octave_value (L,
-		  SparseType (SparseType::Permuted_Lower, nr, fact.row_perm ()));
+		  MatrixType (MatrixType::Permuted_Lower, nr, fact.row_perm ()));
 	      }
 	      break;
 
 	    case 3:
 	      {
 		SparseLU fact (m, Qinit, thres, true);
 
 		retval(2) = fact.Pr ();
 		if (have_Qinit)
 		  retval(1) = octave_value (fact.U () * fact.Pc ().transpose (),
-		    SparseType (SparseType::Permuted_Upper, nc, fact.col_perm ()));
+		    MatrixType (MatrixType::Permuted_Upper, nc, fact.col_perm ()));
 		else
 		  retval(1) = octave_value (fact.U (), 
-					    SparseType (SparseType::Upper));
+					    MatrixType (MatrixType::Upper));
 
 		retval(0) = octave_value (fact.L (), 
-					  SparseType (SparseType::Lower));
+					  MatrixType (MatrixType::Lower));
 	      }
 	      break;
 
 	    case 4:
 	    default:
 	      {
 		if (have_Qinit)
 		  {
 		    SparseLU fact (m, Qinit, thres, false);
 
 		    retval(3) = fact.Pc ();
 		    retval(2) = fact.Pr ();
 		    retval(1) = octave_value (fact.U (), 
-					      SparseType (SparseType::Upper));
+					      MatrixType (MatrixType::Upper));
 		    retval(0) = octave_value (fact.L (), 
-					      SparseType (SparseType::Lower));
+					      MatrixType (MatrixType::Lower));
 		  }
 		else
 		  {
 		    SparseLU fact (m, thres);
 
 		    retval(3) = fact.Pc ();
 		    retval(2) = fact.Pr ();
 		    retval(1) = octave_value (fact.U (), 
-					      SparseType (SparseType::Upper));
+					      MatrixType (MatrixType::Upper));
 		    retval(0) = octave_value (fact.L (), 
-					      SparseType (SparseType::Lower));
+					      MatrixType (MatrixType::Lower));
 		  }
 	      }
 	      break;
 	    }
 	}
     }
   else if (arg.is_complex_type ())
     {
@@ -319,67 +319,67 @@ be square.\n\
 	      {
 		SparseComplexLU fact (m, Qinit, thres, true);
 
 		SparseMatrix P = fact.Pr ();
 		SparseComplexMatrix L = P.transpose () * fact.L ();
 
 		if (have_Qinit)
 		  retval(1) = octave_value (fact.U () * fact.Pc ().transpose (),
-		    SparseType (SparseType::Permuted_Upper, nc, fact.col_perm ()));
+		    MatrixType (MatrixType::Permuted_Upper, nc, fact.col_perm ()));
 		else
 		  retval(1) = octave_value (fact.U (), 
-					    SparseType (SparseType::Upper));
+					    MatrixType (MatrixType::Upper));
 
 		retval(0) = octave_value (L,
-		  SparseType (SparseType::Permuted_Lower, nr, fact.row_perm ()));
+		  MatrixType (MatrixType::Permuted_Lower, nr, fact.row_perm ()));
 	      }
 	      break;
 
 	    case 3:
 	      {
 		SparseComplexLU fact (m, Qinit, thres, true);
 
 		retval(2) = fact.Pr ();
 		if (have_Qinit)
 		  retval(1) = octave_value (fact.U () * fact.Pc ().transpose (),
-		    SparseType (SparseType::Permuted_Upper, nc, fact.col_perm ()));
+		    MatrixType (MatrixType::Permuted_Upper, nc, fact.col_perm ()));
 		else
 		  retval(1) = octave_value (fact.U (), 
-					    SparseType (SparseType::Upper));
+					    MatrixType (MatrixType::Upper));
 
 		retval(0) = octave_value (fact.L (), 
-					  SparseType (SparseType::Lower));
+					  MatrixType (MatrixType::Lower));
 	      }
 	      break;
 
 	    case 4:
 	    default:
 	      {
 		if (have_Qinit)
 		  {
 		    SparseComplexLU fact (m, Qinit, thres, false);
 		    
 		    retval(3) = fact.Pc ();
 		    retval(2) = fact.Pr ();
 		    retval(1) = octave_value (fact.U (), 
-					      SparseType (SparseType::Upper));
+					      MatrixType (MatrixType::Upper));
 		    retval(0) = octave_value (fact.L (), 
-					      SparseType (SparseType::Lower));
+					      MatrixType (MatrixType::Lower));
 		  }
 		else
 		  {
 		    SparseComplexLU fact (m, thres);
 
 		    retval(3) = fact.Pc ();
 		    retval(2) = fact.Pr ();
 		    retval(1) = octave_value (fact.U (), 
-					      SparseType (SparseType::Upper));
+					      MatrixType (MatrixType::Upper));
 		    retval(0) = octave_value (fact.L (), 
-					      SparseType (SparseType::Lower));
+					      MatrixType (MatrixType::Lower));
 		  }
 	      }
 	      break;
 	    }
 	}
     }
   else
     {
@@ -440,26 +440,23 @@ than @code{@var{y} = spinv (@var{a}) * @
 
   if (arg.is_real_type ())
     {
       
       SparseMatrix m = arg.sparse_matrix_value ();      
 
       if (! error_state)
 	{
-	  const octave_sparse_matrix& rep
-	    = dynamic_cast<const octave_sparse_matrix&> (arg.get_rep ());
-
-	  SparseType mattyp = rep.sparse_type ();
+	  MatrixType mattyp = args(0).matrix_type ();
 
 	  octave_idx_type info;
 	  double rcond = 0.0;
 	  SparseMatrix result = m.inverse (mattyp, info, rcond, 1);
 
-	  rep.sparse_type (mattyp);
+	  args(0).matrix_type (mattyp);
 
 	  if (nargout > 1)
 	    retval(1) = rcond;
 
 	  retval(0) = result;
 
 	  volatile double xrcond = rcond;
 	  xrcond += 1.0;
@@ -469,26 +466,24 @@ than @code{@var{y} = spinv (@var{a}) * @
 	}
     }
   else if (arg.is_complex_type ())
     {
       SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
       if (! error_state)
 	{
-	  const octave_sparse_complex_matrix& rep
-	    = dynamic_cast<const octave_sparse_complex_matrix&> (arg.get_rep ());
-	  SparseType mattyp = rep.sparse_type ();
+	  MatrixType mattyp = args(0).matrix_type ();
 
 	  octave_idx_type info;
 	  double rcond = 0.0;
 
 	  SparseComplexMatrix result = m.inverse (mattyp, info, rcond, 1);
 
-	  rep.sparse_type (mattyp);
+	  args(0).matrix_type (mattyp);
 
 	  if (nargout > 1)
 	    retval(1) = rcond;
 
 	  retval(0) = result;
 
 	  volatile double xrcond = rcond;
 	  xrcond += 1.0;
diff --git a/src/OPERATORS/op-cm-cm.cc b/src/OPERATORS/op-cm-cm.cc
--- a/src/OPERATORS/op-cm-cm.cc
+++ b/src/OPERATORS/op-cm-cm.cc
@@ -70,25 +70,46 @@ DEFNCUNOP_METHOD (incr, complex_matrix, 
 DEFNCUNOP_METHOD (decr, complex_matrix, decrement)
 
 // complex matrix by complex matrix ops.
 
 DEFNDBINOP_OP (add, complex_matrix, complex_matrix, complex_array, complex_array, +)
 DEFNDBINOP_OP (sub, complex_matrix, complex_matrix, complex_array, complex_array, -)
 
 DEFBINOP_OP (mul, complex_matrix, complex_matrix, *)
-DEFBINOP_FN (div, complex_matrix, complex_matrix, xdiv)
+
+DEFBINOP (div, complex_matrix, complex_matrix)
+{
+  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  MatrixType typ = v2.matrix_type ();
+  
+  ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+			    v2.complex_matrix_value (), typ);
+
+  v2.matrix_type (typ);
+  return ret;
+}
 
 DEFBINOPX (pow, complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
-DEFBINOP_FN (ldiv, complex_matrix, complex_matrix, xleftdiv)
+DEFBINOP (ldiv, complex_matrix, complex_matrix)
+{
+  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  MatrixType typ = v1.matrix_type ();
+  
+  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
+				v2.complex_matrix_value (), typ);
+
+  v1.matrix_type (typ);
+  return ret;
+}
 
 DEFNDBINOP_FN (lt, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_lt)
 DEFNDBINOP_FN (le, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_le)
 DEFNDBINOP_FN (eq, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_eq)
 DEFNDBINOP_FN (ge, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_ge)
 DEFNDBINOP_FN (gt, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_gt)
 DEFNDBINOP_FN (ne, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_ne)
 
diff --git a/src/OPERATORS/op-cm-cs.cc b/src/OPERATORS/op-cm-cs.cc
--- a/src/OPERATORS/op-cm-cs.cc
+++ b/src/OPERATORS/op-cm-cs.cc
@@ -56,18 +56,21 @@ DEFBINOP (div, complex_matrix, complex)
 DEFBINOP_FN (pow, complex_matrix, complex, xpow)
 
 DEFBINOP (ldiv, complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
+  MatrixType typ = v1.matrix_type ();
 
-  return octave_value (xleftdiv (m1, m2));
+  ComplexMatrix ret = xleftdiv (m1, m2, typ);
+  v1.matrix_type (typ);
+  return ret;
 }
 
 DEFNDBINOP_FN (lt, complex_matrix, complex, complex_array, complex, mx_el_lt)
 DEFNDBINOP_FN (le, complex_matrix, complex, complex_array, complex, mx_el_le)
 DEFNDBINOP_FN (eq, complex_matrix, complex, complex_array, complex, mx_el_eq)
 DEFNDBINOP_FN (ge, complex_matrix, complex, complex_array, complex, mx_el_ge)
 DEFNDBINOP_FN (gt, complex_matrix, complex, complex_array, complex, mx_el_gt)
 DEFNDBINOP_FN (ne, complex_matrix, complex, complex_array, complex, mx_el_ne)
diff --git a/src/OPERATORS/op-cm-m.cc b/src/OPERATORS/op-cm-m.cc
--- a/src/OPERATORS/op-cm-m.cc
+++ b/src/OPERATORS/op-cm-m.cc
@@ -41,25 +41,47 @@ 02110-1301, USA.
 #include "xpow.h"
 
 // complex matrix by matrix ops.
 
 DEFNDBINOP_OP (add, complex_matrix, matrix, complex_array, array, +)
 DEFNDBINOP_OP (sub, complex_matrix, matrix, complex_array, array, -)
 
 DEFBINOP_OP (mul, complex_matrix, matrix, *)
-DEFBINOP_FN (div, complex_matrix, matrix, xdiv)
+
+DEFBINOP (div, complex_matrix, matrix)
+{
+  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
+  MatrixType typ = v2.matrix_type ();
+  
+  ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+			    v2.matrix_value (), typ);
+
+  v2.matrix_type (typ);
+  return ret;
+}
+
 
 DEFBINOPX (pow, complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
-DEFBINOP_FN (ldiv, complex_matrix, matrix, xleftdiv)
+DEFBINOP (ldiv, complex_matrix, matrix)
+{
+  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
+  MatrixType typ = v1.matrix_type ();
+  
+  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
+				v2.matrix_value (), typ);
+
+  v1.matrix_type (typ);
+  return ret;
+}
 
 DEFNDBINOP_FN (lt, complex_matrix, matrix, complex_array, array, mx_el_lt)
 DEFNDBINOP_FN (le, complex_matrix, matrix, complex_array, array, mx_el_le)
 DEFNDBINOP_FN (eq, complex_matrix, matrix, complex_array, array, mx_el_eq)
 DEFNDBINOP_FN (ge, complex_matrix, matrix, complex_array, array, mx_el_ge)
 DEFNDBINOP_FN (gt, complex_matrix, matrix, complex_array, array, mx_el_gt)
 DEFNDBINOP_FN (ne, complex_matrix, matrix, complex_array, array, mx_el_ne)
 
diff --git a/src/OPERATORS/op-cm-s.cc b/src/OPERATORS/op-cm-s.cc
--- a/src/OPERATORS/op-cm-s.cc
+++ b/src/OPERATORS/op-cm-s.cc
@@ -60,18 +60,22 @@ DEFBINOP (div, complex_matrix, scalar)
 DEFBINOP_FN (pow, complex_matrix, scalar, xpow)
 
 DEFBINOP (ldiv, complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   Matrix m2 = v2.matrix_value ();
+  MatrixType typ = v1.matrix_type ();
 
-  return octave_value (xleftdiv (m1, m2));
+  ComplexMatrix ret = xleftdiv (m1, m2, typ);
+
+  v1.matrix_type (typ);
+  return ret;
 }
 
 DEFNDBINOP_FN (lt, complex_matrix, scalar, complex_array, scalar, mx_el_lt)
 DEFNDBINOP_FN (le, complex_matrix, scalar, complex_array, scalar, mx_el_le)
 DEFNDBINOP_FN (eq, complex_matrix, scalar, complex_array, scalar, mx_el_eq)
 DEFNDBINOP_FN (ge, complex_matrix, scalar, complex_array, scalar, mx_el_ge)
 DEFNDBINOP_FN (gt, complex_matrix, scalar, complex_array, scalar, mx_el_gt)
 DEFNDBINOP_FN (ne, complex_matrix, scalar, complex_array, scalar, mx_el_ne)
diff --git a/src/OPERATORS/op-cm-scm.cc b/src/OPERATORS/op-cm-scm.cc
--- a/src/OPERATORS/op-cm-scm.cc
+++ b/src/OPERATORS/op-cm-scm.cc
@@ -45,38 +45,42 @@ DEFBINOP_OP (sub, complex_matrix, sparse
 
 DEFBINOP_OP (mul, complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
 		   const octave_sparse_complex_matrix&);
   
-  SparseType typ = v2.sparse_type ();
+  MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
 			    v2.sparse_complex_matrix_value (), typ);
 
-  v2.sparse_type (typ);
+  v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, 
 		   const octave_sparse_complex_matrix&);
+  MatrixType typ = v1.matrix_type ();
   
-  return xleftdiv (v1.complex_matrix_value (), 
-		   v2.complex_matrix_value ());
+  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
+				v2.complex_matrix_value (), typ);
+
+  v1.matrix_type (typ);
+  return ret;
 }
 
 DEFBINOP_FN (lt, complex_matrix, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, complex_matrix, sparse_complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, complex_matrix, sparse_complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, complex_matrix, sparse_complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, complex_matrix, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, complex_matrix, sparse_complex_matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-cm-sm.cc b/src/OPERATORS/op-cm-sm.cc
--- a/src/OPERATORS/op-cm-sm.cc
+++ b/src/OPERATORS/op-cm-sm.cc
@@ -44,37 +44,42 @@ DEFBINOP_OP (add, complex_matrix, sparse
 DEFBINOP_OP (sub, complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_sparse_matrix&);
   
-  SparseType typ = v2.sparse_type ();
+  MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
 			    v2.sparse_matrix_value (), typ);
 
-  v2.sparse_type (typ);
+  v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, 
 		   const octave_sparse_matrix&);
+  MatrixType typ = v1.matrix_type ();
   
-  return xleftdiv (v1.complex_matrix_value (), v2.matrix_value ());
+  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
+				v2.matrix_value (), typ);
+
+  v1.matrix_type (typ);
+  return ret;
 }
 
 DEFBINOP_FN (lt, complex_matrix, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, complex_matrix, sparse_matrix, mx_el_le)
 DEFBINOP_FN (eq, complex_matrix, sparse_matrix, mx_el_eq)
 DEFBINOP_FN (ge, complex_matrix, sparse_matrix, mx_el_ge)
 DEFBINOP_FN (gt, complex_matrix, sparse_matrix, mx_el_gt)
 DEFBINOP_FN (ne, complex_matrix, sparse_matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-cs-cm.cc b/src/OPERATORS/op-cs-cm.cc
--- a/src/OPERATORS/op-cs-cm.cc
+++ b/src/OPERATORS/op-cs-cm.cc
@@ -42,18 +42,22 @@ DEFNDBINOP_OP (sub, complex, complex_mat
 DEFNDBINOP_OP (mul, complex, complex_matrix, complex, complex_array, *)
 
 DEFBINOP (div, complex, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
+  MatrixType typ = v2.matrix_type ();
 
-  return octave_value (xdiv (m1, m2));
+  ComplexMatrix ret = xdiv (m1, m2, typ);
+
+  v2.matrix_type (typ);
+  return ret;
 }
 
 DEFBINOP_FN (pow, complex, complex_matrix, xpow)
 
 DEFBINOP (ldiv, complex, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
diff --git a/src/OPERATORS/op-cs-m.cc b/src/OPERATORS/op-cs-m.cc
--- a/src/OPERATORS/op-cs-m.cc
+++ b/src/OPERATORS/op-cs-m.cc
@@ -48,18 +48,22 @@ DEFNDBINOP_OP (sub, complex, matrix, com
 DEFNDBINOP_OP (mul, complex, matrix, complex, array, *)
 
 DEFBINOP (div, complex, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   Matrix m2 = v2.matrix_value ();
+  MatrixType typ = v2.matrix_type ();
 
-  return octave_value (xdiv (m1, m2));
+  ComplexMatrix ret = xdiv (m1, m2, typ);
+
+  v2.matrix_type (typ);
+  return ret;
 }
 
 DEFBINOP_FN (pow, complex, matrix, xpow)
 
 DEFBINOP (ldiv, complex, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
diff --git a/src/OPERATORS/op-cs-scm.cc b/src/OPERATORS/op-cs-scm.cc
--- a/src/OPERATORS/op-cs-scm.cc
+++ b/src/OPERATORS/op-cs-scm.cc
@@ -42,21 +42,21 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, complex, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
 
-  SparseType typ = v2.sparse_type ();
+  MatrixType typ = v2.matrix_type ();
   ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
   SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
   ComplexMatrix ret = xdiv (m1, m2, typ);
-  v2.sparse_type (typ);
+  v2.matrix_type (typ);
 
   return ret;
 }
 
 DEFBINOP (pow, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, 
 		   const octave_sparse_complex_matrix&);
diff --git a/src/OPERATORS/op-cs-sm.cc b/src/OPERATORS/op-cs-sm.cc
--- a/src/OPERATORS/op-cs-sm.cc
+++ b/src/OPERATORS/op-cs-sm.cc
@@ -44,21 +44,21 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, complex, sparse_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_matrix, *)
 
 DEFBINOP (div, complex, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
 
-  SparseType typ = v2.sparse_type ();
+  MatrixType typ = v2.matrix_type ();
   ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
   SparseMatrix m2 = v2.sparse_matrix_value ();
   ComplexMatrix ret = xdiv (m1, m2, typ);
-  v2.sparse_type (typ);
+  v2.matrix_type (typ);
 
   return ret;
 }
 
 DEFBINOP (pow, complex, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
   return xpow (v1.complex_value (), v2.matrix_value ());
diff --git a/src/OPERATORS/op-m-cm.cc b/src/OPERATORS/op-m-cm.cc
--- a/src/OPERATORS/op-m-cm.cc
+++ b/src/OPERATORS/op-m-cm.cc
@@ -41,25 +41,46 @@ 02110-1301, USA.
 #include "xpow.h"
 
 // matrix by complex matrix ops.
 
 DEFNDBINOP_OP (add, matrix, complex_matrix, array, complex_array, +)
 DEFNDBINOP_OP (sub, matrix, complex_matrix, array, complex_array, -)
 
 DEFBINOP_OP (mul, matrix, complex_matrix, *)
-DEFBINOP_FN (div, matrix, complex_matrix, xdiv)
+
+DEFBINOP (div, matrix, complex_matrix)
+{
+  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
+  MatrixType typ = v2.matrix_type ();
+  
+  ComplexMatrix ret = xdiv (v1.matrix_value (), 
+			    v2.complex_matrix_value (), typ);
+
+  v2.matrix_type (typ);
+  return ret;
+}
 
 DEFBINOPX (pow, matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
-DEFBINOP_FN (ldiv, matrix, complex_matrix, xleftdiv)
+DEFBINOP (ldiv, matrix, complex_matrix)
+{
+  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
+  MatrixType typ = v1.matrix_type ();
+  
+  ComplexMatrix ret = xleftdiv (v1.matrix_value (), 
+				v2.complex_matrix_value (), typ);
+
+  v1.matrix_type (typ);
+  return ret;
+}
 
 DEFNDBINOP_FN (lt, matrix, complex_matrix, array, complex_array, mx_el_lt)
 DEFNDBINOP_FN (le, matrix, complex_matrix, array, complex_array, mx_el_le)
 DEFNDBINOP_FN (eq, matrix, complex_matrix, array, complex_array, mx_el_eq)
 DEFNDBINOP_FN (ge, matrix, complex_matrix, array, complex_array, mx_el_ge)
 DEFNDBINOP_FN (gt, matrix, complex_matrix, array, complex_array, mx_el_gt)
 DEFNDBINOP_FN (ne, matrix, complex_matrix, array, complex_array, mx_el_ne)
 
diff --git a/src/OPERATORS/op-m-cs.cc b/src/OPERATORS/op-m-cs.cc
--- a/src/OPERATORS/op-m-cs.cc
+++ b/src/OPERATORS/op-m-cs.cc
@@ -62,18 +62,22 @@ DEFBINOP (div, matrix, complex)
 DEFBINOP_FN (pow, matrix, complex, xpow)
 
 DEFBINOP (ldiv, matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   Matrix m1 = v1.matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
+  MatrixType typ = v1.matrix_type ();
 
-  return octave_value (xleftdiv (m1, m2));
+  ComplexMatrix ret = xleftdiv (m1, m2, typ);
+
+  v1.matrix_type (typ);
+  return ret;
 }
 
 DEFNDBINOP_FN (lt, matrix, complex, array, complex, mx_el_lt)
 DEFNDBINOP_FN (le, matrix, complex, array, complex, mx_el_le)
 DEFNDBINOP_FN (eq, matrix, complex, array, complex, mx_el_eq)
 DEFNDBINOP_FN (ge, matrix, complex, array, complex, mx_el_ge)
 DEFNDBINOP_FN (gt, matrix, complex, array, complex, mx_el_gt)
 DEFNDBINOP_FN (ne, matrix, complex, array, complex, mx_el_ne)
diff --git a/src/OPERATORS/op-m-m.cc b/src/OPERATORS/op-m-m.cc
--- a/src/OPERATORS/op-m-m.cc
+++ b/src/OPERATORS/op-m-m.cc
@@ -57,25 +57,44 @@ DEFNCUNOP_METHOD (incr, matrix, incremen
 DEFNCUNOP_METHOD (decr, matrix, decrement)
 
 // matrix by matrix ops.
 
 DEFNDBINOP_OP (add, matrix, matrix, array, array, +)
 DEFNDBINOP_OP (sub, matrix, matrix, array, array, -)
 
 DEFBINOP_OP (mul, matrix, matrix, *)
-DEFBINOP_FN (div, matrix, matrix, xdiv)
+
+DEFBINOP (div, matrix, matrix)
+{
+  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+  MatrixType typ = v2.matrix_type ();
+  
+  Matrix ret = xdiv (v1.matrix_value (), v2.matrix_value (), typ);
+
+  v2.matrix_type (typ);
+  return ret;
+}
 
 DEFBINOPX (pow, matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
-DEFBINOP_FN (ldiv, matrix, matrix, xleftdiv)
+DEFBINOP (ldiv, matrix, matrix)
+{
+  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+  MatrixType typ = v1.matrix_type ();
+  
+  Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (), typ);
+
+  v1.matrix_type (typ);
+  return ret;
+}
 
 DEFNDBINOP_FN (lt, matrix, matrix, array, array, mx_el_lt)
 DEFNDBINOP_FN (le, matrix, matrix, array, array, mx_el_le)
 DEFNDBINOP_FN (eq, matrix, matrix, array, array, mx_el_eq)
 DEFNDBINOP_FN (ge, matrix, matrix, array, array, mx_el_ge)
 DEFNDBINOP_FN (gt, matrix, matrix, array, array, mx_el_gt)
 DEFNDBINOP_FN (ne, matrix, matrix, array, array, mx_el_ne)
 
diff --git a/src/OPERATORS/op-m-s.cc b/src/OPERATORS/op-m-s.cc
--- a/src/OPERATORS/op-m-s.cc
+++ b/src/OPERATORS/op-m-s.cc
@@ -56,18 +56,22 @@ DEFBINOP (div, matrix, scalar)
 DEFBINOP_FN (pow, matrix, scalar, xpow)
 
 DEFBINOP (ldiv, matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   Matrix m1 = v1.matrix_value ();
   Matrix m2 = v2.matrix_value ();
+  MatrixType typ = v1.matrix_type ();
 
-  return octave_value (xleftdiv (m1, m2));
+  Matrix ret = xleftdiv (m1, m2, typ);
+
+  v1.matrix_type (typ);
+  return ret;
 }
 
 DEFNDBINOP_FN (lt, matrix, scalar, array, scalar, mx_el_lt)
 DEFNDBINOP_FN (le, matrix, scalar, array, scalar, mx_el_le)
 DEFNDBINOP_FN (eq, matrix, scalar, array, scalar, mx_el_eq)
 DEFNDBINOP_FN (ge, matrix, scalar, array, scalar, mx_el_ge)
 DEFNDBINOP_FN (gt, matrix, scalar, array, scalar, mx_el_gt)
 DEFNDBINOP_FN (ne, matrix, scalar, array, scalar, mx_el_ne)
diff --git a/src/OPERATORS/op-m-scm.cc b/src/OPERATORS/op-m-scm.cc
--- a/src/OPERATORS/op-m-scm.cc
+++ b/src/OPERATORS/op-m-scm.cc
@@ -45,37 +45,42 @@ DEFBINOP_OP (add, matrix, sparse_complex
 DEFBINOP_OP (sub, matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_complex_matrix&);
 
-  SparseType typ = v2.sparse_type ();
+  MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.matrix_value (), 
 			    v2.sparse_complex_matrix_value (), typ);
 
-  v2.sparse_type (typ);
+  v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, 
 		   const octave_sparse_complex_matrix&);
+  MatrixType typ = v1.matrix_type ();
   
-  return xleftdiv (v1.matrix_value (), v2.complex_matrix_value ());
+  ComplexMatrix ret = xleftdiv (v1.matrix_value (), 
+				v2.complex_matrix_value (), typ);
+
+  v1.matrix_type (typ);
+  return ret;
 }
 
 DEFBINOP_FN (lt, matrix, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, matrix, sparse_complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, matrix, sparse_complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, matrix, sparse_complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, matrix, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, matrix, sparse_complex_matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-m-sm.cc b/src/OPERATORS/op-m-sm.cc
--- a/src/OPERATORS/op-m-sm.cc
+++ b/src/OPERATORS/op-m-sm.cc
@@ -43,35 +43,39 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_matrix, *)
 
 DEFBINOP (div, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
-  SparseType typ = v2.sparse_type ();
+  MatrixType typ = v2.matrix_type ();
 
   Matrix ret = xdiv (v1.matrix_value (), v2.sparse_matrix_value (), typ);
 
-  v2.sparse_type (typ);
+  v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
+  MatrixType typ = v1.matrix_type ();
   
-  return xleftdiv (v1.matrix_value (), v2.matrix_value ());
+  Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (), typ);
+
+  v1.matrix_type (typ);
+  return ret;
 }
 
 DEFBINOP_FN (lt, matrix, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, matrix, sparse_matrix, mx_el_le)
 DEFBINOP_FN (eq, matrix, sparse_matrix, mx_el_eq)
 DEFBINOP_FN (ge, matrix, sparse_matrix, mx_el_ge)
 DEFBINOP_FN (gt, matrix, sparse_matrix, mx_el_gt)
 DEFBINOP_FN (ne, matrix, sparse_matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-s-cm.cc b/src/OPERATORS/op-s-cm.cc
--- a/src/OPERATORS/op-s-cm.cc
+++ b/src/OPERATORS/op-s-cm.cc
@@ -48,18 +48,22 @@ DEFNDBINOP_OP (sub, scalar, complex_matr
 DEFNDBINOP_OP (mul, scalar, complex_matrix, scalar, complex_array, *)
 
 DEFBINOP (div, scalar, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   Matrix m1 = v1.matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
+  MatrixType typ = v2.matrix_type ();
 
-  return octave_value (xdiv (m1, m2));
+  ComplexMatrix ret = xdiv (m1, m2, typ);
+
+  v2.matrix_type (typ);
+  return ret;
 }
 
 DEFBINOP_FN (pow, scalar, complex_matrix, xpow)
 
 DEFBINOP (ldiv, scalar, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
diff --git a/src/OPERATORS/op-s-m.cc b/src/OPERATORS/op-s-m.cc
--- a/src/OPERATORS/op-s-m.cc
+++ b/src/OPERATORS/op-s-m.cc
@@ -42,18 +42,22 @@ DEFNDBINOP_OP (sub, scalar, matrix, scal
 DEFNDBINOP_OP (mul, scalar, matrix, scalar, array, *)
 
 DEFBINOP (div, scalar, matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   Matrix m1 = v1.matrix_value ();
   Matrix m2 = v2.matrix_value ();
+  MatrixType typ = v2.matrix_type ();
 
-  return octave_value (xdiv (m1, m2));
+  Matrix ret = xdiv (m1, m2, typ);
+
+  v2.matrix_type (typ);
+  return ret;
 }
 
 DEFBINOP_FN (pow, scalar, matrix, xpow)
 
 DEFBINOP (ldiv, scalar, matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
diff --git a/src/OPERATORS/op-s-scm.cc b/src/OPERATORS/op-s-scm.cc
--- a/src/OPERATORS/op-s-scm.cc
+++ b/src/OPERATORS/op-s-scm.cc
@@ -45,21 +45,21 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, scalar, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_complex_matrix, *)
 
 DEFBINOP (div, scalar, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_complex_matrix&);
 
-  SparseType typ = v2.sparse_type ();
+  MatrixType typ = v2.matrix_type ();
   Matrix m1 = Matrix (1, 1, v1.scalar_value ());
   SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
   ComplexMatrix ret = xdiv (m1, m2, typ);
-  v2.sparse_type (typ);
+  v2.matrix_type (typ);
 
   return ret;
 }
 
 DEFBINOP (pow, scalar, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, 
 		   const octave_sparse_complex_matrix&);
diff --git a/src/OPERATORS/op-s-sm.cc b/src/OPERATORS/op-s-sm.cc
--- a/src/OPERATORS/op-s-sm.cc
+++ b/src/OPERATORS/op-s-sm.cc
@@ -41,21 +41,21 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, scalar, sparse_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_matrix, *)
 
 DEFBINOP (div, scalar, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
 
-  SparseType typ = v2.sparse_type ();
+  MatrixType typ = v2.matrix_type ();
   Matrix m1 = Matrix (1, 1, v1.double_value ());
   SparseMatrix m2 = v2.sparse_matrix_value ();
   Matrix ret = xdiv (m1, m2, typ);
-  v2.sparse_type (typ);
+  v2.matrix_type (typ);
 
   return ret;
 }
 
 DEFBINOP (pow, scalar, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
   return xpow (v1.scalar_value (), v2.matrix_value ());
diff --git a/src/OPERATORS/op-scm-cm.cc b/src/OPERATORS/op-scm-cm.cc
--- a/src/OPERATORS/op-scm-cm.cc
+++ b/src/OPERATORS/op-scm-cm.cc
@@ -44,35 +44,40 @@ DEFBINOP_OP (add, sparse_complex_matrix,
 DEFBINOP_OP (sub, sparse_complex_matrix, complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
 		   const octave_complex_matrix&);
+  MatrixType typ = v2.matrix_type ();
   
-  return xdiv (v1.complex_matrix_value (), v2.complex_matrix_value ());
+  ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+			    v2.complex_matrix_value (), typ);
+
+  v2.matrix_type (typ);
+  return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_matrix&);
-  SparseType typ = v1.sparse_type ();
+  MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
 				v2.complex_matrix_value (), typ);
 
-  v1.sparse_type (typ);
+  v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, complex_matrix, mx_el_gt)
diff --git a/src/OPERATORS/op-scm-cs.cc b/src/OPERATORS/op-scm-cs.cc
--- a/src/OPERATORS/op-scm-cs.cc
+++ b/src/OPERATORS/op-scm-cs.cc
@@ -69,21 +69,21 @@ DEFBINOP (pow, sparse_complex_matrix, co
 		   const octave_complex&);
   return xpow (v1.complex_matrix_value (), v2.scalar_value ());
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex&);
 
-  SparseType typ = v1.sparse_type ();
+  MatrixType typ = v1.matrix_type ();
   SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
   ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
   ComplexMatrix ret = xleftdiv (m1, m2, typ);
-  v1.sparse_type (typ);
+  v1.matrix_type (typ);
 
   return ret;
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, complex, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, complex, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, complex, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, complex, mx_el_ge)
diff --git a/src/OPERATORS/op-scm-m.cc b/src/OPERATORS/op-scm-m.cc
--- a/src/OPERATORS/op-scm-m.cc
+++ b/src/OPERATORS/op-scm-m.cc
@@ -45,36 +45,41 @@ DEFBINOP_OP (add, sparse_complex_matrix,
 DEFBINOP_OP (sub, sparse_complex_matrix, matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
                    const octave_matrix&);
+  MatrixType typ = v2.matrix_type ();
   
-  return xdiv (v1.complex_matrix_value (), v2.matrix_value ());
+  ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+			    v2.matrix_value (), typ);
+
+  v2.matrix_type (typ);
+  return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_matrix&);
   
-  SparseType typ = v1.sparse_type ();
+  MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
 				v2.matrix_value (), typ);
 
-  v1.sparse_type (typ);
+  v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, matrix, mx_el_gt)
diff --git a/src/OPERATORS/op-scm-s.cc b/src/OPERATORS/op-scm-s.cc
--- a/src/OPERATORS/op-scm-s.cc
+++ b/src/OPERATORS/op-scm-s.cc
@@ -77,21 +77,21 @@ DEFBINOP (pow, sparse_complex_matrix, sc
   else
     return xpow (v1.complex_matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_scalar&);
 
-  SparseType typ = v1.sparse_type ();
+  MatrixType typ = v1.matrix_type ();
   SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
   Matrix m2 = Matrix (1, 1, v2.scalar_value ());
   ComplexMatrix ret = xleftdiv (m1, m2, typ);
-  v1.sparse_type (typ);
+  v1.matrix_type (typ);
 
   return ret;
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, scalar, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, scalar, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, scalar, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, scalar, mx_el_ge)
diff --git a/src/OPERATORS/op-scm-scm.cc b/src/OPERATORS/op-scm-scm.cc
--- a/src/OPERATORS/op-scm-scm.cc
+++ b/src/OPERATORS/op-scm-scm.cc
@@ -54,25 +54,25 @@ DEFUNOP_OP (not, sparse_complex_matrix, 
 DEFUNOP_OP (uplus, sparse_complex_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_complex_matrix, -)
 
 DEFUNOP (transpose, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
   return octave_value 
     (v.sparse_complex_matrix_value().transpose (),
-     v.sparse_type ().transpose ());
+     v.matrix_type ().transpose ());
 }
 
 DEFUNOP (hermitian, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
   return octave_value 
     (v.sparse_complex_matrix_value().hermitian (),
-     v.sparse_type ().transpose ());
+     v.matrix_type ().transpose ());
 }
 
 #if 0
 DEFUNOP (incr, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
 
   return octave_value (v.complex_matrix_value () .increment ());
@@ -92,40 +92,40 @@ DEFBINOP_OP (add, sparse_complex_matrix,
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
 		   const octave_sparse_complex_matrix&);
-  SparseType typ = v2.sparse_type ();
+  MatrixType typ = v2.matrix_type ();
   SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
 				  v2.sparse_complex_matrix_value (), typ);
   
-  v2.sparse_type (typ);
+  v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
 		   const octave_sparse_complex_matrix&);
-  SparseType typ = v1.sparse_type ();
+  MatrixType typ = v1.matrix_type ();
 
   SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
 				      v2.sparse_complex_matrix_value (), typ);
 
-  v1.sparse_type (typ);
+  v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, sparse_complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, sparse_complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, sparse_complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, sparse_complex_matrix, mx_el_gt)
diff --git a/src/OPERATORS/op-scm-sm.cc b/src/OPERATORS/op-scm-sm.cc
--- a/src/OPERATORS/op-scm-sm.cc
+++ b/src/OPERATORS/op-scm-sm.cc
@@ -42,39 +42,39 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
-  SparseType typ = v2.sparse_type ();
+  MatrixType typ = v2.matrix_type ();
   SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
 				  v2.sparse_matrix_value (), typ);
   
-  v2.sparse_type (typ);
+  v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
-  SparseType typ = v1.sparse_type ();
+  MatrixType typ = v1.matrix_type ();
 
   SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
 				      v2.sparse_matrix_value (), typ);
 
-  v1.sparse_type (typ);
+  v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, sparse_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, sparse_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, sparse_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, sparse_matrix, mx_el_gt)
diff --git a/src/OPERATORS/op-sm-cm.cc b/src/OPERATORS/op-sm-cm.cc
--- a/src/OPERATORS/op-sm-cm.cc
+++ b/src/OPERATORS/op-sm-cm.cc
@@ -44,35 +44,40 @@ DEFBINOP_OP (add, sparse_matrix, complex
 DEFBINOP_OP (sub, sparse_matrix, complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, 
 		   const octave_complex_matrix&);
+  MatrixType typ = v2.matrix_type ();
   
-  return xdiv (v1.matrix_value (), v2.complex_matrix_value ());
+  ComplexMatrix ret = xdiv (v1.matrix_value (), 
+			    v2.complex_matrix_value (), typ);
+
+  v2.matrix_type (typ);
+  return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_matrix&);
-  SparseType typ = v1.sparse_type ();
+  MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
 				v2.complex_matrix_value (), typ);
 
-  v1.sparse_type (typ);
+  v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (lt, sparse_matrix, complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, complex_matrix, mx_el_gt)
diff --git a/src/OPERATORS/op-sm-cs.cc b/src/OPERATORS/op-sm-cs.cc
--- a/src/OPERATORS/op-sm-cs.cc
+++ b/src/OPERATORS/op-sm-cs.cc
@@ -69,21 +69,21 @@ DEFBINOP (pow, sparse_matrix, complex)
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
   return xpow (v1.matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
 
-  SparseType typ = v1.sparse_type ();
+  MatrixType typ = v1.matrix_type ();
   SparseMatrix m1 = v1.sparse_matrix_value ();
   ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
   ComplexMatrix ret = xleftdiv (m1, m2, typ);
-  v1.sparse_type (typ);
+  v1.matrix_type (typ);
 
   return ret;
 }
 
 DEFBINOP_FN (lt, sparse_matrix, complex, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, complex, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, complex, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, complex, mx_el_ge)
diff --git a/src/OPERATORS/op-sm-m.cc b/src/OPERATORS/op-sm-m.cc
--- a/src/OPERATORS/op-sm-m.cc
+++ b/src/OPERATORS/op-sm-m.cc
@@ -43,35 +43,39 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, sparse_matrix, matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, matrix, *)
 
 DEFBINOP (div, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
+  MatrixType typ = v2.matrix_type ();
   
-  return xdiv (v1.matrix_value (), v2.matrix_value ());
+  Matrix ret = xdiv (v1.matrix_value (), v2.matrix_value (), typ);
+
+  v2.matrix_type (typ);
+  return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
-  SparseType typ = v1.sparse_type ();
+  MatrixType typ = v1.matrix_type ();
 
   Matrix ret = xleftdiv (v1.sparse_matrix_value (), 
 			       v2.matrix_value (), typ);
 
-  v1.sparse_type (typ);
+  v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (lt, sparse_matrix, matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, matrix, mx_el_gt)
diff --git a/src/OPERATORS/op-sm-s.cc b/src/OPERATORS/op-sm-s.cc
--- a/src/OPERATORS/op-sm-s.cc
+++ b/src/OPERATORS/op-sm-s.cc
@@ -71,21 +71,21 @@ DEFBINOP (pow, sparse_matrix, scalar)
   else
     return xpow (v1.matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
 
-  SparseType typ = v1.sparse_type ();
+  MatrixType typ = v1.matrix_type ();
   SparseMatrix m1 = v1.sparse_matrix_value ();
   Matrix m2 = Matrix (1, 1, v2.scalar_value ());
   Matrix ret = xleftdiv (m1, m2, typ);
-  v1.sparse_type (typ);
+  v1.matrix_type (typ);
 
   return ret;
 }
 
 DEFBINOP_FN (lt, sparse_matrix, scalar, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, scalar, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, scalar, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, scalar, mx_el_ge)
diff --git a/src/OPERATORS/op-sm-scm.cc b/src/OPERATORS/op-sm-scm.cc
--- a/src/OPERATORS/op-sm-scm.cc
+++ b/src/OPERATORS/op-sm-scm.cc
@@ -42,39 +42,39 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, sparse_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
-  SparseType typ = v2.sparse_type ();
+  MatrixType typ = v2.matrix_type ();
   SparseComplexMatrix ret = xdiv (v1.sparse_matrix_value (), 
 				  v2.sparse_complex_matrix_value (), typ);
   
-  v2.sparse_type (typ);
+  v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
-  SparseType typ = v1.sparse_type ();
+  MatrixType typ = v1.matrix_type ();
 
   SparseComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
 				      v2.sparse_complex_matrix_value (), typ);
 
-  v1.sparse_type (typ);
+  v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (lt, sparse_matrix, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, sparse_complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, sparse_complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, sparse_complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, sparse_complex_matrix, mx_el_gt)
diff --git a/src/OPERATORS/op-sm-sm.cc b/src/OPERATORS/op-sm-sm.cc
--- a/src/OPERATORS/op-sm-sm.cc
+++ b/src/OPERATORS/op-sm-sm.cc
@@ -40,51 +40,51 @@ Boston, MA 02110-1301, USA.
 DEFUNOP_OP (not, sparse_matrix, !)
 DEFUNOP_OP (uplus, sparse_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_matrix, -)
 
 DEFUNOP (transpose, sparse_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_matrix&);
   return octave_value (v.sparse_matrix_value().transpose (),
-		       v.sparse_type ().transpose ());
+		       v.matrix_type ().transpose ());
 }
 
 // sparse matrix by sparse matrix ops.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, sparse_matrix, -)
 DEFBINOP_OP (mul, sparse_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
-  SparseType typ = v2.sparse_type ();
+  MatrixType typ = v2.matrix_type ();
   SparseMatrix ret = xdiv (v1.sparse_matrix_value (), 
 			   v2.sparse_matrix_value (), typ);
   
-  v2.sparse_type (typ);
+  v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
-  SparseType typ = v1.sparse_type ();
+  MatrixType typ = v1.matrix_type ();
 
   SparseMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
 			       v2.sparse_matrix_value (), typ);
 
-  v1.sparse_type (typ);
+  v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (lt, sparse_matrix, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, sparse_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, sparse_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, sparse_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, sparse_matrix, mx_el_gt)
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -32,40 +32,49 @@ 02110-1301, USA.
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "error.h"
 #include "oct-obj.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
+#include "MatrixType.h"
+
 class Octave_map;
 
 class tree_walker;
 
 // Real matrix values.
 
 template <class MT>
 class
 octave_base_matrix : public octave_base_value
 {
 public:
 
   octave_base_matrix (void)
-    : octave_base_value () { }
+    : octave_base_value (), typ (MatrixType ()) { }
 
   octave_base_matrix (const MT& m)
-    : octave_base_value (), matrix (m)
+    : octave_base_value (), matrix (m), typ (MatrixType ())
+  {
+    if (matrix.ndims () == 0)
+      matrix.resize (dim_vector (0, 0));
+  }
+
+  octave_base_matrix (const MT& m, const MatrixType& t)
+    : octave_base_value (), matrix (m), typ (t)
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
   octave_base_matrix (const octave_base_matrix& m)
-    : octave_base_value (), matrix (m.matrix) { }
+    : octave_base_value (), matrix (m.matrix), typ (m.typ) { }
 
   ~octave_base_matrix (void) { }
 
   octave_base_value *clone (void) const { return new octave_base_matrix (*this); }
   octave_base_value *empty_clone (void) const { return new octave_base_matrix (); }
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
@@ -102,16 +111,20 @@ public:
   octave_value permute (const Array<int>& vec, bool inv = false) const
     { return MT (matrix.permute (vec, inv)); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   octave_value all (int dim = 0) const { return matrix.all (dim); }
   octave_value any (int dim = 0) const { return matrix.any (dim); }
 
+  MatrixType matrix_type (void) const { return typ; }
+  MatrixType matrix_type (const MatrixType& _typ) const
+    { MatrixType ret = typ; typ = _typ; return ret; }
+
   bool is_matrix_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
@@ -121,16 +134,18 @@ public:
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
 protected:
 
   MT matrix;
+
+  mutable MatrixType typ;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -31,40 +31,40 @@ Boston, MA 02110-1301, USA.
 #include "str-vec.h"
 
 #include "error.h"
 #include "oct-obj.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 #include "boolSparse.h"
-#include "SparseType.h"
+#include "MatrixType.h"
 
 class Octave_map;
 
 class tree_walker;
 
 class octave_sparse_bool_matrix;
 
 template <class T>
 class
 octave_base_sparse : public octave_base_value
 {
  public:
  
-  octave_base_sparse (void) : octave_base_value (), typ (SparseType ()) { }
+  octave_base_sparse (void) : octave_base_value (), typ (MatrixType ()) { }
 
   octave_base_sparse (const T& a) : octave_base_value (), matrix (a),
-				    typ (SparseType ())
+				    typ (MatrixType ())
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
-  octave_base_sparse (const T& a, const SparseType& t) : octave_base_value (), 
+  octave_base_sparse (const T& a, const MatrixType& t) : octave_base_value (), 
 				matrix (a), typ (t)
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
   octave_base_sparse (const octave_base_sparse& a) : 
     octave_base_value (), matrix (a.matrix), typ (a.typ) { }
@@ -112,19 +112,19 @@ octave_base_sparse : public octave_base_
   octave_value permute (const Array<int>& vec, bool inv = false) const
     { return T (matrix.permute (vec, inv)); }
 
   octave_value resize (const dim_vector& dv, bool = false) const;
 
   octave_value all (int dim = 0) const { return matrix.all (dim); }
   octave_value any (int dim = 0) const { return matrix.any (dim); }
 
-  SparseType sparse_type (void) const { return typ; }
-  SparseType sparse_type (const SparseType& _typ) const
-    { SparseType ret = typ; typ = _typ; return ret; }
+  MatrixType matrix_type (void) const { return typ; }
+  MatrixType matrix_type (const MatrixType& _typ) const
+    { MatrixType ret = typ; typ = _typ; return ret; }
 
   bool is_matrix_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
 
   bool is_sparse_type (void) const { return true; }
 
   bool is_defined (void) const { return true; }
@@ -147,17 +147,17 @@ octave_base_sparse : public octave_base_
 		 bool strip_nan_and_inf);
 
   bool load_ascii (std::istream& is);
 
 protected:
 
   T matrix;
 
-  mutable SparseType typ;
+  mutable MatrixType typ;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -245,16 +245,30 @@ octave_base_value::permute (const Array<
 
 octave_value
 octave_base_value::resize (const dim_vector&, bool) const
 {
   gripe_wrong_type_arg ("octave_base_value::resize ()", type_name ());
   return octave_value ();
 }
 
+MatrixType 
+octave_base_value::matrix_type (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::matrix_type ()", type_name ());
+  return MatrixType ();
+}
+
+MatrixType 
+octave_base_value::matrix_type (const MatrixType&) const
+{
+  gripe_wrong_type_arg ("octave_base_value::matrix_type ()", type_name ());
+  return MatrixType ();
+}
+
 octave_value
 octave_base_value::all (int) const
 {
   return 0.0;
 }
 
 octave_value
 octave_base_value::any (int) const
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -178,16 +178,20 @@ public:
   virtual octave_idx_type nzmax (void) const;
 
   virtual octave_value reshape (const dim_vector&) const;
 
   virtual octave_value permute (const Array<int>& vec, bool = false) const;
 
   virtual octave_value resize (const dim_vector&, bool fill = false) const;
 
+  virtual MatrixType matrix_type (void) const;
+
+  virtual MatrixType matrix_type (const MatrixType& typ) const;
+
   virtual bool is_defined (void) const { return false; }
 
   bool is_empty (void) const { return numel () == 0; }
 
   virtual bool is_cell (void) const { return false; }
 
   virtual bool is_real_scalar (void) const { return false; }
 
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -33,16 +33,18 @@ 02110-1301, USA.
 #include "oct-alloc.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-typeinfo.h"
 
+#include "MatrixType.h"
+
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
 // Character matrix values.
 
 class
@@ -54,16 +56,19 @@ public:
     : octave_base_matrix<boolNDArray> () { }
 
   octave_bool_matrix (const boolNDArray& bnda)
     : octave_base_matrix<boolNDArray> (bnda) { }
 
   octave_bool_matrix (const boolMatrix& bm)
     : octave_base_matrix<boolNDArray> (bm) { }
 
+  octave_bool_matrix (const boolMatrix& bm, const MatrixType& t)
+    : octave_base_matrix<boolNDArray> (bm, t) { }
+
   octave_bool_matrix (const Array2<bool>& a)
     : octave_base_matrix<boolNDArray> (a) { }
 
   octave_bool_matrix (const octave_bool_matrix& bm)
     : octave_base_matrix<boolNDArray> (bm) { }
 
   ~octave_bool_matrix (void) { }
 
diff --git a/src/ov-bool-sparse.h b/src/ov-bool-sparse.h
--- a/src/ov-bool-sparse.h
+++ b/src/ov-bool-sparse.h
@@ -54,17 +54,17 @@ public:
 
   octave_sparse_bool_matrix (void)
     : octave_base_sparse<SparseBoolMatrix> () { }
 
   octave_sparse_bool_matrix (const SparseBoolMatrix& bnda)
     : octave_base_sparse<SparseBoolMatrix> (bnda) { }
 
   octave_sparse_bool_matrix (const SparseBoolMatrix& bnda,
-			     const SparseType& t)
+			     const MatrixType& t)
     : octave_base_sparse<SparseBoolMatrix> (bnda, t) { }
 
   octave_sparse_bool_matrix (const boolNDArray& m)
     : octave_base_sparse<SparseBoolMatrix> (SparseBoolMatrix (m)) { }
 
   octave_sparse_bool_matrix (const boolMatrix& m)
     : octave_base_sparse<SparseBoolMatrix> (SparseBoolMatrix (m)) { }
 
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -34,16 +34,18 @@ 02110-1301, USA.
 #include "str-vec.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-typeinfo.h"
 
+#include "MatrixType.h"
+
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
 // Complex matrix values.
 
 class
@@ -55,16 +57,19 @@ public:
     : octave_base_matrix<ComplexNDArray> () { }
 
   octave_complex_matrix (const ComplexNDArray& m)
     : octave_base_matrix<ComplexNDArray> (m) { }
 
   octave_complex_matrix (const ComplexMatrix& m)
     : octave_base_matrix<ComplexNDArray> (m) { }
 
+  octave_complex_matrix (const ComplexMatrix& m, const MatrixType& t)
+    : octave_base_matrix<ComplexNDArray> (m, t) { }
+
   octave_complex_matrix (const ArrayN<Complex>& m)
     : octave_base_matrix<ComplexNDArray> (ComplexNDArray (m)) { }
 
   octave_complex_matrix (const ComplexDiagMatrix& d)
     : octave_base_matrix<ComplexNDArray> (ComplexMatrix (d)) { }
 
   octave_complex_matrix (const ComplexRowVector& v)
     : octave_base_matrix<ComplexNDArray> (ComplexMatrix (v)) { }
diff --git a/src/ov-cx-sparse.h b/src/ov-cx-sparse.h
--- a/src/ov-cx-sparse.h
+++ b/src/ov-cx-sparse.h
@@ -61,17 +61,17 @@ public:
 
   octave_sparse_complex_matrix (const ComplexMatrix& m)
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m)) { }
 
   octave_sparse_complex_matrix (const SparseComplexMatrix& m)
     : octave_base_sparse<SparseComplexMatrix> (m) { }
 
   octave_sparse_complex_matrix (const SparseComplexMatrix& m, 
-				const SparseType &t)
+				const MatrixType &t)
     : octave_base_sparse<SparseComplexMatrix> (m, t) { }
 
   octave_sparse_complex_matrix (const MSparse<Complex>& m)
     : octave_base_sparse<SparseComplexMatrix> (m) { }
 
   octave_sparse_complex_matrix (const octave_sparse_complex_matrix& cm)
     : octave_base_sparse<SparseComplexMatrix> (cm) { }
 
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -35,16 +35,18 @@ 02110-1301, USA.
 #include "str-vec.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-typeinfo.h"
 
+#include "MatrixType.h"
+
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
 // Real matrix values.
 
 class
@@ -53,16 +55,19 @@ octave_matrix : public octave_base_matri
 public:
 
   octave_matrix (void)
     : octave_base_matrix<NDArray> () { }
 
   octave_matrix (const Matrix& m)
     : octave_base_matrix<NDArray> (m) { }
 
+  octave_matrix (const Matrix& m, const MatrixType& t)
+    : octave_base_matrix<NDArray> (m, t) { }
+
   octave_matrix (const NDArray& nda)
     : octave_base_matrix<NDArray> (nda) { }
 
   octave_matrix (const ArrayN<double>& m)
     : octave_base_matrix<NDArray> (NDArray (m)) { }
 
   octave_matrix (const DiagMatrix& d)
     : octave_base_matrix<NDArray> (Matrix (d)) { }
diff --git a/src/ov-re-sparse.h b/src/ov-re-sparse.h
--- a/src/ov-re-sparse.h
+++ b/src/ov-re-sparse.h
@@ -34,17 +34,17 @@ Boston, MA 02110-1301, USA.
 #include "str-vec.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 #include "dSparse.h"
-#include "SparseType.h"
+#include "MatrixType.h"
 #include "ov-base-sparse.h"
 #include "ov-bool-sparse.h"
 #include "ov-cx-sparse.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
@@ -61,17 +61,17 @@ public:
     : octave_base_sparse<SparseMatrix> (SparseMatrix (m)) { }
 
   octave_sparse_matrix (const NDArray& m)
     : octave_base_sparse<SparseMatrix> (SparseMatrix (m)) { }
 
   octave_sparse_matrix (const SparseMatrix& m)
     : octave_base_sparse<SparseMatrix> (m) { }
 
-  octave_sparse_matrix (const SparseMatrix& m, const SparseType& t)
+  octave_sparse_matrix (const SparseMatrix& m, const MatrixType& t)
     : octave_base_sparse<SparseMatrix> (m, t) { }
 
   octave_sparse_matrix (const MSparse<double>& m)
     : octave_base_sparse<SparseMatrix> (m) { }
     
   octave_sparse_matrix (const octave_sparse_matrix& m)
     : octave_base_sparse<SparseMatrix> (m) { }
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -368,18 +368,18 @@ octave_value::octave_value (const Cell& 
 
 octave_value::octave_value (const ArrayN<octave_value>& a, bool is_csl)
   : rep (is_csl
 	 ? dynamic_cast<octave_base_value *> (new octave_cs_list (Cell (a)))
 	 : dynamic_cast<octave_base_value *> (new octave_cell (Cell (a))))
 {
 }
 
-octave_value::octave_value (const Matrix& m)
-  : rep (new octave_matrix (m))
+octave_value::octave_value (const Matrix& m, const MatrixType& t)
+  : rep (new octave_matrix (m, t))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const NDArray& a)
   : rep (new octave_matrix (a))
 {
   maybe_mutate ();
@@ -410,18 +410,18 @@ octave_value::octave_value (const Column
 }
 
 octave_value::octave_value (const Complex& C)
   : rep (new octave_complex (C))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ComplexMatrix& m)
-  : rep (new octave_complex_matrix (m))
+octave_value::octave_value (const ComplexMatrix& m, const MatrixType& t)
+  : rep (new octave_complex_matrix (m, t))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const ComplexNDArray& a)
   : rep (new octave_complex_matrix (a))
 {
   maybe_mutate ();
@@ -451,18 +451,18 @@ octave_value::octave_value (const Comple
   maybe_mutate ();
 }
 
 octave_value::octave_value (bool b)
   : rep (new octave_bool (b))
 {
 }
 
-octave_value::octave_value (const boolMatrix& bm)
-  : rep (new octave_bool_matrix (bm))
+octave_value::octave_value (const boolMatrix& bm, const MatrixType& t)
+  : rep (new octave_bool_matrix (bm, t))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const boolNDArray& bnda)
   : rep (new octave_bool_matrix (bnda))
 {
   maybe_mutate ();
@@ -525,29 +525,29 @@ octave_value::octave_value (const ArrayN
 	 ? (type == '"'
 	    ? new octave_char_matrix_dq_str (chm)
 	    : new octave_char_matrix_sq_str (chm))
 	 : new octave_char_matrix (chm))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const SparseMatrix& m, const SparseType &t)
+octave_value::octave_value (const SparseMatrix& m, const MatrixType &t)
   : rep (new octave_sparse_matrix (m, t))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const SparseComplexMatrix& m, const SparseType &t)
+octave_value::octave_value (const SparseComplexMatrix& m, const MatrixType &t)
   : rep (new octave_sparse_complex_matrix (m, t))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const SparseBoolMatrix& bm, const SparseType &t)
+octave_value::octave_value (const SparseBoolMatrix& bm, const MatrixType &t)
   : rep (new octave_sparse_bool_matrix (bm, t))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const octave_int8& i)
   : rep (new octave_int8_scalar (i))
 {
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -35,17 +35,16 @@ 02110-1301, USA.
 #endif
 
 #include "Range.h"
 #include "idx-vector.h"
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "oct-time.h"
 #include "str-vec.h"
-#include "SparseType.h"
 
 class Cell;
 class streamoff_array;
 class Octave_map;
 class octave_stream;
 class octave_streamoff;
 class octave_function;
 class octave_user_function;
@@ -158,47 +157,47 @@ public:
 #if defined (HAVE_UNSIGNED_LONG_LONG_INT)
   octave_value (unsigned long long int i);
 #endif
 
   octave_value (octave_time t);
   octave_value (double d);
   octave_value (const ArrayN<octave_value>& a, bool is_cs_list = false);
   octave_value (const Cell& c, bool is_cs_list = false);
-  octave_value (const Matrix& m);
+  octave_value (const Matrix& m, const MatrixType& t = MatrixType());
   octave_value (const NDArray& nda);
   octave_value (const ArrayN<double>& m);
   octave_value (const DiagMatrix& d);
   octave_value (const RowVector& v);
   octave_value (const ColumnVector& v);
   octave_value (const Complex& C);
-  octave_value (const ComplexMatrix& m);
+  octave_value (const ComplexMatrix& m, const MatrixType& t = MatrixType());
   octave_value (const ComplexNDArray& cnda);
   octave_value (const ArrayN<Complex>& m);
   octave_value (const ComplexDiagMatrix& d);
   octave_value (const ComplexRowVector& v);
   octave_value (const ComplexColumnVector& v);
   octave_value (bool b);
-  octave_value (const boolMatrix& bm);
+  octave_value (const boolMatrix& bm, const MatrixType& t = MatrixType());
   octave_value (const boolNDArray& bnda);
   octave_value (char c, char type = '"');
   octave_value (const char *s, char type = '"');
   octave_value (const std::string& s, char type = '"');
   octave_value (const string_vector& s, char type = '"');
   octave_value (const charMatrix& chm, bool is_string = false,
 		char type = '"');
   octave_value (const charNDArray& chnda, bool is_string = false,
 		char type = '"');
   octave_value (const ArrayN<char>& chnda, bool is_string = false,
 		char type = '"');
-  octave_value (const SparseMatrix& m, const SparseType& t = SparseType ());
+  octave_value (const SparseMatrix& m, const MatrixType& t = MatrixType ());
   octave_value (const SparseComplexMatrix& m, 
-		const SparseType& t = SparseType ());
+		const MatrixType& t = MatrixType ());
   octave_value (const SparseBoolMatrix& bm, 
-		const SparseType& t = SparseType ());
+		const MatrixType& t = MatrixType ());
   octave_value (const octave_int8& i);
   octave_value (const octave_int16& i);
   octave_value (const octave_int32& i);
   octave_value (const octave_int64& i);
   octave_value (const octave_uint8& i);
   octave_value (const octave_uint16& i);
   octave_value (const octave_uint32& i);
   octave_value (const octave_uint64& i);
@@ -359,16 +358,22 @@ public:
     { return rep->permute (vec, inv); }
 
   octave_value ipermute (const Array<int>& vec) const
     { return rep->permute (vec, true); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const
     { return rep->resize (dv, fill);}
 
+  MatrixType matrix_type (void) const
+  { return rep->matrix_type (); }
+
+  MatrixType matrix_type (const MatrixType& typ) const
+  { return rep->matrix_type (typ); }
+
   // Does this constant have a type?  Both of these are provided since
   // it is sometimes more natural to write is_undefined() instead of
   // ! is_defined().
 
   bool is_defined (void) const
     { return rep->is_defined (); }
 
   bool is_undefined (void) const
diff --git a/src/sparse-xdiv.cc b/src/sparse-xdiv.cc
--- a/src/sparse-xdiv.cc
+++ b/src/sparse-xdiv.cc
@@ -111,164 +111,164 @@ INSTANTIATE_MX_DIV_CONFORM (ComplexMatri
 //                   +--   +---+----+----+----+
 //   sparse matrix         | 1 |  3 |  5 |  7 |
 //                         +---+----+----+----+
 //   sparse complex_matrix | 2 |  4 |  6 |  8 |
 //                         +---+----+----+----+
 
 // -*- 1 -*-
 Matrix
-xdiv (const Matrix& a, const SparseMatrix& b, SparseType &typ)
+xdiv (const Matrix& a, const SparseMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return Matrix ();
 
   Matrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
-  SparseType btyp = typ.transpose ();
+  MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
   double rcond = 0.0;
   Matrix result = btmp.solve (btyp, atmp, info, rcond, 
 			      solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.transpose ();
 }
 
 // -*- 2 -*-
 ComplexMatrix
-xdiv (const Matrix& a, const SparseComplexMatrix& b, SparseType &typ)
+xdiv (const Matrix& a, const SparseComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   Matrix atmp = a.transpose ();
   SparseComplexMatrix btmp = b.hermitian ();
-  SparseType btyp = typ.transpose ();
+  MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
   double rcond = 0.0;
   ComplexMatrix result
     = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 3 -*-
 ComplexMatrix
-xdiv (const ComplexMatrix& a, const SparseMatrix& b, SparseType &typ)
+xdiv (const ComplexMatrix& a, const SparseMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   SparseMatrix btmp = b.transpose ();
-  SparseType btyp = typ.transpose ();
+  MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
   double rcond = 0.0;
   ComplexMatrix result
     = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 4 -*-
 ComplexMatrix
-xdiv (const ComplexMatrix& a, const SparseComplexMatrix& b, SparseType &typ)
+xdiv (const ComplexMatrix& a, const SparseComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   SparseComplexMatrix btmp = b.hermitian ();
-  SparseType btyp = typ.transpose ();
+  MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
   double rcond = 0.0;
   ComplexMatrix result
     = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 5 -*-
 SparseMatrix
-xdiv (const SparseMatrix& a, const SparseMatrix& b, SparseType &typ)
+xdiv (const SparseMatrix& a, const SparseMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseMatrix ();
 
   SparseMatrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
-  SparseType btyp = typ.transpose ();
+  MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
   double rcond = 0.0;
   SparseMatrix result = btmp.solve (btyp, atmp, info, rcond, 
 				    solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.transpose ();
 }
 
 // -*- 6 -*-
 SparseComplexMatrix
-xdiv (const SparseMatrix& a, const SparseComplexMatrix& b, SparseType &typ)
+xdiv (const SparseMatrix& a, const SparseComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseMatrix atmp = a.transpose ();
   SparseComplexMatrix btmp = b.hermitian ();
-  SparseType btyp = typ.transpose ();
+  MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
   double rcond = 0.0;
   SparseComplexMatrix result
     = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 7 -*-
 SparseComplexMatrix
-xdiv (const SparseComplexMatrix& a, const SparseMatrix& b, SparseType &typ)
+xdiv (const SparseComplexMatrix& a, const SparseMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseComplexMatrix atmp = a.hermitian ();
   SparseMatrix btmp = b.transpose ();
-  SparseType btyp = typ.transpose ();
+  MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
   double rcond = 0.0;
   SparseComplexMatrix result
     = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
-xdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b, SparseType &typ)
+xdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseComplexMatrix atmp = a.hermitian ();
   SparseComplexMatrix btmp = b.hermitian ();
-  SparseType btyp = typ.transpose ();
+  MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
   double rcond = 0.0;
   SparseComplexMatrix result
     = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.hermitian ();
@@ -372,102 +372,102 @@ x_el_div (const Complex a, const SparseC
 //                         +---+----+
 //   sparse matrix         | 3 |  7 |
 //                         +---+----+
 //   sparse complex_matrix | 4 |  8 |
 //                         +---+----+
 
 // -*- 1 -*-
 Matrix
-xleftdiv (const SparseMatrix& a, const Matrix& b, SparseType &typ)
+xleftdiv (const SparseMatrix& a, const Matrix& b, MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return Matrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 2 -*-
 ComplexMatrix
-xleftdiv (const SparseMatrix& a, const ComplexMatrix& b, SparseType &typ)
+xleftdiv (const SparseMatrix& a, const ComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 3 -*-
 SparseMatrix
-xleftdiv (const SparseMatrix& a, const SparseMatrix& b, SparseType &typ)
+xleftdiv (const SparseMatrix& a, const SparseMatrix& b, MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 4 -*-
 SparseComplexMatrix
-xleftdiv (const SparseMatrix& a, const SparseComplexMatrix& b, SparseType &typ)
+xleftdiv (const SparseMatrix& a, const SparseComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 5 -*-
 ComplexMatrix
-xleftdiv (const SparseComplexMatrix& a, const Matrix& b, SparseType &typ)
+xleftdiv (const SparseComplexMatrix& a, const Matrix& b, MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 6 -*-
 ComplexMatrix
-xleftdiv (const SparseComplexMatrix& a, const ComplexMatrix& b, SparseType &typ)
+xleftdiv (const SparseComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 7 -*-
 SparseComplexMatrix
-xleftdiv (const SparseComplexMatrix& a, const SparseMatrix& b, SparseType &typ)
+xleftdiv (const SparseComplexMatrix& a, const SparseMatrix& b, MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
 xleftdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b, 
-	  SparseType &typ)
+	  MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
diff --git a/src/sparse-xdiv.h b/src/sparse-xdiv.h
--- a/src/sparse-xdiv.h
+++ b/src/sparse-xdiv.h
@@ -19,61 +19,61 @@ Free Software Foundation, Inc., 51 Frank
 Boston, MA 02110-1301, USA.
 
 */
 
 #if !defined (octave_sparse_xdiv_h)
 #define octave_sparse_xdiv_h 1
 
 #include "oct-cmplx.h"
-#include "SparseType.h"
+#include "MatrixType.h"
 
 class SparseMatrix;
 class SparseComplexMatrix;
 
-extern Matrix xdiv (const Matrix& a, const SparseMatrix& b, SparseType &typ);
+extern Matrix xdiv (const Matrix& a, const SparseMatrix& b, MatrixType &typ);
 extern ComplexMatrix xdiv (const Matrix& a, const SparseComplexMatrix& b,
-			   SparseType &typ);
+			   MatrixType &typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const SparseMatrix& b,
-			   SparseType &typ);
+			   MatrixType &typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, 
-			   const SparseComplexMatrix& b, SparseType &typ);
+			   const SparseComplexMatrix& b, MatrixType &typ);
 
 extern SparseMatrix xdiv (const SparseMatrix& a, const SparseMatrix& b,
-			  SparseType &typ);
+			  MatrixType &typ);
 extern SparseComplexMatrix xdiv (const SparseMatrix& a, 
-				 const SparseComplexMatrix& b, SparseType &typ);
+				 const SparseComplexMatrix& b, MatrixType &typ);
 extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a, 
-				 const SparseMatrix& b, SparseType &typ);
+				 const SparseMatrix& b, MatrixType &typ);
 extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a, 
-				 const SparseComplexMatrix& b, SparseType &typ);
+				 const SparseComplexMatrix& b, MatrixType &typ);
 
 extern Matrix x_el_div (double a, const SparseMatrix& b);
 extern ComplexMatrix x_el_div (double a, const SparseComplexMatrix& b);
 extern ComplexMatrix x_el_div (const Complex a, const SparseMatrix& b);
 extern ComplexMatrix x_el_div (const Complex a, 
 			       const SparseComplexMatrix& b);
 
 extern Matrix xleftdiv (const SparseMatrix& a, const Matrix& b, 
-			SparseType& typ);
+			MatrixType& typ);
 extern ComplexMatrix xleftdiv (const SparseMatrix& a, const ComplexMatrix& b,
-			       SparseType &typ);
+			       MatrixType &typ);
 extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a, const Matrix& b,
-			       SparseType &typ);
+			       MatrixType &typ);
 extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a, 
-			       const ComplexMatrix& b, SparseType &typ);
+			       const ComplexMatrix& b, MatrixType &typ);
 
 extern SparseMatrix xleftdiv (const SparseMatrix& a, const SparseMatrix& b,
-			      SparseType &typ);
+			      MatrixType &typ);
 extern SparseComplexMatrix xleftdiv (const SparseMatrix& a, 
-				     const SparseComplexMatrix& b, SparseType &typ);
+				     const SparseComplexMatrix& b, MatrixType &typ);
 extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a, 
-				     const SparseMatrix& b, SparseType &typ);
+				     const SparseMatrix& b, MatrixType &typ);
 extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a, 
-				     const SparseComplexMatrix& b, SparseType &typ);
+				     const SparseComplexMatrix& b, MatrixType &typ);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/sparse-xpow.cc b/src/sparse-xpow.cc
--- a/src/sparse-xpow.cc
+++ b/src/sparse-xpow.cc
@@ -85,17 +85,17 @@ xpow (const SparseMatrix& a, double b)
 	    {
 	      SparseMatrix atmp;
 	      if (btmp < 0)
 		{
 		  btmp = -btmp;
 
 		  octave_idx_type info;
 		  double rcond = 0.0;
-		  SparseType mattyp (a);
+		  MatrixType mattyp (a);
 
 		  atmp = a.inverse (mattyp, info, rcond, 1);
 
 		  if (info == -1)
 		    warning ("inverse: matrix singular to machine\
  precision, rcond = %g", rcond);
 		}
 	      else
@@ -158,17 +158,17 @@ xpow (const SparseComplexMatrix& a, doub
 	    {
 	      SparseComplexMatrix atmp;
 	      if (btmp < 0)
 		{
 		  btmp = -btmp;
 
 		  octave_idx_type info;
 		  double rcond = 0.0;
-		  SparseType mattyp (a);
+		  MatrixType mattyp (a);
 
 		  atmp = a.inverse (mattyp, info, rcond, 1);
 
 		  if (info == -1)
 		    warning ("inverse: matrix singular to machine\
  precision, rcond = %g", rcond);
 		}
 	      else
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -113,123 +113,95 @@ INSTANTIATE_MX_DIV_CONFORM (ComplexMatri
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 Matrix
-xdiv (const Matrix& a, const Matrix& b)
+xdiv (const Matrix& a, const Matrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return Matrix ();
 
   Matrix atmp = a.transpose ();
   Matrix btmp = b.transpose ();
+  MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
-  if (btmp.rows () == btmp.columns ())
-    {
-      double rcond = 0.0;
-
-      Matrix result
-	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
+  double rcond = 0.0;
 
-      if (result_ok (info))
-	return Matrix (result.transpose ());
-    }
+  Matrix result 
+    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
-  octave_idx_type rank;
-  Matrix result = btmp.lssolve (atmp, info, rank);
-
+  typ = btyp.transpose ();
   return result.transpose ();
 }
 
 // -*- 2 -*-
 ComplexMatrix
-xdiv (const Matrix& a, const ComplexMatrix& b)
+xdiv (const Matrix& a, const ComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   Matrix atmp = a.transpose ();
   ComplexMatrix btmp = b.hermitian ();
+  MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
-  if (btmp.rows () == btmp.columns ())
-    {
-      double rcond = 0.0;
-
-      ComplexMatrix result
-	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
+  double rcond = 0.0;
 
-      if (result_ok (info))
-	return result.hermitian ();
-    }
+  ComplexMatrix result
+    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
-  octave_idx_type rank;
-  ComplexMatrix result = btmp.lssolve (atmp, info, rank);
-
+  typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 3 -*-
 ComplexMatrix
-xdiv (const ComplexMatrix& a, const Matrix& b)
+xdiv (const ComplexMatrix& a, const Matrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   Matrix btmp = b.transpose ();
+  MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
-  if (btmp.rows () == btmp.columns ())
-    {
-      double rcond = 0.0;
-
-      ComplexMatrix result
-	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
+  double rcond = 0.0;
 
-      if (result_ok (info))
-	return result.hermitian ();
-    }
+  ComplexMatrix result
+    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
-  octave_idx_type rank;
-  ComplexMatrix result = btmp.lssolve (atmp, info, rank);
-
+  typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 4 -*-
 ComplexMatrix
-xdiv (const ComplexMatrix& a, const ComplexMatrix& b)
+xdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   ComplexMatrix btmp = b.hermitian ();
+  MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
-  if (btmp.rows () == btmp.columns ())
-    {
-      double rcond = 0.0;
-
-      ComplexMatrix result
-	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
+  double rcond = 0.0;
 
-      if (result_ok (info))
-	return result.hermitian ();
-    }
+  ComplexMatrix result
+    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
-  octave_idx_type rank;
-  ComplexMatrix result = btmp.lssolve (atmp, info, rank);
-
+  typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // Funny element by element division operations.
 //
 //       op2 \ op1:   s   cs
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
@@ -380,103 +352,60 @@ x_el_div (const Complex a, const Complex
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 Matrix
-xleftdiv (const Matrix& a, const Matrix& b)
+xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return Matrix ();
 
   octave_idx_type info;
-  if (a.rows () == a.columns ())
-    {
-      double rcond = 0.0;
-
-      Matrix result
-	= a.solve (b, info, rcond, solve_singularity_warning);
-
-      if (result_ok (info))
-	return result;
-    }
-
-  octave_idx_type rank;
-  return a.lssolve (b, info, rank);
+  double rcond = 0.0;
+  return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 2 -*-
 ComplexMatrix
-xleftdiv (const Matrix& a, const ComplexMatrix& b)
+xleftdiv (const Matrix& a, const ComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
-  if (a.rows () == a.columns ())
-    {
-      double rcond = 0.0;
-
-      ComplexMatrix result
-	= a.solve (b, info, rcond, solve_singularity_warning);
+  double rcond = 0.0;
 
-      if (result_ok (info))
-	return result;
-    }
-
-  octave_idx_type rank;
-  return a.lssolve (b, info, rank);
+  return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 3 -*-
 ComplexMatrix
-xleftdiv (const ComplexMatrix& a, const Matrix& b)
+xleftdiv (const ComplexMatrix& a, const Matrix& b, MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
-  if (a.rows () == a.columns ())
-    {
-      double rcond = 0.0;
-
-      ComplexMatrix result
-	= a.solve (b, info, rcond, solve_singularity_warning);
-
-      if (result_ok (info))
-	return result;
-    }
-
-  octave_idx_type rank;
-  return a.lssolve (b, info, rank);
+  double rcond = 0.0;
+  return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 4 -*-
 ComplexMatrix
-xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b)
+xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
-  if (a.rows () == a.columns ())
-    {
-      double rcond = 0.0;
-
-      ComplexMatrix result
-	= a.solve (b, info, rcond, solve_singularity_warning);
-
-      if (result_ok (info))
-	return result;
-    }
-
-  octave_idx_type rank;
-  return a.lssolve (b, info, rank);
+  double rcond = 0.0;
+  return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/xdiv.h b/src/xdiv.h
--- a/src/xdiv.h
+++ b/src/xdiv.h
@@ -20,42 +20,49 @@ Software Foundation, Inc., 51 Franklin S
 02110-1301, USA.
 
 */
 
 #if !defined (octave_xdiv_h)
 #define octave_xdiv_h 1
 
 #include "oct-cmplx.h"
+#include "MatrixType.h"
 
 class Matrix;
 class ComplexMatrix;
 
 class NDArray;
 class ComplexNDArray;
 
-extern Matrix xdiv (const Matrix& a, const Matrix& b);
-extern ComplexMatrix xdiv (const Matrix& a, const ComplexMatrix& b);
-extern ComplexMatrix xdiv (const ComplexMatrix& a, const Matrix& b);
-extern ComplexMatrix xdiv (const ComplexMatrix& a, const ComplexMatrix& b);
+extern Matrix xdiv (const Matrix& a, const Matrix& b, MatrixType &typ);
+extern ComplexMatrix xdiv (const Matrix& a, const ComplexMatrix& b,
+			   MatrixType &typ);
+extern ComplexMatrix xdiv (const ComplexMatrix& a, const Matrix& b,
+			   MatrixType &typ);
+extern ComplexMatrix xdiv (const ComplexMatrix& a, const ComplexMatrix& b,
+			   MatrixType &typ);
 
 extern Matrix x_el_div (double a, const Matrix& b);
 extern ComplexMatrix x_el_div (double a, const ComplexMatrix& b);
 extern ComplexMatrix x_el_div (const Complex a, const Matrix& b);
 extern ComplexMatrix x_el_div (const Complex a, const ComplexMatrix& b);
 
 extern NDArray x_el_div (double a, const NDArray& b);
 extern ComplexNDArray x_el_div (double a, const ComplexNDArray& b);
 extern ComplexNDArray x_el_div (const Complex a, const NDArray& b);
 extern ComplexNDArray x_el_div (const Complex a, const ComplexNDArray& b);
 
-extern Matrix xleftdiv (const Matrix& a, const Matrix& b);
-extern ComplexMatrix xleftdiv (const Matrix& a, const ComplexMatrix& b);
-extern ComplexMatrix xleftdiv (const ComplexMatrix& a, const Matrix& b);
-extern ComplexMatrix xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b);
+extern Matrix xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ);
+extern ComplexMatrix xleftdiv (const Matrix& a, const ComplexMatrix& b,
+			       MatrixType &typ);
+extern ComplexMatrix xleftdiv (const ComplexMatrix& a, const Matrix& b,
+			       MatrixType &typ);
+extern ComplexMatrix xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b,
+			       MatrixType &typ);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
