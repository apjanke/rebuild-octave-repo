# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1231873716 18000
#      Tue Jan 13 14:08:36 2009 -0500
# Node ID cadc73247d655410197b32ea2ba69e24677109f4
# Parent  bc982528de112088df95e3b922a8be5dcdea1faa
style fixes

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,10 +1,39 @@
 2009-01-13  John W. Eaton  <jwe@octave.org>
 
+	* elfun/lcm.m, general/accumarray.m, general/bicubic.m,
+	general/cellidx.m, general/cplxpair.m, general/dblquad.m,
+	general/gradient.m, general/interp1.m , general/pol2cart.m,
+	general/quadgk.m, general/quadv.m, general/repmat.m,
+	general/structfun.m, geometry/griddata.m, geometry/inpolygon.m,
+	image/brighten.m, image/hsv2rgb.m, image/imread.m,
+	image/imwrite.m, linear-algebra/dmult.m,
+	linear-algebra/onenormest.m, miscellaneous/getfield.m,
+	miscellaneous/setfield.m, miscellaneous/what.m,
+	optimization/fsolve.m, optimization/fzero.m,
+	optimization/lsqnonneg.m, optimization/qp.m, pkg/pkg.m,
+	plot/__area__.m, plot/__clabel__.m, plot/__stem__.m, plot/axis.m,
+	plot/colorbar.m, plot/contour3.m, plot/findall.m, plot/findobj.m,
+	plot/fplot.m, plot/grid.m, plot/hist.m, polynomial/convn.m,
+	polynomial/polyreduce.m, set/intersect.m, set/setxor.m,
+	set/union.m, signal/arch_fit.m, signal/durbinlevinson.m,
+	signal/fftshift.m, signal/freqz_plot.m, signal/ifftshift.m,
+	signal/spectral_adf.m, sparse/bicgstab.m, sparse/cgs.m,
+	sparse/gplot.m, sparse/normest.m, sparse/pcg.m, sparse/pcr.m,
+	sparse/spy.m, sparse/svds.m, sparse/treelayout.m,
+	sparse/treeplot.m, specfun/primes.m, special-matrix/hadamard.m,
+	statistics/base/center.m, statistics/base/quantile.m,
+	statistics/base/ranks.m, statistics/base/std.m,
+	statistics/distributions/hygepdf.m,
+	statistics/tests/kruskal_wallis_test.m, strings/index.m,
+	strings/mat2str.m, strings/str2double.m, strings/strrep.m,
+	testfun/assert.m, testfun/example.m, testfun/fail.m,
+	testfun/speed.m, testfun/test.m: Style fixes.
+
 	* audio/wavread.m, general/__splinen__.m, general/bicubic.m,
 	general/rat.m, linear-algebra/expm.m, linear-algebra/krylov.m,
 	linear-algebra/onenormest.m, miscellaneous/edit.m,
 	optimization/__dogleg__.m, pkg/pkg.m, plot/__errplot__.m,
 	plot/__go_draw_axes__.m, plot/__stem__.m, plot/findobj.m,
 	set/ismember.m, signal/arma_rnd.m, signal/freqz.m, signal/stft.m,
 	sparse/pcg.m, sparse/sprandsym.m, sparse/treelayout.m,
 	specfun/factor.m, specfun/nchoosek.m, specfun/primes.m,
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -64,17 +64,17 @@ function l = lcm (varargin)
       endfor
     endif
   else
     
     l = varargin{1};
     sz = size (l);
     nel = numel (l);
 
-    for i=2:nargin
+    for i = 2:nargin
       a = varargin{i};
 
       if (size (a) != sz)
 	if (nel == 1)
 	  sz = size (a);
 	  nel = numel (a);
 	elseif (numel (a) != 1)
 	  error ("lcm: all arguments must be the same size or scalar");
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -55,17 +55,17 @@
 
 function A = accumarray (subs, val, sz, fun, fillval, isspar)  
 
   if (nargin < 2 || nargin > 6)
     print_usage ();
   endif
 
   if (iscell (subs))
-    subs = cell2mat (cellfun (@(x) x(:), subs, 'UniformOutput', false));
+    subs = cell2mat (cellfun (@(x) x(:), subs, "UniformOutput", false));
   endif
   ndims = size (subs, 2);
 
   if (nargin < 3 || isempty (sz))
     sz = max (subs);
     if (isscalar(sz))
       sz = [sz, 1];
     endif
@@ -102,17 +102,17 @@ function A = accumarray (subs, val, sz, 
     idx{i} = subs (cidx, i);
   endfor
   x = cellfun (fun, mat2cell (val(:), diff ([cidx; length(val) + 1])));
   if (isspar && fillval == 0)
     A = sparse (idx{1}, idx{2}, x, sz(1), sz(2));
   else
     if (iscell (x))
       ## Why did matlab choose to reverse the order of the elements
-      x = cellfun (@(x) flipud (x(:)), x, 'UniformOutput', false);
+      x = cellfun (@(x) flipud (x(:)), x, "UniformOutput", false);
       A = cell (sz);
     elseif (fillval == 0)
       A = zeros (sz, class (x));
     else 
       A = fillval .* ones (sz);
     endif
     A(sub2ind (sz, idx{:})) = x;
   endif
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -113,17 +113,17 @@ function F = bicubic (X, Y, Z, XI, YI, e
     Y = reshape (Y, rz, 1);
     Y(rz) *= 1 + sign (Y(rz))*myeps;
     if (Y(rz) == 0) 
       Y(rz) = myeps;
     endif; 
     YI = reshape (YI, length (YI), 1);
     [m, i] = sort ([Y; YI]);
     o = cumsum (i <= rz);
-    yidx = o([find( i> rz)]);
+    yidx = o([find(i > rz)]);
     
     ## Set s and t used follow codes.
     s = xidx + ((XI .- X(xidx))./(X(xidx+1) .- X(xidx)));
     t = yidx + ((YI - Y(yidx))./(Y(yidx+1) - Y(yidx)));
   else
     print_usage ();
   endif
   
@@ -142,55 +142,55 @@ function F = bicubic (X, Y, Z, XI, YI, e
   d = find (t == rz);
   t = t - floor (t);
   indt(d) = rz-1;
   t(d) = 1.0;
   d = [];
 
   p = zeros (size (Z) + 2);
   p(2:rz+1,2:cz+1) = Z;
-  p(1,:)      =    (6*(1-a))*p(2,:)    -3*p(3,:)   + (6*a-2)*p(4,:);
-  p(rz+2,:)   =    (6*(1-a))*p(rz+1,:) -3*p(rz,:)  + (6*a-2)*p(rz-1,:);
-  p(:,1)      =    (6*(1-a))*p(:,2)    -3*p(:,3)   + (6*a-2)*p(:,4);
-  p(:,cz+2)   =    (6*(1-a))*p(:,cz+1)  -3*p(:,cz) + (6*a-2)*p(:,cz-1);
+  p(1,:) =    (6*(1-a))*p(2,:)    - 3*p(3,:)  + (6*a-2)*p(4,:);
+  p(rz+2,:) = (6*(1-a))*p(rz+1,:) - 3*p(rz,:) + (6*a-2)*p(rz-1,:);
+  p(:,1) =    (6*(1-a))*p(:,2)    - 3*p(:,3)  + (6*a-2)*p(:,4);
+  p(:,cz+2) = (6*(1-a))*p(:,cz+1) - 3*p(:,cz) + (6*a-2)*p(:,cz-1);
 
   ## Calculte the C1(t) C2(t) C3(t) C4(t) and C1(s) C2(s) C3(s) C4(s).
-  t2= t.*t;
-  t3= t2.*t;
+  t2 = t.*t;
+  t3 = t2.*t;
 
-  ct0=     -a .* t3 +     (2 * a) .* t2 - a .* t ;      # -a G0
+  ct0 =    -a .* t3 +     (2 * a) .* t2 - a .* t ;      # -a G0
   ct1 = (2-a) .* t3 +      (-3+a) .* t2          + 1 ;  # F0 - a G1
   ct2 = (a-2) .* t3 + (-2 *a + 3) .* t2 + a .* t ;      # F1 + a G0
   ct3 =     a .* t3 -           a .* t2;                # a G1
-  t = [];t2=[]; t3=[];
+  t = []; t2 = []; t3 = [];
 
-  s2= s.*s;
-  s3= s2.*s;
+  s2 = s.*s;
+  s3 = s2.*s;
 
-  cs0=     -a .* s3 +     (2 * a) .* s2 - a .*s ;      # -a G0
+  cs0 =    -a .* s3 +     (2 * a) .* s2 - a .*s ;      # -a G0
   cs1 = (2-a) .* s3 +    (-3 + a) .* s2         + 1 ;  # F0 - a G1
   cs2 = (a-2) .* s3 + (-2 *a + 3) .* s2 + a .*s ;      # F1 + a G0
   cs3 =     a .* s3 -           a .* s2;               # a G1
-  s=[] ; s2 = []; s3 = [];
+  s = []; s2 = []; s3 = [];
 
   cs0 = cs0([1,1,1,1],:);
   cs1 = cs1([1,1,1,1],:);
   cs2 = cs2([1,1,1,1],:);
   cs3 = cs3([1,1,1,1],:);
 
   lent = length (ct0);
   lens = length (cs0);
   F = zeros (lent, lens);
   
   for i = 1:lent
     it = indt(i);
     int = [it, it+1, it+2, it+3];
-    F(i,:) = [ct0(i),ct1(i),ct2(i),ct3(i)] * ...
-	(p(int,inds) .* cs0 + p(int,inds+1) .* cs1 + ...
-	 p(int,inds+2) .* cs2 + p(int,inds+3) .* cs3);
+    F(i,:) = ([ct0(i),ct1(i),ct2(i),ct3(i)]
+	      * (p(int,inds) .* cs0 + p(int,inds+1) .* cs1
+		 + p(int,inds+2) .* cs2 + p(int,inds+3) .* cs3));
   endfor
 
   ## Set points outside the table to extrapval.
   if (! (isempty (xfirst_ind) && isempty (xlast_ind)))
     F(:, [xfirst_ind, xlast_ind]) = extrapval;
   endif
   if (! (isempty (yfirst_ind) && isempty (ylast_ind)))
     F([yfirst_ind; ylast_ind], :) = extrapval;
diff --git a/scripts/general/cellidx.m b/scripts/general/cellidx.m
--- a/scripts/general/cellidx.m
+++ b/scripts/general/cellidx.m
@@ -73,17 +73,17 @@ function [idxvec,errmsg]  = cellidx (lis
       return;
     endif
   endif
 
   nsigs = length(listvar);
   for idx = 1:length(strlist)
     signame = strlist{idx};
     for jdx = 1:nsigs
-      if (strcmp (signame, listvar{jdx}) )
+      if (strcmp (signame, listvar{jdx}))
 	if (idxvec(idx) != 0)
 	  warning ("Duplicate signal name %s (%d,%d)\n",
 		   listvar{jdx}, jdx, idxvec(idx));
 	else
 	  idxvec(idx) = jdx;
 	endif
       endif
     endfor
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -81,63 +81,63 @@ function y = cplxpair (z, tol, dim)
     endif
   else
     dim = floor(dim);
     if (dim < 1 || dim > nd)
       error ("cplxpair: invalid dimension along which to sort");
     endif
   endif
 
-  ## Move dimension to treat first, and convert to a 2-D matrix
+  ## Move dimension to treat first, and convert to a 2-D matrix.
   perm = [dim:nd, 1:dim-1];
   z = permute (z, perm);
   sz = size (z);
   n = sz (1);
   m = prod (sz) / n;
   z = reshape (z, n, m);
 
-  ## Sort the sequence in terms of increasing real values
+  ## Sort the sequence in terms of increasing real values.
   [q, idx] = sort (real (z), 1);
   z = z(idx + n * ones (n, 1) * [0:m-1]);
 
-  ## Put the purely real values at the end of the returned list
+  ## Put the purely real values at the end of the returned list.
   cls = "double";
   if (isa (z, "single"))
     cls = "single";
   endif
-  [idxi, idxj] = find (abs (imag (z)) ./ (abs (z) + realmin(cls)) < tol );
+  [idxi, idxj] = find (abs (imag (z)) ./ (abs (z) + realmin(cls)) < tol);
   q = sparse (idxi, idxj, 1, n, m);
   nr = sum (q, 1);
   [q, idx] = sort (q, 1);
   z = z(idx);
   y = z;
 
   ## For each remaining z, place the value and its conjugate at the
   ## start of the returned list, and remove them from further
   ## consideration.
   for j = 1:m
     p = n - nr(j);
-    for i=1:2:p
+    for i = 1:2:p
       if (i+1 > p)
 	error ("cplxpair could not pair all complex numbers");
       endif
       [v, idx] = min (abs (z(i+1:p) - conj (z(i))));
       if (v > tol)
 	error ("cplxpair could not pair all complex numbers");
       endif
       if (imag (z(i)) < 0)
 	y([i, i+1]) = z([i, idx+i]);
       else
 	y([i, i+1]) = z([idx+i, i]);
       endif
       z(idx+i) = z(i+1);
     endfor
   endfor
 
-  ## Reshape the output matrix
+  ## Reshape the output matrix.
   y = ipermute (reshape (y, sz), perm);
 
 endfunction
 
 %!demo
 %! [ cplxpair(exp(2i*pi*[0:4]'/5)), exp(2i*pi*[3; 2; 4; 1; 0]/5) ]
 
 %!assert (isempty(cplxpair([])));
diff --git a/scripts/general/dblquad.m b/scripts/general/dblquad.m
--- a/scripts/general/dblquad.m
+++ b/scripts/general/dblquad.m
@@ -27,41 +27,41 @@
 ## If defined, @var{tol} defines the absolute tolerance to which to
 ## which to integrate each sub-integral.
 ##
 ## Additional arguments, are passed directly to @var{f}. To use the default
 ## value for @var{tol} one may pass an empty matrix.
 ## @seealso{triplequad, quad, quadv, quadl, quadgk, trapz}
 ## @end deftypefn
 
-function Q = dblquad(f, xa, xb, ya, yb, tol, quadf, varargin) 
+function q = dblquad(f, xa, xb, ya, yb, tol, quadf, varargin) 
   if (nargin < 5)
     print_usage ();
   endif
   if (nargin < 6 || isempty (tol))
     tol = 1e-6; 
   endif
   if (nargin < 7 || isempty (quadf))
     quadf = @quadgk; 
   endif
 
   inner = @__dblquad_inner__;
   if (ischar (f))
     f = @(x,y) feval (f, x, y, varargin{:});
     varargin = {};
   endif
 
-  Q = feval (quadf, @(y) inner (y, f, xa, xb, tol, quadf,
+  q = feval (quadf, @(y) inner (y, f, xa, xb, tol, quadf,
 				varargin{:}), ya, yb, tol);
 endfunction
 
-function Q = __dblquad_inner__ (y, f, xa, xb, tol, quadf, varargin)
-  Q = zeros (size(y));
+function q = __dblquad_inner__ (y, f, xa, xb, tol, quadf, varargin)
+  q = zeros (size(y));
   for i = 1 : length (y)
-    Q(i) = feval (quadf, @(x) f(x, y(i), varargin{:}), xa, xb, tol);
+    q(i) = feval (quadf, @(x) f(x, y(i), varargin{:}), xa, xb, tol);
   endfor
 endfunction
 
 %% Nasty integrand to show quadgk off
 %!assert (dblquad (@(x,y) 1 ./ (x+y), 0, 1, 0, 1), 2*log(2), 1e-6)
 
 %!assert (dblquad (@(x,y) exp(-x.^2 - y.^2) , -1, 1, -1, 1, [],  @quadgk), pi * erf(1).^2, 1e-6)
 %!assert (dblquad (@(x,y) exp(-x.^2 - y.^2) , -1, 1, -1, 1, [],  @quadl), pi * erf(1).^2, 1e-6)
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -46,63 +46,63 @@
 ## y'(i) = 1/(x(i+1)-x(i-1)) *(y(i-1)-y(i+1)).
 ## @end example
 ## 
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Modified: David Bateman <dbateman@free.fr> Added NDArray support
 
-function [varargout] = gradient (M, varargin)
+function varargout = gradient (M, varargin)
   
   if (nargin < 1)
     print_usage ()
   endif
 
   transposed = false;
   if (isvector (M))
-    ## make a column vector
+    ## Make a column vector.
     transposed = (size (M, 2) == 1);
     M = M(:)';
   endif
 
   nd = ndims (M);
   sz = size (M);
   if (nargin > 2 && nargin != nd + 1)
     print_usage ()
   endif
     
   d = cell (1, nd);
   if (nargin == 1)
-    for i=1:nd
+    for i = 1:nd
       d{i} = ones (sz(i), 1);
     endfor
   elseif (nargin == 2)
     if (isscalar (varargin{1}))
       for i = 1:nd
 	d{i} = varargin{1} * ones (sz(i), 1);
       endfor
     else
       for i = 1:nd
 	d{i} = varargin{1};
       endfor
     endif
   else
-    for i=1:nd
+    for i = 1:nd
       if (isscalar (varargin{i}))
-	## Why the hell did matlab decide to swap these two values?
+	## Why the hell did Matlab decide to swap these two values?
 	if (i == 1)
 	  d{2} = varargin{1} * ones (sz(2), 1);
 	elseif (i == 2)
 	  d{1} = varargin{2} * ones (sz(1), 1);
 	else
 	  d{i} = varargin{i} * ones (sz(i), 1);
 	endif
       else
-	## Why the hell did matlab decide to swap these two values?
+	## Why the hell did Matlab decide to swap these two values?
 	if (i == 1)
 	  d{2} = varargin{1};
 	elseif (i == 2)
 	  d{1} = varargin{2};
 	else
 	  d{i} = varargin{i};
 	endif
       endif
@@ -110,31 +110,31 @@ function [varargout] = gradient (M, vara
   endif
 
   for i = 1:max (2, min (nd, nargout))
     mr = sz(i);
     mc = prod ([sz(1:i-1), sz(i+1:nd)]);
     Y = zeros (size (M), class (M));
 
     if (mr > 1)
-      ## top and bottom boundary
+      ## Top and bottom boundary.
       Y(1,:) = diff (M(1:2,:)) / d{i}(1);
       Y(mr,:) = diff (M(mr-1:mr,:)) / d{i}(mr-1);
     endif
 
     if (mr > 2)
-      ## interior points
+      ## Interior points.
       Y(2:mr-1,:) = (M(3:mr,:) .- M(1:mr-2,:)) ...
 	  ./ kron (d{i}(1:mr-2) .+ d{i}(2:mr-1), ones (1, mc));
     endif
     varargout{i} = ipermute (Y, [i:nd,1:i-1]);
     M = permute (M, [2:nd,1]);
   endfor
 
-  ## Why the hell did matlab decide to swap these two values?
+  ## Why the hell did Matlab decide to swap these two values?
   tmp = varargout{1};
   varargout{1} = varargout{2};
   varargout{2} = tmp;
 
   if (transposed)
     varargout{1} = varargout{1}.';
   endif
 endfunction
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -58,25 +58,27 @@
 ## There is an equivalence, such that @code{ppval (interp1 (@var{x},
 ## @var{y}, @var{method}, 'pp'), @var{xi}) == interp1 (@var{x}, @var{y},
 ## @var{xi}, @var{method}, 'extrap')}.
 ##
 ## An example of the use of @code{interp1} is
 ##
 ## @example
 ## @group
-##    xf=[0:0.05:10]; yf = sin(2*pi*xf/5);
-##    xp=[0:10];      yp = sin(2*pi*xp/5);
-##    lin=interp1(xp,yp,xf);
-##    spl=interp1(xp,yp,xf,'spline');
-##    cub=interp1(xp,yp,xf,'cubic');
-##    near=interp1(xp,yp,xf,'nearest');
-##    plot(xf,yf,"r",xf,lin,"g",xf,spl,"b", ...
-##         xf,cub,"c",xf,near,"m",xp,yp,"r*");
-##    legend ("original","linear","spline","cubic","nearest")
+## xf = [0:0.05:10];
+## yf = sin (2*pi*xf/5);
+## xp = [0:10];
+## yp = sin (2*pi*xp/5);
+## lin = interp1 (xp, yp, xf);
+## spl = interp1 (xp, yp, xf, "spline");
+## cub = interp1 (xp, yp, xf, "cubic");
+## near = interp1 (xp, yp, xf, "nearest");
+## plot (xf, yf, "r", xf, lin, "g", xf, spl, "b",
+##       xf, cub, "c", xf, near, "m", xp, yp, "r*");
+## legend ("original", "linear", "spline", "cubic", "nearest")
 ## @end group
 ## @end example
 ##
 ## @seealso{interpft}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Date: 2000-03-25
@@ -137,17 +139,17 @@ function yi = interp1 (x, y, varargin)
   xi = xi(:);
 
   ## determine sizes
   if (nx < 2 || ny < 2)
     error ("interp1: table too short");
   endif
 
   ## determine which values are out of range and set them to extrap,
-  ## unless extrap=="extrap" in which case, extrapolate them like we
+  ## unless extrap == "extrap" in which case, extrapolate them like we
   ## should be doing in the first place.
   minx = x(1);
   maxx = x(nx);
   if (minx > maxx)
     tmp = minx;
     minx = maxx;
     maxx = tmp;
   endif
diff --git a/scripts/general/pol2cart.m b/scripts/general/pol2cart.m
--- a/scripts/general/pol2cart.m
+++ b/scripts/general/pol2cart.m
@@ -34,25 +34,22 @@ function [X, Y, Z] = pol2cart (Theta, R,
   if (nargin < 2 || nargin > 3)
     error ("pol2cart: number of arguments must be 2 or 3");
   endif
 
   if (nargin == 2 && nargout > 2)
     error ("pol2cart: number of output arguments must not be greater than number of input arguments");
   endif
 
-  if ((! (ismatrix (Theta) && ismatrix (R)))
-      || ((! size_equal (Theta, R)) && (! isscalar (Theta)) && (! isscalar (R)))
+  if (! (ismatrix (Theta) && ismatrix (R))
+      || ! size_equal (Theta, R) && ! isscalar (Theta) && ! isscalar (R)
       || (nargin == 3
-          && ((! ismatrix(Z))
-              || ( (! isscalar(Z))
-                   && ( (!(isscalar(R) || size_equal (R, Z))) || (!(isscalar(Theta) || size_equal (Theta, Z))) )
-                 )
-             )
-         )
-     )
+          && (! ismatrix (Z)
+              || (! isscalar (Z)
+                  && (! (isscalar (R) || size_equal (R, Z))
+		      || ! (isscalar(Theta) || size_equal (Theta, Z)))))))
     error ("pol2cart: arguments must be matrices of same size or scalar");
   endif
 
   X = cos (Theta) .* R;
   Y = sin (Theta) .* R;
 
 endfunction
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -203,17 +203,17 @@ function [q, err] = quadgk (f, a, b, var
     elseif (isinf(a))
       ## Formula defined in Shampine paper as two separate steps. One to
       ## weaken singularity at finite end, then a second to transform to
       ## a finite interval. The singularity weakening transform is
       ##   \int_{-\infinity}^b f(x) dx = 
       ##               - \int_{-\infinity}^0 f (b - t^2) 2 t dt
       ## (note minus sign) and the finite interval transform is
       ##   \int_{-\infinity}^0 f(b - t^2)  2 t dt = 
-      ##                  \int_{-1}^0 f (b - g(s) ^ 2 ) 2 g(s) g'(s) ds
+      ##                  \int_{-1}^0 f (b - g(s) ^ 2) 2 g(s) g'(s) ds
       ## where 
       ##   g(s)  = s / (1 + s)
       ##   g'(s) = 1 / (1 + s) ^ 2
       ## waypoint transform is then
       ##   t = sqrt (b - x)
       ##   s =  - t / (t + 1)
       if (!isempty (waypoints))
 	tmp = sqrt (b - waypoints);
@@ -227,17 +227,17 @@ function [q, err] = quadgk (f, a, b, var
       f = @(s) - 2 * s .* f (b -  (s ./ (1 + s)) .^ 2) ./ ((1 + s) .^ 3);
     elseif (isinf(b))
       ## Formula defined in Shampine paper as two separate steps. One to
       ## weaken singularity at finite end, then a second to transform to
       ## a finite interval. The singularity weakening transform is
       ##   \int_a^\infinity f(x) dx = \int_0^\infinity f (a + t^2) 2 t dt
       ## and the finite interval transform is
       ##  \int_0^\infinity f(a + t^2)  2 t dt = 
-      ##           \int_0^1 f (a + g(s) ^ 2 ) 2 g(s) g'(s) ds
+      ##           \int_0^1 f (a + g(s) ^ 2) 2 g(s) g'(s) ds
       ## where 
       ##   g(s)  = s / (1 - s)
       ##   g'(s) = 1 / (1 - s) ^ 2
       ## waypoint transform is then
       ##   t = sqrt (x - a)
       ##   s = t / (t + 1)
       if (!isempty (waypoints))
 	tmp = sqrt (waypoints - a);
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -37,17 +37,17 @@
 ## current interval, the interval length, and the partial integral.
 ##
 ## Additional arguments @var{p1}, etc, are passed directly to @var{f}.
 ## To use default values for @var{tol} and @var{trace}, one may pass
 ## empty matrices.
 ## @seealso{triplequad, dblquad, quad, quadl, quadgk, trapz}
 ## @end deftypefn
 
-function [Q, fcnt] = quadv (f, a, b, tol, trace, varargin)
+function [q, fcnt] = quadv (f, a, b, tol, trace, varargin)
   if (nargin < 3)
     print_usage ();
   endif
   if (nargin < 4)
     tol = []; 
   endif
   if (nargin < 5)
     trace = []; 
@@ -76,59 +76,59 @@ function [Q, fcnt] = quadv (f, a, b, tol
   if (isinf (fa))
     fa = feval (f, a + myeps * (b-a), varargin{:});
   endif
   if (isinf (fb))
     fb = feval (f, b - myeps * (b-a), varargin{:});
   endif
 
   h = (b - a) / 2;
-  Q = (b - a) / 6 * (fa + 4 * fc + fb);
+  q = (b - a) / 6 * (fa + 4 * fc + fb);
  
-  [Q, fcnt, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, Q, fcnt, abs (b - a), 
+  [q, fcnt, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q, fcnt, abs (b - a), 
 				tol, trace, varargin{:});
 
   if (fcnt > 10000)
-    warning("Maximum iteration count reached");
-  elseif (isnan(Q) || isinf (Q))
-    warning ("Infinite or NaN function evaluations were returned");
+    warning ("maximum iteration count reached");
+  elseif (isnan (q) || isinf (q))
+    warning ("infinite or NaN function evaluations were returned");
   elseif (hmin < (b - a) * myeps)
-    warning ("Minimum step size reached. Possibly singular integral");
+    warning ("minimum step size reached -- possibly singular integral");
   endif
 endfunction
 
-function [Q, fcnt, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, Q0, 
+function [q, fcnt, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q0, 
 				       fcnt, hmin, tol, trace, varargin)
   if (fcnt > 10000)
-    Q = Q0;
+    q = q0;
   else
     d = (a + c) / 2;
     e = (c + b) / 2;
     fd = feval (f, d, varargin{:});
     fe = feval (f, e, varargin{:});
     fcnt += 2;
-    Q1 = (c - a) / 6 * (fa + 4 * fd + fc);
-    Q2 = (b - c) / 6 * (fc + 4 * fe + fb);
-    Q = Q1 + Q2;
+    q1 = (c - a) / 6 * (fa + 4 * fd + fc);
+    q2 = (b - c) / 6 * (fc + 4 * fe + fb);
+    q = q1 + q2;
 
     if (abs(a -  c) < hmin)
       hmin = abs (a - c);
     endif
 
     if (trace)
-      disp ([fcnt, a, b-a, Q]);
+      disp ([fcnt, a, b-a, q]);
     endif
 
-    ## Force at least one adpative step
-    if (fcnt == 5 || abs (Q - Q0) > tol)
-      [Q1, fcnt, hmin] = simpsonstp (f, a, c, d, fa, fc, fd, Q1, fcnt, hmin,
+    ## Force at least one adpative step.
+    if (fcnt == 5 || abs (q - q0) > tol)
+      [q1, fcnt, hmin] = simpsonstp (f, a, c, d, fa, fc, fd, q1, fcnt, hmin,
 				    tol, trace, varargin{:});
-      [Q2, fcnt, hmin] = simpsonstp (f, c, b, e, fc, fb, fe, Q2, fcnt, hmin,
+      [q2, fcnt, hmin] = simpsonstp (f, c, b, e, fc, fb, fe, q2, fcnt, hmin,
 				     tol, trace, varargin{:});
-      Q = Q1 + Q2;
+      q = q1 + q2;
     endif
   endif
 endfunction
 
 %!assert (quadv (@sin, 0, 2 * pi), 0, 1e-5)
 %!assert (quadv (@sin, 0, pi), 2, 1e-5)
 
 %% Handles weak singularities at the edge
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -70,17 +70,17 @@ function x = repmat (a, m, n)
   else
     aidx = size(a);
     if (length(aidx) > length(idx))
       idx = [idx, ones(1,length(aidx)-length(idx))];
     elseif (length(aidx) < length(idx))
       aidx = [aidx, ones(1,length(idx)-length(aidx))];
     endif
     cidx = cell (1, length (aidx));
-    for i=1:length(aidx)
+    for i = 1:length (aidx)
       cidx{i} = kron (ones (1, idx(i)), 1:aidx(i));
     endfor
     x = a (cidx{:});
   endif
 
 endfunction
 
 # Test various methods of providing size parameters
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -14,54 +14,54 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} structfun (@var{func}, @var{s})
 ## @deftypefnx {Function File} {[@var{a}, @var{b}] =} structfun (@dots{})
-## @deftypefnx {Function File} {} structfun (@dots{}, 'ErrorHandler', @var{errfunc})
-## @deftypefnx {Function File} {} structfun (@dots{}, 'UniformOutput', @var{val})
+## @deftypefnx {Function File} {} structfun (@dots{}, "ErrorHandler", @var{errfunc})
+## @deftypefnx {Function File} {} structfun (@dots{}, "UniformOutput", @var{val})
 ## 
 ## Evaluate the function named @var{name} on the fields of the structure
 ## @var{s}. The fields of @var{s} are passed to the function @var{func}
 ## individually.
 ##
 ## @code{structfun} accepts an arbitrary function @var{func} in the form of 
 ## an inline function, function handle, or the name of a function (in a 
 ## character string). In the case of a character string argument, the 
 ## function must accept a single argument named @var{x}, and it must return 
 ## a string value. If the function returns more than one argument, they are
 ## returned as separate output variables.
 ##
-## If the param 'UniformOutput' is set to true (the default), then the function
+## If the param "UniformOutput" is set to true (the default), then the function
 ## must return a single element which will be concatenated into the
-## return value. If 'UniformOutput' is false, the outputs placed in a structure
+## return value. If "UniformOutput" is false, the outputs placed in a structure
 ## with the same fieldnames as the input structure.
 ## 
 ## @example
 ## @group
 ## s.name1 = "John Smith"; 
 ## s.name2 = "Jill Jones"; 
-## structfun (@@(x) regexp (x, '(\w+)$', 'matches')@{1@}, s, 
-##            'UniformOutput', false)
+## structfun (@@(x) regexp (x, '(\w+)$', "matches")@{1@}, s, 
+##            "UniformOutput", false)
 ## @end group
 ## @end example
 ## 
-## Given the parameter 'ErrorHandler', then @var{errfunc} defines a function to
+## Given the parameter "ErrorHandler", then @var{errfunc} defines a function to
 ## call in case @var{func} generates an error. The form of the function is
 ## 
 ## @example
 ## function [@dots{}] = errfunc (@var{se}, @dots{})
 ## @end example
 ## 
 ## where there is an additional input argument to @var{errfunc} relative to
 ## @var{func}, given by @var{se}. This is a structure with the elements
-## 'identifier', 'message' and 'index', giving respectively the error
+## "identifier", "message" and "index", giving respectively the error
 ## identifier, the error message, and the index into the input arguments
 ## of the element that caused the error.
 ## @seealso{cellfun, arrayfun}
 ## @end deftypefn
 
 function varargout = structfun (fun, s, varargin);
   if (nargin < 2)
     print_usage ();
@@ -76,11 +76,11 @@ function varargout = structfun (fun, s, 
 endfunction
 
 
 %!test
 %! s.name1 = "John Smith"; 
 %! s.name2 = "Jill Jones"; 
 %! l.name1 = "Smith";
 %! l.name2 = "Jones";
-%! o = structfun (@(x) regexp (x, '(\w+)$', 'matches'){1}, s, 
-%!		  'UniformOutput', false);
+%! o = structfun (@(x) regexp (x, '(\w+)$', "matches"){1}, s, 
+%!		  "UniformOutput", false);
 %! assert (o, l);
diff --git a/scripts/geometry/griddata.m b/scripts/geometry/griddata.m
--- a/scripts/geometry/griddata.m
+++ b/scripts/geometry/griddata.m
@@ -46,74 +46,74 @@ function [rx, ry, rz] = griddata (x, y, 
 
   if (ischar (method))
     method = tolower (method);
   endif
   if (! all (size (x) == size (y) & size (x) == size (z)))
     error ("griddata: x, y, and z must be vectors of same length");
   endif
   
-  ## meshgrid xi and yi if they are vectors unless they
-  ## are vectors of the same length 
+  ## Meshgrid xi and yi if they are vectors unless they
+  ## are vectors of the same length.
   if (isvector (xi) && isvector (yi) && numel (xi) != numel (yi))
     [xi, yi] = meshgrid (xi, yi);
   endif
 
   if (any (size (xi) != size (yi)))
     error ("griddata: xi and yi must be vectors or matrices of same size");
   endif
 
   [nr, nc] = size (xi);
   
-  ## triangulate data
+  ## Triangulate data.
   tri = delaunay (x, y);
   zi = nan (size (xi));
   
   if (strcmp (method, "cubic"))
     error ("griddata: cubic interpolation not yet implemented")
 
   elseif (strcmp (method, "nearest"))
-    ## search index of nearest point
+    ## Search index of nearest point.
     idx = dsearch (x, y, tri, xi, yi);
     valid = !isnan (idx);
     zi(valid) = z(idx(valid));
 
   elseif (strcmp (method, "linear"))
-    ## search for every point the enclosing triangle
-    tri_list= tsearch (x, y, tri, xi(:), yi(:));
+    ## Search for every point the enclosing triangle.
+    tri_list = tsearch (x, y, tri, xi(:), yi(:));
 
-    ## only keep the points within triangles.
+    ## Only keep the points within triangles.
     valid = !isnan (reshape (tri_list, size (xi)));
     tri_list = tri_list(!isnan (tri_list));
     nr_t = rows (tri_list);
 
-    ## assign x,y,z for each point of triangle
+    ## Assign x,y,z for each point of triangle.
     x1 = x(tri(tri_list,1));
     x2 = x(tri(tri_list,2));
     x3 = x(tri(tri_list,3));
 
     y1 = y(tri(tri_list,1));
     y2 = y(tri(tri_list,2));
     y3 = y(tri(tri_list,3));
 
     z1 = z(tri(tri_list,1));
     z2 = z(tri(tri_list,2));
     z3 = z(tri(tri_list,3));
 
-    ## calculate norm vector
+    ## Calculate norm vector.
     N = cross ([x2-x1, y2-y1, z2-z1], [x3-x1, y3-y1, z3-z1]);
     N_norm = sqrt (sumsq (N, 2));
     N = N ./ N_norm(:,[1,1,1]);
     
-    ## calculate D of plane equation
-    ## Ax+By+Cz+D=0;
+    ## Calculate D of plane equation
+    ## Ax+By+Cz+D = 0;
     D = -(N(:,1) .* x1 + N(:,2) .* y1 + N(:,3) .* z1);
     
-    ## calculate zi by solving plane equation for xi,yi
-    zi(valid) = -(N(:,1).*xi(valid) + N(:,2).*yi(valid) + D ) ./ N(:,3);
+    ## Calculate zi by solving plane equation for xi, yi.
+    zi(valid) = -(N(:,1).*xi(valid) + N(:,2).*yi(valid) + D) ./ N(:,3);
     
   else
     error ("griddata: unknown interpolation method");
   endif
 
   if (nargout == 3)
     rx = xi;
     ry = yi;
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -62,25 +62,25 @@ function [IN, ON] = inpolygon (X, Y, xv,
   for i = 1 : npol
     delta_xv = xv(j) - xv(i);
     delta_yv = yv(j) - yv(i);
     ## distance = [distance from (X,Y) to edge] * length(edge)
     distance = delta_xv .* (Y - yv(i)) - (X - xv(i)) .* delta_yv;
     ##
     ## is Y between the y-values of edge i,j
     ##        AND (X,Y) on the left of the edge ?
-    idx1 = ((yv(i) <= Y & Y < yv(j)) | (yv(j) <= Y & Y < yv(i)) ) & ...
-           0 < distance.*delta_yv;
+    idx1 = (((yv(i) <= Y & Y < yv(j)) | (yv(j) <= Y & Y < yv(i)))
+	    & 0 < distance.*delta_yv);
     IN (idx1) = !IN (idx1);
 
     ## Check if (X,Y) are actually ON the boundary of the polygon.
     if (do_boundary)
-       idx2 = ((yv(i) <= Y & Y <= yv(j)) | (yv(j) <= Y & Y <= yv(i))) & ...
-              ((xv(i) <= X & X <= xv(j)) | (xv(j) <= X & X <= xv(i))) & ...
-              (0 == distance | !delta_xv);
+       idx2 = (((yv(i) <= Y & Y <= yv(j)) | (yv(j) <= Y & Y <= yv(i)))
+	       & ((xv(i) <= X & X <= xv(j)) | (xv(j) <= X & X <= xv(i)))
+	       & (0 == distance | !delta_xv));
        ON (idx2) = true;
     endif
     j = i;
   endfor
 
 endfunction
 
 %!demo
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
--- a/scripts/image/brighten.m
+++ b/scripts/image/brighten.m
@@ -39,24 +39,24 @@ function Rmap = brighten (m, beta)
   if (nargin == 1)
     beta = m;
     m = colormap;
     h = gcf ();
   elseif (nargin == 2)
     if (ishandle (m))
       h = m;
       m = get (h, "colormap");
-    elseif ((!is_matrix (m)) || (size (m, 2) != 3))
+    elseif (! is_matrix (m) || size (m, 2) != 3)
       error ("First argument must be a matrix of size nx3 or a handle.");
     endif
   else
     print_usage ();
   endif
 
-  if ( (!isscalar (beta)) || (beta <= -1) || (beta >= 1) )
+  if (! isscalar (beta) || beta <= -1 || beta >= 1)
     error ("brighten(...,beta) beta must be a scalar in the range (-1,1).");
   endif
 
   if (beta > 0)
     gamma = 1 - beta;
   else
     gamma = 1 / (1 + beta);
   endif
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -23,20 +23,20 @@
 ## @seealso{rgb2hsv}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function rgb_map = hsv2rgb (hsv_map)
 
-## each color value x=(r,g,b) is calculated with
+## Each color value x = (r,g,b) is calculated with
 ## x = (1-sat)*val+sat*val*f_x(hue)
 ## where f_x(hue) is a piecewise defined function for
-## each color with f_r(hue-2/3) = f_g(hue) = f_b(hue-1/3)
+## each color with f_r(hue-2/3) = f_g(hue) = f_b(hue-1/3).
 
   if (nargin != 1)
     print_usage ();
   endif
 
   ## If we have an image convert it into a color map.
   if (ismatrix (hsv_map) && ndims (hsv_map) == 3)
     is_image = true;
diff --git a/scripts/image/imread.m b/scripts/image/imread.m
--- a/scripts/image/imread.m
+++ b/scripts/image/imread.m
@@ -45,17 +45,17 @@ function varargout = imread (filename, v
     error ("imread: filename must be a string")
   endif
 
   filename = tilde_expand (filename);
 
   fn = file_in_path (IMAGE_PATH, filename);
 
   if (isempty (fn))
-    error ( "imread: cannot find %s", filename);
+    error ("imread: cannot find %s", filename);
   endif
 
   try
     [varargout{1:nargout}] = __magick_read__ (fn, varargin{:});
   catch
 
     magick_error = lasterr ();
 
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -63,17 +63,17 @@ function imwrite (varargin)
         fmt = varargin{offset};
         offset++;
       endif
     else
       print_usage ();
     endif
     if (offset < nargin)
       has_param_list = 1;
-      for ii=offset:2:(nargin - 1)
+      for ii = offset:2:(nargin - 1)
         options.(varargin{ii}) = varargin{ii + 1};
       end
     else
       has_param_list = 0;
     endif
   else
     print_usage ();
   endif
diff --git a/scripts/linear-algebra/dmult.m b/scripts/linear-algebra/dmult.m
--- a/scripts/linear-algebra/dmult.m
+++ b/scripts/linear-algebra/dmult.m
@@ -73,20 +73,20 @@ function m = dmult (a, b, ind)
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!test
-%! assert ( dmult ([1,2,3], ones(3)), [1,1,1;2,2,2;3,3,3] )
-%! assert ( dmult ([1,2,3]', ones(3)), [1,1,1;2,2,2;3,3,3] )
+%! assert (dmult ([1,2,3], ones(3)), [1,1,1;2,2,2;3,3,3])
+%! assert (dmult ([1,2,3]', ones(3)), [1,1,1;2,2,2;3,3,3])
 %!test
-%! assert ( dmult ([1,2,3], ones(3,2,2)), reshape ([1,1,1,1;2,2,2,2;3,3,3,3], [3,2,2]) )
+%! assert (dmult ([1,2,3], ones(3,2,2)), reshape ([1,1,1,1;2,2,2,2;3,3,3,3], [3,2,2]))
 %!test
-%! assert ( dmult (ones(3), [1,2,3]), [1,2,3;1,2,3;1,2,3] )
-%! assert ( dmult (ones(3), [1,2,3]'), [1,2,3;1,2,3;1,2,3] )
+%! assert (dmult (ones(3), [1,2,3]), [1,2,3;1,2,3;1,2,3])
+%! assert (dmult (ones(3), [1,2,3]'), [1,2,3;1,2,3;1,2,3])
 %!test
-%! assert ( dmult (ones(2,2,3), [1,2,3]), reshape ([1,2,3;1,2,3;1,2,3;1,2,3], [2,2,3]) )
+%! assert (dmult (ones(2,2,3), [1,2,3]), reshape ([1,2,3;1,2,3;1,2,3;1,2,3], [2,2,3]))
 %!test
-%! assert ( dmult (ones(3,4,2), [1 2 3 4], 2),...
-%! reshape ([1 1 1 2 2 2 3 3 3 4 4 4 1 1 1 2 2 2 3 3 3 4 4 4], [3,4,2]) ) 
+%! assert (dmult (ones(3,4,2), [1 2 3 4], 2),...
+%! reshape ([1 1 1 2 2 2 3 3 3 4 4 4 1 1 1 2 2 2 3 3 3 4 4 4], [3,4,2]))
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -184,17 +184,17 @@ function [est, v, w, iter] = onenormest 
       ## Some vectors are parallel to old ones and are cycling,
       ## but not all of them.  Replace the parallel vectors with
       ## rand{-1,+1}.
       numpar = sum (partest);
       replacements = 2*(rand (n,numpar) < 0.5) - 1;
       S(:,partest) = replacements;
     endif
     ## Now test for parallel vectors within S.
-    partest = any ( (S' * S - eye (t)) == n );
+    partest = any ((S' * S - eye (t)) == n);
     if (any (partest))
       numpar = sum (partest);
       replacements = 2*(rand (n,numpar) < 0.5) - 1;
       S(:,partest) = replacements;
     endif
     
     Z = feval (apply_t, S);
 
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -17,28 +17,28 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{v1}, @dots{}] =} getfield (@var{s}, @var{key}, @dots{}) 
 ## Extract fields from a structure. For example
 ##
 ## @example
 ## @group
-## ss(1,2).fd(3).b=5;
+## ss(1,2).fd(3).b = 5;
 ## getfield (ss, @{1,2@}, "fd", @{3@}, "b")
 ## @result{} ans = 5
 ## @end group
 ## @end example
 ##
 ## Note that the function call in the previous example is equivalent to
 ## the expression
 ##
 ## @example
-##          i1= @{1,2@}; i2= "fd"; i3= @{3@}; i4= "b";
-##          ss(i1@{:@}).(i2)(i3@{:@}).(i4)
+## i1 = @{1,2@}; i2 = "fd"; i3 = @{3@}; i4= "b";
+## ss(i1@{:@}).(i2)(i3@{:@}).(i4)
 ## @end example
 ## @seealso{setfield, rmfield, isfield, isstruct, fieldnames, struct}
 ## @end deftypefn
 
 ## Author: Etienne Grossmann <etienne@cs.uky.edu>
 
 function s = getfield (s, varargin)
 
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -17,28 +17,28 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{k1}, @dots{}, @var{v1}] =} setfield (@var{s}, @var{k1}, @var{v1}, @dots{})
 ## Set field members in a structure.
 ##
 ## @example
 ## @group
-## oo(1,1).f0= 1;
-## oo = setfield(oo,@{1,2@},'fd',@{3@},'b', 6);
+## oo(1,1).f0 = 1;
+## oo = setfield (oo, @{1,2@}, "fd", @{3@}, "b", 6);
 ## oo(1,2).fd(3).b == 6
 ## @result{} ans = 1
 ## @end group
 ## @end example
 ##
 ## Note that this function could be written
 ##
 ## @example
-##          i1= @{1,2@}; i2= 'fd'; i3= @{3@}; i4= 'b';
-##          oo( i1@{:@} ).( i2 )( i3@{:@} ).( i4 ) == 6;
+## i1 = @{1,2@}; i2 = "fd"; i3 = @{3@}; i4 = "b";
+## oo(i1@{:@}).(i2)(i3@{:@}).(i4) == 6;
 ## @end example
 ## @seealso{getfield, rmfield, isfield, isstruct, fieldnames, struct}
 ## @end deftypefn
 
 ## Author:  Etienne Grossmann <etienne@cs.uky.edu>
 
 function obj = setfield (obj, varargin)
    field = "obj";
@@ -57,14 +57,14 @@ function obj = setfield (obj, varargin)
    endfor
    val = varargin{nargin-1};
    eval (sprintf ("%s=val;", field));
 endfunction
 
 %!test
 %! x.a = "hello";
 %! x = setfield(x,"b","world");
-%! y = struct('a','hello','b','world');
+%! y = struct("a","hello","b","world");
 %! assert(x,y);
 %!test
 %! oo(1,1).f0= 1;
-%! oo = setfield(oo,{1,2},'fd',{3},'b', 6);
+%! oo = setfield(oo,{1,2},"fd",{3},"b", 6);
 %! assert (oo(1,2).fd(3).b, 6)
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -29,17 +29,17 @@
 
 ## PKG_ADD: mark_as_command what
 
 function ret = what (d)
 
   if (nargin == 0)
     d = pwd ();
   elseif (isempty (strfind (d, filesep ())))
-    ## Find the appropriate directory on the path
+    ## Find the appropriate directory on the path.
     p = split (path (), pathsep());
     p = cellfun (@(x) deblank (x), mat2cell (p, ones (1, size (p, 1)), ...
 		size (p, 2)), "UniformOutput", false);
     d = p{find (cellfun (@(x) ! isempty (strfind (x, d)), p))(end)};
   else
     [status, msg, msgid] = fileattrib (d);
     if (status != 1)
       error ("could not find the file or path %s", d);
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -74,17 +74,17 @@ function [x, fvec, info, output, fjac] =
   has_jac = strcmpi (optimget (options, "Jacobian", "off"), "on");
   maxiter = optimget (options, "MaxIter", Inf);
   maxfev = optimget (options, "MaxFunEvals", Inf);
   outfcn = optimget (options, "OutputFcn");
   pivoting = optimget (options, "Pivoting", false);
   funvalchk = strcmpi (optimget (options, "FunValCheck", "off"), "on");
 
   if (funvalchk)
-    ## replace fun with a guarded version
+    ## Replace fun with a guarded version.
     fun = @(x) guarded_eval (fun, x);
   endif
 
   ## These defaults are rather stringent. I think that normally, user
   ## prefers accuracy to performance.
 
   macheps = eps (class (x0));
 
@@ -96,21 +96,21 @@ function [x, fvec, info, output, fjac] =
   autodg = true;
 
   niter = 1;
   nfev = 0;
 
   x = x0(:);
   info = 0;
 
-  ## outer loop
+  ## Outer loop.
   while (niter < maxiter && nfev < maxfev && ! info)
 
-    ## calc func value and jacobian (possibly via FD)
-    ## handle arbitrary shapes of x and f and remember them
+    ## Calculate function value and Jacobian (possibly via FD).
+    ## Handle arbitrary shapes of x and f and remember them.
     if (has_jac)
       [fvec, fjac] = fcn (reshape (x, xsiz));
       nfev ++;
     else
       [fvec, fjac] = __fdjac__ (fcn, reshape (x, xsiz));
       nfev += 1 + length (x);
     endif
     fsiz = size (fvec);
@@ -121,105 +121,105 @@ function [x, fvec, info, output, fjac] =
     if (m < n)
       error ("fsolve:under", "cannot solve underdetermined systems");
     elseif (m > n && niter == 1)
       if (isempty (optimget (options, "TolFun")))
 	warning ("an overdetermined system cannot usually be solved exactly; consider specifying the TolFun option");
       endif
     endif
     
-    ## get QR factorization of the jacobian
+    ## Get QR factorization of the jacobian.
     if (pivoting)
       [q, r, p] = qr (fjac);
     else
       [q, r] = qr (fjac);
     endif
 
-    ## get column norms, use them as scaling factor
+    ## Get column norms, use them as scaling factor.
     jcn = norm (fjac, 'columns').';
     if (niter == 1)
       if (autodg)
         dg = jcn;
         dg(dg == 0) = 1;
       endif
       xn = norm (dg .* x);
       delta = factor * xn;
     endif
 
-    ## rescale if necessary
+    ## Rescale if necessary.
     if (autodg)
       dg = max (dg, jcn);
     endif
 
     nfail = 0;
     nsuc = 0;
-    ## inner loop
+    ## Inner loop.
     while (niter <= maxiter && nfev < maxfev && ! info)
 
       qtf = q'*fvec;
 
-      ## get TR model (dogleg) minimizer
-      ## in case of an overdetermined system, get lsq solution
+      ## Get TR model (dogleg) minimizer
+      ## in case of an overdetermined system, get lsq solution.
       s = - __dogleg__ (r(1:n,:), qtf(1:n), dg, delta);
       if (pivoting)
 	s = p * s;
       endif
       sn = norm (dg .* s);
 
       if (niter == 1)
         delta = min (delta, sn);
       endif
 
       fvec1 = fcn (reshape (x + s, xsiz)) (:);
       fn1 = norm (fvec1);
 
       if (fn1 < fn)
-        ## scaled actual reduction
+        ## Scaled actual reduction.
         actred = 1 - (fn1/fn)^2;
       else
         actred = -1;
       endif
 
-      ## scaled predicted reduction, and ratio
+      ## Scaled predicted reduction, and ratio.
       if (pivoting)
 	w = qtf + r*(p'*s);
       else
 	w = qtf + r*s;
       endif
       t = norm (w);
       if (t < fn)
         prered = 1 - (t/fn)^2;
         ratio = actred / prered;
       else
         prered = 0;
         ratio = 0;
       endif
 
-      ## update delta
+      ## Update delta.
       if (ratio < 0.1)
         nsuc = 0;
         nfail ++;
         delta *= 0.5;
         if (delta <= sqrt (macheps)*xn)
-          ## trust region became uselessly small
+          ## Trust region became uselessly small.
           info = -3;
           break;
         endif
       else
         nfail = 0;
         nsuc ++;
         if (abs (1-ratio) <= 0.1)
           delta = 2*sn;
         elseif (ratio >= 0.5 || nsuc > 1)
           delta = max (delta, 2*sn);
         endif
       endif
 
       if (ratio >= 1e-4)
-        ## successful iteration
+        ## Successful iteration.
         x += s;
         xn = norm (dg .* x);
         fvec = fvec1;
         fn = fn1;
         niter ++;
       endif
 
       ## Tests for termination conditions. A mysterious place, anything
@@ -245,35 +245,35 @@ function [x, fvec, info, output, fjac] =
           ## Again a classic one. It seems weird to use the same tolf
 	  ## for two different tests, but that's what M*b manual appears
 	  ## to say.
         elseif (actred < tolf)
           info = 3;
         endif
       endif
 
-      ## criterion for recalculating jacobian 
+      ## Criterion for recalculating jacobian.
       if (nfail == 2)
         break;
       endif
 
-      ## compute the scaled Broyden update
+      ## Compute the scaled Broyden update.
       u = (fvec1 - q*w) / sn; 
       v = dg .* ((dg .* s) / sn);
       if (pivoting)
 	v = p'*v;
       endif
 
-      ## update the QR factorization
+      ## Update the QR factorization.
       [q, r] = qrupdate (q, r, u, v);
 
     endwhile
   endwhile
 
-  ## restore original shapes
+  ## Restore original shapes.
   x = reshape (x, xsiz);
   fvec = reshape (fvec, fsiz);
 
   output.iterations = niter;
   output.funcCount = niter + 2;
 
 endfunction
 
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -74,37 +74,37 @@ function [x, fval, info, output] = fzero
   outfcn = optimget (options, "OutputFcn");
   tolx = optimget (options, "TolX", 0);
   maxiter = optimget (options, "MaxIter", Inf);
   maxfev = optimget (options, "MaxFunEvals", Inf);
 
   persistent mu = 0.5;
 
   if (funvalchk)
-    ## replace fun with a guarded version
+    ## Replace fun with a guarded version.
     fun = @(x) guarded_eval (fun, x);
   endif
 
-  ## the default exit flag if exceeded number of iterations
+  ## The default exit flag if exceeded number of iterations.
   info = 0;
   niter = 0;
   nfev = 0;
 
   x = fval = a = fa = b = fb = NaN;
 
-  ## prepare...
+  ## Prepare...
   a = x0(1);
   fa = fun (a); 
   nfev = 1;
   if (length (x0) > 1)
     b = x0(2);
     fb = fun (b);
     nfev += 1;
   else
-    ## try to get b
+    ## Try to get b.
     if (a == 0)
       aa = 1;
     else
       aa = a;
     endif
     for b = [0.9*aa, 1.1*aa, aa-1, aa+1, 0.5*aa 1.5*aa, -aa, 2*aa, -10*aa, 10*aa]
       fb = fun (b); nfev += 1;
       if (sign (fa) * sign (fb) <= 0)
@@ -136,121 +136,121 @@ function [x, fval, info, output] = fzero
   endif
 
   d = e = u;
   fd = fe = fu;
   mba = mu*(b - a);
   while (niter < maxiter && nfev < maxfev)
     switch (itype)
     case 1
-      ## the initial test
+      ## The initial test.
       if (b - a <= 2*(2 * abs (u) * eps + tolx))
         x = u; fval = fu;
         info = 1;
         break;
       endif
       if (abs (fa) <= 1e3*abs (fb) && abs (fb) <= 1e3*abs (fa))
-        ## secant step
+        ## Secant step.
         c = u - (a - b) / (fa - fb) * fu;
       else
-        ## bisection step
+        ## Bisection step.
         c = 0.5*(a + b);
       endif
       d = u; fd = fu;
       itype = 5;
     case {2, 3}
       l = length (unique ([fa, fb, fd, fe]));
       if (l == 4)
-        ## inverse cubic interpolation
+        ## Inverse cubic interpolation.
         q11 = (d - e) * fd / (fe - fd);
         q21 = (b - d) * fb / (fd - fb);
         q31 = (a - b) * fa / (fb - fa);
         d21 = (b - d) * fd / (fd - fb);
         d31 = (a - b) * fb / (fb - fa);
         q22 = (d21 - q11) * fb / (fe - fb);
         q32 = (d31 - q21) * fa / (fd - fa);
         d32 = (d31 - q21) * fd / (fd - fa);
         q33 = (d32 - q22) * fa / (fe - fa);
         c = a + q31 + q32 + q33;
       endif
       if (l < 4 || sign (c - a) * sign (c - b) > 0)
-        ## quadratic interpolation + newton
+        ## Quadratic interpolation + newton.
         a0 = fa;
         a1 = (fb - fa)/(b - a);
         a2 = ((fd - fb)/(d - b) - a1) / (d - a);
-        ## modification 1: this is simpler and does not seem to be worse
+        ## Modification 1: this is simpler and does not seem to be worse.
         c = a - a0/a1;
         if (a2 != 0)
           c = a - a0/a1;
           for i = 1:itype
             pc = a0 + (a1 + a2*(c - b))*(c - a);
             pdc = a1 + a2*(2*c - a - b);
             if (pdc == 0)
               c = a - a0/a1;
               break;
             endif
             c -= pc/pdc;
           endfor
         endif
       endif
       itype += 1; 
     case 4
-      ## double secant step
+      ## Double secant step.
       c = u - 2*(b - a)/(fb - fa)*fu;
-      ## bisect if too far
+      ## Bisect if too far.
       if (abs (c - u) > 0.5*(b - a))
         c = 0.5 * (b + a);
       endif
       itype = 5;
     case 5
-      ## bisection step
+      ## Bisection step.
       c = 0.5 * (b + a);
       itype = 2;
     endswitch
 
-    ## don't let c come too close to a or b
+    ## Don't let c come too close to a or b.
     delta = 2*0.7*(2 * abs (u) * eps + tolx);
     if ((b - a) <= 2*delta)
       c = (a + b)/2;
     else
       c = max (a + delta, min (b - delta, c));
     endif
 
-    ## calculate new point
+    ## Calculate new point.
     x = c;
     fval = fc = fun (c); 
     niter ++; nfev ++;
 
-    ## modification 2: skip inverse cubic interpolation if
-    ## nonmonotonicity is detected
+    ## Modification 2: skip inverse cubic interpolation if
+    ## nonmonotonicity is detected.
     if (sign (fc - fa) * sign (fc - fb) >= 0)
-      ## the new point broke monotonicity. 
-      ## disable inverse cubic 
+      ## The new point broke monotonicity. 
+      ## Disable inverse cubic.
       fe = fc;
     else
       e = d; fe = fd;
     endif
 
-    ## bracketing
+    ## Bracketing.
     if (sign (fa) * sign (fc) < 0)
       d = b; fd = fb;
       b = c; fb = fc;
     elseif (sign (fb) * sign (fc) < 0)
       d = a; fd = fa;
       a = c; fa = fc;
     elseif (fc == 0)
       a = b = c; fa = fb = fc;
       info = 1;
       break;
     else
-      ## this should never happen.
+      ## This should never happen.
       error ("fzero:bracket", "fzero: zero point is not bracketed");
     endif
 
-    ## if there's an output function, use it now
+    ## If there's an output function, use it now.
     if (outfcn)
       optv.funccount = niter + 2;
       optv.fval = fval;
       optv.iteration = niter;
       if (outfcn (x, optv, "iter"))
         info = -1;
         break;
       endif
@@ -261,33 +261,33 @@ function [x, fval, info, output] = fzero
     else
       u = b; fu = fb;
     endif
     if (b - a <= 2*(2 * abs (u) * eps + tolx))
       info = 1;
       break;
     endif
 
-    ## skip bisection step if successful reduction
+    ## Skip bisection step if successful reduction.
     if (itype == 5 && (b - a) <= mba)
       itype = 2;
     endif
     if (itype == 2)
       mba = mu * (b - a);
     endif
   endwhile
 
   output.iterations = niter;
   output.funcCount = niter + 2;
   output.bracket = [a, b];
   output.bracketf = [fa, fb];
 
 endfunction
 
-## an assistant function that evaluates a function handle and checks for
+## An assistant function that evaluates a function handle and checks for
 ## bad results.
 function fx = guarded_eval (fun, x)
   fx = fun (x);
   fx = fx(1);
   if (! isreal (fx))
     error ("fzero:notreal", "fzero: non-real value encountered"); 
   elseif (isnan (fx))
     error ("fzero:isnan", "fzero: NaN value encountered"); 
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -64,50 +64,50 @@ function [x, resnorm, residual, exitflag
 
   ## Lawson-Hanson Step 1 (LH1): initialize the variables.
   if (isempty (x))
     ## Initial guess is 0s.
     x = zeros (columns (c), 1);
   endif
 
 
-  MaxIter = optimget (options, "MaxIter", 1e5);
+  max_iter = optimget (options, "MaxIter", 1e5);
 
   ## Initialize the values.
   p = false (1, numel (x));
-  z = ~p;
+  z = !p;
   ## If the problem is significantly over-determined, preprocess it using a
   ## QR factorization first.
   if (rows (c) >= 1.5 * columns (c))
     [q, r] = qr (c, 0);
     d = q'*d;
     c = r;
     clear q
   endif
   ## LH2: compute the gradient.
   w = c'*(d - c*x);
 
   xtmp = zeros (columns (c), 1);
 
   iter = 0;
   ## LH3: test for completion.
-  while (any (z) && any (w(z) > 0) && iter < MaxIter)
+  while (any (z) && any (w(z) > 0) && iter < max_iter)
     ## LH4: find the maximum gradient.
     idx = find (w == max (w));
     if (numel (idx) > 1)
       warning ("lsqnonneg:nonunique",
                "A non-unique solution may be returned due to equal gradients.");
       idx = idx(1);
     endif
     ## LH5: move the index from Z to P.
     z(idx) = false;
     p(idx) = true;
 
     newx = false;
-    while (! newx && iter < MaxIter)
+    while (! newx && iter < max_iter)
       iter++;
 
       ## LH6: compute the positive matrix and find the min norm solution
       ## of the positive problem.
       ## Find min norm solution to the positive matrix.
       xtmp(:) = 0;
       xtmp(p) = c(:,p) \ d;
       if (all (xtmp >= 0))
@@ -117,32 +117,32 @@ function [x, resnorm, residual, exitflag
       else
         ## LH8, LH9: find the scaling factor and adjust X.
         mask = (xtmp < 0);
         alpha = min (x(mask)./(x(mask) - xtmp(mask)));
         ## LH10: adjust X.
         x = x + alpha*(xtmp - x);
         ## LH11: move from P to Z all X == 0.
         z |= (x == 0);
-        p = ~z;
+        p = !z;
       endif
     endwhile
     w = c'*(d - c*x);
   endwhile
   ## LH12: complete.
 
   ## Generate the additional output arguments.
   if (nargout > 1)
     resnorm = norm (c*x - d) ^ 2;
   endif
   if (nargout > 2)
     residual = d - c*x;
   endif
   exitflag = iter;
-  if (nargout > 3 && iter >= MaxIter)
+  if (nargout > 3 && iter >= max_iter)
     exitflag = 0;
   endif
   if (nargout > 4)
     output = struct ("algorithm", "nnls", "iterations", iter);
   endif
   if (nargout > 5)
     lambda = w;
   endif
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -187,17 +187,17 @@ function [x, obj, INFO, lambda] = qp (x0
 	  elseif (isempty (A_lb))
 	    Ain = [Ain; -A_in];
 	    bin = [bin; -A_ub];
 	  endif
 	endif
 	
 	if (! isempty (A_lb) && ! isempty (A_ub))
 	  rtol = sqrt (eps);
-	  for i=1:dimA_in
+	  for i = 1:dimA_in
 	    if (abs (A_lb(i) - A_ub(i)) < rtol*(1 + max (abs (A_lb(i) + A_ub(i)))))
               ## These are actually an equality constraint
 	      tmprow = A_in(i,:);
               A = [A;tmprow];
               b = [b; 0.5*(A_lb(i) + A_ub(i))];
 	      n_eq = n_eq + 1;
 	    else
 	      tmprow = A_in(i,:);
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -974,17 +974,17 @@ function [pkg_desc_list, flag] = describ
     flag(1:num_packages) = {"Not Loaded"};
     num_pkgnames = num_packages;
   else
     num_pkgnames = length (pkgnames);
     flag(1:num_pkgnames) = {"Not installed"};
   endif
 
   for i = 1:num_packages
-    curr_name= installed_pkgs_lst{i}.name;
+    curr_name = installed_pkgs_lst{i}.name;
     if (describe_all)
       name_pos = i;
     else
       name_pos = find(strcmp (curr_name, pkgnames));
     endif
 
     if (! isempty (name_pos))
       if (installed_pkgs_lst{i}.loaded)
diff --git a/scripts/plot/__area__.m b/scripts/plot/__area__.m
--- a/scripts/plot/__area__.m
+++ b/scripts/plot/__area__.m
@@ -84,17 +84,17 @@ function move_baseline (h, d)
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
       hlist = get (h, "areagroup");
       b0 = get (h, "basevalue");
 
       for hh = hlist(:)'
-	if (hh != h )
+	if (hh != h)
 	  b1 = get (hh, "basevalue");
 	  if (b1 != b0)
 	    set (hh, "basevalue", b0);
 	  endif
 	endif
       endfor
       update_data (h, d);
     unwind_protect_cleanup
diff --git a/scripts/plot/__clabel__.m b/scripts/plot/__clabel__.m
--- a/scripts/plot/__clabel__.m
+++ b/scripts/plot/__clabel__.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Undocumented internal function.
 
-function h = __clabel__ (c, v, hparent, LabelSpacing, z, varargin)
+function h = __clabel__ (c, v, hparent, label_spacing, z, varargin)
   ## FIXME
   ## Assume that the plot size is 4 by 3 inches.
   lims = axis ();
   xspacing = 72 * 4 / abs(lims(1) - lims(2));
   yspacing = 72 * 3 / abs(lims(3) - lims(4));
 
   if (isscalar (hparent) && ishandle(hparent) && 
 	strcmp (get (hparent, "type"), "hggroup"))
@@ -60,25 +60,25 @@ function h = __clabel__ (c, v, hparent, 
       i1 += clen+1;
       continue;
     endif
 
     p = c(:, i1+1:i1+clen) .* repmat ([xspacing; yspacing], 1, clen);
     d = sqrt (sumsq (diff (p, 1, 2)));
     cumd = cumsum (d);
     td = sum(d);
-    ntag = ceil (td / LabelSpacing);
+    ntag = ceil (td / label_spacing);
 
     if (all (c(:,i1+1) == c(:,i1+clen)))
       Spacing = td / ntag;
       pos = Spacing / 2 + [0:ntag-1] * Spacing;
     else
       pos = zeros(1, ntag);
-      pos(1) = (td - LabelSpacing * (ntag - 1)) ./ 2;
-      pos(2:ntag) = pos(1) + [1:ntag-1] * LabelSpacing;
+      pos(1) = (td - label_spacing * (ntag - 1)) ./ 2;
+      pos(2:ntag) = pos(1) + [1:ntag-1] * label_spacing;
     endif
 
     j1 = 2;
     tlabel = sprintf ("%g", clev);
     for i = 1 : ntag
       tagpos = pos(i);
       
       while (j1 < clen && cumd(j1) < tagpos)
diff --git a/scripts/plot/__stem__.m b/scripts/plot/__stem__.m
--- a/scripts/plot/__stem__.m
+++ b/scripts/plot/__stem__.m
@@ -415,17 +415,17 @@ function [x, y, z, dofill, lc, ls, mc, m
 	endif
       else
 	if (length (x) == rows (y))
 	  x = repmat (x(:), 1, columns (y));
 	else
 	  error ("stem: inconsistent size of x and y");
 	endif
       endif
-    elseif (!size_equal (x, y ))
+    elseif (!size_equal (x, y))
       error ("stem: inconsistent size of x and y");
     endif
   endif
 
 endfunction
 
 function [lc, ls, mc, ms] = stem_line_spec (caller, str)
   if (! ischar (str))
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -23,17 +23,17 @@
 ##
 ## The argument @var{limits} should be a 2, 4, or 6 element vector.  The
 ## first and second elements specify the lower and upper limits for the x
 ## axis.  The third and fourth specify the limits for the y axis, and the
 ## fifth and sixth specify the limits for the z axis.
 ##
 ## Without any arguments, @code{axis} turns autoscaling on.  
 ##
-## With one output argument, @code{x=axis} returns the current axes 
+## With one output argument, @code{x = axis} returns the current axes 
 ##
 ## The vector argument specifying limits is optional, and additional
 ## string arguments may be used to specify various axis properties.  For
 ## example,
 ##
 ## @example
 ## axis ([1, 2, 3, 4], "square");
 ## @end example
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -13,41 +13,41 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} colorbar (@var{s})
-## @deftypefnx {Function File} {} colorbar ('peer', @var{h}, @dots{})
+## @deftypefnx {Function File} {} colorbar ("peer", @var{h}, @dots{})
 ## Adds a colorbar to the current axes. Valid values for @var{s} are
 ##
 ## @table @asis
-## @item 'EastOutside'
+## @item "EastOutside"
 ## Place the colorbar outside the plot to the right. This is the default.
-## @item 'East'
+## @item "East"
 ## Place the colorbar inside the plot to the right.
-## @item 'WestOutside'
+## @item "WestOutside"
 ## Place the colorbar outside the plot to the left.
-## @item 'West'
+## @item "West"
 ## Place the colorbar inside the plot to the left.
-## @item 'NorthOutside'
+## @item "NorthOutside"
 ## Place the colorbar above the plot.
-## @item 'North'
+## @item "North"
 ## Place the colorbar at the top of the plot.
-## @item 'SouthOutside'
+## @item "SouthOutside"
 ## Place the colorbar under the plot.
-## @item 'South'
+## @item "South"
 ## Place the colorbar at the bottom of the plot.
-## @item 'Off', 'None'
+## @item "Off", "None"
 ## Remove any existing colorbar from the plot.
 ## @end table
 ##
-## If the argument 'peer' is given, then the following argument is treated
+## If the argument "peer" is given, then the following argument is treated
 ## as the axes handle on which to add the colorbar.
 ## @end deftypefn
 
 
 ## PKG_ADD: mark_as_command colorbar
 
 function h = colorbar (varargin)
   ax = [];
@@ -57,22 +57,22 @@ function h = colorbar (varargin)
 
   i = 1;
   while (i <= nargin)
     arg = varargin {i++};
 
     if (ischar(arg))
       if (strcmpi (arg, "peer"))
 	if (i > nargin)
-	  error ("colorbar: missing axes handle after 'peer'");
+	  error ("colorbar: missing axes handle after \"peer\"");
 	else
 	  ax = vargin{i++}
 	  if (!isscalar (ax) || ! ishandle (ax)
 	      || strcmp (get (ax, "type"), "axes"))
-	    error ("colorbar: expecting an axes handle following 'peer'");
+	    error ("colorbar: expecting an axes handle following \"peer\"");
 	  endif
 	endif
       elseif (strcmpi (arg, "north") || strcmpi (arg, "south")
 	      || strcmpi (arg, "east") || strcmpi (arg, "west")
 	      || strcmpi (arg, "northoutside") || strcmpi (arg, "southoutside")
 	      || strcmpi (arg, "eastoutside") || strcmpi (arg, "westoutside"))
 	loc = arg;
       elseif (strcmpi (arg, "off") || strcmpi (arg, "none"))
diff --git a/scripts/plot/contour3.m b/scripts/plot/contour3.m
--- a/scripts/plot/contour3.m
+++ b/scripts/plot/contour3.m
@@ -29,17 +29,17 @@
 ## arguments; see the latter for their interpretation.  The contours are
 ## ploted at the Z level corresponding to their contour. The set of
 ## contour levels, @var{c}, is only returned if requested.  For example:
 ##
 ## @example
 ## @group
 ## contour3 (peaks (19));
 ## hold on
-## surface (peaks (19), 'FaceColor', 'none', 'EdgeColor', 'black')
+## surface (peaks (19), "facecolor", "none", "EdgeColor", "black")
 ## colormap hot
 ## @end group
 ## @end example
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## Any markers defined by @var{style} are ignored.
 ##
@@ -71,11 +71,11 @@ function [c, h] = contour3 (varargin)
     h = htmp;
   endif
 
 endfunction
 
 %!demo
 %! contour3 (peaks (19));
 %! hold on
-%! surface (peaks (19), 'FaceColor', 'none', 'EdgeColor', 'black')
+%! surface (peaks (19), "facecolor", "none", "edgecolor", "black")
 %! colormap hot
 %! hold off
diff --git a/scripts/plot/findall.m b/scripts/plot/findall.m
--- a/scripts/plot/findall.m
+++ b/scripts/plot/findall.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{h} =} findall ()
-## @deftypefnx {Function File} {@var{h} =} findall (@var{propName}, @var{propValue})
+## @deftypefnx {Function File} {@var{h} =} findall (@var{prop_name}, @var{prop_value})
 ## @deftypefnx {Function File} {@var{h} =} findall (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findall (@var{h}, "-depth", @var{d}, @dots{})
 ## Find object with specified property values including hidden handles.
 ##
 ## This function performs the same function as @code{findobj}, but it
 ## includes hidden objects in its search.  For full documentation, see
 ## @code{findobj}.
 ## @seealso{get, set, findobj, allchild}
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -13,54 +13,54 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{h} =} findobj ()
-## @deftypefnx {Function File} {@var{h} =} findobj (@var{propName}, @var{propValue})
-## @deftypefnx {Function File} {@var{h} =} findobj ('-property', @var{propName})
-## @deftypefnx {Function File} {@var{h} =} findobj ('-regexp', @var{propName},, @var{pattern})
+## @deftypefnx {Function File} {@var{h} =} findobj (@var{prop_name}, @var{prop_value})
+## @deftypefnx {Function File} {@var{h} =} findobj ('-property', @var{prop_name})
+## @deftypefnx {Function File} {@var{h} =} findobj ('-regexp', @var{prop_name}, @var{pattern})
 ## @deftypefnx {Function File} {@var{h} =} findobj ('flat', @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, '-depth', @var{d}, @dots{})
 ## Find object with specified property values. The simplest form is
 ##
 ## @example
-## findobj (@var{propName}, @var{propValue})
+## findobj (@var{prop_name}, @var{prop_Value})
 ## @end example
 ##
 ## @noindent
 ## which returns all of the handles to the objects with the name 
-## @var{propName} and the name @var{propValue}. The search can be limited
+## @var{prop_name} and the name @var{prop_Value}. The search can be limited
 ## to a particular object or set of objects and their descendants by 
 ## passing a handle or set of handles @var{h} as the first argument to 
 ## @code{findobj}.
 ##
 ## The depth of hierarchy of objects to which to search to can be limited
 ## with the '-depth' argument. To limit the number depth of the hierarchy
 ## to search to @var{d} generations of children, and example is
 ##
 ## @example
-## findobj (@var{h}, '-depth', @var{d}, @var{propName}, @var{propValue})
+## findobj (@var{h}, '-depth', @var{d}, @var{prop_Name}, @var{prop_Value})
 ## @end example
 ##
 ## Specifying a depth @var{d} of 0, limits the search to the set of object
 ## passed in @var{h}. A depth @var{d} of 0 is equivalent to the '-flat'
 ## argument. 
 ##
-## A specified logical operator may be applied to the pairs of @var{propName}
-## and @var{propValue}. The supported logical operators are '-and', '-or', 
+## A specified logical operator may be applied to the pairs of @var{prop_Name}
+## and @var{prop_Value}. The supported logical operators are '-and', '-or', 
 ## '-xor', '-not'.
 ##
 ## The objects may also be matched by comparing a regular expression to the 
 ## property values, where property values that match @code{regexp 
-## (@var{propValue}, @var{pattern})} are returned.  Finally, objects may be 
+## (@var{prop_Value}, @var{pattern})} are returned.  Finally, objects may be 
 ## matched by property name only, using the '-property' option.
 ## @seealso{get, set}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 
 function h = findobj (varargin)
 
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -103,20 +103,20 @@ function fplot (fn, limits, n, linespec)
   else
     plot (x, y);
   endif
 
   if (length (limits) > 2) 
     axis (limits);
   endif
 
-  if (isvector(y))
+  if (isvector (y))
     legend (nam);
   else
-    for i=1:columns(y)
+    for i = 1:columns (y)
       nams{i} = sprintf ("%s(:,%i)", nam, i);
     endfor
     legend (nams{:});
   endif
 endfunction
 
 %!demo
 %! fplot ("cos", [0, 2*pi])
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -53,17 +53,17 @@ function grid (varargin)
 	grid_on = false;
       elseif (strcmpi (x, "on"))
 	grid_on = true;
       elseif (strcmpi (x, "minor"))
         if (nargs == 2)
 	  x2 = varargin{2};
 	  if (strcmpi (x2, "on"))
 	    minor_on = true;
-	    grid_on=true;
+	    grid_on = true;
 	  elseif (strcmpi (x2, "off"))
 	    minor_on = false;
 	  else
 	    print_usage ();
 	  endif
 	else
 	   minor_on = ! minor_on
 	   if (minor_on)
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -156,16 +156,16 @@ endfunction
 %!  assert(nn, [3,2,1]);
 %!test
 %!  [nn,xx]=hist([[1:4]',[1:4]'],3);
 %!  assert(xx, [1.5;2.5;3.5]);
 %!  assert(nn, [[2,1,1]',[2,1,1]']);
 %!assert(hist(1,1),1);
 %!test
 %!  for n = [10, 30, 100, 1000]
-%!    assert( sum(hist([1:n], n)), n );
-%!    assert( sum(hist([1:n], [2:n-1])), n);
-%!    assert( sum(hist([1:n], [1:n])), n );
-%!    assert( sum(hist([1:n], 29)), n);
-%!    assert( sum(hist([1:n], 30)), n);
+%!    assert(sum(hist([1:n], n)), n);
+%!    assert(sum(hist([1:n], [2:n-1])), n);
+%!    assert(sum(hist([1:n], [1:n])), n);
+%!    assert(sum(hist([1:n], 29)), n);
+%!    assert(sum(hist([1:n], 30)), n);
 %!  endfor
 %!test
 %!  assert (size (hist(randn(750,240), 200)), [200,240]);
diff --git a/scripts/polynomial/convn.m b/scripts/polynomial/convn.m
--- a/scripts/polynomial/convn.m
+++ b/scripts/polynomial/convn.m
@@ -116,13 +116,13 @@ endfunction
 %! ## Real data
 %! a = ones (10,10,10); 
 %! b = ones (3,3,3);
 %! c = convn (a, b, "valid");
 %! assert (all (c == numel (b)));
 
 %!test
 %! ## Complex data
-%! a = complex( ones (10,10,10), ones(10,10,10) ); 
-%! b = complex( ones (3,3,3), ones(3,3,3) );
+%! a = complex(ones (10,10,10), ones(10,10,10));
+%! b = complex(ones (3,3,3), ones(3,3,3));
 %! c = convn (a, b, "valid");
 %! assert (all (c == 2*i*numel (b)));
 
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -34,17 +34,17 @@ function p = polyreduce (p)
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! (isvector (p) || isempty (p)))
     error ("polyreduce: argument must be a vector");
   endif
 
-  if (! isempty (p) )
+  if (! isempty (p))
 
     index = find (p != 0);
 
     if (isempty (index))
       
       p = 0;
     
     else
diff --git a/scripts/set/intersect.m b/scripts/set/intersect.m
--- a/scripts/set/intersect.m
+++ b/scripts/set/intersect.m
@@ -82,17 +82,17 @@ function [c, ia, ib] = intersect (a, b, 
 endfunction
 
 
 %!# Test the routine for index vectors ia and ib
 %!test
 %! a = [3 2 4 5 7 6 5 1 0 13 13];
 %! b = [3 5 12 1 1 7];
 %! [c,ia,ib] = intersect(a,b);
-%! assert( c,[1 3 5 7]);
+%! assert(c,[1 3 5 7]);
 %! assert(ia,[8 1 7 5]);
 %! assert(ib,[5 1 2 6]);
 %! assert(a(ia),c);
 %! assert(b(ib),c);
 %!test
 %! a = [1,1,2;1,4,5;2,1,7];
 %! b = [1,4,5;2,3,4;1,1,2;9,8,7];
 %! [c,ia,ib] = intersect(a,b,'rows');
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -22,18 +22,18 @@
 ## @deftypefnx {Function File} {} setxor (@var{a}, @var{b}, 'rows')
 ##
 ## Return the elements exclusive to @var{a} or @var{b}, sorted in ascending
 ## order. If @var{a} and @var{b} are both column vectors return a column
 ## vector, otherwise return a row vector.
 ##
 ## @deftypefnx {Function File} {[@var{c}, @var{ia}, @var{ib}] =} setxor (@var{a}, @var{b})
 ##
-## Return index vectors @var{ia} and @var{ib} such that @code{a==c(ia)} and
-## @code{b==c(ib)}.
+## Return index vectors @var{ia} and @var{ib} such that @code{a == c(ia)} and
+## @code{b == c(ib)}.
 ## 
 ## @seealso{unique, union, intersect, setdiff, ismember}
 ## @end deftypefn
 
 function [c, ia, ib] = setxor (a, b, varargin)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -40,18 +40,18 @@
 ##      @result{}  1   2
 ##     2   3
 ##     3   4
 ## @end group
 ## @end example
 ##
 ## @deftypefnx {Function File} {[@var{c}, @var{ia}, @var{ib}] =} union (@var{a}, @var{b})
 ##
-## Return index vectors @var{ia} and @var{ib} such that @code{a==c(ia)} and
-## @code{b==c(ib)}.
+## Return index vectors @var{ia} and @var{ib} such that @code{a == c(ia)} and
+## @code{b == c(ib)}.
 ## 
 ## @seealso{create_set, intersect, complement}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [y, ia, ib] = union (a, b, varargin)
 
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -91,17 +91,17 @@ function [a, b] = arch_fit (y, X, p, ITE
   for i = 1 : ITER;
     h    = Z * a;
     tmp  = esq ./ h.^2 - 1 ./ h;
     s    = 1 ./ h(1:T-p);
     for j = 1 : p;
       s = s - a(j+1) * tmp(j+1:T-p+j);
     endfor
     r    = 1 ./ h(1:T-p);
-    for j=1:p;
+    for j = 1:p;
       r = r + 2 * h(j+1:T-p+j).^2 .* esq(1:T-p);
     endfor
     r   = sqrt (r);
     X_tilde = X(1:T-p, :) .* (r * ones (1,k));
     e_tilde = e(1:T-p) .*s ./ r;
     delta_b = inv (X_tilde' * X_tilde) * X_tilde' * e_tilde;
     b   = b + gamma * delta_b;
     e   = y - X * b;
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -35,17 +35,17 @@
 
 function [newphi, newv] = durbinlevinson (c, oldphi, oldv)
 
   if (! ((nargin == 1) || (nargin == 3)))
     print_usage ();
   endif
 
   if (columns (c) > 1)
-    c=c';
+    c = c';
   endif
 
   newphi = 0;
   newv = 0;
 
   if (nargin == 3)
 
     t = length (oldphi) + 1;
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -54,32 +54,32 @@ function retval = fftshift (V, dim)
   if (nargin == 2)
     if (!isscalar (dim))
       error ("fftshift: dimension must be an integer scalar");
     endif
     nd = ndims (V);
     sz = size (V);
     sz2 = ceil (sz(dim) / 2);
     idx = cell ();
-    for i=1:nd
+    for i = 1:nd
       idx{i} = 1:sz(i);
     endfor
     idx{dim} = [sz2+1:sz(dim), 1:sz2];
     retval = V (idx{:});
   else
     if (isvector (V))
       x = length (V);
       xx = ceil (x/2);
       retval = V([xx+1:x, 1:xx]);
     elseif (ismatrix (V))
       nd = ndims (V);
       sz = size (V);
       sz2 = ceil (sz ./ 2);
       idx = cell ();
-      for i=1:nd
+      for i = 1:nd
         idx{i} = [sz2(i)+1:sz(i), 1:sz2(i)];
       endfor
       retval = V (idx{:});
     else
       error ("fftshift: expecting vector or matrix argument");
     endif
   endif
 
diff --git a/scripts/signal/freqz_plot.m b/scripts/signal/freqz_plot.m
--- a/scripts/signal/freqz_plot.m
+++ b/scripts/signal/freqz_plot.m
@@ -38,17 +38,17 @@ function freqz_plot (w, h)
 
   mag = 20 * log10 (abs (h));
   phase = unwrap (arg (h));
   maxmag = max (mag);
 
   subplot (3, 1, 1);
   plot (w, mag);
   grid ("on");
-  legend("Pass band (dB)");
+  legend ("Pass band (dB)");
   axis ([w(1), w(n), maxmag-3, maxmag], "labely");
 
   subplot (3, 1, 2);
   plot (w, mag);
   grid ("on");
   legend ("Stop band (dB)");
   if (maxmag - min (mag) > 100)
     axis ([w(1), w(n), maxmag-100, maxmag], "labely");
diff --git a/scripts/signal/ifftshift.m b/scripts/signal/ifftshift.m
--- a/scripts/signal/ifftshift.m
+++ b/scripts/signal/ifftshift.m
@@ -41,32 +41,32 @@ function retval = ifftshift (V, dim)
   if (nargin == 2)
     if (! isscalar (dim))
       error ("ifftshift: dimension must be an integer scalar");
     endif
     nd = ndims (V);
     sz = size (V);
     sz2 = floor (sz(dim) / 2);
     idx = cell ();
-    for i=1:nd
+    for i = 1:nd
       idx{i} = 1:sz(i);
     endfor
     idx{dim} = [sz2+1:sz(dim), 1:sz2];
     retval = V (idx{:});
   else
     if (isvector (V))
       x = length (V);
       xx = floor (x/2);
       retval = V([xx+1:x, 1:xx]);
     elseif (ismatrix (V))
       nd = ndims (V);
       sz = size (V);
       sz2 = floor (sz ./ 2);
       idx = cell ();
-      for i=1:nd
+      for i = 1:nd
         idx{i} = [sz2(i)+1:sz(i), 1:sz2(i)];
       endfor
       retval = V (idx{:});
     else
       error ("ifftshift: expecting vector or matrix argument");
     endif
   endif
 
diff --git a/scripts/signal/spectral_adf.m b/scripts/signal/spectral_adf.m
--- a/scripts/signal/spectral_adf.m
+++ b/scripts/signal/spectral_adf.m
@@ -33,17 +33,17 @@
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Spectral density estimation
 
 function retval = spectral_adf (c, win, b)
 
   cr = length (c);
 
   if (columns (c) > 1)
-    c=c';
+    c = c';
   endif
 
   if (nargin < 3)
     b = 1 / ceil (sqrt (cr));
   endif
 
   if (nargin == 1)
     w = triangle_lw (cr, b);
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -55,120 +55,120 @@ function [x, flag, relres, iter, resvec]
     error ("bicgstab: maxit must be a scalar");
   elseif (nargin > 4 && ismatrix (M1) && (rows (M1) != rows (A) || columns (M1) != columns (A)))
     error ("bicgstab: M1 must have the same number of rows and columns as A");
   elseif (nargin > 5 && (!ismatrix (M2) || rows (M2) != rows (A) || columns (M2) != columns (A)))
     error ("bicgstab: M2 must have the same number of rows and columns as A");
   elseif (nargin > 6 && !isvector (x0))
     error ("bicgstab: x0 must be a vector");
   elseif (nargin > 6 && rows (x0) != rows (b))
-    error ("bicgstab: xO must have the same number of rows as b");
+    error ("bicgstab: x0 must have the same number of rows as b");
   endif
 
-  ## default toleration
+  ## Default tolerance.
   if (nargin < 3)
     tol = 1e-6;
   endif
 
-  ## default maximum number of iteration
+  ## Default maximum number of iteration.
   if (nargin < 4)
     maxit = min (rows (b), 20);
   endif
 
-  ## left preconditioner
+  ## Left preconditioner.
   if (nargin == 5)
     precon = M1;
   elseif (nargin > 5)
     if (isparse(M1) && issparse(M2))
       precon = @(x) M1 * (M2 * x);
     else
       precon = M1 * M2;
     endif 
   endif
 
   if (nargin > 4 && isnumeric (precon))
-    ## precon can by also function
+    ## Precon can by also function.
     if (det (precon) != 0) 
-      ## we can compute inverse preconditioner and use quicker algorithm
-      precon=inv (precon);
+      ## We can compute inverse preconditioner and use quicker algorithm.
+      precon = inv (precon);
     else
       error ("bicgstab: preconditioner is ill conditioned");
     endif
 
     if (isinf (cond (precon))); 
-      ## we must make test if preconditioner isn't ill conditioned
+      ## We must make test if preconditioner isn't ill conditioned.
       error ("bicgstab: preconditioner is ill conditioned");
     endif
   endif
 
   ## specifies initial estimate x0
   if (nargin < 7)
     x = zeros (rows (b), 1);
   else
     x = x0;
   endif
 
   norm_b = norm (b);
 
   res = b - A*x;
   rr = res;
 
-  ## vector of the residual norms for each iteration
+  ## Vector of the residual norms for each iteration.
   resvec = [norm(res)];
 
-  ## default behaviour we don't reach tolerance tol within maxit iterations
+  ## Default behaviour we don't reach tolerance tol within maxit iterations.
   flag = 1;
 
   for iter = 1:maxit
     rho_1 = res' * rr;
 
     if (iter == 1)
       p = res;
     else
       beta = (rho_1 / rho_2) * (alpha / omega);
       p = res + beta * (p - omega * v);
     endif
 
     if (nargin > 4 && isnumeric (precon))
       phat = precon * p;
     elseif (nargin > 4)
-      ## our preconditioner is a function
+      ## Our preconditioner is a function.
       phat = feval (precon, p);
     else
       phat = p;
     endif
 
     v = A * phat;
     alpha = rho_1 / (rr' * v);
     s = res - alpha * v;
 
     if (nargin > 4 && isnumeric (precon))
       shat = precon * s;
     elseif (nargin > 4)
-      ## our preconditioner is a function
+      ## Our preconditioner is a function.
       shat = feval (precon, s);
     else
       shat = s;
     endif
 
     t = A * shat; 
     omega = (t' * s) / (t' * t);
     x = x + alpha * phat + omega * shat;
     res = s - omega * t;
     rho_2 = rho_1;
 
     relres = norm (res) / norm_b;
     resvec = [resvec; relres];
 
     if (relres <= tol)
-      ## we reach tolerance tol within maxit iterations
+      ## We reach tolerance tol within maxit iterations.
       flag = 0;
       break;
-    elseif ( resvec (end) == resvec (end - 1)) 
-      ## the method stagnates
+    elseif (resvec (end) == resvec (end - 1)) 
+      ## The method stagnates.
       flag = 3;
       break;
     endif
   endfor
 
 endfunction
 
 %!demo
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -46,108 +46,108 @@ function [x, flag, relres, iter, resvec]
     error ("cgs: maxit must be a scalar");
   elseif (nargin > 4 && ismatrix (M1) && (rows (M1) != rows (A) || columns (M1) != columns (A)))
     error ("cgs: M1 must have the same number of rows and columns as A");
   elseif (nargin > 5 && (!ismatrix (M2) || rows (M2) != rows (A) || columns (M2) != columns (A)))
     error ("cgs: M2 must have the same number of rows and columns as A");
   elseif (nargin > 6 && !isvector (x0))
     error ("cgs: x0 must be a vector");
   elseif (nargin > 6 && rows (x0) != rows (b))
-    error ("cgs: xO must have the same number of rows as b");
+    error ("cgs: x0 must have the same number of rows as b");
   endif
 
-  ## default toleration
+  ## Default tolerance.
   if (nargin < 3)
     tol = 1e-6;
   endif
 
-  ## default maximum number of iteration
+  ## Default maximum number of iteration.
   if (nargin < 4)
     maxit = min (rows (b),20);
   endif
 
-
-  ## left preconditioner
+  ## Left preconditioner.
   precon = [];
   if (nargin == 5)
     precon = M1;
   elseif (nargin > 5)
     if (isparse(M1) && issparse(M2))
       precon = @(x) M1 * (M2 * x);
     else
       precon = M1 * M2;
     endif
   endif
 
-  ## precon can by also function
+  ## Precon can also be a function.
   if (nargin > 4 && isnumeric (precon))
 
-    ## we can compute inverse preconditioner and use quicker algorithm
+    ## We can compute inverse preconditioner and use quicker algorithm.
     if (det (precon) != 0)
-     precon=inv (precon);
+     precon = inv (precon);
     else
      error ("cgs: preconditioner is ill conditioned");
     endif
 
-    ## we must make test if preconditioner isn't ill conditioned
+    ## We must make test if preconditioner isn't ill conditioned.
     if (isinf (cond (precon))); 
       error ("cgs: preconditioner is ill conditioned");
     endif
   endif
 
-  ## specifies initial estimate x0
+  ## Specifies initial estimate x0.
   if (nargin < 7)
     x = zeros (rows (b), 1);
   else
     x = x0;
   endif
 
   relres = b - A * x;
-  ## vector of the residual norms for each iteration
+  ## Vector of the residual norms for each iteration.
   resvec = [norm(relres)];
   ro = 0;
   norm_b = norm (b);
-  ## default behaviour we don't reach tolerance tol within maxit iterations
+  ## Default behavior we don't reach tolerance tol within maxit iterations.
   flag = 1;
   for iter = 1 : maxit
 
     if (nargin > 4 && isnumeric (precon))
-      ## we have computed inverse matrix so we can use quick algorithm
+      ## We have computed inverse matrix so we can use quick algorithm.
       z = precon * relres;
     elseif (nargin > 4)
-      ## our preconditioner is a function
+      ## Our preconditioner is a function.
       z = feval (precon, relres);
     else
-      ## we don't use preconditioning
+      ## We don't use preconditioning.
       z = relres;
     endif
 
-    ## cache
+    ## Cache.
     ro_old = ro;
     ro = relres' * z;
     if (iter == 1)
       p = z;
     else
       beta = ro / ro_old;
       p = z + beta * p;
     endif
-    q = A * p; #cache
+    ## Cache.
+    q = A * p;
     alpha = ro / (p' * q);
     x = x + alpha * p;
 
     relres = relres - alpha * q;
     resvec = [resvec; norm(relres)];
 
     relres_distance = resvec (end) / norm_b;
     if (relres_distance <= tol)
-      ## we reach tolerance tol within maxit iterations
+      ## We reach tolerance tol within maxit iterations.
       flag = 0;
       break;
-    elseif (resvec (end) == resvec (end - 1) )
-      ## the method stagnates
+    elseif (resvec (end) == resvec (end - 1))
+      ## The method stagnates.
       flag = 3;
       break;
     endif
   endfor;
 
   relres = relres_distance;
 endfunction
 
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -27,27 +27,27 @@
 ##
 ## The optional parameter @var{line_style} defines the output style for
 ## the plot.  Called with no output arguments the graph is plotted
 ## directly.  Otherwise, return the coordinates of the plot in @var{x}
 ## and @var{y}.
 ## @seealso{treeplot, etreeplot, spy}
 ## @end deftypefn
 
-function [x, y] = gplot (A, xy, line_style)
+function [x, y] = gplot (a, xy, line_style)
 
   if (nargin < 2 || nargin > 3 || nargout > 2)
     print_usage ();
   endif
 
   if (nargin == 2)
     line_style = "-";
   endif
 
-  [i, j] = find (A);
+  [i, j] = find (a);
   xcoord = [xy(i,1), xy(j,1), NaN * ones(length(i),1)]'(:);
   ycoord = [xy(i,2), xy(j,2), NaN * ones(length(i),1)]'(:);
 
   if (nargout == 0)
     plot (xcoord, ycoord, line_style); 
   else
     x = xcoord;
     y = ycoord;
diff --git a/scripts/sparse/normest.m b/scripts/sparse/normest.m
--- a/scripts/sparse/normest.m
+++ b/scripts/sparse/normest.m
@@ -36,17 +36,17 @@ function [e1, c] = normest (A, tol)
     if (tol < eps ("single"))
       tol = eps ("single");
     endif
   else
     if (tol < eps)
       tol = eps
     endif
   endif
-  if (ndims(A) != 2)
+  if (ndims (A) != 2)
     error ("normest: A must be a matrix");
   endif 
   maxA = max (max (abs (A)));
   c = 0;
   if (maxA == 0)
     e1 = 0
   else
     [m, n] = size (A);
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -117,87 +117,87 @@
 ## verifying this assumption. 
 ## @end itemize
 ## 
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A) 
 ## 
 ## @example
 ## @group
-## 	N = 10; 
-## 	A = diag (sparse([1:N]));
-## 	b = rand (N, 1);
-##      [L, U, P, Q] = luinc (A,1.e-3);
+## 	n = 10; 
+## 	a = diag (sparse (1:n));
+## 	b = rand (n, 1);
+##      [l, u, p, q] = luinc (a, 1.e-3);
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 1:} Simplest use of @code{pcg}
 ## 
 ## @example
 ##   x = pcg(A,b)
 ## @end example
 ## 
 ## @sc{Example 2:} @code{pcg} with a function which computes
 ## @code{@var{a} * @var{x}}
 ## 
 ## @example
 ## @group
-##   function y = applyA (x)
+##   function y = apply_a (x)
 ##     y = [1:N]'.*x; 
 ##   endfunction
 ##
-##   x = pcg ("applyA", b)
+##   x = pcg ("apply_a", b)
 ## @end group
 ## @end example
 ##
 ## @sc{Example 3:} @code{pcg} with a preconditioner: @var{l} * @var{u}
 ##
 ## @example
-## x=pcg(A,b,1.e-6,500,L*U);
+## x = pcg (a, b, 1.e-6, 500, l*u);
 ## @end example
 ##
 ## @sc{Example 4:} @code{pcg} with a preconditioner: @var{l} * @var{u}.
 ## Faster than @sc{Example 3} since lower and upper triangular matrices 
 ## are easier to invert
 ##
 ## @example
-## x=pcg(A,b,1.e-6,500,L,U);
+## x = pcg (a, b, 1.e-6, 500, l, u);
 ## @end example
 ##
 ## @sc{Example 5:} Preconditioned iteration, with full diagnostics. The
 ## preconditioner (quite strange, because even the original matrix
 ## @var{a} is trivial) is defined as a function
 ## 
 ## @example
 ## @group
-##   function y = applyM(x)
-##     K = floor (length (x) - 2);
+##   function y = apply_m (x)
+##     k = floor (length (x) - 2);
 ##     y = x;
-##     y(1:K) = x(1:K)./[1:K]';
+##     y(1:k) = x(1:k)./[1:k]';
 ##   endfunction
 ## 
 ##   [x, flag, relres, iter, resvec, eigest] = ...
-##                      pcg (A, b, [], [], "applyM");
+##                      pcg (a, b, [], [], "apply_m");
 ##   semilogy (1:iter+1, resvec);
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 6:} Finally, a preconditioner which depends on a
 ## parameter @var{k}.
 ## 
 ## @example
 ## @group
-##   function y = applyM (x, varargin)
+##   function y = apply_M (x, varargin)
 ##   K = varargin@{1@}; 
 ##   y = x;
 ##   y(1:K) = x(1:K)./[1:K]';
 ##   endfunction
 ## 
 ##   [x, flag, relres, iter, resvec, eigest] = ...
-##        pcg (A, b, [], [], "applyM", [], [], 3)
+##        pcg (A, b, [], [], "apply_m", [], [], 3)
 ## @end group
 ## @end example
 ## 
 ## @sc{References}
 ## 
 ## 	[1] C.T.Kelley, 'Iterative methods for linear and nonlinear equations',
 ## 	SIAM, 1995 (the base PCG algorithm) 
 ## 	
@@ -209,37 +209,37 @@
 ## @seealso{sparse, pcr}
 ## @end deftypefn
 
 ## Author: Piotr Krzyzanowski <piotr.krzyzanowski@mimuw.edu.pl>
 ## Modified by: Vittoria Rezzonico <vittoria.rezzonico@epfl.ch>
 ##    - Add the ability to provide the pre-conditioner as two separate
 ## matrices
 
-  function [x, flag, relres, iter, resvec, eigest] = pcg (A, b, tol, maxit, M1, M2, x0, varargin)
+function [x, flag, relres, iter, resvec, eigest] = pcg (a, b, tol, maxit, m1, m2, x0, varargin)
 
-## M = M1*M2
+  ## M = M1*M2
 
   if (nargin < 7 || isempty (x0))
     x = zeros (size (b));
   else
     x = x0;
   endif
 
-if ((nargin < 5) || isempty (M1))
-   existM1 = 0;
-else
-   existM1 = 1;
-endif
+  if (nargin < 5 || isempty (m1))
+     exist_m1 = 0;
+  else
+     exist_m1 = 1;
+  endif
 
-if ((nargin < 6) || isempty (M2))
-   existM2 = 0;
-else
-   existM2 = 1;
-endif
+  if (nargin < 6 || isempty (m2))
+     exist_m2 = 0;
+  else
+     exist_m2 = 1;
+  endif
 
   if (nargin < 4 || isempty (maxit))
     maxit = min (size (b, 1), 20);
   endif
 
   maxit += 2;
 
   if (nargin < 3 || isempty (tol))
@@ -252,58 +252,58 @@ endif
     preconditioned_residual_out = true;
   endif
 
   ## Assume A is positive definite.
   matrix_positive_definite = true;
 
   p = zeros (size (b));
   oldtau = 1; 
-  if (isnumeric (A))
+  if (isnumeric (a))
     ## A is a matrix.
-    r = b - A*x; 
+    r = b - a*x; 
   else
     ## A should be a function.
-    r = b - feval (A, x, varargin{:});
+    r = b - feval (a, x, varargin{:});
   endif
 
   resvec(1,1) = norm (r);
   alpha = 1;
   iter = 2;
 
   while (resvec (iter-1,1) > tol * resvec (1,1) && iter < maxit)
-    if (existM1)
-      if(isnumeric (M1))
-	y = M1 \ r;
+    if (exist_m1)
+      if(isnumeric (m1))
+	y = m1 \ r;
       else
-	y = feval (M1, r, varargin{:});
+	y = feval (m1, r, varargin{:});
       endif
     else
       y = r;
     endif
-    if (existM2)
-      if (isnumeric (M2))
-	z = M2 \ y;
+    if (exist_m2)
+      if (isnumeric (m2))
+	z = m2 \ y;
       else
-	z = feval (M2, y, varargin{:});
+	z = feval (m2, y, varargin{:});
       endif
     else
       z = y;
     endif
     tau = z' * r; 
     resvec (iter-1,2) = sqrt (tau);
     beta = tau / oldtau;
     oldtau = tau;
     p = z + beta * p;
-    if (isnumeric (A))
+    if (isnumeric (a))
       ## A is a matrix.
-      w = A * p;
+      w = a * p;
     else
       ## A should be a function.
-      w = feval (A, p, varargin{:});
+      w = feval (a, p, varargin{:});
     endif
     ## Needed only for eigest.
     oldalpha = alpha;
     alpha = tau / (p'*w);
     if (alpha <= 0.0)
       ## Negative matrix.
       matrix_positive_definite = false;
     endif
@@ -331,30 +331,30 @@ endif
 	warning ("pcg: eigenvalue estimate failed: iteration converged too fast.");
       endif
     else
       eigest = [NaN, NaN];
     endif
 
     ## Apply the preconditioner once more and finish with the precond
     ## residual.
-    if (existM1)
-      if(isnumeric (M1))
-	y = M1 \ r;
+    if (exist_m1)
+      if (isnumeric (m1))
+	y = m1 \ r;
       else
-	y = feval (M1, r, varargin{:});
+	y = feval (m1, r, varargin{:});
       endif
     else
       y = r;
     endif
-    if (existM2)
-      if (isnumeric (M2))
-	z = M2 \ y;
+    if (exist_m2)
+      if (isnumeric (m2))
+	z = m2 \ y;
       else
-	z = feval (M2, y, varargin{:});
+	z = feval (m2, y, varargin{:});
       endif
     else
       z = y;
     endif
 
     resvec (iter-1,2) = sqrt (r' * z);
   else
     resvec = resvec(:,1);
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -95,96 +95,96 @@
 ## 1,2, @dots{}, @var{iter}+1}.
 ## @end itemize
 ## 
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A) 
 ## 
 ## @example
 ## @group
-## 	N = 10; 
-## 	A = diag([1:N]); A = sparse(A);  
-## 	b = rand(N,1);
+## 	n = 10; 
+## 	a = sparse (diag (1:n));
+## 	b = rand (N, 1);
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 1:} Simplest use of @code{pcr}
 ## 
 ## @example
 ##   x = pcr(A, b)
 ## @end example
 ## 
 ## @sc{Example 2:} @code{pcr} with a function which computes
 ## @code{@var{a} * @var{x}}.
 ##
 ## @example
 ## @group
-##   function y = applyA(x) 
+##   function y = apply_a (x) 
 ##     y = [1:10]'.*x; 
 ##   endfunction
 ## 
-##   x = pcr('applyA',b)
+##   x = pcr ("apply_a", b)
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 3:}  Preconditioned iteration, with full diagnostics. The
 ## preconditioner (quite strange, because even the original matrix
 ## @var{a} is trivial) is defined as a function
 ## 
 ## @example
 ## @group
-##   function y = applyM(x)		
-##     K = floor(length(x)-2); 
+##   function y = apply_m (x)		
+##     k = floor (length(x)-2); 
 ##     y = x; 
-##     y(1:K) = x(1:K)./[1:K]';	
+##     y(1:k) = x(1:k)./[1:k]';	
 ##   endfunction
 ## 
 ##   [x, flag, relres, iter, resvec] = ...
-##                      pcr(A, b, [], [], 'applyM')
+##                      pcr (a, b, [], [], "apply_m")
 ##   semilogy([1:iter+1], resvec);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 4:} Finally, a preconditioner which depends on a
 ## parameter @var{k}.
 ## 
 ## @example
 ## @group
-##   function y = applyM(x, varargin)
-##     K = varargin@{1@}; 
-##     y = x; y(1:K) = x(1:K)./[1:K]';	 
+##   function y = apply_m (x, varargin)
+##     k = varargin@{1@}; 
+##     y = x; y(1:k) = x(1:k)./[1:k]';	 
 ##   endfunction
 ## 
 ##   [x, flag, relres, iter, resvec] = ...
-##                      pcr(A, b, [], [], 'applyM', [], 3)
+##                      pcr (a, b, [], [], "apply_m"', [], 3)
 ## @end group
 ## @end example
 ## 
 ## @sc{References}
 ## 
 ## 	[1] W. Hackbusch, "Iterative Solution of Large Sparse Systems of
 ##  	Equations", section 9.5.4; Springer, 1994
 ##
 ## @seealso{sparse, pcg}
 ## @end deftypefn
 
 ## Author: Piotr Krzyzanowski <piotr.krzyzanowski@mimuw.edu.pl>
 
-function [x, flag, relres, iter, resvec] = pcr (A, b, tol, maxit, M, x0, varargin)
+function [x, flag, relres, iter, resvec] = pcr (a, b, tol, maxit, m, x0, varargin)
 
   breakdown = false;
 
   if (nargin < 6 || isempty (x0))
     x = zeros (size (b));
   else
     x = x0;
   endif
 
   if (nargin < 5)
-    M = [];
+    m = [];
   endif
 
   if (nargin < 4 || isempty (maxit))
     maxit = 20;
   endif
 
   maxit += 2;
 
@@ -192,73 +192,73 @@ function [x, flag, relres, iter, resvec]
     tol = 1e-6;
   endif
 
   if (nargin < 2)
     print_usage ();
   endif
 
   ##  init
-  if (isnumeric (A))		# is A a matrix?
-    r = b - A*x;
+  if (isnumeric (a))		# is A a matrix?
+    r = b - a*x;
   else				# then A should be a function!
-    r = b - feval (A, x, varargin{:});
+    r = b - feval (a, x, varargin{:});
   endif
 
-  if (isnumeric (M))		# is M a matrix?
-    if (isempty (M))		# if M is empty, use no precond
+  if (isnumeric (m))		# is M a matrix?
+    if (isempty (m))		# if M is empty, use no precond
       p = r;
     else			# otherwise, apply the precond
-      p = M \ r;
+      p = m \ r;
     endif
   else				# then M should be a function!
-    p = feval (M, r, varargin{:});
+    p = feval (m, r, varargin{:});
   endif
 
   iter = 2;
 
   b_bot_old = 1;
   q_old = p_old = s_old = zeros (size (x));
 
-  if (isnumeric (A))		# is A a matrix?
-    q = A * p;
+  if (isnumeric (a))		# is A a matrix?
+    q = a * p;
   else				# then A should be a function!
-    q = feval (A, p, varargin{:});
+    q = feval (a, p, varargin{:});
   endif
 	
   resvec(1) = abs (norm (r)); 
 
   ## iteration
   while (resvec(iter-1) > tol*resvec(1) && iter < maxit)
 
-    if (isnumeric (M))		# is M a matrix?
-      if (isempty (M))		# if M is empty, use no precond
+    if (isnumeric (m))		# is M a matrix?
+      if (isempty (m))		# if M is empty, use no precond
 	s = q;
       else			# otherwise, apply the precond
-	s = M \ q;
+	s = m \ q;
       endif
     else			# then M should be a function!
-      s = feval (M, q, varargin{:});
+      s = feval (m, q, varargin{:});
     endif
     b_top = r' * s;
     b_bot = q' * s;
 	
     if (b_bot == 0.0)
       breakdown = true;
       break;
     endif
     lambda = b_top / b_bot;
 	
     x += lambda*p;
     r -= lambda*q;
 	
-    if (isnumeric(A))		# is A a matrix?
-      t = A*s;
+    if (isnumeric(a))		# is A a matrix?
+      t = a*s;
     else			# then A should be a function!
-      t = feval (A, s, varargin{:});
+      t = feval (a, s, varargin{:});
     endif
 	
     alpha0 = (t'*s) / b_bot;
     alpha1 = (t'*s_old) / b_bot_old;
 	
     p_temp = p;
     q_temp = q;
 
@@ -281,17 +281,17 @@ function [x, flag, relres, iter, resvec]
     flag = 1;
     if (nargout < 2)
       warning ("pcr: maximum number of iterations (%d) reached\n", iter);
       warning ("the initial residual norm was reduced %g times.\n", 1.0/relres);
     endif
   elseif (nargout < 2 && ! breakdown)
     fprintf (stderr, "pcr: converged in %d iterations. \n", iter);
     fprintf (stderr, "the initial residual norm was reduced %g times.\n",
-	     1.0/relres);
+	     1.0 / relres);
   endif
 
   if (breakdown)
     flag = 3;
     if (nargout < 2)
       warning ("pcr: breakdown occurred:\n");
       warning ("system matrix singular or preconditioner indefinite?\n");
     endif
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -15,50 +15,50 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} spy (@var{x})
 ## @deftypefnx {Function File} {} spy (@dots{}, @var{markersize})
-## @deftypefnx {Function File} {} spy (@dots{}, @var{LineSpec})
+## @deftypefnx {Function File} {} spy (@dots{}, @var{line_spec})
 ## Plot the sparsity pattern of the sparse matrix @var{x}. If the argument
 ## @var{markersize} is given as an scalar value, it is used to determine the
-## point size in the plot. If the string @var{LineSpec} is given it is
+## point size in the plot. If the string @var{line_spec} is given it is
 ## passed to @code{plot} and determines the appearance of the plot.
 ## @seealso{plot}
 ## @end deftypefn
 
-function spy (S, varargin) 
+function spy (x, varargin) 
 
   if (nargin < 1)
     print_usage ();
   endif
 
   markersize = NaN;
   if (numel (i) < 1000)
-    LineSpec = "*";
+    line_spec = "*";
   else
-    LineSpec = ".";
+    line_spec = ".";
   endif
-  for i = 1:length(varargin)
-    if (ischar(varargin{i}))
-      LineSpec = varargin{i};
+  for i = 1:length (varargin)
+    if (ischar (varargin{i}))
+      line_spec = varargin{i};
     elseif (isscalar (varargin{i}))
       markersize = varargin{i};
     else
       error ("spy: expected markersize or linespec");
     endif
   endfor
 
-  [i, j, s] = find (S);
-  [m, n] = size (S);
+  [i, j, s] = find (x);
+  [m, n] = size (x);
 
   if (isnan (markersize))
-    plot (j, i, LineSpec);
+    plot (j, i, line_spec);
   else
-    plot (j, i, LineSpec, "MarkerSize", markersize);
+    plot (j, i, line_spec, "markersize", markersize);
   endif
 
   axis ([0, n+1, 0, m+1], "ij");
 
 endfunction
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -75,131 +75,133 @@
 ## @end example
 ##
 ## will be zero.
 ## @end deftypefn
 ## @seealso{eigs}
 
 function [u, s, v, flag] = svds (a, k, sigma, opts)
 
+  persistent root2 = sqrt (2);
+
   if (nargin < 1 || nargin > 4)
-    error ("Incorrect number of arguments");
+    print_usage ();
   endif
 
   if (nargin < 4)
-    opts.tol = 1e-10 / sqrt(2);
+    opts.tol = 1e-10 / root2;
     opts.disp = 0;
     opts.maxit = 300;
   else
-    if (!isstruct(opts))
-      error("opts must be a structure");
+    if (!isstruct (opts))
+      error ("svds: opts must be a structure");
     endif
-    if (!isfield(opts,"tol"))
-      opts.tol = 1e-10 / sqrt(2);
+    if (!isfield (opts, "tol"))
+      opts.tol = 1e-10 / root2;
     endif
   endif
 
-  if (nargin < 3 || strcmp(sigma,"L"))
-    if (isreal(a))
+  if (nargin < 3 || strcmp (sigma, "L"))
+    if (isreal (a))
       sigma = "LA";
     else
       sigma = "LR";
     endif
-  elseif (isscalar(sigma) && isreal(sigma))
-    if ((sigma < 0))
-      error ("sigma must be a positive real value");
+  elseif (isscalar (sigma) && isreal (sigma))
+    if (sigma < 0)
+      error ("svds: sigma must be a positive real value");
     endif
   else
-    error ("sigma must be a positive real value or the string 'L'");
+    error ("svds: sigma must be a positive real value or the string 'L'");
   endif
 
-  maxA = max(max(abs(a)));
-  if (maxA == 0)
-    u = eye(m, k);
-    s = zeros(k, k);
-    v = eye(n, k);
+  max_a = max (abs (a(:)));
+  if (max_a == 0)
+    u = eye (m, k);
+    s = zeros (k, k);
+    v = eye (n, k);
   else
-    [m, n] = size(a);
+    [m, n] = size (a);
     if (nargin < 2)
-      k = min([6, m, n]);
+      k = min ([6, m, n]);
     else
-      k = min([k, m, n]);
+      k = min ([k, m, n]);
     endif
 
     ## Scale everything by the 1-norm to make things more stable.
-    B = a / maxA;
-    Bopts = opts;
-    Bopts.tol = opts.tol / maxA;
-    Bsigma = sigma;
-    if (!ischar(Bsigma))
-      Bsigma = Bsigma / maxA;
+    b = a / max_a;
+    b_opts = opts;
+    b_opts.tol = opts.tol / max_a;
+    b_sigma = sigma;
+    if (!ischar (b_sigma))
+      b_sigma = b_sigma / max_a;
     endif
 
-    if (!ischar(Bsigma) && Bsigma == 0)
+    if (!ischar (b_sigma) && b_sigma == 0)
       ## The eigenvalues returns by eigs are symmetric about 0. As we 
       ## are only interested in the positive eigenvalues, we have to
       ## double k. If sigma is smaller than the smallest singular value
       ## this can also be an issue. However, we'd like to avoid double
       ## k for all scalar value of sigma...
-      [V, s, flag] = eigs ([sparse(m,m), B; B', sparse(n,n)], 
-			   2 * k, Bsigma, Bopts);
+      [V, s, flag] = eigs ([sparse(m,m), b; b', sparse(n,n)], 
+			   2 * k, b_sigma, b_opts);
     else
-      [V, s, flag] = eigs ([sparse(m,m), B; B', sparse(n,n)],
-			   k, Bsigma, Bopts);
+      [V, s, flag] = eigs ([sparse(m,m), b; b', sparse(n,n)],
+			   k, b_sigma, b_opts);
     endif
-    s = diag(s);
+    s = diag (s);
 
-    if (ischar(sigma))
-      norma = max(s);
+    if (ischar (sigma))
+      norma = max (s);
     else
-      norma = normest(a);
+      norma = normest (a);
     endif
-    V = sqrt(2) * V;
+    V = root2 * V;
     u = V(1:m,:);
     v = V(m+1:end,:);
 
     ## We wish to exclude all eigenvalues that are less than zero as these
     ## are artifacts of the way the matrix passed to eigs is formed. There 
     ## is also the possibility that the value of sigma chosen is exactly 
     ## a singular value, and in that case we're dead!! So have to rely on 
     ## the warning from eigs. We exclude the singular values which are
     ## less than or equal to zero to within some tolerance scaled by the
     ## norm since if we don't we might end up with too many singular
     ## values. What is appropriate for the tolerance?
     tol = norma * opts.tol;
     ind = find(s > tol);
-    if (length(ind) < k)
+    if (length (ind) < k)
       ## Find the zero eigenvalues of B, Ignore the eigenvalues that are 
       ## nominally negative.
-      zind = find(abs(s) <= tol);
-      p = min(length(zind), k-length(ind));
-      ind = [ind;zind(1:p)];
-    elseif (length(ind) > k)
+      zind = find (abs (s) <= tol);
+      p = min (length (zind), k - length (ind));
+      ind = [ind; zind(1:p)];
+    elseif (length (ind) > k)
       ind = ind(1:k);
     endif
     u = u(:,ind);
     s = s(ind);
     v = v(:,ind);
 
-    if (length(s) < k)
-      warning("returning fewer singular values than requested.");
-      if (!ischar(sigma))
-	warning("try increasing the value of sigma");
+    if (length (s) < k)
+      warning ("returning fewer singular values than requested");
+      if (!ischar (sigma))
+	warning ("try increasing the value of sigma");
       endif
     endif
 
-    s = s * maxA;
+    s = s * max_a;
   endif
 
   if (nargout < 2)
     u = s;
   else
     s = diag(s);
     if (nargout > 3)
-      flag = norm(a*v - u*s, 1) > sqrt(2) * opts.tol * norm(a, 1);
+      flag = norm (a*v - u*s, 1) > root2 * opts.tol * norm (a, 1);
     endif
   endif
 endfunction
 
 %!shared n, k, a, u, s, v, opts
 %! n = 100;
 %! k = 7;
 %! a = sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),0.4*n*ones(1,n),ones(1,n-2)]);
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -13,192 +13,195 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} treelayout (@var{Tree})
-## @deftypefnx {Function File} {} treelayout (@var{Tree}, @var{Permutation})
+## @deftypefnx {Function File} {} treelayout (@var{Tree}, @var{permutation})
 ## treelayout lays out a tree or a forest. The first argument @var{Tree} is a vector of
-## predecessors, optional parameter @var{Permutation} is an optional postorder permutation.
+## predecessors, optional parameter @var{permutation} is an optional postorder permutation.
 ## The complexity of the algorithm is O(n) in
 ## terms of time and memory requirements.
 ## @seealso{etreeplot, gplot,treeplot}
 ## @end deftypefn
 
-function [XCoordinate, YCoordinate, Height, s] = treelayout (Tree, Permutation)
+function [x_coordinate, y_coordinate, height, s] = treelayout (tree, permutation)
   if (nargin < 1 || nargin > 2 || nargout > 4)
     print_usage ();
-  elseif (! isvector (Tree) || rows (Tree) != 1 || ! isnumeric (Tree) 
-        ||  any (Tree > length (Tree)) || any (Tree < 0) )
+  elseif (! isvector (tree) || rows (tree) != 1 || ! isnumeric (tree) 
+          ||  any (tree > length (tree)) || any (tree < 0))
     error ("treelayout: the first input argument must be a vector of predecessors");
   else
     ## Make it a row vector.
-    Tree = Tree(:)';
+    tree = tree(:)';
 
     ## The count of nodes of the graph.
-    NodNumber = length (Tree);
+    num_nodes = length (tree);
     ## The number of children.
-    ChildNumber = zeros (1, NodNumber + 1);
+    num_children = zeros (1, num_nodes + 1);
 
     ## Checking vector of predecessors.
-    for i = 1 : NodNumber
-      if (Tree (i) < i)
+    for i = 1 : num_nodes
+      if (tree(i) < i)
 	## This part of graph was checked before.
         continue;
       endif
 
       ## Try to find cicle in this part of graph using modified Floyd's
       ## cycle-finding algorithm.
-      tortoise = Tree (i);
-      hare = Tree (tortoise);
+      tortoise = tree(i);
+      hare = tree(tortoise);
 
       while (tortoise != hare)
 	## End after finding a cicle or reaching a checked part of graph.
 
         if (hare < i)
           ## This part of graph was checked before.
           break
         endif
 
-        tortoise = Tree (tortoise);
+        tortoise = tree(tortoise);
 	## Hare will move faster than tortoise so in cicle hare must
 	## reach tortoise.
-        hare = Tree (Tree (hare));
+        hare = tree(tree(hare));
 
       endwhile
 
       if (tortoise == hare)
 	## If hare reach tortoise we found circle.
         error ("treelayout: vector of predecessors has bad format");
       endif
 
     endfor
     ## Vector of predecessors has right format.
 
-    for i = 1:NodNumber
-      ## VecOfChild is helping vector which is used to speed up the
+    for i = 1:num_nodes
+      ## vec_of_child is helping vector which is used to speed up the
       ## choice of descendant nodes.
 
-      ChildNumber (Tree (i) + 1) = ChildNumber (Tree (i) + 1) + 1;
+      num_children(tree(i)+1) = num_children(tree(i)+1) + 1;
     endfor
 
-    Pos = 1;
-    for i = 1 : NodNumber + 1
-      Start (i) = Pos;
-      Help (i) = Pos;
-      Pos += ChildNumber (i);
-      Stop (i) = Pos;
+    pos = 1;
+    start = zeros (1, num_nodes+1);
+    xhelp = zeros (1, num_nodes+1);
+    stop = zeros (1, num_nodes+1);
+    for i = 1 : num_nodes + 1
+      start(i) = pos;
+      xhelp(i) = pos;
+      pos += num_children(i);
+      stop(i) = pos;
     endfor
 
     if (nargin == 1)
-      for i = 1 : NodNumber
-        VecOfChild (Help (Tree (i) + 1)) = i;  
-        Help (Tree (i) + 1) = Help (Tree (i) + 1) + 1;
+      for i = 1:num_nodes
+        vec_of_child(xhelp(tree(i)+1)) = i;  
+        xhelp(tree(i)+1) = xhelp(tree(i)+1) + 1;
       endfor
     else
-      VecOfChild = Permutation;
+      vec_of_child = permutation;
     endif
 
     ## The number of "parent" (actual) node (it's descendants will be
     ## browse in the next iteration).
-    ParNumber = 0;
+    par_number = 0;
 
     ## The x-coordinate of the left most descendant of "parent node"
     ## this value is increased in each leaf.
-    LeftMost = 0;
+    left_most = 0;
 
-    ## The level of "parent" node (root level is NodNumber).
-    Level = NodNumber;
+    ## The level of "parent" node (root level is num_nodes).
+    level = num_nodes;
 
-    ## NodNumber - Max is the height of this graph.
-    Max = NodNumber;
+    ## num_nodes - max_ht is the height of this graph.
+    max_ht = num_nodes;
 
     ## Main stack - each item consists of two numbers - the number of
     ## node and the number it's of parent node on the top of stack
     ## there is "parent node".
-    St = [-1, 0];
+    stk = [-1, 0];
 
     ## Number of vertices s in the top-level separator.
     s = 0;
     ## Flag which says if we are in top level separator.
-    topLevel = 1;
+    top_level = 1;
     ## The top of the stack.
-    while (ParNumber != -1)
-      if (Start(ParNumber + 1) < Stop(ParNumber + 1))
-        idx = VecOfChild (Start (ParNumber + 1) : Stop (ParNumber + 1) - 1);
+    while (par_number != -1)
+      if (start(par_number+1) < stop(par_number+1))
+        idx = vec_of_child(start(par_number+1) : stop(par_number+1) - 1);
       else
         idx = zeros (1, 0);
       endif
 
       ## Add to idx the vector of parent descendants.
-      St = [St ; [idx', ones(fliplr(size(idx))) * ParNumber]];
+      stk = [stk; [idx', ones(fliplr(size(idx))) * par_number]];
 
       ## We are in top level separator when we have one child and the
       ## flag is 1
-      if (columns(idx) == 1 && topLevel ==1 )
-        s += 1;
+      if (columns(idx) == 1 && top_level == 1)
+        s++;
       else
         # We aren't in top level separator now.
-        topLevel = 0;
+        top_level = 0;
       endif
       ## If there is not any descendant of "parent node":
-      if (St(end,2) != ParNumber)
-       LeftMost = LeftMost + 1;
-       XCoordinateR(ParNumber) = LeftMost;           
-       Max = min (Max, Level);
-       if ((length(St) > 1) && (find((shift(St,1)-St) == 0) >1) 
-	   && St(end,2) != St(end-1,2))
+      if (stk(end,2) != par_number)
+       left_most++;
+       x_coordinate_r(par_number) = left_most;           
+       max_ht = min (max_ht, level);
+       if (length(stk) > 1 && find ((shift(stk,1)-stk) == 0) > 1
+	   && stk(end,2) != stk(end-1,2))
 	  ## Return to the nearest branching the position to return
 	  ## position is the position on the stack, where should be
           ## started further search (there are two nodes which has the
           ## same parent node).
 
-          Position = (find ((shift (St(:, 2), 1) - St(:, 2)) == 0))(end)+1;
-          ParNumberVec = St(Position : end, 2);
+          position = (find ((shift (stk(:,2), 1) - stk(:,2)) == 0))(end) + 1;
+          par_number_vec = stk(position:end,2);
 
           ## The vector of removed nodes (the content of stack form
           ## position to end).
 
-          Level = Level + length(ParNumberVec);
+          level += length (par_number_vec);
 
 	  ## The level have to be decreased.
 
-          XCoordinateR(ParNumberVec) = LeftMost;
-          St(Position:end, :) = [];
+          x_coordinate_r(par_number_vec) = left_most;
+          stk(position:end,:) = [];
         endif	
 
         ## Remove the next node from "searched branch".
 
-        St(end, :) = [];
+        stk(end,:) = [];
 	## Choose new "parent node".
-        ParNumber = St(end, 1);
+        par_number = stk(end,1);
 	## If there is another branch start to search it.
-	if (ParNumber != -1)
-          YCoordinate(ParNumber) = Level;	
-          XCoordinateL(ParNumber) = LeftMost + 1;
+	if (par_number != -1)
+          y_coordinate(par_number) = level;	
+          x_coordinate_l(par_number) = left_most + 1;
 	endif
       else
 
         ## There were descendants of "parent nod" choose the last of
         ## them and go on through it.
-        Level--;
-        ParNumber = St(end, 1);
-        YCoordinate(ParNumber) = Level;     
-        XCoordinateL(ParNumber) = LeftMost+1;
+        level--;
+        par_number = stk(end,1);
+        y_coordinate(par_number) = level;     
+        x_coordinate_l(par_number) = left_most + 1;
       endif
     endwhile
 
     ## Calculate the x coordinates (the known values are the position
     ## of most left and most right descendants).
-    XCoordinate = (XCoordinateL + XCoordinateR) / 2;
+    x_coordinate = (x_coordinate_l + x_coordinate_r) / 2;
 
-    Height = NodNumber - Max - 1;
+    height = num_nodes - max_ht - 1;
   endif
 endfunction
 
 %!demo
 %! % Compute a simple tree layout 
 %! [x,y,h,s]=treelayout([0 1 2 2])
 
 %!demo
diff --git a/scripts/sparse/treeplot.m b/scripts/sparse/treeplot.m
--- a/scripts/sparse/treeplot.m
+++ b/scripts/sparse/treeplot.m
@@ -12,182 +12,200 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} treeplot (@var{Tree})
-## @deftypefnx {Function File} {} treeplot (@var{Tree}, @var{LineStyle}, @var{EdgeStyle})
+## @deftypefn {Function File} {} treeplot (@var{tree})
+## @deftypefnx {Function File} {} treeplot (@var{tree}, @var{line_style}, @var{edge_style})
 ## Produces a graph of tree or forest. The first argument is vector of
-## predecessors, optional parameters @var{LineStyle} and @var{EdgeStyle}
+## predecessors, optional parameters @var{line_style} and @var{edge_style}
 ## define the output style. The complexity of the algorithm is O(n) in
 ## terms of is time and memory requirements.
 ## @seealso{etreeplot, gplot}
 ## @end deftypefn
 
-function treeplot (Tree, NodeS, EdgeS)
+function treeplot (tree, node_s, edge_s)
 
   if (nargin < 1 || nargin > 3 || nargout > 0)
     print_usage ();
   else
-    if (! ismatrix (Tree) || rows (Tree) != 1 || ! isnumeric (Tree) 
-        || ! isvector (Tree) || any (Tree > length (Tree)))
+    if (! ismatrix (tree) || rows (tree) != 1 || ! isnumeric (tree) 
+        || ! isvector (tree) || any (tree > length (tree)))
       error ("treeplot: the first input argument must be a vector of predecessors");
     else
-      ## the inicialization of node end edge style
-      NodeStyle = "k*";
-      EdgeStyle = "r";      
+      ## The initialization of node end edge style.
+      node_style = "k*";
+      edge_style = "r";      
       if (nargin > 2)
-        EdgeStyle = EdgeS;
+        edge_style = edge_s;
         if (nargin > 1) 
-	  if (length (findstr (NodeS, "*")) == 0
-	      && length (findstr (NodeS, "+")) == 0
-	      && length (findstr (NodeS, "x")) == 0)
-	    NodeStyle = [NodeS, "o"];
+	  if (length (findstr (node_s, "*")) == 0
+	      && length (findstr (node_s, "+")) == 0
+	      && length (findstr (node_s, "x")) == 0)
+	    node_style = [node_s, "o"];
 	  else
-	    NodeStyle = NodeS;
+	    node_style = node_s;
 	  endif
         endif
       endif
 
-      Tree = Tree(:)';		            ## make it a row vector
-      NodNumber = length (Tree);            ## the count of nodes of the graph
-      ChildNumber = zeros (1, NodNumber+1); ## the number of childrens
+      ## Make it a row vector.
+      tree = tree(:)';
+
+      ## The count of nodes of the graph.
+      num_nodes = length (tree);
+
+      ## The number of children.
+      num_children = zeros (1, num_nodes+1);
       
-      for i = 1:NodNumber
-        ## VecOfChild is helping vector which is used to speed up the
-        ## choose of descendant nodes
+      for i = 1:num_nodes
+        ## VEC_OF_CHILD is helping vector which is used to speed up the
+        ## choose of descendant nodes.
 
-        ChildNumber(Tree(i)+1) = ChildNumber(Tree(i)+1) + 1;
+        num_children(tree(i)+1) = num_children(tree(i)+1) + 1;
       endfor
-      Pos = 1;
-      for i = 1:NodNumber+1
-        Start(i) = Pos;
-	Help(i) = Pos;
-	Pos += ChildNumber(i);
-	Stop(i) = Pos;
+      pos = 1;
+      start = zeros (1, num_nodes+1);
+      xhelp = zeros (1, num_nodes+1);
+      stop = zeros (1, num_nodes+1);
+      for i = 1:num_nodes+1
+        start(i) = pos;
+	xhelp(i) = pos;
+	pos += num_children(i);
+	stop(i) = pos;
       endfor
-      for i = 1:NodNumber        
-        VecOfChild(Help(Tree(i)+1)) = i;  
-	Help(Tree(i)+1) = Help(Tree(i)+1)+1;
+      for i = 1:num_nodes        
+        vec_of_child(xhelp(tree(i)+1)) = i;  
+	xhelp(tree(i)+1) = xhelp(tree(i)+1)+1;
       endfor
 
-      ## the number of "parent" (actual) node (it's descendants will be
-      ## browse in the next iteration)
-      ParNumber = 0;
+      ## The number of "parent" (actual) node (it's descendants will be
+      ## browse in the next iteration).
+      par_number = 0;
 
-      ## the x-coordinate of the left most descendant of "parent node"
-      ## this value is increased in each leaf		
-      LeftMost = 0;
+      ## The x-coordinate of the left most descendant of "parent node"
+      ## this value is increased in each leaf.
+      left_most = 0;
 
-      ## the level of "parent" node (root level is NodNumber)
-      Level = NodNumber;
+      ## The level of "parent" node (root level is num_nodes).
+      level = num_nodes;
 
-      ## NodNumber - Max is the height of this graph
-      Max = NodNumber;
+      ## Num_nodes - max_ht is the height of this graph.
+      max_ht = num_nodes;
 
-      ## main stack - each item consists of two numbers - the number of
+      ## Main stack - each item consists of two numbers - the number of
       ## node and the number it's of parent node on the top of stack
-      ## there is "parent node"
-      St = [-1,0];
+      ## there is "parent node".
+      stk = [-1, 0];
 
-      ## stack which is use to draw the graph edge (it have to be
-      ## uninterupted line)
-      Skelet = 0;
+      ## Stack which is use to draw the graph edge (it have to be
+      ## uninterupted line).
+      skelet = 0;
 
-      ## the top of the stack
-      while (ParNumber != -1)
-	if (Start(ParNumber+1) < Stop(ParNumber+1))
-	  idx = VecOfChild(Start(ParNumber+1):Stop(ParNumber+1)-1);
+      ## The top of the stack.
+      while (par_number != -1)
+	if (start(par_number+1) < stop(par_number+1))
+	  idx = vec_of_child(start(par_number+1):stop(par_number+1)-1);
 	else
 	  idx = zeros (1, 0);
 	endif
-        ## add to idx the vector of parent descendants
-	St = [St ; [idx', ones(fliplr(size(idx)))*ParNumber]];
-	## add to stack the records relevant to parent descandant s
-	if (ParNumber != 0)
-	  Skelet = [Skelet; ([ones(size(idx))*ParNumber; idx])(:)];
+        ## Add to idx the vector of parent descendants.
+	stk = [stk; [idx', ones(fliplr(size(idx)))*par_number]];
+	## Add to stack the records relevant to parent descandant s.
+	if (par_number != 0)
+	  skelet = [skelet; ([ones(size(idx))*par_number; idx])(:)];
 	endif
 
-	## if there is not any descendant of "parent node":
-	if (St(end,2) != ParNumber)
-	  LeftMost = LeftMost + 1;
-          XCoordinateR(ParNumber) = LeftMost;           
-	  Max = min (Max, Level);
-          if ((length(St)>1) && (find((shift(St,1)-St) == 0) >1)
-	      && St(end,2) != St(end-1,2))
-	    ## return to the nearest branching the position to return
+	## If there is not any descendant of "parent node":
+	if (stk(end,2) != par_number)
+	  left_most++;
+          x_coordinate_r(par_number) = left_most;           
+	  max_ht = min (max_ht, level);
+          if (length(stk) > 1 && find ((shift(stk,1)-stk) == 0) > 1
+	      && stk(end,2) != stk(end-1,2))
+	    ## Return to the nearest branching the position to return
 	    ## position is the position on the stack, where should be
 	    ## started further search (there are two nodes which has the
-	    ## same parent node)
-            Position = (find((shift(St(:,2),1)-St(:,2)) == 0))(end)+1;
-            ParNumberVec = St(Position:end,2);
-            ## the vector of removed nodes (the content of stack form
-	    ## position to end)
-            Skelet = [Skelet; flipud(ParNumberVec)];
-            Level = Level + length(ParNumberVec);
-	    ## the level have to be decreased
-            XCoordinateR(ParNumberVec) = LeftMost;
-            St(Position:end,:) = [];
+	    ## same parent node).
+            position = (find ((shift(stk(:,2),1)-stk(:,2)) == 0))(end) + 1;
+            par_number_vec = stk(position:end,2);
+            ## The vector of removed nodes (the content of stack form
+	    ## position to end).
+            skelet = [skelet; flipud(par_number_vec)];
+            level += length (par_number_vec);
+	    ## The level have to be decreased.
+            x_coordinate_r(par_number_vec) = left_most;
+            stk(position:end,:) = [];
           endif	
-       	  ## remove the next node from "searched branch"
-	  St(end,:) = [];
-	  ## choose new "parent node"
-          ParNumber = St(end,1);
-	  ## if there is another branch start to search it
-	  if (ParNumber != -1)
-	    Skelet = [Skelet ; St(end,2); ParNumber];
-            YCoordinate(ParNumber) = Level;	
-	    XCoordinateL(ParNumber) = LeftMost + 1;
+       	  ## Remove the next node from "searched branch".
+	  stk(end,:) = [];
+	  ## Choose new "parent node".
+          par_number = stk(end,1);
+	  ## If there is another branch start to search it.
+	  if (par_number != -1)
+	    skelet = [skelet; stk(end,2); par_number];
+            y_coordinate(par_number) = level;	
+	    x_coordinate_l(par_number) = left_most + 1;
 	  endif
 	else
-          ## there were descendants of "parent nod" choose the last of
-	  ## them and go on through it
-          Level--;
-	  ParNumber = St(end,1);
-	  YCoordinate(ParNumber) = Level;     
-	  XCoordinateL(ParNumber) = LeftMost+1;
+          ## There were descendants of "parent nod" choose the last of
+	  ## them and go on through it.
+          level--;
+	  par_number = stk(end,1);
+	  y_coordinate(par_number) = level;     
+	  x_coordinate_l(par_number) = left_most + 1;
 	endif
       endwhile
 
-      ## calculate the x coordinates (the known values are the position
-      ## of most left and most right descendants)
-      XCoordinate = (XCoordinateL + XCoordinateR) / 2;
+      ## Calculate the x coordinates (the known values are the position
+      ## of most left and most right descendants).
+      x_coordinate = (x_coordinate_l + x_coordinate_r) / 2;
+
+      ## FIXME -- we should probably stuff all the arguments into a cell
+      ## array and make a single call to plot here so we can avoid
+      ## setting the hold state...
 
-      hold ("on");
+      hold_is_on = ishold ();
+      unwind_protect
+	hold ("on");
+
+	## Plot grah nodes.
+	plot (x_coordinate, y_coordinate, node_style);
+
+	## Helping command - usable for plotting edges
+	skelet = [skelet; 0];
+
+	## Draw graph edges.
+	idx = find (skelet == 0);
 
-      ## plot grah nodes 
-      plot (XCoordinate,YCoordinate,NodeStyle);
-      
-      ## helping command - usable for plotting edges
-      Skelet = [Skelet; 0];
-      
-      ## draw graph edges 
-      idx = find (Skelet == 0);
-       
-      ## plot each tree component in one loop
-      for i = 2:length(idx)
-        ## tree component start
-	istart = idx(i-1) + 1;
-        ## tree component end
-	istop = idx(i) - 1;
-	if (istop - istart < 1)                          
-	  continue;
+	## Plot each tree component in one loop.
+	for i = 2:length(idx)
+	  ## Tree component start.
+	  istart = idx(i-1) + 1;
+	  ## Tree component end.
+	  istop = idx(i) - 1;
+	  if (istop - istart < 1)                          
+	    continue;
+	  endif
+	  plot (x_coordinate(skelet(istart:istop)),
+		y_coordinate(skelet(istart:istop)), edge_style)
+	endfor
+
+	## Set axis and graph size.
+	axis ([0.5, left_most+0.5, max_ht-0.5, num_nodes-0.5], "nolabel");
+
+      unwind_protect_cleanup
+	if (! hold_is_on)
+	  hold ("off");
 	endif
-	plot (XCoordinate(Skelet(istart:istop)),
-	      YCoordinate(Skelet(istart:istop)), EdgeStyle)
-      endfor
-      
-      ## set axis and graph size 
-      axis ([0.5, LeftMost+0.5, Max-0.5, NodNumber-0.5], "nolabel");
-      
-      hold ("off");
+      end_unwind_protect
       
     endif
   endif
 endfunction
 
 %!demo
 %! % Plot a simple tree plot 
 %! treeplot([2 4 2 0 6 4 6])
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} primes (@var{n})
 ##
 ## Return all primes up to @var{n}.  
 ##
 ## Note that if you need a specific number of primes, you can use the
 ## fact the distance from one prime to the next is on average
 ## proportional to the logarithm of the prime.  Integrating, you find
-## that there are about @math{k} primes less than @math{k \log ( 5 k )}.
+## that there are about @math{k} primes less than @math{k \log (5 k)}.
 ##
 ## The algorithm used is called the Sieve of Erastothenes.
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Author: Francesco Potort
 ## Author: Dirk Laurie
 
@@ -43,17 +43,17 @@ function x = primes (p)
     error ("primes: n must be a scalar");
   endif
 
   if (p > 100000)
     ## Optimization: 1/6 less memory, and much faster (asymptotically)
     ## 100000 happens to be the cross-over point for Paul's machine;
     ## below this the more direct code below is faster.  At the limit
     ## of memory in Paul's machine, this saves .7 seconds out of 7 for
-    ## p=3e6.  Hardly worthwhile, but Dirk reports better numbers.
+    ## p = 3e6.  Hardly worthwhile, but Dirk reports better numbers.
     lenm = floor ((p+1)/6);       # length of the 6n-1 sieve
     lenp = floor ((p-1)/6);       # length of the 6n+1 sieve
     sievem = ones (1, lenm);      # assume every number of form 6n-1 is prime
     sievep = ones (1, lenp);      # assume every number of form 6n+1 is prime
 
     for i = 1:(sqrt(p)+1)/6       # check up to sqrt(p)
       if (sievem(i))              # if i is prime, eliminate multiples of i
         sievem(7*i-1:6*i-1:lenm) = 0;
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -56,30 +56,30 @@
 ##     http://www.research.att.com/~njas/hadamard/
 
 function h = hadamard (n)
   
   if (nargin != 1)
     print_usage ();
   endif
 
-  ## find k if n = 2^k*p
+  ## Find k if n = 2^k*p.
   k = 0;
   while (n > 1 && floor (n/2) == n/2)
     k++; 
     n = n/2; 
   endwhile
   
-  ## find base hadamard
-  ## except for n=2^k, need a multiple of 4
+  ## Find base hadamard.
+  ## Except for n=2^k, need a multiple of 4.
   if (n != 1)
     k -= 2; 
   endif
 
-  ## trigger error if not a multiple of 4
+  ## Trigger error if not a multiple of 4.
   if (k < 0)
     n =- 1;
   endif
 
   switch (n)
     case 1
       h = 1;
     case 3
@@ -87,88 +87,88 @@ function h = hadamard (n)
     case 5
       h = h20 ();
     case 7
       h = hnormalize (h28 ());
     otherwise
       error ("n must be 2^k*p, for p = 1, 12, 20 or 28");
   endswitch
 
-  ## build H(2^k*n) from kron(H(2^k),H(n))
+  ## Build H(2^k*n) from kron(H(2^k),H(n)).
   h2 = [1,1;1,-1];
   while (true)
     if (floor (k/2) != k/2)
       h = kron (h2, h); 
     endif
     k = floor (k/2);
     if (k == 0) 
       break; 
     endif
     h2 = kron (h2, h2);
   endwhile
 endfunction
 
 function h = h12 ()
-  tu=[-1,+1,-1,+1,+1,+1,-1,-1,-1,+1,-1];
-  tl=[-1,-1,+1,-1,-1,-1,+1,+1,+1,-1,+1];
-  ## note: assert(tu(2:end),tl(end:-1:2))
+  tu = [-1,+1,-1,+1,+1,+1,-1,-1,-1,+1,-1];
+  tl = [-1,-1,+1,-1,-1,-1,+1,+1,+1,-1,+1];
+  ## Note: assert (tu(2:end), tl(end:-1:2)).
   h = ones (12);
   h(2:end,2:end) = toeplitz (tu, tl);
 endfunction
 
 
 function h = h20 ()
-  tu=[+1,-1,-1,+1,+1,+1,+1,-1,+1,-1,+1,-1,-1,-1,-1,+1,+1,-1,-1];
-  tl=[+1,-1,-1,+1,+1,-1,-1,-1,-1,+1,-1,+1,-1,+1,+1,+1,+1,-1,-1];
-  ## note: assert(tu(2:end),tl(end:-1:2))
+  tu = [+1,-1,-1,+1,+1,+1,+1,-1,+1,-1,+1,-1,-1,-1,-1,+1,+1,-1,-1];
+  tl = [+1,-1,-1,+1,+1,-1,-1,-1,-1,+1,-1,+1,-1,+1,+1,+1,+1,-1,-1];
+  ## Note: assert (tu(2:end), tl(end:-1:2)).
   h = ones (20);
   h(2:end,2:end) = fliplr (toeplitz (tu, tl));
 endfunction
 
 function h = hnormalize (h)
-  ## Make sure each row and column starts with +1
+  ## Make sure each row and column starts with +1.
   h(h(:,1)==-1,:) *= -1;
   h(:,h(1,:)==-1) *= -1;
 endfunction
 
 function h = h28 ()
   ## Williamson matrix construction from
   ## http://www.research.att.com/~njas/hadamard/had.28.will.txt
-  s = ['+------++----++-+--+-+--++--';
-       '-+-----+++-----+-+--+-+--++-';
-       '--+-----+++---+-+-+----+--++';
-       '---+-----+++---+-+-+-+--+--+';
-       '----+-----+++---+-+-+++--+--';
-       '-----+-----++++--+-+--++--+-';
-       '------++----++-+--+-+--++--+';
-       '--++++-+-------++--+++-+--+-';
-       '---++++-+-----+-++--+-+-+--+';
-       '+---+++--+----++-++--+-+-+--';
-       '++---++---+----++-++--+-+-+-';
-       '+++---+----+----++-++--+-+-+';
-       '++++--------+-+--++-++--+-+-';
-       '-++++--------+++--++--+--+-+';
-       '-+-++-++--++--+--------++++-';
-       '+-+-++--+--++--+--------++++';
-       '-+-+-++--+--++--+----+---+++';
-       '+-+-+-++--+--+---+---++---++';
-       '++-+-+-++--+------+--+++---+';
-       '-++-+-+-++--+------+-++++---';
-       '+-++-+---++--+------+-++++--';
-       '-++--++-+-++-+++----++------';
-       '+-++--++-+-++-+++-----+-----';
-       '++-++---+-+-++-+++-----+----';
-       '-++-++-+-+-+-+--+++-----+---';
-       '--++-++++-+-+----+++-----+--';
-       '+--++-+-++-+-+----+++-----+-';
-       '++--++-+-++-+-+----++------+'];
+  s = ["+------++----++-+--+-+--++--";
+       "-+-----+++-----+-+--+-+--++-";
+       "--+-----+++---+-+-+----+--++";
+       "---+-----+++---+-+-+-+--+--+";
+       "----+-----+++---+-+-+++--+--";
+       "-----+-----++++--+-+--++--+-";
+       "------++----++-+--+-+--++--+";
+       "--++++-+-------++--+++-+--+-";
+       "---++++-+-----+-++--+-+-+--+";
+       "+---+++--+----++-++--+-+-+--";
+       "++---++---+----++-++--+-+-+-";
+       "+++---+----+----++-++--+-+-+";
+       "++++--------+-+--++-++--+-+-";
+       "-++++--------+++--++--+--+-+";
+       "-+-++-++--++--+--------++++-";
+       "+-+-++--+--++--+--------++++";
+       "-+-+-++--+--++--+----+---+++";
+       "+-+-+-++--+--+---+---++---++";
+       "++-+-+-++--+------+--+++---+";
+       "-++-+-+-++--+------+-++++---";
+       "+-++-+---++--+------+-++++--";
+       "-++--++-+-++-+++----++------";
+       "+-++--++-+-++-+++-----+-----";
+       "++-++---+-+-++-+++-----+----";
+       "-++-++-+-+-+-+--+++-----+---";
+       "--++-++++-+-+----+++-----+--";
+       "+--++-+-++-+-+----+++-----+-";
+       "++--++-+-++-+-+----++------+"];
   ## Without this, the assignment of -1 will not work properly
   ## (compatibility forces LHS(idx) = ANY_VAL to keep the LHS logical
   ## instead of widening to a type that can represent ANY_VAL).
-  h = double (s=='+');
+  h = double (s == "+");
   h(!h) = -1;
 endfunction
 
 %!assert(hadamard(1),1)
 %!assert(hadamard(2),[1,1;1,-1])
 %!test
 %!  for n=[1,2,4,8,12,24,48,20,28,2^9]
 %!    h=hadamard(n); assert(norm(h*h'-n*eye(n)),0);
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/base/center.m
--- a/scripts/statistics/base/center.m
+++ b/scripts/statistics/base/center.m
@@ -35,18 +35,18 @@ function retval = center (x, varargin)
     print_usage ();
   endif
 
   if (isvector (x))
     retval = x - mean (x, varargin{:});
   elseif (ismatrix (x))
     if nargin < 2
       dim = find (size (x) > 1, 1);
-      if isempty (dim), 
-	dim=1; 
+      if (isempty (dim))
+	dim = 1; 
       endif;
     else
       dim = varargin{1};
     endif
     sz = ones (1, ndims (x));
     sz (dim) = size (x, dim);
     retval = x - repmat (mean (x, dim), sz);
   elseif (isempty (x))
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{q} =} quantile (@var{x}, @var{p})
 ## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim})
-## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim}, @var{method} )
+## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim}, @var{method})
 ## For a sample, @var{x}, calculate the quantiles, @var{q}, corresponding to
 ## the cumulative probability values in @var{p}. All non-numeric values (NaNs) of
 ## @var{x} are ignored.
 ##
 ## If @var{x} is a matrix, compute the quantiles for each column and
 ## return them in a matrix, such that the i-th row of @var{q} contains
 ## the @var{p}(i)th quantiles of each column of @var{x}.
 ## 
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -54,17 +54,17 @@ function y = ranks (x, dim)
 	&& dim < (nd + 1))
       error ("ranks: dim must be an integer and valid dimension");
     endif
   endif
 
   if (sz(dim) == 1)
     y = ones(sz);
   else
-    ## The algorithm works only on dim=1, so permute if necesary
+    ## The algorithm works only on dim = 1, so permute if necesary.
     if (dim != 1)
       perm = [1 : nd];
       perm(1) = dim;
       perm(dim) = 1;
       x = permute (x, perm);
     endif
     sz = size (x);
     infvec = -Inf * ones ([1, sz(2 : end)]);
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -63,19 +63,21 @@
 
 function retval = std (a, opt, dim)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
   if nargin < 3
     dim = find (size (a) > 1, 1);
-    if isempty(dim), dim=1; endif;
+    if (isempty (dim))
+      dim = 1;
+    endif
   endif
-  if ((nargin < 2) || isempty(opt))
+  if (nargin < 2 || isempty (opt))
     opt = 0;
   endif
 
   sz = size(a);
   if (sz (dim) == 1)
     retval = zeros(sz);
   elseif (numel (a) > 0)
     rng = ones (1, length (sz));
diff --git a/scripts/statistics/distributions/hygepdf.m b/scripts/statistics/distributions/hygepdf.m
--- a/scripts/statistics/distributions/hygepdf.m
+++ b/scripts/statistics/distributions/hygepdf.m
@@ -48,17 +48,17 @@ function pdf = hygepdf (x, t, m, n)
   ## everything in i1 gives NaN
   i1 = ((t < 0) | (m < 0) | (n <= 0) | (t != round (t)) |
         (m != round (m)) | (n != round (n)) | (m > t) | (n > t));
   ## everything in i2 gives 0 unless in i1
   i2 = ((x != round (x)) | (x < 0) | (x > m) | (n < x) | (n-x > t-m));
   k = find (i1);
   if (any (k))
     if (isscalar (t) && isscalar (m) && isscalar (n))
-      pdf = NaN * ones ( size (x));
+      pdf = NaN * ones (size (x));
     else
       pdf (k) = NaN;
     endif
   endif
   k = find (!i1 & !i2);
   if (any (k))
     if (isscalar (t) && isscalar (m) && isscalar (n))
       pdf (k) = (bincoeff (m, x(k)) .* bincoeff (t-m, n-x(k))
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -27,19 +27,19 @@
 ## Under the null hypothesis that the ranks in the pooled sample are not
 ## affected by the group memberships, the test statistic @var{k} is
 ## approximately chi-square with @var{df} = @var{k} - 1 degrees of
 ## freedom.
 ##
 ## If the data contains ties (some value appears more than once)
 ## @var{k} is divided by
 ## 
-## 1 - @var{sumTies} / ( @var{n}^3 - @var{n} )
+## 1 - @var{sum_ties} / (@var{n}^3 - @var{n})
 ##
-## where @var{sumTies} is the sum of @var{t}^2 - @var{t} over each group
+## where @var{sum_ties} is the sum of @var{t}^2 - @var{t} over each group
 ## of ties where @var{t} is the number of ties in the group and @var{n}
 ## is the total number of values in the input data. For more info on
 ## this adjustment see "Use of Ranks in One-Criterion Variance Analysis"
 ## in Journal of the American Statistical Association, Vol. 47,
 ## No. 260 (Dec 1952) by William H. Kruskal and W. Allen Wallis.
 ##
 ## The p-value (1 minus the CDF of this distribution at @var{k}) is
 ## returned in @var{pval}.
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -68,17 +68,17 @@ function n = index (s, t, direction)
     v = [];
 
   elseif (l_t == 0)
     ## zero length target: return first
     v = 1;
 
   elseif (l_t == 1)
     ## length one target: simple find
-    v = find (s==t, 1, direction);
+    v = find (s == t, 1, direction);
 
   elseif (l_t == 2)
     ## length two target: find first at i and second at i+1
     v = find (s (1:l_s-1) == t(1) & s(2:l_s) == t(2), 1, direction);
 
   else
     ## length three or more: match the first three by find then go through
     ## the much smaller list to determine which of them are real matches
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -31,23 +31,23 @@
 ## precision of the imaginary part. The default for @var{n} is 17.
 ##
 ## If the argument 'class' is given, then the class of @var{x} is
 ## included in the string in such a way that the eval will result in the
 ## construction of a matrix of the same class.
 ##
 ## @example
 ## @group
-## mat2str( [ -1/3 + i/7; 1/3 - i/7 ], [4 2] )
+## mat2str ([ -1/3 + i/7; 1/3 - i/7 ], [4 2])
 ##      @result{} "[-0.3333+0.14i;0.3333-0.14i]"
 ##
-## mat2str( [ -1/3 +i/7; 1/3 -i/7 ], [4 2] )
+## mat2str ([ -1/3 +i/7; 1/3 -i/7 ], [4 2])
 ##      @result{} "[-0.3333+0i,0+0.14i;0.3333+0i,-0-0.14i]"
 ##
-## mat2str( int16([1 -1]), 'class')
+## mat2str (int16([1 -1]), 'class')
 ##      @result{} "int16([1,-1])"
 ## @end group
 ## @end example
 ##
 ## @seealso{sprintf, num2str, int2str}
 ## @end deftypefn
 
 ## Author: Rolf Fabian <fabian@tu-cottbus.de>
@@ -76,17 +76,17 @@ function s = mat2str (x, n, cls)
     error ("mat2str: X must be two dimensional");
   endif
 
   x_iscomplex = iscomplex (x);
 
   if (! x_iscomplex)
     fmt = sprintf ("%%.%dg", n(1));
   else
-    if (length (n) == 1 )
+    if (length (n) == 1)
       n = [n, n];
     endif
     fmt = sprintf ("%%.%dg%%+.%dgi", n(1), n(2));
   endif
 
   nel = numel (x);
 
   if (nel == 0)
diff --git a/scripts/strings/str2double.m b/scripts/strings/str2double.m
--- a/scripts/strings/str2double.m
+++ b/scripts/strings/str2double.m
@@ -179,17 +179,17 @@ function [num, status, strarray] = str2d
     ## Add stop sign; makes sure last digit is not skipped.
     s(end+1) = rdelim(1);
     RD = zeros (size (s));
     for k = 1:length (rdelim),
       RD = RD | (s == rdelim(k));
     endfor
     CD = RD;
     for k = 1:length (cdelim),
-      CD = CD | (s==cdelim(k));
+      CD = CD | (s == cdelim(k));
     endfor
 
     curr_row = 1;
     curr_col = 0;
     curr_elt = 0;
 
     sl = length (s);
     ix = 1;
@@ -258,17 +258,17 @@ function [num, status, strarray] = str2d
 	endif
 
 	if (strcmpi (t(l:end), "inf"))
 	  num(curr_row,curr_col) = v*Inf;
 	elseif (strcmpi (t(l:end), "NaN"));
 	  num(curr_row,curr_col) = NaN;
 	else
 	  if (ddelim == ".")
-	    t(t==ddelim) = ".";
+	    t(t == ddelim) = ".";
 	  endif
 	  [v, tmp2, c] = sscanf(char(t), "%f %s", "C");
 	  ## [v,c,em,ni] = sscanf(char(t),"%f %s");
 	  ## c = c * (ni>length(t));
 	  if (c == 1),
 	    num(curr_row,curr_col) = v;
 	  else
 	    num(curr_row,curr_col) = NaN;
diff --git a/scripts/strings/strrep.m b/scripts/strings/strrep.m
--- a/scripts/strings/strrep.m
+++ b/scripts/strings/strrep.m
@@ -53,27 +53,28 @@ function t = strrep (s, x, y)
   if (length(ind) == 0)
     t = s;
   elseif (length(y) > 0)
     ## Replacement.
     ##
     ## Copy the parts of s that aren't being replaced.  This is done
     ## with an index vector, with jumps where each search string
     ## is found.  For a jump of 0 (target length == replacement length)
-    ## the index is just cumsum ( ones (length (s))).  For non-zero
+    ## the index is just cumsum (ones (length (s))).  For non-zero
     ## jumps, add the jump size to the ones vector at each found position.
     jump = length(y) - length(x);
     if (jump > 0)
       ## S expands.
-      di = ones(size(s));
+      di = ones (size (s));
       di(ind) = 1 + jump * ones (length (ind), 1);
       t(cumsum (di)) = s;
-    elseif (jump < 0) # s contracts
+    elseif (jump < 0)
+      ## S contracts.
       di = ones (jump * length (ind) + length (s), 1);
-      di (ind + jump * [0:length(ind)-1]) = 1 - jump * ones(length(ind), 1);
+      di (ind + jump * [0:length(ind)-1]) = 1 - jump * ones (length (ind), 1);
       t = s (cumsum (di));
     else
       ## S stays the same length.
       t = s;
     endif
     ## Now, substitute a copy of the replacement string whereever the
     ## search string was found.  Note that we must first update the
     ## target positions to account for any expansion or contraction
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -106,17 +106,17 @@ function assert (cond, varargin)
 	  endfor
 	catch
 	  iserror = 1;
 	end_try_catch
       endif
 
     elseif (isstruct (expected))
       if (! isstruct (cond) || any (size (cond) != size (expected))
-	  || rows(struct_elements (cond)) != rows (struct_elements (expected)))
+	  || rows (fieldnames (cond)) != rows (fieldnames (expected)))
 	iserror = 1;
       else
 	try
 	  empty = numel (cond) == 0;
 	  normal = numel (cond) == 1;
 	  for [v, k] = cond
 	    if (! struct_contains (expected, k))
 	      error ();
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -65,18 +65,18 @@ function [code_r, idx_r] = example (name
     endif
     if (length (idx) == 0)
       warning ("example not available for %s", name);
     elseif (n >= length(idx))
       warning ("only %d examples available for %s", length(idx)-1, name);
       doidx = [];
     endif
 
-    for i=1:length(doidx)
-      block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
+    for i = 1:length (doidx)
+      block = code (idx(doidx(i)):idx(doidx(i)+1)-1);
       printf ("%s example %d:%s\n\n", name, doidx(i), block);
     endfor
   endif
 
 endfunction
 
 %!## warning: don't modify the demos without modifying the tests!
 %!demo
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -55,17 +55,17 @@ function ret = fail (code, pattern, warn
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   ## sort out arguments
   test_warning = (nargin > 1 && strcmp (pattern, "warning"));
   if (nargin == 3)
     pattern = warning_pattern;
-  elseif (nargin == 1 || (nargin==2 && test_warning))
+  elseif (nargin == 1 || (nargin == 2 && test_warning))
     pattern = "";
   endif
 
   ## match any nonempty message
   if (isempty (pattern))
     pattern = ".";
   endif
 
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -35,17 +35,17 @@
 ## @item @var{max_n}
 ## The maximum test length to run. Default value is 100.  Alternatively,
 ## use @code{[min_n,max_n]} or for complete control, @code{[n1,n2,@dots{},nk]}.
 ##
 ## @item @var{init}
 ## Initialization expression for function argument values.  Use @var{k} 
 ## for the test number and @var{n} for the size of the test.  This should
 ## compute values for all variables listed in args.  Note that init will
-## be evaluated first for k=0, so things which are constant throughout
+## be evaluated first for @math{k = 0}, so things which are constant throughout
 ## the test can be computed then. The default value is @code{@var{x} =
 ## randn (@var{n}, 1);}.
 ##
 ## @item @var{f2}
 ## An alternative expression to evaluate, so the speed of the two
 ## can be compared. Default is @code{[]}.
 ##
 ## @item @var{tol}
@@ -82,57 +82,57 @@
 ## general order of your algorithm.  It should indicate if for 
 ## example your implementation is unexpectedly @code{O(n^2)} 
 ## rather than @code{O(n)} because it extends a vector each 
 ## time through the loop rather than preallocating one which is 
 ## big enough.  For example, in the current version of Octave,
 ## the following is not the expected @code{O(n)}:
 ##
 ## @example
-##   speed("for i=1:n,y@{i@}=x(i); end", "", [1000,10000])
+## speed ("for i = 1:n, y@{i@} = x(i); end", "", [1000,10000])
 ## @end example
 ##
 ## but it is if you preallocate the cell array @code{y}:
 ##
 ## @example
-##   speed("for i=1:n,y@{i@}=x(i);end", ...
-##         "x=rand(n,1);y=cell(size(x));", [1000,10000])
+## speed ("for i = 1:n, y@{i@} = x(i); end", ...
+##        "x = rand (n, 1); y = cell (size (x));", [1000, 10000])
 ## @end example
 ##
 ## An attempt is made to approximate the cost of the individual 
 ## operations, but it is wildly inaccurate.  You can improve the
 ## stability somewhat by doing more work for each @code{n}.  For
 ## example:
 ##
 ## @example
-##   speed("airy(x)", "x=rand(n,10)", [10000,100000])
+## speed ("airy(x)", "x = rand (n, 10)", [10000, 100000])
 ## @end example
 ##
 ## When comparing a new and original expression, the line on the
 ## speedup ratio graph should be larger than 1 if the new expression
 ## is faster.  Better algorithms have a shallow slope.  Generally, 
 ## vectorizing an algorithm will not change the slope of the execution 
 ## time graph, but it will shift it relative to the original.  For
 ## example:
 ##
 ## @example
-##   speed("v=sum(x)", "", [10000,100000], ...
-##         "v=0;for i=1:length(x),v+=x(i);end")
+## speed ("v = sum (x)", "", [10000, 100000], ...
+##        "v = 0; for i = 1:length (x), v += x(i); end")
 ## @end example
 ## 
 ## A more complex example, if you had an original version of @code{xcorr}
 ## using for loops and another version using an FFT, you could compare the
 ## run speed for various lags as follows, or for a fixed lag with varying
 ## vector lengths as follows:
 ##
 ## @example
-##   speed("v=xcorr(x,n)", "x=rand(128,1);", 100, ...
-##         "v2=xcorr_orig(x,n)", -100*eps)
-##   speed("v=xcorr(x,15)", "x=rand(20+n,1);", 100, ...
-##         "v2=xcorr_orig(x,n)", -100*eps)
+## speed ("v = xcorr (x, n)", "x = rand (128, 1);", 100,
+##        "v2 = xcorr_orig (x, n)", -100*eps)
+## speed ("v = xcorr (x, 15)", "x = rand (20+n, 1);", 100,
+##        "v2 = xcorr_orig (x, n)", -100*eps)
 ## @end example
 ##
 ## Assuming one of the two versions is in @var{xcorr_orig}, this
 ## would compare their speed and their output values.  Note that the
 ## FFT version is not exact, so we specify an acceptable tolerance on
 ## the comparison @code{100*eps}, and the errors should be computed
 ## relatively, as @code{abs((@var{x} - @var{y})./@var{y})} rather than 
 ## absolutely as @code{abs(@var{x} - @var{y})}.
@@ -200,31 +200,31 @@ function [__order, __test_n, __tnew, __t
   endif
   eval (cstrcat (__f1, ";"));
 
   ## Run the tests.
   for k = 1:length (__test_n)
     n = __test_n(k);
     eval (cstrcat (__init, ";"));
     
-    printf ("n%i=%i  ",k, n);
+    printf ("n%i = %i  ",k, n);
     fflush (stdout);
-    eval (cstrcat ("__t=time();", __f1, "; __v1=ans; __t = time()-__t;"));
+    eval (cstrcat ("__t = time();", __f1, "; __v1=ans; __t = time()-__t;"));
     if (__t < 0.25)
-      eval (cstrcat ("__t2=time();", __f1, "; __t2 = time()-__t2;"));
-      eval (cstrcat ("__t3=time();", __f1, "; __t3 = time()-__t3;"));
+      eval (cstrcat ("__t2 = time();", __f1, "; __t2 = time()-__t2;"));
+      eval (cstrcat ("__t3 = time();", __f1, "; __t3 = time()-__t3;"));
       __t = min ([__t, __t2, __t3]);
     endif
     __tnew(k) = __t;
 
     if (! isempty (__f2))
-      eval (cstrcat ("__t=time();", __f2, "; __v2=ans; __t = time()-__t;"));
+      eval (cstrcat ("__t = time();", __f2, "; __v2=ans; __t = time()-__t;"));
       if (__t < 0.25)
-      	eval (cstrcat ("__t2=time();", __f2, "; __t2 = time()-__t2;"));
-      	eval (cstrcat ("__t3=time();", __f2, "; __t3 = time()-__t3;"));
+      	eval (cstrcat ("__t2 = time();", __f2, "; __t2 = time()-__t2;"));
+      	eval (cstrcat ("__t3 = time();", __f2, "; __t3 = time()-__t3;"));
       endif
       __torig(k) = __t;
       if (! isinf(__tol))
       	assert (__v1, __v2, __tol);
       endif
     endif
   endfor
   
@@ -264,17 +264,17 @@ function [__order, __test_n, __tnew, __t
 	      cstrcat ("-*g;", strrep (__f2, ";", "."), "/",
 		      strrep (__f1, ";", "."), ";"));
     xlabel ("test length");
     title (__f1);
     ylabel ("speedup ratio");
 
     subplot (1, 2, 2);
     loglog (__test_n, __tnew*1000,
-	    cstrcat ("*-g;", strrep (__f1, ";", "."), ";" ), 
+	    cstrcat ("*-g;", strrep (__f1, ";", "."), ";"), 
 	    __test_n, __torig*1000,
 	    cstrcat ("*-r;", strrep (__f2,";","."), ";"));
   
     xlabel ("test length");
     ylabel ("best execution time (ms)");
     title (cstrcat ("init: ", __init));
 
     ratio = mean (__torig ./ __tnew);
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -215,17 +215,17 @@ function [__ret1, __ret2, __ret3, __ret4
   endif
 
   ## Chop it up into blocks for evaluation.
   __lineidx = find (__body == "\n");
   __blockidx = __lineidx(find (! isspace (__body(__lineidx+1))))+1;
 
   ## Ready to start tests ... if in batch mode, tell us what is happening.
   if (__verbose)
-    disp (cstrcat ( __signal_file, __file));
+    disp (cstrcat (__signal_file, __file));
   endif
 
   ## Assume all tests will pass.
   __all_success = 1;
 
   ## Process each block separately, initially with no shared variables.
   __tests = __successes = 0;
   __shared = " ";
