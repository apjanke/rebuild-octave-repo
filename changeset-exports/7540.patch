# HG changeset patch
# User Ben Abbott <bpabbott@mac.com>
# Date 1204184479 18000
#      Thu Feb 28 02:41:19 2008 -0500
# Node ID 3422f39573b18cbab5d4731a92e7fad3f53d61de
# Parent  3e107d73aeb4c9315f487f6396a627e3ecabeccc
strcat.m: Matlab compatibility, with cstrcat.m replacing conventional strcat.m.

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,14 @@
+2008-02-25  Ben Abbott <bpabbott@mac.com>
+
+	* interpreter/geometryimages.m, interpreter/interpimages.m,
+	interpreter/plotimages.m, interpreter/sparseimages.m:
+	Use cstrcat instead of strcat.
+
 2008-02-22  David Bateman  <dbateman@free.fr>
 
 	* interpreter/sparse.txi: Remove refernces to spdiag, spcumprod,
 	spcumsum, spprod, spsum, spsumsq, spchol, spchol2inv, spcholinv,
 	spinv and splu.
 
 2008-02-20  David Bateman  <dbateman@free.fr>
  
diff --git a/doc/interpreter/geometryimages.m b/doc/interpreter/geometryimages.m
--- a/doc/interpreter/geometryimages.m
+++ b/doc/interpreter/geometryimages.m
@@ -39,59 +39,59 @@ function geometryimages (nm, typ)
     plot (vx, vy, "r");
     [r, c] = tri2circ (tri(end,:), x, y);
     pc = [-1:0.01:1];
     xc = r * sin(pi*pc) + c(1);
     yc = r * cos(pi*pc) + c(2);
     plot (xc, yc, "g-", "LineWidth", 3);
     axis([0, 1, 0, 1]);
     legend ("Delaunay Triangulation", "Voronoi Diagram");
-    print (strcat (nm, ".", typ), strcat ("-d", typ))    
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))    
   elseif (strcmp (nm, "triplot"))
     rand ("state", 2)
     x = rand (20, 1);
     y = rand (20, 1);
     tri = delaunay (x, y);
     triplot (tri, x, y);
-    print (strcat (nm, ".", typ), strcat ("-d", typ))    
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))    
   elseif (strcmp (nm, "griddata"))
     rand("state",1);
     x=2*rand(1000,1)-1;
     y=2*rand(size(x))-1;
     z=sin(2*(x.^2+y.^2));
     [xx,yy]=meshgrid(linspace(-1,1,32));
     griddata(x,y,z,xx,yy);
-    print (strcat (nm, ".", typ), strcat ("-d", typ))    
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))    
   elseif (strcmp (nm, "convhull"))
     x = -3:0.05:3;
     y = abs (sin (x));
     k = convhull (x, y);
     plot (x(k),y(k),'r-',x,y,'b+');
     axis ([-3.05, 3.05, -0.05, 1.05]);
-    print (strcat (nm, ".", typ), strcat ("-d", typ)) 
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ)) 
   elseif (strcmp (nm, "delaunay"))
     rand ("state", 1);
     x = rand (1, 10);
     y = rand (1, 10);
     T = delaunay (x, y);
     X = [ x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1)) ];
     Y = [ y(T(:,1)); y(T(:,2)); y(T(:,3)); y(T(:,1)) ];
     axis ([0, 1, 0, 1]);
     plot(X, Y, "b", x, y, "r*");
-    print (strcat (nm, ".", typ), strcat ("-d", typ)) 
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ)) 
   elseif (strcmp (nm, "inpolygon"))
     randn ("state", 2);
     x = randn (100, 1);
     y = randn (100, 1);
     vx = cos (pi * [-1 : 0.1: 1]);
     vy = sin (pi * [-1 : 0.1 : 1]);
     in = inpolygon (x, y, vx, vy);
     plot(vx, vy, x(in), y(in), "r+", x(!in), y(!in), "bo");
     axis ([-2, 2, -2, 2]);
-    print (strcat (nm, ".", typ), strcat ("-d", typ)) 
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ)) 
   else
     error ("unrecognized plot requested");
   endif
   bury_output ();
 endfunction
 
 function [r, c] = tri2circ (tri, xx, yy)
   x = xx(tri);
@@ -124,32 +124,32 @@ function geometryimages (nm, typ)
     plot (vx, vy, "r");
     [r, c] = tri2circ (tri(end,:), x, y);
     pc = [-1:0.01:1];
     xc = r * sin(pi*pc) + c(1);
     yc = r * cos(pi*pc) + c(2);
     plot (xc, yc, "g-", "LineWidth", 3);
     axis([0, 1, 0, 1]);
     legend ("Delaunay Triangulation", "Voronoi Diagram");
-    print (strcat (nm, ".", typ), strcat ("-d", typ))    
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))    
   elseif (strcmp (nm, "triplot"))
     rand ("state", 2)
     x = rand (20, 1);
     y = rand (20, 1);
     tri = delaunay (x, y);
     triplot (tri, x, y);
-    print (strcat (nm, ".", typ), strcat ("-d", typ))    
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))    
   elseif (strcmp (nm, "griddata"))
     rand("state",1);
     x=2*rand(1000,1)-1;
     y=2*rand(size(x))-1;
     z=sin(2*(x.^2+y.^2));
     [xx,yy]=meshgrid(linspace(-1,1,32));
     griddata(x,y,z,xx,yy);
-    print (strcat (nm, ".", typ), strcat ("-d", typ))    
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))    
   else
     error ("unrecognized plot requested");
   endif
   bury_output ();
 endfunction
 
 function [r, c] = tri2circ (tri, xx, yy)
   x = xx(tri);
@@ -186,17 +186,17 @@ function sombreroimage (nm, typ)
     x = y = linspace (-8, 8, 41)';
     [xx, yy] = meshgrid (x, y);
     r = sqrt (xx .^ 2 + yy .^ 2) + eps;
     z = sin (r) ./ r;
     unwind_protect
       mesh (x, y, z);
       title ("Sorry, graphics not available because octave was\\ncompiled without the QHULL library.");
     unwind_protect_cleanup
-      print (strcat (nm, ".", typ), strcat ("-d", typ));
+      print (cstrcat (nm, ".", typ), cstrcat ("-d", typ));
       bury_output ();
     end_unwind_protect
   endif
 endfunction
 
 ## generate something for the texinfo @image command to process
 function image_as_txt(nm)
   fid = fopen (sprintf ("%s.txt", nm), "wt");
diff --git a/doc/interpreter/interpimages.m b/doc/interpreter/interpimages.m
--- a/doc/interpreter/interpimages.m
+++ b/doc/interpreter/interpimages.m
@@ -27,49 +27,49 @@ function interpimages (nm, typ)
     t = 0 : 0.3 : pi; dt = t(2)-t(1);
     n = length (t); k = 100;
     ti = t(1) + [0 : k-1]*dt*n/k;
     y = sin (4*t + 0.3) .* cos (3*t - 0.1);
     yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
     plot (ti, yp, 'g', ti, interp1(t, y, ti, 'spline'), 'b', ...
 	  ti, interpft (y, k), 'c', t, y, 'r+');
     legend ('sin(4t+0.3)cos(3t-0.1','spline','interpft','data');
-    print (strcat (nm, ".", typ), strcat ("-d", typ))
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))
   elseif (strcmp (nm, "interpn"))
     x = y = z = -1:1;
     f = @(x,y,z) x.^2 - y - z.^2;
     [xx, yy, zz] = meshgrid (x, y, z);
     v = f (xx,yy,zz);
     xi = yi = zi = -1:0.1:1;
     [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
     vi = interpn(x, y, z, v, xxi, yyi, zzi, 'spline');
     mesh (zi, yi, squeeze (vi(1,:,:)));
-    print (strcat (nm, ".", typ), strcat ("-d", typ))
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))
   elseif (strcmp (nm, "interpderiv1"))
     t = -2:2;
     dt = 1;
     ti =-2:0.025:2;
     dti = 0.025;
     y = sign(t);
     ys = interp1(t,y,ti,'spline');
     yp = interp1(t,y,ti,'pchip');
     plot (ti, ys,'r-', ti, yp,'g-');
     legend('spline','pchip', 4);
-    print (strcat (nm, ".", typ), strcat ("-d", typ))
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))
   elseif (strcmp (nm, "interpderiv2"))
     t = -2:2;
     dt = 1;
     ti =-2:0.025:2;
     dti = 0.025;
     y = sign(t);
     ddys = diff(diff(interp1(t,y,ti,'spline'))./dti)./dti;
     ddyp = diff(diff(interp1(t,y,ti,'pchip'))./dti)./dti;
     plot (ti(2:end-1),ddys,'r*', ti(2:end-1),ddyp,'g+');
     legend('spline','pchip');
-    print (strcat (nm, ".", typ), strcat ("-d", typ))
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))
   endif
   bury_output ();  
 endfunction
 
 ## Use this function before plotting commands and after every call to
 ## print since print() resets output to stdout (unfortunately, gnpulot
 ## can't pop output as it can the terminal type).
 function bury_output ()
diff --git a/doc/interpreter/plotimages.m b/doc/interpreter/plotimages.m
--- a/doc/interpreter/plotimages.m
+++ b/doc/interpreter/plotimages.m
@@ -21,52 +21,52 @@ function plotimages (nm, typ)
   if (strcmp (typ, "png"))
     set (0, "defaulttextfontname", "*");
   endif
   if (strcmp(typ , "txt"))
     image_as_txt(nm);
   elseif (strcmp (nm, "plot"))
     x = -10:0.1:10;
     plot (x, sin (x));
-    print (strcat (nm, ".", typ), strcat ("-d", typ))    
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))    
   elseif (strcmp (nm, "hist"))
     hist (randn (10000, 1), 30);
-    print (strcat (nm, ".", typ), strcat ("-d", typ))    
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))    
   elseif (strcmp (nm, "errorbar"))
     x = 0:0.1:10;
     y = sin (x);
     yp =  0.1 .* randn (size (x));
     ym = -0.1 .* randn (size (x));
     errorbar (x, sin (x), ym, yp);
-    print (strcat (nm, ".", typ), strcat ("-d", typ))    
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))    
   elseif (strcmp (nm, "polar"))
     polar (0:0.1:10*pi, 0:0.1:10*pi);
-    print (strcat (nm, ".", typ), strcat ("-d", typ))    
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))    
   elseif (strcmp (nm, "mesh"))
     tx = ty = linspace (-8, 8, 41)';
     [xx, yy] = meshgrid (tx, ty);
     r = sqrt (xx .^ 2 + yy .^ 2) + eps;
     tz = sin (r) ./ r;
     mesh (tx, ty, tz);
-    print (strcat (nm, ".", typ), strcat ("-d", typ))    
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))    
   elseif (strcmp (nm, "plot3"))
     t = 0:0.1:10*pi;
     r = linspace (0, 1, numel (t));
     z = linspace (0, 1, numel (t));
     plot3 (r.*sin(t), r.*cos(t), z);
-    print (strcat (nm, ".", typ), strcat ("-d", typ))    
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))    
   elseif (strcmp (nm, "extended"))
     x = 0:0.01:3;
     plot(x,erf(x));
     hold on;
     plot(x,x,"r");
     axis([0, 3, 0, 1]);
-    text(0.65, 0.6175, strcat('\leftarrow x = {2/\surd\pi {\fontsize{16}',
+    text(0.65, 0.6175, cstrcat('\leftarrow x = {2/\surd\pi {\fontsize{16}',
       '\int_{\fontsize{8}0}^{\fontsize{8}x}} e^{-t^2} dt} = 0.6175'))
-    print (strcat (nm, ".", typ), strcat ("-d", typ))
+    print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))
   else
     error ("unrecognized plot requested");
   endif
   bury_output ();
 endfunction
 
 function bury_output ()
   f = figure (1);
diff --git a/doc/interpreter/sparseimages.m b/doc/interpreter/sparseimages.m
--- a/doc/interpreter/sparseimages.m
+++ b/doc/interpreter/sparseimages.m
@@ -46,70 +46,70 @@ function bury_output ()
 endfunction
 
 function gplotimages (nm, typ)
   bury_output ();
   A = sparse ([2,6,1,3,2,4,3,5,4,6,1,5],
 	      [1,1,2,2,3,3,4,4,5,5,6,6], 1, 6, 6);
   xy = [0,4,8,6,4,2;5,0,5,7,5,7]';
   gplot (A, xy)
-  print (strcat (nm, ".", typ), strcat ("-d", typ))
+  print (cstrcat (nm, ".", typ), cstrcat ("-d", typ))
   bury_output ();
 endfunction
 
 function txtimages(nm,n,typ)
   a = 10*speye(n) + sparse(1:n,ceil([1:n]/2),1,n,n) + ...
       sparse(ceil([1:n]/2),1:n,1,n,n);
   if (strcmp (nm, "gplot") || strcmp (nm, "grid"))
     fid = fopen (sprintf ("%s.txt", nm), "wt");
     fputs (fid, "\n");
     fputs (fid, "+---------------------------------+\n");
     fputs (fid, "| Image unavailable in text mode. |\n");
     fputs (fid, "+---------------------------------+\n");
     fclose (fid);
   elseif (strcmp (nm, "spmatrix"))
-    printsparse(a,strcat("spmatrix.",typ));
+    printsparse(a,cstrcat("spmatrix.",typ));
   else
     if (!isempty(findstr(octave_config_info ("DEFS"),"HAVE_COLAMD")) &&
 	!isempty(findstr(octave_config_info ("DEFS"),"HAVE_CHOLMOD")))
       if (strcmp (nm, "spchol"))
 	r1 = chol(a);
-	printsparse(r1,strcat("spchol.",typ));
+	printsparse(r1,cstrcat("spchol.",typ));
       elseif (strcmp (nm, "spcholperm"))
 	[r2,p2,q2]=chol(a);
-	printsparse(r2,strcat("spcholperm.",typ));
+	printsparse(r2,cstrcat("spcholperm.",typ));
       endif
       ## printf("Text NNZ: Matrix %d, Chol %d, PermChol %d\n",nnz(a),nnz(r1),nnz(r2));
     endif
   endif
 endfunction
 
 function otherimages(nm,n,typ)
   bury_output ();
   a = 10*speye(n) + sparse(1:n,ceil([1:n]/2),1,n,n) + ...
       sparse(ceil([1:n]/2),1:n,1,n,n);
   if (strcmp (nm, "spmatrix"))
     spy(a);
     axis("ij")
-    print(strcat("spmatrix.",typ),strcat("-d",typ))
+    print(cstrcat("spmatrix.",typ),cstrcat("-d",typ))
     bury_output ();
   else
     if (!isempty(findstr(octave_config_info ("DEFS"),"HAVE_COLAMD")) &&
 	!isempty(findstr(octave_config_info ("DEFS"),"HAVE_CHOLMOD")))
       if (strcmp (nm, "spchol"))
 	r1 = chol(a);
 	spy(r1);
 	axis("ij")
-	print(strcat("spchol.",typ),strcat("-d",typ))
+	print(cstrcat("spchol.",typ),cstrcat("-d",typ))
 	bury_output ();
       elseif (strcmp (nm, "spcholperm"))
 	[r2,p2,q2]=chol(a);
 	spy(r2);
 	axis("ij")
-	print(strcat("spcholperm.",typ),strcat("-d",typ))
+	print(cstrcat("spcholperm.",typ),cstrcat("-d",typ))
 	bury_output ();
       endif
       ## printf("Image NNZ: Matrix %d, Chol %d, PermChol %d\n",nnz(a),nnz(r1),nnz(r2));
     endif
   endif
 endfunction
 
 function printsparse(a,nm)
@@ -222,17 +222,17 @@ function femimages (nm,typ)
     V(idx) = S(idx,idx)\( Q(idx) - S(idx,D_nodes)*V(D_nodes) );
 
     velems = reshape( V(elemx), 4, E);
 
     sz = size(xelems,2);
 
     plot3 (xelems, yelems, velems);
     view (10, 10);
-    print(strcat(nm,".",typ),strcat("-d",typ))
+    print(cstrcat(nm,".",typ),cstrcat("-d",typ))
     bury_output ();
   endif
 endfunction
 
 ## There is no sparse matrix implementation available because of missing
 ## libraries, plot sombreros instead. Also plot a nice title that we are
 ## sorry about that.
 function sombreroimage (nm, typ)
@@ -252,17 +252,17 @@ function sombreroimage (nm, typ)
     x = y = linspace (-8, 8, 41)';
     [xx, yy] = meshgrid (x, y);
     r = sqrt (xx .^ 2 + yy .^ 2) + eps;
     z = sin (r) ./ r;
     unwind_protect
       mesh (x, y, z);
       title ("Sorry, graphics not available because octave was\\ncompiled without the sparse matrix implementation.");
     unwind_protect_cleanup
-      print (strcat (nm, ".", typ), strcat ("-d", typ));
+      print (cstrcat (nm, ".", typ), cstrcat ("-d", typ));
       bury_output ();
     end_unwind_protect
   endif
 endfunction
 
 ## generate something for the texinfo @image command to process
 function image_as_txt(nm)
   fid = fopen (sprintf ("%s.txt", nm), "wt");
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,28 @@
+2008-02-25  Ben Abbott <bpabbott@mac.com>
+
+	* control/system/zpout.m, finance/irr.m, general/int2str.m,
+	general/num2str.m, miscellaneous/bug_report.m,
+	miscellaneous/copyfile.m, miscellaneous/dir.m,
+	miscellaneous/edit.m, miscellaneous/fullfile.m,
+	miscellaneous/mkoctfile.m, miscellaneous/movefile.m,
+	miscellaneous/tempdir.m, miscellaneous/unpack.m,
+	path/__extractpath__.m, pkg/pkg.m, plot/__ezplot__.m,
+	plot/__go_draw_axes__.m, plot/legend.m, plot/print.m,
+	signal/spectral_adf.m, signal/spectral_xdf.m,
+	statistics/tests/z_test.m, statistics/tests/z_test_2.m,
+	strings/Makefile.in, strings/strcat.m, strings/strvcat.m,
+	testfun/assert.m, testfun/demo.m, testfun/speed.m,
+	testfun/test.m: Use cstrcat instead of strcat.
+
+	* strings/strcat.m: New compatible version.
+
+	* strings/cstrcat.m: Rename from strings/strcat.m.
+
 2008-02-25  John W. Eaton  <jwe@octave.org>
 
 	* strings/isstrprop.m: New file.
 
 2008-02-25  Ryan Hinton  <rwh4s@virginia.edu>
 
 	* miscellaneous/unpack.m: Use "-f -" args for tar.
 
@@ -414,17 +434,17 @@ 2007-12-20  Michael Goffioul <michael.go
 2007-12-19  Soren Hauberg  <hauberg@gmail.com>
 
 	* image/imshow.m: Store uint8 images as doubles.  Handle default
 	display ranges correctly.
 
 2007-12-19  Alexander Barth  <barth.alexander@gmail.com>
 	    Peter A. Gustafson  <petegus@umich.edu>
 
-	* scripts/contourc.m: Allow usage of irregular spaced x, y data.
+	* plot/contourc.m: Allow usage of irregular spaced x, y data.
 
 2007-12-19  John W. Eaton  <jwe@octave.org>
 
 	* miscellaneous/edit.m: New function.
 	* miscellaneous/Makefile.in (SOURCES): Add it to the list.
 
 2007-12-19  Michael Goffioul <michael.goffioul@gmail.com>
 
diff --git a/scripts/control/system/zpout.m b/scripts/control/system/zpout.m
--- a/scripts/control/system/zpout.m
+++ b/scripts/control/system/zpout.m
@@ -53,17 +53,17 @@ function zpout (zer, pol, k, x)
 
   if (length (zer))
     ## find roots at z,s = 0
     nzr = sum (zer == 0);
     if (nzr)
       if (nzr > 1)
 	numstring = sprintf ("%s %s^%d", numstring, x, nzr);
       else
-	numstring = strcat (numstring, x);
+	numstring = cstrcat (numstring, x);
       endif
     endif
     zer = sortcom (-zer);
     for ii = 1:length(zer)
       if (zer(ii) != 0)
 	numstring = sprintf ("%s (%s %s)", numstring, x, com2str (zer(ii), 1));
       endif
     endfor
diff --git a/scripts/finance/irr.m b/scripts/finance/irr.m
--- a/scripts/finance/irr.m
+++ b/scripts/finance/irr.m
@@ -35,17 +35,17 @@ function r = irr (p, i)
     i = 0;
   elseif (! (nargin == 2))
     print_usage ();
   endif
 
   if (! (isvector (p)))
     error ("irr: p must be a vector");
   else
-    p_string = strcat ("[", sprintf ("%.15f, ", p), "]");
+    p_string = cstrcat ("[", sprintf ("%.15f, ", p), "]");
   endif
 
   if (! isscalar (i))
     error ("irr: i must be a scalar");
   endif
 
   r = fsolve (sprintf ("npv (x, %s) - %g", p_string, i), 0.01);
 
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -38,19 +38,19 @@ function retval = int2str (x)
       idx = cell ();
       for i = 1:nd
 	idx{i} = 1:sz(i);
       endfor
       idx(2) = 1;
       ifmt = get_fmt (x(idx{:}), 0);
       idx(2) = 2:sz(2);
       rfmt = get_fmt (x(idx{:}), 2);
-      fmt = strcat (ifmt, repmat (rfmt, 1, nc-1), "\n")
+      fmt = cstrcat (ifmt, repmat (rfmt, 1, nc-1), "\n")
     else
-      fmt = strcat (get_fmt (x, 0), "\n");
+      fmt = cstrcat (get_fmt (x, 0), "\n");
     endif
     tmp = sprintf (fmt, permute (x, [2, 1, 3 : nd]));
     tmp(end) = "";
     retval = split (tmp, "\n");
   else
     print_usage ();
   endif
 
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -37,17 +37,17 @@ function retval = num2str (x, arg)
 
   if (ischar (x))
     retval = x;
   elseif (isempty (x))
     retval = "";
   elseif (iscomplex (x))
     if (nargin == 2)
       if (ischar (arg))
-	fmt = strcat (arg, "%-+", arg(2:end), "i");
+	fmt = cstrcat (arg, "%-+", arg(2:end), "i");
       else
 	if (isnumeric (x) && round (x) == x && abs (x) < (10 .^ arg))
 	  fmt = sprintf ("%%%dd%%-+%ddi  ", arg, arg);
 	else
 	  fmt = sprintf ("%%%d.%dg%%-+%d.%dgi", arg+7, arg, arg+7, arg);
 	endif
       endif
     else
@@ -83,17 +83,17 @@ function retval = num2str (x, arg)
     idx = cell ();
     for i = 1:nd
       idx{i} = 1:sz(i);
     endfor
     idx{2} = perm;
     x = horzcat (real (x), imag (x));
     x = x(idx{:});
 
-    fmt = strcat (deblank (repmat (fmt, 1, nc)), "\n");
+    fmt = cstrcat (deblank (repmat (fmt, 1, nc)), "\n");
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
 
     ## Put the "i"'s where they are supposed to be.
     while (true)
       tmp2 = strrep (tmp, " i\n", "i\n");
       if (length (tmp) == length (tmp2))
 	break;
       else
@@ -135,17 +135,17 @@ function retval = num2str (x, arg)
 	  fmt = sprintf ("%%%dd  ", dgt);
 	endif
       elseif (isscalar (x))
 	fmt = "%11.5g";
       else
 	fmt = "%11.5g";
       endif
     endif
-    fmt = strcat (deblank (repmat (fmt, 1, columns (x))), "\n");
+    fmt = cstrcat (deblank (repmat (fmt, 1, columns (x))), "\n");
     nd = ndims (x);
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
     tmp(length (tmp)) = "";
     retval = strtrim (split (tmp, "\n"));
   endif
 
 endfunction
 
diff --git a/scripts/miscellaneous/bug_report.m b/scripts/miscellaneous/bug_report.m
--- a/scripts/miscellaneous/bug_report.m
+++ b/scripts/miscellaneous/bug_report.m
@@ -45,17 +45,17 @@ function bug_report ()
     if (! isempty (prefs))
       fid = fopen (prefs, "wt");
       if (fid > 0)
         dump_prefs (fid);
         fclose (fid);
       endif
     endif
 
-    cmd = strcat ("octave-bug-", OCTAVE_VERSION);
+    cmd = cstrcat ("octave-bug-", OCTAVE_VERSION);
 
     if (length (subject) > 0)
       cmd = sprintf ("%s -s \"%s\"", cmd, subject);
     endif
 
     if (! isempty (prefs))
       cmd = sprintf ("%s \"%s\"", cmd, prefs);
     endif
diff --git a/scripts/miscellaneous/copyfile.m b/scripts/miscellaneous/copyfile.m
--- a/scripts/miscellaneous/copyfile.m
+++ b/scripts/miscellaneous/copyfile.m
@@ -55,17 +55,17 @@ function [status, msg, msgid] = copyfile
       error ("copyfile: first argument must be a character string or a cell array of character strings");
     endif
 
     if (! ischar (f2))
       error ("copyfile: second argument must be a character string");
     endif
 
     if (nargin == 3 && strcmp (force, "f"))
-      cmd = strcat (cmd, " ", cmd_force_flag);
+      cmd = cstrcat (cmd, " ", cmd_force_flag);
     endif
 
     ## If f1 isn't a cellstr convert it to one.
     if (ischar (f1))
       f1 = cellstr (f1);
     endif
 
     ## If f1 has more than 1 element f2 must be a directory
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -108,17 +108,17 @@ function retval = dir (file)
 	  ## info about the link itself.
 	  if (S_ISLNK (st.mode))
 	    [xst, err, msg] = stat (fn);
 	    if (! err)
 	      st = xst;
 	    endif
 	  endif
 	  [dummy, fn, ext] = fileparts (fn);
-	  fn = strcat (fn, ext);
+	  fn = cstrcat (fn, ext);
 	  info(i,1).name = fn;
 	  lt = localtime (st.mtime);
 	  info(i,1).date = strftime ("%d-%b-%Y %T", lt);
 	  info(i,1).bytes = st.size;
 	  info(i,1).isdir = S_ISDIR (st.mode);
 	  info(i,1).datenum = datenum (lt.year + 1900, lt.mon, lt.mday,
 				       lt.hour, lt.min, lt.sec);
 	  info(i,1).statinfo = st;
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -135,17 +135,17 @@
 ## public domain.
 
 ## PKG_ADD: mark_as_command edit
 
 function ret = edit (file, state)
 
   ## Pick up globals or default them.
 
-  persistent FUNCTION = struct ("EDITOR", strcat (EDITOR (), " %s"),
+  persistent FUNCTION = struct ("EDITOR", cstrcat (EDITOR (), " %s"),
   				"HOME", fullfile (default_home, "octave"),
   				"AUTHOR", default_user(1),
   				"EMAIL",  [],
   				"LICENSE",  "GPL",
   				"MODE", "sync",
   				"EDITINPLACE", false);
 
   mlock; # make sure the state variables survive "clear functions"
@@ -192,17 +192,17 @@ function ret = edit (file, state)
       error ("expected \"edit EDITOR|HOME|AUTHOR|EMAIL|LICENSE|MODE val\"");
     endswitch
     return
   endif
 
   ## Start the editor without a file if no file is given.
   if (nargin < 1)
     if (exist (FUNCTION.HOME, "dir") == 7 && (isunix () || ! ispc ()))
-      system (strcat ("cd \"", FUNCTION.HOME, "\" ; ",
+      system (cstrcat ("cd \"", FUNCTION.HOME, "\" ; ",
 		      sprintf (FUNCTION.EDITOR, "")),
 	      [], FUNCTION.MODE);
     else
       system (sprintf (FUNCTION.EDITOR,""), [], FUNCTION.MODE);
     endif
     return;
   endif
 
@@ -266,50 +266,50 @@ function ret = edit (file, state)
       break;
     endif
   endfor
 
   if (! isempty (fileandpath))
     ## If the file exists, then edit it.
     if (FUNCTION.EDITINPLACE)
       ## Edit in place even if it is protected.
-      system (sprintf (FUNCTION.EDITOR, strcat ("\"", fileandpath, "\"")),
+      system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
               [], FUNCTION.MODE);
       return;
     else
       ## If the file is modifiable in place then edit it, otherwise make
       ## a copy in HOME and then edit it.
       fid = fopen (fileandpath, "r+t");
       if (fid < 0)
         from = fileandpath;
-        fileandpath = strcat (FUNCTION.HOME, from (rindex (from, filesep):end));
+        fileandpath = cstrcat (FUNCTION.HOME, from (rindex (from, filesep):end));
         [status, msg] = copyfile (from, fileandpath, 1);
         if (status == 0)
           error (msg);
         endif
       else
         fclose (fid);
       endif
-      system (sprintf (FUNCTION.EDITOR, strcat ("\"", fileandpath, "\"")),
+      system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
               [], FUNCTION.MODE);
       return;
     endif
   endif
 
   ## If editing a new file that is neither a m-file or an oct-file,
   ## just edit it.
   fileandpath = file;
   idx = rindex (file, ".");
   name = file(1:idx-1);
   ext = file(idx+1:end);
   switch (ext)
     case {"cc", "m"}
       0;
     otherwise
-      system (sprintf (FUNCTION.EDITOR, strcat ("\"", fileandpath, "\"")),
+      system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
 	      [], FUNCTION.MODE);
       return;
   endswitch
 
   ## The file doesn't exist in path so create it, put in the function
   ## template and edit it.
 
   ## Guess the email name if it was not given.
@@ -323,53 +323,53 @@ function ret = edit (file, state)
       ## trim newline from end of hostname
       if (! isempty (host))
 	host = host(1:end-1);
       endif
     endif
     if (isempty (host))
       FUNCTION.EMAIL = " ";
     else
-      FUNCTION.EMAIL = strcat ("<", default_user(0), "@", host, ">");
+      FUNCTION.EMAIL = cstrcat ("<", default_user(0), "@", host, ">");
     endif
   endif
 
   ## Fill in the revision string.
   now = localtime (time);
-  revs = strcat ("Created: ", strftime ("%Y-%m-%d", now));
+  revs = cstrcat ("Created: ", strftime ("%Y-%m-%d", now));
 
   ## Fill in the copyright string.
-  copyright = strcat (strftime ("Copyright (C) %Y ", now), FUNCTION.AUTHOR);
+  copyright = cstrcat (strftime ("Copyright (C) %Y ", now), FUNCTION.AUTHOR);
 
   ## Fill in the author tag field.
-  author = strcat ("Author: ", FUNCTION.AUTHOR, " ", FUNCTION.EMAIL);
+  author = cstrcat ("Author: ", FUNCTION.AUTHOR, " ", FUNCTION.EMAIL);
 
   ## Fill in the header.
   uclicense = toupper (FUNCTION.LICENSE);
   switch (uclicense)
     case "GPL"
-      head = strcat (copyright, "\n\n", "\
+      head = cstrcat (copyright, "\n\n", "\
 This program is free software; you can redistribute it and/or modify\n\
 it under the terms of the GNU General Public License as published by\n\
 the Free Software Foundation; either version 2 of the License, or\n\
 (at your option) any later version.\n\
 \n\
 This program is distributed in the hope that it will be useful,\n\
 but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
 GNU General Public License for more details.\n\
 \n\
 You should have received a copy of the GNU General Public License\n\
 along with Octave; see the file COPYING.  If not, see\n\
 <http://www.gnu.org/licenses/>.\
 ");
-      tail = strcat (author, "\n", revs);
+      tail = cstrcat (author, "\n", revs);
 
     case "BSD"
-      head = strcat (copyright, "\n\n", "\
+      head = cstrcat (copyright, "\n\n", "\
 This program is free software; redistribution and use in source and\n\
 binary forms, with or without modification, are permitted provided that\n\
 the following conditions are met:\n\
 \n\
    1.Redistributions of source code must retain the above copyright\n\
      notice, this list of conditions and the following disclaimer.\n\
    2.Redistributions in binary form must reproduce the above copyright\n\
      notice, this list of conditions and the following disclaimer in the\n\
@@ -382,81 +382,81 @@ ARE DISCLAIMED.  IN NO EVENT SHALL THE A
 FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n\
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n\
 OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n\
 HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n\
 LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n\
 OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n\
 SUCH DAMAGE.\
 ");
-      tail = strcat (author, "\n", revs);
+      tail = cstrcat (author, "\n", revs);
 
     case "PD"
       head = "";
-      tail = strcat (author, "\n", revs, "\n\n",
+      tail = cstrcat (author, "\n", revs, "\n\n",
 		     "This program is granted to the public domain.");
 
     otherwise
       head = "";
-      tail = strcat (copyright, "\n\n", FUNCTION.LICENSE, "\n",
+      tail = cstrcat (copyright, "\n\n", FUNCTION.LICENSE, "\n",
 		     author, "\n", revs);
   endswitch
 
   ## Generate the function template.
   exists = exist (name);
   switch (ext)
     case {"cc", "C", "cpp"}
       if (isempty (head))
-	comment = strcat ("/*\n", tail, "\n\n*/\n\n");
+	comment = cstrcat ("/*\n", tail, "\n\n*/\n\n");
       else
-	comment = strcat ("/*\n", head, "\n\n", tail, "\n\n*/\n\n");
+	comment = cstrcat ("/*\n", head, "\n\n", tail, "\n\n*/\n\n");
       endif
       ## If we are shadowing an m-file, paste the code for the m-file.
       if (any (exists == [2, 103]))
-	code = strcat ("\\ ", strrep (type (name), "\n", "\n// "));
+	code = cstrcat ("\\ ", strrep (type (name), "\n", "\n// "));
       else
 	code = " ";
       endif
-      body = strcat ("#include <octave/oct.h>\n\n",
+      body = cstrcat ("#include <octave/oct.h>\n\n",
                      "DEFUN_DLD(", name, ",args,nargout,\"\\\n",
 		     name, "\\n\\\n\")\n{\n",
 		     "  octave_value_list retval;\n",
 		     "  int nargin = args.length();\n\n",
 		     code, "\n  return retval;\n}\n");
 
-      text = strcat (comment, body);
+      text = cstrcat (comment, body);
     case "m"
       ## If we are editing a function defined on the fly, paste the
       ## code.
       if (any (exists == [2, 103]))
 	body = type (name);
       else
-	body = strcat ("function [ ret ] = ", name, " ()\n\nendfunction\n");
+	body = cstrcat ("function [ ret ] = ", name, " ()\n\nendfunction\n");
       endif
       if (isempty (head))
-	comment = strcat ("## ", name, "\n\n",
+	comment = cstrcat ("## ", name, "\n\n",
 			  "## ", strrep (tail, "\n", "\n## "), "\n\n");
       else
-	comment = strcat ("## ", strrep(head,"\n","\n## "), "\n\n", ...
+	comment = cstrcat ("## ", strrep(head,"\n","\n## "), "\n\n", ...
 			  "## ", name, "\n\n", ...
 			  "## ", strrep (tail, "\n", "\n## "), "\n\n");
       endif
-      text = strcat (comment, body);
+      text = cstrcat (comment, body);
   endswitch
 
   ## Write the initial file (if there is anything to write)
   fid = fopen (fileandpath, "wt");
   if (fid < 0)
     error ("edit: could not create %s", fileandpath);
   endif
   fputs (fid, text);
   fclose (fid);
 
   ## Finally we are ready to edit it!
-  system (sprintf (FUNCTION.EDITOR, strcat ("\"", fileandpath, "\"")),
+  system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
 	  [], FUNCTION.MODE);
 
 endfunction
 
 function ret = default_home ()
 
   ret = getenv ("HOME");
   if (isempty (ret))
diff --git a/scripts/miscellaneous/fullfile.m b/scripts/miscellaneous/fullfile.m
--- a/scripts/miscellaneous/fullfile.m
+++ b/scripts/miscellaneous/fullfile.m
@@ -35,35 +35,35 @@ function filename = fullfile (varargin)
       endif
       for i = 2:nargs
 	tmp = varargin{i};
 	if (i < nargs && strcmp (tmp(end), filesep))
 	  tmp(end) = "";
 	elseif (i == nargs && strcmp (tmp, filesep))
 	  tmp = "";
 	endif
-	filename = strcat (filename, filesep, tmp);
+	filename = cstrcat (filename, filesep, tmp);
       endfor
     elseif (nargs == 1)
       filename = varargin{1};
     else
       filename = "";
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!shared fs, fsx, xfs, fsxfs, xfsy
 %! fs = filesep ();
-%! fsx = strcat (fs, "x");
-%! xfs = strcat ("x", fs);
-%! fsxfs = strcat (fs, "x", fs);
-%! xfsy = strcat ("x", fs, "y");
+%! fsx = cstrcat (fs, "x");
+%! xfs = cstrcat ("x", fs);
+%! fsxfs = cstrcat (fs, "x", fs);
+%! xfsy = cstrcat ("x", fs, "y");
 %!assert (fullfile (""), "")
 %!assert (fullfile (fs), fs)
 %!assert (fullfile ("", fs), fs)
 %!assert (fullfile (fs, ""), fs)
 %!assert (fullfile ("", fs), fs)
 %!assert (fullfile ("x"), "x")
 %!assert (fullfile ("", "x"), "x")
 %!assert (fullfile ("x", ""), "x")
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -120,19 +120,19 @@
 ## PKG_ADD: mark_as_command mkoctfile
 
 function mkoctfile (varargin)
 
   bindir = octave_config_info ("bindir");
 
   shell_script = fullfile (bindir, sprintf ("mkoctfile-%s", OCTAVE_VERSION));
 
-  cmd = strcat ("\"", shell_script, "\"");
+  cmd = cstrcat ("\"", shell_script, "\"");
   for i = 1:nargin
-    cmd = strcat (cmd, " \"", varargin{i}, "\"");
+    cmd = cstrcat (cmd, " \"", varargin{i}, "\"");
   endfor
   
   status = system (cmd);
 
   if (status == 127)
     warning ("unable to find mkoctfile in expected location: `%s'",
 	     shell_script);
 
diff --git a/scripts/miscellaneous/movefile.m b/scripts/miscellaneous/movefile.m
--- a/scripts/miscellaneous/movefile.m
+++ b/scripts/miscellaneous/movefile.m
@@ -54,17 +54,17 @@ function [status, msg, msgid] = movefile
       error ("movefile: first argument must be a character string or a cell array of character strings");
     endif
 
     if (! ischar (f2))
       error ("movefile: second argument must be a character string");
     endif
 
     if (nargin == 3 && strcmp (force, "f"))
-      cmd = strcat (cmd, " ", cmd_force_flag);
+      cmd = cstrcat (cmd, " ", cmd_force_flag);
     endif
 
     ## If f1 isn't a cellstr convert it to one.
     if (ischar (f1))
       f1 = cellstr (f1);
     endif
     
     ## If f1 has more than 1 element f2 must be a directory
diff --git a/scripts/miscellaneous/tempdir.m b/scripts/miscellaneous/tempdir.m
--- a/scripts/miscellaneous/tempdir.m
+++ b/scripts/miscellaneous/tempdir.m
@@ -24,16 +24,16 @@
 function dirname = tempdir ()
 
   dirname = getenv ("TMPDIR");
   if (isempty (dirname))
     dirname = P_tmpdir;
   endif
 
   if (! strcmp (dirname(end), filesep))
-    strcat (dirname, filesep);
+    cstrcat (dirname, filesep);
   endif
 
   if (! isdir (dirname))
     warning ("tempdir: `%s' does not exist or is not a directory", dirname);
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -55,28 +55,28 @@ function filelist = unpack (file, direct
     else
       [pathstr, name, ext] = fileparts (file);
 
       ## Check to see if it's .tar.gz, .tar.Z, etc.
       if (any (strcmpi ({".gz" ".Z" ".bz2" ".bz"}, ext)))
 	[tmppathstr, tmpname, tmpext] = fileparts (name);
 	if (strcmpi (tmpext, ".tar"))
 	  name = tmpname;
-	  ext = strcat (tmpext, ext);
+	  ext = cstrcat (tmpext, ext);
 	endif
       endif
 
       ## If the file is a url, download it and then work with that
       ## file.
       if (! isempty (strfind (file, "://")))
 	## FIXME -- the above is not a perfect test for a url
 	urlfile = file;
 	## FIXME -- should we name the file that we download with the
 	## same file name as the url requests?
-	tmpfile = strcat (tmpnam (), ext);
+	tmpfile = cstrcat (tmpnam (), ext);
 	[file, success, msg] = urlwrite (urlfile, tmpfile);
 	if (! success)
 	  error ("unpack: could not get \"%s\": %s", urlfile, msg);
 	endif
       endif
 
     endif
 
@@ -167,17 +167,17 @@ function filelist = unpack (file, direct
       error ("unpack: mkdir failed to create %s: %s", directory, msg);
     endif
   elseif (! S_ISDIR (s.mode))
     error ("unpack: %s: not a directory", directory);
   endif
 
   unwind_protect
     cd (directory);
-    [status, output] = system (sprintf (strcat (command, " 2>&1"), file));
+    [status, output] = system (sprintf (cstrcat (command, " 2>&1"), file));
   unwind_protect_cleanup
     cd (origdir);
   end_unwind_protect
 
   if (status)
     error ("unpack: unarchiving program exited with status: %d\n%s",
 	   status, output);
   endif
diff --git a/scripts/path/__extractpath__.m b/scripts/path/__extractpath__.m
--- a/scripts/path/__extractpath__.m
+++ b/scripts/path/__extractpath__.m
@@ -79,16 +79,16 @@ function specifiedpath = __extractpath__
     end_unwind_protect
   endif
 
   ## Extract the path specifiation.
   if (startline > endline || (startline > 0 && endline == 0))
     error ("savepath: unable to parse file, %s", savefile);
   elseif (startline > 0)
     ## Undo doubling of single quote characters performed by savepath.
-    specifiedpath = strrep (regexprep (strcat (filelines(startline:endline){:}),
+    specifiedpath = strrep (regexprep (cstrcat (filelines(startline:endline){:}),
 				       " *path *\\('(.*)'\\); *", "$1"),
 			    "''", "'");
   else
     specifiedpath = "";
   endif
 
 endfunction  
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -426,31 +426,31 @@ function descriptions = rebuild (prefix,
     endif
     ## the two first entries of dirlist are "." and ".."
     dirlist([1,2]) = [];
   else
     old_descriptions = installed_packages (list, list);
     wd = pwd ();
     unwind_protect
       cd (prefix);
-      dirlist = glob (cellfun(@(x) strcat(x, '-*'), files, 'UniformOutput', 0));
+      dirlist = glob (cellfun(@(x) cstrcat(x, '-*'), files, 'UniformOutput', 0));
     unwind_protect_cleanup
       cd (wd);
     end_unwind_protect
   endif
   descriptions = {};
   for k = 1:length (dirlist)
     descfile = fullfile (prefix, dirlist{k}, "packinfo", "DESCRIPTION");
     if (verbose)
       printf ("recreating package description from %s\n", dirlist{k});
     endif
     if (exist (descfile, "file"))
       desc = get_description (descfile);
       desc.dir = fullfile (prefix, dirlist{k});
-      desc.archprefix = fullfile (archprefix, strcat (desc.name, "-",
+      desc.archprefix = fullfile (archprefix, cstrcat (desc.name, "-",
 				  desc.version));
       if (auto != 0)
 	if (exist (fullfile (desc.dir, "packinfo", ".autoload"), "file"))
 	  unlink (fullfile (desc.dir, "packinfo", ".autoload"));
 	endif
         if (auto < 0)
 	  desc.autoload = 0;
 	elseif (auto > 0)
@@ -616,20 +616,20 @@ function install (files, handle_deps, au
 	  [dummy, nm] = fileparts (tgz); 
 	  if ((length (nm) >= length (desc.name))
 	      && ! strcmp (desc.name, nm(1:length(desc.name))))
 	    error ("package name '%s' doesn't correspond to its filename '%s'", 
 		   desc.name, nm);
 	  endif
 
 	  ## Set default installation directory
-	  desc.dir = fullfile (prefix, strcat (desc.name, "-", desc.version));
+	  desc.dir = fullfile (prefix, cstrcat (desc.name, "-", desc.version));
 
 	  ## Set default architectire dependent installation directory
-	  desc.archprefix = fullfile (archprefix, strcat (desc.name, "-",
+	  desc.archprefix = fullfile (archprefix, cstrcat (desc.name, "-",
 							  desc.version));
 
 	  ## Save desc
 	  descriptions{end+1} = desc;
 
 	  ## Are any of the new packages already installed?
 	  ## If so we'll remove the old version.
 	  for j = 1:length (packages)
@@ -670,17 +670,17 @@ function install (files, handle_deps, au
 				     descriptions{idx2}};
       endif
       bad_deps = get_unsatisfied_deps (desc, pseudo_installed_packages);
       ## Are there any unsatisfied dependencies?
       if (! isempty (bad_deps))
 	ok = false;
 	for i = 1:length (bad_deps)
 	  dep = bad_deps{i};
-	  error_text = strcat (error_text, " ", desc.name, " needs ",
+	  error_text = cstrcat (error_text, " ", desc.name, " needs ",
 			       dep.package, " ", dep.operator, " ",
 			       dep.version, "\n");
 	endfor
       endif
     endfor
 
     ## Did we find any unsatisfied dependencies?
     if (! ok)
@@ -878,17 +878,17 @@ function uninstall (pkgnames, handle_dep
     for i = 1:length (remaining_packages)
       desc = remaining_packages{i};
       bad_deps = get_unsatisfied_deps (desc, remaining_packages);
 
       ## Will the uninstallation break any dependencies?
       if (! isempty (bad_deps))
 	for i = 1:length (bad_deps)
 	  dep = bad_deps{i};
-	  error_text = strcat (error_text, " ", desc.name, " needs ",
+	  error_text = cstrcat (error_text, " ", desc.name, " needs ",
 			       dep.package, " ", dep.operator, " ",
 			       dep.version, "\n");
 	endfor
       endif
     endfor
 
     if (! isempty (error_text))
       error ("the following dependencies where unsatisfied:\n  %s", error_text);
@@ -1108,17 +1108,17 @@ function repackage (builddir, buildlist)
       endif
       rmdir (fullfile (pack.name, "inst", "packinfo"));
       if (exist (fullfile (pack.name, "inst", "doc"), "dir"))
 	movefile (fullfile (pack.name, "inst", "doc"), pack.name);
       endif
       if (exist (fullfile (pack.name, "inst", "bin"), "dir"))
 	movefile (fullfile (pack.name, "inst", "bin"), pack.name);
       endif
-      archdir = fullfile (pack.archprefix, strcat (pack.name, "-",
+      archdir = fullfile (pack.archprefix, cstrcat (pack.name, "-",
 			  pack.version), getarch ());
       if (exist (archdir, "dir"))
 	if (exist (fullfile (pack.name, "inst", "PKG_ADD"), "file"))
 	  unlink (fullfile (pack.name, "inst", "PKG_ADD"));
 	endif
 	if (exist (fullfile (pack.name, "inst", "PKG_DEL"), "file"))
 	  unlink (fullfile (pack.name, "inst", "PKG_DEL"));
 	endif
@@ -1135,17 +1135,17 @@ function repackage (builddir, buildlist)
 	  movefile (fullfile (pack.name, "inst", "PKG_ADD"), 
 		    fullfile (pack.name, "PKG_ADD"));
 	endif 
 	if (exist (fullfile (pack.name, "inst", "PKG_DEL"), "file"))
 	  movefile (fullfile (pack.name, "inst", "PKG_DEL"), 
 		    fullfile (pack.name, "PKG_DEL")); 
 	endif	
       endif	
-      tfile = strcat (pack.name, "-", pack.version, ".tar");
+      tfile = cstrcat (pack.name, "-", pack.version, ".tar");
       tar (tfile, pack.name);
       try 
 	gzip (tfile);
 	unlink (tfile);
       catch
 	warning ("failed to compress %s", tfile);
       end_try_catch
     unwind_protect_cleanup
@@ -1200,41 +1200,41 @@ endfunction
 function configure_make (desc, packdir, verbose)   
   ## Perform ./configure, make, make install in "src"
   if (exist (fullfile (packdir, "src"), "dir"))
     src = fullfile (packdir, "src");
     ## configure
     if (exist (fullfile (src, "configure"), "file"))
       flags = "";
       if (isempty (getenv ("CC")))
-        flags = strcat (flags, " CC=\"", octave_config_info ("CC"), "\"");
+        flags = cstrcat (flags, " CC=\"", octave_config_info ("CC"), "\"");
       endif
       if (isempty (getenv ("CXX")))
-        flags = strcat (flags, " CXX=\"", octave_config_info ("CXX"), "\"");
+        flags = cstrcat (flags, " CXX=\"", octave_config_info ("CXX"), "\"");
       endif
       if (isempty (getenv ("AR")))
-        flags = strcat (flags, " AR=\"", octave_config_info ("AR"), "\"");
+        flags = cstrcat (flags, " AR=\"", octave_config_info ("AR"), "\"");
       endif
       if (isempty (getenv ("RANLIB")))
-        flags = strcat (flags, " RANLIB=\"", octave_config_info ("RANLIB"), "\"");
+        flags = cstrcat (flags, " RANLIB=\"", octave_config_info ("RANLIB"), "\"");
       endif
-      [status, output] = shell (strcat ("cd ", src, "; ./configure --prefix=\"",
+      [status, output] = shell (cstrcat ("cd ", src, "; ./configure --prefix=\"",
                                         desc.dir, "\"", flags));
       if (status != 0)
 	rm_rf (desc.dir);
 	error ("the configure script returned the following error: %s", output);
       elseif (verbose)
 	printf("%s", output);
       endif
 
     endif
 
     ## make
     if (exist (fullfile (src, "Makefile"), "file"))
-      [status, output] = shell (strcat ("export INSTALLDIR=\"", desc.dir,
+      [status, output] = shell (cstrcat ("export INSTALLDIR=\"", desc.dir,
 					 "\"; make -C ", src));
       if (status != 0)
 	rm_rf (desc.dir);
 	error ("'make' returned the following error: %s", output);
       elseif (verbose)
 	printf("%s", output);
       endif
     endif
@@ -1271,21 +1271,21 @@ function configure_make (desc, packdir, 
       mex = dir (fullfile (src, "*.mex"));
       archdependent = "";
       archindependent = "";
       filenames = "";
       if (length (m) > 0)
 	filenames = sprintf (fullfile (src, "%s "), m.name);
       endif
       if (length (oct) > 0)
-	filenames = strcat (filenames, " ",
+	filenames = cstrcat (filenames, " ",
 			    sprintf (fullfile (src, "%s "), oct.name));
       endif
       if (length (mex) > 0)
-	filenames = strcat (filenames, " ",
+	filenames = cstrcat (filenames, " ",
 			    sprintf (fullfile (src, "%s "), mex.name));
       endif
       filenames = split_by (filenames, " ");
     endif
 
     ## Split into architecture dependent and independent files
     if (isempty (filenames))
       idx = [];
@@ -1335,35 +1335,35 @@ function pkg = extract_pkg (nm, pat)
   fid = fopen (nm, "rt");
   pkg = "";
   if (fid >= 0)
     while (! feof (fid))
       ln = fgetl (fid);
       if (ln > 0)
 	t = regexp (ln, pat, "tokens");
 	if (! isempty (t))
-          pkg = strcat (pkg, "\n", t{1}{1});
+          pkg = cstrcat (pkg, "\n", t{1}{1});
 	endif
       endif
     endwhile
     if (! isempty (pkg))
-      pkg = strcat (pkg, "\n");
+      pkg = cstrcat (pkg, "\n");
     endif
     fclose (fid);
   endif
 endfunction
 
 function create_pkgadddel (desc, packdir, nm, global_install)
   instpkg = fullfile (desc.dir, nm);
   instfid = fopen (instpkg, "wt");
   ## If it is exists, most of the  PKG_* file should go into the 
   ## architecture dependent directory so that the autoload/mfilename 
   ## commands work as expected. The only part that doesn't is the
   ## part in the main directory.
-  archdir = fullfile (getarchprefix (desc), strcat (desc.name, "-",
+  archdir = fullfile (getarchprefix (desc), cstrcat (desc.name, "-",
 		      desc.version), getarch ());
   if (exist (getarchdir (desc, global_install), "dir"))
     archpkg = fullfile (getarchdir (desc, global_install), nm);
     archfid = fopen (archpkg, "at");
   else
     archpkg = instpkg;
     archfid = instfid;
   endif
@@ -1606,17 +1606,17 @@ function desc = get_description (filenam
 
   line = fgetl (fid);
   while (line != -1)
     if (line(1) == "#")
       ## Comments, do nothing
     elseif (isspace(line(1)))
       ## Continuation lines
       if (exist ("keyword", "var") && isfield (desc, keyword))
-	desc.(keyword) = strcat (desc.(keyword), " ", rstrip(line));
+	desc.(keyword) = cstrcat (desc.(keyword), " ", rstrip(line));
       endif
     else
       ## Keyword/value pair
       colon = find (line == ":");
       if (length (colon) == 0)
 	disp ("skipping line");
       else
 	colon = colon(1);
@@ -1951,20 +1951,20 @@ function [out1, out2] = installed_packag
   for i = 1:num_packages
     cur_name = installed_pkgs_lst{idx(i)}.name;
     cur_version = installed_pkgs_lst{idx(i)}.version;
     cur_dir = installed_pkgs_lst{idx(i)}.dir;
     if (length (cur_dir) > max_dir_length)
       first_char = length (cur_dir) - max_dir_length + 4;
       first_filesep = strfind (cur_dir(first_char:end), filesep());
       if (! isempty (first_filesep))
-        cur_dir = strcat ("...", 
+        cur_dir = cstrcat ("...", 
 			  cur_dir((first_char + first_filesep(1) - 1):end));
       else
-        cur_dir = strcat ("...", cur_dir(first_char:end));
+        cur_dir = cstrcat ("...", cur_dir(first_char:end));
       endif
     endif
     if (installed_pkgs_lst{idx(i)}.loaded)
       cur_loaded = "*";
     else
       cur_loaded = " ";
     endif
     printf (format, cur_name, cur_loaded, cur_version, cur_dir);
@@ -2109,25 +2109,25 @@ function emp = dirempty (nm, ign)
     endfor
     emp = true;
   else
     emp = true;
   endif
 endfunction
 
 function arch = getarch ()
-  persistent _arch = strcat (octave_config_info("canonical_host_type"), ...
+  persistent _arch = cstrcat (octave_config_info("canonical_host_type"), ...
 			     "-", octave_config_info("api_version"));
   arch = _arch;
 endfunction
 
 function archprefix = getarchprefix (desc, global_install)
   if ((nargin == 2 && global_install) || (nargin < 2 && issuperuser ()))
     archprefix = fullfile (octave_config_info ("libexecdir"), "octave", 
-			   "packages", strcat(desc.name, "-", desc.version));
+			   "packages", cstrcat(desc.name, "-", desc.version));
   else
     archprefix = desc.dir;
   endif
 endfunction
 
 function archdir = getarchdir (desc)
   archdir = fullfile (desc.archprefix, getarch());
 endfunction
@@ -2148,17 +2148,17 @@ function [status, output] = shell (cmd)
     if (isempty(have_sh))
       if (system("sh.exe -c \"exit\""))
         have_sh = false;
       else
         have_sh = true;
       endif
     endif
     if (have_sh)
-      [status, output] = system (strcat ("sh.exe -c \"", cmd, "\""));
+      [status, output] = system (cstrcat ("sh.exe -c \"", cmd, "\""));
     else
       error ("Can not find the command shell")
     endif
   else
     [status, output] = system (cmd);
   endif
 endfunction
 
@@ -2202,23 +2202,23 @@ function load_packages_and_dependencies 
 					 global_install)
   idx = load_package_dirs (idx, [], handle_deps, installed_pkgs_lst);
   dirs = {};
   execpath = EXEC_PATH ();
   for i = idx;
     ndir = installed_pkgs_lst{i}.dir;
     dirs{end+1} = ndir;
     if (exist (fullfile (dirs{end}, "bin"), "dir"))
-      execpath = strcat (fullfile (dirs{end}, "bin"), ":", execpath);
+      execpath = cstrcat (fullfile (dirs{end}, "bin"), ":", execpath);
     endif
     tmpdir = getarchdir (installed_pkgs_lst{i});
     if (exist (tmpdir, "dir"))
       dirs{end + 1} = tmpdir;
       if (exist (fullfile (dirs{end}, "bin"), "dir"))
-        execpath = strcat (fullfile (dirs{end}, "bin"), ":", execpath);
+        execpath = cstrcat (fullfile (dirs{end}, "bin"), ":", execpath);
       endif
     endif
   endfor
 
   ## Load the packages
   if (length (dirs) > 0)
     addpath (dirs{:});
   endif
diff --git a/scripts/plot/__ezplot__.m b/scripts/plot/__ezplot__.m
--- a/scripts/plot/__ezplot__.m
+++ b/scripts/plot/__ezplot__.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Undocumented internal function
 
 function [h, needusage] = __ezplot__ (pfunc, varargin)
 
-  func = strcat ("ez", pfunc);
+  func = cstrcat ("ez", pfunc);
   if (strncmp (pfunc, "contour", 7))
     iscontour = true;
   else
     iscontour = false;
   endif
   if (strcmp (pfunc, "plot3"))
     isplot3 = true;
     ispolar = false;
@@ -249,17 +249,17 @@ function [h, needusage] = __ezplot__ (pf
     endif
 
     fstrx = regexprep (regexprep (regexprep (fstrx,'\.\^\s*','^'), 
 		      '\./', '/'), '[\.]*\*', '');
     fstry = regexprep (regexprep (regexprep (fstry,'\.\^\s*','^'), 
 		      '\./', '/'), '[\.]*\*', '');
     fstrz = regexprep (regexprep (regexprep (fstrz,'\.\^\s*','^'), 
 		      '\./', '/'), '[\.]*\*', '');
-    fstr = strcat ("[",fstrx,",",fstry,",",fstrz,"]");
+    fstr = cstrcat ("[",fstrx,",",fstry,",",fstrz,"]");
   else
     if (isplot3)
       needusage = true;
       return;
     endif
 
     if (ispolar)
       Z = feval (fun, X);
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -390,17 +390,17 @@ function __go_draw_axes__ (h, plot_strea
 	  data_idx++;
 	  is_image_data(data_idx) = false;
 	  parametric(data_idx) = true;
 	  have_cdata(data_idx) = false;
 	  if (isempty (obj.keylabel))
 	    titlespec{data_idx} = "title \"\"";
 	  else
 	    tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "keylabel", have_newer_gnuplot));
-	    titlespec{data_idx} = strcat ("title \"", tmp, "\"");
+	    titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
 	  endif
 	  usingclause{data_idx} = "";
 	  errbars = "";
 	  if (nd == 3)
 	    xdat = obj.xdata(:);
 	    ydat = obj.ydata(:);
 	    if (! isempty (obj.zdata))
 	      zdat = obj.zdata(:);
@@ -542,17 +542,17 @@ function __go_draw_axes__ (h, plot_strea
 	       data_idx++;
 	       is_image_data(data_idx) = false;
 	       parametric(data_idx) = false;
 	       have_cdata(data_idx) = false;
 	       if (i > 1 || isempty (obj.keylabel))
 		 titlespec{data_idx} = "title \"\"";
 	       else
 		 tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "keylabel", have_newer_gnuplot));
-		 titlespec{data_idx} = strcat ("title \"", tmp, "\"");
+		 titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
 	       endif
 	       usingclause{data_idx} = "";
                if (isfield (obj, "facecolor"))
 		 if ((strncmp (obj.facecolor, "flat", 4)
 		     || strncmp (obj.facecolor, "interp", 6))
 		     && isfield (obj, "cdata"))
 		   if (ndims (obj.cdata) == 2
 		       && (size (obj.cdata, 2) == nc
@@ -844,17 +844,17 @@ function __go_draw_axes__ (h, plot_strea
 	    parametric(data_idx) = false;
 	    have_cdata(data_idx) = true;
 	    [style, typ, with] = do_linestyle_command (obj, data_idx,
 						       mono, plot_stream);
 	    if (isempty (obj.keylabel))
 	      titlespec{data_idx} = "title \"\"";
 	    else
 	      tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "keylabel", have_newer_gnuplot));
-	      titlespec{data_idx} = strcat ("title \"", tmp, "\"");
+	      titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
 	    endif
 	    usingclause{data_idx} = "";
 	    if (have_newer_gnuplot || isnan (typ))
 	      withclause{data_idx} = sprintf ("with pm3d linestyle %d",
 		           		      data_idx);
 	    else
 	      withclause{data_idx} = sprintf ("with pm3d linetype %d %s",
 		 			      typ, with);
@@ -1469,17 +1469,17 @@ function __gnuplot_write_data__ (plot_st
   ## "NA" and that confuses gnuplot.
   idx = find (isna (data));
   if (any (idx))
     data(idx) = NaN;
   endif
 
   if (nd == 2)
     nan_elts = find (sum (isnan (data)));
-    fmt = strcat (repmat ("%.15g ", 1, rows (data)), "\n");
+    fmt = cstrcat (repmat ("%.15g ", 1, rows (data)), "\n");
     if (isempty (nan_elts))
       fprintf (plot_stream, fmt, data);
     else
       n = columns (data);
       have_nans = true;
       num_nan_elts = numel (nan_elts);
       k = 1;
       for i = 1:n
@@ -1649,27 +1649,27 @@ function [f, s, fnt, it, bld] = get_font
   endif
   f = fnt;
   it = false;
   bld = false;
   if (! isempty (t.fontweight) && strcmpi (t.fontweight, "bold"))
     if (! isempty(t.fontangle)
 	&& (strcmpi (t.fontangle, "italic")
 	    || strcmpi (t.fontangle, "oblique")))
-      f = strcat (f, "-bolditalic");
+      f = cstrcat (f, "-bolditalic");
       it = true;
       bld = true;
     else
-      f = strcat (f, "-bold");
+      f = cstrcat (f, "-bold");
       bld = true;
     endif
   elseif (! isempty(t.fontangle)
 	  && (strcmpi (t.fontangle, "italic")
 	      || strcmpi (t.fontangle, "oblique")))
-    f = strcat (f, "-italic");
+    f = cstrcat (f, "-italic");
     it = true;
   endif
   if (isempty (t.fontsize))
     s = 10;
   else
     s = t.fontsize;
   endif
 endfunction
@@ -1689,17 +1689,17 @@ function [str, f, s] = __maybe_munge_tex
   endif
 
   str = getfield (obj, fld);
   if (enhanced)
     if (strcmp (obj.interpreter, "tex"))
       str = __tex2enhanced__ (str, fnt, it, bld);
       if (! have_newer_gnuplot)
 	## Set the font to work around gnuplot 4.0 X11 enhanced terminal bug
-	str = strcat ('{/', f, ' ', str, ' }'); 
+	str = cstrcat ('{/', f, ' ', str, ' }'); 
       endif
     elseif (strcmp (obj.interpreter, "latex"))
       if (! warned_latex)
 	warning ("latex text objects not supported");
 	warned_latex = true;
       endif
     endif
   endif
@@ -1709,79 +1709,79 @@ function str = __tex2enhanced__ (str, fn
   persistent sym = __setup_sym_table__ ();
   persistent flds = fieldnames (sym);
 
   [s, e, m] = regexp(str,'\\([a-zA-Z]+|0)','start','end','matches');
 
   for i = length (s) : -1 : 1
     ## special case for "\0"  and replace with "{/Symbol \306}'
     if (strncmp (m{i}, '\0', 2))
-      str = strcat (str(1:s(i) - 1), '{/Symbol \306}', str(s(i) + 2:end));
+      str = cstrcat (str(1:s(i) - 1), '{/Symbol \306}', str(s(i) + 2:end));
     else
       f = m{i}(2:end);
       if (isfield (sym, f))
 	g = getfield(sym, f);
 	## FIXME The symbol font doesn't seem to support bold or italic
 	##if (bld)
 	##  if (it)
 	##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
 	##  else
 	##    g = regexprep (g, '/Symbol', '/Symbol-bold');
 	##  endif
 	##elseif (it)
 	##  g = regexprep (g, '/Symbol', '/Symbol-italic');
 	##endif
-        str = strcat (str(1:s(i) - 1), g, str(e(i) + 1:end));
+        str = cstrcat (str(1:s(i) - 1), g, str(e(i) + 1:end));
       elseif (strncmp (f, "rm", 2))
 	bld = false;
 	it = false;
-        str = strcat (str(1:s(i) - 1), '/', fnt, ' ', str(s(i) + 3:end));
+        str = cstrcat (str(1:s(i) - 1), '/', fnt, ' ', str(s(i) + 3:end));
       elseif (strncmp (f, "it", 2) || strncmp (f, "sl", 2))
 	it = true;
 	if (bld)
-          str = strcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ', 
+          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ', 
 			str(s(i) + 3:end));
         else
-          str = strcat (str(1:s(i) - 1), '/', fnt, '-italic ', 
+          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-italic ', 
 			str(s(i) + 3:end));
         endif
       elseif (strncmp (f, "bf", 2))
 	bld = true;
 	if (it)
-          str = strcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ', 
+          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ', 
 			str(2(i) + 3:end));
         else
-          str = strcat (str(1:s(i) - 1), '/', fnt, '-bold ', 
+          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bold ', 
 			str(s(i) + 3:end));
         endif
       elseif (strcmp (f, "color"))
 	## FIXME Ignore \color but remove trailing {} block as well
 	d = strfind(str(e(i) + 1:end),'}');
         if (isempty (d))
 	  warning ('syntax error in \color argument');
 	else
-	  str = strcat (str(1:s(i) - 1), str(e(i) + d + 1:end));
+	  str = cstrcat (str(1:s(i) - 1), str(e(i) + d + 1:end));
         endif
       elseif(strcmp (f, "fontname"))
 	b1 = strfind(str(e(i) + 1:end),'{');
 	b2 = strfind(str(e(i) + 1:end),'}');
         if (isempty(b1) || isempty(b2))
 	  warning ('syntax error in \fontname argument');
 	else
-          str = strcat (str(1:s(i) - 1), '/', 
+          str = cstrcat (str(1:s(i) - 1), '/', 
 			str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
 			str(e(i) + b2(1) + 1:end));
         endif
       elseif(strcmp (f, "fontsize"))
 	b1 = strfind(str(e(i) + 1:end),'{');
 	b2 = strfind(str(e(i) + 1:end),'}');
         if (isempty(b1) || isempty(b2))
 	  warning ('syntax error in \fontname argument');
 	else
-          str = strcat (str(1:s(i) - 1), '/=', 
+          str = cstrcat (str(1:s(i) - 1), '/=', 
 			str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
 			str(e(i) + b2(1) + 1:end));
         endif
       else
 	## Last desperate attempt to treat the symbol. Look for things
 	## like \pix, that should be translated to the symbol Pi and x
 	for j = 1 : length (flds)
 	  if (strncmp (flds{j}, f, length (flds{j})))
@@ -1791,17 +1791,17 @@ function str = __tex2enhanced__ (str, fn
 	    ##  if (it)
 	    ##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
 	    ##  else
 	    ##    g = regexprep (g, '/Symbol', '/Symbol-bold');
 	    ##  endif
 	    ##elseif (it)
 	    ##  g = regexprep (g, '/Symbol', '/Symbol-italic');
 	    ##endif
-            str = strcat (str(1:s(i) - 1), g, 
+            str = cstrcat (str(1:s(i) - 1), g, 
 	    		  str(s(i) + length (flds{j}) + 1:end));
 	    break;
 	  endif
 	endfor
       endif
     endif
   endfor
 
@@ -1849,36 +1849,36 @@ function str = __tex2enhanced__ (str, fn
 	      else
 		si++;
 	      endif
 	    endwhile
 	    l2 = l2 (min (length(l2), si));
 	    if (length_string (str(s(i)+p+2:s(i)+p+l1-1)) <=
 		length_string(str(s(i+1)+p+2:s(i+1)+p+l2-1)))
 	      ## shortest already first!
-	      str = strcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
+	      str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
 	    else
 	      ## Have to swap sub/super-script to get shortest first
-	      str = strcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+l2),
+	      str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+l2),
 			    str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+l2+1:end));
 	    endif
 	  else
 	    ## Have to swap sub/super-script to get shortest first
-	    str = strcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+1),
+	    str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+1),
 			  str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+2:end));
 	  endif
           i += 2;
 	  p ++;
 	else
 	  i++;
 	endif
       else
 	if (s(i+1) == s(i) + 2)
 	  ## shortest already first!
-	  str = strcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
+	  str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
 	  p ++;
           i += 2;
 	else
 	  i ++;
 	endif
       endif
     else
       i ++;
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -205,14 +205,14 @@ endfunction
 %! title("a very long label can sometimes cause problems");
 %! legend({"hello world"}, "location", "northeastoutside")
 
 %!demo
 %! close all;
 %! labels = {};
 %! for i = 1:5
 %!     plot(1:100, i + rand(100,1)); hold on;
-%!     labels = {labels{:}, strcat("Signal ", num2str(i))};
+%!     labels = {labels{:}, cstrcat("Signal ", num2str(i))};
 %! endfor; hold off;
 %! title("Signals with random offset and uniform noise")
 %! xlabel("Sample Nr [k]"); ylabel("Amplitude [V]");
 %! legend(labels, "location", "southoutside")
 %! legend("boxon")
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -182,19 +182,19 @@ function print (varargin)
     else
       error ("print: expects string options");
     endif
   endfor
 
   doprint = isempty (name);
   if (doprint)
     if (isempty (devopt))
-      printname = strcat (tmpnam, ".ps");
+      printname = cstrcat (tmpnam, ".ps");
     else
-      printname = strcat (tmpnam, ".", devopt);
+      printname = cstrcat (tmpnam, ".", devopt);
     endif
     name = printname;
   endif
 
   if (isempty (devopt))
     dot = rindex (name, ".");
     if (dot == 0)
       error ("print: no format specified");
@@ -204,39 +204,39 @@ function print (varargin)
   else
     dev = devopt;
   endif
 
   if (strcmp (dev, "tex"))
     dev = "epslatex";
     ## gnuplot 4.0 wants ".eps" in the output name    
     if (compare_versions (__gnuplot_version__, "4.2", "<"))
-      name = strcat (name(1:dot), "eps");
+      name = cstrcat (name(1:dot), "eps");
     endif
   elseif (strcmp (dev, "ill"))
     dev = "aifm";
   elseif (strcmp (dev, "cdr"))
     dev = "corel";
   endif
 
   ## check if we have to use convert
   dev_list = {"aifm", "corel", "fig", "png", "pbm", "dxf", "mf", "svg", ...
 	      "hpgl", "ps", "ps2", "psc", "psc2", "eps", "eps2", ...
 	      "epsc", "epsc2", "emf", "pstex", "pslatex", ...
 	      "epslatex", "epslatexstandalone", "pdf"};
   convertname = "";
   [idx, errmsg] = cellidx (dev_list, dev);
   if (! idx)
     if (! isempty (devopt))
-      convertname = strcat (devopt, ":", name);
+      convertname = cstrcat (devopt, ":", name);
     else
       convertname = name;
     endif
     dev = "epsc";
-    name = strcat (tmpnam, ".eps");
+    name = cstrcat (tmpnam, ".eps");
   endif
 
   if (strcmp (dev, "ps") || strcmp (dev, "ps2") ...
       || strcmp (dev, "psc")  || strcmp (dev, "psc2")
       || strcmp (dev, "epsc") || strcmp (dev, "epsc2")
       || strcmp (dev, "eps")  || strcmp (dev, "eps2")
       || strcmp (dev, "pstex")|| strcmp (dev, "pslatex")
       || strcmp (dev, "epslatex") || strcmp (dev, "epslatexstandalone"))
@@ -252,95 +252,95 @@ function print (varargin)
 	options = "standalone ";
       else
 	error ("print: epslatexstandalone needs gnuplot 4.2 or higher");
       endif
     else
       if (dev(1) == "e")
 	options = "eps ";
       else
-	options = strcat (orientation, " ");
+	options = cstrcat (orientation, " ");
       endif
       termn = "postscript";
     endif
     
     if (any (dev == "c") || use_color > 0)
       if (force_solid < 0)
-	options = strcat (options, "color dashed ");
+	options = cstrcat (options, "color dashed ");
       else
-	options = strcat (options, "color solid ");
+	options = cstrcat (options, "color solid ");
       endif
     else
       if (force_solid > 0)
-	options = strcat (options, "mono solid ");
+	options = cstrcat (options, "mono solid ");
       else
-	options = strcat (options, "mono dashed ");
+	options = cstrcat (options, "mono dashed ");
       endif
     endif
 
     if (! isempty (font))
-      options = strcat (options, "\"", font, "\" ");
+      options = cstrcat (options, "\"", font, "\" ");
     endif
     if (! isempty (fontsize))
-      options = strcat (options, " ", fontsize);
+      options = cstrcat (options, " ", fontsize);
     endif
     
-    new_terminal = strcat (termn, " ", options);
+    new_terminal = cstrcat (termn, " ", options);
     
   elseif (strcmp (dev, "aifm") || strcmp (dev, "corel"))
     ## Adobe Illustrator, CorelDraw
     if (use_color >= 0)
       options = " color";
     else
       options = " mono";
     endif
     if (! isempty (font))
-      options = strcat (options, " \"", font, "\"");
+      options = cstrcat (options, " \"", font, "\"");
     endif
     if (! isempty (fontsize))
-      options = strcat (options, " ", fontsize);
+      options = cstrcat (options, " ", fontsize);
     endif
 
-    new_terminal = strcat (dev, " ", options);
+    new_terminal = cstrcat (dev, " ", options);
 
   elseif (strcmp (dev, "fig"))
     ## XFig
     options = orientation;
     if (use_color >= 0)
       options = " color";
     else
       options = " mono";
     endif
-    options = strcat (options, " ", special_flag);
+    options = cstrcat (options, " ", special_flag);
     if (! isempty (fontsize))
-      options = strcat (options, " fontsize ", fontsize);
+      options = cstrcat (options, " fontsize ", fontsize);
     endif
 
-    new_terminal = strcat ("fig ", options);
+    new_terminal = cstrcat ("fig ", options);
 
 
   elseif (strcmp (dev, "emf"))
     ## Enhanced Metafile format
     options = " ";
     if (use_color >= 0)
       options = " color";
     else
       options = " mono";
     endif
     if (force_solid >= 0)
-      options = strcat (options, " solid");
+      options = cstrcat (options, " solid");
     endif
     if (! isempty (font))
-      options = strcat (options, " \"", font, "\"");
+      options = cstrcat (options, " \"", font, "\"");
     endif
     if (! isempty (fontsize))
-      options = strcat (options, " ", fontsize);
+      options = cstrcat (options, " ", fontsize);
     endif
 
-    new_terminal = strcat ("emf ", options);
+    new_terminal = cstrcat ("emf ", options);
 
   elseif (strcmp (dev, "png") || strcmp (dev, "pbm"))
     ## Portable network graphics, PBMplus
 
     ## FIXME -- New PNG interface takes color as "xRRGGBB"
     ## where x is the literal character 'x' and 'RRGGBB' are the red,
     ## green and blue components in hex.  For now we just ignore it
     ## and use default.  The png terminal now is so rich with options,
@@ -351,53 +351,53 @@ function print (varargin)
     ##	eval (sprintf ("__gnuplot_set__ term %s color medium", dev));
     ##else
     ##eval (sprintf ("__gnuplot_set__ term %s mono medium", dev));
     ##endif
 
     if (isempty (size))
       options = " large";
     else
-      options = strcat (" size ", size);
+      options = cstrcat (" size ", size);
     endif
-    new_terminal = strcat (dev, options);
+    new_terminal = cstrcat (dev, options);
 
   elseif (strcmp (dev, "dxf") || strcmp (dev, "mf") || strcmp (dev, "hpgl"))
     ## AutoCad DXF, METAFONT, HPGL
     new_terminal = dev;
 
   elseif (strcmp (dev, "svg"))
     ## SVG
     options = "";
     if (! isempty (size))
-      options = strcat (" size ", size);
+      options = cstrcat (" size ", size);
     endif
-    new_terminal = strcat ("svg", options);
+    new_terminal = cstrcat ("svg", options);
     
   elseif (strcmp (dev, "pdf"))
     ## Portable Document format
     options = " ";
     if (use_color >= 0)
       options = "color";
     else
       options = "mono";
     endif
     if (force_solid > 0)
-       options = strcat (options, " solid");
+       options = cstrcat (options, " solid");
     elseif (force_solid < 0)
-      options = strcat (options, " dashed");
+      options = cstrcat (options, " dashed");
     endif
     if (! isempty (font))
-      options = strcat (options, "\"", font, "\" ");
+      options = cstrcat (options, "\"", font, "\" ");
     endif
     if (! isempty (fontsize))
-      options = strcat (options, " ", fontsize);
+      options = cstrcat (options, " ", fontsize);
     endif
 
-    new_terminal = strcat ("pdf ", options);
+    new_terminal = cstrcat ("pdf ", options);
 
   endif
 
   mono = use_color < 0;
 
   if (debug)
     drawnow (new_terminal, name, mono, debug_file);
   else
diff --git a/scripts/signal/spectral_adf.m b/scripts/signal/spectral_adf.m
--- a/scripts/signal/spectral_adf.m
+++ b/scripts/signal/spectral_adf.m
@@ -43,17 +43,17 @@ function retval = spectral_adf (c, win, 
 
   if (nargin < 3)
     b = 1 / ceil (sqrt (cr));
   endif
 
   if (nargin == 1)
     w = triangle_lw (cr, b);
   else
-    win = str2func (strcat (win, "_lw"));
+    win = str2func (cstrcat (win, "_lw"));
     w = feval (win, cr, b);
   endif
 
   c = c .* w;
 
   retval = 2 * real (fft (c)) - c(1);
   retval = [(zeros (cr, 1)), retval];
   retval(:, 1) = (0 : cr-1)' / cr;
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -42,17 +42,17 @@ function retval = spectral_xdf (X, win, 
 
   if (nargin < 3)
     b = 1 / ceil (sqrt (xr));
   endif
 
   if (nargin == 1)
     w = triangle_sw (xr, b);
   else
-    win = str2func (strcat (win, "_sw"));
+    win = str2func (cstrcat (win, "_sw"));
     w = feval (win, xr, b);
   endif
 
   X = X - sum (X) / xr;
 
   retval = (abs (fft (X)) / xr).^2;
   retval = real (ifft (fft(retval) .* fft(w)));
 
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -74,15 +74,15 @@ function [pval, z] = z_test (x, m, v, al
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("z_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    s = strcat ("Z-test of mean(x) == %g against mean(x) %s %g,\n",
+    s = cstrcat ("Z-test of mean(x) == %g against mean(x) %s %g,\n",
                 "with known var(x) == %g:\n",
                 "  pval = %g\n");
     printf (s, m, alt, m, v, pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -74,16 +74,16 @@ function [pval, z] = z_test_2 (x, y, v_x
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("z_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    s = strcat ("Two-sample Z-test of mean(x) == mean(y) against ",
+    s = cstrcat ("Two-sample Z-test of mean(x) == mean(y) against ",
                 "mean(x) %s mean(y),\n",
                 "with known var(x) == %g and var(y) == %g:\n",
                 "  pval = %g\n");
     printf (s, alt, v_x, v_y, pval);
   endif
 
 endfunction
diff --git a/scripts/strings/Makefile.in b/scripts/strings/Makefile.in
--- a/scripts/strings/Makefile.in
+++ b/scripts/strings/Makefile.in
@@ -31,17 +31,17 @@ include $(TOPDIR)/Makeconf
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 
 SOURCES = base2dec.m bin2dec.m blanks.m deblank.m dec2base.m \
   dec2bin.m dec2hex.m findstr.m hex2dec.m index.m isletter.m \
   lower.m mat2str.m rindex.m split.m str2double.m str2mat.m \
-  str2num.m strcat.m strcmpi.m strfind.m strjust.m strmatch.m \
+  str2num.m strcat.m cstrcat.m strcmpi.m strfind.m strjust.m strmatch.m \
   strncmpi.m strrep.m strtok.m strtrim.m strtrunc.m strvcat.m \
   substr.m upper.m
 
 DISTFILES = $(addprefix $(srcdir)/, Makefile.in $(SOURCES))
 
 FCN_FILES = $(addprefix $(srcdir)/, $(SOURCES))
 FCN_FILES_NO_DIR = $(notdir $(FCN_FILES))
 
diff --git a/scripts/strings/strcat.m b/scripts/strings/cstrcat.m
copy from scripts/strings/strcat.m
copy to scripts/strings/cstrcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/cstrcat.m
@@ -13,73 +13,58 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} strcat (@var{s1}, @var{s2}, @dots{})
+## @deftypefn {Function File} {} cstrcat (@var{s1}, @var{s2}, @dots{})
 ## Return a string containing all the arguments concatenated.  For example,
 ##
 ## @example
 ## @group
 ## s = [ "ab"; "cde" ];
-## strcat (s, s, s)
+## cstrcat (s, s, s)
 ##      @result{} "ab ab ab "
 ##         "cdecdecde"
 ## @end group
 ## @end example
 ## @end deftypefn
 
 ## Author: jwe
 
-function st = strcat (varargin)
+function st = cstrcat (varargin)
 
   if (nargin > 0)
 
     if (iscellstr (varargin))
       ## All arguments are character strings.
       unwind_protect
 	tmp = warning ("query", "Octave:empty-list-elements");
 	warning ("off", "Octave:empty-list-elements");
 	st = [varargin{:}];
       unwind_protect_cleanup
 	warning (tmp.state, "Octave:empty-list-elements");
       end_unwind_protect
     else
-      for i = 1:nargin
-	tmp = varargin{i};
-	if (! (iscellstr (tmp) || ischar (tmp)))
-	  error ("strcat: all arguments must be strings or cell arrays of strings");
-	endif
-      endfor
-      st = strcat_cell (varargin);
+      error ("cstrcat: expecting arguments to character strings");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
-function st = strcat_cell (varargin)
-  ## All args must be same size or scalars.
-  ## See the xtest below for expected behavior.
-  error ("strcat: concatenating cell arrays of strings not implemented");
-endfunction
-
 ## test the dimensionality
 ## 1d
-%!assert(strcat("ab ", "ab "), "ab ab ")
+%!assert(cstrcat("ab ", "ab "), "ab ab ")
 ## 2d
-%!assert(strcat(["ab ";"cde"], ["ab ";"cde"]), ["ab ab ";"cdecde"])
-
-%!assert((strcmp (strcat ("foo", "bar"), "foobar")
-%! && strcmp (strcat (["a"; "bb"], ["foo"; "bar"]), ["a foo"; "bbbar"])));
+%!assert(cstrcat(["ab ";"cde"], ["ab ";"cde"]), ["ab ab ";"cdecde"])
 
-%!xtest
-%! assert(all (strcmp (strcat ("a", {"bc", "de"}, "f"), {"abcf", "adef"})))
+%!assert((strcmp (cstrcat ("foo", "bar"), "foobar")
+%! && strcmp (cstrcat (["a"; "bb"], ["foo"; "bar"]), ["a foo"; "bbbar"])));
 
-%!error strcat ();
+%!error cstrcat ();
 
-%!error strcat (1, 2);
+%!error cstrcat (1, 2);
 
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -31,55 +31,87 @@
 ## @end example
 ## @end deftypefn
 
 ## Author: jwe
 
 function st = strcat (varargin)
 
   if (nargin > 0)
+    if (nargin == 1)
+      st = varargin{1};
+    elseif (nargin > 1)
+      ## Convert to cells of strings
+      numstrs(nargin) = 0;
+      dims{nargin} = [];
+      allchar = true;
+      for nv = 1:nargin
+        if (ischar (varargin{nv}))
+          varargin{nv} = cellstr (varargin{nv});
+        elseif (iscell (varargin{nv}))
+          allchar = false;
+        else
+          error ("strcat: inputs must be strings or cells of strings.")
+        endif
+        dims{nv} = size (varargin{nv});
+        numstrs(nv) = numel (varargin{nv});
+      endfor
 
-    if (iscellstr (varargin))
-      ## All arguments are character strings.
-      unwind_protect
-	tmp = warning ("query", "Octave:empty-list-elements");
-	warning ("off", "Octave:empty-list-elements");
-	st = [varargin{:}];
-      unwind_protect_cleanup
-	warning (tmp.state, "Octave:empty-list-elements");
-      end_unwind_protect
-    else
-      for i = 1:nargin
-	tmp = varargin{i};
-	if (! (iscellstr (tmp) || ischar (tmp)))
-	  error ("strcat: all arguments must be strings or cell arrays of strings");
-	endif
+      ## Set all cells to a common size
+      n = find (numstrs == max (numstrs), 1);
+      maxstrs = numstrs (n);
+      dim = dims{n};
+      for nv = find (numstrs == 1)
+        str = varargin{nv}{1};
+        varargin{nv} = cell (dim);
+        varargin{nv}{:} = str;
       endfor
-      st = strcat_cell (varargin);
+
+      ## Concatenate the strings
+      st = varargin{1};
+      for ns = 1:maxstrs
+        for nv = 2:nargin
+          if (size_equal (st, varargin{nv}))
+            st{ns} = [st{ns}, varargin{nv}{ns}];
+          else
+            error ("strcat: arguments must be the same size, or be scalars.");
+          endif
+        endfor
+      endfor
+
+      if (allchar)
+        ## If all inputs were strings, return strings.
+        st = char (st);
+      endif
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
-function st = strcat_cell (varargin)
-  ## All args must be same size or scalars.
-  ## See the xtest below for expected behavior.
-  error ("strcat: concatenating cell arrays of strings not implemented");
-endfunction
-
 ## test the dimensionality
 ## 1d
-%!assert(strcat("ab ", "ab "), "ab ab ")
+%!assert(strcat("ab ", "ab "), "abab")
+%!assert(strcat({"ab "}, "ab "), {"ab ab"})
+%!assert(strcat("ab ", {"ab "}), {"abab "})
+%!assert(strcat({"ab "}, {"ab "}), {"ab ab "})
 ## 2d
-%!assert(strcat(["ab ";"cde"], ["ab ";"cde"]), ["ab ab ";"cdecde"])
+%!assert(strcat(["ab ";"cde"], ["ab ";"cde"]), ["abab  ";"cdecde"])
 
-%!assert((strcmp (strcat ("foo", "bar"), "foobar")
-%! && strcmp (strcat (["a"; "bb"], ["foo"; "bar"]), ["a foo"; "bbbar"])));
+## test for deblanking implied trailing spaces of character input
+%!assert((strcmp (strcat ("foo", "bar"), "foobar") &&
+%!        strcmp (strcat (["a"; "bb"], ["foo"; "bar"]), ["afoo "; "bbbar"])));
+
+## test for mixing character and cell inputs
+%!assert(all (strcmp (strcat ("a", {"bc", "de"}, "f"), {"abcf", "adef"})))
 
-%!xtest
-%! assert(all (strcmp (strcat ("a", {"bc", "de"}, "f"), {"abcf", "adef"})))
+## test for scalar strings with vector strings
+%!assert(all (strcmp (strcat (["a"; "b"], "c"), ["ac"; "bc"])))
+
+## test with cells with strings of differing lengths
+%!assert(all (strcmp (strcat ({"a", "bb"}, "ccc"), {"accc", "bbccc"})))
+%!assert(all (strcmp (strcat ("a", {"bb", "ccc"}), {"abb", "accc"})))
 
 %!error strcat ();
 
 %!error strcat (1, 2);
 
diff --git a/scripts/strings/strvcat.m b/scripts/strings/strvcat.m
--- a/scripts/strings/strvcat.m
+++ b/scripts/strings/strvcat.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strvcat (@var{s_1}, @dots{}, @var{s_n})
 ## Return a matrix containing the strings (and cell-strings) 
 ## @var{s_1}, @dots{}, @var{s_n} as
 ## its rows.  Each string is padded with blanks in order to form a valid
 ## matrix.  Unlike @var{str2mat}, empty strings are ignored.
-## @seealso{strcat, str2mat}
+## @seealso{cstrcat, str2mat}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
 ## Modified: Paul Kienzle <pkienzle@kienzle.powernet.co.uk> converted
 ##           str2mat to strvcat.  Same function except that strvcat
 ##           ignores empty strings.
 ## Modified by Alois Schloegl <a.schloegl@ieee.org> Mar 2005
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -61,19 +61,19 @@ function assert (cond, expected, tol)
   endif
 
   if (exist ("argn") == 0)
     argn = " ";
   endif
 
   in = deblank (argn(1,:));
   for i = 2:rows (argn)
-    in = strcat (in, ",", deblank (argn(i,:)));
+    in = cstrcat (in, ",", deblank (argn(i,:)));
   endfor
-  in = strcat ("(", in, ")");
+  in = cstrcat ("(", in, ")");
 
   coda = "";
   iserror = 0;
   if (nargin == 1)
     if (! isnumeric (cond) || ! all (cond(:)))
       error ("assert %s failed", in); # say which elements failed?
     endif
   
@@ -135,17 +135,17 @@ function assert (cond, expected, tol)
 
   elseif (ndims (cond) != ndims (expected)
 	  || any (size (cond) != size (expected)))
     iserror = 1;
     coda = "Dimensions don't match";
 
   elseif (tol == 0 && ! strcmp (typeinfo (cond), typeinfo (expected)))
     iserror = 1;
-    coda = strcat ("Type ", typeinfo (cond), " != ", typeinfo (expected));
+    coda = cstrcat ("Type ", typeinfo (cond), " != ", typeinfo (expected));
 
   else # numeric
     A = cond(:);
     B = expected(:);
     ## Check exceptional values
     if (any (isna (A) != isna (B)))
       iserror = 1;
       coda = "NAs don't match";
@@ -193,19 +193,19 @@ function assert (cond, expected, tol)
   if (! isempty (idx))
     str = str(idx(1):idx(end));
   endif
   str2 = disp (cond);
   idx = find (str2 != "\n");
   if (! isempty (idx))
     str2 = str2 (idx(1):idx(end));
   endif
-  msg = strcat ("assert ", in, " expected\n", str, "\nbut got\n", str2);
+  msg = cstrcat ("assert ", in, " expected\n", str, "\nbut got\n", str2);
   if (! isempty (coda))
-    msg = strcat (msg, "\n", coda);
+    msg = cstrcat (msg, "\n", coda);
   endif
   error ("%s", msg);
   ## disp (msg);
   ## error ("assertion failed");
 endfunction
 
 ## empty
 %!assert([])
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -106,17 +106,17 @@ function demo (name, n)
     if (i > 1)
       input ("Press <enter> to continue: ", "s");
     endif
 
     ## Process each demo without failing
     try
       block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
       ## Use an environment without variables
-      eval (strcat ("function __demo__()\n", block, "\nendfunction"));
+      eval (cstrcat ("function __demo__()\n", block, "\nendfunction"));
       ## Display the code that will be executed before executing it
       printf ("%s example %d:%s\n\n", name, doidx(i), block);
       __demo__;
     catch
       ## Let the programmer know which demo failed.
       printf ("%s example %d: failed\n%s", name, doidx(i), __error_text__);
     end_try_catch
     clear __demo__;
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -182,48 +182,48 @@ function [__order, __test_n, __tnew, __t
   else
     __test_n = __max_n;
   endif
   __test_n = unique (round (__test_n)); # Force n to be an integer
   assert (__test_n >= 1);
 
   __torig = __tnew = zeros (size (__test_n));
 
-  disp (strcat ("testing ", __f1, "\ninit: ", __init));
+  disp (cstrcat ("testing ", __f1, "\ninit: ", __init));
 
   ## make sure the functions are freshly loaded by evaluating them at
   ## test_n(1); first have to initialize the args though.
   n = 1;
   k = 0;
-  eval (strcat (__init, ";"));
+  eval (cstrcat (__init, ";"));
   if (! isempty (__f2))
-    eval (strcat (__f2, ";"));
+    eval (cstrcat (__f2, ";"));
   endif
-  eval (strcat (__f1, ";"));
+  eval (cstrcat (__f1, ";"));
 
   ## run the tests
   for k = 1:length (__test_n)
     n = __test_n(k);
-    eval (strcat (__init, ";"));
+    eval (cstrcat (__init, ";"));
     
     printf ("n%i=%i  ",k, n);
     fflush (stdout);
-    eval (strcat ("__t=time();", __f1, "; __v1=ans; __t = time()-__t;"));
+    eval (cstrcat ("__t=time();", __f1, "; __v1=ans; __t = time()-__t;"));
     if (__t < 0.25)
-      eval (strcat ("__t2=time();", __f1, "; __t2 = time()-__t2;"));
-      eval (strcat ("__t3=time();", __f1, "; __t3 = time()-__t3;"));
+      eval (cstrcat ("__t2=time();", __f1, "; __t2 = time()-__t2;"));
+      eval (cstrcat ("__t3=time();", __f1, "; __t3 = time()-__t3;"));
       __t = min ([__t, __t2, __t3]);
     endif
     __tnew(k) = __t;
 
     if (! isempty (__f2))
-      eval (strcat ("__t=time();", __f2, "; __v2=ans; __t = time()-__t;"));
+      eval (cstrcat ("__t=time();", __f2, "; __v2=ans; __t = time()-__t;"));
       if (__t < 0.25)
-      	eval (strcat ("__t2=time();", __f2, "; __t2 = time()-__t2;"));
-      	eval (strcat ("__t3=time();", __f2, "; __t3 = time()-__t3;"));
+      	eval (cstrcat ("__t2=time();", __f2, "; __t2 = time()-__t2;"));
+      	eval (cstrcat ("__t3=time();", __f2, "; __t3 = time()-__t3;"));
       endif
       __torig(k) = __t;
       if (! isinf(__tol))
       	assert (__v1, __v2, __tol);
       endif
     endif
   endfor
   
@@ -252,45 +252,45 @@ function [__order, __test_n, __tnew, __t
   
   if (doplot)
     figure;
   endif
 
   if (doplot && ! isempty (__f2))
     subplot (1, 2, 1);
     semilogx (__test_n, __torig./__tnew, 
-	      strcat ("-*r;", strrep (__f1, ";", "."), "/",
+	      cstrcat ("-*r;", strrep (__f1, ";", "."), "/",
 		      strrep (__f2, ";", "."), ";"),
 	       __test_n, __tnew./__torig,
-	      strcat ("-*g;", strrep (__f2, ";", "."), "/",
+	      cstrcat ("-*g;", strrep (__f2, ";", "."), "/",
 		      strrep (__f1, ";", "."), ";"));
     xlabel ("test length");
     title (__f1);
     ylabel ("speedup ratio");
 
     subplot (1, 2, 2);
     loglog (__test_n, __tnew*1000,
-	    strcat ("*-g;", strrep (__f1, ";", "."), ";" ), 
+	    cstrcat ("*-g;", strrep (__f1, ";", "."), ";" ), 
 	    __test_n, __torig*1000,
-	    strcat ("*-r;", strrep (__f2,";","."), ";"));
+	    cstrcat ("*-r;", strrep (__f2,";","."), ";"));
   
     xlabel ("test length");
     ylabel ("best execution time (ms)");
-    title (strcat ("init: ", __init));
+    title (cstrcat ("init: ", __init));
 
     ratio = mean (__torig ./ __tnew);
     printf ("\n\nMean runtime ratio = %.3g for '%s' vs '%s'\n",
             ratio, __f2, __f1);
 
   elseif (doplot)
 
     loglog (__test_n, __tnew*1000, "*-g;execution time;");
     xlabel ("test length");
     ylabel ("best execution time (ms)");
-    title (strcat (__f1, "  init: ", __init));
+    title (cstrcat (__f1, "  init: ", __init));
 
   endif
 
   if (doplot)
 
     ## Plot time complexity approximation (using milliseconds).
     order = sprintf ("O(n^%g)", round (10*p(1))/10);
     v = polyval (p, log (__test_n(tailidx)));
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -152,20 +152,20 @@ function [__ret1, __ret2, __ret3, __ret4
     return;
   else
     error ("test unknown flag '%s'", __flag);
   endif
 
   ## locate the file to test
   __file = file_in_loadpath (__name, "all");
   if (isempty (__file))
-    __file = file_in_loadpath (strcat (__name, ".m"), "all");
+    __file = file_in_loadpath (cstrcat (__name, ".m"), "all");
   endif
   if (isempty (__file))
-    __file = file_in_loadpath (strcat (__name, ".cc"), "all");
+    __file = file_in_loadpath (cstrcat (__name, ".cc"), "all");
   endif
   if (iscell (__file))
       ## If repeats, return first in path.
     if (isempty (__file))
       __file = "";
     else
       __file = __file{1};
     endif
@@ -215,17 +215,17 @@ function [__ret1, __ret2, __ret3, __ret4
   endif
 
   ## chop it up into blocks for evaluation
   __lineidx = find (__body == "\n");
   __blockidx = __lineidx(find (! isspace (__body(__lineidx+1))))+1;
 
   ## ready to start tests ... if in batch mode, tell us what is happening
   if (__verbose)
-    disp (strcat ( __signal_file, __file));
+    disp (cstrcat ( __signal_file, __file));
   endif
 
   ## assume all tests will pass
   __all_success = 1;
 
   ## process each block separately, initially with no shared variables
   __tests = __successes = 0;
   __shared = " ";
@@ -265,17 +265,17 @@ function [__ret1, __ret2, __ret3, __ret4
     if (__grabdemo || __isdemo)
       __istest = 0;
 
       if (__grabdemo && __isdemo)
 	if (isempty(__demo_code))
 	  __demo_code = __code;
 	  __demo_idx = [1, length(__demo_code)+1];
 	else
-	  __demo_code = strcat(__demo_code, __code);
+	  __demo_code = cstrcat(__demo_code, __code);
 	  __demo_idx = [__demo_idx, length(__demo_code)+1];
 	endif
 
       elseif (__rundemo && __isdemo)
       	try
 	  ## process the code in an environment without variables
       	  eval (sprintf ("function __test__()\n%s\nendfunction", __code));
 	  __test__;
@@ -308,19 +308,19 @@ function [__ret1, __ret2, __ret3, __ret4
       if (! isempty (__idx))
 	__vars = __vars(1:__idx(1)-1);
       endif
       
       ## assign default values to variables
       try
 	__vars = deblank (__vars);
 	if (! isempty (__vars))
-	  eval (strcat (strrep (__vars, ",", "=[];"), "=[];"));
+	  eval (cstrcat (strrep (__vars, ",", "=[];"), "=[];"));
 	  __shared = __vars;
-	  __shared_r = strcat ("[ ", __vars, "] = ");
+	  __shared_r = cstrcat ("[ ", __vars, "] = ");
       	else
 	  __shared = " ";
 	  __shared_r = " ";
       	endif
       catch
 	__code = "";  # couldn't declare, so don't initialize
 	__success = 0;
 	__msg = sprintf ("%sshared variable initialization failed\n",
@@ -569,17 +569,17 @@ function [pattern, rest] = getpattern (s
       pattern = str(2:close-1);
       rest = str(close+1:end);
     endif
   endif
 endfunction
 
 ## strip '.*prefix:' from '.*prefix: msg\n' and strip trailing blanks
 function msg = trimerr (msg, prefix)
-  idx = index (msg, strcat (prefix, ":"));
+  idx = index (msg, cstrcat (prefix, ":"));
   if (idx > 0)
     msg(1:idx+length(prefix)) = [];
   endif
   msg = trimleft (deblank (msg));
 endfunction
 
 ## strip leading blanks from string
 function str = trimleft (str)
@@ -602,17 +602,17 @@ function body = __extract_test_code (nm)
   fid = fopen (nm, "rt");
   body = [];
   if (fid >= 0)
     while (! feof (fid))
       ln = fgetl (fid);
       if (length (ln) >= 2 && strcmp (ln(1:2), "%!"))
         body = [body, "\n"];
         if (length(ln) > 2)
-          body = strcat (body, ln(3:end));
+          body = cstrcat (body, ln(3:end));
         endif
       endif
     endwhile
     fclose (fid);
   endif
 endfunction
 
 ## Test for test for missing features
diff --git a/test/ChangeLog b/test/ChangeLog
--- a/test/ChangeLog
+++ b/test/ChangeLog
@@ -1,8 +1,13 @@
+2008-02-25  Ben Abbott <bpabbott@mac.com>
+
+	* test_eval-catch.m, test_io.m, test_try.m: Use cstrcat instead of
+	strcat.
+
 2008-02-22  David Bateman  <dbateman@free.fr>
 
 	* build_sparse_tests.sh: Replaced removed sparse functions like
 	spdiag with their generic names. Fix lu tests for modified
 	syntax. Test vector and scaling or LU and chol functions. 
 	* test_linalg.m: Change error message of failing chol/lu test.
 
 2008-02-19  David Bateman  <dbateman@free.fr>
diff --git a/test/test_eval-catch.m b/test/test_eval-catch.m
--- a/test/test_eval-catch.m
+++ b/test/test_eval-catch.m
@@ -44,17 +44,17 @@
 %!test
 %! eval ("error (\"user-defined error\"); str = '';", "str = lasterr;");
 %! assert(lasterr()(1:25),"error: user-defined error");
 %! assert(str(1:25),"error: user-defined error");
 
 %% test/octave.test/eval-catch/eval-catch-7.m
 %!function ms = mangle (s)
 %!  ## Wrap angle brackets around S.
-%!  ms = strcat ("<", s, ">");
+%!  ms = cstrcat ("<", s, ">");
 %!test
 %! eval ("clear a; a; str='';", "str = mangle (lasterr);");
 %! assert(mangle(lasterr)(1:21),"<error: `a' undefined");
 %! assert(str(1:21),"<error: `a' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-8.m
 %!test
 %! eval ("eval (\"clear a; a;str1='';\", \"str1=lasterr;\"); clear b; b; str2='';",
@@ -66,11 +66,11 @@
 %!test
 %! eval ("clear a; a; str1='';",
 %! "eval (\"clear b; b; str2='';\", \"str2=lasterr;\"); str1=lasterr;");
 %! assert(str1(1:20),"error: `b' undefined");
 %! assert(str2(1:20),"error: `b' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-10.m
 %!test
-%! eval ("eval (\"clear a; a; str='';\",\"error (strcat (\\\"rethrow: \\\", lasterr));str='';\");",
+%! eval ("eval (\"clear a; a; str='';\",\"error (cstrcat (\\\"rethrow: \\\", lasterr));str='';\");",
 %! "str=lasterr;");
 %! assert(str(1:36),"error: rethrow: error: `a' undefined");
diff --git a/test/test_io.m b/test/test_io.m
--- a/test/test_io.m
+++ b/test/test_io.m
@@ -279,26 +279,26 @@
 %!       [id, err] = fopen (nm, mode, arch);
 %!       if (id < 0)
 %!         printf_assert ("open failed: %s (%s, %s): %s\n", nm, mode, arch, err);
 %!         status = 0;
 %!         break;
 %!       else
 %!         fclose (id);
 %!       endif
-%!       tmp_mode = strcat (mode, "b");
+%!       tmp_mode = cstrcat (mode, "b");
 %!       [id, err] = fopen (nm, tmp_mode, arch);
 %!       if (id < 0)
 %!         printf_assert ("open failed: %s (%s, %s): %s\n", nm, tmp_mode, arch, err);
 %!         status = 0;
 %!         break;
 %!       else
 %!         fclose (id);
 %!       endif
-%!       tmp_mode = strcat (mode, "t");
+%!       tmp_mode = cstrcat (mode, "t");
 %!       [id, err] = fopen (nm, tmp_mode, arch);
 %!       if (id < 0)
 %!         printf_assert ("open failed: %s (%s, %s): %s\n", nm, tmp_mode, arch, err);
 %!         status = 0;
 %!         break;
 %!       else
 %!         fclose (id);
 %!       endif
diff --git a/test/test_try.m b/test/test_try.m
--- a/test/test_try.m
+++ b/test/test_try.m
@@ -75,17 +75,17 @@
 %!   error ("user-defined error")
 %! catch
 %!   assert(lasterr,"error: user-defined error\n");
 %! end_try_catch
 
 %% test/octave.test/try/try-7.m
 %!function ms = mangle (s)
 %!  ## Wrap angle brackets around S.
-%!  ms = strcat ("<", s, ">");
+%!  ms = cstrcat ("<", s, ">");
 %!test
 %! try
 %!   clear a
 %!   a;
 %!   error("Shoudn't get here");
 %! catch
 %!   assert(strcmp(mangle (lasterr)(1:21),"<error: `a' undefined"))
 %! end_try_catch
@@ -128,14 +128,14 @@
 %% test/octave.test/try/try-10.m
 %!test
 %! try
 %!   try
 %!     clear a
 %!     a;
 %!     error("Shoudn't get here");
 %!   catch
-%!     error(strcat("rethrow: ",lasterr));
+%!     error(cstrcat("rethrow: ",lasterr));
 %!   end_try_catch
 %! catch
 %!   assert(strcmp(lasterr()(1:36), "error: rethrow: error: `a' undefined"))
 %! end_try_catch
 
