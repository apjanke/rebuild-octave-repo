# HG changeset patch
# User Kai T. Ohlhus <k.ohlhus@gmail.com>
# Date 1461167590 -7200
#      Wed Apr 20 17:53:10 2016 +0200
# Node ID dcf8922b724b91579887abd62dfcc0392b02c159
# Parent  e3c44a120a8c987c877a3817457436e8a40533b3
Deprecate printf, puts, and scanf.  Make fputs a M-file.

* libinterp/corefcn/file-io.cc: extracted printf, puts, and scanf to M-files.
* scripts/deprecated/printf.m: new function, equivalent to version file-io.cc.
* scripts/deprecated/puts.m: new function, equivalent to version file-io.cc.
* scripts/deprecated/scanf.m: new function, equivalent to version file-io.cc.
* scripts/deprecated/module.mk: added printf, puts, and scanf.
* scripts/io/fputs.m: new function, equivalent to version file-io.cc.
* scripts/io/module.mk: added fputs.
* doc/interpreter/io.txi: adapted documentation to current implementation.
* NEWS: announced changes.

* doc/interpreter/basics.txi: replaced printf by fprintf.
* doc/interpreter/stmt.txi: replaced printf by fprintf.
* doc/interpreter/var.txi: replaced printf by fprintf.
* doc/refcard/refcard.tex: removed printf and scanf.
* examples/code/@FIRfilter/display.m: replaced printf by fprintf.
* examples/code/@polynomial/display.m: replaced printf by fprintf.
* scripts/@ftp/display.m: replaced printf by fprintf.
* scripts/general/inputParser.m: replaced printf by fprintf.
* scripts/general/methods.m: replaced printf by fprintf.
* scripts/general/profexplore.m: replaced printf by fprintf.
* scripts/general/profshow.m: replaced printf by fprintf.
* scripts/help/help.m: replaced puts by fputs and printf by fprintf.
* scripts/help/lookfor.m: replaced puts by fputs and printf by fprintf.
* scripts/help/which.m: replaced printf by fprintf.
* scripts/image/imformats.m: replaced printf by fprintf.
* scripts/io/beep.m: replaced puts by fputs.
* scripts/io/textread.m: replaced printf by fprintf.
* scripts/java/javaclasspath.m: replaced printf by fprintf.
* scripts/java/javamem.m: replaced printf by fprintf.
* scripts/miscellaneous/dir.m: replaced printf by fprintf.
* scripts/miscellaneous/dos.m: replaced printf by fprintf.
* scripts/miscellaneous/fact.m: replaced printf by fprintf.
* scripts/miscellaneous/info.m: replaced printf by fprintf.
* scripts/miscellaneous/license.m: replaced printf by fprintf.
* scripts/miscellaneous/ls.m: replaced puts by fputs.
* scripts/miscellaneous/menu.m: replaced printf by fprintf.
* scripts/miscellaneous/mkoctfile.m: replaced printf by fprintf.
* scripts/miscellaneous/private/display_info_file.m:
* scripts/miscellaneous/unix.m: replaced printf by fprintf.
* scripts/miscellaneous/ver.m: replaced printf by fprintf.
* scripts/miscellaneous/what.m: replaced printf by fprintf.
* scripts/ode/ode23.m: replaced printf by fprintf.
* scripts/ode/ode45.m: replaced printf by fprintf.
* scripts/optimization/fminbnd.m: replaced printf by fprintf.
* scripts/optimization/optimset.m: replaced puts by fputs and printf by fprintf.
* scripts/optimization/sqp.m: replaced printf by fprintf.
* scripts/pkg/pkg.m: replaced printf by fprintf.
* scripts/pkg/private/describe.m: replaced printf by fprintf.
* scripts/pkg/private/install.m: replaced printf by fprintf.
* scripts/pkg/private/installed_packages.m: replaced printf by fprintf.
* scripts/pkg/private/list_forge_packages.m: replaced puts by fputs and printf by fprintf.
* scripts/pkg/private/rebuild.m: replaced printf by fprintf.
* scripts/plot/util/__gnuplot_drawnow__.m: replaced puts by fputs and printf by fprintf.
* scripts/signal/stft.m: replaced printf by fprintf.
* scripts/sparse/bicg.m: replaced printf by fprintf.
* scripts/sparse/bicgstab.m: replaced printf by fprintf.
* scripts/sparse/cgs.m: replaced printf by fprintf.
* scripts/sparse/pcg.m: replaced printf by fprintf.
* scripts/sparse/pcr.m: replaced printf by fprintf.
* scripts/sparse/qmr.m: replaced printf by fprintf.
* scripts/statistics/models/logistic_regression.m: replaced printf by fprintf.
* scripts/statistics/tests/anova.m: replaced printf by fprintf.
* scripts/statistics/tests/bartlett_test.m: replaced printf by fprintf.
* scripts/statistics/tests/chisquare_test_homogeneity.m: replaced printf by fprintf.
* scripts/statistics/tests/chisquare_test_independence.m: replaced printf by fprintf.
* scripts/statistics/tests/cor_test.m: replaced printf by fprintf.
* scripts/statistics/tests/f_test_regression.m: replaced printf by fprintf.
* scripts/statistics/tests/hotelling_test.m: replaced printf by fprintf.
* scripts/statistics/tests/hotelling_test_2.m: replaced printf by fprintf.
* scripts/statistics/tests/kolmogorov_smirnov_test.m: replaced printf by fprintf.
* scripts/statistics/tests/kolmogorov_smirnov_test_2.m: replaced printf by fprintf.
* scripts/statistics/tests/kruskal_wallis_test.m: replaced printf by fprintf.
* scripts/statistics/tests/manova.m: replaced printf by fprintf.
* scripts/statistics/tests/mcnemar_test.m: replaced printf by fprintf.
* scripts/statistics/tests/prop_test_2.m: replaced printf by fprintf.
* scripts/statistics/tests/run_test.m: replaced printf by fprintf.
* scripts/statistics/tests/sign_test.m: replaced printf by fprintf.
* scripts/statistics/tests/t_test.m: replaced printf by fprintf.
* scripts/statistics/tests/t_test_2.m: replaced printf by fprintf.
* scripts/statistics/tests/t_test_regression.m: replaced printf by fprintf.
* scripts/statistics/tests/u_test.m: replaced printf by fprintf.
* scripts/statistics/tests/var_test.m: replaced printf by fprintf.
* scripts/statistics/tests/welch_test.m: replaced printf by fprintf.
* scripts/statistics/tests/wilcoxon_test.m: replaced printf by fprintf.
* scripts/statistics/tests/z_test.m: replaced printf by fprintf.
* scripts/statistics/tests/z_test_2.m: replaced printf by fprintf.
* scripts/strings/strtok.m: replaced printf by fprintf.
* scripts/testfun/__run_test_suite__.m: replaced puts by fputs and printf by fprintf.
* scripts/testfun/demo.m: replaced printf by fprintf.
* scripts/testfun/example.m: replaced printf by fprintf.
* scripts/testfun/private/compare_plot_demos.m: replaced printf by fprintf.
* scripts/testfun/rundemos.m: replaced printf by fprintf.
* scripts/testfun/runtests.m: replaced puts by fputs and printf by fprintf.
* scripts/testfun/speed.m: replaced printf by fprintf.
* scripts/testfun/test.m: replaced printf by fprintf.
* scripts/time/calendar.m: replaced puts by fputs and printf by fprintf.
* test/io.tst: replaced printf by fprintf.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -66,16 +66,20 @@ Summary of important user-visible change
     which may result in lower precision results than previous versions
     of Octave which used eps as the relative tolerance.  The quadl
     function has also been extended to return a second output with the
     total number of function evaluations.
 
  ** The textscan function is now built-in and is much faster and much
     more Matlab-compatible than the previous m-file version.
 
+ ** The fputs function now allows to ommit the file descriptor to
+    print the string to stdout and returns the number of bytes written
+    to the file descriptor or stdout, respectively.
+
  ** Dialog boxes, errordlg, helpdlg, inputdlg, errordlg, listdlg,
     msgbox, questdlg, and warndlg, now exclusively use QT.  Java based
     versions are removed.
 
  ** Other new functions added in 4.2:
 
       deg2rad
       evalc
@@ -95,16 +99,19 @@ Summary of important user-visible change
     release after 4.2):
 
       Function             | Replacement
       ---------------------|------------------
       bitmax               | flintmax
       mahalanobis          | mahal in Octave-Forge statistics pkg
       md5sum               | hash
       octve_config_info    | __octave_config_info__
+      printf               | fprintf
+      puts                 | fputs
+      scanf                | fscanf
       sleep                | pause
       usleep               | pause
       wavread              | audioread
       wavwrite             | audiowrite
 
  ** The following functions were deprecated in Octave 3.8 and have been
     removed from Octave 4.2.
 
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -305,22 +305,22 @@ options.
 
 @DOCSTRING(program_invocation_name)
 
 Here is an example of using these functions to reproduce the command
 line which invoked Octave.
 
 @example
 @group
-printf ("%s", program_name ());
+fprintf ("%s", program_name ());
 arg_list = argv ();
 for i = 1:nargin
-  printf (" %s", arg_list@{i@});
+  fprintf (" %s", arg_list@{i@});
 endfor
-printf ("\n");
+fprintf ("\n");
 @end group
 @end example
 
 @noindent
 @xref{Indexing Cell Arrays}, for an explanation of how to retrieve objects
 from cell arrays, and @ref{Defining Functions}, for information about the
 variable @code{nargin}.
 
@@ -1033,17 +1033,17 @@ For example, the following program will 
 was used to execute the script, not @samp{-qf}.
 
 @example
 @group
 #! /bin/octave -qf
 printf ("%s", program_name ());
 arg_list = argv ();
 for i = 1:nargin
-  printf (" %s", arg_list@{i@});
+  fprintf (" %s", arg_list@{i@});
 endfor
 printf ("\n");
 @end group
 @end example
 
 @node Comments
 @section Comments in Octave Programs
 @cindex comments
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -103,22 +103,22 @@ most important part of the definition, b
 should actually @emph{do}.
 
 For example, here is a function that, when executed, will ring the bell
 on your terminal (assuming that it is possible to do so):
 
 @example
 @group
 function wakeup
-  printf ("\a");
+  fprintf ("\a");
 endfunction
 @end group
 @end example
 
-The @code{printf} statement (@pxref{Input and Output}) simply tells
+The @code{fprintf} statement (@pxref{Input and Output}) simply tells
 Octave to print the string @qcode{"@xbackslashchar{}a"}.  The special character
 @samp{\a} stands for the alert character (ASCII 7).  @xref{Strings}.
 
 Once this function is defined, you can ask Octave to evaluate it by
 typing the name of the function.
 
 Normally, you will want to pass some information to the functions you
 define.  The syntax for passing parameters to a function in Octave is
@@ -138,31 +138,31 @@ hold the argument values given in the ca
 be empty, in which case this form is equivalent to the one shown above.
 
 To print a message along with ringing the bell, you might modify the
 @code{wakeup} to look like this:
 
 @example
 @group
 function wakeup (message)
-  printf ("\a%s\n", message);
+  fprintf ("\a%s\n", message);
 endfunction
 @end group
 @end example
 
 Calling this function using a statement like this
 
 @example
 wakeup ("Rise and shine!");
 @end example
 
 @noindent
 will cause Octave to ring your terminal's bell and print the message
 @samp{Rise and shine!}, followed by a newline character (the @samp{\n}
-in the first argument to the @code{printf} statement).
+in the first argument to the @code{fprintf} statement).
 
 In most cases, you will also want to get some information back from the
 functions you define.  Here is the syntax for writing a function that
 returns a single value:
 
 @example
 @group
 function @var{ret-var} = @var{name} (@var{arg-list})
@@ -483,17 +483,17 @@ a very simple solution to the problem.
 A slightly more complex example of @code{varargin} is a function
 @code{print_arguments} that prints all input arguments.  Such a function
 can be defined like this
 
 @example
 @group
 function print_arguments (varargin)
   for i = 1:length (varargin)
-    printf ("Input argument %d: ", i);
+    fprintf ("Input argument %d: ", i);
     disp (varargin@{i@});
   endfor
 endfunction
 @end group
 @end example
 
 @noindent
 This function produces output like this
@@ -615,17 +615,17 @@ vector are nonzero.
 function retval = any_nonzero (v)
   retval = 0;
   for i = 1:length (v)
     if (v (i) != 0)
       retval = 1;
       return;
     endif
   endfor
-  printf ("no nonzero elements found\n");
+  fprintf ("no nonzero elements found\n");
 endfunction
 @end group
 @end example
 
 Note that this function could not have been written using the
 @code{break} statement to exit the loop once a nonzero value is found
 without adding extra logic to avoid printing the message if the vector
 does contain a nonzero element.
@@ -659,17 +659,17 @@ If no value is assigned to @var{arg1} by
 value @var{val1}.
 
 As an example, the following function implements a variant of the classic
 ``Hello, World'' program.
 
 @example
 @group
 function hello (who = "World")
-  printf ("Hello, %s!\n", who);
+  fprintf ("Hello, %s!\n", who);
 endfunction
 @end group
 @end example
 
 @noindent
 When called without an input argument the function prints the following
 
 @example
@@ -820,25 +820,25 @@ After this the directory @samp{~/Octave}
 A function file may contain secondary functions called
 @dfn{subfunctions}.  These secondary functions are only visible to the
 other functions in the same function file.  For example, a file
 @file{f.m} containing
 
 @example
 @group
 function f ()
-  printf ("in f, calling g\n");
+  fprintf ("in f, calling g\n");
   g ()
 endfunction
 function g ()
-  printf ("in g, calling h\n");
+  fprintf ("in g, calling h\n");
   h ()
 endfunction
 function h ()
-  printf ("in h\n")
+  fprintf ("in h\n")
 endfunction
 @end group
 @end example
 
 @noindent
 defines a main function @code{f} and two subfunctions.  The
 subfunctions @code{g} and @code{h} may only be called from the main
 function @code{f} or from the other subfunctions, but not from outside
@@ -1091,18 +1091,18 @@ mislocked ("my_function")
 A common use of @code{mlock} is to prevent persistent variables from
 being removed from memory, as the following example shows:
 
 @example
 @group
 function count_calls ()
   mlock ();
   persistent calls = 0;
-  printf ("'count_calls' has been called %d times\n",
-          ++calls);
+  fprintf ("'count_calls' has been called %d times\n",
+           ++calls);
 endfunction
 
 count_calls ();
 @print{} 'count_calls' has been called 1 times
 
 clear count_calls
 count_calls ();
 @print{} 'count_calls' has been called 2 times
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -83,22 +83,21 @@ When running interactively, Octave norma
 for your terminal that is more than one screen long to a paging program,
 such as @code{less} or @code{more}.  This avoids the problem of having a
 large volume of output stream by before you can read it.  With
 @code{less} (and some versions of @code{more}) you can also scan forward
 and backward, and search for specific items.
 
 Normally, no output is displayed by the pager until just before Octave
 is ready to print the top level prompt, or read from the standard input
-(for example, by using the @code{fscanf} or @code{scanf} functions).
-This means that there may be some delay before any output appears on
-your screen if you have asked Octave to perform a significant amount of
-work with a single command statement.  The function @code{fflush} may be
-used to force output to be sent to the pager (or any other stream)
-immediately.
+(for example, by using the @code{fscanf} function).  This means that there
+may be some delay before any output appears on your screen if you have
+asked Octave to perform a significant amount of work with a single
+command statement.  The function @code{fflush} may be used to force output
+to be sent to the pager (or any other stream) immediately.
 
 You can select the program to run as the pager using the @env{PAGER}
 function, and you can turn paging off by using the function
 @code{more}.
 
 @DOCSTRING(more)
 
 @DOCSTRING(PAGER)
@@ -328,38 +327,22 @@ fclose (fid);
 
 @DOCSTRING(fclose)
 
 @DOCSTRING(is_valid_file_id)
 
 @node Simple Output
 @subsection Simple Output
 
-Once a file has been opened for writing a string can be written to the
-file using the @code{fputs} function.  The following example shows
-how to write the string @samp{Free Software is needed for Free Science}
-to the file @samp{free.txt}.
-
-@example
-@group
-filename = "free.txt";
-fid = fopen (filename, "w");
-fputs (fid, "Free Software is needed for Free Science");
-fclose (fid);
-@end group
-@end example
+The function @code{fputs} is the most simple way to write an unformatted
+string to either @code{stdout} or to a file, that has been opened for
+writing.
 
 @DOCSTRING(fputs)
 
-A function much similar to @code{fputs} is available for writing data
-to the screen.  The @code{puts} function works just like @code{fputs}
-except it doesn't take a file pointer as its input.
-
-@DOCSTRING(puts)
-
 @node Line-Oriented Input
 @subsection Line-Oriented Input
 
 To read from a file it must be opened for reading using @code{fopen}.
 Then a line can be read from the file using @code{fgetl} as the following
 code illustrates
 
 @example
@@ -379,50 +362,43 @@ the line @samp{Free Software is needed f
 
 @DOCSTRING(fgets)
 
 @DOCSTRING(fskipl)
 
 @node Formatted Output
 @subsection Formatted Output
 
-This section describes how to call @code{printf} and related functions.
-
-The following functions are available for formatted output.  They are
+This section describes how to call the @code{fprintf} and @code{sprintf}
+functions.  These functions are available for formatted output.  They are
 modeled after the C language functions of the same name, but they
 interpret the format template differently in order to improve the
 performance of printing vector and matrix values.
 
-Implementation Note: For compatibility with @sc{matlab}, escape sequences in
-the template string (e.g., @qcode{"@xbackslashchar{}n"} => newline) are
-expanded even when the template string is defined with single quotes.
-
-@DOCSTRING(printf)
-
 @DOCSTRING(fprintf)
 
 @DOCSTRING(sprintf)
 
-The @code{printf} function can be used to print any number of arguments.
-The template string argument you supply in a call provides
+@code{fprintf} and @code{sprintf} can be used to print any number of
+arguments.  The template string argument you supply in a call provides
 information not only about the number of additional arguments, but also
 about their types and what style should be used for printing them.
 
 Ordinary characters in the template string are simply written to the
 output stream as-is, while @dfn{conversion specifications} introduced by
 a @samp{%} character in the template cause subsequent arguments to be
 formatted and written to the output stream.  For example,
-@cindex conversion specifications (@code{printf})
+@cindex conversion specifications (@code{fprintf})
 
 @example
 @group
 pct = 37;
 filename = "foo.txt";
-printf ("Processed %d%% of '%s'.\nPlease be patient.\n",
-        pct, filename);
+fprintf ("Processed %d%% of '%s'.\nPlease be patient.\n",
+         pct, filename);
 @end group
 @end example
 
 @noindent
 produces output like
 
 @example
 @group
@@ -462,53 +438,52 @@ described in more detail in the followin
 @subsection Output Conversion for Matrices
 
 When given a matrix value, Octave's formatted output functions cycle
 through the format template until all the values in the matrix have been
 printed.  For example:
 
 @example
 @group
-printf ("%4.2f %10.2e %8.4g\n", hilb (3));
+fprintf ("%4.2f %10.2e %8.4g\n", hilb (3));
 
      @print{} 1.00   5.00e-01   0.3333
      @print{} 0.50   3.33e-01     0.25
      @print{} 0.33   2.50e-01      0.2
 @end group
 @end example
 
 If more than one value is to be printed in a single call, the output
 functions do not return to the beginning of the format template when
 moving on from one value to the next.  This can lead to confusing output
 if the number of elements in the matrices are not exact multiples of the
 number of conversions in the format template.  For example:
 
 @example
 @group
-printf ("%4.2f %10.2e %8.4g\n", [1, 2], [3, 4]);
+fprintf ("%4.2f %10.2e %8.4g\n", [1, 2], [3, 4]);
 
      @print{} 1.00   2.00e+00        3
      @print{} 4.00
 @end group
 @end example
 
 If this is not what you want, use a series of calls instead of just one.
 
 @node Output Conversion Syntax
 @subsection Output Conversion Syntax
 
 This section provides details about the precise syntax of conversion
-specifications that can appear in a @code{printf} template
-string.
+specifications that can appear in a @code{fprintf} or @code{sprintf}
+template string.
 
 Characters in the template string that are not part of a
 conversion specification are printed as-is to the output stream.
 
-The conversion specifications in a @code{printf} template string have
-the general form:
+The conversion specifications in a template string have the general form:
 
 @example
 % @var{flags} @var{width} @r{[} . @var{precision} @r{]} @var{type} @var{conversion}
 @end example
 
 For example, in the conversion specifier @samp{%-10.8ld}, the @samp{-}
 is a flag, @samp{10} specifies the field width, the precision is
 @samp{8}, the letter @samp{l} is a type modifier, and @samp{d} specifies
@@ -518,71 +493,71 @@ left-justified in a field at least 10 ch
 
 In more detail, output conversion specifications consist of an
 initial @samp{%} character followed in sequence by:
 
 @itemize @bullet
 @item
 Zero or more @dfn{flag characters} that modify the normal behavior of
 the conversion specification.
-@cindex flag character (@code{printf})
+@cindex flag character (@code{fprintf})
 
 @item
 An optional decimal integer specifying the @dfn{minimum field width}.
 If the normal conversion produces fewer characters than this, the field
 is padded with spaces to the specified width.  This is a @emph{minimum}
 value; if the normal conversion produces more characters than this, the
 field is @emph{not} truncated.  Normally, the output is right-justified
 within the field.
-@cindex minimum field width (@code{printf})
+@cindex minimum field width (@code{fprintf})
 
 You can also specify a field width of @samp{*}.  This means that the
 next argument in the argument list (before the actual value to be
 printed) is used as the field width.  The value is rounded to the
 nearest integer.  If the value is negative, this means to set the
 @samp{-} flag (see below) and to use the absolute value as the field
 width.
 
 @item
 An optional @dfn{precision} to specify the number of digits to be
 written for the numeric conversions.  If the precision is specified, it
 consists of a period (@samp{.}) followed optionally by a decimal integer
 (which defaults to zero if omitted).
-@cindex precision (@code{printf})
+@cindex precision (@code{fprintf})
 
 You can also specify a precision of @samp{*}.  This means that the next
 argument in the argument list (before the actual value to be printed) is
 used as the precision.  The value must be an integer, and is ignored
 if it is negative.
 
 @item
 An optional @dfn{type modifier character}.  This character is ignored by
-Octave's @code{printf} function, but is recognized to provide
-compatibility with the C language @code{printf}.
+Octave's @code{fprintf} function, but is recognized to provide
+compatibility with the C language @code{fprintf}.
 
 @item
 A character that specifies the conversion to be applied.
 @end itemize
 
 The exact options that are permitted and how they are interpreted vary
 between the different conversion specifiers.  See the descriptions of the
 individual conversions for information about the particular options that
 they use.
 
 @node Table of Output Conversions
 @subsection Table of Output Conversions
-@cindex output conversions, for @code{printf}
+@cindex output conversions, for @code{fprintf}
 
 Here is a table summarizing what all the different conversions do:
 
 @table @asis
 @item @samp{%d}, @samp{%i}
 Print an integer as a signed decimal number.  @xref{Integer
 Conversions}, for details.  @samp{%d} and @samp{%i} are synonymous for
-output, but are different when used with @code{scanf} for input
+output, but are different when used with @code{fscanf} for input
 (@pxref{Table of Input Conversions}).
 
 @item @samp{%o}
 Print an integer as an unsigned octal number.  @xref{Integer
 Conversions}, for details.
 
 @item @samp{%u}
 Print an integer as an unsigned decimal number.  @xref{Integer
@@ -618,26 +593,25 @@ Print a string.  @xref{Other Output Conv
 Print a literal @samp{%} character.  @xref{Other Output Conversions}.
 @end table
 
 If the syntax of a conversion specification is invalid, unpredictable
 things will happen, so don't do this.  In particular, @sc{matlab} allows
 a bare percentage sign @samp{%} with no subsequent conversion character.
 Octave will emit an error and stop if it sees such code.  When the string
 variable to be processed cannot be guaranteed to be free of potential format
-codes it is better to use the two argument form of any of the @code{printf}
-functions and set the format string to @code{%s}.  Alternatively, for code
-which is not required to be backwards-compatible with @sc{matlab} the
-Octave function @code{puts} or @code{disp} can be used.
+codes it is better to use the two argument form of @code{fprintf} and
+@code{sprintf} and set the format string to @code{%s}.  Alternatively,
+the function @code{disp} can be used.
 
 @example
 @group
-printf (strvar);        # Unsafe if strvar contains format codes
-printf ("%s", strvar);  # Safe
-puts (strvar);          # Safe
+fprintf (strvar);        # Unsafe if strvar contains format codes
+fprintf ("%s", strvar);  # Safe
+disp (strvar);           # Safe
 @end group
 @end example
 
 If there aren't enough function arguments provided to supply values for all
 the conversion specifications in the template string, or if the arguments are
 not of the correct types, the results are unpredictable.  If you supply more
 arguments than conversion specifications, the extra argument values are
 simply ignored; this is sometimes useful.
@@ -758,149 +732,148 @@ the first digit before the decimal point
 If the precision is @code{0} or not specified for @samp{%g} or
 @samp{%G}, it is treated like a value of @code{1}.  If the value being
 printed cannot be expressed precisely in the specified number of digits,
 the value is rounded to the nearest number that fits.
 
 @node Other Output Conversions
 @subsection Other Output Conversions
 
-This section describes miscellaneous conversions for @code{printf}.
+This section describes miscellaneous conversions for @code{fprintf} and
+@code{sprintf}.
 
 The @samp{%c} conversion prints a single character.  The @samp{-}
 flag can be used to specify left-justification in the field, but no
 other flags are defined, and no precision or type modifier can be given.
 For example:
 
 @example
-printf ("%c%c%c%c%c", "h", "e", "l", "l", "o");
+fprintf ("%c%c%c%c%c", "h", "e", "l", "l", "o");
 @end example
 
 @noindent
 prints @samp{hello}.
 
 The @samp{%s} conversion prints a string.  The corresponding argument
 must be a string.  A precision can be specified to indicate the maximum
 number of characters to write; otherwise characters in the string up to
 but not including the terminating null character are written to the
 output stream.  The @samp{-} flag can be used to specify
 left-justification in the field, but no other flags or type modifiers
 are defined for this conversion.  For example:
 
 @example
-printf ("%3s%-6s", "no", "where");
+fprintf ("%3s%-6s", "no", "where");
 @end example
 
 @noindent
 prints @samp{ nowhere } (note the leading and trailing spaces).
 
 @node Formatted Input
 @subsection Formatted Input
 
-Octave provides the @code{scanf}, @code{fscanf}, and @code{sscanf}
-functions to read formatted input.  There are two forms of each of these
-functions.  One can be used to extract vectors of data from a file, and
-the other is more `C-like'.
+Octave provides the @code{fscanf} and @code{sscanf} functions to read
+formatted input.  There are two forms of each of these functions.  One
+can be used to extract vectors of data from a file, and the other is
+more `C-like'.
 
 @DOCSTRING(fscanf)
 
-@DOCSTRING(scanf)
-
 @DOCSTRING(sscanf)
 
-Calls to @code{scanf} are superficially similar to calls to
-@code{printf} in that arbitrary arguments are read under the control of
+Calls to @code{fscanf} are superficially similar to calls to
+@code{fprintf} in that arbitrary arguments are read under the control of
 a template string.  While the syntax of the conversion specifications in
-the template is very similar to that for @code{printf}, the
+the template is very similar to that for @code{fprintf}, the
 interpretation of the template is oriented more towards free-format
 input and simple pattern matching, rather than fixed-field formatting.
-For example, most @code{scanf} conversions skip over any amount of
+For example, most @code{fscanf} conversions skip over any amount of
 ``white space'' (including spaces, tabs, and newlines) in the input
 file, and there is no concept of precision for the numeric input
 conversions as there is for the corresponding output conversions.
 Ordinarily, non-whitespace characters in the template are expected to
 match characters in the input stream exactly.
-@cindex conversion specifications (@code{scanf})
+@cindex conversion specifications (@code{fscanf})
 
-When a @dfn{matching failure} occurs, @code{scanf} returns immediately,
+When a @dfn{matching failure} occurs, @code{fscanf} returns immediately,
 leaving the first non-matching character as the next character to be
-read from the stream, and @code{scanf} returns all the items that were
+read from the stream, and @code{fscanf} returns all the items that were
 successfully converted.
-@cindex matching failure, in @code{scanf}
+@cindex matching failure, in @code{fscanf}
 
 The formatted input functions are not used as frequently as the
 formatted output functions.  Partly, this is because it takes some care
 to use them properly.  Another reason is that it is difficult to recover
 from a matching error.
 
 @node Input Conversion Syntax
 @subsection Input Conversion Syntax
 
-A @code{scanf} template string is a string that contains ordinary
+A @code{fscanf} template string is a string that contains ordinary
 multibyte characters interspersed with conversion specifications that
 start with @samp{%}.
 
 Any whitespace character in the template causes any number of whitespace
 characters in the input stream to be read and discarded.  The whitespace
 characters that are matched need not be exactly the same whitespace
 characters that appear in the template string.  For example, write
 @samp{ , } in the template to recognize a comma with optional whitespace
 before and after.
 
 Other characters in the template string that are not part of conversion
 specifications must match characters in the input stream exactly; if
 this is not the case, a matching failure occurs.
 
-The conversion specifications in a @code{scanf} template string
+The conversion specifications in a @code{fscanf} template string
 have the general form:
 
 @example
 % @var{flags} @var{width} @var{type} @var{conversion}
 @end example
 
 In more detail, an input conversion specification consists of an initial
 @samp{%} character followed in sequence by:
 
 @itemize @bullet
 @item
 An optional @dfn{flag character} @samp{*}, which says to ignore the text
-read for this specification.  When @code{scanf} finds a conversion
+read for this specification.  When @code{fscanf} finds a conversion
 specification that uses this flag, it reads input as directed by the
 rest of the conversion specification, but it discards this input, does
 not return any value, and does not increment the count of
 successful assignments.
-@cindex flag character (@code{scanf})
+@cindex flag character (@code{fscanf})
 
 @item
 An optional decimal integer that specifies the @dfn{maximum field
 width}.  Reading of characters from the input stream stops either when
 this maximum is reached or when a non-matching character is found,
 whichever happens first.  Most conversions discard initial whitespace
 characters, and these discarded characters don't count towards the
 maximum field width.  Conversions that do not discard initial whitespace
 are explicitly documented.
-@cindex maximum field width (@code{scanf})
+@cindex maximum field width (@code{fscanf})
 
 @item
 An optional type modifier character.  This character is ignored by
-Octave's @code{scanf} function, but is recognized to provide
-compatibility with the C language @code{scanf}.
+Octave's @code{fscanf} function, but is recognized to provide
+compatibility with the C language @code{fscanf}.
 
 @item
 A character that specifies the conversion to be applied.
 @end itemize
 
 The exact options that are permitted and how they are interpreted vary
 between the different conversion specifiers.  See the descriptions of the
 individual conversions for information about the particular options that
 they allow.
 
 @node Table of Input Conversions
 @subsection Table of Input Conversions
-@cindex input conversions, for @code{scanf}
+@cindex input conversions, for @code{fscanf}
 
 Here is a table that summarizes the various conversion specifications:
 
 @table @asis
 @item @samp{%d}
 Matches an optionally signed integer written in decimal.  @xref{Numeric
 Input Conversions}.
 
@@ -944,17 +917,17 @@ undefined.  If there aren't enough funct
 addresses for all the conversion specifications in the template strings
 that perform assignments, or if the arguments are not of the correct
 types, the behavior is also undefined.  On the other hand, extra
 arguments are simply ignored.
 
 @node Numeric Input Conversions
 @subsection Numeric Input Conversions
 
-This section describes the @code{scanf} conversions for reading numeric
+This section describes the @code{fscanf} conversions for reading numeric
 values.
 
 The @samp{%d} conversion matches an optionally signed integer in decimal
 radix.
 
 The @samp{%i} conversion matches an optionally signed integer in any of
 the formats that the C language defines for specifying an integer
 constant.
@@ -964,23 +937,23 @@ could be read in as integers under the @
 these specifies a number with decimal value @code{10}.
 
 The @samp{%o}, @samp{%u}, and @samp{%x} conversions match unsigned
 integers in octal, decimal, and hexadecimal radices, respectively.
 
 The @samp{%X} conversion is identical to the @samp{%x} conversion.  They
 both permit either uppercase or lowercase letters to be used as digits.
 
-Unlike the C language @code{scanf}, Octave ignores the @samp{h},
+Unlike the C language @code{fscanf}, Octave ignores the @samp{h},
 @samp{l}, and @samp{L} modifiers.
 
 @node String Input Conversions
 @subsection String Input Conversions
 
-This section describes the @code{scanf} input conversions for reading
+This section describes the @code{fscanf} input conversions for reading
 string and character values: @samp{%s} and @samp{%c}.
 
 The @samp{%c} conversion is the simplest: it matches a fixed number of
 characters, always.  The maximum field with says how many characters to
 read; if you don't specify the maximum, the default is 1.  This
 conversion does not skip over initial whitespace characters.  It reads
 precisely the next @var{n} characters, and fails if it cannot get that
 many.
@@ -1086,9 +1059,8 @@ four characters, and then returns to the
 @example
 @group
 marker = ftell (myfile);
 frewind (myfile);
 fourch = fgets (myfile, 4);
 fseek (myfile, marker, SEEK_SET);
 @end group
 @end example
-
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -110,26 +110,26 @@ endif
 If @var{condition} is true, @var{then-body} is executed; otherwise,
 @var{else-body} is executed.
 
 Here is an example:
 
 @example
 @group
 if (rem (x, 2) == 0)
-  printf ("x is even\n");
+  fprintf ("x is even\n");
 else
-  printf ("x is odd\n");
+  fprintf ("x is odd\n");
 endif
 @end group
 @end example
 
 In this example, if the expression @code{rem (x, 2) == 0} is true (that
 is, the value of @code{x} is divisible by 2), then the first
-@code{printf} statement is evaluated, otherwise the second @code{printf}
+@code{fprintf} statement is evaluated, otherwise the second @code{fprintf}
 statement is evaluated.
 
 The third and most general form of the @code{if} statement allows
 multiple decisions to be combined in a single statement.  It looks like
 this:
 
 @example
 @group
@@ -147,30 +147,30 @@ endif
 Any number of @code{elseif} clauses may appear.  Each condition is
 tested in turn, and if one is found to be true, its corresponding
 @var{body} is executed.  If none of the conditions are true and the
 @code{else} clause is present, its body is executed.  Only one
 @code{else} clause may appear, and it must be the last part of the
 statement.
 
 In the following example, if the first condition is true (that is, the
-value of @code{x} is divisible by 2), then the first @code{printf}
+value of @code{x} is divisible by 2), then the first @code{fprintf}
 statement is executed.  If it is false, then the second condition is
 tested, and if it is true (that is, the value of @code{x} is divisible
-by 3), then the second @code{printf} statement is executed.  Otherwise,
-the third @code{printf} statement is performed.
+by 3), then the second @code{fprintf} statement is executed.  Otherwise,
+the third @code{fprintf} statement is performed.
 
 @example
 @group
 if (rem (x, 2) == 0)
-  printf ("x is even\n");
+  fprintf ("x is even\n");
 elseif (rem (x, 3) == 0)
-  printf ("x is odd and divisible by 3\n");
+  fprintf ("x is odd and divisible by 3\n");
 else
-  printf ("x is odd\n");
+  fprintf ("x is odd\n");
 endif
 @end group
 @end example
 
 Note that the @code{elseif} keyword must not be spelled @code{else if},
 as is allowed in Fortran.  If it is, the space between the @code{else}
 and @code{if} will tell Octave to treat this as a new @code{if}
 statement within another @code{if} statement's @code{else} clause.  For
@@ -291,19 +291,19 @@ is executed if @emph{any} of the element
 @var{expression}.  As an example, the following program will print
 @samp{Variable is either 6 or 7}.
 
 @example
 @group
 A = 7;
 switch (A)
   case @{ 6, 7 @}
-    printf ("variable is either 6 or 7\n");
+    fprintf ("variable is either 6 or 7\n");
   otherwise
-    printf ("variable is neither 6 nor 7\n");
+    fprintf ("variable is neither 6 nor 7\n");
 endswitch
 @end group
 @end example
 
 As with all other specific @code{end} keywords, @code{endswitch} may be
 replaced by @code{end}, but you can get better diagnostics if you use
 the specific forms.
 
@@ -679,19 +679,19 @@ num = 103;
 div = 2;
 while (div*div <= num)
   if (rem (num, div) == 0)
     break;
   endif
   div++;
 endwhile
 if (rem (num, div) == 0)
-  printf ("Smallest divisor of %d is %d\n", num, div)
+  fprintf ("Smallest divisor of %d is %d\n", num, div)
 else
-  printf ("%d is prime\n", num);
+  fprintf ("%d is prime\n", num);
 endif
 @end group
 @end example
 
 When the remainder is zero in the first @code{while} statement, Octave
 immediately @dfn{breaks out} of the loop.  This means that Octave
 proceeds immediately to the statement following the loop and continues
 processing.  (This is very different from the @code{exit} statement
@@ -702,22 +702,22 @@ how the @var{condition} of a @code{while
 be replaced with a @code{break} inside an @code{if}:
 
 @example
 @group
 num = 103;
 div = 2;
 while (1)
   if (rem (num, div) == 0)
-    printf ("Smallest divisor of %d is %d\n", num, div);
+    fprintf ("Smallest divisor of %d is %d\n", num, div);
     break;
   endif
   div++;
   if (div*div > num)
-    printf ("%d is prime\n", num);
+    fprintf ("%d is prime\n", num);
     break;
   endif
 endwhile
 @end group
 @end example
 
 @node The continue Statement
 @section The continue Statement
@@ -741,34 +741,34 @@ Here is an example:
 vec = round (rand (1, 10) * 100);
 
 # print what we're interested in:
 
 for x = vec
   if (rem (x, 2) != 0)
     continue;
   endif
-  printf ("%d\n", x);
+  fprintf ("%d\n", x);
 endfor
 @end group
 @end example
 
 If one of the elements of @var{vec} is an odd number, this example skips
 the print statement for that element, and continues back to the first
 statement in the loop.
 
 This is not a practical example of the @code{continue} statement, but it
 should give you a clear understanding of how it works.  Normally, one
 would probably write the loop like this:
 
 @example
 @group
 for x = vec
   if (rem (x, 2) == 0)
-    printf ("%d\n", x);
+    fprintf ("%d\n", x);
   endif
 endfor
 @end group
 @end example
 
 @node The unwind_protect Statement
 @section The unwind_protect Statement
 @cindex @code{unwind_protect} statement
diff --git a/doc/interpreter/var.txi b/doc/interpreter/var.txi
--- a/doc/interpreter/var.txi
+++ b/doc/interpreter/var.txi
@@ -188,18 +188,18 @@ particular function and are not visible 
 
 The following example uses a persistent variable to create a function
 that prints the number of times it has been called.
 
 @example
 @group
 function count_calls ()
   persistent calls = 0;
-  printf ("'count_calls' has been called %d times\n",
-          ++calls);
+  fprintf ("'count_calls' has been called %d times\n",
+           ++calls);
 endfunction
 
 for i = 1:3
   count_calls ();
 endfor
 
 @print{} 'count_calls' has been called 1 times
 @print{} 'count_calls' has been called 2 times
@@ -243,18 +243,18 @@ following example illustrates.
 
 @example
 @group
 function count_calls ()
   persistent calls;
   if (isempty (calls))
     calls = 0;
   endif
-  printf ("'count_calls' has been called %d times\n",
-          ++calls);
+  fprintf ("'count_calls' has been called %d times\n",
+           ++calls);
 endfunction
 @end group
 @end example
 
 @noindent
 This implementation behaves in exactly the same way as the previous
 implementation of @code{count_calls}.
 
diff --git a/doc/refcard/refcard.tex b/doc/refcard/refcard.tex
--- a/doc/refcard/refcard.tex
+++ b/doc/refcard/refcard.tex
@@ -872,20 +872,18 @@ ind2gray ({\it img}, {\it map})&convert 
 ind2rgb ({\it img}, {\it map})&convert indexed image to RGB\cr
 rgb2ind ({\it r}, {\it g}, {\it b})&convert RGB to Octave image\cr
 save a matrix to {\it file}\span\cr
 \endsec
 
 \altsec C-style Input and Output;
 fopen ({\it name}, {\it mode})&open file {\it name}\cr
 fclose ({\it file})&close {\it file}\cr
-printf ({\it fmt}, ...)&formatted output to {\tt stdout}\cr
 fprintf ({\it file}, {\it fmt}, ...)&formatted output to {\it file}\cr
 sprintf ({\it fmt}, ...)&formatted output to string\cr
-scanf ({\it fmt})&formatted input from {\tt stdin}\cr
 fscanf ({\it file}, {\it fmt})&formatted input from {\it file}\cr
 sscanf ({\it str}, {\it fmt})&formatted input from {\it string}\cr
 fgets ({\it file}, {\it len})&read {\it len\/} characters from {\it file\/}\cr
 fflush ({\it file})&flush pending output to {\it file}\cr
 ftell ({\it file})&return file pointer position\cr
 frewind ({\it file})&move file pointer to beginning\cr
 freport&print a info for open files\cr
 fread ({\it file}, {\it size}, {\it prec})&read binary data files\cr
diff --git a/examples/code/@FIRfilter/display.m b/examples/code/@FIRfilter/display.m
--- a/examples/code/@FIRfilter/display.m
+++ b/examples/code/@FIRfilter/display.m
@@ -1,4 +1,4 @@
 function display (f)
-  printf ("%s.polynomial", inputname (1));
+  fprintf ("%s.polynomial", inputname (1));
   display (f.polynomial);
 endfunction
diff --git a/examples/code/@polynomial/display.m b/examples/code/@polynomial/display.m
--- a/examples/code/@polynomial/display.m
+++ b/examples/code/@polynomial/display.m
@@ -1,36 +1,36 @@
 function display (p)
 
-  printf ("%s =", inputname (1));
+  fprintf ("%s =", inputname (1));
 
   a = p.poly;
   first = true;
   for i = 1 : length (a);
     if (a(i) != 0)
       if (first)
         first = false;
       elseif (a(i) > 0 || isnan (a(i)))
-        printf (" +");
+        fprintf (" +");
       endif
       if (a(i) < 0)
-        printf (" -");
+        fprintf (" -");
       endif
       if (i == 1)
-        printf (" %.5g", abs (a(i)));
+        fprintf (" %.5g", abs (a(i)));
       elseif (abs (a(i)) != 1)
-        printf (" %.5g *", abs (a(i)));
+        fprintf (" %.5g *", abs (a(i)));
       endif
       if (i > 1)
-        printf (" X");
+        fprintf (" X");
       endif
       if (i > 2)
-        printf (" ^ %d", i - 1);
+        fprintf (" ^ %d", i - 1);
       endif
     endif
   endfor
 
   if (first)
-    printf (" 0");
+    fprintf (" 0");
   endif
-  printf ("\n");
+  fprintf ("\n");
 
 endfunction
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -775,17 +775,17 @@ written to the file descriptor @var{fid}
 If @var{fid} is omitted, the output is written to @code{stdout} making the\n\
 function exactly equivalent to @code{printf}.\n\
 \n\
 The optional output returns the number of bytes written to the file.\n\
 \n\
 Implementation Note: For compatibility with @sc{matlab}, escape sequences in\n\
 the template string (e.g., @qcode{\"@xbackslashchar{}n\"} => newline) are\n\
 expanded even when the template string is defined with single quotes.\n\
-@seealso{fputs, fdisp, fwrite, fscanf, printf, sprintf, fopen}\n\
+@seealso{fputs, fdisp, fwrite, fscanf, sprintf, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fprintf";
 
   int nargin = args.length ();
 
   if (! (nargin > 1 || (nargin > 0 && args(0).is_string ())))
     print_usage ();
@@ -819,123 +819,30 @@ expanded even when the template string i
   result = os.printf (args(fmt_n), tmp_args, who);
 
   if (nargout > 0)
     return ovl (result);
   else
     return ovl ();
 }
 
-DEFUN (printf, args, nargout,
-       "-*- texinfo -*-\n\
-@deftypefn {} {} printf (@var{template}, @dots{})\n\
-Print optional arguments under the control of the template string\n\
-@var{template} to the stream @code{stdout} and return the number of\n\
-characters printed.\n\
-@ifclear OCTAVE_MANUAL\n\
-\n\
-See the Formatted Output section of the GNU Octave manual for a\n\
-complete description of the syntax of the template string.\n\
-@end ifclear\n\
-\n\
-Implementation Note: For compatibility with @sc{matlab}, escape sequences in\n\
-the template string (e.g., @qcode{\"@xbackslashchar{}n\"} => newline) are\n\
-expanded even when the template string is defined with single quotes.\n\
-@seealso{fprintf, sprintf, scanf}\n\
-@end deftypefn")
-{
-  static std::string who = "printf";
-
-  int nargin = args.length ();
-
-  if (nargin == 0)
-    print_usage ();
-
-  int result;
-
-  if (! args(0).is_string ())
-    error ("%s: format TEMPLATE must be a string", who.c_str ());
-
-  octave_value_list tmp_args;
-
-  if (nargin > 1)
-    {
-      tmp_args.resize (nargin-1, octave_value ());
-
-      for (int i = 1; i < nargin; i++)
-        tmp_args(i-1) = args(i);
-    }
-
-  result = stdout_stream.printf (args(0), tmp_args, who);
-
-  if (nargout > 0)
-    return ovl (result);
-  else
-    return ovl ();
-}
-
-DEFUN (fputs, args, ,
-       "-*- texinfo -*-\n\
-@deftypefn  {} {} fputs (@var{fid}, @var{string})\n\
-@deftypefnx {} {@var{status} =} fputs (@var{fid}, @var{string})\n\
-Write the string @var{string} to the file with file descriptor @var{fid}.\n\
-\n\
-The string is written to the file with no additional formatting.  Use\n\
-@code{fdisp} instead to automatically append a newline character appropriate\n\
-for the local machine.\n\
-\n\
-Return a non-negative number on success or EOF on error.\n\
-@seealso{fdisp, fprintf, fwrite, fopen}\n\
-@end deftypefn")
-{
-  static std::string who = "fputs";
-
-  if (args.length () != 2)
-    print_usage ();
-
-  octave_stream os = octave_stream_list::lookup (args(0), who);
-
-  return ovl (os.puts (args(1), who));
-}
-
-DEFUN (puts, args, ,
-       "-*- texinfo -*-\n\
-@deftypefn  {} {} puts (@var{string})\n\
-@deftypefnx {} {@var{status} =} puts (@var{string})\n\
-Write a string to the standard output with no formatting.\n\
-\n\
-The string is written verbatim to the standard output.  Use @code{disp} to\n\
-automatically append a newline character appropriate for the local machine.\n\
-\n\
-Return a non-negative number on success and EOF on error.\n\
-@seealso{fputs, disp}\n\
-@end deftypefn")
-{
-  static std::string who = "puts";
-
-  if (args.length () != 1)
-    print_usage ();
-
-  return ovl (stdout_stream.puts (args(0), who));
-}
-
 DEFUN (sprintf, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} sprintf (@var{template}, @dots{})\n\
 This is like @code{printf}, except that the output is returned as a\n\
 string.\n\
 \n\
 Unlike the C library function, which requires you to provide a suitably\n\
 sized string as an argument, Octave's @code{sprintf} function returns the\n\
 string, automatically sized to hold all of the items converted.\n\
 \n\
 Implementation Note: For compatibility with @sc{matlab}, escape sequences in\n\
 the template string (e.g., @qcode{\"@xbackslashchar{}n\"} => newline) are\n\
 expanded even when the template string is defined with single quotes.\n\
-@seealso{printf, fprintf, sscanf}\n\
+@seealso{fprintf, sscanf}\n\
 @end deftypefn")
 {
   static std::string who = "sprintf";
 
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
@@ -1022,17 +929,17 @@ with each conversion specifier in @var{t
 single scalar return value.  This form is more ``C-like'', and also\n\
 compatible with previous versions of Octave.  The number of successful\n\
 conversions is returned in @var{count}\n\
 @ifclear OCTAVE_MANUAL\n\
 \n\
 See the Formatted Input section of the GNU Octave manual for a\n\
 complete description of the syntax of the template string.\n\
 @end ifclear\n\
-@seealso{fgets, fgetl, fread, scanf, sscanf, fopen}\n\
+@seealso{fgets, fgetl, fread, sscanf, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fscanf";
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
@@ -1085,17 +992,17 @@ DEFUN (sscanf, args, ,
 @deftypefn  {} {[@var{val}, @var{count}, @var{errmsg}, @var{pos}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
 @deftypefnx {} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} sscanf (@var{string}, @var{template}, \"C\")\n\
 This is like @code{fscanf}, except that the characters are taken from the\n\
 string @var{string} instead of from a stream.\n\
 \n\
 Reaching the end of the string is treated as an end-of-file condition.  In\n\
 addition to the values returned by @code{fscanf}, the index of the next\n\
 character to be read is returned in @var{pos}.\n\
-@seealso{fscanf, scanf, sprintf}\n\
+@seealso{fscanf, sprintf}\n\
 @end deftypefn")
 {
   static std::string who = "sscanf";
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
@@ -1133,37 +1040,16 @@ character to be read is returned in @var
 
       retval = ovl (tmp, count, errmsg,
                     (os.eof () ? data.length () : os.tell ()) + 1);
     }
 
   return retval;
 }
 
-DEFUN (scanf, args, nargout,
-       "-*- texinfo -*-\n\
-@deftypefn  {} {[@var{val}, @var{count}, @var{errmsg}] =} scanf (@var{template}, @var{size})\n\
-@deftypefnx {} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}]] =} scanf (@var{template}, \"C\")\n\
-This is equivalent to calling @code{fscanf} with @var{fid} = @code{stdin}.\n\
-\n\
-It is currently not useful to call @code{scanf} in interactive programs.\n\
-@seealso{fscanf, sscanf, printf}\n\
-@end deftypefn")
-{
-  int nargin = args.length ();
-
-  octave_value_list tmp_args (nargin+1, octave_value ());
-
-  tmp_args (0) = 0.0;
-  for (int i = 0; i < nargin; i++)
-    tmp_args(i+1) = args(i);
-
-  return Ffscanf (tmp_args, nargout);
-}
-
 static octave_value_list
 textscan_internal (const std::string& who, const octave_value_list& args)
 {
   if (args.length () < 1)
     print_usage (who);
 
   octave_stream os;
 
diff --git a/libinterp/dldfcn/__init_gnuplot__.cc b/libinterp/dldfcn/__init_gnuplot__.cc
--- a/libinterp/dldfcn/__init_gnuplot__.cc
+++ b/libinterp/dldfcn/__init_gnuplot__.cc
@@ -146,17 +146,17 @@ private:
 
   void send_quit (const octave_value& pstream) const
   {
     if (! pstream.is_empty ())
       {
         octave_value_list args;
         Matrix fids = pstream.matrix_value ();
 
-        Ffputs (ovl (fids(0), "\nquit;\n"));
+        Ffprintf (ovl (fids(0), "%s", "\nquit;\n"));
 
         Ffflush (ovl (fids(0)));
         Fpclose (ovl (fids(0)));
 
         if (fids.numel () > 1)
           {
             Fpclose (ovl (fids(1)));
 
diff --git a/scripts/@ftp/display.m b/scripts/@ftp/display.m
--- a/scripts/@ftp/display.m
+++ b/scripts/@ftp/display.m
@@ -12,19 +12,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 function display (obj)
-  printf ("FTP Object\n");
-  printf (" host: %s\n", obj.host);
-  printf (" user: %s\n", obj.username);
-  printf ("  dir: %s\n", __ftp_pwd__ (obj.curlhandle));
-  printf (" mode: %s\n", __ftp_mode__ (obj.curlhandle));
+  fprintf ("FTP Object\n");
+  fprintf (" host: %s\n", obj.host);
+  fprintf (" user: %s\n", obj.username);
+  fprintf ("  dir: %s\n", __ftp_pwd__ (obj.curlhandle));
+  fprintf (" mode: %s\n", __ftp_mode__ (obj.curlhandle));
 endfunction
 
 
 ## No test possible for interactive function.
 %!assert (1)
 
diff --git a/scripts/deprecated/module.mk b/scripts/deprecated/module.mk
--- a/scripts/deprecated/module.mk
+++ b/scripts/deprecated/module.mk
@@ -15,17 +15,20 @@ scripts_deprecated_FCN_FILES = \
   scripts/deprecated/luinc.m \
   scripts/deprecated/mahalanobis.m \
   scripts/deprecated/md5sum.m \
   scripts/deprecated/mouse_wheel_zoom.m \
   scripts/deprecated/nfields.m \
   scripts/deprecated/octave_config_info.m \
   scripts/deprecated/octave_tmp_file_name.m \
   scripts/deprecated/playaudio.m \
+  scripts/deprecated/printf.m \
+  scripts/deprecated/puts.m \
   scripts/deprecated/saveaudio.m \
+  scripts/deprecated/scanf.m \
   scripts/deprecated/setaudio.m \
   scripts/deprecated/sleep.m \
   scripts/deprecated/syl.m \
   scripts/deprecated/usage.m \
   scripts/deprecated/usleep.m \
   scripts/deprecated/wavread.m \
   scripts/deprecated/wavwrite.m
 
diff --git a/scripts/deprecated/printf.m b/scripts/deprecated/printf.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/printf.m
@@ -0,0 +1,58 @@
+## Copyright (C) 1993-2016 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {} {} fprintf (@var{template}, @dots{})
+##
+## @code{printf} is deprecated and will be removed in Octave version 4.6.
+## Use @code{fprintf} for the equivalent functionality.
+##
+## Print optional arguments under the control of the template string
+## @var{template} to the stream @code{stdout} and return the number of
+## characters printed.
+## @ifclear OCTAVE_MANUAL
+##
+## See the Formatted Output section of the GNU Octave manual for a
+## complete description of the syntax of the template string.
+## @end ifclear
+##
+## Implementation Note: For compatibility with @sc{matlab}, escape sequences in
+## the template string (e.g., @qcode{\"@xbackslashchar{}n\"} => newline) are
+## expanded even when the template string is defined with single quotes.
+##
+## @seealso{fprintf, sprintf, fscanf, sscanf}
+## @end deftypefn
+
+## Deprecated in version 4.2
+
+function varargout = printf (varargin)
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "printf is obsolete and will be removed from a future version of Octave, please use fprintf instead");
+  endif
+
+  if (nargin < 1)
+    print_usage ();
+  endif
+
+  varargout = fprintf (varargin);
+
+endfunction
diff --git a/scripts/deprecated/puts.m b/scripts/deprecated/puts.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/puts.m
@@ -0,0 +1,49 @@
+## Copyright (C) 1993-2016 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {} {} puts (@var{string})
+## @deftypefnx {} {@var{numbytes} =} puts (@var{string})
+##
+## @code{puts} is deprecated and will be removed in Octave version 4.6.
+## Use @code{fputs} for the equivalent functionality.
+##
+## Write a string to the standard output with no formatting.
+##
+## The string is written verbatim to the standard output.  Use @code{disp} to
+## automatically append a newline character appropriate for the local machine.
+##
+## The optional output returns the number of bytes written to stdout.
+##
+## @seealso{fputs, disp}
+## @end deftypefn
+
+## Deprecated in version 4.2
+
+function numbytes = puts (str)
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "puts is obsolete and will be removed from a future version of Octave, please use fputs instead");
+  endif
+
+  numbytes = fputs (stdout (), str);
+
+endfunction
diff --git a/scripts/deprecated/scanf.m b/scripts/deprecated/scanf.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/scanf.m
@@ -0,0 +1,49 @@
+## Copyright (C) 1993-2016 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {} {[@var{val}, @var{count}, @var{errmsg}] =} scanf (@var{template}, @var{size})
+## @deftypefnx {} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}]] =} scanf (@var{template}, \"C\")
+##
+## @code{scanf} is deprecated and will be removed in Octave version 4.6.
+## Use @code{fscanf (stdin, @dots{})} for the equivalent functionality.
+##
+## This is equivalent to calling @code{fscanf} with @var{fid} = @code{stdin}.
+##
+## It is currently not useful to call @code{scanf} in interactive programs.
+## @seealso{fscanf, sscanf, fprintf, sprintf}
+## @end deftypefn
+
+## Deprecated in version 4.2
+
+function varargout = scanf (varargin)
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "scanf is obsolete and will be removed from a future version of Octave, please use fscanf instead");
+  endif
+
+  if (nargin < 1)
+    print_usage ();
+  endif
+
+  varargout = fscanf (stdin (), varargin);
+
+endfunction
diff --git a/scripts/general/inputParser.m b/scripts/general/inputParser.m
--- a/scripts/general/inputParser.m
+++ b/scripts/general/inputParser.m
@@ -405,25 +405,25 @@ classdef inputParser < handle
       this.add_missing ("Switch");
 
     endfunction
 
     function display (this)
       if (nargin > 1)
         print_usage ();
       endif
-      printf ("inputParser object with properties:\n\n");
+      fprintf ("inputParser object with properties:\n\n");
       b2s = @(x) ifelse (any (x), "true", "false");
-      printf (["   CaseSensitive   : %s\n   FunctionName    : %s\n" ...
+      fprintf (["   CaseSensitive   : %s\n   FunctionName    : %s\n" ...
                "   KeepUnmatched   : %s\n   PartialMatching : %s\n" ...
                "   StructExpand    : %s\n\n"],
                b2s (this.CaseSensitive), b2s (this.FunctionName),
                b2s (this.KeepUnmatched), b2s (this.PartialMatching),
                b2s (this.StructExpand));
-      printf ("Defined parameters:\n\n   {%s}\n",
+      fprintf ("Defined parameters:\n\n   {%s}\n",
               strjoin (this.Parameters, ", "));
     endfunction
   endmethods
 
   methods (Access = private)
     function validate_name (this, type, name)
       if (! isvarname (name))
         error ("inputParser.add%s: NAME is an invalid identifier", method);
diff --git a/scripts/general/methods.m b/scripts/general/methods.m
--- a/scripts/general/methods.m
+++ b/scripts/general/methods.m
@@ -57,17 +57,17 @@ function mtds = methods (obj)
     end_try_catch
     mtds_list = strsplit (mtds_str, ';');
   else
     error ("methods: Invalid input argument");
   endif
 
   if (nargout == 0)
     classname = ifelse (ischar (obj), obj, class (obj));
-    printf ("Methods for class %s:\n", classname);
+    fprintf ("Methods for class %s:\n", classname);
     disp (list_in_columns (mtds_list));
   else
     mtds = mtds_list;
   endif
 
 endfunction
 
 
diff --git a/scripts/general/profexplore.m b/scripts/general/profexplore.m
--- a/scripts/general/profexplore.m
+++ b/scripts/general/profexplore.m
@@ -63,43 +63,43 @@ function rv = __profexplore_worker (fcn_
 
   ## Sort children by total time.
   times = -[ tree.TotalTime ];
   [~, p] = sort (times);
   tree = tree(p);
 
   while (true)
 
-    printf ("\n%s", parents);
+    fprintf ("\n%s", parents);
     strings = cell (length (tree), 1);
     for i = 1 : length (tree)
       strings{i} = sprintf ("%s: %d calls, %.3f total, %.3f self", ...
                             fcn_table(tree(i).Index).FunctionName, ...
                             tree(i).NumCalls, ...
                             tree(i).TotalTime, tree(i).SelfTime);
-      printf ("%s%d) %s\n", prefix, i, strings{i});
+      fprintf ("%s%d) %s\n", prefix, i, strings{i});
     endfor
-    printf ("\n");
+    fprintf ("\n");
 
     cmd = input ("profexplore> ", "s");
     option = fix (str2double (cmd));
 
     if (strcmp (cmd, "exit") || strcmp (cmd, "quit"))
       rv = 0;
       return;
     elseif (strcmp (cmd, "help"))
-      printf ("\nCommands for profile explorer:\n\n");
-      printf ("exit   Return to Octave prompt.\n");
-      printf ("quit   Return to Octave prompt.\n");
-      printf ("help   Display this help message.\n");
-      printf ("up [N] Go up N levels, where N is an integer.  Default is 1.\n");
-      printf ("N      Go down a level into option N.\n");
+      fprintf ("\nCommands for profile explorer:\n\n");
+      fprintf ("exit   Return to Octave prompt.\n");
+      fprintf ("quit   Return to Octave prompt.\n");
+      fprintf ("help   Display this help message.\n");
+      fprintf ("up [N] Go up N levels, where N is an integer.  Default is 1.\n");
+      fprintf ("N      Go down a level into option N.\n");
     elseif (! isnan (option))
       if (option < 1 || option > length (tree))
-        printf ("The chosen option is out of range!\n");
+        fprintf ("The chosen option is out of range!\n");
       else
         newParents = sprintf ("%s%s%s\n", parents, prefix, strings{option});
         newPrefix = sprintf ("%s  ", prefix);
 
         rv = __profexplore_worker (fcn_table, tree(option).Children, ...
                                    newParents, newPrefix);
 
         if (rv == 0)
@@ -121,18 +121,18 @@ function rv = __profexplore_worker (fcn_
       if (length (cmd) > 3 && cmd(3) == ' ')
         opt = fix (str2double (substr (cmd, 3)));
         if (! isnan (opt) && opt > 0)
           rv = opt;
           return;
         endif
       endif
 
-      printf ("Invalid 'up' command.  Type 'help' for further");
-      printf (" information.\n");
+      fprintf ("Invalid 'up' command.  Type 'help' for further");
+      fprintf (" information.\n");
     else
-      printf ("Unrecognized input.  Type 'help' to get a list of possible");
-      printf (" commands.\n");
+      fprintf ("Unrecognized input.  Type 'help' to get a list of possible");
+      fprintf (" commands.\n");
     endif
 
   endwhile
 endfunction
 
diff --git a/scripts/general/profshow.m b/scripts/general/profshow.m
--- a/scripts/general/profshow.m
+++ b/scripts/general/profshow.m
@@ -71,28 +71,28 @@ function profshow (data, n = 20)
   ## For printing the table, find out the maximum length of a function name
   ## so that we can proportion the table accordingly.  Based on this,
   ## we can build the format used for printing table rows.
   nameLen = max (length ("Function"),
                  columns (char (data.FunctionTable(p(1:n)).FunctionName)));
   headerFormat = sprintf ("%%4s %%%ds %%4s %%12s %%10s %%12s\n", nameLen);
   rowFormat = sprintf ("%%4d %%%ds %%4s %%12.3f %%10.2f %%12d\n", nameLen);
 
-  printf (headerFormat, ...
+  fprintf (headerFormat, ...
           "#", "Function", "Attr", "Time (s)", "Time (%)", "Calls");
-  printf ("%s\n", repmat ("-", 1, nameLen + 2 * 5 + 11 + 2 * 13));
+  fprintf ("%s\n", repmat ("-", 1, nameLen + 2 * 5 + 11 + 2 * 13));
 
   for i = 1 : n
     row = data.FunctionTable(p(i));
     timePercent = 100 * row.TotalTime / totalTime;
     attr = "";
     if (row.IsRecursive)
       attr = "R";
     endif
-    printf (rowFormat, p(i), row.FunctionName, attr,
+    fprintf (rowFormat, p(i), row.FunctionName, attr,
             row.TotalTime, timePercent, row.NumCalls);
   endfor
 
 endfunction
 
 
 %!demo
 %! profile on;
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -59,37 +59,37 @@ function retval = help (name)
   manual.  To read the manual from the prompt type\n\
 \n\
     doc\n\
 \n\
   GNU Octave is supported and developed by its user community.\n\
   For more information visit http://www.octave.org.\n\n";
 
     if (nargout == 0)
-      puts (text);
+      fputs (text);
     else
       retval = text;
     endif
 
   elseif (nargin == 1 && ischar (name))
 
     if (strcmp (name, "--list"))
       list = do_list_functions ();
       if (nargout == 0)
-        printf ("%s", list);
+        fprintf ("%s", list);
       else
         retval = list;
       endif
       return;
     endif
 
     if (strcmp (name, "."))
       list = do_list_operators ();
       if (nargout == 0)
-        printf ("%s", list);
+        fprintf ("%s", list);
       else
         retval = list;
       endif
       return;
     endif
 
     ## Get help text
     [text, format] = get_help_text (name);
@@ -113,17 +113,17 @@ function retval = help (name)
 
     ## Print text
     if (status != 0)
       warning ("help: Texinfo formatting filter exited abnormally; raw Texinfo source of help text follows...\n");
     endif
 
     if (nargout == 0)
       which (name);
-      printf ("\n%s\n%s", text, __additional_help_message__ ());
+      fprintf ("\n%s\n%s", text, __additional_help_message__ ());
     else
       retval = text;
     endif
 
   else
     error ("help: invalid input\n");
   endif
 
@@ -184,23 +184,23 @@ function do_contents (name)
     endswitch
 
     if (! isempty (text))
       found = true;
       ## Print text.
       if (status != 0)
         warning ("help: Texinfo formatting filter exited abnormally; raw Texinfo source of help text follows...\n");
       endif
-      printf ("%s:\n\n%s\n", fname, text);
+      fprintf ("%s:\n\n%s\n", fname, text);
     endif
 
   endfor
 
   if (found)
-    puts (__additional_help_message__ ());
+    fputs (__additional_help_message__ ());
   else
     msg = feval (missing_function_hook, name);
 
     if (isempty (msg))
       msg = sprintf ("'%s' not found", name);
     endif
 
     error ("help: %s\n", msg);
@@ -211,9 +211,8 @@ endfunction
 
 %!assert (! isempty (strfind (help ("ls"), "List directory contents")))
 %!assert (! isempty (strfind (help ("."), "||")))
 
 ## Test input validation
 %!error <invalid input> help (42)
 %!error <invalid input> help ("abc", "def")
 %!error <'_! UNLIKELY_FCN! _' not found> help ("_! UNLIKELY_FCN! _")
-
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -159,24 +159,24 @@ function [fcn, help1str] = lookfor (str,
     ## Print the results (FIXME: it would be nice to break at word boundaries)
     indent = 20;
     term_width = (terminal_size ())(2);
     desc_width = term_width - indent - 2;
     indent_space = blanks (indent);
     for k = 1:length (fcnlist)
       f = fcnlist{k};
       f(end+1:indent-1) = " ";
-      puts ([f " "]);
+      fputs ([f " "]);
       lf = length (f);
       desc = strtrim (strrep (help_text{k}, "\n", " "));
       ldesc = length (desc);
-      printf ("%s\n", desc(1:min (ldesc, desc_width - (lf - indent))));
+      fprintf ("%s\n", desc(1:min (ldesc, desc_width - (lf - indent))));
       for start = (desc_width - (lf - indent) + 1):desc_width:ldesc
         stop = min (start + desc_width, ldesc);
-        printf ("%s%s\n", indent_space, strtrim (desc (start:stop)));
+        fprintf ("%s%s\n", indent_space, strtrim (desc (start:stop)));
       endfor
     endfor
   else
     ## Return the results instead of displaying them
     fcn = fcnlist;
     help1str = help_text;
   endif
 
@@ -189,9 +189,8 @@ function [fcns, help_texts] = search_cac
     t2 = strfind (lower (cache (search_type, :)), str);
     cache_idx = find (! (cellfun ("isempty", t1) & cellfun ("isempty", t2)));
     fcns = cache(1, cache_idx);
     help_texts = cache(3, cache_idx);
   else
     fcns = help_texts = {};
   endif
 endfunction
-
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -41,28 +41,28 @@ function varargout = which (varargin)
     if (m(i).is_variable)
       m(i).file = "variable";
     endif
   endfor
 
   if (nargout == 0)
     for i = 1:nargin
       if (m(i).is_variable)
-        printf ("'%s' is a variable\n", m(i).name);
+        fprintf ("'%s' is a variable\n", m(i).name);
       elseif (isempty (m(i).file))
         if (! isempty (m(i).type))
-          printf ("'%s' is a %s\n",
+          fprintf ("'%s' is a %s\n",
                   m(i).name, m(i).type);
         endif
       else
         if (isempty (m(i).type))
-          printf ("'%s' is the file %s\n",
+          fprintf ("'%s' is the file %s\n",
                   m(i).name, m(i).file);
         else
-          printf ("'%s' is a %s from the file %s\n",
+          fprintf ("'%s' is a %s from the file %s\n",
                   m(i).name, m(i).type, m(i).file);
         endif
       endif
     endfor
   else
     varargout = {m.file};
   endif
 
diff --git a/scripts/image/imformats.m b/scripts/image/imformats.m
--- a/scripts/image/imformats.m
+++ b/scripts/image/imformats.m
@@ -306,17 +306,17 @@ function pretty_print_formats (formats)
   yes_no_cols = cat (2, {formats.isa}(:), {formats.info}(:), {formats.read}(:),
                      {formats.write}(:), {formats.alpha}(:));
   empty = cellfun (@isempty, yes_no_cols);
   yes_no_cols(empty) = "no";
   yes_no_cols(! empty) = "yes";
 
   descriptions = {formats.description};
   table = cat (2, extensions(:), yes_no_cols, descriptions(:));
-  printf ([template "\n"], table'{:});
+  fprintf ([template "\n"], table'{:});
 
 endfunction
 
 ## This must work, even without support for image IO
 %!test
 %! formats = imformats ();
 %! assert (isstruct (formats));
 %!
diff --git a/scripts/io/beep.m b/scripts/io/beep.m
--- a/scripts/io/beep.m
+++ b/scripts/io/beep.m
@@ -18,26 +18,25 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} beep ()
 ## Produce a beep from the speaker (or visual bell).
 ##
 ## This function sends the alarm character @qcode{"@xbackslashchar{}a"} to
 ## the terminal.  Depending on the user's configuration this may produce an
 ## audible beep, a visual bell, or nothing at all.
-## @seealso{puts, fputs, printf, fprintf}
+## @seealso{fputs, fprintf}
 ## @end deftypefn
 
 ## Author: jwe
 
 function beep ()
 
   if (nargin != 0)
     print_usage ();
   endif
 
-  puts ("\a");
+  fputs ("\a");
 
 endfunction
 
 
 %!error (beep (1))
-
diff --git a/scripts/io/fputs.m b/scripts/io/fputs.m
new file mode 100644
--- /dev/null
+++ b/scripts/io/fputs.m
@@ -0,0 +1,76 @@
+## Copyright (C) 1993-2016 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {} {} fputs (@var{string})
+## @deftypefnx {} {} fputs (@var{fid}, @var{string})
+## @deftypefnx {} {@var{numbytes} =} fputs (@dots{})
+##
+## Write the string @var{string} to the file with file descriptor @var{fid}.
+## If the file descriptor @var{fid} is ommited, the string is written to
+## stdout.
+##
+## The string is written to the file with no additional formatting.  Use
+## @code{fprintf} for formatting the output string.
+##
+## The optional output returns the number of bytes written to @var{fid} or
+## stdout, respectively.
+##
+## Examples:
+##
+## Printing the string @samp{Some text} directly to stdout.
+## @example
+## @group
+## fputs ("Some text");
+## @end group
+## @end example
+##
+## The following example shows how to write the string
+## @samp{Free Software is needed for Free Science} to the file
+## @samp{free.txt}.
+##
+## @example
+## @group
+## filename = "free.txt";
+## fid = fopen (filename, "w");
+## fputs (fid, "Free Software is needed for Free Science");
+## fclose (fid);
+## @end group
+## @end example
+##
+## @seealso{fprintf, fwrite, fopen, stdout}
+## @end deftypefn
+
+function numbytes = fputs (varargin)
+
+  narginchk (1, 2);
+
+  fid = stdout ();
+  str = varargin{1};
+  if (nargin == 2)
+    fid = varargin{1};
+    str = varargin{2};
+  endif
+
+  numbytes = fprintf (fid, "%s", str);
+
+endfunction
+
+%!assert (fputs (1, 1), 1)
+%!error <narginchk: not enough input arguments> fputs ()
+%!error <narginchk: too many input arguments> fputs (1, "foo", 3)
diff --git a/scripts/io/module.mk b/scripts/io/module.mk
--- a/scripts/io/module.mk
+++ b/scripts/io/module.mk
@@ -1,16 +1,17 @@
 FCN_FILE_DIRS += scripts/io
 
 scripts_io_FCN_FILES = \
   scripts/io/beep.m \
   scripts/io/csvread.m \
   scripts/io/csvwrite.m \
   scripts/io/dlmwrite.m \
   scripts/io/fileread.m \
+  scripts/io/fputs.m \
   scripts/io/importdata.m \
   scripts/io/is_valid_file_id.m \
   scripts/io/strread.m \
   scripts/io/textread.m
 
 scripts_iodir = $(fcnfiledir)/io
 
 scripts_io_DATA = $(scripts_io_FCN_FILES)
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -122,17 +122,17 @@ function varargout = textread (filename,
   endif
 
   if (! isempty (varargin) && isnumeric (varargin{1}))
     nlines = varargin{1};
   else
     nlines = Inf;
   endif
   if (nlines < 1)
-    printf ("textread: N = 0, no data read\n");
+    fprintf ("textread: N = 0, no data read\n");
     varargout = cell (1, nargout);
     return;
   endif
 
   ## Read file
   fid = fopen (filename, "r");
   if (fid == -1)
     error ("textread: could not open '%s' for reading", filename);
diff --git a/scripts/java/javaclasspath.m b/scripts/java/javaclasspath.m
--- a/scripts/java/javaclasspath.m
+++ b/scripts/java/javaclasspath.m
@@ -108,16 +108,16 @@ function [path1, path2] = javaclasspath 
     endif
   endif
 
 endfunction
 
 ## Display cell array of paths
 
 function disp_path_list (which, path_list)
-  printf ("   %s JAVA PATH\n\n", which);
+  fprintf ("   %s JAVA PATH\n\n", which);
   if (numel (path_list) > 0)
-    printf ("      %s\n", path_list{:});
+    fprintf ("      %s\n", path_list{:});
   else
-    printf ("      - empty -\n");
+    fprintf ("      - empty -\n");
   endif
 endfunction
 
diff --git a/scripts/java/javamem.m b/scripts/java/javamem.m
--- a/scripts/java/javamem.m
+++ b/scripts/java/javamem.m
@@ -68,24 +68,24 @@ function jmem = javamem ()
   rt = javaMethod ("getRuntime", "java.lang.Runtime");
   rt.gc;
   jvmem = cell (3, 1);
   jvmem{1} = rt.maxMemory ();
   jvmem{2} = rt.totalMemory ();
   jvmem{3} = rt.freeMemory ();
 
   if (nargout == 0)
-    printf ("\nJava virtual machine (JVM) memory info:\n");
-    printf ("Maximum available memory:        %5d MiB;\n",
+    fprintf ("\nJava virtual machine (JVM) memory info:\n");
+    fprintf ("Maximum available memory:        %5d MiB;\n",
             jvmem{1} / 1024 / 1024);
-    printf ("   (...running garbage collector...)\n");
-    printf ("OK, current status:\n");
-    printf ("Total memory in virtual machine: %5d MiB;\n",
+    fprintf ("   (...running garbage collector...)\n");
+    fprintf ("OK, current status:\n");
+    fprintf ("Total memory in virtual machine: %5d MiB;\n",
             jvmem{2} / 1024 / 1024);
-    printf ("Free memory in virtual machine:  %5d MiB;\n",
+    fprintf ("Free memory in virtual machine:  %5d MiB;\n",
             jvmem{3} / 1024 / 1024);
-    printf ("%d CPUs available.\n", rt.availableProcessors ());
+    fprintf ("%d CPUs available.\n", rt.availableProcessors ());
   else
     jmem = jvmem;
   endif
 
 endfunction
 
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -143,17 +143,17 @@ function retval = dir (directory)
   endif
 
   ## Return the output arguments.
   if (nargout > 0)
     ## Return the requested structure.
     retval = info;
   elseif (numel (info) > 0)
     ## Print the structure to the screen.
-    printf ("%s", list_in_columns ({info.name}));
+    fprintf ("%s", list_in_columns ({info.name}));
   else
     warning ("dir: nonexistent directory '%s'", directory);
   endif
 
 endfunction
 
 
 %!test
diff --git a/scripts/miscellaneous/dos.m b/scripts/miscellaneous/dos.m
--- a/scripts/miscellaneous/dos.m
+++ b/scripts/miscellaneous/dos.m
@@ -37,17 +37,17 @@
 
 function [status, text] = dos (command, echo_arg)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   elseif (! isunix ())
     [status, text] = system (command);
     if (nargin > 1 || nargout == 0)
-      printf ("%s\n", text);
+      fprintf ("%s\n", text);
     endif
   endif
 
 endfunction
 
 
 %!test
 %! cmd = ls_command ();
diff --git a/scripts/miscellaneous/fact.m b/scripts/miscellaneous/fact.m
--- a/scripts/miscellaneous/fact.m
+++ b/scripts/miscellaneous/fact.m
@@ -257,17 +257,17 @@ function truth = fact ()
       "Some of these Richard Stallman facts are completely true. Seriously.";
     };
 
   w = wisdom{randi(numel(wisdom))};
   if (nargout > 0)
     truth = w;
   else
     w = wordwrap (w);
-    printf ("%s", w);
+    fprintf ("%s", w);
   endif
 
 endfunction
 
 function out = wordwrap (w)
   ncol = terminal_size ()(2);
   wc = ostrsplit (w, " ");
   out = "\n";
diff --git a/scripts/miscellaneous/info.m b/scripts/miscellaneous/info.m
--- a/scripts/miscellaneous/info.m
+++ b/scripts/miscellaneous/info.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} info ()
 ## Display contact information for the GNU Octave community.
 ## @end deftypefn
 
 function info ()
 
-  printf ("\n\
+  fprintf ("\n\
   Additional information about GNU Octave is available at\n\
   http://www.octave.org\n\
 \n\
   Links to the mailing list and other resources for getting help with\n\
   Octave are available at\n\
   http://www.octave.org/support.html\n\
 \n\
   The Octave Wiki has user-generated content on a variety of subjects\n\
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -83,17 +83,17 @@ function [retval, errmsg] = license (cmd
       endif
 
       features = features(loaded);
 
       if (nargin > 1)
         features = features(strcmp (features, feature));
       endif
       if (nargout == 0)
-        printf ("%s\n", features{:});
+        fprintf ("%s\n", features{:});
       else
         retval = struct ("feature", features, "user", get_username ());
       endif
 
     case "test"
       if (nargin < 2)
         print_usage ();
       endif
diff --git a/scripts/miscellaneous/ls.m b/scripts/miscellaneous/ls.m
--- a/scripts/miscellaneous/ls.m
+++ b/scripts/miscellaneous/ls.m
@@ -93,17 +93,17 @@ function retval = ls (varargin)
   cmd = [__ls_command__ " " args];
 
   if (page_screen_output () || nargout > 0)
     [status, output] = system (cmd);
 
     if (status != 0)
       error ("ls: command exited abnormally with status %d\n", status);
     elseif (nargout == 0)
-      puts (output);
+      fputs (output);
     else
       retval = strvcat (regexp (output, "[\r\n]+", "split"){:});
     endif
   else
     ## Just let the output flow if the pager is off.  That way the
     ## output from things like "ls -R /" will show up immediately and
     ## we won't have to buffer all the output.
     system (cmd);
@@ -126,9 +126,8 @@ endfunction
 %!   list2 = (list2')(:)';   # transform to a single row vector
 %!   assert (! isempty (strfind (list2, "sbin")));
 %!   assert (rows (list) == rows (list2));
 %! endif
 
 %!error <all arguments must be character strings> ls (1)
 ## Test below is valid, but produces confusing output on screen
 %!#error <command exited abnormally> ls ("-!")
-
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -65,29 +65,29 @@ function choice = menu (title, varargin)
     ## Force pending output to appear before the menu.
     fflush (stdout);
 
     ## Don't send the menu through the pager since doing that can cause
     ## major confusion.
     page_screen_output (0, "local");
 
     if (! isempty (title))
-      printf ("%s\n", title);
+      fprintf ("%s\n", title);
     endif
 
     nopt = numel (varargin);
     while (1)
       for i = 1:nopt
-        printf ("  [%2d] %s\n", i, varargin{i});
+        fprintf ("  [%2d] %s\n", i, varargin{i});
       endfor
-      printf ("\n");
+      fprintf ("\n");
       s = input ("Select a number: ", "s");
       choice = sscanf (s, "%d");
       if (! isscalar (choice) || choice < 1 || choice > nopt)
-        printf ("\nerror: input invalid or out of range\n\n");
+        fprintf ("\nerror: input invalid or out of range\n\n");
         choice = 0;
       else
         break;
       endif
     endwhile
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -159,17 +159,17 @@ function [output, status] = mkoctfile (v
     cmd = [cmd ' "' varargin{i} '"'];
   endfor
 
   [sys, out] = system (cmd);
 
   if (nargout > 0)
     [output, status] = deal (out, sys);
   else
-    printf ("%s", out);
+    fprintf ("%s", out);
   endif
 
   if (sys != 0)
     warning ("mkoctfile: building exited with failure status");
   endif
 
 endfunction
 
diff --git a/scripts/miscellaneous/private/display_info_file.m b/scripts/miscellaneous/private/display_info_file.m
--- a/scripts/miscellaneous/private/display_info_file.m
+++ b/scripts/miscellaneous/private/display_info_file.m
@@ -43,14 +43,13 @@ function display_info_file (func, packag
       error ("%s: broken installation -- unable to locate %s file", func, file);
     else
       error ("%s: unable to locate %s file for package %s", func, file, package);
     endif
   endif
 
   fid = fopen (filepath, "r");
   while (ischar (line = fgets (fid)))
-    puts (line);
+    fputs (line);
   endwhile
   fclose (fid);
 
 endfunction
-
diff --git a/scripts/miscellaneous/unix.m b/scripts/miscellaneous/unix.m
--- a/scripts/miscellaneous/unix.m
+++ b/scripts/miscellaneous/unix.m
@@ -37,17 +37,17 @@
 
 function [status, text] = unix (command, echo_arg)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   elseif (isunix ())
     [status, text] = system (command);
     if (nargin > 1 || nargout == 0)
-      printf ("%s\n", text);
+      fprintf ("%s\n", text);
     endif
   endif
 
 endfunction
 
 
 %!test
 %! cmd = ls_command ();
diff --git a/scripts/miscellaneous/ver.m b/scripts/miscellaneous/ver.m
--- a/scripts/miscellaneous/ver.m
+++ b/scripts/miscellaneous/ver.m
@@ -70,17 +70,17 @@ function retval = ver (package = "")
 
     hbar(1:70) = "-";
     desc = {hbar
             ["GNU Octave Version: " OCTAVE_VERSION]
             ["GNU Octave License: " license]
             ["Operating System: " os_string]
             hbar};
 
-    printf ("%s\n", desc{:});
+    fprintf ("%s\n", desc{:});
 
     if (isempty (package))
       pkg ("list");
     elseif (strcmpi (package, "Octave"))
       ## Nothing to do, Octave version was already reported
     else
       pkg ("list", package);
     endif
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -132,31 +132,31 @@ function retval = what (dir)
     retval = w;
   endif
 
 endfunction
 
 function __display_filenames__ (msg, p, f)
 
   if (length (f) > 0)
-    printf ("%s %s:\n\n", msg, p);
+    fprintf ("%s %s:\n\n", msg, p);
 
     maxlen = max (cellfun ("length", f));
     ncols = max (1, floor (terminal_size ()(2) / (maxlen + 3)));
     fmt = sprintf ("   %%-%ds", maxlen);
     fmt = repmat (fmt, [1, ncols]);
     fmt = [fmt "\n"];
 
     nrows = ceil (length (f) / ncols);
     for i = 1 : nrows
       args = f(i:nrows:end);
       if (length (args) < ncols)
         args(end+1 : ncols) = {""};
       endif
-      printf (fmt, args{:});
+      fprintf (fmt, args{:});
     endfor
   endif
 
 endfunction
 
 
 %!test
 %! w = what ();
diff --git a/scripts/ode/ode23.m b/scripts/ode/ode23.m
--- a/scripts/ode/ode23.m
+++ b/scripts/ode/ode23.m
@@ -356,19 +356,19 @@ function varargout = ode23 (fun, trange,
     nsteps    = solution.cntloop-2;              # cntloop from 2..end
     nfailed   = (solution.cntcycles-1)-nsteps+1; # cntcycl from 1..end
     nfevals   = 3 * (solution.cntcycles-1);      # number of ode evaluations
     ndecomps  = 0;  # number of LU decompositions
     npds      = 0;  # number of partial derivatives
     nlinsols  = 0;  # no. of solutions of linear systems
     ## Print cost statistics if no output argument is given
     if (nargout == 0)
-      printf ("Number of successful steps: %d\n", nsteps);
-      printf ("Number of failed attempts:  %d\n", nfailed);
-      printf ("Number of function calls:   %d\n", nfevals);
+      fprintf ("Number of successful steps: %d\n", nsteps);
+      fprintf ("Number of failed attempts:  %d\n", nfailed);
+      fprintf ("Number of function calls:   %d\n", nfevals);
     endif
   else
     havestats = false;
   endif
 
   if (nargout == 2)
     varargout{1} = solution.t;      # Time stamps are first output argument
     varargout{2} = solution.x;      # Results are second output argument
diff --git a/scripts/ode/ode45.m b/scripts/ode/ode45.m
--- a/scripts/ode/ode45.m
+++ b/scripts/ode/ode45.m
@@ -341,19 +341,19 @@ function varargout = ode45 (fun, trange,
     nsteps    = solution.cntloop-2;                 # cntloop from 2..end
     nfailed   = (solution.cntcycles-1)-(nsteps)+1;  # cntcycl from 1..end
     nfevals   = 6 * (solution.cntcycles-1) + 1;     # number of ode evaluations
     ndecomps  = 0;  # number of LU decompositions
     npds      = 0;  # number of partial derivatives
     nlinsols  = 0;  # no. of linear systems solutions
     ## Print cost statistics if no output argument is given
     if (nargout == 0)
-      printf ("Number of successful steps: %d\n", nsteps);
-      printf ("Number of failed attempts:  %d\n", nfailed);
-      printf ("Number of function calls:   %d\n", nfevals);
+      fprintf ("Number of successful steps: %d\n", nsteps);
+      fprintf ("Number of failed attempts:  %d\n", nfailed);
+      fprintf ("Number of function calls:   %d\n", nfevals);
     endif
   else
     havestats = false;
   endif
 
   if (nargout == 2)
     varargout{1} = solution.t;      # Time stamps are first output argument
     varargout{2} = solution.x;      # Results are second output argument
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -255,42 +255,42 @@ function fx = guarded_eval (fun, x)
     error ("fminbnd:notreal", "fminbnd: non-real value encountered");
   elseif (isnan (fx))
     error ("fminbnd:isnan", "fminbnd: NaN value encountered");
   endif
 endfunction
 
 ## A hack for printing a formatted table
 function print_formatted_table (table)
-  printf ("\n Func-count     x          f(x)         Procedure\n");
+  fprintf ("\n Func-count     x          f(x)         Procedure\n");
   for row=table
-    printf("%5.5s        %7.7s    %8.8s\t%s\n",
+    fprintf("%5.5s        %7.7s    %8.8s\t%s\n",
            int2str (row.funccount), num2str (row.x,"%.5f"),
            num2str (row.fx,"%.6f"), row.procedure);
   endfor
-  printf ("\n");
+  fprintf ("\n");
 endfunction
 
 ## Print either a success termination message or bad news
 function print_exit_msg (info, opt=struct())
-  printf ("");
+  fprintf ("");
   switch (info)
     case 1
-      printf ("Optimization terminated:\n");
-      printf (" the current x satisfies the termination criteria using OPTIONS.TolX of %e\n", opt.TolX);
+      fprintf ("Optimization terminated:\n");
+      fprintf (" the current x satisfies the termination criteria using OPTIONS.TolX of %e\n", opt.TolX);
     case 0
-      printf ("Exiting: Maximum number of iterations has been exceeded\n");
-      printf ("         - increase MaxIter option.\n");
-      printf ("         Current function value: %.6f\n", opt.fx);
+      fprintf ("Exiting: Maximum number of iterations has been exceeded\n");
+      fprintf ("         - increase MaxIter option.\n");
+      fprintf ("         Current function value: %.6f\n", opt.fx);
     case -1
       "FIXME"; # FIXME: what's the message MATLAB prints for this case?
     otherwise
       error ("fminbnd: internal error, info return code was %d", info);
   endswitch
-  printf ("\n");
+  fprintf ("\n");
 endfunction
 
 
 %!shared opt0
 %! opt0 = optimset ("tolx", 0);
 %!assert (fminbnd (@cos, pi/2, 3*pi/2, opt0), pi, 10*sqrt (eps))
 %!assert (fminbnd (@(x) (x - 1e-3)^4, -1, 1, opt0), 1e-3, 10e-3*sqrt (eps))
 %!assert (fminbnd (@(x) abs (x-1e7), 0, 1e10, opt0), 1e7, 10e7*sqrt (eps))
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -117,19 +117,19 @@ function retval = optimset (varargin)
 
   nargs = nargin ();
 
   opts = __all_opts__ ();
 
   if (nargs == 0)
     if (nargout == 0)
       ## Display possibilities.
-      puts ("\nAll possible optimization options:\n\n");
-      printf ("  %s\n", opts{:});
-      puts ("\n");
+      fputs ("\nAll possible optimization options:\n\n");
+      fprintf ("  %s\n", opts{:});
+      fputs ("\n");
     else
       ## Return struct with all options initialized to []
       retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
     endif
   elseif (nargs == 1 && ischar (varargin{1}))
     ## Return defaults for named function.
     fcn = varargin{1};
     try
@@ -184,9 +184,8 @@ endfunction
 %!assert (isfield (optimset ("tolFun", 1e-3), "TolFun"))
 %!assert (optimget (optimset ("tolx", 1e-2), "tOLx"), 1e-2)
 
 ## Test input validation
 %!error optimset ("1_Parameter")
 %!error <no defaults for function> optimset ("%NOT_A_REAL_FUNCTION_NAME%")
 %!warning <unrecognized option: foobar> optimset ("foobar", 13);
 %!warning <ambiguous option: Max> optimset ("Max", 10);
-
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -716,19 +716,19 @@ function res = cigrad_ub_lb (x, bgrad, g
   endif
 
 endfunction
 
 ## Utility function used to debug sqp
 function report (iter, qp_iter, alpha, nfun, obj)
 
   if (nargin == 0)
-    printf ("  Itn ItQP     Step  Nfun     Objective\n");
+    fprintf ("  Itn ItQP     Step  Nfun     Objective\n");
   else
-    printf ("%5d %4d %8.1g %5d %13.6e\n", iter, qp_iter, alpha, nfun, obj);
+    fprintf ("%5d %4d %8.1g %5d %13.6e\n", iter, qp_iter, alpha, nfun, obj);
   endif
 
 endfunction
 
 
 ################################################################################
 ## Test Code
 
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -416,18 +416,18 @@ function [local_packages, global_package
     case "unload"
       if (isempty (files))
         error ("pkg: unload action requires at least one package or 'all'");
       endif
       unload_packages (files, deps, local_list, global_list);
 
     case "prefix"
       if (isempty (files) && ! nargout)
-        printf ("Installation prefix:             %s\n", prefix);
-        printf ("Architecture dependent prefix:   %s\n", archprefix);
+        fprintf ("Installation prefix:             %s\n", prefix);
+        fprintf ("Architecture dependent prefix:   %s\n", archprefix);
       elseif (isempty (files) && nargout)
         local_packages = prefix;
         global_packages = archprefix;
       elseif (numel (files) >= 1 && ischar (files{1}))
         prefix = tilde_expand (files{1});
         if (! exist (prefix, "dir"))
           [status, msg] = mkdir (prefix);
           if (status == 0)
diff --git a/scripts/pkg/private/describe.m b/scripts/pkg/private/describe.m
--- a/scripts/pkg/private/describe.m
+++ b/scripts/pkg/private/describe.m
@@ -135,24 +135,24 @@ function pkg_idx_struct = parse_pkg_idx 
     line = fgetl (fid);
   endwhile
   fclose (fid);
 endfunction
 
 
 function print_package_description (pkg_name, pkg_ver, pkg_idx_struct,
                                     pkg_desc, status, verbose)
-  printf ("---\nPackage name:\n\t%s\n", pkg_name);
-  printf ("Version:\n\t%s\n", pkg_ver);
-  printf ("Short description:\n\t%s\n", pkg_desc);
-  printf ("Status:\n\t%s\n", status);
+  fprintf ("---\nPackage name:\n\t%s\n", pkg_name);
+  fprintf ("Version:\n\t%s\n", pkg_ver);
+  fprintf ("Short description:\n\t%s\n", pkg_desc);
+  fprintf ("Status:\n\t%s\n", status);
   if (verbose)
-    printf ("---\nProvides:\n");
+    fprintf ("---\nProvides:\n");
     for i = 1:length (pkg_idx_struct)
       if (! isempty (pkg_idx_struct{i}.functions))
-        printf ("%s\n", pkg_idx_struct{i}.category);
+        fprintf ("%s\n", pkg_idx_struct{i}.category);
         for j = 1:length (pkg_idx_struct{i}.functions)
-          printf ("\t%s\n", pkg_idx_struct{i}.functions{j});
+          fprintf ("\t%s\n", pkg_idx_struct{i}.functions{j});
         endfor
       endif
     endfor
   endif
 endfunction
diff --git a/scripts/pkg/private/install.m b/scripts/pkg/private/install.m
--- a/scripts/pkg/private/install.m
+++ b/scripts/pkg/private/install.m
@@ -62,26 +62,26 @@ function install (files, handle_deps, pr
     for i = 1:length (files)
       tgz = files{i};
 
       if (exist (tgz, "file"))
         ## Create a temporary directory.
         tmpdir = tempname ();
         tmpdirs{end+1} = tmpdir;
         if (verbose)
-          printf ("mkdir (%s)\n", tmpdir);
+          fprintf ("mkdir (%s)\n", tmpdir);
         endif
         [status, msg] = mkdir (tmpdir);
         if (status != 1)
           error ("couldn't create temporary directory: %s", msg);
         endif
 
         ## Uncompress the package.
         if (verbose)
-          printf ("untar (%s, %s)\n", tgz, tmpdir);
+          fprintf ("untar (%s, %s)\n", tgz, tmpdir);
         endif
         untar (tgz, tmpdir);
 
         ## Get the name of the directories produced by tar.
         [dirlist, err, msg] = readdir (tmpdir);
         if (err)
           error ("couldn't read directory produced by tar: %s", msg);
         endif
@@ -271,19 +271,19 @@ function install (files, handle_deps, pr
     ## Something went wrong, delete tmpdirs.
     for i = 1:length (tmpdirs)
       rmdir (tmpdirs{i}, "s");
     endfor
     for i = 1:length (descriptions)
       rmdir (descriptions{i}.dir, "s");
     endfor
     if (global_install)
-      printf ("error: couldn't append to %s\n", global_list);
+      fprintf ("error: couldn't append to %s\n", global_list);
     else
-      printf ("error: couldn't append to %s\n", local_list);
+      fprintf ("error: couldn't append to %s\n", local_list);
     endif
     rethrow (lasterror ());
   end_try_catch
 
   ## All is well, let's clean up.
   for i = 1:length (tmpdirs)
     [status, msg] = rmdir (tmpdirs{i}, "s");
     if (status != 1 && exist (tmpdirs{i}, "dir"))
@@ -291,17 +291,17 @@ function install (files, handle_deps, pr
     endif
   endfor
 
   ## If there is a NEWS file, mention it.
   ## Check if desc exists too because it's possible to get to this point
   ## without creating it such as giving an invalid filename for the package
   if (exist ("desc", "var")
       && exist (fullfile (desc.dir, "packinfo", "NEWS"), "file"))
-    printf ("For information about changes from previous versions of the %s package, run 'news %s'.\n",
+    fprintf ("For information about changes from previous versions of the %s package, run 'news %s'.\n",
             desc.name, desc.name);
   endif
 endfunction
 
 
 function pkg = extract_pkg (nm, pat)
   fid = fopen (nm, "rt");
   pkg = "";
@@ -414,31 +414,31 @@ function copy_built_files (desc, packdir
 
   ## Copy the files.
   if (! all (isspace ([filenames{:}])))
       if (! exist (instdir, "dir"))
         mkdir (instdir);
       endif
       if (! all (isspace ([archindependent{:}])))
         if (verbose)
-          printf ("copyfile");
-          printf (" %s", archindependent{:});
-          printf ("%s\n", instdir);
+          fprintf ("copyfile");
+          fprintf (" %s", archindependent{:});
+          fprintf ("%s\n", instdir);
         endif
         [status, output] = copyfile (archindependent, instdir);
         if (status != 1)
           rmdir (desc.dir, "s");
           error ("Couldn't copy files from 'src' to 'inst': %s", output);
         endif
       endif
       if (! all (isspace ([archdependent{:}])))
         if (verbose)
-          printf ("copyfile");
-          printf (" %s", archdependent{:});
-          printf (" %s\n", archdir);
+          fprintf ("copyfile");
+          fprintf (" %s", archdependent{:});
+          fprintf (" %s\n", archdir);
         endif
         if (! exist (archdir, "dir"))
           mkdir (archdir);
         endif
         [status, output] = copyfile (archdependent, archdir);
         if (status != 1)
           rmdir (desc.dir, "s");
           error ("Couldn't copy files from 'src' to 'inst': %s", output);
diff --git a/scripts/pkg/private/installed_packages.m b/scripts/pkg/private/installed_packages.m
--- a/scripts/pkg/private/installed_packages.m
+++ b/scripts/pkg/private/installed_packages.m
@@ -88,19 +88,19 @@ function [out1, out2] = installed_packag
   elseif (nargout > 1)
     out1 = local_packages;
     out2 = global_packages;
   else
     ## Don't return anything, instead we'll print something.
     num_packages = numel (installed_pkgs_lst);
     if (num_packages == 0)
       if (isempty (pkgname))
-        printf ("no packages installed.\n");
+        fprintf ("no packages installed.\n");
       else
-        printf ("package %s is not installed.\n", pkgname{1});
+        fprintf ("package %s is not installed.\n", pkgname{1});
       endif
       return;
     endif
 
     ## Compute the maximal lengths of name, version, and dir.
     h1 = "Package Name";
     h2 = "Version";
     h3 = "Installation directory";
@@ -113,21 +113,21 @@ function [out1, out2] = installed_packag
       max_dir_length = Inf;
     endif
 
     h1 = postpad (h1, max_name_length + 1, " ");
     h2 = postpad (h2, max_version_length, " ");;
 
     ## Print a header.
     header = sprintf ("%s | %s | %s\n", h1, h2, h3);
-    printf (header);
+    fprintf (header);
     tmp = sprintf (repmat ("-", 1, length (header) - 1));
     tmp(length(h1)+2) = "+";
     tmp(length(h1)+length(h2)+5) = "+";
-    printf ("%s\n", tmp);
+    fprintf ("%s\n", tmp);
 
     ## Print the packages.
     format = sprintf ("%%%ds %%1s| %%%ds | %%s\n",
                       max_name_length, max_version_length);
     for i = 1:num_packages
       cur_name = installed_pkgs_lst{i}.name;
       cur_version = installed_pkgs_lst{i}.version;
       cur_dir = installed_pkgs_lst{i}.dir;
@@ -140,12 +140,12 @@ function [out1, out2] = installed_packag
           cur_dir = ["..." cur_dir(first_char:end)];
         endif
       endif
       if (installed_pkgs_lst{i}.loaded)
         cur_loaded = "*";
       else
         cur_loaded = " ";
       endif
-      printf (format, cur_name, cur_loaded, cur_version, cur_dir);
+      fprintf (format, cur_name, cur_loaded, cur_version, cur_dir);
     endfor
   endif
 endfunction
diff --git a/scripts/pkg/private/list_forge_packages.m b/scripts/pkg/private/list_forge_packages.m
--- a/scripts/pkg/private/list_forge_packages.m
+++ b/scripts/pkg/private/list_forge_packages.m
@@ -26,20 +26,19 @@ function list = list_forge_packages ()
   [list, succ] = urlread ("http://packages.octave.org/list_packages.php");
   if (succ)
     list = ostrsplit (list, " \n\t", true);
   else
     error ("pkg: could not read URL, please verify internet connection");
   endif
   if (nargout == 0)
     page_screen_output (false, "local");
-    puts ("OctaveForge provides these packages:\n");
+    fputs ("OctaveForge provides these packages:\n");
     for i = 1:length (list)
       try
         ver = get_forge_pkg (list{i});
       catch
         ver = "unknown";
       end_try_catch
-      printf ("  %s %s\n", list{i}, ver);
+      fprintf ("  %s %s\n", list{i}, ver);
     endfor
   endif
 endfunction
-
diff --git a/scripts/pkg/private/rebuild.m b/scripts/pkg/private/rebuild.m
--- a/scripts/pkg/private/rebuild.m
+++ b/scripts/pkg/private/rebuild.m
@@ -39,17 +39,17 @@ function descriptions = rebuild (prefix,
     unwind_protect_cleanup
       cd (wd);
     end_unwind_protect
   endif
   descriptions = {};
   for k = 1:length (dirlist)
     descfile = fullfile (prefix, dirlist{k}, "packinfo", "DESCRIPTION");
     if (verbose)
-      printf ("recreating package description from %s\n", dirlist{k});
+      fprintf ("recreating package description from %s\n", dirlist{k});
     endif
     if (exist (descfile, "file"))
       desc = get_description (descfile);
       desc.dir = fullfile (prefix, dirlist{k});
       desc.archprefix = fullfile (archprefix, [desc.name "-" desc.version]);
       descriptions{end + 1} = desc;
     elseif (verbose)
       warning ("directory %s is not a valid package", dirlist{k});
diff --git a/scripts/plot/util/__gnuplot_drawnow__.m b/scripts/plot/util/__gnuplot_drawnow__.m
--- a/scripts/plot/util/__gnuplot_drawnow__.m
+++ b/scripts/plot/util/__gnuplot_drawnow__.m
@@ -93,17 +93,17 @@ function __gnuplot_drawnow__ (h, term, f
       endwhile
       ## reprint the plot on screen
       [a, count] = fscanf (fid, '%c', Inf);
       fclose (fid);
       if (count > 0)
         if (a(1) == 12)
           a = a(2:end);  # avoid ^L at the beginning
         endif
-        puts (a);
+        fputs (a);
       endif
       unlink (dumb_tmp_file);
     endif
   endif
 
 endfunction
 
 function enhanced = gnuplot_set_term (plot_stream, new_stream, h, term, file)
@@ -409,9 +409,8 @@ function retval = have_non_legend_axes (
       retval = (n_all_axes - n_legend_axes) > 1;
     endif
   endif
 endfunction
 
 
 ## No test needed for internal helper function.
 %!assert (1)
-
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -80,17 +80,17 @@ function [y, c] = stft (x, win_size = 80
   if (! isvector (x))
     error ("stft: X must be a vector");
   endif
   x = x(:);
 
   ncoef = 2 * num_coef;
   if (win_size > ncoef)
     win_size = ncoef;
-    printf ("stft: window size adjusted to %f\n", win_size);
+    fprintf ("stft: window size adjusted to %f\n", win_size);
   endif
   num_win = fix ((rows (x) - win_size) / inc);
 
   ## compute the window coefficients
   switch (win_type)
     case 1  win_coef = hanning (win_size);
     case 2  win_coef = hamming (win_size);
     case 3  win_coef = ones (win_size, 1);
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -173,50 +173,50 @@ function [x, flag, res1, k, resvec] = bi
 
         r0 = r1;
         s0 = s1;
 
         res1 = norm (b - Ax (x)) / bnorm;
         if (res1 < tol)
           flag = 0;
           if (nargout < 2)
-            printf ("bicg converged at iteration %i ", k);
-            printf ("to a solution with relative residual %e\n", res1);
+            fprintf ("bicg converged at iteration %i ", k);
+            fprintf ("to a solution with relative residual %e\n", res1);
           endif
           break;
         endif
 
         if (res0 <= res1)
           flag = 3;
-          printf ("bicg stopped at iteration %i ", k);
-          printf ("without converging to the desired tolerance %e\n", tol);
-          printf ("because the method stagnated.\n");
-          printf ("The iterate returned (number %i) ", k-1);
-          printf ("has relative residual %e\n", res0);
+          fprintf ("bicg stopped at iteration %i ", k);
+          fprintf ("without converging to the desired tolerance %e\n", tol);
+          fprintf ("because the method stagnated.\n");
+          fprintf ("The iterate returned (number %i) ", k-1);
+          fprintf ("has relative residual %e\n", res0);
           break
         endif
         res0 = res1;
         if (nargout > 4)
           resvec(k) = res0;
         endif
       endfor
 
       if (k == maxit)
         flag = 1;
-        printf ("bicg stopped at iteration %i ", maxit);
-        printf ("without converging to the desired tolerance %e\n", tol);
-        printf ("because the maximum number of iterations was reached. ");
-        printf ("The iterate returned (number %i) has ", maxit);
-        printf ("relative residual %e\n", res1);
+        fprintf ("bicg stopped at iteration %i ", maxit);
+        fprintf ("without converging to the desired tolerance %e\n", tol);
+        fprintf ("because the maximum number of iterations was reached. ");
+        fprintf ("The iterate returned (number %i) has ", maxit);
+        fprintf ("relative residual %e\n", res1);
       endif
 
     else
       flag = 0;
       if (nargout < 2)
-        printf ("bicg converged after 0 interations\n");
+        fprintf ("bicg converged after 0 interations\n");
       endif
     endif
 
   else
     print_usage ();
   endif
 
 endfunction;
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -175,30 +175,30 @@ function [x, flag, relres, iter, resvec]
         ## The method stagnates.
         flag = 3;
         break;
       endif
     endfor
 
     if (nargout < 2)
       if (flag == 0)
-        printf ("bicgstab converged at iteration %i ", iter);
-        printf ("to a solution with relative residual %e\n", relres);
+        fprintf ("bicgstab converged at iteration %i ", iter);
+        fprintf ("to a solution with relative residual %e\n", relres);
       elseif (flag == 3)
-        printf ("bicgstab stopped at iteration %i ", iter);
-        printf ("without converging to the desired tolerance %e\n", tol);
-        printf ("because the method stagnated.\n");
-        printf ("The iterate returned (number %i) ", iter);
-        printf ("has relative residual %e\n", relres);
+        fprintf ("bicgstab stopped at iteration %i ", iter);
+        fprintf ("without converging to the desired tolerance %e\n", tol);
+        fprintf ("because the method stagnated.\n");
+        fprintf ("The iterate returned (number %i) ", iter);
+        fprintf ("has relative residual %e\n", relres);
       else
-        printf ("bicgstab stopped at iteration %i ", iter);
-        printf ("without converging to the desired toleranc %e\n", tol);
-        printf ("because the maximum number of iterations was reached.\n");
-        printf ("The iterate returned (number %i) ", iter);
-        printf ("has relative residual %e\n", relres);
+        fprintf ("bicgstab stopped at iteration %i ", iter);
+        fprintf ("without converging to the desired toleranc %e\n", tol);
+        fprintf ("because the maximum number of iterations was reached.\n");
+        fprintf ("The iterate returned (number %i) ", iter);
+        fprintf ("has relative residual %e\n", relres);
       endif
     endif
 
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -160,25 +160,25 @@ function [x, flag, relres, iter, resvec]
         ## The method stagnates.
         flag = 3;
         break
       endif
     endfor
 
     if (nargout < 1)
       if (flag == 0)
-        printf ("cgs converged at iteration %i to a solution with relative residual %e\n",
+        fprintf ("cgs converged at iteration %i to a solution with relative residual %e\n",
                 iter, relres);
       elseif (flag == 3)
-        printf (["cgs stopped at iteration %i without converging to the desired tolerance %e\n",
+        fprintf (["cgs stopped at iteration %i without converging to the desired tolerance %e\n",
                  "because the method stagnated.\n",
                  "The iterate returned (number %i) has relative residual %e\n"],
                 iter, tol, iter, relres);
       else
-        printf (["cgs stopped at iteration %i without converging to the desired tolerance %e\n",
+        fprintf (["cgs stopped at iteration %i without converging to the desired tolerance %e\n",
                  "because the maximum number of iterations was reached.\n",
                  "The iterate returned (number %i) has relative residual %e\n"],
                 iter, tol, iter, relres);
       endif
     endif
 
   else
     print_usage ();
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -390,47 +390,47 @@ endfunction
 
 %!demo
 %! ## Simplest usage of pcg (see also 'help pcg')
 %!
 %! N = 10;
 %! A = diag ([1:N]); b = rand (N, 1);
 %! y = A \ b;  # y is the true solution
 %! x = pcg (A, b);
-%! printf ("The solution relative error is %g\n", norm (x - y) / norm (y));
+%! fprintf ("The solution relative error is %g\n", norm (x - y) / norm (y));
 %!
 %! ## You shouldn't be afraid if pcg issues some warning messages in this
 %! ## example: watch out in the second example, why it takes N iterations
 %! ## of pcg to converge to (a very accurate, by the way) solution
 
 %!demo
 %! ## Full output from pcg, except for the eigenvalue estimates
 %! ## We use this output to plot the convergence history
 %!
 %! N = 10;
 %! A = diag ([1:N]); b = rand (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag, relres, iter, resvec] = pcg (A, b);
-%! printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
+%! fprintf ("The solution relative error is %g\n", norm (x - X) / norm (X));
 %! title ("Convergence history");
 %! semilogy ([0:iter], resvec / resvec(1), "o-g");
 %! xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
 %! legend ("relative residual");
 
 %!demo
 %! ## Full output from pcg, including the eigenvalue estimates
 %! ## Hilbert matrix is extremely ill-conditioned, so pcg WILL have problems
 %!
 %! N = 10;
 %! A = hilb (N); b = rand (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], 200);
-%! printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
-%! printf ("Condition number estimate is %g\n", eigest(2) / eigest(1));
-%! printf ("Actual condition number is   %g\n", cond (A));
+%! fprintf ("The solution relative error is %g\n", norm (x - X) / norm (X));
+%! fprintf ("Condition number estimate is %g\n", eigest(2) / eigest(1));
+%! fprintf ("Actual condition number is   %g\n", cond (A));
 %! title ("Convergence history");
 %! semilogy ([0:iter], resvec, ["o-g";"+-r"]);
 %! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
 %! legend ("absolute residual", "absolute preconditioned residual");
 
 %!demo
 %! ## Full output from pcg, including the eigenvalue estimates
 %! ## We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
@@ -441,46 +441,46 @@ endfunction
 %! N = 100;
 %! A = zeros (N, N);
 %! for i = 1 : N - 1 # form 1-D Laplacian matrix
 %!   A(i:i+1, i:i+1) = [2 -1; -1 2];
 %! endfor
 %! b = rand (N, 1);
 %! X = A \ b;  # X is the true solution
 %! maxit = 80;
-%! printf ("System condition number is %g\n", cond (A));
+%! fprintf ("System condition number is %g\n", cond (A));
 %! ## No preconditioner: the convergence is very slow!
 %!
 %! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit);
-%! printf ("System condition number estimate is %g\n", eigest(2) / eigest(1));
+%! fprintf ("System condition number estimate is %g\n", eigest(2) / eigest(1));
 %! title ("Convergence history");
 %! semilogy ([0:iter], resvec(:,1), "o-g");
 %! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
 %! legend ("NO preconditioning: absolute residual");
 %!
 %! pause (1);
 %! ## Test Jacobi preconditioner: it will not help much!!!
 %!
 %! M = diag (diag (A)); # Jacobi preconditioner
 %! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
-%! printf ("JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
+%! fprintf ("JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
 %! hold on;
 %! semilogy ([0:iter], resvec(:,1), "o-r");
 %! legend ("NO preconditioning: absolute residual", ...
 %!         "JACOBI preconditioner: absolute residual");
 %!
 %! pause (1);
 %! ## Test nonoverlapping block Jacobi preconditioner: it will help much!
 %!
 %! M = zeros (N, N); k = 4;
 %! for i = 1 : k : N # form 1-D Laplacian matrix
 %!   M(i:i+k-1, i:i+k-1) = A(i:i+k-1, i:i+k-1);
 %! endfor
 %! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
-%! printf ("BLOCK JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
+%! fprintf ("BLOCK JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
 %! semilogy ([0:iter], resvec(:,1), "o-b");
 %! legend ("NO preconditioning: absolute residual", ...
 %!         "JACOBI preconditioner: absolute residual", ...
 %!         "BLOCK JACOBI preconditioner: absolute residual");
 %! hold off;
 
 %!test
 %! ## solve small diagonal system
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -307,50 +307,50 @@ endfunction
 
 %!demo
 %! ## Simplest usage of PCR (see also 'help pcr')
 %!
 %! N = 20;
 %! A = diag (linspace (-3.1,3,N)); b = rand (N,1);
 %! y = A \ b;  # y is the true solution
 %! x = pcr (A,b);
-%! printf ("The solution relative error is %g\n", norm (x-y) / norm (y));
+%! fprintf ("The solution relative error is %g\n", norm (x-y) / norm (y));
 %!
 %! ## You shouldn't be afraid if PCR issues some warning messages in this
 %! ## example: watch out in the second example, why it takes N iterations
 %! ## of PCR to converge to (a very accurate, by the way) solution.
 
 %!demo
 %! ## Full output from PCR
 %! ## We use this output to plot the convergence history
 %!
 %! N = 20;
 %! A = diag (linspace (-3.1,30,N)); b = rand (N,1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag, relres, iter, resvec] = pcr (A,b);
-%! printf ("The solution relative error is %g\n", norm (x-X) / norm (X));
+%! fprintf ("The solution relative error is %g\n", norm (x-X) / norm (X));
 %! clf;
 %! title ("Convergence history");
 %! xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
 %! semilogy ([0:iter], resvec/resvec(1), "o-g;relative residual;");
 
 %!demo
 %! ## Full output from PCR
 %! ## We use indefinite matrix based on the Hilbert matrix, with one
 %! ## strongly negative eigenvalue
 %! ## Hilbert matrix is extremely ill conditioned, so is ours,
 %! ## and that's why PCR WILL have problems
 %!
 %! N = 10;
 %! A = hilb (N); A(1,1) = -A(1,1); b = rand (N,1);
 %! X = A \ b;  # X is the true solution
-%! printf ("Condition number of A is   %g\n", cond (A));
+%! fprintf ("Condition number of A is   %g\n", cond (A));
 %! [x, flag, relres, iter, resvec] = pcr (A,b,[],200);
 %! if (flag == 3)
-%!   printf ("PCR breakdown.  System matrix is [close to] singular\n");
+%!   fprintf ("PCR breakdown.  System matrix is [close to] singular\n");
 %! end
 %! clf;
 %! title ("Convergence history");
 %! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
 %! semilogy ([0:iter], resvec, "o-g;absolute residual;");
 
 %!demo
 %! ## Full output from PCR
@@ -366,17 +366,17 @@ endfunction
 %! A = zeros (N,N);
 %! for i=1:N-1 # form 1-D Laplacian matrix
 %!   A(i:i+1,i:i+1) = [2 -1; -1 2];
 %! endfor
 %! A = [A, zeros(size(A)); zeros(size(A)), -A];
 %! b = rand (2*N,1);
 %! X = A \ b;  # X is the true solution
 %! maxit = 80;
-%! printf ("System condition number is %g\n", cond (A));
+%! fprintf ("System condition number is %g\n", cond (A));
 %! ## No preconditioner: the convergence is very slow!
 %!
 %! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit);
 %! clf;
 %! title ("Convergence history");
 %! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
 %! semilogy ([0:iter], resvec, "o-g;NO preconditioning: absolute residual;");
 %!
diff --git a/scripts/sparse/qmr.m b/scripts/sparse/qmr.m
--- a/scripts/sparse/qmr.m
+++ b/scripts/sparse/qmr.m
@@ -237,33 +237,33 @@ function [x, flag, relres, iter, resvec]
       eta0 = eta1;
       gamma0 = gamma1;
       rho0 = rho1;
     endfor
 
     relres = res1;
     if (flag == 1)
       if (nargout < 2)
-        printf ("qmr stopped at iteration %i ", iter);
-        printf ("without converging to the desired tolerance %e\n", tol);
-        printf ("because the maximum number of iterations was reached. ");
-        printf ("The iterate returned (number %i) has ", maxit);
-        printf ("relative residual %e\n", res1);
+        fprintf ("qmr stopped at iteration %i ", iter);
+        fprintf ("without converging to the desired tolerance %e\n", tol);
+        fprintf ("because the maximum number of iterations was reached. ");
+        fprintf ("The iterate returned (number %i) has ", maxit);
+        fprintf ("relative residual %e\n", res1);
       endif
     elseif (flag == 3)
       if (nargout < 2)
-        printf ("qmr stopped at iteration %i ", iter);
-        printf (" without converging to the desired tolerance %e\n", tol);
-        printf ("because the method stagnated.\n");
-        printf ("The iterate returned (number %i) ", iter);
-        printf ("has relative residual %e\n", res1);
+        fprintf ("qmr stopped at iteration %i ", iter);
+        fprintf (" without converging to the desired tolerance %e\n", tol);
+        fprintf ("because the method stagnated.\n");
+        fprintf ("The iterate returned (number %i) ", iter);
+        fprintf ("has relative residual %e\n", res1);
       endif
     elseif (nargout < 2)
-      printf ("qmr converged at iteration %i ", iter);
-      printf ("to a solution with relative residual %e\n", res1);
+      fprintf ("qmr converged at iteration %i ", iter);
+      fprintf ("to a solution with relative residual %e\n", res1);
     endif
   else
     print usage();
   endif
 endfunction
 
 
 %!demo
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
--- a/scripts/statistics/models/logistic_regression.m
+++ b/scripts/statistics/models/logistic_regression.m
@@ -156,31 +156,31 @@ function [theta, beta, dev, dl, d2l, p] 
   endwhile
 
   ## tidy up output
 
   theta = tb(1 : nz, 1);
   beta  = tb((nz + 1) : (nz + nx), 1);
 
   if (print >= 1)
-    printf ("\n");
-    printf ("Logistic Regression Results:\n");
-    printf ("\n");
-    printf ("Number of Iterations: %d\n", iter);
-    printf ("Deviance:             %f\n", dev);
-    printf ("Parameter Estimates:\n");
-    printf ("     Theta         S.E.\n");
+    fprintf ("\n");
+    fprintf ("Logistic Regression Results:\n");
+    fprintf ("\n");
+    fprintf ("Number of Iterations: %d\n", iter);
+    fprintf ("Deviance:             %f\n", dev);
+    fprintf ("Parameter Estimates:\n");
+    fprintf ("     Theta         S.E.\n");
     se = sqrt (diag (inv (-d2l)));
     for i = 1 : nz
-      printf ("   %8.4f     %8.4f\n", tb (i), se (i));
+      fprintf ("   %8.4f     %8.4f\n", tb (i), se (i));
     endfor
     if (nx > 0)
-      printf ("      Beta         S.E.\n");
+      fprintf ("      Beta         S.E.\n");
       for i = (nz + 1) : (nz + nx)
-        printf ("   %8.4f     %8.4f\n", tb (i), se (i));
+        fprintf ("   %8.4f     %8.4f\n", tb (i), se (i));
       endfor
     endif
   endif
 
   if (nargout == 6)
     if (nx > 0)
       e = ((x * beta) * ones (1, nz)) + ((y * 0 + 1) * theta');
     else
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -88,25 +88,25 @@ function [pval, f, df_b, df_w] = anova (
   df_w = n - k;
   v_b = SSB / df_b;
   v_w = SSW / df_w;
   f = v_b / v_w;
   pval = 1 - fcdf (f, df_b, df_w);
 
   if (nargout == 0)
     ## This eventually needs to be done more cleanly ...
-    printf ("\n");
-    printf ("One-way ANOVA Table:\n");
-    printf ("\n");
-    printf ("Source of Variation   Sum of Squares    df  Empirical Var\n");
-    printf ("*********************************************************\n");
-    printf ("Between Groups       %15.4f  %4d  %13.4f\n", SSB, df_b, v_b);
-    printf ("Within Groups        %15.4f  %4d  %13.4f\n", SSW, df_w, v_w);
-    printf ("---------------------------------------------------------\n");
-    printf ("Total                %15.4f  %4d\n", SST, n - 1);
-    printf ("\n");
-    printf ("Test Statistic f     %15.4f\n", f);
-    printf ("p-value              %15.4f\n", pval);
-    printf ("\n");
+    fprintf ("\n");
+    fprintf ("One-way ANOVA Table:\n");
+    fprintf ("\n");
+    fprintf ("Source of Variation   Sum of Squares    df  Empirical Var\n");
+    fprintf ("*********************************************************\n");
+    fprintf ("Between Groups       %15.4f  %4d  %13.4f\n", SSB, df_b, v_b);
+    fprintf ("Within Groups        %15.4f  %4d  %13.4f\n", SSW, df_w, v_w);
+    fprintf ("---------------------------------------------------------\n");
+    fprintf ("Total                %15.4f  %4d\n", SST, n - 1);
+    fprintf ("\n");
+    fprintf ("Test Statistic f     %15.4f\n", f);
+    fprintf ("p-value              %15.4f\n", pval);
+    fprintf ("\n");
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/bartlett_test.m b/scripts/statistics/tests/bartlett_test.m
--- a/scripts/statistics/tests/bartlett_test.m
+++ b/scripts/statistics/tests/bartlett_test.m
@@ -56,13 +56,13 @@ function [pval, chisq, df] = bartlett_te
   f_tot = sum (f);
   v_tot = sum (f .* v) / f_tot;
   c     = 1 + (sum (1 ./ f) - 1 / f_tot) / (3 * (k - 1));
   chisq = (f_tot * log (v_tot) - sum (f .* log (v))) / c;
   df    = k;
   pval  = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/chisquare_test_homogeneity.m b/scripts/statistics/tests/chisquare_test_homogeneity.m
--- a/scripts/statistics/tests/chisquare_test_homogeneity.m
+++ b/scripts/statistics/tests/chisquare_test_homogeneity.m
@@ -57,13 +57,13 @@ function [pval, chisq, df] = chisquare_t
   n_x   = sum (x * ones (1, df+1) < ones (l_x, 1) * c);
   l_y   = length (y);
   y     = reshape (y, l_y, 1);
   n_y   = sum (y * ones (1, df+1) < ones (l_y, 1) * c);
   chisq = l_x * l_y * sum ((n_x/l_x - n_y/l_y).^2 ./ (n_x + n_y));
   pval  = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ b/scripts/statistics/tests/chisquare_test_independence.m
@@ -43,13 +43,13 @@ function [pval, chisq, df] = chisquare_t
   df = (r - 1) * (s - 1);
   n = sum (sum (x));
   y = sum (x')' * sum (x) / n;
   x = (x - y) .^2 ./ y;
   chisq = sum (sum (x));
   pval = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -124,13 +124,13 @@ function t = cor_test (x, y, alt, method
     t.pval = cdf;
   else
     error ("cor_test: alternative '%s' not recognized", alt);
   endif
 
   t.alternative = alt;
 
   if (nargout == 0)
-    printf ("pval: %g\n", t.pval);
+    fprintf ("pval: %g\n", t.pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
--- a/scripts/statistics/tests/f_test_regression.m
+++ b/scripts/statistics/tests/f_test_regression.m
@@ -66,13 +66,13 @@ function [pval, f, df_num, df_den] = f_t
   df_den = T - k;
 
   [b, v] = ols (y, x);
   diff   = rr * b - r;
   f      = diff' * inv (rr * inv (x' * x) * rr') * diff / (q * v);
   pval   = 1 - fcdf (f, df_num, df_den);
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/hotelling_test.m b/scripts/statistics/tests/hotelling_test.m
--- a/scripts/statistics/tests/hotelling_test.m
+++ b/scripts/statistics/tests/hotelling_test.m
@@ -61,13 +61,13 @@ function [pval, Tsq] = hotelling_test (x
     error ("hotelling_test: X must be a matrix or vector");
   endif
 
   d    = mean (x) - m;
   Tsq  = n * d * (cov (x) \ d');
   pval = 1 - fcdf ((n-p) * Tsq / (p * (n-1)), p, n-p);
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/hotelling_test_2.m b/scripts/statistics/tests/hotelling_test_2.m
--- a/scripts/statistics/tests/hotelling_test_2.m
+++ b/scripts/statistics/tests/hotelling_test_2.m
@@ -75,13 +75,13 @@ function [pval, Tsq] = hotelling_test_2 
 
   d    = mean (x) - mean (y);
   S    = ((n_x - 1) * cov (x) + (n_y - 1) * cov (y)) / (n_x + n_y - 2);
   Tsq  = (n_x * n_y / (n_x + n_y)) * d * (S \ d');
   pval = 1 - fcdf ((n_x + n_y - p - 1) * Tsq / (p * (n_x + n_y - 2)),
                     p, n_x + n_y - p - 1);
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -101,17 +101,17 @@ function [pval, ks] = kolmogorov_smirnov
   elseif (strcmp (alt, "<"))
     ks   = - sqrt (n) * min (min ([z - (0:(n-1))/n; z - (1:n)/n]));
     pval = exp (- 2 * ks^2);
   else
     error ("kolmogorov_smirnov_test: alternative %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("pval: %g\n", pval);
+    fprintf ("pval: %g\n", pval);
   endif
 
 endfunction
 
 
 ## test for recognition of unifcdf function
 %!assert (kolmogorov_smirnov_test (0:100, "unif", 0, 100), 1.0, eps)
 ## test for recognition of logistic_cdf function
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -93,13 +93,13 @@ function [pval, ks, d] = kolmogorov_smir
     d    = min (z);
     ks   = -sqrt (n) * d;
     pval = exp (-2 * ks^2);
   else
     error ("kolmogorov_smirnov_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -84,17 +84,17 @@ function [pval, k, df] = kruskal_wallis_
   ## Adjust the result to takes ties into account.
   sum_ties = sum (polyval ([1, 0, -1, 0], runlength (sort (p))));
   k /= (1 - sum_ties / (n^3 - n));
 
   df = m - 1;
   pval = 1 - chi2cdf (k, df);
 
   if (nargout == 0)
-    printf ("pval: %g\n", pval);
+    fprintf ("pval: %g\n", pval);
   endif
 
 endfunction
 
 
 ## Test with ties
 %!assert (abs (kruskal_wallis_test ([86 86], [74]) - 0.157299207050285) < 0.0000000000001)
 
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -131,35 +131,35 @@ function manova (x, g)
     ## Pillai-Bartlett
     ## ===============
 
     PB = sum (l ./ (1 + l));
 
     df_den = theta * (2 * v + theta + 1);
     PB_pval = 1 - fcdf (PB * df_den / df_num, df_num, df_den);
 
-    printf ("\n");
-    printf ("One-way MANOVA Table:\n");
-    printf ("\n");
-    printf ("Test             Test Statistic      Approximate p\n");
-    printf ("**************************************************\n");
-    printf ("Wilks            %10.4f           %10.9f \n", Lambda, W_pval_1);
-    printf ("                                      %10.9f \n", W_pval_2);
-    printf ("Hotelling-Lawley %10.4f           %10.9f \n", HL, HL_pval);
-    printf ("Pillai-Bartlett  %10.4f           %10.9f \n", PB, PB_pval);
-    printf ("\n");
+    fprintf ("\n");
+    fprintf ("One-way MANOVA Table:\n");
+    fprintf ("\n");
+    fprintf ("Test             Test Statistic      Approximate p\n");
+    fprintf ("**************************************************\n");
+    fprintf ("Wilks            %10.4f           %10.9f \n", Lambda, W_pval_1);
+    fprintf ("                                      %10.9f \n", W_pval_2);
+    fprintf ("Hotelling-Lawley %10.4f           %10.9f \n", HL, HL_pval);
+    fprintf ("Pillai-Bartlett  %10.4f           %10.9f \n", PB, PB_pval);
+    fprintf ("\n");
 
   endif
 
-  printf ("\n");
-  printf ("MANOVA Results:\n");
-  printf ("\n");
-  printf ("# of groups:    %d\n", k);
-  printf ("# of samples:   %d\n", n);
-  printf ("# of variables: %d\n", p);
-  printf ("\n");
-  printf ("Wilks' Lambda:  %5.4f\n", Lambda);
-  printf ("Approximate p:  %10.9f (chisquare approximation)\n", W_pval_1);
-  printf ("                 %10.9f (F approximation)\n", W_pval_2);
-  printf ("\n");
+  fprintf ("\n");
+  fprintf ("MANOVA Results:\n");
+  fprintf ("\n");
+  fprintf ("# of groups:    %d\n", k);
+  fprintf ("# of samples:   %d\n", n);
+  fprintf ("# of variables: %d\n", p);
+  fprintf ("\n");
+  fprintf ("Wilks' Lambda:  %5.4f\n", Lambda);
+  fprintf ("Approximate p:  %10.9f (chisquare approximation)\n", W_pval_1);
+  fprintf ("                 %10.9f (F approximation)\n", W_pval_2);
+  fprintf ("\n");
 
 endfunction
 
diff --git a/scripts/statistics/tests/mcnemar_test.m b/scripts/statistics/tests/mcnemar_test.m
--- a/scripts/statistics/tests/mcnemar_test.m
+++ b/scripts/statistics/tests/mcnemar_test.m
@@ -53,13 +53,13 @@ function [pval, chisq, df] = mcnemar_tes
   else
     num = abs (x - x') .^ 2;
   endif
 
   chisq = sum (sum (triu (num ./ (x + x'), 1)));
   pval = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
--- a/scripts/statistics/tests/prop_test_2.m
+++ b/scripts/statistics/tests/prop_test_2.m
@@ -70,13 +70,13 @@ function [pval, z] = prop_test_2 (x1, n1
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("prop_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/run_test.m b/scripts/statistics/tests/run_test.m
--- a/scripts/statistics/tests/run_test.m
+++ b/scripts/statistics/tests/run_test.m
@@ -49,13 +49,13 @@ function [pval, chisq] = run_test (x)
 
   n = rows (x);
   r = run_count (x, 6) - n * b * ones (1, columns (x));
 
   chisq = diag (r' * A * r)' / n;
   pval  = chi2cdf (chisq, 6);
 
   if (nargout == 0)
-    printf ("pval: %g\n", pval);
+    fprintf ("pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -73,13 +73,13 @@ function [pval, b, n] = sign_test (x, y,
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("sign_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -72,17 +72,17 @@ function [pval, t, df] = t_test (x, m, a
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("t_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
 
 %!test
 %! ## Two-sided (also the default option)
 %! x = rand (10,1); n = length (x);
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -73,13 +73,13 @@ function [pval, t, df] = t_test_2 (x, y,
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("t_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -87,13 +87,13 @@ function [pval, t, df] = t_test_regressi
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("t_test_regression: the value '%s' for alt is not possible", alt);
   endif
 
   if (nargout == 0)
-    printf ("pval: %g\n", pval);
+    fprintf ("pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -76,13 +76,13 @@ function [pval, z] = u_test (x, y, alt)
     pval = cdf;
   elseif (strcmp (alt, "<"))
     pval = 1 - cdf;
   else
     error ("u_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
--- a/scripts/statistics/tests/var_test.m
+++ b/scripts/statistics/tests/var_test.m
@@ -69,13 +69,13 @@ function [pval, f, df_num, df_den] = var
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("var_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("pval: %g\n", pval);
+    fprintf ("pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
--- a/scripts/statistics/tests/welch_test.m
+++ b/scripts/statistics/tests/welch_test.m
@@ -75,13 +75,13 @@ function [pval, t, df] = welch_test (x, 
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("welch_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -82,13 +82,13 @@ function [pval, z] = wilcoxon_test (x, y
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("wilcoxon_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    printf ("  pval: %g\n", pval);
+    fprintf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -78,17 +78,17 @@ function [pval, z] = z_test (x, m, v, al
   else
     error ("z_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     s = ["Z-test of mean(x) == %g against mean(x) %s %g,\n", ...
          "with known var(x) == %g:\n",                       ...
          "  pval = %g\n"];
-    printf (s, m, alt, m, v, pval);
+    fprintf (s, m, alt, m, v, pval);
   endif
 
 endfunction
 
 
 %!test
 %! ## Two-sided (also the default option)
 %! x = rand (10,1); n = length (x);
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -79,13 +79,13 @@ function [pval, z] = z_test_2 (x, y, v_x
     error ("z_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     s = ["Two-sample Z-test of mean(x) == mean(y) against ", ...
          "mean(x) %s mean(y),\n",                            ...
          "with known var(x) == %g and var(y) == %g:\n",      ...
          "  pval = %g\n"];
-    printf (s, alt, v_x, v_y, pval);
+    fprintf (s, alt, v_x, v_y, pval);
   endif
 
 endfunction
 
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -140,23 +140,23 @@ endfunction
 %!demo
 %! strtok ("this is the life")
 %! # split at the first space, returning "this"
 
 %!demo
 %! s = "14*27+31"
 %! while (1)
 %!   [t, s] = strtok (s, "+-*/");
-%!   printf ("<%s>", t);
+%!   fprintf ("<%s>", t);
 %!   if (isempty (s))
 %!     break;
 %!   endif
-%!   printf ("<%s>", s(1));
+%!   fprintf ("<%s>", s(1));
 %! endwhile
-%! printf ("\n");
+%! fprintf ("\n");
 %! % ----------------------------------------------------
 %! % Demonstrates processing of an entire string split on
 %! % a variety of delimiters.  Tokens and delimiters are
 %! % printed one after another in angle brackets.
 
 ## Test the tokens for all cases
 %!assert (strtok (""), "");             # no string
 %!assert (strtok ("this"), "this");     # no delimiter in string
diff --git a/scripts/testfun/__run_test_suite__.m b/scripts/testfun/__run_test_suite__.m
--- a/scripts/testfun/__run_test_suite__.m
+++ b/scripts/testfun/__run_test_suite__.m
@@ -49,68 +49,68 @@ function [pass, fail, xfail, skip] = __r
     warning ("off", "Octave:deprecated-function");
     try
       fid = fopen (logfile, "wt");
       if (fid < 0)
         error ("__run_test_suite__: could not open %s for writing", logfile);
       endif
       test ("", "explain", fid);
       dp = dn = dxf = dsk = 0;
-      puts ("\nIntegrated test scripts:\n\n");
+      fputs ("\nIntegrated test scripts:\n\n");
       for i = 1:length (fcndirs)
         [p, n, xf, sk] = run_test_script (fid, fcndirs{i});
         dp += p;
         dn += n;
         dxf += xf;
         dsk += sk;
       endfor
-      puts ("\nFixed test scripts:\n\n");
+      fputs ("\nFixed test scripts:\n\n");
       for i = 1:length (fixedtestdirs)
         [p, n, xf, sk] = run_test_dir (fid, fixedtestdirs{i});
         dp += p;
         dn += n;
         dxf += xf;
         dsk += sk;
       endfor
-      puts ("\nSummary:\n\n");
+      fputs ("\nSummary:\n\n");
       nfail = dn - dp - dxf;
-      printf ("  PASS    %6d\n", dp);
-      printf ("  FAIL    %6d\n", nfail);
+      fprintf ("  PASS    %6d\n", dp);
+      fprintf ("  FAIL    %6d\n", nfail);
       if (dxf > 0)
-        printf ("  XFAIL   %6d\n", dxf);
+        fprintf ("  XFAIL   %6d\n", dxf);
       endif
       if (dsk > 0)
-        printf ("  SKIPPED %6d\n", dsk);
+        fprintf ("  SKIPPED %6d\n", dsk);
       endif
-      puts ("\n");
-      printf ("See the file %s for additional details.\n", logfile);
+      fputs ("\n");
+      fprintf ("See the file %s for additional details.\n", logfile);
       if (dxf > 0)
-        puts ("\n");
-        puts ("Expected failures (listed as XFAIL above) are known bugs.\n");
-        puts ("Please help improve Octave by contributing fixes for them.\n");
+        fputs ("\n");
+        fputs ("Expected failures (listed as XFAIL above) are known bugs.\n");
+        fputs ("Please help improve Octave by contributing fixes for them.\n");
       endif
       if (dsk > 0)
-        puts ("\n");
-        puts ("Tests are most often skipped because the features they require\n");
-        puts ("have been disabled.  Features are most often disabled because\n");
-        puts ("they require dependencies that were not present when Octave\n");
-        puts ("was built.  The configure script should have printed a summary\n");
-        puts ("at the end of its run indicating which dependencies were not found.\n");
+        fputs ("\n");
+        fputs ("Tests are most often skipped because the features they require\n");
+        fputs ("have been disabled.  Features are most often disabled because\n");
+        fputs ("they require dependencies that were not present when Octave\n");
+        fputs ("was built.  The configure script should have printed a summary\n");
+        fputs ("at the end of its run indicating which dependencies were not found.\n");
       endif
 
       ## Weed out deprecated and private functions
       weed_idx = cellfun (@isempty, regexp (files_with_tests, '\<deprecated\>|\<private\>', 'once'));
       files_with_tests = files_with_tests(weed_idx);
       weed_idx = cellfun (@isempty, regexp (files_with_no_tests, '\<deprecated\>|\<private\>', 'once'));
       files_with_no_tests = files_with_no_tests(weed_idx);
 
       report_files_with_no_tests (files_with_tests, files_with_no_tests, ".m");
 
-      puts ("\nPlease help improve Octave by contributing tests for these files\n");
-      printf ("(see the list in the file %s).\n\n", logfile);
+      fputs ("\nPlease help improve Octave by contributing tests for these files\n");
+      fprintf ("(see the list in the file %s).\n\n", logfile);
 
       fprintf (fid, "\nFiles with no tests:\n\n%s",
                     list_in_columns (files_with_no_tests, 80));
       fclose (fid);
     catch
       disp (lasterr ());
     end_try_catch
   unwind_protect_cleanup
@@ -125,34 +125,34 @@ function [pass, fail, xfail, skip] = __r
     xfail = dxf;
     skip = xsk;
   endif
 
 endfunction
 
 function print_test_file_name (nm)
   filler = repmat (".", 1, 60-length (nm));
-  printf ("  %s %s", nm, filler);
+  fprintf ("  %s %s", nm, filler);
 endfunction
 
 function print_pass_fail (p, n, xf, sk)
   if ((n + sk) > 0)
-    printf (" PASS   %4d/%-4d", p, n);
+    fprintf (" PASS   %4d/%-4d", p, n);
     nfail = n - p - xf;
     if (nfail > 0)
-      printf ("\n%71s %3d", "FAIL ", nfail);
+      fprintf ("\n%71s %3d", "FAIL ", nfail);
     endif
     if (sk > 0)
-      printf ("\n%71s %3d", "SKIP ", sk);
+      fprintf ("\n%71s %3d", "SKIP ", sk);
     endif
     if (xf > 0)
-      printf ("\n%71s %3d", "XFAIL", xf);
+      fprintf ("\n%71s %3d", "XFAIL", xf);
     endif
   endif
-  puts ("\n");
+  fputs ("\n");
 endfunction
 
 function retval = has_functions (f)
   n = length (f);
   if (n > 3 && strcmpi (f((end-2):end), ".cc"))
     fid = fopen (f);
     if (fid >= 0)
       str = fread (fid, "*char")';
@@ -268,27 +268,26 @@ function [dp, dn, dxf, dsk] = run_test_s
         files_with_tests(end+1) = f;
       else
         ## To reduce the list length, only mark .cc files that contain
         ## DEFUN definitions.
         files_with_no_tests(end+1) = f;
       endif
     endif
   endfor
-  ##  printf("%s%s -> passes %d of %d tests\n", ident, d, dp, dn);
+  ##  fprintf("%s%s -> passes %d of %d tests\n", ident, d, dp, dn);
 endfunction
 
 function n = num_elts_matching_pattern (lst, pat)
   n = sum (! cellfun ("isempty", regexp (lst, pat, 'once')));
 endfunction
 
 function report_files_with_no_tests (with, without, typ)
   pat = ['\' typ "$"];
   n_with = num_elts_matching_pattern (with, pat);
   n_without = num_elts_matching_pattern (without, pat);
   n_tot = n_with + n_without;
-  printf ("\n%d (of %d) %s files have no tests.\n", n_without, n_tot, typ);
+  fprintf ("\n%d (of %d) %s files have no tests.\n", n_without, n_tot, typ);
 endfunction
 
 
 ## No test coverage for internal function.  It is tested through calling fcn.
 %!assert (1)
-
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -133,21 +133,21 @@ function demo (name, n = 0)
     endif
 
     ## Process each demo without failing
     try
       block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
       ## Use an environment without variables
       eval (["function __demo__ ()\n" block "\nendfunction"]);
       ## Display the code that will be executed before executing it
-      printf ("%s example %d:%s\n\n", name, doidx(i), block);
+      fprintf ("%s example %d:%s\n\n", name, doidx(i), block);
       __demo__;
     catch
       ## Let the programmer know which demo failed.
-      printf ("%s example %d: failed\n%s\n", name, doidx(i), lasterr ());
+      fprintf ("%s example %d: failed\n%s\n", name, doidx(i), lasterr ());
     end_try_catch
     clear __demo__;
   endfor
 
 endfunction
 
 
 %!demo
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -81,17 +81,17 @@ function [ex_code, ex_idx] = example (na
     if (n > 0)
       doidx = n;
     else
       doidx = 1:length (idx) - 1;
     endif
 
     for i = 1:length (doidx)
       block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
-      printf ("%s example %d:%s\n\n", name, doidx(i), block);
+      fprintf ("%s example %d:%s\n\n", name, doidx(i), block);
     endfor
   endif
 
 endfunction
 
 
 ## WARNING: don't modify the demos without modifying the tests!
 %!demo
diff --git a/scripts/testfun/private/compare_plot_demos.m b/scripts/testfun/private/compare_plot_demos.m
--- a/scripts/testfun/private/compare_plot_demos.m
+++ b/scripts/testfun/private/compare_plot_demos.m
@@ -93,28 +93,28 @@ function compare_plot_demos (varargin)
         delete (["*." arg.fmt]);
       endif
       if (! strcmp (arg.toolkits{n}, "matlab"))
         close all;
         graphics_toolkit (arg.toolkits{n});
         try
           eval (fcn_name);
         catch
-          printf ("Error running plot demos for ""%s"" toolkit\n",
+          fprintf ("Error running plot demos for ""%s"" toolkit\n",
                   arg.toolkits{n});
           disp (lasterror);
         end_try_catch
       endif
       cd (cwd);
     endfor
   unwind_protect_cleanup
     rmpath (cwd);
   end_unwind_protect
   if (! strcmp (arg.toolkits, "matlab"))
     ## Generate the html comparison of the images
     html_compare_plot_demos (arg.toolkits);
   else
     ## We need to run matlab manually before the html page can be created
-    printf ('\nNow run %s in Matlab.\nAfter this run html_compare_plot_demos,\n', arg.fcn_file);
-    printf ('for example html_compare_plot_demos ({"fltk", "gnuplot", "matlab"}), to create the html page.\n');
+    fprintf ('\nNow run %s in Matlab.\nAfter this run html_compare_plot_demos,\n', arg.fcn_file);
+    fprintf ('for example html_compare_plot_demos ({"fltk", "gnuplot", "matlab"}), to create the html page.\n');
   endif
 endfunction
 
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -68,17 +68,17 @@ function run_all_demos (directory, do_cl
     f = flist{i};
     if ((length (f) > 2 && strcmpi (f((end-1):end), ".m"))
         || (length (f) > 3 && strcmpi (f((end-2):end), ".cc")))
       f = fullfile (directory, f);
       if (has_demos (f))
         try
           demo (f);
         catch
-          printf ("error: %s\n\n", lasterror ().message);
+          fprintf ("error: %s\n\n", lasterror ().message);
         end_try_catch
         if (i != numel (flist))
           input ("Press <enter> to continue: ", "s");
         endif
       endif
     elseif (f(1) == "@")
       f = fullfile (directory, f);
       if (isdir (f))
diff --git a/scripts/testfun/runtests.m b/scripts/testfun/runtests.m
--- a/scripts/testfun/runtests.m
+++ b/scripts/testfun/runtests.m
@@ -60,17 +60,17 @@ function runtests (directory)
   endfor
 
 endfunction
 
 function run_all_tests (directory, do_class_dirs)
   flist = readdir (directory);
   dirs = {};
   no_tests = {};
-  printf ("Processing files in %s:\n\n", directory);
+  fprintf ("Processing files in %s:\n\n", directory);
   fflush (stdout);
   for i = 1:numel (flist)
     f = flist{i};
     if ((length (f) > 2 && strcmpi (f((end-1):end), ".m"))
         || (length (f) > 3 && strcmpi (f((end-2):end), ".cc")))
       ff = fullfile (directory, f);
       if (has_tests (ff))
         print_test_file_name (f);
@@ -83,18 +83,18 @@ function run_all_tests (directory, do_cl
     elseif (f(1) == "@")
       f = fullfile (directory, f);
       if (isdir (f))
         dirs(end+1) = f;
       endif
     endif
   endfor
   if (! isempty (no_tests))
-    printf ("\nThe following files in %s have no tests:\n\n", directory);
-    printf ("%s", list_in_columns (no_tests));
+    fprintf ("\nThe following files in %s have no tests:\n\n", directory);
+    fprintf ("%s", list_in_columns (no_tests));
   endif
 
   ## Recurse into class directories since they are implied in the path
   if (do_class_dirs)
     for i = 1:numel (dirs)
       d = dirs{i};
       run_all_tests (d, false);
     endfor
@@ -129,30 +129,29 @@ function retval = has_tests (f)
                                      'lineanchors', 'once'));
   else
     error ("runtests: fopen failed: %s", f);
   endif
 endfunction
 
 function print_pass_fail (n, p, xf)
   if (n > 0)
-    printf (" PASS %4d/%-4d", p, n);
+    fprintf (" PASS %4d/%-4d", p, n);
     nfail = n - p;
     if (nfail > 0)
       if (nfail != xf)
-        printf (" FAIL %d", nfail - xf);
+        fprintf (" FAIL %d", nfail - xf);
       else
-        printf (" XFAIL %d", xf);
+        fprintf (" XFAIL %d", xf);
       endif
     endif
   endif
-  puts ("\n");
+  fputs ("\n");
 endfunction
 
 function print_test_file_name (nm)
   filler = repmat (".", 1, 55-length (nm));
-  printf ("  %s %s", nm, filler);
+  fprintf ("  %s %s", nm, filler);
 endfunction
 
 
 %!error runtests ("foo", 1)
 %!error <DIRECTORY argument> runtests ("#_TOTALLY_/_INVALID_/_PATHNAME_#")
-
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -206,17 +206,17 @@ function [__order, __test_n, __tnew, __t
   endif
 
   ## Run the tests.
   for k = 1:length (__test_n)
     n = __test_n(k);
     eval (__init);
 
     if (do_display)
-      printf ("n%i = %i  ", k, n);
+      fprintf ("n%i = %i  ", k, n);
       fflush (stdout);
     endif
 
     eval (["__t = time();" __f1 "__v1=ans; __t = time()-__t;"]);
     if (__t < 0.25)
       eval (["__t2 = time();" __f1 "__t2 = time()-__t2;"]);
       eval (["__t3 = time();" __f1 "__t3 = time()-__t3;"]);
       __t = min ([__t, __t2, __t3]);
@@ -296,17 +296,17 @@ function [__order, __test_n, __tnew, __t
             ["*-g;" strrep(__f1,";",".") ";"],
             __test_n, __torig*1000,
             ["*-r;" strrep(__f2,";",".") ";"]);
     title ({"Execution Times", ["init: " __init]});
     xlabel ("test length");
     ylabel ("best execution time (ms)");
 
     ratio = mean (__torig ./ __tnew);
-    printf ("\n\nMean runtime ratio = %.3g for '%s' vs '%s'\n",
+    fprintf ("\n\nMean runtime ratio = %.3g for '%s' vs '%s'\n",
             ratio, __f2, __f1);
 
   endif
 
   if (do_display)
 
     ## Plot time complexity approximation (using milliseconds).
     figure;   # Open second plot window
@@ -332,19 +332,19 @@ function [__order, __test_n, __tnew, __t
       time = sprintf ("%g ms", dt*1e3);
     elseif (log10 (dt) >= -6.5)
       time = sprintf ("%g us", dt*1e6);
     else
       time = sprintf ("%g ns", dt*1e9);
     endif
 
     ## Display nicely formatted complexity.
-    printf ("\nFor %s:\n", __f1);
-    printf ("  asymptotic power: %s\n", order);
-    printf ("  approximate time per operation: %s\n", time);
+    fprintf ("\nFor %s:\n", __f1);
+    fprintf ("  asymptotic power: %s\n", order);
+    fprintf ("  approximate time per operation: %s\n", time);
 
   endif
 
 endfunction
 
 
 ## FIXME: Demos with declared functions do not work.  See bug #31815.
 ##        A workaround has been hacked by not declaring the functions
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -646,29 +646,29 @@ function [__n, __nmax, __nxfail, __nskip
   endfor
 
   ## Clear any functions created during test run
   eval (__clearfcn, "");
 
   if (nargout == 0)
     if (__tests || __xfail || __xskip)
       if (__xfail)
-        printf ("PASSES %d out of %d test%s (%d expected failure%s)\n",
+        fprintf ("PASSES %d out of %d test%s (%d expected failure%s)\n",
                 __successes, __tests, ifelse (__tests > 1, "s", ""),
                 __xfail, ifelse (__xfail > 1, "s", ""));
       else
-        printf ("PASSES %d out of %d test%s\n", __successes, __tests,
+        fprintf ("PASSES %d out of %d test%s\n", __successes, __tests,
                ifelse (__tests > 1, "s", ""));
       endif
       if (__xskip)
-        printf ("Skipped %d test%s due to missing features\n", __xskip,
+        fprintf ("Skipped %d test%s due to missing features\n", __xskip,
                 ifelse (__xskip > 1, "s", ""));
       endif
     else
-      printf ("%s%s has no tests available\n", __signal_empty, __file);
+      fprintf ("%s%s has no tests available\n", __signal_empty, __file);
     endif
   elseif (__grabdemo)
     __n    = __demo_code;
     __nmax = __demo_idx;
   elseif (nargout == 1)
     __n = __all_success;
   else
     __n      = __successes;
diff --git a/scripts/time/calendar.m b/scripts/time/calendar.m
--- a/scripts/time/calendar.m
+++ b/scripts/time/calendar.m
@@ -75,19 +75,19 @@ function varargout = calendar (varargin)
       pos = weekday (dayone) + d - 1;
       idx = 6*pos + fix (pos / 7.1) - ifelse (d < 10, 1, 2);
       str(idx) = "*";
     endif
 
     ## Display the calendar.
     s.year = y - 1900;
     s.mon = m - 1;
-    puts (strftime ("                    %b %Y\n", s));
-    puts ("     S     M    Tu     W    Th     F     S\n");
-    puts (str);
+    fputs (strftime ("                    %b %Y\n", s));
+    fputs ("     S     M    Tu     W    Th     F     S\n");
+    fputs (str);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Calendar for current month
 %! calendar ()
@@ -96,9 +96,8 @@ endfunction
 %! ## Calendar for October, 1957
 %! calendar (1957, 10)
 
 %!assert ((calendar(2000,2))'(2:31), [0:29])
 %!assert ((calendar(1957,10))'(2:33), [0:31])
 
 ## Test input validation
 %!error calendar (1,2,3)
-
diff --git a/test/io.tst b/test/io.tst
--- a/test/io.tst
+++ b/test/io.tst
@@ -257,27 +257,16 @@
 %! save ("-ascii", matrix_ascii, "matrix1");
 %! matrix2 = load (matrix_ascii);
 %! assert (matrix1, matrix2, 1e-9);
 %!
 %! delete (matrix_ascii);
 
 %!error <unable to find file> load ("")
 
-%% FIXME: This test is disabled as it writes to stdout and there is no easy
-%% way to recover output.  Need to spawn new octave process and pipe stdout
-%% somewhere to treat this case.
-%!#test
-%! puts ("foo\n");
-
-%!assert (puts (1),-1)
-
-%!error <Invalid call to puts> puts ()
-%!error <Invalid call to puts> puts (1, 2)
-
 %!assert (sscanf ('123456', '%10c'), '123456')
 %!assert (sscanf ('123456', '%10s'), '123456')
 
 %!assert (sscanf (['ab'; 'cd'], '%s'), 'acbd')
 
 %!assert (sscanf ('02:08:30', '%i:%i:%i'), [2; 0])
 %!assert (sscanf ('02:08:30', '%d:%d:%d'), [2; 8; 30])
 
@@ -330,18 +319,18 @@
 %! fclose (fid1);
 %! fid2 = fopen (nm,"r");
 %! str = fscanf (fid2,"%s");
 %! fclose (fid2);
 %! unlink (nm);
 %! assert (x, 8);
 %! assert (str, "test:1");
 
-%!error printf (1)
-%!error <Invalid call to printf> printf ()
+%!error fprintf (1)
+%!error <Invalid call to fprintf> fprintf ()
 
 %!test
 %! [s, msg, status] = sprintf ("%s: %d\n", "test", 1);
 %! assert (s == "test: 1\n" && ischar (msg) && status == 8);
 
 %!assert (sprintf ("%-+6.2f", Inf), "+Inf  ")
 %!assert (sprintf ("%-6.2f", Inf), "Inf   ")
 %!assert (sprintf ("%-+6.2f", nan), "+NaN  ")  # lowercase nan is part of test
@@ -511,21 +500,16 @@
 %!           error ("bombed!!");
 %!         endif
 %!       endif
 %!     endif
 %!   endif
 %! endif
 %! unlink (nm);
 
-%!assert (fputs (1, 1),-1)
-
-%!error <Invalid call to fputs> fputs ()
-%!error <Invalid call to fputs> fputs (1, "foo", 1)
-
 %!error fgetl ("foo", 1)
 
 %!error <Invalid call to fgetl> fgetl ()
 %!error <Invalid call to fgetl> fgetl (1, 2, 3)
 
 %!error fgets ("foo", 1)
 
 %!error <Invalid call to fgets> fgets ()
