# HG changeset patch
# User jwe
# Date 836929240 0
#      Tue Jul 09 16:20:40 1996 +0000
# Node ID 5a3f1d00a474fde945a8d1d4f8742fdb6060df45
# Parent  532542bd949310f4f3c2d567273b82d509ed7221
[project @ 1996-07-09 16:20:40 by jwe]

diff --git a/src/arith-ops.cc b/src/arith-ops.cc
--- a/src/arith-ops.cc
+++ b/src/arith-ops.cc
@@ -221,45 +221,45 @@ mx_stupid_bool_op (Matrix_bool_op op, do
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
-	    t.elem (i,j) = s < a.elem (i,j);
+	    t (i,j) = s < a (i,j);
 	    break;
 
 	  case Matrix_LE:
-	    t.elem (i,j) = s <= a.elem (i,j);
+	    t (i,j) = s <= a (i,j);
 	    break;
 
 	  case Matrix_EQ:
-	    t.elem (i,j) = s == a.elem (i,j);
+	    t (i,j) = s == a (i,j);
 	    break;
 
 	  case Matrix_GE:
-	    t.elem (i,j) = s >= a.elem (i,j);
+	    t (i,j) = s >= a (i,j);
 	    break;
 
 	  case Matrix_GT:
-	    t.elem (i,j) = s > a.elem (i,j);
+	    t (i,j) = s > a (i,j);
 	    break;
 
 	  case Matrix_NE:
-	    t.elem (i,j) = s != a.elem (i,j);
+	    t (i,j) = s != a (i,j);
 	    break;
 
 	  case Matrix_AND:
-	    t.elem (i,j) = s && a.elem (i,j);
+	    t (i,j) = s && a (i,j);
 	    break;
 
 	  case Matrix_OR:
-	    t.elem (i,j) = s || a.elem (i,j);
+	    t (i,j) = s || a (i,j);
 	    break;
 
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
@@ -284,45 +284,45 @@ mx_stupid_bool_op (Matrix_bool_op op, do
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
-	    t.elem (i,j) = s < real (a.elem (i,j));
+	    t (i,j) = s < real (a (i,j));
 	    break;
 
 	  case Matrix_LE:
-	    t.elem (i,j) = s <= real (a.elem (i,j));
+	    t (i,j) = s <= real (a (i,j));
 	    break;
 
 	  case Matrix_EQ:
-	    t.elem (i,j) = s == a.elem (i,j);
+	    t (i,j) = s == a (i,j);
 	    break;
 
 	  case Matrix_GE:
-	    t.elem (i,j) = s >= real (a.elem (i,j));
+	    t (i,j) = s >= real (a (i,j));
 	    break;
 
 	  case Matrix_GT:
-	    t.elem (i,j) = s > real (a.elem (i,j));
+	    t (i,j) = s > real (a (i,j));
 	    break;
 
 	  case Matrix_NE:
-	    t.elem (i,j) = s != a.elem (i,j);
+	    t (i,j) = s != a (i,j);
 	    break;
 
 	  case Matrix_AND:
-	    t.elem (i,j) = s && (a.elem (i,j) != 0.0);
+	    t (i,j) = s && (a (i,j) != 0.0);
 	    break;
 
 	  case Matrix_OR:
-	    t.elem (i,j) = s || (a.elem (i,j) != 0.0);
+	    t (i,j) = s || (a (i,j) != 0.0);
 	    break;
 
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
@@ -347,45 +347,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
-	    t.elem (i,j) = a.elem (i,j) < s;
+	    t (i,j) = a (i,j) < s;
 	    break;
 
 	  case Matrix_LE:
-	    t.elem (i,j) = a.elem (i,j) <= s;
+	    t (i,j) = a (i,j) <= s;
 	    break;
 
 	  case Matrix_EQ:
-	    t.elem (i,j) = a.elem (i,j) == s;
+	    t (i,j) = a (i,j) == s;
 	    break;
 
 	  case Matrix_GE:
-	    t.elem (i,j) = a.elem (i,j) >= s;
+	    t (i,j) = a (i,j) >= s;
 	    break;
 
 	  case Matrix_GT:
-	    t.elem (i,j) = a.elem (i,j) > s;
+	    t (i,j) = a (i,j) > s;
 	    break;
 
 	  case Matrix_NE:
-	    t.elem (i,j) = a.elem (i,j) != s;
+	    t (i,j) = a (i,j) != s;
 	    break;
 
 	  case Matrix_AND:
-	    t.elem (i,j) = a.elem (i,j) && s;
+	    t (i,j) = a (i,j) && s;
 	    break;
 
 	  case Matrix_OR:
-	    t.elem (i,j) = a.elem (i,j) || s;
+	    t (i,j) = a (i,j) || s;
 	    break;
 
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
@@ -410,45 +410,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
-	    t.elem (i,j) = a.elem (i,j) < real (s);
+	    t (i,j) = a (i,j) < real (s);
 	    break;
 
 	  case Matrix_LE:
-	    t.elem (i,j) = a.elem (i,j) <= real (s);
+	    t (i,j) = a (i,j) <= real (s);
 	    break;
 
 	  case Matrix_EQ:
-	    t.elem (i,j) = a.elem (i,j) == s;
+	    t (i,j) = a (i,j) == s;
 	    break;
 
 	  case Matrix_GE:
-	    t.elem (i,j) = a.elem (i,j) >= real (s);
+	    t (i,j) = a (i,j) >= real (s);
 	    break;
 
 	  case Matrix_GT:
-	    t.elem (i,j) = a.elem (i,j) > real (s);
+	    t (i,j) = a (i,j) > real (s);
 	    break;
 
 	  case Matrix_NE:
-	    t.elem (i,j) = a.elem (i,j) != s;
+	    t (i,j) = a (i,j) != s;
 	    break;
 
 	  case Matrix_AND:
-	    t.elem (i,j) = a.elem (i,j) && (s != 0.0);
+	    t (i,j) = a (i,j) && (s != 0.0);
 	    break;
 
 	  case Matrix_OR:
-	    t.elem (i,j) = a.elem (i,j) || (s != 0.0);
+	    t (i,j) = a (i,j) || (s != 0.0);
 	    break;
 
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
@@ -476,45 +476,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   Matrix c (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
-	    c.elem (i, j) = a.elem (i, j) <  b.elem (i, j);
+	    c (i, j) = a (i, j) <  b (i, j);
 	    break;
 
 	  case Matrix_LE:
-	    c.elem (i, j) = a.elem (i, j) <= b.elem (i, j);
+	    c (i, j) = a (i, j) <= b (i, j);
 	    break;
 
 	  case Matrix_EQ:
-	    c.elem (i, j) = a.elem (i, j) == b.elem (i, j);
+	    c (i, j) = a (i, j) == b (i, j);
 	    break;
 
 	  case Matrix_GE:
-	    c.elem (i, j) = a.elem (i, j) >= b.elem (i, j);
+	    c (i, j) = a (i, j) >= b (i, j);
 	    break;
 
 	  case Matrix_GT:
-	    c.elem (i, j) = a.elem (i, j) >  b.elem (i, j);
+	    c (i, j) = a (i, j) >  b (i, j);
 	    break;
 
 	  case Matrix_NE:
-	    c.elem (i, j) = a.elem (i, j) != b.elem (i, j);
+	    c (i, j) = a (i, j) != b (i, j);
 	    break;
 
 	  case Matrix_AND:
-	    c.elem (i, j) = a.elem (i, j) && b.elem (i, j);
+	    c (i, j) = a (i, j) && b (i, j);
 	    break;
 
 	  case Matrix_OR:
-	    c.elem (i, j) = a.elem (i, j) || b.elem (i, j);
+	    c (i, j) = a (i, j) || b (i, j);
 	    break;
 
 	  default:
 	    panic_impossible ();
 	    break;
 	  }
       }
 
@@ -542,45 +542,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   Matrix c (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
-	    c.elem (i, j) = a.elem (i, j) <  real (b.elem (i, j));
+	    c (i, j) = a (i, j) <  real (b (i, j));
 	    break;
 
 	  case Matrix_LE:
-	    c.elem (i, j) = a.elem (i, j) <= real (b.elem (i, j));
+	    c (i, j) = a (i, j) <= real (b (i, j));
 	    break;
 
 	  case Matrix_EQ:
-	    c.elem (i, j) = a.elem (i, j) == b.elem (i, j);
+	    c (i, j) = a (i, j) == b (i, j);
 	    break;
 
 	  case Matrix_GE:
-	    c.elem (i, j) = a.elem (i, j) >= real (b.elem (i, j));
+	    c (i, j) = a (i, j) >= real (b (i, j));
 	    break;
 
 	  case Matrix_GT:
-	    c.elem (i, j) = a.elem (i, j) >  real (b.elem (i, j));
+	    c (i, j) = a (i, j) >  real (b (i, j));
 	    break;
 
 	  case Matrix_NE:
-	    c.elem (i, j) = a.elem (i, j) != b.elem (i, j);
+	    c (i, j) = a (i, j) != b (i, j);
 	    break;
 
 	  case Matrix_AND:
-	    c.elem (i, j) = a.elem (i, j) && (b.elem (i, j) != 0.0);
+	    c (i, j) = a (i, j) && (b (i, j) != 0.0);
 	    break;
 
 	  case Matrix_OR:
-	    c.elem (i, j) = a.elem (i, j) || (b.elem (i, j) != 0.0);
+	    c (i, j) = a (i, j) || (b (i, j) != 0.0);
 	    break;
 
 	  default:
 	    panic_impossible ();
 	    break;
 	  }
       }
   return c;
@@ -604,45 +604,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
-	    t.elem (i,j) = real (s) < a.elem (i,j);
+	    t (i,j) = real (s) < a (i,j);
 	    break;
 
 	  case Matrix_LE:
-	    t.elem (i,j) = real (s) <= a.elem (i,j);
+	    t (i,j) = real (s) <= a (i,j);
 	    break;
 
 	  case Matrix_EQ:
-	    t.elem (i,j) = s == a.elem (i,j);
+	    t (i,j) = s == a (i,j);
 	    break;
 
 	  case Matrix_GE:
-	    t.elem (i,j) = real (s) >= a.elem (i,j);
+	    t (i,j) = real (s) >= a (i,j);
 	    break;
 
 	  case Matrix_GT:
-	    t.elem (i,j) = real (s) > a.elem (i,j);
+	    t (i,j) = real (s) > a (i,j);
 	    break;
 
 	  case Matrix_NE:
-	    t.elem (i,j) = s != a.elem (i,j);
+	    t (i,j) = s != a (i,j);
 	    break;
 
 	  case Matrix_AND:
-	    t.elem (i,j) = (s != 0.0) && a.elem (i,j);
+	    t (i,j) = (s != 0.0) && a (i,j);
 	    break;
 
 	  case Matrix_OR:
-	    t.elem (i,j) = (s != 0.0) || a.elem (i,j);
+	    t (i,j) = (s != 0.0) || a (i,j);
 	    break;
 
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
@@ -667,45 +667,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
-	    t.elem (i,j) = real (s) < real (a.elem (i,j));
+	    t (i,j) = real (s) < real (a (i,j));
 	    break;
 
 	  case Matrix_LE:
-	    t.elem (i,j) = real (s) <= real (a.elem (i,j));
+	    t (i,j) = real (s) <= real (a (i,j));
 	    break;
 
 	  case Matrix_EQ:
-	    t.elem (i,j) = s == a.elem (i,j);
+	    t (i,j) = s == a (i,j);
 	    break;
 
 	  case Matrix_GE:
-	    t.elem (i,j) = real (s) >= real (a.elem (i,j));
+	    t (i,j) = real (s) >= real (a (i,j));
 	    break;
 
 	  case Matrix_GT:
-	    t.elem (i,j) = real (s) > real (a.elem (i,j));
+	    t (i,j) = real (s) > real (a (i,j));
 	    break;
 
 	  case Matrix_NE:
-	    t.elem (i,j) = s != a.elem (i,j);
+	    t (i,j) = s != a (i,j);
 	    break;
 
 	  case Matrix_AND:
-	    t.elem (i,j) = (s != 0.0) && (a.elem (i,j) != 0.0);
+	    t (i,j) = (s != 0.0) && (a (i,j) != 0.0);
 	    break;
 
 	  case Matrix_OR:
-	    t.elem (i,j) = (s != 0.0) || (a.elem (i,j) != 0.0);
+	    t (i,j) = (s != 0.0) || (a (i,j) != 0.0);
 	    break;
 
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
@@ -730,45 +730,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
-	    t.elem (i,j) = real (a.elem (i,j)) < s;
+	    t (i,j) = real (a (i,j)) < s;
 	    break;
 
 	  case Matrix_LE:
-	    t.elem (i,j) = real (a.elem (i,j)) <= s;
+	    t (i,j) = real (a (i,j)) <= s;
 	    break;
 
 	  case Matrix_EQ:
-	    t.elem (i,j) = a.elem (i,j) == s;
+	    t (i,j) = a (i,j) == s;
 	    break;
 
 	  case Matrix_GE:
-	    t.elem (i,j) = real (a.elem (i,j)) >= s;
+	    t (i,j) = real (a (i,j)) >= s;
 	    break;
 
 	  case Matrix_GT:
-	    t.elem (i,j) = real (a.elem (i,j)) > s;
+	    t (i,j) = real (a (i,j)) > s;
 	    break;
 
 	  case Matrix_NE:
-	    t.elem (i,j) = a.elem (i,j) != s;
+	    t (i,j) = a (i,j) != s;
 	    break;
 
 	  case Matrix_AND:
-	    t.elem (i,j) = (a.elem (i,j) != 0.0) && s;
+	    t (i,j) = (a (i,j) != 0.0) && s;
 	    break;
 
 	  case Matrix_OR:
-	    t.elem (i,j) = (a.elem (i,j) != 0.0) || s;
+	    t (i,j) = (a (i,j) != 0.0) || s;
 	    break;
 
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
@@ -793,45 +793,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   Matrix t (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
-	    t.elem (i,j) = real (a.elem (i,j)) < real (s);
+	    t (i,j) = real (a (i,j)) < real (s);
 	    break;
 
 	  case Matrix_LE:
-	    t.elem (i,j) = real (a.elem (i,j)) <= real (s);
+	    t (i,j) = real (a (i,j)) <= real (s);
 	    break;
 
 	  case Matrix_EQ:
-	    t.elem (i,j) = a.elem (i,j) == s;
+	    t (i,j) = a (i,j) == s;
 	    break;
 
 	  case Matrix_GE:
-	    t.elem (i,j) = real (a.elem (i,j)) >= real (s);
+	    t (i,j) = real (a (i,j)) >= real (s);
 	    break;
 
 	  case Matrix_GT:
-	    t.elem (i,j) = real (a.elem (i,j)) > real (s);
+	    t (i,j) = real (a (i,j)) > real (s);
 	    break;
 
 	  case Matrix_NE:
-	    t.elem (i,j) = a.elem (i,j) != s;
+	    t (i,j) = a (i,j) != s;
 	    break;
 
 	  case Matrix_AND:
-	    t.elem (i,j) = (a.elem (i,j) != 0.0) && (s != 0.0);
+	    t (i,j) = (a (i,j) != 0.0) && (s != 0.0);
 	    break;
 
 	  case Matrix_OR:
-	    t.elem (i,j) = (a.elem (i,j) != 0.0) || (s != 0.0);
+	    t (i,j) = (a (i,j) != 0.0) || (s != 0.0);
 	    break;
 
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
@@ -859,45 +859,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   Matrix c (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
-	    c.elem (i, j) = real (a.elem (i, j)) <  b.elem (i, j);
+	    c (i, j) = real (a (i, j)) <  b (i, j);
 	    break;
 
 	  case Matrix_LE:
-	    c.elem (i, j) = real (a.elem (i, j)) <= b.elem (i, j);
+	    c (i, j) = real (a (i, j)) <= b (i, j);
 	    break;
 
 	  case Matrix_EQ:
-	    c.elem (i, j) = a.elem (i, j) == b.elem (i, j);
+	    c (i, j) = a (i, j) == b (i, j);
 	    break;
 
 	  case Matrix_GE:
-	    c.elem (i, j) = real (a.elem (i, j)) >= b.elem (i, j);
+	    c (i, j) = real (a (i, j)) >= b (i, j);
 	    break;
 
 	  case Matrix_GT:
-	    c.elem (i, j) = real (a.elem (i, j)) >  b.elem (i, j);
+	    c (i, j) = real (a (i, j)) >  b (i, j);
 	    break;
 
 	  case Matrix_NE:
-	    c.elem (i, j) = a.elem (i, j) != b.elem (i, j);
+	    c (i, j) = a (i, j) != b (i, j);
 	    break;
 
 	  case Matrix_AND:
-	    c.elem (i, j) = (a.elem (i, j) != 0.0)  && b.elem (i, j);
+	    c (i, j) = (a (i, j) != 0.0)  && b (i, j);
 	    break;
 
 	  case Matrix_OR:
-	    c.elem (i, j) = (a.elem (i, j) != 0.0) || b.elem (i, j);
+	    c (i, j) = (a (i, j) != 0.0) || b (i, j);
 	    break;
 
 	  default:
 	    panic_impossible ();
 	    break;
 	  }
       }
   return c;
@@ -925,45 +925,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   Matrix c (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
-	    c.elem (i, j) = real (a.elem (i, j)) <  real (b.elem (i, j));
+	    c (i, j) = real (a (i, j)) <  real (b (i, j));
 	    break;
 
 	  case Matrix_LE:
-	    c.elem (i, j) = real (a.elem (i, j)) <= real (b.elem (i, j));
+	    c (i, j) = real (a (i, j)) <= real (b (i, j));
 	    break;
 
 	  case Matrix_EQ:
-	    c.elem (i, j) = a.elem (i, j) == b.elem (i, j);
+	    c (i, j) = a (i, j) == b (i, j);
 	    break;
 
 	  case Matrix_GE:
-	    c.elem (i, j) = real (a.elem (i, j)) >= real (b.elem (i, j));
+	    c (i, j) = real (a (i, j)) >= real (b (i, j));
 	    break;
 
 	  case Matrix_GT:
-	    c.elem (i, j) = real (a.elem (i, j)) >  real (b.elem (i, j));
+	    c (i, j) = real (a (i, j)) >  real (b (i, j));
 	    break;
 
 	  case Matrix_NE:
-	    c.elem (i, j) = a.elem (i, j) != b.elem (i, j);
+	    c (i, j) = a (i, j) != b (i, j);
 	    break;
 
 	  case Matrix_AND:
-	    c.elem (i, j) = (a.elem (i, j) != 0.0) && (b.elem (i, j) != 0.0);
+	    c (i, j) = (a (i, j) != 0.0) && (b (i, j) != 0.0);
 	    break;
 
 	  case Matrix_OR:
-	    c.elem (i, j) = (a.elem (i, j) != 0.0) || (b.elem (i, j) != 0.0);
+	    c (i, j) = (a (i, j) != 0.0) || (b (i, j) != 0.0);
 	    break;
 
 	  default:
 	    panic_impossible ();
 	    break;
 	  }
       }
 
diff --git a/src/balance.cc b/src/balance.cc
--- a/src/balance.cc
+++ b/src/balance.cc
@@ -196,18 +196,18 @@ where OPT is an optional single characte
 	      cbb = bb;
 
 	    // Compute magnitudes of elements for balancing purposes.
 	    // Surely there's a function I can call someplace!
 
 	    for (int i = 0; i < a_nr; i++)
 	      for (int j = 0; j < a_nc; j++)
 		{
-		  aa.elem (i, j) = abs (caa.elem (i, j));
-		  bb.elem (i, j) = abs (cbb.elem (i, j));
+		  aa (i, j) = abs (caa (i, j));
+		  bb (i, j) = abs (cbb (i, j));
 		}
 	  }
 
 	GEPBALANCE result (aa, bb, bal_job);
 
 	if (arg_a.is_complex_type () || arg_b.is_complex_type ())
 	  {
 	    caa = result.left_balancing_matrix () * caa
diff --git a/src/dassl.cc b/src/dassl.cc
--- a/src/dassl.cc
+++ b/src/dassl.cc
@@ -57,28 +57,28 @@ dassl_user_function (const ColumnVector&
   args(2) = t;
 
   if (nstates > 1)
     {
       Matrix m1 (nstates, 1);
       Matrix m2 (nstates, 1);
       for (int i = 0; i < nstates; i++)
 	{
-	  m1 (i, 0) = x.elem (i);
-	  m2 (i, 0) = xdot.elem (i);
+	  m1 (i, 0) = x (i);
+	  m2 (i, 0) = xdot (i);
 	}
       octave_value state (m1);
       octave_value deriv (m2);
       args(1) = deriv;
       args(0) = state;
     }
   else
     {
-      double d1 = x.elem (0);
-      double d2 = xdot.elem (0);
+      double d1 = x (0);
+      double d2 = xdot (0);
       octave_value state (d1);
       octave_value deriv (d2);
       args(1) = deriv;
       args(0) = state;
     }
 
   if (dassl_fcn)
     {
@@ -169,17 +169,17 @@ where x, xdot, and res are vectors, and 
     }
 
   if (state.capacity () != deriv.capacity ())
     {
       error ("dassl: x and xdot must have the same size");
       return retval;
     }
 
-  double tzero = out_times.elem (0);
+  double tzero = out_times (0);
 
   DAEFunc func (dassl_user_function);
   DASSL dae (state, deriv, tzero, func);
   dae.copy (dassl_opts);
 
   Matrix output;
   Matrix deriv_output;
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -102,32 +102,32 @@ map (d_dd_fcn f, double x, const Matrix&
 {
   int nr = y.rows ();
   int nc = y.columns ();
 
   Matrix retval (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      retval.elem (i, j) = f (x, y.elem (i, j));
+      retval (i, j) = f (x, y (i, j));
 
   return retval;
 }
 
 static Matrix
 map (d_dd_fcn f, const Matrix& x, double y)
 {
   int nr = x.rows ();
   int nc = x.columns ();
 
   Matrix retval (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      retval.elem (i, j) = f (x.elem (i, j), y);
+      retval (i, j) = f (x (i, j), y);
 
   return retval;
 }
 
 static Matrix
 map (d_dd_fcn f, const Matrix& x, const Matrix& y)
 {
   int x_nr = x.rows ();
@@ -137,17 +137,17 @@ map (d_dd_fcn f, const Matrix& x, const 
   int y_nc = y.columns ();
 
   assert (x_nr == y_nr && x_nc == y_nc);
 
   Matrix retval (x_nr, x_nc);
 
   for (int j = 0; j < x_nc; j++)
     for (int i = 0; i < x_nr; i++)
-      retval.elem (i, j) = f (x.elem (i, j), y.elem (i, j));
+      retval (i, j) = f (x (i, j), y (i, j));
 
   return retval;
 }
 
 DEFUN (atan2, args, ,
   "atan2 (Y, X): atan (Y / X) in range -pi to pi")
 {
   octave_value_list retval;
@@ -329,25 +329,25 @@ make_diag (const Matrix& v, int k)
       coff = 0;
     }
 
   if (nr == 1)
     {
       int n = nc + ABS (k);
       Matrix m (n, n, 0.0);
       for (int i = 0; i < nc; i++)
-	m.elem (i+roff, i+coff) = v.elem (0, i);
+	m (i+roff, i+coff) = v (0, i);
       retval = octave_value (m);
     }
   else
     {
       int n = nr + ABS (k);
       Matrix m (n, n, 0.0);
       for (int i = 0; i < nr; i++)
-	m.elem (i+roff, i+coff) = v.elem (i, 0);
+	m (i+roff, i+coff) = v (i, 0);
       retval = octave_value (m);
     }
 
   return retval;
 }
 
 static octave_value
 make_diag (const ComplexMatrix& v, int k)
@@ -371,25 +371,25 @@ make_diag (const ComplexMatrix& v, int k
       coff = 0;
     }
 
   if (nr == 1)
     {
       int n = nc + ABS (k);
       ComplexMatrix m (n, n, 0.0);
       for (int i = 0; i < nc; i++)
-	m.elem (i+roff, i+coff) = v.elem (0, i);
+	m (i+roff, i+coff) = v (0, i);
       retval = octave_value (m);
     }
   else
     {
       int n = nr + ABS (k);
       ComplexMatrix m (n, n, 0.0);
       for (int i = 0; i < nr; i++)
-	m.elem (i+roff, i+coff) = v.elem (i, 0);
+	m (i+roff, i+coff) = v (i, 0);
       retval = octave_value (m);
     }
 
   return retval;
 }
 
 static octave_value
 make_diag (const octave_value& arg)
@@ -470,23 +470,23 @@ make_diag (const octave_value& a, const 
 	{
 	  double d = a.double_value ();
 
 	  if (k == 0)
 	    retval = d;
 	  else if (k > 0)
 	    {
 	      Matrix m (n, n, 0.0);
-	      m.elem (0, k) = d;
+	      m (0, k) = d;
 	      retval = m;
 	    }
 	  else if (k < 0)
 	    {
 	      Matrix m (n, n, 0.0);
-	      m.elem (-k, 0) = d;
+	      m (-k, 0) = d;
 	      retval = m;
 	    }
 	}
       else if (a.is_matrix_type ())
 	{
 	  Matrix m = a.matrix_value ();
 
 	  int nr = m.rows ();
@@ -511,23 +511,23 @@ make_diag (const octave_value& a, const 
 	{
 	  Complex c = a.complex_value ();
 
 	  if (k == 0)
 	    retval = c;
 	  else if (k > 0)
 	    {
 	      ComplexMatrix m (n, n, 0.0);
-	      m.elem (0, k) = c;
+	      m (0, k) = c;
 	      retval = m;
 	    }
 	  else if (k < 0)
 	    {
 	      ComplexMatrix m (n, n, 0.0);
-	      m.elem (-k, 0) = c;
+	      m (-k, 0) = c;
 	      retval = m;
 	    }
 	}
       else if (a.is_matrix_type ())
 	{
 	  ComplexMatrix cm = a.complex_matrix_value ();
 
 	  int nr = cm.rows ();
@@ -621,18 +621,18 @@ m = size (x, 2): return number of column
   if (nargin == 1 && nargout < 3)
     {
       int nr = args(0).rows ();
       int nc = args(0).columns ();
 
       if (nargout == 0 || nargout == 1)
 	{
 	  Matrix m (1, 2);
-	  m.elem (0, 0) = nr;
-	  m.elem (0, 1) = nc;
+	  m (0, 0) = nr;
+	  m (0, 1) = nc;
 	  retval = m;
 	}
       else if (nargout == 2)
 	{
 	  retval(1) = (double) nc;
 	  retval(0) = (double) nr;
 	}
     }
@@ -840,18 +840,18 @@ get_dimensions (const octave_value& a, c
 
       if ((nr == 1 && nc == 2) || (nr == 2 && nc == 1))
 	{
 	  ColumnVector v = a.vector_value ();
 
 	  if (error_state)
 	    return;
 
-	  nr = NINT (v.elem (0));
-	  nc = NINT (v.elem (1));
+	  nr = NINT (v (0));
+	  nc = NINT (v (1));
 	}
       else
 	warning ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
     }
 
   check_dimensions (nr, nc, warn_for); // May set error_state.
 }
 
@@ -965,17 +965,17 @@ identity_matrix (const octave_value& a)
     return octave_value ();
 
   Matrix m (nr, nc, 0.0);
 
   if (nr > 0 && nc > 0)
     {
       int n = MIN (nr, nc);
       for (int i = 0; i < n; i++)
-	m.elem (i, i) = 1.0;
+	m (i, i) = 1.0;
     }
 
   return m;
 }
 
 static octave_value
 identity_matrix (const octave_value& a, const octave_value& b)
 {
@@ -986,17 +986,17 @@ identity_matrix (const octave_value& a, 
     return octave_value ();
 
   Matrix m (nr, nc, 0.0);
 
   if (nr > 0 && nc > 0)
     {
       int n = MIN (nr, nc);
       for (int i = 0; i < n; i++)
-	m.elem (i, i) = 1.0;
+	m (i, i) = 1.0;
     }
 
   return m;
 }
 
 DEFUN (eye, args, ,
   "eye (N), eye (N, M), eye (X): create an identity matrix")
 {
diff --git a/src/filter.cc b/src/filter.cc
--- a/src/filter.cc
+++ b/src/filter.cc
@@ -60,17 +60,17 @@ filter (MArray<T>& b, MArray<T>& a, MArr
   b.resize (ab_len, 0.0);
 
   if (si.length () != ab_len - 1)
     {
       error ("filter: si must be a vector of length max (length (a), length (b)) - 1");
       return y;
     }
 
-  T norm = a.elem (0);
+  T norm = a (0);
 
   if (norm == 0.0)
     {
       error ("filter: the first element of a must be non-zero");
       return y;
     }
 
   y.resize (x_len, 0.0);
@@ -82,51 +82,51 @@ filter (MArray<T>& b, MArray<T>& a, MArr
     {
       a.resize (ab_len, 0.0);
 
       if (norm != 1.0)
 	a = a / norm;
 
       for (int i = 0; i < x_len; i++)
 	{
-	  y.elem (i) = si.elem (0) + b.elem (0) * x.elem (i);
+	  y (i) = si (0) + b (0) * x (i);
 
 	  if (si_len > 1)
 	    {
 	      for (int j = 0; j < si_len - 1; j++)
-		si.elem (j) = si.elem (j+1) - a.elem (j+1) * y.elem (i)
-		  + b.elem (j+1) * x.elem (i);
+		si (j) = si (j+1) - a (j+1) * y (i)
+		  + b (j+1) * x (i);
 
-	      si.elem (si_len-1) = b.elem (si_len) * x.elem (i)
-		- a.elem (si_len) * y.elem (i);
+	      si (si_len-1) = b (si_len) * x (i)
+		- a (si_len) * y (i);
 	    }
 	  else
-	    si.elem (0) = b.elem (si_len) * x.elem (i)
-	      - a.elem (si_len) * y.elem (i);
+	    si (0) = b (si_len) * x (i)
+	      - a (si_len) * y (i);
 	}
     }
   else if (si_len > 0)
     {
       for (int i = 0; i < x_len; i++)
 	{
-	  y.elem (i) = si.elem (0) + b.elem (0) * x.elem (i);
+	  y (i) = si (0) + b (0) * x (i);
 
 	  if (si_len > 1)
 	    {
 	      for (int j = 0; j < si_len - 1; j++)
-		si.elem (j) = si.elem (j+1) + b.elem (j+1) * x.elem (i);
+		si (j) = si (j+1) + b (j+1) * x (i);
 
-	      si.elem (si_len-1) = b.elem (si_len) * x.elem (i);
+	      si (si_len-1) = b (si_len) * x (i);
 	    }
 	  else
-	    si.elem (0) = b.elem (1) * x.elem (i);
+	    si (0) = b (1) * x (i);
 	}
     }
   else
-    y = b.elem (0) * x;
+    y = b (0) * x;
 
   return y;
 }
 
 extern MArray<double>
 filter (MArray<double>&, MArray<double>&, MArray<double>&,
 	MArray<double>&);
 
diff --git a/src/find.cc b/src/find.cc
--- a/src/find.cc
+++ b/src/find.cc
@@ -82,33 +82,33 @@ find_nonzero_elem_idx (const Matrix& m, 
 {
   int count = 0;
   int m_nr = m.rows ();
   int m_nc = m.columns ();
 
   int i, j;
   for (j = 0; j < m_nc; j++)
     for (i = 0; i < m_nr; i++)
-      if (m.elem (i, j) != 0.0)
+      if (m (i, j) != 0.0)
 	count++;
 
   octave_value_list retval (((nargout == 0) ? 1 : nargout), Matrix ());
 
   if (count == 0)
     return retval;
 
   ColumnVector i_idx (count);
   ColumnVector j_idx (count);
   ColumnVector v (count);
 
   count = 0;
   for (j = 0; j < m_nc; j++)
     for (i = 0; i < m_nr; i++)
       {
-	double d = m.elem (i, j);
+	double d = m (i, j);
 	if (d != 0.0)
 	  {
 	    i_idx (count) = i + 1;
 	    j_idx (count) = j + 1;
 	    v (count) = d;
 	    count++;
 	  }
       }
@@ -122,33 +122,33 @@ find_nonzero_elem_idx (const ComplexMatr
 {
   int count = 0;
   int m_nr = m.rows ();
   int m_nc = m.columns ();
 
   int i, j;
   for (j = 0; j < m_nc; j++)
     for (i = 0; i < m_nr; i++)
-      if (m.elem (i, j) != 0.0)
+      if (m (i, j) != 0.0)
 	count++;
 
   octave_value_list retval (((nargout == 0) ? 1 : nargout), Matrix ());
 
   if (count == 0)
     return retval;
 
   ColumnVector i_idx (count);
   ColumnVector j_idx (count);
   ComplexColumnVector v (count);
 
   count = 0;
   for (j = 0; j < m_nc; j++)
     for (i = 0; i < m_nr; i++)
       {
-	Complex c = m.elem (i, j);
+	Complex c = m (i, j);
 	if (c != 0.0)
 	  {
 	    i_idx (count) = i + 1;
 	    j_idx (count) = j + 1;
 	    v (count) = c;
 	    count++;
 	  }
       }
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -87,23 +87,23 @@ fsolve_user_function (const ColumnVector
 
   octave_value_list args;
   args.resize (1);
 
   if (n > 1)
     {
       Matrix m (n, 1);
       for (int i = 0; i < n; i++)
-	m (i, 0) = x.elem (i);
+	m (i, 0) = x (i);
       octave_value vars (m);
       args(0) = vars;
     }
   else
     {
-      double d = x.elem (0);
+      double d = x (0);
       octave_value vars (d);
       args(0) = vars;
     }
 
   if (fsolve_fcn)
     {
       octave_value_list tmp = fsolve_fcn->eval (0, 1, args);
       if (tmp.length () > 0 && tmp(0).is_defined ())
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1140,17 +1140,17 @@ read_mat_binary_data (istream& is, const
 	  error ("load: reading imaginary matrix data for `%s'", name);
 	  goto data_read_error;
 	}
 
       ComplexMatrix ctmp (nr, nc);
 
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  ctmp.elem (i, j) = Complex (re.elem (i, j), im.elem (i, j));
+	  ctmp (i, j) = Complex (re (i, j), im (i, j));
 
       tc = ctmp;
     }
   else
     tc = re;
 
   if (type == 1)
     tc = tc.convert_to_str ();
@@ -1818,21 +1818,21 @@ strip_infnan (const Matrix& m)
 
   Matrix retval (nr, nc);
 
   int k = 0;
   for (int i = 0; i < nr; i++)
     {
       for (int j = 0; j < nc; j++)
 	{
-	  double d = m.elem (i, j);
+	  double d = m (i, j);
 	  if (xisnan (d))
 	    goto next_row;
 	  else
-	    retval.elem (k, j) = xisinf (d) ? (d > 0 ? OCT_RBV : -OCT_RBV) : d;
+	    retval (k, j) = xisinf (d) ? (d > 0 ? OCT_RBV : -OCT_RBV) : d;
 	}
       k++;
 
     next_row:
       continue;
     }
 
   if (k > 0)
@@ -1849,28 +1849,28 @@ strip_infnan (const ComplexMatrix& m)
 
   ComplexMatrix retval (nr, nc);
 
   int k = 0;
   for (int i = 0; i < nr; i++)
     {
       for (int j = 0; j < nc; j++)
 	{
-	  Complex c = m.elem (i, j);
+	  Complex c = m (i, j);
 	  if (xisnan (c))
 	    goto next_row;
 	  else
 	    {
 	      double re = real (c);
 	      double im = imag (c);
 
 	      re = xisinf (re) ? (re > 0 ? OCT_RBV : -OCT_RBV) : re;
 	      im = xisinf (im) ? (im > 0 ? OCT_RBV : -OCT_RBV) : im;
 
-	      retval.elem (k, j) = Complex (re, im);
+	      retval (k, j) = Complex (re, im);
 	    }
 	}
       k++;
 
     next_row:
       continue;
     }
 
diff --git a/src/log.cc b/src/log.cc
--- a/src/log.cc
+++ b/src/log.cc
@@ -88,21 +88,21 @@ DEFUN_DLD_BUILTIN (logm, args, ,
 	  else
 	    {
 	      EIG m_eig (m);
 	      ComplexColumnVector lambda (m_eig.eigenvalues ());
 	      ComplexMatrix Q (m_eig.eigenvectors ());
 
 	      for (int i = 0; i < nr; i++)
 		{
-		  Complex elt = lambda.elem (i);
+		  Complex elt = lambda (i);
 		  if (imag (elt) == 0.0 && real (elt) > 0.0)
-		    lambda.elem (i) = log (real (elt));
+		    lambda (i) = log (real (elt));
 		  else
-		    lambda.elem (i) = log (elt);
+		    lambda (i) = log (elt);
 		}
 
 	      ComplexDiagMatrix D (lambda);
 	      ComplexMatrix result = Q * D * Q.inverse ();
 
 	      retval(0) = result;
 	    }
 	}
@@ -121,21 +121,21 @@ DEFUN_DLD_BUILTIN (logm, args, ,
 	  else
 	    {
 	      EIG m_eig (m);
 	      ComplexColumnVector lambda (m_eig.eigenvalues ());
 	      ComplexMatrix Q (m_eig.eigenvectors ());
 
 	      for (int i = 0; i < nr; i++)
 		{
-		  Complex elt = lambda.elem (i);
+		  Complex elt = lambda (i);
 		  if (imag (elt) == 0.0 && real (elt) > 0.0)
-		    lambda.elem (i) = log (real (elt));
+		    lambda (i) = log (real (elt));
 		  else
-		    lambda.elem (i) = log (elt);
+		    lambda (i) = log (elt);
 		}
 
 	      ComplexDiagMatrix D (lambda);
 	      ComplexMatrix result = Q * D * Q.inverse ();
 
 	      retval(0) = result;
 	    }
 	}
@@ -200,21 +200,21 @@ DEFUN_DLD_BUILTIN (sqrtm, args, ,
 	  else
 	    {
 	      EIG m_eig (m);
 	      ComplexColumnVector lambda (m_eig.eigenvalues ());
 	      ComplexMatrix Q (m_eig.eigenvectors ());
 
 	      for (int i = 0; i < nr; i++)
 		{
-		  Complex elt = lambda.elem (i);
+		  Complex elt = lambda (i);
 		  if (imag (elt) == 0.0 && real (elt) > 0.0)
-		    lambda.elem (i) = sqrt (real (elt));
+		    lambda (i) = sqrt (real (elt));
 		  else
-		    lambda.elem (i) = sqrt (elt);
+		    lambda (i) = sqrt (elt);
 		}
 
 	      ComplexDiagMatrix D (lambda);
 	      ComplexMatrix result = Q * D * Q.inverse ();
 
 	      retval(0) = result;
 	    }
 	}
@@ -233,21 +233,21 @@ DEFUN_DLD_BUILTIN (sqrtm, args, ,
 	  else
 	    {
 	      EIG m_eig (m);
 	      ComplexColumnVector lambda (m_eig.eigenvalues ());
 	      ComplexMatrix Q (m_eig.eigenvectors ());
 
 	      for (int i = 0; i < nr; i++)
 		{
-		  Complex elt = lambda.elem (i);
+		  Complex elt = lambda (i);
 		  if (imag (elt) == 0.0 && real (elt) > 0.0)
-		    lambda.elem (i) = sqrt (real (elt));
+		    lambda (i) = sqrt (real (elt));
 		  else
-		    lambda.elem (i) = sqrt (elt);
+		    lambda (i) = sqrt (elt);
 		}
 
 	      ComplexDiagMatrix D (lambda);
 	      ComplexMatrix result = Q * D * Q.inverse ();
 
 	      retval(0) = result;
 	    }
 	}
diff --git a/src/lsode.cc b/src/lsode.cc
--- a/src/lsode.cc
+++ b/src/lsode.cc
@@ -53,23 +53,23 @@ lsode_user_function (const ColumnVector&
 
   octave_value_list args;
   args(1) = t;
 
   if (nstates > 1)
     {
       Matrix m (nstates, 1);
       for (int i = 0; i < nstates; i++)
-	m (i, 0) = x.elem (i);
+	m (i, 0) = x (i);
       octave_value state (m);
       args(0) = state;
     }
   else
     {
-      double d = x.elem (0);
+      double d = x (0);
       octave_value state (d);
       args(0) = state;
     }
 
   if (lsode_fcn)
     {
       octave_value_list tmp = lsode_fcn->eval (0, 1, args);
 
@@ -144,17 +144,17 @@ where xdot and x are vectors and t is a 
 	{
 	  error ("lsode: expecting critical time vector as fourth argument");
 	  return retval;
 	}
 
       crit_times_set = 1;
     }
 
-  double tzero = out_times.elem (0);
+  double tzero = out_times (0);
   int nsteps = out_times.capacity ();
 
   ODEFunc func (lsode_user_function);
   LSODE ode (state, tzero, func);
   ode.copy (lsode_opts);
 
   int nstates = state.capacity ();
   Matrix output (nsteps, nstates + 1);
diff --git a/src/minmax.cc b/src/minmax.cc
--- a/src/minmax.cc
+++ b/src/minmax.cc
@@ -49,36 +49,36 @@ min (double d, const Matrix& m)
   int nr = m.rows ();
   int nc = m.columns ();
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double m_elem = m.elem (i, j);
-	result.elem (i, j) = MIN (d, m_elem);
+	double m_elem = m (i, j);
+	result (i, j) = MIN (d, m_elem);
       }
 
   return result;
 }
 
 static Matrix
 min (const Matrix& m, double d)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double m_elem = m.elem (i, j);
-	result.elem (i, j) = MIN (m_elem, d);
+	double m_elem = m (i, j);
+	result (i, j) = MIN (m_elem, d);
       }
 
   return result;
 }
 
 static ComplexMatrix
 min (const Complex& c, const ComplexMatrix& m)
 {
@@ -88,21 +88,21 @@ min (const Complex& c, const ComplexMatr
   ComplexMatrix result (nr, nc);
 
   double abs_c = abs (c);
 
   for (int j = 0; j < nc; j++)
     {
       for (int i = 0; i < nr; i++)
 	{
-	  double abs_m_elem = abs (m.elem (i, j));
+	  double abs_m_elem = abs (m (i, j));
 	  if (abs_c < abs_m_elem)
-	    result.elem (i, j) = c;
+	    result (i, j) = c;
 	  else
-	    result.elem (i, j) = m.elem (i, j);
+	    result (i, j) = m (i, j);
 	}
     }
 
   return result;
 }
 
 static ComplexMatrix
 min (const ComplexMatrix& m, const Complex& c)
@@ -112,21 +112,21 @@ min (const ComplexMatrix& m, const Compl
 
   ComplexMatrix result (nr, nc);
 
   double abs_c = abs (c);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double abs_m_elem = abs (m.elem (i, j));
+	double abs_m_elem = abs (m (i, j));
 	if (abs_m_elem < abs_c)
-	  result.elem (i, j) = m.elem (i, j);
+	  result (i, j) = m (i, j);
 	else
-	  result.elem (i, j) = c;
+	  result (i, j) = c;
       }
 
   return result;
 }
 
 static Matrix
 min (const Matrix& a, const Matrix& b)
 {
@@ -138,19 +138,19 @@ min (const Matrix& a, const Matrix& b)
       return Matrix ();
     }
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double a_elem = a.elem (i, j);
-	double b_elem = b.elem (i, j);
-	result.elem (i, j) = MIN (a_elem, b_elem);
+	double a_elem = a (i, j);
+	double b_elem = b (i, j);
+	result (i, j) = MIN (a_elem, b_elem);
       }
 
   return result;
 }
 
 static ComplexMatrix
 min (const ComplexMatrix& a, const ComplexMatrix& b)
 {
@@ -163,44 +163,44 @@ min (const ComplexMatrix& a, const Compl
     }
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (int i = 0; i < nr; i++)
-	if (imag (a.elem (i, j)) != 0.0 && imag (b.elem (i, j)) != 0.0)
+	if (imag (a (i, j)) != 0.0 && imag (b (i, j)) != 0.0)
 	  {
 	    columns_are_real_only = 0;
 	    break;
 	  }
 
       if (columns_are_real_only)
 	{
 	  for (int i = 0; i < nr; i++)
 	    {
-	      double a_elem = real (a.elem (i, j));
-	      double b_elem = real (b.elem (i, j));
+	      double a_elem = real (a (i, j));
+	      double b_elem = real (b (i, j));
 	      if (a_elem < b_elem)
-		result.elem (i, j) = a_elem;
+		result (i, j) = a_elem;
 	      else
-		result.elem (i, j) = b_elem;
+		result (i, j) = b_elem;
 	    }
 	}
       else
 	{
 	  for (int i = 0; i < nr; i++)
 	    {
-	      double abs_a_elem = abs (a.elem (i, j));
-	      double abs_b_elem = abs (b.elem (i, j));
+	      double abs_a_elem = abs (a (i, j));
+	      double abs_b_elem = abs (b (i, j));
 	      if (abs_a_elem < abs_b_elem)
-		result.elem (i, j) = a.elem (i, j);
+		result (i, j) = a (i, j);
 	      else
-		result.elem (i, j) = b.elem (i, j);
+		result (i, j) = b (i, j);
 	    }
 	}
     }
 
   return result;
 }
 
 static Matrix
@@ -209,36 +209,36 @@ max (double d, const Matrix& m)
   int nr = m.rows ();
   int nc = m.columns ();
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double m_elem = m.elem (i, j);
-	result.elem (i, j) = MAX (d, m_elem);
+	double m_elem = m (i, j);
+	result (i, j) = MAX (d, m_elem);
       }
 
   return result;
 }
 
 static Matrix
 max (const Matrix& m, double d)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double m_elem = m.elem (i, j);
-	result.elem (i, j) = MAX (m_elem, d);
+	double m_elem = m (i, j);
+	result (i, j) = MAX (m_elem, d);
       }
 
   return result;
 }
 
 static ComplexMatrix
 max (const Complex& c, const ComplexMatrix& m)
 {
@@ -247,21 +247,21 @@ max (const Complex& c, const ComplexMatr
 
   ComplexMatrix result (nr, nc);
 
   double abs_c = abs (c);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double abs_m_elem = abs (m.elem (i, j));
+	double abs_m_elem = abs (m (i, j));
 	if (abs_c > abs_m_elem)
-	  result.elem (i, j) = c;
+	  result (i, j) = c;
 	else
-	  result.elem (i, j) = m.elem (i, j);
+	  result (i, j) = m (i, j);
       }
 
   return result;
 }
 
 static ComplexMatrix
 max (const ComplexMatrix& m, const Complex& c)
 {
@@ -270,21 +270,21 @@ max (const ComplexMatrix& m, const Compl
 
   ComplexMatrix result (nr, nc);
 
   double abs_c = abs (c);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double abs_m_elem = abs (m.elem (i, j));
+	double abs_m_elem = abs (m (i, j));
 	if (abs_m_elem > abs_c)
-	  result.elem (i, j) = m.elem (i, j);
+	  result (i, j) = m (i, j);
 	else
-	  result.elem (i, j) = c;
+	  result (i, j) = c;
       }
 
   return result;
 }
 
 static Matrix
 max (const Matrix& a, const Matrix& b)
 {
@@ -296,19 +296,19 @@ max (const Matrix& a, const Matrix& b)
       return Matrix ();
     }
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double a_elem = a.elem (i, j);
-	double b_elem = b.elem (i, j);
-	result.elem (i, j) = MAX (a_elem, b_elem);
+	double a_elem = a (i, j);
+	double b_elem = b (i, j);
+	result (i, j) = MAX (a_elem, b_elem);
       }
 
   return result;
 }
 
 static ComplexMatrix
 max (const ComplexMatrix& a, const ComplexMatrix& b)
 {
@@ -321,44 +321,44 @@ max (const ComplexMatrix& a, const Compl
     }
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (int i = 0; i < nr; i++)
-	if (imag (a.elem (i, j)) != 0.0 && imag (b.elem (i, j)) != 0.0)
+	if (imag (a (i, j)) != 0.0 && imag (b (i, j)) != 0.0)
 	  {
 	    columns_are_real_only = 0;
 	    break;
 	  }
 
       if (columns_are_real_only)
 	{
 	  for (int i = 0; i < nr; i++)
 	    {
-	      double a_elem = real (a.elem (i, j));
-	      double b_elem = real (b.elem (i, j));
+	      double a_elem = real (a (i, j));
+	      double b_elem = real (b (i, j));
 	      if (a_elem > b_elem)
-		result.elem (i, j) = a_elem;
+		result (i, j) = a_elem;
 	      else
-		result.elem (i, j) = b_elem;
+		result (i, j) = b_elem;
 	    }
 	}
       else
 	{
 	  for (int i = 0; i < nr; i++)
 	    {
-	      double abs_a_elem = abs (a.elem (i, j));
-	      double abs_b_elem = abs (b.elem (i, j));
+	      double abs_a_elem = abs (a (i, j));
+	      double abs_b_elem = abs (b (i, j));
 	      if (abs_a_elem > abs_b_elem)
-		result.elem (i, j) = a.elem (i, j);
+		result (i, j) = a (i, j);
 	      else
-		result.elem (i, j) = b.elem (i, j);
+		result (i, j) = b (i, j);
 	    }
 	}
     }
 
   return result;
 }
 
 DEFUN_DLD_BUILTIN (min, args, nargout,
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -53,22 +53,22 @@ npsol_objective_function (const ColumnVe
 {
   int n = x.capacity ();
 
   octave_value decision_vars;
   if (n > 1)
     {
       Matrix m (n, 1);
       for (int i = 0; i < n; i++)
-	m (i, 0) = x.elem (i);
+	m (i, 0) = x (i);
       decision_vars = m;
     }
   else
     {
-      double d = x.elem (0);
+      double d = x (0);
       decision_vars = d;
     }
 
   octave_value_list args;
   args(0) = decision_vars;
 
   static double retval;
   retval = 0.0;
@@ -94,17 +94,17 @@ npsol_objective_function (const ColumnVe
 	  return retval;
 	}
     }
 
   if (objective_value.is_real_matrix ())
     {
       Matrix m = objective_value.matrix_value ();
       if (m.rows () == 1 && m.columns () == 1)
-	retval = m.elem (0, 0);
+	retval = m (0, 0);
       else
 	{
 	  gripe_user_returned_invalid ("npsol_objective");
 	  npsol_objective_error = 1; // XXX FIXME XXX
 	}
     }
   else if (objective_value.is_real_scalar ())
     {
@@ -126,22 +126,22 @@ npsol_constraint_function (const ColumnV
 
   int n = x.capacity ();
 
   octave_value decision_vars;
   if (n > 1)
     {
       Matrix m (n, 1);
       for (int i = 0; i < n; i++)
-	m (i, 0) = x.elem (i);
+	m (i, 0) = x (i);
       decision_vars = m;
     }
   else
     {
-      double d = x.elem (0);
+      double d = x (0);
       decision_vars = d;
     }
 
   octave_value_list args;
   args(0) = decision_vars;
 
   if (npsol_constraints)
     {
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -109,29 +109,29 @@ get_size (const Matrix& size, int& nr, i
   nr = -1;
   nc = -1;
 
   double dnr = -1.0;
   double dnc = -1.0;
 
   if (size.rows () == 1 && size.cols () > 0)
     {
-      dnr = size.elem (0, 0);
+      dnr = size (0, 0);
 
       if (size.cols () == 2)
-	dnc = size.elem (0, 1);
+	dnc = size (0, 1);
       else if (size.cols () > 2)
 	::error ("%s: invalid size specification", warn_for);
     }
   else if (size.cols () == 1 && size.rows () > 0)
     {
-      dnr = size.elem (0, 0);
+      dnr = size (0, 0);
 
       if (size.rows () == 2)
-	dnc = size.elem (1, 0);
+	dnc = size (1, 0);
       else if (size.rows () > 2)
 	::error ("%s: invalid size specification", warn_for);
     }
   else
     ::error ("%s: invalid size specification", warn_for);
 
   if (! error_state)
     {
@@ -196,17 +196,17 @@ scanf_format_list::scanf_format_list (co
 }
 
 scanf_format_list::~scanf_format_list (void)
 {
   int n = list.length ();
 
   for (int i = 0; i < n; i++)
     {
-      scanf_format_elt *elt = list.elem (i);
+      scanf_format_elt *elt = list (i);
       delete elt;
     }	
 }
 
 void
 scanf_format_list::add_elt_to_list (int width, bool discard, char type,
 				    char modifier, int& num_elts)
 {
@@ -221,17 +221,17 @@ scanf_format_list::add_elt_to_list (int 
 	  if (*text)
 	    {
 	      scanf_format_elt *elt
 		= new scanf_format_elt (text, width, discard, type, modifier);
 
 	      if (num_elts == list.length ())
 		list.resize (2 * num_elts);
 
-	      list.elem (num_elts++) = elt;
+	      list (num_elts++) = elt;
 	    }
 	  else
 	    delete [] text;
 	}
 
       delete buf;
       buf = 0;
     }
@@ -390,17 +390,17 @@ scanf_format_list::finish_conversion (co
 
 void
 scanf_format_list::printme (void) const
 {
   int n = list.length ();
 
   for (int i = 0; i < n; i++)
     {
-      scanf_format_elt *elt = list.elem (i);
+      scanf_format_elt *elt = list (i);
 
       cerr << elt->width << "\t"
 	   << elt->discard << "\t"
 	   << elt->type << "\t"
 	   << elt->modifier << "\t"
 	   << undo_string_escapes (elt->text) << "\n";
     }
 }
@@ -409,17 +409,17 @@ bool
 scanf_format_list::all_character_conversions (void)
 {
   int n = list.length ();
 
   if (n > 0)
     {
       for (int i = 0; i < n; i++)
 	{
-	  scanf_format_elt *elt = list.elem (i);
+	  scanf_format_elt *elt = list (i);
 
 	  switch (elt->type)
 	    {
 	    case 'c': case 's': case 'p': case '%': case '[':
 	      break;
 
 	    default:
 	      return false;
@@ -437,17 +437,17 @@ bool
 scanf_format_list::all_numeric_conversions (void)
 {
   int n = list.length ();
 
   if (n > 0)
     {
       for (int i = 0; i < n; i++)
 	{
-	  scanf_format_elt *elt = list.elem (i);
+	  scanf_format_elt *elt = list (i);
 
 	  switch (elt->type)
 	    {
 	    case 'd': case 'i': case 'o': case 'u': case 'x':
 	    case 'e': case 'f': case 'g':
 	      break;
 
 	    default:
@@ -517,17 +517,17 @@ printf_format_list::printf_format_list (
 }
 
 printf_format_list::~printf_format_list (void)
 {
   int n = list.length ();
 
   for (int i = 0; i < n; i++)
     {
-      printf_format_elt *elt = list.elem (i);
+      printf_format_elt *elt = list (i);
       delete elt;
     }	
 }
 
 void
 printf_format_list::add_elt_to_list (int args, char type, char modifier,
 				     int& num_elts)
 {
@@ -542,17 +542,17 @@ printf_format_list::add_elt_to_list (int
 	  if (*text)
 	    {
 	      printf_format_elt *elt
 		= new printf_format_elt (text, args, type, modifier);
 
 	      if (num_elts == list.length ())
 		list.resize (2 * num_elts);
 
-	      list.elem (num_elts++) = elt;
+	      list (num_elts++) = elt;
 	    }
 	  else
 	    delete [] text;
 	}
 
       delete buf;
       buf = 0;
     }
@@ -701,17 +701,17 @@ printf_format_list::finish_conversion (c
 
 void
 printf_format_list::printme (void) const
 {
   int n = list.length ();
 
   for (int i = 0; i < n; i++)
     {
-      printf_format_elt *elt = list.elem (i);
+      printf_format_elt *elt = list (i);
 
       cerr << elt->args<< "\t"
 	   << elt->type << "\t"
 	   << elt->modifier << "\t"
 	   << undo_string_escapes (elt->text) << "\n";
     }
 }
 
@@ -2664,34 +2664,34 @@ octave_stream_list::do_insert (octave_ba
     {
       octave_stream *os = new octave_stream (obs);
 
       // Insert item in first open slot, increasing size of list if
       // necessary.
 
       for (int i = 0; i < curr_len; i++)
 	{
-	  octave_stream *tmp = list.elem (i);
+	  octave_stream *tmp = list (i);
 
 	  if (! tmp)
 	    {
-	      list.elem (i) = os;
+	      list (i) = os;
 	      retval = i;
 	      break;
 	    }
 	}
 
       if (retval < 0)
 	{
 	  int total_len = list.length ();
 
 	  if (curr_len == total_len)
 	    list.resize (total_len * 2);
 
-	  list.elem (curr_len) = os;
+	  list (curr_len) = os;
 	  retval = curr_len;
 	  curr_len++;
 	}
     }
   else
     ::error ("octave_stream_list: attempt to insert invalid stream");
 
   return retval;
@@ -2714,17 +2714,17 @@ octave_stream_list::insert (octave_base_
 }
 
 octave_stream *
 octave_stream_list::do_lookup (int fid) const
 {
   octave_stream *retval = 0;
 
   if (fid >= 0 && fid < curr_len)
-    retval = list.elem (fid);
+    retval = list (fid);
 
   return retval;
 }
 
 octave_stream *
 octave_stream_list::do_lookup (const octave_value& fid) const
 {
   octave_stream *retval = 0;
@@ -2763,22 +2763,22 @@ int
 octave_stream_list::do_remove (int fid)
 {
   int retval = -1;
 
   // Can't remove stdin (cin), stdout (cout), or stderr (cerr).
 
   if (fid > 2 && fid < curr_len)
     {
-      octave_stream *os = list.elem (fid);
+      octave_stream *os = list (fid);
 
       if (os)
 	{
 	  delete os;
-	  list.elem (fid) = 0;
+	  list (fid) = 0;
 	  retval = 0;
 	}
     }
 
   return retval;
 }
 
 int
@@ -2816,28 +2816,28 @@ octave_stream_list::remove (const octave
   return retval;
 }
 
 void
 octave_stream_list::do_clear (void)
 {
   // Do flush stdout and stderr.
 
-  list.elem (0) -> flush ();
-  list.elem (1) -> flush ();
+  list (0) -> flush ();
+  list (1) -> flush ();
 
   // But don't delete them or stdin.
 
   for (int i = 3; i < curr_len; i++)
     {
-      octave_stream *os = list.elem (i);
+      octave_stream *os = list (i);
 
       delete os;
 
-      list.elem (i) = 0;
+      list (i) = 0;
     }
 }
 
 void
 octave_stream_list::clear (void)
 {
   if (instance)
     instance->do_clear ();
@@ -2913,17 +2913,17 @@ octave_stream_list::do_list_open_files (
   ostrstream buf;
 
   buf << "\n"
       << "  number  mode  arch       name\n"
       << "  ------  ----  ----       ----\n";
 
   for (int i = 0; i < curr_len; i++)
     {
-      octave_stream *os = list.elem (i);
+      octave_stream *os = list (i);
 
       if (os)
 	{
 	  string mode = octave_stream::mode_as_string (os->mode ());
 	  string arch = octave_stream::arch_as_string (os->architecture ());
 	  string name = os->name ();
 
 	  buf.form ("  %4d     %-3s  %-9s  %s\n",
@@ -2959,17 +2959,17 @@ octave_stream_list::do_open_file_numbers
   Matrix retval (1, curr_len, 0.0);
 
   int num_open = 0;
 
   // Skip stdin, stdout, and stderr.
 
   for (int i = 3; i < curr_len; i++)
     {
-      if (list.elem (i))
+      if (list (i))
 	retval (0, num_open++) = i;
     }
 
   retval.resize ((num_open > 0), num_open);
 
   return retval;
 }
 
@@ -2992,17 +2992,17 @@ octave_stream_list::get_file_number (con
   if (fid.is_string ())
     {
       string nm = fid.string_value ();
 
       // stdin (cin), stdout (cout), and stderr (cerr) are unnamed.
 
       for (int i = 3; i < curr_len; i++)
 	{
-	  octave_stream *os = list.elem (i);
+	  octave_stream *os = list (i);
 
 	  if (os && os->name () == nm)
 	    {
 	      retval = i;
 	      break;
 	    }
 	}
     }
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -103,94 +103,94 @@ static int print_big_e = 0;
 
 static int
 any_element_is_negative (const Matrix& a)
 {
   int nr = a.rows ();
   int nc = a.columns ();
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      if (a.elem (i, j) < 0.0)
+      if (a (i, j) < 0.0)
 	return 1;
   return 0;
 }
 
 // XXX FIXME XXX -- these should probably be somewhere else.
 
 int
 any_element_is_inf_or_nan (const Matrix& a)
 {
   int nr = a.rows ();
   int nc = a.columns ();
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double val = a.elem (i, j);
+	double val = a (i, j);
 	if (xisinf (val) || xisnan (val))
 	  return 1;
       }
   return 0;
 }
 
 int
 any_element_is_inf_or_nan (const ComplexMatrix& a)
 {
   int nr = a.rows ();
   int nc = a.columns ();
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	Complex val = a.elem (i, j);
+	Complex val = a (i, j);
 	if (xisinf (val) || xisnan (val))
 	  return 1;
       }
   return 0;
 }
 
 static int
 all_elements_are_int_or_inf_or_nan (const Matrix& a)
 {
   int nr = a.rows ();
   int nc = a.columns ();
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double val = a.elem (i, j);
+	double val = a (i, j);
 	if (xisnan (val) || D_NINT (val) == val)
 	  continue;
 	else
 	  return 0;
       }
   return 1;
 }
 
 static Matrix
 abs (const Matrix& a)
 {
   int nr = a.rows ();
   int nc = a.columns ();
   Matrix retval (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      retval.elem (i, j) = fabs (a.elem (i, j));
+      retval (i, j) = fabs (a (i, j));
   return retval;
 }
 
 static double
 pr_max_internal (const Matrix& m)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   double result = DBL_MIN;
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double val = m.elem (i, j);
+	double val = m (i, j);
 	if (xisinf (val) || xisnan (val))
 	  continue;
 
 	if (val > result)
 	  result = val;
       }
   return result;
 }
@@ -201,17 +201,17 @@ pr_min_internal (const Matrix& m)
   int nr = m.rows ();
   int nc = m.columns ();
 
   double result = DBL_MAX;
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double val = m.elem (i, j);
+	double val = m (i, j);
 	if (xisinf (val) || xisnan (val))
 	  continue;
 
 	if (val < result)
 	  result = val;
       }
   return result;
 }
@@ -1186,17 +1186,17 @@ octave_print_internal (ostream& os, cons
     {
       for (int i = 0; i < nr; i++)
 	{
 	  for (int j = 0; j < nc; j++)
 	    {
 	      if (j == 0)
 		os << "  ";
 
-	      if (m.elem (i, j) == 0.0)
+	      if (m (i, j) == 0.0)
 		os << " ";
 	      else
 		os << "+";
 	    }
 	  os << "\n";
 	}
     }
   else
@@ -1252,17 +1252,17 @@ octave_print_internal (ostream& os, cons
 		      else
 			{
 			  if (j > col && j < lim)
 			    os << ", ";
 			  else
 			    os << "  ";
 			}
 
-		      pr_float (os, m.elem (i, j));
+		      pr_float (os, m (i, j));
 		    }
 
 		  col += inc;
 
 		  if (col >= nc)
 		    {
 		      if (i == nr - 1)
 			os << " ]";
@@ -1286,17 +1286,17 @@ octave_print_internal (ostream& os, cons
 	      for (int i = 0; i < nr; i++)
 		{
 		  os.form ("%*s", extra_indent, "");
 
 		  for (int j = col; j < lim; j++)
 		    {
 		      os << "  ";
 
-		      pr_float (os, m.elem (i, j), fw);
+		      pr_float (os, m (i, j), fw);
 		    }
 
 		  os << "\n";
 		}
 	    }
 	}
     }
 }
@@ -1338,17 +1338,17 @@ octave_print_internal (ostream& os, cons
     {
       for (int i = 0; i < nr; i++)
 	{
 	  for (int j = 0; j < nc; j++)
 	    {
 	      if (j == 0)
 		os << "  ";
 
-	      if (cm.elem (i, j) == 0.0)
+	      if (cm (i, j) == 0.0)
 		os << " ";
 	      else
 		os << "+";
 	    }
 	  os << "\n";
 	}
     }
   else
@@ -1405,17 +1405,17 @@ octave_print_internal (ostream& os, cons
 		      else
 			{
 			  if (j > col && j < lim)
 			    os << ", ";
 			  else
 			    os << "  ";
 			}
 
-		      pr_complex (os, cm.elem (i, j));
+		      pr_complex (os, cm (i, j));
 		    }
 
 		  col += inc;
 
 		  if (col >= nc)
 		    {
 		      if (i == nr - 1)
 			os << " ]";
@@ -1439,17 +1439,17 @@ octave_print_internal (ostream& os, cons
 	      for (int i = 0; i < nr; i++)
 		{
 		  os.form ("%*s", extra_indent, "");
 
 		  for (int j = col; j < lim; j++)
 		    {
 		      os << "  ";
 
-		      pr_complex (os, cm.elem (i, j));
+		      pr_complex (os, cm (i, j));
 		    }
 		  os << "\n";
 		}
 	    }
 	}
     }
 }
 
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -157,17 +157,17 @@ decrement_struct_indent (void)
 static bool
 any_element_is_complex (const ComplexMatrix& a)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      if (imag (a.elem (i, j)) != 0.0)
+      if (imag (a (i, j)) != 0.0)
 	return true;
 
   return false;
 }
 
 // The following three variables could be made static members of the
 // octave_value class.
 
@@ -480,100 +480,100 @@ OCT_VAL_REP::octave_value_rep (double d)
   scalar = d;
   type_tag = scalar_constant;
 }
 
 OCT_VAL_REP::octave_value_rep (const Matrix& m)
 {
   if (m.rows () == 1 && m.columns () == 1)
     {
-      scalar = m.elem (0, 0);
+      scalar = m (0, 0);
       type_tag = scalar_constant;
     }
   else
     {
       matrix = new Matrix (m);
       type_tag = matrix_constant;
     }
 }
 
 OCT_VAL_REP::octave_value_rep (const DiagMatrix& d)
 {
   if (d.rows () == 1 && d.columns () == 1)
     {
-      scalar = d.elem (0, 0);
+      scalar = d (0, 0);
       type_tag = scalar_constant;
     }
   else
     {
       matrix = new Matrix (d);
       type_tag = matrix_constant;
     }
 }
 
 OCT_VAL_REP::octave_value_rep (const RowVector& v, int prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
-      scalar = v.elem (0);
+      scalar = v (0);
       type_tag = scalar_constant;
     }
   else
     {
       int pcv = (prefer_column_vector < 0)
 	? Vprefer_column_vectors
 	  : prefer_column_vector;
 
       if (pcv)
 	{
 	  Matrix m (len, 1);
 	  for (int i = 0; i < len; i++)
-	    m.elem (i, 0) = v.elem (i);
+	    m (i, 0) = v (i);
 	  matrix = new Matrix (m);
 	  type_tag = matrix_constant;
 	}
       else
 	{
 	  Matrix m (1, len);
 	  for (int i = 0; i < len; i++)
-	    m.elem (0, i) = v.elem (i);
+	    m (0, i) = v (i);
 	  matrix = new Matrix (m);
 	  type_tag = matrix_constant;
 	}
     }
 }
 
 OCT_VAL_REP::octave_value_rep (const ColumnVector& v, int prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
-      scalar = v.elem (0);
+      scalar = v (0);
       type_tag = scalar_constant;
     }
   else
     {
       int pcv = (prefer_column_vector < 0)
 	? Vprefer_column_vectors
 	  : prefer_column_vector;
 
       if (pcv)
 	{
 	  Matrix m (len, 1);
 	  for (int i = 0; i < len; i++)
-	    m.elem (i, 0) = v.elem (i);
+	    m (i, 0) = v (i);
 	  matrix = new Matrix (m);
 	  type_tag = matrix_constant;
 	}
       else
 	{
 	  Matrix m (1, len);
 	  for (int i = 0; i < len; i++)
-	    m.elem (0, i) = v.elem (i);
+	    m (0, i) = v (i);
 	  matrix = new Matrix (m);
 	  type_tag = matrix_constant;
 	}
     }
 }
 
 OCT_VAL_REP::octave_value_rep (const Complex& c)
 {
@@ -588,17 +588,17 @@ OCT_VAL_REP::octave_value_rep (const Com
       type_tag = complex_scalar_constant;
     }
 }
 
 OCT_VAL_REP::octave_value_rep (const ComplexMatrix& m)
 {
   if (m.rows () == 1 && m.columns () == 1)
     {
-      Complex c = m.elem (0, 0);
+      Complex c = m (0, 0);
 
       if (::imag (c) == 0.0)
 	{
 	  scalar = ::real (c);
 	  type_tag = scalar_constant;
 	}
       else
 	{
@@ -612,17 +612,17 @@ OCT_VAL_REP::octave_value_rep (const Com
       type_tag = complex_matrix_constant;
     }
 }
 
 OCT_VAL_REP::octave_value_rep (const ComplexDiagMatrix& d)
 {
   if (d.rows () == 1 && d.columns () == 1)
     {
-      Complex c = d.elem (0, 0);
+      Complex c = d (0, 0);
 
       if (::imag (c) == 0.0)
 	{
 	  scalar = ::real (c);
 	  type_tag = scalar_constant;
 	}
       else
 	{
@@ -638,17 +638,17 @@ OCT_VAL_REP::octave_value_rep (const Com
 }
 
 OCT_VAL_REP::octave_value_rep (const ComplexRowVector& v,
 			   int prefer_column_vector) 
 {
   int len = v.capacity ();
   if (len == 1)
     {
-      Complex c = v.elem (0);
+      Complex c = v (0);
 
       if (::imag (c) == 0.0)
 	{
 	  scalar = ::real (c);
 	  type_tag = scalar_constant;
 	}
       else
 	{
@@ -661,38 +661,38 @@ OCT_VAL_REP::octave_value_rep (const Com
       int pcv = (prefer_column_vector < 0)
 	? Vprefer_column_vectors
 	  : prefer_column_vector;
 
       if (pcv)
 	{
 	  ComplexMatrix m (len, 1);
 	  for (int i = 0; i < len; i++)
-	    m.elem (i, 0) = v.elem (i);
+	    m (i, 0) = v (i);
 	  complex_matrix = new ComplexMatrix (m);
 	  type_tag = complex_matrix_constant;
 	}
       else
 	{
 	  ComplexMatrix m (1, len);
 	  for (int i = 0; i < len; i++)
-	    m.elem (0, i) = v.elem (i);
+	    m (0, i) = v (i);
 	  complex_matrix = new ComplexMatrix (m);
 	  type_tag = complex_matrix_constant;
 	}
     }
 }
 
 OCT_VAL_REP::octave_value_rep (const ComplexColumnVector& v, int
 			   prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
-      Complex c = v.elem (0);
+      Complex c = v (0);
 
       if (::imag (c) == 0.0)
 	{
 	  scalar = ::real (c);
 	  type_tag = scalar_constant;
 	}
       else
 	{
@@ -705,25 +705,25 @@ OCT_VAL_REP::octave_value_rep (const Com
       int pcv = (prefer_column_vector < 0)
 	? Vprefer_column_vectors
 	  : prefer_column_vector;
 
       if (pcv)
 	{
 	  ComplexMatrix m (len, 1);
 	  for (int i = 0; i < len; i++)
-	    m.elem (i, 0) = v.elem (i);
+	    m (i, 0) = v (i);
 	  complex_matrix = new ComplexMatrix (m);
 	  type_tag = complex_matrix_constant;
 	}
       else
 	{
 	  ComplexMatrix m (1, len);
 	  for (int i = 0; i < len; i++)
-	    m.elem (0, i) = v.elem (i);
+	    m (0, i) = v (i);
 	  complex_matrix = new ComplexMatrix (m);
 	  type_tag = complex_matrix_constant;
 	}
     }
 }
 
 OCT_VAL_REP::octave_value_rep (const char *s)
 {
@@ -741,17 +741,17 @@ OCT_VAL_REP::octave_value_rep (const str
 {
   int nr = s.length ();
   int nc = s.max_length ();
   char_matrix = new charMatrix (nr, nc, 0);
   for (int i = 0; i < nr; i++)
     {
       nc = s[i].length ();
       for (int j = 0; j < nc; j++)
-	char_matrix->elem (i, j) = s[i][j];
+	(*char_matrix) (i, j) = s[i][j];
     }
   type_tag = char_matrix_constant_str;
 }
 
 OCT_VAL_REP::octave_value_rep (const charMatrix& chm, bool is_str)
 {
   char_matrix = new charMatrix (chm);
   type_tag = is_str ? char_matrix_constant_str : char_matrix_constant;
@@ -1156,30 +1156,30 @@ OCT_VAL_REP::is_true (void) const
       retval = (scalar != 0.0);
       break;
 
     case matrix_constant:
       {
 	Matrix m = (matrix->all ()) . all ();
 	retval = (m.rows () == 1
 		  && m.columns () == 1
-		  && m.elem (0, 0) != 0.0);
+		  && m (0, 0) != 0.0);
       }
       break;
 
     case complex_scalar_constant:
       retval = (*complex_scalar != 0.0);
       break;
 
     case complex_matrix_constant:
       {
 	Matrix m = (complex_matrix->all ()) . all ();
 	retval = (m.rows () == 1
 		  && m.columns () == 1
-		  && m.elem (0, 0) != 0.0);
+		  && m (0, 0) != 0.0);
       }
       break;
 
     default:
       gripe_wrong_type_arg (0, *this);
       break;
     }
 
@@ -1203,17 +1203,17 @@ OCT_VAL_REP::double_value (bool force_st
     {
     case scalar_constant:
       retval = scalar;
       break;
 
     case matrix_constant:
       {
 	if (Vdo_fortran_indexing && rows () > 0 && columns () > 0)
-	  retval = matrix->elem (0, 0);
+	  retval = (*matrix) (0, 0);
 	else
 	  gripe_invalid_conversion ("real matrix", "real scalar");
       }
       break;
 
     case complex_matrix_constant:
     case complex_scalar_constant:
       {
@@ -1225,34 +1225,34 @@ OCT_VAL_REP::double_value (bool force_st
 	if (flag)
 	  {
 	    if (type_tag == complex_scalar_constant)
 	      retval = ::real (*complex_scalar);
 	    else if (type_tag == complex_matrix_constant)
 	      {
 		if (Vdo_fortran_indexing
 		    && rows () > 0 && columns () > 0)
-		  retval = ::real (complex_matrix->elem (0, 0));
+		  retval = ::real ((*complex_matrix) (0, 0));
 		else
 		  gripe_invalid_conversion ("complex matrix", "real scalar");
 	      }
 	    else
 	      panic_impossible ();
 	  }
 	else
 	  gripe_invalid_conversion ("complex scalar", "real scalar");
       }
       break;
 
     case char_matrix_constant:
       {
 	int len = char_matrix->rows ();
 	if ((char_matrix->rows () == 1 && len == 1)
 	    || (len > 1 && Vdo_fortran_indexing))
-	  retval = toascii ((int) char_matrix->elem (0, 0));
+	  retval = toascii ((int) (*char_matrix) (0, 0));
 	else
 	  gripe_invalid_conversion ("char matrix", "real scalar");
       }
       break;
 
     case char_matrix_constant_str:
       {
 	int flag = force_string_conv;
@@ -1261,17 +1261,17 @@ OCT_VAL_REP::double_value (bool force_st
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "real scalar");
 
 	int len = char_matrix->rows ();
 	if (flag
 	    && ((char_matrix->rows () == 1 && len == 1)
 		|| (len > 1 && Vdo_fortran_indexing)))
-	  retval = toascii ((int) char_matrix->elem (0, 0));
+	  retval = toascii ((int) (*char_matrix) (0, 0));
 	else
 	  gripe_invalid_conversion ("string", "real scalar");
       }
       break;
 
     case range_constant:
       {
 	int nel = range->nelem ();
@@ -1374,31 +1374,31 @@ OCT_VAL_REP::complex_value (bool force_s
       break;
 
     case complex_matrix_constant:
     case matrix_constant:
       {
 	if (Vdo_fortran_indexing && rows () > 0 && columns () > 0)
 	  {
 	    if (type_tag == complex_matrix_constant)
-	      retval = complex_matrix->elem (0, 0);
+	      retval = (*complex_matrix) (0, 0);
 	    else
-	      retval = matrix->elem (0, 0);
+	      retval = (*matrix) (0, 0);
 	  }
 	else
 	  gripe_invalid_conversion ("real matrix", "real scalar");
       }
       break;
 
     case char_matrix_constant:
       {
 	int len = char_matrix->cols ();
 	if ((char_matrix->rows () == 1 && len == 1)
 	    || (len > 1 && Vdo_fortran_indexing))
-	  retval = toascii ((int) char_matrix->elem (0, 0));
+	  retval = toascii ((int) (*char_matrix) (0, 0));
 	else
 	  gripe_invalid_conversion ("char matrix", "complex scalar");
       }
       break;
 
     case char_matrix_constant_str:
       {
 	int flag = force_string_conv;
@@ -1407,17 +1407,17 @@ OCT_VAL_REP::complex_value (bool force_s
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "complex scalar");
 
 	int len = char_matrix->cols ();
 	if (flag
 	    && ((char_matrix->rows () == 1 && len == 1)
 		|| (len > 1 && Vdo_fortran_indexing)))
-	  retval = toascii ((int) char_matrix->elem (0, 0));
+	  retval = toascii ((int) (*char_matrix) (0, 0));
 	else
 	  gripe_invalid_conversion ("string", "complex scalar");
       }
       break;
 
     case range_constant:
       {
 	int nel = range->nelem ();
@@ -1594,32 +1594,32 @@ OCT_VAL_REP::vector_value (bool force_st
     return retval;
 
   int nr = m.rows ();
   int nc = m.columns ();
   if (nr == 1)
     {
       retval.resize (nc);
       for (int i = 0; i < nc; i++)
-	retval.elem (i) = m (0, i);
+	retval (i) = m (0, i);
     }
   else if (nc == 1)
     {
       retval.resize (nr);
       for (int i = 0; i < nr; i++)
-	retval.elem (i) = m.elem (i, 0);
+	retval (i) = m (i, 0);
     }
   else if (nr > 0 && nc > 0
 	   && (Vdo_fortran_indexing || force_vector_conversion))
     {
       retval.resize (nr * nc);
       int k = 0;
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  retval.elem (k++) = m.elem (i, j);
+	  retval (k++) = m (i, j);
     }
   else
     gripe_invalid_conversion ("real matrix", "real vector");
 
   return retval;
 }
 
 // This could be made more efficient by doing all the work here rather
@@ -1638,32 +1638,32 @@ OCT_VAL_REP::complex_vector_value (bool 
     return retval;
 
   int nr = m.rows ();
   int nc = m.columns ();
   if (nr == 1)
     {
       retval.resize (nc);
       for (int i = 0; i < nc; i++)
-	retval.elem (i) = m (0, i);
+	retval (i) = m (0, i);
     }
   else if (nc == 1)
     {
       retval.resize (nr);
       for (int i = 0; i < nr; i++)
-	retval.elem (i) = m.elem (i, 0);
+	retval (i) = m (i, 0);
     }
   else if (nr > 0 && nc > 0
 	   && (Vdo_fortran_indexing || force_vector_conversion))
     {
       retval.resize (nr * nc);
       int k = 0;
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  retval.elem (k++) = m.elem (i, j);
+	  retval (k++) = m (i, j);
     }
   else
     gripe_invalid_conversion ("complex matrix", "complex vector");
 
   return retval;
 }
 
 octave_value
@@ -1719,30 +1719,30 @@ OCT_VAL_REP::convert_to_str (void) const
 	    else
 	      {
 		charMatrix chm (nr, nc);
 
 		for (int j = 0; j < nc; j++)
 		  {
 		    for (int i = 0; i < nr; i++)
 		      {
-			double d = m.elem (i, j);
+			double d = m (i, j);
 
 			if (xisnan (d))
 			  {
 			    ::error ("invalid conversion from NaN to character");
 			    return retval;
 			  }
 			else
 			  {
 			    // XXX FIXME XXX -- warn about out of
 			    // range conversions?
 
 			    int ival = NINT (d);
-			    chm.elem (i, j) = (char) ival;
+			    chm (i, j) = (char) ival;
 			  }
 		      }
 		  }
 
 		retval = octave_value (chm, 1);
 	      }
 	  }
       }
@@ -1823,36 +1823,36 @@ OCT_VAL_REP::convert_to_row_or_column_ve
     {
       Matrix *m = new Matrix (new_nr, new_nc);
 
       double *cop_out = matrix->fortran_vec ();
 
       for (int i = 0; i < len; i++)
 	{
 	  if (new_nr == 1)
-	    m->elem (0, i) = *cop_out++;
+	    (*m) (0, i) = *cop_out++;
 	  else
-	    m->elem (i, 0) = *cop_out++;
+	    (*m) (i, 0) = *cop_out++;
 	}
 
       delete matrix;
       matrix = m;
     }
   else
     {
       ComplexMatrix *cm = new ComplexMatrix (new_nr, new_nc);
 
       Complex *cop_out = complex_matrix->fortran_vec ();
 
       for (int i = 0; i < len; i++)
 	{
 	  if (new_nr == 1)
-	    cm->elem (0, i) = *cop_out++;
+	    (*cm) (0, i) = *cop_out++;
 	  else
-	    cm->elem (i, 0) = *cop_out++;
+	    (*cm) (i, 0) = *cop_out++;
 	}
 
       delete complex_matrix;
       complex_matrix = cm;
     }
 }
 
 void
@@ -1946,17 +1946,17 @@ OCT_VAL_REP::force_numeric (bool force_s
 	  }
 
 	int nr = char_matrix->rows ();
 	int nc = char_matrix->cols ();
 
 	if (nr == 1 && nc == 1)
 	  {
 	    type_tag = scalar_constant;
-	    double tmp = toascii ((int) char_matrix->elem (0, 0));
+	    double tmp = toascii ((int) (*char_matrix) (0, 0));
 	    delete char_matrix;
 	    scalar = tmp;
 	  }
 	else if (nr == 0 || nc == 0)
 	  {
 	    delete char_matrix;
 	    type_tag = matrix_constant;
 	    matrix = new Matrix (0, 0);
@@ -1966,18 +1966,18 @@ OCT_VAL_REP::force_numeric (bool force_s
 	    type_tag = matrix_constant;
 
 	    Matrix *tm = new Matrix (nr, nc);
 
 	    for (int i = 0; i < nr; i++)
 	      {
 		for (int j = 0; j < nc; j++)
 		  {
-		    int c = (int) char_matrix->elem (i, j);
-		    tm->elem (i, j) = toascii (c);
+		    int c = (int) (*char_matrix) (i, j);
+		    (*tm) (i, j) = toascii (c);
 		  }
 	      }
 	    delete char_matrix;
 	    matrix = tm;
 	  }
 	else
 	  panic_impossible ();
       }
@@ -1988,17 +1988,17 @@ OCT_VAL_REP::force_numeric (bool force_s
 	int len = range->nelem ();
 	if (len > 1)
 	  {
 	    type_tag = matrix_constant;
 	    Matrix *tm = new Matrix (1, len);
 	    double b = range->base ();
 	    double increment = range->inc ();
 	    for (int i = 0; i < len; i++)
-	      tm->elem (0, i) = b + i * increment;
+	      (*tm) (0, i) = b + i * increment;
 	    delete range;
 	    matrix = tm;
 	  }
 	else if (len == 1)
 	  {
 	    type_tag = scalar_constant;
 	    scalar = range->base ();
 	  }
@@ -2218,27 +2218,27 @@ OCT_VAL_REP::maybe_mutate (void)
       nc = columns ();
     }
 
   switch (type_tag)
     {
     case matrix_constant:
       if (nr == 1 && nc == 1)
 	{
-	  double d = matrix->elem (0, 0);
+	  double d = (*matrix) (0, 0);
 	  delete matrix;
 	  scalar = d;
 	  type_tag = scalar_constant;
 	}
       break;
 
     case complex_matrix_constant:
       if (nr == 1 && nc == 1)
 	{
-	  Complex c = complex_matrix->elem (0, 0);
+	  Complex c = (*complex_matrix) (0, 0);
 	  delete complex_matrix;
 	  complex_scalar = new Complex (c);
 	  type_tag = complex_scalar_constant;
 	}
       break;
 
     case range_constant:
       if (nr == 1 && nc == 1)
diff --git a/src/pt-fvc.cc b/src/pt-fvc.cc
--- a/src/pt-fvc.cc
+++ b/src/pt-fvc.cc
@@ -49,31 +49,31 @@ Software Foundation, 59 Temple Place - S
 static bool
 any_element_less_than (const Matrix& a, double val)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      if (a.elem (i, j) < val)
+      if (a (i, j) < val)
 	return true;
 
   return false;
 }
 
 static bool
 any_element_greater_than (const Matrix& a, double val)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      if (a.elem (i, j) > val)
+      if (a (i, j) > val)
 	return true;
 
   return false;
 }
 
 // Make sure that all arguments have values.
 
 // Are any of the arguments `:'?
@@ -664,44 +664,44 @@ apply_mapper_fcn (const octave_value& ar
 		  {
 		    Matrix result (nr, nc);
 
 		    // islapha and friends can return any nonzero value
 		    // to mean true, but we want to return 1 or 0 only.
 
 		    for (int j = 0; j < nc; j++)
 		      for (int i = 0; i < nr; i++)
-			result.elem (i, j)
-			  = (*m_fcn.ch_mapper) (chm.elem (i, j)) ? 1 : 0;
+			result (i, j)
+			  = (*m_fcn.ch_mapper) (chm (i, j)) ? 1 : 0;
 
 		    retval = result;
 		  }
 		  break;
 
 		case 1:
 		  {
 		    Matrix result (nr, nc);
 
 		    for (int j = 0; j < nc; j++)
 		      for (int i = 0; i < nr; i++)
-			result.elem (i, j)
-			  = (*m_fcn.ch_mapper) (chm.elem (i, j));
+			result (i, j)
+			  = (*m_fcn.ch_mapper) (chm (i, j));
 
 		    retval = result;
 		  }
 		  break;
 
 		case 2:
 		  {
 		    charMatrix result (nr, nc);
 
 		    for (int j = 0; j < nc; j++)
 		      for (int i = 0; i < nr; i++)
-			result.elem (i, j)
-			  = (*m_fcn.ch_mapper) (chm.elem (i, j));
+			result (i, j)
+			  = (*m_fcn.ch_mapper) (chm (i, j));
 
 		    retval = octave_value (result, true);
 		  }
 		  break;
 
 		default:
 		  panic_impossible ();
 		  break;
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -474,17 +474,17 @@ subplot_using::eval (int ndim, int n_max
 	      int n = NINT (val_tmp);
 
 	      if (n < 1 || n_max > 0 && n > n_max)
 		{
 		  ::error ("using: column %d out of range", n); 
 		  return -1;
 		}
 	      else
-		val.elem (i) = n;
+		val (i) = n;
 	    }
 	  else
 	    return -1;
 	}
       else
 	return -1;
     }
 
@@ -515,17 +515,17 @@ subplot_using::print (int ndim, int n_ma
 
   for (int i = 0; i < qual_count; i++)
     {
       if (i == 0)
 	plot_buf << " " << GNUPLOT_COMMAND_USING << " ";
       else
 	plot_buf << ":";
 
-      plot_buf << val.elem (i);
+      plot_buf << val (i);
     }
 
   return 0;
 }
 
 void
 subplot_using::accept (tree_walker& tw)
 {
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -191,20 +191,20 @@ integrand is singular.")
 	{
 	  error ("quad: expecting vector of tolerances as fifth argument");
 	  return retval;
 	}
 
       switch (tol.capacity ())
 	{
 	case 2:
-	  reltol = tol.elem (1);
+	  reltol = tol (1);
 
 	case 1:
-	  abstol = tol.elem (0);
+	  abstol = tol (0);
 	  break;
 
 	default:
 	  error ("quad: expecting tol to contain no more than two values");
 	  return retval;
 	}
 
     case 3:
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -229,23 +229,23 @@ do_rand (const octave_value_list& args, 
 	  if (error_state)
 	    return retval;
 
 	  n = a.rows ();
 	  m = a.columns ();
 
 	  if (n == 1 && m == 2)
 	    {
-	      n = NINT (a.elem (0, 0));
-	      m = NINT (a.elem (0, 1));
+	      n = NINT (a (0, 0));
+	      m = NINT (a (0, 1));
 	    }
 	  else if (n == 2 && m == 1)
 	    {
-	      n = NINT (a.elem (0, 0));
-	      m = NINT (a.elem (1, 0));
+	      n = NINT (a (0, 0));
+	      m = NINT (a (1, 0));
 	    }
 	  else
 	    warning ("rand (A): use rand (size (A)) instead");
 
 	  goto gen_matrix;
 	}
       else
 	{
@@ -303,22 +303,22 @@ do_rand (const octave_value_list& args, 
       for (int j = 0; j < m; j++)
 	for (int i = 0; i < n; i++)
 	  {
 	    double val;
 	    switch (current_distribution)
 	      {
 	      case uniform_dist:
 		F77_FCN (dgenunf, DGENUNF) (0.0, 1.0, val);
-		rand_mat.elem (i, j) = val;
+		rand_mat (i, j) = val;
 		break;
 
 	      case normal_dist:
 		F77_FCN (dgennor, DGENNOR) (0.0, 1.0, val);
-		rand_mat.elem (i, j) = val;
+		rand_mat (i, j) = val;
 		break;
 
 	      default:
 		panic_impossible ();
 		break;
 	      }
 	  }
 
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -459,21 +459,21 @@ octave_child_list::do_insert (pid_t pid,
 {
   // Insert item in first open slot, increasing size of list if
   // necessary.
 
   bool enlarge = true;
 
   for (int i = 0; i < curr_len; i++)
     {
-      octave_child& tmp = list.elem (i);
+      octave_child& tmp = list (i);
 
       if (tmp.pid < 0)
 	{
-	  list.elem (i) = octave_child (pid, f);
+	  list (i) = octave_child (pid, f);
 	  enlarge = false;
 	  break;
 	}
     }
 
   if (enlarge)
     {
       int total_len = list.length ();
@@ -481,17 +481,17 @@ octave_child_list::do_insert (pid_t pid,
       if (curr_len == total_len)
 	{
 	  if (total_len == 0)
 	    list.resize (16);
 	  else
 	    list.resize (total_len * 2);
 	}
 
-      list.elem (curr_len) = octave_child (pid, f);
+      list (curr_len) = octave_child (pid, f);
       curr_len++;
     }
 }
 
 void
 octave_child_list::insert (pid_t pid, octave_child::dead_child_handler f)
 {
   if (! instance)
@@ -507,17 +507,17 @@ void
 octave_child_list::do_remove (pid_t pid)
 {
   // Mark the record for PID invalid.
 
   bool enlarge = true;
 
   for (int i = 0; i < curr_len; i++)
     {
-      octave_child& tmp = list.elem (i);
+      octave_child& tmp = list (i);
 
       if (tmp.pid == pid)
 	{
 	  tmp.pid = -1;
 	  break;
 	}
     }
 }
diff --git a/src/sort.cc b/src/sort.cc
--- a/src/sort.cc
+++ b/src/sort.cc
@@ -38,81 +38,81 @@ Software Foundation, 59 Temple Place - S
 //
 // Maybe some cpp abuse will make it better.
 
 static Array<int>
 create_index_array (int n)
 {
   Array<int> l (n+2);
 
-  l.elem (0) = 1;
+  l (0) = 1;
 
   for (int i = 1; i < n - 1; i++)
-    l.elem (i) = -(i+2);
+    l (i) = -(i+2);
 
-  l.elem (n-1) = 0;
-  l.elem (n) = 0;
-  l.elem (n+1) = 2;
+  l (n-1) = 0;
+  l (n) = 0;
+  l (n+1) = 2;
 
   return l;
 }
 
 #define SORT_INIT_PHASE(n) \
   int s = 0; \
   int t = n + 1; \
-  int p = l.elem (s); \
-  int q = l.elem (t); \
+  int p = l (s); \
+  int q = l (t); \
   if (q == 0) \
      break
 
 #define SORT_COMMON_CODE \
   p = -p; \
   q = -q; \
   if (q == 0) \
     { \
-      l.elem (s) = (l.elem (s) < 0) \
+      l (s) = (l (s) < 0) \
 	? ((p < 0) ? p : -p) \
 	  : ((p >= 0) ? p : -p); \
-      l.elem (t) = 0; \
+      l (t) = 0; \
       break; \
     } \
 
 #define SORT_REORDER_PHASE_ONE \
-  l.elem (s) = (l.elem (s) < 0) \
+  l (s) = (l (s) < 0) \
     ? ((q < 0) ? q : -q) \
       : ((q >= 0) ? q : -q); \
   s = q; \
-  q = l.elem (q); \
+  q = l (q); \
   if (q <= 0) \
     { \
-      l.elem (s) = p; \
+      l (s) = p; \
       s = t; \
       do \
 	{ \
 	  t = p; \
-	  p = l.elem (p); \
+	  p = l (p); \
 	} \
       while (p > 0); \
       SORT_COMMON_CODE; \
     } \
 
 #define SORT_REORDER_PHASE_TWO \
-  l.elem (s) = (l.elem (s) < 0) \
+  l (s) = (l (s) < 0) \
     ? ((p < 0) ? p : -p) \
       : ((p >= 0) ? p : -p); \
   s = p; \
-  p = l.elem (p); \
+  p = l (p); \
   if (p <= 0) \
     { \
-      l.elem (s) = q; \
+      l (s) = q; \
       s = t; \
       do \
 	{ \
 	  t = q; \
-	  q = l.elem (q); \
+	  q = l (q); \
 	} \
       while (q > 0); \
       SORT_COMMON_CODE; \
     }
 
 #define DO_SORT(n, condition) \
   while (1) \
     { \
@@ -126,35 +126,35 @@ create_index_array (int n)
 	  else \
 	    { \
 	      SORT_REORDER_PHASE_TWO; \
 	    } \
 	} \
     }
 
 #define VECTOR_CREATE_RETURN_VALUES(vs, v) \
-  int k = l.elem (0); \
-  idx.elem (0) = k; \
-  vs.elem (0) = v.elem (k-1); \
+  int k = l (0); \
+  idx (0) = k; \
+  vs (0) = v (k-1); \
   for (int i = 1; i < n; i++) \
     { \
-      k = l.elem ((int) idx.elem (i-1)); \
-      idx.elem (i) = k; \
-      vs.elem (i) = v.elem (k-1); \
+      k = l ((int) idx (i-1)); \
+      idx (i) = k; \
+      vs (i) = v (k-1); \
     }
 
 #define MATRIX_CREATE_RETURN_VALUES(ms, m) \
-  int k = l.elem (0); \
-  idx.elem (0, j) = k; \
-  ms.elem (0, j) = m.elem (k-1, j); \
+  int k = l (0); \
+  idx (0, j) = k; \
+  ms (0, j) = m (k-1, j); \
   for (int i = 1; i < nr; i++) \
     { \
-      k = l.elem ((int) idx.elem (i-1, j)); \
-      idx.elem (i, j) = k; \
-      ms.elem (i, j) = m.elem (k-1, j); \
+      k = l ((int) idx (i-1, j)); \
+      idx (i, j) = k; \
+      ms (i, j) = m (k-1, j); \
     }
 
 static octave_value_list
 mx_sort (const Matrix& m)
 {
   octave_value_list retval;
 
   int nr = m.rows ();
@@ -171,17 +171,17 @@ mx_sort (const Matrix& m)
       return retval;
     }
   else if (nr > 1 && nc > 0)
     {
       for (int j = 0; j < nc; j++)
 	{
 	  Array<int> l = create_index_array (nr);
 
-	  DO_SORT (nr, (m.elem (p-1, j) > m.elem (q-1, j)));
+	  DO_SORT (nr, (m (p-1, j) > m (q-1, j)));
 
 	  MATRIX_CREATE_RETURN_VALUES (ms, m);
 	}
     }
 
   retval (1) = idx;
   retval (0) = ms;
 
@@ -204,17 +204,17 @@ mx_sort (const RowVector& v)
       retval (0) = v;
 
       return retval;
     }
   else if (n > 1)
     {
       Array<int> l = create_index_array (n);
 
-      DO_SORT (n, (v.elem (p-1) > v.elem (q-1)));
+      DO_SORT (n, (v (p-1) > v (q-1)));
 
       VECTOR_CREATE_RETURN_VALUES (vs, v);
     }
 
   retval (1) = octave_value (idx, 0);
   retval (0) = octave_value (vs, 0);
 
   return retval;
@@ -241,25 +241,25 @@ mx_sort (const ComplexMatrix& cm)
   else if (nr > 1 && nc > 0)
     {
       for (int j = 0; j < nc; j++)
 	{
 	  Array<int> l = create_index_array (nr);
 
 	  int all_elts_real = 1;
 	  for (int i = 0; i < nr; i++)
-	    if (imag (cm.elem (i, j)) != 0.0)
+	    if (imag (cm (i, j)) != 0.0)
 	      {
 		all_elts_real = 0;
 		break;
 	      }
 
 	  DO_SORT (nr, ((all_elts_real
-			 && real (cm.elem (p-1, j)) > real (cm.elem (q-1, j)))
-			|| abs (cm.elem (p-1, j)) > abs (cm.elem (q-1, j))));
+			 && real (cm (p-1, j)) > real (cm (q-1, j)))
+			|| abs (cm (p-1, j)) > abs (cm (q-1, j))));
 
 	  MATRIX_CREATE_RETURN_VALUES (cms, cm);
 	}
     }
 
   retval (1) = idx;
   retval (0) = cms;
 
@@ -284,25 +284,25 @@ mx_sort (ComplexRowVector& cv)
       return retval;
     }
   else if (n > 1)
     {
       Array<int> l = create_index_array (n);
 
       int all_elts_real = 1;
       for (int i = 0; i < n; i++)
-	if (imag (cv.elem (i)) != 0.0)
+	if (imag (cv (i)) != 0.0)
 	  {
 	    all_elts_real = 0;
 	    break;
 	  }
 
       DO_SORT (n, ((all_elts_real
-		    && real (cv.elem (p-1)) > real (cv.elem (q-1)))
-		   || abs (cv.elem (p-1)) > abs (cv.elem (q-1))));
+		    && real (cv (p-1)) > real (cv (q-1)))
+		   || abs (cv (p-1)) > abs (cv (q-1))));
 
       VECTOR_CREATE_RETURN_VALUES (cvs, cv);
     }
 
   retval (1) = octave_value (idx, 0);
   retval (0) = octave_value (cvs, 0);
 
   return retval;
@@ -337,17 +337,17 @@ sort the columns of X, optionally return
 
       if (! error_state)
 	{
 	  if (m.rows () == 1)
 	    {
 	      int nc = m.columns ();
 	      RowVector v (nc);
 	      for (int i = 0; i < nc; i++)
-		v.elem (i) = m.elem (0, i);
+		v (i) = m (0, i);
 
 	      retval = mx_sort (v);
 	    }
 	  else
 	    retval = mx_sort (m);
 	}
     }
   else if (arg.is_complex_type ())
@@ -356,17 +356,17 @@ sort the columns of X, optionally return
 
       if (! error_state)
 	{
 	  if (cm.rows () == 1)
 	    {
 	      int nc = cm.columns ();
 	      ComplexRowVector cv (nc);
 	      for (int i = 0; i < nc; i++)
-		cv.elem (i) = cm.elem (0, i);
+		cv (i) = cm (0, i);
 
 	      retval = mx_sort (cv);
 	    }
 	  else
 	    retval = mx_sort (cm);
 	}
     }
   else
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -153,17 +153,17 @@ DEFUN(exec, args, ,
 		  exec_args[0] = strsave (exec_file.c_str ());
 		  exec_args[nr+1] = 0;
 
 		  for (int i = 0; i < nr; i++)
 		    {
 		      exec_args[i+1] = new char [nc+1];
 
 		      for (int j = 0; j < nc; j++)
-			exec_args[i+1][j] = chm.elem (i, j);
+			exec_args[i+1][j] = chm (i, j);
 
 		      exec_args[i+1][nc] = '\0';
 		    }
 		}
 	      else
 		error ("exec: arguments must be strings");
 	    }
 	  else
@@ -402,18 +402,18 @@ DEFUN (pipe, args, ,
 	  octave_istdiostream *is
 	    = new octave_istdiostream (string (), in_file);
 
 	  octave_ostdiostream *os
 	    = new octave_ostdiostream (string (), out_file);
 
 	  Matrix file_ids (1, 2);
 
-	  file_ids.elem (0, 0) = octave_stream_list::insert (is);
-	  file_ids.elem (0, 1) = octave_stream_list::insert (os);
+	  file_ids (0, 0) = octave_stream_list::insert (is);
+	  file_ids (0, 1) = octave_stream_list::insert (os);
 
           retval(0) = file_ids;
 	  retval(1) = 0.0;
 	}	  
     }
   else
     print_usage ("pipe");
 #else
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -198,62 +198,62 @@ x_el_div (double a, const Matrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   Matrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result.elem (i, j) = a / b.elem (i, j);
+      result (i, j) = a / b (i, j);
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (double a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result.elem (i, j) = a / b.elem (i, j);
+      result (i, j) = a / b (i, j);
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const Matrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result.elem (i, j) = a / b.elem (i, j);
+      result (i, j) = a / b (i, j);
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result.elem (i, j) = a / b.elem (i, j);
+      result (i, j) = a / b (i, j);
 
   return result;
 }
 
 // Left division functions.
 //
 //       op2 \ op1:   m   cm
 //            +--   +---+----+
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -45,17 +45,17 @@ Software Foundation, 59 Temple Place - S
 
 static int
 any_element_is_negative (const Matrix& a)
 {
   int nr = a.rows ();
   int nc = a.columns ();
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      if (a.elem (i, j) < 0.0)
+      if (a (i, j) < 0.0)
 	return 1;
   return 0;
 }
 
 static inline int
 xisint (double x)
 {
   return (D_NINT (x) == x
@@ -105,21 +105,21 @@ xpow (double a, const Matrix& b)
   else
     {
       EIG b_eig (b);
       ComplexColumnVector lambda (b_eig.eigenvalues ());
       ComplexMatrix Q (b_eig.eigenvectors ());
 
       for (int i = 0; i < nr; i++)
 	{
-	  Complex elt = lambda.elem (i);
+	  Complex elt = lambda (i);
 	  if (imag (elt) == 0.0)
-	    lambda.elem (i) = pow (a, real (elt));
+	    lambda (i) = pow (a, real (elt));
 	  else
-	    lambda.elem (i) = pow (a, elt);
+	    lambda (i) = pow (a, elt);
 	}
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
@@ -150,21 +150,21 @@ xpow (double a, const ComplexMatrix& b)
   else
     {
       EIG b_eig (b);
       ComplexColumnVector lambda (b_eig.eigenvalues ());
       ComplexMatrix Q (b_eig.eigenvectors ());
 
       for (int i = 0; i < nr; i++)
 	{
-	  Complex elt = lambda.elem (i);
+	  Complex elt = lambda (i);
 	  if (imag (elt) == 0.0)
-	    lambda.elem (i) = pow (a, real (elt));
+	    lambda (i) = pow (a, real (elt));
 	  else
-	    lambda.elem (i) = pow (a, elt);
+	    lambda (i) = pow (a, elt);
 	}
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
@@ -223,17 +223,17 @@ xpow (const Matrix& a, double b)
 	}
       else
 	{
 	  EIG a_eig (a);
 	  ComplexColumnVector lambda (a_eig.eigenvalues ());
 	  ComplexMatrix Q (a_eig.eigenvectors ());
 
 	  for (int i = 0; i < nr; i++)
-	    lambda.elem (i) = pow (lambda.elem (i), b);
+	    lambda (i) = pow (lambda (i), b);
 
 	  ComplexDiagMatrix D (lambda);
 
 	  retval = ComplexMatrix (Q * D * Q.inverse ());
 	}
     }
 
   return retval;
@@ -254,17 +254,17 @@ xpow (const Matrix& a, const Complex& b)
     }
   else
     {
       EIG a_eig (a);
       ComplexColumnVector lambda (a_eig.eigenvalues ());
       ComplexMatrix Q (a_eig.eigenvectors ());
 
       for (int i = 0; i < nr; i++)
-	lambda.elem (i) = pow (lambda.elem (i), b);
+	lambda (i) = pow (lambda (i), b);
 
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
@@ -299,21 +299,21 @@ xpow (const Complex& a, const Matrix& b)
   else
     {
       EIG b_eig (b);
       ComplexColumnVector lambda (b_eig.eigenvalues ());
       ComplexMatrix Q (b_eig.eigenvectors ());
 
       for (int i = 0; i < nr; i++)
 	{
-	  Complex elt = lambda.elem (i);
+	  Complex elt = lambda (i);
 	  if (imag (elt) == 0.0)
-	    lambda.elem (i) = pow (a, real (elt));
+	    lambda (i) = pow (a, real (elt));
 	  else
-	    lambda.elem (i) = pow (a, elt);
+	    lambda (i) = pow (a, elt);
 	}
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
@@ -343,21 +343,21 @@ xpow (const Complex& a, const ComplexMat
   else
     {
       EIG b_eig (b);
       ComplexColumnVector lambda (b_eig.eigenvalues ());
       ComplexMatrix Q (b_eig.eigenvectors ());
 
       for (int i = 0; i < nr; i++)
 	{
-	  Complex elt = lambda.elem (i);
+	  Complex elt = lambda (i);
 	  if (imag (elt) == 0.0)
-	    lambda.elem (i) = pow (a, real (elt));
+	    lambda (i) = pow (a, real (elt));
 	  else
-	    lambda.elem (i) = pow (a, elt);
+	    lambda (i) = pow (a, elt);
 	}
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
@@ -416,17 +416,17 @@ xpow (const ComplexMatrix& a, double b)
 	}
       else
 	{
 	  EIG a_eig (a);
 	  ComplexColumnVector lambda (a_eig.eigenvalues ());
 	  ComplexMatrix Q (a_eig.eigenvectors ());
 
 	  for (int i = 0; i < nr; i++)
-	    lambda.elem (i) = pow (lambda.elem (i), b);
+	    lambda (i) = pow (lambda (i), b);
 
 	  ComplexDiagMatrix D (lambda);
 
 	  retval = ComplexMatrix (Q * D * Q.inverse ());
 	}
     }
 
   return retval;
@@ -447,17 +447,17 @@ xpow (const ComplexMatrix& a, const Comp
     }
   else
     {
       EIG a_eig (a);
       ComplexColumnVector lambda (a_eig.eigenvalues ());
       ComplexMatrix Q (a_eig.eigenvectors ());
 
       for (int i = 0; i < nr; i++)
-	lambda.elem (i) = pow (lambda.elem (i), b);
+	lambda (i) = pow (lambda (i), b);
 
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
@@ -489,26 +489,26 @@ elem_xpow (double a, const Matrix& b)
   // For now, assume the worst.
 
   if (a < 0.0)
     {
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result.elem (i, j) = pow (atmp, b.elem (i, j));
+	  result (i, j) = pow (atmp, b (i, j));
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result.elem (i, j) = pow (a, b.elem (i, j)); 
+	  result (i, j) = pow (a, b (i, j)); 
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 2 -*-
@@ -516,17 +516,17 @@ octave_value
 elem_xpow (double a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result.elem (i, j) = pow (a, b.elem (i, j));
+      result (i, j) = pow (a, b (i, j));
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
 elem_xpow (const Matrix& a, double b)
 {
@@ -536,28 +536,28 @@ elem_xpow (const Matrix& a, double b)
   int nc = a.columns ();
 
   if ((int) b != b && any_element_is_negative (a))
     {
       ComplexMatrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
-	    Complex atmp (a.elem (i, j));
-	    result.elem (i, j) = pow (atmp, b);
+	    Complex atmp (a (i, j));
+	    result (i, j) = pow (atmp, b);
 	  }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result.elem (i, j) = pow (a.elem (i, j), b);
+	  result (i, j) = pow (a (i, j), b);
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 4 -*-
@@ -570,48 +570,48 @@ elem_xpow (const Matrix& a, const Matrix
   int nc = a.columns ();
 
   assert (nr == b.rows () && nc == b.columns ());
 
   int convert_to_complex = 0;
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double atmp = a.elem (i, j);
-	double btmp = b.elem (i, j);
+	double atmp = a (i, j);
+	double btmp = b (i, j);
 	if (atmp < 0.0 && (int) btmp != btmp)
 	  {
 	    convert_to_complex = 1;
 	    goto done;
 	  }
       }
 
  done:
 
   if (convert_to_complex)
     {
       ComplexMatrix complex_result (nr, nc);
 
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
-	    Complex atmp (a.elem (i, j));
-	    Complex btmp (b.elem (i, j));
-	    complex_result.elem (i, j) = pow (atmp, btmp);
+	    Complex atmp (a (i, j));
+	    Complex btmp (b (i, j));
+	    complex_result (i, j) = pow (atmp, btmp);
 	  }
 
       retval = complex_result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result.elem (i, j) = pow (a.elem (i, j), b.elem (i, j));
+	  result (i, j) = pow (a (i, j), b (i, j));
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 5 -*-
@@ -619,70 +619,70 @@ octave_value
 elem_xpow (const Matrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result.elem (i, j) = pow (a.elem (i, j), b);
+      result (i, j) = pow (a (i, j), b);
 
   return result;
 }
 
 // -*- 6 -*-
 octave_value
 elem_xpow (const Matrix& a, const ComplexMatrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   assert (nr == b.rows () && nc == b.columns ());
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result.elem (i, j) = pow (a.elem (i, j), b.elem (i, j));
+      result (i, j) = pow (a (i, j), b (i, j));
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const Complex& a, const Matrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double btmp = b.elem (i, j);
+	double btmp = b (i, j);
 	if (xisint (btmp))
-	  result.elem (i, j) = pow (a, (int) btmp);
+	  result (i, j) = pow (a, (int) btmp);
 	else
-	  result.elem (i, j) = pow (a, btmp);
+	  result (i, j) = pow (a, btmp);
       }
 
   return result;
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const Complex& a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result.elem (i, j) = pow (a, b.elem (i, j));
+      result (i, j) = pow (a, b (i, j));
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, double b)
 {
@@ -690,23 +690,23 @@ elem_xpow (const ComplexMatrix& a, doubl
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
 
   if (xisint (b))
     {
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result.elem (i, j) = pow (a.elem (i, j), (int) b);
+	  result (i, j) = pow (a (i, j), (int) b);
     }
   else
     {
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result.elem (i, j) = pow (a.elem (i, j), b);
+	  result (i, j) = pow (a (i, j), b);
     }
 
   return result;
 }
 
 // -*- 10 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const Matrix& b)
@@ -715,53 +715,53 @@ elem_xpow (const ComplexMatrix& a, const
   int nc = a.columns ();
 
   assert (nr == b.rows () && nc == b.columns ());
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
-	double btmp = b.elem (i, j);
+	double btmp = b (i, j);
 	if (xisint (btmp))
-	  result.elem (i, j) = pow (a.elem (i, j), (int) btmp);
+	  result (i, j) = pow (a (i, j), (int) btmp);
 	else
-	  result.elem (i, j) = pow (a.elem (i, j), btmp);
+	  result (i, j) = pow (a (i, j), btmp);
       }
 
   return result;
 }
 
 // -*- 11 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result.elem (i, j) = pow (a.elem (i, j), b);
+      result (i, j) = pow (a (i, j), b);
 
   return result;
 }
 
 // -*- 12 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      result.elem (i, j) = pow (a.elem (i, j), b.elem (i, j));
+      result (i, j) = pow (a (i, j), b (i, j));
 
   return result;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
