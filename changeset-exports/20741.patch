# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1448329807 18000
#      Mon Nov 23 20:50:07 2015 -0500
# Node ID a5ab31b52ae84ad05a8dae326f0766097f5b4600
# Parent  bba1a5fd4d8c7a8cf70f9e29ffa5317546ffccc1
eliminate more uses of error_state

* __qp__.cc, besselj.cc, data.cc, file-io.cc, input.cc, load-save.cc,
ls-oct-text.cc, oct-map.cc, oct-stream.cc, syscalls.cc, toplev.cc,
ov-base.cc, ov-cell.cc, ov-fcn-handle.cc: Eliminate more uses of
error_state.

* ov.h, ov.cc (octave_value::xfunction_value,
octave_value::xuser_function_value,
octave_value::xuser_script_value, octave_value::xuser_code_value,
octave_value::xfcn_handle_value, octave_value::xfcn_inline_value,
octave_value::xlist_value): New value extraction functions.

diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -131,22 +131,25 @@ qp (const Matrix& H, const ColumnVector&
               bact.resize (n_act, bin(i));
               Wact.resize (n_act-n_eq, i);
             }
         }
     }
 
   // Computing the ???
 
-  EIG eigH (H);
+  EIG eigH;
 
-  if (error_state)
+  try
+    {
+      eigH = EIG (H);
+    }
+  catch (const octave_execution_exception&)
     {
       error ("qp: failed to compute eigenvalues of H");
-      return -1;
     }
 
   ColumnVector eigenvalH = real (eigH.eigenvalues ());
   Matrix eigenvecH = real (eigH.eigenvectors ());
   double minReal = eigenvalH.min ();
   octave_idx_type indminR = 0;
   for (octave_idx_type i = 0; i < n; i++)
     {
@@ -276,22 +279,25 @@ qp (const Matrix& H, const ColumnVector&
                 }
             }
           else
             {
               info = 1;
 
               // Searching for the most negative curvature.
 
-              EIG eigrH (rH);
+              EIG eigrH;
 
-              if (error_state)
+              try
+                {
+                  eigrH = EIG (rH);
+                }
+              catch (const octave_execution_exception&)
                 {
                   error ("qp: failed to compute eigenvalues of rH");
-                  return -1;
                 }
 
               ColumnVector eigenvalrH = real (eigrH.eigenvalues ());
               Matrix eigenvecrH = real (eigrH.eigenvectors ());
               double mRrH = eigenvalrH.min ();
               indminR = 0;
               for (octave_idx_type i = 0; i < n; i++)
                 {
diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -24,17 +24,16 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "lo-specfun.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 enum bessel_type
 {
   BESSEL_J,
   BESSEL_Y,
   BESSEL_I,
@@ -73,22 +72,16 @@ enum bessel_type
             break; \
  \
           default: \
             break; \
         } \
     } \
   while (0)
 
-static void
-gripe_bessel_arg (const char *fn, const char *arg)
-{
-  error ("%s: %s argument must be a scalar or matrix", fn, arg);
-}
-
 octave_value_list
 do_bessel (enum bessel_type type, const char *fn,
            const octave_value_list& args, int nargout)
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1799,38 +1799,56 @@ attempt_type_conversion (const octave_va
   // type.
 
   std::string cname = ov.class_name ();
 
   octave_value fcn = symbol_table::find_method (dtype, cname);
 
   if (fcn.is_defined ())
     {
-      octave_value_list result
-        = fcn.do_multi_index_op (1, octave_value_list (1, ov));
-
-      if (! error_state && result.length () > 0)
+      octave_value_list result;
+
+      try
+        {
+          result = fcn.do_multi_index_op (1, octave_value_list (1, ov));
+        }
+      catch (const octave_execution_exception&)
+        {
+          error ("conversion from %s to %s failed", dtype.c_str (),
+                 cname.c_str ());
+        }
+
+      if (result.length () > 0)
         retval = result(0);
       else
         error ("conversion from %s to %s failed", dtype.c_str (),
                cname.c_str ());
     }
   else
     {
       // No conversion function available.  Try the constructor for the
       // dispatch type.
 
       fcn = symbol_table::find_method (dtype, dtype);
 
       if (fcn.is_defined ())
         {
-          octave_value_list result
-            = fcn.do_multi_index_op (1, octave_value_list (1, ov));
-
-          if (! error_state && result.length () > 0)
+          octave_value_list result;
+
+          try
+            {
+              result = fcn.do_multi_index_op (1, octave_value_list (1, ov));
+            }
+          catch (const octave_execution_exception&)
+            {
+              error ("%s constructor failed for %s argument", dtype.c_str (),
+                     cname.c_str ());
+            }
+
+          if (result.length () > 0)
             retval = result(0);
           else
             error ("%s constructor failed for %s argument", dtype.c_str (),
                    cname.c_str ());
         }
       else
         error ("no constructor for %s!", dtype.c_str ());
     }
@@ -1848,26 +1866,32 @@ do_class_concat (const octave_value_list
   std::string dtype = get_dispatch_type (ovl);
 
   octave_value fcn = symbol_table::find_method (cattype, dtype);
 
   if (fcn.is_defined ())
     {
       // Have method for dominant type.  Call it and let it handle conversions.
 
-      octave_value_list tmp2 = fcn.do_multi_index_op (1, ovl);
+      octave_value_list tmp2;
+
+      try
+        {
+          tmp2 = fcn.do_multi_index_op (1, ovl);
+        }
+      catch (const octave_execution_exception&)
+        {
+          error ("%s/%s method failed", dtype.c_str (), cattype.c_str ());
+        }
 
       if (tmp2.length () > 0)
         retval = tmp2(0);
       else
-        {
-          error ("%s/%s method did not return a value",
-                 dtype.c_str (), cattype.c_str ());
-          goto done;
-        }
+        error ("%s/%s method did not return a value", dtype.c_str (),
+               cattype.c_str ());
     }
   else
     {
       // No method for dominant type, so attempt type conversions for
       // all elements that are not of the dominant type, then do the
       // default operation for octave_class values.
 
       octave_idx_type j = 0;
@@ -1890,17 +1914,16 @@ do_class_concat (const octave_value_list
       octave_map m = do_single_type_concat_map (tmp, dim);
 
       std::string cname = tmp(0).class_name ();
       std::list<std::string> parents = tmp(0).parent_class_name_list ();
 
       retval = octave_value (new octave_class (m, cname, parents));
     }
 
-done:
   return retval;
 }
 
 static octave_value
 do_cat (const octave_value_list& xargs, int dim, std::string fname)
 {
   octave_value retval;
 
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1312,52 +1312,54 @@ It is currently not useful to call @code
   return Ffscanf (tmp_args, nargout);
 }
 
 static octave_value
 do_fread (octave_stream& os, const octave_value& size_arg,
           const octave_value& prec_arg, const octave_value& skip_arg,
           const octave_value& arch_arg, octave_idx_type& count)
 {
-  octave_value retval;
-
   count = -1;
 
   Array<double> size = size_arg.xvector_value ("fread: invalid SIZE specified");
 
   std::string prec = prec_arg.xstring_value ("fread: PRECISION must be a string");
 
   int block_size = 1;
   oct_data_conv::data_type input_type;
   oct_data_conv::data_type output_type;
 
-  oct_data_conv::string_to_data_type (prec, block_size,
-                                      input_type, output_type);
-
-  if (! error_state)
+  try
     {
-      int skip = skip_arg.int_value (true);
+      oct_data_conv::string_to_data_type (prec, block_size,
+                                          input_type, output_type);
+    }
+  catch (const octave_execution_exception&)
+    {
+      error ("fread: invalid PRECISION specified");
+    }
 
-      if (! error_state)
-        {
-          std::string arch = arch_arg.xstring_value ("fread: ARCH architecture type must be a string");
+  int skip;
 
-          oct_mach_info::float_format flt_fmt
-            = oct_mach_info::string_to_float_format (arch);
+  try
+    {
+      skip = skip_arg.int_value (true);
+    }
+  catch (const octave_execution_exception&)
+    {
+      error ("fread: SKIP must be an integer");
+    }
 
-          retval = os.read (size, block_size, input_type,
-                            output_type, skip, flt_fmt, count);
-        }
-      else
-        error ("fread: SKIP must be an integer");
-    }
-  else
-    error ("fread: invalid PRECISION specified");
+  std::string arch = arch_arg.xstring_value ("fread: ARCH architecture type must be a string");
 
-  return retval;
+  oct_mach_info::float_format flt_fmt
+    = oct_mach_info::string_to_float_format (arch);
+
+  return os.read (size, block_size, input_type, output_type, skip,
+                  flt_fmt, count);
 }
 
 DEFUN (fread, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} fread (@var{fid})\n\
 @deftypefnx {Built-in Function} {@var{val} =} fread (@var{fid}, @var{size})\n\
 @deftypefnx {Built-in Function} {@var{val} =} fread (@var{fid}, @var{size}, @var{precision})\n\
 @deftypefnx {Built-in Function} {@var{val} =} fread (@var{fid}, @var{size}, @var{precision}, @var{skip})\n\
@@ -1574,46 +1576,47 @@ The optional return value @var{count} co
   return retval;
 }
 
 static int
 do_fwrite (octave_stream& os, const octave_value& data,
            const octave_value& prec_arg, const octave_value& skip_arg,
            const octave_value& arch_arg)
 {
-  int retval = -1;
-
   std::string prec = prec_arg.xstring_value ("fwrite: PRECISION must be a string");
 
   int block_size = 1;
   oct_data_conv::data_type output_type;
 
-  oct_data_conv::string_to_data_type (prec, block_size, output_type);
-
-  if (! error_state)
+  try
     {
-      int skip = skip_arg.int_value (true);
+      oct_data_conv::string_to_data_type (prec, block_size, output_type);
+    }
+  catch (const octave_execution_exception&)
+    {
+      error ("fwrite: invalid PRECISION specified");
+    }
 
-      if (! error_state)
-        {
-          std::string arch = arch_arg.xstring_value ("fwrite: ARCH architecture type must be a string");
+  int skip;
 
-          oct_mach_info::float_format flt_fmt
-            = oct_mach_info::string_to_float_format (arch);
+  try
+    {
+      skip = skip_arg.int_value (true);
+    }
+  catch (const octave_execution_exception&)
+    {
+      error ("fwrite: SKIP must be an integer");
+    }
 
-          retval = os.write (data, block_size, output_type,
-                             skip, flt_fmt);
-        }
-      else
-        error ("fwrite: SKIP must be an integer");
-    }
-  else
-    error ("fwrite: invalid PRECISION specified");
+  std::string arch = arch_arg.xstring_value ("fwrite: ARCH architecture type must be a string");
 
-  return retval;
+  oct_mach_info::float_format flt_fmt
+    = oct_mach_info::string_to_float_format (arch);
+
+  return os.write (data, block_size, output_type, skip, flt_fmt);
 }
 
 DEFUN (fwrite, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fwrite (@var{fid}, @var{data})\n\
 @deftypefnx {Built-in Function} {} fwrite (@var{fid}, @var{data}, @var{precision})\n\
 @deftypefnx {Built-in Function} {} fwrite (@var{fid}, @var{data}, @var{precision}, @var{skip})\n\
 @deftypefnx {Built-in Function} {} fwrite (@var{fid}, @var{data}, @var{precision}, @var{skip}, @var{arch})\n\
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -1256,27 +1256,22 @@ list of input hook functions.\n\
     {
       octave_value user_data;
 
       if (nargin == 2)
         user_data = args(1);
 
       hook_function hook_fcn (args(0), user_data);
 
-      if (! error_state)
-        {
-          if (input_event_hook_functions.empty ())
-            command_editor::add_event_hook (internal_input_event_hook_fcn);
+      if (input_event_hook_functions.empty ())
+        command_editor::add_event_hook (internal_input_event_hook_fcn);
 
-          input_event_hook_functions.insert (hook_fcn.id (), hook_fcn);
+      input_event_hook_functions.insert (hook_fcn.id (), hook_fcn);
 
-          retval = hook_fcn.id ();
-        }
-      else
-        error ("add_input_event_hook: FCN must be a function handle or string");
+      retval = hook_fcn.id ();
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (remove_input_event_hook, args, ,
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -393,17 +393,17 @@ do_load (std::istream& stream, const std
                                            global, tc);
           break;
 
         default:
           gripe_unrecognized_data_fmt ("load");
           break;
         }
 
-      if (error_state || stream.eof () || name.empty ())
+      if (stream.eof () || name.empty ())
         break;
       else
         {
           if (tc.is_defined ())
             {
               if (format == LS_MAT_ASCII && argv_idx < argc)
                 warning ("load: loaded ASCII file '%s' -- ignoring extra args",
                          orig_fname.c_str ());
diff --git a/libinterp/corefcn/ls-oct-text.cc b/libinterp/corefcn/ls-oct-text.cc
--- a/libinterp/corefcn/ls-oct-text.cc
+++ b/libinterp/corefcn/ls-oct-text.cc
@@ -246,21 +246,18 @@ read_text_data (std::istream& is, const 
         error ("load: empty name keyword or no data found in file '%s'",
                filename.c_str ());
 
       return std::string ();
     }
 
   if (! (name == ".nargin." || name == ".nargout."
          || name == CELL_ELT_TAG || valid_identifier (name)))
-    {
-      error ("load: bogus identifier '%s' found in file '%s'",
-             name.c_str (), filename.c_str ());
-      return std::string ();
-    }
+    error ("load: bogus identifier '%s' found in file '%s'",
+           name.c_str (), filename.c_str ());
 
   // Look for type keyword.
 
   std::string tag = extract_keyword (is, "type");
 
   if (! tag.empty ())
     {
       std::string typ;
@@ -282,22 +279,16 @@ read_text_data (std::istream& is, const 
         tc = octave_value_typeinfo::lookup_type (typ);
 
       if (! tc.load_ascii (is))
         error ("load: trouble reading ascii file '%s'", filename.c_str ());
     }
   else
     error ("load: failed to extract keyword specifying value type");
 
-  if (error_state)
-    {
-      error ("load: reading file %s", filename.c_str ());
-      return std::string ();
-    }
-
   return name;
 }
 
 // Save the data from TC along with the corresponding NAME, and global
 // flag MARK_AS_GLOBAL on stream OS in the plain text format described
 // above for load_text_data.  If NAME is empty, the name: line is not
 // generated.  PRECISION specifies the number of decimal digits to print.
 //
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -634,30 +634,31 @@ static void
 permute_to_correct_order (octave_idx_type n, octave_idx_type nf,
                           octave_idx_type idx, const map *map_list,
                           map *new_map_list)
 {
   new_map_list[idx] = map_list[idx];
 
   Array<octave_idx_type> perm (dim_vector (1, nf));
 
-  for (octave_idx_type i = 0; i < n; i++)
+  try
     {
-      if (i == idx)
-        continue;
+      for (octave_idx_type i = 0; i < n; i++)
+        {
+          if (i == idx)
+            continue;
 
-      permute_to_correct_order1 (map_list[idx], map_list[i], new_map_list[i],
-                                 perm);
-
-      if (error_state)
-        {
-          error ("cat: field names mismatch in concatenating structs");
-          break;
+          permute_to_correct_order1 (map_list[idx], map_list[i],
+                                     new_map_list[i], perm);
         }
     }
+  catch (const octave_execution_exception&)
+    {
+      error ("cat: field names mismatch in concatenating structs");
+    }
 }
 
 
 octave_map
 octave_map::cat (int dim, octave_idx_type n, const octave_scalar_map *map_list)
 {
   octave_map retval;
 
@@ -989,24 +990,29 @@ octave_map::assign (const idx_vector& i,
     {
       octave_map tmp (dimensions, rhs.xkeys);
       tmp.assign (i, rhs);
       *this = tmp;
     }
   else
     {
       Array<octave_idx_type> perm;
-      octave_map rhs1 = rhs.orderfields (*this, perm);
-      if (! error_state)
+      octave_map rhs1;
+
+      try
         {
-          assert (rhs1.xkeys.is_same (xkeys));
-          assign (i, rhs1);
+          rhs1 = rhs.orderfields (*this, perm);
         }
-      else
-        error ("incompatible fields in struct assignment");
+      catch (const octave_execution_exception&)
+        {
+          error ("incompatible fields in struct assignment");
+        }
+
+      assert (rhs1.xkeys.is_same (xkeys));
+      assign (i, rhs1);
     }
 }
 
 void
 octave_map::assign (const idx_vector& i, const idx_vector& j,
                     const octave_map& rhs)
 {
   if (rhs.xkeys.is_same (xkeys))
@@ -1032,24 +1038,29 @@ octave_map::assign (const idx_vector& i,
     {
       octave_map tmp (dimensions, rhs.xkeys);
       tmp.assign (i, j, rhs);
       *this = tmp;
     }
   else
     {
       Array<octave_idx_type> perm;
-      octave_map rhs1 = rhs.orderfields (*this, perm);
-      if (! error_state)
+      octave_map rhs1;
+
+      try
         {
-          assert (rhs1.xkeys.is_same (xkeys));
-          assign (i, j, rhs1);
+          rhs1 = rhs.orderfields (*this, perm);
         }
-      else
-        error ("incompatible fields in struct assignment");
+      catch (const octave_execution_exception&)
+        {
+          error ("incompatible fields in struct assignment");
+        }
+
+      assert (rhs1.xkeys.is_same (xkeys));
+      assign (i, j, rhs1);
     }
 }
 
 void
 octave_map::assign (const Array<idx_vector>& ia,
                     const octave_map& rhs)
 {
   if (rhs.xkeys.is_same (xkeys))
@@ -1075,24 +1086,29 @@ octave_map::assign (const Array<idx_vect
     {
       octave_map tmp (dimensions, rhs.xkeys);
       tmp.assign (ia, rhs);
       *this = tmp;
     }
   else
     {
       Array<octave_idx_type> perm;
-      octave_map rhs1 = rhs.orderfields (*this, perm);
-      if (! error_state)
+      octave_map rhs1;
+
+      try
         {
-          assert (rhs1.xkeys.is_same (xkeys));
-          assign (ia, rhs1);
+          rhs1 = rhs.orderfields (*this, perm);
         }
-      else
-        error ("incompatible fields in struct assignment");
+      catch (const octave_execution_exception&)
+        {
+          error ("incompatible fields in struct assignment");
+        }
+
+      assert (rhs1.xkeys.is_same (xkeys));
+      assign (ia, rhs1);
     }
 }
 
 void
 octave_map::assign (const octave_value_list& idx, const octave_map& rhs)
 {
   octave_idx_type n_idx = idx.length ();
 
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -60,34 +60,38 @@ along with Octave; see the file COPYING.
 
 static int
 convert_to_valid_int (const octave_value& tc, int& conv_err)
 {
   int retval = 0;
 
   conv_err = 0;
 
-  double dval = tc.double_value ();
-
-  if (! error_state)
+  double dval;
+
+  try
+    {
+      dval = tc.double_value ();
+    }
+  catch (const octave_execution_exception&)
     {
-      if (! lo_ieee_isnan (dval))
-        {
-          int ival = NINT (dval);
-
-          if (ival == dval)
-            retval = ival;
-          else
-            conv_err = 3;
-        }
+      conv_err = 1;
+    }
+
+  if (! lo_ieee_isnan (dval))
+    {
+      int ival = NINT (dval);
+
+      if (ival == dval)
+        retval = ival;
       else
-        conv_err = 2;
+        conv_err = 3;
     }
   else
-    conv_err = 1;
+    conv_err = 2;
 
   return retval;
 }
 
 static int
 get_size (double d, const std::string& who)
 {
   int retval = -1;
@@ -2241,29 +2245,19 @@ printf_value_cache::get_next_value (char
     curr_state = conversion_error;
 
   while (! exhausted ())
     {
       if (! have_data)
         {
           curr_val = values (val_idx);
 
-          // Force string conversion here for compatibility.
-
-          if (! error_state)
-            {
-              elt_idx = 0;
-              n_elts = curr_val.numel ();
-              have_data = true;
-            }
-          else
-            {
-              curr_state = conversion_error;
-              break;
-            }
+          elt_idx = 0;
+          n_elts = curr_val.numel ();
+          have_data = true;
         }
 
       if (elt_idx < n_elts)
         {
           if (type == 's')
             {
               if (curr_val.is_string ())
                 {
@@ -3364,205 +3358,204 @@ octave_stream::read (const Array<double>
       // numbering stays consistent with the order of the elements in the
       // data_type enum in the oct_data_conv class.
 
       // Expose this in a future version?
       octave_idx_type char_count = 0;
 
       count = 0;
 
-      get_size (size, nr, nc, one_elt_size_spec, "fread");
-
-      if (! error_state)
+      try
+        {
+          get_size (size, nr, nc, one_elt_size_spec, "fread");
+        }
+      catch (const octave_execution_exception&)
         {
-          octave_idx_type elts_to_read;
-
-          if (one_elt_size_spec)
-            {
-              // If NR == 0, Matlab returns [](0x0).
-
-              // If NR > 0, the result will be a column vector with the given
-              // number of rows.
-
-              // If NR < 0, then we have Inf and the result will be a column
-              // vector but we have to wait to see how big NR will be.
-
-              if (nr == 0)
-                nr = nc = 0;
-              else
-                nc = 1;
-            }
-          else
-            {
-              // Matlab returns [] even if there are two elements in the size
-              // specification and one is nonzero.
-
-              // If NC < 0 we have [NR, Inf] and we'll wait to decide how big NC
-              // should be.
-
-              if (nr == 0 || nc == 0)
-                nr = nc = 0;
-            }
-
-          // FIXME: Ensure that this does not overflow.
-          //        Maybe try comparing nr * nc computed in double with
-          //        std::numeric_limits<octave_idx_type>::max ();
-
-          elts_to_read = nr * nc;
-
-          bool read_to_eof = elts_to_read < 0;
-
-          octave_idx_type input_buf_elts = -1;
-
-          if (skip == 0)
-            {
-              if (read_to_eof)
-                input_buf_elts = 1024 * 1024;
-              else
-                input_buf_elts = elts_to_read;
-            }
+          invalid_operation ("fread", "reading");
+        }
+
+      octave_idx_type elts_to_read;
+
+      if (one_elt_size_spec)
+        {
+          // If NR == 0, Matlab returns [](0x0).
+
+          // If NR > 0, the result will be a column vector with the given
+          // number of rows.
+
+          // If NR < 0, then we have Inf and the result will be a column
+          // vector but we have to wait to see how big NR will be.
+
+          if (nr == 0)
+            nr = nc = 0;
           else
-            input_buf_elts = block_size;
-
-          octave_idx_type input_elt_size
-            = oct_data_conv::data_type_size (input_type);
-
-          octave_idx_type input_buf_size = input_buf_elts * input_elt_size;
-
-          assert (input_buf_size >= 0);
-
-          // Must also work and return correct type object
-          // for 0 elements to read.
-
-          std::istream *isp = input_stream ();
-
-          if (isp)
-            {
-              std::istream& is = *isp;
-
-              std::list <void *> input_buf_list;
-
-              while (is && ! is.eof ()
-                     && (read_to_eof || count < elts_to_read))
-                {
-                  if (! read_to_eof)
-                    {
-                      octave_idx_type remaining_elts = elts_to_read - count;
-
-                      if (remaining_elts < input_buf_elts)
-                        input_buf_size = remaining_elts * input_elt_size;
-                    }
-
-                  char *input_buf = new char [input_buf_size];
-
-                  is.read (input_buf, input_buf_size);
-
-                  size_t gcount = is.gcount ();
-
-                  char_count += gcount;
-
-                  octave_idx_type nel = gcount / input_elt_size;
-
-                  count += nel;
-
-                  input_buf_list.push_back (input_buf);
-
-                  if (is && skip != 0 && nel == block_size)
-                    {
-                      // Seek to skip.  If skip would move past EOF,
-                      // position at EOF.
-
-                      off_t orig_pos = tell ();
-
-                      seek (0, SEEK_END);
-
-                      off_t eof_pos = tell ();
-
-                      // Is it possible for this to fail to return us to
-                      // the original position?
-                      seek (orig_pos, SEEK_SET);
-
-                      off_t remaining = eof_pos - orig_pos;
-
-                      if (remaining < skip)
-                        seek (0, SEEK_END);
-                      else
-                        seek (skip, SEEK_CUR);
-
-                      if (! is)
-                        break;
-                    }
-                }
-
-              if (read_to_eof)
-                {
-                  if (nc < 0)
-                    {
-                      nc = count / nr;
-
-                      if (count % nr != 0)
-                        nc++;
-                    }
-                  else
-                    nr = count;
-                }
-              else if (count == 0)
-                {
-                  nr = 0;
-                  nc = 0;
-                }
-              else if (count != nr * nc)
-                {
-                  if (count % nr != 0)
-                    nc = count / nr + 1;
-                  else
-                    nc = count / nr;
-
-                  if (count < nr)
-                    nr = count;
-                }
-
-              retval = finalize_read (input_buf_list, input_buf_elts, count,
-                                      nr, nc, input_type, output_type, ffmt);
-            }
+            nc = 1;
+        }
+      else
+        {
+          // Matlab returns [] even if there are two elements in the size
+          // specification and one is nonzero.
+
+          // If NC < 0 we have [NR, Inf] and we'll wait to decide how big NC
+          // should be.
+
+          if (nr == 0 || nc == 0)
+            nr = nc = 0;
+        }
+
+      // FIXME: Ensure that this does not overflow.
+      //        Maybe try comparing nr * nc computed in double with
+      //        std::numeric_limits<octave_idx_type>::max ();
+
+      elts_to_read = nr * nc;
+
+      bool read_to_eof = elts_to_read < 0;
+
+      octave_idx_type input_buf_elts = -1;
+
+      if (skip == 0)
+        {
+          if (read_to_eof)
+            input_buf_elts = 1024 * 1024;
           else
-            error ("fread: invalid input stream");
+            input_buf_elts = elts_to_read;
         }
       else
-        invalid_operation ("fread", "reading");
+        input_buf_elts = block_size;
+
+      octave_idx_type input_elt_size
+                                        = oct_data_conv::data_type_size (input_type);
+
+      octave_idx_type input_buf_size = input_buf_elts * input_elt_size;
+
+      assert (input_buf_size >= 0);
+
+      // Must also work and return correct type object
+      // for 0 elements to read.
+
+      std::istream *isp = input_stream ();
+
+      if (isp)
+        {
+          std::istream& is = *isp;
+
+          std::list <void *> input_buf_list;
+
+          while (is && ! is.eof ()
+                 && (read_to_eof || count < elts_to_read))
+            {
+              if (! read_to_eof)
+                {
+                  octave_idx_type remaining_elts = elts_to_read - count;
+
+                  if (remaining_elts < input_buf_elts)
+                    input_buf_size = remaining_elts * input_elt_size;
+                }
+
+              char *input_buf = new char [input_buf_size];
+
+              is.read (input_buf, input_buf_size);
+
+              size_t gcount = is.gcount ();
+
+              char_count += gcount;
+
+              octave_idx_type nel = gcount / input_elt_size;
+
+              count += nel;
+
+              input_buf_list.push_back (input_buf);
+
+              if (is && skip != 0 && nel == block_size)
+                {
+                  // Seek to skip.  If skip would move past EOF,
+                  // position at EOF.
+
+                  off_t orig_pos = tell ();
+
+                  seek (0, SEEK_END);
+
+                  off_t eof_pos = tell ();
+
+                  // Is it possible for this to fail to return us to
+                  // the original position?
+                  seek (orig_pos, SEEK_SET);
+
+                  off_t remaining = eof_pos - orig_pos;
+
+                  if (remaining < skip)
+                    seek (0, SEEK_END);
+                  else
+                    seek (skip, SEEK_CUR);
+
+                  if (! is)
+                    break;
+                }
+            }
+
+          if (read_to_eof)
+            {
+              if (nc < 0)
+                {
+                  nc = count / nr;
+
+                  if (count % nr != 0)
+                    nc++;
+                }
+              else
+                nr = count;
+            }
+          else if (count == 0)
+            {
+              nr = 0;
+              nc = 0;
+            }
+          else if (count != nr * nc)
+            {
+              if (count % nr != 0)
+                nc = count / nr + 1;
+              else
+                nc = count / nr;
+
+              if (count < nr)
+                nr = count;
+            }
+
+          retval = finalize_read (input_buf_list, input_buf_elts, count,
+                                  nr, nc, input_type, output_type, ffmt);
+        }
+      else
+        error ("fread: invalid input stream");
     }
 
   return retval;
 }
 
 octave_idx_type
 octave_stream::write (const octave_value& data, octave_idx_type block_size,
                       oct_data_conv::data_type output_type,
                       octave_idx_type skip, oct_mach_info::float_format flt_fmt)
 {
   octave_idx_type retval = -1;
 
   if (stream_ok ())
     {
-      if (! error_state)
-        {
-          if (flt_fmt == oct_mach_info::flt_fmt_unknown)
-            flt_fmt = float_format ();
-
-          octave_idx_type status = data.write (*this, block_size, output_type,
-                                               skip, flt_fmt);
-
-          if (status < 0)
-            error ("fwrite: write error");
-          else
-            retval = status;
-        }
+      if (flt_fmt == oct_mach_info::flt_fmt_unknown)
+        flt_fmt = float_format ();
+
+      octave_idx_type status = data.write (*this, block_size, output_type,
+                                           skip, flt_fmt);
+
+      if (status < 0)
+        error ("fwrite: write error");
       else
-        invalid_operation ("fwrite", "writing");
+        retval = status;
     }
+  else
+    invalid_operation ("fwrite", "writing");
 
   return retval;
 }
 
 template <class T, class V>
 static void
 convert_chars (const void *data, void *conv_data, octave_idx_type n_elts)
 {
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -127,36 +127,31 @@ error message.\n\
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       octave_stream old_stream
         = octave_stream_list::lookup (args(0), "dup2");
 
-      if (! error_state)
-        {
-          octave_stream new_stream
-            = octave_stream_list::lookup (args(1), "dup2");
+      octave_stream new_stream
+        = octave_stream_list::lookup (args(1), "dup2");
 
-          int i_old = old_stream.file_number ();
-          int i_new = new_stream.file_number ();
+      int i_old = old_stream.file_number ();
+      int i_new = new_stream.file_number ();
 
-          if (i_old >= 0 && i_new >= 0)
-            {
-              std::string msg;
-
-              int status = octave_syscalls::dup2 (i_old, i_new, msg);
+      if (i_old >= 0 && i_new >= 0)
+        {
+          std::string msg;
 
-              retval(1) = msg;
-              retval(0) = status;
-            }
+          int status = octave_syscalls::dup2 (i_old, i_new, msg);
+
+          retval(1) = msg;
+          retval(0) = status;
         }
-      else
-        error ("dup2: invalid stream");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("exec", Fexec, args, ,
@@ -481,38 +476,33 @@ message.\n\
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 3)
     {
       octave_stream strm = octave_stream_list::lookup (args(0), "fcntl");
 
-      if (! error_state)
-        {
-          int fid = strm.file_number ();
+      int fid = strm.file_number ();
 
-          int req = args(1).int_value (true);
-          int arg = args(2).int_value (true);
+      int req = args(1).int_value (true);
+      int arg = args(2).int_value (true);
 
-          // FIXME: Need better checking here?
-          if (fid < 0)
-            error ("fcntl: invalid file id");
-          else
-            {
-              std::string msg;
+      // FIXME: Need better checking here?
+      if (fid < 0)
+        error ("fcntl: invalid file id");
+      else
+        {
+          std::string msg;
 
-              int status = octave_fcntl (fid, req, arg, msg);
+          int status = octave_fcntl (fid, req, arg, msg);
 
-              retval(1) = msg;
-              retval(0) = status;
-            }
+          retval(1) = msg;
+          retval(0) = status;
         }
-      else
-        error ("fcntl: FID, REQUEST, and ARG must be integers");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("fork", Ffork, args, ,
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -625,32 +625,20 @@ main_loop (void)
 
                       if (tree_break_command::breaking)
                         tree_break_command::breaking--;
 
                       if (quit)
                         break;
                     }
 
-                  if (error_state)
-                    {
-                      if (! interactive)
-                        {
-                          // We should exit with a nonzero status.
-                          retval = 1;
-                          break;
-                        }
-                    }
+                  if (octave_completion_matches_called)
+                    octave_completion_matches_called = false;
                   else
-                    {
-                      if (octave_completion_matches_called)
-                        octave_completion_matches_called = false;
-                      else
-                        command_editor::increment_current_command_number ();
-                    }
+                    command_editor::increment_current_command_number ();
                 }
               else if (parser.lexer.end_of_input)
                 break;
             }
         }
       catch (const octave_interrupt_exception&)
         {
           recover_from_exception ();
@@ -667,17 +655,24 @@ main_loop (void)
         }
       catch (const octave_execution_exception& e)
         {
           std::string stack_trace = e.info ();
 
           if (! stack_trace.empty ())
             std::cerr << stack_trace;
 
-          recover_from_exception ();
+          if (interactive)
+            recover_from_exception ();
+          else
+            {
+              // We should exit with a nonzero status.
+              retval = 1;
+              break;
+            }
         }
       catch (const std::bad_alloc&)
         {
           recover_from_exception ();
           std::cerr << "error: out of memory -- trying to return to prompt"
                     << std::endl;
         }
     }
@@ -1048,22 +1043,23 @@ command shell that is started to run the
             {
               error ("system: TYPE must be \"sync\" or \"async\"");
               return retval;
             }
         }
 
       if (nargin > 1)
         {
-          return_output = args(1).is_true ();
-
-          if (error_state)
+          try
+            {
+              return_output = args(1).is_true ();
+            }
+          catch (const octave_execution_exception&)
             {
               error ("system: RETURN_OUTPUT must be boolean value true or false");
-              return retval;
             }
         }
 
       if (return_output && type == et_async)
         {
           error ("system: can't return output from commands run asynchronously");
           return retval;
         }
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -453,32 +453,35 @@ octave_base_value::print_info (std::ostr
 }
 
 #define INT_CONV_METHOD(T, F) \
   T \
   octave_base_value::F ## _value (bool require_int, bool frc_str_conv) const \
   { \
     T retval = 0; \
  \
-    double d = double_value (frc_str_conv); \
+    double d; \
  \
-    if (! error_state) \
+    try \
+      { \
+        d = double_value (frc_str_conv); \
+      } \
+    catch (const octave_execution_exception&) \
       { \
-        if (require_int && D_NINT (d) != d) \
-          error_with_cfn ("conversion of %g to " #T " value failed", d); \
-        else if (d < std::numeric_limits<T>::min ()) \
-          retval = std::numeric_limits<T>::min (); \
-        else if (d > std::numeric_limits<T>::max ()) \
-          retval = std::numeric_limits<T>::max (); \
-        else \
-          retval = static_cast<T> (::fix (d));  \
+        gripe_wrong_type_arg ("octave_base_value::" #F "_value ()", type_name ()); \
       } \
+ \
+    if (require_int && D_NINT (d) != d) \
+      error_with_cfn ("conversion of %g to " #T " value failed", d); \
+    else if (d < std::numeric_limits<T>::min ()) \
+      retval = std::numeric_limits<T>::min (); \
+    else if (d > std::numeric_limits<T>::max ()) \
+      retval = std::numeric_limits<T>::max (); \
     else \
-      gripe_wrong_type_arg ("octave_base_value::" #F "_value ()", \
-                            type_name ()); \
+      retval = static_cast<T> (::fix (d)); \
  \
     return retval; \
   }
 
 INT_CONV_METHOD (short int, short)
 INT_CONV_METHOD (unsigned short int, ushort)
 
 INT_CONV_METHOD (int, int)
@@ -488,34 +491,31 @@ INT_CONV_METHOD (long int, long)
 INT_CONV_METHOD (unsigned long int, ulong)
 
 INT_CONV_METHOD (int64_t, int64)
 INT_CONV_METHOD (uint64_t, uint64)
 
 int
 octave_base_value::nint_value (bool frc_str_conv) const
 {
-  int retval = 0;
+  double d;
 
-  double d = double_value (frc_str_conv);
-
-  if (! error_state)
+  try
+    {
+      d = double_value (frc_str_conv);
+    }
+  catch (const octave_execution_exception&)
     {
-      if (xisnan (d))
-        {
-          error ("conversion of NaN to integer value failed");
-          return retval;
-        }
+      gripe_wrong_type_arg ("octave_base_value::nint_value ()", type_name ());
+    }
 
-      retval = static_cast<int> (::fix (d));
-    }
-  else
-    gripe_wrong_type_arg ("octave_base_value::nint_value ()", type_name ());
+  if (xisnan (d))
+    error ("conversion of NaN to integer value failed");
 
-  return retval;
+  return static_cast<int> (::fix (d));
 }
 
 double
 octave_base_value::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
   gripe_wrong_type_arg ("octave_base_value::double_value ()", type_name ());
   return retval;
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -123,22 +123,16 @@ octave_base_matrix<Cell>::fast_elem_inse
   return retval;
 }
 
 template class octave_base_matrix<Cell>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_cell, "cell", "cell");
 
-static void
-gripe_failed_assignment (void)
-{
-  error ("assignment to cell array failed");
-}
-
 octave_value_list
 octave_cell::subsref (const std::string& type,
                       const std::list<octave_value_list>& idx,
                       int nargout,
                       const std::list<octave_lvalue> *lvalue_list)
 {
   octave_value_list retval;
 
@@ -344,23 +338,18 @@ octave_cell::subsasgn (const std::string
 
         if (t_rhs.is_cell ())
           octave_base_matrix<Cell>::assign (i, t_rhs.cell_value ());
         else if (t_rhs.is_null_value ())
           octave_base_matrix<Cell>::delete_elements (i);
         else
           octave_base_matrix<Cell>::assign (i, Cell (t_rhs));
 
-        if (! error_state)
-          {
-            count++;
-            retval = octave_value (this);
-          }
-        else
-          gripe_failed_assignment ();
+        count++;
+        retval = octave_value (this);
       }
       break;
 
     case '{':
       {
         octave_value_list idxf = idx.front ();
 
         if (t_rhs.is_cs_list ())
@@ -382,23 +371,18 @@ octave_cell::subsasgn (const std::string
         else if (idxf.all_scalars ()
                  || do_index_op (idxf, true).numel () == 1)
           // Regularize a null matrix if stored into a cell.
           octave_base_matrix<Cell>::assign (idxf,
                                             Cell (t_rhs.storable_value ()));
         else
           gripe_nonbraced_cs_list_assignment ();
 
-        if (! error_state)
-          {
-            count++;
-            retval = octave_value (this);
-          }
-        else
-          gripe_failed_assignment ();
+        count++;
+        retval = octave_value (this);
       }
       break;
 
     case '.':
       {
         if (is_empty ())
           {
             // Allow conversion of empty cell array to some other
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1713,96 +1713,91 @@ It's behavior may change in the future a
 particular output.\n\
 \n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      octave_fcn_handle *fh = args(0).fcn_handle_value ();
-
-      if (! error_state)
-        {
-          octave_function *fcn = fh ? fh->function_value () : 0;
+      octave_fcn_handle *fh = args(0).fcn_handle_value ("functions: FCN_HANDLE argument must be a function handle object");
 
-          if (fcn)
-            {
-              octave_scalar_map m;
-
-              std::string fh_nm = fh->fcn_name ();
+      octave_function *fcn = fh ? fh->function_value () : 0;
 
-              if (fh_nm == octave_fcn_handle::anonymous)
-                {
-                  std::ostringstream buf;
-                  fh->print_raw (buf);
-                  m.setfield ("function", buf.str ());
-
-                  m.setfield ("type", "anonymous");
-                }
-              else
-                {
-                  m.setfield ("function", fh_nm);
+      if (fcn)
+        {
+          octave_scalar_map m;
 
-                  if (fcn->is_subfunction ())
-                    {
-                      m.setfield ("type", "subfunction");
-                      Cell parentage (dim_vector (1, 2));
-                      parentage.elem (0) = fh_nm;
-                      parentage.elem (1) = fcn->parent_fcn_name ();
-                      m.setfield ("parentage", octave_value (parentage));
-                    }
-                  else if (fcn->is_private_function ())
-                    m.setfield ("type", "private");
-                  else if (fh->is_overloaded ())
-                    m.setfield ("type", "overloaded");
-                  else
-                    m.setfield ("type", "simple");
-                }
-
-              std::string nm = fcn->fcn_file_name ();
-
-              if (fh_nm == octave_fcn_handle::anonymous)
-                {
-                  m.setfield ("file", nm);
-
-                  octave_user_function *fu = fh->user_function_value ();
+          std::string fh_nm = fh->fcn_name ();
 
-                  std::list<symbol_table::symbol_record> vars
-                    = symbol_table::all_variables (fu->scope (), 0);
-
-                  size_t varlen = vars.size ();
+          if (fh_nm == octave_fcn_handle::anonymous)
+            {
+              std::ostringstream buf;
+              fh->print_raw (buf);
+              m.setfield ("function", buf.str ());
 
-                  if (varlen > 0)
-                    {
-                      octave_scalar_map ws;
-                      for (std::list<symbol_table::symbol_record>::const_iterator
-                           p = vars.begin (); p != vars.end (); p++)
-                        {
-                          ws.assign (p->name (), p->varval (0));
-                        }
-
-                      m.setfield ("workspace", ws);
-                    }
-                }
-              else if (fcn->is_user_function () || fcn->is_user_script ())
-                {
-                  octave_function *fu = fh->function_value ();
-                  m.setfield ("file", fu->fcn_file_name ());
-                }
-              else
-                m.setfield ("file", "");
-
-              retval = m;
+              m.setfield ("type", "anonymous");
             }
           else
-            error ("functions: FCN_HANDLE is not a valid function handle object");
+            {
+              m.setfield ("function", fh_nm);
+
+              if (fcn->is_subfunction ())
+                {
+                  m.setfield ("type", "subfunction");
+                  Cell parentage (dim_vector (1, 2));
+                  parentage.elem (0) = fh_nm;
+                  parentage.elem (1) = fcn->parent_fcn_name ();
+                  m.setfield ("parentage", octave_value (parentage));
+                }
+              else if (fcn->is_private_function ())
+                m.setfield ("type", "private");
+              else if (fh->is_overloaded ())
+                m.setfield ("type", "overloaded");
+              else
+                m.setfield ("type", "simple");
+            }
+
+          std::string nm = fcn->fcn_file_name ();
+
+          if (fh_nm == octave_fcn_handle::anonymous)
+            {
+              m.setfield ("file", nm);
+
+              octave_user_function *fu = fh->user_function_value ();
+
+              std::list<symbol_table::symbol_record> vars
+                = symbol_table::all_variables (fu->scope (), 0);
+
+              size_t varlen = vars.size ();
+
+              if (varlen > 0)
+                {
+                  octave_scalar_map ws;
+                  for (std::list<symbol_table::symbol_record>::const_iterator
+                         p = vars.begin (); p != vars.end (); p++)
+                    {
+                      ws.assign (p->name (), p->varval (0));
+                    }
+
+                  m.setfield ("workspace", ws);
+                }
+            }
+          else if (fcn->is_user_function () || fcn->is_user_script ())
+            {
+              octave_function *fu = fh->function_value ();
+              m.setfield ("file", fu->fcn_file_name ());
+            }
+          else
+            m.setfield ("file", "");
+
+          retval = m;
         }
       else
-        error ("functions: FCN_HANDLE argument must be a function handle object");
+        error ("functions: FCN_HANDLE is not a valid function handle object");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (func2str, args, ,
@@ -1812,19 +1807,19 @@ Return a string containing the name of t
 function handle @var{fcn_handle}.\n\
 @seealso{str2func, functions}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      octave_fcn_handle *fh = args(0).fcn_handle_value ();
+      octave_fcn_handle *fh = args(0).fcn_handle_value ("func2str: FCN_HANDLE argument must be a function handle object");
 
-      if (! error_state && fh)
+      if (fh)
         {
           std::string fh_nm = fh->fcn_name ();
 
           if (fh_nm == octave_fcn_handle::anonymous)
             {
               std::ostringstream buf;
 
               fh->print_raw (buf);
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1386,35 +1386,16 @@ octave_value::do_multi_index_op (int nar
 
 octave_value_list
 octave_value::do_multi_index_op (int nargout, const octave_value_list& idx,
                                  const std::list<octave_lvalue> *lvalue_list)
 {
   return rep->do_multi_index_op (nargout, idx, lvalue_list);
 }
 
-#if 0
-static void
-gripe_assign_failed (const std::string& on, const std::string& tn1,
-                     const std::string& tn2)
-{
-  error ("assignment failed for '%s %s %s'",
-         tn1.c_str (), on.c_str (), tn2.c_str ());
-}
-#endif
-
-static void
-gripe_assign_failed_or_no_method (const std::string& on,
-                                  const std::string& tn1,
-                                  const std::string& tn2)
-{
-  error ("assignment failed, or no method for '%s %s %s'",
-         tn1.c_str (), on.c_str (), tn2.c_str ());
-}
-
 octave_value
 octave_value::subsasgn (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         const octave_value& rhs)
 {
   return rep->subsasgn (type, idx, rhs);
 }
 
@@ -1446,23 +1427,17 @@ octave_value::assign (assign_op op, cons
           binary_op binop = op_eq_to_binary_op (op);
 
           t_rhs = do_binary_op (binop, t, rhs);
         }
       else
         error ("in computed assignment A(index) OP= X, A must be defined first");
     }
 
-  octave_value tmp = subsasgn (type, idx, t_rhs);
-
-  if (error_state)
-    gripe_assign_failed_or_no_method (assign_op_as_string (op_asn_eq),
-                                      type_name (), rhs.type_name ());
-  else
-    *this = tmp;
+  *this = subsasgn (type, idx, t_rhs);
 
   return *this;
 }
 
 octave_value&
 octave_value::assign (assign_op op, const octave_value& rhs)
 {
   if (op == op_asn_eq)
@@ -2020,16 +1995,25 @@ XVALUE_EXTRACTOR (Array<int>, xint_vecto
 XVALUE_EXTRACTOR (Array<octave_idx_type>, xoctave_idx_type_vector_value, octave_idx_type_vector_value)
 
 XVALUE_EXTRACTOR (Array<double>, xvector_value, vector_value)
 XVALUE_EXTRACTOR (Array<Complex>, xcomplex_vector_value, complex_vector_value)
 
 XVALUE_EXTRACTOR (Array<float>, xfloat_vector_value, float_vector_value)
 XVALUE_EXTRACTOR (Array<FloatComplex>, xfloat_complex_vector_value, float_complex_vector_value)
 
+XVALUE_EXTRACTOR (octave_function *, xfunction_value, function_value)
+XVALUE_EXTRACTOR (octave_user_function *, xuser_function_value, user_function_value)
+XVALUE_EXTRACTOR (octave_user_script *, xuser_script_value, user_script_value)
+XVALUE_EXTRACTOR (octave_user_code *, xuser_code_value, user_code_value)
+XVALUE_EXTRACTOR (octave_fcn_handle *, xfcn_handle_value, fcn_handle_value)
+XVALUE_EXTRACTOR (octave_fcn_inline *, xfcn_inline_value, fcn_inline_value)
+
+XVALUE_EXTRACTOR (octave_value_list, xlist_value, list_value)
+
 #undef XVALUE_EXTRACTOR
 
 octave_value
 octave_value::storable_value (void) const
 {
   octave_value retval = *this;
   if (is_null_value ())
     retval = octave_value (rep->empty_clone ());
@@ -2479,40 +2463,45 @@ do_colon_op (const octave_value& base, c
       else
         error ("colon method not defined for %s class", dispatch_type.c_str ());
     }
   else
     {
       bool result_is_str = (base.is_string () && limit.is_string ());
       bool dq_str = (base.is_dq_string () || limit.is_dq_string ());
 
-      Matrix m_base = base.matrix_value (true);
-
-      if (error_state)
+      Matrix m_base, m_limit, m_increment;
+
+      try
+        {
+          m_base = base.matrix_value (true);
+        }
+      catch (const octave_execution_exception&)
         {
           error ("invalid base value in colon expression");
-          return retval;
         }
 
-      Matrix m_limit = limit.matrix_value (true);
-
-      if (error_state)
+      try
+        {
+          m_limit = limit.matrix_value (true);
+        }
+      catch (const octave_execution_exception&)
         {
           error ("invalid limit value in colon expression");
-          return retval;
         }
 
-      Matrix m_increment = (increment.is_defined ()
-                            ? increment.matrix_value (true)
-                            : Matrix (1, 1, 1.0));
-
-      if (error_state)
+      try
+        {
+          m_increment = (increment.is_defined ()
+                         ? increment.matrix_value (true)
+                         : Matrix (1, 1, 1.0));
+        }
+      catch (const octave_execution_exception&)
         {
           error ("invalid increment value in colon expression");
-          return retval;
         }
 
       bool base_empty = m_base.is_empty ();
       bool limit_empty = m_limit.is_empty ();
       bool increment_empty = m_increment.is_empty ();
 
       if (base_empty || limit_empty || increment_empty)
         retval = Range ();
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -1150,16 +1150,25 @@ public:
   Array<double> xvector_value (const char *fmt, ...) const;
 
   Array<Complex> xcomplex_vector_value (const char *fmt, ...) const;
 
   Array<float> xfloat_vector_value (const char *fmt, ...) const;
 
   Array<FloatComplex> xfloat_complex_vector_value (const char *fmt, ...) const;
 
+  octave_function *xfunction_value (const char *fmt, ...) const;
+  octave_user_function *xuser_function_value (const char *fmt, ...) const;
+  octave_user_script *xuser_script_value (const char *fmt, ...) const;
+  octave_user_code *xuser_code_value (const char *fmt, ...) const;
+  octave_fcn_handle *xfcn_handle_value (const char *fmt, ...) const;
+  octave_fcn_inline *xfcn_inline_value (const char *fmt, ...) const;
+
+  octave_value_list xlist_value (const char *fmt, ...) const;
+  
   // Possibly economize a lazy-indexed value.
 
   void maybe_economize (void)
   { rep->maybe_economize (); }
 
   // The following two hook conversions are called on any octave_value prior to
   // storing it to a "permanent" location, like a named variable, a cell or a
   // struct component, or a return value of a function.
