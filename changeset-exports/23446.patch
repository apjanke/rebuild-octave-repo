# HG changeset patch
# User Rik <rik@octave.org>
# Date 1493311737 25200
#      Thu Apr 27 09:48:57 2017 -0700
# Node ID cd4e1ee2871654f5c5c6000f14b49a375098e7e2
# Parent  8e310ef0fa97306d39fced5f43410751f9618846
maint: Use convention 'void * fcn ()' for functions which return pointers.

* make_int.cc, dialog.h, file-editor-interface.h, file-editor-tab.h,
file-editor.h, octave-txt-lexer.h, main-window.h, octave-dock-widget.h,
parser.h, webinfo.h, resource-manager.h, thread-manager.h, c-file-ptr-stream.h,
call-stack.h, comment-list.h, ft-text-renderer.h, gl-render.cc, input.h,
mex.cc, mexproto.h, mxarray.in.h, oct-fstrm.h, oct-iostrm.h, oct-procbuf.h,
oct-stdstrm.h, oct-stream.cc, oct-stream.h, oct-strstrm.h, octave-link.h,
sighandlers.cc, symtab.h, sysdep.h, utils.h, audiodevinfo.cc, ov-base-diag.h,
ov-base-int.h, ov-base-scalar.h, ov-base-sparse.h, ov-base.h, ov-bool-mat.h,
ov-bool-sparse.h, ov-bool.h, ov-builtin.h, ov-cell.h, ov-ch-mat.h, ov-class.h,
ov-classdef.h, ov-colon.h, ov-complex.cc, ov-complex.h, ov-cs-list.h,
ov-cx-diag.h, ov-cx-mat.h, ov-cx-sparse.h, ov-fcn-handle.h, ov-fcn-inline.h,
ov-fcn.h, ov-float.h, ov-flt-complex.h, ov-flt-cx-diag.h, ov-flt-cx-mat.h,
ov-flt-re-diag.h, ov-flt-re-mat.h, ov-intx.h, ov-java.cc, ov-java.h,
ov-lazy-idx.h, ov-mex-fcn.h, ov-oncleanup.h, ov-perm.h, ov-range.h,
ov-re-diag.h, ov-re-mat.h, ov-re-sparse.h, ov-scalar.h, ov-str-mat.h,
ov-struct.h, ov-usr-fcn.h, ov.h, octave.h, bp-table.h, jit-ir.h,
jit-typeinfo.h, jit-util.h, lex.h, parse.h, pt-arg-list.h, pt-array-list.h,
pt-assign.h, pt-binop.h, pt-cell.h, pt-classdef.h, pt-cmd.h, pt-colon.h,
pt-const.h, pt-decl.h, pt-except.h, pt-exp.h, pt-fcn-handle.h, pt-funcall.h,
pt-id.h, pt-idx.h, pt-jit.h, pt-jump.h, pt-loop.h, pt-mat.h, pt-misc.h,
pt-select.h, pt-stmt.h, pt-unop.h, token.h, Array.cc, Array.h, DiagArray2.h,
Sparse.h, dim-vector.h, idx-vector.h, sparse-chol.cc, cmd-edit.cc, cmd-edit.h,
lo-array-errwarn.cc, lo-array-errwarn.h, lo-array-gripes.cc, lo-utils.h,
oct-inttypes.h, oct-locbuf.h, oct-refcount.h, oct-rl-edit.h, oct-rl-hist.h,
oct-shlib.cc, oct-shlib.h, str-vec.h, canonicalize-file-name-wrapper.h,
dirent-wrappers.h, getopt-wrapper.h, glob-wrappers.h, localcharset-wrapper.h,
set-program-name-wrapper.h, signal-wrappers.h, strdup-wrapper.h,
tmpfile-wrapper.h, unistd-wrappers.h, display-available.h:
Use convention 'void * fcn ()' for functions which return pointers.

diff --git a/examples/code/make_int.cc b/examples/code/make_int.cc
--- a/examples/code/make_int.cc
+++ b/examples/code/make_int.cc
@@ -42,17 +42,17 @@ public:
   octave_integer (int i)
     : octave_base_value (), scalar (i) { }
 
   octave_integer (const octave_integer& s)
     : octave_base_value (), scalar (s.scalar) { }
 
   ~octave_integer (void) = default;
 
-  octave_base_value *clone (void) { return new octave_integer (*this); }
+  octave_base_value * clone (void) { return new octave_integer (*this); }
 
 #if 0
   void *operator new (size_t size);
   void operator delete (void *p, size_t size);
 #endif
 
   idx_vector index_vector (void) const { return idx_vector ((double) scalar); }
 
diff --git a/libgui/src/dialog.h b/libgui/src/dialog.h
--- a/libgui/src/dialog.h
+++ b/libgui/src/dialog.h
@@ -83,41 +83,41 @@ public:
       return false;
 
     emit create_listview (list, mode, wd, ht, initial, name,
                           prompt, ok_string, cancel_string);
 
     return true;
   };
 
-  const QIntList *get_list_index (void) { return list_index; }
+  const QIntList * get_list_index (void) { return list_index; }
 
   bool signal_inputlayout (const QStringList& prompt, const QString& title,
                            const QFloatList& nr, const QFloatList& nc,
                            const QStringList& defaults)
   {
     if (prompt.isEmpty ())
       return false;
 
     emit create_inputlayout (prompt, title, nr, nc, defaults);
 
     return true;
   };
 
-  const QStringList *get_string_list (void) { return string_list; }
+  const QStringList * get_string_list (void) { return string_list; }
 
   bool signal_filedialog (const QStringList& filters, const QString& title,
                           const QString& filename, const QString& dirname,
                           const QString& multimode)
   {
     emit create_filedialog (filters, title, filename, dirname, multimode);
     return true;
   }
 
-  const QString *get_dialog_path (void) { return path_name; }
+  const QString * get_dialog_path (void) { return path_name; }
 
   // GUI objects cannot be accessed in the non-GUI thread.  However,
   // signals can be sent to slots across threads with proper
   // synchronization.  Hence, the use of QWaitCondition.
   QMutex mutex;
   QWaitCondition waitcondition;
 
 signals:
diff --git a/libgui/src/m-editor/file-editor-interface.h b/libgui/src/m-editor/file-editor-interface.h
--- a/libgui/src/m-editor/file-editor-interface.h
+++ b/libgui/src/m-editor/file-editor-interface.h
@@ -35,19 +35,19 @@ public:
   file_editor_interface (QWidget *p)
     : octave_dock_widget (p)
   {
     setObjectName ("FileEditor");
   }
 
   virtual ~file_editor_interface () { }
 
-  virtual QMenu *get_mru_menu () = 0;
-  virtual QMenu *debug_menu () = 0;
-  virtual QToolBar *toolbar () = 0;
+  virtual QMenu * get_mru_menu () = 0;
+  virtual QMenu * debug_menu () = 0;
+  virtual QToolBar * toolbar () = 0;
 
   virtual void insert_global_actions (QList<QAction*>) = 0;
   virtual void handle_enter_debug_mode (void) = 0;
   virtual void handle_exit_debug_mode (void) = 0;
 
   virtual void
   handle_insert_debugger_pointer_request (const QString& file, int line) = 0;
 
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -50,17 +50,17 @@ class file_editor_tab : public QWidget
   Q_OBJECT
 
 public:
 
   file_editor_tab (const QString& directory = "");
 
   ~file_editor_tab (void);
 
-  octave_qscintilla *qsci_edit_area () { return _edit_area; }
+  octave_qscintilla * qsci_edit_area () { return _edit_area; }
 
   // Will initiate close if associated with the identifier tag.
   bool conditional_close (void);
 
   static void reset_cancel (void) {_cancelled = false;}
   static bool was_cancelled (void) {return _cancelled;}
 
 public slots:
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -114,19 +114,19 @@ public:
     }
   };
 
   file_editor (QWidget *p);
   ~file_editor (void);
 
   void loadFile (const QString& fileName);
 
-  QMenu *get_mru_menu (void) { return _mru_file_menu; }
-  QMenu *debug_menu (void);
-  QToolBar *toolbar (void);
+  QMenu * get_mru_menu (void) { return _mru_file_menu; }
+  QMenu * debug_menu (void);
+  QToolBar * toolbar (void);
 
   void insert_global_actions (QList<QAction*>);
   enum shared_actions_idx
   {
     NEW_SCRIPT_ACTION = 0,
     NEW_FUNCTION_ACTION,
     OPEN_ACTION,
     FIND_FILES_ACTION,
@@ -344,19 +344,19 @@ private:
   void toggle_preference (const QString& preference, bool def);
 
   void switch_tab (int direction, bool movetab = false);
 
   void restore_session (QSettings *settings);
 
   bool editor_tab_has_focus ();
 
-  QWidget *find_tab_widget (const QString& openFileName) const;
-  QAction *add_action (QMenu *menu, const QIcon& icon, const QString& text,
-                       const char *member);
+  QWidget * find_tab_widget (const QString& openFileName) const;
+  QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
+                        const char *member);
 
   QMenu* m_add_menu (QMenuBar *p, QString text);
 
   std::map<QString, tab_info> editor_tab_map;
   QHash<QMenu*, QStringList> _hash_menu_text;
 
   QString ced;
 
diff --git a/libgui/src/m-editor/octave-txt-lexer.h b/libgui/src/m-editor/octave-txt-lexer.h
--- a/libgui/src/m-editor/octave-txt-lexer.h
+++ b/libgui/src/m-editor/octave-txt-lexer.h
@@ -30,15 +30,15 @@ along with Octave; see the file COPYING.
 
 
 class octave_txt_lexer : public QsciLexer
 {
   Q_OBJECT
 
 public:
 
-  virtual const char *language () const;
-  virtual const char *lexer () const;
+  virtual const char * language () const;
+  virtual const char * lexer () const;
   virtual QString description (int style) const;
 
 };
 
 #endif
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -276,29 +276,29 @@ protected:
   void closeEvent (QCloseEvent *closeEvent);
 
 private:
 
   void construct (void);
 
   void construct_octave_qt_link (void);
 
-  QAction *add_action (QMenu *menu, const QIcon& icon, const QString& text,
-                       const char *member, const QWidget *receiver = 0);
+  QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
+                        const char *member, const QWidget *receiver = 0);
 
   QMenu* m_add_menu (QMenuBar *p, QString text);
   void construct_menu_bar (void);
   void construct_file_menu (QMenuBar *p);
   void construct_new_menu (QMenu *p);
   void construct_edit_menu (QMenuBar *p);
-  QAction *construct_debug_menu_item (const char *icon, const QString& item,
-                                      const char* member);
+  QAction * construct_debug_menu_item (const char *icon, const QString& item,
+                                       const char* member);
   void construct_debug_menu (QMenuBar *p);
-  QAction *construct_window_menu_item (QMenu *p, const QString& item,
-                                       bool checkable, QWidget*);
+  QAction * construct_window_menu_item (QMenu *p, const QString& item,
+                                        bool checkable, QWidget*);
   void construct_window_menu (QMenuBar *p);
   void construct_help_menu (QMenuBar *p);
   void construct_documentation_menu (QMenu *p);
 
   void construct_news_menu (QMenuBar *p);
 
   void construct_tool_bar (void);
 
diff --git a/libgui/src/octave-dock-widget.h b/libgui/src/octave-dock-widget.h
--- a/libgui/src/octave-dock-widget.h
+++ b/libgui/src/octave-dock-widget.h
@@ -76,17 +76,17 @@ public slots:
   }
 
   virtual void notice_settings (const QSettings*)
   { }
   void handle_settings (const QSettings*);
 
   void handle_active_dock_changed (octave_dock_widget*, octave_dock_widget*);
 
-  QMainWindow *main_win () { return _parent; }
+  QMainWindow * main_win () { return _parent; }
 
   void save_settings (void);
 
 protected slots:
 
   /** Slot to steer changing visibility from outside. */
   virtual void handle_visibility_changed (bool visible)
   {
diff --git a/libgui/src/qtinfo/parser.h b/libgui/src/qtinfo/parser.h
--- a/libgui/src/qtinfo/parser.h
+++ b/libgui/src/qtinfo/parser.h
@@ -99,17 +99,17 @@ private:
   QString get_node_next (const QString& text);
   QString get_node_prev (const QString& text);
   void append_line (QString *test, const char *line);
 
   /** Parses info files and gets map of node positions.*/
   void parse_info_map ();
 
   /** Open info files and uncompress them. */
-  QIODevice *open_file (QFileInfo & fileInfo);
+  QIODevice * open_file (QFileInfo & fileInfo);
 
   /** Calculates real position of nodes.
     * @param pos position from info file.
     * @param fileInfo returns file what contains that position.
     * @param realPos returns real position inside of fileInfo.
     */
   void real_position (int pos, QFileInfo & file_info, int & real_pos);
 
diff --git a/libgui/src/qtinfo/webinfo.h b/libgui/src/qtinfo/webinfo.h
--- a/libgui/src/qtinfo/webinfo.h
+++ b/libgui/src/qtinfo/webinfo.h
@@ -44,17 +44,17 @@ along with Octave; see the file COPYING.
 class webinfo_tab_bar : public QTabBar
 {
   Q_OBJECT
 
 public:
 
   webinfo_tab_bar (QWidget *p);
   ~webinfo_tab_bar ();
-  QMenu *get_context_menu () { return _context_menu; }
+  QMenu * get_context_menu () { return _context_menu; }
 
 public slots:
 
 protected:
 
   void mousePressEvent(QMouseEvent *event);
 
 private:
@@ -90,30 +90,30 @@ public slots:
   void pasteClipboard ();
   void selectAll ();
 
   void request_close_tab (bool);
   void request_close_other_tabs (bool);
 
 private:
 
-  QAction *add_action (QMenu *menu, const QIcon& icon, const QString& text,
-                       const char *member);
+  QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
+                        const char *member);
   void tab_state_changed (void);
 
   QTextBrowser        *_text_browser;
   webinfo_tab_bar     *_tab_bar;
   QStackedWidget      *_stacked_widget;
   QLineEdit           *_search_line_edit;
   QCheckBox           *_search_check_box;
   QToolButton         *_zoom_in_button;
   QToolButton         *_zoom_out_button;
 
   parser              _parser;
   QFont               _font_web;
 
-  QTextBrowser *addNewTab (const QString& name);
+  QTextBrowser * addNewTab (const QString& name);
   QAction *_close_action;
   QAction *_close_others_action;
 
 };
 
 #endif
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -43,30 +43,30 @@ public:
   // No copying!
 
   resource_manager (const resource_manager&) = delete;
 
   resource_manager& operator = (const resource_manager&) = delete;
 
   ~resource_manager ();
 
-  static QSettings *get_settings (void)
+  static QSettings * get_settings (void)
   {
     return instance_ok () ? instance->do_get_settings () : 0;
   }
 
   static QIcon icon (const QString& icon_name, bool fallback = true)
   {
     if (instance_ok ())
       return instance->do_icon (icon_name, fallback);
 
     return QIcon ();
   }
 
-  static QSettings *get_default_settings (void)
+  static QSettings * get_default_settings (void)
   {
     return instance_ok () ? instance->do_get_default_settings () : 0;
   }
 
   static QString get_settings_file (void)
   {
     return instance_ok () ? instance->do_get_settings_file () : QString ();
   }
@@ -125,19 +125,19 @@ private:
   QString settings_directory;
 
   QString settings_file;
 
   QSettings *settings;
 
   QSettings *default_settings;
 
-  QSettings *do_get_settings (void) const;
+  QSettings * do_get_settings (void) const;
 
-  QSettings *do_get_default_settings (void) const;
+  QSettings * do_get_default_settings (void) const;
 
   QString do_get_settings_file (void);
 
   QString do_get_settings_directory (void);
 
   void do_reload_settings (void);
 
   void do_set_settings (const QString& file);
diff --git a/libgui/src/thread-manager.h b/libgui/src/thread-manager.h
--- a/libgui/src/thread-manager.h
+++ b/libgui/src/thread-manager.h
@@ -85,12 +85,12 @@ public:
   static void block_interrupt_signal (void);
 
   static void unblock_interrupt_signal (void);
 
 private:
 
   octave_base_thread_manager *rep;
 
-  static octave_base_thread_manager *create_rep (void);
+  static octave_base_thread_manager * create_rep (void);
 };
 
 #endif
diff --git a/libinterp/corefcn/c-file-ptr-stream.h b/libinterp/corefcn/c-file-ptr-stream.h
--- a/libinterp/corefcn/c-file-ptr-stream.h
+++ b/libinterp/corefcn/c-file-ptr-stream.h
@@ -112,17 +112,17 @@ public:
   // No copying!
 
   c_file_ptr_stream (const c_file_ptr_stream&) = delete;
 
   c_file_ptr_stream& operator = (const c_file_ptr_stream&) = delete;
 
   ~c_file_ptr_stream (void) { delete buf; buf = 0; }
 
-  BUF_T *rdbuf (void) { return buf; }
+  BUF_T * rdbuf (void) { return buf; }
 
   void stream_close (void) { if (buf) buf->buf_close (); }
 
   int seek (off_t offset, int origin)
   { return buf ? buf->seek (offset, origin) : -1; }
 
   off_t tell (void) { return buf ? buf->tell () : -1; }
 
diff --git a/libinterp/corefcn/call-stack.h b/libinterp/corefcn/call-stack.h
--- a/libinterp/corefcn/call-stack.h
+++ b/libinterp/corefcn/call-stack.h
@@ -102,17 +102,17 @@ namespace octave
 
       if (! instance)
         error ("unable to create call stack object!");
 
       return retval;
     }
 
     // Current function (top of stack).
-    static octave_function *current (void)
+    static octave_function * current (void)
     {
       return instance_ok () ? instance->do_current () : 0;
     }
 
     // Current line in current function.
     static int current_line (void)
     {
       return instance_ok () ? instance->do_current_line () : -1;
@@ -120,17 +120,17 @@ namespace octave
 
     // Current column in current function.
     static int current_column (void)
     {
       return instance_ok () ? instance->do_current_column () : -1;
     }
 
     // Caller function, may be built-in.
-    static octave_function *caller (void)
+    static octave_function * caller (void)
     {
       return instance_ok () ? instance->do_caller () : 0;
     }
 
     static size_t current_frame (void)
     {
       return instance_ok () ? instance->do_current_frame () : 0;
     }
@@ -160,23 +160,23 @@ namespace octave
     static stack_frame frame (size_t idx)
     {
       return instance_ok () ? instance->do_frame (idx) : stack_frame ();
     }
 #endif
 
     // Function at location N on the call stack (N == 0 is current), may
     // be built-in.
-    static octave_function *element (size_t n)
+    static octave_function * element (size_t n)
     {
       return instance_ok () ? instance->do_element (n) : 0;
     }
 
     // User code caller.
-    static octave_user_code *caller_user_code (size_t nskip = 0)
+    static octave_user_code * caller_user_code (size_t nskip = 0)
     {
       return instance_ok () ? instance->do_caller_user_code (nskip) : 0;
     }
 
     // Line in user code caller.
     static int caller_user_code_line (void)
     {
       return instance_ok () ? instance->do_caller_user_code_line () : -1;
@@ -184,17 +184,17 @@ namespace octave
 
     // Column in user code caller.
     static int caller_user_code_column (void)
     {
       return instance_ok () ? instance->do_caller_user_code_column () : -1;
     }
 
     // Current function that we are debugging.
-    static octave_user_code *debug_user_code (void)
+    static octave_user_code * debug_user_code (void)
     {
       return instance_ok () ? instance->do_debug_user_code () : 0;
     }
 
     // Line number in current function that we are debugging.
     static int debug_user_code_line (void)
     {
       return instance_ok () ? instance->do_debug_user_code_line () : 0;
@@ -334,17 +334,17 @@ namespace octave
     static call_stack *instance;
 
     static void cleanup_instance (void) { delete instance; instance = 0; }
 
     int do_current_line (void) const;
 
     int do_current_column (void) const;
 
-    octave_function *do_caller (void) const
+    octave_function * do_caller (void) const
     {
       return curr_frame > 1 ? cs[curr_frame-1].m_fcn : cs[0].m_fcn;
     }
 
     size_t do_current_frame (void) { return curr_frame; }
 
     size_t do_size (void) { return cs.size (); }
 
@@ -366,49 +366,49 @@ namespace octave
     const stack_frame& do_frame (size_t idx)
     {
       static stack_frame foobar;
 
       return idx < cs.size () ? cs[idx] : foobar;
     }
 #endif
 
-    octave_function *do_element (size_t n)
+    octave_function * do_element (size_t n)
     {
       octave_function *retval = 0;
 
       if (cs.size () > n)
         {
           stack_frame& elt = cs[n];
           retval = elt.m_fcn;
         }
 
       return retval;
     }
 
-    octave_user_code *do_caller_user_code (size_t nskip) const;
+    octave_user_code * do_caller_user_code (size_t nskip) const;
     int do_caller_user_code_line (void) const;
     int do_caller_user_code_column (void) const;
 
-    octave_user_code *do_debug_user_code (void) const;
+    octave_user_code * do_debug_user_code (void) const;
     int do_debug_user_code_line (void) const;
     int do_debug_user_code_column (void) const;
 
     bool do_all_scripts (void) const;
 
     void do_push (octave_function *fcn, symbol_table::scope_id scope,
                   symbol_table::context_id context)
     {
       size_t prev_frame = curr_frame;
       curr_frame = cs.size ();
       cs.push_back (stack_frame (fcn, scope, context, prev_frame));
       symbol_table::set_scope_and_context (scope, context);
     }
 
-    octave_function *do_current (void) const
+    octave_function * do_current (void) const
     {
       octave_function *retval = 0;
 
       if (! cs.empty ())
         {
           const stack_frame& elt = cs[curr_frame];
           retval = elt.m_fcn;
         }
diff --git a/libinterp/corefcn/comment-list.h b/libinterp/corefcn/comment-list.h
--- a/libinterp/corefcn/comment-list.h
+++ b/libinterp/corefcn/comment-list.h
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <string>
 
 #include "base-list.h"
 
 extern std::string get_comment_text (void);
 
-extern char *get_comment_text_c_str (void);
+extern char * get_comment_text_c_str (void);
 
 extern void save_comment_text (const std::string& text);
 
 class
 octave_comment_elt
 {
 public:
 
@@ -92,12 +92,12 @@ public:
 
   void append (const octave_comment_elt& elt)
   { octave::base_list<octave_comment_elt>::append (elt); }
 
   void append (const std::string& s,
                octave_comment_elt::comment_type t = octave_comment_elt::unknown)
   { append (octave_comment_elt (s, t)); }
 
-  octave_comment_list *dup (void) const;
+  octave_comment_list * dup (void) const;
 };
 
 #endif
diff --git a/libinterp/corefcn/ft-text-renderer.h b/libinterp/corefcn/ft-text-renderer.h
--- a/libinterp/corefcn/ft-text-renderer.h
+++ b/libinterp/corefcn/ft-text-renderer.h
@@ -25,12 +25,12 @@ along with Octave; see the file COPYING.
 #define octave_ft_text_renderer_h 1
 
 #include "octave-config.h"
 
 namespace octave
 {
   class base_text_renderer;
 
-  extern base_text_renderer *make_ft_text_renderer (void);
+  extern base_text_renderer * make_ft_text_renderer (void);
 }
 
 #endif
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -391,17 +391,17 @@ namespace octave
         : coords (c), color (col), normal (n), alpha (a),
           ambient (as), diffuse (ds), specular (ss), specular_exp (se),
           specular_color_refl (scr), count (1) { }
     };
 
   private:
     vertex_data_rep *rep;
 
-    vertex_data_rep *nil_rep (void) const
+    vertex_data_rep * nil_rep (void) const
     {
       static vertex_data_rep *nr = new vertex_data_rep ();
 
       return nr;
     }
 
   public:
     vertex_data (void) : rep (nil_rep ())
@@ -431,17 +431,17 @@ namespace octave
         delete rep;
 
       rep = v.rep;
       rep->count++;
 
       return *this;
     }
 
-    vertex_data_rep *get_rep (void) const { return rep; }
+    vertex_data_rep * get_rep (void) const { return rep; }
   };
 
   class
   opengl_renderer::patch_tesselator : public opengl_tesselator
   {
   public:
     patch_tesselator (opengl_renderer *r, int cmode, int lmode, float idx = 0.0)
       : opengl_tesselator (), renderer (r),
diff --git a/libinterp/corefcn/input.h b/libinterp/corefcn/input.h
--- a/libinterp/corefcn/input.h
+++ b/libinterp/corefcn/input.h
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include "pager.h"
 
 class octave_value;
 namespace octave
 {
   class base_lexer;
 }
 
-extern OCTINTERP_API FILE *get_input_from_stdin (void);
+extern OCTINTERP_API FILE * get_input_from_stdin (void);
 
 // TRUE after a call to completion_matches.
 extern bool octave_completion_matches_called;
 
 // TRUE if the plotting system has requested a call to drawnow at
 // the next user prompt.
 extern OCTINTERP_API bool Vdrawnow_requested;
 
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -144,34 +144,34 @@ calc_single_subscript_internal (mwSize n
 // then invoke the method on that object instead (for example, getting
 // a pointer to real or imaginary data from a complex object requires
 // a mutation but getting a pointer to real data from a real object
 // does not).  Changing the representation causes a copy so we try to
 // avoid it unless it is really necessary.  Once the conversion
 // happens, we delete this representation, so the conversion can only
 // happen once per call to a MEX file.
 
-static inline void *maybe_mark_foreign (void *ptr);
+static inline void * maybe_mark_foreign (void *ptr);
 
 class mxArray_octave_value : public mxArray_base
 {
 public:
 
   mxArray_octave_value (const octave_value& ov)
     : mxArray_base (), val (ov), mutate_flag (false),
       id (mxUNKNOWN_CLASS), class_name (0), ndims (-1), dims (0) { }
 
   // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
   mxArray_octave_value& operator = (const mxArray_octave_value&) = delete;
 
-  mxArray_base *dup (void) const { return new mxArray_octave_value (*this); }
-
-  mxArray *as_mxArray (void) const
+  mxArray_base * dup (void) const { return new mxArray_octave_value (*this); }
+
+  mxArray * as_mxArray (void) const
   {
     mxArray *retval = val.as_mxArray ();
 
     // RETVAL is assumed to be an mxArray_matlab object.  Should we
     // assert that condition here?
 
     if (retval)
       {
@@ -266,17 +266,17 @@ public:
     get_dimensions ();
 
     for (mwIndex i = ndims - 1; i > 0; i--)
       n *= dims[i];
 
     return n;
   }
 
-  mwSize *get_dimensions (void) const
+  mwSize * get_dimensions (void) const
   {
     if (! dims)
       {
         ndims = val.ndims ();
 
         dims = static_cast<mwSize *> (mxArray::malloc (ndims
                                                        * sizeof (mwSize)));
 
@@ -355,31 +355,31 @@ public:
     else if (cn == "int64")
       id = mxINT64_CLASS;
     else if (cn == "uint64")
       id = mxUINT64_CLASS;
 
     return id;
   }
 
-  const char *get_class_name (void) const
+  const char * get_class_name (void) const
   {
     if (! class_name)
       {
         std::string s = val.class_name ();
         class_name = mxArray::strsave (s.c_str ());
       }
 
     return class_name;
   }
 
   // Not allowed.
   void set_class_name (const char * /*name_arg*/) { request_mutation (); }
 
-  mxArray *get_cell (mwIndex /*idx*/) const
+  mxArray * get_cell (mwIndex /*idx*/) const
   {
     request_mutation ();
     return 0;
   }
 
   // Not allowed.
   void set_cell (mwIndex /*idx*/, mxArray * /*val*/) { request_mutation (); }
 
@@ -398,29 +398,29 @@ public:
           return *static_cast<double *> (data);
         else  // Complex type, only return real part
           return *static_cast<double *> (data);
       }
     else
       return val.scalar_value (true);
   }
 
-  void *get_data (void) const
+  void * get_data (void) const
   {
     void *retval = val.mex_get_data ();
 
     if (retval)
       maybe_mark_foreign (retval);
     else
       request_mutation ();
 
     return retval;
   }
 
-  void *get_imag_data (void) const
+  void * get_imag_data (void) const
   {
     void *retval = 0;
 
     if (is_numeric () && is_real_type ())
       retval = 0;
     else
       request_mutation ();
 
@@ -428,22 +428,22 @@ public:
   }
 
   // Not allowed.
   void set_data (void * /*pr*/) { request_mutation (); }
 
   // Not allowed.
   void set_imag_data (void * /*pi*/) { request_mutation (); }
 
-  mwIndex *get_ir (void) const
+  mwIndex * get_ir (void) const
   {
     return static_cast<mwIndex *> (maybe_mark_foreign (val.mex_get_ir ()));
   }
 
-  mwIndex *get_jc (void) const
+  mwIndex * get_jc (void) const
   {
     return static_cast<mwIndex *> (maybe_mark_foreign (val.mex_get_jc ()));
   }
 
   mwSize get_nzmax (void) const { return val.nzmax (); }
 
   // Not allowed.
   void set_ir (mwIndex * /*ir*/) { request_mutation (); }
@@ -459,32 +459,32 @@ public:
   {
     request_mutation ();
     return 0;
   }
 
   // Not allowed.
   void remove_field (int /*key_num*/) { request_mutation (); }
 
-  mxArray *get_field_by_number (mwIndex /*index*/, int /*key_num*/) const
+  mxArray * get_field_by_number (mwIndex /*index*/, int /*key_num*/) const
   {
     request_mutation ();
     return 0;
   }
 
   // Not allowed.
   void set_field_by_number (mwIndex /*index*/, int /*key_num*/,
                             mxArray * /*val*/)
   {
     request_mutation ();
   }
 
   int get_number_of_fields (void) const { return val.nfields (); }
 
-  const char *get_field_name_by_number (int /*key_num*/) const
+  const char * get_field_name_by_number (int /*key_num*/) const
   {
     request_mutation ();
     return 0;
   }
 
   int get_field_number (const char * /*key*/) const
   {
     request_mutation ();
@@ -509,17 +509,17 @@ public:
         buf[nel] = 0;
 
         retval = 0;
       }
 
     return retval;
   }
 
-  char *array_to_string (void) const
+  char * array_to_string (void) const
   {
     // FIXME: this is supposed to handle multi-byte character strings.
 
     char *buf = 0;
 
     if (val.is_string ())
       {
         mwSize nel = get_number_of_elements ();
@@ -583,17 +583,17 @@ public:
   void request_mutation (void) const
   {
     if (mutate_flag)
       panic_impossible ();
 
     mutate_flag = true;
   }
 
-  mxArray *mutate (void) const { return as_mxArray (); }
+  mxArray * mutate (void) const { return as_mxArray (); }
 
   octave_value as_octave_value (void) const { return val; }
 
 protected:
 
   mxArray_octave_value (const mxArray_octave_value& arg)
     : mxArray_base (arg), val (arg.val), mutate_flag (arg.mutate_flag),
       id (arg.id), class_name (mxArray::strsave (arg.class_name)),
@@ -767,17 +767,17 @@ public:
     mwSize n = 1;
 
     for (mwSize i = ndims - 1 ; i > 0 ; i--)
       n *= dims[i];
 
     return n;
   }
 
-  mwSize *get_dimensions (void) const { return dims; }
+  mwSize * get_dimensions (void) const { return dims; }
 
   mwSize get_number_of_dimensions (void) const { return ndims; }
 
   void set_m (mwSize m) { dims[0] = m; }
 
   void set_n (mwSize n) { dims[1] = n; }
 
   int set_dimensions (mwSize *dims_arg, mwSize ndims_arg)
@@ -820,17 +820,17 @@ public:
 
   bool is_scalar (void) const
   {
     return ndims == 2 && dims[0] == 1 && dims[1] == 1;
   }
 
   mxClassID get_class_id (void) const { return id; }
 
-  const char *get_class_name (void) const
+  const char * get_class_name (void) const
   {
     switch (id)
       {
       case mxDOUBLE_CLASS: return "double";
       case mxSINGLE_CLASS: return "single";
       case mxCHAR_CLASS: return "char";
       case mxLOGICAL_CLASS: return "logical";
       case mxCELL_CLASS: return "cell";
@@ -852,57 +852,57 @@ public:
 
   void set_class_name (const char *name_arg)
   {
     mxFree (class_name);
     class_name = static_cast<char *> (mxArray::malloc (strlen (name_arg) + 1));
     strcpy (class_name, name_arg);
   }
 
-  mxArray *get_cell (mwIndex /*idx*/) const
+  mxArray * get_cell (mwIndex /*idx*/) const
   {
     err_invalid_type ();
   }
 
   void set_cell (mwIndex /*idx*/, mxArray * /*val*/)
   {
     err_invalid_type ();
   }
 
   double get_scalar (void) const
   {
     err_invalid_type ();
   }
 
-  void *get_data (void) const
+  void * get_data (void) const
   {
     err_invalid_type ();
   }
 
-  void *get_imag_data (void) const
+  void * get_imag_data (void) const
   {
     err_invalid_type ();
   }
 
   void set_data (void * /*pr*/)
   {
     err_invalid_type ();
   }
 
   void set_imag_data (void * /*pi*/)
   {
     err_invalid_type ();
   }
 
-  mwIndex *get_ir (void) const
+  mwIndex * get_ir (void) const
   {
     err_invalid_type ();
   }
 
-  mwIndex *get_jc (void) const
+  mwIndex * get_jc (void) const
   {
     err_invalid_type ();
   }
 
   mwSize get_nzmax (void) const
   {
     err_invalid_type ();
   }
@@ -927,48 +927,48 @@ public:
     err_invalid_type ();
   }
 
   void remove_field (int /*key_num*/)
   {
     err_invalid_type ();
   }
 
-  mxArray *get_field_by_number (mwIndex /*index*/, int /*key_num*/) const
+  mxArray * get_field_by_number (mwIndex /*index*/, int /*key_num*/) const
   {
     err_invalid_type ();
   }
 
   void set_field_by_number (mwIndex /*index*/, int /*key_num*/,
                             mxArray * /*val*/)
   {
     err_invalid_type ();
   }
 
   int get_number_of_fields (void) const
   {
     err_invalid_type ();
   }
 
-  const char *get_field_name_by_number (int /*key_num*/) const
+  const char * get_field_name_by_number (int /*key_num*/) const
   {
     err_invalid_type ();
   }
 
   int get_field_number (const char * /*key*/) const
   {
     return -1;
   }
 
   int get_string (char * /*buf*/, mwSize /*buflen*/) const
   {
     err_invalid_type ();
   }
 
-  char *array_to_string (void) const
+  char * array_to_string (void) const
   {
     err_invalid_type ();
   }
 
   mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const
   {
     return calc_single_subscript_internal (ndims, dims, nsubs, subs);
   }
@@ -1152,17 +1152,17 @@ protected:
 
 public:
 
   // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
   mxArray_number& operator = (const mxArray_number&);
 
-  mxArray_base *dup (void) const { return new mxArray_number (*this); }
+  mxArray_base * dup (void) const { return new mxArray_number (*this); }
 
   ~mxArray_number (void)
   {
     mxFree (pr);
     mxFree (pi);
   }
 
   int is_complex (void) const { return pi != 0; }
@@ -1223,19 +1223,19 @@ public:
 
       default:
         panic_impossible ();
       }
 
     return retval;
   }
 
-  void *get_data (void) const { return pr; }
-
-  void *get_imag_data (void) const { return pi; }
+  void * get_data (void) const { return pr; }
+
+  void * get_imag_data (void) const { return pi; }
 
   void set_data (void *pr_arg) { pr = pr_arg; }
 
   void set_imag_data (void *pi_arg) { pi = pi_arg; }
 
   int get_string (char *buf, mwSize buflen) const
   {
     int retval = 0;
@@ -1257,17 +1257,17 @@ public:
           buf[i] = static_cast<char> (ptr[i]);
 
         buf[nel] = 0;
       }
 
     return retval;
   }
 
-  char *array_to_string (void) const
+  char * array_to_string (void) const
   {
     // FIXME: this is supposed to handle multi-byte character strings.
 
     mwSize nel = get_number_of_elements ();
 
     char *buf = static_cast<char *> (mxArray::malloc (nel + 1));
 
     if (buf)
@@ -1487,41 +1487,41 @@ private:
 
 public:
 
   // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
   mxArray_sparse& operator = (const mxArray_sparse&);
 
-  mxArray_base *dup (void) const { return new mxArray_sparse (*this); }
+  mxArray_base * dup (void) const { return new mxArray_sparse (*this); }
 
   ~mxArray_sparse (void)
   {
     mxFree (pr);
     mxFree (pi);
     mxFree (ir);
     mxFree (jc);
   }
 
   int is_complex (void) const { return pi != 0; }
 
   int is_sparse (void) const { return 1; }
 
-  void *get_data (void) const { return pr; }
-
-  void *get_imag_data (void) const { return pi; }
+  void * get_data (void) const { return pr; }
+
+  void * get_imag_data (void) const { return pi; }
 
   void set_data (void *pr_arg) { pr = pr_arg; }
 
   void set_imag_data (void *pi_arg) { pi = pi_arg; }
 
-  mwIndex *get_ir (void) const { return ir; }
-
-  mwIndex *get_jc (void) const { return jc; }
+  mwIndex * get_ir (void) const { return ir; }
+
+  mwIndex * get_jc (void) const { return jc; }
 
   mwSize get_nzmax (void) const { return nzmax; }
 
   void set_ir (mwIndex *ir_arg) { ir = ir_arg; }
 
   void set_jc (mwIndex *jc_arg) { jc = jc_arg; }
 
   void set_nzmax (mwSize nzmax_arg) { nzmax = nzmax_arg; }
@@ -1688,17 +1688,17 @@ public:
   mxArray_struct& operator = (const mxArray_struct& val);
 
   void init (const char **keys)
   {
     for (int i = 0; i < nfields; i++)
       fields[i] = mxArray::strsave (keys[i]);
   }
 
-  mxArray_base *dup (void) const { return new mxArray_struct (*this); }
+  mxArray_base * dup (void) const { return new mxArray_struct (*this); }
 
   ~mxArray_struct (void)
   {
     for (int i = 0; i < nfields; i++)
       mxFree (fields[i]);
 
     mxFree (fields);
 
@@ -1808,27 +1808,27 @@ public:
         mxFree (fields);
         mxFree (data);
 
         fields = new_fields;
         data = new_data;
       }
   }
 
-  mxArray *get_field_by_number (mwIndex index, int key_num) const
+  mxArray * get_field_by_number (mwIndex index, int key_num) const
   {
     return key_num >= 0 && key_num < nfields
            ? data[nfields * index + key_num] : 0;
   }
 
   void set_field_by_number (mwIndex index, int key_num, mxArray *val);
 
   int get_number_of_fields (void) const { return nfields; }
 
-  const char *get_field_name_by_number (int key_num) const
+  const char * get_field_name_by_number (int key_num) const
   {
     return key_num >= 0 && key_num < nfields ? fields[key_num] : 0;
   }
 
   int get_field_number (const char *key) const
   {
     int retval = -1;
 
@@ -1839,17 +1839,17 @@ public:
             retval = i;
             break;
           }
       }
 
     return retval;
   }
 
-  void *get_data (void) const { return data; }
+  void * get_data (void) const { return data; }
 
   void set_data (void *data_arg) { data = static_cast<mxArray **> (data_arg); }
 
   octave_value as_octave_value (void) const
   {
     dim_vector dv = dims_to_dim_vector ();
 
     string_vector keys (fields, nfields);
@@ -1922,36 +1922,36 @@ private:
 
 public:
 
   // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
   mxArray_cell& operator = (const mxArray_cell&);
 
-  mxArray_base *dup (void) const { return new mxArray_cell (*this); }
+  mxArray_base * dup (void) const { return new mxArray_cell (*this); }
 
   ~mxArray_cell (void)
   {
     mwSize nel = get_number_of_elements ();
 
     for (mwIndex i = 0; i < nel; i++)
       delete data[i];
 
     mxFree (data);
   }
 
-  mxArray *get_cell (mwIndex idx) const
+  mxArray * get_cell (mwIndex idx) const
   {
     return idx >= 0 && idx < get_number_of_elements () ? data[idx] : 0;
   }
 
   void set_cell (mwIndex idx, mxArray *val);
 
-  void *get_data (void) const { return data; }
+  void * get_data (void) const { return data; }
 
   void set_data (void *data_arg) { data = static_cast<mxArray **> (data_arg); }
 
   octave_value as_octave_value (void) const
   {
     dim_vector dv = dims_to_dim_vector ();
 
     Cell c (dv);
@@ -2106,17 +2106,17 @@ public:
       }
 
     if (! (memlist.empty () && arraylist.empty ()))
       error ("mex: %s: cleanup failed", function_name ());
 
     mxFree (fname);
   }
 
-  const char *function_name (void) const
+  const char * function_name (void) const
   {
     if (! fname)
       {
         octave_function *fcn = octave::call_stack::current ();
 
         if (fcn)
           {
             std::string nm = fcn->name ();
@@ -2125,66 +2125,66 @@ public:
         else
           fname = mxArray::strsave ("unknown");
       }
 
     return fname;
   }
 
   // Allocate memory.
-  void *malloc_unmarked (size_t n)
+  void * malloc_unmarked (size_t n)
   {
     void *ptr = std::malloc (n);
 
     if (! ptr)
       {
         // FIXME: could use "octave_new_handler();" instead
         error ("%s: failed to allocate %d bytes of memory",
                function_name (), n);
       }
 
     global_mark (ptr);
 
     return ptr;
   }
 
   // Allocate memory to be freed on exit.
-  void *malloc (size_t n)
+  void * malloc (size_t n)
   {
     void *ptr = malloc_unmarked (n);
 
     mark (ptr);
 
     return ptr;
   }
 
   // Allocate memory and initialize to 0.
-  void *calloc_unmarked (size_t n, size_t t)
+  void * calloc_unmarked (size_t n, size_t t)
   {
     void *ptr = malloc_unmarked (n*t);
 
     memset (ptr, 0, n*t);
 
     return ptr;
   }
 
   // Allocate memory to be freed on exit and initialize to 0.
-  void *calloc (size_t n, size_t t)
+  void * calloc (size_t n, size_t t)
   {
     void *ptr = calloc_unmarked (n, t);
 
     mark (ptr);
 
     return ptr;
   }
 
   // Reallocate a pointer obtained from malloc or calloc.
   // If the pointer is NULL, allocate using malloc.
   // We don't need an "unmarked" version of this.
-  void *realloc (void *ptr, size_t n)
+  void * realloc (void *ptr, size_t n)
   {
     void *v;
 
     if (ptr)
       {
         v = std::realloc (ptr, n);
 
         std::set<void *>::iterator p = memlist.find (ptr);
@@ -2258,17 +2258,17 @@ public:
     if (p != memlist.end ())
       memlist.erase (p);
 #if defined (DEBUG)
     else
       warning ("%s: value not marked", function_name ());
 #endif
   }
 
-  mxArray *mark_array (mxArray *ptr)
+  mxArray * mark_array (mxArray *ptr)
   {
     arraylist.insert (ptr);
     return ptr;
   }
 
   void unmark_array (mxArray *ptr)
   {
     std::set<mxArray *>::iterator p = arraylist.find (ptr);
@@ -2299,17 +2299,17 @@ public:
     else
       warning ("%s: value not marked", function_name ());
 #endif
 
   }
 
   // Make a new array value and initialize from an octave value; it will be
   // freed on exit unless marked as persistent.
-  mxArray *make_value (const octave_value& ov)
+  mxArray * make_value (const octave_value& ov)
   {
     return mark_array (new mxArray (ov));
   }
 
   // Free an array and its contents.
   bool free_value (mxArray *ptr)
   {
     bool inlist = false;
@@ -2325,17 +2325,17 @@ public:
 #if defined (DEBUG)
     else
       warning ("mex::free_value: skipping memory not allocated by mex::make_value");
 #endif
 
     return inlist;
   }
 
-  octave_mex_function *current_mex_function (void) const
+  octave_mex_function * current_mex_function (void) const
   {
     return curr_mex_fcn;
   }
 
   // 1 if error should be returned to MEX file, 0 if abort.
   int trap_feval_error = 0;
 
 private:
diff --git a/libinterp/corefcn/mexproto.h b/libinterp/corefcn/mexproto.h
--- a/libinterp/corefcn/mexproto.h
+++ b/libinterp/corefcn/mexproto.h
@@ -58,17 +58,17 @@ extern "C" {
 #  include <stdbool.h>
 #endif
 
 #define MXARRAY_TYPEDEFS_ONLY
 #include "mxarray.h"
 #undef MXARRAY_TYPEDEFS_ONLY
 
 /* Interface to the interpreter.  */
-extern OCTINTERP_API const char *mexFunctionName (void);
+extern OCTINTERP_API const char * mexFunctionName (void);
 
 extern OCTINTERP_API int mexCallMATLAB (int nargout, mxArray *argout[],
                                         int nargin, mxArray *argin[],
                                         const char *fname);
 extern OCTINTERP_API mxArray * mexCallMATLABWithTrap (int nargout,
                                                       mxArray *argout[],
                                                       int nargin,
                                                       mxArray *argin[],
@@ -82,26 +82,26 @@ extern OCTINTERP_API void mexSetTrapFlag
 extern OCTINTERP_API void mexErrMsgTxt (const char *s);
 extern OCTINTERP_API void mexErrMsgIdAndTxt (const char *id, const char *s,
                                              ...);
 extern OCTINTERP_API void mexWarnMsgTxt (const char *s);
 extern OCTINTERP_API void mexWarnMsgIdAndTxt (const char *id, const char *s,
                                               ...);
 extern OCTINTERP_API int mexPrintf (const char *fmt, ...);
 
-extern OCTINTERP_API mxArray *mexGetVariable (const char *space,
-                                              const char *name);
-extern OCTINTERP_API const mxArray *mexGetVariablePtr (const char *space,
-                                                       const char *name);
+extern OCTINTERP_API mxArray * mexGetVariable (const char *space,
+                                               const char *name);
+extern OCTINTERP_API const mxArray * mexGetVariablePtr (const char *space,
+                                                        const char *name);
 
 extern OCTINTERP_API int mexPutVariable (const char *space, const char *name,
                                          const mxArray *ptr);
 
-extern OCTINTERP_API const mxArray *mexGet (double handle,
-                                            const char *property);
+extern OCTINTERP_API const mxArray * mexGet (double handle,
+                                             const char *property);
 extern OCTINTERP_API int mexSet (double handle, const char *property,
                                  mxArray *val);
 
 extern OCTINTERP_API void mexMakeArrayPersistent (mxArray *ptr);
 extern OCTINTERP_API void mexMakeMemoryPersistent (void *ptr);
 
 extern OCTINTERP_API void mexLock (void);
 extern OCTINTERP_API void mexUnlock (void);
@@ -117,66 +117,66 @@ extern OCTINTERP_API bool mxIsInf (doubl
 extern OCTINTERP_API bool mxIsNaN (double v);
 
 /* Floating point values.  */
 extern OCTINTERP_API double mxGetEps (void);
 extern OCTINTERP_API double mxGetInf (void);
 extern OCTINTERP_API double mxGetNaN (void);
 
 /* Memory management.  */
-extern OCTINTERP_API void *mxCalloc (size_t n, size_t size);
-extern OCTINTERP_API void *mxMalloc (size_t n);
-extern OCTINTERP_API void *mxRealloc (void *ptr, size_t size);
+extern OCTINTERP_API void * mxCalloc (size_t n, size_t size);
+extern OCTINTERP_API void * mxMalloc (size_t n);
+extern OCTINTERP_API void * mxRealloc (void *ptr, size_t size);
 extern OCTINTERP_API void mxFree (void *ptr);
 
 /* Constructors.  */
-extern OCTINTERP_API mxArray *mxCreateCellArray (mwSize ndims,
-                                                 const mwSize *dims);
-extern OCTINTERP_API mxArray *mxCreateCellMatrix (mwSize m, mwSize n);
-extern OCTINTERP_API mxArray *mxCreateCharArray (mwSize ndims,
-                                                 const mwSize *dims);
-extern OCTINTERP_API mxArray *mxCreateCharMatrixFromStrings (mwSize m,
-                                                             const char **str);
-extern OCTINTERP_API mxArray *mxCreateDoubleMatrix (mwSize nr, mwSize nc,
-                                                    mxComplexity flag);
-extern OCTINTERP_API mxArray *mxCreateDoubleScalar (double val);
-extern OCTINTERP_API mxArray *mxCreateLogicalArray (mwSize ndims,
-                                                    const mwSize *dims);
-extern OCTINTERP_API mxArray *mxCreateLogicalMatrix (mwSize m, mwSize n);
-extern OCTINTERP_API mxArray *mxCreateLogicalScalar (mxLogical val);
-extern OCTINTERP_API mxArray *mxCreateNumericArray (mwSize ndims,
-                                                    const mwSize *dims,
-                                                    mxClassID class_id,
-                                                    mxComplexity flag);
-extern OCTINTERP_API mxArray *mxCreateNumericMatrix (mwSize m, mwSize n,
+extern OCTINTERP_API mxArray * mxCreateCellArray (mwSize ndims,
+                                                  const mwSize *dims);
+extern OCTINTERP_API mxArray * mxCreateCellMatrix (mwSize m, mwSize n);
+extern OCTINTERP_API mxArray * mxCreateCharArray (mwSize ndims,
+                                                  const mwSize *dims);
+extern OCTINTERP_API mxArray * mxCreateCharMatrixFromStrings (mwSize m,
+                                                              const char **str);
+extern OCTINTERP_API mxArray * mxCreateDoubleMatrix (mwSize nr, mwSize nc,
+                                                     mxComplexity flag);
+extern OCTINTERP_API mxArray * mxCreateDoubleScalar (double val);
+extern OCTINTERP_API mxArray * mxCreateLogicalArray (mwSize ndims,
+                                                     const mwSize *dims);
+extern OCTINTERP_API mxArray * mxCreateLogicalMatrix (mwSize m, mwSize n);
+extern OCTINTERP_API mxArray * mxCreateLogicalScalar (mxLogical val);
+extern OCTINTERP_API mxArray * mxCreateNumericArray (mwSize ndims,
+                                                     const mwSize *dims,
                                                      mxClassID class_id,
                                                      mxComplexity flag);
-extern OCTINTERP_API mxArray *mxCreateUninitNumericArray (mwSize ndims,
-                                                          const mwSize *dims,
-                                                          mxClassID class_id,
-                                                          mxComplexity flag);
-extern OCTINTERP_API mxArray *mxCreateUninitNumericMatrix (mwSize m, mwSize n,
+extern OCTINTERP_API mxArray * mxCreateNumericMatrix (mwSize m, mwSize n,
+                                                      mxClassID class_id,
+                                                      mxComplexity flag);
+extern OCTINTERP_API mxArray * mxCreateUninitNumericArray (mwSize ndims,
+                                                           const mwSize *dims,
                                                            mxClassID class_id,
                                                            mxComplexity flag);
+extern OCTINTERP_API mxArray * mxCreateUninitNumericMatrix (mwSize m, mwSize n,
+                                                            mxClassID class_id,
+                                                            mxComplexity flag);
 
-extern OCTINTERP_API mxArray *mxCreateSparse (mwSize m, mwSize n, mwSize nzmax,
-                                              mxComplexity flag);
-extern OCTINTERP_API mxArray *mxCreateSparseLogicalMatrix (mwSize m, mwSize n,
-                                                           mwSize nzmax);
-extern OCTINTERP_API mxArray *mxCreateString (const char *str);
-extern OCTINTERP_API mxArray *mxCreateStructArray (mwSize ndims,
-                                                   const mwSize *dims,
-                                                   int num_keys,
-                                                   const char **keys);
-extern OCTINTERP_API mxArray *mxCreateStructMatrix (mwSize rows, mwSize cols,
+extern OCTINTERP_API mxArray * mxCreateSparse (mwSize m, mwSize n, mwSize nzmax,
+                                               mxComplexity flag);
+extern OCTINTERP_API mxArray * mxCreateSparseLogicalMatrix (mwSize m, mwSize n,
+                                                            mwSize nzmax);
+extern OCTINTERP_API mxArray * mxCreateString (const char *str);
+extern OCTINTERP_API mxArray * mxCreateStructArray (mwSize ndims,
+                                                    const mwSize *dims,
                                                     int num_keys,
                                                     const char **keys);
+extern OCTINTERP_API mxArray * mxCreateStructMatrix (mwSize rows, mwSize cols,
+                                                     int num_keys,
+                                                     const char **keys);
 
 /* Copy constructor.  */
-extern OCTINTERP_API mxArray *mxDuplicateArray (const mxArray *v);
+extern OCTINTERP_API mxArray * mxDuplicateArray (const mxArray *v);
 
 /* Destructor.  */
 extern OCTINTERP_API void mxDestroyArray (mxArray *v);
 
 /* Type Predicates.  */
 extern OCTINTERP_API bool mxIsCell (const mxArray *ptr);
 extern OCTINTERP_API bool mxIsChar (const mxArray *ptr);
 extern OCTINTERP_API bool mxIsClass (const mxArray *ptr, const char *name);
@@ -209,85 +209,85 @@ extern OCTINTERP_API bool mxIsEmpty (con
 extern OCTINTERP_API bool mxIsScalar (const mxArray *ptr);
 
 /* Just plain odd thing to ask of a value.  */
 extern OCTINTERP_API bool mxIsFromGlobalWS (const mxArray *ptr);
 
 /* Dimension extractors.  */
 extern OCTINTERP_API size_t mxGetM (const mxArray *ptr);
 extern OCTINTERP_API size_t mxGetN (const mxArray *ptr);
-extern OCTINTERP_API const mwSize *mxGetDimensions (const mxArray *ptr);
+extern OCTINTERP_API const mwSize * mxGetDimensions (const mxArray *ptr);
 extern OCTINTERP_API mwSize mxGetNumberOfDimensions (const mxArray *ptr);
 extern OCTINTERP_API size_t mxGetNumberOfElements (const mxArray *ptr);
 
 /* Dimension setters.  */
 extern OCTINTERP_API void mxSetM (mxArray *ptr, mwSize M);
 extern OCTINTERP_API void mxSetN (mxArray *ptr, mwSize N);
 extern OCTINTERP_API int mxSetDimensions (mxArray *ptr, const mwSize *dims,
                                           mwSize ndims);
 
 /* Data extractors.  */
-extern OCTINTERP_API double *mxGetPi (const mxArray *ptr);
-extern OCTINTERP_API double *mxGetPr (const mxArray *ptr);
+extern OCTINTERP_API double * mxGetPi (const mxArray *ptr);
+extern OCTINTERP_API double * mxGetPr (const mxArray *ptr);
 extern OCTINTERP_API double mxGetScalar (const mxArray *ptr);
-extern OCTINTERP_API mxChar *mxGetChars (const mxArray *ptr);
-extern OCTINTERP_API mxLogical *mxGetLogicals (const mxArray *ptr);
-extern OCTINTERP_API void *mxGetData (const mxArray *ptr);
-extern OCTINTERP_API void *mxGetImagData (const mxArray *ptr);
+extern OCTINTERP_API mxChar * mxGetChars (const mxArray *ptr);
+extern OCTINTERP_API mxLogical * mxGetLogicals (const mxArray *ptr);
+extern OCTINTERP_API void * mxGetData (const mxArray *ptr);
+extern OCTINTERP_API void * mxGetImagData (const mxArray *ptr);
 
 /* Data setters.  */
 extern OCTINTERP_API void mxSetPr (mxArray *ptr, double *pr);
 extern OCTINTERP_API void mxSetPi (mxArray *ptr, double *pi);
 extern OCTINTERP_API void mxSetData (mxArray *ptr, void *data);
 extern OCTINTERP_API void mxSetImagData (mxArray *ptr, void *pi);
 
 /* Classes.  */
 extern OCTINTERP_API mxClassID mxGetClassID (const mxArray *ptr);
-extern OCTINTERP_API const char *mxGetClassName (const mxArray *ptr);
+extern OCTINTERP_API const char * mxGetClassName (const mxArray *ptr);
 
 extern OCTINTERP_API void mxSetClassName (mxArray *ptr, const char *name);
 
 /* Cell support.  */
-extern OCTINTERP_API mxArray *mxGetCell (const mxArray *ptr, mwIndex idx);
+extern OCTINTERP_API mxArray * mxGetCell (const mxArray *ptr, mwIndex idx);
 
 extern OCTINTERP_API void mxSetCell (mxArray *ptr, mwIndex idx, mxArray *val);
 
 /* Sparse support.  */
-extern OCTINTERP_API mwIndex *mxGetIr (const mxArray *ptr);
-extern OCTINTERP_API mwIndex *mxGetJc (const mxArray *ptr);
+extern OCTINTERP_API mwIndex * mxGetIr (const mxArray *ptr);
+extern OCTINTERP_API mwIndex * mxGetJc (const mxArray *ptr);
 extern OCTINTERP_API mwSize mxGetNzmax (const mxArray *ptr);
 
 extern OCTINTERP_API void mxSetIr (mxArray *ptr, mwIndex *ir);
 extern OCTINTERP_API void mxSetJc (mxArray *ptr, mwIndex *jc);
 extern OCTINTERP_API void mxSetNzmax (mxArray *ptr, mwSize nzmax);
 
 /* Structure support.  */
 extern OCTINTERP_API int mxAddField (mxArray *ptr, const char *key);
 
 extern OCTINTERP_API void mxRemoveField (mxArray *ptr, int key_num);
 
-extern OCTINTERP_API mxArray *mxGetField (const mxArray *ptr, mwIndex index,
-                                          const char *key);
-extern OCTINTERP_API mxArray *mxGetFieldByNumber (const mxArray *ptr,
-                                                  mwIndex index, int key_num);
+extern OCTINTERP_API mxArray * mxGetField (const mxArray *ptr, mwIndex index,
+                                           const char *key);
+extern OCTINTERP_API mxArray * mxGetFieldByNumber (const mxArray *ptr,
+                                                   mwIndex index, int key_num);
 
 extern OCTINTERP_API void mxSetField (mxArray *ptr, mwIndex index,
                                       const char *key, mxArray *val);
 extern OCTINTERP_API void mxSetFieldByNumber (mxArray *ptr, mwIndex index,
                                               int key_num, mxArray *val);
 
 extern OCTINTERP_API int mxGetNumberOfFields (const mxArray *ptr);
 
-extern OCTINTERP_API const char *mxGetFieldNameByNumber (const mxArray *ptr,
-                                                         int key_num);
+extern OCTINTERP_API const char * mxGetFieldNameByNumber (const mxArray *ptr,
+                                                          int key_num);
 extern OCTINTERP_API int mxGetFieldNumber (const mxArray *ptr, const char *key);
 
 extern OCTINTERP_API int mxGetString (const mxArray *ptr, char *buf,
                                       mwSize buflen);
-extern OCTINTERP_API char *mxArrayToString (const mxArray *ptr);
+extern OCTINTERP_API char * mxArrayToString (const mxArray *ptr);
 
 /* Miscellaneous.  */
 extern OCTINTERP_API mwIndex mxCalcSingleSubscript (const mxArray *ptr,
                                                     mwSize nsubs,
                                                     mwIndex *subs);
 
 extern OCTINTERP_API size_t mxGetElementSize (const mxArray *ptr);
 
diff --git a/libinterp/corefcn/mxarray.in.h b/libinterp/corefcn/mxarray.in.h
--- a/libinterp/corefcn/mxarray.in.h
+++ b/libinterp/corefcn/mxarray.in.h
@@ -130,19 +130,19 @@ class mxArray;
 class mxArray_base
 {
 protected:
 
   mxArray_base (void) { }
 
 public:
 
-  virtual mxArray_base *dup (void) const = 0;
+  virtual mxArray_base * dup (void) const = 0;
 
-  virtual mxArray *as_mxArray (void) const { return 0; }
+  virtual mxArray * as_mxArray (void) const { return 0; }
 
   virtual ~mxArray_base (void) = default;
 
   virtual bool is_octave_value (void) const { return false; }
 
   virtual int is_cell (void) const = 0;
 
   virtual int is_char (void) const = 0;
@@ -197,17 +197,17 @@ public:
   }
 
   virtual int is_logical_scalar_true (void) const = 0;
 
   virtual mwSize get_m (void) const = 0;
 
   virtual mwSize get_n (void) const = 0;
 
-  virtual mwSize *get_dimensions (void) const = 0;
+  virtual mwSize * get_dimensions (void) const = 0;
 
   virtual mwSize get_number_of_dimensions (void) const = 0;
 
   virtual void set_m (mwSize m) = 0;
 
   virtual void set_n (mwSize n) = 0;
 
   virtual int set_dimensions (mwSize *dims_arg, mwSize ndims_arg) = 0;
@@ -215,77 +215,77 @@ public:
   virtual mwSize get_number_of_elements (void) const = 0;
 
   virtual int is_empty (void) const = 0;
 
   virtual bool is_scalar (void) const = 0;
 
   virtual mxClassID get_class_id (void) const = 0;
 
-  virtual const char *get_class_name (void) const = 0;
+  virtual const char * get_class_name (void) const = 0;
 
   virtual void set_class_name (const char *name_arg) = 0;
 
   // FIXME: Why not just have this '= 0' as the others?
   // Could then eliminate err_invalid_type function and #include "error.h".
-  virtual mxArray *get_cell (mwIndex /*idx*/) const
+  virtual mxArray * get_cell (mwIndex /*idx*/) const
   {
     err_invalid_type ();
   }
 
   virtual void set_cell (mwIndex idx, mxArray *val) = 0;
 
   virtual double get_scalar (void) const = 0;
 
-  virtual void *get_data (void) const = 0;
+  virtual void * get_data (void) const = 0;
 
-  virtual void *get_imag_data (void) const = 0;
+  virtual void * get_imag_data (void) const = 0;
 
   virtual void set_data (void *pr) = 0;
 
   virtual void set_imag_data (void *pi) = 0;
 
-  virtual mwIndex *get_ir (void) const = 0;
+  virtual mwIndex * get_ir (void) const = 0;
 
-  virtual mwIndex *get_jc (void) const = 0;
+  virtual mwIndex * get_jc (void) const = 0;
 
   virtual mwSize get_nzmax (void) const = 0;
 
   virtual void set_ir (mwIndex *ir) = 0;
 
   virtual void set_jc (mwIndex *jc) = 0;
 
   virtual void set_nzmax (mwSize nzmax) = 0;
 
   virtual int add_field (const char *key) = 0;
 
   virtual void remove_field (int key_num) = 0;
 
-  virtual mxArray *get_field_by_number (mwIndex index, int key_num) const = 0;
+  virtual mxArray * get_field_by_number (mwIndex index, int key_num) const = 0;
 
   virtual void
   set_field_by_number (mwIndex index, int key_num, mxArray *val) = 0;
 
   virtual int get_number_of_fields (void) const = 0;
 
-  virtual const char *get_field_name_by_number (int key_num) const = 0;
+  virtual const char * get_field_name_by_number (int key_num) const = 0;
 
   virtual int get_field_number (const char *key) const = 0;
 
   virtual int get_string (char *buf, mwSize buflen) const = 0;
 
-  virtual char *array_to_string (void) const = 0;
+  virtual char * array_to_string (void) const = 0;
 
   virtual mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const = 0;
 
   virtual size_t get_element_size (void) const = 0;
 
   virtual bool mutation_needed (void) const { return false; }
 
-  virtual mxArray *mutate (void) const { return 0; }
+  virtual mxArray * mutate (void) const { return 0; }
 
   virtual octave_value as_octave_value (void) const = 0;
 
 protected:
 
   mxArray_base (const mxArray_base&) { }
 
   // FIXME: Deprecated in 4.2, remove in 4.6
@@ -337,17 +337,17 @@ public:
   mxArray (mwSize m, mwSize n, int num_keys, const char **keys);
 
   mxArray (mwSize ndims, const mwSize *dims);
 
   mxArray (const dim_vector& dv);
 
   mxArray (mwSize m, mwSize n);
 
-  mxArray *dup (void) const
+  mxArray * dup (void) const
   {
     mxArray *retval = rep->as_mxArray ();
 
     if (retval)
       retval->set_name (name);
     else
       {
         mxArray_base *new_rep = rep->dup ();
@@ -410,17 +410,17 @@ public:
 
   int is_logical_scalar_true (void) const
   { return rep->is_logical_scalar_true (); }
 
   mwSize get_m (void) const { return rep->get_m (); }
 
   mwSize get_n (void) const { return rep->get_n (); }
 
-  mwSize *get_dimensions (void) const { return rep->get_dimensions (); }
+  mwSize * get_dimensions (void) const { return rep->get_dimensions (); }
 
   mwSize get_number_of_dimensions (void) const
   { return rep->get_number_of_dimensions (); }
 
   void set_m (mwSize m) { DO_VOID_MUTABLE_METHOD (set_m (m)); }
 
   void set_n (mwSize n) { DO_VOID_MUTABLE_METHOD (set_n (n)); }
 
@@ -429,94 +429,94 @@ public:
 
   mwSize get_number_of_elements (void) const
   { return rep->get_number_of_elements (); }
 
   int is_empty (void) const { return get_number_of_elements () == 0; }
 
   bool is_scalar (void) const { return rep->is_scalar (); }
 
-  const char *get_name (void) const { return name; }
+  const char * get_name (void) const { return name; }
 
   void set_name (const char *name_arg);
 
   mxClassID get_class_id (void) const { return rep->get_class_id (); }
 
-  const char *get_class_name (void) const { return rep->get_class_name (); }
+  const char * get_class_name (void) const { return rep->get_class_name (); }
 
   void set_class_name (const char *name_arg)
   { DO_VOID_MUTABLE_METHOD (set_class_name (name_arg)); }
 
-  mxArray *get_cell (mwIndex idx) const
+  mxArray * get_cell (mwIndex idx) const
   { DO_MUTABLE_METHOD (mxArray *, get_cell (idx)); }
 
   void set_cell (mwIndex idx, mxArray *val)
   { DO_VOID_MUTABLE_METHOD (set_cell (idx, val)); }
 
   double get_scalar (void) const { return rep->get_scalar (); }
 
-  void *get_data (void) const { DO_MUTABLE_METHOD (void *, get_data ()); }
+  void * get_data (void) const { DO_MUTABLE_METHOD (void *, get_data ()); }
 
-  void *get_imag_data (void) const
+  void * get_imag_data (void) const
   { DO_MUTABLE_METHOD (void *, get_imag_data ()); }
 
   void set_data (void *pr) { DO_VOID_MUTABLE_METHOD (set_data (pr)); }
 
   void set_imag_data (void *pi) { DO_VOID_MUTABLE_METHOD (set_imag_data (pi)); }
 
-  mwIndex *get_ir (void) const { DO_MUTABLE_METHOD (mwIndex *, get_ir ()); }
+  mwIndex * get_ir (void) const { DO_MUTABLE_METHOD (mwIndex *, get_ir ()); }
 
-  mwIndex *get_jc (void) const { DO_MUTABLE_METHOD (mwIndex *, get_jc ()); }
+  mwIndex * get_jc (void) const { DO_MUTABLE_METHOD (mwIndex *, get_jc ()); }
 
   mwSize get_nzmax (void) const { return rep->get_nzmax (); }
 
   void set_ir (mwIndex *ir) { DO_VOID_MUTABLE_METHOD (set_ir (ir)); }
 
   void set_jc (mwIndex *jc) { DO_VOID_MUTABLE_METHOD (set_jc (jc)); }
 
   void set_nzmax (mwSize nzmax) { DO_VOID_MUTABLE_METHOD (set_nzmax (nzmax)); }
 
   int add_field (const char *key) { DO_MUTABLE_METHOD (int, add_field (key)); }
 
   void remove_field (int key_num)
   { DO_VOID_MUTABLE_METHOD (remove_field (key_num)); }
 
-  mxArray *get_field_by_number (mwIndex index, int key_num) const
+  mxArray * get_field_by_number (mwIndex index, int key_num) const
   { DO_MUTABLE_METHOD (mxArray *, get_field_by_number (index, key_num)); }
 
   void set_field_by_number (mwIndex index, int key_num, mxArray *val)
   { DO_VOID_MUTABLE_METHOD (set_field_by_number (index, key_num, val)); }
 
   int get_number_of_fields (void) const { return rep->get_number_of_fields (); }
 
-  const char *get_field_name_by_number (int key_num) const
+  const char * get_field_name_by_number (int key_num) const
   { DO_MUTABLE_METHOD (const char*, get_field_name_by_number (key_num)); }
 
   int get_field_number (const char *key) const
   { DO_MUTABLE_METHOD (int, get_field_number (key)); }
 
   int get_string (char *buf, mwSize buflen) const
   { return rep->get_string (buf, buflen); }
 
-  char *array_to_string (void) const { return rep->array_to_string (); }
+  char * array_to_string (void) const { return rep->array_to_string (); }
 
   mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const
   { return rep->calc_single_subscript (nsubs, subs); }
 
   size_t get_element_size (void) const { return rep->get_element_size (); }
 
   bool mutation_needed (void) const { return rep->mutation_needed (); }
 
-  mxArray *mutate (void) const { return rep->mutate (); }
+  mxArray * mutate (void) const { return rep->mutate (); }
 
-  static void *malloc (size_t n);
+  static void * malloc (size_t n);
 
-  static void *calloc (size_t n, size_t t);
+  static void * calloc (size_t n, size_t t);
 
-  static char *strsave (const char *str)
+  static char * strsave (const char *str)
   {
     char *retval = 0;
 
     if (str)
       {
         mwSize sz = sizeof (mxChar) * (strlen (str) + 1);
         retval = static_cast<char *> (mxArray::malloc (sz));
         strcpy (retval, str);
diff --git a/libinterp/corefcn/oct-fstrm.h b/libinterp/corefcn/oct-fstrm.h
--- a/libinterp/corefcn/oct-fstrm.h
+++ b/libinterp/corefcn/oct-fstrm.h
@@ -65,19 +65,19 @@ public:
   bool eof (void) const;
 
   void do_close (void);
 
   // The name of the file.
 
   std::string name (void) const { return nm; }
 
-  std::istream *input_stream (void);
+  std::istream * input_stream (void);
 
-  std::ostream *output_stream (void);
+  std::ostream * output_stream (void);
 
 protected:
 
   ~octave_fstream (void) = default;
 
 private:
 
   std::string nm;
diff --git a/libinterp/corefcn/oct-iostrm.h b/libinterp/corefcn/oct-iostrm.h
--- a/libinterp/corefcn/oct-iostrm.h
+++ b/libinterp/corefcn/oct-iostrm.h
@@ -71,17 +71,17 @@ public:
 protected:
 
   void invalid_operation (void) const;
 
 private:
 
   std::string nm;
 
-  virtual const char *stream_type (void) const = 0;
+  virtual const char * stream_type (void) const = 0;
 };
 
 class
 octave_istream : public octave_base_iostream
 {
 public:
 
   octave_istream (std::istream *arg = 0, const std::string& n = "")
@@ -92,29 +92,29 @@ public:
 
   static octave::stream
   create (std::istream *arg = 0, const std::string& n = "");
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
-  std::istream *input_stream (void) { return is; }
+  std::istream * input_stream (void) { return is; }
 
-  std::ostream *output_stream (void) { return 0; }
+  std::ostream * output_stream (void) { return 0; }
 
 protected:
 
   ~octave_istream (void) = default;
 
 private:
 
   std::istream *is;
 
-  const char *stream_type (void) const { return "octave_istream"; }
+  const char * stream_type (void) const { return "octave_istream"; }
 
   // No copying!
 
   octave_istream (const octave_istream&) = delete;
 
   octave_istream& operator = (const octave_istream&) = delete;
 };
 
@@ -131,29 +131,29 @@ public:
 
   static octave::stream
   create (std::ostream *arg, const std::string& n = "");
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
-  std::istream *input_stream (void) { return 0; }
+  std::istream * input_stream (void) { return 0; }
 
-  std::ostream *output_stream (void) { return os; }
+  std::ostream * output_stream (void) { return os; }
 
 protected:
 
   ~octave_ostream (void) = default;
 
 private:
 
   std::ostream *os;
 
-  const char *stream_type (void) const { return "octave_ostream"; }
+  const char * stream_type (void) const { return "octave_ostream"; }
 
   // No copying!
 
   octave_ostream (const octave_ostream&) = delete;
 
   octave_ostream& operator = (const octave_ostream&) = delete;
 };
 
diff --git a/libinterp/corefcn/oct-procbuf.h b/libinterp/corefcn/oct-procbuf.h
--- a/libinterp/corefcn/oct-procbuf.h
+++ b/libinterp/corefcn/oct-procbuf.h
@@ -48,19 +48,19 @@ public:
   // No copying!
 
   octave_procbuf (const octave_procbuf&) = delete;
 
   octave_procbuf& operator = (const octave_procbuf&) = delete;
 
   ~octave_procbuf (void) { close (); }
 
-  octave_procbuf *open (const char *command, int mode);
+  octave_procbuf * open (const char *command, int mode);
 
-  octave_procbuf *close (void);
+  octave_procbuf * close (void);
 
   int wait_status (void) const { return wstatus; }
 
   bool is_open (void) const { return open_p; }
 
   pid_t pid (void) const { return proc_pid; }
 
 protected:
diff --git a/libinterp/corefcn/oct-stdstrm.h b/libinterp/corefcn/oct-stdstrm.h
--- a/libinterp/corefcn/oct-stdstrm.h
+++ b/libinterp/corefcn/oct-stdstrm.h
@@ -61,22 +61,22 @@ public:
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return s ? s->eof () : true; }
 
   // The name of the file.
 
   std::string name (void) const { return nm; }
 
-  std::istream *input_stream (void) { return (md & std::ios::in) ? s : 0; }
+  std::istream * input_stream (void) { return (md & std::ios::in) ? s : 0; }
 
-  std::ostream *output_stream (void) { return (md & std::ios::out) ? s : 0; }
+  std::ostream * output_stream (void) { return (md & std::ios::out) ? s : 0; }
 
   // FIXME: should not have to cast away const here.
-  BUF_T *rdbuf (void) const
+  BUF_T * rdbuf (void) const
   { return s ? (const_cast<STREAM_T *> (s))->rdbuf () : 0; }
 
   int file_number (void) const { return fnum; }
 
   bool bad (void) const { return s ? s->bad () : true; }
 
   void clear (void) { if (s) s->clear (); }
 
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -297,28 +297,28 @@ namespace octave
 
     // The length can be different than the number of conversions.
     // For example, "x %d y %d z" has 2 conversions but the length of
     // the list is 3 because of the characters that appear after the
     // last conversion.
 
     size_t length (void) const { return fmt_elts.size (); }
 
-    const scanf_format_elt *first (void)
+    const scanf_format_elt * first (void)
     {
       curr_idx = 0;
       return current ();
     }
 
-    const scanf_format_elt *current (void) const
+    const scanf_format_elt * current (void) const
     {
       return length () > 0 ? fmt_elts[curr_idx] : 0;
     }
 
-    const scanf_format_elt *next (bool cycle = true)
+    const scanf_format_elt * next (bool cycle = true)
     {
       static scanf_format_elt dummy
         (0, 0, false, scanf_format_elt::null, '\0', "");
 
       curr_idx++;
 
       if (curr_idx >= length ())
         {
@@ -806,30 +806,30 @@ namespace octave
     printf_format_list (const printf_format_list&) = delete;
 
     printf_format_list& operator = (const printf_format_list&) = delete;
 
     ~printf_format_list (void);
 
     octave_idx_type num_conversions (void) { return nconv; }
 
-    const printf_format_elt *first (void)
+    const printf_format_elt * first (void)
     {
       curr_idx = 0;
       return current ();
     }
 
-    const printf_format_elt *current (void) const
+    const printf_format_elt * current (void) const
     {
       return length () > 0 ? fmt_elts[curr_idx] : 0;
     }
 
     size_t length (void) const { return fmt_elts.size (); }
 
-    const printf_format_elt *next (bool cycle = true)
+    const printf_format_elt * next (bool cycle = true)
     {
       curr_idx++;
 
       if (curr_idx >= length ())
         {
           if (cycle)
             curr_idx = 0;
           else
@@ -1277,21 +1277,21 @@ namespace octave
     // get() or get_undelim(), with no intervening
     // get, get_delim, field_done, refresh_buf, getline, read or seekg.
     void putback (char /*ch*/ = 0) { if (! eof ()) --idx; }
 
     int getline  (std::string& dest, char delim);
 
     // int skipline (char delim);
 
-    char *read (char *buffer, int size, char* &new_start);
+    char * read (char *buffer, int size, char* &new_start);
 
     // Return a position suitable to "seekg", valid only within this
     // block between calls to field_done.
-    char *tellg (void) { return idx; }
+    char * tellg (void) { return idx; }
 
     void seekg (char *old_idx) { idx = old_idx; }
 
     bool eof (void)
     {
       return (eob == buf && i_stream.eof ()) || (flags & std::ios_base::eofbit);
     }
 
@@ -1711,28 +1711,28 @@ namespace octave
 
     // The length can be different than the number of conversions.
     // For example, "x %d y %d z" has 2 conversions but the length of
     // the list is 3 because of the characters that appear after the
     // last conversion.
 
     size_t numel (void) const { return fmt_elts.size (); }
 
-    const textscan_format_elt *first (void)
+    const textscan_format_elt * first (void)
     {
       curr_idx = 0;
       return current ();
     }
 
-    const textscan_format_elt *current (void) const
+    const textscan_format_elt * current (void) const
     {
       return numel () > 0 ? fmt_elts[curr_idx] : 0;
     }
 
-    const textscan_format_elt *next (bool cycle = true)
+    const textscan_format_elt * next (bool cycle = true)
     {
       curr_idx++;
 
       if (curr_idx >= numel ())
         {
           if (cycle)
             curr_idx = 0;
           else
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -96,23 +96,23 @@ namespace octave
     // The name of the file.
 
     virtual std::string name (void) const = 0;
 
     // If the derived class provides this function and it returns a
     // pointer to a valid istream, scanf(), read(), getl(), and gets()
     // will automatically work for this stream.
 
-    virtual std::istream *input_stream (void) { return 0; }
+    virtual std::istream * input_stream (void) { return 0; }
 
     // If the derived class provides this function and it returns a
     // pointer to a valid ostream, flush(), write(), and printf() will
     // automatically work for this stream.
 
-    virtual std::ostream *output_stream (void) { return 0; }
+    virtual std::ostream * output_stream (void) { return 0; }
 
     // Return TRUE if this stream is open.
 
     bool is_open (void) const { return open_state; }
 
     virtual void do_close (void) { }
 
     void close (void)
@@ -356,22 +356,22 @@ namespace octave
     std::string name (void) const;
 
     int mode (void) const;
 
     mach_info::float_format float_format (void) const;
 
     static std::string mode_as_string (int mode);
 
-    std::istream *input_stream (void)
+    std::istream * input_stream (void)
     {
       return rep ? rep->input_stream () : 0;
     }
 
-    std::ostream *output_stream (void)
+    std::ostream * output_stream (void)
     {
       return rep ? rep->output_stream () : 0;
     }
 
     void clearerr (void) { if (rep) rep->clearerr (); }
 
   private:
 
diff --git a/libinterp/corefcn/oct-strstrm.h b/libinterp/corefcn/oct-strstrm.h
--- a/libinterp/corefcn/oct-strstrm.h
+++ b/libinterp/corefcn/oct-strstrm.h
@@ -59,17 +59,17 @@ public:
   // Return current stream position.
 
   virtual off_t tell (void);
 
   // The name of the file.
 
   std::string name (void) const { return ""; }
 
-  virtual std::streambuf *rdbuf (void) = 0;
+  virtual std::streambuf * rdbuf (void) = 0;
 
   virtual bool bad (void) const = 0;
 
   virtual void clear (void) = 0;
 };
 
 class
 octave_istrstream : public octave_base_strstream
@@ -110,23 +110,23 @@ public:
   create (const std::string& data, std::ios::openmode arg_md = std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format ());
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return is.eof (); }
 
-  std::istream *input_stream (void) { return &is; }
+  std::istream * input_stream (void) { return &is; }
 
-  std::ostream *output_stream (void) { return 0; }
+  std::ostream * output_stream (void) { return 0; }
 
   off_t tell (void) { return is.tellg (); }
 
-  std::streambuf *rdbuf (void) { return is ? is.rdbuf () : 0; }
+  std::streambuf * rdbuf (void) { return is ? is.rdbuf () : 0; }
 
   bool bad (void) const { return is.bad (); }
 
   void clear (void) { is.clear (); }
 
 private:
 
   std::istringstream is;
@@ -158,23 +158,23 @@ public:
   create (std::ios::openmode arg_md = std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format ());
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return os.eof (); }
 
-  std::istream *input_stream (void) { return 0; }
+  std::istream * input_stream (void) { return 0; }
 
-  std::ostream *output_stream (void) { return &os; }
+  std::ostream * output_stream (void) { return &os; }
 
   std::string str (void) { return os.str (); }
 
-  std::streambuf *rdbuf (void) { return os ? os.rdbuf () : 0; }
+  std::streambuf * rdbuf (void) { return os ? os.rdbuf () : 0; }
 
   bool bad (void) const { return os.bad (); }
 
   void clear (void) { os.clear (); }
 
 private:
 
   std::ostringstream os;
diff --git a/libinterp/corefcn/octave-link.h b/libinterp/corefcn/octave-link.h
--- a/libinterp/corefcn/octave-link.h
+++ b/libinterp/corefcn/octave-link.h
@@ -306,17 +306,17 @@ public:
                      const std::string& cond = "")
   {
     if (enabled ())
       instance->do_update_breakpoint (insert, file, line, cond);
   }
 
   static void connect_link (octave_link *);
 
-  static octave_link *disconnect_link (bool delete_instance = true)
+  static octave_link * disconnect_link (bool delete_instance = true)
   {
     if (delete_instance)
       {
         delete instance;
         instance = 0;
         return 0;
       }
     else
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -316,17 +316,17 @@ namespace octave
         }
 
       if (! instance)
         error ("unable to create interrupt_manager");
 
       return retval;
     }
 
-    static base_interrupt_manager *create_instance (void)
+    static base_interrupt_manager * create_instance (void)
     {
 #if defined (OCTAVE_USE_WINDOWS_API)
       return new w32_interrupt_manager ();
 #else
       return new posix_interrupt_manager ();
 #endif
     }
 
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -450,17 +450,17 @@ public:
 
       scope_id scope (void) const { return decl_scope; }
 
       void set_curr_fcn (octave_user_function *fcn)
       {
         curr_fcn = fcn;
       }
 
-      symbol_record_rep *dup (scope_id new_scope) const
+      symbol_record_rep * dup (scope_id new_scope) const
       {
         return new symbol_record_rep (new_scope, name, varval (),
                                       storage_class);
       }
 
       void dump (std::ostream& os, const std::string& prefix) const;
 
       scope_id decl_scope;
@@ -2228,17 +2228,17 @@ public:
 
         if (! parents.empty ())
           retval.insert (retval.end (), parents.begin (), parents.end ());
       }
 
     return retval;
   }
 
-  static octave_user_function *get_curr_fcn (scope_id scope = xcurrent_scope)
+  static octave_user_function * get_curr_fcn (scope_id scope = xcurrent_scope)
   {
     symbol_table *inst = get_instance (scope);
     return inst->curr_fcn;
   }
 
   static void set_curr_fcn (octave_user_function *curr_fcn,
                             scope_id scope = xcurrent_scope)
   {
@@ -2353,17 +2353,17 @@ private:
   // No copying!
 
   symbol_table (const symbol_table&) = delete;
 
   symbol_table& operator = (const symbol_table&) = delete;
 
   ~symbol_table (void) = default;
 
-  static symbol_table *get_instance (scope_id scope, bool create = true)
+  static symbol_table * get_instance (scope_id scope, bool create = true)
   {
     symbol_table *retval = 0;
 
     bool ok = true;
 
     if (scope != xglobal_scope)
       {
         if (scope == xcurrent_scope)
@@ -2466,17 +2466,17 @@ private:
 
                     sr.mark_inherited ();
                   }
               }
           }
       }
   }
 
-  static fcn_info *get_fcn_info (const std::string& name)
+  static fcn_info * get_fcn_info (const std::string& name)
   {
     fcn_table_iterator p = fcn_table.find (name);
     return p != fcn_table.end () ? &p->second : 0;
   }
 
   octave_value
   do_find (const std::string& name, const octave_value_list& args,
            bool skip_variables, bool local_funcs);
diff --git a/libinterp/corefcn/sysdep.h b/libinterp/corefcn/sysdep.h
--- a/libinterp/corefcn/sysdep.h
+++ b/libinterp/corefcn/sysdep.h
@@ -35,17 +35,19 @@ along with Octave; see the file COPYING.
 extern OCTINTERP_API void sysdep_init (void);
 
 extern OCTINTERP_API void set_application_id (void);
 
 extern OCTINTERP_API void sysdep_cleanup (void);
 
 extern OCTINTERP_API void raw_mode (bool, bool wait = true);
 
-extern OCTINTERP_API FILE *octave_popen (const char *command, const char *mode);
+extern OCTINTERP_API FILE * octave_popen (const char *command,
+                                          const char *mode);
+
 extern OCTINTERP_API int octave_pclose (FILE *f);
 
 extern OCTINTERP_API int octave_kbhit (bool wait = true);
 
 extern OCTINTERP_API std::string get_P_tmpdir (void);
 
 extern OCTINTERP_API bool same_file_internal (const std::string&,
                                               const std::string&);
diff --git a/libinterp/corefcn/utils.h b/libinterp/corefcn/utils.h
--- a/libinterp/corefcn/utils.h
+++ b/libinterp/corefcn/utils.h
@@ -79,17 +79,17 @@ extern OCTINTERP_API std::string fcn_fil
 OCTAVE_DEPRECATED ("use 'load_path::find_oct_file' instead")
 extern OCTINTERP_API std::string oct_file_in_path (const std::string&);
 
 OCTAVE_DEPRECATED ("use 'load_path::find_mex_file' instead")
 extern OCTINTERP_API std::string mex_file_in_path (const std::string&);
 
 extern OCTINTERP_API std::string do_string_escapes (const std::string& s);
 
-extern OCTINTERP_API const char *undo_string_escape (char c);
+extern OCTINTERP_API const char * undo_string_escape (char c);
 
 extern OCTINTERP_API std::string undo_string_escapes (const std::string& s);
 
 extern OCTINTERP_API void
 check_dimensions (dim_vector& dim, const char *warnfor);
 
 extern OCTINTERP_API void
 get_dimensions (const octave_value& a, const char *warn_for,
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -498,17 +498,17 @@ public:
   unsigned int get_total_samples (void);
   void set_end_sample (unsigned int sample);
   unsigned int get_end_sample (void);
   void reset_end_sample (void);
   void set_tag (const charMatrix& tag);
   charMatrix get_tag (void);
   void set_userdata (const octave_value& userdata);
   octave_value get_userdata (void);
-  PaStream *get_stream (void);
+  PaStream * get_stream (void);
 
   void playblocking (void);
   void play (void);
   void pause (void);
   void resume (void);
   void stop (void);
   bool isplaying (void);
 
@@ -1253,20 +1253,20 @@ public:
   unsigned int get_total_samples (void);
   void set_end_sample (unsigned int sample);
   unsigned int get_end_sample (void);
   void reset_end_sample (void);
   void set_tag (const charMatrix& tag);
   charMatrix get_tag (void);
   void set_userdata (const octave_value& userdata);
   octave_value get_userdata (void);
-  PaStream *get_stream (void);
+  PaStream * get_stream (void);
 
   octave_value getaudiodata (void);
-  audioplayer *getplayer (void);
+  audioplayer * getplayer (void);
   bool isrecording (void);
   audioplayer play (void);
   void record (void);
   void recordblocking (float seconds);
   void pause (void);
   void resume (void);
   void stop (void);
   void append (float sample_l, float sample_r);
diff --git a/libinterp/octave-value/ov-base-diag.h b/libinterp/octave-value/ov-base-diag.h
--- a/libinterp/octave-value/ov-base-diag.h
+++ b/libinterp/octave-value/ov-base-diag.h
@@ -201,17 +201,17 @@ public:
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const;
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
   octave_value fast_elem_extract (octave_idx_type n) const;
diff --git a/libinterp/octave-value/ov-base-int.h b/libinterp/octave-value/ov-base-int.h
--- a/libinterp/octave-value/ov-base-int.h
+++ b/libinterp/octave-value/ov-base-int.h
@@ -48,23 +48,23 @@ octave_base_int_matrix : public octave_b
 public:
 
   octave_base_int_matrix (void) : octave_base_matrix<T> () { }
 
   octave_base_int_matrix (const T& nda) : octave_base_matrix<T> (nda) { }
 
   ~octave_base_int_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_base_int_matrix (*this); }
 
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_base_int_matrix (); }
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   bool is_real_type (void) const { return true; }
 
   //  void increment (void) { matrix += 1; }
 
   //  void decrement (void) { matrix -= 1; }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
@@ -107,22 +107,22 @@ octave_base_int_scalar : public octave_b
 public:
 
   octave_base_int_scalar (void) : octave_base_scalar<T> () { }
 
   octave_base_int_scalar (const T& s) : octave_base_scalar<T> (s) { }
 
   ~octave_base_int_scalar (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_base_int_scalar (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_base_int_scalar (); }
 
-  octave_base_value *try_narrowing_conversion (void) { return 0; }
+  octave_base_value * try_narrowing_conversion (void) { return 0; }
 
   bool is_real_type (void) const { return true; }
 
   bool is_real_scalar (void) const { return true; }
 
   //  void increment (void) { scalar += 1; }
 
   //  void decrement (void) { scalar -= 1; }
diff --git a/libinterp/octave-value/ov-base-scalar.h b/libinterp/octave-value/ov-base-scalar.h
--- a/libinterp/octave-value/ov-base-scalar.h
+++ b/libinterp/octave-value/ov-base-scalar.h
@@ -138,17 +138,17 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
   void short_disp (std::ostream& os) const;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
-  void *mex_get_data (void) const { return const_cast<ST *> (&scalar); }
+  void * mex_get_data (void) const { return const_cast<ST *> (&scalar); }
 
   const ST& scalar_ref (void) const { return scalar; }
 
   ST& scalar_ref (void) { return scalar; }
 
   octave_value fast_elem_extract (octave_idx_type n) const;
 
   bool fast_elem_insert_self (void *where, builtin_type_t btyp) const;
diff --git a/libinterp/octave-value/ov-base-sparse.h b/libinterp/octave-value/ov-base-sparse.h
--- a/libinterp/octave-value/ov-base-sparse.h
+++ b/libinterp/octave-value/ov-base-sparse.h
@@ -162,21 +162,21 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   // Unsafe.  These functions exists to support the MEX interface.
   // You should not use them anywhere else.
-  void *mex_get_data (void) const { return matrix.mex_get_data (); }
+  void * mex_get_data (void) const { return matrix.mex_get_data (); }
 
-  octave_idx_type *mex_get_ir (void) const { return matrix.mex_get_ir (); }
+  octave_idx_type * mex_get_ir (void) const { return matrix.mex_get_ir (); }
 
-  octave_idx_type *mex_get_jc (void) const { return matrix.mex_get_jc (); }
+  octave_idx_type * mex_get_jc (void) const { return matrix.mex_get_jc (); }
 
   octave_value fast_elem_extract (octave_idx_type n) const;
 
 protected:
 
   octave_value map (octave_base_value::unary_mapper_t umap) const;
 
   T matrix;
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -248,17 +248,17 @@ public:
   virtual octave_value as_int32 (void) const;
   virtual octave_value as_int64 (void) const;
 
   virtual octave_value as_uint8 (void) const;
   virtual octave_value as_uint16 (void) const;
   virtual octave_value as_uint32 (void) const;
   virtual octave_value as_uint64 (void) const;
 
-  virtual octave_base_value *try_narrowing_conversion (void) { return 0; }
+  virtual octave_base_value * try_narrowing_conversion (void) { return 0; }
 
   virtual void maybe_economize (void) { }
 
   virtual Matrix size (void);
 
   virtual octave_idx_type numel (const octave_value_list&);
 
   virtual octave_value
@@ -592,36 +592,36 @@ public:
   virtual string_vector map_keys (void) const;
 
   virtual size_t nparents (void) const;
 
   virtual std::list<std::string> parent_class_name_list (void) const;
 
   virtual string_vector parent_class_names (void) const;
 
-  virtual octave_base_value *find_parent_class (const std::string&)
+  virtual octave_base_value * find_parent_class (const std::string&)
   { return 0; }
 
-  virtual octave_base_value *unique_parent_class (const std::string&)
+  virtual octave_base_value * unique_parent_class (const std::string&)
   { return 0; }
 
   virtual bool is_instance_of (const std::string&) const
   { return false; }
 
-  virtual octave_function *function_value (bool silent = false);
+  virtual octave_function * function_value (bool silent = false);
 
-  virtual octave_user_function *user_function_value (bool silent = false);
+  virtual octave_user_function * user_function_value (bool silent = false);
 
-  virtual octave_user_script *user_script_value (bool silent = false);
+  virtual octave_user_script * user_script_value (bool silent = false);
 
-  virtual octave_user_code *user_code_value (bool silent = false);
+  virtual octave_user_code * user_code_value (bool silent = false);
 
-  virtual octave_fcn_handle *fcn_handle_value (bool silent = false);
+  virtual octave_fcn_handle * fcn_handle_value (bool silent = false);
 
-  virtual octave_fcn_inline *fcn_inline_value (bool silent = false);
+  virtual octave_fcn_inline * fcn_inline_value (bool silent = false);
 
   virtual octave_value_list list_value (void) const;
 
   virtual octave_value convert_to_str (bool pad = false, bool force = false,
                                        char type = '\'') const;
   virtual octave_value
   convert_to_str_internal (bool pad, bool force, char type) const;
 
@@ -665,23 +665,23 @@ public:
   virtual bool
   load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   virtual int
   write (octave::stream& os, int block_size,
          oct_data_conv::data_type output_type, int skip,
          octave::mach_info::float_format flt_fmt) const;
 
-  virtual void *mex_get_data (void) const { return 0; }
+  virtual void * mex_get_data (void) const { return 0; }
 
-  virtual octave_idx_type *mex_get_ir (void) const { return 0; }
+  virtual octave_idx_type * mex_get_ir (void) const { return 0; }
 
-  virtual octave_idx_type *mex_get_jc (void) const { return 0; }
+  virtual octave_idx_type * mex_get_jc (void) const { return 0; }
 
-  virtual mxArray *as_mxArray (void) const;
+  virtual mxArray * as_mxArray (void) const;
 
   virtual octave_value diag (octave_idx_type k = 0) const;
 
   virtual octave_value diag (octave_idx_type m, octave_idx_type n) const;
 
   virtual octave_value sort (octave_idx_type dim = 0,
                              sortmode mode = ASCENDING) const;
   virtual octave_value sort (Array<octave_idx_type> &sidx,
@@ -835,17 +835,17 @@ protected:
   void reset (void) const;
 
   // A reference count.
   // NOTE: the declaration is octave_idx_type because with 64-bit indexing,
   // it is well possible to have more than MAX_INT copies of a single value
   // (think of an empty cell array with >2G elements).
   octave::refcount<octave_idx_type> count;
 
-  static const char *get_umap_name (unary_mapper_t);
+  static const char * get_umap_name (unary_mapper_t);
 
   void warn_load (const char *type) const;
   void warn_save (const char *type) const;
 
 private:
 
   void wrong_type_arg_error (void) const;
 
diff --git a/libinterp/octave-value/ov-bool-mat.h b/libinterp/octave-value/ov-bool-mat.h
--- a/libinterp/octave-value/ov-bool-mat.h
+++ b/libinterp/octave-value/ov-bool-mat.h
@@ -72,25 +72,25 @@ public:
     set_idx_cache (cache);
   }
 
   octave_bool_matrix (const octave_bool_matrix& bm)
     : octave_base_matrix<boolNDArray> (bm) { }
 
   ~octave_bool_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_bool_matrix (*this); }
 
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_bool_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   idx_vector index_vector (bool /* require_integers */ = false) const
   {
     return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix));
   }
 
   builtin_type_t builtin_type (void) const { return btyp_bool; }
 
@@ -224,19 +224,19 @@ public:
 
   int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
-  void *mex_get_data (void) const { return matrix.mex_get_data (); }
+  void * mex_get_data (void) const { return matrix.mex_get_data (); }
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
   octave_value map (unary_mapper_t umap) const
   {
     octave_matrix m (array_value ());
     return m.map (umap);
   }
 
diff --git a/libinterp/octave-value/ov-bool-sparse.h b/libinterp/octave-value/ov-bool-sparse.h
--- a/libinterp/octave-value/ov-bool-sparse.h
+++ b/libinterp/octave-value/ov-bool-sparse.h
@@ -70,24 +70,24 @@ public:
   octave_sparse_bool_matrix (const Sparse<bool>& a)
     : octave_base_sparse<SparseBoolMatrix> (a) { }
 
   octave_sparse_bool_matrix (const octave_sparse_bool_matrix& bm)
     : octave_base_sparse<SparseBoolMatrix> (bm) { }
 
   ~octave_sparse_bool_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_sparse_bool_matrix (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_sparse_bool_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   // FIXME: Adapt idx_vector to allow sparse logical indexing without overflow!
   idx_vector index_vector (bool /* require_integers */ = false) const
   {
     return idx_vector (matrix);
   }
 
   builtin_type_t builtin_type (void) const { return btyp_bool; }
@@ -136,17 +136,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
   octave_value map (unary_mapper_t umap) const
   {
     octave_sparse_matrix m (sparse_matrix_value ());
     return m.map (umap);
   }
 
diff --git a/libinterp/octave-value/ov-bool.h b/libinterp/octave-value/ov-bool.h
--- a/libinterp/octave-value/ov-bool.h
+++ b/libinterp/octave-value/ov-bool.h
@@ -57,18 +57,18 @@ public:
   octave_bool (bool b)
     : octave_base_scalar<bool> (b) { }
 
   octave_bool (const octave_bool& s)
     : octave_base_scalar<bool> (s) { }
 
   ~octave_bool (void) = default;
 
-  octave_base_value *clone (void) const { return new octave_bool (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * clone (void) const { return new octave_bool (*this); }
+  octave_base_value * empty_clone (void) const
   { return new octave_bool_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   idx_vector index_vector (bool /* require_integers */ = false) const { return idx_vector (scalar); }
@@ -238,17 +238,17 @@ public:
   int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     return os.write (bool_array_value (), block_size, output_type,
                      skip, flt_fmt);
   }
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
   octave_value map (unary_mapper_t umap) const
   {
     octave_scalar m (scalar_value ());
     return m.map (umap);
   }
 
diff --git a/libinterp/octave-value/ov-builtin.h b/libinterp/octave-value/ov-builtin.h
--- a/libinterp/octave-value/ov-builtin.h
+++ b/libinterp/octave-value/ov-builtin.h
@@ -77,28 +77,28 @@ public:
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout,
                              const std::list<octave_lvalue>* lvalue_list);
 
-  octave_function *function_value (bool = false) { return this; }
+  octave_function * function_value (bool = false) { return this; }
 
   bool is_builtin_function (void) const { return true; }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args,
                      const std::list<octave_lvalue>* lvalue_list);
 
-  jit_type *to_jit (void) const;
+  jit_type * to_jit (void) const;
 
   void stash_jit (jit_type& type);
 
   fcn function (void) const;
 
   void push_dispatch_class (const std::string& dispatch_type);
 
   bool handles_dispatch_class (const std::string& dispatch_type) const;
diff --git a/libinterp/octave-value/ov-cell.h b/libinterp/octave-value/ov-cell.h
--- a/libinterp/octave-value/ov-cell.h
+++ b/libinterp/octave-value/ov-cell.h
@@ -59,21 +59,21 @@ public:
     : octave_base_matrix<Cell> (Cell (str)),
       cellstr_cache (new Array<std::string> (str)) { }
 
   octave_cell (const octave_cell& c)
     : octave_base_matrix<Cell> (c), cellstr_cache () { }
 
   ~octave_cell (void) = default;
 
-  octave_base_value *clone (void) const { return new octave_cell (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_cell (); }
+  octave_base_value * clone (void) const { return new octave_cell (*this); }
+  octave_base_value * empty_clone (void) const { return new octave_cell (); }
 
 #if 0
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 #endif
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
   {
     octave_value_list tmp = subsref (type, idx, 1);
     return tmp.length () > 0 ? tmp(0) : octave_value ();
   }
@@ -166,21 +166,21 @@ public:
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   octave_value map (unary_mapper_t umap) const;
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
-  void *mex_get_data (void) const;
+  void * mex_get_data (void) const;
 
 private:
 
   void clear_cellstr_cache (void) const
   { cellstr_cache.reset (); }
 
   mutable std::unique_ptr<Array<std::string> > cellstr_cache;
 
diff --git a/libinterp/octave-value/ov-ch-mat.h b/libinterp/octave-value/ov-ch-mat.h
--- a/libinterp/octave-value/ov-ch-mat.h
+++ b/libinterp/octave-value/ov-ch-mat.h
@@ -77,19 +77,19 @@ protected:
 
   octave_char_matrix (const octave_char_matrix& chm)
     : octave_base_matrix<charNDArray> (chm) { }
 
 public:
 
   ~octave_char_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_char_matrix (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_char_matrix (); }
 
   idx_vector index_vector (bool require_integers = false) const;
 
   builtin_type_t builtin_type (void) const { return btyp_char; }
 
   bool is_char_matrix (void) const { return true; }
   bool is_real_matrix (void) const { return true; }
@@ -158,16 +158,16 @@ public:
   octave_value as_uint16 (void) const;
   octave_value as_uint32 (void) const;
   octave_value as_uint64 (void) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
-  void *mex_get_data (void) const { return matrix.mex_get_data (); }
+  void * mex_get_data (void) const { return matrix.mex_get_data (); }
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-class.h b/libinterp/octave-value/ov-class.h
--- a/libinterp/octave-value/ov-class.h
+++ b/libinterp/octave-value/ov-class.h
@@ -63,21 +63,21 @@ public:
                 const octave_value_list& parents);
 
   octave_class (const octave_class& s)
     : octave_base_value (s), map (s.map), c_name (s.c_name),
       parent_list (s.parent_list), obsolete_copies (0)  { }
 
   ~octave_class (void) = default;
 
-  octave_base_value *clone (void) const { return new octave_class (*this); }
+  octave_base_value * clone (void) const { return new octave_class (*this); }
 
-  octave_base_value *unique_clone (void);
+  octave_base_value * unique_clone (void);
 
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   {
     return new octave_class (octave_map (map.keys ()), c_name, parent_list);
   }
 
   Cell dotref (const octave_value_list& idx);
 
   Matrix size (void);
 
@@ -159,19 +159,19 @@ public:
   string_vector map_keys (void) const;
 
   std::list<std::string> parent_class_name_list (void) const
   { return parent_list; }
 
   string_vector parent_class_names (void) const
   { return string_vector (parent_list); }
 
-  octave_base_value *find_parent_class (const std::string&);
+  octave_base_value * find_parent_class (const std::string&);
 
-  octave_base_value *unique_parent_class (const std::string&);
+  octave_base_value * unique_parent_class (const std::string&);
 
   bool is_instance_of (const std::string&) const;
 
   string_vector string_vector_value (bool pad) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
@@ -195,17 +195,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
 private:
   octave_map map;
 
 public:
   int type_id (void) const { return t_id; }
   std::string type_name (void) const { return t_name; }
   std::string class_name (void) const { return c_name; }
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -700,17 +700,17 @@ private:
       else
         delete this;
     }
 
     void mark_as_meta_class (void) { meta = true; }
 
     bool is_meta_class (void) const { return meta; }
 
-    octave::tree_evaluator *evaluator (void) const { return m_evaluator; }
+    octave::tree_evaluator * evaluator (void) const { return m_evaluator; }
 
   private:
     void load_all_methods (void);
 
     void find_names (std::set<std::string>& names, bool all);
 
     void find_properties (std::map<std::string,cdef_property>& props,
                           int mode = 0);
@@ -891,17 +891,17 @@ public:
 
 private:
   cdef_class_rep* get_rep (void)
   { return dynamic_cast<cdef_class_rep *> (cdef_object::get_rep ()); }
 
   const cdef_class_rep* get_rep (void) const
   { return dynamic_cast<const cdef_class_rep *> (cdef_object::get_rep ()); }
 
-  octave::tree_evaluator *evaluator (void) const
+  octave::tree_evaluator * evaluator (void) const
   { return get_rep ()->evaluator (); }
 
   friend bool operator == (const cdef_class&, const cdef_class&);
   friend bool operator != (const cdef_class&, const cdef_class&);
   friend bool operator < (const cdef_class&, const cdef_class&);
 
 private:
   static cdef_class _meta_class;
diff --git a/libinterp/octave-value/ov-colon.h b/libinterp/octave-value/ov-colon.h
--- a/libinterp/octave-value/ov-colon.h
+++ b/libinterp/octave-value/ov-colon.h
@@ -49,19 +49,19 @@ public:
   octave_magic_colon (void)
     : octave_base_value () { }
 
   octave_magic_colon (const octave_magic_colon&)
     : octave_base_value () { }
 
   ~octave_magic_colon (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_magic_colon (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_magic_colon (); }
 
   idx_vector index_vector (bool /* require_integers */ = false) const { return idx_vector (':'); }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -75,17 +75,17 @@ namespace octave
     ~complex_index_exception (void) = default;
 
     std::string details (void) const
     {
       return "subscripts must be real (forgot to initialize i or j?)";
     }
 
     // ID of error to throw.
-    const char *err_id (void) const
+    const char * err_id (void) const
     {
       return "Octave:invalid-index";
     }
   };
 }
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -57,28 +57,28 @@ public:
   octave_complex (const Complex& c)
     : octave_base_scalar<Complex> (c) { }
 
   octave_complex (const octave_complex& c)
     : octave_base_scalar<Complex> (c) { }
 
   ~octave_complex (void) = default;
 
-  octave_base_value *clone (void) const { return new octave_complex (*this); }
+  octave_base_value * clone (void) const { return new octave_complex (*this); }
 
   // We return an octave_complex_matrix object here instead of an
   // octave_complex object so that in expressions like A(2,2,2) = 2
   // (for A previously undefined), A will be empty instead of a 1x1
   // object.
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_complex_matrix (); }
 
   type_conv_info numeric_demotion_function (void) const;
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   // Use this to give a more specific error message.
   idx_vector index_vector (bool /* require_integers */ = false) const;
 
   octave_value any (int = 0) const
@@ -182,17 +182,17 @@ public:
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (array_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-cs-list.h b/libinterp/octave-value/ov-cs-list.h
--- a/libinterp/octave-value/ov-cs-list.h
+++ b/libinterp/octave-value/ov-cs-list.h
@@ -53,18 +53,18 @@ public:
 
   octave_cs_list (const Cell& c);
 
   octave_cs_list (const octave_cs_list& l)
     : octave_base_value (), lst (l.lst) { }
 
   ~octave_cs_list (void) = default;
 
-  octave_base_value *clone (void) const { return new octave_cs_list (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_cs_list (); }
+  octave_base_value * clone (void) const { return new octave_cs_list (*this); }
+  octave_base_value * empty_clone (void) const { return new octave_cs_list (); }
 
   dim_vector dims (void) const { return dim_vector (1, lst.length ()); }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_cs_list (void) const { return true; }
diff --git a/libinterp/octave-value/ov-cx-diag.h b/libinterp/octave-value/ov-cx-diag.h
--- a/libinterp/octave-value/ov-cx-diag.h
+++ b/libinterp/octave-value/ov-cx-diag.h
@@ -45,26 +45,26 @@ public:
   octave_complex_diag_matrix (const ComplexDiagMatrix& m)
     : octave_base_diag<ComplexDiagMatrix, ComplexMatrix> (m) { }
 
   octave_complex_diag_matrix (const octave_complex_diag_matrix& m)
     : octave_base_diag<ComplexDiagMatrix, ComplexMatrix> (m) { }
 
   ~octave_complex_diag_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_complex_diag_matrix (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_complex_diag_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   type_conv_info numeric_demotion_function (void) const;
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
 
   bool is_complex_matrix (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
diff --git a/libinterp/octave-value/ov-cx-mat.h b/libinterp/octave-value/ov-cx-mat.h
--- a/libinterp/octave-value/ov-cx-mat.h
+++ b/libinterp/octave-value/ov-cx-mat.h
@@ -76,24 +76,24 @@ public:
   octave_complex_matrix (const ComplexColumnVector& v)
     : octave_base_matrix<ComplexNDArray> (ComplexMatrix (v)) { }
 
   octave_complex_matrix (const octave_complex_matrix& cm)
     : octave_base_matrix<ComplexNDArray> (cm) { }
 
   ~octave_complex_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_complex_matrix (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_complex_matrix (); }
 
   type_conv_info numeric_demotion_function (void) const;
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
 
   bool is_complex_matrix (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
@@ -168,17 +168,17 @@ public:
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (matrix_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-cx-sparse.h b/libinterp/octave-value/ov-cx-sparse.h
--- a/libinterp/octave-value/ov-cx-sparse.h
+++ b/libinterp/octave-value/ov-cx-sparse.h
@@ -81,22 +81,22 @@ public:
   octave_sparse_complex_matrix (const Sparse<Complex>& m)
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m)) { }
 
   octave_sparse_complex_matrix (const octave_sparse_complex_matrix& cm)
     : octave_base_sparse<SparseComplexMatrix> (cm) { }
 
   ~octave_sparse_complex_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_sparse_complex_matrix (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_sparse_complex_matrix (); }
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
 
   bool is_complex_matrix (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
@@ -142,17 +142,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-fcn-handle.h b/libinterp/octave-value/ov-fcn-handle.h
--- a/libinterp/octave-value/ov-fcn-handle.h
+++ b/libinterp/octave-value/ov-fcn-handle.h
@@ -69,19 +69,19 @@ public:
     for (int i = 0; i < btyp_num_types; i++)
       builtin_overloads[i] = fh.builtin_overloads[i];
 
     overloads = fh.overloads;
   }
 
   ~octave_fcn_handle (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_fcn_handle (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_fcn_handle (); }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
   {
     octave_value_list tmp = subsref (type, idx, 1);
     return tmp.length () > 0 ? tmp(0) : octave_value ();
   }
@@ -107,23 +107,23 @@ public:
   bool is_function_handle (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return btyp_func_handle; }
 
   bool is_overloaded (void) const { return has_overloads; }
 
   dim_vector dims (void) const;
 
-  octave_function *function_value (bool = false)
+  octave_function * function_value (bool = false)
   { return fcn.function_value (); }
 
-  octave_user_function *user_function_value (bool = false)
+  octave_user_function * user_function_value (bool = false)
   { return fcn.user_function_value (); }
 
-  octave_fcn_handle *fcn_handle_value (bool = false) { return this; }
+  octave_fcn_handle * fcn_handle_value (bool = false) { return this; }
 
   octave_value fcn_val (void) const { return fcn; }
 
   std::string fcn_name (void) const { return nm; }
 
   void set_overload (builtin_type_t btyp, const octave_value& ov_fcn)
   {
     if (btyp != btyp_unknown)
@@ -200,18 +200,18 @@ private:
   // Private ctor.
   octave_fcn_binder (const octave_value& f, const octave_value& root,
                      const octave_value_list& templ,
                      const std::vector<int>& mask, int exp_nargin);
 
 public:
 
   // Factory method.
-  static octave_fcn_handle *maybe_binder (const octave_value& f,
-                                          octave::tree_evaluator *tw);
+  static octave_fcn_handle * maybe_binder (const octave_value& f,
+                                           octave::tree_evaluator *tw);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args,
                      const std::list<octave_lvalue>* lvalue_list);
 
diff --git a/libinterp/octave-value/ov-fcn-inline.h b/libinterp/octave-value/ov-fcn-inline.h
--- a/libinterp/octave-value/ov-fcn-inline.h
+++ b/libinterp/octave-value/ov-fcn-inline.h
@@ -49,24 +49,24 @@ public:
   octave_fcn_inline (const std::string& f, const string_vector& a,
                      const std::string& n = "");
 
   octave_fcn_inline (const octave_fcn_inline& fi)
     : octave_fcn_handle (fi), iftext (fi.iftext), ifargs (fi.ifargs) { }
 
   ~octave_fcn_inline (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_fcn_inline (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_fcn_inline (); }
 
   bool is_inline_function (void) const { return true; }
 
-  octave_fcn_inline *fcn_inline_value (bool = false) { return this; }
+  octave_fcn_inline * fcn_inline_value (bool = false) { return this; }
 
   std::string fcn_text (void) const { return iftext; }
 
   string_vector fcn_arg_names (void) const { return ifargs; }
 
   octave_value convert_to_str_internal (bool, bool, char) const;
 
   octave_map map_value (void) const;
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -56,18 +56,18 @@ public:
   // No copying!
 
   octave_function (const octave_function& f) = delete;
 
   octave_function& operator = (const octave_function& f) = delete;
 
   ~octave_function (void) = default;
 
-  octave_base_value *clone (void) const;
-  octave_base_value *empty_clone (void) const;
+  octave_base_value * clone (void) const;
+  octave_base_value * empty_clone (void) const;
 
   bool is_defined (void) const { return true; }
 
   bool is_function (void) const { return true; }
 
   virtual bool is_system_fcn_file (void) const { return false; }
 
   virtual std::string fcn_file_name (void) const { return ""; }
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -59,23 +59,23 @@ public:
   octave_float_scalar (float d)
     : octave_base_scalar<float> (d) { }
 
   octave_float_scalar (const octave_float_scalar& s)
     : octave_base_scalar<float> (s) { }
 
   ~octave_float_scalar (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_float_scalar (*this); }
 
   // We return an octave_matrix here instead of an octave_float_scalar so
   // that in expressions like A(2,2,2) = 2 (for A previously
   // undefined), A will be empty instead of a 1x1 object.
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_float_matrix (); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   idx_vector index_vector (bool /* require_integers */ = false) const { return idx_vector (scalar); }
 
   octave_value any (int = 0) const
@@ -253,17 +253,17 @@ public:
   int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     return os.write (array_value (), block_size, output_type,
                      skip, flt_fmt);
   }
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
   bool fast_elem_insert_self (void *where, builtin_type_t btyp) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -57,27 +57,27 @@ public:
   octave_float_complex (const FloatComplex& c)
     : octave_base_scalar<FloatComplex> (c) { }
 
   octave_float_complex (const octave_float_complex& c)
     : octave_base_scalar<FloatComplex> (c) { }
 
   ~octave_float_complex (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_float_complex (*this); }
 
   // We return an octave_float_complex_matrix object here instead of an
   // octave_float_complex object so that in expressions like A(2,2,2) = 2
   // (for A previously undefined), A will be empty instead of a 1x1
   // object.
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_float_complex_matrix (); }
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   octave_value any (int = 0) const
   {
     return (scalar != FloatComplex (0, 0)
             && ! (lo_ieee_isnan (scalar.real ())
@@ -178,17 +178,17 @@ public:
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (array_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-flt-cx-diag.h b/libinterp/octave-value/ov-flt-cx-diag.h
--- a/libinterp/octave-value/ov-flt-cx-diag.h
+++ b/libinterp/octave-value/ov-flt-cx-diag.h
@@ -45,24 +45,24 @@ public:
   octave_float_complex_diag_matrix (const FloatComplexDiagMatrix& m)
     : octave_base_diag<FloatComplexDiagMatrix, FloatComplexMatrix> (m) { }
 
   octave_float_complex_diag_matrix (const octave_float_complex_diag_matrix& m)
     : octave_base_diag<FloatComplexDiagMatrix, FloatComplexMatrix> (m) { }
 
   ~octave_float_complex_diag_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_float_complex_diag_matrix (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_float_complex_diag_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_float_complex; }
 
   bool is_complex_matrix (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
   bool is_single_type (void) const { return true; }
diff --git a/libinterp/octave-value/ov-flt-cx-mat.h b/libinterp/octave-value/ov-flt-cx-mat.h
--- a/libinterp/octave-value/ov-flt-cx-mat.h
+++ b/libinterp/octave-value/ov-flt-cx-mat.h
@@ -76,22 +76,22 @@ public:
   octave_float_complex_matrix (const FloatComplexColumnVector& v)
     : octave_base_matrix<FloatComplexNDArray> (FloatComplexMatrix (v)) { }
 
   octave_float_complex_matrix (const octave_float_complex_matrix& cm)
     : octave_base_matrix<FloatComplexNDArray> (cm) { }
 
   ~octave_float_complex_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_float_complex_matrix (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_float_complex_matrix (); }
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_float_complex; }
 
   bool is_complex_matrix (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
   bool is_single_type (void) const { return true; }
@@ -164,17 +164,17 @@ public:
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (matrix_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-flt-re-diag.h b/libinterp/octave-value/ov-flt-re-diag.h
--- a/libinterp/octave-value/ov-flt-re-diag.h
+++ b/libinterp/octave-value/ov-flt-re-diag.h
@@ -45,24 +45,24 @@ public:
   octave_float_diag_matrix (const FloatDiagMatrix& m)
     : octave_base_diag<FloatDiagMatrix, FloatMatrix> (m) { }
 
   octave_float_diag_matrix (const octave_float_diag_matrix& m)
     : octave_base_diag<FloatDiagMatrix, FloatMatrix> (m) { }
 
   ~octave_float_diag_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_float_diag_matrix (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_float_diag_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_float; }
 
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool is_single_type (void) const { return true; }
diff --git a/libinterp/octave-value/ov-flt-re-mat.h b/libinterp/octave-value/ov-flt-re-mat.h
--- a/libinterp/octave-value/ov-flt-re-mat.h
+++ b/libinterp/octave-value/ov-flt-re-mat.h
@@ -76,22 +76,22 @@ public:
   octave_float_matrix (const FloatColumnVector& v)
     : octave_base_matrix<FloatNDArray> (FloatMatrix (v)) { }
 
   octave_float_matrix (const octave_float_matrix& m)
     : octave_base_matrix<FloatNDArray> (m) { }
 
   ~octave_float_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_float_matrix (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_float_matrix (); }
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   idx_vector index_vector (bool /* require_integers */ = false) const
   {
     return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix));
   }
 
   builtin_type_t builtin_type (void) const { return btyp_float; }
 
@@ -208,19 +208,19 @@ public:
 
   int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
-  void *mex_get_data (void) const { return matrix.mex_get_data (); }
+  void * mex_get_data (void) const { return matrix.mex_get_data (); }
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-intx.h b/libinterp/octave-value/ov-intx.h
--- a/libinterp/octave-value/ov-intx.h
+++ b/libinterp/octave-value/ov-intx.h
@@ -61,20 +61,20 @@ public:
     : octave_base_int_matrix<intNDArray<OCTAVE_INT_T> > (nda) { }
 
   OCTAVE_VALUE_INT_MATRIX_T (const Array<OCTAVE_INT_T>& nda)
     : octave_base_int_matrix<intNDArray<OCTAVE_INT_T> >
         (intNDArray<OCTAVE_INT_T> (nda)) { }
 
   ~OCTAVE_VALUE_INT_MATRIX_T (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new OCTAVE_VALUE_INT_MATRIX_T (*this); }
 
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new OCTAVE_VALUE_INT_MATRIX_T (); }
 
   bool OCTAVE_TYPE_PREDICATE_FUNCTION (void) const { return true; }
 
   bool is_integer_type (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return OCTAVE_INT_BTYP; }
 
@@ -306,19 +306,19 @@ public:
 
   int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
-  void *mex_get_data (void) const { return matrix.mex_get_data (); }
+  void * mex_get_data (void) const { return matrix.mex_get_data (); }
 
-  mxArray *as_mxArray (void) const
+  mxArray * as_mxArray (void) const
   {
     mxArray *retval = new mxArray (OCTAVE_INT_MX_CLASS, dims (), mxREAL);
 
     OCTAVE_INT_T::val_type *pr = static_cast<OCTAVE_INT_T::val_type *>
                                  (retval->get_data ());
 
     mwSize nel = numel ();
 
@@ -384,20 +384,20 @@ public:
   OCTAVE_VALUE_INT_SCALAR_T (void)
     : octave_base_int_scalar<OCTAVE_INT_T> () { }
 
   OCTAVE_VALUE_INT_SCALAR_T (const OCTAVE_INT_T& nda)
     : octave_base_int_scalar<OCTAVE_INT_T> (nda) { }
 
   ~OCTAVE_VALUE_INT_SCALAR_T (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new OCTAVE_VALUE_INT_SCALAR_T (*this); }
 
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new OCTAVE_VALUE_INT_MATRIX_T (); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false)
   {
     // FIXME: this doesn't solve the problem of
     //
     //   a = 1; a([1,1], [1,1], [1,1])
@@ -616,19 +616,19 @@ public:
              octave::mach_info::float_format flt_fmt) const
   {
     return os.write (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION (),
                      block_size, output_type, skip, flt_fmt);
   }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
-  void *mex_get_data (void) const { return scalar.mex_get_data (); }
+  void * mex_get_data (void) const { return scalar.mex_get_data (); }
 
-  mxArray *as_mxArray (void) const
+  mxArray * as_mxArray (void) const
   {
     mxArray *retval = new mxArray (OCTAVE_INT_MX_CLASS, 1, 1, mxREAL);
 
     OCTAVE_INT_T::val_type *pr = static_cast<OCTAVE_INT_T::val_type *>
                                  (retval->get_data ());
 
     pr[0] = scalar.value ();
 
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -197,17 +197,17 @@ namespace octave
       vm_args.ignoreUnrecognized = false;
     }
 
     ~JVMArgs (void)
     {
       clean ();
     }
 
-    JavaVMInitArgs *to_args ()
+    JavaVMInitArgs * to_args ()
     {
       update ();
       return &vm_args;
     }
 
     void add (const std::string& opt)
     {
       java_opts.push_back (opt);
diff --git a/libinterp/octave-value/ov-java.h b/libinterp/octave-value/ov-java.h
--- a/libinterp/octave-value/ov-java.h
+++ b/libinterp/octave-value/ov-java.h
@@ -41,18 +41,18 @@ public:
   octave_java (const octave_java& jobj)
     : octave_base_value (jobj), java_object (0), java_class (0)
   {
     init (jobj.java_object, jobj.java_class);
   }
 
   ~octave_java (void) { release (); }
 
-  void *to_java (void) const { return java_object; }
-  void *to_class (void) const { return java_class; }
+  void * to_java (void) const { return java_object; }
+  void * to_class (void) const { return java_class; }
 
   std::string java_class_name (void) const { return java_classname; }
 
   octave_base_value* clone (void) const { return new octave_java (*this); }
   octave_base_value* empty_clone (void) const { return new octave_java (); }
 
   bool is_instance_of (const std::string&) const;
 
diff --git a/libinterp/octave-value/ov-lazy-idx.h b/libinterp/octave-value/ov-lazy-idx.h
--- a/libinterp/octave-value/ov-lazy-idx.h
+++ b/libinterp/octave-value/ov-lazy-idx.h
@@ -42,23 +42,23 @@ public:
   octave_lazy_index (const idx_vector& idx)
     : octave_base_value (), index (idx), value () { }
 
   octave_lazy_index (const octave_lazy_index& i)
     : octave_base_value (), index (i.index), value (i.value) { }
 
   ~octave_lazy_index (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_lazy_index (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_matrix (); }
+  octave_base_value * empty_clone (void) const { return new octave_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   octave_value fast_elem_extract (octave_idx_type n) const;
 
   size_t byte_size (void) const { return numel () * sizeof (octave_idx_type); }
 
   octave_value squeeze (void) const;
 
   octave_value full_value (void) const { return make_value (); }
@@ -205,22 +205,22 @@ public:
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     return make_value ().write (os, block_size, output_type, skip, flt_fmt);
   }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
-  void *mex_get_data (void) const
+  void * mex_get_data (void) const
   {
     return make_value ().mex_get_data ();
   }
 
-  mxArray *as_mxArray (void) const
+  mxArray * as_mxArray (void) const
   {
     return make_value ().as_mxArray ();
   }
 
   octave_value map (unary_mapper_t umap) const
   {
     return make_value ().map (umap);
   }
diff --git a/libinterp/octave-value/ov-mex-fcn.h b/libinterp/octave-value/ov-mex-fcn.h
--- a/libinterp/octave-value/ov-mex-fcn.h
+++ b/libinterp/octave-value/ov-mex-fcn.h
@@ -64,19 +64,19 @@ public:
     octave_value_list tmp = subsref (type, idx, 1);
     return tmp.length () > 0 ? tmp(0) : octave_value ();
   }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
-  octave_function *function_value (bool = false) { return this; }
+  octave_function * function_value (bool = false) { return this; }
 
-  const octave_function *function_value (bool = false) const { return this; }
+  const octave_function * function_value (bool = false) const { return this; }
 
   void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
   std::string fcn_file_name (void) const;
 
   octave::sys::time time_parsed (void) const;
 
   octave::sys::time time_checked (void) const { return t_checked; }
diff --git a/libinterp/octave-value/ov-oncleanup.h b/libinterp/octave-value/ov-oncleanup.h
--- a/libinterp/octave-value/ov-oncleanup.h
+++ b/libinterp/octave-value/ov-oncleanup.h
@@ -34,25 +34,25 @@ along with Octave; see the file COPYING.
 
 class octave_oncleanup : public octave_base_value
 {
 public:
   octave_oncleanup (void) : fcn () { }
 
   octave_oncleanup (const octave_value& fcn);
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   {
     if (fcn.is_defined ())
       error ("onCleanup: internal error: cloning nonempty object");
 
     return empty_clone ();
   }
 
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   {
     return new octave_oncleanup ();
   }
 
   ~octave_oncleanup (void);
 
   bool is_defined (void) const { return true; }
 
diff --git a/libinterp/octave-value/ov-perm.h b/libinterp/octave-value/ov-perm.h
--- a/libinterp/octave-value/ov-perm.h
+++ b/libinterp/octave-value/ov-perm.h
@@ -36,24 +36,24 @@ class
 OCTINTERP_API
 octave_perm_matrix : public octave_base_value
 {
 public:
   octave_perm_matrix (void) : matrix (), dense_cache () { }
 
   octave_perm_matrix (const PermMatrix& p) : matrix (p), dense_cache () { }
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_perm_matrix (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_perm_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
   octave_value squeeze (void) const { return matrix; }
 
   octave_value full_value (void) const { return to_dense (); }
 
   octave_value subsref (const std::string& type,
@@ -217,17 +217,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const;
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
   octave_value map (unary_mapper_t umap) const
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -77,26 +77,26 @@ public:
   octave_range (const Range& r, const idx_vector& cache)
     : octave_base_value (), range (r), idx_cache ()
   {
     set_idx_cache (cache);
   }
 
   ~octave_range (void) { clear_cached_info (); }
 
-  octave_base_value *clone (void) const { return new octave_range (*this); }
+  octave_base_value * clone (void) const { return new octave_range (*this); }
 
   // A range is really just a special kind of real matrix object.  In
   // the places where we need to call empty_clone, it makes more sense
   // to create an empty matrix (0x0) instead of an empty range (1x0).
-  octave_base_value *empty_clone (void) const { return new octave_matrix (); }
+  octave_base_value * empty_clone (void) const { return new octave_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx, int)
   { return subsref (type, idx); }
 
@@ -286,17 +286,17 @@ public:
              octave::mach_info::float_format flt_fmt) const
   {
     // FIXME: could be more memory efficient by having a
     // special case of the octave::stream::write method for ranges.
 
     return os.write (matrix_value (), block_size, output_type, skip, flt_fmt);
   }
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const
   {
     octave_matrix m (matrix_value ());
     return m.map (umap);
   }
 
   octave_value fast_elem_extract (octave_idx_type n) const;
diff --git a/libinterp/octave-value/ov-re-diag.h b/libinterp/octave-value/ov-re-diag.h
--- a/libinterp/octave-value/ov-re-diag.h
+++ b/libinterp/octave-value/ov-re-diag.h
@@ -45,26 +45,26 @@ public:
   octave_diag_matrix (const DiagMatrix& m)
     : octave_base_diag<DiagMatrix, Matrix> (m) { }
 
   octave_diag_matrix (const octave_diag_matrix& m)
     : octave_base_diag<DiagMatrix, Matrix> (m) { }
 
   ~octave_diag_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_diag_matrix (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_diag_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   type_conv_info numeric_demotion_function (void) const;
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_matrix (void) const { return true; }
 
diff --git a/libinterp/octave-value/ov-re-mat.h b/libinterp/octave-value/ov-re-mat.h
--- a/libinterp/octave-value/ov-re-mat.h
+++ b/libinterp/octave-value/ov-re-mat.h
@@ -91,22 +91,22 @@ public:
   octave_matrix (const NDArray& nda, const idx_vector& cache)
     : octave_base_matrix<NDArray> (nda)
   {
     set_idx_cache (cache);
   }
 
   ~octave_matrix (void) = default;
 
-  octave_base_value *clone (void) const { return new octave_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_matrix (); }
+  octave_base_value * clone (void) const { return new octave_matrix (*this); }
+  octave_base_value * empty_clone (void) const { return new octave_matrix (); }
 
   type_conv_info numeric_demotion_function (void) const;
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   idx_vector index_vector (bool /* require_integers */ = false) const
   { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_matrix (void) const { return true; }
 
@@ -232,19 +232,19 @@ public:
 
   int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
-  void *mex_get_data (void) const { return matrix.mex_get_data (); }
+  void * mex_get_data (void) const { return matrix.mex_get_data (); }
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-re-sparse.h b/libinterp/octave-value/ov-re-sparse.h
--- a/libinterp/octave-value/ov-re-sparse.h
+++ b/libinterp/octave-value/ov-re-sparse.h
@@ -79,22 +79,22 @@ public:
   octave_sparse_matrix (const Sparse<double>& m, const MatrixType& t)
     : octave_base_sparse<SparseMatrix> (SparseMatrix (m), t) { }
 
   octave_sparse_matrix (const octave_sparse_matrix& m)
     : octave_base_sparse<SparseMatrix> (m) { }
 
   ~octave_sparse_matrix (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_sparse_matrix (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_sparse_matrix (); }
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   idx_vector index_vector (bool require_integers = false) const;
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
@@ -145,17 +145,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
   octave_value map (double (*fcn) (double)) const;
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -58,22 +58,22 @@ public:
   octave_scalar (double d)
     : octave_base_scalar<double> (d) { }
 
   octave_scalar (const octave_scalar& s)
     : octave_base_scalar<double> (s) { }
 
   ~octave_scalar (void) = default;
 
-  octave_base_value *clone (void) const { return new octave_scalar (*this); }
+  octave_base_value * clone (void) const { return new octave_scalar (*this); }
 
   // We return an octave_matrix here instead of an octave_scalar so
   // that in expressions like A(2,2,2) = 2 (for A previously
   // undefined), A will be empty instead of a 1x1 object.
-  octave_base_value *empty_clone (void) const { return new octave_matrix (); }
+  octave_base_value * empty_clone (void) const { return new octave_matrix (); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   type_conv_info numeric_demotion_function (void) const;
 
   idx_vector index_vector (bool /* require_integers */ = false) const { return idx_vector (scalar); }
 
@@ -256,17 +256,17 @@ public:
   int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     return os.write (array_value (), block_size, output_type,
                      skip, flt_fmt);
   }
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
   bool fast_elem_insert_self (void *where, builtin_type_t btyp) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
diff --git a/libinterp/octave-value/ov-str-mat.h b/libinterp/octave-value/ov-str-mat.h
--- a/libinterp/octave-value/ov-str-mat.h
+++ b/libinterp/octave-value/ov-str-mat.h
@@ -79,19 +79,19 @@ public:
   octave_char_matrix_str (const octave_char_matrix& chm)
     : octave_char_matrix (chm) { }
 
   octave_char_matrix_str (const octave_char_matrix_str& chms)
     : octave_char_matrix (chms) { }
 
   ~octave_char_matrix_str (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_char_matrix_str (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_char_matrix_str (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false)
   { return do_index_op_internal (idx, resize_ok); }
 
@@ -208,19 +208,19 @@ public:
   octave_char_matrix_sq_str (const octave_char_matrix_str& chm)
     : octave_char_matrix_str (chm) { }
 
   octave_char_matrix_sq_str (const octave_char_matrix_sq_str& chms)
     : octave_char_matrix_str (chms) { }
 
   ~octave_char_matrix_sq_str (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_char_matrix_sq_str (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_char_matrix_sq_str (); }
 
   octave_value squeeze (void) const
   { return octave_value (charNDArray (matrix.squeeze ()), '\''); }
 
   octave_value reshape (const dim_vector& new_dims) const
   { return octave_value (charNDArray (matrix.reshape (new_dims)), '\''); }
 
diff --git a/libinterp/octave-value/ov-struct.h b/libinterp/octave-value/ov-struct.h
--- a/libinterp/octave-value/ov-struct.h
+++ b/libinterp/octave-value/ov-struct.h
@@ -53,20 +53,20 @@ public:
   octave_struct (const octave_map& m)
     : octave_base_value (), map (m) { }
 
   octave_struct (const octave_struct& s)
     : octave_base_value (), map (s.map) { }
 
   ~octave_struct (void) = default;
 
-  octave_base_value *clone (void) const { return new octave_struct (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_struct (); }
+  octave_base_value * clone (void) const { return new octave_struct (*this); }
+  octave_base_value * empty_clone (void) const { return new octave_struct (); }
 
-  octave_base_value *try_narrowing_conversion (void);
+  octave_base_value * try_narrowing_conversion (void);
 
   Cell dotref (const octave_value_list& idx, bool auto_add = false);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
   {
     octave_value_list tmp = subsref (type, idx, 1);
     return tmp.length () > 0 ? tmp(0) : octave_value ();
@@ -139,17 +139,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   octave_value
   fast_elem_extract (octave_idx_type n) const;
 
   bool
   fast_elem_insert (octave_idx_type n, const octave_value& x);
 
 protected:
@@ -173,19 +173,19 @@ public:
   octave_scalar_struct (const octave_scalar_map& m)
     : octave_base_value (), map (m) { }
 
   octave_scalar_struct (const octave_scalar_struct& s)
     : octave_base_value (), map (s.map) { }
 
   ~octave_scalar_struct (void) = default;
 
-  octave_base_value *clone (void) const
+  octave_base_value * clone (void) const
   { return new octave_scalar_struct (*this); }
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return new octave_scalar_struct (); }
 
   octave_value dotref (const octave_value_list& idx, bool auto_add = false);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
@@ -257,17 +257,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  mxArray *as_mxArray (void) const;
+  mxArray * as_mxArray (void) const;
 
   bool fast_elem_insert_self (void *where, builtin_type_t btyp) const;
 
 protected:
 
   // The associative array used to manage the structure data.
   octave_scalar_map map;
 
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -74,17 +74,17 @@ public:
   octave_user_code& operator = (const octave_user_code& f) = delete;
 
   ~octave_user_code (void) = default;
 
   bool is_user_code (void) const { return true; }
 
   virtual std::map<std::string, octave_value> subfunctions (void) const;
 
-  virtual octave::tree_statement_list *body (void) = 0;
+  virtual octave::tree_statement_list * body (void) = 0;
 };
 
 // Scripts.
 
 class
 octave_user_script : public octave_user_code
 {
 public:
@@ -101,21 +101,21 @@ public:
   // No copying!
 
   octave_user_script (const octave_user_script& f) = delete;
 
   octave_user_script& operator = (const octave_user_script& f) = delete;
 
   ~octave_user_script (void);
 
-  octave_function *function_value (bool = false) { return this; }
+  octave_function * function_value (bool = false) { return this; }
 
-  octave_user_script *user_script_value (bool = false) { return this; }
+  octave_user_script * user_script_value (bool = false) { return this; }
 
-  octave_user_code *user_code_value (bool = false) { return this; }
+  octave_user_code * user_code_value (bool = false) { return this; }
 
   // Scripts and user functions are both considered "scripts" because
   // they are written in Octave's scripting language.
 
   bool is_user_script (void) const { return true; }
 
   void stash_fcn_file_name (const std::string& nm) { file_name = nm; }
 
@@ -142,17 +142,17 @@ public:
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
-  octave::tree_statement_list *body (void) { return cmd_list; }
+  octave::tree_statement_list * body (void) { return cmd_list; }
 
   void accept (octave::tree_walker& tw);
 
 private:
 
   // The list of commands that make up the body of this function.
   octave::tree_statement_list *cmd_list;
 
@@ -193,25 +193,25 @@ public:
   ~octave_user_function (void);
 
   symbol_table::context_id active_context () const
   {
     return is_anonymous_function ()
            ? 0 : static_cast<symbol_table::context_id>(call_depth);
   }
 
-  octave_function *function_value (bool = false) { return this; }
+  octave_function * function_value (bool = false) { return this; }
 
-  octave_user_function *user_function_value (bool = false) { return this; }
+  octave_user_function * user_function_value (bool = false) { return this; }
 
-  octave_user_code *user_code_value (bool = false) { return this; }
+  octave_user_code * user_code_value (bool = false) { return this; }
 
-  octave_user_function *define_param_list (octave::tree_parameter_list *t);
+  octave_user_function * define_param_list (octave::tree_parameter_list *t);
 
-  octave_user_function *define_ret_list (octave::tree_parameter_list *t);
+  octave_user_function * define_ret_list (octave::tree_parameter_list *t);
 
   void stash_fcn_file_name (const std::string& nm);
 
   void stash_fcn_location (int line, int col)
   {
     location_line = line;
     location_column = col;
   }
@@ -377,29 +377,29 @@ public:
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args,
                      const std::list<octave_lvalue>* lvalue_list);
 
-  octave::tree_parameter_list *parameter_list (void) { return param_list; }
+  octave::tree_parameter_list * parameter_list (void) { return param_list; }
 
-  octave::tree_parameter_list *return_list (void) { return ret_list; }
+  octave::tree_parameter_list * return_list (void) { return ret_list; }
 
-  octave::tree_statement_list *body (void) { return cmd_list; }
+  octave::tree_statement_list * body (void) { return cmd_list; }
 
-  octave_comment_list *leading_comment (void) { return lead_comm; }
+  octave_comment_list * leading_comment (void) { return lead_comm; }
 
-  octave_comment_list *trailing_comment (void) { return trail_comm; }
+  octave_comment_list * trailing_comment (void) { return trail_comm; }
 
   // If is_special_expr is true, retrieve the sigular expression that forms the
   // body.  May be null (even if is_special_expr is true).
-  octave::tree_expression *special_expr (void);
+  octave::tree_expression * special_expr (void);
 
   bool subsasgn_optimization_ok (void);
 
   void accept (octave::tree_walker& tw);
 
   template <typename T>
   bool local_protect (T& variable)
   {
@@ -408,17 +408,17 @@ public:
         curr_unwind_protect_frame->protect_var (variable);
         return true;
       }
     else
       return false;
   }
 
 #if defined (HAVE_LLVM)
-  jit_function_info *get_info (void) { return jit_info; }
+  jit_function_info * get_info (void) { return jit_info; }
 
   void stash_info (jit_function_info *info) { jit_info = info; }
 #endif
 
 #if 0
   void print_symtab_info (std::ostream& os) const;
 #endif
 
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -310,19 +310,19 @@ public:
   octave_value (const octave_value& a)
   {
     rep = a.rep;
     rep->count++;
   }
 
   // This should only be called for derived types.
 
-  octave_base_value *clone (void) const;
+  octave_base_value * clone (void) const;
 
-  octave_base_value *empty_clone (void) const
+  octave_base_value * empty_clone (void) const
   { return rep->empty_clone (); }
 
   // Delete the representation of this constant if the count drops to zero.
 
   ~octave_value (void)
   {
     if (--rep->count == 0)
       delete rep;
@@ -400,17 +400,17 @@ public:
   octave_value as_int32 (void) const { return rep->as_int32 (); }
   octave_value as_int64 (void) const { return rep->as_int64 (); }
 
   octave_value as_uint8 (void) const { return rep->as_uint8 (); }
   octave_value as_uint16 (void) const { return rep->as_uint16 (); }
   octave_value as_uint32 (void) const { return rep->as_uint32 (); }
   octave_value as_uint64 (void) const { return rep->as_uint64 (); }
 
-  octave_base_value *try_narrowing_conversion (void)
+  octave_base_value * try_narrowing_conversion (void)
   { return rep->try_narrowing_conversion (); }
 
   // Close to dims (), but can be overloaded for classes.
   Matrix size (void)
   { return rep->size (); }
 
   octave_idx_type numel (const octave_value_list& idx)
   { return rep->numel (idx); }
@@ -945,27 +945,27 @@ public:
 
   octave_base_value *
   find_parent_class (const std::string& parent_class_name)
   { return rep->find_parent_class (parent_class_name); }
 
   bool is_instance_of (const std::string& cls_name) const
   { return rep->is_instance_of (cls_name); }
 
-  octave_function *function_value (bool silent = false) const;
+  octave_function * function_value (bool silent = false) const;
 
-  octave_user_function *user_function_value (bool silent = false) const;
+  octave_user_function * user_function_value (bool silent = false) const;
 
-  octave_user_script *user_script_value (bool silent = false) const;
+  octave_user_script * user_script_value (bool silent = false) const;
 
-  octave_user_code *user_code_value (bool silent = false) const;
+  octave_user_code * user_code_value (bool silent = false) const;
 
-  octave_fcn_handle *fcn_handle_value (bool silent = false) const;
+  octave_fcn_handle * fcn_handle_value (bool silent = false) const;
 
-  octave_fcn_inline *fcn_inline_value (bool silent = false) const;
+  octave_fcn_inline * fcn_inline_value (bool silent = false) const;
 
   octave_value_list list_value (void) const;
 
   ColumnVector column_vector_value (bool frc_str_conv = false,
                                     bool frc_vec_conv = false) const;
 
   ComplexColumnVector
   complex_column_vector_value (bool frc_str_conv = false,
@@ -1169,22 +1169,22 @@ public:
   Array<double> xvector_value (const char *fmt, ...) const;
 
   Array<Complex> xcomplex_vector_value (const char *fmt, ...) const;
 
   Array<float> xfloat_vector_value (const char *fmt, ...) const;
 
   Array<FloatComplex> xfloat_complex_vector_value (const char *fmt, ...) const;
 
-  octave_function *xfunction_value (const char *fmt, ...) const;
-  octave_user_function *xuser_function_value (const char *fmt, ...) const;
-  octave_user_script *xuser_script_value (const char *fmt, ...) const;
-  octave_user_code *xuser_code_value (const char *fmt, ...) const;
-  octave_fcn_handle *xfcn_handle_value (const char *fmt, ...) const;
-  octave_fcn_inline *xfcn_inline_value (const char *fmt, ...) const;
+  octave_function * xfunction_value (const char *fmt, ...) const;
+  octave_user_function * xuser_function_value (const char *fmt, ...) const;
+  octave_user_script * xuser_script_value (const char *fmt, ...) const;
+  octave_user_code * xuser_code_value (const char *fmt, ...) const;
+  octave_fcn_handle * xfcn_handle_value (const char *fmt, ...) const;
+  octave_fcn_inline * xfcn_inline_value (const char *fmt, ...) const;
 
   octave_value_list xlist_value (const char *fmt, ...) const;
 
   // Possibly economize a lazy-indexed value.
 
   void maybe_economize (void)
   { rep->maybe_economize (); }
 
@@ -1295,27 +1295,27 @@ public:
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name)
   { return rep->load_hdf5 (loc_id, name); }
 
   int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const;
 
-  octave_base_value *internal_rep (void) const { return rep; }
+  octave_base_value * internal_rep (void) const { return rep; }
 
   // Unsafe.  These functions exist to support the MEX interface.
   // You should not use them anywhere else.
-  void *mex_get_data (void) const { return rep->mex_get_data (); }
+  void * mex_get_data (void) const { return rep->mex_get_data (); }
 
-  octave_idx_type *mex_get_ir (void) const { return rep->mex_get_ir (); }
+  octave_idx_type * mex_get_ir (void) const { return rep->mex_get_ir (); }
 
-  octave_idx_type *mex_get_jc (void) const { return rep->mex_get_jc (); }
+  octave_idx_type * mex_get_jc (void) const { return rep->mex_get_jc (); }
 
-  mxArray *as_mxArray (void) const { return rep->as_mxArray (); }
+  mxArray * as_mxArray (void) const { return rep->as_mxArray (); }
 
   octave_value diag (octave_idx_type k = 0) const
   { return rep->diag (k); }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const
   { return rep->diag (m, n); }
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
diff --git a/libinterp/octave.h b/libinterp/octave.h
--- a/libinterp/octave.h
+++ b/libinterp/octave.h
@@ -226,17 +226,17 @@ namespace octave
     void program_invocation_name (const std::string& nm) { m_program_invocation_name = nm; }
 
     void program_name (const std::string& nm) { m_program_name = nm; }
 
     void forced_interactive (bool arg) { m_options.forced_interactive (arg); }
 
     void interactive (bool arg);
 
-    static application *app (void) { return instance; }
+    static application * app (void) { return instance; }
 
     static std::string program_invocation_name (void)
     {
       return instance ? instance->m_program_invocation_name : "";
     }
 
     static std::string program_name (void)
     {
@@ -248,17 +248,17 @@ namespace octave
       return instance ? instance->m_argv : string_vector ();
     }
 
     static bool is_gui_running (void)
     {
       return instance ? instance->gui_running () : false;
     }
 
-    static interpreter *the_interpreter (void)
+    static interpreter * the_interpreter (void)
     {
       return instance ? instance->m_interpreter : 0;
     }
 
     // Convenience functions.
 
     static bool forced_interactive (void);
     static bool interactive (void);
diff --git a/libinterp/parse-tree/bp-table.h b/libinterp/parse-tree/bp-table.h
--- a/libinterp/parse-tree/bp-table.h
+++ b/libinterp/parse-tree/bp-table.h
@@ -195,11 +195,11 @@ private:
 
   fname_bp_map do_get_breakpoint_list (const octave_value_list& fname_list);
 
   bool do_have_breakpoints (void) { return (! bp_set.empty ()); }
 };
 
 extern std::string get_file_line (const std::string& fname, size_t line);
 
-extern octave_user_code *get_user_code (const std::string& fname = "");
+extern octave_user_code * get_user_code (const std::string& fname = "");
 
 #endif
diff --git a/libinterp/parse-tree/jit-ir.h b/libinterp/parse-tree/jit-ir.h
--- a/libinterp/parse-tree/jit-ir.h
+++ b/libinterp/parse-tree/jit-ir.h
@@ -105,28 +105,28 @@ jit_factory
 
 public:
 
   ~jit_factory (void);
 
   const value_list& constants (void) const { return mconstants; }
 
   template <typename T>
-  T *create (void)
+  T * create (void)
   {
     T *ret = new T ();
     track_value (ret);
     return ret;
   }
 
 #define DECL_ARG(n) const ARG ## n& arg ## n
 
 #define JIT_CREATE(N)                                           \
   template <typename T, OCT_MAKE_DECL_LIST (typename, ARG, N)>  \
-  T *create (OCT_MAKE_LIST (DECL_ARG, N))                       \
+  T * create (OCT_MAKE_LIST (DECL_ARG, N))                      \
   {                                                             \
     T *ret = new T (OCT_MAKE_ARG_LIST (arg, N));                \
     track_value (ret);                                          \
     return ret;                                                 \
   }
 
   JIT_CREATE (1)
   JIT_CREATE (2)
@@ -151,29 +151,29 @@ private:
 // blocks stashed location in push_back and insert.
 class
 jit_block_list
 {
 public:
   typedef std::list<jit_block *>::iterator iterator;
   typedef std::list<jit_block *>::const_iterator const_iterator;
 
-  jit_block *back (void) const { return mlist.back (); }
+  jit_block * back (void) const { return mlist.back (); }
 
   iterator begin (void) { return mlist.begin (); }
 
   const_iterator begin (void) const { return mlist.begin (); }
 
   iterator end (void)  { return mlist.end (); }
 
   const_iterator end (void) const  { return mlist.end (); }
 
   iterator erase (iterator iter) { return mlist.erase (iter); }
 
-  jit_block *front (void) const { return mlist.front (); }
+  jit_block * front (void) const { return mlist.front (); }
 
   void insert_after (iterator iter, jit_block *ablock);
 
   void insert_after (jit_block *loc, jit_block *ablock);
 
   void insert_before (iterator iter, jit_block *ablock);
 
   void insert_before (jit_block *loc, jit_block *ablock);
@@ -207,24 +207,24 @@ public:
 
   void stash_in_worklist (bool ain_worklist)
   {
     min_worklist = ain_worklist;
   }
 
   // The block of the first use which is not a jit_error_check
   // So this is not necessarily first_use ()->parent ().
-  jit_block *first_use_block (void);
+  jit_block * first_use_block (void);
 
   // replace all uses with
   virtual void replace_with (jit_value *value);
 
-  jit_type *type (void) const { return ty; }
+  jit_type * type (void) const { return ty; }
 
-  llvm::Type *type_llvm (void) const
+  llvm::Type * type_llvm (void) const
   {
     return ty ? ty->to_llvm () : 0;
   }
 
   const std::string& type_name (void) const
   {
     return ty->name ();
   }
@@ -233,17 +233,17 @@ public:
 
   std::string print_string (void)
   {
     std::stringstream ss;
     print (ss);
     return ss.str ();
   }
 
-  jit_instruction *last_use (void) const { return mlast_use; }
+  jit_instruction * last_use (void) const { return mlast_use; }
 
   void stash_last_use (jit_instruction *alast_use)
   {
     mlast_use = alast_use;
   }
 
   virtual bool needs_release (void) const { return false; }
 
@@ -254,17 +254,17 @@ public:
 
   virtual void accept (jit_ir_walker& walker) = 0;
 
   bool has_llvm (void) const
   {
     return llvm_value;
   }
 
-  llvm::Value *to_llvm (void) const
+  llvm::Value * to_llvm (void) const
   {
     assert (llvm_value);
     return llvm_value;
   }
 
   void stash_llvm (llvm::Value *compiled)
   {
     llvm_value = compiled;
@@ -307,19 +307,19 @@ public:
   jit_use& operator= (const jit_use& use)
   {
     stash_value (use.value (), use.user (), use.index ());
     return *this;
   }
 
   size_t index (void) const { return mindex; }
 
-  jit_instruction *user (void) const { return muser; }
+  jit_instruction * user (void) const { return muser; }
 
-  jit_block *user_parent (void) const;
+  jit_block * user_parent (void) const;
 
   std::list<jit_block *> user_parent_location (void) const;
 
   void stash_value (jit_value *avalue, jit_instruction *auser = 0,
                     size_t aindex = -1)
   {
     PARENT_T::stash_value (avalue);
     mindex = aindex;
@@ -369,33 +369,33 @@ public:
       stash_argument (i, aarguments[i]);
   }
 
   static void reset_ids (void)
   {
     next_id (true);
   }
 
-  jit_value *argument (size_t i) const
+  jit_value * argument (size_t i) const
   {
     return marguments[i].value ();
   }
 
-  llvm::Value *argument_llvm (size_t i) const
+  llvm::Value * argument_llvm (size_t i) const
   {
     assert (argument (i));
     return argument (i)->to_llvm ();
   }
 
-  jit_type *argument_type (size_t i) const
+  jit_type * argument_type (size_t i) const
   {
     return argument (i)->type ();
   }
 
-  llvm::Type *argument_type_llvm (size_t i) const
+  llvm::Type * argument_type_llvm (size_t i) const
   {
     assert (argument (i));
     return argument_type (i)->to_llvm ();
   }
 
   std::ostream& print_argument (std::ostream& os, size_t i) const
   {
     if (argument (i))
@@ -448,24 +448,24 @@ public:
   }
 
   virtual bool infer (void) { return false; }
 
   void remove (void);
 
   virtual std::ostream& short_print (std::ostream& os) const;
 
-  jit_block *parent (void) const { return mparent; }
+  jit_block * parent (void) const { return mparent; }
 
   std::list<jit_instruction *>::iterator location (void) const
   {
     return mlocation;
   }
 
-  llvm::BasicBlock *parent_llvm (void) const;
+  llvm::BasicBlock * parent_llvm (void) const;
 
   void stash_parent (jit_block *aparent,
                      std::list<jit_instruction *>::iterator alocation)
   {
     mparent = aparent;
     mlocation = alocation;
   }
 
@@ -570,72 +570,72 @@ public:
       malive (false)
   { }
 
   virtual void replace_with (jit_value *value);
 
   void replace_in_phi (jit_block *ablock, jit_block *with);
 
   // we have a new internal list, but we want to stay compatible with jit_value
-  jit_use *first_use (void) const { return jit_value::first_use (); }
+  jit_use * first_use (void) const { return jit_value::first_use (); }
 
   size_t use_count (void) const { return jit_value::use_count (); }
 
   // if a block is alive, then it might be visited during execution
   bool alive (void) const { return malive; }
 
   void mark_alive (void) { malive = true; }
 
   // If we can merge with a successor, do so and return the now empty block
-  jit_block *maybe_merge ();
+  jit_block * maybe_merge ();
 
   // merge another block into this block, leaving the merge block empty
   void merge (jit_block& merge);
 
   const std::string& name (void) const { return mname; }
 
-  jit_instruction *prepend (jit_instruction *instr);
+  jit_instruction * prepend (jit_instruction *instr);
 
-  jit_instruction *prepend_after_phi (jit_instruction *instr);
+  jit_instruction * prepend_after_phi (jit_instruction *instr);
 
   template <typename T>
-  T *append (T *instr)
+  T * append (T *instr)
   {
     internal_append (instr);
     return instr;
   }
 
-  jit_instruction *insert_before (iterator loc, jit_instruction *instr);
+  jit_instruction * insert_before (iterator loc, jit_instruction *instr);
 
-  jit_instruction *insert_before (jit_instruction *loc, jit_instruction *instr)
+  jit_instruction * insert_before (jit_instruction *loc, jit_instruction *instr)
   {
     return insert_before (loc->location (), instr);
   }
 
-  jit_instruction *insert_after (iterator loc, jit_instruction *instr);
+  jit_instruction * insert_after (iterator loc, jit_instruction *instr);
 
-  jit_instruction *insert_after (jit_instruction *loc, jit_instruction *instr)
+  jit_instruction * insert_after (jit_instruction *loc, jit_instruction *instr)
   {
     return insert_after (loc->location (), instr);
   }
 
   iterator remove (iterator iter)
   {
     jit_instruction *instr = *iter;
     iter = instructions.erase (iter);
     instr->stash_parent (0, instructions.end ());
     return iter;
   }
 
-  jit_terminator *terminator (void) const;
+  jit_terminator * terminator (void) const;
 
   // is the jump from pred alive?
   bool branch_alive (jit_block *asucc) const;
 
-  jit_block *successor (size_t i) const;
+  jit_block * successor (size_t i) const;
 
   size_t successor_count (void) const;
 
   iterator begin (void) { return instructions.begin (); }
 
   const_iterator begin (void) const { return instructions.begin (); }
 
   iterator end (void) { return instructions.end (); }
@@ -685,36 +685,36 @@ public:
     compute_df (mvisit_count);
   }
 
   void create_dom_tree (void)
   {
     create_dom_tree (mvisit_count);
   }
 
-  jit_block *dom_successor (size_t idx) const
+  jit_block * dom_successor (size_t idx) const
   {
     return dom_succ[idx];
   }
 
   size_t dom_successor_count (void) const
   {
     return dom_succ.size ();
   }
 
   // call pop_varaible on all instructions
   void pop_all (void);
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const;
 
-  jit_block *maybe_split (jit_factory& factory, jit_block_list& blocks,
-                          jit_block *asuccessor);
+  jit_block * maybe_split (jit_factory& factory, jit_block_list& blocks,
+                           jit_block *asuccessor);
 
-  jit_block *maybe_split (jit_factory& factory, jit_block_list& blocks,
-                          jit_block& asuccessor)
+  jit_block * maybe_split (jit_factory& factory, jit_block_list& blocks,
+                           jit_block& asuccessor)
   {
     return maybe_split (factory, blocks, &asuccessor);
   }
 
   // print dominator infomration
   std::ostream& print_dom (std::ostream& os) const;
 
   virtual std::ostream& short_print (std::ostream& os) const
@@ -722,17 +722,17 @@ public:
     os << mname;
     if (mid != NO_ID)
       os << mid;
     else
       os << "!";
     return os;
   }
 
-  llvm::BasicBlock *to_llvm (void) const;
+  llvm::BasicBlock * to_llvm (void) const;
 
   std::list<jit_block *>::iterator location (void) const
   { return mlocation; }
 
   void stash_location (std::list<jit_block *>::iterator alocation)
   { mlocation = alocation; }
 
   // used to prevent visiting the same node twice in the graph
@@ -746,31 +746,31 @@ public:
       {
         mvisit_count = avisit_count + 1;
         return false;
       }
 
     return true;
   }
 
-  jit_instruction *front (void) { return instructions.front (); }
+  jit_instruction * front (void) { return instructions.front (); }
 
-  jit_instruction *back (void) { return instructions.back (); }
+  jit_instruction * back (void) { return instructions.back (); }
 
   JIT_VALUE_ACCEPT;
 private:
   void internal_append (jit_instruction *instr);
 
   void compute_df (size_t avisit_count);
 
   bool update_idom (size_t avisit_count);
 
   void create_dom_tree (size_t avisit_count);
 
-  static jit_block *idom_intersect (jit_block *i, jit_block *j);
+  static jit_block * idom_intersect (jit_block *i, jit_block *j);
 
   size_t mvisit_count;
   size_t mid;
   jit_block *idom;
   df_set mdf;
   std::vector<jit_block *> dom_succ;
   std::string mname;
   instruction_list instructions;
@@ -794,19 +794,19 @@ public:
 
   jit_phi_incomming& operator= (const jit_phi_incomming& use)
   {
     stash_value (use.value ());
     muser = use.muser;
     return *this;
   }
 
-  jit_phi *user (void) const { return muser; }
+  jit_phi * user (void) const { return muser; }
 
-  jit_block *user_parent (void) const;
+  jit_block * user_parent (void) const;
 private:
   jit_phi *muser;
 };
 
 // A non-ssa variable
 class
 jit_variable : public jit_value
 {
@@ -817,33 +817,33 @@ public:
 
   // manipulate the value_stack, for use during SSA construction.  The top of
   // the value stack represents the current value for this variable
   bool has_top (void) const
   {
     return ! value_stack.empty ();
   }
 
-  jit_value *top (void) const
+  jit_value * top (void) const
   {
     return value_stack.top ();
   }
 
   void push (jit_instruction *v)
   {
     value_stack.push (v);
     mlast_use = v;
   }
 
   void pop (void)
   {
     value_stack.pop ();
   }
 
-  jit_instruction *last_use (void) const
+  jit_instruction * last_use (void) const
   {
     return mlast_use;
   }
 
   void stash_last_use (jit_instruction *instr)
   {
     mlast_use = instr;
   }
@@ -878,17 +878,17 @@ public:
   jit_assign_base (jit_variable *adest) : jit_instruction (), mdest (adest) { }
 
   jit_assign_base (jit_variable *adest, size_t npred) : jit_instruction (npred),
                                                         mdest (adest) { }
 
   jit_assign_base (jit_variable *adest, jit_value *arg0, jit_value *arg1)
     : jit_instruction (arg0, arg1), mdest (adest) { }
 
-  jit_variable *dest (void) const { return mdest; }
+  jit_variable * dest (void) const { return mdest; }
 
   virtual void push_variable (void)
   {
     mdest->push (this);
   }
 
   virtual void pop_variable (void)
   {
@@ -909,22 +909,22 @@ private:
 
 class
 jit_assign : public jit_assign_base
 {
 public:
   jit_assign (jit_variable *adest, jit_value *asrc)
     : jit_assign_base (adest, adest, asrc), martificial (false) { }
 
-  jit_value *overwrite (void) const
+  jit_value * overwrite (void) const
   {
     return argument (0);
   }
 
-  jit_value *src (void) const
+  jit_value * src (void) const
   {
     return argument (1);
   }
 
   // variables don't get modified in an SSA, but COW requires we modify
   // variables.  An artificial assign is for when a variable gets modified.  We
   // need an assign in the SSA, but the reference counts shouldn't be updated.
   bool artificial (void) const { return martificial; }
@@ -973,22 +973,22 @@ public:
 
   void add_incomming (jit_block *from, jit_value *value)
   {
     push_argument (value);
     mincomming.push_back (jit_phi_incomming (this));
     mincomming[mincomming.size () - 1].stash_value (from);
   }
 
-  jit_block *incomming (size_t i) const
+  jit_block * incomming (size_t i) const
   {
     return mincomming[i].value ();
   }
 
-  llvm::BasicBlock *incomming_llvm (size_t i) const
+  llvm::BasicBlock * incomming_llvm (size_t i) const
   {
     return incomming (i)->to_llvm ();
   }
 
   virtual void construct_ssa (void) { }
 
   virtual bool infer (void);
 
@@ -1012,17 +1012,17 @@ public:
 
         if (i + 1 < argument_count ())
           os << std::endl;
       }
 
     return os;
   }
 
-  llvm::PHINode *to_llvm (void) const;
+  llvm::PHINode * to_llvm (void) const;
 
   JIT_VALUE_ACCEPT;
 private:
   std::vector<jit_phi_incomming> mincomming;
 };
 
 class
 jit_terminator : public jit_instruction
@@ -1036,22 +1036,22 @@ public:
       malive (asuccessor_count, false) { }
 
   JIT_TERMINATOR_CONST (1)
   JIT_TERMINATOR_CONST (2)
   JIT_TERMINATOR_CONST (3)
 
 #undef JIT_TERMINATOR_CONST
 
-  jit_block *successor (size_t idx = 0) const
+  jit_block * successor (size_t idx = 0) const
   {
     return static_cast<jit_block *> (argument (idx));
   }
 
-  llvm::BasicBlock *successor_llvm (size_t idx = 0) const
+  llvm::BasicBlock * successor_llvm (size_t idx = 0) const
   {
     return successor (idx)->to_llvm ();
   }
 
   size_t successor_index (const jit_block *asuccessor) const;
 
   std::ostream& print_successor (std::ostream& os, size_t idx = 0) const
   {
@@ -1072,17 +1072,17 @@ public:
   bool alive (size_t idx) const { return malive[idx]; }
 
   bool alive (int idx) const { return malive[idx]; }
 
   size_t successor_count (void) const { return malive.size (); }
 
   virtual bool infer (void);
 
-  llvm::TerminatorInst *to_llvm (void) const;
+  llvm::TerminatorInst * to_llvm (void) const;
 protected:
   virtual bool check_alive (size_t) const { return true; }
 private:
   std::vector<bool> malive;
 };
 
 class
 jit_branch : public jit_terminator
@@ -1103,24 +1103,24 @@ public:
 
 class
 jit_cond_branch : public jit_terminator
 {
 public:
   jit_cond_branch (jit_value *c, jit_block *ctrue, jit_block *cfalse)
     : jit_terminator (2, ctrue, cfalse, c) { }
 
-  jit_value *cond (void) const { return argument (2); }
+  jit_value * cond (void) const { return argument (2); }
 
   std::ostream& print_cond (std::ostream& os) const
   {
     return cond ()->short_print (os);
   }
 
-  llvm::Value *cond_llvm (void) const
+  llvm::Value * cond_llvm (void) const
   {
     return cond ()->to_llvm ();
   }
 
   virtual size_t successor_count (void) const { return 2; }
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
@@ -1237,17 +1237,17 @@ public:
 
   variable check_variable (void) const { return mvariable; }
 
   bool has_check_for (void) const
   {
     return argument_count () == 3;
   }
 
-  jit_call *check_for (void) const
+  jit_call * check_for (void) const
   {
     assert (has_check_for ());
     return static_cast<jit_call *> (argument (2));
   }
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const;
 
   JIT_VALUE_ACCEPT;
@@ -1345,27 +1345,27 @@ public:
     return dest->name ();
   }
 
   const jit_function& overload (void) const
   {
     return jit_typeinfo::cast (jit_typeinfo::get_any (), result_type ());
   }
 
-  jit_value *result (void) const
+  jit_value * result (void) const
   {
     return argument (0);
   }
 
-  jit_type *result_type (void) const
+  jit_type * result_type (void) const
   {
     return result ()->type ();
   }
 
-  llvm::Value *result_llvm (void) const
+  llvm::Value * result_llvm (void) const
   {
     return result ()->to_llvm ();
   }
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     jit_value *res = result ();
     print_indent (os, indent) << "store ";
@@ -1388,22 +1388,22 @@ private:
 class
 jit_return : public jit_instruction
 {
 public:
   jit_return (void) { }
 
   jit_return (jit_value *retval) : jit_instruction (retval) { }
 
-  jit_value *result (void) const
+  jit_value * result (void) const
   {
     return argument_count () ? argument (0) : 0;
   }
 
-  jit_type *result_type (void) const
+  jit_type * result_type (void) const
   {
     jit_value *res = result ();
     return res ? res->type () : 0;
   }
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent) << "return";
diff --git a/libinterp/parse-tree/jit-typeinfo.h b/libinterp/parse-tree/jit-typeinfo.h
--- a/libinterp/parse-tree/jit-typeinfo.h
+++ b/libinterp/parse-tree/jit-typeinfo.h
@@ -141,23 +141,23 @@ public:
 
   // a user readable type name
   const std::string& name (void) const { return mname; }
 
   // a unique id for the type
   int type_id (void) const { return mid; }
 
   // An abstract base type, may be null
-  jit_type *parent (void) const { return mparent; }
+  jit_type * parent (void) const { return mparent; }
 
   // convert to an llvm type
-  llvm::Type *to_llvm (void) const { return llvm_type; }
+  llvm::Type * to_llvm (void) const { return llvm_type; }
 
   // how this type gets passed as a function argument
-  llvm::Type *to_llvm_arg (void) const;
+  llvm::Type * to_llvm_arg (void) const;
 
   size_t depth (void) const { return mdepth; }
 
   bool skip_paren (void) const { return mskip_paren; }
 
   // -------------------- Calling Convention information --------------------
 
   // A function declared like: mytype foo (int arg0, int arg1);
@@ -186,17 +186,17 @@ public:
 
   // The inverse operation of pack.
   convert_fn unpack (jit_convention::type cc) { return munpack[cc]; }
 
   void set_unpack (jit_convention::type cc, convert_fn fn)
   { munpack[cc] = fn; }
 
   // The resulting type after pack is called.
-  llvm::Type *packed_type (jit_convention::type cc)
+  llvm::Type * packed_type (jit_convention::type cc)
   { return mpacked_type[cc]; }
 
   void set_packed_type (jit_convention::type cc, llvm::Type *ty)
   { mpacked_type[cc] = ty; }
 private:
   std::string mname;
   jit_type *mparent;
   llvm::Type *llvm_type;
@@ -247,25 +247,25 @@ public:
   {
     do_add_mapping (engine, reinterpret_cast<void *> (fn));
   }
 
   bool valid (void) const { return llvm_function; }
 
   std::string name (void) const;
 
-  llvm::BasicBlock *new_block (const std::string& aname = "body",
-                               llvm::BasicBlock *insert_before = 0);
+  llvm::BasicBlock * new_block (const std::string& aname = "body",
+                                llvm::BasicBlock *insert_before = 0);
 
-  llvm::Value *call (llvm::IRBuilderD& builder,
-                     const std::vector<jit_value *>& in_args) const;
+  llvm::Value * call (llvm::IRBuilderD& builder,
+                      const std::vector<jit_value *>& in_args) const;
 
-  llvm::Value *call (llvm::IRBuilderD& builder,
-                     const std::vector<llvm::Value *>& in_args
-                     = std::vector<llvm::Value *> ()) const;
+  llvm::Value * call (llvm::IRBuilderD& builder,
+                      const std::vector<llvm::Value *>& in_args
+                      = std::vector<llvm::Value *> ()) const;
 
 #define JIT_PARAM_ARGS llvm::IRBuilderD& builder,
 #define JIT_PARAMS builder,
 #define JIT_CALL(N) JIT_EXPAND (llvm::Value *, call, llvm::Value *, const, N)
 
   JIT_CALL (1)
   JIT_CALL (2)
   JIT_CALL (3)
@@ -279,33 +279,33 @@ public:
   JIT_CALL (1);
   JIT_CALL (2);
   JIT_CALL (3);
 
 #undef JIT_CALL
 #undef JIT_PARAMS
 #undef JIT_PARAM_ARGS
 
-  llvm::Value *argument (llvm::IRBuilderD& builder, size_t idx) const;
+  llvm::Value * argument (llvm::IRBuilderD& builder, size_t idx) const;
 
   void do_return (llvm::IRBuilderD& builder, llvm::Value *rval = 0,
                   bool verify = true);
 
-  llvm::Function *to_llvm (void) const { return llvm_function; }
+  llvm::Function * to_llvm (void) const { return llvm_function; }
 
   // If true, then the return value is passed as a pointer in the first argument
   bool sret (void) const { return mresult && mresult->sret (call_conv); }
 
   bool can_error (void) const { return mcan_error; }
 
   void mark_can_error (void) { mcan_error = true; }
 
-  jit_type *result (void) const { return mresult; }
+  jit_type * result (void) const { return mresult; }
 
-  jit_type *argument_type (size_t idx) const
+  jit_type * argument_type (size_t idx) const
   {
     assert (idx < args.size ());
     return args[idx];
   }
 
   const std::vector<jit_type *>& arguments (void) const { return args; }
 private:
   void do_add_mapping (llvm::ExecutionEngine *engine, void *fn);
@@ -336,17 +336,17 @@ public:
     add_overload (func, func.arguments ());
   }
 
   void add_overload (const jit_function& func,
                      const signature_vec& args);
 
   const jit_function& overload (const signature_vec& types) const;
 
-  jit_type *result (const signature_vec& types) const
+  jit_type * result (const signature_vec& types) const
   {
     const jit_function& temp = overload (types);
     return temp.result ();
   }
 
 #define JIT_PARAMS
 #define JIT_PARAM_ARGS
 #define JIT_OVERLOAD(N)                                              \
@@ -359,17 +359,17 @@ public:
 
 #undef JIT_PARAMS
 #undef JIT_PARAM_ARGS
 
   const std::string& name (void) const { return mname; }
 
   void stash_name (const std::string& aname) { mname = aname; }
 protected:
-  virtual jit_function *generate (const signature_vec& types) const;
+  virtual jit_function * generate (const signature_vec& types) const;
 private:
   Array<octave_idx_type> to_idx (const signature_vec& types) const;
 
   const jit_function& do_generate (const signature_vec& types) const;
 
   struct signature_cmp
   {
     bool operator () (const signature_vec *lhs, const signature_vec *rhs) const;
@@ -393,95 +393,95 @@ public:
 
   void initialize (llvm::Module *amodule, llvm::ExecutionEngine *aengine)
   {
     module = amodule;
     engine = aengine;
     do_initialize ();
   }
 protected:
-  virtual jit_function *generate (const signature_vec& types) const;
+  virtual jit_function * generate (const signature_vec& types) const;
 
-  virtual jit_function *generate_matrix (const signature_vec& types) const = 0;
+  virtual jit_function * generate_matrix (const signature_vec& types) const = 0;
 
   virtual void do_initialize (void) = 0;
 
   // helper functions
   // [start_idx, end_idx).
-  llvm::Value *create_arg_array (llvm::IRBuilderD& builder,
-                                 const jit_function& fn, size_t start_idx,
-                                 size_t end_idx) const;
+  llvm::Value * create_arg_array (llvm::IRBuilderD& builder,
+                                  const jit_function& fn, size_t start_idx,
+                                  size_t end_idx) const;
 
   llvm::Module *module;
   llvm::ExecutionEngine *engine;
 };
 
 class
 jit_paren_subsref : public jit_index_operation
 {
 protected:
-  virtual jit_function *generate_matrix (const signature_vec& types) const;
+  virtual jit_function * generate_matrix (const signature_vec& types) const;
 
   virtual void do_initialize (void);
 private:
   jit_function paren_scalar;
 };
 
 class
 jit_paren_subsasgn : public jit_index_operation
 {
 protected:
-  jit_function *generate_matrix (const signature_vec& types) const;
+  jit_function * generate_matrix (const signature_vec& types) const;
 
   virtual void do_initialize (void);
 private:
   jit_function paren_scalar;
 };
 
 // A singleton class which handles the construction of jit_types and
 // jit_operations.
 class
 jit_typeinfo
 {
 public:
   static void initialize (llvm::Module *m, llvm::ExecutionEngine *e);
 
-  static jit_type *join (jit_type *lhs, jit_type *rhs)
+  static jit_type * join (jit_type *lhs, jit_type *rhs)
   {
     return instance->do_join (lhs, rhs);
   }
 
-  static jit_type *get_any (void) { return instance->any; }
+  static jit_type * get_any (void) { return instance->any; }
 
-  static jit_type *get_matrix (void) { return instance->matrix; }
+  static jit_type * get_matrix (void) { return instance->matrix; }
 
-  static jit_type *get_scalar (void) { return instance->scalar; }
+  static jit_type * get_scalar (void) { return instance->scalar; }
 
-  static llvm::Type *get_scalar_llvm (void)
+  static llvm::Type * get_scalar_llvm (void)
   { return instance->scalar->to_llvm (); }
 
-  static jit_type *get_scalar_ptr (void) { return instance->scalar_ptr; }
+  static jit_type * get_scalar_ptr (void) { return instance->scalar_ptr; }
 
-  static jit_type *get_any_ptr (void) { return instance->any_ptr; }
+  static jit_type * get_any_ptr (void) { return instance->any_ptr; }
 
-  static jit_type *get_range (void) { return instance->range; }
+  static jit_type * get_range (void) { return instance->range; }
 
-  static jit_type *get_string (void) { return instance->string; }
+  static jit_type * get_string (void) { return instance->string; }
 
-  static jit_type *get_bool (void) { return instance->boolean; }
+  static jit_type * get_bool (void) { return instance->boolean; }
 
-  static jit_type *get_index (void) { return instance->index; }
+  static jit_type * get_index (void) { return instance->index; }
 
-  static llvm::Type *get_index_llvm (void)
+  static llvm::Type * get_index_llvm (void)
   { return instance->index->to_llvm (); }
 
-  static jit_type *get_complex (void) { return instance->complex; }
+  static jit_type * get_complex (void) { return instance->complex; }
 
   // Get the jit_type of an octave_value
-  static jit_type *type_of (const octave_value& ov)
+  static jit_type * type_of (const octave_value& ov)
   {
     return instance->do_type_of (ov);
   }
 
   static const jit_operation& binary_op (int op)
   {
     return instance->do_binary_op (op);
   }
@@ -558,22 +558,22 @@ public:
     return instance->do_cast (result);
   }
 
   static const jit_function& cast (jit_type *to, jit_type *from)
   {
     return instance->do_cast (to, from);
   }
 
-  static llvm::Value *insert_error_check (llvm::IRBuilderD& bld)
+  static llvm::Value * insert_error_check (llvm::IRBuilderD& bld)
   {
     return instance->do_insert_error_check (bld);
   }
 
-  static llvm::Value *insert_interrupt_check (llvm::IRBuilderD& bld)
+  static llvm::Value * insert_interrupt_check (llvm::IRBuilderD& bld)
   {
     return instance->do_insert_interrupt_check (bld);
   }
 
   static const jit_operation& end (void)
   {
     return instance->end_fn;
   }
@@ -584,25 +584,25 @@ public:
     return instance->do_end (value, index, count);
   }
 
   static const jit_operation& create_undef (void)
   {
     return instance->create_undef_fn;
   }
 
-  static llvm::Value *create_complex (llvm::Value *real, llvm::Value *imag)
+  static llvm::Value * create_complex (llvm::Value *real, llvm::Value *imag)
   {
     return instance->complex_new (real, imag);
   }
 private:
   jit_typeinfo (llvm::Module *m, llvm::ExecutionEngine *e);
 
   // FIXME: Do these methods really need to be in jit_typeinfo?
-  jit_type *do_join (jit_type *lhs, jit_type *rhs)
+  jit_type * do_join (jit_type *lhs, jit_type *rhs)
   {
     // empty case
     if (! lhs)
       return rhs;
 
     if (! rhs)
       return lhs;
 
@@ -623,23 +623,23 @@ private:
               }
             while (lhs != rhs);
           }
       }
 
     return lhs;
   }
 
-  jit_type *do_difference (jit_type *lhs, jit_type *)
+  jit_type * do_difference (jit_type *lhs, jit_type *)
   {
     // FIXME: Maybe we can do something smarter?
     return lhs;
   }
 
-  jit_type *do_type_of (const octave_value& ov) const;
+  jit_type * do_type_of (const octave_value& ov) const;
 
   const jit_operation& do_binary_op (int op) const
   {
     assert (static_cast<size_t>(op) < binary_ops.size ());
     return binary_ops[op];
   }
 
   const jit_operation& do_unary_op (int op) const
@@ -663,18 +663,18 @@ private:
   const jit_function& do_cast (jit_type *to, jit_type *from)
   {
     return do_cast (to).overload (from);
   }
 
   const jit_function& do_end (jit_value *value, jit_value *index,
                               jit_value *count);
 
-  jit_type *new_type (const std::string& name, jit_type *parent,
-                      llvm::Type *llvm_type, bool skip_paren = false);
+  jit_type * new_type (const std::string& name, jit_type *parent,
+                       llvm::Type *llvm_type, bool skip_paren = false);
 
   void add_print (jit_type *ty, void *fptr);
 
   void add_binary_op (jit_type *ty, int op, int llvm_op);
 
   void add_binary_icmp (jit_type *ty, int op, int llvm_op);
 
   void add_binary_fcmp (jit_type *ty, int op, int llvm_op);
@@ -734,19 +734,19 @@ private:
   CREATE_FUNCTION(4);
 
 #undef JIT_PARAM_ARGS
 #undef JIT_PARAMS
 #undef CREATE_FUNCTION
 
   jit_function create_identity (jit_type *type);
 
-  llvm::Value *do_insert_error_check (llvm::IRBuilderD& bld);
+  llvm::Value * do_insert_error_check (llvm::IRBuilderD& bld);
 
-  llvm::Value *do_insert_interrupt_check (llvm::IRBuilderD& bld);
+  llvm::Value * do_insert_interrupt_check (llvm::IRBuilderD& bld);
 
   void add_builtin (const std::string& name);
 
   void register_intrinsic (const std::string& name, size_t id,
                            jit_type *result, jit_type *arg0)
   {
     std::vector<jit_type *> args (1, arg0);
     register_intrinsic (name, id, result, args);
@@ -760,41 +760,41 @@ private:
   {
     std::vector<jit_type *> args (1, arg0);
     register_generic (name, result, args);
   }
 
   void register_generic (const std::string& name, jit_type *result,
                          const std::vector<jit_type *>& args);
 
-  octave_builtin *find_builtin (const std::string& name);
+  octave_builtin * find_builtin (const std::string& name);
 
   jit_function mirror_binary (const jit_function& fn);
 
-  llvm::Function *wrap_complex (llvm::Function *wrap);
+  llvm::Function * wrap_complex (llvm::Function *wrap);
 
-  static llvm::Value *pack_complex (llvm::IRBuilderD& bld,
-                                    llvm::Value *cplx);
+  static llvm::Value * pack_complex (llvm::IRBuilderD& bld,
+                                     llvm::Value *cplx);
 
-  static llvm::Value *unpack_complex (llvm::IRBuilderD& bld,
-                                      llvm::Value *result);
+  static llvm::Value * unpack_complex (llvm::IRBuilderD& bld,
+                                       llvm::Value *result);
 
-  llvm::Value *complex_real (llvm::Value *cx);
+  llvm::Value * complex_real (llvm::Value *cx);
 
-  llvm::Value *complex_real (llvm::Value *cx, llvm::Value *real);
+  llvm::Value * complex_real (llvm::Value *cx, llvm::Value *real);
 
-  llvm::Value *complex_imag (llvm::Value *cx);
+  llvm::Value * complex_imag (llvm::Value *cx);
 
-  llvm::Value *complex_imag (llvm::Value *cx, llvm::Value *imag);
+  llvm::Value * complex_imag (llvm::Value *cx, llvm::Value *imag);
 
-  llvm::Value *complex_new (llvm::Value *real, llvm::Value *imag);
+  llvm::Value * complex_new (llvm::Value *real, llvm::Value *imag);
 
   void create_int (size_t nbits);
 
-  jit_type *intN (size_t nbits) const;
+  jit_type * intN (size_t nbits) const;
 
   static jit_typeinfo *instance;
 
   llvm::Module *module;
   llvm::ExecutionEngine *engine;
   int next_id;
 
   llvm::GlobalVariable *lerror_state;
diff --git a/libinterp/parse-tree/jit-util.h b/libinterp/parse-tree/jit-util.h
--- a/libinterp/parse-tree/jit-util.h
+++ b/libinterp/parse-tree/jit-util.h
@@ -115,17 +115,17 @@ public:
   jit_internal_list (void) : use_head (0), use_tail (0), muse_count (0) { }
 
   virtual ~jit_internal_list (void)
   {
     while (use_head)
       use_head->stash_value (0);
   }
 
-  NODE_T *first_use (void) const { return use_head; }
+  NODE_T * first_use (void) const { return use_head; }
 
   size_t use_count (void) const { return muse_count; }
 private:
   NODE_T *use_head;
   NODE_T *use_tail;
   size_t muse_count;
 };
 
@@ -136,17 +136,17 @@ jit_internal_node
 {
 public:
   typedef jit_internal_list<LIST_T, NODE_T> jit_ilist;
 
   jit_internal_node (void) : mvalue (0), mnext (0), mprev (0) { }
 
   ~jit_internal_node (void) { remove (); }
 
-  LIST_T *value (void) const { return mvalue; }
+  LIST_T * value (void) const { return mvalue; }
 
   void stash_value (LIST_T *avalue)
   {
     remove ();
 
     mvalue = avalue;
 
     if (mvalue)
@@ -161,19 +161,19 @@ public:
         else
           ilist->use_head = sthis;
 
         ilist->use_tail = sthis;
         ++ilist->muse_count;
       }
   }
 
-  NODE_T *next (void) const { return mnext; }
+  NODE_T * next (void) const { return mnext; }
 
-  NODE_T *prev (void) const { return mprev; }
+  NODE_T * prev (void) const { return mprev; }
 private:
   void remove ()
   {
     if (mvalue)
       {
         jit_ilist *ilist = mvalue;
         if (mprev)
           mprev->mnext = mnext;
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -213,43 +213,43 @@ namespace octave
         if (! empty ())
           {
             delete buffer.back ();
             buffer.pop_back ();
           }
       }
 
       // Direct access.
-      token *at (size_t n)
+      token * at (size_t n)
       {
         return empty () ? 0 : buffer.at (n);
       }
 
-      const token *at (size_t n) const
+      const token * at (size_t n) const
       {
         return empty () ? 0 : buffer.at (n);
       }
 
       // Most recently pushed.
-      token *front (void)
+      token * front (void)
       {
         return empty () ? 0 : buffer.front ();
       }
 
-      const token *front (void) const
+      const token * front (void) const
       {
         return empty () ? 0 : buffer.front ();
       }
 
-      token *back (void)
+      token * back (void)
       {
         return empty () ? 0 : buffer.back ();
       }
 
-      const token *back (void) const
+      const token * back (void) const
       {
         return empty () ? 0 : buffer.back ();
       }
 
       // Number of elements currently in the buffer.
       size_t size (void) const { return buffer.size (); }
 
       bool empty (void) const { return buffer.empty (); }
@@ -520,17 +520,17 @@ namespace octave
         if (! comment_list)
           comment_list = new octave_comment_list ();
 
         comment_list->append (s, t);
       }
 
       // Caller is expected to delete the returned value.
 
-      octave_comment_list *get_comment (void)
+      octave_comment_list * get_comment (void)
       {
         octave_comment_list *retval = comment_list;
 
         comment_list = 0;
 
         return retval;
       }
 
@@ -574,17 +574,17 @@ namespace octave
     virtual int fill_flex_buffer (char *buf, unsigned int max_size) = 0;
 
     bool at_end_of_buffer (void) const { return input_buf.empty (); }
 
     bool at_end_of_file (void) const { return input_buf.at_eof (); }
 
     int handle_end_of_input (void);
 
-    char *flex_yytext (void);
+    char * flex_yytext (void);
 
     int flex_yyleng (void);
 
     int text_yyinput (void);
 
     void xunput (char c, char *buf);
 
     void xunput (char c);
@@ -602,17 +602,17 @@ namespace octave
     bool whitespace_is_significant (void);
 
     void handle_number (void);
 
     void handle_continuation (void);
 
     void finish_comment (octave_comment_elt::comment_type typ);
 
-    octave_comment_list *get_comment (void) { return comment_buf.get_comment (); }
+    octave_comment_list * get_comment (void) { return comment_buf.get_comment (); }
 
     int handle_close_bracket (int bracket_type);
 
     bool looks_like_command_arg (void);
 
     int handle_superclass_identifier (void);
 
     int handle_meta_identifier (void);
@@ -630,17 +630,17 @@ namespace octave
     void maybe_warn_language_extension_comment (char c);
 
     void warn_language_extension_continuation (void);
 
     void warn_language_extension_operator (const std::string& op);
 
     void push_token (token *);
 
-    token *current_token (void);
+    token * current_token (void);
 
     void display_token (int tok);
 
     void fatal_error (const char *msg);
 
     void lexer_debug (const char *pattern);
 
     // Internal state of the flex-generated lexer.
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -164,23 +164,23 @@ namespace octave
     // Maybe print a warning if an assignment expression is used as the
     // test in a logical expression.
     void maybe_warn_assign_as_truth_value (tree_expression *expr);
 
     // Maybe print a warning about switch labels that aren't constants.
     void maybe_warn_variable_switch_label (tree_expression *expr);
 
     // Finish building a range.
-    tree_expression *finish_colon_expression (tree_colon_expression *e);
+    tree_expression * finish_colon_expression (tree_colon_expression *e);
 
     // Build a constant.
-    tree_constant *make_constant (int op, token *tok_val);
+    tree_constant * make_constant (int op, token *tok_val);
 
     // Build a function handle.
-    tree_fcn_handle *make_fcn_handle (token *tok_val);
+    tree_fcn_handle * make_fcn_handle (token *tok_val);
 
     // Build an anonymous function handle.
     tree_anon_fcn_handle *
     make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt);
 
     // Build a binary expression.
     tree_expression *
     make_binary_op (int op, tree_expression *op1, token *tok_val,
@@ -226,23 +226,23 @@ namespace octave
     // Build a for command.
     tree_command *
     make_for_command (int tok_id, token *for_tok, tree_argument_list *lhs,
                       tree_expression *expr, tree_expression *maxproc,
                       tree_statement_list *body, token *end_tok,
                       octave_comment_list *lc);
 
     // Build a break command.
-    tree_command *make_break_command (token *break_tok);
+    tree_command * make_break_command (token *break_tok);
 
     // Build a continue command.
-    tree_command *make_continue_command (token *continue_tok);
+    tree_command * make_continue_command (token *continue_tok);
 
     // Build a return command.
-    tree_command *make_return_command (token *return_tok);
+    tree_command * make_return_command (token *return_tok);
 
     // Start an if command.
     tree_if_command_list *
     start_if_command (tree_expression *expr, tree_statement_list *list);
 
     // Finish an if command.
     tree_if_command *
     finish_if_command (token *if_tok, tree_if_command_list *list,
@@ -273,17 +273,17 @@ namespace octave
     void make_script (tree_statement_list *cmds, tree_statement *end_script);
 
     // Begin defining a function.
     octave_user_function *
     start_function (tree_parameter_list *param_list, tree_statement_list *body,
                     tree_statement *end_function);
 
     // Create a no-op statement for end_function.
-    tree_statement *make_end (const std::string& type, bool eof, int l, int c);
+    tree_statement * make_end (const std::string& type, bool eof, int l, int c);
 
     // Do most of the work for defining a function.
     octave_user_function *
     frob_function (const std::string& fname, octave_user_function *fcn);
 
     // Finish defining a function.
     tree_function_def *
     finish_function (tree_parameter_list *ret_list,
@@ -356,41 +356,41 @@ namespace octave
     // Make a declaration command.
     tree_decl_command *
     make_decl_command (int tok, token *tok_val, tree_decl_init_list *lst);
 
     // Validate matrix or cell
     bool validate_array_list (tree_expression *e);
 
     // Validate matrix object used in "[lhs] = ..." assignments.
-    tree_argument_list *validate_matrix_for_assignment (tree_expression *e);
+    tree_argument_list * validate_matrix_for_assignment (tree_expression *e);
 
     // Finish building an array_list (common action for finish_matrix
     // and finish_cell).
-    tree_expression *finish_array_list (tree_array_list *a);
+    tree_expression * finish_array_list (tree_array_list *a);
 
     // Finish building a matrix list.
-    tree_expression *finish_matrix (tree_matrix *m);
+    tree_expression * finish_matrix (tree_matrix *m);
 
     // Finish building a cell list.
-    tree_expression *finish_cell (tree_cell *c);
+    tree_expression * finish_cell (tree_cell *c);
 
     // Maybe print a warning.  Duh.
     void maybe_warn_missing_semi (tree_statement_list *);
 
     // Set the print flag for a statement based on the separator type.
     tree_statement_list *
     set_stmt_print_flag (tree_statement_list *, char, bool);
 
     // Finish building a statement.
     template <typename T>
-    tree_statement *make_statement (T *arg);
+    tree_statement * make_statement (T *arg);
 
     // Create a statement list.
-    tree_statement_list *make_statement_list (tree_statement *stmt);
+    tree_statement_list * make_statement_list (tree_statement *stmt);
 
     // Append a statement to an existing statement list.
     tree_statement_list *
     append_statement_list (tree_statement_list *list, char sep,
                            tree_statement *stmt, bool warn_missing_semi);
 
     // Generic error messages.
     void bison_error (const std::string& s, int l = -1, int c = -1);
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -67,17 +67,17 @@ namespace octave
 
     ~tree_argument_list (void);
 
     bool has_magic_end (void) const;
 
     bool has_magic_tilde (void) const
     { return list_includes_magic_tilde; }
 
-    tree_expression *remove_front (void)
+    tree_expression * remove_front (void)
     {
       iterator p = begin ();
       tree_expression *retval = *p;
       erase (p);
       return retval;
     }
 
     void append (const element_type& s);
@@ -94,18 +94,18 @@ namespace octave
                                                const octave_value *object = 0);
 
     std::list<octave_lvalue> lvalue_list (tree_evaluator *tw);
 
     string_vector get_arg_names (void) const;
 
     std::list<std::string> variable_names (void) const;
 
-    tree_argument_list *dup (symbol_table::scope_id scope,
-                             symbol_table::context_id context) const;
+    tree_argument_list * dup (symbol_table::scope_id scope,
+                              symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_argument_list (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-array-list.h b/libinterp/parse-tree/pt-array-list.h
--- a/libinterp/parse-tree/pt-array-list.h
+++ b/libinterp/parse-tree/pt-array-list.h
@@ -75,18 +75,18 @@ namespace octave
     using tree_expression::copy_base;
 
     void copy_base (const tree_array_list& array_list);
 
     void copy_base (const tree_array_list& array_list,
                     symbol_table::scope_id scope,
                     symbol_table::context_id context);
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw);
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::tree_array_list' instead")
diff --git a/libinterp/parse-tree/pt-assign.h b/libinterp/parse-tree/pt-assign.h
--- a/libinterp/parse-tree/pt-assign.h
+++ b/libinterp/parse-tree/pt-assign.h
@@ -67,22 +67,22 @@ namespace octave
     bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
 
     bool rvalue_ok (void) const { return true; }
 
     bool is_assignment_expression (void) const { return true; }
 
     std::string oper (void) const;
 
-    tree_expression *left_hand_side (void) { return lhs; }
+    tree_expression * left_hand_side (void) { return lhs; }
 
-    tree_expression *right_hand_side (void) { return rhs; }
+    tree_expression * right_hand_side (void) { return rhs; }
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_simple_assignment (*this);
     }
     
     octave_value::assign_op op_type (void) const { return etype; }
 
@@ -132,22 +132,22 @@ namespace octave
     bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
 
     bool is_assignment_expression (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
     std::string oper (void) const;
 
-    tree_argument_list *left_hand_side (void) { return lhs; }
+    tree_argument_list * left_hand_side (void) { return lhs; }
 
-    tree_expression *right_hand_side (void) { return rhs; }
+    tree_expression * right_hand_side (void) { return rhs; }
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_multi_assignment (*this);
     }
 
     octave_value::assign_op op_type (void) const
     { return octave_value::op_asn_eq; }
diff --git a/libinterp/parse-tree/pt-binop.h b/libinterp/parse-tree/pt-binop.h
--- a/libinterp/parse-tree/pt-binop.h
+++ b/libinterp/parse-tree/pt-binop.h
@@ -90,26 +90,26 @@ namespace octave
     bool is_binary_expression (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
     std::string oper (void) const;
 
     octave_value::binary_op op_type (void) const { return etype; }
 
-    tree_expression *lhs (void) { return op_lhs; }
-    tree_expression *rhs (void) { return op_rhs; }
+    tree_expression * lhs (void) { return op_lhs; }
+    tree_expression * rhs (void) { return op_rhs; }
 
     bool is_eligible_for_braindead_shortcircuit (void) const
     {
       return eligible_for_braindead_shortcircuit;
     }
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_binary_expression (*this);
     }
 
     std::string profiler_name (void) const { return "binary " + oper (); }
 
@@ -166,18 +166,18 @@ namespace octave
     bool is_boolean_expression (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
     std::string oper (void) const;
 
     type op_type (void) const { return etype; }
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_boolean_expression (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-cell.h b/libinterp/parse-tree/pt-cell.h
--- a/libinterp/parse-tree/pt-cell.h
+++ b/libinterp/parse-tree/pt-cell.h
@@ -55,18 +55,18 @@ namespace octave
     tree_cell& operator = (const tree_cell&) = delete;
 
     ~tree_cell (void) = default;
 
     bool is_cell (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_cell (*this);
     }
   };
 }
 
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -55,19 +55,19 @@ namespace octave
     tree_classdef_attribute& operator = (const tree_classdef_attribute&) = delete;
 
     ~tree_classdef_attribute (void)
     {
       delete id;
       delete expr;
     }
 
-    tree_identifier *ident (void) { return id; }
+    tree_identifier * ident (void) { return id; }
 
-    tree_expression *expression (void) { return expr; }
+    tree_expression * expression (void) { return expr; }
 
     bool negate (void) { return neg; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef_attribute (*this);
     }
 
@@ -180,23 +180,23 @@ namespace octave
     ~tree_classdef_element (void)
     {
       delete attr_list;
       delete elt_list;
       delete lead_comm;
       delete trail_comm;
     }
 
-    tree_classdef_attribute_list *attribute_list (void) { return attr_list; }
+    tree_classdef_attribute_list * attribute_list (void) { return attr_list; }
 
-    octave::base_list<T> *element_list (void) { return elt_list; }
+    octave::base_list<T> * element_list (void) { return elt_list; }
 
-    octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list *trailing_comment (void) { return trail_comm; }
+    octave_comment_list * trailing_comment (void) { return trail_comm; }
 
     void accept (tree_walker&) { }
 
   private:
 
     // List of attributes that apply to this class.
     tree_classdef_attribute_list *attr_list;
 
@@ -224,19 +224,19 @@ namespace octave
     tree_classdef_property& operator = (const tree_classdef_property&) = delete;
 
     ~tree_classdef_property (void)
     {
       delete id;
       delete expr;
     }
 
-    tree_identifier *ident (void) { return id; }
+    tree_identifier * ident (void) { return id; }
 
-    tree_expression *expression (void) { return expr; }
+    tree_expression * expression (void) { return expr; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef_property (*this);
     }
 
   private:
 
@@ -360,17 +360,17 @@ namespace octave
 
     tree_classdef_event& operator = (const tree_classdef_event&) = delete;
 
     ~tree_classdef_event (void)
     {
       delete id;
     }
 
-    tree_identifier *ident (void) { return id; }
+    tree_identifier * ident (void) { return id; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef_event (*this);
     }
 
   private:
 
@@ -445,19 +445,19 @@ namespace octave
     tree_classdef_enum& operator = (const tree_classdef_enum&) = delete;
 
     ~tree_classdef_enum (void)
     {
       delete id;
       delete expr;
     }
 
-    tree_identifier *ident (void) { return id; }
+    tree_identifier * ident (void) { return id; }
 
-    tree_expression *expression (void) { return expr; }
+    tree_expression * expression (void) { return expr; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef_enum (*this);
     }
 
   private:
 
@@ -650,34 +650,34 @@ namespace octave
       delete attr_list;
       delete id;
       delete supclass_list;
       delete element_list;
       delete lead_comm;
       delete trail_comm;
     }
 
-    tree_classdef_attribute_list *attribute_list (void) { return attr_list; }
+    tree_classdef_attribute_list * attribute_list (void) { return attr_list; }
 
-    tree_identifier *ident (void) { return id; }
+    tree_identifier * ident (void) { return id; }
 
-    tree_classdef_superclass_list *superclass_list (void) { return supclass_list; }
+    tree_classdef_superclass_list * superclass_list (void) { return supclass_list; }
 
-    tree_classdef_body *body (void) { return element_list; }
+    tree_classdef_body * body (void) { return element_list; }
 
-    octave_comment_list *leading_comment (void) { return lead_comm; }
-    octave_comment_list *trailing_comment (void) { return trail_comm; }
+    octave_comment_list * leading_comment (void) { return lead_comm; }
+    octave_comment_list * trailing_comment (void) { return trail_comm; }
 
     const std::string& package_name (void) const { return pack_name; }
 
     octave_function* make_meta_class (tree_evaluator *tw,
                                       bool is_at_folder = false);
 
-    tree_classdef *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+    tree_classdef * dup (symbol_table::scope_id scope,
+                         symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-cmd.h b/libinterp/parse-tree/pt-cmd.h
--- a/libinterp/parse-tree/pt-cmd.h
+++ b/libinterp/parse-tree/pt-cmd.h
@@ -47,18 +47,18 @@ namespace octave
     // No copying!
 
     tree_command (const tree_command&) = delete;
 
     tree_command& operator = (const tree_command&) = delete;
 
     virtual ~tree_command (void) = default;
 
-    virtual tree_command *dup (symbol_table::scope_id,
-                               symbol_table::context_id context) const = 0;
+    virtual tree_command * dup (symbol_table::scope_id,
+                                symbol_table::context_id context) const = 0;
   };
 
   // No-op.
 
   class tree_no_op_command : public tree_command
   {
   public:
 
@@ -69,18 +69,18 @@ namespace octave
     // No copying!
 
     tree_no_op_command (const tree_no_op_command&) = delete;
 
     tree_no_op_command& operator = (const tree_no_op_command&) = delete;
 
     ~tree_no_op_command (void) = default;
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_no_op_command (*this);
     }
 
     bool is_end_of_fcn_or_script (void) const
     {
@@ -110,18 +110,18 @@ namespace octave
     // No copying!
 
     tree_function_def (const tree_function_def&) = delete;
 
     tree_function_def& operator = (const tree_function_def&) = delete;
 
     ~tree_function_def (void) = default;
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_function_def (*this);
     }
 
     octave_value function (void) { return fcn; }
 
diff --git a/libinterp/parse-tree/pt-colon.h b/libinterp/parse-tree/pt-colon.h
--- a/libinterp/parse-tree/pt-colon.h
+++ b/libinterp/parse-tree/pt-colon.h
@@ -74,33 +74,33 @@ namespace octave
     {
       return ((op_base && op_base->has_magic_end ())
               || (op_limit && op_limit->has_magic_end ())
               || (op_increment && op_increment->has_magic_end ()));
     }
 
     void preserve_base (void) { save_base = true; }
 
-    tree_colon_expression *append (tree_expression *t);
+    tree_colon_expression * append (tree_expression *t);
 
     bool rvalue_ok (void) const { return true; }
 
     void eval_error (const std::string& s) const;
 
-    tree_expression *base (void) { return op_base; }
+    tree_expression * base (void) { return op_base; }
 
-    tree_expression *limit (void) { return op_limit; }
+    tree_expression * limit (void) { return op_limit; }
 
-    tree_expression *increment (void) { return op_increment; }
+    tree_expression * increment (void) { return op_increment; }
 
     int line (void) const;
     int column (void) const;
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_colon_expression (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-const.h b/libinterp/parse-tree/pt-const.h
--- a/libinterp/parse-tree/pt-const.h
+++ b/libinterp/parse-tree/pt-const.h
@@ -73,18 +73,18 @@ namespace octave
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
     bool rvalue_ok (void) const { return true; }
 
     octave_value value (void) { return val; }
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_constant (*this);
     }
 
     // Store the original text corresponding to this constant for later
     // pretty printing.
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -69,24 +69,24 @@ namespace octave
 
     bool lvalue_ok (void) { return id ? id->lvalue_ok () : false; }
 
     octave_lvalue lvalue (tree_evaluator *tw)
     {
       return id ? id->lvalue (tw) : octave_lvalue ();
     }
 
-    tree_identifier *ident (void) { return id; }
+    tree_identifier * ident (void) { return id; }
 
     std::string name (void) { return id ? id->name () : ""; }
 
-    tree_expression *expression (void) { return expr; }
+    tree_expression * expression (void) { return expr; }
 
-    tree_decl_elt *dup (symbol_table::scope_id scope,
-                        symbol_table::context_id context) const;
+    tree_decl_elt * dup (symbol_table::scope_id scope,
+                         symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_decl_elt (*this);
     }
 
   private:
 
@@ -116,18 +116,18 @@ namespace octave
       while (! empty ())
         {
           iterator p = begin ();
           delete *p;
           erase (p);
         }
     }
 
-    tree_decl_init_list *dup (symbol_table::scope_id scope,
-                              symbol_table::context_id context) const;
+    tree_decl_init_list * dup (symbol_table::scope_id scope,
+                               symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_decl_init_list (*this);
     }
   };
 
   // Base class for declaration commands -- global, static, etc.
@@ -146,17 +146,17 @@ namespace octave
     // No copying!
 
     tree_decl_command (const tree_decl_command&) = delete;
 
     tree_decl_command& operator = (const tree_decl_command&) = delete;
 
     ~tree_decl_command (void);
 
-    tree_decl_init_list *initializer_list (void) { return init_list; }
+    tree_decl_init_list * initializer_list (void) { return init_list; }
 
     std::string name (void) { return cmd_name; }
 
   protected:
 
     // The name of this command -- global, static, etc.
     std::string cmd_name;
 
@@ -179,18 +179,18 @@ namespace octave
     // No copying!
 
     tree_global_command (const tree_global_command&) = delete;
 
     tree_global_command& operator = (const tree_global_command&) = delete;
 
     ~tree_global_command (void) = default;
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_global_command (*this);
     }
 
   private:
 
@@ -212,18 +212,18 @@ namespace octave
     // No copying!
 
     tree_persistent_command (const tree_persistent_command&) = delete;
 
     tree_persistent_command& operator = (const tree_persistent_command&) = delete;
 
     ~tree_persistent_command (void) = default;
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_persistent_command (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-except.h b/libinterp/parse-tree/pt-except.h
--- a/libinterp/parse-tree/pt-except.h
+++ b/libinterp/parse-tree/pt-except.h
@@ -57,30 +57,30 @@ namespace octave
     // No copying!
 
     tree_try_catch_command (const tree_try_catch_command&) = delete;
 
     tree_try_catch_command& operator = (const tree_try_catch_command&) = delete;
 
     ~tree_try_catch_command (void);
 
-    tree_identifier *identifier (void) { return expr_id; }
+    tree_identifier * identifier (void) { return expr_id; }
 
-    tree_statement_list *body (void) { return try_code; }
+    tree_statement_list * body (void) { return try_code; }
 
-    tree_statement_list *cleanup (void) { return catch_code; }
+    tree_statement_list * cleanup (void) { return catch_code; }
 
-    octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list *middle_comment (void) { return mid_comm; }
+    octave_comment_list * middle_comment (void) { return mid_comm; }
 
-    octave_comment_list *trailing_comment (void) { return trail_comm; }
+    octave_comment_list * trailing_comment (void) { return trail_comm; }
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_try_catch_command (*this);
     }
 
   private:
 
@@ -126,28 +126,28 @@ namespace octave
 
     tree_unwind_protect_command (const tree_unwind_protect_command&) = delete;
 
     tree_unwind_protect_command&
     operator = (const tree_unwind_protect_command&) = delete;
 
     ~tree_unwind_protect_command (void);
 
-    tree_statement_list *body (void) { return unwind_protect_code; }
+    tree_statement_list * body (void) { return unwind_protect_code; }
 
-    tree_statement_list *cleanup (void) { return cleanup_code; }
+    tree_statement_list * cleanup (void) { return cleanup_code; }
 
-    octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list *middle_comment (void) { return mid_comm; }
+    octave_comment_list * middle_comment (void) { return mid_comm; }
 
-    octave_comment_list *trailing_comment (void) { return trail_comm; }
+    octave_comment_list * trailing_comment (void) { return trail_comm; }
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_unwind_protect_command (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-exp.h b/libinterp/parse-tree/pt-exp.h
--- a/libinterp/parse-tree/pt-exp.h
+++ b/libinterp/parse-tree/pt-exp.h
@@ -53,18 +53,18 @@ namespace octave
     tree_expression (const tree_expression&) = delete;
 
     tree_expression& operator = (const tree_expression&) = delete;
 
     virtual ~tree_expression (void) = default;
 
     virtual bool has_magic_end (void) const = 0;
 
-    virtual tree_expression *dup (symbol_table::scope_id,
-                                  symbol_table::context_id context) const = 0;
+    virtual tree_expression * dup (symbol_table::scope_id,
+                                   symbol_table::context_id context) const = 0;
 
     virtual bool is_constant (void) const { return false; }
 
     virtual bool is_matrix (void) const { return false; }
 
     virtual bool is_cell (void) const { return false; }
 
     virtual bool is_identifier (void) const { return false; }
@@ -105,29 +105,29 @@ namespace octave
     virtual std::string original_text (void) const;
 
     virtual void mark_braindead_shortcircuit (void) { }
 
     void mark_as_for_cmd_expr (void) { for_cmd_expr = true; }
 
     bool is_for_cmd_expr (void) const { return for_cmd_expr; }
 
-    tree_expression *mark_in_parens (void)
+    tree_expression * mark_in_parens (void)
     {
       num_parens++;
       return this;
     }
 
-    tree_expression *set_postfix_index (char type)
+    tree_expression * set_postfix_index (char type)
     {
       postfix_index_type = type;
       return this;
     }
 
-    tree_expression *set_print_flag (bool print)
+    tree_expression * set_print_flag (bool print)
     {
       print_flag = print;
       return this;
     }
 
     virtual void copy_base (const tree_expression& e)
     {
       num_parens = e.num_parens;
diff --git a/libinterp/parse-tree/pt-fcn-handle.h b/libinterp/parse-tree/pt-fcn-handle.h
--- a/libinterp/parse-tree/pt-fcn-handle.h
+++ b/libinterp/parse-tree/pt-fcn-handle.h
@@ -68,18 +68,18 @@ namespace octave
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
     std::string name (void) const { return nm; }
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_fcn_handle (*this);
     }
 
   private:
 
@@ -108,38 +108,38 @@ namespace octave
     tree_anon_fcn_handle& operator = (const tree_anon_fcn_handle&) = delete;
 
     ~tree_anon_fcn_handle (void) { delete fcn; }
 
     bool has_magic_end (void) const { return false; }
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_parameter_list *parameter_list (void) const
+    tree_parameter_list * parameter_list (void) const
     {
       return fcn ? fcn->parameter_list () : 0;
     }
 
-    tree_parameter_list *return_list (void) const
+    tree_parameter_list * return_list (void) const
     {
       return fcn ? fcn->return_list () : 0;
     }
 
-    tree_statement_list *body (void) const
+    tree_statement_list * body (void) const
     {
       return fcn ? fcn->body () : 0;
     }
 
     symbol_table::scope_id scope (void) const
     {
       return fcn ? fcn->scope () : -1;
     }
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_anon_fcn_handle (*this);
     }
 
     void stash_file_name (const std::string& file) { m_file_name = file; }
 
diff --git a/libinterp/parse-tree/pt-funcall.h b/libinterp/parse-tree/pt-funcall.h
--- a/libinterp/parse-tree/pt-funcall.h
+++ b/libinterp/parse-tree/pt-funcall.h
@@ -61,18 +61,18 @@ namespace octave
     bool has_magic_end (void) const { return false; }
 
     void print (std::ostream& os, bool pr_as_read_syntax = false,
                 bool pr_orig_txt = true);
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
-    tree_funcall *dup (symbol_table::scope_id,
-                       symbol_table::context_id context) const;
+    tree_funcall * dup (symbol_table::scope_id,
+                        symbol_table::context_id context) const;
 
     octave_value function (void) const { return fcn; }
 
     octave_value_list arguments (void) const { return args; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_funcall (*this);
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -117,18 +117,18 @@ namespace octave
     void eval_undefined_error (void);
 
     void static_workspace_error (void)
     {
       error ("can not add variable \"%s\" to a static workspace",
              name ().c_str ());
     }
 
-    tree_identifier *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_identifier * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_identifier (*this);
     }
 
     symbol_table::symbol_reference symbol (void) const
     {
@@ -148,18 +148,18 @@ namespace octave
       : tree_identifier (l, c) { }
 
     std::string name (void) const { return "~"; }
 
     bool is_variable (void) const { return false; }
 
     bool is_black_hole (void) { return true; }
 
-    tree_black_hole *dup (symbol_table::scope_id,
-                          symbol_table::context_id) const
+    tree_black_hole * dup (symbol_table::scope_id,
+                           symbol_table::context_id) const
     {
       return new tree_black_hole;
     }
 
     octave_lvalue lvalue (tree_evaluator *)
     {
       return octave_lvalue (); // black hole lvalue
     }
diff --git a/libinterp/parse-tree/pt-idx.h b/libinterp/parse-tree/pt-idx.h
--- a/libinterp/parse-tree/pt-idx.h
+++ b/libinterp/parse-tree/pt-idx.h
@@ -73,34 +73,34 @@ namespace octave
     void append (const std::string& n);
 
     void append (tree_expression *df);
 
     bool is_index_expression (void) const { return true; }
 
     std::string name (void) const;
 
-    tree_expression *expression (void) { return expr; }
+    tree_expression * expression (void) { return expr; }
 
     std::list<tree_argument_list *> arg_lists (void) { return args; }
 
     std::string type_tags (void) { return type; }
 
     std::list<string_vector> arg_names (void) { return arg_nm; }
 
     std::list<tree_expression *> dyn_fields (void) { return dyn_field; }
 
     bool lvalue_ok (void) const { return expr->lvalue_ok (); }
 
     bool rvalue_ok (void) const { return true; }
 
     octave_lvalue lvalue (tree_evaluator *tw);
 
-    tree_index_expression *dup (symbol_table::scope_id scope,
-                                symbol_table::context_id context) const;
+    tree_index_expression * dup (symbol_table::scope_id scope,
+                                 symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_index_expression (*this);
     }
 
     std::string
     get_struct_index
diff --git a/libinterp/parse-tree/pt-jit.h b/libinterp/parse-tree/pt-jit.h
--- a/libinterp/parse-tree/pt-jit.h
+++ b/libinterp/parse-tree/pt-jit.h
@@ -46,17 +46,17 @@ public:
 
   jit_convert (tree& tee, jit_type *for_bounds = 0);
 
   jit_convert (octave_user_function& fcn, const std::vector<jit_type *>& args);
 
 #define DECL_ARG(n) const ARG ## n& arg ## n
 #define JIT_CREATE_CHECKED(N)                                           \
   template <OCT_MAKE_DECL_LIST (typename, ARG, N)>                      \
-  jit_call *create_checked (OCT_MAKE_LIST (DECL_ARG, N))                \
+  jit_call * create_checked (OCT_MAKE_LIST (DECL_ARG, N))               \
   {                                                                     \
     jit_call *ret = factory.create<jit_call> (OCT_MAKE_ARG_LIST (arg, N)); \
     return create_checked_impl (ret);                                   \
   }
 
   JIT_CREATE_CHECKED (1)
   JIT_CREATE_CHECKED (2)
   JIT_CREATE_CHECKED (3)
@@ -193,72 +193,72 @@ private:
   size_t iterator_count;
   size_t for_bounds_count;
   size_t short_count;
 
   variable_map vmap;
 
   void initialize (symbol_table::scope_id s);
 
-  jit_call *create_checked_impl (jit_call *ret);
+  jit_call * create_checked_impl (jit_call *ret);
 
   // get an existing vairable.  If the variable does not exist, it will not be
   // created
-  jit_variable *find_variable (const std::string& vname) const;
+  jit_variable * find_variable (const std::string& vname) const;
 
   // get a variable, create it if it does not exist.  The type will default to
   // the variable's current type in the symbol table.
-  jit_variable *get_variable (const std::string& vname);
+  jit_variable * get_variable (const std::string& vname);
 
   // create a variable of the given name and given type.  Will also insert an
   // extract statement
-  jit_variable *create_variable (const std::string& vname, jit_type *type,
-                                 bool isarg = true);
+  jit_variable * create_variable (const std::string& vname, jit_type *type,
+                                  bool isarg = true);
 
   // The name of the next for loop iterator.  If inc is false, then the
   // iterator counter will not be incremented.
   std::string next_iterator (bool inc = true)
   { return next_name ("#iter", iterator_count, inc); }
 
   std::string next_for_bounds (bool inc = true)
   { return next_name ("#for_bounds", for_bounds_count, inc); }
 
   std::string next_shortcircut_result (bool inc = true)
   { return next_name ("#shortcircut_result", short_count, inc); }
 
   std::string next_name (const char *prefix, size_t& count, bool inc);
 
-  jit_instruction *resolve (tree_index_expression& exp,
-                            jit_value *extra_arg = 0, bool lhs = false);
+  jit_instruction * resolve (tree_index_expression& exp,
+                             jit_value *extra_arg = 0, bool lhs = false);
 
-  jit_value *do_assign (tree_expression *exp, jit_value *rhs,
-                        bool artificial = false);
+  jit_value * do_assign (tree_expression *exp, jit_value *rhs,
+                         bool artificial = false);
 
-  jit_value *do_assign (const std::string& lhs, jit_value *rhs, bool print,
-                        bool artificial = false);
+  jit_value * do_assign (const std::string& lhs, jit_value *rhs, bool print,
+                         bool artificial = false);
 
-  jit_value *visit (tree *tee) { return visit (*tee); }
+  jit_value * visit (tree *tee) { return visit (*tee); }
 
-  jit_value *visit (tree& tee);
+  jit_value * visit (tree& tee);
 
   typedef std::list<jit_block *> block_list;
   block_list breaks;
   block_list continues;
 
   void finish_breaks (jit_block *dest, const block_list& lst);
 };
 
 // Convert from the low level Octave IR to LLVM
 class
 jit_convert_llvm : public jit_ir_walker
 {
 public:
-  llvm::Function *convert_loop (llvm::Module *module,
-                                const jit_block_list& blocks,
-                                const std::list<jit_value *>& constants);
+  llvm::Function * convert_loop (llvm::Module *module,
+                                 const jit_block_list& blocks,
+                                 const std::list<jit_value *>& constants);
 
   jit_function convert_function (llvm::Module *module,
                                  const jit_block_list& blocks,
                                  const std::list<jit_value *>& constants,
                                  octave_user_function& fcn,
                                  const std::vector<jit_type *>& args);
 
   // arguments to the llvm::Function for loops
@@ -361,19 +361,19 @@ public:
   static bool execute (tree_simple_for_command& cmd,
                        const octave_value& bounds);
 
   static bool execute (tree_while_command& cmd);
 
   static bool execute (octave_user_function& fcn, const octave_value_list& args,
                        octave_value_list& retval);
 
-  llvm::ExecutionEngine *get_engine (void) const { return engine; }
+  llvm::ExecutionEngine * get_engine (void) const { return engine; }
 
-  llvm::Module *get_module (void) const { return module; }
+  llvm::Module * get_module (void) const { return module; }
 
   void optimize (llvm::Function *fn);
 private:
   tree_jit (void);
 
   static tree_jit& instance (void);
 
   bool initialize (void);
diff --git a/libinterp/parse-tree/pt-jump.h b/libinterp/parse-tree/pt-jump.h
--- a/libinterp/parse-tree/pt-jump.h
+++ b/libinterp/parse-tree/pt-jump.h
@@ -43,18 +43,18 @@ namespace octave
     // No copying!
 
     tree_break_command (const tree_break_command&) = delete;
 
     tree_break_command& operator = (const tree_break_command&) = delete;
 
     ~tree_break_command (void) = default;
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_break_command (*this);
     }
 
     static int breaking;
   };
@@ -71,18 +71,18 @@ namespace octave
     // No copying!
 
     tree_continue_command (const tree_continue_command&) = delete;
 
     tree_continue_command& operator = (const tree_continue_command&) = delete;
 
     ~tree_continue_command (void) = default;
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_continue_command (*this);
     }
 
     static int continuing;
   };
@@ -99,18 +99,18 @@ namespace octave
     // No copying!
 
     tree_return_command (const tree_return_command&) = delete;
 
     tree_return_command& operator = (const tree_return_command&) = delete;
 
     ~tree_return_command (void) = default;
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_return_command (*this);
     }
 
     static int returning;
   };
diff --git a/libinterp/parse-tree/pt-loop.h b/libinterp/parse-tree/pt-loop.h
--- a/libinterp/parse-tree/pt-loop.h
+++ b/libinterp/parse-tree/pt-loop.h
@@ -79,35 +79,35 @@ namespace octave
     // No copying!
 
     tree_while_command (const tree_while_command&) = delete;
 
     tree_while_command& operator = (const tree_while_command&) = delete;
 
     ~tree_while_command (void);
 
-    tree_expression *condition (void) { return expr; }
+    tree_expression * condition (void) { return expr; }
 
-    tree_statement_list *body (void) { return list; }
+    tree_statement_list * body (void) { return list; }
 
-    octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list *trailing_comment (void) { return trail_comm; }
+    octave_comment_list * trailing_comment (void) { return trail_comm; }
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_while_command (*this);
     }
 
 #if defined (HAVE_LLVM)
     // some functions use by tree_jit
-    jit_info *get_info (void) const
+    jit_info * get_info (void) const
     {
       return compiled;
     }
 
     void stash_info (jit_info *jinfo)
     {
       compiled = jinfo;
     }
@@ -159,18 +159,18 @@ namespace octave
     // No copying!
 
     tree_do_until_command (const tree_do_until_command&) = delete;
 
     tree_do_until_command& operator = (const tree_do_until_command&) = delete;
 
     ~tree_do_until_command (void) = default;
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_do_until_command (*this);
     }
   };
 
   // For.
@@ -207,39 +207,39 @@ namespace octave
     tree_simple_for_command (const tree_simple_for_command&) = delete;
 
     tree_simple_for_command& operator = (const tree_simple_for_command&) = delete;
 
     ~tree_simple_for_command (void);
 
     bool in_parallel (void) { return parallel; }
 
-    tree_expression *left_hand_side (void) { return lhs; }
+    tree_expression * left_hand_side (void) { return lhs; }
 
-    tree_expression *control_expr (void) { return expr; }
+    tree_expression * control_expr (void) { return expr; }
 
-    tree_expression *maxproc_expr (void) { return maxproc; }
+    tree_expression * maxproc_expr (void) { return maxproc; }
 
-    tree_statement_list *body (void) { return list; }
+    tree_statement_list * body (void) { return list; }
 
-    octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list *trailing_comment (void) { return trail_comm; }
+    octave_comment_list * trailing_comment (void) { return trail_comm; }
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_simple_for_command (*this);
     }
 
 #if defined (HAVE_LLVM)
     // some functions use by tree_jit
-    jit_info *get_info (void) const
+    jit_info * get_info (void) const
     {
       return compiled;
     }
 
     void stash_info (jit_info *jinfo)
     {
       compiled = jinfo;
     }
@@ -294,28 +294,28 @@ namespace octave
     // No copying!
 
     tree_complex_for_command (const tree_complex_for_command&) = delete;
 
     tree_complex_for_command& operator = (const tree_complex_for_command&) = delete;
 
     ~tree_complex_for_command (void);
 
-    tree_argument_list *left_hand_side (void) { return lhs; }
+    tree_argument_list * left_hand_side (void) { return lhs; }
 
-    tree_expression *control_expr (void) { return expr; }
+    tree_expression * control_expr (void) { return expr; }
 
-    tree_statement_list *body (void) { return list; }
+    tree_statement_list * body (void) { return list; }
 
-    octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list *trailing_comment (void) { return trail_comm; }
+    octave_comment_list * trailing_comment (void) { return trail_comm; }
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_complex_for_command (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-mat.h b/libinterp/parse-tree/pt-mat.h
--- a/libinterp/parse-tree/pt-mat.h
+++ b/libinterp/parse-tree/pt-mat.h
@@ -61,18 +61,18 @@ namespace octave
     tree_matrix& operator = (const tree_matrix&) = delete;
 
     ~tree_matrix (void) = default;
 
     bool is_matrix (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_matrix (*this);
     }
   };
 
   extern std::string
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -79,18 +79,18 @@ namespace octave
     bool takes_varargs (void) const { return marked_for_varargs != 0; }
 
     bool varargs_only (void) { return (marked_for_varargs < 0); }
 
     bool is_defined (void);
 
     std::list<std::string> variable_names (void) const;
 
-    tree_parameter_list *dup (symbol_table::scope_id scope,
-                              symbol_table::context_id context) const;
+    tree_parameter_list * dup (symbol_table::scope_id scope,
+                               symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_parameter_list (*this);
     }
 
   private:
 
@@ -115,18 +115,18 @@ namespace octave
     // No copying!
 
     tree_return_list (const tree_return_list&) = delete;
 
     tree_return_list& operator = (const tree_return_list&) = delete;
 
     ~tree_return_list (void);
 
-    tree_return_list *dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_return_list * dup (symbol_table::scope_id scope,
+                            symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_return_list (*this);
     }
   };
 
   class tree_va_return_list : public octave::base_list<octave_value>
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -59,24 +59,24 @@ namespace octave
     tree_if_clause (const tree_if_clause&) = delete;
 
     tree_if_clause& operator = (const tree_if_clause&) = delete;
 
     ~tree_if_clause (void);
 
     bool is_else_clause (void) { return ! expr; }
 
-    tree_expression *condition (void) { return expr; }
+    tree_expression * condition (void) { return expr; }
 
-    tree_statement_list *commands (void) { return list; }
+    tree_statement_list * commands (void) { return list; }
 
-    octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list * leading_comment (void) { return lead_comm; }
 
-    tree_if_clause *dup (symbol_table::scope_id scope,
-                         symbol_table::context_id context) const;
+    tree_if_clause * dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_if_clause (*this);
     }
 
   private:
 
@@ -109,18 +109,18 @@ namespace octave
       while (! empty ())
         {
           iterator p = begin ();
           delete *p;
           erase (p);
         }
     }
 
-    tree_if_command_list *dup (symbol_table::scope_id scope,
-                               symbol_table::context_id context) const;
+    tree_if_command_list * dup (symbol_table::scope_id scope,
+                                symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_if_command_list (*this);
     }
   };
 
   class tree_if_command : public tree_command
@@ -137,24 +137,24 @@ namespace octave
     // No copying!
 
     tree_if_command (const tree_if_command&) = delete;
 
     tree_if_command& operator = (const tree_if_command&) = delete;
 
     ~tree_if_command (void);
 
-    tree_if_command_list *cmd_list (void) { return list; }
+    tree_if_command_list * cmd_list (void) { return list; }
 
-    octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list *trailing_comment (void) { return trail_comm; }
+    octave_comment_list * trailing_comment (void) { return trail_comm; }
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_if_command (*this);
     }
 
   private:
 
@@ -191,24 +191,24 @@ namespace octave
     tree_switch_case (const tree_switch_case&) = delete;
 
     tree_switch_case& operator = (const tree_switch_case&) = delete;
 
     ~tree_switch_case (void);
 
     bool is_default_case (void) { return ! label; }
 
-    tree_expression *case_label (void) { return label; }
+    tree_expression * case_label (void) { return label; }
 
-    tree_statement_list *commands (void) { return list; }
+    tree_statement_list * commands (void) { return list; }
 
-    octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list * leading_comment (void) { return lead_comm; }
 
-    tree_switch_case *dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_switch_case * dup (symbol_table::scope_id scope,
+                            symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_switch_case (*this);
     }
 
   private:
 
@@ -241,18 +241,18 @@ namespace octave
       while (! empty ())
         {
           iterator p = begin ();
           delete *p;
           erase (p);
         }
     }
 
-    tree_switch_case_list *dup (symbol_table::scope_id scope,
-                                symbol_table::context_id context) const;
+    tree_switch_case_list * dup (symbol_table::scope_id scope,
+                                 symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_switch_case_list (*this);
     }
   };
 
   class tree_switch_command : public tree_command
@@ -272,26 +272,26 @@ namespace octave
     // No copying!
 
     tree_switch_command (const tree_switch_command&) = delete;
 
     tree_switch_command& operator = (const tree_switch_command&) = delete;
 
     ~tree_switch_command (void);
 
-    tree_expression *switch_value (void) { return expr; }
+    tree_expression * switch_value (void) { return expr; }
 
-    tree_switch_case_list *case_list (void) { return list; }
+    tree_switch_case_list * case_list (void) { return list; }
 
-    octave_comment_list *leading_comment (void) { return lead_comm; }
+    octave_comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list *trailing_comment (void) { return trail_comm; }
+    octave_comment_list * trailing_comment (void) { return trail_comm; }
 
-    tree_command *dup (symbol_table::scope_id scope,
-                       symbol_table::context_id context) const;
+    tree_command * dup (symbol_table::scope_id scope,
+                        symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_switch_command (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -82,38 +82,38 @@ namespace octave
 
     int line (void) const;
     int column (void) const;
 
     void set_location (int l, int c);
 
     void echo_code (void);
 
-    tree_command *command (void) { return cmd; }
+    tree_command * command (void) { return cmd; }
 
-    tree_expression *expression (void) { return expr; }
+    tree_expression * expression (void) { return expr; }
 
-    octave_comment_list *comment_text (void) { return comm; }
+    octave_comment_list * comment_text (void) { return comm; }
 
     bool is_null_statement (void) const { return ! (cmd || expr || comm); }
 
     bool is_end_of_fcn_or_script (void) const;
 
     bool is_end_of_file (void) const;
 
     // Allow modification of this statement.  Note that there is no
     // checking.  If you use these, are you sure you knwo what you are
     // doing?
 
     void set_command (tree_command *c) { cmd = c; }
 
     void set_expression (tree_expression *e) { expr = e; }
 
-    tree_statement *dup (symbol_table::scope_id scope,
-                         symbol_table::context_id context) const;
+    tree_statement * dup (symbol_table::scope_id scope,
+                          symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_statement (*this);
     }
 
   private:
 
@@ -180,18 +180,18 @@ namespace octave
     std::list<bp_type> breakpoints_and_conds (void);
 
     bp_table::intmap add_breakpoint (const std::string& file,
                                      const bp_table::intmap& line,
                                      const std::string& condition);
 
     bp_table::intmap remove_all_breakpoints (const std::string& file);
 
-    tree_statement_list *dup (symbol_table::scope_id scope,
-                              symbol_table::context_id context) const;
+    tree_statement_list * dup (symbol_table::scope_id scope,
+                               symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_statement_list (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-unop.h b/libinterp/parse-tree/pt-unop.h
--- a/libinterp/parse-tree/pt-unop.h
+++ b/libinterp/parse-tree/pt-unop.h
@@ -61,17 +61,17 @@ namespace octave
     tree_unary_expression& operator = (const tree_unary_expression&) = delete;
 
     ~tree_unary_expression (void) { delete op; }
 
     bool is_unary_expression (void) const { return true; }
 
     bool has_magic_end (void) const { return (op && op->has_magic_end ()); }
 
-    tree_expression *operand (void) { return op; }
+    tree_expression * operand (void) { return op; }
 
     std::string oper (void) const;
 
     octave_value::unary_op op_type (void) const { return etype; }
 
   protected:
 
     // The operand for the expression.
@@ -100,18 +100,18 @@ namespace octave
     tree_prefix_expression (const tree_prefix_expression&) = delete;
 
     tree_prefix_expression& operator = (const tree_prefix_expression&) = delete;
 
     ~tree_prefix_expression (void) = default;
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_prefix_expression (*this);
     }
 
     std::string profiler_name (void) const { return "prefix " + oper (); }
   };
@@ -135,18 +135,18 @@ namespace octave
     tree_postfix_expression (const tree_postfix_expression&) = delete;
 
     tree_postfix_expression& operator = (const tree_postfix_expression&) = delete;
 
     ~tree_postfix_expression (void) = default;
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression *dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope_id scope,
+                           symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_postfix_expression (*this);
     }
 
     std::string profiler_name (void) const { return "postfix " + oper (); }
   };
diff --git a/libinterp/parse-tree/token.h b/libinterp/parse-tree/token.h
--- a/libinterp/parse-tree/token.h
+++ b/libinterp/parse-tree/token.h
@@ -106,17 +106,17 @@ namespace octave
       return m_type_tag == sym_rec_token;
     }
 
     std::string text (void) const;
     std::string symbol_name (void) const;
     double number (void) const;
     token_type ttype (void) const;
     end_tok_type ettype (void) const;
-    symbol_table::symbol_record *sym_rec (void) const;
+    symbol_table::symbol_record * sym_rec (void) const;
 
     std::string superclass_method_name (void) const;
     std::string superclass_class_name (void) const;
 
     std::string text_rep (void) const;
 
   private:
 
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -395,17 +395,17 @@ public:
 
     return dest + nr*nc;
   }
 
 private:
 
   // Recursive N-D generalized transpose
   template <typename T>
-  T *do_permute (const T *src, T *dest, int lev) const
+  T * do_permute (const T *src, T *dest, int lev) const
   {
     if (lev == 0)
       {
         octave_idx_type step = stride[0];
         octave_idx_type len = dim[0];
         if (step == 1)
           {
             std::copy_n (src, len, dest);
@@ -561,34 +561,34 @@ public:
   rec_index_helper& operator = (const rec_index_helper&) = delete;
 
   ~rec_index_helper (void) { delete [] idx; delete [] dim; }
 
 private:
 
   // Recursive N-D indexing
   template <typename T>
-  T *do_index (const T *src, T *dest, int lev) const
+  T * do_index (const T *src, T *dest, int lev) const
   {
     if (lev == 0)
       dest += idx[0].index (src, dim[0], dest);
     else
       {
         octave_idx_type nn = idx[lev].length (dim[lev]);
         octave_idx_type d = cdim[lev];
         for (octave_idx_type i = 0; i < nn; i++)
           dest = do_index (src + d*idx[lev].xelem (i), dest, lev-1);
       }
 
     return dest;
   }
 
   // Recursive N-D indexed assignment
   template <typename T>
-  const T *do_assign (const T *src, T *dest, int lev) const
+  const T * do_assign (const T *src, T *dest, int lev) const
   {
     if (lev == 0)
       src += idx[0].assign (src, dim[0], dest);
     else
       {
         octave_idx_type nn = idx[lev].length (dim[lev]);
         octave_idx_type d = cdim[lev];
         for (octave_idx_type i = 0; i < nn; i++)
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -580,21 +580,21 @@ public:
 
   bool is_vector (void) const { return dimensions.is_vector (); }
 
   bool is_nd_vector (void) const { return dimensions.is_nd_vector (); }
 
   Array<T> transpose (void) const;
   Array<T> hermitian (T (*fcn) (const T&) = 0) const;
 
-  const T *data (void) const { return slice_data; }
+  const T * data (void) const { return slice_data; }
 
-  const T *fortran_vec (void) const { return data (); }
+  const T * fortran_vec (void) const { return data (); }
 
-  T *fortran_vec (void);
+  T * fortran_vec (void);
 
   bool is_shared (void) { return rep->count > 1; }
 
   int ndims (void) const { return dimensions.ndims (); }
 
   //@{
   //! Indexing without resizing.
   Array<T> index (const idx_vector& i) const;
@@ -704,17 +704,17 @@ public:
       }
   }
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
   //! Give a pointer to the data in mex format.  Unsafe.  This function
   //! exists to support the MEX interface.  You should not use it
   //! anywhere else.
-  void *mex_get_data (void) const { return const_cast<T *> (data ()); }
+  void * mex_get_data (void) const { return const_cast<T *> (data ()); }
 
   Array<T> sort (int dim = 0, sortmode mode = ASCENDING) const;
   Array<T> sort (Array<octave_idx_type> &sidx, int dim = 0,
                  sortmode mode = ASCENDING) const;
 
   //! Ordering is auto-detected or can be specified.
   sortmode is_sorted (sortmode mode = UNSORTED) const;
 
@@ -842,23 +842,23 @@ public:
   //! Returns true if this->dims () == dv, and if so, replaces this->dimensions
   //! by a shallow copy of dv.  This is useful for maintaining several arrays
   //! with supposedly equal dimensions (e.g. structs in the interpreter).
   bool optimize_dimensions (const dim_vector& dv);
 
   //@{
   //! WARNING: Only call these functions from jit
 
-  int *jit_ref_count (void) { return rep->count.get (); }
+  int * jit_ref_count (void) { return rep->count.get (); }
 
-  T *jit_slice_data (void) const { return slice_data; }
+  T * jit_slice_data (void) const { return slice_data; }
 
-  octave_idx_type *jit_dimensions (void) const { return dimensions.to_jit (); }
+  octave_idx_type * jit_dimensions (void) const { return dimensions.to_jit (); }
 
-  void *jit_array_rep (void) const { return rep; }
+  void * jit_array_rep (void) const { return rep; }
   //@}
 
 private:
   static void instantiation_guard ();
 };
 
 // We use a variadic template for template template parameter so that
 // we don't have to specify all the template parameters and limit this
diff --git a/liboctave/array/DiagArray2.h b/liboctave/array/DiagArray2.h
--- a/liboctave/array/DiagArray2.h
+++ b/liboctave/array/DiagArray2.h
@@ -168,21 +168,21 @@ public:
     resize (n, m, Array<T>::resize_fill_value ());
   }
 
   DiagArray2<T> transpose (void) const;
   DiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const;
 
   Array<T> array_value (void) const;
 
-  const T *data (void) const { return Array<T>::data (); }
+  const T * data (void) const { return Array<T>::data (); }
 
-  const T *fortran_vec (void) const { return Array<T>::fortran_vec (); }
+  const T * fortran_vec (void) const { return Array<T>::fortran_vec (); }
 
-  T *fortran_vec (void) { return Array<T>::fortran_vec (); }
+  T * fortran_vec (void) { return Array<T>::fortran_vec (); }
 
   void print_info (std::ostream& os, const std::string& prefix) const
   { Array<T>::print_info (os, prefix); }
 
 private:
 
   bool check_idx (octave_idx_type r, octave_idx_type c) const;
 };
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -556,24 +556,24 @@ public:
   void assign (const idx_vector& i, const Sparse<T>& rhs);
 
   void assign (const idx_vector& i, const idx_vector& j, const Sparse<T>& rhs);
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
   // Unsafe.  These functions exist to support the MEX interface.
   // You should not use them anywhere else.
-  void *mex_get_data (void) const { return const_cast<T *> (data ()); }
+  void * mex_get_data (void) const { return const_cast<T *> (data ()); }
 
-  octave_idx_type *mex_get_ir (void) const
+  octave_idx_type * mex_get_ir (void) const
   {
     return const_cast<octave_idx_type *> (ridx ());
   }
 
-  octave_idx_type *mex_get_jc (void) const
+  octave_idx_type * mex_get_jc (void) const
   {
     return const_cast<octave_idx_type *> (cidx ());
   }
 
   Sparse<T> sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const;
   Sparse<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                   sortmode mode = ASCENDING) const;
 
diff --git a/liboctave/array/dim-vector.h b/liboctave/array/dim-vector.h
--- a/liboctave/array/dim-vector.h
+++ b/liboctave/array/dim-vector.h
@@ -90,42 +90,42 @@ dim_vector
 private:
 
   octave_idx_type *rep;
 
   octave_idx_type& count (void) const { return rep[-2]; }
 
   //! Construct a new rep with count = 1 and ndims given.
 
-  static octave_idx_type *newrep (int ndims)
+  static octave_idx_type * newrep (int ndims)
   {
     octave_idx_type *r = new octave_idx_type [ndims + 2];
 
     *r++ = 1;
     *r++ = ndims;
 
     return r;
   }
 
   //! Clone this->rep.
 
-  octave_idx_type *clonerep (void)
+  octave_idx_type * clonerep (void)
   {
     int nd = ndims ();
 
     octave_idx_type* r = newrep (nd);
 
     std::copy_n (rep, nd, r);
 
     return r;
   }
 
   //! Clone and resize this->rep to length n, filling by given value.
 
-  octave_idx_type *resizerep (int n, octave_idx_type fill_value)
+  octave_idx_type * resizerep (int n, octave_idx_type fill_value)
   {
     int nd = ndims ();
 
     if (n < 2)
       n = 2;
 
     octave_idx_type* r = newrep (n);
 
@@ -243,17 +243,17 @@ public:
         while (nd > 2 && rep[nd-1] == 1);
         rep[-1] = nd;
       }
   }
 
   void chop_all_singletons (void);
 
   // WARNING: Only call by jit
-  octave_idx_type *to_jit (void) const
+  octave_idx_type * to_jit (void) const
   {
     return rep;
   }
 
 private:
 
   static octave_idx_type *nil_rep (void);
 
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -94,19 +94,19 @@ private:
 
     // The maximum index + 1.  The actual dimension is passed in.
     virtual octave_idx_type extent (octave_idx_type n) const = 0;
 
     // Index class.
     virtual idx_class_type idx_class (void) const { return class_invalid; }
 
     // Sorts, maybe uniqifies, and returns a clone object pointer.
-    virtual idx_base_rep *sort_uniq_clone (bool uniq = false) = 0;
+    virtual idx_base_rep * sort_uniq_clone (bool uniq = false) = 0;
     // Sorts, and returns a sorting permutation (aka Array::sort).
-    virtual idx_base_rep *sort_idx (Array<octave_idx_type>&) = 0;
+    virtual idx_base_rep * sort_idx (Array<octave_idx_type>&) = 0;
 
     // Checks whether the index is colon or a range equivalent to colon.
     virtual bool is_colon_equiv (octave_idx_type) const { return false; }
 
     // The original dimensions of object (used when subscribing by matrices).
     virtual dim_vector orig_dimensions (void) const { return dim_vector (); }
 
     // i/o
@@ -139,20 +139,20 @@ private:
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type n) const { return n; }
 
     octave_idx_type extent (octave_idx_type n) const { return n; }
 
     idx_class_type idx_class (void) const { return class_colon; }
 
-    idx_base_rep *sort_uniq_clone (bool = false)
+    idx_base_rep * sort_uniq_clone (bool = false)
     { count++; return this; }
 
-    OCTAVE_NORETURN idx_base_rep *sort_idx (Array<octave_idx_type>&);
+    OCTAVE_NORETURN idx_base_rep * sort_idx (Array<octave_idx_type>&);
 
     bool is_colon_equiv (octave_idx_type) const { return true; }
 
     std::ostream& print (std::ostream& os) const;
   };
 
   // To distinguish the "direct" constructors that blindly trust the data.
   enum direct { DIRECT };
@@ -190,19 +190,19 @@ private:
     octave_idx_type extent (octave_idx_type n) const
     {
       return len ? std::max (n, start + 1 + (step < 0 ? 0 : step * (len - 1)))
                  : n;
     }
 
     idx_class_type idx_class (void) const { return class_range; }
 
-    idx_base_rep *sort_uniq_clone (bool uniq = false);
+    idx_base_rep * sort_uniq_clone (bool uniq = false);
 
-    idx_base_rep *sort_idx (Array<octave_idx_type>&);
+    idx_base_rep * sort_idx (Array<octave_idx_type>&);
 
     bool is_colon_equiv (octave_idx_type n) const
     { return start == 0 && step == 1 && len == n; }
 
     dim_vector orig_dimensions (void) const
     { return dim_vector (1, len); }
 
     octave_idx_type get_start (void) const { return start; }
@@ -248,20 +248,20 @@ private:
 
     octave_idx_type length (octave_idx_type) const { return 1; }
 
     octave_idx_type extent (octave_idx_type n) const
     { return std::max (n, data + 1); }
 
     idx_class_type idx_class (void) const { return class_scalar; }
 
-    idx_base_rep *sort_uniq_clone (bool = false)
+    idx_base_rep * sort_uniq_clone (bool = false)
     { count++; return this; }
 
-    idx_base_rep *sort_idx (Array<octave_idx_type>&);
+    idx_base_rep * sort_idx (Array<octave_idx_type>&);
 
     bool is_colon_equiv (octave_idx_type n) const
     { return n == 1 && data == 0; }
 
     dim_vector orig_dimensions (void) const { return dim_vector (1, 1); }
 
     octave_idx_type get_data (void) const { return data; }
 
@@ -321,23 +321,23 @@ private:
 
     octave_idx_type length (octave_idx_type) const { return len; }
 
     octave_idx_type extent (octave_idx_type n) const
     { return std::max (n, ext); }
 
     idx_class_type idx_class (void) const { return class_vector; }
 
-    idx_base_rep *sort_uniq_clone (bool uniq = false);
+    idx_base_rep * sort_uniq_clone (bool uniq = false);
 
-    idx_base_rep *sort_idx (Array<octave_idx_type>&);
+    idx_base_rep * sort_idx (Array<octave_idx_type>&);
 
     dim_vector orig_dimensions (void) const { return orig_dims; }
 
-    const octave_idx_type *get_data (void) const { return data; }
+    const octave_idx_type * get_data (void) const { return data; }
 
     std::ostream& print (std::ostream& os) const;
 
     Array<double> unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
 
   private:
@@ -390,27 +390,27 @@ private:
 
     octave_idx_type length (octave_idx_type) const { return len; }
 
     octave_idx_type extent (octave_idx_type n) const
     { return std::max (n, ext); }
 
     idx_class_type idx_class (void) const { return class_mask; }
 
-    idx_base_rep *sort_uniq_clone (bool = false)
+    idx_base_rep * sort_uniq_clone (bool = false)
     { count++; return this; }
 
-    idx_base_rep *sort_idx (Array<octave_idx_type>&);
+    idx_base_rep * sort_idx (Array<octave_idx_type>&);
 
     dim_vector orig_dimensions (void) const { return orig_dims; }
 
     bool is_colon_equiv (octave_idx_type n) const
     { return len == n && ext == n; }
 
-    const bool *get_data (void) const { return data; }
+    const bool * get_data (void) const { return data; }
 
     std::ostream& print (std::ostream& os) const;
 
     Array<bool> unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
 
   private:
@@ -1020,17 +1020,17 @@ public:
   void unconvert (idx_class_type& iclass,
                   double& scalar, Range& range,
                   Array<double>& array, Array<bool>& mask) const;
 
   Array<octave_idx_type> as_array (void) const;
 
   // Raw pointer to index array.  This is non-const because it may be
   // necessary to mutate the index.
-  const octave_idx_type *raw (void);
+  const octave_idx_type * raw (void);
 
   bool is_vector (void) const;
 
   // FIXME: these are here for compatibility.  They should be removed
   // when no longer in use.
 
   octave_idx_type elem (octave_idx_type n) const
   { return (*this) (n); }
diff --git a/liboctave/numeric/sparse-chol.cc b/liboctave/numeric/sparse-chol.cc
--- a/liboctave/numeric/sparse-chol.cc
+++ b/liboctave/numeric/sparse-chol.cc
@@ -81,17 +81,17 @@ namespace octave
         if (Lsparse)
           CHOLMOD_NAME (free_sparse) (&Lsparse, &Common);
 
         CHOLMOD_NAME(finish) (&Common);
 #endif
       }
 
 #if defined (HAVE_CHOLMOD)
-      cholmod_sparse *L (void) const
+      cholmod_sparse * L (void) const
       {
         return Lsparse;
       }
 #endif
 
       octave_idx_type P (void) const
       {
 #if defined (HAVE_CHOLMOD)
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -46,17 +46,17 @@ along with Octave; see the file COPYING.
 #if defined (USE_READLINE)
 #include <cstdio>
 
 #include "oct-rl-edit.h"
 #endif
 
 namespace octave
 {
-  char *do_completer_word_break_hook ();
+  char * do_completer_word_break_hook ();
 
   command_editor *command_editor::instance = 0;
 
   std::set<command_editor::startup_hook_fcn> command_editor::startup_hook_set;
 
   std::set<command_editor::pre_input_hook_fcn> command_editor::pre_input_hook_set;
 
   std::set<command_editor::event_hook_fcn> command_editor::event_hook_set;
@@ -83,21 +83,21 @@ namespace octave
     ~gnu_readline (void) = default;
 
     void do_set_name (const std::string& n);
 
     std::string do_readline (const std::string& prompt, bool& eof);
 
     void do_set_input_stream (FILE *f);
 
-    FILE *do_get_input_stream (void);
+    FILE * do_get_input_stream (void);
 
     void do_set_output_stream (FILE *f);
 
-    FILE *do_get_output_stream (void);
+    FILE * do_get_output_stream (void);
 
     void do_redisplay (void);
 
     int do_terminal_rows (void);
 
     int do_terminal_cols (void);
 
     void do_clear_screen (bool skip_redisplay);
@@ -216,28 +216,28 @@ namespace octave
     dequoting_fcn dequoting_function;
 
     char_is_quoted_fcn char_is_quoted_function;
 
     user_accept_line_fcn user_accept_line_function;
 
     static std::string completer_quote_characters;
 
-    static char *command_generator (const char *text, int state);
+    static char * command_generator (const char *text, int state);
 
-    static char *command_quoter (char *text, int match_type, char *quote_pointer);
-    static char *command_dequoter (char *text, int match_type);
+    static char * command_quoter (char *text, int match_type, char *quote_pointer);
+    static char * command_dequoter (char *text, int match_type);
 
     static int command_char_is_quoted (char *text, int index);
 
     static int command_accept_line (int count, int key);
 
-    static char **command_completer (const char *text, int start, int end);
+    static char ** command_completer (const char *text, int start, int end);
 
-    static char *do_completer_word_break_hook ();
+    static char * do_completer_word_break_hook ();
   };
 
   std::string gnu_readline::completer_quote_characters = "";
 
   gnu_readline::gnu_readline ()
     : command_editor (), previous_startup_hook (0),
       previous_pre_input_hook (0),
       previous_event_hook (0), completion_function (0),
@@ -930,21 +930,21 @@ namespace octave
     default_command_editor& operator = (const default_command_editor&) = delete;
 
     ~default_command_editor (void) = default;
 
     std::string do_readline (const std::string& prompt, bool& eof);
 
     void do_set_input_stream (FILE *f);
 
-    FILE *do_get_input_stream (void);
+    FILE * do_get_input_stream (void);
 
     void do_set_output_stream (FILE *f);
 
-    FILE *do_get_output_stream (void);
+    FILE * do_get_output_stream (void);
 
     string_vector do_generate_filename_completions (const std::string& text);
 
     std::string do_get_line_buffer (void) const;
 
     std::string do_get_current_line (void) const;
 
     char do_get_prev_char (int) const;
diff --git a/liboctave/util/cmd-edit.h b/liboctave/util/cmd-edit.h
--- a/liboctave/util/cmd-edit.h
+++ b/liboctave/util/cmd-edit.h
@@ -74,21 +74,21 @@ namespace octave
     static void set_name (const std::string& n);
 
     static std::string readline (const std::string& prompt);
 
     static std::string readline (const std::string& prompt, bool& eof);
 
     static void set_input_stream (FILE *f);
 
-    static FILE *get_input_stream (void);
+    static FILE * get_input_stream (void);
 
     static void set_output_stream (FILE *f);
 
-    static FILE *get_output_stream (void);
+    static FILE * get_output_stream (void);
 
     static void redisplay (void);
 
     static int terminal_rows (void);
 
     static int terminal_cols (void);
 
     static void clear_screen (bool skip_redisplay = false);
@@ -234,21 +234,21 @@ namespace octave
 
       return do_readline (prompt, eof);
     }
 
     virtual std::string do_readline (const std::string&, bool&) = 0;
 
     virtual void do_set_input_stream (FILE *) = 0;
 
-    virtual FILE *do_get_input_stream (void) = 0;
+    virtual FILE * do_get_input_stream (void) = 0;
 
     virtual void do_set_output_stream (FILE *) = 0;
 
-    virtual FILE *do_get_output_stream (void) = 0;
+    virtual FILE * do_get_output_stream (void) = 0;
 
     virtual void do_redisplay (void) { }
 
     virtual int do_terminal_rows (void) { return 24; }
 
     virtual int do_terminal_cols (void) { return 80; }
 
     virtual void do_clear_screen (bool) { }
diff --git a/liboctave/util/lo-array-errwarn.cc b/liboctave/util/lo-array-errwarn.cc
--- a/liboctave/util/lo-array-errwarn.cc
+++ b/liboctave/util/lo-array-errwarn.cc
@@ -178,17 +178,17 @@ namespace octave
 #if defined (OCTAVE_ENABLE_64)
       return "subscripts must be either integers 1 to (2^63)-1 or logicals";
 #else
       return "subscripts must be either integers 1 to (2^31)-1 or logicals";
 #endif
     }
 
     // ID of error to throw
-    const char *err_id (void) const
+    const char * err_id (void) const
     {
       return error_id_invalid_index;
     }
   };
 
   // Complain if an index is negative, fractional, or too big.
 
   void
@@ -248,17 +248,17 @@ namespace octave
           buf << extent;
           expl = "out of bound " + buf.str ();
         }
 
       return expl;
     }
 
     // ID of error to throw.
-    const char *err_id (void) const
+    const char * err_id (void) const
     {
       return error_id_index_out_of_bounds;
     }
 
     void set_size (const dim_vector& size_in) { size = size_in; }
 
     void set_extent (octave_idx_type ext) { extent = ext; }
 
diff --git a/liboctave/util/lo-array-errwarn.h b/liboctave/util/lo-array-errwarn.h
--- a/liboctave/util/lo-array-errwarn.h
+++ b/liboctave/util/lo-array-errwarn.h
@@ -52,17 +52,17 @@ namespace octave
     // Erroneous index value.  Called in what, and by external code
     // (e.g., nth_element) to make a custom error message.
     std::string idx (void) const { return index; }
 
     // details set by subclass.
     virtual std::string details (void) const = 0;
 
     // ID of error to throw.
-    virtual const char *err_id (void) const = 0;
+    virtual const char * err_id (void) const = 0;
 
     virtual std::string message (void) const;
 
     // Position of error: dimension in error, and number of dimensions.
     void set_pos (octave_idx_type nd_arg, octave_idx_type dim_arg)
     {
       nd = nd_arg;
       dim = dim_arg;
diff --git a/liboctave/util/lo-array-gripes.cc b/liboctave/util/lo-array-gripes.cc
--- a/liboctave/util/lo-array-gripes.cc
+++ b/liboctave/util/lo-array-gripes.cc
@@ -122,17 +122,17 @@ namespace octave
 #if defined (OCTAVE_ENABLE_64)
       return "subscripts must be either integers 1 to (2^63)-1 or logicals";
 #else
       return "subscripts must be either integers 1 to (2^31)-1 or logicals";
 #endif
     }
 
     // ID of error to throw
-    const char *err_id (void) const
+    const char * err_id (void) const
     {
       return error_id_invalid_index;
     }
   };
 }
 
 // Complain if an index is negative, fractional, or too big.
 
@@ -215,17 +215,17 @@ namespace octave
           buf << extent;
           expl = "out of bound " + buf.str ();
         }
 
       return expl;
     }
 
     // ID of error to throw.
-    const char *err_id (void) const
+    const char * err_id (void) const
     {
       return error_id_index_out_of_bounds;
     }
 
     void set_size (const dim_vector& size_in) { size = size_in; }
 
     void set_extent (octave_idx_type ext) { extent = ext; }
 
diff --git a/liboctave/util/lo-utils.h b/liboctave/util/lo-utils.h
--- a/liboctave/util/lo-utils.h
+++ b/liboctave/util/lo-utils.h
@@ -69,17 +69,17 @@ extern OCTAVE_API bool xtoo_large_for_fl
 
 extern OCTAVE_API bool xtoo_large_for_float (const Complex&  x);
 
 extern OCTAVE_API bool xis_int_or_inf_or_nan (float x);
 extern OCTAVE_API bool xis_one_or_zero (float x);
 extern OCTAVE_API bool xis_zero (float x);
 extern OCTAVE_API bool xtoo_large_for_float (float x);
 
-extern OCTAVE_API char *strsave (const char *);
+extern OCTAVE_API char * strsave (const char *);
 
 extern OCTAVE_API void
 octave_putenv (const std::string&, const std::string&);
 
 extern OCTAVE_API std::string octave_fgets (std::FILE *);
 extern OCTAVE_API std::string octave_fgetl (std::FILE *);
 
 extern OCTAVE_API std::string octave_fgets (std::FILE *, bool& eof);
diff --git a/liboctave/util/oct-inttypes.h b/liboctave/util/oct-inttypes.h
--- a/liboctave/util/oct-inttypes.h
+++ b/liboctave/util/oct-inttypes.h
@@ -946,24 +946,24 @@ public:
 
   static octave_int<T> min (void) { return std::numeric_limits<T>::min (); }
   static octave_int<T> max (void) { return std::numeric_limits<T>::max (); }
 
   static int nbits (void) { return std::numeric_limits<T>::digits; }
 
   static int byte_size (void) { return sizeof (T); }
 
-  static const char *type_name ();
+  static const char * type_name ();
 
   // The following are provided for convenience.
   static const octave_int zero, one;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
-  void *mex_get_data (void) const { return const_cast<T *> (&ival); }
+  void * mex_get_data (void) const { return const_cast<T *> (&ival); }
 
 private:
 
   T ival;
 };
 
 template <typename T>
 inline octave_int<T>
diff --git a/liboctave/util/oct-locbuf.h b/liboctave/util/oct-locbuf.h
--- a/liboctave/util/oct-locbuf.h
+++ b/liboctave/util/oct-locbuf.h
@@ -82,17 +82,17 @@ namespace octave
     // No copying!
 
     chunk_buffer (const chunk_buffer&) = delete;
 
     chunk_buffer& operator = (const chunk_buffer&) = delete;
 
     OCTAVE_API virtual ~chunk_buffer (void);
 
-    char *data (void) const { return dat; }
+    char * data (void) const { return dat; }
 
     static OCTAVE_API void clear (void);
 
   private:
 
     // The number of bytes we allocate for each large chunk of memory we
     // manage.
     static const size_t chunk_size;
diff --git a/liboctave/util/oct-refcount.h b/liboctave/util/oct-refcount.h
--- a/liboctave/util/oct-refcount.h
+++ b/liboctave/util/oct-refcount.h
@@ -101,17 +101,17 @@ namespace octave
       return OCTAVE_ATOMIC_POST_DECREMENT (&count);
     }
 
     operator count_type (void) const
     {
       return static_cast<count_type const volatile&> (count);
     }
 
-    count_type *get (void)
+    count_type * get (void)
     {
       return &count;
     }
 
   private:
 
     count_type count;
   };
diff --git a/liboctave/util/oct-rl-edit.h b/liboctave/util/oct-rl-edit.h
--- a/liboctave/util/oct-rl-edit.h
+++ b/liboctave/util/oct-rl-edit.h
@@ -75,65 +75,65 @@ extern void octave_rl_clear_screen (int 
 extern void octave_rl_resize_terminal (void);
 
 extern void octave_rl_resize_terminal (void);
 
 extern void octave_rl_set_screen_size (int ht, int wd);
 
 extern void octave_rl_restore_terminal_state (void);
 
-extern char *octave_rl_copy_line (void);
+extern char * octave_rl_copy_line (void);
 
 extern void octave_rl_replace_line (const char *s, int clear_undo);
 
 extern void octave_rl_kill_full_line (void);
 
 extern void octave_rl_insert_text (const char *);
 
 extern int octave_rl_newline (int, int);
 
-extern const char *octave_rl_line_buffer (void);
+extern const char * octave_rl_line_buffer (void);
 
 extern int octave_rl_point (void);
 
 extern int octave_rl_do_undo (void);
 
 extern void octave_rl_clear_undo_list (void);
 
 extern void octave_rl_set_name (const char *);
 
-extern char *octave_rl_readline (const char *);
+extern char * octave_rl_readline (const char *);
 
 extern void octave_rl_set_input_stream (FILE *);
 
-extern FILE *octave_rl_get_input_stream (void);
+extern FILE * octave_rl_get_input_stream (void);
 
 extern void octave_rl_set_output_stream (FILE *);
 
-extern FILE *octave_rl_get_output_stream (void);
+extern FILE * octave_rl_get_output_stream (void);
 
 extern void octave_rl_read_init_file (const char *);
 
 extern void octave_rl_re_read_init_file (void);
 
 extern int octave_rl_filename_completion_desired (int);
 
 extern int octave_rl_filename_quoting_desired (int);
 
 extern int octave_rl_prefer_env_winsize (int);
 
 extern void octave_rl_done (int);
 
-extern char *octave_rl_filename_completion_function (const char *, int);
+extern char * octave_rl_filename_completion_function (const char *, int);
 
 extern void octave_rl_set_basic_word_break_characters (const char *);
 
 extern void octave_rl_set_completer_word_break_characters (const char *);
 
-extern char *octave_rl_get_completer_word_break_characters (void);
+extern char * octave_rl_get_completer_word_break_characters (void);
 
 extern void octave_rl_set_completion_word_break_hook (rl_completion_hook_fcn_ptr);
 
 extern void octave_rl_set_basic_quote_characters (const char *);
 
 extern void octave_rl_set_filename_quote_characters (const char *);
 
 extern void octave_rl_set_completer_quote_characters (const char *);
diff --git a/liboctave/util/oct-rl-hist.h b/liboctave/util/oct-rl-hist.h
--- a/liboctave/util/oct-rl-hist.h
+++ b/liboctave/util/oct-rl-hist.h
@@ -66,21 +66,21 @@ extern int octave_write_history (const c
 extern int octave_append_history (int, const char *);
 
 extern int octave_history_truncate_file (const char *, int);
 
 extern void octave_remove_history (int);
 
 extern void octave_clear_history (void);
 
-extern char *octave_history_goto_mark (int n);
+extern char * octave_history_goto_mark (int n);
 
-extern char *octave_history_get (int n);
+extern char * octave_history_get (int n);
 
-extern char **octave_history_list (int, int);
+extern char ** octave_history_list (int, int);
 
 extern void octave_replace_history_entry (int, const char *);
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -37,19 +37,19 @@ along with Octave; see the file COPYING.
 #endif
 
 extern "C"
 {
 #if defined (HAVE_DLOPEN_API)
 #  if defined (HAVE_DLFCN_H)
 #    include <dlfcn.h>
 #  else
-extern void *dlopen (const char *, int);
-extern const char *dlerror (void);
-extern void *dlsym (void *, const char *);
+extern void * dlopen (const char *, int);
+extern const char * dlerror (void);
+extern void * dlsym (void *, const char *);
 extern int dlclose (void *);
 #  endif
 #elif defined (HAVE_SHL_LOAD_API)
 #  include <dl.h>
 #elif defined (HAVE_LOADLIBRARY_API)
 #  define WIN32_LEAN_AND_MEAN 1
 #  include <windows.h>
 #endif
@@ -167,18 +167,18 @@ namespace octave
     // No copying!
 
     octave_dlopen_shlib (const octave_dlopen_shlib&) = delete;
 
     octave_dlopen_shlib& operator = (const octave_dlopen_shlib&) = delete;
 
     ~octave_dlopen_shlib (void);
 
-    void *search (const std::string& name,
-                  dynamic_library::name_mangler mangler = 0);
+    void * search (const std::string& name,
+                   dynamic_library::name_mangler mangler = 0);
 
     // FIXME: this is possibly redundant because failure to open a library will
     // normally throw an exception, avoiding the construction of an invalid
     // library.  Leave it here for possible future use.
 
     bool is_open (void) const { return (library != 0); }
 
   private:
@@ -258,18 +258,18 @@ namespace octave
     // No copying!
 
     octave_shl_load_shlib (const octave_shl_load_shlib&) = delete;
 
     octave_shl_load_shlib& operator = (const octave_shl_load_shlib&) = delete;
 
     ~octave_shl_load_shlib (void);
 
-    void *search (const std::string& name,
-                  dynamic_library::name_mangler mangler = 0);
+    void * search (const std::string& name,
+                   dynamic_library::name_mangler mangler = 0);
 
     bool is_open (void) const { return (library != 0); }
 
   private:
 
     shl_t library;
   };
 
@@ -326,18 +326,18 @@ namespace octave
     // No copying!
 
     octave_w32_shlib (const octave_w32_shlib&) = delete;
 
     octave_w32_shlib& operator = (const octave_w32_shlib&) = delete;
 
     ~octave_w32_shlib (void);
 
-    void *search (const std::string& name,
-                  dynamic_library::name_mangler mangler = 0);
+    void * search (const std::string& name,
+                   dynamic_library::name_mangler mangler = 0);
 
     bool is_open (void) const { return (handle != 0); }
 
   private:
 
     HINSTANCE handle;
   };
 
@@ -427,18 +427,18 @@ namespace octave
     octave_dyld_shlib (const octave_dyld_shlib&) = delete;
 
     octave_dyld_shlib& operator = (const octave_dyld_shlib&) = delete;
 
     ~octave_dyld_shlib (void);
 
     void open (const std::string& f);
 
-    void *search (const std::string& name,
-                  dynamic_library::name_mangler mangler = 0);
+    void * search (const std::string& name,
+                   dynamic_library::name_mangler mangler = 0);
 
     void close (dynamic_library::close_hook cl_hook = 0);
 
     bool is_open (void) const {return (handle != 0); }
 
   private:
 
     NSObjectFileImage img;
diff --git a/liboctave/util/oct-shlib.h b/liboctave/util/oct-shlib.h
--- a/liboctave/util/oct-shlib.h
+++ b/liboctave/util/oct-shlib.h
@@ -59,25 +59,25 @@ namespace octave
       virtual ~dynlib_rep (void)
       {
         instances.erase (file);
       }
 
       virtual bool is_open (void) const
       { return false; }
 
-      virtual void *search (const std::string&, name_mangler = 0)
+      virtual void * search (const std::string&, name_mangler = 0)
       { return 0; }
 
       bool is_out_of_date (void) const;
 
       // This method will be overridden conditionally.
-      static dynlib_rep *new_instance (const std::string& f);
+      static dynlib_rep * new_instance (const std::string& f);
 
-      static dynlib_rep *get_instance (const std::string& f, bool fake);
+      static dynlib_rep * get_instance (const std::string& f, bool fake);
 
       octave::sys::time time_loaded (void) const
       { return tm_loaded; }
 
       std::string file_name (void) const
       { return file; }
 
       size_t num_fcn_names (void) const { return fcn_names.size (); }
@@ -156,17 +156,17 @@ namespace octave
     void close (close_hook cl_hook = 0)
     {
       if (cl_hook)
         rep->do_close_hook (cl_hook);
 
       *this = dynamic_library ();
     }
 
-    void *search (const std::string& nm, name_mangler mangler = 0) const
+    void * search (const std::string& nm, name_mangler mangler = 0) const
     {
       void *f = rep->search (nm, mangler);
       if (f)
         rep->add_fcn_name (nm);
 
       return f;
     }
 
diff --git a/liboctave/util/str-vec.h b/liboctave/util/str-vec.h
--- a/liboctave/util/str-vec.h
+++ b/liboctave/util/str-vec.h
@@ -110,17 +110,17 @@ public:
   string_vector& uniq (void);
 
   string_vector& append (const std::string& s);
 
   string_vector& append (const string_vector& sv);
 
   std::string join (const std::string& sep = "") const;
 
-  char **c_str_vec (void) const;
+  char ** c_str_vec (void) const;
 
   std::list<std::string> std_list (void) const;
 
   static void delete_c_str_vec (const char * const*);
 
   std::ostream&
   list_in_columns (std::ostream&, int width = 0,
                    const std::string& prefix = "") const;
diff --git a/liboctave/wrappers/canonicalize-file-name-wrapper.h b/liboctave/wrappers/canonicalize-file-name-wrapper.h
--- a/liboctave/wrappers/canonicalize-file-name-wrapper.h
+++ b/liboctave/wrappers/canonicalize-file-name-wrapper.h
@@ -22,15 +22,15 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_canonicalize_file_name_wrapper_h)
 #define octave_canonicalize_file_name_wrapper_h 1
 
 #if defined __cplusplus
 extern "C" {
 #endif
 
-extern char *octave_canonicalize_file_name_wrapper (const char *name);
+extern char * octave_canonicalize_file_name_wrapper (const char *name);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
diff --git a/liboctave/wrappers/dirent-wrappers.h b/liboctave/wrappers/dirent-wrappers.h
--- a/liboctave/wrappers/dirent-wrappers.h
+++ b/liboctave/wrappers/dirent-wrappers.h
@@ -26,19 +26,19 @@ along with Octave; see the file COPYING.
 #if ! defined (__cplusplus)
 #  include <stdbool.h>
 #endif
 
 #if defined __cplusplus
 extern "C" {
 #endif
 
-extern void *octave_opendir_wrapper (const char *dname);
+extern void * octave_opendir_wrapper (const char *dname);
 
-extern char *octave_readdir_wrapper (void *dir);
+extern char * octave_readdir_wrapper (void *dir);
 
 extern void octave_rewinddir_wrapper (void *dir);
 
 extern int octave_closedir_wrapper (void *dir);
 
 extern unsigned int octave_name_max_wrapper (void);
 
 #if defined __cplusplus
diff --git a/liboctave/wrappers/getopt-wrapper.h b/liboctave/wrappers/getopt-wrapper.h
--- a/liboctave/wrappers/getopt-wrapper.h
+++ b/liboctave/wrappers/getopt-wrapper.h
@@ -40,17 +40,17 @@ struct octave_getopt_options
 #define octave_optional_arg 2
 
 extern int
 octave_getopt_long_wrapper (int argc, char **argv,
                             const char *shortopts,
                             const struct octave_getopt_options *longopts,
                             int *longind);
 
-extern char *octave_optarg_wrapper (void);
+extern char * octave_optarg_wrapper (void);
 
 extern int octave_optind_wrapper (void);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
diff --git a/liboctave/wrappers/glob-wrappers.h b/liboctave/wrappers/glob-wrappers.h
--- a/liboctave/wrappers/glob-wrappers.h
+++ b/liboctave/wrappers/glob-wrappers.h
@@ -22,29 +22,29 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_glob_wrappers_h)
 #define octave_glob_wrappers_h 1
 
 #if defined __cplusplus
 extern "C" {
 #endif
 
-extern void *octave_create_glob_info_struct (void);
+extern void * octave_create_glob_info_struct (void);
 
 // Does not call globfree.
 extern void octave_destroy_glob_info_struct (void *glob_info);
 
 // We don't need the error function pointer that the system glob
 // function allows.
 extern int
 octave_glob_wrapper (const char *pattern, int flags, void *glob_info);
 
 extern int octave_glob_num_matches (void *glob_info);
 
-extern char **octave_glob_match_list (void *glob_info);
+extern char ** octave_glob_match_list (void *glob_info);
 
 extern void octave_globfree_wrapper (void *glob_info);
 
 extern int octave_glob_nosort_wrapper (void);
 
 extern int
 octave_fnmatch_wrapper (const char *pattern, const char *name, int flags);
 
diff --git a/liboctave/wrappers/localcharset-wrapper.h b/liboctave/wrappers/localcharset-wrapper.h
--- a/liboctave/wrappers/localcharset-wrapper.h
+++ b/liboctave/wrappers/localcharset-wrapper.h
@@ -22,15 +22,15 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_localcharset_wrapper_h)
 #define octave_localcharset_wrapper_h 1
 
 #if defined __cplusplus
 extern "C" {
 #endif
 
-extern const char *octave_locale_charset_wrapper (void);
+extern const char * octave_locale_charset_wrapper (void);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
diff --git a/liboctave/wrappers/set-program-name-wrapper.h b/liboctave/wrappers/set-program-name-wrapper.h
--- a/liboctave/wrappers/set-program-name-wrapper.h
+++ b/liboctave/wrappers/set-program-name-wrapper.h
@@ -22,15 +22,15 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_set_program_name_wrapper_h)
 #define octave_set_program_name_wrapper_h 1
 
 #if defined __cplusplus
 extern "C" {
 #endif
 
-extern const char *octave_set_program_name_wrapper (const char *pname);
+extern const char * octave_set_program_name_wrapper (const char *pname);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
diff --git a/liboctave/wrappers/signal-wrappers.h b/liboctave/wrappers/signal-wrappers.h
--- a/liboctave/wrappers/signal-wrappers.h
+++ b/liboctave/wrappers/signal-wrappers.h
@@ -32,34 +32,34 @@ along with Octave; see the file COPYING.
 #if defined __cplusplus
 extern "C" {
 #endif
 
 typedef void octave_sig_handler (int);
 
 extern int octave_kill_wrapper (pid_t pid, int signum);
 
-extern char *octave_strsignal_wrapper (int signum);
+extern char * octave_strsignal_wrapper (int signum);
 
 extern bool octave_have_kill (void);
 
 extern bool octave_get_sig_number (const char *signame, int *signum);
 
 extern octave_sig_handler *
 octave_set_signal_handler_by_name (const char *signame,
                                    octave_sig_handler *handler,
                                    bool restart_syscalls);
 
 octave_sig_handler *
 octave_set_signal_handler_internal (int sig, octave_sig_handler *handler,
                                     bool restart_syscalls);
 
 extern int octave_num_signals (void);
 
-extern void *octave_block_child (void);
+extern void * octave_block_child (void);
 
 extern void octave_unblock_child (void *context);
 
 extern void octave_block_interrupt_signal (void);
 
 extern void octave_unblock_interrupt_signal (void);
 
 extern void octave_save_signal_mask (void);
diff --git a/liboctave/wrappers/strdup-wrapper.h b/liboctave/wrappers/strdup-wrapper.h
--- a/liboctave/wrappers/strdup-wrapper.h
+++ b/liboctave/wrappers/strdup-wrapper.h
@@ -22,15 +22,15 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_strdup_wrapper_h)
 #define octave_strdup_wrapper_h 1
 
 #if defined __cplusplus
 extern "C" {
 #endif
 
-extern char *octave_strdup_wrapper (const char *str);
+extern char * octave_strdup_wrapper (const char *str);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
diff --git a/liboctave/wrappers/tmpfile-wrapper.h b/liboctave/wrappers/tmpfile-wrapper.h
--- a/liboctave/wrappers/tmpfile-wrapper.h
+++ b/liboctave/wrappers/tmpfile-wrapper.h
@@ -31,15 +31,15 @@ along with Octave; see the file COPYING.
 
 #if defined __cplusplus
 extern "C" {
 #endif
 
 // c++11 provides std::tmpfile but it appears to fail on 64-bit
 // Windows systems.
 
-extern FILE *octave_tmpfile_wrapper (void);
+extern FILE * octave_tmpfile_wrapper (void);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
diff --git a/liboctave/wrappers/unistd-wrappers.h b/liboctave/wrappers/unistd-wrappers.h
--- a/liboctave/wrappers/unistd-wrappers.h
+++ b/liboctave/wrappers/unistd-wrappers.h
@@ -42,29 +42,29 @@ extern int octave_access_w_ok (void);
 extern int octave_access_x_ok (void);
 
 extern int octave_access_wrapper (const char *nm, int mode);
 
 extern int octave_chdir_wrapper (const char *nm);
 
 extern int octave_close_wrapper (int fd);
 
-extern const char *octave_ctermid_wrapper (void);
+extern const char * octave_ctermid_wrapper (void);
 
 extern int octave_dup2_wrapper (int fd1, int fd2);
 
 extern int octave_execv_wrapper (const char *file, char *const *argv);
 
 extern int octave_execvp_wrapper (const char *file, char *const *argv);
 
 extern pid_t octave_fork_wrapper (void);
 
 extern int octave_ftruncate_wrapper (int fd, off_t sz);
 
-extern char *octave_getcwd_wrapper (char *nm, size_t len);
+extern char * octave_getcwd_wrapper (char *nm, size_t len);
 
 extern gid_t octave_getegid_wrapper (void);
 
 extern uid_t octave_geteuid_wrapper (void);
 
 extern gid_t octave_getgid_wrapper (void);
 
 extern int octave_gethostname_wrapper (char *nm, size_t len);
diff --git a/src/display-available.h b/src/display-available.h
--- a/src/display-available.h
+++ b/src/display-available.h
@@ -23,15 +23,15 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_display_available_h)
 #define octave_display_available_h 1
 
 #if defined (__cplusplus)
 #  include <new>
 extern "C" {
 #endif
 
-extern const char *display_available (int *dpy_avail);
+extern const char * display_available (int *dpy_avail);
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
