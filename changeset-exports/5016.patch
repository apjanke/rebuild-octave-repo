# HG changeset patch
# User jwe
# Date 1095821436 0
#      Wed Sep 22 02:50:36 2004 +0000
# Node ID bdbee528295427dc13b1f711ec7e677477a07c72
# Parent  6d481b6e349e8d3cc0993a5ed54b5c3614d7dc39
[project @ 2004-09-22 02:50:35 by jwe]

diff --git a/doc/interpreter/control.txi b/doc/interpreter/control.txi
--- a/doc/interpreter/control.txi
+++ b/doc/interpreter/control.txi
@@ -1,32 +1,32 @@
 @c Copyright (C) 1996, 1997 John W. Eaton
 @c This is part of the Octave manual.
 @c For copying conditions, see the file gpl.texi.
 
 @node Control Theory
 @chapter Control Theory
 
-The Octave Control Systems Toolbox (OCST) was initially developed
+The Octave Control Systems Toolbox (@acronym{OCST}) was initially developed
 by Dr.@: A. Scottedward Hodel 
 @email{a.s.hodel@@eng.auburn.edu} with the assistance
 of his students
 @itemize @bullet
 @item R. Bruce Tenison @email{btenison@@dibbs.net}, 
 @item David C. Clem,
 @item John E. Ingram @email{John.Ingram@@sea.siemans.com}, and 
 @item Kristi McGowan.  
 @end itemize
-This development was supported in part by NASA's Marshall Space Flight 
-Center as part of an in-house CACSD environment.  Additional important 
+This development was supported in part by @acronym{NASA}'s Marshall Space Flight 
+Center as part of an in-house @acronym{CACSD} environment.  Additional important 
 contributions were made by Dr. Kai Mueller @email{mueller@@ifr.ing.tu-bs.de}
 and Jose Daniel Munoz Frias (@code{place.m}).
 
 An on-line menu-driven tutorial is available via @code{DEMOcontrol};
-beginning OCST users should start with this program. 
+beginning @acronym{OCST} users should start with this program. 
 
 @DOCSTRING(DEMOcontrol)
 
 @menu
 * sysstruct::                   
 * sysinterface::                
 * sysdisp::                     
 * blockdiag::                   
@@ -43,37 +43,37 @@ beginning OCST users should start with t
 
 @menu
 * sysstructvars::               
 * sysstructtf::                 
 * sysstructzp::                 
 * sysstructss::                 
 @end menu
 
-The OCST stores all dynamic systems in
+The @acronym{OCST} stores all dynamic systems in
 a single data structure format that can represent continuous systems,
 discrete-systems, and mixed (hybrid) systems in state-space form, and
 can also represent purely continuous/discrete systems in either
 transfer function or pole-zero form. In order to
 provide more flexibility in treatment of discrete/hybrid systems, the
-OCST also keeps a record of which system outputs are sampled.
+@acronym{OCST} also keeps a record of which system outputs are sampled.
 
 Octave structures are accessed with a syntax much like that used
 by the C programming language.  For consistency in
-use of the data structure used in the OCST, it is recommended that
+use of the data structure used in the @acronym{OCST}, it is recommended that
 the system structure access m-files be used (@pxref{sysinterface}).
 Some elements of the data structure are absent depending on the internal
 system representation(s) used.  More than one system representation
-can be used for SISO systems; the OCST m-files ensure that all representations
+can be used for @acronym{SISO} systems; the @acronym{OCST} m-files ensure that all representations
 used are consistent with one another.
 
 @DOCSTRING(sysrepdemo)
 
 @node sysstructvars
-@subsection Variables common to all OCST system formats
+@subsection Variables common to all @acronym{OCST} system formats
 
 The data structure elements (and variable types) common to all  system
 representations are listed below; examples of the initialization
 and use of the system data structures are given in subsequent sections and
 in the online demo @code{DEMOcontrol}.
 @table @var
 @item n
 @itemx nz
@@ -171,17 +171,17 @@ will not accept systems with both discre
 @item stname
 names of system states   (list of strings)
 
 @end table
 
 @node sysinterface
 @section System Construction and Interface Functions
 
-Construction and manipulations of the OCST system data structure
+Construction and manipulations of the @acronym{OCST} system data structure
 (@pxref{sysstruct}) requires attention to many details in order
 to ensure that data structure contents remain consistent.  Users
 are strongly encouraged to use the system interface functions
 in this section.  Functions for the formatted display in of system
 data structures are given in @ref{sysdisp}.
 
 @menu
 * fir2sys::                     
@@ -347,23 +347,23 @@ system data structures.
 @DOCSTRING(zgrownorm)
 
 @DOCSTRING(zgscal)
 
 @DOCSTRING(zgsgiv)
 
 @DOCSTRING(zgshsr)
 
-References:
+@strong{References}
 @table @strong
 @item  ZGEP
- Hodel, "Computation of Zeros with Balancing," 1992, Linear Algebra
+ Hodel, @cite{Computation of Zeros with Balancing}, 1992, Linear Algebra
  and its Applications
 @item @strong{Generalized CG}
- Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
+ Golub and Van Loan, @cite{Matrix Computations, 2nd ed} 1989.
 @end table
 
 @node sysprop
 @section System Analysis-Properties
 
 @DOCSTRING(analdemo)
 
 @DOCSTRING(abcddim)
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -62,85 +62,19 @@ a (1, [1, 2])
 a (1, 1:2)
 a (1, :)
 @end group
 @end example
 
 @noindent
 and select the first row of the matrix.
 
-A special form of indexing may be used to select elements of a matrix or
-vector.  If the indices are vectors made up of only ones and zeros, the
-result is a new matrix whose elements correspond to the elements of the
-index vector that are equal to one.  For example,
-
-@example
-@group
-a = [1, 2; 3, 4];
-a ([1, 0], :)
-@end group
-@end example
-
-@noindent
-selects the first row of the matrix @code{a}.
-
-This operation can be useful for selecting elements of a matrix based on
-some condition, since the comparison operators return matrices of ones
-and zeros.
-
-This special zero-one form of indexing leads to a conflict with the
-standard indexing operation.  For example, should the following
-statements
-
-@example
-@group
-a = [1, 2; 3, 4];
-a ([1, 1], :)
-@end group
-@end example
+@c FIXED -- sections on variable prefer_zero_one_indexing were removed
 
-@noindent
-return the original matrix, or the matrix formed by selecting the first
-row twice?  Although this conflict is not likely to arise very often in
-practice, you may select the behavior you prefer by setting the built-in
-variable @code{prefer_zero_one_indexing}.
-
-@c XXX FIXME XXX -- this variable no longer exists!
-
-@defvr {Built-in Variable} prefer_zero_one_indexing
-If the value of @code{prefer_zero_one_indexing} is nonzero, Octave
-will perform zero-one style indexing when there is a conflict with the
-normal indexing rules.  @xref{Index Expressions}.  For example, given a
-matrix
-
-@example
-a = [1, 2, 3, 4]
-@end example
-
-@noindent
-with @code{prefer_zero_one_indexing} is set to nonzero, the
-expression
-
-@example
-a ([1, 1, 1, 1])
-@end example
-
-@noindent
-results in the matrix @code{[ 1, 2, 3, 4 ]}.  If the value of
-@code{prefer_zero_one_indexing} set to 0, the result would be
-the matrix @code{[ 1, 1, 1, 1 ]}.
-
-In the first case, Octave is selecting each element corresponding to a
-@samp{1} in the index vector.  In the second, Octave is selecting the
-first element multiple times.
-
-The default value for @code{prefer_zero_one_indexing} is 0.
-@end defvr
-
-Finally, indexing a scalar with a vector of ones can be used to create a
+Indexing a scalar with a vector of ones can be used to create a
 vector the same size as the index vector, with each element equal to
 the value of the original scalar.  For example, the following statements
 
 @example
 @group
 a = 13;
 a ([1, 1, 1, 1])
 @end group
@@ -885,17 +819,17 @@ A (3, :) = []
 @noindent
 deletes the third row of @var{A}, and the assignment
 
 @example
 A (:, 1:2:5) = []
 @end example
 
 @noindent
-deletes the first, third, and fifth columns.
+deletes the first, second, and fifth columns.
 
 An assignment is an expression, so it has a value.  Thus, @code{z = 1}
 as an expression has the value 1.  One consequence of this is that you
 can write multiple assignments together:
 
 @example
 x = y = z = 0
 @end example
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -370,17 +370,17 @@ endfunction
 
 Note that this function could not have been written using the
 @code{break} statement to exit the loop once a nonzero value is found
 without adding extra logic to avoid printing the message if the vector
 does contain a nonzero element.
 
 @defvr {Keyword} return
 When Octave encounters the keyword @code{return} inside a function or
-script, it returns control to be caller immediately.  At the top level,
+script, it returns control to the caller immediately. At the top level,
 the return statement is ignored.  A @code{return} statement is assumed
 at the end of every function definition.
 @end defvr
 
 @DOCSTRING(return_last_computed_value)
 
 @node Function Files
 @section Function Files
@@ -662,29 +662,27 @@ All of the Octave's built-in functions d
 arguments, so you can check the source code for those functions for
 examples of various strategies for verifying that the correct number and
 types of arguments have been supplied.
 
 The next statements
 
 @example
 @group
-ColumnVector dx (3);
-
 dx(0) = 77.27 * (x(1) - x(0)*x(1) + x(0)
                  - 8.375e-06*pow (x(0), 2));
 
 dx(1) = (x(2) - x(0)*x(1) - x(1)) / 77.27;
 
 dx(2) = 0.161*(x(0) - x(2));
 @end group
 @end example
 
 @noindent
-define the right hand side of the differential equation.  Finally, we
+define the right-hand side of the differential equation.  Finally, we
 can return @code{dx}:
 
 @example
 return octave_value (dx);
 @end example
 
 @noindent
 The actual return type is @code{octave_value_list}, but it is only
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -119,17 +119,17 @@ carriage return.
 @node Simple File I/O
 @subsection Simple File I/O
 
 The @code{save} and @code{load} commands allow data to be written to and
 read from disk files in various formats.  The default format of files
 written by the @code{save} command can be controlled using the built-in
 variables @code{default_save_format} and @code{save_precision}.
 
-Note that Octave can not yet save or load structure variables or any
+Note that Octave cannot yet save or load structure variables or any
 user-defined types.
 
 @DOCSTRING(save)
 
 There are three variables that modify the behavior of @code{save} and
 three more that control whether variables are saved when Octave exits
 unexpectedly.
 
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -39,17 +39,17 @@ commas.  Each expression may have its ow
 The optional item @var{ranges} has the syntax
 
 @example
 [ x_lo : x_up ] [ y_lo : y_up ]
 @end example
 
 @noindent
 and may be used to specify the ranges for the axes of the plot,
-independent of the actual range of the data.  The range for the y axes
+independent of the actual range of the data.  The range for the y axis
 and any of the individual limits may be omitted.  A range @code{[:]}
 indicates that the default limits should be used.  This normally means
 that a range just large enough to include all the data points will be
 used.
 
 The expression to be plotted must not contain any literal matrices
 (e.g. @code{[ 1, 2; 3, 4 ]}) since it is nearly impossible to
 distinguish a plot range from a matrix of data.
diff --git a/doc/interpreter/struct.txi b/doc/interpreter/struct.txi
--- a/doc/interpreter/struct.txi
+++ b/doc/interpreter/struct.txi
@@ -98,17 +98,20 @@ other structures, only a few levels are 
 @example
 @group
 octave:1> a.b.c.d.e = 1;
 octave:2> a
 a =
 @{
   b =
   @{
-    c = <structure>
+    c =
+    @{
+      d: 1x1 struct
+    @}
   @}
 @}
 @end group
 @end example
 
 @noindent
 This prevents long and confusing output from large deeply nested
 structures.
diff --git a/liboctave/DASPK-opts.in b/liboctave/DASPK-opts.in
--- a/liboctave/DASPK-opts.in
+++ b/liboctave/DASPK-opts.in
@@ -33,17 +33,18 @@ OPTION
   DOC_ITEM
 Relative tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the absolute
 tolerance must also be a vector of the same length.
 
 The local error test applied at each integration step is
 
 @example
-  abs (local error in x(i)) <= rtol(i) * abs (Y(i)) + atol(i)
+  abs (local error in x(i))
+       <= rtol(i) * abs (Y(i)) + atol(i)
 @end example
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
diff --git a/liboctave/DASSL-opts.in b/liboctave/DASSL-opts.in
--- a/liboctave/DASSL-opts.in
+++ b/liboctave/DASSL-opts.in
@@ -33,17 +33,18 @@ OPTION
   DOC_ITEM
 Relative tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the absolute
 tolerance must also be a vector of the same length.
 
 The local error test applied at each integration step is
 
 @example
-  abs (local error in x(i)) <= rtol(i) * abs (Y(i)) + atol(i)
+  abs (local error in x(i))
+       <= rtol(i) * abs (Y(i)) + atol(i)
 @end example
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
diff --git a/liboctave/ODESSA-opts.in b/liboctave/ODESSA-opts.in
--- a/liboctave/ODESSA-opts.in
+++ b/liboctave/ODESSA-opts.in
@@ -31,17 +31,18 @@ OPTION
   NAME = "relative tolerance"
   DOC_ITEM
 Relative tolerance parameter.  Unlike the absolute tolerance, this
 parameter may only be a scalar.
 
 The local error test applied at each integration step is
 
 @example
-  abs (local error in x(i)) <= rtol * abs (y(i)) + atol(i)
+  abs (local error in x(i))
+       <= rtol * abs (y(i)) + atol(i)
 @end example
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "::sqrt (DBL_EPSILON)"
   SET_EXPR = "(val > 0.0) ? val : ::sqrt (DBL_EPSILON)"
 END_OPTION
 
 OPTION
diff --git a/scripts/control/base/DEMOcontrol.m b/scripts/control/base/DEMOcontrol.m
--- a/scripts/control/base/DEMOcontrol.m
+++ b/scripts/control/base/DEMOcontrol.m
@@ -14,44 +14,44 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} DEMOcontrol
 ## Octave Control Systems Toolbox demo/tutorial program.  The demo
-## allows the user to select among several categories of OCST function:
+## allows the user to select among several categories of @acronym{OCST} function:
 ## @example
 ## @group
 ## octave:1> DEMOcontrol
 ## O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X
 ## Octave Controls System Toolbox Demo
 ##
 ##   [ 1] System representation
 ##   [ 2] Block diagram manipulations
 ##   [ 3] Frequency response functions
 ##   [ 4] State space analysis functions
 ##   [ 5] Root locus functions
 ##   [ 6] LQG/H2/Hinfinity functions
 ##   [ 7] End
 ## @end group
 ## @end example
 ## Command examples are interactively run for users to observe the use
-## of OCST functions.
+## of @acronym{OCST} functions.
 ## @end deftypefn
 ## @seealso{Demo Programs: bddemo.m, frdemo.m, analdemo.m,
 ## moddmeo.m, rldemo.m}
 
 ## Author: David Clem
 ## Created: August 15, 1994
 
 function DEMOcontrol ()
 
-  puts ("O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X")
+  puts ("O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X");
 
   while (1)
 
     clc ();
 
     k = 0;
 
     while (k > 8 || k < 1),
diff --git a/scripts/control/base/__bodquist__.m b/scripts/control/base/__bodquist__.m
--- a/scripts/control/base/__bodquist__.m
+++ b/scripts/control/base/__bodquist__.m
@@ -13,17 +13,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{f}, @var{w}, @var{rsys}] =} __bodquist__ (@var{sys}, @var{w}, @var{out_idx}, @var{in_idx})
-## used internally by bode, nyquist; compute system frequency response.
+## Used internally by @command{bode}, @command{nyquist}; compute system frequency response.
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ## input system structure
 ## @item w
 ## range of frequencies; empty if user wants default
 ## @item out_idx
@@ -40,17 +40,17 @@
 ## frequency response of sys; @math{f(ii) = f(omega(ii))}
 ## @item rsys
 ## system with selected inputs and outputs
 ## @end table
 ##
 ## @code{bode}, @code{nichols}, and @code{nyquist} share the same 
 ## introduction, so the common parts are
 ## in __bodquist__.  It contains the part that finds the number of arguments,
-## determines whether or not the system is SISO, and computes the frequency
+## determines whether or not the system is @acronym{SISO}, and computes the frequency
 ## response.  Only the way the response is plotted is different between the
 ## these functions.
 ## @end deftypefn
 
 function [f, w, rsys] = __bodquist__ (sys, w, outputs, inputs, rname)
 
   ## check number of input arguments given
   if (nargin != 5)
diff --git a/scripts/control/base/__freqresp__.m b/scripts/control/base/__freqresp__.m
--- a/scripts/control/base/__freqresp__.m
+++ b/scripts/control/base/__freqresp__.m
@@ -13,32 +13,32 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __freqresp__ (@var{sys}, @var{USEW}, @var{w})
-## Frequency response function - used internally by @code{bode}, @code{nyquist}.
-## minimal argument checking; "do not attempt to do this at home"
+## Frequency response function - used internally by @command{bode}, @command{nyquist}.
+## minimal argument checking; ``do not attempt to do this at home''.
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ## system data structure
 ## @item USEW
 ## returned by @code{freqchkw}
 ## @item optional
 ## must be present if @var{USEW} is true (nonzero)
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item @var{out}
-## vector of finite @math{G(j*w)} entries (or @math{||G(j*w)||} for MIMO)
+## vector of finite @math{G(j*w)} entries (or @math{||G(j*w)||} for @acronym{MIMO})
 ## @item w
 ## vector of corresponding frequencies
 ## @end table
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 11, 1994
 
diff --git a/scripts/control/base/__stepimp__.m b/scripts/control/base/__stepimp__.m
--- a/scripts/control/base/__stepimp__.m
+++ b/scripts/control/base/__stepimp__.m
@@ -15,25 +15,25 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{y}, @var{t}] =} __stepimp__ (@var{sitype}, @var{sys} [, @var{inp}, @var{tstop}, @var{n}])
 ## Impulse or step response for a linear system.
 ## The system can be discrete or multivariable (or both).
-## This m-file contains the "common code" of step and impulse.
+## This m-file contains the ``common code'' of step and impulse.
 ##
-## Produces a plot or the response data for system sys.
+## Produces a plot or the response data for system @var{sys}.
 ##
-## Limited argument checking; "do not attempt to do this at home".
-## Used internally in @code{impulse}, @code{step}. Use @code{step}
-## or @code{impulse} instead.
+## Limited argument checking; ``do not attempt to do this at home''.
+## Used internally in @command{impulse}, @command{step}. Use @command{step}
+## or @command{impulse} instead.
 ## @end deftypefn
-## @seealso{step and impulse}
+## @seealso{step, impulse}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 
 function [y, t] = __stepimp__ (sitype, sys, inp, tstop, n)
 
   if (sitype == 1)         IMPULSE = 0;
diff --git a/scripts/control/base/analdemo.m b/scripts/control/base/analdemo.m
--- a/scripts/control/base/analdemo.m
+++ b/scripts/control/base/analdemo.m
@@ -27,69 +27,69 @@
 
 function analdemo ()
 
   while (1)
     clc
     k=0;
     while(k > 8 || k < 1)
       k = menu("Octave State Space Analysis Demo", ...
-        "System grammians (gram, dgram)", ...
+        "System gramians (gram, dgram)", ...
         "System zeros (tzero)", ...
         "Continuous => Discrete and Discrete => Continuous conversions (c2d,d2c)", ...
         "Algebraic Riccati Equation (are, dare)", ...
         "Balanced realizations (balreal, dbalreal)", ...
         "Open loop truncations via Hankel singular values (balreal, dbalreal)", ...
         "SISO pole placement", ...
         "Return to main demo menu");
     endwhile
     if (k == 1)
       clc
       help dgram
       prompt
 
       clc
-      disp("System Grammians: (see Moore, IEEE T-AC, 1981) \n");
+      disp("System Gramians: (see Moore, IEEE T-AC, 1981) \n");
       disp("Example #1, consider the discrete time state space system:\n");
       a=[1, 5, -8.4; 1.2, -3, 5; 1, 7, 9]
       b=[1, 5; 2, 6; -4.4, 5]
       c=[1, -1.5, 2; 6, -9.8, 1]
       d=0
       prompt
-      disp("\nThe discrete controllability grammian is computed as follows:");
-      cmd = "grammian = dgram(a, b);";
+      disp("\nThe discrete controllability gramian is computed as follows:");
+      cmd = "gramian = dgram(a, b);";
       run_cmd;
       disp("Results:\n");
-      grammian = dgram(a,b)
+      gramian = dgram(a,b)
       disp("Variable Description:\n");
-      disp("grammian => discrete controllability grammian");
+      disp("gramian => discrete controllability gramian");
       disp("a, b => a and b matrices of discrete time system\n");
-      disp("A dual approach may be used to compute the observability grammian.");
+      disp("A dual approach may be used to compute the observability gramian.");
       prompt
       clc
 
       help gram
       prompt
       clc
 
       disp("Example #2, consider the continuous state space system:\n");
       a=[1, 3, -10.2; 3.7, -2, 9; 1, 3, 7]
       b=[1, 12; 6, 2; -3.8, 7]
       c=[1, -1.1, 7; 3, -9.8, 2]
       d=0
       prompt
-      disp("\nThe continuous controllability grammian is computed as follows:");
-      cmd = "grammian = gram(a, b);";
+      disp("\nThe continuous controllability gramian is computed as follows:");
+      cmd = "gramian = gram(a, b);";
       run_cmd;
       disp("Results:\n");
-      grammian = gram(a,b)
+      gramian = gram(a,b)
       disp("Variable Description:\n");
-      disp("grammian => continuous controllability grammian");
+      disp("gramian => continuous controllability gramian");
       disp("a, b => a and b matrices of continuous time system\n");
-      disp("A dual approach may be used to compute the observability grammian.");
+      disp("A dual approach may be used to compute the observability gramian.");
       prompt
       clc
 
 
     elseif (k == 2)
       clc
       help tzero
       prompt
diff --git a/scripts/control/base/are.m b/scripts/control/base/are.m
--- a/scripts/control/base/are.m
+++ b/scripts/control/base/are.m
@@ -12,18 +12,18 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} are (@var{a}, @var{b}, @var{c}, @var{opt})
-## Solve the algebraic Riccati equation
+## @deftypefn {Function File} {@var{x} =} are (@var{a}, @var{b}, @var{c}, @var{opt})
+## Solve the Algebraic Riccati Equation
 ## @iftex
 ## @tex
 ## $$
 ## A^TX + XA - XBX + C = 0
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
@@ -32,33 +32,36 @@
 ## @end example
 ## @end ifinfo
 ##
 ## @strong{Inputs}
 ## @noindent
 ## for identically dimensioned square matrices
 ## @table @var
 ## @item a
-## @var{n}x@var{n} matrix.
+## @var{n} by @var{n} matrix;
 ## @item b
-##   @var{n}x@var{n} matrix or @var{n}x@var{m} matrix; in the latter case
-##   @var{b} is replaced by @math{b:=b*b'}.
+##   @var{n} by @var{n} matrix or @var{n} by @var{m} matrix; in the latter case
+##   @var{b} is replaced by @math{b:=b*b'};
 ## @item c
-##   @var{n}x@var{n} matrix or @var{p}x@var{m} matrix; in the latter case
-##   @var{c} is replaced by @math{c:=c'*c}.
+##   @var{n} by @var{n} matrix or @var{p} by @var{m} matrix; in the latter case
+##   @var{c} is replaced by @math{c:=c'*c};
 ## @item opt
 ## (optional argument; default = @code{"B"}):
 ## String option passed to @code{balance} prior to ordered Schur decomposition.
 ## @end table
 ##
-## @strong{Outputs}
-## @var{x}: solution of the ARE.
+## @strong{Output}
+## @table @var
+## @item x
+## solution of the @acronym{ARE}.
+## @end table
 ##
 ## @strong{Method}
-## Laub's Schur method (IEEE Transactions on
+## Laub's Schur method (@acronym{IEEE} Transactions on
 ## Automatic Control, 1979) is applied to the appropriate Hamiltonian
 ## matrix.
 ##
 ## @end deftypefn
 ## @seealso{balance and dare}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
diff --git a/scripts/control/base/bddemo.m b/scripts/control/base/bddemo.m
--- a/scripts/control/base/bddemo.m
+++ b/scripts/control/base/bddemo.m
@@ -13,17 +13,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} bddemo (@var{inputs})
-## Octave Controls toolbox demo: Block Diagram Manipulations demo
+## Octave Controls toolbox demo: Block Diagram Manipulations demo.
 ## @end deftypefn
 
 ## Author: David Clem
 ## Created: August 15, 1994
 ## Modified by A S Hodel Summer-Fall 1996
 
 function bddemo ()
 
diff --git a/scripts/control/base/bode.m b/scripts/control/base/bode.m
--- a/scripts/control/base/bode.m
+++ b/scripts/control/base/bode.m
@@ -34,17 +34,17 @@
 ##
 ## if @var{sys} is discrete, then bode evaluates G(@code{exp}(jwT)), where
 ## @itemize @bullet
 ## @item @math{T} is the system sampling time
 ## @item @math{G(z)} is the system transfer function.
 ## @end itemize
 ##
 ## @strong{Default} the default frequency range is selected as follows: (These
-## steps are NOT performed if @var{w} is specified)
+## steps are @strong{not} performed if @var{w} is specified)
 ## @enumerate
 ## @item via routine __bodquist__, isolate all poles and zeros away from
 ## @var{w}=0 (@var{jw}=0 or @math{@code{exp}(jwT)}=1) and select the frequency
 ## range based on the breakpoint locations of the frequencies.
 ## @item if @var{sys} is discrete time, the frequency range is limited
 ##               to @math{jwT} in
 ## @ifinfo
 ## [0,2 pi /T]
@@ -86,17 +86,17 @@
 ## bode(sys);
 ## @end example
 ## bode plots the results to the screen.  Descriptive labels are
 ## automatically placed.
 ##
 ## Failure to include a concluding semicolon will yield some garbage
 ## being printed to the screen (@code{ans = []}).
 ##
-## @item If the requested plot is for an MIMO system, mag is set to
+## @item If the requested plot is for an @acronym{MIMO} system, mag is set to
 ## @math{||G(jw)||} or @math{||G(@code{exp}(jwT))||}
 ## and phase information is not computed.
 ## @end enumerate
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 10, 1996
 ## Based on previous code by R. Bruce Tenison, July 13, 1994
diff --git a/scripts/control/base/bode_bounds.m b/scripts/control/base/bode_bounds.m
--- a/scripts/control/base/bode_bounds.m
+++ b/scripts/control/base/bode_bounds.m
@@ -15,19 +15,27 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{wmin}, @var{wmax}] =} bode_bounds (@var{zer}, @var{pol}, @var{dflg}, @var{tsam})
 ## Get default range of frequencies based on cutoff frequencies of system
 ## poles and zeros.
-## Frequency range is the interval [10^wmin,10^wmax]
+## Frequency range is the interval
+## @iftex
+## @tex
+## $ [ 10^{w_{min}}, 10^{w_{max}} ] $
+## @end tex
+## @end iftex
+## @ifinfo
+## [10^@var{wmin}, 10^@var{wmax}]
+## @end ifinfo
 ##
-## Used internally in __freqresp__ (@code{bode}, @code{nyquist})
+## Used internally in @command{__freqresp__} (@command{bode}, @command{nyquist})
 ## @end deftypefn
 
 function [wmin, wmax] = bode_bounds (zer, pol, DIGITAL, tsam)
 
   ## make sure zer,pol are row vectors
   if(!isempty(pol)) pol = reshape(pol,1,length(pol)); endif
   if(!isempty(zer)) zer = reshape(zer,1,length(zer)); endif
 
diff --git a/scripts/control/base/controldemo.m b/scripts/control/base/controldemo.m
--- a/scripts/control/base/controldemo.m
+++ b/scripts/control/base/controldemo.m
@@ -13,17 +13,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} controldemo ()
-## Controls toolbox demo.
+## Control Systems Toolbox demo.
 ## @end deftypefn
 ## @seealso{Demo programs: bddemo, frdemo, analdemo, moddmeo, rldemo}
 
 ## Author: David Clem
 ## Created: August 15, 1994
 
 function controldemo ()
   DEMOcontrol ();
diff --git a/scripts/control/base/ctrb.m b/scripts/control/base/ctrb.m
--- a/scripts/control/base/ctrb.m
+++ b/scripts/control/base/ctrb.m
@@ -14,26 +14,33 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ctrb (@var{sys}, @var{b})
 ## @deftypefnx {Function File} {} ctrb (@var{a}, @var{b})
-## Build controllability matrix
+## Build controllability matrix:
+## @iftex
+## @tex
+## $$ Q_s = [ B AB A^2B \ldots A^{n-1}B ] $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
 ##              2       n-1
 ## Qs = [ B AB A B ... A   B ]
 ## @end example
+## @end ifinfo
 ##
 ## of a system data structure or the pair (@var{a}, @var{b}).
 ##
-## @code{ctrb} forms the controllability matrix.
-## The numerical properties of @code{is_controllable}
+## @command{ctrb} forms the controllability matrix.
+## The numerical properties of @command{is_controllable}
 ## are much better for controllability tests.
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: November 4, 1997
 ## based on is_controllable.m of Scottedward Hodel
 
 function Qs = ctrb (sys, b)
diff --git a/scripts/control/base/damp.m b/scripts/control/base/damp.m
--- a/scripts/control/base/damp.m
+++ b/scripts/control/base/damp.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} damp (@var{p}, @var{tsam})
 ## Displays eigenvalues, natural frequencies and damping ratios
-## of the eigenvalues of a matrix @var{p} or the @math{A}-matrix of a
+## of the eigenvalues of a matrix @var{p} or the @math{A} matrix of a
 ## system @var{p}, respectively.
 ## If @var{p} is a system, @var{tsam} must not be specified.
 ## If @var{p} is a matrix and @var{tsam} is specified, eigenvalues
 ## of @var{p} are assumed to be in @var{z}-domain.
 ## @end deftypefn
 ## @seealso{eig}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
diff --git a/scripts/control/base/dare.m b/scripts/control/base/dare.m
--- a/scripts/control/base/dare.m
+++ b/scripts/control/base/dare.m
@@ -13,64 +13,67 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} dare (@var{a}, @var{b}, @var{q}, @var{r}, @var{opt})
+## @deftypefn {Function File} {@var{x} =} dare (@var{a}, @var{b}, @var{q}, @var{r}, @var{opt})
 ##
 ## Return the solution, @var{x} of the discrete-time algebraic Riccati
 ## equation
 ## @iftex
 ## @tex
 ## $$
-## A^TXA - X + A^TXB (R + B^TXB)^{-1} B^TXA + Q = 0
+## A^TXA - X + A^TXB  (R + B^TXB)^{-1} B^TXA + Q = 0
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## @example
 ## a' x a - x + a' x b (r + b' x b)^(-1) b' x a + q = 0
 ## @end example
 ## @end ifinfo
 ## @noindent
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item a
-## @var{n} by @var{n}.
+## @var{n} by @var{n} matrix;
 ##
 ## @item b
-## @var{n} by @var{m}.
+## @var{n} by @var{m} matrix;
 ##
 ## @item q
-## @var{n} by @var{n}, symmetric positive semidefinite, or @var{p} by @var{n}.
-## In the latter case @math{q:=q'*q} is used.
+## @var{n} by @var{n} matrix, symmetric positive semidefinite, or a @var{p} by @var{n} matrix,
+## In the latter case @math{q:=q'*q} is used;
 ##
 ## @item r
-## @var{m} by @var{m}, symmetric positive definite (invertible).
+## @var{m} by @var{m}, symmetric positive definite (invertible);
 ##
 ## @item opt
 ## (optional argument; default = @code{"B"}):
 ## String option passed to @code{balance} prior to ordered @var{QZ} decomposition.
 ## @end table
 ##
-## @strong{Outputs}
-## @var{x} solution of DARE.
+## @strong{Output}
+## @table @var
+## @item x
+## solution of @acronym{DARE}.
+## @end table
 ##
 ## @strong{Method}
-## Generalized eigenvalue approach (Van Dooren; SIAM J.
+## Generalized eigenvalue approach (Van Dooren; @acronym{SIAM} J.
 ##  Sci. Stat. Comput., Vol 2) applied  to the appropriate symplectic pencil.
 ##
-##  See also: Ran and Rodman, "Stable Hermitian Solutions of Discrete
-##  Algebraic Riccati Equations," Mathematics of Control, Signals and
-##  Systems, Vol 5, no 2 (1992)  pp 165-194.
+##  See also: Ran and Rodman, @cite{Stable Hermitian Solutions of Discrete
+##  Algebraic Riccati Equations}, Mathematics of Control, Signals and
+##  Systems, Vol 5, no 2 (1992), pp 165--194.
 ##
 ## @end deftypefn
 ## @seealso{balance and are}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
diff --git a/scripts/control/base/dcgain.m b/scripts/control/base/dcgain.m
--- a/scripts/control/base/dcgain.m
+++ b/scripts/control/base/dcgain.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dcgain (@var{sys}, @var{tol})
 ## Returns dc-gain matrix. If dc-gain is infinite
 ## an empty matrix is returned.
 ## The argument @var{tol} is an optional tolerance for the condition
-## number of the @math{A}-Matrix in @var{sys} (default @var{tol} = 1.0e-10)
+## number of the @math{A} Matrix in @var{sys} (default @var{tol} = 1.0e-10)
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 1, 1997
 
 function gm = dcgain (sys, tol)
 
   if((nargin < 1) || (nargin > 2) || (nargout > 1))
diff --git a/scripts/control/base/dgram.m b/scripts/control/base/dgram.m
--- a/scripts/control/base/dgram.m
+++ b/scripts/control/base/dgram.m
@@ -13,34 +13,52 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dgram (@var{a}, @var{b})
-## Return controllability grammian of discrete time system
+## Return controllability gramian of discrete time system
+## @iftex
+## @tex
+## $$ x_{k+1} = ax_k + bu_k $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
 ##   x(k+1) = a x(k) + b u(k)
 ## @end example
-##
+## @end ifinfo
+## 
 ## @strong{Inputs}
 ## @table @var
 ## @item a
 ## @var{n} by @var{n} matrix
 ## @item b
 ## @var{n} by @var{m} matrix
 ## @end table
 ##
-## @strong{Outputs}
+## @strong{Output}
+## @table @var
+## @item m 
+## @var{n} by @var{n} matrix, satisfies
+## @iftex
+## @tex
+## $$ ama^T - m + bb^T = 0 $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @var{m} (@var{n} by @var{n}) satisfies
 ## @example
 ##  a m a' - m + b*b' = 0
 ## @end example
+## @end ifinfo
+## @end table
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1995
 
 function m = dgram (a, b)
 
   ## let dlyap do the error checking...
diff --git a/scripts/control/base/dlyap.m b/scripts/control/base/dlyap.m
--- a/scripts/control/base/dlyap.m
+++ b/scripts/control/base/dlyap.m
@@ -18,48 +18,74 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dlyap (@var{a}, @var{b})
 ## Solve the discrete-time Lyapunov equation
 ##
 ## @strong{Inputs}
 ## @table @var
 ##   @item a
-##   @var{n} by @var{n} matrix
+##   @var{n} by @var{n} matrix;
 ##   @item b
 ##   Matrix: @var{n} by @var{n}, @var{n} by @var{m}, or @var{p} by @var{n}.
 ## @end table
 ##
-## @strong{Outputs}
-## @var{x}: matrix satisfying appropriate discrete time Lyapunov equation.
+## @strong{Output}
+## @table @var
+## @item x
+## matrix satisfying appropriate discrete time Lyapunov equation.
+## @end table
+##
 ## Options:
 ## @itemize @bullet
-## @item @var{b} is square: solve @code{a x a' - x + b = 0}
+## @item @var{b} is square: solve 
+## @iftex
+## @tex
+## $$ axa^T - x + b = 0 $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @code{a x a' - x + b = 0}
+## @end ifinfo
 ## @item @var{b} is not square: @var{x} satisfies either
+## @iftex
+## @tex
+## $$ axa^T - x + bb^T = 0 $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
 ## a x a' - x + b b' = 0
 ## @end example
+## @end ifinfo
 ## @noindent
 ## or
+## @iftex
+## @tex
+## $$ a^Txa - x + b^Tb = 0, $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
 ## a' x a - x + b' b = 0,
 ## @end example
+## @end ifinfo
 ## @noindent
 ## whichever is appropriate.
 ## @end itemize
 ##
 ## @strong{Method}
 ## Uses Schur decomposition method as in Kitagawa,
 ## @cite{An Algorithm for Solving the Matrix Equation @math{X = F X F' + S}},
 ## International Journal of Control, Volume 25, Number 5, pages 745--753
 ## (1977).
 ##
 ## Column-by-column solution method as suggested in
 ## Hammarling, @cite{Numerical Solution of the Stable, Non-Negative
-## Definite Lyapunov Equation}, IMA Journal of Numerical Analysis, Volume
+## Definite Lyapunov Equation}, @acronym{IMA} Journal of Numerical Analysis, Volume
 ## 2, pages 303--323 (1982).
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 
 function x = dlyap (a, b)
 
diff --git a/scripts/control/base/dre.m b/scripts/control/base/dre.m
--- a/scripts/control/base/dre.m
+++ b/scripts/control/base/dre.m
@@ -12,40 +12,40 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{tvals}, @var{plist}] =} dre (@var{sys}, @var{q}, @var{r}, @var{qf}, @var{t0}, @var{tf}, @var{ptol}, @var{maxits});
+## @deftypefn {Function File} {[@var{tvals}, @var{plist}] =} dre (@var{sys}, @var{q}, @var{r}, @var{qf}, @var{t0}, @var{tf}, @var{ptol}, @var{maxits})
 ## Solve the differential Riccati equation
 ## @ifinfo
 ## @example
 ##   -d P/dt = A'P + P A - P B inv(R) B' P + Q
 ##   P(tf) = Qf
 ## @end example
 ## @end ifinfo
 ## @iftex
 ## @tex
 ## $$ -{dP \over dt} = A^T P+PA-PBR^{-1}B^T P+Q $$
-## $$ P(t_f) = Qf $$
+## $$ P(t_f) = Q_f $$
 ## @end tex
 ## @end iftex
-## for the LTI system sys.  Solution of standard LTI
-## state feedback optimization
+## for the @acronym{LTI} system sys.  Solution of 
+## standard @acronym{LTI} state feedback optimization
 ## @ifinfo
 ## @example
-##   min \int_@{t_0@}^@{t_f@} x' Q x + u' R u dt + x(t_f)' Qf x(t_f)
+##   min int(t0, tf) ( x' Q x + u' R u ) dt + x(tf)' Qf x(tf)
 ## @end example
 ## @end ifinfo
 ## @iftex
 ## @tex
-## $$ \min \int_{t_0}^{t_f} x^T Q x + u^T R u dt + x(t_f)^T Qf x(t_f) $$
+## $$ \min \int_{t_0}^{t_f} x^T Q x + u^T R u dt + x(t_f)^T Q_f x(t_f) $$
 ## @end tex
 ## @end iftex
 ## optimal input is
 ## @ifinfo
 ## @example
 ##   u = - inv(R) B' P(t) x
 ## @end example
 ## @end ifinfo
@@ -72,25 +72,31 @@
 ## @item maxits
 ## number of refinement iterations (default=10)
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item tvals
 ## time values at which @var{p}(@var{t}) is computed
 ## @item plist
-## list values of @var{p}(@var{t}); @var{plist} @{ @var{ii} @}
-## is @var{p}(@var{tvals}(@var{ii})).
-##
-## @item tvals
+## list values of @var{p}(@var{t}); @var{plist} @{ @var{i} @}
+## is @var{p}(@var{tvals}(@var{i}))
+## @end table
+## @var{tvals} is selected so that:
+## @iftex
+## @tex
+## $$ \Vert plist_{i} - plist_{i-1} \Vert < ptol $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
-## is selected so that || Plist@{ii@} - Plist@{ii-1@} || < Ptol
-## for ii=2:length(tvals)
+## || Plist@{i@} - Plist@{i-1@} || < Ptol
 ## @end example
-## @end table
+## @end ifinfo
+## for every @var{i} between 2 and length(@var{tvals}).
 ## @end deftypefn
 
 function [tvals, Plist] = dre (sys, Q, R, Qf, t0, tf, Ptol, maxits)
 
   if(nargin < 6 | nargin > 8 | nargout != 2)
     usage("[tvals,Plist] = dre(sys,Q,R,Qf,t0,tf{,Ptol})");
   elseif(!isstruct(sys))
     error("sys must be a system data structure")
diff --git a/scripts/control/base/frdemo.m b/scripts/control/base/frdemo.m
--- a/scripts/control/base/frdemo.m
+++ b/scripts/control/base/frdemo.m
@@ -13,17 +13,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} frdemo ()
-## Octave Controls toolbox demo: Frequency Response demo
+## Octave Control Toolbox demo: Frequency Response demo.
 ## @end deftypefn
 
 ## Author: David Clem
 ## Created: August 15, 1994
 ## a s hodel: updated to match new order of ss2zp outputs
 ## J Ingram:  updated for system data structure format August 1996
 
 function frdemo ()
diff --git a/scripts/control/base/freqchkw.m b/scripts/control/base/freqchkw.m
--- a/scripts/control/base/freqchkw.m
+++ b/scripts/control/base/freqchkw.m
@@ -13,17 +13,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} freqchkw (@var{w})
-## Used by @code{__freqresp__} to check that input frequency vector @var{w}
+## Used by @command{__freqresp__} to check that input frequency vector @var{w}
 ## is valid.
 ## Returns boolean value.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996
 
 function USEW = freqchkw (w)
diff --git a/scripts/control/base/gram.m b/scripts/control/base/gram.m
--- a/scripts/control/base/gram.m
+++ b/scripts/control/base/gram.m
@@ -13,17 +13,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} gram (@var{a}, @var{b})
-## Return controllability grammian @var{m} of the continuous time system
+## Return controllability gramian @var{m} of the continuous time system
 ## @math{dx/dt = a x + b u}.
 ##
 ## @var{m} satisfies @math{a m + m a' + b b' = 0}.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 
 function m = gram (a, b)
diff --git a/scripts/control/base/impulse.m b/scripts/control/base/impulse.m
--- a/scripts/control/base/impulse.m
+++ b/scripts/control/base/impulse.m
@@ -31,22 +31,27 @@
 ## Index of input being excited
 ## @item tstop
 ## The argument @var{tstop} (scalar value) denotes the time when the
 ## simulation should end.
 ## @item n
 ## the number of data values.
 ##
 ## Both parameters @var{tstop} and @var{n} can be omitted and will be
-## computed from the eigenvalues of the A-Matrix.
+## computed from the eigenvalues of the A Matrix.
 ## @end table
 ## @strong{Outputs}
-## @var{y}, @var{t}: impulse response
+## @table @var
+## @item y
+## Values of the impulse response.
+## @item t
+## Times of the impulse response.
+## @end table
 ## @end deftypefn
-## @seealso{step and __stepimp__}
+## @seealso{step, __stepimp__}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 ## modified by
 
 function [y, t] = impulse (sys, inp, tstop, n)
 
diff --git a/scripts/control/base/lqg.m b/scripts/control/base/lqg.m
--- a/scripts/control/base/lqg.m
+++ b/scripts/control/base/lqg.m
@@ -33,37 +33,37 @@
 ## @table @var
 ## @item  sys
 ## system data structure
 ## @item  sigw
 ## @itemx  sigv
 ## intensities of independent Gaussian noise processes (as above)
 ## @item  q
 ## @itemx  r
-## state, control weighting respectively.  Control ARE is
+## state, control weighting respectively.  Control @acronym{ARE} is
 ## @item  in_idx
-## names or indices of controlled inputs (see @code{sysidx}, @code{cellidx})
+## names or indices of controlled inputs (see @command{sysidx}, @command{cellidx})
 ##
 ## default: last dim(R) inputs are assumed to be controlled inputs, all
 ## others are assumed to be noise inputs.
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item    k
-## system data structure format LQG optimal controller (Obtain A,B,C
-## matrices with @code{sys2ss}, @code{sys2tf}, or @code{sys2zp} as
-## appropriate)
+## system data structure format @acronym{LQG} optimal controller (Obtain A, B, C
+## matrices with @command{sys2ss}, @command{sys2tf}, or @command{sys2zp} as
+## appropriate).
 ## @item    p1
-## Solution of control (state feedback) algebraic Riccati equation
+## Solution of control (state feedback) algebraic Riccati equation.
 ## @item    q1
-## Solution of estimation algebraic Riccati equation
+## Solution of estimation algebraic Riccati equation.
 ## @item    ee
-## estimator poles
+## Estimator poles.
 ## @item    es
-## controller poles
+## Controller poles.
 ## @end table
 ## @end deftypefn
 ## @seealso{h2syn, lqe, and lqr}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## revised for new system format August 1996
 
diff --git a/scripts/control/base/lqr.m b/scripts/control/base/lqr.m
--- a/scripts/control/base/lqr.m
+++ b/scripts/control/base/lqr.m
@@ -102,18 +102,18 @@
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## (@var{a} - @var{b}@var{k}).
 ## @end ifinfo
 ## @end table
 ##
 ## @strong{Reference}
-## Anderson and Moore, OPTIMAL CONTROL: LINEAR QUADRATIC METHODS,
-## Prentice-Hall, 1990, pp. 56-58
+## Anderson and Moore, @cite{Optimal control: linear quadratic methods},
+## Prentice-Hall, 1990, pp. 56--58.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993.
 
 function [k, p, e] = lqr (a, b, q, r, s)
 
   ## disp("lqr: entry");
diff --git a/scripts/control/base/lsim.m b/scripts/control/base/lsim.m
--- a/scripts/control/base/lsim.m
+++ b/scripts/control/base/lsim.m
@@ -12,31 +12,29 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} lsim (@var{sys}, @var{u}, @var{t}, @var{x0})
-## Produce output for a linear simulation of a system
-##
-## Produces a plot for the output of the system, sys.
+## @deftypefn {Function File} {[@var{y}, @var{x}] =} lsim (@var{sys}, @var{u}, @var{t}, @var{x0})
+## Produce output for a linear simulation of a system; produces 
+## a plot for the output of the system, @var{sys}.
 ##
-## U is an array that contains the system's inputs.  Each row in u
-## corresponds to a different time step.  Each column in u corresponds to a
-## different input.  T is an array that contains the time index of the
-## system.  T should be regularly spaced.  If initial conditions are required
-## on the system, the x0 vector should be added to the argument list.
+## @var{u} is an array that contains the system's inputs.  Each row in @var{u}
+## corresponds to a different time step.  Each column in @var{u} corresponds to a
+## different input.  @var{t} is an array that contains the time index of the
+## system; @var{t} should be regularly spaced.  If initial conditions are required
+## on the system, the @var{x0} vector should be added to the argument list.
 ##
-## When the lsim function is invoked with output parameters:
-## [y,x] = lsim(sys,u,t,[x0])
-## a plot is not displayed, however, the data is returned in y = system output
-## and x = system states.
+## When the lsim function is invoked a plot is not displayed; 
+## however, the data is returned in @var{y} (system output)
+## and @var{x} (system states).
 ## @end deftypefn
 
 ## Author: David Clem
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1995
 ## modified by John Ingram for system format August 1996
 
 function [y, x] = lsim (sys, u, t, x0)
diff --git a/scripts/control/base/ltifr.m b/scripts/control/base/ltifr.m
--- a/scripts/control/base/ltifr.m
+++ b/scripts/control/base/ltifr.m
@@ -12,35 +12,46 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} ltifr (@var{a}, @var{b}, @var{w})
-## @deftypefnx {Function File} {} ltifr (@var{sys}, @var{w})
-## Linear time invariant frequency response of single input systems
+## @deftypefn {Function File} {@var{out} =} ltifr (@var{a}, @var{b}, @var{w})
+## @deftypefnx {Function File} {@var{out} =} ltifr (@var{sys}, @var{w})
+## Linear time invariant frequency response of single-input systems.
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item a
 ## @itemx b
 ## coefficient matrices of @math{dx/dt = A x + B u}
 ## @item sys
 ## system data structure
 ## @item w
 ## vector of frequencies
 ## @end table
-## @strong{Outputs}
-## @var{out}
+## @strong{Output}
+## @table @var
+## @item out
+## frequency response, that is:
+## @end table
+## @iftex
+## @tex
+## $$ G(j\omega) = (j\omegaI-A)^{-1}B $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
 ##                            -1
-##             G(s) = (jw I-A) B
+##              G(s) = (jw I-A) B
 ## @end example
+## @end ifinfo
 ## for complex frequencies @math{s = jw}.
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Author: David Clem
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1995
 ## updated by John Ingram August 1996 for system format
diff --git a/scripts/control/base/lyap.m b/scripts/control/base/lyap.m
--- a/scripts/control/base/lyap.m
+++ b/scripts/control/base/lyap.m
@@ -16,31 +16,31 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} lyap (@var{a}, @var{b}, @var{c})
 ## @deftypefnx {Function File} {} lyap (@var{a}, @var{b})
 ## Solve the Lyapunov (or Sylvester) equation via the Bartels-Stewart
-## algorithm (Communications of the ACM, 1972).
+## algorithm (Communications of the @acronym{ACM}, 1972).
 ##
 ## If @var{a}, @var{b}, and @var{c} are specified, then @code{lyap} returns
 ## the solution of the  Sylvester equation
 ## @iftex
 ## @tex
 ##   $$ A X + X B + C = 0 $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## @example
 ##     a x + x b + c = 0
 ## @end example
 ## @end ifinfo
-## If only @code{(a, b)} are specified, then @code{lyap} returns the
+## If only @code{(a, b)} are specified, then @command{lyap} returns the
 ## solution of the Lyapunov equation
 ## @iftex
 ## @tex
 ##   $$ A^T X + X A + B = 0 $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## @example
diff --git a/scripts/control/base/nichols.m b/scripts/control/base/nichols.m
--- a/scripts/control/base/nichols.m
+++ b/scripts/control/base/nichols.m
@@ -15,45 +15,75 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{mag}, @var{phase}, @var{w}] =} nichols (@var{sys}, @var{w}, @var{outputs}, @var{inputs})
 ## Produce Nichols plot of a system.
 ##
-## inputs:
-##   sys: system data structure (must be either purely continuous or discrete;
-##       see is_digital)
-##   w: frequency values for evaluation.
-##      if sys is continuous, then nichols evaluates G(jw)
-##      if sys is discrete, then nichols evaluates G(exp(jwT)), where T=sys.tsam
-##         (the system sampling time)
-##      default: the default frequency range is selected as follows: (These
-##        steps are NOT performed if w is specified)
-##          (1) via routine __bodquist__, isolate all poles and zeros away from
-##              w=0 (jw=0 or exp(jwT)=1) and select the frequency
-##             range based on the breakpoint locations of the frequencies.
-##          (2) if sys is discrete time, the frequency range is limited
-##              to jwT in [0,2p*pi]
-##          (3) A "smoothing" routine is used to ensure that the plot phase does
-##              not change excessively from point to point and that singular
-##              points (e.g., crossovers from +/- 180) are accurately shown.
-##   outputs, inputs: the names or indices of the output(s) and input(s) 
-##     to be used in the frequency response; see sysprune.
-## outputs:
-##    mag, phase: the magnitude and phase of the frequency response
-##       G(jw) or G(exp(jwT)) at the selected frequency values.
-##    w: the vector of frequency values used
-## If no output arguments are given, nichols plots the results to the screen.
-## Descriptive labels are automatically placed.  See xlabel, ylable, title,
-## and replot.
+## @strong{Inputs}
+## @table @var
+## @item sys
+## System data structure (must be either purely continuous or discrete; 
+## see @command{is_digital}).
+## @item w
+## Frequency values for evaluation.
+## @itemize
+## @item if sys is continuous, then nichols evaluates @math{G(jw)}.
+## @item if sys is discrete, then nichols evaluates @math{G(exp(jwT))}, 
+## where @var{T}=@var{sys}. @var{tsam} is the system sampling time.
+## @item the default frequency range is selected as follows (These
+##        steps are @strong{not} performed if @var{w} is specified):
+## @enumerate
+## @item via routine @command{__bodquist__}, isolate all poles and zeros away from
+## @var{w}=0 (@math{jw=0} or @math{exp(jwT)=1}) and select the frequency range 
+## based on the breakpoint locations of the frequencies.
+## @item if sys is discrete time, the frequency range is limited to jwT in 
+## @iftex
+## @tex
+## $ [0, 2p\pi] $.
+## @end tex
+## @end iftex
+## @ifinfo
+## [0,2p*pi].
+## @end ifinfo
+## @item A ``smoothing'' routine is used to ensure that the plot phase does
+## not change excessively from point to point and that singular points 
+## (e.g., crossovers from +/- 180) are accurately shown.
+## @end enumerate
+## @end itemize
+## @item outputs
+## @itemx inputs
+## the names or indices of the output(s) and input(s) to be used in the 
+## frequency response; see @command{sysprune}.
+## @end table
+## @strong{Outputs}
+## @table @var
+## @item mag
+## @itemx phase
+## The magnitude and phase of the frequency response @math{G(jw)} or 
+## @math{G(exp(jwT))} at the selected frequency values.
+## @item w
+## The vector of frequency values used.
+## @end table
+## If no output arguments are given, @command{nichols} plots the results to the screen.
+## Descriptive labels are automatically placed. See @command{xlabel}, 
+## @command{ylabel}, @command{title}, and @command{replot}.
 ##
-## Note: if the requested plot is for an MIMO system, mag is set to
-## ||G(jw)|| or ||G(exp(jwT))|| and phase information is not computed.
+## Note: if the requested plot is for an @acronym{MIMO} system, @var{mag} is set to
+## @iftex
+## @tex
+## $ \Vert G(jw) \Vert $ or $ \Vert G( {\rm exp}(jwT) \Vert $
+## @end tex
+## @end iftex
+## @ifinfo
+## ||G(jw)|| or ||G(exp(jwT))||
+## @end ifinfo
+## and phase information is not computed.
 ## @end deftypefn
 
 function [mag, phase, w] = nichols (sys, w, outputs, inputs)
 
   ## check number of input arguments given
   if (nargin < 1 | nargin > 4)
     usage("[mag,phase,w] = nichols(sys[,w,outputs,inputs])");
   endif
diff --git a/scripts/control/base/nyquist.m b/scripts/control/base/nyquist.m
--- a/scripts/control/base/nyquist.m
+++ b/scripts/control/base/nyquist.m
@@ -18,75 +18,80 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{realp}, @var{imagp}, @var{w}] =} nyquist (@var{sys}, @var{w}, @var{out_idx}, @var{in_idx}, @var{atol})
 ## @deftypefnx {Function File} {} nyquist (@var{sys}, @var{w}, @var{out_idx}, @var{in_idx}, @var{atol})
 ## Produce Nyquist plots of a system; if no output arguments are given, Nyquist
 ## plot is printed to the screen.
 ##
 ## Compute the frequency response of a system.
+##
 ## @strong{Inputs} (pass as empty to get default values)
 ## @table @var
 ## @item sys
 ## system data structure (must be either purely continuous or discrete;
-## see is_digital)
+## see @code{is_digital})
 ## @item w
 ## frequency values for evaluation.
-## if sys is continuous, then bode evaluates @math{G(jw)}
-## if sys is discrete, then bode evaluates @math{G(exp(jwT))}, where
-## @math{T} is the system sampling time.
+## If sys is continuous, then bode evaluates @math{G(@var{jw})}; 
+## if sys is discrete, then bode evaluates @math{G(exp(@var{jwT}))},
+## where @var{T} is the system sampling time.
 ## @item default
 ## the default frequency range is selected as follows: (These
-## steps are NOT performed if @var{w} is specified)
-## @end table
+## steps are @strong{not} performed if @var{w} is specified)
 ## @enumerate
-## @item via routine __bodquist__, isolate all poles and zeros away from
+## @item via routine @command{__bodquist__}, isolate all poles and zeros away from
 ## @var{w}=0 (@var{jw}=0 or @math{exp(@var{jwT})=1}) and select the frequency
 ## range based on the breakpoint locations of the frequencies.
 ## @item if @var{sys} is discrete time, the frequency range is limited
 ## to @var{jwT} in
 ## @ifinfo
 ## [0,2p*pi]
 ## @end ifinfo
 ## @iftex
-## $[0,2p*\pi]$
+## @tex
+## $ [ 0,2  p \pi ] $
+## @end tex
 ## @end iftex
-## @item A "smoothing" routine is used to ensure that the plot phase does
+## @item A ``smoothing'' routine is used to ensure that the plot phase does
 ## not change excessively from point to point and that singular
 ## points (e.g., crossovers from +/- 180) are accurately shown.
 ## @end enumerate
-## outputs, inputs: names or indices of the output(s) and input(s) to be 
-## used in the frequency response; see sysprune.
-##
-## @strong{Inputs} (pass as empty to get default values)
-## @table @var
 ## @item   atol
 ## for interactive nyquist plots: atol is a change-in-slope tolerance
 ## for the of asymptotes (default = 0; 1e-2 is a good choice).  This allows
 ## the user to ``zoom in'' on portions of the Nyquist plot too small to be
 ## seen with large asymptotes.
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item    realp
 ## @itemx   imagp
 ## the real and imaginary parts of the frequency response
 ## @math{G(jw)} or @math{G(exp(jwT))} at the selected frequency values.
-## @item    w
+## @item w
 ## the vector of frequency values used
 ## @end table
 ##
 ## If no output arguments are given, nyquist plots the results to the screen.
 ## If @var{atol} != 0 and asymptotes are detected then the user is asked
 ## interactively if they wish to zoom in (remove asymptotes)
 ## Descriptive labels are automatically placed.
 ##
-## Note: if the requested plot is for an MIMO system, a warning message is
+## Note: if the requested plot is for an @acronym{MIMO} system, a warning message is
 ## presented; the returned information is of the magnitude
-## ||G(jw)|| or ||G(exp(jwT))|| only; phase information is not computed.
+## @iftex
+## @tex
+## $ \Vert G(jw) \Vert $ or $ \Vert G( {\rm exp}(jwT) \Vert $
+## @end tex
+## @end iftex
+## @ifinfo
+## ||G(jw)|| or ||G(exp(jwT))||
+## @end ifinfo
+## only; phase information is not computed.
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 13, 1994
 ## A. S. Hodel July 1995 (adaptive frequency spacing,
 ##     remove acura parameter, etc.)
 ## Revised by John Ingram July 1996 for system format
 
diff --git a/scripts/control/base/obsv.m b/scripts/control/base/obsv.m
--- a/scripts/control/base/obsv.m
+++ b/scripts/control/base/obsv.m
@@ -12,32 +12,42 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-##@deftypefn {Function File} {} obsv (@var{sys}, @var{c})
-## Build observability matrix
+## @deftypefn {Function File} {} obsv (@var{sys}, @var{c})
+## @deftypefnx {Function File} {} obsv (@var{a}, @var{c})
+## Build observability matrix:
+## @iftex
+## @tex
+## $$ Q_b = \left[ \matrix{  C       \cr
+##                           CA    \cr
+##                           CA^2  \cr
+##                           \vdots  \cr
+##                           CA^{n-1} } \right ] $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
 ## @group
 ##      | C        |
 ##      | CA       |
 ## Qb = | CA^2     |
 ##      | ...      |
 ##      | CA^(n-1) |
 ## @end group
 ## @end example
-## of a system data structure or the pair (A, C).
+## @end ifinfo
+## of a system data structure or the pair (@var{a}, @var{c}).
 ##
-## Note: @code{obsv()} forms the observability matrix.
-##
-## The numerical properties of is_observable()
+## The numerical properties of @command{is_observable}
 ## are much better for observability tests.
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: November 4, 1997
 
 function Qb = obsv (sys, c)
 
diff --git a/scripts/control/base/place.m b/scripts/control/base/place.m
--- a/scripts/control/base/place.m
+++ b/scripts/control/base/place.m
@@ -12,20 +12,20 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} place (@var{sys}, @var{p})
-## Computes the matrix  K such that if the state
-## is feedback with gain K, then the eigenvalues  of the closed loop
-## system (i.e. A-BK) are those specified in the vector @var{p}.
+## @deftypefn {Function File} {@var{K} =} place (@var{sys}, @var{p})
+## Computes the matrix @var{K} such that if the state
+## is feedback with gain @var{K}, then the eigenvalues  of the closed loop
+## system (i.e. @math{A-BK}) are those specified in the vector @var{p}.
 ##
 ## Version: Beta (May-1997): If you have any comments, please let me know.
 ## (see the file place.m for my address)
 ## @end deftypefn
 
 ## Author: Jose Daniel Munoz Frias
 
 ## Universidad Pontificia Comillas
diff --git a/scripts/control/base/pzmap.m b/scripts/control/base/pzmap.m
--- a/scripts/control/base/pzmap.m
+++ b/scripts/control/base/pzmap.m
@@ -12,25 +12,33 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{zer}, @var{pol}]=} pzmap (@var{sys})
+## @deftypefn {Function File} {[@var{zer}, @var{pol}] =} pzmap (@var{sys})
 ## Plots the zeros and poles of a system in the complex plane.
-## @strong{Inputs}
-## @var{sys} system data structure
+##
+## @strong{Input}
+## @table @var
+## @item sys
+## System data structure.
+## @end table
 ##
 ## @strong{Outputs}
+## @table @var
+## @item pol
+## @item zer
 ## if omitted, the poles and zeros are plotted on the screen.
-## otherwise, pol, zer are returned as the system poles and zeros.
-## (see sys2zp for a preferable function call)
+## otherwise, @var{pol} and @var{zer} are returned as the 
+## system poles and zeros (see @command{sys2zp} for a preferable function call).
+## @end table
 ## @end deftypefn
 
 function [zer, pol]=pzmap (sys)
 
   save_warn_empty_list_elements = warn_empty_list_elements;
   unwind_protect
     warn_empty_list_elements = 0;
 
diff --git a/scripts/control/base/rldemo.m b/scripts/control/base/rldemo.m
--- a/scripts/control/base/rldemo.m
+++ b/scripts/control/base/rldemo.m
@@ -12,19 +12,19 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-##@deftypefn {Function File} {} rldemo (@var{inputs})
-##Octave Controls toolbox demo: Root Locus demo
-##@end deftypefn
+## @deftypefn {Function File} {} rldemo (@var{inputs})
+## Octave Control toolbox demo: Root Locus demo.
+## @end deftypefn
 
 ## Author: David Clem
 ## Created: August 15, 1994
 ## Updated by John Ingram December 1996
 
 function rldemo ()
 
   while (1)
diff --git a/scripts/control/base/rlocus.m b/scripts/control/base/rlocus.m
--- a/scripts/control/base/rlocus.m
+++ b/scripts/control/base/rlocus.m
@@ -12,35 +12,50 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} rlocus (@var{inputs})
-## @format
-## [rldata, k] = rlocus(sys[,increment,min_k,max_k])
-## Displays root locus plot of the specified SISO system.
+## @deftypefn {Function File} {[@var{rldata}, @var{k}] =} rlocus (@var{sys}[, @var{increment}, @var{min_k}, @var{max_k}])
 ##
+## Displays root locus plot of the specified @acronym{SISO} system.
+## @example
+## @group
 ##        -----   ---     --------
 ##    --->| + |---|k|---->| SISO |----------->
 ##        -----   ---     --------        |
 ##        - ^                             |
 ##          |_____________________________|
+## @end group
+## @end example
 ##
-## inputs: sys = system data structure
-## min_k, max_k,increment: minimum, maximum values of k and
-## the increment used in computing gain values
-## Outputs: plots the root locus to the screen.
-## rldata: Data points plotted column 1: real values, column 2: imaginary
-## values)
-## k: gains for real axis break points.
-## @end format
+## @strong{Inputs}
+## @table @var
+## @item sys
+## system data structure
+## @item min_k
+## Minimum value of @var{k}
+## @item max_k
+## Maximum value of @var{k}
+## @item increment
+## The increment used in computing gain values
+## @end table
+##
+## @strong{Outputs}
+##
+## Plots the root locus to the screen.
+## @table @var 
+## @item rldata
+## Data points plotted: in column 1 real values, in column 2 the imaginary values.
+## @item k
+## Gains for real axis break points.
+## @end table
 ## @end deftypefn
 
 ## Author: David Clem
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Updated by Kristi McGowan July 1996 for intelligent gain selection
 ## Updated by John Ingram July 1996 for systems
 
 function [rldata, k_break, rlpol, gvec, real_ax_pts] = rlocus (sys, increment, min_k, max_k)
diff --git a/scripts/control/base/step.m b/scripts/control/base/step.m
--- a/scripts/control/base/step.m
+++ b/scripts/control/base/step.m
@@ -31,22 +31,27 @@
 ## Index of input being excited
 ## @item tstop
 ## The argument @var{tstop} (scalar value) denotes the time when the
 ## simulation should end.
 ## @item n
 ## the number of data values.
 ##
 ## Both parameters @var{tstop} and @var{n} can be omitted and will be
-## computed from the eigenvalues of the A-Matrix.
+## computed from the eigenvalues of the A Matrix.
 ## @end table
 ## @strong{Outputs}
-## @var{y}, @var{t}: impulse response
+## @table @var
+## @item y
+## Values of the step response.
+## @item t
+## Times of the step response.
+## @end table
 ##
-## When invoked with the output paramter y the plot is not displayed.
+## When invoked with the output parameter @var{y} the plot is not displayed.
 ## @end deftypefn
 ## @seealso{impulse and __stepimp__}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 30, 1997
 ## based on lsim.m of Scottedward Hodel
 
 function [y, t] = step (sys, inp, tstop, n)
diff --git a/scripts/control/base/tzero.m b/scripts/control/base/tzero.m
--- a/scripts/control/base/tzero.m
+++ b/scripts/control/base/tzero.m
@@ -12,42 +12,58 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} tzero (@var{a}, @var{b}, @var{c}, @var{d}, @var{opt})
-## @deftypefnx {Function File} {} tzero (@var{sys}, @var{opt})
-## Compute transmission zeros of a continuous
+## @deftypefn {Function File} {[@var{zer}, @var{gain}] =} tzero (@var{a}, @var{b}, @var{c}, @var{d}, @var{opt})
+## @deftypefnx {Function File} {[@var{zer}, @var{gain}] =} tzero (@var{sys}, @var{opt})
+## Compute transmission zeros of a continuous system:
+## @iftex
+## @tex
+## $$ \dot x = Ax + Bu $$
+## $$ y = Cx + Du $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
 ## .
 ## x = Ax + Bu
 ## y = Cx + Du
 ## @end example
-## or discrete
+## @end ifinfo
+## or of a discrete one:
+## @iftex
+## @tex
+## $$ x_{k+1} = Ax_k + Bu_k $$
+## $$ y_k = Cx_k + Du_k $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
 ## x(k+1) = A x(k) + B u(k)
 ## y(k)   = C x(k) + D u(k)
 ## @end example
-## system.
+## @end ifinfo
+## 
 ## @strong{Outputs}
 ## @table @var
 ## @item zer
 ##  transmission zeros of the system
 ## @item gain
-## leading coefficient (pole-zero form) of SISO transfer function
+## leading coefficient (pole-zero form) of @acronym{SISO} transfer function
 ## returns gain=0 if system is multivariable
 ## @end table
 ## @strong{References}
 ## @enumerate
 ## @item Emami-Naeini and Van Dooren, Automatica, 1982.
-## @item Hodel, "Computation of Zeros with Balancing," 1992 Lin. Alg. Appl.
+## @item Hodel, @cite{Computation of Zeros with Balancing}, 1992 Lin. Alg. Appl.
 ## @end enumerate
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 4, 1994
 ## A. S. Hodel Aug 1995: allow for MIMO and system data structures
 
 function [zer, gain] = tzero (A, B, C, D)
diff --git a/scripts/control/base/tzero2.m b/scripts/control/base/tzero2.m
--- a/scripts/control/base/tzero2.m
+++ b/scripts/control/base/tzero2.m
@@ -12,23 +12,23 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} tzero2 (@var{a}, @var{b}, @var{c}, @var{d}, @var{bal})
-## Compute the transmission zeros of a, b, c, d.
+## @deftypefn {Function File} {@var{zr} =} tzero2 (@var{a}, @var{b}, @var{c}, @var{d}, @var{bal})
+## Compute the transmission zeros of @var{a}, @var{b}, @var{c}, @var{d}.
 ##
-## bal = balancing option (see balance); default is "B".
+## @var{bal} = balancing option (see balance); default is @code{"B"}.
 ##
-## Needs to incorporate @code{mvzero} algorithm to isolate finite zeros; use
-## @code{tzero} instead.
+## Needs to incorporate @command{mvzero} algorithm to isolate finite zeros; 
+## use @command{tzero} instead.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 
 function zr = tzero2 (a, b, c, d, bal)
 
   if (nargin == 4)
diff --git a/scripts/control/hinf/dgkfdemo.m b/scripts/control/hinf/dgkfdemo.m
--- a/scripts/control/hinf/dgkfdemo.m
+++ b/scripts/control/hinf/dgkfdemo.m
@@ -13,17 +13,26 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dgkfdemo ()
-## Octave Controls toolbox demo: H2/Hinfinity options demos
+## Octave Controls toolbox demo: 
+## @iftex
+## @tex
+## $ { \cal H }_2 $/$ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-2/H-infinity
+## @end ifinfo
+## options demos.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function dgkfdemo ()
 
   save_val = page_screen_output;
diff --git a/scripts/control/hinf/dhinfdemo.m b/scripts/control/hinf/dhinfdemo.m
--- a/scripts/control/hinf/dhinfdemo.m
+++ b/scripts/control/hinf/dhinfdemo.m
@@ -13,50 +13,78 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dhinfdemo ()
-## Demonstrate the functions available for designining a discrete
-## H_infinity controller.  This is not a true discrete design. The
+## Demonstrate the functions available to design a discrete
+## @iftex
+## @tex
+## $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-infinity
+## @end ifinfo
+## controller.  This is not a true discrete design. The
 ## design is carried out in continuous time while the effect of sampling
 ## is described by a bilinear transformation of the sampled system.
 ## This method works quite well if the sampling period is "small"
 ## compared to the plant time constants.
 ##
 ## Continuous plant:
-##
+## @iftex
+## @tex
+## $$ G(s) = { 1 \over (s+2) (s+1) } $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
+## @group
 ##                   1
 ##      G(s) = --------------
 ##             (s + 2)(s + 1)
+## @end group
 ## @end example
+## @end ifinfo
 ##
-## Discretised plant with ZOH (Sampling period = Ts = 1 second):
+## Discretised plant with @acronym{ZOH} (Sampling period = @var{Ts} = 1 second):
+## @iftex
+## @tex
+## $$ G(z) = { 0.39958z + 0.14700 \over (z - 0.36788) (z - 0.13533) } $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
+## @group
+##                 0.39958z + 0.14700
+##      G(z) = --------------------------
+##             (z - 0.36788)(z - 0.13533)
+## @end group
+## @end example
+## @end ifinfo
 ##
 ## @example
-##                 0.39958z + 0.14700
-##      G(s) = --------------------------
-##             (z - 0.36788)(z - 0.13533)
-##
+## @group
 ##                               +----+
 ##          -------------------->| W1 |---> v1
 ##      z   |                    +----+
 ##      ----|-------------+                   || T   ||     => min.
 ##          |             |                       vz   infty
 ##          |    +---+    v      +----+
 ##          *--->| G |--->O--*-->| W2 |---> v2
 ##          |    +---+       |   +----+
 ##          |                |
 ##          |    +---+       |
 ##          -----| K |<-------
 ##               +---+
+## @end group
 ## @end example
 ##
 ## @noindent
 ## W1 and W2 are the robustness and performancs weighting functions.
 ## @end deftypefn
 
 ## K. Mueller, <mueller@ifr.ing.tu-bs.de>
 ## Technical University of Braunschweig, IfR
diff --git a/scripts/control/hinf/h2norm.m b/scripts/control/hinf/h2norm.m
--- a/scripts/control/hinf/h2norm.m
+++ b/scripts/control/hinf/h2norm.m
@@ -12,22 +12,39 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function Fil} {} h2norm (@var{sys})
-## Computes the H2 norm of a system data structure (continuous time only)
+## @deftypefn {Function File} {} h2norm (@var{sys})
+## Computes the 
+## @iftex
+## @tex
+## $ { \cal H }_2 $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-2
+## @end ifinfo
+## norm of a system data structure (continuous time only).
 ##
 ## Reference:
-## Doyle, Glover, Khargonekar, Francis, ``State Space Solutions to Standard
-## H2 and Hinf Control Problems", IEEE TAC August 1989
+## Doyle, Glover, Khargonekar, Francis, @cite{State-Space Solutions to Standard} 
+## @iftex
+## @tex
+## $ { \cal H }_2 $ @cite{and} $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## @cite{H-2 and H-infinity}
+## @end ifinfo
+## @cite{Control Problems}, @acronym{IEEE} @acronym{TAC} August 1989.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## updated for system data structure by John Ingram November 1996
 
 function h2gain = h2norm (sys)
 
@@ -45,14 +62,14 @@ function h2gain = h2norm (sys)
     ## compute gain
     [a,b,c,d] = sys2ss(sys);
     if(dflg)
       M = dlyap(a,b*b');
     else
       M = lyap (a,b*b');
     endif
     if( min(real(eig(M))) < 0)
-      error("h2norm: grammian not >= 0 (lightly damped modes?)")
+      error("h2norm: gramian not >= 0 (lightly damped modes?)")
     endif
 
     h2gain = sqrt(trace(d'*d + c*M*c'));
   endif
 endfunction
diff --git a/scripts/control/hinf/h2syn.m b/scripts/control/hinf/h2syn.m
--- a/scripts/control/hinf/h2syn.m
+++ b/scripts/control/hinf/h2syn.m
@@ -12,54 +12,70 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[K}, @var{gain}, @var{kc}, @var{kf}, @var{pc}, @var{pf}] = h2syn (@var{asys}, @var{nu}, @var{ny}, @var{tol})
-## Design H2 optimal controller per procedure in
-## Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
-## H2 and Hinf Control Problems", IEEE TAC August 1989
+## @deftypefn {Function File} {[@var{K}, @var{gain}, @var{kc}, @var{kf}, @var{pc}, @var{pf}] = } h2syn (@var{asys}, @var{nu}, @var{ny}, @var{tol})
+## Design 
+## @iftex
+## @tex
+## $ { \cal H }_2 $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-2
+## @end ifinfo
+## optimal controller per procedure in 
+## Doyle, Glover, Khargonekar, Francis, @cite{State-Space Solutions to Standard}
+## @iftex
+## @tex
+## $ { \cal H }_2 $ @cite{and} $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## @cite{H-2 and H-infinity}
+## @end ifinfo
+## @cite{Control Problems}, @acronym{IEEE} @acronym{TAC} August 1989.
 ##
-## Discrete time control per Zhou, Doyle, and Glover, ROBUST AND OPTIMAL
-## CONTROL, Prentice-Hall, 1996
+## Discrete-time control per Zhou, Doyle, and Glover, @cite{Robust and optimal control}, Prentice-Hall, 1996.
 ##
-## @strong{Inputs} input system is passed as either
+## @strong{Inputs}
 ## @table @var
 ## @item asys
 ## system data structure (see ss, sys2ss)
 ## @itemize @bullet
 ## @item controller is implemented for continuous time systems
-## @item controller is NOT implemented for discrete time systems
+## @item controller is @strong{not} implemented for discrete time systems
 ## @end itemize
 ## @item nu
 ## number of controlled inputs
 ## @item ny
 ## number of measured outputs
 ## @item tol
-## threshhold for 0.  Default: 200*eps
+## threshold for 0.  Default: 200*@code{eps}
 ## @end table
 ##
 ## @strong{Outputs}
 ## @table @var
 ## @item    k
 ## system controller
 ## @item    gain
 ## optimal closed loop gain
 ## @item    kc
 ## full information control (packed)
 ## @item    kf
 ## state estimator (packed)
 ## @item    pc
-## ARE solution matrix for regulator subproblem
+## @acronym{ARE} solution matrix for regulator subproblem
 ## @item    pf
-## ARE solution matrix for filter subproblem
+## @acronym{ARE} solution matrix for filter subproblem
 ## @end table
 ## @end deftypefn
 
 ## Updated for System structure December 1996 by John Ingram
 
 function [K, gain, Kc, Kf, Pc, Pf] = h2syn (Asys, nu, ny, tol)
 
   if ((nargin < 3) | (nargin > 4))
diff --git a/scripts/control/hinf/hinf_ctr.m b/scripts/control/hinf/hinf_ctr.m
--- a/scripts/control/hinf/hinf_ctr.m
+++ b/scripts/control/hinf/hinf_ctr.m
@@ -12,31 +12,43 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} hinf_ctr (@var{dgs}, @var{f}, @var{h}, @var{z}, @var{g})
-## Called by @code{hinfsyn} to compute the H_inf optimal controller.
+## @deftypefn {Function File} {@var{K} =} hinf_ctr (@var{dgs}, @var{f}, @var{h}, @var{z}, @var{g})
+## Called by @code{hinfsyn} to compute the 
+## @iftex
+## @tex
+## $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-infinity
+## @end ifinfo
+## optimal controller.
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item dgs
 ## data structure returned by @code{is_dgkf}
 ## @item f
 ## @itemx h
 ## feedback and filter gain (not partitioned)
 ## @item g
 ## final gamma value
 ## @end table
 ## @strong{Outputs}
+## @table @var
+## @item K
 ## controller (system data structure)
+## @end table
 ##
 ## Do not attempt to use this at home; no argument checking performed.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## Revised by Kai P. Mueller April 1998 to solve the general H_infinity
 ## problem using unitary transformations Q (on w and z)
diff --git a/scripts/control/hinf/hinfdemo.m b/scripts/control/hinf/hinfdemo.m
--- a/scripts/control/hinf/hinfdemo.m
+++ b/scripts/control/hinf/hinfdemo.m
@@ -14,122 +14,219 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hinfdemo ()
 ##
-## H_infinity design demos for continuous SISO and MIMO systems and a
-## discrete system.  The SISO system is difficult to control because it
-## is non minimum phase and unstable.  The second design example
-## controls the "jet707" plant, the linearized state space model of a
-## Boeing 707-321 aircraft at v=80m/s (M = 0.26, Ga0 = -3 deg, alpha0 =
-## 4 deg, kappa = 50 deg).  Inputs: (1) thrust and (2) elevator angle
-## outputs: (1) airspeed and (2) pitch angle. The discrete system is a
+## @iftex
+## @tex
+## $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-infinity
+## @end ifinfo
+## design demos for continuous @acronym{SISO} and @acronym{MIMO} systems and a
+## discrete system.  The @acronym{SISO} system is difficult to control because
+## it is non-minimum-phase and unstable. The second design example
+## controls the @command{jet707} plant, the linearized state space model of a
+## Boeing 707-321 aircraft at @var{v}=80 m/s 
+## @iftex
+## @tex
+## ($M = 0.26$, $G_{a0} = -3^{\circ}$, ${\alpha}_0 = 4^{\circ}$, ${\kappa}= 50^{\circ}$).
+## @end tex
+## @end iftex
+## @ifinfo
+## (@var{M} = 0.26, @var{Ga0} = -3 deg, @var{alpha0} = 4 deg, @var{kappa} = 50 deg).
+## @end ifinfo
+## Inputs: (1) thrust and (2) elevator angle
+## Outputs: (1) airspeed and (2) pitch angle. The discrete system is a
 ## stable and second order.
 ##
 ## @table @asis
-## @item SISO plant
-## @display
+## @item @acronym{SISO} plant:
+##
+## @iftex
+## @tex
+## $$ G(s) = { s-2 \over (s+2) (s-1) } $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
 ## @group
 ##                 s - 2
 ##      G(s) = --------------
 ##             (s + 2)(s - 1)
+## @end group
+## @end example
+## @end ifinfo
+##
+## @example
+## @group
 ##
 ##                               +----+
 ##          -------------------->| W1 |---> v1
 ##      z   |                    +----+
-##      ----|-------------+                   || T   ||     => min.
-##          |             |                       vz   infty
+##      ----|-------------+
+##          |             |
 ##          |    +---+    v   y  +----+
 ##        u *--->| G |--->O--*-->| W2 |---> v2
 ##          |    +---+       |   +----+
 ##          |                |
 ##          |    +---+       |
 ##          -----| K |<-------
 ##               +---+
 ## @end group
-## @end display
-## W1 und W2 are the robustness and performance weighting
-## functions
+## @end example
+## 
+## @iftex
+## @tex
+## $$ { \rm min } \Vert T_{vz} \Vert _\infty $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
+## min || T   ||
+##         vz   infty
+## @end example
+## @end ifinfo
 ##
-## @item MIMO plant
-## The optimal controller minimizes the H_infinity norm of the
-## augmented plant P (mixed-sensitivity problem):
-## @display
+## @var{W1} und @var{W2} are the robustness and performance weighting
+## functions.
+##
+## @item @acronym{MIMO} plant:
+## The optimal controller minimizes the 
+## @iftex
+## @tex
+## $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-infinity
+## @end ifinfo
+## norm of the
+## augmented plant @var{P} (mixed-sensitivity problem):
+## @example
 ## @group
 ##      w
 ##       1 -----------+
 ##                    |                   +----+
 ##                +---------------------->| W1 |----> z1
 ##      w         |   |                   +----+
 ##       2 ------------------------+
 ##                |   |            |
 ##                |   v   +----+   v      +----+
 ##             +--*-->o-->| G  |-->o--*-->| W2 |---> z2
 ##             |          +----+      |   +----+
 ##             |                      |
 ##             ^                      v
-##              u (from                 y (to K)
-##                controller
-##                K)
+##             u                       y (to K)
+##          (from controller K)
+## @end group
+## @end example
 ##
-##
+## @iftex
+## @tex
+## $$ \left [ \matrix{ z_1 \cr
+##                     z_2 \cr
+##                     y   } \right ] =  
+##  P \left [ \matrix{ w_1 \cr
+##                     w_2 \cr
+##                     u   } \right ] $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
+## @group
 ##                   +    +           +    +
 ##                   | z  |           | w  |
 ##                   |  1 |           |  1 |
 ##                   | z  | = [ P ] * | w  |
 ##                   |  2 |           |  2 |
 ##                   | y  |           | u  |
 ##                   +    +           +    +
 ## @end group
-## @end display
+## @end example
+## @end ifinfo
 ##
-## @item DISCRETE SYSTEM
+## @item Discrete system:
 ## This is not a true discrete design. The design is carried out
 ## in continuous time while the effect of sampling is described by
 ## a bilinear transformation of the sampled system.
-## This method works quite well if the sampling period is "small"
+## This method works quite well if the sampling period is ``small''
 ## compared to the plant time constants.
 ##
-## @item The continuous plant
-## @display
+## @item The continuous plant:
+## @iftex
+## @tex
+## $$ G(s) = { 1 \over (s+2)(s+1) } $$
+## @end tex
+## @end iftex
+##
+## @ifinfo
+## @example
 ## @group
 ##                    1
 ##      G (s) = --------------
 ##       k      (s + 2)(s + 1)
 ##
 ## @end group
-## @end display
-## is discretised with a ZOH (Sampling period = Ts = 1 second):
-## @display
+## @end example
+## @end ifinfo
+##
+## is discretised with a @acronym{ZOH} (Sampling period = @var{Ts} = 1 second):
+## @iftex
+## @tex
+## $$ G(z) = { 0.199788z + 0.073498 \over (z - 0.36788) (z - 0.13534) } $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
 ## @group
 ##
 ##                0.199788z + 0.073498
-##      G(s) = --------------------------
+##      G(z) = --------------------------
 ##             (z - 0.36788)(z - 0.13534)
+## @end group
+## @end example
+## @end ifinfo
+##
+## @example
+## @group
 ##
 ##                               +----+
 ##          -------------------->| W1 |---> v1
 ##      z   |                    +----+
-##      ----|-------------+                   || T   ||     => min.
-##          |             |                       vz   infty
+##      ----|-------------+
+##          |             |
 ##          |    +---+    v      +----+
 ##          *--->| G |--->O--*-->| W2 |---> v2
 ##          |    +---+       |   +----+
 ##          |                |
 ##          |    +---+       |
 ##          -----| K |<-------
 ##               +---+
 ## @end group
-## @end display
-## W1 and W2 are the robustness and performancs weighting
-## functions
+## @end example
+## @iftex
+## @tex
+## $$ { \rm min } \Vert T_{vz} \Vert _\infty $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
+## min || T   ||
+##         vz   infty
+## @end example
+## @end ifinfo
+## @var{W1} and @var{W2} are the robustness and performance weighting
+## functions.
 ## @end table
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: April 30, 1998
 
 yn = [];
 while (length(yn) < 1)
diff --git a/scripts/control/hinf/hinfnorm.m b/scripts/control/hinf/hinfnorm.m
--- a/scripts/control/hinf/hinfnorm.m
+++ b/scripts/control/hinf/hinfnorm.m
@@ -13,59 +13,108 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{g}, @var{gmin}, @var{gmax}] =} hinfnorm (@var{sys}, @var{tol}, @var{gmin}, @var{gmax}, @var{ptol})
-##  Computes the H infinity norm of a system data structure.
+## Computes the 
+## @iftex
+## @tex
+## $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-infinity
+## @end ifinfo
+## norm of a system data structure.
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ## system data structure
 ## @item tol
-## H infinity norm search tolerance (default: 0.001)
+## @iftex
+## @tex
+## $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-infinity
+## @end ifinfo
+## norm search tolerance (default: 0.001)
 ## @item gmin
 ## minimum value for norm search (default: 1e-9)
 ## @item gmax
 ## maximum value for norm search (default: 1e+9)
 ## @item ptol
 ## pole tolerance:
 ## @itemize @bullet
 ## @item if sys is continuous, poles with
-## |real(pole)| < ptol*||H|| (H is appropriate Hamiltonian)
+## @iftex
+## @tex
+## $ \vert {\rm real}(pole) \vert < ptol \Vert H \Vert $
+## @end tex
+## @end iftex
+## @ifinfo
+## @math{ |real(pole))| < ptol*||H|| }
+## @end ifinfo
+## (@var{H} is appropriate Hamiltonian)
 ## are considered to be on the imaginary axis.
 ##
 ## @item if sys is discrete, poles with
-## |abs(pole)-1| < ptol*||[s1,s2]|| (appropriate symplectic pencil)
-## are considered to be on the unit circle
+## @iftex
+## @tex
+## $ \vert { \rm pole } - 1 \vert < ptol \Vert [ s_1 s_2 ] \Vert $
+## @end tex
+## @end iftex
+## @ifinfo
+## @math{|abs(pole)-1| < ptol*||[s1,s2]||}
+## @end ifinfo
+## (appropriate symplectic pencil)
+## are considered to be on the unit circle.
 ##
-## @item Default: 1e-9
+## @item Default value: 1e-9
 ## @end itemize
 ## @end table
 ##
 ## @strong{Outputs}
 ## @table @var
 ## @item g
 ## Computed gain, within @var{tol} of actual gain.  @var{g} is returned as Inf
 ## if the system is unstable.
 ## @item gmin
 ## @itemx gmax
-## Actual system gain lies in the interval [@var{gmin}, @var{gmax}]
+## Actual system gain lies in the interval [@var{gmin}, @var{gmax}].
 ## @end table
 ##
 ## References:
-## Doyle, Glover, Khargonekar, Francis, "State space solutions to standard
-## H2 and Hinf control problems", IEEE TAC August 1989
-## Iglesias and Glover, "State-Space approach to discrete-time Hinf control,"
-## Int. J. Control, vol 54, #5, 1991
-## Zhou, Doyle, Glover, "Robust and Optimal Control," Prentice-Hall, 1996
+## Doyle, Glover, Khargonekar, Francis, @cite{State-space solutions to standard}
+## @iftex
+## @tex
+## $ { \cal H }_2 $ @cite{and} $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## @cite{H-2 and H-infinity}
+## @end ifinfo
+## @cite{control problems}, @acronym{IEEE} @acronym{TAC} August 1989;
+## Iglesias and Glover, @cite{State-Space approach to discrete-time}
+## @iftex
+## @tex
+## $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## @cite{H-infinity}
+## @end ifinfo
+## @cite{control}, Int. J. Control, vol 54, no. 5, 1991;
+## Zhou, Doyle, Glover, @cite{Robust and Optimal Control}, Prentice-Hall, 1996.
 ## @end deftypefn
 
 function [g, gmin, gmax] = hinfnorm (sys, tol, gmin, gmax, ptol)
 
   if((nargin == 0) || (nargin > 4))
     usage("[g gmin gmax] = hinfnorm(sys[,tol,gmin,gmax,ptol])");
   elseif(!isstruct(sys))
     error("Sys must be a system data structure");
diff --git a/scripts/control/hinf/hinfsyn.m b/scripts/control/hinf/hinfsyn.m
--- a/scripts/control/hinf/hinfsyn.m
+++ b/scripts/control/hinf/hinfsyn.m
@@ -17,66 +17,111 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{k}, @var{g}, @var{gw}, @var{xinf}, @var{yinf}] =} hinfsyn (@var{asys}, @var{nu}, @var{ny}, @var{gmin}, @var{gmax}, @var{gtol}, @var{ptol}, @var{tol})
 ##
 ## @strong{Inputs} input system is passed as either
 ## @table @var
 ## @item asys
-## system data structure (see ss, sys2ss)
+## system data structure (see @command{ss}, @command{sys2ss})
 ## @itemize @bullet
 ## @item controller is implemented for continuous time systems
-## @item controller is NOT implemented for discrete time systems  (see
-## bilinear transforms in @code{c2d}, @code{d2c})
+## @item controller is @strong{not} implemented for discrete time systems  (see
+## bilinear transforms in @command{c2d}, @command{d2c})
 ## @end itemize
 ## @item nu
 ## number of controlled inputs
 ## @item ny
 ## number of measured outputs
 ## @item gmin
-## initial lower bound on H-infinity optimal gain
+## initial lower bound on 
+## @iftex
+## @tex
+## $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-infinity
+## @end ifinfo
+## optimal gain
 ## @item gmax
-## initial upper bound on H-infinity optimal gain
+## initial upper bound on 
+## @iftex
+## @tex
+## $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-infinity
+## @end ifinfo
+## Optimal gain.
 ## @item gtol
-## gain threshhold.  Routine quits when gmax/gmin < 1+tol
+## Gain threshold.  Routine quits when @var{gmax}/@var{gmin} < 1+tol.
 ## @item ptol
-## poles with abs(real(pole)) < ptol*||H|| (H is appropriate
+## poles with @code{abs(real(pole))} 
+## @iftex
+## @tex
+## $ < ptol \Vert H \Vert $
+## @end tex
+## @end iftex
+## @ifinfo
+## < ptol*||H|| 
+## @end ifinfo
+## (@var{H} is appropriate
 ## Hamiltonian) are considered to be on the imaginary axis.
-## Default: 1e-9
+## Default: 1e-9.
 ## @item tol
-## threshhold for 0.  Default: 200*eps
+## threshold for 0.  Default: 200*@code{eps}.
 ##
 ## @var{gmax}, @var{min}, @var{tol}, and @var{tol} must all be postive scalars.
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item k
-## system controller
+## System controller.
 ## @item g
-## designed gain value
+## Designed gain value.
 ## @item gw
-## closed loop system
+## Closed loop system.
 ## @item xinf
-## ARE solution matrix for regulator subproblem
+## @acronym{ARE} solution matrix for regulator subproblem.
 ## @item yinf
-## ARE solution matrix for filter subproblem
+## @acronym{ARE} solution matrix for filter subproblem.
 ## @end table
 ##
+## References:
 ## @enumerate
-## @item Doyle, Glover, Khargonekar, Francis, "State Space Solutions
-## to Standard H2 and Hinf Control Problems," IEEE TAC August 1989
+## @item Doyle, Glover, Khargonekar, Francis, @cite{State-Space Solutions
+## to Standard}
+## @iftex
+## @tex
+## $ { \cal H }_2 $ @cite{and} $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## @cite{H-2 and H-infinity}
+## @end ifinfo
+## @cite{Control Problems}, @acronym{IEEE} @acronym{TAC} August 1989.
 ##
-## @item Maciejowksi, J.M., "Multivariable feedback design,"
-## Addison-Wesley, 1989, ISBN 0-201-18243-2
+## @item Maciejowksi, J.M., @cite{Multivariable feedback design},
+## Addison-Wesley, 1989, @acronym{ISBN} 0-201-18243-2.
 ##
-## @item Keith Glover and John C. Doyle, "State-space formulae for all
-## stabilizing controllers that satisfy and h-infinity-norm bound
-## and relations to risk sensitivity,"
-## Systems & Control Letters 11, Oct. 1988, pp 167-172.
+## @item Keith Glover and John C. Doyle, @cite{State-space formulae for all
+## stabilizing controllers that satisfy an}
+## @iftex
+## @tex
+## $ { \cal H }_\infty $@cite{norm}
+## @end tex
+## @end iftex
+## @ifinfo
+## @cite{H-infinity-norm}
+## @end ifinfo
+## @cite{bound and relations to risk sensitivity},
+## Systems & Control Letters 11, Oct. 1988, pp 167--172.
 ## @end enumerate
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## Updated for Packed system structures December 1996 by John Ingram
 ##
 ## Revised by Kai P. Mueller April 1998 to solve the general H_infinity
diff --git a/scripts/control/hinf/hinfsyn_chk.m b/scripts/control/hinf/hinfsyn_chk.m
--- a/scripts/control/hinf/hinfsyn_chk.m
+++ b/scripts/control/hinf/hinfsyn_chk.m
@@ -15,38 +15,66 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{retval}, @var{pc}, @var{pf}] =} hinfsyn_chk (@var{a}, @var{b1}, @var{b2}, @var{c1}, @var{c2}, @var{d12}, @var{d21}, @var{g}, @var{ptol})
 ## Called by @code{hinfsyn} to see if gain @var{g} satisfies conditions in
 ## Theorem 3 of
-## Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
-## H2 and Hinf Control Problems", IEEE TAC August 1989
+## Doyle, Glover, Khargonekar, Francis, @cite{State Space Solutions to Standard}
+## @iftex
+## @tex
+## $ { \cal H }_2 $ @cite{and} $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## @cite{H-2 and H-infinity}
+## @end ifinfo
+## @cite{Control Problems}, @acronym{IEEE} @acronym{TAC} August 1989.
 ##
-## @strong{Warning} Do not attempt to use this at home; no argument
+## @strong{Warning:} do not attempt to use this at home; no argument
 ## checking performed.
 ##
-## @strong{Inputs} as returned by @code{is_dgkf}, except for:
+## @strong{Inputs}
+##
+## As returned by @code{is_dgkf}, except for:
 ## @table @var
 ## @item g
 ## candidate gain level
 ## @item ptol
 ##  as in @code{hinfsyn}
 ## @end table
 ##
 ## @strong{Outputs}
 ## @table @var
 ## @item retval
 ##  1 if g exceeds optimal Hinf closed loop gain, else 0
 ## @item pc
-##  solution of "regulator" H-inf ARE
+## solution of ``regulator'' 
+## @iftex
+## @tex
+## $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-infinity
+## @end ifinfo
+## @acronym{ARE}
 ## @item pf
-##  solution of "filter" H-inf ARE
+## solution of ``filter''
+## @iftex
+## @tex
+## $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-infinity
+## @end ifinfo
+## @acronym{ARE}
 ## @end table
 ## Do not attempt to use this at home; no argument checking performed.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 
 function [retval, Pc, Pf] = hinfsyn_chk (A, B1, B2, C1, C2, D12, D21, g, ptol)
diff --git a/scripts/control/hinf/hinfsyn_ric.m b/scripts/control/hinf/hinfsyn_ric.m
--- a/scripts/control/hinf/hinfsyn_ric.m
+++ b/scripts/control/hinf/hinfsyn_ric.m
@@ -15,18 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{xinf}, @var{x_ha_err}] =} hinfsyn_ric (@var{a}, @var{bb}, @var{c1}, @var{d1dot}, @var{r}, @var{ptol})
 ## Forms
 ## @example
-## xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1 BB'];
-## Ha = [A 0*A; -C1'*C1 -A'] - xx;
+## xx = ([bb; -c1'*d1dot]/r) * [d1dot'*c1 bb'];
+## Ha = [a 0*a; -c1'*c1 - a'] - xx;
 ## @end example
 ## and solves associated Riccati equation.
 ## The error code @var{x_ha_err} indicates one of the following
 ## conditions:
 ## @table @asis
 ## @item 0
 ## successful
 ## @item 1
diff --git a/scripts/control/hinf/is_dgkf.m b/scripts/control/hinf/is_dgkf.m
--- a/scripts/control/hinf/is_dgkf.m
+++ b/scripts/control/hinf/is_dgkf.m
@@ -14,46 +14,46 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{retval}, @var{dgkf_struct} ] =} is_dgkf (@var{asys}, @var{nu}, @var{ny}, @var{tol} )
 ## Determine whether a continuous time state space system meets
-## assumptions of DGKF algorithm.
+## assumptions of @acronym{DGKF} algorithm.
 ## Partitions system into:
 ## @example
-## [dx/dt] = [A  | Bw  Bu  ][w]
-## [ z   ]   [Cz | Dzw Dzu ][u]
+## [dx/dt]   [A  | Bw  Bu  ][w]
+## [ z   ] = [Cz | Dzw Dzu ][u]
 ## [ y   ]   [Cy | Dyw Dyu ]
 ## @end example
 ## or similar discrete-time system.
 ## If necessary, orthogonal transformations @var{qw}, @var{qz} and nonsingular
 ## transformations @var{ru}, @var{ry} are applied to respective vectors
-## @var{w}, @var{z}, @var{u}, @var{y} in order to satisfy DGKF assumptions.
+## @var{w}, @var{z}, @var{u}, @var{y} in order to satisfy @acronym{DGKF} assumptions.
 ## Loop shifting is used if @var{dyu} block is nonzero.
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item         asys
 ## system data structure
 ## @item           nu
 ## number of controlled inputs
 ## @item        ny
 ## number of measured outputs
 ## @item        tol
-## threshhold for 0.  Default: 200@var{eps}
+## threshold for 0; default: 200*@code{eps}.
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item    retval
 ## true(1) if system passes check, false(0) otherwise
 ## @item    dgkf_struct
-## data structure of @code{is_dgkf} results.  Entries:
+## data structure of @command{is_dgkf} results.  Entries:
 ## @table @var
 ## @item      nw
 ## @itemx     nz
 ## dimensions of @var{w}, @var{z}
 ## @item      a
 ## system @math{A} matrix
 ## @item      bw
 ## (@var{n} x @var{nw}) @var{qw}-transformed disturbance input matrix
@@ -79,25 +79,33 @@
 ## nonzero if the @var{dyu} block is nonzero.
 ## @item      dyu
 ## untransformed @var{dyu} block
 ## @item      dflg
 ## nonzero if the system is discrete-time
 ## @end table
 ## @end table
 ## @code{is_dgkf} exits with an error if the system is mixed
-## discrete/continuous
+## discrete/continuous.
 ##
 ## @strong{References}
 ## @table @strong
 ## @item [1]
-## Doyle, Glover, Khargonekar, Francis, "State Space Solutions
-## to Standard H2 and Hinf Control Problems," IEEE TAC August 1989
+## Doyle, Glover, Khargonekar, Francis, @cite{State Space Solutions to Standard}
+## @iftex
+## @tex
+## $ { \cal H }_2 $ @cite{and} $ { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## @cite{H-2 and H-infinity}
+## @end ifinfo
+## @cite{Control Problems}, @acronym{IEEE} @acronym{TAC} August 1989.
 ## @item [2]
-## Maciejowksi, J.M.: "Multivariable feedback design,"
+## Maciejowksi, J.M., @cite{Multivariable Feedback Design}, Addison-Wesley, 1989.
 ## @end table
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Updated by John Ingram July 1996 to accept structured systems
 
 ## Revised by Kai P. Mueller April 1998 to solve the general H_infinity
 ## problem using unitary transformations Q (on w and z)
diff --git a/scripts/control/hinf/wgt1o.m b/scripts/control/hinf/wgt1o.m
--- a/scripts/control/hinf/wgt1o.m
+++ b/scripts/control/hinf/wgt1o.m
@@ -12,28 +12,47 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} wgt1o (@var{vl}, @var{vh}, @var{fc})
+## @deftypefn {Function File} {@var{W} =} wgt1o (@var{vl}, @var{vh}, @var{fc})
 ## State space description of a first order weighting function.
 ##
-## Weighting function are needed by the H2/H_infinity design procedure.
-## These function are part of thye augmented plant P (see hinfdemo
-## for an applicattion example).
+## Weighting function are needed by the 
+## @iftex
+## @tex
+## $ { \cal H }_2 / { \cal H }_\infty $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-2/H-infinity
+## @end ifinfo
+## design procedure.
+## These function are part of the augmented plant @var{P}
+## (see @command{hinfdemo} for an application example).
 ##
-## vl = Gain at low frequencies
+## @strong{Inputs}
+## @table @var
+## @item vl
+## Gain at low frequencies.
+## @item vh
+## Gain at high frequencies.
+## @item fc
+## Corner frequency (in Hz, @strong{not} in rad/sec)
+## @end table
 ##
-## vh = Gain at high frequencies
-##
-## fc = Corner frequency (in Hz, *not* in rad/sec)
+## @strong{Output}
+## @table @var
+## @item W
+## Weighting function, given in form of a system data structure.
+## @end table
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 30, 1997
 
 function wsys = wgt1o (vl, vh, fc)
 
   if (nargin != 3)
diff --git a/scripts/control/obsolete/minfo.m b/scripts/control/obsolete/minfo.m
--- a/scripts/control/obsolete/minfo.m
+++ b/scripts/control/obsolete/minfo.m
@@ -11,28 +11,35 @@
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-##  function [systype, nout, nin, ncstates, ndstates] = minfo(inmat)
-##
-## MINFO:  Determines the type of system matrix.  INMAT can be
-##         a varying(*), system, constant, and empty matrix.
+## -*- texinfo -*-
+## @deftypefn {Function File} {[@var{systype}, @var{nout}, @var{nin}, @var{ncstates}, @var{ndstates}] =} minfo (@var{inmat})
+## Determines the type of system matrix.  @var{inmat} can be a varying, 
+## a system, a constant, and an empty matrix.
 ##
-##    Returns:
-##      systype can be one of:
-##            varying, system, constant, and empty
-##      nout is the number of outputs of the system
-##      nin is the number of inputs of the system
-##      ncstates is the number of continuous states of the system
-##       ndstates is the number of discrete states of the system
+## @strong{Outputs}
+## @table @var
+## @item systype 
+## Can be one of: varying, system, constant, and empty.
+## @item nout 
+## The number of outputs of the system.
+## @item nin
+## The number of inputs of the system.
+## @item ncstates
+## The number of continuous states of the system.
+## @item ndstates 
+## The number of discrete states of the system.
+## @end table
+## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 29, 1994
 ## Modified by David Clem November 13, 1994
 ## Modified by A. S. Hodel July 1995
 
 function [systype, nout, nin, ncstates, ndstates] = minfo (inmat)
 
diff --git a/scripts/control/obsolete/syschnames.m b/scripts/control/obsolete/syschnames.m
--- a/scripts/control/obsolete/syschnames.m
+++ b/scripts/control/obsolete/syschnames.m
@@ -13,17 +13,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} syschnames (@var{sys}, @var{opt}, @var{list}, @var{names})
-## Superseded by @code{syssetsignals}
+## Superseded by @command{syssetsignals}.
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 ## updated by A. S. Hodel 1998
 
 function retsys = syschnames (sys, opt, list, names)
 
diff --git a/scripts/control/system/buildssic.m b/scripts/control/system/buildssic.m
--- a/scripts/control/system/buildssic.m
+++ b/scripts/control/system/buildssic.m
@@ -15,59 +15,67 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} buildssic (@var{clst}, @var{ulst}, @var{olst}, @var{ilst}, @var{s1}, @var{s2}, @var{s3}, @var{s4}, @var{s5}, @var{s6}, @var{s7}, @var{s8})
 ##
 ## Form an arbitrary complex (open or closed loop) system in
-## state-space form from several systems. "@code{buildssic}" can
-## easily (despite it's cryptic syntax) integrate transfer functions
+## state-space form from several systems. @command{buildssic} can
+## easily (despite its cryptic syntax) integrate transfer functions
 ## from a complex block diagram into a single system with one call.
 ## This function is especially useful for building open loop
-## interconnections for H_infinity and H2 designs or for closing
-## loops with these controllers.
+## interconnections for 
+## @iftex
+## @tex
+## $ { \cal H }_\infty $ and $ { \cal H }_2 $
+## @end tex
+## @end iftex
+## @ifinfo
+## H-infinity and H-2
+## @end ifinfo
+## designs or for closing loops with these controllers.
 ##
-## Although this function is general purpose, the use of "@code{sysgroup}"
-## "@code{sysmult}", "@code{sysconnect}" and the like is recommended for
+## Although this function is general purpose, the use of @command{sysgroup}
+## @command{sysmult}, @command{sysconnect} and the like is recommended for
 ## standard operations since they can handle mixed discrete and continuous
 ## systems and also the names of inputs, outputs, and states.
 ##
 ## The parameters consist of 4 lists that describe the connections
-## outputs and inputs and up to 8 systems s1-s8.
+## outputs and inputs and up to 8 systems @var{s1}--@var{s8}.
 ## Format of the lists:
 ## @table @var
 ## @item      clst
 ## connection list, describes the input signal of
 ## each system. The maximum number of rows of Clst is
 ## equal to the sum of all inputs of s1-s8.
 ##
 ## Example:
-## @code{[1 2 -1; 2 1 0]} ==> new input 1 is old inpout 1
-## + output 2 - output 1, new input 2 is old input 2
+## @code{[1 2 -1; 2 1 0]} means that:  new input 1 is old input 1
+## + output 2 - output 1, and new input 2 is old input 2
 ## + output 1. The order of rows is arbitrary.
 ##
-## @item     ulst
-## if not empty the old inputs in vector Ulst will
+## @item ulst
+## if not empty the old inputs in vector @var{ulst} will
 ## be appended to the outputs. You need this if you
-## want to "pull out" the input of a system. Elements
-## are input numbers of s1-s8.
+## want to ``pull out'' the input of a system. Elements
+## are input numbers of @var{s1}--@var{s8}.
 ##
-## @item     olst
+## @item olst
 ## output list, specifiy the outputs of the resulting
-## systems. Elements are output numbers of s1-s8.
-## The numbers are alowed to be negative and may
+## systems. Elements are output numbers of @var{s1}--@var{s8}.
+## The numbers are allowed to be negative and may
 ## appear in any order. An empty matrix means
 ## all outputs.
 ##
-## @item     ilst
+## @item ilst
 ## input list, specifiy the inputs of the resulting
-## systems. Elements are input numbers of s1-s8.
-## The numbers are alowed to be negative and may
+## systems. Elements are input numbers of @var{s1}--@var{s8}.
+## The numbers are allowed to be negative and may
 ## appear in any order. An empty matrix means
 ## all inputs.
 ## @end table
 ##
 ## Example:  Very simple closed loop system.
 ## @example
 ## @group
 ## w        e  +-----+   u  +-----+
@@ -77,56 +85,77 @@
 ##      |  |            +----------------> u
 ##      |  |                         |
 ##      |  +-------------------------|---> e
 ##      |                            |
 ##      +----------------------------+
 ## @end group
 ## @end example
 ##
-## The closed loop system GW can be optained by
+## The closed loop system @var{GW} can be optained by
 ## @example
 ## GW = buildssic([1 2; 2 -1], 2, [1 2 3], 2, G, K);
 ## @end example
 ## @table @var
 ## @item clst
-## (1. row) connect input 1 (G) with output 2 (K).
-## (2. row) connect input 2 (K) with neg. output 1 (G).
+## 1st row: connect input 1 (@var{G}) with output 2 (@var{K}).
+##
+## 2nd row: connect input 2 (@var{K}) with negative output 1 (@var{G}).
 ## @item ulst
-## append input of (2) K to the number of outputs.
+## Append input of 2 (@var{K}) to the number of outputs.
 ## @item olst
-## Outputs are output of 1 (G), 2 (K) and appended output 3 (from Ulst).
+## Outputs are output of 1 (@var{G}), 2 (@var{K}) and 
+## appended output 3 (from @var{ulst}).
 ## @item ilst
-## the only input is 2 (K).
+## The only input is 2 (@var{K}).
 ## @end table
 ##
 ## Here is a real example:
 ## @example
 ## @group
 ##                          +----+
 ##     -------------------->| W1 |---> v1
 ## z   |                    +----+
-## ----|-------------+                   || GW   ||     => min.
-##     |             |                        vz   infty
+## ----|-------------+
+##     |             |
 ##     |    +---+    v      +----+
 ##     *--->| G |--->O--*-->| W2 |---> v2
 ##     |    +---+       |   +----+
 ##     |                |
 ##     |                v
 ##    u                  y
 ## @end group
 ## @end example
+## @iftex
+## @tex
+## $$ { \rm min } \Vert GW_{vz} \Vert _\infty $$  
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
+## min || GW   ||
+##          vz   infty
+## @end example
+## @end ifinfo
 ##
-## The closed loop system GW from [z; u]' to [v1; v2; y]' can be
-## obtained by (all SISO systems):
+## The closed loop system @var{GW} 
+## @iftex
+## @tex
+## from $ [z, u]^T $ to $ [v_1, v_2, y]^T $
+## @end tex
+## @end iftex
+## @ifinfo
+## from [z, u]' to [v1, v2, y]' 
+## @end ifinfo
+## can be obtained by (all @acronym{SISO} systems):
 ## @example
 ## GW = buildssic([1, 4; 2, 4; 3, 1], 3, [2, 3, 5],
 ##                [3, 4], G, W1, W2, One);
 ## @end example
-## where "One" is a unity gain (auxillary) function with order 0.
+## where ``One'' is a unity gain (auxillary) function with order 0.
 ## (e.g. @code{One = ugain(1);})
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: April 1998
 
 function sys = buildssic (Clst, Ulst, Olst, Ilst, s1, s2, s3, s4, s5, s6, s7, s8)
 
diff --git a/scripts/control/system/c2d.m b/scripts/control/system/c2d.m
--- a/scripts/control/system/c2d.m
+++ b/scripts/control/system/c2d.m
@@ -15,61 +15,85 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} c2d (@var{sys}, @var{opt}, @var{t})
 ## @deftypefnx {Function File} {} c2d (@var{sys}, @var{t})
 ##
+## Converts the system data structure describing:
+## @iftex
+## @tex
+## $$ \dot x = A_cx + B_cu $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
+## .
+## x = Ac x + Bc u
+## @end example
+## @end ifinfo
+## into a discrete time equivalent model:
+## @iftex
+## @tex
+## $$ x_{n+1} = A_dx_n + B_du_n $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
+## x[n+1] = Ad x[n] + Bd u[n]
+## @end example
+## @end ifinfo
+## via the matrix exponential or bilinear transform.
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ## system data structure (may have both continuous time and discrete
 ## time subsystems)
 ## @item opt
 ## string argument; conversion option (optional argument;
 ## may be omitted as shown above)
 ## @table @code
 ## @item "ex"
 ## use the matrix exponential (default)
 ## @item "bi"
 ## use the bilinear transformation
-## @end table
+## @iftex
+## @tex
+## $$ s = { 2(z-1) \over T(z+1) } $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
 ##     2(z-1)
 ## s = -----
 ##     T(z+1)
 ## @end example
+## @end ifinfo
 ## FIXME: This option exits with an error if @var{sys} is not purely
 ## continuous. (The @code{ex} option can handle mixed systems.)
-## @item t
-## sampling time; required if sys is purely continuous.
-##
-## If the 2nd argument is not a string, @code{c2d} assumes that
-## the 2nd argument is @var{t} and performs appropriate argument checks.
 ## @item "matched"
 ## Use the matched pole/zero equivalent transformation (currently only
-## works for purely continuous SISO systems).
+## works for purely continuous @acronym{SISO} systems).
+## @end table
+## @item t
+## sampling time; required if @var{sys} is purely continuous.
+## 
+## @strong{Note:} if the second argument is not a string, @code{c2d()}
+## assumes that the second argument is @var{t} and performs 
+## appropriate argument checks.
 ## @end table
 ##
-## @strong{Outputs}
-## @var{dsys} discrete time equivalent via zero-order hold,
-## sample each @var{t} sec.
-##
-## converts the system data structure describing
-## @example
-## .
-## x = Ac x + Bc u
-## @end example
-## into a discrete time equivalent model
-## @example
-## x[n+1] = Ad x[n] + Bd u[n]
-## @end example
-## via the matrix exponential or bilinear transform
+## @strong{Output}
+## @table @var
+## @item dsys 
+## Discrete time equivalent via zero-order hold, sample each @var{t} sec.
+## @end table
 ##
 ## This function adds the suffix  @code{_d}
 ## to the names of the new discrete states.
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: October 1993
 ## Updated by John Ingram for system data structure August 1996
diff --git a/scripts/control/system/d2c.m b/scripts/control/system/d2c.m
--- a/scripts/control/system/d2c.m
+++ b/scripts/control/system/d2c.m
@@ -14,26 +14,26 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} d2c (@var{sys}, @var{tol})
 ## @deftypefnx {Function File} {} d2c (@var{sys}, @var{opt})
-## Convert discrete (sub)system to a purely continuous system.  Sampling
-## time used is @code{sysgettsam(@var{sys})}
+## Convert a discrete (sub)system into a purely continuous one. 
+## The sampling time used is @code{sysgettsam(@var{sys})}.
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item   sys
 ## system data structure with discrete components
 ## @item   tol
 ## Scalar value.
-## tolerance for convergence of default @code{"log"} option (see below)
+## Tolerance for convergence of default @code{"log"} option (see below)
 ## @item   opt
 ## conversion option.  Choose from:
 ## @table @code
 ## @item         "log"
 ## (default) Conversion is performed via a matrix logarithm.
 ## Due to some problems with this computation, it is
 ## followed by a steepest descent algorithm to identify continuous time
 ## @var{a}, @var{b}, to get a better fit to the original data.
@@ -45,18 +45,21 @@
 ## Conversion is performed via bilinear transform
 ## @math{z = (1 + s T / 2)/(1 - s T / 2)} where @math{T} is the
 ## system sampling time (see @code{sysgettsam}).
 ##
 ## FIXME: bilinear option exits with an error if @var{sys} is not purely
 ## discrete
 ## @end table
 ## @end table
-## @strong{Outputs} @var{csys} continuous time system (same dimensions and
-## signal names as in @var{sys}).
+## @strong{Output}
+## @table @var
+## @item csys 
+## continuous time system (same dimensions and signal names as in @var{sys}).
+## @end table
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: August 23, 1994
 ## Updated by John Ingram for system data structure  August 1996
 
 function csys = d2c (sys, opt)
 
diff --git a/scripts/control/system/fir2sys.m b/scripts/control/system/fir2sys.m
--- a/scripts/control/system/fir2sys.m
+++ b/scripts/control/system/fir2sys.m
@@ -13,50 +13,60 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} fir2sys (@var{num}, @var{tsam}, @var{inname}, @var{outname})
-## construct a system data structure from FIR description
+## construct a system data structure from @acronym{FIR} description
 ##
-## @strong{Inputs:}
+## @strong{Inputs}
 ## @table @var
 ## @item num
-## vector of coefficients @math{[c_0 c_1 ... c_n]}
-## of the SISO FIR transfer function
+## vector of coefficients 
 ## @ifinfo
-##
-## C(z) = c0 + c1*z^@{-1@} + c2*z^@{-2@} + ... + znz^@{-n@}
-##
+## [c0, c1, ..., cn]
 ## @end ifinfo
 ## @iftex
 ## @tex
-## $$C(z) = c0 + c1*z^{-1} + c2*z^{-2} + ... + znz^{-n}$$
+## $ [c_0, c_1, \ldots, c_n ]$
+## @end tex
+## @end iftex
+## of the @acronym{SISO} @acronym{FIR} transfer function
+## @ifinfo
+## C(z) = c0 + c1*z^(-1) + c2*z^(-2) + ... + cn*z^(-n)
+## @end ifinfo
+## @iftex
+## @tex
+## $$ C(z) = c_0 + c_1z^{-1} + c_2z^{-2} + \ldots + c_nz^{-n} $$
 ## @end tex
 ## @end iftex
 ##
 ## @item tsam
 ## sampling time (default: 1)
 ##
 ## @item inname
 ## name of input signal;  may be a string or a list with a single entry.
 ##
 ## @item outname
 ## name of output signal; may be a string or a list with a single entry.
 ## @end table
 ##
-## @strong{Outputs}
-## @var{sys} (system data structure)
+## @strong{Output}
+## @table @var
+## @item sys
+## system data structure
+## @end table
 ##
 ## @strong{Example}
 ## @example
-## octave:1> sys = fir2sys([1 -1 2 4],0.342,"A/D input","filter output");
+## octave:1> sys = fir2sys([1 -1 2 4],0.342,\
+## > "A/D input","filter output");
 ## octave:2> sysout(sys)
 ## Input(s)
 ##         1: A/D input
 ##
 ## Output(s):
 ##         1: filter output (discrete)
 ##
 ## Sampling interval: 0.342
diff --git a/scripts/control/system/is_abcd.m b/scripts/control/system/is_abcd.m
--- a/scripts/control/system/is_abcd.m
+++ b/scripts/control/system/is_abcd.m
@@ -12,21 +12,21 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} is_abcd (@var{a}, @var{b}, @var{c}, @var{d})
+## @deftypefn {Function File} {@var{retval} =} is_abcd (@var{a}, @var{b}, @var{c}, @var{d})
 ##  Returns @var{retval} = 1 if the dimensions of @var{a}, @var{b},
 ##  @var{c}, @var{d} are compatible, otherwise @var{retval} = 0 with an
 ##  appropriate diagnostic message printed to the screen.  The matrices
-##  b, c, or d may be omitted.
+##  @var{b}, @var{c}, or @var{d} may be omitted.
 ## @end deftypefn
 ## @seealso{abcddim}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: November 4, 1997
 ## based on is_controllable.m of Scottedward Hodel
 
 function retval = is_abcd (a, b, c, d)
diff --git a/scripts/control/system/is_controllable.m b/scripts/control/system/is_controllable.m
--- a/scripts/control/system/is_controllable.m
+++ b/scripts/control/system/is_controllable.m
@@ -33,18 +33,18 @@
 ## @end table
 ##
 ## @strong{Outputs}
 ## @table @var
 ## @item retval
 ## Logical flag; returns true (1) if the system @var{sys} or the
 ## pair (@var{a}, @var{b}) is controllable, whichever was passed as input
 ## arguments.
-## @item U
-##  U is an orthogonal basis of the controllable subspace.
+## @item u
+## @var{u} is an orthogonal basis of the controllable subspace.
 ## @end table
 ##
 ## @strong{Method}
 ## Controllability is determined by applying Arnoldi iteration with
 ## complete re-orthogonalization to obtain an orthogonal basis of the
 ## Krylov subspace
 ## @example
 ## span ([b,a*b,...,a^@{n-1@}*b]).
diff --git a/scripts/control/system/is_detectable.m b/scripts/control/system/is_detectable.m
--- a/scripts/control/system/is_detectable.m
+++ b/scripts/control/system/is_detectable.m
@@ -18,19 +18,19 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{retval} =} is_detectable (@var{a}, @var{c}, @var{tol}, @var{dflg})
 ## @deftypefnx {Function File} {@var{retval} =} is_detectable (@var{sys}, @var{tol})
 ## Test for detactability (observability of unstable modes) of (@var{a}, @var{c}).
 ##
 ## Returns 1 if the system @var{a} or the pair (@var{a}, @var{c}) is
 ## detectable, 0 if not, and -1 if the system has unobservable modes at the
-## imaginary axis (unit circle for discrete-time systems)
+## imaginary axis (unit circle for discrete-time systems).
 ##
-## @strong{See} @code{is_stabilizable} for detailed description of
+## @strong{See} @command{is_stabilizable} for detailed description of
 ## arguments and computational method.
 ##
 ##
 ## @end deftypefn
 ## @seealso{is_stabilizable, size, rows, columns, length, ismatrix,
 ## isscalar, and isvector}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
diff --git a/scripts/control/system/is_digital.m b/scripts/control/system/is_digital.m
--- a/scripts/control/system/is_digital.m
+++ b/scripts/control/system/is_digital.m
@@ -12,29 +12,38 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} is_digital (@var{sys})
-## Return nonzero if system is digital;
-## inputs:
-## sys: system data structure
-## eflg: 0 [default] exit with an error if system is mixed (continuous and
-## discrete components)
-##     : 1 print a warning if system is mixed (continuous and discrete)
-##     : 2 silent operation
-## outputs:
-## DIGITAL:  0: system is purely continuous
-##        :  1: system is purely discrete
-##        : -1: system is mixed continuous and discrete
-## Exits with an error of sys is a mixed (continuous and discrete) system
+## @deftypefn {Function File} {@var{digital} =} is_digital (@var{sys}, @var{eflg})
+## Return nonzero if system is digital.
+##
+## @strong{Inputs}
+## @table @var
+## @item sys
+## System data structure.
+## @item eflg
+## When equal to 0 (default value), exits with an error if the system 
+## is mixed (continuous and discrete components); when equal to 1, print
+## a warning if the system is mixed (continuous and discrete); when equal
+## to 2, operate silently.
+## @end table
+##
+## @strong{Output}
+## @table @var
+## @item digital
+## When equal to 0, the system is purely continuous; when equal to 1, the
+## system is purely discrete; when equal to -1, the system is mixed continuous 
+## and discrete.
+## @end table
+## Exits with an error if @var{sys} is a mixed (continuous and discrete) system.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996
 
 function DIGITAL = is_digital (sys, eflg)
 
   switch(nargin)
diff --git a/scripts/control/system/is_observable.m b/scripts/control/system/is_observable.m
--- a/scripts/control/system/is_observable.m
+++ b/scripts/control/system/is_observable.m
@@ -16,22 +16,22 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{retval}, @var{u}] =} is_observable (@var{a}, @var{c}, @var{tol})
 ## @deftypefnx {Function File} {[@var{retval}, @var{u}] =} is_observable (@var{sys}, @var{tol})
 ## Logical check for system observability.
 ##
-## Default: tol = 10*norm(a,'fro')*eps
+## Default: tol = @code{tol = 10*norm(a,'fro')*eps}
 ##
 ## Returns 1 if the system @var{sys} or the pair (@var{a}, @var{c}) is
 ## observable, 0 if not.
 ##
-## @strong{See} @code{is_controllable} for detailed description of arguments
+## See @command{is_controllable} for detailed description of arguments
 ## and default values.
 ## @end deftypefn
 ## @seealso{size, rows, columns, length, ismatrix, isscalar, and isvector}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
diff --git a/scripts/control/system/is_sample.m b/scripts/control/system/is_sample.m
--- a/scripts/control/system/is_sample.m
+++ b/scripts/control/system/is_sample.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} is_sample (@var{ts})
 ## Return true if @var{ts} is a valid sampling time
-## (real,scalar, > 0)
+## (real, scalar, > 0).
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1995
 
 function out = is_sample (Ts)
 
   out = (isscalar (Ts) && (Ts == abs (Ts)) && (Ts != 0));
diff --git a/scripts/control/system/is_siso.m b/scripts/control/system/is_siso.m
--- a/scripts/control/system/is_siso.m
+++ b/scripts/control/system/is_siso.m
@@ -13,17 +13,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} is_siso (@var{sys})
-## return nonzero if the system data structure
+## Returns nonzero if the system data structure
 ## @var{sys} is single-input, single-output.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996, 1998
 
 function  SISO = is_siso (sys)
 
diff --git a/scripts/control/system/is_stabilizable.m b/scripts/control/system/is_stabilizable.m
--- a/scripts/control/system/is_stabilizable.m
+++ b/scripts/control/system/is_stabilizable.m
@@ -1,8 +1,10 @@
+## Copyright (C) 1998 Kai P. Mueller.
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
@@ -14,25 +16,32 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{retval} =} is_stabilizable (@var{sys}, @var{tol})
 ## @deftypefnx {Function File} {@var{retval} =} is_stabilizable (@var{a}, @var{b}, @var{tol}, @var{dflg})
 ## Logical check for system stabilizability (i.e., all unstable modes are controllable). 
 ## Returns 1 if the system is stabilizable, 0 if the the system is not stabilizable, -1 
-## if the system has non stabilizable modes at the imaginary axis (unit circle for discrete-time
-## systems.
+## if the system has non stabilizable modes at the imaginary axis (unit circle for 
+## discrete-time systems.
 ##
-## Test for stabilizability is performed via Hautus Lemma. If @var{dflg}!=0 assume that 
-## discrete-time matrices (a,b) are supplied.
-##
-
-## See also: size, rows, columns, length, ismatrix, isscalar, isvector
-##     is_observable, is_stabilizable, is_detectable
+## Test for stabilizability is performed via Hautus Lemma. If 
+## @iftex
+## @tex
+## @var{dflg}$\neq$0
+## @end tex
+## @end iftex
+## @ifinfo 
+## @var{dflg}!=0
+## @end ifinfo
+## assume that discrete-time matrices (a,b) are supplied.
+## @end deftypefn
+## @seealso{size, rows, columns, length, ismatrix, isscalar, isvector
+## is_observable, is_stabilizable, is_detectable}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 to accept systems
 
 function retval = is_stabilizable (a, b, tol, dflg)
 
diff --git a/scripts/control/system/is_stable.m b/scripts/control/system/is_stable.m
--- a/scripts/control/system/is_stable.m
+++ b/scripts/control/system/is_stable.m
@@ -20,25 +20,25 @@
 ## @deftypefn {Function File} {} is_stable (@var{a}, @var{tol}, @var{dflg})
 ## @deftypefnx {Function File} {} is_stable (@var{sys}, @var{tol})
 ## Returns 1 if the matrix @var{a} or the system @var{sys}
 ## is stable, or 0 if not.
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item  tol
-## is a roundoff paramter, set to 200*@var{eps} if omitted.
+## is a roundoff parameter, set to 200*@code{eps} if omitted.
 ## @item dflg
 ## Digital system flag (not required for system data structure):
 ## @table @code
 ## @item @var{dflg} != 0
-## stable if eig(a) in unit circle
+## stable if eig(a) is in the unit circle
 ##
 ## @item @var{dflg} == 0
-## stable if eig(a) in open LHP (default)
+## stable if eig(a) is in the open LHP (default)
 ## @end table
 ## @end table
 ## @end deftypefn
 ## @seealso{size, rows, columns, length, ismatrix, isscalar, isvector
 ## is_observable, is_stabilizable, is_detectable, krylov, and krylovb}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
diff --git a/scripts/control/system/jet707.m b/scripts/control/system/jet707.m
--- a/scripts/control/system/jet707.m
+++ b/scripts/control/system/jet707.m
@@ -12,22 +12,33 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} jet707 ()
-## Creates linearized state space model of a Boeing 707-321 aircraft
-## at v=80m/s. (M = 0.26, Ga0 = -3 deg, alpha0 = 4 deg, kappa = 50 deg)
-## System inputs:   (1) thrust   and (2) elevator angle
-## System outputs:  (1) airspeed and (2) pitch angle
-## Ref: R. Brockhaus: Flugregelung (Flight Control), Springer, 1994
+## @deftypefn {Function File} {@var{sys} =} jet707 ()
+## Creates a linearized state-space model of a Boeing 707-321 aircraft
+## at @var{v}=80 m/s 
+## @iftex
+## @tex
+## ($M = 0.26$, $G_{a0} = -3^{\circ}$, ${\alpha}_0 = 4^{\circ}$, ${\kappa}= 50^{\circ}$).
+## @end tex
+## @end iftex
+## @ifinfo
+## (@var{M} = 0.26, @var{Ga0} = -3 deg, @var{alpha0} = 4 deg, @var{kappa} = 50 deg).
+## @end ifinfo
+##
+## System inputs: (1) thrust and (2) elevator angle.
+##
+## System outputs:  (1) airspeed and (2) pitch angle.
+##
+## @strong{Reference}: R. Brockhaus: @cite{Flugregelung} (Flight Control), Springer, 1994.
 ## @end deftypefn
 ## @seealso{ord2}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 28, 1997
 
 function outsys = jet707 ()
 
diff --git a/scripts/control/system/moddemo.m b/scripts/control/system/moddemo.m
--- a/scripts/control/system/moddemo.m
+++ b/scripts/control/system/moddemo.m
@@ -13,17 +13,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} moddemo (@var{inputs})
-## Octave Controls toolbox demo: Model Manipulations demo
+## Octave Control toolbox demo: Model Manipulations demo.
 ## @end deftypefn
 
 ## Author: David Clem
 ## Created: August 15, 1994
 ## a s hodel: updated to reflect updated output order in ss2zp
 
 function moddemo ()
 
diff --git a/scripts/control/system/ord2.m b/scripts/control/system/ord2.m
--- a/scripts/control/system/ord2.m
+++ b/scripts/control/system/ord2.m
@@ -14,38 +14,52 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ord2 (@var{nfreq}, @var{damp}, @var{gain})
 ## Creates a continuous 2nd order system with parameters:
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item nfreq
 ## natural frequency [Hz]. (not in rad/s)
 ## @item damp
 ## damping coefficient
 ## @item gain
 ## dc-gain
 ## This is steady state value only for damp > 0.
 ## gain is assumed to be 1.0 if ommitted.
 ## @end table
-## @strong{Outputs}
-## @var{outsys}
-## system data structure has representation with @math{w = 2 * pi * nfreq}:
+##
+## @strong{Output}
+## @table @var
+## @item outsys
+## system data structure has representation with 
+## @ifinfo
+## @math{w = 2 * pi * nfreq}:
+## @end ifinfo
+## @iftex
+## @tex
+## $ w = 2  \pi  f $:
+## @end tex
+## @end iftex
 ## @example
+## @group
 ##     /                                        \
 ##     | / -2w*damp -w \  / w \                 |
 ## G = | |             |, |   |, [ 0  gain ], 0 |
 ##     | \   w       0 /  \ 0 /                 |
 ##     \                                        /
+## @end group
 ## @end example
-## @strong{See also} @code{jet707} (MIMO example, Boeing 707-321
+## @end table
+## @strong{See also} @command{jet707} (@acronym{MIMO} example, Boeing 707-321
 ## aircraft model)
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 28, 1997
 
 function outsys = ord2 (nfreq, damp, gain)
 
diff --git a/scripts/control/system/parallel.m b/scripts/control/system/parallel.m
--- a/scripts/control/system/parallel.m
+++ b/scripts/control/system/parallel.m
@@ -12,28 +12,32 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} parallel (@var{asys}, @var{bsys})
+## @deftypefn {Function File} {@var{ksys} =} parallel (@var{asys}, @var{bsys})
 ## Forms the parallel connection of two systems.
 ##
-##              ____________________
-##              |      ________    |
+## @example
+## @group
+##              --------------------
+##              |      --------    |
 ##     u  ----->|----> | asys |--->|----> y1
 ##         |    |      --------    |
-##         |    |      ________    |
+##         |    |      --------    |
 ##         |--->|----> | bsys |--->|----> y2
 ##              |      --------    |
 ##              --------------------
 ##                   ksys
+## @end group
+## @end example
 ## @end deftypefn
 
 ## Author: David Clem
 ## Created: August 15, 1994
 ## completely rewritten Oct 1996 a s hodel
 ## SYS_INTERNAL accesses members of system structure
 
 function sysp = parallel (Asys, Bsys)
diff --git a/scripts/control/system/ss.m b/scripts/control/system/ss.m
--- a/scripts/control/system/ss.m
+++ b/scripts/control/system/ss.m
@@ -12,19 +12,19 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} ss (@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam}, @var{n}, @var{nz}, @var{stname}, @var{inname}, @var{outname}, @var{outlist})
+## @deftypefn {Function File} {@var{outsys} =} ss (@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam}, @var{n}, @var{nz}, @var{stname}, @var{inname}, @var{outname}, @var{outlist})
 ## Create system structure from state-space data.   May be continous,
-## discrete, or mixed (sampeled-data)
+## discrete, or mixed (sampled data)
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item a
 ## @itemx b
 ## @itemx c
 ## @itemx d
 ## usual state space matrices.
@@ -70,18 +70,21 @@
 ## If @var{tsam} is greater than 0, @math{outlist = 1:@code{rows}(@var{c})}.
 ## @end table
 ##
 ## Unlike states, discrete/continous outputs may appear in any order.
 ##
 ## @code{sys2ss} returns a vector @var{yd} where
 ## @var{yd}(@var{outlist}) = 1; all other entries of @var{yd} are 0.
 ##
-## @strong{Outputs}
-## @var{outsys} = system data structure
+## @strong{Output}
+## @table @var
+## @item outsys
+## system data structure
+## @end table
 ##
 ## @strong{System partitioning}
 ##
 ## Suppose for simplicity that outlist specified
 ## that the first several outputs were continuous and the remaining outputs
 ## were discrete.  Then the system is partitioned as
 ## @example
 ## @group
diff --git a/scripts/control/system/ss2sys.m b/scripts/control/system/ss2sys.m
--- a/scripts/control/system/ss2sys.m
+++ b/scripts/control/system/ss2sys.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ss (@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam}, @var{n}, @var{nz}, @var{stname}, @var{inname}, @var{outname}, @var{outlist})
 ## Create system structure from state-space data.   May be continous,
-## discrete, or mixed (sampeled-data)
+## discrete, or mixed (sampled data)
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item a
 ## @itemx b
 ## @itemx c
 ## @itemx d
 ## usual state space matrices.
diff --git a/scripts/control/system/ss2tf.m b/scripts/control/system/ss2tf.m
--- a/scripts/control/system/ss2tf.m
+++ b/scripts/control/system/ss2tf.m
@@ -12,33 +12,49 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} ss2tf (@var{inputs})
-## @format
-## [num,den] = ss2tf(a,b,c,d)
+## @deftypefn {Function File} {[@var{num}, @var{den}] =} ss2tf (@var{a}, @var{b}, @var{c}, @var{d})
 ## Conversion from tranfer function to state-space.
-## The state space system
+## The state space system:
+## @iftex
+## @tex
+## $$ \dot x = Ax + Bu $$
+## $$ y = Cx + Du $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
 ##       .
 ##       x = Ax + Bu
 ##       y = Cx + Du
+## @end example
+## @end ifinfo
 ##
-## is converted to a transfer function
+## is converted to a transfer function:
+## @iftex
+## @tex
+## $$ G(s) = { { \rm num }(s) \over { \rm den }(s) } $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
 ##
 ##                 num(s)
 ##           G(s)=-------
 ##                 den(s)
+## @end example
+## @end ifinfo
 ##
-## used internally in system data structure format manipulations
-## @end format
+## used internally in system data structure format manipulations.
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: June 24, 1994
 ## a s hodel: modified to allow for pure gain blocks Aug 1996
 
 function [num, den] = ss2tf (a, b, c, d)
 
diff --git a/scripts/control/system/ss2zp.m b/scripts/control/system/ss2zp.m
--- a/scripts/control/system/ss2zp.m
+++ b/scripts/control/system/ss2zp.m
@@ -12,25 +12,21 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} ss2zp (@var{inputs})
-## @format
-## Converts a state space representation to a set of poles and zeros.
+## @deftypefn {Function File} {[@var{pol}, @var{zer}, @var{k}] =} ss2zp (@var{a}, @var{b}, @var{c}, @var{d})
+## Converts a state space representation to a set of poles and zeros;
+## @var{k} is a gain associated with the zeros.
 ##
-## [pol,zer,k] = ss2zp(a,b,c,d) returns the poles and zeros of the state space
-## system (a,b,c,d).  K is a gain associated with the zeros.
-##
-## used internally in system data structure format manipulations
-## @end format
+## Used internally in system data structure format manipulations.
 ## @end deftypefn
 
 ## Author: David Clem
 ## Created: August 15, 1994
 ## Hodel: changed order of output arguments to zer, pol, k. July 1996
 ## a s hodel: added argument checking, allow for pure gain blocks aug 1996
 
 function [zer, pol, k] = ss2zp (a, b, c, d)
diff --git a/scripts/control/system/starp.m b/scripts/control/system/starp.m
--- a/scripts/control/system/starp.m
+++ b/scripts/control/system/starp.m
@@ -13,43 +13,43 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} starp (@var{P}, @var{K}, @var{ny}, @var{nu})
-## @format
 ##
 ## Redheffer star product or upper/lower LFT, respectively.
-##
+## @example
+## @group
 ##
 ##                +-------+
 ##      --------->|       |--------->
 ##                |   P   |
 ##           +--->|       |---+  ny
 ##           |    +-------+   |
 ##           +-------------------+
 ##                            |  |
 ##           +----------------+  |
 ##           |                   |
 ##           |    +-------+      |
 ##           +--->|       |------+ nu
 ##                |   K   |
 ##      --------->|       |--------->
 ##                +-------+
+## @end group
+## @end example
+## If @var{ny} and @var{nu} ``consume'' all inputs and outputs of
+## @var{K} then the result is a lower fractional transformation. 
+## If @var{ny} and @var{nu} ``consume'' all inputs and outputs of 
+## @var{P} then the result is an upper fractional transformation.
 ##
-## If ny and nu "consume" all inputs and outputs of K then the result
-## is a lower fractional transformation. If ny and nu "consume" all
-## inputs and outputs of P then the result is an upper fractional
-## transformation.
-##
-## ny and/or nu may be negative (= negative feedback)
-## @end format
+## @var{ny} and/or @var{nu} may be negative (i.e. negative feedback).
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: May 1998
 
 function sys = starp (P, K, ny, nu);
 
   if((nargin != 2) && (nargin != 4))
diff --git a/scripts/control/system/sys2fir.m b/scripts/control/system/sys2fir.m
--- a/scripts/control/system/sys2fir.m
+++ b/scripts/control/system/sys2fir.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{c}, @var{tsam}, @var{input}, @var{output}] =} sys2fir (@var{sys})
 ##
-## Extract FIR data from system data structure; see fir2sys for
+## Extract @acronym{FIR} data from system data structure; see @command{fir2sys} for
 ## parameter descriptions.
 ## @end deftypefn
 ## @seealso{fir2sys}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996
 
 function [c, tsam, inname, outname] = sys2fir (sys)
diff --git a/scripts/control/system/sys2ss.m b/scripts/control/system/sys2ss.m
--- a/scripts/control/system/sys2ss.m
+++ b/scripts/control/system/sys2ss.m
@@ -15,48 +15,51 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam}, @var{n}, @var{nz}, @var{stname}, @var{inname}, @var{outname}, @var{yd}] =} sys2ss (@var{sys})
 ## Extract state space representation from system data structure.
 ##
-## @strong{Inputs}
-## @var{sys} system data structure
+## @strong{Input}
+## @table @var
+## @item sys
+## System data structure.
+## @end table
 ##
 ## @strong{Outputs}
 ## @table @var
 ## @item a
 ## @itemx b
 ## @itemx c
 ## @itemx d
-## state space matrices for sys
+## State space matrices for @var{sys}.
 ##
 ## @item tsam
-## sampling time of sys (0 if continuous)
+## Sampling time of @var{sys} (0 if continuous).
 ##
 ## @item n
 ## @itemx nz
-## number of continuous, discrete states (discrete states come
-## last in state vector @var{x})
+## Number of continuous, discrete states (discrete states come
+## last in state vector @var{x}).
 ##
 ## @item stname
 ## @itemx inname
 ## @itemx outname
-## signal names (lists of strings);  names of states,
-## inputs, and outputs, respectively
+## Signal names (lists of strings);  names of states,
+## inputs, and outputs, respectively.
 ##
 ## @item yd
-## binary vector; @var{yd}(@var{ii}) is 1 if output @var{y}(@var{ii})$
-## is discrete (sampled); otherwise  @var{yd}(@var{ii}) 0.
+## Binary vector; @var{yd}(@var{ii}) is 1 if output @var{y}(@var{ii})
+## is discrete (sampled); otherwise  @var{yd}(@var{ii}) is 0.
 ##
 ## @end table
 ## A warning massage is printed if the system is a mixed
-## continuous and discrete system
+## continuous and discrete system.
 ##
 ## @strong{Example}
 ## @example
 ## octave:1> sys=tf2sys([1 2],[3 4 5]);
 ## octave:2> [a,b,c,d] = sys2ss(sys)
 ## a =
 ##    0.00000   1.00000
 ##   -1.66667  -1.33333
diff --git a/scripts/control/system/sys2tf.m b/scripts/control/system/sys2tf.m
--- a/scripts/control/system/sys2tf.m
+++ b/scripts/control/system/sys2tf.m
@@ -13,19 +13,19 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{num}, @var{den}, @var{tsam}, @var{inname}, @var{outname}] =} sys2tf (@var{sys})
-## Extract transfer function data from a system data structure
+## Extract transfer function data from a system data structure.
 ##
-## See tf for parameter descriptions.
+## See @command{tf} for parameter descriptions.
 ##
 ## @strong{Example}
 ## @example
 ## octave:1> sys=ss([1 -2; -1.1,-2.1],[0;1],[1 1]);
 ## octave:2> [num,den] = sys2tf(sys)
 ## num = 1.0000  -3.0000
 ## den = 1.0000   1.1000  -4.3000
 ## @end example
diff --git a/scripts/control/system/sys2zp.m b/scripts/control/system/sys2zp.m
--- a/scripts/control/system/sys2zp.m
+++ b/scripts/control/system/sys2zp.m
@@ -14,19 +14,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ##@deftypefn {Function File} {[@var{zer}, @var{pol}, @var{k}, @var{tsam}, @var{inname}, @var{outname}] =} sys2zp (@var{sys})
 ## Extract zero/pole/leading coefficient information from a system data
-## structure
+## structure.
 ##
-## See zp for parameter descriptions.
+## See @command{zp} for parameter descriptions.
 ##
 ## @strong{Example}
 ## @example
 ## octave:1> sys=ss([1 -2; -1.1,-2.1],[0;1],[1 1]);
 ## octave:2> [zer,pol,k] = sys2zp(sys)
 ## zer = 3.0000
 ## pol =
 ##   -2.6953
diff --git a/scripts/control/system/sysappend.m b/scripts/control/system/sysappend.m
--- a/scripts/control/system/sysappend.m
+++ b/scripts/control/system/sysappend.m
@@ -12,22 +12,22 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} sysappend (@var{sys}, @var{b}, @var{c}, @var{d}, @var{outname}, @var{inname}, @var{yd})
+## @deftypefn {Function File} {@var{sys} =} sysappend (@var{syst}, @var{b}, @var{c}, @var{d}, @var{outname}, @var{inname}, @var{yd})
 ## appends new inputs and/or outputs to a system
 ##
 ## @strong{Inputs}
 ## @table @var
-## @item sys
+## @item syst
 ## system data structure
 ##
 ## @item b
 ## matrix to be appended to sys "B" matrix (empty if none)
 ##
 ## @item c
 ## matrix to be appended to sys "C" matrix (empty if none)
 ##
@@ -40,41 +40,45 @@
 ## @item inname
 ## list of names for new inputs
 ##
 ## @item yd
 ## binary vector; @math{yd(ii)=0} indicates a continuous output;
 ## @math{yd(ii)=1} indicates a discrete output.
 ## @end table
 ##
-## @strong{Outputs} @var{sys}
+## @strong{Outputs}
+## @table @var
+## @item sys
 ## @example
 ## @group
-##    sys.b := [sys.b , b]
-##    sys.c := [sys.c  ]
+##    sys.b := [syst.b , b]
+##    sys.c := [syst.c  ]
 ##             [ c     ]
-##    sys.d := [sys.d | D12 ]
-##             [D21   | D22 ]
+##    sys.d := [syst.d | D12 ]
+##             [ D21   | D22 ]
 ## @end group
 ## @end example
 ## where @math{D12}, @math{D21}, and @math{D22} are the appropriate dimensioned
 ## blocks of the input parameter @var{d}.
 ## @itemize @bullet
 ## @item The leading block @math{D11} of @var{d} is ignored.
 ## @item If @var{inname} and @var{outname} are not given as arguments,
 ##      the new inputs and outputs are be assigned default names.
 ## @item @var{yd} is a binary vector of length rows(c) that indicates
 ##      continuous/sampled outputs.  Default value for @var{yd} is:
-##
-## @item @var{sys} = continuous or mixed
+## @itemize @minus
+## @item @var{sys} is continuous or mixed
 ## @var{yd} = @code{zeros(1,rows(c))}
 ##
-## @item @var{sys} = discrete
+## @item @var{sys} is discrete
 ## @var{yd} = @code{ones(1,rows(c))}
 ## @end itemize
+## @end itemize
+## @end table
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function retsys = sysappend (sys, b, c, d, outname, inname, yd)
 
   save_warn_empty_list_elements = warn_empty_list_elements;
diff --git a/scripts/control/system/sysconnect.m b/scripts/control/system/sysconnect.m
--- a/scripts/control/system/sysconnect.m
+++ b/scripts/control/system/sysconnect.m
@@ -12,55 +12,59 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} sysconnect (@var{sys}, @var{out_idx}, @var{in_idx}, @var{order}, @var{tol})
+## @deftypefn {Function File} {@var{clsys} =} sysconnect (@var{sys}, @var{out_idx}, @var{in_idx}, @var{order}, @var{tol})
 ## Close the loop from specified outputs to respective specified inputs
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item   sys
-## system data structure
+## System data structure.
 ## @item   out_idx
 ## @itemx  in_idx
-## names or indices of signals to connect (see @code{sysidx}).
+## Names or indices of signals to connect (see @code{sysidx}).
 ## The output specified by @math{out_idx(ii)} is connected to the input
 ## specified by @math{in_idx(ii)}.
 ## @item   order
 ## logical flag (default = 0)
 ## @table @code
 ## @item        0
-## leave inputs and outputs in their original order
+## Leave inputs and outputs in their original order.
 ## @item        1
-## permute inputs and outputs to the order shown in the diagram below
+## Permute inputs and outputs to the order shown in the diagram below.
 ## @end table
 ## @item     tol
-## tolerance for singularities in algebraic loops default: 200@var{eps}
+## Tolerance for singularities in algebraic loops, default: 200@code{eps}.
 ## @end table
 ##
 ## @strong{Outputs}
-## @var{sys}: resulting closed loop system.
+## @table @var
+## @item clsys
+## Resulting closed loop system.
+## @end table
 ##
 ## @strong{Method}
+##
 ## @code{sysconnect} internally permutes selected inputs, outputs as shown
 ## below, closes the loop, and then permutes inputs and outputs back to their
 ## original order
 ## @example
 ## @group
-##                  ____________________
+##                  --------------------
 ##  u_1       ----->|                  |----> y_1
 ##                  |        sys       |
 ##          old u_2 |                  |
 ## u_2* ---->(+)--->|                  |----->y_2
-## (in_idx)   ^     -------------------|    | (out_idx)
+## (in_idx)   ^     --------------------    | (out_idx)
 ##            |                             |
 ##            -------------------------------
 ## @end group
 ## @end example
 ## The input that has the summing junction added to it has an * added to
 ## the end  of the input name.
 ## @end deftypefn
 
diff --git a/scripts/control/system/syscont.m b/scripts/control/system/syscont.m
--- a/scripts/control/system/syscont.m
+++ b/scripts/control/system/syscont.m
@@ -15,18 +15,21 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{csys}, @var{acd}, @var{ccd}] =} syscont (@var{sys})
 ## Extract the purely continuous subsystem of an input system.
 ##
-## @strong{Inputs}
-## @var{sys} is a system data structure
+## @strong{Input}
+## @table @var
+## @item sys
+## system data structure.
+## @end table
 ##
 ## @strong{Outputs}
 ## @table @var
 ## @item csys
 ## is the purely continuous input/output connections of @var{sys}
 ## @item acd
 ## @itemx ccd
 ## connections from discrete states to continuous states,
diff --git a/scripts/control/system/sysdisc.m b/scripts/control/system/sysdisc.m
--- a/scripts/control/system/sysdisc.m
+++ b/scripts/control/system/sysdisc.m
@@ -14,27 +14,30 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{dsys}, @var{adc}, @var{cdc}] =} sysdisc (@var{sys})
 ##
-## @strong{Inputs}
-## @var{sys} = system data structure
+## @strong{Input}
+## @table @var
+## @item sys
+## System data structure.
+## @end table
 ##
 ## @strong{Outputs}
 ## @table @var
 ## @item dsys
-## purely discrete portion of sys (returned empty if there is
-## no purely discrete path from inputs to outputs)
+## Purely discrete portion of sys (returned empty if there is
+## no purely discrete path from inputs to outputs).
 ## @item    adc
 ## @itemx   cdc
-## connections from continuous states to discrete states and discrete
+## Connections from continuous states to discrete states and discrete.
 ## outputs, respectively.
 ## @end table
 ## @end deftypefn
 
 function [dsys, Adc, Cdc] = sysdisc (sys)
 
   save_warn_empty_list_elements = warn_empty_list_elements;
   unwind_protect
diff --git a/scripts/control/system/sysdup.m b/scripts/control/system/sysdup.m
--- a/scripts/control/system/sysdup.m
+++ b/scripts/control/system/sysdup.m
@@ -12,46 +12,49 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} sysdup (@var{asys}, @var{out_idx}, @var{in_idx})
+## @deftypefn {Function File} {@var{retsys} =} sysdup (@var{asys}, @var{out_idx}, @var{in_idx})
 ## Duplicate specified input/output connections of a system
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item asys
 ## system data structure
 ## @item out_idx
 ## @itemx in_idx
 ## indices or names of desired signals (see @code{sigidx}).
 ## duplicates are made of @code{y(out_idx(ii))} and @code{u(in_idx(ii))}.
 ## @end table
 ##
-## @strong{Outputs}
-## @var{retsys}: resulting closed loop system:
+## @strong{Output}
+## @table @var
+## @item retsys
+## Resulting closed loop system:
 ## duplicated i/o names are appended with a @code{"+"} suffix.
-##
+## @end table
 ##
 ## @strong{Method}
+##
 ## @code{sysdup} creates copies of selected inputs and outputs as
-## shown below.  u1/y1 is the set of original inputs/outputs, and
-## u2,y2 is the set of duplicated inputs/outputs in the order specified
-## in @var{in_idx}, @var{out_idx}, respectively
+## shown below.  @var{u1}, @var{y1} is the set of original inputs/outputs, and
+## @var{u2}, @var{y2} is the set of duplicated inputs/outputs in the order 
+## specified in @var{in_idx}, @var{out_idx}, respectively
 ## @example
 ## @group
 ##           ____________________
 ## u1  ----->|                  |----> y1
 ##           |       asys       |
 ## u2 ------>|                  |----->y2
-## (in_idx)  -------------------| (out_idx)
+## (in_idx)  -------------------- (out_idx)
 ## @end group
 ## @end example
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram July 1996
 
diff --git a/scripts/control/system/sysgetsignals.m b/scripts/control/system/sysgetsignals.m
--- a/scripts/control/system/sysgetsignals.m
+++ b/scripts/control/system/sysgetsignals.m
@@ -53,58 +53,59 @@
 ## return a string.  Exits with an error if signum does not specify an 
 ## individual signal.
 ## @end table
 ##
 ## @end table
 ##
 ## @strong{Outputs}
 ## @table @bullet
-## @item If @var{sigid} is not specified
+## @item If @var{sigid} is not specified:
 ## @table @var
 ## @item stname
 ## @itemx inname
 ## @itemx outname
 ## signal names (cell array of strings);  names of states,
-## inputs, and outputs, respectively
+## inputs, and outputs, respectively.
 ## @item yd
 ## binary vector; @var{yd}(@var{ii}) is nonzero if output @var{ii} is
 ## discrete.
 ## @end table
 ##
-## @item If @var{sigid} is specified but @var{signum} is not specified, then
+## @item If @var{sigid} is specified but @var{signum} is not specified:
 ## @table @code
 ## @item sigid="in"
-## @var{siglist} is set to the cell array of input names
+## @var{siglist} is set to the cell array of input names.
 ##
 ## @item sigid="out"
-## @var{siglist} is set to the cell array of output names
+## @var{siglist} is set to the cell array of output names.
 ##
 ## @item sigid="st"
-## @var{siglist} is set to the cell array of state names
+## @var{siglist} is set to the cell array of state names.
 ##
 ## stage signals
 ## @item sigid="yd"
 ## @var{siglist} is set to logical vector indicating discrete outputs;
 ## @var{siglist}(@var{ii}) = 0 indicates that output @var{ii} is continuous
 ## (unsampled), otherwise it is discrete.
 ##
 ## @end table
 ##
-## @item if the first three input arguments are specified, then @var{signame} is
-## a cell array of the specified signal names (@var{sigid} is @code{"in"},
-## @code{"out"}, or @code{"st"}), or else the logical flag
+## @item If the first three input arguments are specified:
+## @var{signame} is a cell array of the specified signal names (@var{sigid} is 
+## @code{"in"}, @code{"out"}, or @code{"st"}), or else the logical flag
 ## indicating whether output(s) @var{signum} is(are) discrete (@var{sigval}=1)
 ## or continuous (@var{sigval}=0).
 ## @end table
 ##
 ## @strong{Examples} (From @code{sysrepdemo})
 ## @example
 ## octave> sys=ss(rand(4),rand(4,2),rand(3,4));
-## octave> [Ast,Ain,Aout,Ayd] = sysgetsignals(sys) i  # get all signal names
+## octave># get all signal names
+## octave> [Ast,Ain,Aout,Ayd] = sysgetsignals(sys)
 ## Ast =
 ## (
 ##   [1] = x_1
 ##   [2] = x_2
 ##   [3] = x_3
 ##   [4] = x_4
 ## )
 ## Ain =
@@ -116,28 +117,31 @@
 ## (
 ##   [1] = y_1
 ##   [2] = y_2
 ##   [3] = y_3
 ## )
 ## Ayd =
 ##
 ##   0  0  0
-## octave> Ain = sysgetsignals(sys,"in")   # get only input signal names
+## octave> # get only input signal names:
+## octave> Ain = sysgetsignals(sys,"in")
 ## Ain =
 ## (
 ##   [1] = u_1
 ##   [2] = u_2
 ## )
-## octave> Aout = sysgetsignals(sys,"out",2)   # get name of output 2 (in cell array)
+## octave> # get name of output 2 (in cell array):
+## octave> Aout = sysgetsignals(sys,"out",2)
 ## Aout =
 ## (
 ##   [1] = y_2
 ## )
-## octave> Aout = sysgetsignals(sys,"out",2,1)  # get name of output 2 (as string)
+## octave> # get name of output 2 (as string):
+## octave> Aout = sysgetsignals(sys,"out",2,1)
 ## Aout = y_2
 ## @end example
 ## @end deftypefn
 
 function [stname, inname, outname, yd] = sysgetsignals (sys, sigid, signum, strflg)
 
   ## Adapted from ss
 
diff --git a/scripts/control/system/sysgettype.m b/scripts/control/system/sysgettype.m
--- a/scripts/control/system/sysgettype.m
+++ b/scripts/control/system/sysgettype.m
@@ -15,25 +15,30 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sysgettype (@var{sys})
 ## return the initial system type of the system
 ##
-## @strong{Inputs}
-## @var{sys}: system data structure
+## @strong{Input}
+## @table @var
+## @item sys
+## System data structure.
+## @end table
 ##
-## @strong{Outputs}
-## @var{systype}: string indicating how the structure was initially
-## constructed:
-## values: @code{"ss"}, @code{"zp"}, or @code{"tf"}
+## @strong{Output}
+## @table @var
+## @item systype
+## String indicating how the structure was initially
+## constructed. Values: @code{"ss"}, @code{"zp"}, or @code{"tf"}.
+## @end table
 ##
-## FIR initialized systems return @code{systype="tf"}.
+## @acronym{FIR} initialized systems return @code{systype="tf"}.
 ## @end deftypefn
 
 function systype = sysgettype (sys)
 
   if (! isstruct (sys))
     error ("sysgettype: input sys is not a structure");
   endif
 
diff --git a/scripts/control/system/sysgroup.m b/scripts/control/system/sysgroup.m
--- a/scripts/control/system/sysgroup.m
+++ b/scripts/control/system/sysgroup.m
@@ -12,40 +12,46 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} sysgroup (@var{asys}, @var{bsys})
-## Combines two systems into a single system
+## @deftypefn {Function File} {@var{sys} =} sysgroup (@var{asys}, @var{bsys})
+## Combines two systems into a single system.
 ##
 ## @strong{Inputs}
-## @var{asys}, @var{bsys}: system data structures
+## @table @var
+## @item asys
+## @itemx bsys
+## System data structures.
+## @end table
 ##
-## @strong{Outputs}
+## @strong{Output}
+## @table @var
+## @item sys
 ## @math{sys = @r{block diag}(asys,bsys)}
+## @end table
 ## @example
 ## @group
 ##          __________________
 ##          |    ________    |
 ## u1 ----->|--> | asys |--->|----> y1
 ##          |    --------    |
 ##          |    ________    |
 ## u2 ----->|--> | bsys |--->|----> y2
 ##          |    --------    |
 ##          ------------------
 ##               Ksys
 ## @end group
 ## @end example
 ## The function also rearranges the internal state-space realization of @var{sys}
-## so that the
-## continuous states come first and the discrete states come last.
+## so that the continuous states come first and the discrete states come last.
 ## If there are duplicate names, the second name has a unique suffix appended
 ## on to the end of the name.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram July 1996
 ## A. S. Hodel: modified for variable number of arguments 1999
diff --git a/scripts/control/system/sysmin.m b/scripts/control/system/sysmin.m
--- a/scripts/control/system/sysmin.m
+++ b/scripts/control/system/sysmin.m
@@ -13,30 +13,42 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{retsys}, @var{nc}, @var{no}] =} sysmin (@var{sys}, @var{flg})
-## return a minimal (or reduced order) system
-## inputs:
-##   sys: system data structure
-##   flg: 0 [default] return minimal system; state names lost
-##      : 1           return system with physical states removed that
-##                    are either uncontrollable or unobservable
-##                    (cannot reduce further without discarding physical
-##                    meaning of states)
-## outputs:
-##   retsys: returned system
-##   nc: number of controllable states in the returned system
-##   no: number of observable states in the returned system
-##   cflg: is_controllable(retsys)
-##   oflg: is_observable(retsys)
+## Returns a minimal (or reduced order) system
+##
+## @strong{Inputs}
+## @table @var
+## @item sys
+## System data structure
+## @item flg
+## When equal to 0 (default value), returns minimal system,
+## in which state names are lost; when equal to 1, returns system 
+## with physical states removed that are either uncontrollable or 
+## unobservable (cannot reduce further without discarding physical
+## meaning of states).
+## @end table
+## @strong{Outputs}
+## @table @var
+## @item retsys
+## Returned system.
+## @item nc
+## Number of controllable states in the returned system.
+## @item no
+## Number of observable states in the returned system.
+## @item cflg
+## @code{is_controllable(retsys)}.
+## @item oflg
+## @code{is_observable(retsys)}.
+## @end table
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 
 function [retsys, nc, no, cflg, oflg] = sysmin (sys, flg)
 
   switch(nargin)
   case(1), flg = 0;
diff --git a/scripts/control/system/sysmult.m b/scripts/control/system/sysmult.m
--- a/scripts/control/system/sysmult.m
+++ b/scripts/control/system/sysmult.m
@@ -12,28 +12,28 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} sysmult (@var{asys}, @var{bsys})
+## @deftypefn {Function File} {@var{sys} =} sysmult (@var{Asys}, @var{Bsys})
 ## Compute @math{sys = Asys*Bsys} (series connection):
 ## @example
 ## @group
 ## u   ----------     ----------
-## --->|  bsys  |---->|  asys  |--->
+## --->|  Bsys  |---->|  Asys  |--->
 ##     ----------     ----------
 ## @end group
 ## @end example
-## A warning occurs if there is direct feed-through
-## from an input of Bsys or a continuous state of @var{bsys} through a
-## discrete output of Bsys to a continuous state or output in @var{asys}
+## A warning occurs if there is direct feed-through from an input 
+## or a continuous state of @var{Bsys}, through a discrete output 
+## of @var{Bsys}, to a continuous state or output in @var{Asys}
 ## (system data structure does not recognize discrete inputs).
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 1996
 ## updated for variable number of arguments by A. S. Hodel July 1999
 
 function sys = sysmult (varargin)
diff --git a/scripts/control/system/sysprune.m b/scripts/control/system/sysprune.m
--- a/scripts/control/system/sysprune.m
+++ b/scripts/control/system/sysprune.m
@@ -12,39 +12,41 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} sysprune (@var{asys}, @var{out_idx}, @var{in_idx})
+## @deftypefn {Function File} {@var{retsys} =} sysprune (@var{asys}, @var{out_idx}, @var{in_idx})
 ## Extract specified inputs/outputs from a system
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item asys
 ## system data structure
 ## @item out_idx
 ## @itemx in_idx
-##
 ## Indices or signal names of the outputs and inputs to be kept in the returned
-## system; remaining connections are "pruned" off.
+## system; remaining connections are ``pruned'' off.
 ## May select as [] (empty matrix) to specify all outputs/inputs.
 ##
 ## @example
 ## retsys = sysprune (Asys, [1:3,4], "u_1");
 ## retsys = sysprune (Asys, @{"tx", "ty", "tz"@}, 4);
 ## @end example
 ##
 ## @end table
 ##
-## @strong{Outputs}
-## @var{retsys}: resulting system
+## @strong{Output}
+## @table @var
+## @item retsys
+## Resulting system.
+## @end table
 ## @example
 ## @group
 ##            ____________________
 ## u1 ------->|                  |----> y1
 ##  (in_idx)  |       Asys       | (out_idx)
 ## u2 ------->|                  |----| y2
 ##   (deleted)-------------------- (deleted)
 ## @end group
diff --git a/scripts/control/system/sysreorder.m b/scripts/control/system/sysreorder.m
--- a/scripts/control/system/sysreorder.m
+++ b/scripts/control/system/sysreorder.m
@@ -12,24 +12,32 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} sysreorder (@var{vlen}, @var{list})
+## @deftypefn {Function File} {@var{pv} =} sysreorder (@var{vlen}, @var{list})
 ##
 ## @strong{Inputs}
-## @var{vlen}=vector length, @var{list}= a subset of @code{[1:vlen]},
+## @table @var
+## @item vlen
+## Vector length.
+## @item list
+## A subset of @code{[1:vlen]}.
+## @end table
 ##
-## @strong{Outputs}
-## @var{pv}: a permutation vector to order elements of @code{[1:vlen]} in
+## @strong{Output}
+## @table @var
+## @item pv
+## A permutation vector to order elements of @code{[1:vlen]} in
 ## @code{list} to the end of a vector.
+## @end table
 ##
 ## Used internally by @code{sysconnect} to permute vector elements to their
 ## desired locations.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 
diff --git a/scripts/control/system/sysscale.m b/scripts/control/system/sysscale.m
--- a/scripts/control/system/sysscale.m
+++ b/scripts/control/system/sysscale.m
@@ -12,30 +12,41 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} sysscale (@var{sys}, @var{outscale}, @var{inscale}, @var{outname}, @var{inname})
+## @deftypefn {Function File} {@var{retsys} =} sysscale (@var{sys}, @var{outscale}, @var{inscale}, @var{outname}, @var{inname})
 ## scale inputs/outputs of a system.
 ##
 ## @strong{Inputs}
-## sys: structured system
-## outscale, inscale: constant matrices of appropriate dimension
+## @table @var
+## @item sys
+## Structured system.
+## @item outscale
+## @itemx inscale
+## Constant matrices of appropriate dimension.
+## @item outname
+## @itemx inname
+## Lists of strings with the names of respectively outputs and inputs.
+## @end table
 ##
-## @strong{Outputs}
-## @var{sys}: resulting open loop system:
+## @strong{Output}
+## @table @var
+## @item retsys
+## resulting open loop system:
 ## @example
 ##       -----------    -------    -----------
 ## u --->| inscale |--->| sys |--->| outscale |---> y
 ##       -----------    -------    -----------
 ## @end example
+## @end table
 ## If the input names and output names (each a list of strings)
 ## are not given and the scaling matrices
 ## are not square, then default names will be given to the inputs and/or
 ## outputs.
 ##
 ## A warning message is printed if outscale attempts to add continuous
 ## system outputs to discrete system outputs; otherwise @var{yd} is
 ## set appropriately in the returned value of @var{sys}.
diff --git a/scripts/control/system/syssetsignals.m b/scripts/control/system/syssetsignals.m
--- a/scripts/control/system/syssetsignals.m
+++ b/scripts/control/system/syssetsignals.m
@@ -14,53 +14,58 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} syssetsignals (@var{sys}, @var{opt}, @var{names}, @var{sig_idx})
 ## change the names of selected inputs, outputs and states.
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
-## system data structure
+## System data structure.
 ##
 ## @item opt
-## change default name (output)
+## Change default name (output).
 ##
 ## @table @code
 ## @item "out"
-## change selected output names
+## Change selected output names.
 ## @item "in"
-## change selected input names
+## Change selected input names.
 ## @item "st"
-## change selected state names
+## Change selected state names.
 ## @item "yd"
-## change selected outputs from discrete to continuous or
+## Change selected outputs from discrete to continuous or
 ## from continuous to discrete.
 ## @end table
 ##
 ## @item names
 ## @table @code
-## @item opt = "out", "in", or "st"
+## @item opt = "out", "in", "st"
 ## string or string array containing desired signal names or values.
 ## @item opt = "yd"
 ## To desired output continuous/discrete flag.
 ## Set name to 0 for continuous, or 1 for discrete.
 ## @end table
 ## @item sig_idx
 ## indices or names of outputs, yd, inputs, or
 ## states whose respective names/values should be changed.
 ##
 ## Default: replace entire cell array of names/entire yd vector.
 ## @end table
+##
 ## @strong{Outputs}
-## @var{retsys=sys} with appropriate signal names changed
-## (or yd values, where appropriate)
+## @table @var
+## @item retsys
+## @var{sys} with appropriate signal names changed
+## (or @var{yd} values, where appropriate).
+## @end table
 ##
 ## @strong{Example}
 ## @example
 ## octave:1> sys=ss([1 2; 3 4],[5;6],[7 8]);
 ## octave:2> sys = syssetsignals(sys,"st",str2mat("Posx","Velx"));
 ## octave:3> sysout(sys)
 ## Input(s)
 ##         1: u_1
diff --git a/scripts/control/system/syssub.m b/scripts/control/system/syssub.m
--- a/scripts/control/system/syssub.m
+++ b/scripts/control/system/syssub.m
@@ -12,32 +12,34 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} syssub (@var{gsys}, @var{hsys})
+## @deftypefn {Function File} {@var{sys} =} syssub (@var{Gsys}, @var{Hsys})
 ## Return @math{sys = Gsys - Hsys}.
 ##
-## Method: @var{gsys} and @var{hsys} are connected in parallel
+## @strong{Method}
+##
+## @var{Gsys} and @var{Hsys} are connected in parallel.
 ## The input vector is connected to both systems; the outputs are
-## subtracted.  Returned system names are those of @var{gsys}.
+## subtracted.  Returned system names are those of @var{Gsys}.
 ## @example
 ## @group
 ##          +--------+
-##     +--->|  gsys  |---+
+##     +--->|  Gsys  |---+
 ##     |    +--------+   |
 ##     |                +|
 ## u --+                (_)--> y
 ##     |                -|
 ##     |    +--------+   |
-##     +--->|  hsys  |---+
+##     +--->|  Hsys  |---+
 ##          +--------+
 ## @end group
 ## @end example
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 1996
 ## updated for variable numbers of input arguments by July 1999 A. S. Hodel
diff --git a/scripts/control/system/sysupdate.m b/scripts/control/system/sysupdate.m
--- a/scripts/control/system/sysupdate.m
+++ b/scripts/control/system/sysupdate.m
@@ -34,20 +34,23 @@
 ## @item "ss"
 ## update state space form
 ## @item "all"
 ## all of the above
 ## @end table
 ## @end table
 ##
 ## @strong{Outputs}
-## @var{retsys}: contains union of data in sys and requested data.
-## If requested data in sys is already up to date then retsys=sys.
+## @table @var
+## @item retsys
+## Contains union of data in sys and requested data.
+## If requested data in @var{sys} is already up to date then @var{retsys}=@var{sys}.
+## @end table
 ##
-## Conversion to @code{tf} or @code{zp} exits with an error if the system is
+## Conversion to @command{tf} or @command{zp} exits with an error if the system is
 ## mixed continuous/digital.
 ## @end deftypefn
 ## @seealso{tf, ss, zp, sysout, sys2ss, sys2tf, and sys2zp}
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 9, 1996
 
 function sys = sysupdate (sys, opt)
diff --git a/scripts/control/system/tf2ss.m b/scripts/control/system/tf2ss.m
--- a/scripts/control/system/tf2ss.m
+++ b/scripts/control/system/tf2ss.m
@@ -12,39 +12,51 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} tf2ss (@var{inputs})
-## @format
+## @deftypefn {Function File} {[@var{a}, @var{b}, @var{c}, @var{d}] =} tf2ss (@var{num}, @var{den})
 ## Conversion from tranfer function to state-space.
-## The state space system
+## The state space system:
+## @iftex
+## @tex
+## $$ \dot x = Ax + Bu $$
+## $$ y = Cx + Du $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
 ##       .
 ##       x = Ax + Bu
 ##       y = Cx + Du
-##
-## is obtained from a transfer function
-##
+## @end example
+## @end ifinfo
+## is obtained from a transfer function:
+## @iftex
+## @tex
+## $$ G(s) = { { \rm num }(s) \over { \rm den }(s) } $$
+## @end tex
+## @end iftex
+## @ifinfo
+## @example
 ##                 num(s)
 ##           G(s)=-------
 ##                 den(s)
+## @end example
+## @end ifinfo
 ##
-## via the function call [a,b,c,d] = tf2ss(num,den).
-## The vector 'den' must contain only one row, whereas the vector 'num'
-## may contain as many rows as there are outputs of the system 'y'.
-## The state space system matrices obtained from this function will be
-## in controllable canonical form as described in "Modern Control Theory",
-## [Brogan, 1991].
-##
-##
-## @end format
+## The vector @var{den} must contain only one row, whereas the vector 
+## @var{num} may contain as many rows as there are outputs @var{y} of 
+## the system. The state space system matrices obtained from this function 
+## will be in controllable canonical form as described in @cite{Modern Control 
+## Theory}, (Brogan, 1991).
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: June 22, 1994
 ## mod A S Hodel July, Aug  1995
 
 function [a, b, c, d] = tf2ss (num, den)
 
diff --git a/scripts/control/system/tf2sys.m b/scripts/control/system/tf2sys.m
--- a/scripts/control/system/tf2sys.m
+++ b/scripts/control/system/tf2sys.m
@@ -13,33 +13,36 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} tf2sys (@var{num}, @var{den}, @var{tsam}, @var{inname}, @var{outname})
-## build system data structure from transfer function format data
+## Build system data structure from transfer function format data.
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item  num
 ## @itemx den
-## coefficients of numerator/denominator polynomials
+## Coefficients of numerator/denominator polynomials.
 ## @item tsam
-## sampling interval. default: 0 (continuous time)
+## Sampling interval; default: 0 (continuous time).
 ## @item inname
 ## @itemx outname
-## input/output signal names; may be a string or cell array with a single string
+## Input/output signal names; may be a string or cell array with a single string
 ## entry.
 ## @end table
 ##
-## @strong{Outputs}
-## @var{sys} = system data structure
+## @strong{Output}
+## @table @var
+## @item sys
+## System data structure.
+## @end table
 ##
 ## @strong{Example}
 ## @example
 ## octave:1> sys=tf2sys([2 1],[1 2 1],0.1);
 ## octave:2> sysout(sys)
 ## Input(s)
 ##         1: u_1
 ## Output(s):
diff --git a/scripts/control/system/tf2zp.m b/scripts/control/system/tf2zp.m
--- a/scripts/control/system/tf2zp.m
+++ b/scripts/control/system/tf2zp.m
@@ -12,21 +12,22 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} tf2zp (@var{inputs})
-## Converts transfer functions to poles / zeros.
+## @deftypefn {Function File} {[@var{zer}, @var{pol}, @var{k}] =} tf2zp (@var{num}, @var{den})
+## Converts transfer functions to poles-and-zero representations.
 ##
-## [zer,pol,k] = tf2zp(num,den) returns the zeros and poles of the SISO system
-## defined by num/den.  K is a gain associated with the system zeros.
+## Returns the zeros and poles of the @acronym{SISO} system defined 
+## by @var{num}/@var{den}.
+## @var{k} is a gain associated with the system zeros.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 
 function [zer, pol, k] = tf2zp (num, den)
 
   if (nargin == 2)
     if (length (den) > 1)
diff --git a/scripts/control/system/ugain.m b/scripts/control/system/ugain.m
--- a/scripts/control/system/ugain.m
+++ b/scripts/control/system/ugain.m
@@ -15,18 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ugain (@var{n})
 ## Creates a system with unity gain, no states.
 ## This trivial system is sometimes needed to create arbitrary
-## complex systems from simple systems with buildssic.
-## Watch out if you are forming sampled systems since "ugain"
+## complex systems from simple systems with @command{buildssic}.
+## Watch out if you are forming sampled systems since @command{ugain}
 ## does not contain a sampling period.
 ## @end deftypefn
 ## @seealso{hinfdemo and jet707}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: April 1998
 
 function outsys = ugain (n)
diff --git a/scripts/control/system/zp2ss.m b/scripts/control/system/zp2ss.m
--- a/scripts/control/system/zp2ss.m
+++ b/scripts/control/system/zp2ss.m
@@ -14,41 +14,50 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{a}, @var{b}, @var{c}, @var{d}] =} zp2ss (@var{zer}, @var{pol}, @var{k})
 ## Conversion from zero / pole to state space.
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item zer
 ## @itemx pol
-## vectors of (possibly) complex poles and zeros of a transfer
-## function.  Complex values must come in conjugate pairs
-## (i.e., x+jy in zer means that x-jy is also in zer)
+## Vectors of (possibly) complex poles and zeros of a transfer
+## function. Complex values must come in conjugate pairs
+## (i.e., @math{x+jy} in @var{zer} means that @math{x-jy} is also in @var{zer}).
+## The number of zeros must not exceed the number of poles.
 ## @item k
-## real scalar (leading coefficient)
+## Real scalar (leading coefficient).
 ## @end table
+##
 ## @strong{Outputs}
-##  @var{a}, @var{b}, @var{c}, @var{d}
-## The state space system
+## @table @var
+## @item @var{a}
+## @itemx @var{b}
+## @itemx @var{c}
+## @itemx @var{d}
+## The state space system, in the form:
+## @iftex
+## @tex
+## $$ \dot x = Ax + Bu $$
+## $$ y = Cx + Du $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
-## .
-## x = Ax + Bu
-## y = Cx + Du
+##      .
+##      x = Ax + Bu
+##      y = Cx + Du
 ## @end example
-## is obtained from a vector of zeros and a vector of poles via the
-## function call @code{[a,b,c,d] = zp2ss(zer,pol,k)}.
-## The vectors @samp{zer} and
-## @samp{pol} may either be row or column vectors.  Each zero and pole that
-## has an imaginary part must have a conjugate in the list.
-## The number of zeros must not exceed the number of poles.
-## @samp{k} is @code{zp}-form leading coefficient.
+## @end ifinfo
+## @end table
 ## @end deftypefn
 
 ## Author: David Clem
 ## Created: August 15, 1994
 
 function [a, b, c, d] = zp2ss (zer, pol, k)
 
     if(nargin != 3)
diff --git a/scripts/control/system/zp2sys.m b/scripts/control/system/zp2sys.m
--- a/scripts/control/system/zp2sys.m
+++ b/scripts/control/system/zp2sys.m
@@ -18,30 +18,33 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} zp2sys (@var{zer}, @var{pol}, @var{k}, @var{tsam}, @var{inname}, @var{outname})
 ## Create system data structure from zero-pole data.
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item   zer
-## vector of system zeros
+## Vector of system zeros.
 ## @item   pol
-## vector of system poles
+## Vector of system poles.
 ## @item   k
-## scalar leading coefficient
+## Scalar leading coefficient.
 ## @item   tsam
-## sampling period. default: 0 (continuous system)
+## Sampling period; default: 0 (continuous system).
 ## @item   inname
 ## @itemx  outname
-## input/output signal names (lists of strings)
+## Input/output signal names (lists of strings).
 ## @end table
 ##
-## @strong{Outputs}
-## sys: system data structure
+## @strong{Output}
+## @table @var
+## @item sys
+## System data structure.
+## @end table
 ##
 ## @strong{Example}
 ## @example
 ## octave:1> sys=zp2sys([1 -1],[-2 -2 0],1);
 ## octave:2> sysout(sys)
 ## Input(s)
 ##         1: u_1
 ## Output(s):
diff --git a/scripts/control/system/zp2tf.m b/scripts/control/system/zp2tf.m
--- a/scripts/control/system/zp2tf.m
+++ b/scripts/control/system/zp2tf.m
@@ -14,27 +14,26 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{num}, @var{den}] =} zp2tf (@var{zer}, @var{pol}, @var{k})
 ## Converts zeros / poles to a transfer function.
+##
 ## @strong{Inputs}
 ## @table @var
 ## @item zer
 ## @itemx pol
-## vectors of (possibly complex) poles and zeros of a transfer
-## function.  Complex values should appear in conjugate pairs
+## Vectors of (possibly complex) poles and zeros of a transfer
+## function.  Complex values must appear in conjugate pairs.
 ## @item k
-## real scalar (leading coefficient)
+## Real scalar (leading coefficient).
 ## @end table
-## @code{[num,den] = zp2tf(zer,pol,k)} forms the transfer function
-## @code{num/den} from the vectors of poles and zeros.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## (With help from students Ingram, McGowan.)
 
 function [num, den] = zp2tf (zer, pol, k)
 
   ## Find out whether data was entered as a row or a column vector and
diff --git a/scripts/control/util/__zgpbal__.m b/scripts/control/util/__zgpbal__.m
--- a/scripts/control/util/__zgpbal__.m
+++ b/scripts/control/util/__zgpbal__.m
@@ -14,28 +14,29 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __zgpbal__ (@var{sys})
 ##
-## used internally in @code{tzero}; minimal argument checking performed
+## Used internally in @command{tzero}; minimal argument checking performed.
 ##
-## implementation of zero computation generalized eigenvalue problem
+## Implementation of zero computation generalized eigenvalue problem
 ## balancing method (Hodel and Tiller, Allerton Conference, 1991)
-## Based on Ward's balancing algorithm (SIAM J. Sci Stat. Comput., 1981)
+## Based on Ward's balancing algorithm (@acronym{SIAM} J. Sci Stat. Comput., 1981).
 ##
-## __zgpbal__ computes a state/input/output weighting that attempts to
-## reduced the range of the magnitudes of the nonzero elements of [a,b,c,d]
+## @command{__zgpbal__} computes a state/input/output weighting that attempts to
+## reduced the range of the magnitudes of the nonzero elements of [@var{a}, @var{b},
+## @var{c}, @var{d}].
 ## The weighting uses scalar multiplication by powers of 2, so no roundoff
 ## will occur.
 ##
-## __zgpbal__ should be followed by zgpred
+## @command{__zgpbal__} should be followed by @command{zgpred}.
 ## @end deftypefn
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
diff --git a/scripts/control/util/axis2dlim.m b/scripts/control/util/axis2dlim.m
--- a/scripts/control/util/axis2dlim.m
+++ b/scripts/control/util/axis2dlim.m
@@ -13,25 +13,32 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} {} axis2dlim (@var{axdata})
-## determine axis limits for 2-d data(column vectors); leaves a 10% margin
-## around the plots.
-## puts in margins of +/- 0.1 if data is one dimensional (or a single point)
+## Determine axis limits for 2-D data (column vectors); leaves a 10%
+## margin around the plots.
+## Inserts margins of +/- 0.1 if data is one-dimensional 
+## (or a single point).
 ##
-## @strong{Inputs}
-## @var{axdata} nx2 matrix of data [x,y]
+## @strong{Input}
+## @table @var
+## @item axdata
+## @var{n} by 2 matrix of data [@var{x}, @var{y}].
+## @end table
 ##
-## @strong{Outputs}
-## @var{axvec} vector of axis limits appropriate for call to axis() function
+## @strong{Output}
+## @table @var
+## @item axvec
+## Vector of axis limits appropriate for call to @command{axis} function.
+## @end table
 ## @end deftypefn
 
 function axvec = axis2dlim (axdata)
 
   if(isempty(axdata))
     axdata = 0;
   endif
 
diff --git a/scripts/control/util/prompt.m b/scripts/control/util/prompt.m
--- a/scripts/control/util/prompt.m
+++ b/scripts/control/util/prompt.m
@@ -12,22 +12,27 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} prompt (@var{inputs})
-## @format
-## function prompt([str])
+## @deftypefn {Function File} {} prompt (@var{str})
 ## Prompt user to continue
-## str: input string. Default value: "\n ---- Press a key to continue ---"
-## @end format
+## 
+## @strong{Input}
+## @table @var
+## @item str
+## Input string. Its default value is: 
+## @example 
+## \n ---- Press a key to  continue ---
+## @end example
+## @end table
 ## @end deftypefn
 
 ## Author: David Clem
 ## Created: August 15, 1994
 ## Modified A. S. Hodel June 1995
 
 function prompt (str)
 
diff --git a/scripts/control/util/sortcom.m b/scripts/control/util/sortcom.m
--- a/scripts/control/util/sortcom.m
+++ b/scripts/control/util/sortcom.m
@@ -12,30 +12,44 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} sortcom (@var{inputs})
-## @format
-## [yy,idx] = sortcom(xx[,opt]): sort a complex vector
-## xx: complex vector
-## opt: sorting option:
-##  "re": real part (default)
-##  "mag": by magnitude
-##  "im": by imaginary part
+## @deftypefn {Function File} {[@var{yy}, @var{idx}] =} sortcom (@var{xx}[, @var{opt}])
+## Sort a complex vector.
 ##
-## if opt != "im" then complex conjugate pairs are grouped together,
-## a - jb followed by a + jb.
-## yy: sorted values
-## idx: permutation vector: yy = xx(idx)
-## @end format
+## @strong{Inputs}
+## @table @var
+## @item xx
+## Complex vector
+## @item opt
+## sorting option:
+## @table @code
+## @item "re"
+## Real part (default);
+## @item "mag"
+## By magnitude;
+## @item "im"
+## By imaginary part.
+## @end table
+## if @var{opt} is not chosen as @code{"im"}, then complex conjugate pairs are grouped together,
+## @math{a - jb} followed by @math{a + jb}.
+## @end table
+##
+## @strong{Outputs}
+## @table @var
+## @item yy
+## Sorted values
+## @item idx
+## Permutation vector: @code{yy = xx(idx)}
+## @end table
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function [yy, idx] = sortcom (xx, opt)
 
   if( nargin < 1 | nargin > 2 )
diff --git a/scripts/control/util/zgfmul.m b/scripts/control/util/zgfmul.m
--- a/scripts/control/util/zgfmul.m
+++ b/scripts/control/util/zgfmul.m
@@ -12,19 +12,19 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} zgfmul (@var{a}, @var{b}, @var{c}, @var{d}, @var{x})
-## Compute product of zgep incidence matrix @math{F} with vector @var{x}.
-## Used by zgepbal (in zgscal) as part of generalized conjugate gradient
+## @deftypefn {Function File} {@var{y} =} zgfmul (@var{a}, @var{b}, @var{c}, @var{d}, @var{x})
+## Compute product of @var{zgep} incidence matrix @math{F} with vector @var{x}.
+## Used by @command{zgepbal} (in @command{zgscal}) as part of generalized conjugate gradient
 ## iteration.
 ## @end deftypefn
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
diff --git a/scripts/control/util/zginit.m b/scripts/control/util/zginit.m
--- a/scripts/control/util/zginit.m
+++ b/scripts/control/util/zginit.m
@@ -12,20 +12,20 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} zginit (@var{a}, @var{b}, @var{c}, @var{d})
-## Construct right hand side vector zz
+## @deftypefn {Function File} {@var{zz} =} zginit (@var{a}, @var{b}, @var{c}, @var{d})
+## Construct right hand side vector @var{zz}
 ## for the zero-computation generalized eigenvalue problem
-## balancing procedure.  Called by zgepbal.
+## balancing procedure.  Called by @command{zgepbal}.
 ## @end deftypefn
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
diff --git a/scripts/control/util/zgscal.m b/scripts/control/util/zgscal.m
--- a/scripts/control/util/zgscal.m
+++ b/scripts/control/util/zgscal.m
@@ -12,21 +12,20 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} zgscal (@var{f}, @var{z}, @var{n}, @var{m}, @var{p})
+## @deftypefn {Function File} {@var{x} =} zgscal (@var{f}, @var{z}, @var{n}, @var{m}, @var{p})
 ## Generalized conjugate gradient iteration to
 ## solve zero-computation generalized eigenvalue problem balancing equation
-## @math{fx=z};
-## called by @code{zgepbal}
+## @math{fx=z}; called by @command{zgepbal}.
 ## @end deftypefn
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
diff --git a/scripts/control/util/zgshsr.m b/scripts/control/util/zgshsr.m
--- a/scripts/control/util/zgshsr.m
+++ b/scripts/control/util/zgshsr.m
@@ -12,20 +12,28 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} zgshsr (@var{y})
-## apply householder vector based on @math{e^(m)} to
-## (column vector) y.
-## Called by zgfslv
+## @deftypefn {Function File} {@var{x} =} zgshsr (@var{y})
+## Apply householder vector based on 
+## @iftex
+## @tex
+## $ e^m $
+## @end tex
+## @end iftex
+## @ifinfo
+## @math{e^(m)}
+## @end ifinfo
+## to column vector @var{y}.
+## Called by @command{zgfslv}.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave by R. Bruce Tenison July 3, 1994
 
 function x = zgshsr (y)
 
diff --git a/scripts/elfun/acoth.m b/scripts/elfun/acoth.m
--- a/scripts/elfun/acoth.m
+++ b/scripts/elfun/acoth.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Mapping Function} acoth (@var{x})
+## @deftypefn {Mapping Function} {} acoth (@var{x})
 ## Compute the inverse hyperbolic cotangent of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = acoth (z)
 
   if (nargin != 1)
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -12,24 +12,31 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} polyout (@var{c}, @var{x})
+## @deftypefn {Function File} {} polyout (@var{c}, @var{x})
 ## Write formatted polynomial
+## @iftex
+## @tex
+## $$ c(x) = c_1 x^n + \ldots + c_n x + c_{n+1} $$
+## @end tex
+## @end iftex
+## @ifinfo
 ## @example
 ##    c(x) = c(1) * x^n + ... + c(n) x + c(n+1)
 ## @end example
+## @end ifinfo
 ##  and return it as a string or write it to the screen (if
 ##  @var{nargout} is zero).
-##  @var{x} defaults to the string @code{"s"}
+##  @var{x} defaults to the string @code{"s"}.
 ## @end deftypefn
 ## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
 ## filter, polyderiv, and polyinteg}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: May 1995
 ## Nov 1998: Correctly handles complex coefficients
 
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -27,17 +27,17 @@
 ## $$
 ## v_1 z^{N-1} + \cdots + v_{N-1} z + v_N.
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##
 ## @example
-## v(1) * z^(N-1) + ... + v(N-1) * z + v(N).
+## v(1) * z^(N-1) + ... + v(N-1) * z + v(N)
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
diff --git a/scripts/specfun/log2.m b/scripts/specfun/log2.m
--- a/scripts/specfun/log2.m
+++ b/scripts/specfun/log2.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} log2 (@var{x})
-## @deftypefnx {Mapping Function} {[@var{f}, @var{e}]} log2 (@var{x})
+## @deftypefnx {Mapping Function} {[@var{f}, @var{e}] =} log2 (@var{x})
 ## Compute the base-2 logarithm of @var{x}.  With two outputs, returns
 ## @var{f} and @var{e} such that
 ## @iftex
 ## @tex
 ##  $1/2 <= |f| < 1$ and $x = f \cdot 2^e$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -20,39 +20,38 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} toeplitz (@var{c}, @var{r})
 ## Return the Toeplitz matrix constructed given the first column @var{c},
 ## and (optionally) the first row @var{r}.  If the first element of @var{c}
 ## is not the same as the first element of @var{r}, the first element of
 ## @var{c} is used.  If the second argument is omitted, the first row is
 ## taken to be the same as the first column.
 ##
-## A square Toeplitz matrix has the form
+## A square Toeplitz matrix has the form:
 ## @iftex
 ## @tex
 ## $$
-## \left[\matrix{c_0    & r_1     & r_2      & \ldots & r_n\cr
-##               c_1    & c_0     & r_1      &        & c_{n-1}\cr
-##               c_2    & c_1     & c_0      &        & c_{n-2}\cr
-##               \vdots &         &          &        & \vdots\cr
-##               c_n    & c_{n-1} & c_{n-2} & \ldots & c_0}\right].
+## \left[\matrix{c_0    & r_1     & r_2      & \cdots & r_n\cr
+##               c_1    & c_0     & r_1      & \cdots & r_{n-1}\cr
+##               c_2    & c_1     & c_0      & \cdots & r_{n-2}\cr
+##               \vdots & \vdots  & \vdots   & \ddots & \vdots\cr
+##               c_n    & c_{n-1} & c_{n-2} & \ldots & c_0}\right]
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##
 ## @example
 ## @group
 ## c(0)  r(1)   r(2)  ...  r(n)
-## c(1)  c(0)   r(1)      r(n-1)
-## c(2)  c(1)   c(0)      r(n-2)
-##  .                       .
-##  .                       .
-##  .                       .
-##
+## c(1)  c(0)   r(1)  ... r(n-1)
+## c(2)  c(1)   c(0)  ... r(n-2)
+##  .     ,      ,   .      .
+##  .     ,      ,     .    .
+##  .     ,      ,       .  .
 ## c(n) c(n-1) c(n-2) ...  c(0)
 ## @end group
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
 ## @seealso{hankel, vander, sylvester_matrix, hilb, and invhib}
 
 ## Author: jwe
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -16,38 +16,37 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} vander (@var{c})
 ## Return the Vandermonde matrix whose next to last column is @var{c}.
 ##
-## A Vandermonde matrix has the form
+## A Vandermonde matrix has the form:
 ## @iftex
 ## @tex
 ## $$
-## \left[\matrix{c_0^n  & \ldots & c_0^2  & c_0    & 1\cr
-##               c_1^n  & \ldots & c_1^2  & c_1    & 1\cr
-##               \vdots &        & \vdots & \vdots & \vdots\cr
-##               c_n^n  & \ldots & c_n^2  & c_n    & 1}\right].
+## \left[\matrix{c_1^{n-1}  & \cdots & c_1^2  & c_1    & 1      \cr
+##               c_2^{n-1}  & \cdots & c_2^2  & c_2    & 1      \cr
+##               \vdots     & \ddots & \vdots & \vdots & \vdots \cr
+##               c_n^{n-1}  & \cdots & c_n^2  & c_n    & 1      }\right]
 ## $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##
 ## @example
 ## @group
-## c(0)^n ... c(0)^2  c(0)  1
-## c(1)^n ... c(1)^2  c(1)  1
-##  .           .      .    .
-##  .           .      .    .
-##  .           .      .    .
-##
-## c(n)^n ... c(n)^2  c(n)  1
+## c(1)^(n-1) ... c(1)^2  c(1)  1
+## c(2)^(n-1) ... c(2)^2  c(2)  1
+##     .     .      .      .    .
+##     .       .    .      .    .
+##     .         .  .      .    .
+## c(n)^(n-1) ... c(n)^2  c(n)  1
 ## @end group
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
 ## @seealso{hankel, sylvester_matrix, hilb, invhilb, and toeplitz}
 
 ## Author: jwe
 
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -202,40 +202,58 @@ fout (const int& lsize, const double& al
   else
     return (fabs (p) >= 1 ? 1 : -1);
 }
 
 DEFUN_DLD (qz, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{lambda} =} qz (@var{a}, @var{b})\n\
 Generalized eigenvalue problem @math{A x = s B x},\n\
-@var{QZ} decomposition.  Three ways to call:\n\
+@var{QZ} decomposition. There are three ways to call this function:\n\
 @enumerate\n\
 @item @code{lambda = qz(A,B)}\n\
 \n\
-Computes the generalized eigenvalues @var{lambda} of @math{(A - sB)}.\n\
-\n\
+Computes the generalized eigenvalues\n\
+@iftex\n\
+@tex\n\
+$\\lambda$\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+@var{lambda}\n\
+@end ifinfo\n\
+of @math{(A - s B)}.\n\
 @item @code{[AA, BB, Q, Z, V, W, lambda] = qz (A, B)}\n\
 \n\
 Computes qz decomposition, generalized eigenvectors, and \n\
         generalized eigenvalues of @math{(A - sB)}\n\
+@iftex\n\
+@tex\n\
+$$ AV = BV{ \\rm diag }(\\lambda) $$\n\
+$$ W^T A = { \\rm diag }(\\lambda)W^T B $$\n\
+$$ AA = Q^T AZ, BB = Q^T BZ $$\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
 @example\n\
 @group\n\
-        A V = B V diag(lambda)\n\
-        W' A = diag(lambda) W' B\n\
-        AA = Q'*A*Z, BB = Q'*B*Z  with Q, Z orthogonal (unitary)= I\n\
+        A*V = B*V*diag(lambda)\n\
+        W'*A = diag(lambda)*W'*B\n\
+        AA = Q'*A*Z, BB = Q'*B*Z\n\
 @end group\n\
 @end example\n\
+@end ifinfo\n\
+with @var{Q} and @var{Z} orthogonal (unitary)= @var{I}\n\
 \n\
-@item @code{[AA,BB,Z@{,lambda@}] = qz(A,B,opt)}\n\
+@item @code{[AA,BB,Z@{, lambda@}] = qz(A,B,opt)}\n\
 \n\
 As in form [2], but allows ordering of generalized eigenpairs\n\
         for (e.g.) solution of discrete time algebraic Riccati equations.\n\
-        Form 3 is not available for complex matrices and does not compute\n\
-        the generalized eigenvectors V, W, nor the orthogonal matrix Q.\n\
+        Form 3 is not available for complex matrices, and does not compute\n\
+        the generalized eigenvectors @var{V}, @var{W}, nor the orthogonal matrix @var{Q}.\n\
 @table @var\n\
 @item opt\n\
  for ordering eigenvalues of the GEP pencil.  The leading  block\n\
              of the revised pencil contains all eigenvalues that satisfy:\n\
 @table @code\n\
 @item \"N\"\n\
  = unordered (default) \n\
 \n\
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -223,17 +223,17 @@ fields have a fixed size; numeric fields
 Padding is with zeros by default; for fields that display a single\n\
 number, padding can be changed or inhibited by following the @samp{%}\n\
 with one of the modifiers described below.  Unknown field specifiers are\n\
 copied as normal characters.  All other characters are copied to the\n\
 output without change.  For example,\n\
 \n\
 @example\n\
 @group\n\
-strftime (\"%r (%Z) %A %e %B %Y\", localtime (time ())\n\
+strftime (\"%r (%Z) %A %e %B %Y\", localtime (time ()) )\n\
      @result{} \"01:15:06 AM (CST) Monday 17 February 1997\"\n\
 @end group\n\
 @end example\n\
 \n\
 Octave's @code{strftime} function supports a superset of the ANSI C\n\
 field specifiers.\n\
 \n\
 @noindent\n\
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -689,17 +689,17 @@ to go on.\n\
   return retval;
 }
 
 DEFUN (lasterr, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} lasterr ()\n\
 @deftypefnx {Built-in Function} {} lasterr (@var{msg})\n\
 Without any arguments, return the last error message.  With one\n\
-argument, set the last warning message to @var{msg}.\n\
+argument, set the last error message to @var{msg}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("lasterr");
 
@@ -717,17 +717,17 @@ argument, set the last warning message t
 DEFALIAS (error_text, lasterr);
 DEFALIAS (__error_text__, lasterr);
 
 DEFUN (lastwarn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} lastwarn ()\n\
 @deftypefnx {Built-in Function} {} lastwarn (@var{msg})\n\
 Without any arguments, return the last warning message.  With one\n\
-argument, set the last error message to @var{msg}.\n\
+argument, set the last warning message to @var{msg}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("lastwarn");
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1746,17 +1746,17 @@ system-dependent error message.\n\
   return retval;
 }
 
 DEFUN (mkstemp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{fid}, @var{name}, @var{msg}] =} tmpfile (@var{template}, @var{delete})\n\
 Return the file ID corresponding to a new temporary file with a unique\n\
 name created from @var{template}.  The last six characters of @var{template}\n\
-must be @code{XXXXXX} and tehse are replaced with a string that makes the\n\
+must be @code{XXXXXX} and these are replaced with a string that makes the\n\
 filename unique.  The file is then created with mode read/write and\n\
 permissions that are system dependent (on GNU/Linux systems, the permissions\n\
 will be 0600 for versions of glibc 2.0.7 and later).  The file is opened\n\
 with the @code{O_EXCL} flag.\n\
 \n\
 If the optional argument @var{delete} is supplied and is true,\n\
 the file will be deleted automatically when Octave exits, or when\n\
 the function @code{purge_tmp_files} is called.\n\
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -1159,20 +1159,20 @@ expecting additional input to complete a
 defining a function over several lines, Octave will print the value of\n\
 @code{PS1} at the beginning of each line after the first.  The default\n\
 value of @code{PS2} is @code{\"> \"}.\n\
 @end defvr");
 
   DEFVAR (PS4, "+ ", ps4,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} PS4\n\
-If Octave is invoked with the @code{--echo-input} option, the value of\n\
+If Octave is invoked with the @code{--echo-commands} option, the value of\n\
 @code{PS4} is printed before each line of input that is echoed.  The\n\
 default value of @code{PS4} is @code{\"+ \"}.  @xref{Invoking Octave}, for\n\
-a description of @code{--echo-input}.\n\
+a description of @code{--echo-commands}.\n\
 @end defvr");
 
   DEFVAR (completion_append_char, " ", completion_append_char,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} completion_append_char\n\
 The value of @code{completion_append_char} is used as the character to\n\
 append to successful command-line completion attempts.  The default\n\
 value is @code{\" \"} (a single space).\n\
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -217,17 +217,16 @@ Compute the argument of @var{z}, defined
 @iftex\n\
 @tex\n\
 $\\theta = \\tan^{-1}(y/x)$.\n\
 @end tex\n\
 @end iftex\n\
 @ifinfo\n\
 @var{theta} = @code{atan (@var{y}/@var{x})}.\n\
 @end ifinfo\n\
-\n\
 @noindent\n\
 in radians. \n\
 \n\
 For example,\n\
 \n\
 @example\n\
 @group\n\
 arg (3 + 4i)\n\
@@ -240,29 +239,29 @@ arg (3 + 4i)\n\
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asin (@var{x})\n\
 Compute the inverse sine of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (asinh, 0, 0, 0, asinh, 0, asinh, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asinh (@var{x})\n\
-Ompute the inverse hyperbolic sine of each element of @var{x}.\n\
+Compute the inverse hyperbolic sine of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (atan, 0, 0, 0, atan, 0, atan, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan (@var{x})\n\
 Compute the inverse tangent of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (atanh, 0, 0, 0, atanh, 0, atanh, -1.0, 1.0, 0, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atanh (@var{x})\n\
-Compute the inverse hyperbolic tanget of each element of @var{x}.\n\
+Compute the inverse hyperbolic tangent of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (ceil, 0, 0, 0, ceil, 0, ceil, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ceil (@var{x})\n\
 Return the smallest integer not less than @var{x}.  If @var{x} is\n\
 complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
 @end deftypefn");
@@ -344,18 +343,18 @@ see @ref{Linear Algebra}.\n\
   DEFUN_MAPPER (finite, 0, xfinite, xfinite, 0, 0, 0, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} finite (@var{x})\n\
 Return 1 for elements of @var{x} that are finite values and zero\n\
 otherwise. For example,\n\
 \n\
 @example\n\
 @group\n\
-finite ([13, Inf, NaN])\n\
-     @result{} [ 1, 0, 0 ]\n\
+finite ([13, Inf, NA, NaN])\n\
+     @result{} [ 1, 0, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn");
 
   DEFUN_MAPPER (fix, 0, 0, 0, fix, 0, fix, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} fix (@var{x})\n\
 Truncate @var{x} toward zero.  If @var{x} is complex, return\n\
@@ -594,37 +593,37 @@ sign (x) =  0, x = 0;\n\
 @end ifinfo\n\
 \n\
 For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (sin, 0, 0, 0, sin, 0, sin, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sin (@var{x})\n\
-Compute the sin of each element of @var{x}.\n\
+Compute the sine of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (sinh, 0, 0, 0, sinh, 0, sinh, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sinh (@var{x})\n\
-Compute the inverse hyperbolic sin of each element of @var{x}.\n\
+Compute the inverse hyperbolic sine of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (sqrt, 0, 0, 0, sqrt, 0, sqrt, 0.0, octave_Inf, 0, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sqrt (@var{x})\n\
 Compute the square root of @var{x}.  If @var{x} is negative, a complex\n\
 result is returned.  To compute the matrix square root, see\n\
 @ref{Linear Algebra}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (tan, 0, 0, 0, tan, 0, tan, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tan (@var{z})\n\
-Compute tanget of each element of @var{x}.\n\
+Compute tangent of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (tanh, 0, 0, 0, tanh, 0, tanh, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tanh (@var{x})\n\
 Compute hyperbolic tangent of each element of @var{x}.\n\
 @end deftypefn");
 
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -329,17 +329,17 @@ print_rhs_assign_val (void)
   return 0;
 }
 
 void
 symbols_of_pt_assign (void)
 {
   DEFVAR (print_rhs_assign_val, false, print_rhs_assign_val,
     "-*- texinfo -*-\n\
-@defvr print_rhs_assign_val\n\
+@defvr {Built-in Variable} print_rhs_assign_val\n\
 If the value of this variable is non-zero, Octave will print the value\n\
 of the right hand side of assignment expressions instead of the value\n\
 of the left hand side (after the assignment).\n\
 @end defvr");
 
 }
 
 /*
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -1353,17 +1353,17 @@ is @code{\"gnuplot\"}.  @xref{Installati
   bool with_frames = false;
 #endif
 
   DEFVAR (gnuplot_has_frames, with_frames, gnuplot_has_frames,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} gnuplot_has_frames\n\
 If the value of this variable is nonzero, Octave assumes that your copy\n\
 of gnuplot has support for multiple frames that is included in recent\n\
-3.6beta releases.  It's initial value is determined by configure, but it\n\
+3.6beta releases.  Its initial value is determined by configure, but it\n\
 can be changed in your startup script or at the command line in case\n\
 configure got it wrong, or if you upgrade your gnuplot installation.\n\
 @end defvr");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1761,17 +1761,17 @@ whos_line_format (void)
   return 0;
 }
 
 void
 symbols_of_symtab (void)
 {
   DEFVAR (variables_can_hide_functions, true, variables_can_hide_functions,
     "-*- texinfo -*-\n\
-@defvr variables_can_hide_functions\n\
+@defvr {Built-in Variable} variables_can_hide_functions\n\
 If the value of this variable is nonzero, assignments to variables may\n\
 hide previously defined functions of the same name.  A negative value\n\
 will cause Octave to print a warning, but allow the operation.\n\
 @end defvr");
 
   DEFVAR (debug_symtab_lookups, false, debug_symtab_lookups,
     "-*- texinfo -*-\n\
 @defvr debug_symtab_lookups\n\
