# HG changeset patch
# User Rik <rik@octave.org>
# Date 1459551809 25200
#      Fri Apr 01 16:03:29 2016 -0700
# Node ID ecce63c99c3fe81cf7007c0cef6ca49a59cd3a05
# Parent  0d1bd2ede0c151f80d6d5b33323542cbcec93fe5
maint: Add semicolons to terminate code in %! blocks.

* splineimages.m, Cell.cc, bsxfun.cc, cellfun.cc, conv2.cc, data.cc,
debug.cc, file-io.cc, gcd.cc, getrusage.cc, graphics.cc, kron.cc, mappers.cc,
oct-map.cc, ordschur.cc, psi.cc, rand.cc, variables.cc, __osmesa_print__.cc,
amd.cc, audiodevinfo.cc, dmperm.cc, qr.cc, ov-bool-mat.cc, ov-class.cc,
ov-fcn-handle.cc, ov-java.cc, oct-parse.in.yy, bicubic.m, delaunay3.m,
accumarray.m, flip.m, fliplr.m, flipud.m, gradient.m, inputParser.m, interp1.m,
narginchk.m, rot90.m, validateattributes.m, delaunay.m, delaunayn.m,
griddata3.m, inpolygon.m, waitbar.m, gray2ind.m, hsv2rgb.m, im2double.m,
image.m, imformats.m, imread.m, imshow.m, imwrite.m, ntsc2rgb.m, rgb2hsv.m,
rgb2ntsc.m, isbanded.m, onenormest.m, edit.m, fullfile.m, license.m, ode23.m,
ode45.m, glpk.m, annotation.m, legend.m, orient.m, text.m, area.m, barh.m,
contour.m, line.m, plot.m, plot3.m, plotyy.m, quiver.m, stem.m, clf.m,
copyobj.m, findobj.m, subplot.m, ppval.m, splinefit.m, ismember.m, freqz.m,
unwrap.m, eigs.m, ichol.m, pcg.m, spdiags.m, svds.m, magic.m, lscov.m,
median.m, ols.m, dec2base.m, strsplit.m, strtok.m, test.m, bug-31371.tst,
bug-36025.tst, bug-44940.tst, build-sparse-tests.sh, class-concat.tst,
classdef.tst, classes.tst, colormaps.tst, command.tst, ctor-vs-method.tst,
error.tst, fcn-handle-derived-resolution.tst, for.tst, index.tst, io.tst,
jit.tst, null-assign.tst, parser.tst, struct.tst, system.tst:
Add semicolons to terminate code in %! blocks.

diff --git a/doc/interpreter/splineimages.m b/doc/interpreter/splineimages.m
--- a/doc/interpreter/splineimages.m
+++ b/doc/interpreter/splineimages.m
@@ -200,11 +200,11 @@ function image_as_txt (d, nm)
   fputs (fid, "| Image unavailable in text mode. |\n");
   fputs (fid, "+---------------------------------+\n");
   fclose (fid);
 endfunction
 
 
 %!demo
 %! for s = 1:6
-%!   splineimages (sprintf ("splinefit##d", s), "pdf")
+%!   splineimages (sprintf ("splinefit##d", s), "pdf");
 %! endfor
 
diff --git a/libinterp/corefcn/Cell.cc b/libinterp/corefcn/Cell.cc
--- a/libinterp/corefcn/Cell.cc
+++ b/libinterp/corefcn/Cell.cc
@@ -215,17 +215,17 @@ Cell::index (const octave_value_list& id
     }
 
   return retval;
 }
 
 /*
 %!test
 %! a = {"foo", "bar"};
-%! assert (a(), a)
+%! assert (a(), a);
 */
 
 void
 Cell::assign (const octave_value_list& idx_arg, const Cell& rhs,
               const octave_value& fill_val)
 
 {
   octave_idx_type len = idx_arg.length ();
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -814,11 +814,11 @@ dimensionality as the other array.\n\
 ## Automatic broadcasting with zero length dimensions (bug #47085)
 %!assert ([1 2 3] .+ zeros (0, 3), zeros (0, 3))
 %!assert (rand (3, 3, 1) .+ rand (3, 3, 0), zeros (3, 3, 0))
 
 ## In-place broadcasting with zero length dimensions (bug #47085)
 %!test
 %! a = zeros (0, 3);
 %! a .+= [1 2 3];
-%! assert (a, zeros (0, 3))
+%! assert (a, zeros (0, 3));
 
 */
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -1417,19 +1417,19 @@ arrayfun (@@str2num, [1234],\n\
 
 %% Test function to check the "Errorhandler" option
 %!function z = __arrayfunerror (S, varargin)
 %!  z = S;
 %!endfunction
 %% First input argument can be a string, an inline function, a
 %% function_handle or an anonymous function
 %!test
-%! arrayfun (@isequal, [false, true], [true, true]); %% No output argument
+%! arrayfun (@isequal, [false, true], [true, true]);  # No output argument
 %!error
-%! arrayfun (@isequal); %% One or less input arguments
+%! arrayfun (@isequal);  # One or less input arguments
 %!test
 %! A = arrayfun ("isequal", [false, true], [true, true]);
 %! assert (A, [false, true]);
 %!test
 %! A = arrayfun (inline ("(x == y)", "x", "y"), [false, true], [true, true]);
 %! assert (A, [false, true]);
 %!test
 %! A = arrayfun (@isequal, [false, true], [true, true]);
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -406,34 +406,34 @@ The size of the result is @code{max (siz
 %!
 %!test
 %! ## test 3D by 2D
 %! a = rand (10, 10, 10);
 %! b = rand (3, 3);
 %! c = convn (a, b, "full");
 %!assert (convn (a, b, "same"), c(2:11,2:11,:))
 %!xtest
-%! assert (convn (a, b, "valid"), c(3:10,3:10,:))
+%! assert (convn (a, b, "valid"), c(3:10,3:10,:));
 %!
 %!test
 %! ## test 2D by 3D
 %! a = rand (10, 10);
 %! b = rand (3, 3, 3);
 %! c = convn (a, b, "full");
 %!assert (convn (a, b, "same"), c(2:11,2:11,2))
 %!assert (convn (a, b, "valid"), c(3:10,3:10,3:2))  # a 7x7x0 matrix
 %!
 %!test
 %! ## test multiple different number of dimensions, with odd and even numbers
 %! a = rand (10, 15, 7, 8, 10);
 %! b = rand (4, 3, 2, 3);
 %! c = convn (a, b, "full");
 %!assert (convn (a, b, "same"), c(3:12,2:16,2:8,2:9,:))
 %!xtest
-%! assert (convn (a, b, "valid"), c(4:10,3:15,2:7,3:8,:))
+%! assert (convn (a, b, "valid"), c(4:10,3:15,2:7,3:8,:));
 
 %!test
 %! a = reshape (floor (magic (16) /10), [4 8 4 2]);
 %! b = reshape (magic (6), [4 3 3]);
 %! c = zeros (7, 10, 6, 2);
 %! c(:,:,1,1) = [
 %!    875  1415  1215   741   288   264   635  1109   687   171
 %!    110   467  1551  1790  1891  1651  1165   900   659   568
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -4267,21 +4267,21 @@ val = ones (m,n, \"uint8\")\n\
 ## Tests for bug #47298
 ## Matlab requires the size to be a row vector.  In that logic, it supports
 ## n to be a 1x0 vector (returns 0x0) but not a 0x1 vector.  Octave supports
 ## any vector and therefore must support 0x1, 1x0, and 0x0x1 (but not 0x1x1).
 %!test
 %! funcs = {@zeros, @ones, @inf, @nan, @NA, @i, @pi, @e};
 %! for idx = 1:numel (funcs)
 %!   func = funcs{idx};
-%!   assert (func (zeros (1, 0)), zeros (0, 0))
-%!   assert (func (zeros (0, 1)), zeros (0, 0))
-%!   assert (func (zeros (0, 1, 1)), zeros (0, 0))
-%!   fail ([func2str(func) " ([])"])
-%!   fail ([func2str(func) " (zeros (0, 0, 1))"])
+%!   assert (func (zeros (1, 0)), zeros (0, 0));
+%!   assert (func (zeros (0, 1)), zeros (0, 0));
+%!   assert (func (zeros (0, 1, 1)), zeros (0, 0));
+%!   fail ([func2str(func) " ([])"]);
+%!   fail ([func2str(func) " (zeros (0, 0, 1))"]);
 %! endfor
 */
 
 DEFUN (zeros, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} zeros (@var{n})\n\
 @deftypefnx {} {} zeros (@var{m}, @var{n})\n\
 @deftypefnx {} {} zeros (@var{m}, @var{n}, @var{k}, @dots{})\n\
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -1483,20 +1483,20 @@ The @qcode{\"warn\"} field is set simila
 /*
 %!test
 %! dbstop @ftp/dir;
 %! dbstop @audioplayer/set 70;
 %! dbstop quantile>__quantile__;
 %! dbstop ls;
 %! s = dbstatus;
 %! dbclear all
-%! assert (s(1).name, "@audioplayer/set>setproperty")
-%! assert (s(2).name, "@ftp/dir")
-%! assert (s(3).name, "ls")
-%! assert (s(4).name, "quantile>__quantile__")
+%! assert (s(1).name, "@audioplayer/set>setproperty");
+%! assert (s(2).name, "@ftp/dir");
+%! assert (s(3).name, "ls");
+%! assert (s(4).name, "quantile>__quantile__");
 %! assert (s(2).file(end-10:end), "/@ftp/dir.m");
 */
 
 DEFUN (dbwhere, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} dbwhere\n\
 In debugging mode, report the current file and line number where execution\n\
 is stopped.\n\
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1665,95 +1665,95 @@ as the name of the function when reporti
 %! ## Check number of lines read, not number of passes through format string
 %! f = tempname ();
 %! fid = fopen (f, "w+");
 %! fprintf (fid, "1\r\n2\r3\n4\r\n5\n6");
 %! fseek (fid, 0, "bof");
 %! c = textscan (fid, "%f %f", 4);
 %! fclose (fid);
 %! unlink (f);
-%! assert (c, {[1;3], [2;4]})
+%! assert (c, {[1;3], [2;4]});
 
 %!test
 %! ## Check number of lines read, with multiple delimiters
 %! f = tempname ();
 %! fid = fopen (f, "w+");
 %! fprintf (fid, "1-\r\n-2\r3-\n-4\r\n5\n6");
 %! fseek (fid, 0, "bof");
 %! c = textscan (fid, "%f %f", 4, "delimiter", "-", "multipleDelimsAsOne", 1);
 %! fclose (fid);
 %! unlink (f);
-%! assert (c, {[1;3], [2;4]})
+%! assert (c, {[1;3], [2;4]});
 
 %!test
 %! ## Check ReturnOnError
 %! f = tempname ();
 %! fid = fopen (f, "w+");
 %! str = "1 2 3\n4 s 6";
 %! fprintf (fid, str);
 %! fseek (fid, 0, "bof");
 %! c = textscan (fid, "%f %f %f");
 %! fseek (fid, 0, "bof");
 %! d = textscan (fid, "%f %f %f", "ReturnOnError", 1);
 %! fseek (fid, 0, "bof");
 %! fclose (fid);
 %! unlink (f);
 %! u = textscan (str, "%f %f %f");
 %! v = textscan (str, "%f %f %f", "ReturnOnError", 1);
-%! assert (c, {[1;4], [2;NaN], [3;6]})
-%! assert (d, {[1;4], [2], [3]})
-%! assert (u, {[1;4], [2;NaN], [3;6]})
-%! assert (v, {[1;4], [2], [3]})
+%! assert (c, {[1;4], [2;NaN], [3;6]});
+%! assert (d, {[1;4], [2], [3]});
+%! assert (u, {[1;4], [2;NaN], [3;6]});
+%! assert (v, {[1;4], [2], [3]});
 
 %!test
 %! ## Check ReturnOnError
 %! f = tempname ();
 %! fid = fopen (f, "w+");
 %! str = "1 2 3\n4 s 6\n";
 %! fprintf (fid, str);
 %! fseek (fid, 0, "bof");
 %! c = textscan (fid, "%f %f %f", "ReturnOnError", 1);
 %! fseek (fid, 0, "bof");
 %! fclose (fid);
 %! unlink (f);
 %! u = textscan (str, "%f %f %f", "ReturnOnError", 1);
-%! assert (c, {[1;4], 2, 3})
-%! assert (u, {[1;4], 2, 3})
+%! assert (c, {[1;4], 2, 3});
+%! assert (u, {[1;4], 2, 3});
 
 %!error <Read error in field 2 of row 2> textscan ("1 2 3\n4 s 6", "%f %f %f", "ReturnOnError", 0);
 
 %!test
 %! ## Check ReturnOnError
 %! f = tempname ();
 %! fid = fopen (f, "w+");
 %! fprintf (fid, "1 s 3\n4 5 6");
 %! fseek (fid, 0, "bof");
 %! c = textscan (fid, "");
 %! fseek (fid, 0, "bof");
 %! d = textscan (fid, "", "ReturnOnError", 1);
 %! fseek (fid, 0, "bof");
 %! fclose (fid);
 %! unlink (f);
-%! assert (c, {[1;4], [NaN;5], [3;6]})
-%! assert (d, {1})
+%! assert (c, {[1;4], [NaN;5], [3;6]});
+%! assert (d, {1});
 
 %!test
 %! ## Check ReturnOnError with empty fields
 %! c = textscan ("1,,3\n4,5,6", "", "Delimiter", ",", "ReturnOnError", 1);
-%! assert (c, {[1;4], [NaN;5], [3;6]})
+%! assert (c, {[1;4], [NaN;5], [3;6]});
 
 %!test
 %! ## Check ReturnOnError with empty fields
 %! c = textscan ("1,,3\n4,5,6", "%f %f %f", "Delimiter", ",", "ReturnOnError", 1);
-%! assert (c, {[1;4], [NaN;5], [3;6]})
+%! assert (c, {[1;4], [NaN;5], [3;6]});
 
 %!test
 %! ## Check ReturnOnError in first column
 %! c = textscan ("1 2 3\ns 5 6", "", "ReturnOnError", 1);
-%! assert (c, {1, 2, 3})
+%! assert (c, {1, 2, 3});
 
 ## Test input validation
 %!error textscan ()
 %!error textscan (single (40))
 %!error textscan ({40})
 %!error <must be a string> textscan ("Hello World", 2)
 #%!error <cannot provide position information> [C, pos] = textscan ("Hello World")
 %!error <at most one character or> textscan ("Hello World", '%s', 'EndOfLine', 3)
@@ -2113,17 +2113,17 @@ as the name of the function when reporti
 %% Check single quoted format interprets control sequences
 %!test
 %! C = textscan ("1 2\t3 4", '%f %[^\t] %f %f');
 %! assert (C, {1, {"2"}, 3, 4});
 
 %% Check a non-empty line with no valid conversion registers empytValue
 %!test
 %! C = textscan ("Empty\n", "Empty%f %f");
-%! assert (C, { NaN, NaN })
+%! assert (C, { NaN, NaN });
 
 %% Check overflow and underflow of integer types
 %!test
 %! a = "-1e90 ";
 %! b = "1e90 ";
 %! fmt = "%d8 %d16 %d32 %d64 %u8 %u16 %u32 %u64 ";
 %! C = textscan ([a a a a a a a a b b b b b b b b], fmt);
 %! assert (C{1}, int8 ([-128; 127]));
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -510,20 +510,20 @@ gcd ([15, 9], [20, 18])\n\
 %!assert (gcd (uint64 (200), uint64 (300), uint64 (50), uint64 (35)), uint64 (5))
 %!assert (gcd (18-i, -29+3i), -3-4i)
 
 %!test
 %! p = [953 967];
 %! u = [953 + i*971, 967 + i*977];
 %! [d, k(1), k(2)] = gcd (p(1), p(2));
 %! [z, w(1), w(2)] = gcd (u(1), u(2));
-%! assert (d, 1)
-%! assert (sum (p.*k), d)
-%! assert (abs (z), sqrt (2))
-%! assert (abs (sum (u.*w)), sqrt (2))
+%! assert (d, 1);
+%! assert (sum (p.*k), d);
+%! assert (abs (z), sqrt (2));
+%! assert (abs (sum (u.*w)), sqrt (2));
 
 %!error <all values must be integers> gcd (1/2, 2);
 %!error <all complex parts must be integers> gcd (e + i*pi, 1);
 
 %!error gcd ()
 
 %!test
 %! s.a = 1;
diff --git a/libinterp/corefcn/getrusage.cc b/libinterp/corefcn/getrusage.cc
--- a/libinterp/corefcn/getrusage.cc
+++ b/libinterp/corefcn/getrusage.cc
@@ -204,30 +204,30 @@ elements @code{sec} (seconds) @code{usec
 
   return ovl (m);
 }
 
 /*
 %!test
 %! r = getrusage ();
 %! assert (isstruct (r));
-%! assert (isfield (r, "idrss"))
-%! assert (isfield (r, "inblock"))
-%! assert (isfield (r, "isrss"))
-%! assert (isfield (r, "ixrss"))
-%! assert (isfield (r, "majflt"))
-%! assert (isfield (r, "maxrss"))
-%! assert (isfield (r, "minflt"))
-%! assert (isfield (r, "msgrcv"))
-%! assert (isfield (r, "msgsnd"))
-%! assert (isfield (r, "nivcsw"))
-%! assert (isfield (r, "nsignals"))
-%! assert (isfield (r, "nswap"))
-%! assert (isfield (r, "nvcsw"))
-%! assert (isfield (r, "oublock"))
-%! assert (isfield (r, "stime"))
-%! assert (isfield (r, "utime"))
-%! assert (isfield (r.stime, "sec"))
-%! assert (isfield (r.stime, "usec"))
-%! assert (isfield (r.utime, "sec"))
-%! assert (isfield (r.utime, "usec"))
+%! assert (isfield (r, "idrss"));
+%! assert (isfield (r, "inblock"));
+%! assert (isfield (r, "isrss"));
+%! assert (isfield (r, "ixrss"));
+%! assert (isfield (r, "majflt"));
+%! assert (isfield (r, "maxrss"));
+%! assert (isfield (r, "minflt"));
+%! assert (isfield (r, "msgrcv"));
+%! assert (isfield (r, "msgsnd"));
+%! assert (isfield (r, "nivcsw"));
+%! assert (isfield (r, "nsignals"));
+%! assert (isfield (r, "nswap"));
+%! assert (isfield (r, "nvcsw"));
+%! assert (isfield (r, "oublock"));
+%! assert (isfield (r, "stime"));
+%! assert (isfield (r, "utime"));
+%! assert (isfield (r.stime, "sec"));
+%! assert (isfield (r.stime, "usec"));
+%! assert (isfield (r.utime, "sec"));
+%! assert (isfield (r.utime, "usec"));
 */
 
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -3021,18 +3021,18 @@ base_properties::set_parent (const octav
   ::adopt (parent.handle_value (), __myhandle__);
 }
 
 /*
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   hax = gca ();
-%!   set (hax, "parent", gcf ())
-%!   assert (gca (), hax)
+%!   set (hax, "parent", gcf ());
+%!   assert (gca (), hax);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 */
 
 void
 base_properties::mark_modified (void)
 {
@@ -3988,80 +3988,80 @@ figure::properties::get_auto_paperpositi
 %!   ## paperpositionmode "auto" converts figure size to paper units
 %!   set (hf, "units", "inches");
 %!   set (hf, "position", in_pos);
 %!   set (hf, "paperunits", "centimeters");
 %!   psz = get (hf, "papersize");
 %!   fsz = in_pos(3:4) * 2.54;
 %!   pos = [(psz/2 .- fsz/2) fsz];
 %!   set (hf, "paperpositionmode", "auto");
-%!   assert (get (hf, "paperposition"), pos, tol)
+%!   assert (get (hf, "paperposition"), pos, tol);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off", "paperpositionmode", "auto");
 %! in_pos = [0 0 4 5];
 %! tol = 20 * eps ();
 %! unwind_protect
 %!   ## likewise with normalized units
 %!   set (hf, "units", "inches");
 %!   set (hf, "position", in_pos);
 %!   psz = get (hf, "papersize");
 %!   set (hf, "paperunits", "normalized");
 %!   fsz = in_pos(3:4) ./ psz;
 %!   pos = [([0.5 0.5] .- fsz/2) fsz];
-%!   assert (get (hf, "paperposition"), pos, tol)
+%!   assert (get (hf, "paperposition"), pos, tol);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off", "paperpositionmode", "auto");
 %! in_pos = [0 0 4 5];
 %! tol = 20 * eps ();
 %! unwind_protect
 %!   ## changing papertype updates paperposition
 %!   set (hf, "units", "inches");
 %!   set (hf, "position", in_pos);
 %!   set  (hf, "papertype", "a4");
 %!   psz = get (hf, "papersize");
 %!   fsz = in_pos(3:4);
 %!   pos = [(psz/2 .- fsz/2) fsz];
-%!   assert (get (hf, "paperposition"), pos, tol)
+%!   assert (get (hf, "paperposition"), pos, tol);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off", "paperpositionmode", "auto");
 %! in_pos = [0 0 4 5];
 %! tol = 20 * eps ();
 %! unwind_protect
 %!   ## lanscape updates paperposition
 %!   set (hf, "units", "inches");
 %!   set (hf, "position", in_pos);
 %!   set (hf, "paperorientation", "landscape");
 %!   psz = get (hf, "papersize");
 %!   fsz = in_pos(3:4);
 %!   pos = [(psz/2 .- fsz/2) fsz];
-%!   assert (get (hf, "paperposition"), pos, tol)
+%!   assert (get (hf, "paperposition"), pos, tol);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off", "paperpositionmode", "auto");
 %! in_pos = [0 0 4 5];
 %! unwind_protect
 %!   ## back to manual mode
-%!   set (hf, "paperposition", in_pos * 1.1)
-%!   assert (get (hf, "paperpositionmode"), "manual")
-%!   assert (get (hf, "paperposition"), in_pos * 1.1)
+%!   set (hf, "paperposition", in_pos * 1.1);
+%!   assert (get (hf, "paperpositionmode"), "manual");
+%!   assert (get (hf, "paperposition"), in_pos * 1.1);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 */
 
 void
 figure::properties::update_paperunits (const caseless_str& old_paperunits)
 {
@@ -4612,47 +4612,47 @@ axes::properties::sync_positions (void)
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 %!testif HAVE_OPENGL, HAVE_FLTK
 %! hf = figure ("visible", "off");
 %! graphics_toolkit (hf, "fltk");
 %! fpos = get (hf, "position");
 %! unwind_protect
-%!   plot (rand (3))
+%!   plot (rand (3));
 %!   position = get (gca, "position");
 %!   outerposition = get (gca, "outerposition");
 %!   looseinset = get (gca, "looseinset");
 %!   tightinset = get (gca, "tightinset");
-%!   set (hf, "position", [fpos(1:2), 2*fpos(3:4)])
+%!   set (hf, "position", [fpos(1:2), 2*fpos(3:4)]);
 %!   set (hf, "position", fpos);
-%!   assert (get (gca, "outerposition"), outerposition, 0.001)
-%!   assert (get (gca, "position"), position, 0.001)
-%!   assert (get (gca, "looseinset"), looseinset, 0.001)
-%!   assert (get (gca, "tightinset"), tightinset, 0.001)
+%!   assert (get (gca, "outerposition"), outerposition, 0.001);
+%!   assert (get (gca, "position"), position, 0.001);
+%!   assert (get (gca, "looseinset"), looseinset, 0.001);
+%!   assert (get (gca, "tightinset"), tightinset, 0.001);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 %!testif HAVE_OPENGL, HAVE_FLTK
 %! hf = figure ("visible", "off");
 %! graphics_toolkit (hf, "fltk");
 %! fpos = get (hf, "position");
-%! set (gca, "activepositionproperty", "position")
+%! set (gca, "activepositionproperty", "position");
 %! unwind_protect
-%!   plot (rand (3))
+%!   plot (rand (3));
 %!   position = get (gca, "position");
 %!   outerposition = get (gca, "outerposition");
 %!   looseinset = get (gca, "looseinset");
 %!   tightinset = get (gca, "tightinset");
-%!   set (hf, "position", [fpos(1:2), 2*fpos(3:4)])
+%!   set (hf, "position", [fpos(1:2), 2*fpos(3:4)]);
 %!   set (hf, "position", fpos);
-%!   assert (get (gca, "position"), position, 0.001)
-%!   assert (get (gca, "outerposition"), outerposition, 0.001)
-%!   assert (get (gca, "looseinset"), looseinset, 0.001)
-%!   assert (get (gca, "tightinset"), tightinset, 0.001)
+%!   assert (get (gca, "position"), position, 0.001);
+%!   assert (get (gca, "outerposition"), outerposition, 0.001);
+%!   assert (get (gca, "looseinset"), looseinset, 0.001);
+%!   assert (get (gca, "tightinset"), tightinset, 0.001);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 */
 
 void
 axes::properties::set_text_child (handle_property& hp,
                                   const std::string& who,
@@ -9631,18 +9631,17 @@ each individual object will be reset.\n\
 %!
 %!   hli = line (1:10, 1:10, 1:10, "marker", "o",
 %!               "markerfacecolor", "b", "linestyle", ":");
 %!
 %!   reset (hli);
 %!   assert (get (hli, "marker"), get (0, "defaultlinemarker"));
 %!   assert (get (hli, "markerfacecolor"),
 %!           get (0, "defaultlinemarkerfacecolor"));
-%!   assert (get (hli, "linestyle"),
-%!           get (0, "defaultlinelinestyle"));
+%!   assert (get (hli, "linestyle"), get (0, "defaultlinelinestyle"));
 %!   assert (get (hli, "linewidth"), 3, tol);  # parent axes defaults
 %!
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test  # patch object
 %! hf = figure ("visible", "off");
@@ -9672,18 +9671,17 @@ each individual object will be reset.\n\
 %! unwind_protect
 %!   tol = 20 * eps;
 %!   hsu = surface (peaks, "edgecolor", "none");
 %!
 %!   reset (hsu);
 %!   assert (get (hsu, "xdata"), get (0, "defaultsurfacexdata"), tol);
 %!   assert (get (hsu, "ydata"), get (0, "defaultsurfaceydata"), tol);
 %!   assert (get (hsu, "zdata"), get (0, "defaultsurfacezdata"), tol);
-%!   assert (get (hsu, "edgecolor"),
-%!           get (0, "defaultsurfaceedgecolor"), tol);
+%!   assert (get (hsu, "edgecolor"), get (0, "defaultsurfaceedgecolor"), tol);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test  # image object
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   tol = 20 * eps;
@@ -9716,31 +9714,31 @@ each individual object will be reset.\n\
 %! unwind_protect
 %!   tol = 20 * eps;
 %!   pos = get (0, "defaultaxesposition") * .5;
 %!   hax = axes ("linewidth", 2, "position", pos);
 %!   title ("Reset me, please!");
 %!
 %!   reset (hax);
 %!   assert (get (hax, "linewidth"), get (0, "defaultaxeslinewidth"), tol);
-%!   assert (get (hax, "position"), pos, tol); # axes position is unchanged
-%!   assert (get (hax, "default"), struct ()); # no more axes' defaults
+%!   assert (get (hax, "position"), pos, tol);  # axes position is unchanged
+%!   assert (get (hax, "default"), struct ());  # no more axes' defaults
 %!   assert (get (get (hax, "title"), "string"), "");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test  # root figure object
 %! set (0, "defaultfigurevisible", "off");
 %! hf = figure ("visible", "off", "paperunits", "centimeters",
 %!              "papertype", "a4");
 %! unwind_protect
 %!   reset (hf);
 %!   assert (get (hf, "papertype"), get (0, "defaultfigurepapertype"));
-%!   assert (get (hf, "paperunits"), "centimeters"); # paperunits is unchanged
+%!   assert (get (hf, "paperunits"), "centimeters");  # paperunits is unchanged
 %!   assert (get (hf, "visible"), get (0, "defaultfigurevisible"));
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   set (0, "defaultfigurevisible", "remove");
 %! end_unwind_protect
 
 */
 
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -316,10 +316,10 @@ Since the Kronecker product is associati
 %% dispatch_kron for this case.
 %%
 %!test
 %! expected = zeros (16, 16);
 %! expected (1, 11) = 3;
 %! expected (2, 12) = 4;
 %! expected (5, 15) = 6;
 %! expected (6, 16) = 8;
-%! assert (kron (diag ([1, 2], 2), diag ([3, 4], 2)), expected)
+%! assert (kron (diag ([1, 2], 2), diag ([3, 4], 2)), expected);
 */
diff --git a/libinterp/corefcn/mappers.cc b/libinterp/corefcn/mappers.cc
--- a/libinterp/corefcn/mappers.cc
+++ b/libinterp/corefcn/mappers.cc
@@ -1548,26 +1548,26 @@ Return the natural logarithm of the gamm
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (gammaln (a), gammaln (real (a)));
 
 %!test
 %! x = [.5, 1, 1.5, 2, 3, 4, 5];
 %! v = [sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24];
-%! assert (gammaln (x), log (v), sqrt (eps))
+%! assert (gammaln (x), log (v), sqrt (eps));
 
 %!test
 %! a = single (-1i*sqrt (-1/(6.4187*6.4187)));
 %! assert (gammaln (a), gammaln (real (a)));
 
 %!test
 %! x = single ([.5, 1, 1.5, 2, 3, 4, 5]);
 %! v = single ([sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24]);
-%! assert (gammaln (x), log (v), sqrt (eps ("single")))
+%! assert (gammaln (x), log (v), sqrt (eps ("single")));
 
 %!test
 %! x = [-1, 0, 1, Inf];
 %! v = [Inf, Inf, 0, Inf];
 %! assert (gammaln (x), v);
 %! assert (gammaln (single (x)), single (v));
 
 %!error gammaln ()
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -1189,17 +1189,17 @@ octave_map::assign (const octave_value_l
   if (&ref == &tmp)
     setfield (k, tmp);
 }
 
 /*
 %!test
 %! rhs.b = 1;
 %! a(3) = rhs;
-%! assert ({a.b}, {[], [], 1})
+%! assert ({a.b}, {[], [], 1});
 */
 
 void
 octave_map::delete_elements (const idx_vector& i)
 {
   octave_idx_type nf = nfields ();
   for (octave_idx_type k = 0; k < nf; k++)
     xvals[k].delete_elements (i);
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -210,33 +210,33 @@ is in the upper left corner, by doing:\n
 }
 
 /*
 
 %!test
 %! A = [1, 2, 3, -2; 4, 5, 6, -5 ; 7, 8, 9, -5; 10, 11, 12, 4 ];
 %! [U, T] = schur (A);
 %! [US, TS] = ordschur (U, T, [ 0, 0, 1, 1 ]);
-%! assert (US*TS*US', A, sqrt (eps))
-%! assert (diag (T)(3:4), diag (TS)(1:2), sqrt (eps))
+%! assert (US*TS*US', A, sqrt (eps));
+%! assert (diag (T)(3:4), diag (TS)(1:2), sqrt (eps));
 
 %!test
 %! A = [1, 2, 3, -2; 4, 5, 6, -5 ; 7, 8, 9, -5; 10, 11, 12, 4 ];
 %! [U, T] = schur (A);
 %! [US, TS] = ordschur (single (U), single (T), [ 0, 0, 1, 1 ]);
-%! assert (US*TS*US', A, sqrt (eps ("single")))
-%! assert (diag (T)(3:4), diag (TS)(1:2), sqrt (eps ("single")))
+%! assert (US*TS*US', A, sqrt (eps ("single")));
+%! assert (diag (T)(3:4), diag (TS)(1:2), sqrt (eps ("single")));
 
 %!test
 %! A = [1, 2, 3, -2; 4, 5, 6, -5 ; 7, 8, 9, -5; 10, 11, 12, 4+3i ];
 %! [U, T] = schur (A);
 %! [US, TS] = ordschur (U, T, [ 0, 0, 1, 1 ]);
-%! assert (US*TS*US', A, sqrt (eps))
-%! assert (diag (T)(3:4), diag (TS)(1:2), sqrt (eps))
+%! assert (US*TS*US', A, sqrt (eps));
+%! assert (diag (T)(3:4), diag (TS)(1:2), sqrt (eps));
 
 %!test
 %! A = [1, 2, 3, -2; 4, 5, 6, -5 ; 7, 8, 9, -5; 10, 11, 12, 4+3i ];
 %! [U, T] = schur (A);
 %! [US, TS] = ordschur (single (U), single (T), [ 0, 0, 1, 1 ]);
-%! assert (US*TS*US', A, sqrt (eps ("single")))
-%! assert (diag (T)(3:4), diag (TS)(1:2), sqrt (eps ("single")))
+%! assert (US*TS*US', A, sqrt (eps ("single")));
+%! assert (diag (T)(3:4), diag (TS)(1:2), sqrt (eps ("single")));
 
 */
diff --git a/libinterp/corefcn/psi.cc b/libinterp/corefcn/psi.cc
--- a/libinterp/corefcn/psi.cc
+++ b/libinterp/corefcn/psi.cc
@@ -155,17 +155,17 @@ can have any value real or complex value
 %!assert (psi (ones (7, 3, 5)), repmat (-em, [7 3 5]))
 %!assert (psi ([0 1]), [-Inf -em])
 %!assert (psi ([-20:1]), [repmat(-Inf, [1 21]) -em])
 %!assert (psi (single ([0 1])), single ([-Inf -em]))
 
 ## Abramowitz and Stegun, page 258, eq 6.3.5
 %!test
 %! z = [-100:-1 1:200] ./ 10; # drop the 0
-%! assert (psi (z + 1), psi (z) + 1 ./ z, eps*1000)
+%! assert (psi (z + 1), psi (z) + 1 ./ z, eps*1000);
 
 ## Abramowitz and Stegun, page 258, eq 6.3.2
 %!assert (psi (1), -em)
 
 ## Abramowitz and Stegun, page 258, eq 6.3.3
 %!assert (psi (1/2), -em - 2 * log (2))
 
 ## The following tests are from Pascal Sebah and Xavier Gourdon (2002)
@@ -199,25 +199,28 @@ can have any value real or complex value
 %!assert (imag (psi (1/2 + i*z)), 1/2 * pi * tanh (pi * z), eps*10)
 
 ## Abramowitz and Stegun, page 259 eq 6.3.13
 %!assert (imag (psi (1 + i*z)), - 1./(2*z) + 1/2 * pi * coth (pi * z), eps*10)
 
 ## Abramowitz and Stegun, page 260 eq 6.4.5
 %!test
 %! for z = 0:20
-%!   assert (psi (1, z + 0.5), 0.5 * (pi^2) - 4 * sum ((2*(1:z) -1) .^(-2)), eps*10)
+%!   assert (psi (1, z + 0.5),
+%!           0.5 * (pi^2) - 4 * sum ((2*(1:z) -1) .^(-2)),
+%!           eps*10);
 %! endfor
 
 ## Abramowitz and Stegun, page 260 eq 6.4.6
 %!test
 %! z = 0.1:0.1:20;
 %! for n = 0:8
-%!   ## our precision goes down really quick when computing n is too high,
-%!   assert (psi (n, z+1), psi (n, z) + ((-1)^n) * factorial (n) * (z.^(-n-1)), 0.1)
+%!   ## our precision goes down really quick when computing n is too high.
+%!   assert (psi (n, z+1),
+%!           psi (n, z) + ((-1)^n) * factorial (n) * (z.^(-n-1)), 0.1);
 %! endfor
 
 ## Test input validation
 %!error psi ()
 %!error psi (1, 2, 3)
 %!error <Z must be> psi ("non numeric")
 %!error <conversion of 5.3 to int value failed> psi (5.3, 1)
 %!error <K must be non-negative> psi (-5, 1)
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -748,17 +748,17 @@ classes.\n\
   if (nargin < 1)
     error ("randg: insufficient arguments");
 
   return do_rand (args, nargin, "randg", "gamma", true);
 }
 
 /*
 %!test
-%! randg ("state", 12)
+%! randg ("state", 12);
 %! assert (randg ([-inf, -1, 0, inf, nan]), [nan, nan, nan, nan, nan]); # *** Please report
 
 %!test
 %! ## Test fixed state
 %! randg ("state", 1);
 %! assert (randg (0.1, 1, 6), [0.0103951513331241 8.335671459898252e-05 0.00138691397249762 0.000587308416993855 0.495590518784736 2.3921917414795e-12], 1e-6);
 %!test
 %! ## Test fixed state
@@ -978,38 +978,38 @@ classes.\n\
 
 /*
 %!test
 %! randp ("state", 12);
 %! assert (randp ([-inf, -1, 0, inf, nan]), [nan, nan, 0, nan, nan]);   # *** Please report
 %!test
 %! ## Test fixed state
 %! randp ("state", 1);
-%! assert (randp (5, 1, 6), [5 5 3 7 7 3])
+%! assert (randp (5, 1, 6), [5 5 3 7 7 3]);
 %!test
 %! ## Test fixed state
 %! randp ("state", 1);
-%! assert (randp (15, 1, 6), [13 15 8 18 18 15])
+%! assert (randp (15, 1, 6), [13 15 8 18 18 15]);
 %!test
 %! ## Test fixed state
 %! randp ("state", 1);
-%! assert (randp (1e9, 1, 6), [999915677 999976657 1000047684 1000019035 999985749 999977692], -1e-6)
+%! assert (randp (1e9, 1, 6), [999915677 999976657 1000047684 1000019035 999985749 999977692], -1e-6);
 %!test
 %! ## Test fixed state
 %! randp ("seed", 1);
 %! %%assert (randp (5, 1, 6), [8 2 3 6 6 8])
-%! assert (randp (5, 1, 5), [8 2 3 6 6])
+%! assert (randp (5, 1, 5), [8 2 3 6 6]);
 %!test
 %! ## Test fixed state
 %! randp ("seed", 1);
-%! assert (randp (15, 1, 6), [15 16 12 10 10 12])
+%! assert (randp (15, 1, 6), [15 16 12 10 10 12]);
 %!test
 %! ## Test fixed state
 %! randp ("seed", 1);
-%! assert (randp (1e9, 1, 6), [1000006208 1000012224 999981120 999963520 999963072 999981440], -1e-6)
+%! assert (randp (1e9, 1, 6), [1000006208 1000012224 999981120 999963520 999963072 999981440], -1e-6);
 %!test
 %! if (__random_statistical_tests__)
 %!   ## statistical tests may fail occasionally.
 %!   randp ("state", 12);
 %!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
 %!     x = randp (a (1), 100000, 1);
 %!     assert (min (x) >= 0);   # *** Please report this!!! ***
 %!     assert (mean (x), a(1), a(2));
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -353,17 +353,17 @@ isglobal (\"x\")\n\
 @end deftypefn")
 {
   return do_isglobal (args);
 }
 
 /*
 %!test
 %! global x;
-%! assert (isglobal ("x"), true)
+%! assert (isglobal ("x"), true);
 
 %!error isglobal ()
 %!error isglobal ("a", "b")
 %!error isglobal (1)
 */
 
 static octave_value
 safe_symbol_lookup (const std::string& symbol_name)
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -211,29 +211,29 @@ instead.\n\
 %! if (isunix ())
 %!   h = figure ("visible", "off");
 %!   fn = tempname ();
 %!   sombrero ();
 %!   __osmesa_print__ (h, fn, "svg");
 %!   assert (stat (fn).size, 2692270, -0.1);
 %!   unlink (fn);
 %!   img = __osmesa_print__ (h);
-%!   assert (size (img), [get(h, "position")([4, 3]), 3])
+%!   assert (size (img), [get(h, "position")([4, 3]), 3]);
 %!   ## Use pixel sum per RGB channel as fingerprint
 %!   img_fp = squeeze (sum (sum (img), 2));
 %!   assert (img_fp, [52942515; 54167797; 56158178], -0.05);
 %! endif
 
 %!testif HAVE_OPENGL, HAVE_OSMESA, HAVE_GL2PS_H
 %! if (isunix ())
 %!   h = figure ("visible", "off");
 %!   fn = tempname ();
 %!   plot (sin (0:0.1:2*pi));
 %!   __osmesa_print__ (h, fn, "svgis2d");
 %!   assert (stat (fn).size, 7438, -0.1);
 %!   unlink (fn);
 %!   img = __osmesa_print__ (h);
-%!   assert (size (img), [get(h, "position")([4, 3]), 3])
+%!   assert (size (img), [get(h, "position")([4, 3]), 3]);
 %!   ## Use pixel sum per RGB channel as fingerprint
 %!   img_fp = squeeze (sum (sum (img), 2));
 %!   assert (img_fp, [59281711; 59281711; 59482179], -0.05);
 %! endif
 */
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -183,18 +183,18 @@ The author of the code itself is Timothy
 }
 
 /*
 %!shared A, A2, opts
 %! A = ones (20, 30);
 %! A2 = ones (30, 30);
 %!
 %!testif HAVE_AMD
-%! assert(amd (A2), [1:30])
+%! assert(amd (A2), [1:30]);
 %! opts.dense = 25;
-%! assert(amd (A2, opts), [1:30])
+%! assert(amd (A2, opts), [1:30]);
 %! opts.aggressive = 1;
-%! assert(amd (A2, opts), [1:30])
+%! assert(amd (A2, opts), [1:30]);
 
 %!error <S must be a square matrix|was unavailable or disabled> amd (A)
 %!error amd (A2, 2)
 %!error <matrix S is corrupted|was unavailable or disabled> amd ([])
 */
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -424,31 +424,31 @@ recording using those parameters.\n\
 %! assert (columns (devinfo.output), nout);
 %! assert (columns (devinfo.input), nin);
 
 %!testif HAVE_PORTAUDIO
 %! devinfo = audiodevinfo;
 %! nout = audiodevinfo (0);
 %! nin = audiodevinfo (1);
 %! for i = 1:nout,
-%!   assert (devinfo.output(i).Name, audiodevinfo (0, devinfo.output(i).ID))
+%!   assert (devinfo.output(i).Name, audiodevinfo (0, devinfo.output(i).ID));
 %! endfor
 %! for i=1:nin,
-%!   assert (devinfo.input(i).Name, audiodevinfo (1, devinfo.input(i).ID))
+%!   assert (devinfo.input(i).Name, audiodevinfo (1, devinfo.input(i).ID));
 %! endfor
 
 %!testif HAVE_PORTAUDIO
 %! devinfo = audiodevinfo;
 %! nout = audiodevinfo (0);
 %! nin = audiodevinfo (1);
 %! for i = 1:nout,
-%!   assert (devinfo.output(i).ID, audiodevinfo (0, devinfo.output(i).Name))
+%!   assert (devinfo.output(i).ID, audiodevinfo (0, devinfo.output(i).Name));
 %! endfor
 %! for i = 1:nin,
-%!   assert (devinfo.input(i).ID, audiodevinfo (1, devinfo.input(i).Name))
+%!   assert (devinfo.input(i).ID, audiodevinfo (1, devinfo.input(i).Name));
 %! endfor
 */
 
 #ifdef HAVE_PORTAUDIO
 
 enum audio_type { TYPE_INT8, TYPE_UINT8, TYPE_UINT16, TYPE_DOUBLE };
 
 class audioplayer : public octave_base_value
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -188,14 +188,14 @@ such the numerical rank of the matrix @v
 
 #else
   err_disabled_feature ("sprank", "CXSparse");
 #endif
 }
 
 /*
 %!testif HAVE_CXSPARSE
-%! assert (sprank (speye (20)), 20)
+%! assert (sprank (speye (20)), 20);
 %!testif HAVE_CXSPARSE
-%! assert (sprank ([1,0,2,0;2,0,4,0]), 2)
+%! assert (sprank ([1,0,2,0;2,0,4,0]), 2);
 
 %!error sprank (1,2)
 */
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -635,81 +635,81 @@ x = @var{R} \\ @var{C}\n\
 
 ## The deactivated tests below can't be tested till rectangular back-subs is
 ## implemented for sparse matrices.
 
 %!testif HAVE_CXSPARSE
 %! n = 20;  d = 0.2;
 %! a = sprandn (n,n,d) + speye (n,n);
 %! r = qr (a);
-%! assert (r'*r, a'*a, 1e-10)
+%! assert (r'*r, a'*a, 1e-10);
 
 %!testif HAVE_COLAMD
 %! n = 20;  d = 0.2;
 %! a = sprandn (n,n,d) + speye (n,n);
 %! q = symamd (a);
 %! a = a(q,q);
 %! r = qr (a);
-%! assert (r'*r, a'*a, 1e-10)
+%! assert (r'*r, a'*a, 1e-10);
 
 %!testif HAVE_CXSPARSE
 %! n = 20;  d = 0.2;
 %! a = sprandn (n,n,d) + speye (n,n);
 %! [c,r] = qr (a, ones (n,1));
-%! assert (r\c, full (a)\ones (n,1), 10e-10)
+%! assert (r\c, full (a)\ones (n,1), 10e-10);
 
 %!testif HAVE_CXSPARSE
 %! n = 20;  d = 0.2;
 %! a = sprandn (n,n,d) + speye (n,n);
 %! b = randn (n,2);
 %! [c,r] = qr (a, b);
-%! assert (r\c, full (a)\b, 10e-10)
+%! assert (r\c, full (a)\b, 10e-10);
 
 %% Test under-determined systems!!
 %!#testif HAVE_CXSPARSE
 %! n = 20;  d = 0.2;
 %! a = sprandn (n,n+1,d) + speye (n,n+1);
 %! b = randn (n,2);
 %! [c,r] = qr (a, b);
-%! assert (r\c, full (a)\b, 10e-10)
+%! assert (r\c, full (a)\b, 10e-10);
 
 %!testif HAVE_CXSPARSE
 %! n = 20;  d = 0.2;
 %! a = 1i*sprandn (n,n,d) + speye (n,n);
 %! r = qr (a);
-%! assert (r'*r,a'*a,1e-10)
+%! assert (r'*r,a'*a,1e-10);
 
 %!testif HAVE_COLAMD
 %! n = 20;  d = 0.2;
 %! a = 1i*sprandn (n,n,d) + speye (n,n);
 %! q = symamd (a);
 %! a = a(q,q);
 %! r = qr (a);
-%! assert (r'*r, a'*a, 1e-10)
+%! assert (r'*r, a'*a, 1e-10);
 
 %!testif HAVE_CXSPARSE
 %! n = 20;  d = 0.2;
 %! a = 1i*sprandn (n,n,d) + speye (n,n);
 %! [c,r] = qr (a, ones (n,1));
-%! assert (r\c, full (a)\ones (n,1), 10e-10)
+%! assert (r\c, full (a)\ones (n,1), 10e-10);
 
 %!testif HAVE_CXSPARSE
 %! n = 20;  d = 0.2;
 %! a = 1i*sprandn (n,n,d) + speye (n,n);
 %! b = randn (n,2);
 %! [c,r] = qr (a, b);
-%! assert (r\c, full (a)\b, 10e-10)
+%! assert (r\c, full (a)\b, 10e-10);
 
 %% Test under-determined systems!!
 %!#testif HAVE_CXSPARSE
 %! n = 20;  d = 0.2;
 %! a = 1i*sprandn (n,n+1,d) + speye (n,n+1);
 %! b = randn (n,2);
 %! [c,r] = qr (a, b);
-%! assert (r\c, full (a)\b, 10e-10)
+%! assert (r\c, full (a)\b, 10e-10);
 
 */
 
 static
 bool check_qr_dims (const octave_value& q, const octave_value& r,
                     bool allow_ecf = false)
 {
   octave_idx_type m = q.rows ();
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -555,12 +555,12 @@ Compatibility Note: Octave accepts compl
 }
 
 /*
 %!test
 %! m = eye (2) != 0;
 %! s = ! 0;
 %! c = {"double", "single", "int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64", "logical"};
 %! for i = 1:numel (c)
-%!   assert (logical (eye (2, c{i})), m)
-%!   assert (logical (eye (1, c{i})), s)
+%!   assert (logical (eye (2, c{i})), m);
+%!   assert (logical (eye (1, c{i})), s);
 %! endfor
 */
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1852,19 +1852,19 @@ belongs to.\n\
 %!assert (isa ({1, 2}, "cell"))
 %!assert (isa ({1, 2}, {"numeric", "integer", "cell"}), [false false true])
 
 %!testif HAVE_JAVA
 %! ## The first and last assert() are equal on purpose.  The assert() in
 %! ## the middle with an invalid class name will cause the java code to
 %! ## throw exceptions which we then must clear properly (or all other calls
 %! ## will fail).  So we test this too.
-%! assert (isa (javaObject ("java.lang.Double", 10), "java.lang.Number"))
-%! assert (isa (javaObject ("java.lang.Double", 10), "not_a_class"), false)
-%! assert (isa (javaObject ("java.lang.Double", 10), "java.lang.Number"))
+%! assert (isa (javaObject ("java.lang.Double", 10), "java.lang.Number"));
+%! assert (isa (javaObject ("java.lang.Double", 10), "not_a_class"), false);
+%! assert (isa (javaObject ("java.lang.Double", 10), "java.lang.Number"));
 
 %!test
 %! a.b = 1;
 %! assert (isa (a, "struct"));
 */
 
 DEFUN (__parent_classes__, args, ,
        "-*- texinfo -*-\n\
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1320,17 +1320,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 %!  if (n == 0)
 %!    save (mode, nm, "f2", "g2", "hm2", "hdld2", "hbi2");
 %!  else
 %!    fcn_handle_save_recurse (n - 1, mode, nm, f2, g2, hm2, hdld2, hbi2);
 %!  endif
 %!endfunction
 %!function [f2, g2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (n, nm)
 %!  if (n == 0)
-%!    load (nm)
+%!    load (nm);
 %!  else
 %!    [f2, g2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (n - 1, nm);
 %!  endif
 %!endfunction
 
 Test for bug #35876
 %!test
 %! a = 2;
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -2975,12 +2975,12 @@ Return true if @var{x} is a Java object.
 %!testif HAVE_JAVA
 %! assert (class (javaObject ("java.lang.Byte", uint8 (1))), "java.lang.Byte");
 %! assert (class (javaObject ("java.lang.Byte", int8 (1))), "java.lang.Byte");
 %! assert (class (javaObject ("java.lang.Short", uint16 (1))), "java.lang.Short");
 %! assert (class (javaObject ("java.lang.Short", int16 (1))), "java.lang.Short");
 
 ## Automatic conversion from string cell array into String[] (bug #45290)
 %!testif HAVE_JAVA
-%! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "aaa"), 0)
-%! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "zzz"), 3)
-%! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "hhh") < 0)
+%! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "aaa"), 0);
+%! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "zzz"), 3);
+%! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "hhh") < 0);
 */
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -5096,17 +5096,17 @@ the security considerations that the eva
 %! y = eval ("x");
 %! assert (y, 1);
 
 %!test
 %! y = eval ("x;");
 %! assert (y, 1);
 
 %!test
-%! eval ("x = 1;")
+%! eval ("x = 1;");
 %! assert (x,1);
 
 %!test
 %! eval ("flipud = 2;");
 %! assert (flipud, 2);
 
 %!function y = __f ()
 %!  eval ("flipud = 2;");
@@ -5364,17 +5364,17 @@ s = evalc (\"t = 42\"), t\n\
 %! [s, a, b] = evalc ("deal (1, 2)");
 %! assert (s, "");
 %! assert (a, 1);
 %! assert (b, 2);
 
 %!function [a, b] = __f_evalc ()
 %!  printf ("foo");
 %!  fprintf (stdout, "bar");
-%!  disp (pi)
+%!  disp (pi);
 %!  a = 1;
 %!  b = 2;
 %!endfunction
 %!test
 %! [s, a, b] = evalc ("__f_evalc ()");
 %! assert (s, "foobar 3.1416\n");
 %! assert (a, 1);
 %! assert (b, 2);
diff --git a/scripts/deprecated/bicubic.m b/scripts/deprecated/bicubic.m
--- a/scripts/deprecated/bicubic.m
+++ b/scripts/deprecated/bicubic.m
@@ -251,10 +251,10 @@ endfunction
 %! [xx, yy] = meshgrid (x);
 %! z = cos (6 * xx) + sin (6 * yy);
 %! x = linspace (1, -1, 30);
 %! [xx2, yy2] = meshgrid (x);
 %! z1 = interp2 (xx, yy, z, xx2, yy2, "spline");
 %! z2 = interp2 (fliplr (xx), flipud (yy), fliplr (flipud(z)),
 %!               fliplr (xx2), flipud (yy2), "spline");
 %! z2 = fliplr (flipud (z2));
-%! assert (z1, z2, 100 * eps ())
+%! assert (z1, z2, 100 * eps ());
 
diff --git a/scripts/deprecated/delaunay3.m b/scripts/deprecated/delaunay3.m
--- a/scripts/deprecated/delaunay3.m
+++ b/scripts/deprecated/delaunay3.m
@@ -79,12 +79,12 @@ function tetr = delaunay3 (x, y, z, opti
     tetr = delaunayn ([x(:), y(:), z(:)], options);
   endif
 
 endfunction
 
 
 %!testif HAVE_QHULL
 %! x = [-1, -1, 1, 0, -1]; y = [-1, 1, 1, 0, -1]; z = [0, 0, 0, 1, 1];
-%! assert (sortrows (sort (delaunay3 (x, y, z), 2)), [1,2,3,4;1,2,4,5])
+%! assert (sortrows (sort (delaunay3 (x, y, z), 2)), [1,2,3,4;1,2,4,5]);
 
 ## FIXME: Need input validation tests
 
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -396,52 +396,52 @@ endfunction
 
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 0), [3; 4])
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 1), sparse ([3; 4]))
 %!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 0), [3, 4])
 %!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 1), sparse ([3, 4]))
 
 %!test
 %! A = accumarray ([1 1; 2 1; 2 3; 2 1; 2 3], 101:105, [2,4], @(x) {x});
-%! assert (A{2},[102; 104])
+%! assert (A{2},[102; 104]);
 
 %!test
 %! subs = ceil (rand (2000, 3)*10);
 %! vals = rand (2000, 1);
 %! assert (accumarray (subs, vals, [], @max),
-%!         accumarray (subs, vals, [], @(x) max (x)))
+%!         accumarray (subs, vals, [], @(x) max (x)));
 
 %!test
 %! subs = ceil (rand (2000, 1)*100);
 %! vals = rand (2000, 1);
 %! assert (accumarray (subs, vals, [100, 1], @min, NaN),
-%!         accumarray (subs, vals, [100, 1], @(x) min (x), NaN))
+%!         accumarray (subs, vals, [100, 1], @(x) min (x), NaN));
 
 %!test
 %! subs = ceil (rand (2000, 2)*30);
 %! subsc = num2cell (subs, 1);
 %! vals = rand (2000, 1);
 %! assert (accumarray (subsc, vals, [], [], 0, true),
-%!         accumarray (subs, vals, [], [], 0, true))
+%!         accumarray (subs, vals, [], [], 0, true));
 
 %!test
 %! subs = ceil (rand (2000, 3)*10);
 %! subsc = num2cell (subs, 1);
 %! vals = rand (2000, 1);
 %! assert (accumarray (subsc, vals, [], @max),
 %!         accumarray (subs, vals, [], @max));
 
 %!error (accumarray (1:5))
 %!error (accumarray ([1,2,3],1:2))
 
 ## Handle empty arrays (bug #47287)
 %!test
 %! ## min, max, and sum are special cases within accumarray so test them.
 %! funcs = {@(x) length (x) > 1, @min, @max, @sum};
 %! for idx = 1:numel (funcs)
-%!   assert (accumarray (zeros (0, 1), [], [0 1] , funcs{idx}), zeros (0, 1))
-%!   assert (accumarray (zeros (0, 1), [], [1 0] , funcs{idx}), zeros (1, 0))
-%!   assert (accumarray (zeros (0, 1), [], [] , funcs{idx}), zeros (0, 1))
+%!   assert (accumarray (zeros (0, 1), [], [0 1] , funcs{idx}), zeros (0, 1));
+%!   assert (accumarray (zeros (0, 1), [], [1 0] , funcs{idx}), zeros (1, 0));
+%!   assert (accumarray (zeros (0, 1), [], [] , funcs{idx}), zeros (0, 1));
 %! endfor
 
 ## Matlab returns an array of doubles even though FUNC returns cells.  In
 ## Octave, we do not have that bug, at least for this case.
 %!assert (accumarray (zeros (0, 1), [], [0 1] , @(x) {x}), cell (0, 1))
diff --git a/scripts/general/flip.m b/scripts/general/flip.m
--- a/scripts/general/flip.m
+++ b/scripts/general/flip.m
@@ -83,24 +83,24 @@ endfunction
 %!assert (flip ([1 2; 3 4]), flip ([1 2 ; 3 4], 1))
 
 ## Test NDArrays
 %!test
 %! a(1:2,1:2,1) = [1 2; 3 4];
 %! a(1:2,1:2,2) = [5 6; 7 8];
 %! b(1:2,1:2,1) = [5 6; 7 8];
 %! b(1:2,1:2,2) = [1 2; 3 4];
-%! assert (flip (a, 3), b)
+%! assert (flip (a, 3), b);
 
 %!test
 %! a = b = zeros (2, 2, 1, 2);
 %! a(1:2,1:2,:,1) = [1 2; 3 4];
 %! a(1:2,1:2,:,2) = [5 6; 7 8];
 %! b(1:2,1:2,:,1) = [5 6; 7 8];
 %! b(1:2,1:2,:,2) = [1 2; 3 4];
-%! assert (flip (a, 3), a)
-%! assert (flip (a, 4), b)
-%! assert (flip (a, 5), a)
+%! assert (flip (a, 3), a);
+%! assert (flip (a, 4), b);
+%! assert (flip (a, 5), a);
 
 %!error flip ()
 %!error flip (1, 2, 3)
 %!error <DIM must be a positive integer> flip (magic (3), -1)
 
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -52,27 +52,27 @@ endfunction
 %!assert (fliplr ([1 2 3].'), [1 2 3].')
 
 ## Test NDArrays
 %!test
 %! a(:,:,1) = [ 1  2;  3  4;  5  6];
 %! a(:,:,2) = [ 7  8;  9 10; 11 12];
 %! b(:,:,1) = [ 2  1;  4  3;  6  5];
 %! b(:,:,2) = [ 8  7; 10  9; 12 11];
-%! assert (fliplr (a), b)
+%! assert (fliplr (a), b);
 
 ## Test NDArray with singleton dimensions
 %!test
 %! a(:,:,:,1) = [ 1  2;  3  4;  5  6];
 %! a(:,:,:,2) = [ 7  8;  9 10; 11 12];
 %! b(:,:,:,1) = [ 2  1;  4  3;  6  5];
 %! b(:,:,:,2) = [ 8  7; 10  9; 12 11];
-%! assert (fliplr (a), b)
+%! assert (fliplr (a), b);
 
 ## Test for 1 row, i.e., returns the same
 %!test
 %! a(:,1,:,1) = [ 1  2  3  4];
 %! a(:,1,:,2) = [ 5  6  7  8];
-%! assert (fliplr (a), a)
+%! assert (fliplr (a), a);
 
 %!error fliplr()
 %!error fliplr (1, 2)
 
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -52,27 +52,27 @@ endfunction
 %!assert (flipud ([1 2 3]), [1 2 3])
 
 ## Test NDArrays
 %!test
 %! a(:,:,1) = [ 1  2  3;  4  5  6];
 %! a(:,:,2) = [ 7  8  9; 10 11 12];
 %! b(:,:,1) = [ 4  5  6;  1  2  3];
 %! b(:,:,2) = [10 11 12;  7  8  9];
-%! assert (flipud (a), b)
+%! assert (flipud (a), b);
 
 ## Test NDArray with singleton dimensions
 %!test
 %! a(:,:,:,1) = [ 1  2  3;  4  5  6];
 %! a(:,:,:,2) = [ 7  8  9; 10 11 12];
 %! b(:,:,:,1) = [ 4  5  6;  1  2  3];
 %! b(:,:,:,2) = [10 11 12;  7  8  9];
-%! assert (flipud (a), b)
+%! assert (flipud (a), b);
 
 ## Test for 1 row, i.e., returns the same
 %!test
 %! a(1,:,:,1) = [ 1  2  3  4];
 %! a(1,:,:,2) = [ 5  6  7  8];
-%! assert (flipud (a), a)
+%! assert (flipud (a), a);
 
 %!error flipud ()
 %!error flipud (1, 2)
 
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -295,11 +295,11 @@ endfunction
 %! assert (gradient (f, x, 0.5), df_dx (x), 0.1);
 
 %!test
 %! xy = reshape (1:10, 5, 2);
 %! f = @(x,y) sin (x) .* cos (y);
 %! df_dx = @(x, y) cos (x) .* cos (y);
 %! df_dy = @(x, y) -sin (x) .* sin (y);
 %! [dx, dy] = gradient (f, xy);
-%! assert (dx, df_dx (xy (:, 1), xy (:, 2)), 0.1)
-%! assert (dy, df_dy (xy (:, 1), xy (:, 2)), 0.1)
+%! assert (dx, df_dx (xy (:, 1), xy (:, 2)), 0.1);
+%! assert (dy, df_dy (xy (:, 1), xy (:, 2)), 0.1);
 
diff --git a/scripts/general/inputParser.m b/scripts/general/inputParser.m
--- a/scripts/general/inputParser.m
+++ b/scripts/general/inputParser.m
@@ -490,17 +490,17 @@ endclassdef
 ## check normal use, only required are given
 %!test
 %! p = create_p ();
 %! p.parse ("file");
 %! r = p.Results;
 %! assert (r.req1, "file");
 %! assert (sort (p.UsingDefaults), sort ({"op1", "op2", "verbose", "line"}));
 %! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
-%!        {"file", "val", 78,    false,     "tree"});
+%!         {"file", "val", 78,    false,     "tree"});
 
 ## check normal use, but give values different than defaults
 %!test
 %! p = create_p ();
 %! p.parse ("file", "foo", 80, "line", "circle", "verbose");
 %! r = p.Results;
 %! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
 %!         {"file", "foo", 80,    true,      "circle"});
@@ -522,17 +522,17 @@ endclassdef
 %! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
 %!         {"file", "foo", 80,    true,      "circle"});
 
 ## check KeepUnmatched
 %!test
 %! p = create_p ();
 %! p.KeepUnmatched = true;
 %! p.parse ("file", "foo", 80, "line", "circle", "verbose", "extra", 50);
-%! assert (p.Unmatched.extra, 50)
+%! assert (p.Unmatched.extra, 50);
 
 ## check error when missing required
 %!error <not enough input arguments>
 %! p = create_p ();
 %! p.parse ();
 
 ## check error when given required does not validate
 %!error <failed validation of >
@@ -576,29 +576,29 @@ endclassdef
 %! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
 %!         {"file", "foo", 80,    true,      "circle"});
 
 ## We must not perform validation of default values (bug #45837)
 %!test
 %! p = inputParser;
 %! p.addParamValue ("Dir", [], @ischar);
 %! p.parse ();
-%! assert (p.Results.Dir, [])
+%! assert (p.Results.Dir, []);
 
 %!test
 %! p = inputParser;
 %! p.addParamValue ("positive", -1, @(x) x > 5);
 %! p.parse ();
-%! assert (p.Results.positive, -1)
+%! assert (p.Results.positive, -1);
 
 %!function r = foobar (varargin)
 %!  p = inputParser ();
 %!  p.addParamValue ("foo", "bar", @ischar);
 %!  p.parse (varargin{2:end});
-%!  r = p.Results
+%!  r = p.Results;
 %!endfunction
 
 %!xtest assert (foobar (), struct ("foo", "bar"))
 %!xtest assert (foobar ([], "foo", "qux"), struct ("foo", "qux"))
 
 ## FIXME: This somehow works in Matlab
 %!xtest
 %! p = inputParser;
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -462,17 +462,17 @@ endfunction
 %! x = 0:0.5:3;
 %! x1 = [3 2 2 1];
 %! x2 = [1 2 2 3];
 %! y1 = [1 1 0 0];
 %! y2 = [0 0 1 1];
 %! h = plot (x, interp1 (x1, y1, x), 'b', x1, y1, 'sb');
 %! hold on
 %! g = plot (x, interp1 (x2, y2, x), 'r', x2, y2, '*r');
-%! axis ([0.5 3.5 -0.5 1.5])
+%! axis ([0.5 3.5 -0.5 1.5]);
 %! legend ([h(1), g(1)], {'left-continuous', 'right-continuous'}, ...
 %!         'location', 'northwest')
 %! legend boxoff
 %! %--------------------------------------------------------
 %! % red curve is left-continuous and blue is right-continuous at x = 2
 
 ##FIXME: add test for N-d arguments here
 
diff --git a/scripts/general/narginchk.m b/scripts/general/narginchk.m
--- a/scripts/general/narginchk.m
+++ b/scripts/general/narginchk.m
@@ -61,12 +61,12 @@ endfunction
 %!function f (nargs, varargin)
 %! narginchk (nargs(1), nargs(2));
 %!endfunction
 
 %!error <too many input arguments> f([0,0])
 %!error <not enough input arguments> f([3, 3], 1)
 
 %!test
-%! f([1,1])
+%! f([1,1]);
 %!test
-%! f([1,5], 2, 3, 4, 5)
+%! f([1,5], 2, 3, 4, 5);
 
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -103,41 +103,41 @@ endfunction
 %! assert (rot90 (x1, -1), x4);
 
 ## Test NDArrays
 %!test
 %! a(1:2,1:2,1) = [1 2; 3 4];
 %! a(1:2,1:2,2) = [5 6; 7 8];
 %! b(1:2,1:2,1) = [2 4; 1 3];
 %! b(1:2,1:2,2) = [6 8; 5 7];
-%! assert (rot90 (a, 1), b)
-%! assert (rot90 (a, 2), rot90 (b, 1))
-%! assert (rot90 (a, 3), rot90 (b, 2))
+%! assert (rot90 (a, 1), b);
+%! assert (rot90 (a, 2), rot90 (b, 1));
+%! assert (rot90 (a, 3), rot90 (b, 2));
 
 %!test
 %! a = b = zeros (2, 2, 1, 2);
 %! a(1:2,1:2,:,1) = [1 2; 3 4];
 %! a(1:2,1:2,:,2) = [5 6; 7 8];
 %! b(1:2,1:2,:,1) = [2 4; 1 3];
 %! b(1:2,1:2,:,2) = [6 8; 5 7];
-%! assert (rot90 (a, 1), b)
-%! assert (rot90 (a, 2), rot90 (b, 1))
-%! assert (rot90 (a, 3), rot90 (b, 2))
+%! assert (rot90 (a, 1), b);
+%! assert (rot90 (a, 2), rot90 (b, 1));
+%! assert (rot90 (a, 3), rot90 (b, 2));
 
 ## With non-square matrices
 %!test
 %! a = zeros (3, 2, 1, 2);
 %! b = zeros (2, 3, 1, 2);
 %! a(1:2,1:3,:,1) = [ 1  2  3;  4  5  6];
 %! a(1:2,1:3,:,2) = [ 7  8  9; 10 11 12];
 %! b(1:3,1:2,:,1) = [ 3  6;  2  5;  1  4];
 %! b(1:3,1:2,:,2) = [ 9 12;  8 11;  7 10];
-%! assert (rot90 (a, 1), b)
-%! assert (rot90 (a, 2), rot90 (b, 1))
-%! assert (rot90 (a, 3), rot90 (b, 2))
+%! assert (rot90 (a, 1), b);
+%! assert (rot90 (a, 2), rot90 (b, 1));
+%! assert (rot90 (a, 3), rot90 (b, 2));
 
 ## Test input validation
 %!error rot90 ()
 %!error rot90 (1, 2, 3)
 %!error rot90 (1, ones (2))
 %!error rot90 (1, 1.5)
 %!error rot90 (1, 1+i)
 
diff --git a/scripts/general/validateattributes.m b/scripts/general/validateattributes.m
--- a/scripts/general/validateattributes.m
+++ b/scripts/general/validateattributes.m
@@ -388,56 +388,56 @@ endfunction
 %!error <greater than> validateattributes ([6 7 8 5], {}, {">", 5})
 %!error <greater than> validateattributes ([6 7 8 5], {}, {">=", 6})
 %!error <less than> validateattributes ([6 7 8 5], {}, {"<", 8})
 %!error <less than> validateattributes ([6 7 8 5], {}, {"<=", 7})
 %!error <diag> validateattributes ([0 0 0; 0 0 0; 1 0 0], {}, {"diag"})
 %!error <diag> validateattributes (repmat (eye (3), [1 1 3]), {}, {"diag"})
 
 %!test
-%! validateattributes (rand (5), {"numeric"}, {})
-%! validateattributes (rand (5), {"float"}, {})
-%! validateattributes (rand (5), {"double"}, {})
-%! validateattributes ("text", {"char"}, {})
-%! validateattributes (rand (5), {}, {"2d"})
-%! validateattributes (rand (5), {}, {"3d"})
-%! validateattributes (rand (5, 5, 5), {}, {"3d"})
-%! validateattributes (rand (5, 1), {}, {"column"})
-%! validateattributes (rand (1, 5), {}, {"row"})
-%! validateattributes ("a", {}, {"scalar"})
-%! validateattributes (5, {}, {"scalar"})
-%! validateattributes (rand (1, 5), {}, {"vector"})
-%! validateattributes (rand (5, 1), {}, {"vector"})
-%! validateattributes (rand (5), {}, {"square"})
-%! validateattributes (rand (5), {}, {"nonempty"})
-%! validateattributes (rand (5), {}, {"nonsparse"})
-%! validateattributes ([0 1 0 1 0], {}, {"binary"})
-%! validateattributes (rand (5) > 0.5, {}, {"binary"})
-%! validateattributes ([8 4 0 6], {}, {"even"})
-%! validateattributes ([-1 3 5], {}, {"odd"})
-%! validateattributes ([8 4 0 6], {}, {"real"})
-%! validateattributes ([8 4i 0 6], {}, {"finite"})
-%! validateattributes (uint8 ([8 4]), {}, {"finite"})
-%! validateattributes ([8 Inf], {}, {"nonnan"})
-%! validateattributes ([0 7 4], {}, {"nonnegative"})
-%! validateattributes ([-8 7 4], {}, {"nonzero"})
-%! validateattributes ([8 7 4], {}, {"positive"})
-%! validateattributes ([8 7 4 -5], {}, {"decreasing"})
-%! validateattributes ([-8 -7 4 5], {}, {"increasing"})
-%! validateattributes ([8 4 4 -5], {}, {"nonincreasing"})
-%! validateattributes ([-8 -8 4 5], {}, {"nondecreasing"})
-%! validateattributes (rand (4, 6, 7, 2), {}, {"size", [4 6 7 2]})
-%! validateattributes (rand (4, 6, 7, 2), {}, {"size", [4 NaN 7 2]})
-%! validateattributes (rand (4, 6, 7, 2), {}, {"size", [4 6 NaN 2 NaN]})
-%! validateattributes (rand (6, 2), {}, {"numel", 12})
-%! validateattributes (rand (6, 2), {}, {"ncols", 2})
-%! validateattributes (rand (6, 2), {}, {"nrows", 6})
-%! validateattributes (rand (6, 2, 4, 5), {}, {"ndims", 4})
-%! validateattributes ([4 5 6 7], {}, {">", 3})
-%! validateattributes ([4 5 6 7], {}, {">=", 4})
-%! validateattributes ([4 5 6 7], {}, {"<", 8})
-%! validateattributes ([4 5 6 7], {}, {"<=", 7})
-%! validateattributes (eye (3), {}, {"diag"})
-%! validateattributes ([1 0 0; 0 1 0; 0 0 1], {}, {"diag"})
-%! validateattributes (zeros (3), {}, {"diag"})
+%! validateattributes (rand (5), {"numeric"}, {});
+%! validateattributes (rand (5), {"float"}, {});
+%! validateattributes (rand (5), {"double"}, {});
+%! validateattributes ("text", {"char"}, {});
+%! validateattributes (rand (5), {}, {"2d"});
+%! validateattributes (rand (5), {}, {"3d"});
+%! validateattributes (rand (5, 5, 5), {}, {"3d"});
+%! validateattributes (rand (5, 1), {}, {"column"});
+%! validateattributes (rand (1, 5), {}, {"row"});
+%! validateattributes ("a", {}, {"scalar"});
+%! validateattributes (5, {}, {"scalar"});
+%! validateattributes (rand (1, 5), {}, {"vector"});
+%! validateattributes (rand (5, 1), {}, {"vector"});
+%! validateattributes (rand (5), {}, {"square"});
+%! validateattributes (rand (5), {}, {"nonempty"});
+%! validateattributes (rand (5), {}, {"nonsparse"});
+%! validateattributes ([0 1 0 1 0], {}, {"binary"});
+%! validateattributes (rand (5) > 0.5, {}, {"binary"});
+%! validateattributes ([8 4 0 6], {}, {"even"});
+%! validateattributes ([-1 3 5], {}, {"odd"});
+%! validateattributes ([8 4 0 6], {}, {"real"});
+%! validateattributes ([8 4i 0 6], {}, {"finite"});
+%! validateattributes (uint8 ([8 4]), {}, {"finite"});
+%! validateattributes ([8 Inf], {}, {"nonnan"});
+%! validateattributes ([0 7 4], {}, {"nonnegative"});
+%! validateattributes ([-8 7 4], {}, {"nonzero"});
+%! validateattributes ([8 7 4], {}, {"positive"});
+%! validateattributes ([8 7 4 -5], {}, {"decreasing"});
+%! validateattributes ([-8 -7 4 5], {}, {"increasing"});
+%! validateattributes ([8 4 4 -5], {}, {"nonincreasing"});
+%! validateattributes ([-8 -8 4 5], {}, {"nondecreasing"});
+%! validateattributes (rand (4, 6, 7, 2), {}, {"size", [4 6 7 2]});
+%! validateattributes (rand (4, 6, 7, 2), {}, {"size", [4 NaN 7 2]});
+%! validateattributes (rand (4, 6, 7, 2), {}, {"size", [4 6 NaN 2 NaN]});
+%! validateattributes (rand (6, 2), {}, {"numel", 12});
+%! validateattributes (rand (6, 2), {}, {"ncols", 2});
+%! validateattributes (rand (6, 2), {}, {"nrows", 6});
+%! validateattributes (rand (6, 2, 4, 5), {}, {"ndims", 4});
+%! validateattributes ([4 5 6 7], {}, {">", 3});
+%! validateattributes ([4 5 6 7], {}, {">=", 4});
+%! validateattributes ([4 5 6 7], {}, {"<", 8});
+%! validateattributes ([4 5 6 7], {}, {"<=", 7});
+%! validateattributes (eye (3), {}, {"diag"});
+%! validateattributes ([1 0 0; 0 1 0; 0 0 1], {}, {"diag"});
+%! validateattributes (zeros (3), {}, {"diag"});
 
 %!test
-%! validateattributes ([0 1 0 1], {"double", "uint8"}, {"binary", "size", [NaN 4], "nonnan"})
+%! validateattributes ([0 1 0 1], {"double", "uint8"}, {"binary", "size", [NaN 4], "nonnan"});
diff --git a/scripts/geometry/delaunay.m b/scripts/geometry/delaunay.m
--- a/scripts/geometry/delaunay.m
+++ b/scripts/geometry/delaunay.m
@@ -190,17 +190,17 @@ endfunction
 %!testif HAVE_QHULL
 %! x = [1 5 2; 5 6 7];
 %! y = [5 7 8; 1 2 3];
 %! assert (sortrows (sort (delaunay (x, y), 2)), [1,2,4;1,3,4;1,3,5;3,4,6]);
 
 ## Test 3-D input
 %!testif HAVE_QHULL
 %! x = [-1, -1, 1, 0, -1]; y = [-1, 1, 1, 0, -1]; z = [0, 0, 0, 1, 1];
-%! assert (sortrows (sort (delaunay (x, y, z), 2)), [1,2,3,4;1,2,4,5])
+%! assert (sortrows (sort (delaunay (x, y, z), 2)), [1,2,3,4;1,2,4,5]);
 
 ## Input validation tests
 %!error delaunay ()
 %!error delaunay (1,2,3,4,5)
 %!error <X must be a matrix with 2 or 3 columns> delaunay (ones (2,4))
 %!error <OPTIONS must be a string or cell array> delaunay (ones (2,2), struct())
 %!error <X must be a matrix with 2 or 3 columns> delaunay (ones (2,4), "")
 %!error <OPTIONS must be a string or cell array> delaunay (ones (2,2), ones (2,2), struct())
diff --git a/scripts/geometry/delaunayn.m b/scripts/geometry/delaunayn.m
--- a/scripts/geometry/delaunayn.m
+++ b/scripts/geometry/delaunayn.m
@@ -90,15 +90,15 @@ endfunction
 
 %!testif HAVE_QHULL
 %! x = [-1, 0; 0, 1; 1, 0; 0, -1; 0, 0];
 %! assert (sortrows (sort (delaunayn (x), 2)), [1,2,5;1,4,5;2,3,5;3,4,5]);
 
 ## Test 3-D input
 %!testif HAVE_QHULL
 %! x = [-1, -1, 1, 0, -1]; y = [-1, 1, 1, 0, -1]; z = [0, 0, 0, 1, 1];
-%! assert (sortrows (sort (delaunayn ([x(:) y(:) z(:)]), 2)), [1,2,3,4;1,2,4,5])
+%! assert (sortrows (sort (delaunayn ([x(:) y(:) z(:)]), 2)), [1,2,3,4;1,2,4,5]);
 
 ## FIXME: Need tests for delaunayn
 
 ## Input validation tests
 %!error delaunayn ()
 
diff --git a/scripts/geometry/griddata3.m b/scripts/geometry/griddata3.m
--- a/scripts/geometry/griddata3.m
+++ b/scripts/geometry/griddata3.m
@@ -94,10 +94,10 @@ endfunction
 %! rand ("state", 0);
 %! x = 2 * rand (1000, 1) - 1;
 %! y = 2 * rand (1000, 1) - 1;
 %! z = 2 * rand (1000, 1) - 1;
 %! v = x.^2 + y.^2 + z.^2;
 %! [xi, yi, zi] = meshgrid (-0.8:0.2:0.8);
 %! vi = griddata3 (x, y, z, v, xi, yi, zi, "nearest");
 %! vv = vi - xi.^2 - yi.^2 - zi.^2;
-%! assert (max (abs (vv(:))), 0, 0.1)
+%! assert (max (abs (vv(:))), 0, 0.1);
 
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -98,17 +98,17 @@ endfunction
 %! ya = [0:0.1:1.4];
 %! [x,y] = meshgrid (xa, ya);
 %! [in,on] = inpolygon (x, y, xv, yv);
 %! inside = in & ! on;
 %!
 %! clf;
 %! plot (xv, yv);
 %! hold on;
-%! plot (x(inside), y(inside), "@g")
+%! plot (x(inside), y(inside), "@g");
 %! plot (x(! in), y(! in), "@m");
 %! plot (x(on), y(on), "@b");
 %! hold off;
 %! disp ("Green points are inside polygon, magenta are outside,");
 %! disp ("and blue are on boundary.");
 
 %!demo
 %!  xv = [ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, ...
diff --git a/scripts/gui/waitbar.m b/scripts/gui/waitbar.m
--- a/scripts/gui/waitbar.m
+++ b/scripts/gui/waitbar.m
@@ -250,26 +250,26 @@ endfunction
 %!demo
 %! clf ();
 %! niter = 9;
 %! l = 1;
 %! xx = [0 l];
 %! yy = [0 0];
 %! hli = plot (xx, yy);
 %!
-%! disp ("Push the cancel to stop the process.")
+%! disp ("Push the cancel to stop the process.");
 %! hf = waitbar(0,"0","Name","Building Koch curve ...",...
 %!              "createcancelbtn", "setappdata (gcbf,'interrupt', true)");
 %! for ii = 1:niter
 %!   ## Check cancel request
 %!   if (! ishandle (hf))
-%!     break
+%!     break;
 %!   elseif (getappdata (hf, "interrupt"))
-%!     delete (hf)
-%!     break
+%!     delete (hf);
+%!     break;
 %!   else
 %!     waitbar (ii/niter, hf, sprintf ("Step %d/%d", ii, niter));
 %!   endif
 %!
 %!   ## Increasingly lengthy computation
 %!   l /= 3;
 %!   theta = angle (complex (diff (xx), diff (yy)));
 %!
@@ -278,23 +278,23 @@ endfunction
 %!                                              0 0 l*(3)^.5/2 0;
 %!                                              1 1 1          1];
 %!   tmp = arrayfun (xy, theta, xx(1:end-1), yy(1:end-1),
 %!                  "uniformoutput", false);
 %!
 %!   tmp = cell2mat (tmp);
 %!   xx = [tmp(1,:) xx(end)];
 %!   yy = [tmp(2,:) yy(end)];
-%!   set (hli, "xdata", xx, "ydata", yy)
+%!   set (hli, "xdata", xx, "ydata", yy);
 %!   drawnow ();
-%!   pause (0.5)
+%!   pause (0.5);
 %! endfor
 %!
 %! if (ishandle (hf))
-%!   delete (hf)
+%!   delete (hf);
 %! endif
 
 ## Test input validation
 %!error <FRAC must be between 0 and 1> waitbar (-0.5)
 %!error <FRAC must be between 0 and 1> waitbar (1.5)
 %!error <MSG must be a character string> waitbar (0.5, struct ())
 %!error <invalid number of property/value pairs> waitbar (0.5, "msg", "Name")
 
diff --git a/scripts/image/gray2ind.m b/scripts/image/gray2ind.m
--- a/scripts/image/gray2ind.m
+++ b/scripts/image/gray2ind.m
@@ -93,19 +93,19 @@ endfunction
 %! g2i = gray2ind (i2g, 100);
 %! assert (g2i, uint8 (0:99));
 
 %!assert (gray2ind ([0 0.25 0.5 1], 256), uint8 ([0 64 128 255]))
 %!assert (gray2ind ([0 (1/511) (1/510) 1-(1/509) 1-(1/510) 1], 256),
 %!        uint8 ([0 0 1 254 255 255]))
 
 %!test
-%! assert (class (gray2ind ([0.0 0.5 1.0], 255)), "uint8")
-%! assert (class (gray2ind ([0.0 0.5 1.0], 256)), "uint8")
-%! assert (class (gray2ind ([0.0 0.5 1.0], 257)), "uint16")
+%! assert (class (gray2ind ([0.0 0.5 1.0], 255)), "uint8");
+%! assert (class (gray2ind ([0.0 0.5 1.0], 256)), "uint8");
+%! assert (class (gray2ind ([0.0 0.5 1.0], 257)), "uint16");
 
 ## Test input validation
 %!error gray2ind ()
 %!error gray2ind (1,2,3)
 %!error <I must be a grayscale or binary image> gray2ind ({1})
 %!error <I must be a grayscale or binary image> gray2ind ([1+i])
 %!error <I must be a grayscale or binary image> gray2ind (sparse ([1]))
 %!error <I must be a grayscale or binary image> gray2ind (ones (2,2,3))
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -139,61 +139,61 @@ endfunction
 
 ## Test ND input
 %!test
 %! hsv = rand (16, 16, 3, 5);
 %! rgb = zeros (size (hsv));
 %! for i = 1:5
 %!   rgb(:,:,:,i) = hsv2rgb (hsv(:,:,:,i));
 %! endfor
-%! assert (hsv2rgb (hsv), rgb)
+%! assert (hsv2rgb (hsv), rgb);
 
 ## Test output class and size for input images.
 ## Most of the tests only test for colormap input.
 
 %!test
 %! rgb = hsv2rgb (rand (10, 10, 3));
-%! assert (class (rgb), "double")
-%! assert (size (rgb), [10 10 3])
+%! assert (class (rgb), "double");
+%! assert (size (rgb), [10 10 3]);
 
 %!test
 %! rgb = hsv2rgb (rand (10, 10, 3, "single"));
-%! assert (class (rgb), "single")
-%! assert (size (rgb), [10 10 3])
+%! assert (class (rgb), "single");
+%! assert (size (rgb), [10 10 3]);
 
 %!test
 %! rgb = (rand (10, 10, 3) * 3 ) - 0.5; # values outside range [0 1]
 %! rgb = hsv2rgb (rgb);
-%! assert (class (rgb), "double")
-%! assert (size (rgb), [10 10 3])
+%! assert (class (rgb), "double");
+%! assert (size (rgb), [10 10 3]);
 
 %!test
 %! rgb = (rand (10, 10, 3, "single") * 3 ) - 0.5; # values outside range [0 1]
 %! rgb = hsv2rgb (rgb);
-%! assert (class (rgb), "single")
-%! assert (size (rgb), [10 10 3])
+%! assert (class (rgb), "single");
+%! assert (size (rgb), [10 10 3]);
 
 %!test
 %! rgb = hsv2rgb (randi ([0 255], 10, 10, 3, "uint8"));
-%! assert (class (rgb), "double")
-%! assert (size (rgb), [10 10 3])
+%! assert (class (rgb), "double");
+%! assert (size (rgb), [10 10 3]);
 
 %!test
 %! rgb = hsv2rgb (randi ([0 65535], 10, 10, 3, "uint16"));
-%! assert (class (rgb), "double")
-%! assert (size (rgb), [10 10 3])
+%! assert (class (rgb), "double");
+%! assert (size (rgb), [10 10 3]);
 
 %!test
 %! rgb = hsv2rgb (randi ([-128 127], 10, 10, 3, "int8"));
-%! assert (class (rgb), "double")
-%! assert (size (rgb), [10 10 3])
+%! assert (class (rgb), "double");
+%! assert (size (rgb), [10 10 3]);
 
 %!test
 %! hsv_double = reshape ([2/3 1/3 1 0 1 1 1 0, 1 1 1 1], [2 2 3]);
 %! hsv_uint8  = reshape (uint8 ([170 85 255 0 255 255 255 0 255 255 255 255]),
 %!                       [2 2 3]);
 %! hsv_int16 = int16 (double (hsv_double * uint16 (65535)) -32768);
 %! expected = reshape ([0 0 1 1 0 1 0 1 1 0 0 1], [2 2 3]);
 %!
-%! assert (hsv2rgb (hsv_double), expected)
-%! assert (hsv2rgb (hsv_uint8), expected)
-%! assert (hsv2rgb (hsv_int16), expected)
-%! assert (hsv2rgb (single (hsv_double)), single (expected), eps (single (2)))
+%! assert (hsv2rgb (hsv_double), expected);
+%! assert (hsv2rgb (hsv_uint8), expected);
+%! assert (hsv2rgb (hsv_int16), expected);
+%! assert (hsv2rgb (single (hsv_double)), single (expected), eps (single (2)));
diff --git a/scripts/image/im2double.m b/scripts/image/im2double.m
--- a/scripts/image/im2double.m
+++ b/scripts/image/im2double.m
@@ -104,17 +104,17 @@ endfunction
 %!  in = rand (2, 4, 2, 3, 2);
 %!  in *= high - low;
 %!  in += low;
 %!  in = cast (in, cls);
 %!  out = zeros (size (in));
 %!  for n = 1:12
 %!    out(:,:,n) = im2double (in(:,:,n));
 %!  endfor
-%!  assert (im2double (in), out)
+%!  assert (im2double (in), out);
 %!endfunction
 
 %!test
 %! test_im2double_nd ("double", 0, 1);
 %! test_im2double_nd ("single", 0, 1);
 %! test_im2double_nd ("uint8", 0, 255);
 %! test_im2double_nd ("uint16", 0, 6535);
 %! test_im2double_nd ("int16", -32768, 32767);
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -232,29 +232,29 @@ endfunction
 
 %!test
 %! ## test hidden properties x/ydatamode (bug #42121)
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   nx = 64; ny = 64;
 %!   cdata = rand (ny, nx)*127;
 %!   hi = image (cdata);             # x/ydatamode is auto
-%!   assert (get (hi, "xdata"), [1 nx])
-%!   assert (get (hi, "ydata"), [1 ny])
-%!   set (hi, "cdata", cdata(1:2:end, 1:2:end))
-%!   assert (get (hi, "xdata"), [1 nx/2])
-%!   assert (get (hi, "ydata"), [1 ny/2])
+%!   assert (get (hi, "xdata"), [1 nx]);
+%!   assert (get (hi, "ydata"), [1 ny]);
+%!   set (hi, "cdata", cdata(1:2:end, 1:2:end));
+%!   assert (get (hi, "xdata"), [1 nx/2]);
+%!   assert (get (hi, "ydata"), [1 ny/2]);
 %!
-%!   set (hi, "xdata", [10 100])     # xdatamode is now manual
-%!   set (hi, "ydata", [10 1000])    # ydatamode is now manual
-%!   set (hi, "cdata", cdata)
-%!   assert (get (hi, "xdata"), [10 100])
-%!   assert (get (hi, "ydata"), [10 1000])
+%!   set (hi, "xdata", [10 100]);    # xdatamode is now manual
+%!   set (hi, "ydata", [10 1000]);   # ydatamode is now manual
+%!   set (hi, "cdata", cdata);
+%!   assert (get (hi, "xdata"), [10 100]);
+%!   assert (get (hi, "ydata"), [10 1000]);
 %!
-%!   set (hi, "ydata", [])           # ydatamode is now auto
-%!   set (hi, "cdata", cdata(1:2:end, 1:2:end))
-%!   assert (get (hi, "xdata"), [10 100])
-%!   assert (get (hi, "ydata"), [1 ny/2])
+%!   set (hi, "ydata", []);          # ydatamode is now auto
+%!   set (hi, "cdata", cdata(1:2:end, 1:2:end));
+%!   assert (get (hi, "xdata"), [10 100]);
+%!   assert (get (hi, "ydata"), [1 ny/2]);
 %! unwind_protect_cleanup
-%!   close (hf)
+%!   close (hf);
 %! end_unwind_protect
 
 ## FIXME: Need %!tests for linear
diff --git a/scripts/image/imformats.m b/scripts/image/imformats.m
--- a/scripts/image/imformats.m
+++ b/scripts/image/imformats.m
@@ -313,25 +313,25 @@ function pretty_print_formats (formats)
   table = cat (2, extensions(:), yes_no_cols, descriptions(:));
   printf ([template "\n"], table'{:});
 
 endfunction
 
 ## This must work, even without support for image IO
 %!test
 %! formats = imformats ();
-%! assert (isstruct (formats))
+%! assert (isstruct (formats));
 %!
 %! min_fields = {"ext", "read", "isa", "write", "info", "alpha", "description"};
-%! assert (all (ismember (min_fields, fieldnames (formats))))
+%! assert (all (ismember (min_fields, fieldnames (formats))));
 %!
 %! if (__have_feature__ ("MAGICK"))
-%!   assert (numel (formats) > 0)
+%!   assert (numel (formats) > 0);
 %! else
-%!   assert (numel (formats), 0)
+%!   assert (numel (formats), 0);
 %! endif
 
 ## When imread or imfinfo are called, the file must exist or the
 ## function defined by imformats will never be called.  Because
 ## of this, we must create a file for the tests to work.
 
 ## changing the function that does the reading
 %!testif HAVE_MAGICK
diff --git a/scripts/image/imread.m b/scripts/image/imread.m
--- a/scripts/image/imread.m
+++ b/scripts/image/imread.m
@@ -149,19 +149,19 @@ endfunction
 %!    unlink (filename);
 %!  end_unwind_protect
 %!endfunction
 
 ## test PixelRegion option
 %!testif HAVE_MAGICK
 %! w = randi (255, 100, 100, "uint8");
 %! [r, cmap, a] = write_and_read (w, "tif", "PixelRegion", {[50 70] [20 40]});
-%! assert (r, w(50:70, 20:40))
+%! assert (r, w(50:70, 20:40));
 %! [r, cmap, a] = write_and_read (w, "tif", "PixelRegion", {[50 2 70] [20 3 40]});
-%! assert (r, w(50:2:70, 20:3:40))
+%! assert (r, w(50:2:70, 20:3:40));
 
 ## If a file does not exist, it's the job of imread to check the file
 ## exists before sending it over to __imread__ or whatever function
 ## is defined in imformats to handle that specific format.  This is the
 ## same in imfinfo.  So in this test we replace one format in imformats
 ## with something that will not give an error if the file is missing
 ## and make sure we do get an error.
 %!testif HAVE_MAGICK
@@ -205,10 +205,10 @@ endfunction
 
 ## Test for bug #41584 (some GM coders report saturated channels as binary)
 %!testif HAVE_MAGICK
 %! im = zeros ([16 16 3], "uint8");
 %! im(:,:,1) = 255;
 %! im(:,:,3) = repmat (0:16:255, [16 1]);
 %! [r, cmap, a] = write_and_read (im, "png");
 %! assert (class (r), "uint8");
-%! assert (isempty (cmap))
-%! assert (isempty (a))
+%! assert (isempty (cmap));
+%! assert (isempty (a));
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -265,15 +265,15 @@ endfunction
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   fail ("imshow ([1,1], [2 0 0])", "all MAP values must be in the range");
 %!   fail ("imshow ([1,1], [1 0 0 0])", "argument number 2 is invalid");
 %!   fail ('imshow ([1,1], "colormap", [2 0 0])', "all MAP values must be in the range");
 %!   fail ('imshow ([1,1], "parent", -1)', "must be an axes handle");
 %!   fail ('imshow ([1,1], "xdata", ones (2,2))', "xdata must be a vector");
 %!   fail ('imshow ([1,1], "ydata", ones (2,2))', "ydata must be a vector");
-%!   fail ('imshow ([1,1], "foobar")', "warning", "unrecognized property foobar")
+%!   fail ('imshow ([1,1], "foobar")', "warning", "unrecognized property foobar");
 %!   fail ("imshow ([1,1], {1})", "argument number 2 is invalid");
 %!   fail ("imshow ([1+i,1-i])", "warning", "only showing real part of complex image");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -139,77 +139,77 @@ endfunction
 %!    unlink (filename);
 %!  end_unwind_protect
 %!endfunction
 
 ## typical usage with grayscale uint8 images
 %!testif HAVE_MAGICK
 %! gray = randi (255, 10, 10, 1, "uint8");
 %! r = write_and_read (".tif", gray);
-%! assert (r, gray)
+%! assert (r, gray);
 
 ## grayscale uint8 images with alpha channel
 %!testif HAVE_MAGICK
 %! gray  = randi (255, 10, 10, 1, "uint8");
 %! alpha = randi (255, 10, 10, 1, "uint8");
 %! [r, ~, a] = write_and_read (".tif", gray, "Alpha", alpha);
-%! assert (r, gray)
-%! assert (a, alpha)
+%! assert (r, gray);
+%! assert (a, alpha);
 
 ## multipage grayscale uint8 images
 %!testif HAVE_MAGICK
 %! gray = randi (255, 10, 10, 1, 5, "uint8");
 %! r    = write_and_read (".tif", gray);
-%! assert (r, gray)
+%! assert (r, gray);
 
 ## multipage RGB uint8 images with alpha channel
 %!testif HAVE_MAGICK
 %! gray  = randi (255, 10, 10, 3, 5, "uint8");
 %! alpha = randi (255, 10, 10, 1, 5, "uint8");
 %! [r, ~, a] = write_and_read (".tif", gray, "Alpha", alpha);
-%! assert (r, gray)
-%! assert (a, alpha)
+%! assert (r, gray);
+%! assert (a, alpha);
 
 ## typical usage with RGB uint8 images
 %!testif HAVE_MAGICK
 %! rgb = randi (255, 10, 10, 3, "uint8");
 %! r = write_and_read (".tif", rgb);
-%! assert (r, rgb)
+%! assert (r, rgb);
 
 ## RGB uint8 images with alpha channel
 %!testif HAVE_MAGICK
 %! rgb   = randi (255, 10, 10, 3, "uint8");
 %! alpha = randi (255, 10, 10, 1, "uint8");
 %! [r, ~, a] = write_and_read (".tif", rgb, "Alpha", alpha);
-%! assert (r, rgb)
-%! assert (a, alpha)
+%! assert (r, rgb);
+%! assert (a, alpha);
 
 ## multipage RGB uint8 images
 %!testif HAVE_MAGICK
 %! rgb = randi (255, 10, 10, 3, 5, "uint8");
 %! r = write_and_read (".tif", rgb);
-%! assert (r, rgb)
+%! assert (r, rgb);
 
 ## multipage RGB uint8 images with alpha channel
 %!testif HAVE_MAGICK
 %! rgb   = randi (255, 10, 10, 3, 5, "uint8");
 %! alpha = randi (255, 10, 10, 1, 5, "uint8");
 %! [r, ~, a] = write_and_read (".tif", rgb, "Alpha", alpha);
-%! assert (r, rgb)
-%! assert (a, alpha)
+%! assert (r, rgb);
+%! assert (a, alpha);
 
 %!testif HAVE_MAGICK
 %! gray = repmat (uint8 (0:255), 100, 1);
 %! [g] = write_and_read (".jpeg", gray);
-%! assert (g, gray, 2)
+%! assert (g, gray, 2);
 
 %!testif HAVE_MAGICK
 %! gray = repmat (uint8 (0:255), 100, 1);
 %! [g] = write_and_read (".jpeg", gray, "quality", 100);
-%! assert (g, gray)
+%! assert (g, gray);
 
 %!function [compression] = get_bmp_compression (ext, cmap = [], varargin)
 %!  gray = repmat (uint8 (0:255), 100, 1);
 %!  filename = [tempname() ext];
 %!  unwind_protect
 %!    if (isempty (cmap))
 %!      imwrite (gray, filename, varargin{1:end});
 %!    else
@@ -223,15 +223,15 @@ endfunction
 %!    end_unwind_protect
 %!  unwind_protect_cleanup
 %!    unlink (filename);
 %!  end_unwind_protect
 %!endfunction
 
 ## BMP images must be saved uncompressed by default (bug #45565)
 %!testif HAVE_MAGICK
-%! assert (get_bmp_compression ("", [], "BMP"), 0)
-%! assert (get_bmp_compression ("", [], "bmp"), 0)
-%! assert (get_bmp_compression (".BMP"), 0)
-%! assert (get_bmp_compression (".bmp"), 0)
-%! assert (get_bmp_compression (".bmp", [], "bmp"), 0)
-%! assert (get_bmp_compression ("", gray (256), "bmp"), 0)
-%! assert (get_bmp_compression (".bmp", gray (256), "Compression", "rle"), 1)
+%! assert (get_bmp_compression ("", [], "BMP"), 0);
+%! assert (get_bmp_compression ("", [], "bmp"), 0);
+%! assert (get_bmp_compression (".BMP"), 0);
+%! assert (get_bmp_compression (".bmp"), 0);
+%! assert (get_bmp_compression (".bmp", [], "bmp"), 0);
+%! assert (get_bmp_compression ("", gray (256), "bmp"), 0);
+%! assert (get_bmp_compression (".bmp", gray (256), "Compression", "rle"), 1);
diff --git a/scripts/image/ntsc2rgb.m b/scripts/image/ntsc2rgb.m
--- a/scripts/image/ntsc2rgb.m
+++ b/scripts/image/ntsc2rgb.m
@@ -109,36 +109,36 @@ endfunction
 ## Test scaling of output.  After conversion, cut of negative values
 ## and scaling of all the others relative to the maximum above 1.
 %!test
 %! ntsc = [0.4229  0.0336  0.7184];
 %! rgb = ntsc * trans;    # [0.9014  -0.0509  1.6075]
 %! rgb(1) /= rgb(3); # scaled based on the maximum
 %! rgb(2) = 0; # cut to 0
 %! rgb(3) = 1; # cut to 1
-%! assert (ntsc2rgb (ntsc), rgb)
+%! assert (ntsc2rgb (ntsc), rgb);
 
 ## test scaling when conversion has more than one value above 1
 ## (check that it does pick the maximum)
 %!test
 %! ntsc = [0.8229  0.3336  0.7184];
 %! rgb = ntsc * trans;    # [1.58831   0.26726   1.67642]
 %! rgb /= rgb(3);
-%! assert (ntsc2rgb (ntsc), rgb)
+%! assert (ntsc2rgb (ntsc), rgb);
 
 ## check scaling for more than 1 row
 %!test
 %! ntsc = [0.4229  0.0336  0.7184
 %!         0.8229  0.3336  0.7184];
-%! rgb = ntsc * trans; # [0.9014  -0.0509  1.6075;  1.58831  0.26726  1.67642]
+%! rgb = ntsc * trans;  # [0.9014  -0.0509  1.6075;  1.58831  0.26726  1.67642]
 %! rgb(1,1) /= rgb(1,3);
 %! rgb(1,2) = 0;
 %! rgb(1,3) = 1;
 %! rgb(2,:) /= rgb(2,3);
-%! assert (ntsc2rgb (ntsc), rgb)
+%! assert (ntsc2rgb (ntsc), rgb);
 
 ## Test input validation
 %!error ntsc2rgb ()
 %!error ntsc2rgb (1,2)
 %!error <YIQ must be of floating point class> ntsc2rgb (uint8 (1))
 %!error <YIQ must be a colormap or YIQ image> ntsc2rgb (ones (2,2))
 %!error <YIQ must be of floating point class> ntsc2rgb (ones ([10 10 3], "uint8"))
 %!error <YIQ must be of floating point class> ntsc2rgb (ones ([10 10 3], "uint16"))
@@ -146,42 +146,42 @@ endfunction
 
 ## Test ND input
 %!test
 %! yiq = rand (16, 16, 3, 5);
 %! rgb = zeros (size (yiq));
 %! for i = 1:5
 %!   rgb(:,:,:,i) = ntsc2rgb (yiq(:,:,:,i));
 %! endfor
-%! assert (ntsc2rgb (yiq), rgb)
+%! assert (ntsc2rgb (yiq), rgb);
 
 ## Test output class and size for input images.
 ## Most of the tests only test for colormap input.
 
 %!test
 %! rgb = ntsc2rgb (rand (10, 10, 3));
-%! assert (class (rgb), "double")
-%! assert (size (rgb), [10 10 3])
+%! assert (class (rgb), "double");
+%! assert (size (rgb), [10 10 3]);
 
 %!test
 %! rgb = ntsc2rgb (rand (10, 10, 3, "single"));
-%! assert (class (rgb), "single")
-%! assert (size (rgb), [10 10 3])
+%! assert (class (rgb), "single");
+%! assert (size (rgb), [10 10 3]);
 
 %!test
 %! ntsc = (rand (10, 10, 3) * 3 ) - 0.5; # values outside range [0 1]
 %! rgb = ntsc2rgb (ntsc);
-%! assert (class (rgb), "double")
-%! assert (size (rgb), [10 10 3])
+%! assert (class (rgb), "double");
+%! assert (size (rgb), [10 10 3]);
 
 %!test
 %! ntsc = (rand (10, 10, 3, "single") * 3 ) - 0.5; # values outside range [0 1]
 %! rgb = ntsc2rgb (ntsc);
-%! assert (class (rgb), "single")
-%! assert (size (rgb), [10 10 3])
+%! assert (class (rgb), "single");
+%! assert (size (rgb), [10 10 3]);
 
 %!test
 %! ntsc_double = reshape ([.299 .587 .114 0 .596 -.274 -.322 0 .211 -.523 .312 0],
 %!                        [2 2 3]);
 %! expected = reshape ([1 0 0 0 0 1 0 0 0 0 1 0], [2 2 3]);
 %!
-%! assert (ntsc2rgb (ntsc_double), expected, 1e-5)
-%! assert (ntsc2rgb (single (ntsc_double)), single (expected), 1e-5)
+%! assert (ntsc2rgb (ntsc_double), expected, 1e-5);
+%! assert (ntsc2rgb (single (ntsc_double)), single (expected), 1e-5);
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -115,61 +115,61 @@ endfunction
 
 ## Test ND input
 %!test
 %! rgb = rand (16, 16, 3, 5);
 %! hsv = zeros (size (rgb));
 %! for i = 1:5
 %!   hsv(:,:,:,i) = rgb2hsv (rgb(:,:,:,i));
 %! endfor
-%! assert (rgb2hsv (rgb), hsv)
+%! assert (rgb2hsv (rgb), hsv);
 
 ## Test output class and size for input images.
 ## Most of the tests only test for colormap input.
 
 %!test
 %! hsv = rgb2hsv (rand (10, 10, 3));
-%! assert (class (hsv), "double")
-%! assert (size (hsv), [10 10 3])
+%! assert (class (hsv), "double");
+%! assert (size (hsv), [10 10 3]);
 
 %!test
 %! hsv = rgb2hsv (rand (10, 10, 3, "single"));
-%! assert (class (hsv), "single")
-%! assert (size (hsv), [10 10 3])
+%! assert (class (hsv), "single");
+%! assert (size (hsv), [10 10 3]);
 
 %!test
 %! rgb = (rand (10, 10, 3) * 3 ) - 0.5; # values outside range [0 1]
 %! hsv = rgb2hsv (rgb);
-%! assert (class (hsv), "double")
-%! assert (size (hsv), [10 10 3])
+%! assert (class (hsv), "double");
+%! assert (size (hsv), [10 10 3]);
 
 %!test
 %! rgb = (rand (10, 10, 3, "single") * 3 ) - 0.5; # values outside range [0 1]
 %! hsv = rgb2hsv (rgb);
-%! assert (class (hsv), "single")
-%! assert (size (hsv), [10 10 3])
+%! assert (class (hsv), "single");
+%! assert (size (hsv), [10 10 3]);
 
 %!test
 %! hsv = rgb2hsv (randi ([0 255], 10, 10, 3, "uint8"));
-%! assert (class (hsv), "double")
-%! assert (size (hsv), [10 10 3])
+%! assert (class (hsv), "double");
+%! assert (size (hsv), [10 10 3]);
 
 %!test
 %! hsv = rgb2hsv (randi ([0 65535], 10, 10, 3, "uint16"));
-%! assert (class (hsv), "double")
-%! assert (size (hsv), [10 10 3])
+%! assert (class (hsv), "double");
+%! assert (size (hsv), [10 10 3]);
 
 %!test
 %! hsv = rgb2hsv (randi ([-128 127], 10, 10, 3, "int8"));
-%! assert (class (hsv), "double")
-%! assert (size (hsv), [10 10 3])
+%! assert (class (hsv), "double");
+%! assert (size (hsv), [10 10 3]);
 
 %!test
 %! rgb_double = reshape ([1 0 1 .5 1 1 0 .5 0 1 1 .5], [2 2 3]);
 %! rgb_uint8  = reshape (uint8 ([255 0 255 128 255 255 0 128 0 255 255 128]),
 %!                       [2 2 3]);
 %! rgb_int16 = int16 (double (rgb_double * uint16 (65535)) -32768);
 %! expected = reshape ([1/6 1/2 5/6 0 1 1 1 0 1 1 1 .5], [2 2 3]);
 %!
-%! assert (rgb2hsv (rgb_double), expected)
-%! assert (rgb2hsv (rgb_uint8), expected, 0.005)
-%! assert (rgb2hsv (single (rgb_double)), single (expected))
+%! assert (rgb2hsv (rgb_double), expected);
+%! assert (rgb2hsv (rgb_uint8), expected, 0.005);
+%! assert (rgb2hsv (single (rgb_double)), single (expected));
 
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -93,61 +93,61 @@ endfunction
 
 ## Test ND input
 %!test
 %! rgb = rand (16, 16, 3, 5);
 %! yiq = zeros (size (rgb));
 %! for i = 1:5
 %!   yiq(:,:,:,i) = rgb2ntsc (rgb(:,:,:,i));
 %! endfor
-%! assert (rgb2ntsc (rgb), yiq)
+%! assert (rgb2ntsc (rgb), yiq);
 
 ## Test output class and size for input images.
 ## Most of the tests only test for colormap input.
 
 %!test
 %! ntsc = rgb2ntsc (rand (10, 10, 3));
-%! assert (class (ntsc), "double")
-%! assert (size (ntsc), [10 10 3])
+%! assert (class (ntsc), "double");
+%! assert (size (ntsc), [10 10 3]);
 
 %!test
 %! ntsc = rgb2ntsc (rand (10, 10, 3, "single"));
-%! assert (class (ntsc), "single")
-%! assert (size (ntsc), [10 10 3])
+%! assert (class (ntsc), "single");
+%! assert (size (ntsc), [10 10 3]);
 
 %!test
 %! rgb = (rand (10, 10, 3) * 3 ) - 0.5; # values outside range [0 1]
 %! ntsc = rgb2ntsc (rgb);
-%! assert (class (ntsc), "double")
-%! assert (size (ntsc), [10 10 3])
+%! assert (class (ntsc), "double");
+%! assert (size (ntsc), [10 10 3]);
 
 %!test
 %! rgb = (rand (10, 10, 3, "single") * 3 ) - 0.5; # values outside range [0 1]
 %! ntsc = rgb2ntsc (rgb);
-%! assert (class (ntsc), "single")
-%! assert (size (ntsc), [10 10 3])
+%! assert (class (ntsc), "single");
+%! assert (size (ntsc), [10 10 3]);
 
 %!test
 %! ntsc = rgb2ntsc (randi ([0 255], 10, 10, 3, "uint8"));
-%! assert (class (ntsc), "double")
-%! assert (size (ntsc), [10 10 3])
+%! assert (class (ntsc), "double");
+%! assert (size (ntsc), [10 10 3]);
 
 %!test
 %! ntsc = rgb2ntsc (randi ([0 65535], 10, 10, 3, "uint16"));
-%! assert (class (ntsc), "double")
-%! assert (size (ntsc), [10 10 3])
+%! assert (class (ntsc), "double");
+%! assert (size (ntsc), [10 10 3]);
 
 %!test
 %! ntsc = rgb2ntsc (randi ([-128 127], 10, 10, 3, "int8"));
-%! assert (class (ntsc), "double")
-%! assert (size (ntsc), [10 10 3])
+%! assert (class (ntsc), "double");
+%! assert (size (ntsc), [10 10 3]);
 
 %!test
 %! rgb_double = reshape ([1 0 0 0 0 1 0 0 0 0 1 0], [2 2 3]);
 %! rgb_uint8  = reshape (uint8 ([255 0 0 0 0 255 0 0 0 0 255 0]),
 %!                       [2 2 3]);
 %! rgb_int16 = int16 (double (rgb_double * uint16 (65535)) -32768);
 %! expected = reshape ([.299 .587 .114 0 .596 -.274 -.322 0 .211 -.523 .312 0],
 %!                     [2 2 3]);
 %!
-%! assert (rgb2ntsc (rgb_double), expected)
-%! assert (rgb2ntsc (rgb_uint8), expected)
-%! assert (rgb2ntsc (single (rgb_double)), single (expected))
+%! assert (rgb2ntsc (rgb_double), expected);
+%! assert (rgb2ntsc (rgb_uint8), expected);
+%! assert (rgb2ntsc (single (rgb_double)), single (expected));
diff --git a/scripts/linear-algebra/isbanded.m b/scripts/linear-algebra/isbanded.m
--- a/scripts/linear-algebra/isbanded.m
+++ b/scripts/linear-algebra/isbanded.m
@@ -65,19 +65,19 @@ endfunction
 %!assert (isbanded ([1, 1],1,1))
 %!assert (isbanded ([1; 1],1,1))
 %!assert (isbanded (eye(10),0,0))
 %!assert (isbanded (eye(10),1,1))
 %!assert (isbanded (i*eye(10),1,1))
 %!assert (isbanded (logical (eye (10)),1,1))
 
 %! A = [2 3 0 0 0; 1 2 3 0 0; 0 1 2 3 0; 0 0 1 2 3; 0 0 0 1 2];
-%! assert (isbanded (A,1,1))
-%! assert (! isbanded (A,0,1))
-%! assert (! isbanded (A,1,0))
+%! assert (isbanded (A,1,1));
+%! assert (! isbanded (A,0,1));
+%! assert (! isbanded (A,1,0));
 
 ## Test input validation
 %!error isbanded ()
 %!error isbanded (1)
 %!error isbanded (1,2)
 %!error isbanded (1,2,3,4)
 %!error <LOWER and UPPER must be non-negative> isbanded (1, -1, 1)
 %!error <LOWER and UPPER must be non-negative> isbanded (1, 1, -1)
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -276,17 +276,17 @@ endfunction
 %! assert (nminf, norm (A, inf), -2*eps);
 %! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
 %! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);
 
 ## Only likely to be within a factor of 10.
 %!test
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
-%! rand ('state', 42);  % Initialize to guarantee reproducible results
+%! rand ("state", 42);  # Initialize to guarantee reproducible results
 %! N = 100;
 %! A = rand (N);
 %! [nm1, v1, w1] = onenormest (A);
 %! [nminf, vinf, winf] = onenormest (A', 6);
 %! assert (nm1, norm (A, 1), -.1);
 %! assert (nminf, norm (A, inf), -.1);
 %! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
 %! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -565,17 +565,17 @@ endfunction
 %! s.email = edit ("get", "email");
 %! s.license = edit ("get", "license");
 %! s.editinplace = edit ("get", "editinplace");
 %! s.mode = edit ("get", "mode");
 %! edit home none
 %! edit author none
 %! edit email none
 %! edit license none
-%! edit ("editinplace", ! s.editinplace)
+%! edit ("editinplace", ! s.editinplace);
 %! if (s.mode(1) == "a")
 %!   edit mode sync
 %! else
 %!   edit mode async
 %! endif
 %! edit ("home", s.home);
 %! edit ("author", s.author);
 %! edit ("email", s.email);
diff --git a/scripts/miscellaneous/fullfile.m b/scripts/miscellaneous/fullfile.m
--- a/scripts/miscellaneous/fullfile.m
+++ b/scripts/miscellaneous/fullfile.m
@@ -110,17 +110,17 @@ endfunction
 %! if (ispc)
 %!   assert (fullfile ('\/\/\//A:/\/\', "x/", "/", "/", "y", "/", "/"), ...
 %!           ['A:\' xfsyfs]);
 %! endif
 
 ## *nix specific - double backslash
 %!test
 %! if (isunix || ismac)
-%!   assert (fullfile (fs, fs), fs)
+%!   assert (fullfile (fs, fs), fs);
 %! endif
 
 ## Windows specific - drive letters and file sep type, cell array
 %!test
 %! if (ispc)
 %!  tmp = fullfile ({"\\\/B:\//", "A://c", "\\\C:/g/h/i/j\/"});
 %!  assert (tmp{1}, 'B:\');
 %!  assert (tmp{2}, 'A:\c');
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -167,17 +167,17 @@ endfunction
 %!   endif
 %! endfor
 
 %!assert (license ("test", "octave"), true)
 %!assert (license ("test", "not_a_valid package name"), false)
 
 %!test
 %! for idx = 1: numel (list)
-%!   assert (license ("test", list{idx}.name), true)
+%!   assert (license ("test", list{idx}.name), true);
 %! endfor
 
 %!assert (license ("checkout", "octave"), true)
 
 %!test
 %! [s, e] = license ("checkout", "NOT_A_PACKAGE");
 %! assert (e, 'No package named "NOT_A_PACKAGE" installed');
 
diff --git a/scripts/ode/ode23.m b/scripts/ode/ode23.m
--- a/scripts/ode/ode23.m
+++ b/scripts/ode/ode23.m
@@ -413,17 +413,17 @@ endfunction
 %!endfunction
 %!function ref = fref ()       # The computed reference sol
 %! ref = [0.32331666704577, -1.83297456798624];
 %!endfunction
 %!function jac = fjac (t, y, varargin)  # its Jacobian
 %! jac = [0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2];
 %!endfunction
 %!function jac = fjcc (t, y, varargin)  # sparse type
-%! jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2])
+%! jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2]);
 %!endfunction
 %!function [val, trm, dir] = feve (t, y, varargin)
 %! val = fpol (t, y, varargin);    # We use the derivatives
 %! trm = zeros (2,1);              # that's why component 2
 %! dir = ones (2,1);               # seems to not be exact
 %!endfunction
 %!function [val, trm, dir] = fevn (t, y, varargin)
 %! val = fpol (t, y, varargin);    # We use the derivatives
@@ -531,18 +531,18 @@ endfunction
 %! assert (isfield (sol, "ie"));
 %! assert (sol.ie(1), 2);
 %! assert (isfield (sol, "xe"));
 %! assert (isfield (sol, "ye"));
 %!test  # Events option, now stop integration
 %! warning ("off", "integrate_adaptive:unexpected_termination", "local");
 %! opt = odeset ("Events", @fevn, "NormControl", "on");
 %! sol = ode23 (@fpol, [0 10], [2 0], opt);
-%! assert ([sol.ie, sol.xe, sol.ye], ...
-%!   [2.0, 2.496110, -0.830550, -2.677589], .5e-1);
+%! assert ([sol.ie, sol.xe, sol.ye],
+%!         [2.0, 2.496110, -0.830550, -2.677589], .5e-1);
 %!test  # Events option, five output arguments
 %! warning ("off", "integrate_adaptive:unexpected_termination", "local");
 %! opt = odeset ("Events", @fevn, "NormControl", "on");
 %! [t, y, vxe, ye, vie] = ode23 (@fpol, [0 10], [2 0], opt);
 %! assert ([vie, vxe, ye], [2.0, 2.496110, -0.830550, -2.677589], 1e-1);
 %!test  # Mass option as function
 %! opt = odeset ("Mass", @fmas);
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
diff --git a/scripts/ode/ode45.m b/scripts/ode/ode45.m
--- a/scripts/ode/ode45.m
+++ b/scripts/ode/ode45.m
@@ -398,17 +398,17 @@ endfunction
 %!endfunction
 %!function ref = fref ()       # The computed reference solution
 %! ref = [0.32331666704577, -1.83297456798624];
 %!endfunction
 %!function jac = fjac (t, y, varargin)  # its Jacobian
 %! jac = [0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2];
 %!endfunction
 %!function jac = fjcc (t, y, varargin)  # sparse type
-%! jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2])
+%! jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2]);
 %!endfunction
 %!function [val, trm, dir] = feve (t, y, varargin)
 %! val = fpol (t, y, varargin);    # We use the derivatives
 %! trm = zeros (2,1);              # that's why component 2
 %! dir = ones (2,1);               # seems to not be exact
 %!endfunction
 %!function [val, trm, dir] = fevn (t, y, varargin)
 %! val = fpol (t, y, varargin);    # We use the derivatives
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -607,45 +607,45 @@ endfunction
 %! ctype = ['U', 'U', 'U']';
 %! lb = [0, 0, 0]';
 %! ub = [];
 %! vartype = ['C', 'C', 'C']';
 %! param.msglev = 0;
 %! param.lpsolver = 1;
 %! [xmin, fmin, errnum, extra] = glpk (c, A, b, lb, ub, ctype, vartype, ...
 %!   sense, param);
-%! assert (fmin, c' * xmin)
+%! assert (fmin, c' * xmin);
 %! for i = 1:3
-%!   assert (A(i,:) * xmin <= b(i))
+%!   assert (A(i,:) * xmin <= b(i));
 %! endfor
 
 %!testif HAVE_GLPK
 %! sense = 1;
 %! c = [-1, -1]';
 %! A = [-2, 5; 2, -2];
 %! b = [5, 1]';
 %! ctype = ['U', 'U']';
 %! lb = [0, 0]';
 %! ub = [];
 %! vartype = ['I', 'I']';
 %! param.msglev = 0;
 %! [xmin, fmin, errnum, extra] = glpk (c, A, b, lb, ub, ctype, vartype, ...
 %!   sense, param);
-%! assert (fmin, c' * xmin)
+%! assert (fmin, c' * xmin);
 %! for i = 1:2
-%!   assert (A(i,:) * xmin <= b(i))
+%!   assert (A(i,:) * xmin <= b(i));
 %! endfor
 
 
 %!testif HAVE_GLPK
 %! sense = 1;
 %! c = [0, 0, 0, -1, -1]';
 %! A = [-2, 0, 0, 1, 0; 0, 1, 0, 0, 2; 0, 0, 1, 3, 2];
 %! b = [4, 12, 18]';
 %! ctype = ['S', 'S', 'S']';
 %! lb = [0, 0, 0, 0, 0]';
 %! ub = [];
 %! vartype = ['C', 'C', 'C', 'C', 'C']';
 %! param.msglev = 0;
 %! [xmin, fmin, errnum, extra] = glpk (c, A, b, lb, ub, ctype, vartype, ...
 %!   sense, param);
-%! assert (fmin, c' * xmin)
-%! assert (A * xmin, b)
+%! assert (fmin, c' * xmin);
+%! assert (A * xmin, b);
diff --git a/scripts/plot/appearance/annotation.m b/scripts/plot/appearance/annotation.m
--- a/scripts/plot/appearance/annotation.m
+++ b/scripts/plot/appearance/annotation.m
@@ -1242,17 +1242,17 @@ endfunction
 ## FIXME: the additionnal regular axes is necessary for fltk to draw the
 ##        annotation axes.
 %!demo
 %! clf; axes ('visible', 'off');
 %! annotation ('textbox', [.25 .9 .5 .09], 'string', ...
 %!             {'Right Click on annotation objects', ...
 %!              'to customize their appearance'}, ...
 %!             'horizontalalignment', 'center', 'fitboxtotext', 'off');
-%! annotation ('ellipse', [.2 .2 .6 .6], 'linewidth', 4)
+%! annotation ('ellipse', [.2 .2 .6 .6], 'linewidth', 4);
 %! ang = pi/2:-pi/2:-pi;
 %! lab = {'N', 'W', 'S', 'E'};
 %! x0 = 0.5;
 %! y0 = 0.5;
 %! r = 0.3;
 %! for ii = 1:4
 %!   x = r * cos (ang(ii)) + x0;
 %!   y = r * sin (ang(ii)) + y0;
@@ -1262,19 +1262,19 @@ endfunction
 %!
 %! h = annotation ('doublearrow', [x0 x0], [y0-r y0+r], ...
 %!                 'head1style', 'diamond', 'head1length', 60, ...
 %!                 'head2style', 'diamond', 'head2length', 60);
 
 %!demo
 %! clf; axes ('visible', 'off');
 %! plot (1:10);
-%! xlabel ('X-LABEL')
-%! ylabel ('LARGE Y-LABEL', 'fontsize', 20)
-%! title ('FIGURE LAYOUT', 'fontsize', 24)
+%! xlabel ('X-LABEL');
+%! ylabel ('LARGE Y-LABEL', 'fontsize', 20);
+%! title ('FIGURE LAYOUT', 'fontsize', 24);
 %!
 %! ti = get (gca, 'tightinset');
 %! pos = get (gca, 'position');
 %! pos(1:2) = pos(1:2) - ti(1:2);
 %! pos(3) = pos(3) + ti (1) + ti (3);
 %! pos(4) = pos(4) + ti (2) + ti (4);
 %!
 %! ht = annotation ('textbox', pos, 'string', ' Position + tighinset', ...
@@ -1295,17 +1295,17 @@ endfunction
 %!                  'verticalalignment', 'bottom', 'fontsize', 15);
 
 %!demo
 %! clf; axes ('visible', 'off');
 %! h = annotation ('arrow');
 %!
 %! %% Get allowed headstyles
 %! styles = set (h, 'headstyle');
-%! delete (h)
+%! delete (h);
 %!
 %! %% Textbox for the title
 %! annotation ('textbox', [0.1 0 0.8 1], 'string', ...
 %!             '"headstyle" property:', ...
 %!             'backgroundcolor', [0.7 0.7 0.7], 'fontsize', 20, ...
 %!             'fitboxtotext', 'off', 'verticalalignment', 'top', ...
 %!             'horizontalalignment', 'center');
 %!
@@ -1324,17 +1324,17 @@ endfunction
 %!   if (jj <= ns)
 %!     annotation ('textarrow', [0.7 0.5], [y y], ...
 %!                 'string', ['"' styles{jj} '"'], 'fontsize', 15, ...
 %!                 'headstyle', styles{jj}, 'textcolor', 'b');
 %!   jj = jj + 1;
 %!   end
 %!   y = y - dy;
 %! end
-%! annotation ('line', [0.5 0.5], [dy/2 1-dy/2], 'linestyle', '-.')
+%! annotation ('line', [0.5 0.5], [dy/2 1-dy/2], 'linestyle', '-.');
 
 %!demo
 %! clf; axes ('visible', 'off');
 %!
 %! %% Textbox for the title
 %! annotation ('textbox', [0.1 0 0.8 1], 'string', ...
 %!             'Text arrows: text rotation', ...
 %!             'backgroundcolor', [0.7 0.7 0.7], 'fontsize', 20, ...
@@ -1370,17 +1370,17 @@ endfunction
 %!   ii = ii + 1;
 %! end
 
 %!demo
 %! clf; axes ('visible', 'off');
 %!
 %! x = 0:0.01:2*pi;
 %! y = sin (x);
-%! plot (x, y)
+%! plot (x, y);
 %!
 %! %% Extrema
 %! x0 = [pi/2 3*pi/2];
 %! y0 = [1 -1];
 %!
 %! %% Convert axes coordinates into normalized coordinates
 %! xl = xlim ();
 %! yl = [-1.2 1.5];
@@ -1397,48 +1397,48 @@ endfunction
 %! for ii = 1:2
 %!   annotation ('doublearrow', [(x0(ii) - .05) (x0(ii) + .05)], ...
 %!               [y0(ii) y0(ii)], 'head1style', 'vback3', ...
 %!               'head2style', 'vback3', ...
 %!               'head1width', 4, 'head2width', 4)
 %!   h = annotation ('textarrow', [0.5 x0(ii)], [.85 y0(ii)], ...
 %!                   'linestyle', '--', 'headstyle', 'none');
 %! end
-%! set (h, 'string', 'Extrema', 'fontsize', 15)
+%! set (h, 'string', 'Extrema', 'fontsize', 15);
 
 ## test line properties
 %!test
 %! hf = figure ("visible", "off");
 %! hax = axes ();
 %! unwind_protect
 %!   h = annotation ("line", [0.2 0.7], [0.2 0.7], "linewidth", 2,
 %!                   "linestyle", "--", "color", "r");
 %!   hli = get (h, "children");
 %!   assert (get (hli, "linewidth"), 2);
 %!   assert (get (hli, "linestyle"), "--");
 %!   assert (get (hli, "color"), [1 0 0]);
 %!   assert (gca (), hax);
 %! unwind_protect_cleanup
-%!   close (hf)
+%!   close (hf);
 %! end_unwind_protect
 
 ## test textarrow properties
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = annotation ("textarrow", [0.2 0.7], [0.2 0.7],
 %!                   "string", "Hello!", "fontsize", 20,
 %!                   "textrotation", 90, "textcolor", "r");
 %!   hte = findobj (h, "-depth", 1, "type", "text");
 %!   assert (get (hte, "string"), "Hello!");
 %!   assert (get (hte, "fontsize"), 20);
 %!   assert (get (hte, "rotation"), 90);
 %!   assert (get (hte, "color"), [1 0 0]);
 %! unwind_protect_cleanup
-%!   close (hf)
+%!   close (hf);
 %! end_unwind_protect
 
 ## test textbox properties
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = annotation ("textbox", [0.2 0.2 0.7 0.3], "string", "Hello!",
 %!                   "horizontalalignment", "left",
@@ -1446,47 +1446,47 @@ endfunction
 %!                   "backgroundcolor", "r");
 %!   hte = findobj (h, "-depth", 1, "type", "text");
 %!   hpa = findobj (h, "-depth", 1, "type", "patch");
 %!   assert (get (hte, "string"), "Hello!");
 %!   assert (get (hte, "verticalalignment"), "bottom");
 %!   assert (get (hte, "horizontalalignment"), "left");
 %!   assert (get (hpa, "facecolor"), [1 0 0]);
 %! unwind_protect_cleanup
-%!   close (hf)
+%!   close (hf);
 %! end_unwind_protect
 
 ## test units conversion
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = annotation ("arrow", [0.1 0.2],  [0.5 0.2]);
 %!   set (h, "units", "inches");
 %!   pos = get (h, "position");
 %!   x = get (h, "x");
 %!   y = get (h, "y");
 %!   set (h, "units", "centimeters");
 %!   assert (get (h, "position"), pos * 2.54, 20*eps);
 %!   assert (get (h, "x"), x * 2.54, 20*eps);
 %!   assert (get (h, "y"), y * 2.54, 20*eps);
 %! unwind_protect_cleanup
-%!   close (hf)
+%!   close (hf);
 %! end_unwind_protect
 
 ## test annotated figure
 %!test
 %! hf1 = figure ("visible", "off");
 %! hf2 = figure ("visible", "off");
 %! unwind_protect
 %!   h = annotation (hf1, "doublearrow");
 %!   assert (ancestor (h, "figure"), hf1);
 %!   assert (gcf (), hf2);
 %! unwind_protect_cleanup
-%!   close (hf1)
-%!   close (hf2)
+%!   close (hf1);
+%!   close (hf2);
 %! end_unwind_protect
 
 ## Test input validation
 %!error <unknown annotation type foo> annotation ("foo")
 %!error annotation ([], "foo")
 %!error annotation ({})
 %!error annotation ("line", [.5 .6])
 %!error <X and Y must be 2-element vectors> annotation ("line", 1:3, 1:3)
diff --git a/scripts/plot/appearance/legend.m b/scripts/plot/appearance/legend.m
--- a/scripts/plot/appearance/legend.m
+++ b/scripts/plot/appearance/legend.m
@@ -1308,17 +1308,17 @@ endfunction
 %! h = legend ({'I am blue', 'I am green'}, 'location', 'east');
 %! legend ('right');
 %! set (h, 'textposition', 'left');
 %! set (h, 'textcolor', [1 0 1]);
 
 %!demo
 %! clf;
 %! plot (1:10, 1:10, 1:10, fliplr (1:10));
-%! title ('Legend is hidden')
+%! title ('Legend is hidden');
 %! legend ({'I am blue', 'I am green'}, 'location', 'east');
 %! legend hide
 
 %!demo
 %! clf;
 %! x = 0:1;
 %! plot (x,x,';I am Blue;', x,2*x,';I am Green;', x,3*x,';I am Red;');
 %! title ({'Labels are embedded in call to plot', ...
@@ -1390,17 +1390,17 @@ endfunction
 %! ylim ([0 1.0]);
 %! title ('legend() works for bar graphs (hggroups)');
 %! legend ({'1st Bar', '2nd Bar', '3rd Bar'});
 
 %!demo
 %! clf;
 %! colormap (cool (64));
 %! surf (peaks ());
-%! legend ('peaks()')
+%! legend ('peaks()');
 %! title ('legend() works for surface objects too');
 
 %!demo
 %! clf reset;  % needed to undo colormap assignment in previous demo
 %! rand_2x3_data2 = [0.44804, 0.84368, 0.23012; 0.72311, 0.58335, 0.90531];
 %! bar (rand_2x3_data2);
 %! ylim ([0 1.2]);
 %! title ('"left" option places text label west of colors');
@@ -1644,16 +1644,16 @@ endfunction
 %! ## bug #42035
 %! h = figure ("visible", "off");
 %! unwind_protect
 %!   hax1 = subplot (1,2,1);
 %!   plot (1:10);
 %!   hax2 = subplot (1,2,2);
 %!   plot (1:10);
 %!   hleg1 = legend (hax1, "foo");
-%!   assert (get (hleg1, "userdata").handle, hax1)
+%!   assert (get (hleg1, "userdata").handle, hax1);
 %!   assert (gca (), hax2);
 %!   hleg2 = legend ("bar");
-%!   assert (get (hleg2, "userdata").handle, gca ())
+%!   assert (get (hleg2, "userdata").handle, gca ());
 %! unwind_protect_cleanup
 %!   close (h);
 %! end_unwind_protect
 
diff --git a/scripts/plot/appearance/orient.m b/scripts/plot/appearance/orient.m
--- a/scripts/plot/appearance/orient.m
+++ b/scripts/plot/appearance/orient.m
@@ -122,23 +122,23 @@ endfunction
 %! hfig = figure ("visible", "off");
 %! set (hfig, "paperunits", "inches");
 %! set (hfig, "paperorientation", "portrait");
 %! set (hfig, "papersize", papersize);
 %! set (hfig, "paperposition", paperposition);
 
 %!test
 %! orient portrait;
-%! assert (orient, "portrait")   # default
+%! assert (orient, "portrait");  # default
 %! assert (get (hfig, "papersize"), papersize);
 %! assert (get (hfig, "paperposition"), paperposition);
 
 %!test
 %! orient landscape;
-%! assert (orient,"landscape")   # change to landscape
+%! assert (orient,"landscape");  # change to landscape
 %! assert (get (hfig, "papersize"), papersize([2, 1]));
 %! assert (get (hfig, "paperposition"), fullpaperposition([1, 2, 4, 3]));
 
 %!test
 %! orient portrait   # change back to portrait
 %! assert (orient, "portrait");
 %! assert (get (hfig, "papersize"), papersize);
 %! assert (get (hfig, "paperposition"), paperposition);
diff --git a/scripts/plot/appearance/text.m b/scripts/plot/appearance/text.m
--- a/scripts/plot/appearance/text.m
+++ b/scripts/plot/appearance/text.m
@@ -338,16 +338,16 @@ endfunction
 %!   h = text ([0.1, 0.1], [0.7, 0.8], {"cellstr1", "cellstr2"});
 %!   assert (class (get (h(1), "string")), "char");
 %!   assert (class (get (h(2), "string")), "char");
 %!   assert (get (h(1), "string"), "cellstr1");
 %!   assert (get (h(2), "string"), "cellstr2");
 %!
 %!   ## Test special keyword processing
 %!   h = text (0.5, 0.5, "default");
-%!   assert (get (h, "string"), "default")
+%!   assert (get (h, "string"), "default");
 %!   h = text (0.5, 0.5, "factory");
-%!   assert (get (h, "string"), "factory")
+%!   assert (get (h, "string"), "factory");
 %!
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/draw/area.m b/scripts/plot/draw/area.m
--- a/scripts/plot/draw/area.m
+++ b/scripts/plot/draw/area.m
@@ -263,17 +263,17 @@ endfunction
 %! set (h, 'basevalue', -1);
 %! title ({'Parabola y = x^2 -1';'BaseValue = -1'});
 
 %!demo
 %! clf;
 %! x = 0:10;
 %! y = rand (size (x));
 %! h = area (x, y);
-%! set (h, 'ydata', sort (get (h, 'ydata')))
+%! set (h, 'ydata', sort (get (h, 'ydata')));
 %! title ('area() plot of sorted data');
 
 ## Test input validation
 %!error area ()
 %!error area (1,2,3,4)
 %!error <X and Y must be real vectors or matrices> area ({1})
 %!error <X and Y must be real vectors or matrices> area (1+i)
 %!error <X and Y must be real vectors or matrices> area (1:2, {1, 2})
diff --git a/scripts/plot/draw/barh.m b/scripts/plot/draw/barh.m
--- a/scripts/plot/draw/barh.m
+++ b/scripts/plot/draw/barh.m
@@ -75,18 +75,18 @@ function varargout = barh (varargin)
   [varargout{:}] = __bar__ (false, "barh", varargin{:});
 endfunction
 
 
 %!demo
 %! clf;
 %! x = rand (10, 1);
 %! barh (x);
-%! title ('barh() graph')
+%! title ('barh() graph');
 
 %!demo
 %! clf;
 %! h = barh (rand (5, 3));
-%! set (h(1), 'facecolor', 'r')
-%! set (h(2), 'facecolor', 'g')
-%! set (h(3), 'facecolor', 'b')
-%! title ('barh() graph w/multiple bars')
+%! set (h(1), 'facecolor', 'r');
+%! set (h(2), 'facecolor', 'g');
+%! set (h(3), 'facecolor', 'b');
+%! title ('barh() graph w/multiple bars');
 
diff --git a/scripts/plot/draw/contour.m b/scripts/plot/draw/contour.m
--- a/scripts/plot/draw/contour.m
+++ b/scripts/plot/draw/contour.m
@@ -112,30 +112,30 @@ endfunction
 %!test
 %! hf = figure ("visible", "off");
 %! clf (hf);
 %! unwind_protect
 %!   [x, y, z] = peaks ();
 %!   [c, h] = contour (x, y, z);
 %!   levellist = -6:6;
 %!   set (h, "levellist", levellist);
-%!   assert (get (h, "levellist"), levellist)
-%!   assert (get (h, "levellistmode"), "manual")
+%!   assert (get (h, "levellist"), levellist);
+%!   assert (get (h, "levellistmode"), "manual");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! clf (hf);
 %! unwind_protect
 %!   [x, y, z] = peaks ();
 %!   [c, h] = contour (x, y, z);
 %!   levelstep = 3;
 %!   set (h, "levelstep", levelstep);
-%!   assert (get (h, "levelstep"), levelstep)
-%!   assert (get (h, "levelstepmode"), "manual")
-%!   assert (get (h, "levellist"), -6:levelstep:6)
-%!   assert (get (h, "levellistmode"), "auto")
+%!   assert (get (h, "levelstep"), levelstep);
+%!   assert (get (h, "levelstepmode"), "manual");
+%!   assert (get (h, "levellist"), -6:levelstep:6);
+%!   assert (get (h, "levellistmode"), "auto");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/draw/line.m b/scripts/plot/draw/line.m
--- a/scripts/plot/draw/line.m
+++ b/scripts/plot/draw/line.m
@@ -58,27 +58,27 @@ function h = line (varargin)
   if (nargout > 0)
     h = htmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! line ([0 1], [0.8 0.8], 'linestyle', '-', 'color', 'b');
 %! line ([0 1], [0.6 0.6], 'linestyle', '--', 'color', 'g');
 %! line ([0 1], [0.4 0.4], 'linestyle', ':', 'color', 'r');
 %! line ([0 1], [0.2 0.2], 'linestyle', '-.', 'color', 'k');
 %! ylim ([0 1]);
 %! title ('line() with various linestyles');
 %! legend ('"-"', '"--"', '":"', '"-."', 'location', 'eastoutside');
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:0.3:10;
 %! y1 = cos (x);
 %! y2 = sin (x);
 %! subplot (3,1,1);
 %!  args = {'color', 'b', 'marker', 's'};
 %!  line ([x(:), x(:)], [y1(:), y2(:)], args{:});
 %!  title ('Test broadcasting for line()');
 %! subplot (3,1,2);
diff --git a/scripts/plot/draw/plot.m b/scripts/plot/draw/plot.m
--- a/scripts/plot/draw/plot.m
+++ b/scripts/plot/draw/plot.m
@@ -248,40 +248,40 @@ endfunction
 %! x2 = 5:9; y2 = 5:-1:1;
 %! plot (x1,y1,'bo-', x2,y2,'rs-');
 %! axis ('tight');
 %! title ({'plot() of blue circles ascending and red squares descending';
 %!         'connecting lines drawn'});
 
 %!demo
 %! x = 0:10;
-%! plot (x, rand (numel (x), 3))
-%! axis ([0 10 0 1])
-%! title ({'Three random variables', 'x[1x11], y[11x3]'})
+%! plot (x, rand (numel (x), 3));
+%! axis ([0 10 0 1]);
+%! title ({'Three random variables', 'x[1x11], y[11x3]'});
 
 %!demo
 %! x = 0:10;
-%! plot (x, rand (3, numel (x)))
-%! axis ([0 10 0 1])
-%! title ({'Three random variables', 'x[1x11], y[3x11]'})
+%! plot (x, rand (3, numel (x)));
+%! axis ([0 10 0 1]);
+%! title ({'Three random variables', 'x[1x11], y[3x11]'});
 
 %!demo
 %! x = 0:10;
-%! plot (repmat (x, 2, 1), rand (2, numel (x)), '-s')
-%! axis ([0 10 0 1])
+%! plot (repmat (x, 2, 1), rand (2, numel (x)), '-s');
+%! axis ([0 10 0 1]);
 %! title ({'Vertical lines with random height and lengths', ...
 %!         'x[2x11], y[2,11]'})
 
 %!demo
 %! x = 0:10;
-%! plot (repmat (x(:), 1, 2), rand (numel (x), 2))
-%! axis ([0 10 0 1])
-%! title ({'Two random variables', 'x[11x2], y[11x2]'})
+%! plot (repmat (x(:), 1, 2), rand (numel (x), 2));
+%! axis ([0 10 0 1]);
+%! title ({'Two random variables', 'x[11x2], y[11x2]'});
 
 %!demo
 %! x = 0:10;
 %! shape = [1, 1, numel(x), 2];
 %! x = reshape (repmat (x(:), 1, 2), shape);
 %! y = rand (shape);
-%! plot (x, y)
-%! axis ([0 10 0 1])
-%! title ({'Two random variables', 'squeezed from 4-d arrays'})
+%! plot (x, y);
+%! axis ([0 10 0 1]);
+%! title ({'Two random variables', 'squeezed from 4-d arrays'});
 
diff --git a/scripts/plot/draw/plot3.m b/scripts/plot/draw/plot3.m
--- a/scripts/plot/draw/plot3.m
+++ b/scripts/plot/draw/plot3.m
@@ -372,17 +372,17 @@ function retval = plot3 (varargin)
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! z = [0:0.05:5];
-%! plot3 (cos (2*pi*z), sin (2*pi*z), z)
+%! plot3 (cos (2*pi*z), sin (2*pi*z), z);
 %! legend ('helix');
 %! title ('plot3() of a helix');
 
 %!demo
 %! clf;
 %! z = [0:0.05:5];
 %! plot3 (z, exp (2i*pi*z));
 %! legend ('complex sinusoid');
diff --git a/scripts/plot/draw/plotyy.m b/scripts/plot/draw/plotyy.m
--- a/scripts/plot/draw/plotyy.m
+++ b/scripts/plot/draw/plotyy.m
@@ -293,17 +293,17 @@ endfunction
 %!  surf (peaks (25));
 %! subplot (2,2,3);
 %!  contour (peaks (25));
 %! subplot (2,2,4);
 %!  plotyy (x,10*sin(2*pi*x), x,cos(2*pi*x));
 %! axis square;
 
 %!demo
-%! clf
+%! clf;
 %! hold on
 %! t = (0:0.1:9);
 %! x = sin (t);
 %! y = 5 * cos (t);
 %! [hax, h1, h2] = plotyy (t, x, t, y);
 %! [~, h3, h4] = plotyy (t+1, x, t+1, y);
 %! set ([h3, h4], 'linestyle', '--');
 %! xlabel (hax(1), 'xlabel');
diff --git a/scripts/plot/draw/quiver.m b/scripts/plot/draw/quiver.m
--- a/scripts/plot/draw/quiver.m
+++ b/scripts/plot/draw/quiver.m
@@ -92,17 +92,17 @@ function h = quiver (varargin)
 
 endfunction
 
 
 %!demo
 %! clf;
 %! [x,y] = meshgrid (1:2:20);
 %! h = quiver (x,y, sin (2*pi*x/10), sin (2*pi*y/10));
-%! title ('quiver plot')
+%! title ('quiver plot');
 
 %!demo
 %! clf;
 %! x = linspace (0, 3, 80);
 %! y = sin (2*pi*x);
 %! theta = 2*pi*x + pi/2;
 %! quiver (x, y, sin (theta)/10, cos (theta)/10, 0.4);
 %! axis equal tight;
diff --git a/scripts/plot/draw/stem.m b/scripts/plot/draw/stem.m
--- a/scripts/plot/draw/stem.m
+++ b/scripts/plot/draw/stem.m
@@ -194,32 +194,32 @@ endfunction
 %! clf;
 %! N = 11;
 %! x = 0:(N-1);
 %! y = rand (1, N);
 %! hs = stem (x(1), y(1));
 %! set (gca (), 'xlim', [1, N-1], 'ylim', [0, 1]);
 %! title ('stem plot data modified through hggroup handle');
 %! for k=2:N
-%!   set (hs, 'xdata', x(1:k), 'ydata', y(1:k))
+%!   set (hs, 'xdata', x(1:k), 'ydata', y(1:k));
 %!   drawnow ();
 %!   pause (0.2);
 %! end
 
 %!test
 %! ## stemseries share the same baseline and basevalue
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = stem ([1 2; 1.5 2.5], [1 1;2 2]);
-%!   assert (get (h(1), "baseline"), get (h(2), "baseline"))
+%!   assert (get (h(1), "baseline"), get (h(2), "baseline"));
 %!   bv = 0.3;
-%!   set (h(1), "basevalue", bv)
-%!   assert (get (get (h(1), "baseline"), "basevalue"), bv)
-%!   assert (get (h(1), "basevalue"), bv)
-%!   assert (get (h(2), "basevalue"), bv)
+%!   set (h(1), "basevalue", bv);
+%!   assert (get (get (h(1), "baseline"), "basevalue"), bv);
+%!   assert (get (h(1), "basevalue"), bv);
+%!   assert (get (h(2), "basevalue"), bv);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 ## Test input validation
 %!error stem ()
 %!error <can not define Z for 2-D stem plot> stem (1,2,3)
 %!error <Y must be a vector or 2-D array> stem (ones (2,2,2))
diff --git a/scripts/plot/util/clf.m b/scripts/plot/util/clf.m
--- a/scripts/plot/util/clf.m
+++ b/scripts/plot/util/clf.m
@@ -105,26 +105,26 @@ endfunction
 %! unwind_protect
 %!   clf;
 %!   assert (isempty (get (gcf, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!xtest
-%! set (0, "defaultfigurevisible", "off")
+%! set (0, "defaultfigurevisible", "off");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot (1:10);
 %!   set (hf, "papertype", "tabloid");
 %!   clf (hf);
 %!   assert (isempty (get (gcf, "children")));
 %!   assert (get (hf, "papertype"), "tabloid");
 %!   plot (1:10);
 %!   clf (hf, "reset");
 %!   kids = get (hf, "children");
 %!   assert (isempty (get (gcf, "children")));
 %!   assert (get (hf, "papertype"), "usletter");
 %! unwind_protect_cleanup
-%!   set (0, "defaultfigurevisible", "remove")
+%!   set (0, "defaultfigurevisible", "remove");
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/util/copyobj.m b/scripts/plot/util/copyobj.m
--- a/scripts/plot/util/copyobj.m
+++ b/scripts/plot/util/copyobj.m
@@ -169,16 +169,16 @@ endfunction
 %! end_unwind_protect
 
 %!test
 %! unwind_protect
 %!   tag = "foo";
 %!   hf = figure ("visible", "off");
 %!   hax = axes ("tag", tag);
 %!   hpa = patch ();
-%!   set (hpa, "facecolor", [.5 .5 .5], "tag", tag)
+%!   set (hpa, "facecolor", [.5 .5 .5], "tag", tag);
 %!   hax2 = copyobj (hax, hf);
-%!   assert (get (hax2, "tag"), tag)
+%!   assert (get (hax2, "tag"), tag);
 %!   hpa2 = get (hax2, "children");
-%!   assert (get (hpa2, "facecolor"), [.5 .5 .5])
+%!   assert (get (hpa2, "facecolor"), [.5 .5 .5]);
 %! unwind_protect_cleanup
-%!   close (hf)
+%!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/util/findobj.m b/scripts/plot/util/findobj.m
--- a/scripts/plot/util/findobj.m
+++ b/scripts/plot/util/findobj.m
@@ -356,17 +356,17 @@ endfunction
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h1 = subplot (2,2,1, "tag", "1");
 %!   h2 = subplot (2,2,2, "tag", "2");
 %!   h3 = subplot (2,2,3, "tag", "3");
 %!   h4 = subplot (2,2,4, "tag", "4");
 %!   h = findobj (hf, "type", "axes", "-not", "tag", "1");
-%!   assert (h, [h4; h3; h2])
+%!   assert (h, [h4; h3; h2]);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h1 = subplot (2, 2, 1);
@@ -377,30 +377,30 @@ endfunction
 %!   set (h3, "userdata", struct ("column", 1, "row", 2));
 %!   h4 = subplot (2, 2, 4);
 %!   set (h4, "userdata", struct ("column", 2, "row", 2));
 %!   h = findobj (hf, "type", "axes",
 %!                "-not", "userdata", struct ("column", 1, "row", 1));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
-%! assert (h, [h4; h3; h2])
+%! assert (h, [h4; h3; h2]);
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   ha = axes ();
 %!   plot (1:10);
 %!   h = findobj (hf, "type", "figure",
 %!                "-or", "parent", hf,
 %!                "-and", "type", "axes");
 %! unwind_protect_cleanup
-%!   close (hf)
+%!   close (hf);
 %! end_unwind_protect
-%! assert (h, [hf; ha])
+%! assert (h, [hf; ha]);
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   set (hf, "tag", "foo");
 %!   h1 = subplot (2,2,1, "tag", "foo");
 %!   h2 = subplot (2,2,2, "tag", "bar");
 %!   h3 = subplot (2,2,3, "tag", "foo");
diff --git a/scripts/plot/util/subplot.m b/scripts/plot/util/subplot.m
--- a/scripts/plot/util/subplot.m
+++ b/scripts/plot/util/subplot.m
@@ -486,65 +486,65 @@ endfunction
 %! ylabel ('ylabel (1,2,1)');
 %! title ('title (1,2,1)');
 
 %!demo
 %! clf;
 %! x = 0:10;
 %! ax(1) = subplot (221);
 %! set (ax(1), 'tag', '1');
-%! plot (x, rand (3, 11))
+%! plot (x, rand (3, 11));
 %! title ('x & y labels & ticklabels');
 %! xlabel xlabel
 %! ylabel ylabel
 %! ax(2) = subplot (222);
 %! set (ax(2), 'tag', '2');
-%! plot (x, rand (3, 11))
+%! plot (x, rand (3, 11));
 %! title ('no labels');
-%! axis ('nolabel','tic')
+%! axis ('nolabel','tic');
 %! ax(3) = subplot (223);
 %! set (ax(3), 'tag', '3');
-%! plot (x, rand (3, 11))
+%! plot (x, rand (3, 11));
 %! title ('no labels');
-%! axis ('nolabel','tic')
+%! axis ('nolabel','tic');
 %! ax(4) = subplot (224);
 %! set (ax(4), 'tag', '4');
-%! plot (x, rand (3, 11))
+%! plot (x, rand (3, 11));
 %! title ('x & y labels & ticklabels');
 %! xlabel xlabel
 %! ylabel ylabel
 
 %!demo
 %! x = 0:10;
 %! subplot (221);
-%! plot (x, rand (3, 11))
+%! plot (x, rand (3, 11));
 %! ylim ([0, 1]);
 %! text (0.5, 0.5, '{x,y}labels & {x,y}ticklabels', ...
 %!       'horizontalalignment', 'center', ...
 %!       'units', 'normalized');
 %! xlabel xlabel
 %! ylabel ylabel
 %! title title
 %! subplot (222);
-%! plot (x, rand (3, 11))
+%! plot (x, rand (3, 11));
 %! axis ('labely');
 %! ylabel ylabel
 %! text (0.5, 0.5, 'no xlabels, xticklabels', ...
 %!       'horizontalalignment', 'center', ...
 %!       'units', 'normalized');
 %! subplot (223);
-%! plot (x, rand (3, 11))
+%! plot (x, rand (3, 11));
 %! axis ('labelx');
 %! text (0.5, 0.5, 'no ylabels, yticklabels', ...
 %!       'horizontalalignment', 'center', ...
 %!       'units', 'normalized');
 %! xlabel xlabel
 %! title title
 %! subplot (224);
-%! plot (x, rand (3, 11))
+%! plot (x, rand (3, 11));
 %! axis ('nolabel','tic');
 %! text (0.5, 0.5, 'no {x,y}labels, {x,y}ticklabels', ...
 %!       'horizontalalignment', 'center', ...
 %!       'units', 'normalized');
 
 ## Test recognition/deletion of previous axes
 ## Default mode
 %!test
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -124,17 +124,17 @@ endfunction
 %!
 %!test
 %! breaks = [0, 1, 2, 3];
 %! coefs = rand (6, 4);
 %! pp = mkpp (breaks, coefs, 2);
 %! ret = zeros (2, 4, 2);
 %! ret(:,:,1) = ppval (pp, breaks');
 %! ret(:,:,2) = ppval (pp, breaks');
-%! assert (ppval (pp, [breaks',breaks']), ret)
+%! assert (ppval (pp, [breaks',breaks']), ret);
 
 ## Test input validation
 %!error ppval ()
 %!error ppval (1)
 %!error ppval (1,2,3)
 %!error <argument must be a pp-form structure> ppval (1,2)
 %!error <argument must be a pp-form structure> ppval (struct ("a", 1), 2)
 %!error <argument must be a pp-form structure> ppval (struct ("form", "ab"), 2)
diff --git a/scripts/polynomial/splinefit.m b/scripts/polynomial/splinefit.m
--- a/scripts/polynomial/splinefit.m
+++ b/scripts/polynomial/splinefit.m
@@ -149,82 +149,82 @@ endfunction
 %!demo
 %! % Noisy data
 %! x = linspace (0, 2*pi, 100);
 %! y = sin (x) + 0.1 * randn (size (x));
 %! % Breaks
 %! breaks = [0:5, 2*pi];
 %! % Fit a spline of order 5
 %! pp = splinefit (x, y, breaks, "order", 4);
-%! clf ()
-%! plot (x, y, "s", x, ppval (pp, x), "r", breaks, ppval (pp, breaks), "+r")
-%! xlabel ("Independent Variable")
-%! ylabel ("Dependent Variable")
+%! clf;
+%! plot (x, y, "s", x, ppval (pp, x), "r", breaks, ppval (pp, breaks), "+r");
+%! xlabel ("Independent Variable");
+%! ylabel ("Dependent Variable");
 %! title ("Fit a piece-wise polynomial of order 4");
-%! legend ({"data", "fit", "breaks"})
+%! legend ({"data", "fit", "breaks"});
 %! axis tight
 %! ylim auto
 
 %!demo
 %! % Noisy data
 %! x = linspace (0,2*pi, 100);
 %! y = sin (x) + 0.1 * randn (size (x));
 %! % Breaks
 %! breaks = [0:5, 2*pi];
 %! % Fit a spline of order 3 with periodic boundary conditions
 %! pp = splinefit (x, y, breaks, "order", 2, "periodic", true);
-%! clf ()
-%! plot (x, y, "s", x, ppval (pp, x), "r", breaks, ppval (pp, breaks), "+r")
-%! xlabel ("Independent Variable")
-%! ylabel ("Dependent Variable")
+%! clf;
+%! plot (x, y, "s", x, ppval (pp, x), "r", breaks, ppval (pp, breaks), "+r");
+%! xlabel ("Independent Variable");
+%! ylabel ("Dependent Variable");
 %! title ("Fit a periodic piece-wise polynomial of order 2");
-%! legend ({"data", "fit", "breaks"})
+%! legend ({"data", "fit", "breaks"});
 %! axis tight
 %! ylim auto
 
 %!demo
 %! % Noisy data
 %! x = linspace (0, 2*pi, 100);
 %! y = sin (x) + 0.1 * randn (size (x));
 %! % Breaks
 %! breaks = [0:5, 2*pi];
 %! % Constraints: y(0) = 0, y'(0) = 1 and y(3) + y"(3) = 0
 %! xc = [0 0 3];
 %! yc = [0 1 0];
 %! cc = [1 0 1; 0 1 0; 0 0 1];
 %! con = struct ("xc", xc, "yc", yc, "cc", cc);
 %! % Fit a cubic spline with 8 pieces and constraints
 %! pp = splinefit (x, y, 8, "constraints", con);
-%! clf ()
-%! plot (x, y, "s", x, ppval (pp, x), "r", breaks, ppval (pp, breaks), "+r")
-%! xlabel ("Independent Variable")
-%! ylabel ("Dependent Variable")
-%! title ("Fit a cubic spline with constraints")
-%! legend ({"data", "fit", "breaks"})
+%! clf;
+%! plot (x, y, "s", x, ppval (pp, x), "r", breaks, ppval (pp, breaks), "+r");
+%! xlabel ("Independent Variable");
+%! ylabel ("Dependent Variable");
+%! title ("Fit a cubic spline with constraints");
+%! legend ({"data", "fit", "breaks"});
 %! axis tight
 %! ylim auto
 
 %!demo
 %! % Noisy data
 %! x = linspace (0, 2*pi, 100);
 %! y = sin (x) + 0.1 * randn (size (x));
 %! % Breaks
 %! breaks = [0:5, 2*pi];
 %! xc = [0 0 3];
 %! yc = [0 1 0];
 %! cc = [1 0 1; 0 1 0; 0 0 1];
 %! con = struct ("xc", xc, "yc", yc, "cc", cc);
 %! % Fit a spline of order 6 with constraints and periodicity
 %! pp = splinefit (x, y, breaks, "constraints", con, "order", 5, "periodic", true);
-%! clf ()
-%! plot (x, y, "s", x, ppval (pp, x), "r", breaks, ppval (pp, breaks), "+r")
-%! xlabel ("Independent Variable")
-%! ylabel ("Dependent Variable")
-%! title ("Fit a 5th order piece-wise periodic polynomial with constraints")
-%! legend ({"data", "fit", "breaks"})
+%! clf;
+%! plot (x, y, "s", x, ppval (pp, x), "r", breaks, ppval (pp, breaks), "+r");
+%! xlabel ("Independent Variable");
+%! ylabel ("Dependent Variable");
+%! title ("Fit a 5th order piece-wise periodic polynomial with constraints");
+%! legend ({"data", "fit", "breaks"});
 %! axis tight
 %! ylim auto
 
 %!shared xb, yb, x
 %! xb = 0:2:10;
 %! yb = 2*rand (size (xb)) - 1;
 %! x = 0:0.1:10;
 
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -158,47 +158,47 @@ endfunction
 %!assert (ismember ({"bar"}, {"foobar"}), false)
 %!assert (ismember ({"bar"}, {"foobar", "bar"}), true)
 %!assert (ismember ({"foo", "bar"}, {"foobar", "bar"}), [false true])
 %!assert (ismember ({"xfb", "f", "b"}, {"fb", "b"}), [false false true])
 %!assert (ismember ("1", "0123456789."), true)
 
 %!test
 %! [result, s_idx] = ismember ([1, 2], []);
-%! assert (result, [false false])
+%! assert (result, [false false]);
 %! assert (s_idx, [0, 0]);
 
 %!test
 %! [result, s_idx] = ismember ([], [1, 2]);
-%! assert (result, logical ([]))
+%! assert (result, logical ([]));
 %! assert (s_idx, []);
 
 %!test
 %! [result, s_idx] = ismember ({"a", "b"}, "");
-%! assert (result, [false false])
+%! assert (result, [false false]);
 %! assert (s_idx, [0, 0]);
 
 %!test
 %! [result, s_idx] = ismember ({"a", "b"}, {});
-%! assert (result, [false false])
+%! assert (result, [false false]);
 %! assert (s_idx, [0, 0]);
 
 %!test
 %! [result, s_idx] = ismember ("", {"a", "b"});
-%! assert (result, false)
+%! assert (result, false);
 %! assert (s_idx, 0);
 
 %!test
 %! [result, s_idx] = ismember ({}, {"a", "b"});
-%! assert (result, logical ([]))
+%! assert (result, logical ([]));
 %! assert (s_idx, []);
 
 %!test
 %! [result, s_idx] = ismember ([1 2 3 4 5], [3]);
-%! assert (result, logical ([0 0 1 0 0]))
+%! assert (result, logical ([0 0 1 0 0]));
 %! assert (s_idx , [0 0 1 0 0]);
 
 %!test
 %! [result, s_idx] = ismember ([1 6], [1 2 3 4 5 1 6 1]);
 %! assert (result, [true true]);
 %! assert (s_idx(2), 7);
 
 %!test
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -203,17 +203,17 @@ endfunction
 
 %!test # correct values and fft-polyval consistency
 %! ## butterworth filter, order 2, cutoff pi/2 radians
 %! b = [0.292893218813452  0.585786437626905  0.292893218813452];
 %! a = [1  0  0.171572875253810];
 %! [h,w] = freqz (b,a,32);
 %! assert (h(1),1,10*eps);
 %! assert (abs (h(17)).^2,0.5,10*eps);
-%! assert (h,freqz (b,a,w),10*eps); # fft should be consistent with polyval
+%! assert (h,freqz (b,a,w),10*eps);  # fft should be consistent with polyval
 
 %!test # whole-half consistency
 %! b = [1 1 1]/3; # 3-sample average
 %! [h,w] = freqz (b,1,32,"whole");
 %! assert (h(2:16),conj (h(32:-1:18)),20*eps);
 %! [h2,w2] = freqz (b,1,16,"half");
 %! assert (h(1:16),h2,20*eps);
 %! assert (w(1:16),w2,20*eps);
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -120,34 +120,34 @@ endfunction
 %!assert ([0; 10 - 4*pi], unwrap ([0; 10]))
 %!assert ([0; 13 - 4*pi], unwrap ([0; 13]))
 %!assert ([0; 16 - 6*pi], unwrap ([0; 16]))
 %!assert ([0; 19 - 6*pi], unwrap ([0; 19]))
 %!assert (max (abs (diff (unwrap (100*pi * rand (1000, 1))))) < pi)
 
 %!test
 %! A = [pi*(-4), pi*(-2+1/6), pi/4, pi*(2+1/3), pi*(4+1/2), pi*(8+2/3), pi*(16+1), pi*(32+3/2), pi*64];
-%! assert (unwrap (A), unwrap (A, pi))
-%! assert (unwrap (A, pi), unwrap (A, pi, 2))
-%! assert (unwrap (A', pi), unwrap (A', pi, 1))
+%! assert (unwrap (A), unwrap (A, pi));
+%! assert (unwrap (A, pi), unwrap (A, pi, 2));
+%! assert (unwrap (A', pi), unwrap (A', pi, 1));
 
 %!test
 %! A = [pi*(-4); pi*(2+1/3); pi*(16+1)];
 %! B = [pi*(-2+1/6); pi*(4+1/2); pi*(32+3/2)];
 %! C = [pi/4; pi*(8+2/3); pi*64];
 %! D = [pi*(-2+1/6); pi*(2+1/3); pi*(8+2/3)];
 %! E(:, :, 1) = [A, B, C, D];
 %! E(:, :, 2) = [A+B, B+C, C+D, D+A];
 %! F(:, :, 1) = [unwrap(A), unwrap(B), unwrap(C), unwrap(D)];
 %! F(:, :, 2) = [unwrap(A+B), unwrap(B+C), unwrap(C+D), unwrap(D+A)];
-%! assert (unwrap (E), F)
+%! assert (unwrap (E), F);
 
 %!test
 %! A = [0, 2*pi, 4*pi, 8*pi, 16*pi, 65536*pi];
 %! B = [pi*(-2+1/6), pi/4, pi*(2+1/3), pi*(4+1/2), pi*(8+2/3), pi*(16+1), pi*(32+3/2), pi*64];
-%! assert (unwrap (A), zeros (1, length (A)))
-%! assert (diff (unwrap (B), 1) < 2*pi, true (1, length (B)-1))
+%! assert (unwrap (A), zeros (1, length (A)));
+%! assert (diff (unwrap (B), 1) < 2*pi, true (1, length (B)-1));
 
 ## Test input validation
 %!error unwrap ()
 %!error unwrap (1,2,3,4)
 %!error unwrap ("foo")
 
diff --git a/scripts/sparse/eigs.m b/scripts/sparse/eigs.m
--- a/scripts/sparse/eigs.m
+++ b/scripts/sparse/eigs.m
@@ -492,17 +492,17 @@ endfunction
 ## Real unsymmetric tests
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
 %! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]);
 %! d0 = eig (A);
 %! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
-%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
+%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k+1);
 %! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, "lm");
@@ -619,17 +619,17 @@ endfunction
 ## Complex hermitian tests
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
 %! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]);
 %! d0 = eig (A);
 %! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
-%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
+%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k+1);
 %! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, "lm");
@@ -750,17 +750,17 @@ endfunction
 %!shared n, k, A, d0, d2
 %! n = 20;
 %! k = 4;
 %! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]));
 %! d0 = eig (A);
 %! d2 = sort (d0);
 %! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
-%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
+%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k+1);
 %! assert (d1, d0(end:-1:(end-k)),1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, "lm");
@@ -861,17 +861,17 @@ endfunction
 ## Real unsymmetric tests
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
 %! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]));
 %! d0 = eig (A);
 %! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
-%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
+%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k+1);
 %! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, "lm");
@@ -987,17 +987,17 @@ endfunction
 ## Complex hermitian tests
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
 %! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]));
 %! d0 = eig (A);
 %! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
-%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
+%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k+1);
 %! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, "lm");
@@ -1112,17 +1112,17 @@ endfunction
 %!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 
 %!test
 %! A = 2 * diag (ones (10, 1)) - diag (ones (9, 1), 1) - diag (ones (9, 1), -1);
 %! B = diag (ones (10, 1));
 %! reseig = eig (A, B);
 %! [~, idx] = sort (abs (reseig), "ascend");
-%! assert (eigs (A, B, 10, 0), reseig (idx))
+%! assert (eigs (A, B, 10, 0), reseig (idx));
 
 %!test
 %! X = [70 47 42 39 50 73 79 23;
 %!      19 52 61 80 36 76 63 68;
 %!      14 34 66 65 29  4 72  9;
 %!      24  8 78 49 58 54 43 33;
 %!      62 69 32 31 40 46 22 28;
 %!      48 12 45 59 10 17 15 25;
diff --git a/scripts/sparse/ichol.m b/scripts/sparse/ichol.m
--- a/scripts/sparse/ichol.m
+++ b/scripts/sparse/ichol.m
@@ -313,20 +313,20 @@ endfunction
 %! opts.diagcomp = 3e-3;
 %! L = ichol (A1, opts);
 %! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.0272, 1e-4);
 %!
 %!test
 %! opts.type = "nofill";
 %! opts.michol = "off";
 %! L = ichol (A2, opts);
-%! assert (norm (A2 - L*L', "fro") / norm (A2, "fro"), 0.0893, 1e-4)
+%! assert (norm (A2 - L*L', "fro") / norm (A2, "fro"), 0.0893, 1e-4);
 %! opts.michol = "on";
 %! L = ichol (A2, opts);
-%! assert (norm (A2 - L*L', "fro") / norm (A2, "fro"), 0.2377, 1e-4)
+%! assert (norm (A2 - L*L', "fro") / norm (A2, "fro"), 0.2377, 1e-4);
 %!
 %!test
 %! opts.type = "nofill";
 %! opts.michol = "off";
 %! L = ichol (A3, opts);
 %! assert (norm (A3 - L*L', "fro") / norm (A3, "fro"), eps, eps);
 %! opts.michol = "on";
 %! L = ichol (A3, opts);
@@ -385,20 +385,20 @@ endfunction
 %! L = ichol (A1, opts);
 %! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.3266, 1e-4);
 %!
 %!test
 %! opts.type = "ict";
 %! opts.droptol = 1e-1;
 %! opts.michol = "off";
 %! L = ichol (A2, opts);
-%! assert (norm (A2 - L*L', "fro") / norm (A2, "fro"),  0.0893, 1e-4)
+%! assert (norm (A2 - L*L', "fro") / norm (A2, "fro"),  0.0893, 1e-4);
 %! opts.michol = "on";
 %! L = ichol (A2, opts);
-%! assert (norm (A2 - L*L', "fro") / norm (A2, "fro"), 0.2377, 1e-4)
+%! assert (norm (A2 - L*L', "fro") / norm (A2, "fro"), 0.2377, 1e-4);
 %!
 %!test
 %! opts.type = "ict";
 %! opts.droptol = 1e-1;
 %! opts.michol = "off";
 %! L = ichol (A3, opts);
 %! assert (norm (A3 - L*L', "fro") / norm (A3, "fro"), eps, eps);
 %! opts.michol = "on";
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -528,11 +528,11 @@ endfunction
 %! for i = 1 : N - 1  # form 1-D Laplacian matrix
 %!   A(i:i+1, i:i+1) = [2 -1; -1 2];
 %! endfor
 %! b = ones (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], [], A, [], b);
 %! assert (norm (x - X) / norm (X), 0, 1e-6);
 %! assert (flag, 0);
-%! assert (iter, 1); # should converge in one iteration
+%! assert (iter, 1);  # should converge in one iteration
 %! assert (isnan (eigest), isnan ([NaN, NaN]));
 
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -139,37 +139,37 @@ endfunction
 %!test
 %! ## Case 1: M = N
 %! A = sparse (zeros (3,3));
 %! A(1,3) = 13;
 %! A(3,1) = 31;
 %! [B, d] = spdiags (A);
 %! assert (d, [-2 2]');
 %! assert (B, [31 0; 0 0; 0 13]);
-%! assert (spdiags (B, d, 3,3), A)
+%! assert (spdiags (B, d, 3,3), A);
 
 %!test
 %! ## Case 1: M > N
 %! A = sparse (zeros (4,3));
 %! A(1,3) = 13;
 %! A(3,1) = 31;
 %! [B, d] = spdiags (A);
 %! assert (d, [-2 2]');
 %! assert (B, [31 0; 0 0; 0 13]);
-%! assert (spdiags (B, d, 4,3), A)
+%! assert (spdiags (B, d, 4,3), A);
 
 %!test
 %! ## Case 1: M < N
 %! A = sparse (zeros (3,4));
 %! A(1,3) = 13;
 %! A(3,1) = 31;
 %! [B, d] = spdiags (A);
 %! assert (d, [-2 2]');
 %! assert (B, [0 13; 0 0; 31 0]);
-%! assert (spdiags (B, d, 3,4), A)
+%! assert (spdiags (B, d, 3,4), A);
 
 %!assert (spdiags (zeros (1,0),1,1,1), sparse (0))
 %!assert (spdiags (zeros (0,1),1,1,1), sparse (0))
 %!assert (spdiags ([0.5 -1 0.5], 0:2, 1, 1), sparse (0.5))
 
 ## Test input validation
 %!error spdiags ()
 %!error spdiags (1,2,3,4,5)
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -264,18 +264,18 @@ endfunction
 %! [u,s,v] = svd (full (A));
 %! s = diag (s);
 %! [~, idx] = sort (abs (s));
 %! s = s(idx);
 %! u = u(:, idx);
 %! v = v(:, idx);
 %! rand_state = rand ("state");
 %! rand ("state", 42);
-%! opts.v0 = rand (2*n,1); % Initialize eigs ARPACK starting vector
-%!                         % to guarantee reproducible results
+%! opts.v0 = rand (2*n,1);  # Initialize eigs ARPACK starting vector
+%!                          # to guarantee reproducible results
 %!
 %!testif HAVE_ARPACK
 %! [u2,s2,v2,flag] = svds (A,k);
 %! s2 = diag (s2);
 %! assert (flag, ! 1);
 %! tol = 10 * eps() * norm(s2, 1);
 %! assert (s2, s(end:-1:end-k+1), tol);
 %!
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -85,18 +85,18 @@ endfunction
 %!   assert (norm(diff([sum(diag(A)),sum(diag(flipud(A))),sum(A),sum(A')])),0);
 %! endfor
 
 ## Not a magic square but we must return something (bug #46672)
 ## While one day we may change the actual return of magic (2),
 ## this properties still must be true.
 %!test
 %! m = magic (2);
-%! assert (size (m), [2 2])
-%! assert (unique (m), [1; 2; 3; 4])
+%! assert (size (m), [2 2]);
+%! assert (unique (m), [1; 2; 3; 4]);
 
 %!assert (magic (2), [4 3; 1 2])
 %!assert (isempty (magic (-1)))
 %!assert (isempty (magic (0)))
 %!assert (magic (1), 1)
 %!assert (magic (1.5), 1)
 
 ## Test input validation
diff --git a/scripts/statistics/base/lscov.m b/scripts/statistics/base/lscov.m
--- a/scripts/statistics/base/lscov.m
+++ b/scripts/statistics/base/lscov.m
@@ -167,21 +167,21 @@ endfunction
 %! assert(msew, 3.4741e-004, -1E-4);
 %! V = .2*ones(length(x1)) + .8*diag(ones(size(x1)));
 %! [bg, sew_b, mseg] = lscov (X, y, V);
 %! assert(bg, [0.1203 0.3284 -0.1312]', 1E-4);
 %! assert(sew_b, [0.0672 0.2267 0.1488]', 1E-4);
 %! assert(mseg, 0.0019, 1E-4);
 %! y2 = [y 2*y];
 %! [b2, se_b2, mse2, S2] = lscov (X, y2);
-%! assert(b2, [b 2*b], 2*eps)
-%! assert(se_b2, [se_b 2*se_b], eps)
-%! assert(mse2, [mse 4*mse], eps)
-%! assert(S2(:, :, 1), S, eps)
-%! assert(S2(:, :, 2), 4*S, eps)
+%! assert(b2, [b 2*b], 2*eps);
+%! assert(se_b2, [se_b 2*se_b], eps);
+%! assert(mse2, [mse 4*mse], eps);
+%! assert(S2(:, :, 1), S, eps);
+%! assert(S2(:, :, 2), 4*S, eps);
 
 %!test
 %! ## Artificial example with positive semidefinite weight matrix
 %! x = (0:0.2:2)';
 %! y = round(100*sin(x) + 200*cos(x));
 %! X = [ones(size(x)) sin(x) cos(x)];
 %! V = eye(numel(x));
 %! V(end, end-1) = V(end-1, end) = 1;
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -117,21 +117,21 @@ endfunction
 %! a = rand (2,3,4,5);
 %! b = rand (3,4,6,5);
 %! x = sort (a, 4);
 %! y = sort (b, 3);
 %!assert (median (a, 4), x(:, :, :, 3))
 %!assert (median (b, 3), (y(:, :, 3, :) + y(:, :, 4, :))/2)
 
 ## Test non-floating point types
-%!assert (median ([true, false]), true);
-%!assert (median (uint8 ([1, 3])), uint8 (2));
-%!assert (median (int8 ([1, 3, 4])), int8 (3));
-%!assert (median (single ([1, 3, 4])), single (3));
-%!assert (median (single ([1, 3, NaN])), single (NaN));
+%!assert (median ([true, false]), true)
+%!assert (median (uint8 ([1, 3])), uint8 (2))
+%!assert (median (int8 ([1, 3, 4])), int8 (3))
+%!assert (median (single ([1, 3, 4])), single (3))
+%!assert (median (single ([1, 3, NaN])), single (NaN))
 
 ## Test input validation
 %!error median ()
 %!error median (1, 2, 3)
 %!error <X must be a numeric> median ({1:5})
 %!error <X cannot be an empty matrix> median ([])
 %!error <DIM must be an integer> median (1, ones (2,2))
 %!error <DIM must be an integer> median (1, 1.5)
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -136,17 +136,17 @@ function [beta, sigma, r] = ols (y, x)
 
 endfunction
 
 
 %!test
 %! x = [1:5]';
 %! y = 3*x + 2;
 %! x = [x, ones(5,1)];
-%! assert (ols (y,x), [3; 2], 50*eps)
+%! assert (ols (y,x), [3; 2], 50*eps);
 
 %!test
 %! x = [1, 2; 3, 4];
 %! y = [1; 2];
 %! [b, s, r] = ols (x, y);
 %! assert (b, [1.4, 2], 2*eps);
 %! assert (s, [0.2, 0; 0, 0], 2*eps);
 %! assert (r, [-0.4, 0; 0.2, 0], 2*eps);
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -151,17 +151,17 @@ endfunction
 %!assert (dec2base (2^51-1, 2), ...
 %!        "111111111111111111111111111111111111111111111111111")
 %!assert (dec2base (uint64 (2)^63-1, 16), "7FFFFFFFFFFFFFFF")
 %!assert (dec2base ([1, 2; 3, 4], 2, 3), ["001"; "011"; "010"; "100"])
 %!assert (dec2base ({1, 2; 3, 4}, 2, 3), ["001"; "011"; "010"; "100"])
 
 %!test
 %! a = 0:3;
-%! assert (dec2base (! a, 2, 1), ["1"; "0"; "0"; "0"])
+%! assert (dec2base (! a, 2, 1), ["1"; "0"; "0"; "0"]);
 
 ## Test input validation
 %!error dec2base ()
 %!error dec2base (1)
 %!error dec2base (1, 2, 3, 4)
 %!error dec2base ("A")
 %!error dec2base (2i)
 %!error dec2base (-1)
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -267,40 +267,40 @@ endfunction
 
 %!assert (strsplit ("foo\tbar", '\t', "delimitertype", "r"), {"foo", "bar"})
 %!assert (strsplit ("foo\tbar", '\t', "delimitertype", "s"), {"foo", "bar"})
 
 ## Test "match" for consecutive delmiters
 %!test
 %! [a, m] = strsplit ("a\t \nb", '\s', "delimitertype", "regularexpression",
 %!   "collapsedelimiters", false);
-%! assert (a, {"a", "", "", "b"})
-%! assert (m, {"\t", " ", "\n"})
+%! assert (a, {"a", "", "", "b"});
+%! assert (m, {"\t", " ", "\n"});
 %!test
 %! [a, m] = strsplit ("a\t \nb", '\s', false, "delimitertype", "regularexpression");
-%! assert (a, {"a", "", "", "b"})
-%! assert (m, {"\t", " ", "\n"})
+%! assert (a, {"a", "", "", "b"});
+%! assert (m, {"\t", " ", "\n"});
 %!test
 %! [a, m] = strsplit ("a\t \nb", '\s', "delimitertype", "regularexpression");
-%! assert (a, {"a", "b"})
-%! assert (m, {"\t \n"})
+%! assert (a, {"a", "b"});
+%! assert (m, {"\t \n"});
 %!test
 %! [a, m] = strsplit ("a\t \nb", {"\t", " ", "\n"}, "delimitertype", "simple");
-%! assert (a, {"a", "b"})
-%! assert (m, {"\t \n"})
+%! assert (a, {"a", "b"});
+%! assert (m, {"\t \n"});
 %!test
 %! [s, m] = strsplit ("hello \t world", true);
 %! assert (s, {"hello", "world"});
 %! assert (m, {" \t "});
 
 ## Compatibility
-%! assert (strsplit ("", "a"), {""})
-%! assert (strsplit ("a", "a"), {"", ""})
-%! assert (strsplit ("aa", "a"), {"", ""})
-%! assert (strsplit ("aaa", "a"), {"", ""})
+%! assert (strsplit ("", "a"), {""});
+%! assert (strsplit ("a", "a"), {"", ""});
+%! assert (strsplit ("aa", "a"), {"", ""});
+%! assert (strsplit ("aaa", "a"), {"", ""});
 
 ## Bug #44641
 %!assert (strsplit ("xxx<yyy", "<"), {"xxx", "yyy"})
 %!assert (strsplit ('xxx\yyy', '\'), {"xxx", "yyy"})
 
 ## Bug #47403
 %!assert (strsplit ('xxx+yyy', '+'), {"xxx", "yyy"})
 
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -134,17 +134,17 @@ function [tok, rem] = strtok (str, delim
     endif
   endif
 
 endfunction
 
 
 %!demo
 %! strtok ("this is the life")
-%! % split at the first space, returning "this"
+%! # split at the first space, returning "this"
 
 %!demo
 %! s = "14*27+31"
 %! while (1)
 %!   [t, s] = strtok (s, "+-*/");
 %!   printf ("<%s>", t);
 %!   if (isempty (s))
 %!     break;
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -879,17 +879,17 @@ endfunction
 %! error ("testif executed code despite not having feature");
 
 ## Test 'xtest' keyword
 %!xtest
 %! assert (1, 1);      # Test passes
 %!xtest
 %! assert (0, 1);      # Test fails
 
-## Test comment block. it can contain anything.
+## Test comment block.  It can contain anything.
 %!##
 %! it is the "#" as the block type that makes it a comment
 %! and it stays as a comment even through continuation lines
 %! which means that it works well with commenting out whole tests
 
 ## Test test() input validation
 %!error <NAME must be a string> test (1)
 %!error <second argument must be a string> test ("ls", 1)
diff --git a/test/bug-31371.tst b/test/bug-31371.tst
--- a/test/bug-31371.tst
+++ b/test/bug-31371.tst
@@ -31,11 +31,11 @@
 %!
 %! % Y combinator implements recursion
 %! Ycomb = @(f) C(@(g) f(@(x) C(g(g), x)), ...
 %!                @(g) f(@(x) C(g(g), x)));
 %!
 %! Factorial = Ycomb(@(f) @(n) C(C2(Iszero(n), ...
 %!                   @(d) One, @(d) Mult(n, f(Dec(n)))),0));
 %!
-%! assert (Render (Factorial (Two)), 2)
-%! assert (Render (Factorial (Three)), 6)
-%! assert (Render (Factorial (Four)), 24)
+%! assert (Render (Factorial (Two)), 2);
+%! assert (Render (Factorial (Three)), 6);
+%! assert (Render (Factorial (Four)), 24);
diff --git a/test/bug-36025/bug-36025.tst b/test/bug-36025/bug-36025.tst
--- a/test/bug-36025/bug-36025.tst
+++ b/test/bug-36025/bug-36025.tst
@@ -1,9 +1,9 @@
 %!test
-%! warning off Octave:function-name-clash
+%! warning ("off", "Octave:function-name-clash", "local");
 %! f = testclass (1, 2);
 %! assert (one (f), 1);
 %! assert (two (f), 2);
 %! rehash ();
 %! assert (one (f), 1);
 %! assert (two (f), 2);
 %! assert (two (f), 2);
diff --git a/test/bug-44940/bug-44940.tst b/test/bug-44940/bug-44940.tst
--- a/test/bug-44940/bug-44940.tst
+++ b/test/bug-44940/bug-44940.tst
@@ -1,11 +1,11 @@
 %!test
 %! a = class_bug44940 ();
 %! b = a;
 %! c = a ();
 %! a.child = 100;
-%! assert (a.child, b.child)
-%! assert (a.child, c.child)
+%! assert (a.child, b.child);
+%! assert (a.child, c.child);
 %! c.child = 500;
-%! assert (a.child, b.child)
-%! assert (a.child, c.child)
+%! assert (a.child, b.child);
+%! assert (a.child, c.child);
 
diff --git a/test/build-sparse-tests.sh b/test/build-sparse-tests.sh
--- a/test/build-sparse-tests.sh
+++ b/test/build-sparse-tests.sh
@@ -315,34 +315,34 @@ gen_elementop_tests() {
 
 %!assert (as./bf, sparse (af./bf), 100*eps)
 %!assert (bf.\as, sparse (bf.\af), 100*eps)
 
 %!test
 %! sv = as.^bf;
 %! fv = af.^bf;
 %! idx = find (af!=0);
-%! assert (sv(:)(idx), sparse (fv(:)(idx)), 100*eps)
+%! assert (sv(:)(idx), sparse (fv(:)(idx)), 100*eps);
 
 EOF
 }
 
 gen_sparsesparse_elementop_tests() {
     cat <<EOF
 %!assert (as==bs, sparse (af==bf))
 %!assert (as!=bs, sparse (af!=bf))
 %!assert (as+bs, sparse (af+bf))
 %!assert (as-bs, sparse (af-bf))
 %!assert (as.*bs, sparse (af.*bf))
 %!xtest assert (as./bs, sparse (af./bf), 100*eps)
 %!test
 %! sv = as.^bs;
 %! fv = af.^bf;
 %! idx = find (af!=0);
-%! assert(sv(:)(idx), sparse (fv(:)(idx)), 100*eps)
+%! assert(sv(:)(idx), sparse (fv(:)(idx)), 100*eps);
 
 EOF
 }
 
 # test matrix-matrix left and right division: uses as,af,bs,bf
 gen_divop_tests() {
     cat <<EOF
 %% Matrix-matrix operators (uses af,as,bs,bf)
@@ -623,17 +623,17 @@ EOF
 
 # operations which require square matrices.
 gen_square_tests() {
 # The \ and / operator tests on square matrices
     gen_square_divop_tests
 
     cat <<EOF
 %!testif HAVE_UMFPACK
-%! assert(det(bs+speye(size(bs))), det(bf+eye(size(bf))), 100*eps*abs(det(bf+eye(size(bf)))))
+%! assert(det(bs+speye(size(bs))), det(bf+eye(size(bf))), 100*eps*abs(det(bf+eye(size(bf)))));
 
 %!testif HAVE_UMFPACK
 %! [l,u] = lu (sparse ([1,1;1,1]));
 %! assert (l*u, [1,1;1,1], 10*eps);
 
 %!testif HAVE_UMFPACK
 %! [l,u] = lu (sparse ([1,1;1,1+i]));
 %! assert (l, sparse ([1,2,2],[1,1,2],1), 10*eps);
@@ -859,17 +859,17 @@ gen_select_tests() {
 %!assert (as((size (as,1):-1:1),:), sparse (af((size (af,1):-1:1),:)))
 %!assert (as(:,(size (as,2):-1:1)), sparse (af(:, (size (af,2):-1:1))))
 
 %% Indexing tests
 %!assert (full (as([1,1],:)), af([1,1],:))
 %!assert (full (as(:,[1,1])), af(:,[1,1]))
 %!test
 %! [i,j,v] = find (as);
-%! assert (as(i(1),j(1))([1,1]), sparse ([v(1), v(1)]))
+%! assert (as(i(1),j(1))([1,1]), sparse ([v(1), v(1)]));
 
 %% Assignment test
 %!test
 %! ts = as; ts(:,:) = ts(fliplr (1:size (as,1)),:);
 %! tf = af; tf(:,:) = tf(fliplr (1:size (af,1)),:);
 %! assert (ts, sparse (tf));
 %!test
 %! ts = as; ts(fliplr (1:size (as,1)),:) = ts;
@@ -1064,75 +1064,75 @@ cat <<EOF
 %!test
 %! pds = ds([2,1,3:11],:);
 %! pdf = full (pds);
 %!assert (pds\xf, pdf\xf, 100*eps)
 %!assert (pds\xs, sparse (pdf\xs), 100*eps)
 %!test
 %! us = alpha*[[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]];
 %!testif HAVE_UMFPACK
-%! assert (us*(us\xf), xf, 100*eps)
+%! assert (us*(us\xf), xf, 100*eps);
 %!testif HAVE_UMFPACK
-%! assert (us*(us\xs), xs, 100*eps)
+%! assert (us*(us\xs), xs, 100*eps);
 %!test
 %! pus = us(:,[2,1,3:12]);
 %!testif HAVE_UMFPACK
-%! assert (pus*(pus\xf), xf, 100*eps)
+%! assert (pus*(pus\xf), xf, 100*eps);
 %!testif HAVE_UMFPACK
-%! assert (pus*(pus\xs), xs, 100*eps)
+%! assert (pus*(pus\xs), xs, 100*eps);
 %!test
 %! us = alpha*[speye(11,9),[1;sparse(8,1);1;0]];
 %!testif HAVE_CXSPARSE
 %! [c,r] = qr (us, xf);
-%! assert (us\xf, r\c, 100*eps)
+%! assert (us\xf, r\c, 100*eps);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (us, xs);
 %! r = matrix_type (r, "Singular"); ## Force Matrix Type
-%! assert (us\xs, r\c, 100*eps)
+%! assert (us\xs, r\c, 100*eps);
 %!test
 %! pus = us(:,[1:8,10,9]);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (pus, xf);
 %! r = matrix_type (r, "Singular"); ## Force Matrix Type
-%! assert (pus\xf, r\c, 100*eps)
+%! assert (pus\xf, r\c, 100*eps);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (pus, xs);
 %! r = matrix_type (r, "Singular"); ## Force Matrix Type
-%! assert (pus\xs, r\c, 100*eps)
+%! assert (pus\xs, r\c, 100*eps);
 %!test
 %! ls = alpha*[speye(9,11);[1, sparse(1,8),1,0]];
 %! xf = beta * ones (10,2);
 %! xs = speye (10,10);
 %!assert (ls*(ls\xf), xf, 100*eps)
 %!assert (ls*(ls\xs), xs, 100*eps)
 %!test
 %! pls = ls([1:8,10,9],:);
 %!assert (pls*(pls\xf), xf, 100*eps)
 %!assert (pls*(pls\xs), xs, 100*eps)
 %!test
 %! ls = alpha*[speye(10,10), sparse(10,1);[1;1], sparse(2,9),[1;1]];
 %! xf = beta * ones (12,2);
 %! xs = speye (12,12);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (ls, xf);
-%! assert (ls\xf, r\c, 100*eps)
+%! assert (ls\xf, r\c, 100*eps);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (ls, xs);
 %! r = matrix_type (r, "Singular"); ## Force Matrix Type
-%! assert (ls\xs, r\c, 100*eps)
+%! assert (ls\xs, r\c, 100*eps);
 %!testif HAVE_CXSPARSE
 %! pls = ls(:,[1:8,10,9]);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (pls, xf);
 %! r = matrix_type (r, "Singular"); ## Force Matrix Type
-%! assert (pls\xf, r\c, 100*eps)
+%! assert (pls\xf, r\c, 100*eps);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (pls, xs);
 %! r = matrix_type (r, "Singular"); ## Force Matrix Type
-%! assert (pls\xs, r\c, 100*eps)
+%! assert (pls\xs, r\c, 100*eps);
 
 EOF
 }
 
 
 # =============================================================
 # Putting it all together: defining the combined tests
 
diff --git a/test/class-concat/class-concat.tst b/test/class-concat/class-concat.tst
--- a/test/class-concat/class-concat.tst
+++ b/test/class-concat/class-concat.tst
@@ -1,14 +1,14 @@
 %!test
 %! f = foo ();
 %! x = [f,f];
-%! assert (size (x), [1, 2])
-%! assert (class (x), "foo")
+%! assert (size (x), [1, 2]);
+%! assert (class (x), "foo");
 
 %!test
 %! f = foo ();
 %! x = [f,f];
 %! tmp = num2cell (x);
-%! assert (iscell (tmp))
-%! assert (size (tmp), [1, 2])
-%! assert (class (tmp{1}), "foo")
-%! assert (class (tmp{2}), "foo")
+%! assert (iscell (tmp));
+%! assert (size (tmp), [1, 2]);
+%! assert (class (tmp{1}), "foo");
+%! assert (class (tmp{2}), "foo");
diff --git a/test/classdef/classdef.tst b/test/classdef/classdef.tst
--- a/test/classdef/classdef.tst
+++ b/test/classdef/classdef.tst
@@ -44,30 +44,30 @@
 %!assert (isempty (q.term))
 %!assert (class (p), "foo_value_class")
 %!assert (p.term, 48)
 %!assert (p.rate, 4.0)
 %!assert (p.principle, 50e3)
 %!assert (p.amount, amt, eps ())
 %!assert (amount (p), amt, eps ())
 %!xtest
-%! assert (properties (p), {'rate'; 'term'; 'principle'})
+%! assert (properties (p), {'rate'; 'term'; 'principle'});
 %!xtest
-%! assert (methods (p), {'amount'; 'foo_value_class'})
+%! assert (methods (p), {'amount'; 'foo_value_class'});
 %!assert (isempty (foo_value_class().rate))
 %!error <property `rate' is not constant> foo_value_class.rate
 
 %%  Static method and Constant Property
 %!assert (foo_static_method_constant_property.radians_per_cycle, 2*pi)
 %!assert (foo_static_method_constant_property().radians_per_cycle, 2*pi)
 %!assert (foo_static_method_constant_property().pie, pi)
 %!error <property `frequency' is not constant> foo_static_method_constant_property.frequency
 %!error <method `cosine' is not static> foo_static_method_constant_property.cosine
 %!test
 %! obj = foo_static_method_constant_property;
 %! obj.frequency = 10;
-%! assert (obj.cosine (0.1), cos (2 * pi * 10 * 0.1), eps ())
-%! assert (obj.sine (0.1), sin (2 * pi * 10 * 0.1), eps ())
+%! assert (obj.cosine (0.1), cos (2 * pi * 10 * 0.1), eps ());
+%! assert (obj.sine (0.1), sin (2 * pi * 10 * 0.1), eps ());
 
 %!test
 %! obj = foo_method_changes_property_size (3);
 %! obj = obj.move_element_to_end (2);
-%! assert (obj.element, [1 3 2])
+%! assert (obj.element, [1 3 2]);
diff --git a/test/classes/classes.tst b/test/classes/classes.tst
--- a/test/classes/classes.tst
+++ b/test/classes/classes.tst
@@ -364,46 +364,46 @@
 ##############################################
 ## Testing overridden size+numel method     ##
 ## (builtin size method and similar methods ##
 ## use the size of the struct container)    ##
 ##############################################
 
 %!shared st
 %!test st = SizeTester ([1 1]);
-%! assert (isequal (size (st), [1 1]))
-%! assert (isequal (numel (st), 1))
+%! assert (isequal (size (st), [1 1]));
+%! assert (isequal (numel (st), 1));
 %!assert (isequal (ndims (st), 2))
 %!assert (isequal (rows (st), 1))
 %!assert (isequal (columns (st), 1))
 %!assert (isequal (st, st))
 %!assert (isscalar (st))
 %!assert (isvector (st))
 
 %!test st = SizeTester ([1 2]);
-%! assert (isequal (size (st), [1 2]))
-%! assert (isequal (numel (st), 2))
+%! assert (isequal (size (st), [1 2]));
+%! assert (isequal (numel (st), 2));
 %!assert (isequal (ndims (st), 2))
 %!assert (isequal (rows (st), 1))
 %!xtest assert (isequal (columns (st), 2))
 %!assert (isequal (st, st))                # bug #44334
 %!xtest assert (not (isscalar (st)))       # bug #44498
 %!assert (isvector (st))
 
 %!test st = SizeTester ([2 3]);
-%! assert (isequal (size (st), [2 3]))
-%! assert (isequal (numel (st), 6))
+%! assert (isequal (size (st), [2 3]));
+%! assert (isequal (numel (st), 6));
 %!assert (isequal (ndims (st), 2))
 %!xtest assert (isequal (rows (st), 2))
 %!xtest assert (isequal (columns (st), 3))
 %!assert (isequal (st, st))                # bug #44334
 %!xtest assert (not (isscalar (st)))       # bug #44498
 %!xtest assert (not (isvector (st)))       # bug #44498
 
 %!test st = SizeTester ([2 3 4]);
-%! assert (isequal (size (st), [2 3 4]))
-%! assert (isequal (numel (st), 24))
+%! assert (isequal (size (st), [2 3 4]));
+%! assert (isequal (numel (st), 24));
 %!xtest assert (isequal (ndims (st), 3))
 %!xtest assert (isequal (rows (st), 2))
 %!xtest assert (isequal (columns (st), 3))
 %!assert (isequal (st, st))                # bug #44334
 %!xtest assert (not (isscalar (st)))       # bug #44498
 %!xtest assert (not (isvector (st)))       # bug #44498
diff --git a/test/colormaps.tst b/test/colormaps.tst
--- a/test/colormaps.tst
+++ b/test/colormaps.tst
@@ -16,27 +16,27 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   all_colormaps = colormap ("list");
 %!
-%!   assert (numel (all_colormaps) > 0)
+%!   assert (numel (all_colormaps) > 0);
 %!
 %!   for i = 1:numel (all_colormaps)
 %!     f = str2func (all_colormaps{i});
 %!
-%!     assert (iscolormap (f (1)))
-%!     assert (iscolormap (f (12)))
-%!     assert (iscolormap (f (200)))
+%!     assert (iscolormap (f (1)));
+%!     assert (iscolormap (f (12)));
+%!     assert (iscolormap (f (200)));
 %!
 %!     ## bug #44070
-%!     assert (class (f (uint8 (12))), "double")
-%!     assert (iscolormap (f (uint8 (12))))
+%!     assert (class (f (uint8 (12))), "double");
+%!     assert (iscolormap (f (uint8 (12))));
 %!
-%!     assert (f (0), zeros (0, 3))
+%!     assert (f (0), zeros (0, 3));
 %!   endfor
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/test/command.tst b/test/command.tst
--- a/test/command.tst
+++ b/test/command.tst
@@ -7,148 +7,148 @@
 %!endfunction
 
 %!function gobble_command (varargin)
 %!endfunction
 
 ## 0, 1, 2, 3 simple arguments
 %!test
 %! command_test
-%! assert (cmd_out, '|')
+%! assert (cmd_out, '|');
 %!test
 %! command_test a
-%! assert (cmd_out, '|a|')
+%! assert (cmd_out, '|a|');
 %!test
 %! command_test aa     b
-%! assert (cmd_out, '|aa|b|')
+%! assert (cmd_out, '|aa|b|');
 %!test
 %! command_test aaa  bb    c
-%! assert (cmd_out, '|aaa|bb|c|')
+%! assert (cmd_out, '|aaa|bb|c|');
 
 ## continuation
 %!test
 %! command_test a...
 %!  bb ccc
-%! assert (cmd_out, '|a|bb|ccc|')
+%! assert (cmd_out, '|a|bb|ccc|');
 %!test
 %! command_test a ...
 %!  bb ccc
-%! assert (cmd_out, '|a|bb|ccc|')
+%! assert (cmd_out, '|a|bb|ccc|');
 %!test
 %! command_test aa(...
 %!  bb cc
-%! assert (cmd_out, '|aa(|bb|cc|')
+%! assert (cmd_out, '|aa(|bb|cc|');
 %!test
 %! command_test aa(   ...
 %!  bb cc
-%! assert (cmd_out, '|aa(   |bb|cc|')
+%! assert (cmd_out, '|aa(   |bb|cc|');
 
 ## comments
 %!test
 %! command_test aa bb cc%comment
-%! assert (cmd_out, '|aa|bb|cc|')
+%! assert (cmd_out, '|aa|bb|cc|');
 %!test
 %! command_test aa bb cc#comment
-%! assert (cmd_out, '|aa|bb|cc|')
+%! assert (cmd_out, '|aa|bb|cc|');
 %!test
 %! command_test aa bb cc   %comment
-%! assert (cmd_out, '|aa|bb|cc|')
+%! assert (cmd_out, '|aa|bb|cc|');
 %!test
 %! command_test aa bb cc   #comment
-%! assert (cmd_out, '|aa|bb|cc|')
+%! assert (cmd_out, '|aa|bb|cc|');
 %!test
 %! command_test aa bb cc(  %comment
-%! assert (cmd_out, '|aa|bb|cc(  |')
+%! assert (cmd_out, '|aa|bb|cc(  |');
 %!test
 %! command_test aa bb cc(  #comment
-%! assert (cmd_out, '|aa|bb|cc(  |')
+%! assert (cmd_out, '|aa|bb|cc(  |');
 
 ## semicolons and commas; multiple commands
 %!test
 %! command_test aa bb, gobble_command cc
-%! assert (cmd_out, '|aa|bb|')
+%! assert (cmd_out, '|aa|bb|');
 %!test
 %! command_test aa bb ; gobble_command cc
-%! assert (cmd_out, '|aa|bb|')
+%! assert (cmd_out, '|aa|bb|');
 %!test
 %! command_test aa bb ; command_test cc dd
-%! assert (cmd_out, '|cc|dd|')
+%! assert (cmd_out, '|cc|dd|');
 %!test
 %! command_test aa bb
 %!test
 %! command_test cc dd
-%! assert (cmd_out, '|cc|dd|')
+%! assert (cmd_out, '|cc|dd|');
 
 ## parenthesis matching
 %!test
 %! command_test aa(bb,cc,dd) ee(ff,gg) hh
-%! assert (cmd_out, '|aa(bb,cc,dd)|ee(ff,gg)|hh|')
+%! assert (cmd_out, '|aa(bb,cc,dd)|ee(ff,gg)|hh|');
 %!test
 %! command_test aa([bb,cc)]
-%! assert (cmd_out, '|aa([bb,cc)]|')
+%! assert (cmd_out, '|aa([bb,cc)]|');
 %!test
 %! command_test aa(,@!$@"bb"'cc'
-%! assert (cmd_out, '|aa(,@!$@"bb"''cc''|')
+%! assert (cmd_out, '|aa(,@!$@"bb"''cc''|');
 %!test
 %! command_test aa(bb,cc,dd)
-%! assert (cmd_out, '|aa(bb,cc,dd)|')
+%! assert (cmd_out, '|aa(bb,cc,dd)|');
 %!test
 %! command_test aa( bb,cc,dd )
-%! assert (cmd_out, '|aa( bb,cc,dd )|')
+%! assert (cmd_out, '|aa( bb,cc,dd )|');
 %!test
 %! command_test aa (bb,cc,dd)
-%! assert (cmd_out, '|aa|(bb,cc,dd)|')
+%! assert (cmd_out, '|aa|(bb,cc,dd)|');
 %!test
 %! command_test aa ( bb,cc,dd )
-%! assert (cmd_out, '|aa|( bb,cc,dd )|')
+%! assert (cmd_out, '|aa|( bb,cc,dd )|');
 %!test
 %! command_test aa(bb, cc, dd)
-%! assert (cmd_out, '|aa(bb, cc, dd)|')
+%! assert (cmd_out, '|aa(bb, cc, dd)|');
 %!test
 %! command_test aa( bb, cc, dd )
-%! assert (cmd_out, '|aa( bb, cc, dd )|')
+%! assert (cmd_out, '|aa( bb, cc, dd )|');
 %!test
 %! command_test aa (bb, cc, dd)
-%! assert (cmd_out, '|aa|(bb, cc, dd)|')
+%! assert (cmd_out, '|aa|(bb, cc, dd)|');
 %!test
 %! command_test aa ( bb, cc, dd )
-%! assert (cmd_out, '|aa|( bb, cc, dd )|')
+%! assert (cmd_out, '|aa|( bb, cc, dd )|');
 
 ## single and double quotes
 %!test
 %! command_test "aa" 'bb' cc
-%! assert (cmd_out, '|aa|bb|cc|')
+%! assert (cmd_out, '|aa|bb|cc|');
 %!test
 %! command_test "aa"'bb'cc
-%! assert (cmd_out, '|aabbcc|')
+%! assert (cmd_out, '|aabbcc|');
 %!test
 %! command_test aa'bb'"cc"
-%! assert (cmd_out, '|aabbcc|')
+%! assert (cmd_out, '|aabbcc|');
 %!test
 %! command_test "aa"bb'cc'
-%! assert (cmd_out, '|aabbcc|')
+%! assert (cmd_out, '|aabbcc|');
 
 ## CVX-inspired
 %!test
 %! command_test Z(n,n) hermitian toeplitz
-%! assert (cmd_out, '|Z(n,n)|hermitian|toeplitz|')
+%! assert (cmd_out, '|Z(n,n)|hermitian|toeplitz|');
 %!test
 %! command_test X( n, n ) symmetric
-%! assert (cmd_out, '|X( n, n )|symmetric|')
+%! assert (cmd_out, '|X( n, n )|symmetric|');
 %!test
 %! command_test xw( nm-1, nv );
-%! assert (cmd_out, '|xw( nm-1, nv )|')
+%! assert (cmd_out, '|xw( nm-1, nv )|');
 %!test
 %! command_test x( sx ) y( sx ) z( sx )
-%! assert (cmd_out, '|x( sx )|y( sx )|z( sx )|')
+%! assert (cmd_out, '|x( sx )|y( sx )|z( sx )|');
 %!test
 %! command_test coeffs(deg+1) complex;
-%! assert (cmd_out, '|coeffs(deg+1)|complex|')
+%! assert (cmd_out, '|coeffs(deg+1)|complex|');
 %!test
 %! command_test w( 1, npairs * nv ) v( 1, npairs * nv )
-%! assert (cmd_out, '|w( 1, npairs * nv )|v( 1, npairs * nv )|')
+%! assert (cmd_out, '|w( 1, npairs * nv )|v( 1, npairs * nv )|');
 %!test
 %! command_test w(m,1)   % edge weights
-%! assert (cmd_out, '|w(m,1)|')
+%! assert (cmd_out, '|w(m,1)|');
 %!test
 %! command_test x2( size( x ) )
-%! assert (cmd_out, '|x2( size( x ) )|')
+%! assert (cmd_out, '|x2( size( x ) )|');
 
diff --git a/test/ctor-vs-method/ctor-vs-method.tst b/test/ctor-vs-method/ctor-vs-method.tst
--- a/test/ctor-vs-method/ctor-vs-method.tst
+++ b/test/ctor-vs-method/ctor-vs-method.tst
@@ -30,27 +30,27 @@
 
 %!test
 %! ctrace = {'begin parent/method';
 %!           'begin derived/parent';
 %!           'begin parent/parent';
 %!           'end parent/parent';
 %!           'end derived/parent';
 %!           'end parent/method'};
-%! __trace__ (); %% clear call trace info
+%! __trace__ ();  # clear call trace info
 %! method (d);
 %! assert (__trace__ (), ctrace);
 
 %!test
 %! ctrace = {'begin other/parent';
 %!           'end other/parent'};
-%! __trace__ (); %% clear call trace info
+%! __trace__ ();  # clear call trace info
 %! parent (o);
 %! assert (__trace__ (), ctrace);
 
 %!test
 %! ctrace = {'begin derived/parent';
 %!           'begin parent/parent';
 %!           'end parent/parent';
 %!           'end derived/parent'};
-%! __trace__ (); %% clear call trace info
+%! __trace__ ();  # clear call trace info
 %! parent (d);
 %! assert (__trace__ (), ctrace);
diff --git a/test/error.tst b/test/error.tst
--- a/test/error.tst
+++ b/test/error.tst
@@ -79,18 +79,18 @@
 ## Bug 36393
 
 %!test
 %! w0 = warning;
 %! warnoffId = "MATLAB:singularMatrix";
 %! warnstat = warning ("query", warnoffId);
 %! warnoff = warnstat;
 %! warnoff.state = "off";
-%! warning (warnoff); %update warning status
-%! warning (warnstat); %reset warning status
+%! warning (warnoff);  # update warning status
+%! warning (warnstat); # reset warning status
 %! w = warning;
 %! assert (w, w0);
 
 ## Test usage() function
 
 %!function g ()
 %!  usage ("foo");
 %!endfunction
diff --git a/test/fcn-handle-derived-resolution/fcn-handle-derived-resolution.tst b/test/fcn-handle-derived-resolution/fcn-handle-derived-resolution.tst
--- a/test/fcn-handle-derived-resolution/fcn-handle-derived-resolution.tst
+++ b/test/fcn-handle-derived-resolution/fcn-handle-derived-resolution.tst
@@ -30,38 +30,38 @@
 %% Until the bug is fixed, it suffices to make the class names unique so that
 %% there is no re-use.  Using the prefix fhdr (fcn-handle-derived-resolution)
 %% for this directory.
 %%!shared
 %%! #clear -classes
 
 %!test
 %! p = fhdr_parent (7);
-%! assert (numel (p), 7)
+%! assert (numel (p), 7);
 
 %!test
 %! d = fhdr_derived (13);
-%! assert (numel (d), 13)
+%! assert (numel (d), 13);
 
 %!test
 %! p = fhdr_parent (11);
 %! f = @numel;
-%! assert (f (p), 11)
+%! assert (f (p), 11);
 
 %!test
 %! d = fhdr_parent (21);
 %! f = @numel;
-%! assert (f (d), 21)
+%! assert (f (d), 21);
 
 %!test
 %! o(1) = fhdr_other (13);
 %! o(2) = fhdr_other (42);
-%! assert (getsize_loop (o), [13, 42])
+%! assert (getsize_loop (o), [13, 42]);
 
 %!test
 %! o(1) = fhdr_other (13);
 %! o(2) = fhdr_other (42);
-%! assert (getsize_cellfun (o), [13, 42])
+%! assert (getsize_cellfun (o), [13, 42]);
 
 %!test
 %! o(1) = fhdr_other (13);
 %! o(2) = fhdr_other (42);
-%! assert (getsize_arrayfun (o), [13, 42])
+%! assert (getsize_arrayfun (o), [13, 42]);
diff --git a/test/for.tst b/test/for.tst
--- a/test/for.tst
+++ b/test/for.tst
@@ -86,24 +86,24 @@
 %! endfor
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("34"));
 
 %!test
 %! a = [1,3;2,4];
 %! j = 0;
 %! for i = cat (3, a, 4 + a)
-%!   assert (i, [1;2] + 2*j++)
+%!   assert (i, [1;2] + 2*j++);
 %! endfor
 
 %!test
 %! a = {1,3;2,4};
 %! j = 0;
 %! for i = cat (3, a, cellfun (@(x) 4 + x, a, "UniformOutput", 0))
-%!   assert (i, {1 + 2*j; 2 + 2*j++})
+%!   assert (i, {1 + 2*j; 2 + 2*j++});
 %! endfor
 
 ## test parsing of single-quoted character string appearing at the
 ## beginning of a for loop
 %!test
 %! for i = 1:5
 %!   'foo';
 %! endfor
diff --git a/test/index.tst b/test/index.tst
--- a/test/index.tst
+++ b/test/index.tst
@@ -89,29 +89,29 @@
 %!assert (a(:,1), [1;3])
 %!assert (a(1,1), 1)
 %!assert (a(1:2,1), [1;3])
 %!assert (a(:,:,1), [1,2;3,4])
 
 %!test
 %! c(:,:,1) = [1,2;3,4];
 %! c(:,:,2) = [1,2;3,4];
-%! assert (a(:,:,[1,1]), c)
+%! assert (a(:,:,[1,1]), c);
 
 %!test
 %! c(:,:,1,1) = [1,2;3,4];
 %! c(:,:,1,2) = [1,2;3,4];
-%! assert (a(:,:,1,[1,1]), c)
+%! assert (a(:,:,1,[1,1]), c);
 
 %!test
 %! c(:,:,1,1) = [1,2;3,4];
 %! c(:,:,2,1) = [1,2;3,4];
 %! c(:,:,1,2) = [1,2;3,4];
 %! c(:,:,2,2) = [1,2;3,4];
-%! assert (a(:,:,[1,1],[1,1]), c)
+%! assert (a(:,:,[1,1],[1,1]), c);
 
 %!assert (a(1,[]), zeros (1,0))
 %!assert (a(1,[],[1,1]), zeros (1,0,2))
 %!assert (a(1,1,[]), zeros (1,1,0))
 
 %!test
 %! c (1:10,1) = 1:10;
 %! assert (c, [1:10]');
diff --git a/test/io.tst b/test/io.tst
--- a/test/io.tst
+++ b/test/io.tst
@@ -249,17 +249,17 @@
 %!         STR.struct_fld.x == 0 && ...
 %!         STR.struct_fld.y == 1);
 %!
 %! delete (struct_dat);
 
 %!test
 %! matrix1 = rand (100, 2);
 %! matrix_ascii = fullfile (P_tmpdir, "matrix.ascii");
-%! save ("-ascii", matrix_ascii, "matrix1")
+%! save ("-ascii", matrix_ascii, "matrix1");
 %! matrix2 = load (matrix_ascii);
 %! assert (matrix1, matrix2, 1e-9);
 %!
 %! delete (matrix_ascii);
 
 %!error <unable to find file> load ("")
 
 %% FIXME: This test is disabled as it writes to stdout and there is no easy
@@ -306,18 +306,18 @@
 %! assert (pos, 6);
 
 %!test
 %! [a, b, c] = sscanf ("1.2 3 foo", "%f%d%s", "C");
 %! [v1, c1, m1] = sscanf ("1 2 3 4 5 6", "%d");
 %! [v2, c2, m2] = sscanf ("1 2 bar 3 4 5 6", "%d");
 %!
 %! assert ((a == 1.2 && b == 3 && c == "foo"
-%! && v1 == [1; 2; 3; 4; 5; 6] && c1 == 6 && ischar (m1)
-%! && v2 == [1; 2] && c2 == 2 && ischar (m2)));
+%!          && v1 == [1; 2; 3; 4; 5; 6] && c1 == 6 && ischar (m1)
+%!          && v2 == [1; 2] && c2 == 2 && ischar (m2)));
 
 %!error <Invalid call to sscanf> sscanf ()
 %!error sscanf (1, 2)
 %!error <Invalid call to sscanf> sscanf ("foo", "bar", "C", 1)
 
 %!test
 %! [x, n] = sscanf ("   0.024000 0.200 0.200 2.000         1987           5           0  0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 2 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 4 5 1 2    2 5 5 8 2 8 12 6 15 18 28 26 47 88 118 162 192 130 88 56 27 23 14 9 6 3 4 1 0    2 3 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0   0.026000 0.250 0.250 2.100         3115           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0    0 0 0 0 1 0 1 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 1 0 1    1 1 0 1 0 1 3 2 0 5 15 25 44 66 145 179 193 172 104 57 17 11 12 2 1 0 1 1 0 1    0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.028000 0.300 0.300 2.200         4929           3           0  1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0    1 0 1 0 1 2 2 3 2 3 14 21 49 80 148 184 218 159 124 63 37 13 12 3 1 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.030000 0.350 0.350 2.300         7051           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1    0 0 1 0 0 0 2 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1    0 0 0 2 0 0 0 1 5 6 14 28 51 88 154 177 208 169 124 65 39 15 5 3 3 2 1 0 1 0 1   0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.032000 0.400 0.400 2.400         9113           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0    1 0 0 0 0 2 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 2 0    1 0 0 1 1 0 2 3 5 3 17 30 60 117 156 189 209 129 102 64 56 16 11 4 2 2 0 0 0 0   1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0   0.034000 0.450 0.450 2.500        11811           6           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0    0 0 2 1 0 0 1 0 5 5 15 21 57 99 149 190 195 159 130 69 41 16 10 2 5 3 0 1 0 0    0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.036000 0.500 0.500 2.600        14985           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 1 0 0 0 0    0 0 0 0 1 0 0 2 2 6 10 34 60 95 126 177 194 155 99 71 44 17 6 7 2 0 0 0 3 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.038000 0.550 0.550 2.700        18391           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0    0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 2    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 2 0 0 1 1 0 1    2 1 0 0 0 1 0 1 3 6 19 27 52 95 161 154 169 134 94 64 37 19 9 6 0 2 1 0 0 0 0    1 2 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 2 2 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0    0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.040000 0.600 0.600 2.800        22933           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 1    0 0 0 0 0 2 0 3 4 7 18 27 47 82 134 163 133 138 101 58 34 26 10 5 2 1 2 1 1 0    2 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.042000 0.650 0.650 2.900        27719           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 1 1 2 8 16 37 51 87 128 153 146 123 105 62 35 24 8 3 5 0 1 2 1 0 0   0 1 1 1 0 0 0 1 0 1 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0    0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.044000 0.700 0.700 3.000        32922           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 2 0    0 0 0 0 0 0 0 2 1 0 0 0 0 1 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1    1 1 0 0 0 1 4 3 5 5 15 35 54 88 132 168 149 105 92 62 30 16 17 4 5 1 0 0 1 0 1   1 0 1 1 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.046000 0.750 0.750 3.100        38973           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0    0 0 0 1 0 0 0 4 3 5 20 37 56 94 110 135 149 124 84 58 36 17 14 7 1 0 2 0 1 0 0   1 1 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 1    1 0 1 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0    1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.048000 0.800 0.800 3.200        45376           5           0  1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 0 2 1 1 2 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 0    0 0 0 1 0 0 0 0 1 3 18 34 55 82 104 135 116 99 79 60 51 29 10 4 3 1 1 1 0 0 1    0 0 0 1 0 0 3 1 2 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 1    0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.050000 0.850 0.850 3.300        52060           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1    0 0 0 0 0 2 2 1 3 12 24 40 39 107 121 127 138 100 86 68 44 23 15 7 3 1 1 0 1 1   0 0 2 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0 0 2 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.052000 0.900 0.900 3.400        59454           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 1    0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0    0 0 0 0 0 1 0 0 0 0 0 2 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 1 0 0 2 0 2 1 0 0 0 1 0    0 1 0 0 0 0 0 3 3 6 21 32 68 90 132 111 122 107 73 57 47 24 11 7 4 2 2 1 0 0 0   0 0 0 0 0 1 0 0 1 0 0 2 0 1 1 0 0 1 0 0 0 0 0 3 0 1 0 0 0 0 1 1 0 0 0 1 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0   0.054000 0.950 0.950 3.500        67013           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0 0 1 0 0 1 1 0 0 0    1 0 1 0 1 2 4 3 7 9 28 31 71 94 115 96 108 78 82 60 38 17 12 11 4 3 1 1 0 2 1    0 0 0 2 1 3 0 0 0 0 3 0 0 1 0 0 0 0 0 0 0 2 0 0 0 1 0 2 0 1 0 2 0 1 0 0 1 0 0    0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0   0.056000 1.000 1.000 3.600        75475           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 2 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 3 0 0 1    1 2 0 1 4 0 1 8 6 7 17 41 56 71 109 113 84 103 72 54 35 22 6 9 1 7 5 4 0 0 1 0   0 0 0 0 0 1 0 0 2 1 0 0 0 0 2 0 0 1 0 0 1 0 0 0 0 0 0 1 0 2 0 1 0 0 0 0 1 0 1    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0 0 1 0 0 0 0 0 0 1 1 0 0 2 0 0 0 0    0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.058000 1.050 1.050 3.700        83558           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 2 0 0    2 0 0 1 0 3 2 3 6 15 27 41 77 73 94 94 92 76 61 56 42 23 13 11 6 2 1 2 0 1 2 0   0 1 0 1 0 0 1 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0 0 0 0 2 0 0 0 0 0 1 2 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0   0.060000 1.100 1.100 3.800        93087           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1    0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 2 2 0 0 0 1 0 1 1 0 0 0 1 1 0 4    0 0 1 2 0 3 1 3 5 13 33 31 65 75 77 96 97 80 59 45 36 32 18 2 5 0 1 0 0 1 0 0    3 0 0 0 0 1 0 0 0 0 0 1 0 0 1 2 0 0 0 0 1 0 0 0 0 1 0 1 1 1 0 0 2 0 0 2 0 1 0    0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0    0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.062000 1.150 1.150 3.900       102829           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 1 0 0 0 0 0 1 1 1 0 1 0 1 1 0 1 1 0 2 0 2    1 2 0 0 2 4 3 5 11 9 23 43 53 68 65 87 83 77 59 49 34 18 15 9 4 2 3 2 0 0 0 4    0 1 1 0 0 2 0 0 1 0 0 0 0 1 1 1 0 1 0 0 0 0 2 0 0 0 0 1 0 0 1 1 1 1 0 0 0 1 0    0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0   0.064000 1.200 1.200 4.000       113442           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0    0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 1 1 1 0 1 1 1 1 1 0 0 0 1    2 0 0 0 2 0 4 5 11 13 29 39 61 68 61 75 76 74 73 44 37 29 19 6 3 3 2 0 1 2 1 0   0 0 0 1 1 1 0 1 1 0 0 0 1 0 1 1 0 1 2 0 2 1 1 1 0 0 0 0 1 0 0 1 1 1 1 1 0 0 0    0 0 0 0 1 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0    0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0   0.066000 1.250 1.250 4.100       126668           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1    0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 1 1 2 3 0 2 1 2 0 1 0 3 0 0 0 1 0 1 1 3    0 0 1 3 0 2 4 3 12 12 30 48 56 66 77 78 71 82 52 31 32 19 20 16 8 2 1 3 0 0 2    1 0 1 0 1 0 0 0 1 3 1 0 1 0 1 1 1 0 0 0 0 0 2 0 2 0 0 0 0 0 1 0 0 0 0 1 1 0 0    0 0 0 1 0 0 0 0 0 2 0 3 1 0 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.068000 1.300 1.300 4.200       138042           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 2 0 0 1 0 1 0 0 0 0 0    0 0 0 1 0 0 2 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0    0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0 3 0 0 1 0 0 1 2 0 0 0 3 0 1 0 0 3 0    1 0 1 1 3 1 4 7 11 14 27 36 44 68 72 70 71 45 44 46 29 13 16 11 5 2 0 3 0 0 0    0 1 1 2 0 0 1 1 2 1 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 2 0 0 1 1 0 1 1 1 0    0 1 0 0 1 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    0 0 0 1 0 0 1 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.070000 1.350 1.350 4.300       152335           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 0    1 0 0 0 2 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 2 0 0 0 0 1 1 1 0 1 1 0 1 1 1 1 0 2 0    0 0 0 0 2 0 1 7 14 19 34 35 54 72 68 72 68 58 48 36 37 27 25 17 1 4 1 0 0 0 1    2 2 0 0 1 1 1 2 1 0 3 1 0 1 0 2 1 0 0 0 1 1 1 2 0 0 0 0 1 1 0 1 1 0 2 1 1 1 1    0 0 0 1 1 0 0 2 0 0 1 0 0 0 1 1 0 2 1 1 0 0 0 0 2 0 0 0 0 0 0 0 1 1 0 0 0 0 1    0 0 1 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0   0.072000 1.400 1.400 4.400       166280           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0    2 0 0 0 0 0 0 0 1 0 1 0 1 1 1 0 0 1 0 1 0 0 3 4 2 2 0 0 0 0 0 1 1 3 1 0 3 2 2    1 2 2 0 2 2 1 8 14 26 24 29 47 47 68 65 63 55 42 41 26 29 17 8 4 4 1 0 1 2 0 0   0 1 1 2 0 1 2 1 0 0 1 1 1 0 0 1 0 0 0 1 0 0 1 2 1 2 1 0 0 0 0 0 1 1 2 0 2 2 0    0 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.074000 1.450 1.450 4.500       179484           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0    1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 0 1 0 0 1 0 1 2 0 0 0 0 0 0 0 0 0 1 0    0 0 1 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 1 1 1 2 0 0 1 1 2 1 0    1 1 2 2 0 1 5 6 10 20 43 50 57 62 53 62 66 45 42 33 27 26 23 14 3 0 2 0 1 0 0    1 1 0 0 2 1 1 0 0 3 0 1 1 1 0 1 1 0 1 0 1 2 1 0 0 1 2 0 2 0 0 0 0 1 1 3 1 0 0    2 1 1 1 0 0 0 0 0 0 1 2 0 1 0 0 0 0 0 1 1 0 2 0 0 0 0 0 1 0 2 1 0 0 0 0 0 0 1    0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0   0.076000 1.500 1.500 4.600       197657           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 1 0 0 0 0 0 0 1 0 1 0    0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 2 0 0 0 1 0 0 0 0    0 0 1 0 1 0 0 0 0 0 0 0 0 1 2 0 0 0 2 1 1 0 1 1 0 1 1 3 2 1 1 2 1 0 1 0 0 0 0    0 1 1 1 0 5 3 7 12 24 38 32 41 48 54 66 71 49 46 31 38 25 15 8 6 6 5 0 1 3 0 1   1 1 1 1 0 1 2 0 1 0 0 0 1 0 2 1 2 0 0 0 0 1 3 1 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0    4 1 1 1 0 3 0 0 0 2 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0   0.078000 1.550 1.550 4.700       212054           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0    0 1 0 1 1 0 0 1 0 0 1 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1    0 0 2 0 0 0 1 0 0 1 0 1 1 0 1 3 1 0 0 1 2 0 0 0 1 0 0 0 0 0 2 1 2 1 1 1 0 0 1    5 1 1 2 3 5 7 9 11 22 31 37 48 50 52 54 57 37 38 38 33 24 11 19 11 3 1 2 0 3 3   2 1 0 1 3 0 1 1 1 1 1 2 0 0 0 1 1 2 0 1 1 3 0 1 1 0 0 1 0 2 0 1 0 0 1 3 0 2 0    1 0 1 2 0 1 1 1 1 1 0 3 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0   0.080000 1.600 1.600 4.800       231971           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 1 1 0 1 0 0 0 0 1 0 1 1    0 0 0 0 2 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 2 1 0 1 1 1 0 1 0 0 1 0 1 3 0 0 0 1 0    0 0 1 1 1 0 0 4 1 1 0 2 0 1 1 1 2 0 0 0 1 0 1 2 1 2 3 2 0 1 0 4 3 1 1 1 1 3 1    0 0 0 2 1 0 2 7 17 13 29 47 58 59 52 38 51 51 38 34 35 21 14 13 4 1 0 1 1 1 0    2 2 4 1 0 1 1 4 0 0 0 2 0 2 2 2 0 0 1 3 2 1 1 2 2 2 2 1 0 3 0 2 1 2 1 2 2 0 0    1 1 0 2 0 2 2 0 1 0 2 2 3 1 2 3 1 1 0 1 0 2 0 1 2 1 2 0 2 1 0 0 3 0 0 1 1 1 1    0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0   0.082000 1.650 1.650 4.900       252503           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 2 0 0    0 0 0 0 0 1 0 0 0 1 1 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0    0 0 0 0 2 0 0 1 0 1 2 2 2 1 0 2 0 1 0 1 1 2 2 0 3 0 0 4 1 0 0 3 0 0 1 2 0 1 1    1 3 0 1 0 2 9 11 25 27 34 53 41 49 43 47 36 31 38 22 30 22 18 9 5 9 2 2 1 2 2    3 1 4 1 1 0 0 1 2 0 2 1 0 0 1 3 2 2 1 0 0 0 1 2 1 0 0 0 2 1 1 0 2 0 0 1 0 0 2    1 3 1 1 1 0 2 1 1 0 2 1 0 1 3 0 0 0 0 2 0 0 1 0 0 0 0 0 1 2 1 1 1 0 2 1 0 0 0    2 0 1 0 0 0 0 1 0 0 0 0 1 0 0 2 0 1 0 1 0 0 0 0 0 0 0 0 0 0   0.084000 1.700 1.700 5.000       267889           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 1 0 1    0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0    0 1 0 1 1 0 3 0 1 1 1 0 1 2 1 0 2 0 2 4 0 1 0 0 0 1 1 0 1 3 2 0 2 0 4 0 0 2 0    1 4 2 4 3 3 6 10 14 28 37 54 36 40 52 40 50 46 40 32 26 29 12 18 5 2 0 2 4 1 2   1 0 2 1 2 2 1 0 1 0 2 1 2 4 1 1 5 1 0 2 0 1 2 3 2 2 1 2 1 0 2 1 2 1 1 4 1 2 1    4 0 2 2 0 0 3 1 0 2 0 0 1 1 1 0 0 2 1 0 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0   0.086000 1.750 1.750 5.100       290294           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 2 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 0    0 0 0 0 1 0 0 0 0 1 0 0 0 1 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 0 2    1 0 1 0 1 0 0 2 2 0 1 2 2 0 2 0 2 0 1 0 0 1 1 1 3 1 1 1 1 3 4 1 1 2 2 2 1 0 3    0 0 0 2 4 5 6 16 18 20 31 40 54 55 46 41 52 35 27 21 28 27 20 15 8 6 7 1 0 0 3   0 0 2 2 0 3 1 3 1 1 2 0 0 1 2 1 3 2 0 1 2 1 3 1 1 1 1 1 2 0 2 1 0 1 1 1 3 1 1    2 0 1 0 1 0 2 1 1 0 0 1 2 0 3 1 1 0 0 0 1 3 1 1 1 0 0 1 2 1 0 0 1 1 1 0 0 1 0    0 0 0 0 0 2 0 1 0 0 0 2 1 0 2 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0   0.088000 1.800 1.800 5.200       312476           6           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 0 1 0 1 1 0 0 0 0    0 0 2 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 2 0 0 0 1 0 1 0 0 0 0 0 0 2    1 0 0 1 0 0 1 1 1 1 4 2 0 1 0 0 3 0 0 0 0 0 1 1 4 0 0 0 0 1 1 2 1 0 3 0 0 2 2    4 0 3 1 6 9 10 13 21 24 32 43 33 41 43 49 50 32 26 31 27 12 16 17 3 3 3 5 0 3    0 2 1 3 3 2 1 2 3 1 2 1 1 1 2 0 1 1 0 2 0 3 0 0 2 0 0 0 0 1 0 1 1 3 3 0 1 1 1    1 1 1 2 2 2 0 3 1 0 2 2 2 0 0 0 0 3 1 2 5 1 1 2 0 0 3 3 0 2 2 0 0 0 0 1 2 0 0    1 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0   0.090000 1.850 1.850 5.300       337348           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 2 0 1 0 1 0 0 0 1 0 0 0    0 0 0 1 0 0 0 0 2 0 1 1 0 0 0 1 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0    2 0 0 0 1 3 2 0 0 2 2 3 3 2 2 2 0 0 1 1 3 1 3 0 0 0 0 0 0 1 2 1 2 1 2 2 2 0 1    1 0 4 2 2 7 6 15 22 21 39 37 50 31 51 30 33 34 34 26 21 14 13 10 9 4 3 3 4 2 2   0 1 2 3 3 0 1 3 2 5 3 2 2 4 0 2 3 0 4 2 1 2 2 2 4 2 1 3 1 3 2 1 3 1 2 4 1 1 1    1 2 4 1 3 3 3 1 0 4 1 0 1 1 1 1 2 3 0 3 0 0 4 1 1 1 0 2 2 2 1 2 2 0 1 1 0 0 0    2 0 1 0 1 0 0 1 0 0 0 1 3 0 0 1 0 0 1 1 1 0 0 1 0 0 0 0 0 0   0.092000 1.900 1.900 5.400       357303           3           0  0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 1 1 0 1 0 0 1 0    0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 3 1 0 1 0 0 0 0 1 0 0 1 0 0 1 1 2 2 0 0 2    2 1 1 1 1 1 1 0 1 0 0 1 1 1 3 1 1 1 1 1 0 1 4 0 1 1 1 3 0 1 1 2 2 2 0 2 3 2 2    2 2 1 2 1 3 8 22 14 32 36 46 39 42 39 29 36 38 26 24 26 18 16 19 10 9 3 6 5 0    3 2 1 1 1 2 0 2 1 1 0 1 1 3 1 0 2 4 2 2 1 4 1 2 2 1 1 0 1 2 0 2 2 2 4 2 1 1 0    2 1 3 1 2 3 4 2 3 2 3 0 1 2 1 0 0 0 4 1 1 1 2 1 3 1 0 5 1 0 0 0 0 0 0 1 0 2 0    1 2 1 0 1 0 0 0 0 0 1 1 0 1 0 1 4 0 0 0 1 0 1 0 0 0 0 0 0 0 0   0.094000 1.950 1.950 5.500       383138           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 0 0 0 0 0 1 0    0 0 1 0 0 2 1 0 1 1 1 0 0 0 0 0 0 1 1 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 2 1 1 1 1    2 1 0 2 0 1 0 3 2 1 3 0 1 3 1 1 0 5 0 1 0 1 2 0 0 1 1 2 0 0 6 1 0 3 2 2 3 4 5    0 4 2 1 5 4 11 15 22 27 28 57 38 38 40 38 39 38 27 26 30 18 14 10 10 4 4 4 3 3   2 2 2 2 1 1 1 1 2 2 3 4 1 2 3 1 2 1 2 2 2 1 3 2 1 5 0 1 1 1 3 2 2 2 1 3 1 1 0    3 2 2 0 0 2 2 2 0 0 0 2 0 1 3 1 2 3 2 1 1 0 1 1 1 0 3 2 2 1 0 0 1 3 1 1 0 1 0    0 0 0 0 1 0 0 0 0 1 0 0 3 1 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 0   0.096000 2.000 2.000 5.600       409868           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 1 0 1 0 1 0 2 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 2 0 1 0 0 2 0 2 0 0 0 0 1 0 0 2 1    2 2 2 1 2 1 1 1 1 1 2 0 0 1 1 0 1 0 2 1 2 0 2 0 3 1 2 1 3 1 5 0 2 2 1 2 4 1 2    0 3 1 4 7 5 9 13 22 19 31 27 28 41 34 39 37 22 23 21 22 17 23 15 8 9 3 8 0 3 1   2 2 2 3 1 0 4 2 4 2 2 2 2 4 2 1 1 0 2 0 3 0 3 2 2 1 2 2 1 4 1 2 2 1 1 5 2 1 2    1 2 2 1 0 2 4 3 2 1 2 2 3 2 3 1 2 1 1 1 1 2 1 1 2 2 1 2 3 2 1 1 0 2 2 4 0 1 1    1 1 1 0 0 1 1 3 0 0 0 0 0 1 0 0 2 0 1 2 0 1 1 1 0 1 0 1 0 0   0.098000 2.050 2.050 5.700       439102           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 1 1 0 0 1 0 1 0 1 0 0 0 0 1 1 0 1 0 0 1 1 0    0 1 1 0 0 1 1 0 1 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 2 0 1 1 0 0 0 0 1 1 1 0 4 0 0    0 2 1 1 0 3 4 0 1 2 2 1 0 3 0 3 2 0 0 2 0 1 0 0 1 0 1 3 1 3 5 0 2 2 3 5 2 2 2    0 3 2 3 6 5 16 21 19 23 28 29 35 42 42 44 39 33 23 30 18 25 24 15 13 5 4 2 2 0   3 3 0 0 1 3 0 1 1 3 2 4 3 4 2 1 1 1 3 1 0 0 2 2 4 2 2 1 4 2 4 2 2 2 1 2 2 1 2    0 4 2 2 3 1 2 1 1 2 2 1 2 4 2 1 4 1 2 2 2 2 0 2 0 3 0 1 0 2 1 0 4 2 1 3 2 1 0    2 1 1 1 1 0 1 1 2 1 1 1 2 0 1 0 2 1 1 0 0 1 0 0 1 0 0 0 0 0 0   0.100000 2.100 2.100 5.800       467340           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 0 0 1 2 0 0 0 0 0 1 0 2 0 0 2 0 0 1 1 0 0    0 1 0 0 1 1 0 0 0 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 1 2 0 2    2 4 1 0 1 1 2 3 4 1 4 1 5 1 2 1 0 2 2 2 1 5 4 1 5 4 0 1 2 4 2 2 0 2 1 2 5 4 1    1 1 2 5 7 9 16 23 31 15 22 36 36 44 42 29 31 28 28 18 35 12 10 13 8 4 3 2 2 5    1 2 3 3 1 3 3 5 2 0 3 4 1 2 2 3 0 0 5 2 3 6 2 1 2 5 3 4 3 1 1 1 1 2 2 4 0 2 3    1 2 1 2 4 5 4 3 5 2 1 2 0 5 0 2 2 4 1 0 4 1 0 2 1 2 0 0 1 3 2 4 3 0 2 3 3 3 4    2 2 0 0 0 0 1 1 0 3 2 0 1 2 0 4 2 1 1 1 2 0 0 0 0 0 0 0 0 0 0   0.102000 2.150 2.150 5.900       497495           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 0 2 1 0 0 0 0 1 0 1 0 0 0 0 1 2    0 0 0 0 0 2 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 1 1 1 2 0 0 1 0 0 0 1 0 2 2 1 0 0 0    2 0 2 1 1 1 6 3 2 0 3 2 2 2 1 1 3 4 1 0 1 2 4 2 3 3 1 1 1 1 3 3 1 4 1 3 4 3 2    3 1 2 2 5 11 11 14 26 27 28 28 28 36 39 42 29 33 24 20 29 18 13 17 13 6 10 4 3   3 6 1 0 1 0 2 1 3 2 3 1 2 3 1 2 1 2 0 2 2 3 1 3 1 1 2 4 4 1 4 3 2 2 3 5 5 3 0    2 5 3 5 1 4 1 1 3 4 2 2 2 2 1 3 0 1 1 2 2 4 2 1 3 2 0 1 2 1 0 2 3 1 2 0 0 0 2    0 0 1 3 0 0 1 2 0 3 1 0 3 1 2 2 1 1 2 0 0 0 0 2 0 0 1 0 0 0 0 0   0.104000 2.200 2.200 6.000       529288           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 3 0 2 0 2 0 0    3 2 2 0 4 0 3 2 2 1 3 1 7 3 1 1 0 4 3 2 1 0 0 3 2 3 5 2 1 4 1 5 1 0 3 2 3 0 1    2 4 7 3 7 8 12 15 20 24 34 39 34 35 27 36 34 23 22 26 15 24 12 12 14 5 3 0 7 1   1 3 5 1 2 2 2 4 3 1 2 5 2 2 3 1 1 4 2 1 3 0 4 5 4 6 4 5 3 3 3 3 1 1 5 0 6 1 2    4 2 3 2 1 3 2 0 0 0 1 3 3 0 1 4 0 3 2 3 0 3 3 0 2 3 4 3 1 1 1 2 5 3 1 2 1 1 2    4 1 0 2 4 1 3 0 0 3 0 1 3 0 1 0 0 1 1 1 0 1 1 1 0 0 0 0 0 0 0   0.106000 2.250 2.250 6.100       560628           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 2 0 1 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1    1 0 0 1 1 1 0 1 1 0 0 0 1 1 1 1 0 0 1 1 2 0 0 0 0 2 0 3 1 1 0 0 2 2 2 0 5 2 1    1 1 1 3 1 2 3 0 1 0 0 0 0 1 0 2 2 1 2 1 0 4 3 2 1 2 1 0 4 2 2 0 2 1 1 2 3 1 2    1 2 4 4 11 12 17 19 19 29 30 24 30 35 51 32 36 34 31 19 22 17 11 19 11 7 6 6 3   4 0 3 3 2 0 2 2 2 3 1 5 3 2 3 5 1 0 2 2 5 4 2 3 2 0 1 6 1 2 2 2 2 1 1 2 2 1 4    3 2 2 1 2 5 2 0 2 0 2 5 4 5 2 1 3 6 1 3 4 4 0 0 6 0 2 6 1 2 2 2 0 1 3 1 3 4 2    1 4 2 1 2 3 3 0 3 1 0 2 0 2 1 0 2 1 2 0 0 1 1 0 2 0 0 0 0 0 0 0   0.108000 2.300 2.300 6.200       593293           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 2 0 2 2 1 0 0 2 0 1 0 1 0 0 1 2 2 1 0    0 1 0 2 0 0 0 0 0 1 1 1 1 1 0 0 1 1 0 0 1 1 1 2 2 1 0 1 1 0 1 5 0 2 4 1 0 1 4    2 1 3 2 2 3 2 3 2 0 0 3 4 3 1 3 2 2 0 3 0 2 4 0 3 2 5 1 2 1 4 6 1 2 4 0 3 6 1    7 6 4 5 4 10 16 24 22 20 40 37 44 34 29 21 28 36 36 27 23 24 14 10 4 5 2 5 3 6   2 3 3 1 4 2 1 5 1 3 5 3 2 1 2 2 6 2 3 1 1 0 5 3 3 3 4 5 2 2 3 3 5 5 1 6 2 3 2    6 0 5 2 4 3 5 1 2 2 5 1 2 3 1 2 2 2 4 2 5 5 2 2 2 5 0 1 2 5 2 3 2 3 1 1 2 4 0    2 1 4 2 1 1 1 0 1 2 0 0 1 3 1 0 2 1 1 3 3 2 0 0 0 1 2 0 0 0 0   0.110000 2.350 2.350 6.300       636559           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 1 0 0 0 1 1 2 0 0 1 0 0 0 0 0 0 0    1 2 0 0 1 1 1 0 0 0 0 1 0 1 1 0 0 1 0 0 2 0 1 0 1 0 1 0 0 1 1 3 0 1 2 2 0 2 1    1 1 1 0 1 0 1 3 0 3 2 3 4 3 3 4 3 3 2 6 3 1 1 1 2 4 2 3 1 5 1 3 1 4 5 3 3 2 1    3 7 4 3 10 19 17 19 23 27 28 33 39 36 23 23 32 32 16 19 35 23 12 11 12 8 4 5 7   1 2 2 1 2 3 5 4 2 3 2 6 4 4 2 4 1 2 2 1 2 3 0 4 2 1 2 6 2 2 1 3 3 1 6 4 8 5 2    3 5 2 3 0 3 2 3 1 2 2 3 4 3 8 6 2 1 4 6 3 1 2 0 2 0 2 5 0 3 3 3 3 1 3 3 2 5 4    2 1 4 2 2 4 4 1 3 2 5 2 3 1 2 0 4 0 1 0 6 3 1 2 0 2 0 1 0 0 0 0   0.112000 2.400 2.400 6.400       670484           3           0  0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 1 1 0 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 2    0 1 1 1 3 0 0 0 2 1 3 0 1 1 1 0 1 1 1 0 0 1 2 0 1 3 1 5 2 3 0 4 0 2 0 0 1 2 1    0 1 0 0 1 0 2 2 3 2 3 2 2 2 3 4 4 2 3 5 3 3 2 3 3 4 2 4 0 3 2 4 4 1 3 1 3 4 2    2 5 2 8 6 12 17 14 22 27 26 29 39 30 24 36 22 22 20 9 19 15 5 12 16 4 7 5 7 5    5 1 4 5 5 4 4 1 4 4 3 3 3 4 2 2 4 2 4 4 4 4 0 2 3 2 1 4 3 6 1 3 3 3 4 5 4 2 2    2 5 3 0 2 5 4 2 5 3 5 1 1 3 1 1 3 6 6 2 3 2 0 3 2 4 3 4 1 2 2 6 2 0 3 2 2 5 3    3 5 2 1 0 3 1 1 2 2 0 1 1 3 2 3 2 1 1 1 1 3 2 1 0 0 0 0 0 0 0   0.114000 2.450 2.450 6.500       711783           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 1 0 2 1 2 0 1 0 0 1 0 0 1 1 1 1 0 0 0 1    1 2 0 1 1 0 0 0 2 1 1 1 1 1 2 1 2 3 3 1 1 1 2 3 1 3 2 2 1 0 1 1 4 4 4 1 0 4 0    0 1 1 2 1 3 2 0 3 4 1 1 1 1 3 2 0 1 3 2 1 2 1 0 3 3 2 5 4 2 5 3 4 2 2 5 3 3 3    3 5 5 8 7 14 12 28 22 24 23 36 33 26 32 27 26 18 30 24 15 13 19 15 17 6 5 7 5    4 3 5 3 1 4 4 9 5 3 1 4 0 0 6 2 5 3 3 3 1 2 3 2 4 1 5 5 3 8 2 1 1 4 1 7 5 6 6    4 4 3 2 6 3 3 3 3 1 3 4 5 4 3 4 3 1 2 3 1 2 1 2 2 6 5 2 2 2 4 2 2 0 2 3 3 2 7    4 4 1 4 2 0 3 1 1 2 1 2 3 1 3 2 2 4 3 1 4 0 0 4 2 2 2 1 0 0 0 0   0.116000 2.500 2.500 6.600       745364           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 2 1 1 2 1 1 1 0 1 0 2 0 1 1    0 1 0 1 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 1 2 3 0 1 4 4 0 4 0 1 0 1 3 3 0 2 1 2 3    2 1 1 1 2 0 4 0 0 4 5 2 5 4 1 3 5 5 4 0 4 4 2 3 2 3 5 2 2 4 2 3 4 2 3 3 3 3 3    2 4 12 10 13 14 19 22 23 24 36 19 32 25 25 36 24 18 20 21 14 18 13 8 6 9 2 9 5   2 5 3 4 4 3 3 0 4 3 2 5 3 4 2 2 6 3 4 0 2 4 1 3 4 7 4 5 3 2 4 5 5 3 4 4 4 2 3    2 4 4 2 1 5 7 1 5 2 4 1 5 5 3 4 4 3 2 4 2 4 0 6 2 3 4 1 2 2 2 4 1 4 2 2 2 5 6    5 1 4 4 2 3 3 3 1 4 3 4 2 6 2 5 3 2 2 1 3 2 2 5 1 1 0 0 1 0 0 0   0.118000 2.550 2.550 6.700       791846           4           0  0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 2 1 1 0 0 0 0 0 1 0 0 0 1 1 0 1 0 1 0 1 1 0 1 0    1 4 1 2 3 0 3 1 0 1 1 1 0 3 1 2 1 1 1 0 0 1 1 1 3 1 3 2 3 1 2 2 1 3 2 4 1 4 0    2 4 1 4 3 2 1 1 2 1 3 2 3 3 2 1 1 5 3 3 3 3 2 3 4 3 5 3 1 1 2 2 3 5 1 2 1 1 4    4 6 9 6 6 13 17 21 20 24 22 25 20 29 23 28 30 26 27 18 20 17 16 17 12 10 8 5 6   6 6 4 3 1 2 4 6 9 2 2 3 5 7 6 2 3 8 5 4 5 6 4 6 5 3 5 3 2 5 3 2 8 3 5 4 5 3 5    4 3 4 8 4 3 8 3 3 3 1 1 2 2 5 4 7 3 2 3 3 2 2 3 6 3 2 2 1 1 5 2 5 6 3 5 3 4 1    3 1 2 1 0 4 1 4 2 2 2 3 1 1 1 1 3 2 0 1 6 1 1 0 2 1 0 1 0 0 0 0   0.120000 2.600 2.600 6.800       833394           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 2 1 1 1 2 1 0 0 0 1 0 1 0 0 0 1 0 0 1 1 2 1 0 0    0 0 0 2 2 0 3 1 0 0 2 1 1 1 1 0 1 2 1 5 0 1 0 2 2 1 2 0 4 2 1 4 3 4 2 2 1 2 1    5 2 3 1 3 0 2 2 2 2 3 4 0 4 2 3 3 4 5 2 2 6 3 4 5 5 5 3 4 6 5 1 3 0 5 4 5 1 3    2 2 6 18 13 17 27 27 21 28 28 24 26 27 29 23 21 16 17 19 22 14 11 9 5 14 7 7 6   4 4 12 3 6 4 5 4 6 4 2 0 1 8 1 6 8 5 2 3 4 5 6 4 2 5 8 3 1 1 6 3 7 8 4 1 6 5 2   8 11 5 6 5 6 2 4 5 1 2 7 2 2 5 5 6 3 3 2 3 8 5 1 9 3 3 2 3 6 3 5 3 2 4 6 3 1 3   5 4 4 4 6 3 3 5 0 2 2 5 1 3 2 2 1 4 2 0 2 2 2 2 4 1 2 1 2 1 1 0   0.122000 2.650 2.650 6.900       876007           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 1 1 1 1 2 2 1 0 0 1 0 0 0 1 1 0 0 0 2 0 0    4 1 0 2 1 2 0 1 2 0 1 3 2 1 0 1 1 0 1 2 1 0 2 3 3 5 3 3 3 0 1 4 0 1 5 3 4 3 1    2 2 2 4 1 3 3 3 2 3 2 3 2 1 4 4 2 2 5 5 3 4 1 2 1 2 4 2 4 7 2 4 4 2 7 3 5 7 5    3 6 8 10 10 18 21 22 24 14 25 27 29 31 22 25 24 21 27 20 19 22 19 14 13 14 10    5 7 3 4 5 5 3 1 4 3 8 4 5 4 0 3 4 3 4 1 7 6 1 1 3 4 4 3 4 3 6 4 3 4 2 4 4 3 5    6 5 1 1 6 2 6 6 3 5 5 3 2 6 5 4 3 4 6 4 3 5 5 6 5 6 2 4 2 1 2 2 4 2 7 6 2 1 3    1 5 2 1 2 4 3 3 3 2 5 2 4 1 4 3 2 2 5 5 1 1 3 3 2 2 2 2 1 0 0 0 0 0   0.124000 2.700 2.700 7.000       925764           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 2 1 3 0 1 1 0 0 0 0 0 1 1 1 1 0 0 0 1 1 0    1 2 0 0 3 2 0 1 2 1 1 2 0 2 1 2 2 0 0 2 3 2 3 2 2 3 2 2 4 0 2 0 5 1 3 2 3 1 2    3 2 0 6 4 3 6 2 5 0 5 2 1 4 4 5 7 4 2 3 5 2 0 2 5 2 4 7 4 4 4 8 5 3 1 7 2 2 1    5 5 5 14 19 16 22 18 30 29 25 36 23 23 22 25 25 27 26 23 14 20 16 16 10 6 6 6    4 2 6 6 6 6 6 4 6 1 0 3 4 4 5 2 4 3 2 4 4 5 5 5 6 10 6 3 6 8 5 5 8 7 4 6 4 3 4   8 5 5 7 4 6 3 5 8 4 3 4 4 3 4 3 1 3 3 7 2 4 8 3 6 4 3 3 2 5 4 4 3 7 4 5 4 4 3    4 7 2 3 3 4 3 0 2 2 4 3 4 2 4 2 2 6 4 4 6 6 1 5 1 1 2 1 0 0 0 0 0   0.126000 2.750 2.750 7.100       969560           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 1 1 0 1 2 0 2 0 2 2 0 1 1 1 0 0 1 0 1 1 1 1 2 0    1 2 2 1 2 0 0 1 0 1 0 2 1 0 1 0 1 1 2 0 3 0 3 4 3 1 3 2 0 4 0 1 2 0 3 1 1 2 3    2 2 2 5 1 7 1 5 1 5 4 2 0 0 1 2 1 3 2 3 3 5 4 10 10 2 5 11 4 1 2 1 7 3 5 4 4 1   5 10 8 7 9 9 20 20 21 33 21 28 20 27 32 21 29 22 20 24 15 13 27 14 13 15 10 9    3 11 6 7 5 3 6 8 5 4 4 1 3 3 5 2 7 3 6 6 1 6 4 6 5 3 4 2 4 3 3 9 4 5 4 4 5 2 3   10 4 3 2 6 10 6 3 6 5 5 5 4 8 8 5 4 3 6 4 4 2 4 4 4 5 7 4 4 4 4 5 2 2 3 4 5 2    1 3 2 6 2 7 7 1 6 4 4 6 5 5 4 0 2 2 3 2 7 5 0 4 1 1 4 6 1 0 3 2 0 0 1   0.128000 2.800 2.800 7.200      1022713           5           0  0 0 0 0 0 0 0 0 0 0 0 1 0 2 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 2 1 0 0 4 0 0 1 2 3    1 1 0 1 0 1 0 3 1 1 1 2 2 1 1 1 3 1 0 2 4 2 1 2 1 2 0 3 1 3 2 1 5 2 1 3 1 2 1    5 3 2 1 2 5 3 8 2 3 2 5 5 4 3 6 4 4 4 3 2 3 8 4 3 4 5 4 5 4 7 6 5 3 3 3 5 2 9    10 7 9 12 11 13 17 15 22 19 33 24 28 30 26 21 24 22 27 20 26 16 10 10 9 20 10    7 4 5 7 7 2 7 5 3 5 1 6 1 5 7 5 6 3 1 5 1 1 3 4 8 6 3 9 5 5 3 6 7 4 6 7 6 4 2    4 6 2 3 6 5 6 7 6 4 4 9 6 8 6 9 7 1 2 6 2 7 5 4 4 4 4 5 5 4 4 3 6 3 5 3 6 4 3    6 6 2 5 2 8 4 5 3 6 5 4 5 8 4 3 5 6 5 5 2 8 1 2 2 5 4 1 3 0 0 0 0 0   0.130000 2.850 2.850 7.300      1081669           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 5 0 0 2 2 0 0 1 0 0 0 1 1 0 2 0 2 2 2 1 0    1 0 2 2 3 1 1 0 2 0 1 0 2 1 1 2 2 0 1 4 3 0 2 1 1 0 2 5 2 1 0 1 3 2 5 2 1 2 5    2 3 4 3 6 6 6 4 6 6 3 1 3 2 3 4 7 5 2 9 7 4 1 4 4 3 2 2 2 7 4 8 4 7 4 6 8 5 1    8 6 10 18 21 18 15 21 24 21 26 22 30 28 27 23 22 21 17 25 20 17 13 17 9 12 7 8   5 4 4 5 5 2 4 1 1 2 5 7 6 4 9 7 7 5 5 5 5 5 2 4 5 3 6 8 2 4 9 4 10 5 1 4 5 5 5   10 3 2 8 6 5 7 3 13 3 3 6 5 1 4 5 9 5 2 7 4 5 6 3 5 6 5 4 5 9 6 4 3 4 4 4 5 8    5 5 0 3 6 3 4 3 7 5 6 4 3 3 6 8 4 1 3 1 2 7 3 4 6 6 1 3 4 1 0 1 0 0   0.132000 2.900 2.900 7.400      1131887           3           0  0 0 0 0 0 0 0 0 1 0 0 1 2 1 1 0 0 0 1 2 2 1 1 0 2 1 1 0 1 1 1 0 2 2 3 1 0 1 0    1 0 2 0 2 0 1 4 0 1 2 2 0 0 0 2 3 0 1 2 3 0 1 2 3 5 6 2 2 3 1 4 4 8 4 3 3 3 7    2 2 5 7 4 1 2 4 8 1 5 2 7 3 4 2 9 6 5 5 6 2 2 3 6 2 5 6 7 7 2 8 3 3 3 3 6 6 5    3 10 15 15 17 19 13 29 20 23 22 34 28 28 33 20 20 22 17 22 18 15 19 14 11 9 13   6 6 13 4 2 9 8 8 7 6 5 6 4 4 9 6 2 8 9 7 2 6 3 7 3 6 3 7 4 4 5 4 5 6 4 7 5 4     10 2 6 6 8 3 6 6 9 5 8 8 7 6 4 8 5 7 5 5 7 3 5 5 5 10 7 3 8 7 5 7 2 4 4 6 4 10   7 6 4 4 4 4 3 2 4 2 6 5 9 7 3 2 6 2 5 1 5 6 2 2 1 9 2 5 2 5 1 0 0 0 1 1   0.134000 2.950 2.950 7.500      1185706           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 3 2 1 0 1 1 0 0 0 0 0 1 0 1 1 2 0 1 0 1 2 0 0 0    1 1 0 1 1 1 0 2 2 0 1 3 3 2 3 0 0 2 2 3 2 1 1 3 0 0 1 1 3 4 3 1 1 9 1 4 0 1 3    4 1 3 2 6 4 7 7 3 2 8 5 2 5 2 4 6 7 3 7 7 8 4 7 2 4 7 7 9 9 2 5 5 8 3 5 7 3 6    10 6 10 15 10 13 14 29 21 23 37 26 20 28 20 16 24 25 16 19 21 20 20 17 11 10     12 8 7 7 5 5 5 4 5 6 7 3 6 5 7 5 11 9 6 8 11 6 4 6 8 8 7 7 7 4 5 4 8 5 4 3 4 8   10 7 9 4 7 6 8 9 7 3 5 7 7 6 2 6 4 7 3 9 8 12 7 6 6 6 4 5 7 2 4 7 3 2 4 4 7 1    4 5 0 4 6 3 10 8 5 4 3 4 5 7 5 7 5 7 3 5 2 5 6 4 5 2 4 1 6 6 2 4 2 0 0 1 0   0.136000 3.000 3.000 7.600      1238426           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 2 4 0 2 0 2 2 0 1 1 1 0 2 1 1 2 1 0 1 1 0 3 1 0    0 1 0 1 0 0 2 1 1 0 4 0 2 6 3 3 4 0 3 1 2 4 0 4 4 0 1 5 2 2 5 1 3 4 3 3 5 2 4    4 6 2 5 3 4 5 4 5 6 7 5 6 2 8 3 4 7 2 4 4 3 7 6 5 1 4 8 3 7 10 3 3 6 1 5 3 8     11 5 7 15 11 15 17 21 23 21 24 28 16 21 29 15 22 27 28 20 13 19 13 7 15 10 11    9 6 8 8 4 7 5 4 6 5 10 6 7 8 9 3 5 5 9 5 9 4 4 4 3 5 7 4 10 6 8 4 9 8 4 6 7 9    11 6 8 3 5 8 12 3 6 9 7 11 9 6 7 4 7 7 7 2 5 4 5 0 2 9 5 5 5 10 7 5 6 3 9 4 4    13 2 7 5 7 4 7 2 0 4 5 4 4 6 8 1 2 5 6 4 7 3 11 4 3 3 5 5 4 4 3 1 4 2 2 1 1 0   0.138000 3.050 3.050 7.700      1299809           6           0  0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 1 2 1 1 0 0 1 0 0 2 0 1 2 0 0 3 0 0 1 3 1    2 0 2 0 1 1 2 1 2 3 2 1 2 5 2 2 2 4 3 2 5 3 0 3 2 4 5 4 3 0 5 4 1 4 3 8 6 4 4    7 4 5 4 3 6 5 6 10 3 6 6 2 6 3 4 4 3 6 7 6 8 3 4 7 5 4 9 2 4 8 5 9 8 3 7 5 7 7   13 7 11 15 17 16 18 18 18 20 17 26 25 19 20 26 31 22 18 20 18 14 11 16 4 7 11    10 8 9 9 6 3 8 8 7 5 6 10 3 5 6 6 3 12 7 8 8 2 10 4 13 9 9 12 4 5 9 7 9 5 7 4    8 9 6 7 8 10 8 7 5 7 11 6 4 4 4 6 4 9 4 5 9 10 7 4 12 7 4 9 5 10 10 6 8 4 7 2    4 7 2 6 8 4 11 3 3 9 7 6 7 3 8 7 4 8 5 3 7 4 5 5 7 4 6 7 5 5 3 5 2 5 4 1 2 0 0   1   0.140000 3.100 3.100 7.800      1361810           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 3 2 1 0 0 0 1 1 1 2 0 0 0 0 1 0 2 2 2 1 0 0 3 3 0    2 0 6 2 3 1 0 3 3 1 2 2 5 3 5 3 3 2 2 7 3 2 2 3 4 2 3 4 4 1 3 7 4 5 4 2 3 5 4    2 1 3 6 3 4 3 8 7 6 5 3 5 11 5 5 3 3 7 3 6 4 4 2 4 4 4 1 5 5 9 6 6 9 3 10 8 6    8 3 10 8 16 16 13 18 23 29 25 19 19 20 27 19 22 27 24 21 15 18 11 20 21 17 12    5 18 6 12 7 9 11 7 12 11 4 8 8 4 8 7 7 2 6 4 4 9 6 9 3 4 7 7 7 4 10 4 11 5 8 8   8 5 4 4 8 6 4 9 8 12 12 8 5 8 3 10 8 7 5 3 5 6 8 5 6 10 7 2 11 2 5 5 6 8 10 2    7 5 5 14 2 7 3 9 3 5 2 8 2 3 4 4 7 9 5 4 7 6 7 5 6 3 5 4 7 6 7 7 9 3 0 2 1 1 1   0 0   0.142000 3.150 3.150 7.900      1429499           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 2 1 1 0 0 0 3 0 2 2 1 0 3 0 2 1 3 0 0 1    1 3 1 2 4 1 5 3 5 1 0 7 1 3 2 3 2 2 2 3 0 0 1 3 6 3 2 2 4 4 4 6 4 3 6 4 10 3 7   2 5 4 7 4 5 8 4 7 4 1 7 11 5 2 10 2 11 3 7 8 10 9 6 3 5 3 6 3 10 11 5 5 9 7 10   8 9 5 15 11 9 18 18 15 24 17 23 17 19 25 17 24 18 37 16 17 21 17 14 20 17 15     15 9 4 11 7 3 8 10 8 8 6 8 3 4 5 8 4 6 3 9 9 6 2 10 4 4 3 8 4 9 1 7 5 9 7 10 9   10 4 6 5 8 6 6 10 10 6 5 7 6 6 10 5 7 8 8 8 7 7 11 12 8 3 10 6 9 13 11 4 6 7 6   3 10 5 8 4 7 7 7 5 8 4 9 5 5 7 6 6 7 11 11 7 8 5 3 5 7 7 10 3 3 6 5 7 9 2 3 7    1 0 0 0 0 1   0.144000 3.200 3.200 8.000      1493946           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 2 3 0 0 1 2 1 1 1 4 1 0 1 0 1 2 1 3 1 1 1 1 2    1 1 3 2 6 0 4 0 1 4 2 4 5 2 1 3 0 2 2 4 2 3 2 4 3 5 4 4 4 1 5 1 3 4 5 6 4 7 2    8 8 8 5 3 6 0 7 3 2 2 5 7 5 7 5 8 9 6 4 3 6 8 6 10 2 5 6 3 3 6 6 6 6 17 5 10 6   6 11 11 13 12 21 26 18 24 21 24 23 30 18 22 20 24 19 13 17 25 22 17 15 8 13 7    10 8 9 6 7 9 8 7 8 9 7 7 6 12 5 9 9 12 9 12 6 9 7 10 7 7 4 9 7 4 2 7 4 5 8 8 9   7 6 7 5 9 4 8 13 6 5 4 7 9 6 7 7 9 4 4 5 8 10 9 10 6 6 7 9 12 11 8 8 9 11 5 8    7 5 5 8 5 9 10 5 5 11 11 6 8 8 4 8 5 5 5 4 7 4 5 6 5 6 6 7 7 4 2 6 3 2 1 0 0 0   0 0   0.146000 3.250 3.250 8.100      1562352           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 2 0 1 2 1 1 0 0 1 0 1 2 0 0 0 3 1 2 0 4 4 2 0    0 2 3 2 0 1 3 3 4 0 1 4 3 3 4 5 5 4 2 1 4 2 5 3 2 7 6 3 5 6 5 5 5 1 5 2 7 4 8    7 4 6 5 7 5 3 5 8 1 6 4 6 8 7 6 7 6 3 4 6 3 5 8 4 10 3 3 11 6 5 3 9 6 4 3 17 9   11 11 24 13 15 14 25 26 26 21 17 32 32 22 18 25 29 29 27 24 21 12 23 14 12 11    9 17 7 9 11 3 7 6 5 5 12 3 6 8 7 4 7 11 10 8 9 5 8 2 10 9 8 10 10 7 7 4 7 5 7    7 9 10 8 7 7 16 6 8 10 5 6 6 12 12 7 11 11 8 9 7 8 12 10 7 8 7 11 8 9 7 7 4 9    4 7 14 9 8 8 13 9 8 7 13 5 9 5 7 4 9 5 7 8 7 8 7 3 10 9 3 4 4 4 5 2 6 6 3 5 10   4 4 2 3 0 1 0 0   0.148000 3.300 3.300 8.200      1630559           3           0  0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 4 2 1 1 1 2 1 2 0 2 1 5 0 1 1 4 0 2 1 4 5 3 0    1 1 1 2 1 3 3 3 1 1 1 1 1 3 4 6 6 8 8 4 3 2 7 2 2 1 7 4 4 5 1 10 6 4 4 4 3 3 3   6 11 6 4 5 4 8 5 5 9 4 5 5 7 6 4 13 12 3 6 7 5 2 7 9 7 8 8 4 7 6 4 10 6 8 9 9    9 13 15 17 23 25 13 16 24 22 26 21 27 24 24 21 21 21 15 17 22 25 21 22 17 14     11 8 12 5 9 7 8 5 11 10 6 6 5 9 13 10 9 8 8 8 6 4 9 10 9 9 7 8 7 5 7 8 14 13 5   14 5 12 11 8 9 6 5 4 9 13 7 10 13 11 11 8 5 9 10 8 7 6 7 13 3 13 8 7 13 17 5 8   5 10 7 12 7 6 6 9 7 8 8 11 8 11 9 11 11 8 5 6 10 4 9 3 10 8 7 10 8 7 8 10 10 7   4 11 5 7 8 2 4 3 0 0 1 0 1   0.150000 3.350 3.350 8.300      1707576           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 1 2 1 0 2 0 2 3 1 3 2 2 2 2 0 2 1 4 3 2 2 3    1 2 1 0 2 2 4 2 5 3 3 5 2 8 4 5 4 2 3 6 7 6 1 0 7 4 7 7 6 5 4 3 4 6 6 7 6 2 7    4 4 2 5 5 6 9 3 3 3 6 6 5 3 5 7 8 8 6 8 8 6 8 3 9 6 6 8 8 6 4 8 6 6 10 4 11 6    11 15 23 16 8 17 20 21 19 24 15 14 19 21 30 25 21 15 19 16 18 21 21 15 14 12     16 8 10 12 7 10 9 8 10 10 7 9 8 10 12 6 6 9 11 6 5 9 12 6 7 12 7 5 6 8 5 9 4     11 9 8 8 10 7 6 10 7 11 13 7 4 13 11 8 11 9 16 6 12 11 10 10 19 2 9 11 8 7 8 8   6 13 6 10 12 12 9 12 9 9 8 7 7 9 6 12 8 4 9 9 8 5 7 8 9 5 12 5 7 5 9 10 9 10 3   6 6 8 7 11 3 5 5 4 2 0 0 0 0   0.152000 3.400 3.400 8.400      1777231           3           0  0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 0 0 1 1 3 1 0 3 4 2 3 3 3 3 3 2 1 1 1 1 3 3 0    1 8 0 0 5 3 7 4 4 4 4 4 3 5 2 2 5 3 6 1 7 6 1 2 2 5 2 1 6 6 8 7 7 5 10 4 1 6 9   3 4 5 3 5 8 4 9 8 11 8 3 2 7 7 9 10 9 10 8 6 8 6 8 7 10 8 7 3 8 4 10 7 6 8 9 6   5 16 9 19 24 23 17 23 24 22 30 21 15 23 27 20 20 20 18 20 23 18 17 15 19 17 18   13 9 4 4 7 12 7 10 4 8 6 10 5 6 13 2 3 8 7 8 7 3 11 8 7 9 7 19 7 8 9 6 14 8 8    11 10 11 13 14 10 16 8 9 13 8 9 9 12 7 12 11 6 9 15 5 9 9 9 11 11 13 6 10 6 4    12 9 9 12 11 8 6 9 16 10 10 10 8 10 10 6 7 4 1 15 6 8 4 9 13 11 8 10 11 9 8 3    3 6 6 7 9 4 6 8 7 4 2 1 2 2 1 0   0.154000 3.450 3.450 8.500      1849489           6           0  0 0 0 0 0 0 0 0 0 0 1 1 3 0 1 2 2 0 1 4 1 1 0 1 0 2 1 0 0 1 1 1 1 6 3 6 1 3 1    3 3 0 6 0 4 2 7 4 6 4 4 3 7 4 5 7 5 5 2 3 9 9 2 5 5 3 9 4 2 7 6 2 8 2 5 7 12 6   5 4 5 10 4 12 10 6 4 14 7 9 10 11 7 7 7 7 3 9 7 4 3 8 7 5 7 9 6 8 9 6 8 8 12 6   5 11 12 13 11 13 21 26 19 23 25 18 23 22 23 23 18 27 20 15 20 25 24 19 18 12     14 13 15 8 15 10 11 7 9 13 11 12 13 11 11 7 11 13 6 5 10 6 6 10 8 14 5 14 11 8   5 9 7 10 10 8 7 15 13 3 13 12 18 15 7 10 9 10 8 15 9 6 8 9 10 10 9 5 7 7 5 10    11 13 12 12 12 10 6 17 10 11 9 4 8 7 6 6 9 12 8 16 18 7 5 10 8 12 10 15 6 13     11 6 10 16 10 11 16 8 9 5 11 10 14 11 5 2 5 7 3 1 1 0 1 0   0.156000 3.500 3.500 8.600      1920727           4           0  0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 2 1 2 0 3 0 1 1 0 1 0 3 0 4 4 1 3 1 2 3 3 4 3    1 2 3 9 5 2 3 7 3 3 6 5 2 6 1 4 3 2 3 6 5 1 8 3 8 5 3 7 6 13 11 9 5 8 7 7 5 8    7 4 8 6 4 10 4 6 5 6 9 9 12 6 7 10 9 9 8 8 3 8 9 8 8 2 12 11 13 8 13 7 8 6 6 9   6 8 16 13 14 16 16 22 20 21 21 17 20 18 19 22 20 11 20 22 21 14 19 15 23 17 15   12 14 19 16 10 11 14 11 9 11 9 12 8 16 14 9 6 18 10 11 7 10 11 17 10 13 8 10     12 9 12 7 7 10 10 11 11 9 8 8 14 10 10 9 14 9 14 13 9 19 16 17 4 11 8 12 11 10   21 6 10 8 9 12 9 7 7 12 7 16 14 10 13 6 13 8 9 10 6 10 8 7 10 4 6 11 19 12 6 7   5 8 11 10 12 13 9 6 10 5 11 11 4 14 10 7 2 6 5 1 2 5 1 1 0 0   0.158000 3.550 3.550 8.700      1999833           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 2 3 2 2 2 1 2 3 0 1 0 1 3 2 0 0 3 2 3 2 5 7 0    3 4 1 10 7 7 4 5 2 3 4 3 8 3 6 4 4 4 8 2 3 4 5 5 7 1 6 7 8 1 6 8 1 4 4 11 9 4    7 11 9 10 5 6 8 4 3 9 7 9 11 5 5 8 8 4 8 7 8 11 9 12 6 4 13 4 12 10 6 9 11 10    11 10 11 11 11 14 15 14 23 18 17 29 16 26 23 15 19 14 18 19 22 31 13 21 20 12    16 15 14 18 17 15 8 12 14 13 10 10 10 10 10 13 11 6 8 11 8 14 8 10 11 11 8 10    13 5 14 7 12 9 10 10 12 15 18 8 6 9 9 12 8 9 20 14 16 10 11 14 5 5 13 6 11 9     11 15 6 9 13 11 7 8 7 10 8 16 12 11 8 10 14 11 17 11 8 16 13 9 10 5 10 17 13     14 16 8 10 9 11 5 10 9 10 12 8 11 12 11 8 6 7 12 15 13 12 7 13 5 0 3 2 0 0 0 0   0.160000 3.600 3.600 8.800      2073149           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 2 1 2 1 2 2 1 0 2 2 1 0 3 6 4 5 5 2 2 2 5 5 3 6 4    6 4 5 2 4 4 3 2 4 6 3 3 6 5 7 4 5 7 5 3 5 6 13 5 3 10 5 9 7 4 5 6 5 10 6 5 5 6   6 4 14 7 6 11 6 9 10 9 8 5 3 8 10 10 6 6 8 9 5 6 14 7 11 10 9 9 11 13 8 4 5 10   12 6 16 8 8 7 19 20 23 10 16 27 25 23 19 26 21 16 20 21 24 18 25 8 11 13 16 18   13 22 18 9 16 4 16 10 12 13 9 7 9 8 17 11 10 13 10 14 4 9 12 16 8 9 16 17 13     11 14 8 8 13 9 11 15 10 11 14 8 6 4 9 11 18 9 9 8 9 15 11 11 11 9 6 13 13 10 7   8 10 15 14 9 7 4 10 12 17 10 14 13 10 10 12 20 9 7 6 11 15 11 10 8 9 6 10 13     17 6 8 9 6 13 13 16 10 15 5 11 14 11 12 6 5 12 9 4 9 2 4 1 1 0 0 0   0.162000 3.650 3.650 8.900      2156456           5           0  0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 2 0 1 1 3 2 3 4 3 3 2 1 3 6 5 2 3 4 4 3 6 2 3    4 4 5 5 3 4 1 4 5 9 3 3 4 3 3 8 5 6 12 2 10 3 4 6 8 9 8 8 2 2 7 5 8 2 8 9 7 2    6 8 6 5 8 2 7 5 6 13 5 6 8 11 6 10 5 6 3 8 10 11 10 10 14 10 11 8 11 8 12 6 12   5 15 12 13 10 13 13 18 23 12 21 18 21 23 20 30 20 23 26 24 24 21 21 29 19 21     16 23 20 13 19 13 16 11 15 13 13 11 8 11 14 14 13 4 16 15 18 13 9 19 8 11 6 9    14 8 13 12 13 10 13 10 14 11 13 11 8 10 13 11 11 14 11 8 14 11 10 9 14 12 14     18 8 12 7 13 12 10 14 14 8 12 17 11 13 9 12 12 15 7 9 13 17 11 11 11 12 17 12    11 16 15 8 9 12 7 13 15 11 16 7 10 7 14 5 18 10 10 8 8 6 6 13 14 6 9 11 9 9 3    5 1 1 3 0 0   0.164000 3.700 3.700 9.000      2234753           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 4 1 4 2 1 3 1 1 3 2 3 3 1 3 6 2 4 4 3 3 3 6 5 2    6 4 1 3 3 7 1 4 4 6 12 4 5 2 6 4 9 3 1 8 11 5 2 7 6 3 8 4 7 3 8 3 9 6 7 8 9 2    7 6 9 6 15 6 9 5 9 4 9 17 15 10 2 10 6 8 12 12 11 12 10 9 7 11 8 7 5 11 10 14    16 7 7 7 13 15 10 16 17 21 19 14 18 24 19 27 27 24 20 22 24 21 20 14 24 17 17    18 32 15 12 13 15 12 8 14 11 11 19 11 14 15 18 10 5 12 11 11 9 15 9 7 9 16 12    9 12 10 15 9 18 7 11 12 14 7 20 8 10 13 14 11 6 6 9 11 8 10 16 8 17 13 17 9 16   11 10 9 13 20 17 14 12 10 13 11 9 9 17 20 10 16 8 14 13 14 18 15 15 8 10 12 11   22 12 13 9 12 9 11 14 19 12 12 8 8 12 11 19 11 11 12 15 11 15 13 9 9 10 9 4 9    4 2 1 0 0   0.166000 3.750 3.750 9.100      2327990           3           0  0 0 0 0 0 0 0 0 0 0 0 0 3 2 2 0 1 2 2 1 1 0 0 3 1 4 2 6 4 2 4 3 2 5 5 2 3 1 3    1 2 10 2 7 4 3 4 3 3 4 3 10 6 9 6 3 8 5 5 3 4 4 6 8 4 4 7 5 5 11 14 5 3 6 8 8    7 10 11 7 17 7 11 10 8 7 8 12 13 11 12 6 13 9 7 7 6 5 8 13 10 10 14 11 11 8 12   15 14 9 13 10 9 18 13 18 12 23 14 17 24 15 23 25 31 19 17 29 19 19 19 26 25 19   17 22 19 19 19 11 11 12 22 21 8 10 18 10 14 19 17 13 14 10 6 9 10 15 11 5 13     13 11 11 17 16 9 7 14 7 19 6 10 13 7 12 18 14 7 12 15 13 13 9 13 13 13 12 12     14 12 19 10 16 18 18 12 8 10 10 9 7 14 9 11 13 12 8 15 12 11 10 12 11 17 15 19   14 14 12 7 7 12 11 15 16 12 11 12 10 19 19 12 14 12 15 11 20 13 7 18 9 15 19     16 11 5 9 8 6 2 4 0 2 0 1   0.168000 3.800 3.800 9.200      2406866           3           0  0 0 0 0 0 0 0 0 0 1 0 2 0 1 0 2 3 2 3 1 2 1 2 2 5 2 1 2 3 2 2 2 5 3 5 3 3 1 3    6 8 6 1 3 9 6 3 6 10 5 5 7 4 5 7 12 9 5 7 5 6 6 8 3 5 4 7 8 5 6 5 8 13 4 10 2    10 9 7 7 16 9 10 9 13 8 12 9 13 15 9 15 9 10 11 6 6 6 7 7 6 8 15 9 8 9 6 12 12   11 14 12 11 13 8 17 18 18 11 14 19 14 25 21 15 10 15 19 27 23 22 24 17 19 18     12 16 22 21 25 9 25 15 19 15 21 15 8 11 13 12 10 12 7 13 11 17 11 13 10 16 19    14 23 11 8 12 13 10 9 17 4 14 10 7 10 17 14 11 11 20 18 13 8 12 6 8 13 12 23     15 14 15 16 9 14 9 13 14 17 11 17 11 10 15 17 11 6 12 12 14 15 17 12 16 16 8     17 15 15 10 15 11 10 15 12 13 9 12 9 12 15 12 6 18 7 15 14 12 21 18 11 10 18     11 19 11 7 11 3 2 5 4 0 1 1   0.170000 3.850 3.850 9.300      2508471           7           0  0 0 0 0 0 0 0 0 0 0 0 0 1 3 1 2 1 4 3 3 1 2 7 0 3 2 2 2 2 5 2 3 2 3 3 4 3 7 3    5 3 4 4 6 2 3 10 4 11 3 13 7 7 5 6 3 8 10 6 6 4 10 11 4 12 7 8 9 7 7 8 4 6 7 9   9 5 9 11 5 14 9 10 7 9 8 8 5 6 11 13 14 10 10 10 10 8 9 9 9 9 14 14 13 11 8 18   9 10 9 16 12 13 15 13 10 17 16 20 14 22 20 26 29 29 27 24 20 37 21 24 13 18 13   28 24 22 25 21 13 14 15 9 11 18 8 16 17 16 13 12 16 11 11 17 15 11 15 10 11 12   13 12 12 20 15 14 15 16 12 17 15 15 12 10 14 14 17 15 19 15 13 13 11 12 16 14    17 16 8 16 12 8 14 13 13 10 10 9 12 11 19 20 13 11 4 15 11 14 11 20 18 18 13     20 12 20 21 15 15 12 13 18 18 11 16 9 14 9 18 11 10 11 20 11 13 17 13 13 12 14   16 10 12 12 23 12 11 12 8 8 1 0 1 2 0   0.172000 3.900 3.900 9.400      2591210           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 4 4 3 2 1 3 3 2 3 0 3 6 1 3 1 5 5 4 3 9 9 0 4 7    5 3 5 5 8 7 3 3 5 5 8 5 11 10 8 10 3 6 6 6 7 7 8 8 12 9 6 10 8 7 10 8 8 10 4 6   12 20 4 6 11 7 9 10 7 5 10 6 12 11 7 13 13 16 12 6 8 14 13 9 7 5 14 17 17 10     12 11 6 13 11 17 3 23 13 21 12 21 28 11 23 30 28 23 24 26 26 17 21 15 27 23 33   16 22 25 11 20 22 23 21 20 7 21 13 16 12 16 16 13 18 18 9 13 16 15 9 20 13 19    15 8 9 11 14 13 10 9 10 16 15 14 17 15 19 16 12 14 12 14 14 16 19 19 4 24 8 12   15 16 11 15 14 20 14 13 13 14 16 19 14 13 19 14 18 23 15 15 4 14 17 14 8 10 15   20 11 15 19 12 9 13 12 11 16 12 16 13 14 16 13 16 16 19 19 12 11 10 19 15 15     14 12 5 11 18 17 10 13 12 9 6 2 0 0 1 0   0.174000 3.950 3.950 9.500      2675515           3           0  0 0 0 0 0 0 0 0 0 0 2 0 1 1 0 2 1 2 3 3 1 3 1 3 7 5 3 6 4 3 9 4 5 2 5 3 3 3 6    9 5 5 2 6 8 5 8 4 8 5 6 5 6 4 6 3 7 11 6 9 9 3 6 6 7 6 8 7 9 12 18 6 9 8 11 11   8 14 15 15 11 15 13 9 19 10 15 14 9 4 18 5 8 10 8 10 13 9 12 11 8 8 12 6 15 8    9 9 18 7 17 21 9 13 18 14 21 24 18 22 17 26 15 21 23 25 19 26 23 20 27 17 27     20 26 15 22 15 19 15 16 24 12 15 24 13 13 17 11 7 10 21 15 15 16 13 20 22 12     16 12 16 15 14 18 11 12 14 14 24 10 13 16 19 8 11 18 19 15 15 23 16 16 11 12     18 11 13 14 16 10 14 13 18 12 15 15 14 8 11 17 12 22 13 12 14 15 10 11 15 19     15 12 17 8 21 23 13 19 11 8 12 15 11 14 15 19 15 10 17 9 16 14 18 14 16 14 14    23 14 14 13 16 12 14 15 14 9 14 7 5 2 3 1 1 1   0.176000 4.000 4.000 9.600      2779386           5           0  0 0 0 0 0 0 0 0 0 0 0 2 2 3 0 1 3 0 6 2 6 3 1 5 0 4 1 6 5 1 6 3 6 5 6 2 5 4 5    3 9 8 5 7 5 8 4 12 8 12 6 8 5 7 5 7 10 5 5 6 7 9 7 10 7 10 10 8 12 10 6 13 10    11 12 11 10 10 16 9 6 12 9 11 17 10 11 10 14 11 16 7 11 13 12 10 17 14 11 13     12 10 13 16 16 17 17 15 14 11 8 15 13 27 22 14 19 17 22 22 27 18 28 19 27 32     24 33 21 17 23 12 27 25 20 20 17 22 14 15 22 21 14 9 16 12 19 16 17 16 16 20     14 18 15 14 18 10 12 9 16 12 12 10 13 19 12 12 15 14 15 22 12 11 15 18 19 18     10 6 11 14 10 23 17 14 16 19 10 10 16 19 17 23 16 18 19 18 16 12 14 14 14 13     11 10 24 21 22 26 18 18 18 14 17 5 13 17 11 13 16 14 18 16 9 15 15 18 16 14 21   13 22 17 9 8 16 17 16 16 19 7 20 19 18 16 10 6 10 6 3 5 1 0 0 2   0.178000 4.050 4.050 9.700      2869617           3           0  0 0 0 0 0 0 0 0 0 0 2 2 2 0 1 4 1 3 2 2 1 2 3 2 2 4 4 7 5 6 5 3 6 6 5 7 8 1 5    2 3 5 5 8 10 7 6 10 9 6 8 9 7 8 10 15 4 10 5 8 8 6 11 8 8 11 7 5 8 14 5 11 7     13 10 9 7 8 9 14 12 10 9 11 6 14 15 14 13 11 9 18 18 10 14 14 10 12 16 12 9 8    14 15 6 11 11 12 10 14 12 11 18 13 13 27 16 23 23 20 21 32 20 18 25 22 24 32     25 34 19 23 21 25 22 25 19 23 19 21 16 19 16 18 9 18 6 13 12 13 18 12 8 19 14    14 11 16 13 15 14 21 11 14 14 13 11 20 14 14 26 10 22 16 18 15 20 24 18 19 19    16 14 14 14 21 13 19 18 20 13 17 11 17 14 22 17 15 15 20 8 21 15 16 16 23 17     13 19 21 20 12 15 18 15 19 15 18 17 20 15 13 14 24 18 15 15 14 18 20 19 17 19    20 21 21 15 19 19 17 11 16 16 11 23 10 20 13 10 5 10 2 3 1 1 0   0.180000 4.100 4.100 9.800      2975040           3           0  0 0 0 0 0 0 0 0 1 0 0 1 2 2 4 4 2 4 4 1 2 5 0 3 3 5 2 5 5 4 9 2 7 8 4 8 3 11 6   10 4 7 8 6 6 5 8 8 7 11 4 4 11 12 7 11 7 10 11 7 11 11 10 9 7 13 12 18 8 14 12   14 12 8 8 16 10 10 14 16 10 6 8 15 15 15 22 13 19 18 12 6 11 10 7 12 12 24 15    17 9 17 21 10 17 18 14 14 14 9 22 11 23 17 15 23 32 20 11 12 20 15 23 30 20 25   19 26 29 19 27 23 15 19 11 30 16 21 24 18 18 14 8 6 25 13 21 13 13 19 13 21 25   23 18 14 14 13 20 12 14 8 10 25 14 15 20 15 10 15 16 21 8 15 20 21 20 13 16 15   20 11 18 17 17 9 12 24 19 13 18 17 20 14 15 20 10 23 19 25 8 7 13 14 11 15 18    13 10 12 10 17 11 24 16 17 11 12 13 16 20 14 26 12 17 13 14 16 16 6 20 16 23     22 11 17 16 14 25 19 17 21 22 19 13 19 16 18 10 11 7 4 6 0 0 2   0.182000 4.150 4.150 9.900      3083416           6           0  0 0 0 0 0 0 0 0 0 0 2 1 1 4 1 3 4 3 5 6 2 1 4 2 3 5 6 6 7 2 4 1 11 7 5 2 6 6 8   9 8 12 7 11 9 6 12 7 8 9 6 6 8 11 6 6 8 11 8 11 12 11 13 9 10 7 9 6 11 9 13 12   12 8 14 15 8 9 8 8 11 22 16 6 11 16 15 9 13 12 12 13 11 15 9 9 16 14 14 12 21    12 12 12 16 19 10 15 18 8 16 14 16 16 21 30 22 9 25 19 19 26 23 33 25 22 21 19   21 20 20 21 20 26 20 29 27 25 25 21 20 25 21 21 18 14 19 15 6 20 18 16 20 16     13 13 15 15 15 15 22 16 15 15 11 21 19 11 19 13 14 15 17 21 12 18 12 22 18 21    18 13 23 15 18 9 21 11 14 23 18 21 25 18 22 15 21 23 15 15 16 19 21 18 19 21     17 13 24 23 22 19 14 20 22 15 14 14 20 20 23 13 18 15 18 20 20 24 9 12 17 21     21 12 16 17 16 16 21 26 19 15 21 22 24 15 11 13 13 6 8 1 4 0 1 0   0.184000 4.200 4.200 10.00      3174897           3           0  0 0 0 0 0 0 0 0 0 0 1 1 2 3 0 5 4 3 3 0 7 3 2 4 2 8 6 4 5 9 3 8 6 4 2 7 6 8 7    9 3 5 8 5 9 7 7 6 11 14 7 12 9 9 5 15 12 14 15 12 9 11 5 8 13 11 12 10 9 17 12   11 8 17 11 19 11 15 9 11 7 15 14 16 16 16 7 12 10 14 13 13 16 16 11 15 13 14     12 16 11 12 13 17 10 13 19 11 17 11 13 14 13 10 19 19 23 24 22 24 24 31 19 23    22 28 21 25 29 17 23 17 21 30 22 19 25 27 27 22 23 23 17 25 17 20 17 12 23 21    9 17 20 16 19 16 17 20 9 16 11 22 16 15 12 15 17 23 24 16 16 18 26 11 16 20 18   10 14 17 26 19 17 15 17 19 12 21 20 24 17 27 13 16 18 19 23 14 19 14 10 11 18    19 6 15 21 23 25 17 17 18 21 27 20 17 18 20 25 22 20 18 22 18 17 15 24 16 15     22 18 22 14 20 20 22 18 22 25 19 26 12 19 19 13 12 16 19 14 9 7 5 4 2 0 2   0.186000 4.250 4.250 10.10      3283256           3           0  0 0 0 0 0 0 0 1 0 0 1 1 4 1 5 2 5 5 3 4 6 3 2 4 7 8 2 6 6 4 10 7 8 7 5 4 4 9 8   18 10 7 6 6 13 12 10 13 10 7 15 4 7 10 13 12 8 8 13 5 14 6 9 14 9 10 16 12 13    11 8 12 11 10 13 9 11 15 17 23 18 13 10 12 11 12 14 14 14 10 12 12 16 13 15 13   13 14 18 10 13 17 14 14 14 12 12 8 18 14 23 20 16 19 16 16 16 27 18 21 19 20     19 37 22 21 22 28 24 26 18 21 28 21 22 21 21 22 16 15 13 22 22 27 22 11 13 20    10 17 16 19 20 30 18 25 8 7 22 18 17 14 23 16 17 11 16 24 19 18 22 15 15 23 16   13 15 22 14 8 12 18 13 15 22 17 15 15 17 27 21 19 21 24 17 10 12 14 19 17 22     18 19 17 28 19 15 14 16 28 17 20 15 11 22 18 19 16 21 17 24 19 22 22 20 10 20    18 18 18 21 18 23 18 32 26 21 21 22 20 22 16 17 20 22 21 17 13 13 11 9 5 0 1 1   1   0.188000 4.300 4.300 10.20      3396610           5           0  0 0 0 0 0 0 0 0 0 0 1 2 3 0 2 5 5 4 3 3 5 1 2 3 6 9 3 3 3 8 7 2 9 5 7 5 11 8 9   7 6 9 6 4 5 8 6 10 9 14 10 15 6 7 13 15 10 13 7 15 10 10 11 14 14 6 7 17 13 19   3 13 9 6 13 13 14 10 11 12 16 17 13 10 15 15 19 19 11 11 15 11 13 9 13 20 8 18   14 18 23 23 23 15 19 20 14 11 7 18 16 15 22 28 20 24 22 25 17 20 39 24 26 25     25 33 25 25 25 33 15 29 18 29 18 12 18 23 17 24 28 22 16 20 33 23 18 23 26 23    15 24 16 16 16 16 17 15 15 16 14 11 9 23 17 13 13 18 12 19 20 30 20 20 15 21     19 16 18 20 23 19 15 10 11 15 19 13 22 22 18 19 16 19 23 16 10 25 23 20 21 20    31 19 19 18 15 22 18 14 13 21 18 19 22 19 16 17 21 14 20 26 18 26 22 19 26 19    20 22 15 13 24 23 15 21 21 21 27 18 22 19 24 17 22 16 18 23 10 12 3 5 3 3 0 0   0.190000 4.350 4.350 10.30      3502025           3           0  0 0 0 0 0 0 0 0 0 0 0 3 0 3 2 3 4 4 3 4 5 10 7 6 6 4 5 12 10 6 6 13 10 6 7 14    9 6 13 10 12 16 3 9 9 7 5 6 13 11 10 8 11 19 12 14 13 16 13 14 9 12 14 13 14     16 10 14 7 16 18 16 9 15 11 20 15 10 14 14 11 14 17 10 6 16 10 15 12 17 17 20    15 7 12 23 15 8 13 12 8 16 15 20 16 16 20 14 11 20 24 23 20 16 18 27 25 31 27    27 25 21 31 27 20 23 24 32 17 21 34 27 17 19 19 25 30 27 21 24 28 30 19 26 21    14 16 21 23 27 8 17 21 17 11 23 15 22 15 18 10 17 20 23 18 18 17 19 22 15 22     21 19 23 18 18 26 17 18 26 18 24 15 22 23 23 19 23 25 23 24 26 10 21 16 32 23    18 19 24 21 28 26 22 19 19 14 30 21 24 23 22 21 13 27 20 27 24 15 20 22 22 13    25 14 19 32 21 18 18 23 22 22 14 18 20 24 14 19 20 18 17 24 29 27 20 12 18 17    11 9 2 3 2 1 0   0.192000 4.400 4.400 10.40      3593938           3           0  0 0 0 0 0 0 0 0 0 0 1 0 1 1 2 3 4 7 8 1 5 6 8 3 7 5 4 9 8 8 7 7 9 7 9 9 15 5 7   8 15 14 9 9 13 8 8 15 10 7 10 9 10 14 7 8 18 16 17 11 14 15 13 8 15 8 15 18 16   16 22 12 8 16 13 10 13 13 10 21 11 10 16 16 13 13 17 16 20 23 13 22 16 14 15     22 19 22 15 22 24 16 16 16 19 12 15 16 17 20 18 19 26 17 23 18 32 20 28 36 22    25 30 29 31 36 24 24 21 29 24 32 29 30 23 34 19 33 34 25 20 31 27 24 16 14 21    20 13 24 17 28 13 24 16 26 15 26 21 11 15 20 13 20 18 25 23 18 24 26 22 16 22    14 13 16 20 24 25 19 29 20 15 20 16 25 26 21 22 17 24 22 21 17 23 23 15 19 30    23 17 21 19 18 21 26 14 29 24 20 33 19 15 20 23 28 19 23 25 15 19 17 31 23 18    29 26 25 14 24 25 18 19 19 24 35 31 23 23 14 15 19 11 20 19 24 17 16 9 10 12 3   2 2 0 1   0.194000 4.450 4.450 10.50      3712573           7           0  0 0 0 0 0 0 0 0 0 0 0 1 1 1 5 3 5 4 3 11 3 10 4 6 7 8 5 5 5 8 9 12 7 7 11 8 6    7 9 10 13 10 6 13 9 9 9 11 14 14 12 13 10 6 13 13 15 12 13 19 8 14 13 16 11 13   14 15 9 15 16 13 16 17 17 17 23 18 16 19 10 13 18 16 10 9 21 11 22 14 20 14 18   13 15 12 13 14 16 14 15 20 29 17 14 18 8 15 21 15 19 15 22 20 17 15 23 26 16     26 24 23 23 23 23 30 24 29 28 26 35 33 31 22 23 22 20 37 22 27 33 26 27 26 17    16 18 27 22 21 24 18 18 18 17 15 18 14 19 24 22 15 20 21 15 19 25 15 16 26 19    22 29 20 16 13 15 16 32 24 23 13 33 17 22 18 18 23 24 22 21 20 26 21 16 22 18    18 16 15 26 26 17 22 21 13 25 24 13 23 18 18 25 32 20 24 21 17 19 24 24 23 33    19 19 21 32 18 22 23 19 23 32 18 31 22 25 23 23 31 29 21 16 20 20 15 22 14 12    5 10 9 2 1 0 1   0.196000 4.500 4.500 10.60      3829518           3           0  0 0 0 0 0 0 0 0 0 1 2 2 1 6 2 6 5 9 3 5 6 8 6 3 8 10 7 11 9 4 8 9 5 11 10 13 9   16 13 10 9 5 12 9 15 10 13 9 12 18 14 19 9 13 14 12 13 21 17 17 18 16 13 12 16   14 18 10 15 15 16 11 15 22 17 19 17 11 12 26 12 17 19 18 21 20 27 17 18 19 21    14 19 16 12 16 21 20 18 8 17 17 13 13 18 15 19 15 19 20 28 21 29 27 27 34 24     26 31 25 24 16 17 23 23 30 28 18 28 32 28 37 18 26 18 16 33 21 31 21 20 22 19    20 25 18 18 20 11 17 20 22 23 14 14 17 18 20 25 20 19 20 22 19 16 33 25 21 21    24 18 16 22 29 22 16 27 26 28 21 20 22 17 25 23 20 23 18 16 19 26 22 21 22 23    15 20 19 17 23 19 20 15 22 18 22 26 23 23 31 17 29 18 13 15 19 18 24 22 28 22    17 23 24 26 21 23 25 24 29 26 18 41 24 29 22 27 23 28 16 30 24 18 23 19 17 18    21 17 14 8 2 5 2 0 0   0.198000 4.550 4.550 10.70      3950740           3           0  0 0 0 0 0 0 0 0 1 1 1 2 1 3 7 5 6 7 7 7 4 5 6 4 1 8 9 10 9 8 10 8 12 6 10 8 10   8 11 9 10 15 7 11 8 13 11 13 15 15 17 12 10 8 17 12 9 14 12 14 11 14 21 14 15    20 18 16 8 15 22 24 14 10 18 14 15 16 12 10 16 21 16 25 17 20 17 17 20 15 24     15 17 22 25 17 13 22 18 20 19 11 21 22 21 16 21 24 16 22 17 21 17 24 22 24 35    27 24 28 24 32 37 34 25 24 29 37 37 25 28 21 23 24 22 21 20 25 22 32 19 21 22    24 20 21 20 22 18 27 17 14 20 22 22 22 14 19 20 20 21 23 22 14 20 21 23 20 18    23 20 25 31 24 18 22 14 23 22 21 23 27 27 20 21 18 22 23 24 23 21 18 22 17 22    21 35 15 24 24 12 27 30 27 28 22 31 24 24 19 27 24 28 23 25 26 35 27 22 29 21    24 18 19 26 33 29 31 23 25 19 24 26 21 10 23 24 26 28 20 27 26 17 29 22 18 14    22 8 10 11 4 4 1 2 0   0.200000 4.600 4.600 10.80      4068161           5           0  0 0 0 0 0 0 0 0 0 1 1 0 1 5 5 2 9 3 11 6 9 8 7 7 8 3 3 13 10 8 7 5 8 13 8 7 14   12 10 7 15 13 13 11 12 12 14 12 13 12 10 15 11 14 7 16 15 8 15 13 15 13 18 13    17 21 15 12 13 13 17 18 18 18 16 19 20 17 14 17 24 13 12 18 19 19 13 21 18 26    21 23 16 14 18 19 13 33 13 19 20 14 20 23 14 26 19 22 21 21 16 27 30 25 28 22    32 21 30 27 31 21 30 22 27 27 31 27 21 17 38 41 17 21 20 19 30 24 27 20 20 21    30 20 19 19 31 25 24 13 21 23 19 24 33 24 17 20 17 12 25 23 18 24 11 24 25 22    33 20 11 22 31 21 20 26 27 21 26 24 14 23 23 20 20 26 28 10 20 27 24 22 17 27    28 20 23 23 33 20 24 26 32 33 29 21 25 24 17 18 19 27 26 20 24 26 24 24 26 21    19 24 21 36 32 18 33 33 20 23 25 33 19 27 25 27 24 27 21 21 23 28 18 27 25 19    24 15 17 12 15 7 2 1 0 0 ", "%f ", Inf);
 %! assert (rows (x) == n);
diff --git a/test/jit.tst b/test/jit.tst
--- a/test/jit.tst
+++ b/test/jit.tst
@@ -22,127 +22,127 @@
 %!testif HAVE_LLVM
 %! global __old_jit_enable__;
 %! global __old_jit_startcnt__;
 %! __old_jit_enable__ = jit_enable (true);
 %! __old_jit_startcnt__ = jit_startcnt (1000);
 
 ## Test some simple cases that compile.
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! for i=1:1e6
 %!   if (i < 5)
 %!     break;
 %!   else
 %!     break;
 %!   endif
 %! endfor
 %! assert (i, 1);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! while (1)
 %!   if (1)
 %!     break;
 %!   else
 %!     break;
 %!   endif
 %! endwhile
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! do
 %!   break;
 %! until (0)
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! do
 %!   if (1)
 %!     break;
 %!   end;
 %! until (0)
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! i=1;
 %! do
 %!   continue;
 %!   i=i+1;
 %! until (1)
 %! assert (i, 1);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! for i=1:1e6
 %!   if (i == 100)
 %!     break;
 %!   endif
 %! endfor
 %! assert (i, 100);
 %! assert (jit_failcnt, 0);
 
 ## Also test parfor keyword
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! parfor i=1:1e6
 %!   if (i == 100)
 %!     break;
 %!   endif
 %! endparfor
 %! assert (i, 100);
 %! assert (jit_failcnt, 0);
 ## Test some switch statements
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! do
 %!   switch (1)
 %!   end;
 %! until(1)
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! do
 %!   switch (1)
 %!   case 1
 %!     break;
 %!   end;
 %! until(1)
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! do
 %!   switch (1)
 %!   otherwise
 %!     break;
 %!   end;
 %! until(1)
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! do
 %!   switch (1)
 %!   case 1
 %!     break;
 %!   otherwise
 %!     break;
 %!   end;
 %! until(1)
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! i=0;
 %! a=0;
 %! b=0;
 %! do
 %!   i=i+1;
 %!   switch (i)
 %!   case 1
 %!     continue;
@@ -158,95 +158,95 @@
 %! until(0);
 %! assert (i, 4);
 %! assert (a, 6);
 %! assert (b, 1);
 %! assert (jit_failcnt, 0);
 
 ## Some more complex calculations
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! inc = 1e-5;
 %! result = 0;
 %! for ii = 0:inc:1
 %!   result = result + inc * (1/3 * ii * ii);
 %! endfor
 %! assert (abs (result - 1/9) < 1e-5);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! inc = 1e-5;
 %! result = 0;
 %! for ii = 0:inc:1
 %!   ## the ^ operator's result is complex
 %!   result = result + inc * (1/3 * ii ^ 2);
 %! endfor
 %! assert (abs (result - 1/9) < 1e-5);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! temp = 1+1i;
 %! nan = NaN;
 %! while (1)
 %!   temp = temp - 1i;
 %!   temp = temp * nan;
 %!   break;
 %! endwhile
 %! assert (imag (temp), 0);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! temp = 1+1i;
 %! nan = NaN+1i;
 %! while (1)
 %!   nan = nan - 1i;
 %!   temp = temp - 1i;
 %!   temp = temp * nan;
 %!   break;
 %! endwhile
 %! assert (imag (temp), 0);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! temp = 1+1i;
 %! while (1)
 %!   temp = temp * 5;
 %!   break;
 %! endwhile
 %! assert (temp, 5+5i);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! nr = 1001;
 %! mat = zeros (1, nr);
 %! for i = 1:nr
 %!   mat(i) = i;
 %! endfor
 %! assert (mat == 1:nr);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! nr = 1001;
 %! mat = 1:nr;
 %! mat(end) = 0; # force mat to a matrix
 %! total = 0;
 %! for i = 1:nr
 %!   total = mat(i) + total;
 %! endfor
 %! assert (sum (mat) == total);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! nr = 1001;
 %! mat = [3 1 5];
 %! try
 %!   for i = 1:nr
 %!     if (i > 500)
 %!       result = mat(100);
 %!     else
 %!       result = i;
@@ -286,76 +286,76 @@
 %!  endfor
 %!
 %!  if (counter > 0 && counter < K)
 %!    z(end-counter+1:end) = 0;
 %!  endif
 %!endfunction
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! test_set = gen_test (10000);
 %! assert (all (vectorized (test_set, 3) == loopy (test_set, 3)));
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! niter = 1001;
 %! i = 0;
 %! while (i < niter)
 %!   i = i + 1;
 %! endwhile
 %! assert (i == niter);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! niter = 1001;
 %! result = 0;
 %! m = [5 10];
 %! for i=1:niter
 %!   result = result + m(end);
 %! endfor
 %! assert (result == m(end) * niter);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! ndim = 100;
 %! result = 0;
 %! m = zeros (ndim);
 %! m(:) = 1:ndim^2;
 %! i = 1;
 %! while (i <= ndim)
 %!   for j = 1:ndim
 %!     result = result + m(i, j);
 %!    endfor
 %!   i = i + 1;
 %! endwhile
 %! assert (result == sum (sum (m)));
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! ndim = 100;
 %! m = zeros (ndim);
 %! i = 1;
 %! while (i <= ndim)
 %!   for j = 1:ndim
 %!     m(i, j) = (j - 1) * ndim + i;
 %!   endfor
 %!   i = i + 1;
 %! endwhile
 %! m2 = zeros (ndim);
 %! m2(:) = 1:(ndim^2);
 %! assert (all (m == m2));
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! ndim = 2;
 %! m = zeros (ndim, ndim, ndim, ndim);
 %! result = 0;
 %! i0 = 1;
 %! while (i0 <= ndim)
 %!   for i1 = 1:ndim
 %!     for i2 = 1:ndim
 %!       for i3 = 1:ndim
@@ -381,88 +381,88 @@
 %!     a / 0;
 %!   endfor
 %! unwind_protect_cleanup
 %!   warning (state, "Octave:divide-by-zero");
 %! end_unwind_protect
 %!endfunction
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! lasterr ("");
 %! try
 %!   test_divide ();
 %! end_try_catch
 %! assert (strcmp (lasterr (), "division by zero"));
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! while (1)
 %!   a = 0;
 %!   result = a / 1;
 %!   break;
 %! endwhile
 %! assert (result, 0);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! m = zeros (2, 1001);
 %! for i=1:1001
 %!   m(end, i) = i;
 %!   m(end - 1, end - i + 1) = i;
 %! endfor
 %! m2 = zeros (2, 1001);
 %! m2(1, :) = fliplr (1:1001);
 %! m2(2, :) = 1:1001;
 %! assert (m, m2);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! m = [1 2 3];
 %! for i=1:1001
 %!   m = sin (m);
 %!   break;
 %! endfor
 %! assert (m == sin ([1 2 3]));
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! i = 0;
 %! while i < 10
 %!   i += 1;
 %! endwhile
 %! assert (i == 10);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! i = 0;
 %! while i < 10
 %!   a = ++i;
 %! endwhile
 %! assert (i == 10);
 %! assert (a == 10);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! i = 0;
 %! while i < 10
 %!   a = i++;
 %! endwhile
 %! assert (i == 10);
 %! assert (a == 9);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! num = 2;
 %! a = zeros (1, num);
 %! i = 1;
 %! while i <= num
 %!   a(i) = norm (eye (i));
 %!   ++i;
 %! endwhile
 %! assert (a, ones (1, num));
@@ -476,33 +476,33 @@
 %!     endif;
 %!     li++;
 %!   else
 %!     si++;
 %!   endif;
 %! endwhile
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! lasterr ("");
 %! try
 %!   test_compute_idom ();
 %! end_try_catch
 %! assert (! isempty (lasterr ()));
 %! assert (jit_failcnt, 1);
 
 %!function x = test_overload (a)
 %!  while (1)
 %!    x = a;
 %!    break;
 %!  endwhile
 %!endfunction
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! assert (test_overload (1), 1);
 %! assert (test_overload ([1 2]), [1 2]);
 %! assert (jit_failcnt, 0);
 
 %!function a = bubble (a = [3 2 1])
 %!  swapped = 1;
 %!  n = length (a);
 %!  while (swapped)
@@ -514,75 +514,75 @@
 %!        a(i) = a(i + 1);
 %!        a(i + 1) = temp;
 %!      endif
 %!    endfor
 %!  endwhile
 %!endfunction
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! assert (bubble (), [1 2 3]);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! a = 0;
 %! b = 1;
 %! for i=1:1e3
 %!   for j=1:2
 %!     a = a + b;
 %!   endfor
 %! endfor
 %! assert (a, 2000);
 %! assert (b, 1);
 %! assert (jit_failcnt, 0);
 
 %!xtest
 %! ## FIXME: No support for functions with complex input prototypes
 %! ## testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! a = [1+1i 1+2i];
 %! b = 0;
 %! while (1)
 %!   b = a(1);
 %!   break;
 %! endwhile
 %! assert (b, a(1));
 %! assert (jit_failcnt, 0);
 
 %!function test_undef ()
 %!  for i=1:1e7
 %!    XXX;
 %!  endfor
 %!endfunction
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! lasterr ("");
 %! try
 %!   test_undef ();
 %! end_try_catch
 %! assert (strncmp (lasterr (), "'XXX' undefined near", 20));
 %! assert (jit_failcnt, 1);
 
 %!shared id
 %! id = @(x) x;
 
 %!xtest
 %! ## FIXME: No support for functions with complex input prototypes
 %! ## testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! assert (id (1), 1);
 %! assert (id (1+1i), 1+1i);
 %! assert (id (1, 2), 1);
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
-%! jit_failcnt (0)
+%! jit_failcnt (0);
 %! lasterr ("");
 %! try
 %!   id ();
 %! end_try_catch
 %! assert (strncmp (lasterr (), "'x' undefined near", 18));
 %! assert (jit_failcnt, 0);
 
 ## Restore JIT settings
diff --git a/test/null-assign.tst b/test/null-assign.tst
--- a/test/null-assign.tst
+++ b/test/null-assign.tst
@@ -12,59 +12,59 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %!test
-%! a = 1:3; a(:) = []; assert (size (a), [0, 0])
+%! a = 1:3; a(:) = []; assert (size (a), [0, 0]);
 %!test
-%! a = 1:3; a(1:3) = []; assert (size (a), [1, 0])
+%! a = 1:3; a(1:3) = []; assert (size (a), [1, 0]);
 %!test
-%! a = (1:3).'; a(1:3) = []; assert (size (a), [0, 1])
+%! a = (1:3).'; a(1:3) = []; assert (size (a), [0, 1]);
 %!test
-%! a = ones (3); a(:,:) = []; assert (size (a), [0, 3])
+%! a = ones (3); a(:,:) = []; assert (size (a), [0, 3]);
 %!test
-%! a = ones (3); a(1:3,:) = []; assert (size (a), [0, 3])
+%! a = ones (3); a(1:3,:) = []; assert (size (a), [0, 3]);
 %!test
-%! a = ones (3); a(:,1:3) = []; assert (size (a), [3, 0])
+%! a = ones (3); a(:,1:3) = []; assert (size (a), [3, 0]);
 %!test
 %! a = ones (3); fail ("a(1:2,1:2) = []", ".*");
 %!test
 %! a = ones (3); fail ("a(1:3,1:3) = []", ".*");
 
 ## null strings should delete. [,] and [;] should delete.
 %!test
-%! a = ones (3); a(1:2,:) = [,]; assert (size (a), [1,3])
+%! a = ones (3); a(1:2,:) = [,]; assert (size (a), [1,3]);
 %!test
-%! a = ones (3); a(1:2,:) = [;]; assert (size (a), [1,3])
+%! a = ones (3); a(1:2,:) = [;]; assert (size (a), [1,3]);
 %!test
-%! a = ones (3); a(1:2,:) = ''; assert (size (a), [1,3])
+%! a = ones (3); a(1:2,:) = ''; assert (size (a), [1,3]);
 %!test
-%! a = ones (3); a(1:2,:) = ""; assert (size (a), [1,3])
+%! a = ones (3); a(1:2,:) = ""; assert (size (a), [1,3]);
 
 ## null matrix stored anywhere should lose its special status
 %!test
-%! a = ones (3); b = []; fail ("a(:,1:3) = b", ".")
+%! a = ones (3); b = []; fail ("a(:,1:3) = b", ".");
 %!test
-%! a = ones (3); b{1} = []; fail ("a(:,1:3) = b{1}", ".")
+%! a = ones (3); b{1} = []; fail ("a(:,1:3) = b{1}", ".");
 %!test
-%! a = ones (3); b.x = []; fail ("a(:,1:3) = b.x", ".")
+%! a = ones (3); b.x = []; fail ("a(:,1:3) = b.x", ".");
 
 ## filtering a null matrix through a function should not delete
 %!test
-%! a = ones (3); fail ("a(:,1:3) = double ([])")
+%! a = ones (3); fail ("a(:,1:3) = double ([])");
 
 ## subsasgn should work the same way
 %!test
-%! a = ones (3); a = subsasgn (a, substruct ('()', {':',1:2}), []); assert (size (a), [3,1])
+%! a = ones (3); a = subsasgn (a, substruct ('()', {':',1:2}), []); assert (size (a), [3,1]);
 %!test
-%! a = ones (3); b = []; fail ("subsasgn (a, substruct ('()', {':',1:2}), b)", ".")
+%! a = ones (3); b = []; fail ("subsasgn (a, substruct ('()', {':',1:2}), b)", ".");
 
 %!test
 %! classes = {@int8, @int16, @int32, @int64, ...
 %!   @uint8, @uint16, @uint32, @uint64, ...
 %!   @single, @double, @logical};
 %! for i = 1:numel (classes)
 %!   cls = classes{i};
 %!   x = cls ([1, 2, 3]);
diff --git a/test/parser.tst b/test/parser.tst
--- a/test/parser.tst
+++ b/test/parser.tst
@@ -85,28 +85,28 @@
 %! assert (0 || a --, true);
 %! a = 5; b = 2;
 %! b +=a ++;
 %! assert (b, 7);
 
 ## Level 11 (transpose and exponentiation)
 %!test
 %! a = 2;
-%! assert (2 ^a++, 4)
-%! assert (a, 3)
-%! assert (2 ^--a ^2, 16)
-%! assert (a, 2)
-%! assert (2 ^++a, 8)
-%! assert (a, 3)
-%! assert (a' ^2, 9)
-%! assert (2 ^sin(0), 1)
-%! assert (-2 ^2, -4);
-%! assert (2 ^+1 ^3, 8)
-%! assert (2 ^-1 ^3, 0.125)
-%! assert (2 ^~0 ^2, 4)
+%! assert (2 ^a++, 4);
+%! assert (a, 3);
+%! assert (2 ^--a ^2, 16);
+%! assert (a, 2);
+%! assert (2 ^++a, 8);
+%! assert (a, 3);
+%! assert (a' ^2, 9);
+%! assert (2 ^sin(0), 1);
+%! assert (-2 ^2, -4);;
+%! assert (2 ^+1 ^3, 8);
+%! assert (2 ^-1 ^3, 0.125);
+%! assert (2 ^~0 ^2, 4);
 %! assert (!0 ^0, false);
 %! assert (2*3 ^2, 18);
 %! assert (2+3 ^2, 11);
 %! assert ([1:10](1:2 ^2), [1 2 3 4]);
 %! assert (3>2 ^2, false);
 %! assert (1&0 ^0, true);
 %! assert (0|0 ^0, true);
 %! assert (1&&0 ^0, true);
@@ -310,13 +310,13 @@
 %!      'b'];
 %! assert (a, 'ab');
 
 ## Check that a cell array containing function handles is parsed
 ## correctly with or without commas.
 %!test
 %! a = {1, @sin, 2, @cos};
 %! b = {1 @sin 2 @cos};
-%! assert (a, b)
+%! assert (a, b);
 
 ## Maybe unnecessary, but check that further changes to parser don't
 ## invalidate error handling (bug #46534).
 #!error <vertical dimensions mismatch \(1x2 vs 1x1\)> z = [1, 2; 3]
diff --git a/test/struct.tst b/test/struct.tst
--- a/test/struct.tst
+++ b/test/struct.tst
@@ -133,18 +133,17 @@
 %! assert ({b.name}, {"e", "b", "b", "e", "d", "a"});
 
 ## test internal ordering of struct array fields
 %!test
 %! c(4, 4, 4, 4).value = 3;
 %! c(1, 2, 3, 4).value = 2;
 %! c(3, 3, 3, 3).value = 1;
 %! d = reshape ({c.value}, size (c));
-%! assert ([d{4, 4, 4, 4}, d{1, 2, 3, 4}, d{3, 3, 3, 3}],
-%!         [3, 2, 1]);
+%! assert ([d{4, 4, 4, 4}, d{1, 2, 3, 4}, d{3, 3, 3, 3}], [3, 2, 1]);
 
 ## test assignment to mixed cs-list of field element subranges
 %!test
 %! b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 100);
 %! [b(1:2, [1, 3]).name, b(2, 1:3).value] = ...
 %!   deal (1, 2, 3, 4, "5", "6", "7");
 %! assert ({b.name}, {1, 2, "b", "e", 3, 4});
 %! assert ({b.value}, {100, "5", 100, "6", 100, "7"});
diff --git a/test/system.tst b/test/system.tst
--- a/test/system.tst
+++ b/test/system.tst
@@ -124,48 +124,48 @@
 %!   umask (orig_umask);
 %! endif
 
 %!error <Invalid call to umask> umask ()
 %!error <Invalid call to umask> umask (1, 2)
 
 %!test
 %! [s, err, msg] = stat (filesep);
-%! assert ((err == 0
-%! && isstruct (s)
-%! && isfield (s, "dev")
-%! && isfield (s, "ino")
-%! && isfield (s, "modestr")
-%! && isfield (s, "nlink")
-%! && isfield (s, "uid")
-%! && isfield (s, "gid")
-%! && isfield (s, "size")
-%! && isfield (s, "atime")
-%! && isfield (s, "mtime")
-%! && isfield (s, "ctime")
-%! && ischar (msg)));
+%! assert (err == 0
+%!         && isstruct (s)
+%!         && isfield (s, "dev")
+%!         && isfield (s, "ino")
+%!         && isfield (s, "modestr")
+%!         && isfield (s, "nlink")
+%!         && isfield (s, "uid")
+%!         && isfield (s, "gid")
+%!         && isfield (s, "size")
+%!         && isfield (s, "atime")
+%!         && isfield (s, "mtime")
+%!         && isfield (s, "ctime")
+%!         && ischar (msg));
 
 %!error <Invalid call to stat> stat ()
 %!error <Invalid call to stat> stat ("foo", 1)
 
 %!test
 %! [s, err, msg] = lstat (filesep);
-%! assert ((err == 0
-%! && isstruct (s)
-%! && isfield (s, "dev")
-%! && isfield (s, "ino")
-%! && isfield (s, "modestr")
-%! && isfield (s, "nlink")
-%! && isfield (s, "uid")
-%! && isfield (s, "gid")
-%! && isfield (s, "size")
-%! && isfield (s, "atime")
-%! && isfield (s, "mtime")
-%! && isfield (s, "ctime")
-%! && ischar (msg)));
+%! assert (err == 0
+%!         && isstruct (s)
+%!         && isfield (s, "dev")
+%!         && isfield (s, "ino")
+%!         && isfield (s, "modestr")
+%!         && isfield (s, "nlink")
+%!         && isfield (s, "uid")
+%!         && isfield (s, "gid")
+%!         && isfield (s, "size")
+%!         && isfield (s, "atime")
+%!         && isfield (s, "mtime")
+%!         && isfield (s, "ctime")
+%!         && ischar (msg));
 
 %!error <Invalid call to lstat> lstat ()
 %!error <Invalid call to lstat> lstat ("foo", 1)
 
 %!test
 %! if (isunix ())
 %!   assert (S_ISCHR (stat ("/dev/null").mode));
 %!   if (exist ("/dev/initctl"))
@@ -291,24 +291,24 @@
 
 %!error cd (1)
 
 %!assert (ischar (pwd ()))
 
 %!testif HAVE_GETPWENT
 %! s = getpwent ();
 %! endpwent ();
-%! assert ((isstruct (s)
-%! && isfield (s, "name")
-%! && isfield (s, "passwd")
-%! && isfield (s, "uid")
-%! && isfield (s, "gid")
-%! && isfield (s, "gecos")
-%! && isfield (s, "dir")
-%! && isfield (s, "shell")));
+%! assert (isstruct (s)
+%!         && isfield (s, "name")
+%!         && isfield (s, "passwd")
+%!         && isfield (s, "uid")
+%!         && isfield (s, "gid")
+%!         && isfield (s, "gecos")
+%!         && isfield (s, "dir")
+%!         && isfield (s, "shell"));
 
 %!error <Invalid call to getpwent> getpwent (1)
 
 %!testif HAVE_GETPWUID
 %! x = getpwent ();
 %! y = getpwuid (x.uid);
 %! endpwent ();
 %! assert (strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
@@ -333,21 +333,21 @@
 %! assert (strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
 
 %!error <Invalid call to setpwent> setpwent (1)
 %!error <Invalid call to endpwent> endpwent (1)
 
 %!testif HAVE_GETGRENT
 %! x = getgrent ();
 %! endgrent ();
-%! assert ((isstruct (x)
-%! && isfield (x, "name")
-%! && isfield (x, "passwd")
-%! && isfield (x, "gid")
-%! && isfield (x, "mem")));
+%! assert (isstruct (x)
+%!         && isfield (x, "name")
+%!         && isfield (x, "passwd")
+%!         && isfield (x, "gid")
+%!         && isfield (x, "mem"));
 
 %!error <Invalid call to getgrent> getgrent (1)
 
 %!testif HAVE_GETGRGID
 %! x = getgrent ();
 %! y = getgrgid (x.gid);
 %! endgrent ();
 %! assert (strcmp (x.name, y.name) && x.gid == y.gid);
