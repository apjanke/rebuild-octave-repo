# HG changeset patch
# User Jacob Dawid <jacob.dawid@googlemail.com>
# Date 1314109943 -7200
#      Tue Aug 23 16:32:23 2011 +0200
# Node ID 484a487f39991f3c6a6a27488d38075fc7e4d7a7
# Parent  8afea6b9e6dfc84c39b43181334f485a856c195d
Removed KProcess.

diff --git a/gui/octave-gui.pro b/gui/octave-gui.pro
--- a/gui/octave-gui.pro
+++ b/gui/octave-gui.pro
@@ -53,20 +53,17 @@ mac {
 }
 
 QMAKE_LFLAGS        += $$LFLAGS -lutil $$system(mkoctfile -p RLD_FLAG)
 QMAKE_CXXFLAGS      += $$INCFLAGS
 
 # Files associated with the project:
 SOURCES +=\
         src/lexer/lexeroctavegui.cpp \
-        src/terminal/Pty.cpp \
         src/terminal/kpty.cpp \
-        src/terminal/kptyprocess.cpp \
-        src/terminal/kprocess.cpp \
         src/terminal/kptydevice.cpp \
         src/MainWindow.cpp \
     	  src/OctaveTerminal.cpp \
     	  src/VariablesDockWidget.cpp \
     	  src/HistoryDockWidget.cpp \
     	  src/FilesDockWidget.cpp \
     	  src/FileEditorMdiSubWindow.cpp \
     	  src/BrowserWidget.cpp \
@@ -81,21 +78,18 @@ SOURCES +=\
     src/backend/OctaveMainThread.cpp \
     src/qirc/IRCClientImpl.cpp \
     src/terminal/TerminalEmulation.cpp \
     src/terminal/LinuxTerminalEmulation.cpp \
     src/backend/ReadlineAdapter.cpp
 
 HEADERS += \
         src/lexer/lexeroctavegui.h \
-        src/terminal/Pty.h \
         src/terminal/kpty.h \
         src/terminal/kpty_p.h \
-        src/terminal/kptyprocess.h \
-        src/terminal/kprocess.h \
         src/terminal/kptydevice.h \
     	  src/MainWindow.h \
     	  src/OctaveTerminal.h \
     	  src/VariablesDockWidget.h \
     	  src/HistoryDockWidget.h \
     	  src/FilesDockWidget.h \
     	  src/FileEditorMdiSubWindow.h \
     	  src/BrowserWidget.h \
diff --git a/gui/src/terminal/LinuxTerminalEmulation.cpp b/gui/src/terminal/LinuxTerminalEmulation.cpp
--- a/gui/src/terminal/LinuxTerminalEmulation.cpp
+++ b/gui/src/terminal/LinuxTerminalEmulation.cpp
@@ -7,75 +7,79 @@ LinuxTerminalEmulation::LinuxTerminalEmu
   if (openpty (&fdm, &fds, 0, 0, 0) < 0)
     {
       assert (0);
     }
   dup2 (fds, STDIN_FILENO);
   dup2 (fds, STDOUT_FILENO);
   dup2 (fds, STDERR_FILENO);
 
-  m_pty = new Pty (fdm);
-  connect (m_pty, SIGNAL(receivedData(QByteArray)),
-           this, SLOT(handleReceivedData(QByteArray)));
+  m_pty = new KPtyDevice ();
+  m_pty->open (fdm);
+  //m_pty->setPtyChannels (KPtyProcess::AllChannels);
+  connect (m_pty, SIGNAL(readyRead ()),
+           this, SLOT (handleReadyRead ()));
 }
 
 LinuxTerminalEmulation::~LinuxTerminalEmulation ()
 {
-  m_pty->terminate ();
+  //m_pty->terminate ();
 }
 
 void LinuxTerminalEmulation::processKeyEvent (QKeyEvent *keyEvent)
 {
   switch (keyEvent->key ())
     {
       case Qt::Key_PageUp:
       //if (verticalScrollBar ())
       //  verticalScrollBar ()->setValue (verticalScrollBar ()->value () - 10);
       return;
       case Qt::Key_PageDown:
       //if (verticalScrollBar ())
       //  verticalScrollBar ()->setValue (verticalScrollBar ()->value () + 10);
       return;
 
       case Qt::Key_Up:
-      m_pty->sendData ("\033OA");
+      m_pty->write ("\033OA");
       break;
 
       case Qt::Key_Down:
-      m_pty->sendData ("\033OB");
+      m_pty->write ("\033OB");
       break;
 
       case Qt::Key_Right:
-      m_pty->sendData ("\033OC");
+      m_pty->write ("\033OC");
       break;
 
       case Qt::Key_Left:
-      m_pty->sendData ("\033OF");
+      m_pty->write ("\033OF");
       break;
 
       //case Qt::Key_Backspace:
       //m_pty->sendData ("\03308");
       //break;
 
       default:
-      m_pty->sendData (keyEvent->text ().toAscii ());
+      m_pty->write (keyEvent->text ().toAscii ());
       break;
     }
   keyEvent->accept ();
 }
 
 void
 LinuxTerminalEmulation::transmitText (const QString &text)
 {
-  m_pty->sendData (text.toLocal8Bit ());
+  m_pty->write (text.toLocal8Bit ());
 }
 
 void
-LinuxTerminalEmulation::handleReceivedData (const QByteArray& data)
+LinuxTerminalEmulation::handleReadyRead ()
 {
+  QByteArray data = m_pty->readAll ();
+
   int position;
   QTextCursor tc = m_terminal->textCursor ();
   tc.movePosition (QTextCursor::End);
 
   // Decode data into cursor actions.
   foreach(QChar character, data)
     {
       unsigned short unicode = character.unicode ();
diff --git a/gui/src/terminal/LinuxTerminalEmulation.h b/gui/src/terminal/LinuxTerminalEmulation.h
--- a/gui/src/terminal/LinuxTerminalEmulation.h
+++ b/gui/src/terminal/LinuxTerminalEmulation.h
@@ -1,29 +1,28 @@
 #ifndef LINUXTERMINALEMULATION_H
 #define LINUXTERMINALEMULATION_H
 
 #include "TerminalEmulation.h"
-#include "Pty.h"
-
 #include "pty.h"
 #include "unistd.h"
 #include <assert.h>
 #include <cstdio>
+#include "kptydevice.h"
 
 class LinuxTerminalEmulation : public TerminalEmulation
 {
   Q_OBJECT
 public:
   LinuxTerminalEmulation ();
   ~LinuxTerminalEmulation ();
 
   void processKeyEvent (QKeyEvent *keyEvent);
   void transmitText (const QString &text);
 
 private slots:
-  void handleReceivedData (const QByteArray& data);
+  void handleReadyRead ();
 
 private:
-  Pty *m_pty;
+  KPtyDevice *m_pty;
 };
 
 #endif // LINUXTERMINALEMULATION_H
diff --git a/gui/src/terminal/Pty.cpp b/gui/src/terminal/Pty.cpp
deleted file mode 100644
--- a/gui/src/terminal/Pty.cpp
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
-    This file is part of Konsole, an X terminal.
-    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA.
-*/
-
-// Own
-#include "kptyprocess.h"
-#include "Pty.h"
-
-// System
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <errno.h>
-#include <termios.h>
-#include <signal.h>
-
-// Qt
-#include <QtCore/QStringList>
-
-#include "kpty.h"
-#include "kptydevice.h"
-
-
-Pty::Pty (int masterFd, QObject * parent):
-KPtyProcess (masterFd, parent)
-{
-  connect (pty (), SIGNAL (readyRead ()), this, SLOT (dataReceived ()));
-  setPtyChannels (KPtyProcess::AllChannels);
-}
-
-Pty::~Pty ()
-{
-}
-
-void
-Pty::sendData (const QByteArray& data)
-{
-  if (!data.length ())
-    return;
-  pty ()->write (data);
-}
-
-void
-Pty::dataReceived ()
-{
-  emit receivedData (pty ()->readAll ());
-}
diff --git a/gui/src/terminal/Pty.h b/gui/src/terminal/Pty.h
deleted file mode 100644
--- a/gui/src/terminal/Pty.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
-    This file is part of Konsole, KDE's terminal emulator. 
-    
-    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
-    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA.
-*/
-
-#ifndef PTY_H
-#define PTY_H
-
-// Qt
-#include <QtCore/QStringList>
-#include <QtCore/QVector>
-#include <QtCore/QList>
-#include <QtCore/QSize>
-
-// KDE
-#include "kptyprocess.h"
-
-/**
- * The Pty class is used to start the terminal process, 
- * send data to it, receive data from it and manipulate 
- * various properties of the pseudo-teletype interface
- * used to communicate with the process.
- *
- * To use this class, construct an instance and connect
- * to the sendData slot and receivedData signal to
- * send data to or receive data from the process.
- *
- * To start the terminal process, call the start() method
- * with the program name and appropriate arguments. 
- */
-class Pty:public KPtyProcess
-{
-Q_OBJECT public:
-
-    /** 
-     * Construct a process using an open pty master.
-     * See KPtyProcess::KPtyProcess()
-     */
-  explicit Pty (int ptyMasterFd, QObject * parent = 0);
-   ~Pty ();
-
-  public slots:
-    /** 
-     * Sends data to the process currently controlling the 
-     * teletype ( whose id is returned by foregroundProcessGroup() )
-     *
-     */
-  void sendData (const QByteArray& data);
-
-    signals:
-    /**
-     * Emitted when a new block of data is received from
-     * the teletype.
-     *
-     */
-  void receivedData (const QByteArray& data);
-
-private slots:
-  // called when data is received from the terminal process
-  void dataReceived ();
-
-};
-
-#endif // PTY_H
diff --git a/gui/src/terminal/kprocess.cpp b/gui/src/terminal/kprocess.cpp
deleted file mode 100644
--- a/gui/src/terminal/kprocess.cpp
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
-    This file is part of the KDE libraries
-
-    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-
-#include "kprocess.h"
-
-#include <qfile.h>
-#include <unistd.h>
-#include <errno.h>
-
-#define STD_OUTPUT_HANDLE 1
-#define STD_ERROR_HANDLE 2
-
-void
-KProcessPrivate::writeAll (const QByteArray & buf, int fd)
-{
-  int off = 0;
-  do
-    {
-      int ret =::write (fd, buf.data () + off, buf.size () - off);
-      if (ret < 0)
-	{
-	  if (errno != EINTR)
-	    return;
-	}
-      else
-	{
-	  off += ret;
-	}
-    }
-  while (off < buf.size ());
-}
-
-void
-KProcessPrivate::forwardStd (KProcess::ProcessChannel good, int fd)
-{
-  Q_Q (KProcess);
-
-  QProcess::ProcessChannel oc = q->readChannel ();
-  q->setReadChannel (good);
-  writeAll (q->readAll (), fd);
-  q->setReadChannel (oc);
-}
-
-void
-KProcessPrivate::_k_forwardStdout ()
-{
-  forwardStd (KProcess::StandardOutput, STD_OUTPUT_HANDLE);
-}
-
-void
-KProcessPrivate::_k_forwardStderr ()
-{
-  forwardStd (KProcess::StandardError, STD_ERROR_HANDLE);
-}
-
-/////////////////////////////
-// public member functions //
-/////////////////////////////
-
-KProcess::KProcess (QObject * parent):
-QProcess (parent), d_ptr (new KProcessPrivate)
-{
-  d_ptr->q_ptr = this;
-  setOutputChannelMode (ForwardedChannels);
-}
-
-KProcess::KProcess (KProcessPrivate * d, QObject * parent):
-QProcess (parent), d_ptr (d)
-{
-  d_ptr->q_ptr = this;
-  setOutputChannelMode (ForwardedChannels);
-}
-
-KProcess::~KProcess ()
-{
-  delete d_ptr;
-}
-
-void
-KProcess::setOutputChannelMode (OutputChannelMode mode)
-{
-  Q_D (KProcess);
-
-  d->outputChannelMode = mode;
-  disconnect (this, SIGNAL (readyReadStandardOutput ()));
-  disconnect (this, SIGNAL (readyReadStandardError ()));
-  switch (mode)
-    {
-    case OnlyStdoutChannel:
-      connect (this, SIGNAL (readyReadStandardError ()),
-	       SLOT (_k_forwardStderr ()));
-      break;
-    case OnlyStderrChannel:
-      connect (this, SIGNAL (readyReadStandardOutput ()),
-	       SLOT (_k_forwardStdout ()));
-      break;
-    default:
-      QProcess::setProcessChannelMode ((ProcessChannelMode) mode);
-      return;
-    }
-  QProcess::setProcessChannelMode (QProcess::SeparateChannels);
-}
-
-KProcess::OutputChannelMode KProcess::outputChannelMode () const
-{
-  Q_D (const KProcess);
-
-  return d->outputChannelMode;
-}
-
-
-
-
-void
-KProcess::setProgram (const QString & exe, const QStringList & args)
-{
-  Q_D (KProcess);
-
-  d->prog = exe;
-  d->args = args;
-}
-
-void
-KProcess::setProgram (const QStringList & argv)
-{
-  Q_D (KProcess);
-
-  Q_ASSERT (!argv.isEmpty ());
-  d->args = argv;
-  d->prog = d->args.takeFirst ();
-}
-
-KProcess & KProcess::operator<< (const QString & arg)
-{
-  Q_D (KProcess);
-
-  if (d->prog.isEmpty ())
-    d->prog = arg;
-  else
-    d->args << arg;
-  return *this;
-}
-
-KProcess & KProcess::operator<< (const QStringList & args)
-{
-  Q_D (KProcess);
-
-  if (d->prog.isEmpty ())
-    setProgram (args);
-  else
-    d->args << args;
-  return *this;
-}
-
-void
-KProcess::clearProgram ()
-{
-  Q_D (KProcess);
-
-  d->prog.clear ();
-  d->args.clear ();
-}
-
-QStringList
-KProcess::program () const
-{
-  Q_D (const KProcess);
-
-  QStringList argv = d->args;
-  argv.prepend (d->prog);
-  return argv;
-}
-
-void
-KProcess::start ()
-{
-  Q_D (KProcess);
-
-  QProcess::start (d->prog, d->args, d->openMode);
-}
-
-int
-KProcess::execute (int msecs)
-{
-  start ();
-  if (!waitForFinished (msecs))
-    {
-      kill ();
-      waitForFinished (-1);
-      return -2;
-    }
-  return (exitStatus () == QProcess::NormalExit) ? exitCode () : -1;
-}
-
-// static
-int
-KProcess::execute (const QString & exe, const QStringList & args, int msecs)
-{
-  KProcess p;
-  p.setProgram (exe, args);
-  return p.execute (msecs);
-}
-
-// static
-int
-KProcess::execute (const QStringList & argv, int msecs)
-{
-  KProcess p;
-  p.setProgram (argv);
-  return p.execute (msecs);
-}
-
-int
-KProcess::startDetached ()
-{
-  Q_D (KProcess);
-
-  qint64 pid;
-  if (!QProcess::startDetached (d->prog, d->args, workingDirectory (), &pid))
-    return 0;
-  return (int) pid;
-}
-
-// static
-int
-KProcess::startDetached (const QString & exe, const QStringList & args)
-{
-  qint64 pid;
-  if (!QProcess::startDetached (exe, args, QString (), &pid))
-    return 0;
-  return (int) pid;
-}
-
-// static
-int
-KProcess::startDetached (const QStringList & argv)
-{
-  QStringList args = argv;
-  QString prog = args.takeFirst ();
-  return startDetached (prog, args);
-}
-
-int
-KProcess::pid () const
-{
-  return (int) QProcess::pid ();
-}
diff --git a/gui/src/terminal/kprocess.h b/gui/src/terminal/kprocess.h
deleted file mode 100644
--- a/gui/src/terminal/kprocess.h
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
-    This file is part of the KDE libraries
-
-    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-
-#ifndef KPROCESS_H
-#define KPROCESS_H
-
-#include <QtCore/QProcess>
-class KProcess;
-class KProcessPrivate;
-
-
-/**
- * \class KProcess kprocess.h <KProcess>
- * 
- * Child process invocation, monitoring and control.
- *
- * This class extends QProcess by some useful functionality, overrides
- * some defaults with saner values and wraps parts of the API into a more
- * accessible one.
- * This is the preferred way of spawning child processes in KDE; don't
- * use QProcess directly.
- *
- * @author Oswald Buddenhagen <ossi@kde.org>
- **/
-class KProcess:public QProcess
-{
-Q_OBJECT Q_DECLARE_PRIVATE (KProcess) public:
-
-    /**
-     * Modes in which the output channels can be opened.
-     */
-  enum OutputChannelMode
-  {
-    SeparateChannels = QProcess::SeparateChannels,
-	    /**< Standard output and standard error are handled by KProcess
-                 as separate channels */
-    MergedChannels = QProcess::MergedChannels,
-	    /**< Standard output and standard error are handled by KProcess
-                 as one channel */
-    ForwardedChannels = QProcess::ForwardedChannels,
-	    /**< Both standard output and standard error are forwarded
-                 to the parent process' respective channel */
-    OnlyStdoutChannel,
-	    /**< Only standard output is handled; standard error is forwarded */
-    OnlyStderrChannel	   /**< Only standard error is handled; standard output is forwarded */
-  };
-
-    /**
-     * Constructor
-     */
-  explicit KProcess (QObject * parent = 0);
-
-    /**
-     * Destructor
-     */
-    virtual ~ KProcess ();
-
-    /**
-     * Set how to handle the output channels of the child process.
-     *
-     * The default is ForwardedChannels, which is unlike in QProcess.
-     * Do not request more than you actually handle, as this output is
-     * simply lost otherwise.
-     *
-     * This function must be called before starting the process.
-     *
-     * @param mode the output channel handling mode
-     */
-  void setOutputChannelMode (OutputChannelMode mode);
-
-    /**
-     * Query how the output channels of the child process are handled.
-     *
-     * @return the output channel handling mode
-     */
-  OutputChannelMode outputChannelMode () const;
-
-
-    /**
-     * Set the program and the command line arguments.
-     *
-     * This function must be called before starting the process, obviously.
-     *
-     * @param exe the program to execute
-     * @param args the command line arguments for the program,
-     *   one per list element
-     */
-  void setProgram (const QString & exe, const QStringList & args =
-		   QStringList ());
-
-    /**
-     * @overload
-     *
-     * @param argv the program to execute and the command line arguments
-     *   for the program, one per list element
-     */
-  void setProgram (const QStringList & argv);
-
-    /**
-     * Append an element to the command line argument list for this process.
-     *
-     * If no executable is set yet, it will be set instead.
-     *
-     * For example, doing an "ls -l /usr/local/bin" can be achieved by:
-     *  \code
-     *  KProcess p;
-     *  p << "ls" << "-l" << "/usr/local/bin";
-     *  ...
-     *  \endcode
-     *
-     * This function must be called before starting the process, obviously.
-     *
-     * @param arg the argument to add
-     * @return a reference to this KProcess
-     */
-    KProcess & operator<< (const QString & arg);
-
-    /**
-     * @overload
-     *
-     * @param args the arguments to add
-     * @return a reference to this KProcess
-     */
-    KProcess & operator<< (const QStringList & args);
-
-    /**
-     * Clear the program and command line argument list.
-     */
-  void clearProgram ();
-
-    /**
-     * Obtain the currently set program and arguments.
-     *
-     * @return a list, the first element being the program, the remaining ones
-     *  being command line arguments to the program.
-     */
-  QStringList program () const;
-
-    /**
-     * Start the process.
-     *
-     * @see QProcess::start(const QString &, const QStringList &, OpenMode)
-     */
-  void start ();
-
-    /**
-     * Start the process, wait for it to finish, and return the exit code.
-     *
-     * This method is roughly equivalent to the sequence:
-     * <code>
-     *   start();
-     *   waitForFinished(msecs);
-     *   return exitCode();
-     * </code>
-     *
-     * Unlike the other execute() variants this method is not static,
-     * so the process can be parametrized properly and talked to.
-     *
-     * @param msecs time to wait for process to exit before killing it
-     * @return -2 if the process could not be started, -1 if it crashed,
-     *  otherwise its exit code
-     */
-  int execute (int msecs = -1);
-
-    /**
-     * @overload
-     *
-     * @param exe the program to execute
-     * @param args the command line arguments for the program,
-     *   one per list element
-     * @param msecs time to wait for process to exit before killing it
-     * @return -2 if the process could not be started, -1 if it crashed,
-     *  otherwise its exit code
-     */
-  static int execute (const QString & exe, const QStringList & args =
-		      QStringList (), int msecs = -1);
-
-    /**
-     * @overload
-     *
-     * @param argv the program to execute and the command line arguments
-     *   for the program, one per list element
-     * @param msecs time to wait for process to exit before killing it
-     * @return -2 if the process could not be started, -1 if it crashed,
-     *  otherwise its exit code
-     */
-  static int execute (const QStringList & argv, int msecs = -1);
-
-    /**
-     * Start the process and detach from it. See QProcess::startDetached()
-     * for details.
-     *
-     * Unlike the other startDetached() variants this method is not static,
-     * so the process can be parametrized properly.
-     * @note Currently, only the setProgram()/setShellCommand() and
-     * setWorkingDirectory() parametrizations are supported.
-     *
-     * The KProcess object may be re-used immediately after calling this
-     * function.
-     *
-     * @return the PID of the started process or 0 on error
-     */
-  int startDetached ();
-
-    /**
-     * @overload
-     *
-     * @param exe the program to start
-     * @param args the command line arguments for the program,
-     *   one per list element
-     * @return the PID of the started process or 0 on error
-     */
-  static int startDetached (const QString & exe, const QStringList & args =
-			    QStringList ());
-
-    /**
-     * @overload
-     *
-     * @param argv the program to start and the command line arguments
-     *   for the program, one per list element
-     * @return the PID of the started process or 0 on error
-     */
-  static int startDetached (const QStringList & argv);
-
-    /**
-     * Obtain the process' ID as known to the system.
-     *
-     * Unlike with QProcess::pid(), this is a real PID also on Windows.
-     *
-     * This function can be called only while the process is running.
-     * It cannot be applied to detached processes.
-     *
-     * @return the process ID
-     */
-  int pid () const;
-
-protected:
-    /**
-     * @internal
-     */
-    KProcess (KProcessPrivate * d, QObject * parent);
-
-    /**
-     * @internal
-     */
-  KProcessPrivate *const d_ptr;
-
-private:
-  // hide those
-    using QProcess::setReadChannelMode;
-  using QProcess::readChannelMode;
-  using QProcess::setProcessChannelMode;
-  using QProcess::processChannelMode;
-
-  Q_PRIVATE_SLOT (d_func (), void _k_forwardStdout ())
-  Q_PRIVATE_SLOT (d_func (), void _k_forwardStderr ())
-};
-
-class KProcessPrivate
-{
-Q_DECLARE_PUBLIC (KProcess) protected:
-  KProcessPrivate ():openMode (QIODevice::ReadWrite)
-  {
-  }
-  void writeAll (const QByteArray & buf, int fd);
-  void forwardStd (KProcess::ProcessChannel good, int fd);
-  void _k_forwardStdout ();
-  void _k_forwardStderr ();
-
-  QString prog;
-  QStringList args;
-  KProcess::OutputChannelMode outputChannelMode;
-  QIODevice::OpenMode openMode;
-
-  KProcess *q_ptr;
-};
-
-#endif
diff --git a/gui/src/terminal/kpty.cpp b/gui/src/terminal/kpty.cpp
--- a/gui/src/terminal/kpty.cpp
+++ b/gui/src/terminal/kpty.cpp
@@ -19,104 +19,43 @@
    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
 */
 
 #include "kpty_p.h"
 
-#ifdef __sgi
-#define __svr4__
-#endif
-
-#ifdef __osf__
-#define _OSF_SOURCE
-#include <float.h>
-#endif
-
-#ifdef _AIX
-#define _ALL_SOURCE
-#endif
-
-// __USE_XOPEN isn't defined by default in ICC
-// (needed for ptsname(), grantpt() and unlockpt())
-#ifdef __INTEL_COMPILER
-#ifndef __USE_XOPEN
-#define __USE_XOPEN
-#endif
-#endif
-
 #include <sys/types.h>
-#include <sys/ioctl.h>
-#include <sys/time.h>
+#include <sys/ioctl.h>#include <sys/time.h>
 #include <sys/resource.h>
 #include <sys/stat.h>
 #include <sys/param.h>
 
 #include <errno.h>
 #include <fcntl.h>
 #include <time.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
 #include <grp.h>
 
-#if defined(HAVE_PTY_H)
 #include <pty.h>
-#endif
-
-#ifdef HAVE_LIBUTIL_H
-#include <libutil.h>
-#elif defined(HAVE_UTIL_H)
-#include <util.h>
-#endif
-
-#define HAVE_UTMPX
 #define _UTMPX_COMPAT
-
-#ifdef HAVE_UTEMPTER
-extern "C"
-{
-#include <utempter.h>
-}
-#else
 #include <utmp.h>
-#ifdef HAVE_UTMPX
 #include <utmpx.h>
-#endif
-#if !defined(_PATH_UTMPX) && defined(_UTMPX_FILE)
-#define _PATH_UTMPX _UTMPX_FILE
-#endif
-#if !defined(_PATH_WTMPX) && defined(_WTMPX_FILE)
-#define _PATH_WTMPX _WTMPX_FILE
-#endif
-#endif
 
 /* for HP-UX (some versions) the extern C is needed, and for other
    platforms it doesn't hurt */
 extern "C"
 {
 #include <termios.h>
-#if defined(HAVE_TERMIO_H)
-#include <termio.h>		// struct winsize on some systems
-#endif
 }
 
-#if defined (_HPUX_SOURCE)
-#define _TERMIOS_INCLUDED
-#include <bsdtty.h>
-#endif
-
-#ifdef HAVE_SYS_STROPTS_H
-#include <sys/stropts.h>	// Defines I_PUSH
-#define _NEW_TTY_CTRL
-#endif
-
 #if defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__bsdi__) || defined(__APPLE__) || defined (__DragonFly__)
 #define _tcgetattr(fd, ttmode) ioctl(fd, TIOCGETA, (char *)ttmode)
 #else
 #if defined(_HPUX_SOURCE) || defined(__Lynx__) || defined (__CYGWIN__) || defined(__sun)
 #define _tcgetattr(fd, ttmode) tcgetattr(fd, ttmode)
 #else
 #define _tcgetattr(fd, ttmode) ioctl(fd, TCGETS, (char *)ttmode)
 #endif
@@ -131,59 +70,28 @@ extern "C"
 #define _tcsetattr(fd, ttmode) ioctl(fd, TCSETS, (char *)ttmode)
 #endif
 #endif
 
 #include <QtCore/Q_PID>
 
 #define TTY_GROUP "tty"
 
-#ifndef PATH_MAX
-#ifdef MAXPATHLEN
-#define PATH_MAX MAXPATHLEN
-#else
-#define PATH_MAX 1024
-#endif
-#endif
-
-///////////////////////
-// private functions //
-///////////////////////
-
-//////////////////
-// private data //
-//////////////////
-
 KPtyPrivate::KPtyPrivate (KPty * parent):
 masterFd (-1),
 slaveFd (-1),
 ownMaster (true),
 q_ptr (parent)
 {
 }
 
 KPtyPrivate::~KPtyPrivate ()
 {
 }
 
-#ifndef HAVE_OPENPTY
-bool
-KPtyPrivate::chownpty (bool grant)
-{
-  return !QProcess::execute (KStandardDirs::findExe ("kgrantpty"),
-			     QStringList () << (grant ? "--grant" :
-						"--revoke") << QString::
-			     number (masterFd));
-}
-#endif
-
-/////////////////////////////
-// public member functions //
-/////////////////////////////
-
 KPty::KPty ():
 d_ptr (new KPtyPrivate (this))
 {
 }
 
 KPty::KPty (KPtyPrivate * d):
 d_ptr (d)
 {
@@ -210,236 +118,63 @@ KPty::open ()
 
   // Find a master pty that we can open ////////////////////////////////
 
   // Because not all the pty animals are created equal, they want to
   // be opened by several different methods.
 
   // We try, as we know them, one by one.
 
-#ifdef HAVE_OPENPTY
-
   char ptsn[PATH_MAX];
   if (::openpty (&d->masterFd, &d->slaveFd, ptsn, 0, 0))
     {
       d->masterFd = -1;
       d->slaveFd = -1;
-      //kWarning(175) << "Can't open a pseudo teletype";
       return false;
     }
   d->ttyName = ptsn;
 
-#else
-
-#ifdef HAVE__GETPTY		// irix
-
-  char *ptsn =
-    _getpty (&d->masterFd, O_RDWR | O_NOCTTY, S_IRUSR | S_IWUSR, 0);
-  if (ptsn)
-    {
-      d->ttyName = ptsn;
-      goto grantedpt;
-    }
-
-#elif defined(HAVE_PTSNAME) || defined(TIOCGPTN)
-
-#ifdef HAVE_POSIX_OPENPT
-  d->masterFd =::posix_openpt (O_RDWR | O_NOCTTY);
-#elif defined(HAVE_GETPT)
-  d->masterFd =::getpt ();
-#elif defined(PTM_DEVICE)
-  //d->masterFd = KDE_open(PTM_DEVICE, O_RDWR|O_NOCTTY);
-  d->masterFd =::open (PTM_DEVICE, O_RDWR | O_NOCTTY);
-#else
-#error No method to open a PTY master detected.
-#endif
-  if (d->masterFd >= 0)
-    {
-#ifdef HAVE_PTSNAME
-      char *ptsn = ptsname (d->masterFd);
-      if (ptsn)
-	{
-	  d->ttyName = ptsn;
-#else
-      int ptyno;
-      if (!ioctl (d->masterFd, TIOCGPTN, &ptyno))
-	{
-	  char buf[32];
-	  sprintf (buf, "/dev/pts/%d", ptyno);
-	  d->ttyName = buf;
-#endif
-#ifdef HAVE_GRANTPT
-	  if (!grantpt (d->masterFd))
-	    goto grantedpt;
-#else
-	  goto gotpty;
-#endif
-	}
-      ::close (d->masterFd);
-      d->masterFd = -1;
-    }
-#endif // HAVE_PTSNAME || TIOCGPTN
-
-  // Linux device names, FIXME: Trouble on other systems?
-  for (const char *s3 = "pqrstuvwxyzabcde"; *s3; s3++)
-    {
-      for (const char *s4 = "0123456789abcdef"; *s4; s4++)
-	{
-	  ptyName = QString ().sprintf ("/dev/pty%c%c", *s3, *s4).toAscii ();
-	  d->ttyName =
-	    QString ().sprintf ("/dev/tty%c%c", *s3, *s4).toAscii ();
-
-	  d->masterFd =::open (ptyName.data (), O_RDWR);
-	  if (d->masterFd >= 0)
-	    {
-#ifdef Q_OS_SOLARIS
-	      /* Need to check the process group of the pty.
-	       * If it exists, then the slave pty is in use,
-	       * and we need to get another one.
-	       */
-	      int pgrp_rtn;
-	      if (ioctl (d->masterFd, TIOCGPGRP, &pgrp_rtn) == 0
-		  || errno != EIO)
-		{
-		  ::close (d->masterFd);
-		  d->masterFd = -1;
-		  continue;
-		}
-#endif /* Q_OS_SOLARIS */
-	      if (!access (d->ttyName.data (), R_OK | W_OK))	// checks availability based on permission bits
-		{
-		  if (!geteuid ())
-		    {
-		      struct group *p = getgrnam (TTY_GROUP);
-		      if (!p)
-			p = getgrnam ("wheel");
-		      gid_t gid = p ? p->gr_gid : getgid ();
-
-		      chown (d->ttyName.data (), getuid (), gid);
-		      chmod (d->ttyName.data (), S_IRUSR | S_IWUSR | S_IWGRP);
-		    }
-		  goto gotpty;
-		}
-	      ::close (d->masterFd);
-	      d->masterFd = -1;
-	    }
-	}
-    }
-
-  //kWarning(175) << "Can't open a pseudo teletype";
-  return false;
-
-gotpty:
-  KDE_struct_stat st;
-  if (KDE_stat (d->ttyName.data (), &st))
-    return false;		// this just cannot happen ... *cough*  Yeah right, I just
-  // had it happen when pty #349 was allocated.  I guess
-  // there was some sort of leak?  I only had a few open.
-  if (((st.st_uid != getuid ()) ||
-       (st.st_mode & (S_IRGRP | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH))) &&
-      !d->chownpty (true))
-    {
-
-      /*kWarning(175)
-         << "chownpty failed for device " << ptyName << "::" << d->ttyName
-         << "\nThis means the communication can be eavesdropped." << endl;
-       */
-    }
-
-grantedpt:
-
-#ifdef HAVE_REVOKE
-  revoke (d->ttyName.data ());
-#endif
-
-#ifdef HAVE_UNLOCKPT
-  unlockpt (d->masterFd);
-#elif defined(TIOCSPTLCK)
-  int flag = 0;
-  ioctl (d->masterFd, TIOCSPTLCK, &flag);
-#endif
-
-  d->slaveFd =::open (d->ttyName.data (), O_RDWR | O_NOCTTY);
-  if (d->slaveFd < 0)
-    {
-      //kWarning(175) << "Can't open slave pseudo teletype";
-      ::close (d->masterFd);
-      d->masterFd = -1;
-      return false;
-    }
-
-#if (defined(__svr4__) || defined(__sgi__) || defined(Q_OS_SOLARIS))
-  // Solaris uses STREAMS for terminal handling. It is possible
-  // for the pty handling modules to be left off the stream; in that
-  // case push them on. ioctl(fd, I_FIND, ...) is documented to return
-  // 1 if the module is on the stream already.
-  {
-    static const char *pt = "ptem";
-    static const char *ld = "ldterm";
-    if (ioctl (d->slaveFd, I_FIND, pt) == 0)
-      ioctl (d->slaveFd, I_PUSH, pt);
-    if (ioctl (d->slaveFd, I_FIND, ld) == 0)
-      ioctl (d->slaveFd, I_PUSH, ld);
-  }
-#endif
-
-#endif /* HAVE_OPENPTY */
-
   fcntl (d->masterFd, F_SETFD, FD_CLOEXEC);
   fcntl (d->slaveFd, F_SETFD, FD_CLOEXEC);
 
   return true;
 }
 
 bool
 KPty::open (int fd)
 {
-#if !defined(HAVE_PTSNAME) && !defined(TIOCGPTN)
-  //kWarning(175) << "Unsupported attempt to open pty with fd" << fd;
-  return false;
-#else
   Q_D (KPty);
 
   if (d->masterFd >= 0)
     {
-      //kWarning(175) << "Attempting to open an already open pty";
       return false;
     }
 
   d->ownMaster = false;
 
-#ifdef HAVE_PTSNAME
-  char *ptsn = ptsname (fd);
-  if (ptsn)
-    {
-      d->ttyName = ptsn;
-#else
   int ptyno;
   if (!ioctl (fd, TIOCGPTN, &ptyno))
     {
       char buf[32];
       sprintf (buf, "/dev/pts/%d", ptyno);
       d->ttyName = buf;
-#endif
     }
   else
     {
-      //kWarning(175) << "Failed to determine pty slave device for fd" << fd;
-      return false;
+       return false;
     }
 
   d->masterFd = fd;
   if (!openSlave ())
     {
       d->masterFd = -1;
       return false;
     }
 
   return true;
-#endif
 }
 
 void
 KPty::closeSlave ()
 {
   Q_D (KPty);
 
   if (d->slaveFd < 0)
@@ -452,62 +187,37 @@ bool
 KPty::openSlave ()
 {
   Q_D (KPty);
 
   if (d->slaveFd >= 0)
     return true;
   if (d->masterFd < 0)
     {
-      //kWarning(175) << "Attempting to open pty slave while master is closed";
       return false;
     }
   d->slaveFd =::open (d->ttyName.data (), O_RDWR | O_NOCTTY);
   if (d->slaveFd < 0)
     {
-      //kWarning(175) << "Can't open slave pseudo teletype";
       return false;
     }
   fcntl (d->slaveFd, F_SETFD, FD_CLOEXEC);
   return true;
 }
 
 void
 KPty::close ()
 {
   Q_D (KPty);
 
   if (d->masterFd < 0)
     return;
   closeSlave ();
   if (d->ownMaster)
     {
-#ifndef HAVE_OPENPTY
-      // don't bother resetting unix98 pty, it will go away after closing master anyway.
-      if (memcmp (d->ttyName.data (), "/dev/pts/", 9))
-	{
-	  if (!geteuid ())
-	    {
-	      struct stat st;
-	      if (!stat (d->ttyName.data (), &st))
-		{
-		  chown (d->ttyName.data (), 0,
-			 st.st_gid == getgid ()? 0 : -1);
-		  chmod (d->ttyName.data (),
-			 S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH |
-			 S_IWOTH);
-		}
-	    }
-	  else
-	    {
-	      fcntl (d->masterFd, F_SETFD, 0);
-	      d->chownpty (false);
-	    }
-	}
-#endif
       ::close (d->masterFd);
     }
   d->masterFd = -1;
 }
 
 void
 KPty::setCTty ()
 {
@@ -515,207 +225,89 @@ KPty::setCTty ()
 
   // Setup job control //////////////////////////////////
 
   // Become session leader, process group leader,
   // and get rid of the old controlling terminal.
   setsid ();
 
   // make our slave pty the new controlling terminal.
-#ifdef TIOCSCTTY
   ioctl (d->slaveFd, TIOCSCTTY, 0);
-#else
-  // __svr4__ hack: the first tty opened after setsid() becomes controlling tty
-  ::close (open (d->ttyName, O_WRONLY, 0));
-#endif
 
   // make our new process group the foreground group on the pty
   int pgrp = getpid ();
-#if defined(_POSIX_VERSION) || defined(__svr4__)
   tcsetpgrp (d->slaveFd, pgrp);
-#elif defined(TIOCSPGRP)
-  ioctl (d->slaveFd, TIOCSPGRP, (char *) &pgrp);
-#endif
 }
 
 void
 KPty::login (const char *user, const char *remotehost)
 {
-#ifdef HAVE_UTEMPTER
-  Q_D (KPty);
+  struct utmp l_struct;
 
-  addToUtmp (d->ttyName, remotehost, d->masterFd);
-  Q_UNUSED (user);
-#else
-#ifdef HAVE_UTMPX
-  struct utmpx l_struct;
-#else
-  struct utmp l_struct;
-#endif
   memset (&l_struct, 0, sizeof (l_struct));
   // note: strncpy without terminators _is_ correct here. man 4 utmp
 
   if (user)
     strncpy (l_struct.ut_name, user, sizeof (l_struct.ut_name));
 
   if (remotehost)
     {
       strncpy (l_struct.ut_host, remotehost, sizeof (l_struct.ut_host));
-#ifdef HAVE_STRUCT_UTMP_UT_SYSLEN
-      l_struct.ut_syslen =
-	qMin (strlen (remotehost), sizeof (l_struct.ut_host));
-#endif
     }
 
-#ifndef __GLIBC__
-  Q_D (KPty);
-  const char *str_ptr = d->ttyName.data ();
-  if (!memcmp (str_ptr, "/dev/", 5))
-    str_ptr += 5;
-  strncpy (l_struct.ut_line, str_ptr, sizeof (l_struct.ut_line));
-#ifdef HAVE_STRUCT_UTMP_UT_ID
-  strncpy (l_struct.ut_id,
-	   str_ptr + strlen (str_ptr) - sizeof (l_struct.ut_id),
-	   sizeof (l_struct.ut_id));
-#endif
-#endif
-
-#ifdef HAVE_UTMPX
-  //gettimeofday(&l_struct.ut_tv, 0);
-  gettimeofday ((struct timeval *) &l_struct.ut_tv, 0);
-#else
   l_struct.ut_time = time (0);
-#endif
-
-#ifdef HAVE_LOGIN
-#ifdef HAVE_LOGINX
-  ::loginx (&l_struct);
-#else
-  ::login (&l_struct);
-#endif
-#else
-#ifdef HAVE_STRUCT_UTMP_UT_TYPE
-  l_struct.ut_type = USER_PROCESS;
-#endif
-#ifdef HAVE_STRUCT_UTMP_UT_PID
-  l_struct.ut_pid = getpid ();
-#ifdef HAVE_STRUCT_UTMP_UT_SESSION
-  l_struct.ut_session = getsid (0);
-#endif
-#endif
-#ifdef HAVE_UTMPX
-  utmpxname (_PATH_UTMPX);
-  setutxent ();
-  pututxline (&l_struct);
-  endutxent ();
-  //updwtmpx(_PATH_WTMPX, &l_struct);
-#else
   utmpname (_PATH_UTMP);
   setutent ();
   pututline (&l_struct);
   endutent ();
   updwtmp (_PATH_WTMP, &l_struct);
-#endif
-#endif
-#endif
 }
 
 void
 KPty::logout ()
 {
-#ifdef HAVE_UTEMPTER
-  Q_D (KPty);
-
-  removeLineFromUtmp (d->ttyName, d->masterFd);
-#else
   Q_D (KPty);
 
   const char *str_ptr = d->ttyName.data ();
   if (!memcmp (str_ptr, "/dev/", 5))
     str_ptr += 5;
-#ifdef __GLIBC__
   else
     {
       const char *sl_ptr = strrchr (str_ptr, '/');
       if (sl_ptr)
 	str_ptr = sl_ptr + 1;
     }
-#endif
-#ifdef HAVE_LOGIN
-#ifdef HAVE_LOGINX
-  ::logoutx (str_ptr, 0, DEAD_PROCESS);
-#else
-  ::logout (str_ptr);
-#endif
-#else
-#ifdef HAVE_UTMPX
-  struct utmpx l_struct, *ut;
-#else
+
   struct utmp l_struct, *ut;
-#endif
+
   memset (&l_struct, 0, sizeof (l_struct));
-
   strncpy (l_struct.ut_line, str_ptr, sizeof (l_struct.ut_line));
-
-#ifdef HAVE_UTMPX
-  utmpxname (_PATH_UTMPX);
-  setutxent ();
-  if ((ut = getutxline (&l_struct)))
-    {
-#else
   utmpname (_PATH_UTMP);
   setutent ();
   if ((ut = getutline (&l_struct)))
     {
-#endif
       memset (ut->ut_name, 0, sizeof (*ut->ut_name));
       memset (ut->ut_host, 0, sizeof (*ut->ut_host));
-#ifdef HAVE_STRUCT_UTMP_UT_SYSLEN
-      ut->ut_syslen = 0;
-#endif
-#ifdef HAVE_STRUCT_UTMP_UT_TYPE
-      ut->ut_type = DEAD_PROCESS;
-#endif
-#ifdef HAVE_UTMPX
-      //gettimeofday(&(ut->ut_tv), 0);
-      gettimeofday ((struct timeval *) &(ut->ut_tv), 0);
-      pututxline (ut);
-    }
-  endutxent ();
-#else
       ut->ut_time = time (0);
       pututline (ut);
     }
   endutent ();
-#endif
-#endif
-#endif
 }
 
 bool
 KPty::tcGetAttr (struct::termios * ttmode) const
 {
   Q_D (const KPty);
-
-#ifdef Q_OS_SOLARIS
-  if (_tcgetattr (d->slaveFd, ttmode) == 0)
-    return true;
-#endif
   return _tcgetattr (d->masterFd, ttmode) == 0;
 }
 
 bool
 KPty::tcSetAttr (struct::termios * ttmode)
 {
   Q_D (KPty);
-
-#ifdef Q_OS_SOLARIS
-  if (_tcsetattr (d->slaveFd, ttmode) == 0)
-    return true;
-#endif
   return _tcsetattr (d->masterFd, ttmode) == 0;
 }
 
 bool
 KPty::setWinSize (int lines, int columns)
 {
   Q_D (KPty);
 
diff --git a/gui/src/terminal/kptyprocess.cpp b/gui/src/terminal/kptyprocess.cpp
deleted file mode 100644
--- a/gui/src/terminal/kptyprocess.cpp
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
-
-    This file is part of the KDE libraries
-
-    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-#include "kptyprocess.h"
-#include "kprocess.h"
-
-#include "kptydevice.h"
-
-#include <stdlib.h>
-#include <unistd.h>
-
-//////////////////
-// private data //
-//////////////////
-
-KPtyProcess::KPtyProcess (QObject * parent):
-KProcess (new KPtyProcessPrivate, parent)
-{
-  Q_D (KPtyProcess);
-
-  d->pty = new KPtyDevice (this);
-  d->pty->open ();
-  connect (this, SIGNAL (stateChanged (QProcess::ProcessState)),
-	   SLOT (_k_onStateChanged (QProcess::ProcessState)));
-}
-
-KPtyProcess::KPtyProcess (int ptyMasterFd, QObject * parent):
-KProcess (new KPtyProcessPrivate, parent)
-{
-  Q_D (KPtyProcess);
-
-  d->pty = new KPtyDevice (this);
-  d->pty->open (ptyMasterFd);
-  connect (this, SIGNAL (stateChanged (QProcess::ProcessState)),
-	   SLOT (_k_onStateChanged (QProcess::ProcessState)));
-}
-
-KPtyProcess::~KPtyProcess ()
-{
-  Q_D (KPtyProcess);
-
-  if (state () != QProcess::NotRunning && d->addUtmp)
-    {
-      d->pty->logout ();
-      disconnect (SIGNAL (stateChanged (QProcess::ProcessState)),
-		  this, SLOT (_k_onStateChanged (QProcess::ProcessState)));
-    }
-  delete d->pty;
-}
-
-void
-KPtyProcess::setPtyChannels (PtyChannels channels)
-{
-  Q_D (KPtyProcess);
-
-  d->ptyChannels = channels;
-}
-
-KPtyProcess::PtyChannels KPtyProcess::ptyChannels () const
-{
-  Q_D (const KPtyProcess);
-
-  return d->ptyChannels;
-}
-
-KPtyDevice *
-KPtyProcess::pty () const
-{
-  Q_D (const KPtyProcess);
-
-  return d->pty;
-}
-
-void
-KPtyProcess::setupChildProcess ()
-{
-  Q_D (KPtyProcess);
-
-  d->pty->setCTty ();
-  if (d->addUtmp)
-    d->pty->login (getenv ("USER"), getenv ("DISPLAY"));
-  //d->pty->login(KUser(KUser::UseRealUserID).loginName().toLocal8Bit().data(), qgetenv("DISPLAY"));
-  if (d->ptyChannels & StdinChannel)
-    dup2 (d->pty->slaveFd (), 0);
-  if (d->ptyChannels & StdoutChannel)
-    dup2 (d->pty->slaveFd (), 1);
-  if (d->ptyChannels & StderrChannel)
-    dup2 (d->pty->slaveFd (), 2);
-
-  KProcess::setupChildProcess ();
-}
diff --git a/gui/src/terminal/kptyprocess.h b/gui/src/terminal/kptyprocess.h
deleted file mode 100644
--- a/gui/src/terminal/kptyprocess.h
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
-    This file is part of the KDE libraries
-
-    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-
-#ifndef KPTYPROCESS_H
-#define KPTYPROCESS_H
-
-#include "kprocess.h"
-#include "kptydevice.h"
-
-class KPtyDevice;
-class KPtyProcess;
-struct KPtyProcessPrivate;
-
-/**
- * This class extends KProcess by support for PTYs (pseudo TTYs).
- *
- * The PTY is opened as soon as the class is instantiated. Verify that
- * it was opened successfully by checking that pty()->masterFd() is not -1.
- *
- * The PTY is always made the process' controlling TTY.
- * Utmp registration and connecting the stdio handles to the PTY are optional.
- *
- * No attempt to integrate with QProcess' waitFor*() functions was made,
- * for it is impossible. Note that execute() does not work with the PTY, too.
- * Use the PTY device's waitFor*() functions or use it asynchronously.
- *
- * @author Oswald Buddenhagen <ossi@kde.org>
- */
-class KPtyProcess:public KProcess
-{
-Q_OBJECT Q_DECLARE_PRIVATE (KPtyProcess) public:
-  enum PtyChannelFlag
-  {
-    NoChannels = 0,	/**< The PTY is not connected to any channel. */
-    StdinChannel = 1,	  /**< Connect PTY to stdin. */
-    StdoutChannel = 2,	   /**< Connect PTY to stdout. */
-    StderrChannel = 4,	   /**< Connect PTY to stderr. */
-    AllOutputChannels = 6,     /**< Connect PTY to all output channels. */
-    AllChannels = 7	/**< Connect PTY to all channels. */
-  };
-
-    Q_DECLARE_FLAGS (PtyChannels, PtyChannelFlag)
-    /**
-     * Constructor
-     */
-  explicit KPtyProcess (QObject * parent = 0);
-
-    /**
-     * Construct a process using an open pty master.
-     *
-     * @param ptyMasterFd an open pty master file descriptor.
-     *   The process does not take ownership of the descriptor;
-     *   it will not be automatically closed at any point.
-     */
-    KPtyProcess (int ptyMasterFd, QObject * parent = 0);
-
-    /**
-     * Destructor
-     */
-    virtual ~ KPtyProcess ();
-
-    /**
-     * Set to which channels the PTY should be assigned.
-     *
-     * This function must be called before starting the process.
-     *
-     * @param channels the output channel handling mode
-     */
-  void setPtyChannels (PtyChannels channels);
-
-    /**
-     * Query to which channels the PTY is assigned.
-     *
-     * @return the output channel handling mode
-     */
-  PtyChannels ptyChannels () const;
-
-
-    /**
-     * Get the PTY device of this process.
-     *
-     * @return the PTY device
-     */
-  KPtyDevice *pty () const;
-
-protected:
-    /**
-     * @reimp
-     */
-    virtual void setupChildProcess ();
-
-private:
-  Q_PRIVATE_SLOT (d_func (),
-		    void _k_onStateChanged (QProcess::ProcessState))};
-
-struct KPtyProcessPrivate:KProcessPrivate
-{
-  KPtyProcessPrivate ():ptyChannels (KPtyProcess::NoChannels), addUtmp (false)
-  {
-  }
-
-  void _k_onStateChanged (QProcess::ProcessState newState)
-  {
-    if (newState == QProcess::NotRunning && addUtmp)
-      pty->logout ();
-  }
-
-  KPtyDevice *pty;
-  KPtyProcess::PtyChannels ptyChannels;
-  bool addUtmp:1;
-};
-
-Q_DECLARE_OPERATORS_FOR_FLAGS (KPtyProcess::PtyChannels)
-#endif
