# HG changeset patch
# User jwe
# Date 810337914 0
#      Tue Sep 05 21:51:54 1995 +0000
# Node ID 7eb93d12654c3193ffc00decb09e721708a1cdf8
# Parent  a6994c934a50acca625f7ee553549170e3b72d6f
[project @ 1995-09-05 21:51:54 by jwe]

diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -28,19 +28,17 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <assert.h>
 
 #include "Array.h"
 
-/*
- * The real representation of all arrays.
- */
+// The real representation of all arrays.
 
 template <class T>
 ArrayRep<T>::ArrayRep (T *d, int l)
 {
   data = d;
   len = l;
 }
 
@@ -91,20 +89,18 @@ ArrayRep<T>::elem (int n)
 
 template <class T>
 T
 ArrayRep<T>::elem (int n) const
 {
   return data[n];
 }
 
-/*
- * One dimensional array class.  Handles the reference counting for
- * all the derived classes.
- */
+// One dimensional array class.  Handles the reference counting for
+// all the derived classes.
 
 template <class T>
 Array<T>::Array (T *d, int l)
 {
   rep = new ArrayRep<T> (d, l);
   rep->count = 1;
 }
 
@@ -326,19 +322,17 @@ Array<T>::fortran_vec (void)
     {
       --rep->count;
       rep = new ArrayRep<T> (*rep);
       rep->count = 1;
     }
   return rep->data;
 }
 
-/*
- * Two dimensional array class.
- */
+// Two dimensional array class.
 
 template <class T>
 Array2<T>::Array2 (T *d, int n, int m) : Array<T> (d, n*m)
 {
   d1 = n;
   d2 = m;
 }
 
@@ -583,19 +577,17 @@ Array2<T>::resize (int r, int c, const T
   for (int j = min_c; j < c; j++)
     for (int i = 0; i < r; i++)
       xelem (i, j) = val;
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
-/*
- * Three dimensional array class.
- */
+// Three dimensional array class.
 
 template <class T>
 Array3<T>::Array3 (T *d, int n, int m, int k) : Array2<T> (d, n, m*k)
 {
   d2 = m;
   d3 = k;
 }
 
@@ -721,29 +713,27 @@ Array3<T>::operator () (int i, int j, in
     }
   return Array2<T>::elem (i, d2*k+j);
 }
 
 template <class T>
 void
 Array3<T>::resize (int n, int m, int k)
 {
-  assert (0); /* XXX FIXME XXX */
+  assert (0); // XXX FIXME XXX
 }
 
 template <class T>
 void
 Array3<T>::resize (int n, int m, int k, const T& val)
 {
-  assert (0); /* XXX FIXME XXX */
+  assert (0); // XXX FIXME XXX
 }
 
-/*
- * A two-dimensional array with diagonal elements only.
- */
+// A two-dimensional array with diagonal elements only.
 
 template <class T>
 DiagArray<T>::DiagArray (T *d, int r, int c) : Array<T> (d, r < c ? r : c)
 {
   nr = r;
   nc = c;
 }
 
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -44,19 +44,17 @@ extern "C"
 {
   int F77_FCN (zgemv, ZGEMV) (const char*, const int&, const int&,
 			      const Complex&, const Complex*,
 			      const int&, const Complex*, const int&,
 			      const Complex&, Complex*, const int&,
 			      long);
 }
 
-/*
- * Complex Column Vector class
- */
+// Complex Column Vector class
 
 ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
    : MArray<Complex> (a.length ())
 {
   for (int i = 0; i < length (); i++)
     elem (i) = a.elem (i);
 }
 
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -32,19 +32,17 @@ Software Foundation, 59 Temple Place - S
 #include <iostream.h>
 
 #include <Complex.h>
 
 #include "mx-base.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 
-/*
- * Complex Diagonal Matrix class
- */
+// Complex Diagonal Matrix class
 
 ComplexDiagMatrix::ComplexDiagMatrix (const RowVector& a)
   : MDiagArray<Complex> (a.length ())
 {
   for (int i = 0; i < length (); i++)
     elem (i, i) = a.elem (i);
 }
 
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -62,31 +62,29 @@ extern "C"
   int F77_FCN (zgesl, ZGESL) (Complex*, const int&, const int&, int*,
 			      Complex*, const int&);
 
   int F77_FCN (zgelss, ZGELSS) (const int&, const int&, const int&,
 				Complex*, const int&, Complex*,
 				const int&, double*, double&, int&,
 				Complex*, const int&, double*, int&);
 
-// Note that the original complex fft routines were not written for
-// double complex arguments.  They have been modified by adding an
-// implicit double precision (a-h,o-z) statement at the beginning of
-// each subroutine.
+  // Note that the original complex fft routines were not written for
+  // double complex arguments.  They have been modified by adding an
+  // implicit double precision (a-h,o-z) statement at the beginning of
+  // each subroutine.
 
   int F77_FCN (cffti, CFFTI) (const int&, Complex*);
 
   int F77_FCN (cfftf, CFFTF) (const int&, Complex*, Complex*);
 
   int F77_FCN (cfftb, CFFTB) (const int&, Complex*, Complex*);
 }
 
-/*
- * Complex Matrix class
- */
+// Complex Matrix class
 
 ComplexMatrix::ComplexMatrix (const Matrix& a)
   : MArray2<Complex> (a.rows (), a.cols ())
 {
   for (int j = 0; j < cols (); j++)
     for (int i = 0; i < rows (); i++)
       elem (i, j) = a.elem (i, j);
 }
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -44,19 +44,17 @@ extern "C"
 {
   int F77_FCN (zgemv, ZGEMV) (const char*, const int&, const int&,
 			      const Complex&, const Complex*,
 			      const int&, const Complex*, const int&,
 			      const Complex&, Complex*, const int&,
 			      long);
 }
 
-/*
- * Complex Row Vector class
- */
+// Complex Row Vector class
 
 ComplexRowVector::ComplexRowVector (const RowVector& a)
   : MArray<Complex> (a.length ())
 {
   for (int i = 0; i < length (); i++)
     elem (i) = a.elem (i);
 }
 
@@ -433,17 +431,17 @@ operator * (const ComplexRowVector& v, c
       (*current_liboctave_error_handler)
 	("nonconformant vector multiplication attempted");
       return ComplexRowVector ();
     }
 
   if (len == 0 || a.cols () == 0)
     return ComplexRowVector (0);
 
-// Transpose A to form A'*x == (x'*A)'
+  // Transpose A to form A'*x == (x'*A)'
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
   int ld = a_nr;
 
   Complex *y = new Complex [len];
 
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/CmplxAEPBAL.cc
--- a/liboctave/CmplxAEPBAL.cc
+++ b/liboctave/CmplxAEPBAL.cc
@@ -46,32 +46,32 @@ extern "C"
 }
 
 int
 ComplexAEPBALANCE::init (const ComplexMatrix& a, const char *balance_job)
 {
 
   int n = a.cols ();
 
-// Parameters for balance call.
+  // Parameters for balance call.
 
   int info;
   int ilo;
   int ihi;
   double *scale = new double [n];
 
-// Copy matrix into local structure.
+  // Copy matrix into local structure.
 
   balanced_mat = a;
 
   F77_FCN (zgebal, ZGEBAL) (balance_job, n,
 			    balanced_mat.fortran_vec (), n, ilo, ihi,
 			    scale, info, 1L, 1L);
 
-// Initialize balancing matrix to identity.
+  // Initialize balancing matrix to identity.
 
   balancing_mat = Matrix (n, n, 0.0);
   for (int i = 0; i < n; i++)
     balancing_mat (i, i) = 1.0;
 
   F77_FCN (zgebak, ZGEBAK) (balance_job, "R", n, ilo, ihi, scale, n, 
 			    balancing_mat.fortran_vec (), n, info, 1L,
 			    1L);
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -56,18 +56,18 @@ ComplexCHOL::init (const ComplexMatrix& 
    int info;
 
    Complex *h = dup (a.data (), a.length ());
 
    F77_FCN (zpotrf, ZPOTRF) ("U", n, h, n, info, 1L);
 
    chol_mat = ComplexMatrix (h, n, n);
 
-// If someone thinks of a more graceful way of doing this (or faster for
-// that matter :-)), please let me know!
+  // If someone thinks of a more graceful way of doing this (or faster
+  // for that matter :-)), please let me know!
 
   if (n > 1)
     for (int j = 0; j < a_nc; j++)
       for (int i = j+1; i < a_nr; i++)
         chol_mat.elem (i, j) = 0.0;
 
    return info;
 }
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -95,18 +95,18 @@ ComplexHESS::init (const ComplexMatrix& 
 			     info, 1L, 1L);
 
    F77_FCN (zgebak, ZGEBAK) (job, side, n, ilo, ihi, scale, n, z, n,
 			     info, 1L, 1L);
 
    hess_mat = ComplexMatrix (h, n, n);
    unitary_hess_mat = ComplexMatrix (z, n, n);
 
-// If someone thinks of a more graceful way of doing this (or faster for
-// that matter :-)), please let me know!
+  // If someone thinks of a more graceful way of doing this (or faster
+  // for that matter :-)), please let me know!
 
    if (n > 2)
      for (int j = 0; j < a_nc; j++)
        for (int i = j+2; i < a_nr; i++)
          hess_mat.elem (i, j) = 0;
 
    delete [] work;
    delete [] tau;
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -78,27 +78,27 @@ ComplexQRP::ComplexQRP (const ComplexMat
   else
     tmp_data = dup (a.data (), a.length ());
 
 
   work = new Complex[n];
   double *rwork = new double[2*n];
   int *jpvt = new int[n];
 
-// Clear Pivot vector (code to enforce a certain permutation would go
-// here...)
+  // Clear Pivot vector (code to enforce a certain permutation would
+  // go here...)
 
   for (int i = 0; i < n; i++)
     jpvt[i] = 0;      
 
   F77_FCN (zgeqpf, ZGEQPF) (m, n, tmp_data, m, jpvt, tau, work, rwork,
 			    info);
 
-// Form Permutation matrix (if economy is requested, return the
-// indices only!)
+  // Form Permutation matrix (if economy is requested, return the
+  // indices only!)
 
   if (qr_type == QR::economy && m > n)
     {
       p.resize (1, n, 0.0);
       for (int j = 0; j < n; j++)
 	p.elem (0, j) = jpvt[j];
     }
   else
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -82,17 +82,17 @@ ComplexSCHUR::init (const ComplexMatrix&
   int lwork = 8 * n;
   int info;
   int sdim;
   double rconde;
   double rcondv;
 
   double *rwork = new double [n];
 
-// bwork is not referenced for non-ordered Schur.
+  // bwork is not referenced for non-ordered Schur.
 
   int *bwork = 0;
   if (*ord == 'A' || *ord == 'D' || *ord == 'a' || *ord == 'd')
     bwork = new int [n];
 
   Complex *s = dup (a.data (), a.length ());
 
   Complex *work = new Complex [lwork];
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -244,17 +244,17 @@ CollocWt::set_beta (double val)
   Beta = val;
   initialized = 0;
   return *this;
 }
 
 void
 CollocWt::init (void)
 {
-// Check for possible errors.
+  // Check for possible errors.
 
   double wid = rb - lb;
   if (wid <= 0.0)
     {
       error ("width less than or equal to zero");
       return;
     }
 
@@ -274,48 +274,48 @@ CollocWt::init (void)
 
   r.resize (nt);
   q.resize (nt);
   A.resize (nt, nt);
   B.resize (nt, nt);
 
   double *pr = r.fortran_vec ();
 
-// Compute roots.
+  // Compute roots.
 
   F77_FCN (jcobi, JCOBI) (nt, n, inc_left, inc_right, Alpha, Beta,
 			  dif1, dif2, dif3, pr);
 
   int id;
 
-// First derivative weights.
+  // First derivative weights.
 
   id = 1;
   for (int i = 1; i <= nt; i++)
     {
       F77_FCN (dfopr, DFOPR) (nt, n, inc_left, inc_right, i, id, dif1,
 			      dif2, dif3, pr, vect); 
 
       for (int j = 0; j < nt; j++)
 	A (i-1, j) = vect[j];
     }
 
-// Second derivative weights.
+  // Second derivative weights.
 
   id = 2;
   for (int i = 1; i <= nt; i++)
     {
       F77_FCN (dfopr, DFOPR) (nt, n, inc_left, inc_right, i, id, dif1,
 			      dif2, dif3, pr, vect); 
 
       for (int j = 0; j < nt; j++)
 	B (i-1, j) = vect[j];
     }
 
-// Gaussian quadrature weights.
+  // Gaussian quadrature weights.
 
   id = 3;
   double *pq = q.fortran_vec ();
   F77_FCN (dfopr, DFOPR) (nt, n, inc_left, inc_right, id, id, dif1,
 			  dif2, dif3, pr, pq);
 
   delete [] dif1;
   delete [] dif2;
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -227,17 +227,17 @@ ddassl_f (const double& time, double *st
 int
 ddassl_j (const double& time, double *state UNUSED,
 	  double *deriv UNUSED, double *pd, const double& cj,
 	  double *rpar UNUSED, int *ipar UNUSED) 
 {
   Vector tmp_state (nn);
   Vector tmp_deriv (nn);
 
-// XXX FIXME XXX
+  // XXX FIXME XXX
 
   Matrix tmp_dfdxdot (nn, nn);
   Matrix tmp_dfdx (nn, nn);
 
   DAEFunc::DAEJac tmp_jac;
   tmp_jac.dfdxdot = &tmp_dfdxdot;
   tmp_jac.dfdx    = &tmp_dfdx;
 
@@ -314,23 +314,26 @@ DAE::integrate (double tout)
 			    liw, dummy, idummy, ddassl_j);
 
   switch (idid)
     {
     case 1: // A step was successfully taken in the
 	    // intermediate-output mode. The code has not yet reached
 	    // TOUT.
       break;
+
     case 2: // The integration to TSTOP was successfully completed
 	    // (T=TSTOP) by stepping exactly to TSTOP.
       break;
+
     case 3: // The integration to TOUT was successfully completed
 	    // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
 	    // interpolation.  YPRIME(*) is obtained by interpolation.
       break;
+
     case -1: // A large amount of work has been expended.  (About 500 steps).
     case -2: // The error tolerances are too stringent.
     case -3: // The local error test cannot be satisfied because you
 	     // specified a zero component in ATOL and the
 	     // corresponding computed solution component is zero.
 	     // Thus, a pure relative error test is impossible for
 	     // this component.
     case -6: // DDASSL had repeated error test failures on the last
@@ -343,16 +346,17 @@ DAE::integrate (double tout)
 	      // equal to minus one.
     case -11: // IRES equal to -2 was encountered and control is being
 	      // returned to the calling program.
     case -12: // DDASSL failed to compute the initial YPRIME.
     case -33: // The code has encountered trouble from which it cannot
 	      // recover. A message is printed explaining the trouble
 	      // and control is returned to the calling program. For
 	      // example, this occurs when invalid input is detected.
+
     default:
       integration_error = 1;
       break;
     }
 
   t = tout;
 
   return x;
diff --git a/liboctave/FSQP.cc b/liboctave/FSQP.cc
--- a/liboctave/FSQP.cc
+++ b/liboctave/FSQP.cc
@@ -29,16 +29,16 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #ifndef FSQP_MISSING
 
 #include "FSQP.h"
 #include "f77-uscore.h"
 
-#endif /* FSQP_MISSING */
+#endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/LPsolve.cc b/liboctave/LPsolve.cc
--- a/liboctave/LPsolve.cc
+++ b/liboctave/LPsolve.cc
@@ -36,17 +36,17 @@ Vector
 LPsolve::minimize (double& objf, int& inform, Vector& lambda)
 {
   return Vector ();
 }
 
 void
 LPsolve::set_default_options (void)
 {
-// Maybe this isn't needed?
+  // Maybe this isn't needed?
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -155,21 +155,20 @@ ODE::~ODE (void)
 }
 
 int
 lsode_f (const int& neq, const double& time, double *state,
 	 double *deriv, int& ierr) 
 {
   ColumnVector tmp_deriv (neq);
 
-  /*
-   * NOTE: this won't work if LSODE passes copies of the state vector.
-   *       In that case we have to create a temporary vector object
-   *       and copy.
-   */
+  // NOTE: this won't work if LSODE passes copies of the state vector.
+  //       In that case we have to create a temporary vector object
+  //       and copy.
+
   tmp_deriv = (*user_fun) (*tmp_x, time);
 
   if (tmp_deriv.length () == 0)
     ierr = -1;
   else
     {
       for (int i = 0; i < neq; i++)
 	deriv [i] = tmp_deriv.elem (i);
@@ -179,21 +178,20 @@ lsode_f (const int& neq, const double& t
 }
 
 int
 lsode_j (const int& neq, const double& time, double *state,
 	 const int& ml, const int& mu, double *pd, const int& nrowpd)
 {
   Matrix tmp_jac (neq, neq);
 
-  /*
-   * NOTE: this won't work if LSODE passes copies of the state vector.
-   *       In that case we have to create a temporary vector object
-   *       and copy.
-   */
+  // NOTE: this won't work if LSODE passes copies of the state vector.
+  //       In that case we have to create a temporary vector object
+  //       and copy.
+
   tmp_jac = (*user_jac) (*tmp_x, time);
 
   for (int j = 0; j < neq; j++)
     for (int i = 0; i < neq; i++)
       pd [nrowpd * j + i] = tmp_jac (i, j);
 
   return 0;
 }
@@ -205,25 +203,25 @@ ODE::integrate (double tout)
     method_flag = 21;
   else
     method_flag = 22;
 
   integration_error = 0;
 
   double *xp = x.fortran_vec ();
 
-// NOTE: this won't work if LSODE passes copies of the state vector.
-//       In that case we have to create a temporary vector object
-//       and copy.
+  // NOTE: this won't work if LSODE passes copies of the state vector.
+  //       In that case we have to create a temporary vector object
+  //       and copy.
 
   tmp_x = &x;
   user_fun = fun;
   user_jac = jac;
 
-// Try 5000 steps before giving up.
+  // Try 5000 steps before giving up.
 
   iwork[5] = 5000;
   int working_too_hard = 0;
 
   if (stop_time_set)
     {
       itask = 4;
       rwork [0] = stop_time;
@@ -250,44 +248,47 @@ ODE::integrate (double tout)
 
   F77_FCN (lsode, LSODE) (lsode_f, n, xp, t, tout, itol, rel_tol,
 			  abs_tol, itask, istate, iopt, rwork, lrw,
 			  iwork, liw, lsode_j, method_flag);
 
   switch (istate)
     {
     case -13: // Return requested in user-supplied function.
-    case -6: // error weight became zero during problem. (solution
-	     // component i vanished, and atol or atol(i) = 0.)
-    case -5: // repeated convergence failures (perhaps bad jacobian
-	     // supplied or wrong choice of mf or tolerances).
-    case -4: // repeated error test failures (check all inputs).
-    case -3: // illegal input detected (see printed message).
-    case -2: // excess accuracy requested (tolerances too small).
+    case -6:  // error weight became zero during problem. (solution
+	      // component i vanished, and atol or atol(i) = 0.)
+    case -5:  // repeated convergence failures (perhaps bad jacobian
+	      // supplied or wrong choice of mf or tolerances).
+    case -4:  // repeated error test failures (check all inputs).
+    case -3:  // illegal input detected (see printed message).
+    case -2:  // excess accuracy requested (tolerances too small).
       integration_error = 1;
       return ColumnVector ();
       break;
-    case -1: // excess work done on this call (perhaps wrong mf).
+
+    case -1:  // excess work done on this call (perhaps wrong mf).
       working_too_hard++;
       if (working_too_hard > 20)
 	{
 	  (*current_liboctave_error_handler)
 	    ("giving up after more than %d steps attempted in lsode",
 	     iwork[5] * 20);
 	  integration_error = 1;
 	  return ColumnVector ();
 	}
       else
 	{
 	  istate = 2;
 	  goto again;
 	}
       break;
-    case 2: // lsode was successful
+
+    case 2:  // lsode was successful
       break;
+
     default:
       // Error?
       break;
     }
 
   t = tout;
 
   return x;
diff --git a/liboctave/LinConst.cc b/liboctave/LinConst.cc
--- a/liboctave/LinConst.cc
+++ b/liboctave/LinConst.cc
@@ -40,17 +40,17 @@ void
 LinConst::error (const char* msg)
 {
   (*current_liboctave_error_handler) ("fatal LinConst error: %s", msg);
 }
 
 LinConst::LinConst (const Matrix& a_eq, const Vector& b_eq,
 		    const Matrix& a_ineq, const Vector& b_ineq)
 {
-// Need some checks here.
+  // Need some checks here.
 
   int nc_eq = b_eq.capacity ();
   int nc_ineq = b_ineq.capacity ();
   nb = nc_eq + nc_ineq;
 
   lb.resize (nb);
   ub.resize (nb);
 
diff --git a/liboctave/MArray.cc b/liboctave/MArray.cc
--- a/liboctave/MArray.cc
+++ b/liboctave/MArray.cc
@@ -94,19 +94,17 @@ Software Foundation, 59 Temple Place - S
     { \
       T *a_tmp = a.fortran_vec (); \
       const T *b_tmp = b.data (); \
       for (int i = 0; i < l; i++) \
 	a_tmp[i] += b_tmp[i]; \
     } \
   while (0)
 
-/*
- * One dimensional array with math ops.
- */
+// One dimensional array with math ops.
 
 // Element by element MArray by scalar ops.
 
 template <class T>
 MArray<T>&
 operator += (MArray<T>& a, const T& s)
 {
   DO_VS_OP2 (+=)
@@ -217,19 +215,17 @@ MARRAY_AA_OP (quotient,   /, "division")
 template <class T>
 MArray<T>
 operator - (const MArray<T>& a)
 {
   NEG_V;
   return MArray<T> (result, l);
 }
 
-/*
- * Two dimensional array with math ops.
- */
+// Two dimensional array with math ops.
 
 template <class T>
 MArray2<T>::MArray2 (const MDiagArray<T>& a)
   : Array2<T> (a.rows (), a.cols (), T (0))
 {
   for (int i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
@@ -362,19 +358,17 @@ MARRAY_A2A2_OP (quotient,   /, "quotient
 template <class T>
 MArray2<T>
 operator - (const MArray2<T>& a)
 {
   NEG_V;
   return MArray2<T> (result, a.rows (), a.cols ());
 }
 
-/*
- * Two dimensional diagonal array with math ops.
- */
+// Two dimensional diagonal array with math ops.
 
 // Element by element MDiagArray by MDiagArray ops.
 
 template <class T>
 MDiagArray<T>&
 operator += (MDiagArray<T>& a, const MDiagArray<T>& b)
 {
   int r = a.rows ();
diff --git a/liboctave/NPSOL.cc b/liboctave/NPSOL.cc
--- a/liboctave/NPSOL.cc
+++ b/liboctave/NPSOL.cc
@@ -181,34 +181,34 @@ NPSOL::minimize (double& objf, int& info
 {
   Vector lambda;
   return minimize (objf, inform, lambda);
 }
 
 Vector
 NPSOL::minimize (double& objf, int& inform, Vector& lambda)
 {
-// Dimensions of various things.
+  // Dimensions of various things.
 
   int n     = x.capacity ();
   int nclin = lc.size ();
   int ncnln = nlc.size ();
   int nrowa = 1 > nclin ? 1 : nclin;
   int nrowj = 1 > ncnln ? 1 : ncnln;
   int nrowr = n;
 
-// Informative stuff.
+  // Informative stuff.
 
   int iter;
   int *istate = new int [n+nclin+ncnln];
 
-// User defined function stuff is defined above in the functions
-// npsol_confun() and npsol_objfun();
+  // User defined function stuff is defined above in the functions
+  // npsol_confun() and npsol_objfun();
 
-// Constraint stuff.
+  // Constraint stuff.
 
   double dummy;
   double *pclin = &dummy;
   Matrix clin;
   if (nclin > 0)
     {
       clin = lc.constraint_matrix ();
       pclin  = clin.fortran_vec ();
@@ -250,32 +250,32 @@ NPSOL::minimize (double& objf, int& info
   double *c = 0;
   double *cjac = 0;
   if (ncnln > 0)
     {
       c = new double [ncnln];
       cjac = new double [nrowj*n];
     }
 
-// Objective stuff.
+  // Objective stuff.
 
   double *objgrd = new double [n];
 
-// Other stuff.
+  // Other stuff.
 
   double *r = new double [n*n];
 
   lambda.resize (n+nclin+ncnln);
   double *pclambda = lambda.fortran_vec ();
 
-// Decision variable stuff.
+  // Decision variable stuff.
 
   double *px = x.fortran_vec ();
 
-// Workspace parameters.
+  // Workspace parameters.
 
   int lenw;
   int leniw = 3 * n + nclin + 2 * ncnln;
   if (nclin == 0 && ncnln == 0)
     lenw = 20*n;
   else if (ncnln == 0)
     lenw = 2*n*(10 + n) + 11*nclin;
   else
@@ -311,29 +311,29 @@ NPSOL::minimize (double& objf, int& info
 			      leniw, w, lenw);
 
       if (inform == 6 || inform == 1)
 	continue;
       else
 	break;
     }
 
-// Clean up.
+  // Clean up.
 
   delete [] istate;
   delete [] clow;
   delete [] cup;
   delete [] c;
   delete [] cjac;
   delete [] objgrd;
   delete [] r;
   delete [] iw;
   delete [] w;
 
-// See how it went.
+  // See how it went.
 
   return x;
 }
 
 Vector
 NPSOL::minimize (const Vector& xnew)
 {
   x = xnew;
@@ -444,20 +444,18 @@ NPSOL_options::copy (const NPSOL_options
 }
 
 void
 NPSOL_options::set_default_options (void)
 {
   init ();
 }
 
-/*
- * Passing invalid values to the set_* functions will result in
- * setting the default option.
- */
+// Passing invalid values to the set_* functions will result in
+// setting the default option.
 
 void
 NPSOL_options::set_central_difference_interval (double val)
 {
   x_central_difference_interval = (val > 0.0) ? val : -1.0;
 }
 
 void
@@ -764,16 +762,16 @@ NPSOL_options::set_option (const char *k
   ostrstream buf;
   buf << key << " " << opt << ends;
   char *command = buf.str ();
   size_t len = strlen (command);
   F77_FCN (npoptn, NPOPTN) (command, (long) len);
   delete [] command;
 }
 
-#endif /* NPSOL_MISSING */
+#endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/QPSOL.cc b/liboctave/QPSOL.cc
--- a/liboctave/QPSOL.cc
+++ b/liboctave/QPSOL.cc
@@ -261,16 +261,16 @@ QPSOL_options::iteration_limit (void)
 }
 
 int
 QPSOL_options::print_level (void)
 {
   return x_print_level;
 }
 
-#endif /* QPSOL_MISSING */
+#endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -231,22 +231,25 @@ IndefQuad::integrate (int& ier, int& nev
   int last;
 
   int inf;
   switch (type)
     {
     case bound_to_inf:
       inf = 1;
       break;
+
     case neg_inf_to_bound:
       inf = -1;
       break;
+
     case doubly_infinite:
       inf = 2;
       break;
+
     default:
       assert (0);
       break;
     }
 
   double abs_tol = absolute_tolerance ();
   double rel_tol = relative_tolerance ();
 
diff --git a/liboctave/Range.cc b/liboctave/Range.cc
--- a/liboctave/Range.cc
+++ b/liboctave/Range.cc
@@ -130,74 +130,74 @@ operator >> (istream& is, Range& a)
 	  is >> a.rng_inc;
 	  a.rng_nelem = a.nelem_internal ();
 	}
     }
 
   return is;
 }
 
-int
-Range::nelem_internal (void) const
-{
 // Find an approximate number of intervals, then do the best we can to
 // find the number of intervals that we would get if we had done
 // something like
 //
 //   nelem = 0;
 //   while (base + nelem * inc <= limit)
 //     nelem++;
 //
 // (for limit > base && inc > 0)
 //
 // The number of elements in the range is one greater than the number
 // of intervals.
 
-// We can't have more than INT_MAX elements in the range.
+int
+Range::nelem_internal (void) const
+{
+  // We can't have more than INT_MAX elements in the range.
 
   double d_n_intervals = (rng_limit - rng_base) / rng_inc;
   int max_intervals = INT_MAX - 1;
   double d_max_val = (double) max_intervals;
 
   if (d_n_intervals > d_max_val)
     return -1;
 
   int n_intervals = (d_n_intervals > 0)
     ? ((int) (d_n_intervals + 0.5))
     : ((int) (d_n_intervals - 0.5)); 
 
   if (rng_limit > rng_base && rng_inc > 0)
     {
-// Our approximation may have been too big.
+      // Our approximation may have been too big.
 
       while (rng_base + n_intervals * rng_inc > rng_limit && n_intervals > 0)
 	n_intervals--;
 
-// Now that we are close, get the actual number.  Try to avoid
-// problems with extended precision registers.
+      // Now that we are close, get the actual number.  Try to avoid
+      // problems with extended precision registers.
 
       for (;;)
 	{
 	  volatile double tmp_inc = (n_intervals + 1) * rng_inc;
 	  volatile double tmp_val = rng_base + tmp_inc;
 	  if (tmp_val <= rng_limit && n_intervals < max_intervals)
 	    n_intervals++;
 	  else
 	    break;
 	}
     }
   else if (rng_limit < rng_base && rng_inc < 0)
     {
-// Our approximation may have been too big.
+      // Our approximation may have been too big.
 
       while (rng_base + n_intervals * rng_inc < rng_limit && n_intervals > 0)
 	n_intervals--;
 
-// Now that we are close, get the actual number.  Try to avoid
-// problems with extended precision registers.
+      // Now that we are close, get the actual number.  Try to avoid
+      // problems with extended precision registers.
 
       for (;;)
 	{
 	  volatile double tmp_inc = (n_intervals + 1) * rng_inc;
 	  volatile double tmp_val = rng_base + tmp_inc;
 	  if (tmp_val >= rng_limit && n_intervals < max_intervals)
 	    n_intervals++;
 	  else
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -44,19 +44,17 @@ extern "C"
 {
   int F77_FCN (dgemv, DGEMV) (const char*, const int&, const int&,
 			      const double&, const double*,
 			      const int&, const double*, const int&,
 			      const double&, double*, const int&,
 			      long);
 }
 
-/*
- * Column Vector class.
- */
+// Column Vector class.
 
 int
 ColumnVector::operator == (const ColumnVector& a) const
 {
   int len = length ();
   if (len != a.length ())
     return 0;
   return equal (data (), a.data (), len);
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -32,19 +32,17 @@ Software Foundation, 59 Temple Place - S
 #include <iostream.h>
 
 #include <Complex.h>
 
 #include "mx-base.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 
-/*
- * Diagonal Matrix class.
- */
+// Diagonal Matrix class.
 
 int
 DiagMatrix::operator == (const DiagMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return 0;
 
   return equal (data (), a.data (), length ());
@@ -441,16 +439,17 @@ DiagMatrix::diag (int k) const
 
   return d;
 }
 
 ostream&
 operator << (ostream& os, const DiagMatrix& a)
 {
 //  int field_width = os.precision () + 7;
+
   for (int i = 0; i < a.rows (); i++)
     {
       for (int j = 0; j < a.cols (); j++)
 	{
 	  if (i == j)
 	    os << " " /* setw (field_width) */ << a.elem (i, i);
 	  else
 	    os << " " /* setw (field_width) */ << 0.0;
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -64,31 +64,29 @@ extern "C"
 			      const int*, double*, double*,
 			      const int&);
 
   int F77_FCN (dgelss, DGELSS) (const int&, const int&, const int&,
 				double*, const int&, double*,
 				const int&, double*, double&, int&,
 				double*, const int&, int&);
 
-// Note that the original complex fft routines were not written for
-// double complex arguments.  They have been modified by adding an
-// implicit double precision (a-h,o-z) statement at the beginning of
-// each subroutine.
+  // Note that the original complex fft routines were not written for
+  // double complex arguments.  They have been modified by adding an
+  // implicit double precision (a-h,o-z) statement at the beginning of
+  // each subroutine.
 
   int F77_FCN (cffti, CFFTI) (const int&, Complex*);
 
   int F77_FCN (cfftf, CFFTF) (const int&, Complex*, Complex*);
 
   int F77_FCN (cfftb, CFFTB) (const int&, Complex*, Complex*);
 }
 
-/*
- * Matrix class.
- */
+// Matrix class.
 
 Matrix::Matrix (const DiagMatrix& a)
   : MArray2<double> (a.rows (), a.cols (), 0.0)
 {
   for (int i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
@@ -2149,16 +2147,17 @@ Matrix::column_max_loc (void) const
 
   return result;
 }
 
 ostream&
 operator << (ostream& os, const Matrix& a)
 {
 //  int field_width = os.precision () + 7;
+
   for (int i = 0; i < a.rows (); i++)
     {
       for (int j = 0; j < a.cols (); j++)
 	os << " " /* setw (field_width) */ << a.elem (i, j);
       os << "\n";
     }
   return os;
 }
@@ -2183,23 +2182,22 @@ operator >> (istream& is, Matrix& a)
 	    else
 	      break;
 	  }
     }
 
   return is;
 }
 
-/*
- * Read an array of data froma file in binary format.
- */
+// Read an array of data froma file in binary format.
+
 int
 Matrix::read (FILE *fptr, char *type)
 {
-// Allocate buffer pointers.
+  // Allocate buffer pointers.
 
   union
     {
       void *vd;
       char *ch;
       u_char *uc;
       short *sh;
       u_short *us;
@@ -2207,17 +2205,17 @@ Matrix::read (FILE *fptr, char *type)
       u_int *ui;
       long *ln;
       u_long *ul;
       float *fl;
       double *db;
     }
   buf;
 
-// Convert data to double.
+  // Convert data to double.
 
   if (! type)
     {
       (*current_liboctave_error_handler)
 	("fread: invalid NULL type parameter");
       return 0;
     }    
 
@@ -2261,23 +2259,22 @@ Matrix::read (FILE *fptr, char *type)
       (*current_liboctave_error_handler)
 	("fread: invalid NULL type parameter");
       return 0;
     }
 
   return count;
 }
 
-/*
- * Write the data array to a file in binary format.
- */
+// Write the data array to a file in binary format.
+
 int
 Matrix::write (FILE *fptr, char *type)
 {
-// Allocate buffer pointers.
+  // Allocate buffer pointers.
 
   union
     {
       void *vd;
       char *ch;
       u_char *uc;
       short *sh;
       u_short *us;
@@ -2289,17 +2286,17 @@ Matrix::write (FILE *fptr, char *type)
       double *db;
     }
   buf;
 
   int nitems = length ();
 
   double *d = fortran_vec ();
 
-// Convert from double to correct size.
+  // Convert from double to correct size.
 
   if (! type)
     {
       (*current_liboctave_error_handler)
 	("fwrite: invalid NULL type parameter");
       return 0;
     }    
 
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -47,19 +47,17 @@ extern "C"
 			      const int&, const double*, const int&,
 			      const double&, double*, const int&,
 			      long);
 
   double F77_FCN (ddot, DDOT) (const int&, const double*, const int&,
 			       const double*, const int&);
 }
 
-/*
- * Row Vector class.
- */
+// Row Vector class.
 
 int
 RowVector::operator == (const RowVector& a) const
 {
   int len = length ();
   if (len != a.length ())
     return 0;
   return equal (data (), a.data (), len);
@@ -221,17 +219,17 @@ operator * (const RowVector& v, const Ma
       (*current_liboctave_error_handler)
 	("nonconformant vector multiplication attempted");
       return RowVector ();
     }
 
   if (len == 0 || a.cols () == 0)
     return RowVector (0);
 
-// Transpose A to form A'*x == (x'*A)'
+  // Transpose A to form A'*x == (x'*A)'
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
   int ld = a_nr;
 
   double *y = new double [len];
 
@@ -299,16 +297,17 @@ RowVector::max (void) const
 
   return res;
 }
 
 ostream&
 operator << (ostream& os, const RowVector& a)
 {
 //  int field_width = os.precision () + 7;
+
   for (int i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 istream&
 operator >> (istream& is, RowVector& a)
 {
diff --git a/liboctave/dbleAEPBAL.cc b/liboctave/dbleAEPBAL.cc
--- a/liboctave/dbleAEPBAL.cc
+++ b/liboctave/dbleAEPBAL.cc
@@ -51,32 +51,32 @@ AEPBALANCE::init (const Matrix& a, const
   if (a.rows () != a_nc)
     {
       (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
       return -1;
     }
 
   int n = a_nc;
 
-// Parameters for balance call.
+  // Parameters for balance call.
 
   int info;
   int ilo;
   int ihi;
   double *scale = new double [n];
 
-// Copy matrix into local structure.
+  // Copy matrix into local structure.
 
   balanced_mat = a;
 
   F77_FCN (dgebal, DGEBAL) (balance_job, n,
 			    balanced_mat.fortran_vec (), n, ilo, ihi,
 			    scale, info, 1L, 1L);
 
-// Initialize balancing matrix to identity.
+  // Initialize balancing matrix to identity.
 
   balancing_mat = Matrix (n, n, 0.0);
   for (int i = 0; i < n; i++)
     balancing_mat.elem (i ,i) = 1.0;
 
   F77_FCN (dgebak, DGEBAK) (balance_job, "R", n, ilo, ihi, scale, n,
 			    balancing_mat.fortran_vec (), n, info, 1L,
 			    1L);
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -55,18 +55,18 @@ CHOL::init (const Matrix& a)
   int info;
 
   double *h = dup (a.data (), a.length ());
 
   F77_FCN (dpotrf, DPOTRF) ("U", n, h, n, info, 1L);
 
   chol_mat = Matrix (h, n, n);
 
-// If someone thinks of a more graceful way of doing this (or faster for
-// that matter :-)), please let me know!
+  // If someone thinks of a more graceful way of doing this (or faster
+  // for that matter :-)), please let me know!
 
   if (n > 1)
     for (int j = 0; j < a_nc; j++)
       for (int i = j+1; i < a_nr; i++)
         chol_mat.elem (i, j) = 0.0;
 
   return info;
 }
diff --git a/liboctave/dbleGEPBAL.cc b/liboctave/dbleGEPBAL.cc
--- a/liboctave/dbleGEPBAL.cc
+++ b/liboctave/dbleGEPBAL.cc
@@ -65,124 +65,124 @@ GEPBALANCE::init (const Matrix& a, const
     {
       (*current_liboctave_error_handler)
 	("GEPBALANCE requires square matrices of the same size");
       return -1;
     }
 
   int n = a_nc;
 
-// Parameters for balance call.
+  // Parameters for balance call.
 
   int info;
   int ilo;
   int ihi;
   double *cscale = new double [n];
   double *cperm = new double [n];
   Matrix wk (n, 6, 0.0);
 
-// Back out the permutations:
-//
-// cscale contains the exponents of the column scaling factors in its 
-// ilo through ihi locations and the reducing column permutations in 
-// its first ilo-1 and its ihi+1 through n locations.
-//
-// cperm contains the column permutations applied in grading the a and b 
-// submatrices in its ilo through ihi locations.
-//
-// wk contains the exponents of the row scaling factors in its ilo 
-// through ihi locations, the reducing row permutations in its first 
-// ilo-1 and its ihi+1 through n locations, and the row permutations
-// applied in grading the a and b submatrices in its n+ilo through 
-// n+ihi locations.
+  // Back out the permutations:
+  //
+  // cscale contains the exponents of the column scaling factors in its 
+  // ilo through ihi locations and the reducing column permutations in 
+  // its first ilo-1 and its ihi+1 through n locations.
+  //
+  // cperm contains the column permutations applied in grading the a and b 
+  // submatrices in its ilo through ihi locations.
+  //
+  // wk contains the exponents of the row scaling factors in its ilo 
+  // through ihi locations, the reducing row permutations in its first 
+  // ilo-1 and its ihi+1 through n locations, and the row permutations
+  // applied in grading the a and b submatrices in its n+ilo through 
+  // n+ihi locations.
   
-// Copy matrices into local structure.
+  // Copy matrices into local structure.
 
   balanced_a_mat = a;
   balanced_b_mat = b;
 
-// Initialize balancing matrices to identity.
+  // Initialize balancing matrices to identity.
 
   left_balancing_mat = Matrix (n, n, 0.0);
   for (int i = 0; i < n; i++)
     left_balancing_mat (i, i) = 1.0;
 
   right_balancing_mat = left_balancing_mat;
 
-// Check for permutation option.
+  // Check for permutation option.
 
   if (*balance_job == 'P' || *balance_job == 'B')
     {
       F77_FCN (reduce, REDUCE) (n, n, balanced_a_mat.fortran_vec (),
 				n, balanced_b_mat.fortran_vec (), ilo,
 				ihi, cscale, wk.fortran_vec ());
     }
   else
     {
-
-// Set up for scaling later.
+      // Set up for scaling later.
 
       ilo = 1;
       ihi = n;
     }
 
-// Check for scaling option.
+  // Check for scaling option.
 
   if ((*balance_job == 'S' || *balance_job == 'B') && ilo != ihi)
     {
       F77_FCN (scaleg, SCALEG) (n, n, balanced_a_mat.fortran_vec (), 
 				n, balanced_b_mat.fortran_vec (), ilo,
 				ihi, cscale, cperm, wk.fortran_vec ());
     }
   else
     {
-
-// Set scaling data to 0's.
+      // Set scaling data to 0's.
 
       for (int tmp = ilo-1; tmp < ihi; tmp++)
 	{
 	  cscale[tmp] = 0.0;
 	  wk.elem (tmp, 0) = 0.0;
 	}
     }
 
-// Scaleg returns exponents, not values, so...
+  // Scaleg returns exponents, not values, so...
 
   for (int tmp = ilo-1; tmp < ihi; tmp++)
     {
       cscale[tmp] = pow (2.0, cscale[tmp]);
       wk.elem (tmp, 0) = pow (2.0, -wk.elem (tmp, 0));
     }
 
-// Column permutations/scaling.
+  // Column permutations/scaling.
 
   F77_FCN (dgebak, DGEBAK) (balance_job, "R", n, ilo, ihi, cscale, n, 
 			    right_balancing_mat.fortran_vec (), n,
 			    info, 1L, 1L);
     
-// Row permutations/scaling.
+  // Row permutations/scaling.
 
   F77_FCN (dgebak, DGEBAK) (balance_job, "L", n, ilo, ihi,
 			    wk.fortran_vec (), n,
 			    left_balancing_mat.fortran_vec (), n,
 			    info, 1L, 1L);
 
-// XXX FIXME XXX --- these four lines need to be added and debugged.
-// GEPBALANCE::init will work without them, though, so here they are.
+  // XXX FIXME XXX --- these four lines need to be added and
+  // debugged.  GEPBALANCE::init will work without them, though, so
+  // here they are.
 
 #if 0
   if ((*balance_job == 'P' || *balance_job == 'B') && ilo != ihi)
     {
       F77_FCN (gradeq, GRADEQ) (n, n, balanced_a_mat.fortran_vec (),
 				n, balanced_b_mat.fortran_vec (), ilo,
 				ihi, cperm, wk.fortran_vec ());
     }
 #endif
 
-// Transpose for aa = cc*a*dd convention...
+  // Transpose for aa = cc*a*dd convention...
+
   left_balancing_mat = left_balancing_mat.transpose ();
 
   delete [] cscale;
   delete [] cperm;
 
   return info;
 }
 
diff --git a/liboctave/dbleHESS.cc b/liboctave/dbleHESS.cc
--- a/liboctave/dbleHESS.cc
+++ b/liboctave/dbleHESS.cc
@@ -90,24 +90,24 @@ HESS::init (const Matrix& a)
   copy (z, h, n*n);
 
   F77_FCN (dorghr, DORGHR) (n, ilo, ihi, z, n, tau, work, lwork, info,
 			    1L, 1L);
 
   F77_FCN (dgebak, DGEBAK) (jobbal, side, n, ilo, ihi, scale, n, z, n,
 			    info, 1L, 1L);
 
-// We need to clear out all of the area below the sub-diagonal which was used
-// to store the unitary matrix.
+  // We need to clear out all of the area below the sub-diagonal which
+  // was used to store the unitary matrix.
 
   hess_mat = Matrix (h, n, n);
   unitary_hess_mat = Matrix (z, n, n);
 
-// If someone thinks of a more graceful way of doing this (or faster for 
-// that matter :-)), please let me know! 
+  // If someone thinks of a more graceful way of doing this (or faster
+  // for that matter :-)), please let me know! 
 
   if (n > 2)
     for (int j = 0; j < a_nc; j++)
       for (int i = j+2; i < a_nr; i++)
         hess_mat.elem (i, j) = 0;
 
   delete [] tau;
   delete [] work;
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -74,26 +74,26 @@ QRP::QRP (const Matrix& a, QR::type qr_t
       tmp_data = new double [m*m];
       copy (tmp_data, a.data (), a.length ());
     }
   else
     tmp_data = dup (a.data (), a.length ());
 
   int *jpvt = new int[n];
 
-// Clear Pivot vector (code to enforce a certain permutation would go
-// here...)
+  // Clear Pivot vector (code to enforce a certain permutation would
+  // go here...)
 
   for (int i = 0; i < n; i++)
     jpvt[i] = 0;
 
   F77_FCN (dgeqpf, DGEQPF) (m, n, tmp_data, m, jpvt, tau, work, info);
 
-// Form Permutation matrix (if economy is requested, return the
-// indices only!)
+  // Form Permutation matrix (if economy is requested, return the
+  // indices only!)
 
   if (qr_type == QR::economy && m > n)
     {
       p.resize (1, n, 0.0);
       for (int j = 0; j < n; j++)
 	p.elem (0, j) = jpvt[j];
     }
   else
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -88,17 +88,17 @@ SCHUR::init (const Matrix& a, const char
 
   double *s = dup (a.data (), a.length ());
 
   double *wr = new double [n];
   double *wi = new double [n];
   double *q = new double [n*n];
   double *work = new double [lwork];
 
-// These are not referenced for the non-ordered Schur routine.
+  // These are not referenced for the non-ordered Schur routine.
 
   int *iwork = 0;
   int *bwork = 0;
   if (*ord == 'A' || *ord == 'D' || *ord == 'a' || *ord == 'd')
     {
       iwork = new int [liwork];
       bwork = new int [n];
     }
diff --git a/liboctave/mx-kludge.cc b/liboctave/mx-kludge.cc
--- a/liboctave/mx-kludge.cc
+++ b/liboctave/mx-kludge.cc
@@ -71,19 +71,17 @@ Software Foundation, 59 Temple Place - S
       result = new TYPE [l]; \
       const TYPE *x = a.data (); \
       for (int i = 0; i < l; i++) \
 	result[i] = -x[i]; \
     }
 
 #ifdef KLUDGE_VECTORS
 
-/*
- * Like type operations for vectors.
- */
+// Like type operations for vectors.
 
 // Element by element vector by scalar ops.
 
 #define KL_VS_OP(OP) \
   KL_VEC_TYPE \
   operator OP (const KL_VEC_TYPE& a, const TYPE& s) \
   { \
     DO_VS_OP (OP); \
@@ -142,19 +140,17 @@ operator - (const KL_VEC_TYPE& a)
   NEG_V;
   return KL_VEC_TYPE (result, l);
 }
 
 #endif
 
 #ifdef KLUDGE_MATRICES
 
-/*
- * Like type operations for matrices
- */
+// Like type operations for matrices.
 
 // Element by element matrix by scalar ops.
 
 #define KL_MS_OP(OP) \
   KL_MAT_TYPE \
   operator OP (const KL_MAT_TYPE& a, const TYPE& s) \
   { \
     DO_VS_OP (OP); \
@@ -215,19 +211,17 @@ operator - (const KL_MAT_TYPE& a)
   NEG_V;
   return KL_MAT_TYPE (result, a.rows (), a.cols ());
 }
 
 #endif
 
 #ifdef KLUDGE_DIAG_MATRICES
 
-/*
- * Like type operations for diagonal matrices.
- */
+// Like type operations for diagonal matrices.
 
 // Element by element MDiagArray by scalar ops.
 
 #define KL_DMS_OP(OP) \
   KL_DMAT_TYPE \
   operator OP (const KL_DMAT_TYPE& a, const TYPE& s) \
   { \
     DO_VS_OP (OP); \
diff --git a/liboctave/sun-utils.cc b/liboctave/sun-utils.cc
--- a/liboctave/sun-utils.cc
+++ b/liboctave/sun-utils.cc
@@ -20,21 +20,19 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef sun
 
 #include <assert.h>
 
-/*
- * I think that this is really only needed if linking to Fortran
- * compiled libraries on a Sun.  It should never be called.
- * There should probably be a sysdep.cc file, eh?
- */
+// I think that this is really only needed if linking to Fortran
+// compiled libraries on a Sun.  It should never be called.
+// There should probably be a sysdep.cc file, eh?
 
 extern "C"
 {
   int MAIN_ (void)
     {
       assert (0);
       return 0;
     }
