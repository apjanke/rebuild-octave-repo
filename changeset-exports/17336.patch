# HG changeset patch
# User Rik <rik@octave.org>
# Date 1377703658 25200
#      Wed Aug 28 08:27:38 2013 -0700
# Node ID b81b9d079515fc60486fbee7755e918b72c680ee
# Parent  583306fe7e4fc72adcd1143079361c6431f74c46
Use '##' for comments which stand alone on a line.

* libinterp/corefcn/besselj.cc, libinterp/corefcn/conv2.cc,
libinterp/corefcn/pinv.cc, libinterp/corefcn/rand.cc,
libinterp/corefcn/regexp.cc, libinterp/corefcn/sqrtm.cc,
libinterp/dldfcn/qr.cc, libinterp/parse-tree/pt-eval.cc,
scripts/general/cplxpair.m, scripts/general/repmat.m, scripts/help/doc.m,
scripts/help/doc_cache_create.m, scripts/image/colorcube.m,
scripts/image/hsv2rgb.m, scripts/image/image.m, scripts/io/strread.m,
scripts/io/textscan.m, scripts/miscellaneous/bzip2.m,
scripts/miscellaneous/edit.m, scripts/miscellaneous/gzip.m,
scripts/optimization/__all_opts__.m, scripts/optimization/fminbnd.m,
scripts/optimization/sqp.m, scripts/pkg/private/get_forge_pkg.m,
scripts/plot/area.m, scripts/plot/stemleaf.m, scripts/plot/surfc.m,
scripts/plot/uiresume.m, scripts/plot/zlabel.m, scripts/polynomial/mkpp.m,
scripts/polynomial/ppval.m, scripts/set/intersect.m, scripts/signal/freqz.m,
scripts/sparse/pcg.m, scripts/sparse/pcr.m, scripts/sparse/svds.m,
scripts/sparse/treelayout.m, scripts/specfun/ellipke.m,
scripts/special-matrix/toeplitz.m, scripts/strings/dec2base.m,
scripts/strings/strsplit.m, scripts/testfun/test.m, test/build-sparse-tests.sh,
test/index.tst, test/system.tst:
Use '##' for comments which stand alone on a line.

diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -644,21 +644,20 @@ return @code{NaN}.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%! # Test values computed with GP/PARI version 2.3.3
-%!
+## Test values computed with GP/PARI version 2.3.3
 %!shared alpha, x, jx, yx, ix, kx, nix
 %!
-%! # Bessel functions, even order, positive and negative x
+%! ## Bessel functions, even order, positive and negative x
 %! alpha = 2;  x = 1.25;
 %! jx = 0.1710911312405234823613091417;
 %! yx = -1.193199310178553861283790424;
 %! ix = 0.2220184483766341752692212604;
 %! kx = 0.9410016167388185767085460540;
 %!
 %!assert (besselj (alpha,x), jx, 100*eps)
 %!assert (bessely (alpha,x), yx, 100*eps)
@@ -701,17 +700,17 @@ return @code{NaN}.\n\
 %!
 %!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
 %!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
 %!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%! # Bessel functions, odd order, positive and negative x
+%! ## Bessel functions, odd order, positive and negative x
 %! alpha = 3;  x = 2.5;
 %! jx = 0.2166003910391135247666890035;
 %! yx = -0.7560554967536709968379029772;
 %! ix = 0.4743704087780355895548240179;
 %! kx = 0.2682271463934492027663765197;
 %!
 %!assert (besselj (alpha,x), jx, 100*eps)
 %!assert (bessely (alpha,x), yx, 100*eps)
@@ -756,17 +755,17 @@ return @code{NaN}.\n\
 %!
 %!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
 %!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
 %!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%! # Bessel functions, fractional order, positive and negative x
+%! ## Bessel functions, fractional order, positive and negative x
 %!
 %! alpha = 3.5;  x = 2.75;
 %! jx = 0.1691636439842384154644784389;
 %! yx = -0.8301381935499356070267953387;
 %! ix = 0.3930540878794826310979363668;
 %! kx = 0.2844099013460621170288192503;
 %!
 %!assert (besselj (alpha,x), jx, 100*eps)
@@ -814,17 +813,17 @@ return @code{NaN}.\n\
 %!
 %!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
 %!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
 %!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%! # Bessel functions, even order, complex x
+%! ## Bessel functions, even order, complex x
 %!
 %! alpha = 2;  x = 1.25 + 3.625 * I;
 %! jx = -1.299533366810794494030065917 + 4.370833116012278943267479589*I;
 %! yx = -4.370357232383223896393056727 - 1.283083391453582032688834041*I;
 %! ix = -0.6717801680341515541002273932 - 0.2314623443930774099910228553*I;
 %! kx = -0.01108009888623253515463783379 + 0.2245218229358191588208084197*I;
 %!
 %!assert (besselj (alpha,x), jx, 100*eps)
@@ -850,17 +849,17 @@ return @code{NaN}.\n\
 %!
 %!assert (besselj (-alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert (bessely (-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert (besseli (-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
 %!assert (besselk (-alpha,x,1), kx*exp(x), 100*eps)
 %!assert (besselh (-alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert (besselh (-alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%! # Bessel functions, odd order, complex x
+%! ## Bessel functions, odd order, complex x
 %!
 %! alpha = 3; x = 2.5 + 1.875 * I;
 %! jx = 0.1330721523048277493333458596 + 0.5386295217249660078754395597*I;
 %! yx = -0.6485072392105829901122401551 + 0.2608129289785456797046996987*I;
 %! ix = -0.6182064685486998097516365709 + 0.4677561094683470065767989920*I;
 %! kx = -0.1568585587733540007867882337 - 0.05185853709490846050505141321*I;
 %!
 %!assert (besselj (alpha,x), jx, 100*eps)
@@ -886,17 +885,17 @@ return @code{NaN}.\n\
 %!
 %!assert (besselj (-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
 %!assert (bessely (-alpha,x,1), -yx*exp(-abs(imag(x))), 100*eps)
 %!assert (besseli (-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
 %!assert (besselk (-alpha,x,1), kx*exp(x), 100*eps)
 %!assert (besselh (-alpha,1,x,1), -(jx + I*yx)*exp(-I*x), 100*eps)
 %!assert (besselh (-alpha,2,x,1), -(jx - I*yx)*exp(I*x), 100*eps)
 %!
-%! # Bessel functions, fractional order, complex x
+%! ## Bessel functions, fractional order, complex x
 %!
 %! alpha = 3.5;  x = 1.75 + 4.125 * I;
 %! jx = -3.018566131370455929707009100 - 0.7585648436793900607704057611*I;
 %! yx = 0.7772278839106298215614791107 - 3.018518722313849782683792010*I;
 %! ix = 0.2100873577220057189038160913 - 0.6551765604618246531254970926*I;
 %! kx = 0.1757147290513239935341488069 + 0.08772348296883849205562558311*I;
 %!
 %!assert (besselj (alpha,x), jx, 100*eps)
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -272,17 +272,17 @@ When the third argument is a matrix, ret
 %!assert (conv2 ([1:5;1:5]', [1:2]', "valid"), [4 7 10 13; 4 7 10 13]')
 
 %!test
 %! rand ("seed", 42);
 %! x = rand (100);
 %! y = ones (5);
 %! A = conv2 (x, y)(5:end-4,5:end-4);
 %! B = conv2 (x, y, "valid");
-%! assert (B, A); ## Yes, this test is for *exact* equivalence.
+%! assert (B, A);   # Yes, this test is for *exact* equivalence.
 
 
 %% Test input validation
 %!error conv2 ()
 %!error conv2 (1)
 %!error <must be 1-D vectors or 2-D matrices> conv2 (ones (2), ones (2,2,2))
 %!error <SHAPE type not valid> conv2 (1,2, "NOT_A_SHAPE")
 %% Test alternate calling form which should be 2 vectors and a matrix
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -167,22 +167,22 @@ where @code{sigma_max (@var{x})} is the 
         }
     }
 
   return retval;
 }
 
 /*
 %!shared a, b, tol, hitol, d, u, x, y
-%! a = reshape (rand*[1:16], 4, 4);   ## Rank 2 matrix
+%! a = reshape (rand*[1:16], 4, 4);  # Rank 2 matrix
 %! b = pinv (a);
 %! tol = 4e-14;
 %! hitol = 40*sqrt (eps);
 %! d = diag ([rand, rand, hitol, hitol]);
-%! u = rand (4);                      ## Could be singular by freak accident
+%! u = rand (4);                     # Could be singular by freak accident
 %! x = inv (u)*d*u;
 %! y = pinv (x, sqrt (eps));
 %!
 %!assert (a*b*a, a, tol)
 %!assert (b*a*b, b, tol)
 %!assert ((b*a)', b*a, tol)
 %!assert ((a*b)', a*b, tol)
 %!assert (x*y*x, x, -hitol)
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -44,17 +44,17 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "ov-re-mat.h"
 
 /*
 %!shared __random_statistical_tests__
-%! # Flag whether the statistical tests should be run in "make check" or not
+%! ## Flag whether the statistical tests should be run in "make check" or not
 %! __random_statistical_tests__ = 0;
 */
 
 static octave_value
 do_rand (const octave_value_list& args, int nargin, const char *fcn,
          const std::string& distribution, bool additional_arg = false)
 {
   octave_value retval;
@@ -497,38 +497,38 @@ classes.\n\
 %! s = rand ("seed");  y = rand (1,2);
 %! assert (x, y);
 %! rand ("seed", s);  z = rand (1,2);
 %! assert (x, z);
 */
 
 /*
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! rand ("state", 1);
 %! assert (rand (1,6), [0.1343642441124013 0.8474337369372327 0.763774618976614 0.2550690257394218 0.495435087091941 0.4494910647887382], 1e-6);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! rand ("seed", 1);
 %! assert (rand (1,6), [0.8668024251237512 0.9126510815694928 0.09366085007786751 0.1664607301354408 0.7408077004365623 0.7615650338120759], 1e-6);
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   rand ("state", 12);
 %!   x = rand (100000, 1);
 %!   assert (max (x) < 1);   #*** Please report this!!! ***
 %!   assert (min (x) > 0);   #*** Please report this!!! ***
 %!   assert (mean (x), 0.5, 0.0024);
 %!   assert (var (x), 1/48, 0.0632);
 %!   assert (skewness (x), 0, 0.012);
 %!   assert (kurtosis (x), -6/5, 0.0094);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   rand ("seed", 12);
 %!   x = rand (100000, 1);
 %!   assert (max (x) < 1);   #*** Please report this!!! ***
 %!   assert (min (x) > 0);   #*** Please report this!!! ***
 %!   assert (mean (x), 0.5, 0.0024);
 %!   assert (var (x), 1/48, 0.0632);
 %!   assert (skewness (x), 0, 0.012);
 %!   assert (kurtosis (x), -6/5, 0.0094);
@@ -588,36 +588,36 @@ J. Statistical Software, vol 5, 2000,\n\
 
   retval = do_rand (args, nargin, "randn", "normal");
 
   return retval;
 }
 
 /*
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randn ("state", 1);
 %! assert (randn (1, 6), [-2.666521678978671 -0.7381719971724564 1.507903992673601 0.6019427189162239 -0.450661261143348 -0.7054431351574116], 1e-6);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! randn ("seed", 1);
 %! assert (randn (1, 6), [-1.039402365684509 -1.25938892364502 0.1968704611063004 0.3874166905879974 -0.5976632833480835 -0.6615074276924133], 1e-6);
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randn ("state", 12);
 %!   x = randn (100000, 1);
 %!   assert (mean (x), 0, 0.01);
 %!   assert (var (x), 1, 0.02);
 %!   assert (skewness (x), 0, 0.02);
 %!   assert (kurtosis (x), 0, 0.04);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randn ("seed", 12);
 %!   x = randn (100000, 1);
 %!   assert (mean (x), 0, 0.01);
 %!   assert (var (x), 1, 0.02);
 %!   assert (skewness (x), 0, 0.02);
 %!   assert (kurtosis (x), 0, 0.04);
 %! endif
 */
@@ -659,37 +659,37 @@ J. Statistical Software, vol 5, 2000,\n\
 
   retval = do_rand (args, nargin, "rande", "exponential");
 
   return retval;
 }
 
 /*
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! rande ("state", 1);
 %! assert (rande (1, 6), [3.602973885835625 0.1386190677555021 0.6743112889616958 0.4512830847258422 0.7255744741233175 0.3415969205292291], 1e-6);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! rande ("seed", 1);
 %! assert (rande (1, 6), [0.06492075175653866 1.717980206012726 0.4816154008731246 0.5231300676241517 0.103910739364359 1.668931916356087], 1e-6);
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally
+%!   ## statistical tests may fail occasionally
 %!   rande ("state", 1);
 %!   x = rande (100000, 1);
 %!   assert (min (x) > 0);   # *** Please report this!!! ***
 %!   assert (mean (x), 1, 0.01);
 %!   assert (var (x), 1, 0.03);
 %!   assert (skewness (x), 2, 0.06);
 %!   assert (kurtosis (x), 6, 0.7);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally
+%!   ## statistical tests may fail occasionally
 %!   rande ("seed", 1);
 %!   x = rande (100000, 1);
 %!   assert (min (x)>0);   # *** Please report this!!! ***
 %!   assert (mean (x), 1, 0.01);
 %!   assert (var (x), 1, 0.03);
 %!   assert (skewness (x), 2, 0.06);
 %!   assert (kurtosis (x), 6, 0.7);
 %! endif
@@ -807,161 +807,161 @@ classes.\n\
 }
 
 /*
 %!test
 %! randg ("state", 12)
 %! assert (randg ([-inf, -1, 0, inf, nan]), [nan, nan, nan, nan, nan]); # *** Please report
 
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randg ("state", 1);
 %! assert (randg (0.1, 1, 6), [0.0103951513331241 8.335671459898252e-05 0.00138691397249762 0.000587308416993855 0.495590518784736 2.3921917414795e-12], 1e-6);
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randg ("state", 1);
 %! assert (randg (0.95, 1, 6), [3.099382433255327 0.3974529788871218 0.644367450750855 1.143261091802246 1.964111762696822 0.04011915547957939], 1e-6);
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randg ("state", 1);
 %! assert (randg (1, 1, 6), [0.2273389379645993 1.288822625058359 0.2406335209340746 1.218869553370733 1.024649860162554 0.09631230343599533], 1e-6);
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randg ("state", 1);
 %! assert (randg (10, 1, 6), [3.520369644331133 15.15369864472106 8.332112081991205 8.406211067432674 11.81193475187611 10.88792728177059], 1e-5);
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randg ("state", 1);
 %! assert (randg (100, 1, 6), [75.34570255262264 115.4911985594699 95.23493031356388 95.48926019250911 106.2397448229803 103.4813150404118], 1e-4);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! randg ("seed", 1);
 %! assert (randg (0.1, 1, 6), [0.07144210487604141 0.460641473531723 0.4749028384685516 0.06823389977216721 0.000293838675133884 1.802567535340305e-12], 1e-6);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! randg ("seed", 1);
 %! assert (randg (0.95, 1, 6), [1.664905071258545 1.879976987838745 1.905677795410156 0.9948706030845642 0.5606933236122131 0.0766092911362648], 1e-6);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! randg ("seed", 1);
 %! assert (randg (1, 1, 6), [0.03512085229158401 0.6488978862762451 0.8114678859710693 0.1666885763406754 1.60791552066803 1.90356981754303], 1e-6);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! randg ("seed", 1);
 %! assert (randg (10, 1, 6), [6.566435813903809 10.11648464202881 10.73162078857422 7.747178077697754 6.278522491455078 6.240195751190186], 1e-5);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! randg ("seed", 1);
 %! assert (randg (100, 1, 6), [89.40208435058594 101.4734725952148 103.4020004272461 93.62763214111328 88.33104705810547 88.1871337890625], 1e-4);
 
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("state", 12);
 %!   a = 0.1;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
 %!   assert (var (x),      a,          0.01);
 %!   assert (skewness (x), 2/sqrt (a), 1);
 %!   assert (kurtosis (x), 6/a,        50);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("state", 12);
 %!   a = 0.95;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
 %!   assert (var (x),      a,          0.04);
 %!   assert (skewness (x), 2/sqrt (a), 0.2);
 %!   assert (kurtosis (x), 6/a,        2);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("state", 12);
 %!   a = 1;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
 %!   assert (var (x),      a,          0.04);
 %!   assert (skewness (x), 2/sqrt (a), 0.2);
 %!   assert (kurtosis (x), 6/a,        2);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("state", 12);
 %!   a = 10;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.1);
 %!   assert (var (x),      a,          0.5);
 %!   assert (skewness (x), 2/sqrt (a), 0.1);
 %!   assert (kurtosis (x), 6/a,        0.5);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("state", 12);
 %!   a = 100;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.2);
 %!   assert (var (x),      a,          2);
 %!   assert (skewness (x), 2/sqrt (a), 0.05);
 %!   assert (kurtosis (x), 6/a,        0.2);
 %! endif
 %!test
 %! randg ("seed", 12);
 %!assert (randg ([-inf, -1, 0, inf, nan]), [nan, nan, nan, nan, nan]) # *** Please report
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("seed", 12);
 %!   a = 0.1;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
 %!   assert (var (x),      a,          0.01);
 %!   assert (skewness (x), 2/sqrt (a), 1);
 %!   assert (kurtosis (x), 6/a,        50);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("seed", 12);
 %!   a = 0.95;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
 %!   assert (var (x),      a,          0.04);
 %!   assert (skewness (x), 2/sqrt (a), 0.2);
 %!   assert (kurtosis (x), 6/a,        2);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("seed", 12);
 %!   a = 1;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
 %!   assert (var (x),      a,          0.04);
 %!   assert (skewness (x), 2/sqrt (a), 0.2);
 %!   assert (kurtosis (x), 6/a,        2);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("seed", 12);
 %!   a = 10;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.1);
 %!   assert (var (x),      a,          0.5);
 %!   assert (skewness (x), 2/sqrt (a), 0.1);
 %!   assert (kurtosis (x), 6/a,        0.5);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("seed", 12);
 %!   a = 100;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.2);
 %!   assert (var (x),      a,          2);
 %!   assert (skewness (x), 2/sqrt (a), 0.05);
 %!   assert (kurtosis (x), 6/a,        0.2);
 %! endif
@@ -1029,85 +1029,85 @@ classes.\n\
   return retval;
 }
 
 /*
 %!test
 %! randp ("state", 12);
 %! assert (randp ([-inf, -1, 0, inf, nan]), [nan, nan, 0, nan, nan]);   # *** Please report
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randp ("state", 1);
 %! assert (randp (5, 1, 6), [5 5 3 7 7 3])
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randp ("state", 1);
 %! assert (randp (15, 1, 6), [13 15 8 18 18 15])
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randp ("state", 1);
 %! assert (randp (1e9, 1, 6), [999915677 999976657 1000047684 1000019035 999985749 999977692], -1e-6)
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randp ("seed", 1);
 %! %%assert (randp (5, 1, 6), [8 2 3 6 6 8])
 %! assert (randp (5, 1, 5), [8 2 3 6 6])
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randp ("seed", 1);
 %! assert (randp (15, 1, 6), [15 16 12 10 10 12])
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randp ("seed", 1);
 %! assert (randp (1e9, 1, 6), [1000006208 1000012224 999981120 999963520 999963072 999981440], -1e-6)
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randp ("state", 12);
 %!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
 %!     x = randp (a (1), 100000, 1);
 %!     assert (min (x) >= 0);   # *** Please report this!!! ***
 %!     assert (mean (x), a(1), a(2));
 %!     assert (var (x), a(1), 0.02*a(1));
 %!     assert (skewness (x), 1/sqrt (a(1)), a(3));
 %!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randp ("state", 12);
 %!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
 %!     x = randp (a(1)*ones (100000, 1), 100000, 1);
 %!     assert (min (x) >= 0);   # *** Please report this!!! ***
 %!     assert (mean (x), a(1), a(2));
 %!     assert (var (x), a(1), 0.02*a(1));
 %!     assert (skewness (x), 1/sqrt (a(1)), a(3));
 %!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 %!test
 %! randp ("seed", 12);
 %! assert (randp ([-inf, -1, 0, inf, nan]), [nan, nan, 0, nan, nan]);   # *** Please report
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randp ("seed", 12);
 %!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
 %!     x = randp (a(1), 100000, 1);
 %!     assert (min (x) >= 0);   # *** Please report this!!! ***
 %!     assert (mean (x), a(1), a(2));
 %!     assert (var (x), a(1), 0.02*a(1));
 %!     assert (skewness (x), 1/sqrt (a(1)), a(3));
 %!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randp ("seed", 12);
 %!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
 %!     x = randp (a(1)*ones (100000, 1), 100000, 1);
 %!     assert (min (x) >= 0);   # *** Please report this!!! ***
 %!     assert (mean (x), a(1), a(2));
 %!     assert (var (x), a(1), 0.02*a(1));
 %!     assert (skewness (x), 1/sqrt (a(1)), a(3));
 %!     assert (kurtosis (x), 1/a(1), 3*a(3));
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -920,17 +920,17 @@ are zero or more @qcode{'b'} characters 
 %! assert (size (nm), [1, 1]);
 %! assert (nm.first{1}, 'John');
 %! assert (nm.first{2}, 'James');
 %! assert (nm.last{1}, 'Davis');
 %! assert (nm.last{2}, 'Rogers');
 
 ## Tests for named tokens
 %!test
-%! # Parenthesis in named token (ie (int)) causes a problem
+%! ## Parenthesis in named token (ie (int)) causes a problem
 %! assert (regexp ('qwe int asd', ['(?<typestr>(int))'], 'names'), struct ('typestr', 'int'));
 
 %!test
 %! ## Mix of named and unnamed tokens can cause segfault (bug #35683)
 %! str = "abcde";
 %! ptn = '(?<T1>a)(\w+)(?<T2>d\w+)';
 %! tokens = regexp (str, ptn, "names");
 %! assert (isstruct (tokens) && numel (tokens) == 1);
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -267,10 +267,10 @@ Mathematics, Manchester, England, Januar
 %! x = [0 1; 0 0];
 %! assert (any (isnan (sqrtm (x))(:)));
 
 %!test
 %! x = eye (4);  x(2,2) = x(3,3) = 2^-26;  x(1,4) = 1;
 %! z = eye (4);  z(2,2) = z(3,3) = 2^-13;  z(1,4) = 0.5;
 %! [y, err] = sqrtm (x);
 %! assert (y, z);
-%! assert (err, 0);   ## Yes, this one has to hold exactly
+%! assert (err, 0);   # Yes, this one has to hold exactly
 */
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -1387,17 +1387,17 @@ If @var{orient} is @qcode{\"row\"}, full
 %!               0.669966  0.743851  0.457255  0.445057 ]);
 %!
 %! [Q,R] = qr (AA);
 %! [Q,R] = qrdelete (Q, R, 3, "row");
 %! assert (norm (vec (Q'*Q - eye (4,"single")), Inf) < 1.5e1*eps ("single"));
 %! assert (norm (vec (triu (R) - R), Inf) == 0);
 %! assert (norm (vec (Q*R - [AA(1:2,:);AA(4:5,:)]), Inf) < norm (AA)*1e1*eps ("single"));
 %!testif HAVE_QRUPDATE
-%! # Same test as above but with more precicision
+%! ## Same test as above but with more precicision
 %! AA = single ([0.091364  0.613038  0.027504  0.999083;
 %!               0.594638  0.425302  0.562834  0.603537;
 %!               0.383594  0.291238  0.742073  0.085574;
 %!               0.265712  0.268003  0.783553  0.238409;
 %!               0.669966  0.743851  0.457255  0.445057 ]);
 %!
 %! [Q,R] = qr (AA);
 %! [Q,R] = qrdelete (Q, R, 3, "row");
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -805,28 +805,28 @@ tree_evaluator::visit_statement_list (tr
 
               if (tree_return_command::returning)
                 break;
 
               if (p == lst.end ())
                 break;
               else
                 {
-                  // Clear preivous values before next statement is
+                  // Clear previous values before next statement is
                   // evaluated so that we aren't holding an extra
                   // reference to a value that may be used next.  For
                   // example, in code like this:
                   //
-                  //   X = rand (N);  ## refcount for X should be 1
-                  //                  ## after this statement
+                  //   X = rand (N);  # refcount for X should be 1
+                  //                  # after this statement
                   //
-                  //   X(idx) = val;  ## no extra copy of X should be
-                  //                  ## needed, but we will be faked
-                  //                  ## out if retval is not cleared
-                  //                  ## between statements here
+                  //   X(idx) = val;  # no extra copy of X should be
+                  //                  # needed, but we will be faked
+                  //                  # out if retval is not cleared
+                  //                  # between statements here
 
                   //              result_values = empty_list;
                 }
             }
           else
             error ("invalid statement found in statement list!");
         }
     }
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -156,11 +156,11 @@ endfunction
 %! z = exp (2i*pi*[4; 3; 5; 2; 6; 1; 0]/7);
 %!assert (cplxpair (z(randperm (7))), z)
 %!assert (cplxpair (z(randperm (7))), z)
 %!assert (cplxpair (z(randperm (7))), z)
 %!assert (cplxpair ([z(randperm(7)),z(randperm(7))]), [z,z])
 %!assert (cplxpair ([z(randperm(7)),z(randperm(7))],[],1), [z,z])
 %!assert (cplxpair ([z(randperm(7)).';z(randperm(7)).'],[],2), [z.';z.'])
 
-%!## tolerance test
+## tolerance test
 %!assert (cplxpair ([1i, -1i, 1+(1i*eps)],2*eps), [-1i, 1i, 1+(1i*eps)])
  
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -112,17 +112,17 @@ function x = repmat (A, m, n)
     aidx(end+1:length (idx)) = 1;
     ## create subscript array
     cidx = cell (2, length (aidx));
     for i = 1:length (aidx)
       cidx{1,i} = ':';
       cidx{2,i} = ones (1, idx (i));
     endfor
     aaidx = aidx;
-    # add singleton dims
+    ## add singleton dims
     aaidx(2,:) = 1;
     A = reshape (A, aaidx(:));
     x = reshape (A (cidx{:}), idx .* aidx);
   endif
 
 endfunction
 
 # Tests for ML compatibility
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -48,17 +48,17 @@ function retval = doc (fname)
         ftype = exist (fname);
       else
         error ("doc: expecting argument to be a character string");
       endif
     else
       fname = "";
     endif
 
-    # if GUI is running, let it display the function
+    ## if GUI is running, let it display the function
     if isguirunning ()
       __octave_link_show_doc__ (fname);
     else
   
       if (ftype == 2 || ftype == 3)
         ffile = which (fname);
       else
         ffile = "";
diff --git a/scripts/help/doc_cache_create.m b/scripts/help/doc_cache_create.m
--- a/scripts/help/doc_cache_create.m
+++ b/scripts/help/doc_cache_create.m
@@ -114,35 +114,35 @@ function cache = create_cache (list)
   endfor
 endfunction
 
 function cache = gen_doc_cache_in_dir (directory)
 
   ## If 'directory' is not in the current path, add it so we search it
   dir_in_path = ismember (directory, ostrsplit (path (), pathsep ()));
 
-  # dirs not in path
+  ## dirs not in path
   if (! iscell (directory))
     directory = {directory};
   endif
   dirs_notpath = {directory{!dir_in_path}};
 
-  # add them
+  ## add them
   if (! isempty (dirs_notpath))
     cellfun (@addpath, dirs_notpath);
   endif
 
-  # create cache
+  ## create cache
   func = @(s_) create_cache (__list_functions__ (s_));
   cache = cellfun (func, directory, 'UniformOutput', false);
 
-  # concatenate results
+  ## concatenate results
   cache = [cache{:}];
 
-  #remove dirs form path
+  ## remove dirs form path
   if (! isempty (dirs_notpath))
     cellfun (@rmpath, dirs_notpath);
   endif
 
 endfunction
 
 function cache = gen_builtin_cache ()
   operators = __operators__ ();
diff --git a/scripts/image/colorcube.m b/scripts/image/colorcube.m
--- a/scripts/image/colorcube.m
+++ b/scripts/image/colorcube.m
@@ -41,41 +41,41 @@ function map = colorcube (n)
     print_usage ();
   endif
 
   if (n < 9)
     map = gray (n);
     return;
   endif
 
-  # Create colorcube of evenly spaced points with side length of n^1/3
+  ## Create colorcube of evenly spaced points with side length of n^1/3
   cubelen = fix (cbrt (n));
   reserve = n - cubelen^3; 
 
   if (reserve == 0)
-    # Steal space from blue to put the gray gradient
+    ## Steal space from blue to put the gray gradient
     [r, g, b] = meshgrid (linspace (0,1,cubelen),
                           linspace (0,1,cubelen),
                           linspace (0,1,cubelen-1));
   else
     [r, g, b] = meshgrid (linspace (0,1,cubelen),
                           linspace (0,1,cubelen),
                           linspace (0,1,cubelen));
   endif
 
-  # Create map and weed out grays
+  ## Create map and weed out grays
   map = [r(:), g(:), b(:)];
   idx = any (bsxfun (@ne, map(:, 1), map(:, 2:3)), 2);
   map = map(idx, :);
 
-  # Weed out pure colors
+  ## Weed out pure colors
   idx = sum (map == 0, 2);
   map = map(idx != 2, :);
 
-  # Put in remaining gradients of pure red, green, blue, and gray
+  ## Put in remaining gradients of pure red, green, blue, and gray
   reserve = n - rows (map) - 1;
   csteps = fix (reserve/4);
   cstepsz = 1 / csteps;
   cgrad = (cstepsz:cstepsz:1)';
   gsteps = reserve - 3*csteps;
   gstepsz = 1 / gsteps;
   ggrad = (gstepsz:gstepsz:1)';
   map = [map
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -70,18 +70,18 @@ function rgb_map = hsv2rgb (hsv_map)
   if (! isreal (hsv_map) || columns (hsv_map) != 3 || issparse (hsv_map))
     error ("hsv2rgb: input must be a matrix of size Nx3 or MxNx3");
   endif
 
   ## FIXME: Currently input is validated and an error results if values
   ##        are outside range [0, 1].  We could also simply allow those values
   ##        and re-instate this code to produce saturating semantics.
   ## Trim map to range [0, 1]
-  #hsv_map(hsv_map < 0) = 0;
-  #hsv_map(hsv_map > 1) = 1;
+  ## hsv_map(hsv_map < 0) = 0;
+  ## hsv_map(hsv_map > 1) = 1;
 
   h = hsv_map(:,1);
   s = hsv_map(:,2);
   v = hsv_map(:,3);
   ## Prefill rgb map with v*(1-s)
   rgb_map = repmat (v .* (1 - s), 1, 3);
 
   ## red = hue-2/3 : green = hue : blue = hue-1/3
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -165,17 +165,17 @@ function h = __img__ (hax, x, y, img, va
       mx = intmax (cls);
       set (hax, "clim", double ([mn, mx]));
     endif
   endif
 
   set (hax, "view", [0, 90]);
 
   if (strcmp (get (hax, "nextplot"), "replace"))
-    # Always reverse y-axis for images, unless hold is on
+    ## Always reverse y-axis for images, unless hold is on
     set (hax, "ydir", "reverse");
   endif
 
   if (nargout > 0)
     h = htmp;
   endif
 
 endfunction
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -835,24 +835,24 @@ endfunction
 %! assert (c{1}, {"Tom"; "Dick"; "Harry"})
 %! assert (c{2}, [100; 90; 80])
 
 %!test
 %! a = strread ("a b c, d e, , f", "%s", "delimiter", ",");
 %! assert (a, {"a b c"; "d e"; ""; "f"});
 
 %!test
-%! # Bug #33536
+%! ## Bug #33536
 %! [a, b, c] = strread ("1,,2", "%s%s%s", "delimiter", ",");
 %! assert (a{1}, "1");
 %! assert (b{1}, "");
 %! assert (c{1}, "2");
 
 %!test
-%! # Bug #33536
+%! ## Bug #33536
 %! a = strread ("[SomeText]", "[%s", "delimiter", "]");
 %! assert (a{1}, "SomeText");
 
 %!test
 %! dat = "Data file.\r\n=  =  =  =  =\r\nCOMPANY    : <Company name>\r\n";
 %! a = strread (dat, "%s", "delimiter", "\n", "whitespace", "", "endofline", "\r\n");
 %! assert (a{2}, "=  =  =  =  =");
 %! assert (double (a{3}(end-5:end)), [32 110 97 109 101 62]);
@@ -863,34 +863,34 @@ endfunction
 %! assert (d, NaN);
 
 %!test
 %! [a, b, c, d] = strread ("1,2,3,,5,6\n", "%d%d%f%d", "delimiter", ",");
 %! assert (c, [3; NaN]);
 %! assert (d, int32 ([0; 0]));
 
 %!test
-%! # Default format (= %f)
+%! ## Default format (= %f)
 %1 [a, b, c] = strread ("0.12 0.234 0.3567");
 %1 assert (a, 0.12);
 %1 assert (b, 0.234);
 %1 assert (c, 0.3567);
 
 %!test
 %! [a, b] = strread ("0.41 8.24 3.57 6.24 9.27", "%f%f", 2, "delimiter", " ");
 %1 assert (a, [0.41; 3.57]);
 
 %!test
-%! # TreatAsEmpty
+%! ## TreatAsEmpty
 %! [a, b, c, d] = strread ("1,2,3,NN,5,6\n", "%d%d%d%f", "delimiter", ",", "TreatAsEmpty", "NN");
 %! assert (c, int32 ([3; 0]));
 %! assert (d, [NaN; NaN]);
 
 %!test
-%! # No delimiters at all besides EOL.  Plain reading numbers & strings
+%! ## No delimiters at all besides EOL.  Plain reading numbers & strings
 %! str = "Text1Text2Text\nText398Text4Text\nText57Text";
 %! [a, b] = strread (str, "Text%dText%1sText");
 %! assert (a, int32 ([1; 398; 57]));
 %! assert (b(1:2), {"2"; "4"});
 %! assert (isempty (b{3}), true);
 
 %% MultipleDelimsAsOne
 %!test
@@ -953,24 +953,24 @@ endfunction
 %! assert (b, NaN);
 
 %!test
 %! [a, b] = strread (["Empty" char(10)], "Empty%f %f");
 %! assert (a, NaN);
 %! assert (b, NaN);
 
 %!test
-%! # Bug #35999
+%! ## Bug #35999
 %! [a, b, c] = strread ("", "%f");
 %! assert (isempty (a));
 %! assert (isempty (b));
 %! assert (isempty (c));
 
-%% bug #37023
 %!test
+%! ## bug #37023
 %! [a, b] = strread (" 1. 1 \n  2 3 \n", "%f %f", "endofline", "\n");
 %! assert (a, [1; 2], 1e-15);
 %! assert (b, [1; 3], 1e-15);
 
 %% Test for no output arg (interactive use)
 %!test
 %! assert (strread (",2,,4\n5,,7,", "", "delimiter", ","), [NaN; 2; NaN; 4; 5; NaN; 7]);
 
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -75,18 +75,18 @@
 ##
 ## @seealso{dlmread, fscanf, load, strread, textread}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 
 function [C, position] = textscan (fid, format = "%f", varargin)
 
-  BUFLENGTH = 4096;               ## Read buffer
-  emptfmt = 0;                    ## Signals deliberately empty format string
+  BUFLENGTH = 4096;               # Read buffer
+  emptfmt = 0;                    # Signals deliberately empty format string
 
   ## Check input
   if (nargin < 1)
     print_usage ();
   endif
 
   if (isempty (format))
     emptfmt = 1;
@@ -434,17 +434,17 @@ endfunction
 %! assert (c{:}, {"L1"; "L2"});
 
 %% Test with endofline parameter set to "" (empty) - newline should be in word
 %!test
 %! c = textscan ("L1\nL2", "%s", "endofline", "");
 %! assert (int8 (c{:}{:}), int8 ([ 76,  49,  10,  76,  50 ]));
 
 %!test
-%! # No delimiters at all besides EOL.  Skip fields, even empty fields
+%! ## No delimiters at all besides EOL.  Skip fields, even empty fields
 %! str = "Text1Text2Text\nTextText4Text\nText57Text";
 %! c = textscan (str, "Text%*dText%dText");
 %! assert (c{1}, int32 ([2; 4; 0]));
 
 %!test
 %% CollectOutput test
 %! b = [10:10:100];
 %! b = [b; 8*b/5; 8*b*1000/5];
diff --git a/scripts/miscellaneous/bzip2.m b/scripts/miscellaneous/bzip2.m
--- a/scripts/miscellaneous/bzip2.m
+++ b/scripts/miscellaneous/bzip2.m
@@ -39,17 +39,17 @@ function entries = bzip2 (varargin)
   else
     print_usage ();
   endif
 
 endfunction
 
 
 %!xtest
-%! # test for correct cleanup of temporary files
+%! ## test for correct cleanup of temporary files
 %! unwind_protect
 %!   filename = tmpnam;
 %!   dummy    = 1;
 %!   save (filename, "dummy");
 %!   n_tmpfiles_before = length (find (strncmp ("oct-", cellstr (ls (tempdir)), 4)));
 %!   entry = bzip2 (filename);
 %!   n_tmpfiles_after = length (find (strncmp ("oct-", cellstr (ls (tempdir)), 4)));
 %!   if (n_tmpfiles_before != n_tmpfiles_after)
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -156,17 +156,17 @@ function ret = edit (varargin)
   persistent FUNCTION = struct ("EDITOR", [EDITOR() " %s"],
                                 "HOME", fullfile (default_home, "octave"),
                                 "AUTHOR", default_user(1),
                                 "EMAIL", [],
                                 "LICENSE", "GPL",
                                 "MODE", "async",
                                 "EDITINPLACE", false);
   ## Make sure the stateval variables survive "clear functions".
-  #mlock;
+  mlock;
 
   if (nargin == 1)
     ## User has supplied one arg, this can be a single file name
     ## or a cell array of strings containing multiple files to be opened
     if (iscellstr (varargin{1}))
       ## If first arg is a cell array of strings, 
       ## it becomes the list of files to be edited
       editfilelist = varargin{1};
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -37,17 +37,17 @@ function entries = gzip (varargin)
   else
     entries = __xzip__ ("gzip", "gz", "gzip -r %s", varargin{:});
   endif
 
 endfunction
 
 
 %!xtest
-%! # test gzip together with gunzip
+%! ## test gzip together with gunzip
 %! unwind_protect
 %!   filename = tmpnam;
 %!   dummy    = 1;
 %!   save (filename, "dummy");
 %!   dirname  = tmpnam;
 %!   mkdir (dirname);
 %!   entry = gzip (filename, dirname);
 %!   [path, basename, extension] = fileparts (filename);
diff --git a/scripts/optimization/__all_opts__.m b/scripts/optimization/__all_opts__.m
--- a/scripts/optimization/__all_opts__.m
+++ b/scripts/optimization/__all_opts__.m
@@ -44,17 +44,17 @@ function names = __all_opts__ (varargin)
     recursive = true;
     names = saved_names;
     for i = 1:nargin
       try
         opts = optimset (varargin{i});
         fn = fieldnames (opts).';
         names = [names, fn];
       catch
-        # throw the error as a warning.
+        ## throw the error as a warning.
         warning (lasterr ());
       end_try_catch
     endfor
     names = unique (names);
     [lnames, idx] = unique (tolower (names));
     if (length (lnames) < length (names))
       ## This is bad.
       error ("__all_opts__: duplicate options with inconsistent case");
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -264,17 +264,17 @@ function print_exit_msg (info, opt=struc
     case 1
       printf ("Optimization terminated:\n");
       printf (" the current x satisfies the termination criteria using OPTIONS.TolX of %e\n", opt.TolX);
     case 0
       printf ("Exiting: Maximum number of iterations has been exceeded\n");
       printf ("         - increase MaxIter option.\n");
       printf ("         Current function value: %.6f\n", opt.fx);
     case -1
-      "FIXME"; ## FIXME: what's the message MATLAB prints for this case?
+      "FIXME"; # FIXME: what's the message MATLAB prints for this case?
     otherwise
       error ("internal error - fminbnd() is bug, sorry!");
   endswitch
   printf ("\n");
 endfunction
 
 
 %!shared opt0
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -181,18 +181,17 @@
 ##   -0.0052227
 ## @end example
 ##
 ## @seealso{qp}
 ## @end deftypefn
 
 function [x, obj, info, iter, nf, lambda] = sqp (x0, objf, cef, cif, lb, ub, maxiter, tolerance)
 
-  globals = struct (); # data and handles, needed and changed by
-                       # subfunctions
+  globals = struct (); # data and handles, needed and changed by subfunctions
 
   if (nargin < 2 || nargin > 8 || nargin == 5)
     print_usage ();
   endif
 
   if (!isvector (x0))
     error ("sqp: X0 must be a vector");
   endif
diff --git a/scripts/pkg/private/get_forge_pkg.m b/scripts/pkg/private/get_forge_pkg.m
--- a/scripts/pkg/private/get_forge_pkg.m
+++ b/scripts/pkg/private/get_forge_pkg.m
@@ -44,17 +44,17 @@ function [ver, url] = get_forge_pkg (nam
     ## Good. Let's grep for the version.
     pat = "<tdclass=""package_table"">PackageVersion:</td><td>([\\d.]*)</td>";
     t = regexp (html, pat, "tokens");
     if (isempty (t) || isempty (t{1}))
       error ("get_forge_pkg: could not read version number from package's page");
     else
       ver = t{1}{1};
       if (nargout > 1)
-        # Build download string.
+        ## Build download string.
         pkg_file = sprintf ("%s-%s.tar.gz", name, ver);
         url = ["http://packages.octave.org/download/" pkg_file];
         ## Verify that the package string exists on the page.
         if (isempty (strfind (html, pkg_file)))
           warning ("get_forge_pkg: download URL not verified");
         endif
       endif
     endif
diff --git a/scripts/plot/area.m b/scripts/plot/area.m
--- a/scripts/plot/area.m
+++ b/scripts/plot/area.m
@@ -224,27 +224,27 @@ function update_data (h, d)
     endif
 
     y0 = y1;
   endfor
 endfunction
 
 
 %!demo
-%! # Verify identity sin^2 + cos^2 = 1
+%! ## Verify identity sin^2 + cos^2 = 1
 %! clf;
 %! t = linspace (0, 2*pi, 100)';
 %! y = [sin(t).^2, cos(t).^2];
 %! area (t, y);
 %! axis tight
 %! legend ('sin^2', 'cos^2', 'location', 'NorthEastOutside');  
 %! title ('area() plot');
 
 %!demo
-%! # Show effects of setting BaseValue
+%! ## Show effects of setting BaseValue
 %! clf;
 %! x = [-2:0.1:2]';
 %! y = x.^2 - 1;
 %! subplot (1, 2, 1)
 %! area (x, y);
 %! title ({'Parabola y = x^2 -1';'BaseValue = 0'});
 %! subplot (1, 2, 2)
 %! h = area (x, y);
@@ -253,8 +253,9 @@ endfunction
 
 %!demo
 %! clf;
 %! x = 0:10;
 %! y = rand (size (x));
 %! h = area (x, y);
 %! set (h, 'ydata', sort (get (h, 'ydata')))
 %! title ('area() plot of sorted data');
+
diff --git a/scripts/plot/stemleaf.m b/scripts/plot/stemleaf.m
--- a/scripts/plot/stemleaf.m
+++ b/scripts/plot/stemleaf.m
@@ -190,17 +190,17 @@ function plotstr = stemleaf (x, caption,
   o_fence_l = hl - 2*step;      # outer fences: outside hinges + 2*step
   i_fence_h = hu + step;
   o_fence_h = hu + 2*step;
   n_out_l   = sum (x<i_fence_l) - sum (x<o_fence_l);
   n_out_h   = sum (x>i_fence_h) - sum (x>o_fence_h);
   n_far_l   = sum (x<o_fence_l);
   n_far_h   = sum (x>o_fence_h);
 
-  # display table similar to that on pg. 33
+  ## display table similar to that on pg. 33
   plot_out = sprintf ("       Data: %s", caption);
   plot_out = [plot_out; sprintf(" ")];
   plot_out = [plot_out; sprintf("         Fenced Letter Display")];
   plot_out = [plot_out; sprintf(" ")];
   plot_out = [plot_out; sprintf("     #%3d|___________________", nx)];
   plot_out = [plot_out; sprintf("     M%3d|       %5d      |", mdidx, md)];
   plot_out = [plot_out; sprintf("     H%3d|%5d        %5d|   %d", hlidx, hl, hu, h_spread)];
   plot_out = [plot_out; sprintf("     1   |%5d        %5d|", xs(1), xs(nx))];
diff --git a/scripts/plot/surfc.m b/scripts/plot/surfc.m
--- a/scripts/plot/surfc.m
+++ b/scripts/plot/surfc.m
@@ -77,17 +77,17 @@ function h = surfc (varargin)
     if (! ishold ())
       set (hax, "view", [-37.5, 30],
                 "xgrid", "on", "ygrid", "on", "zgrid", "on",
                 "xlimmode", "manual", "ylimmode", "manual");
     endif
 
     drawnow ();
 
-    # don't pass string arguments to __contour__()
+    ## don't pass string arguments to __contour__()
     stop_idx = find (cellfun ("isclass", varargin, "char"), 1);
     if (isempty (stop_idx))
       stop_idx = nargin;
     else
       stop_idx--;
     endif
 
     if (stop_idx - 1 == 1 || stop_idx - 1 == 3)
diff --git a/scripts/plot/uiresume.m b/scripts/plot/uiresume.m
--- a/scripts/plot/uiresume.m
+++ b/scripts/plot/uiresume.m
@@ -34,12 +34,12 @@ function uiresume (h)
   endif
 
   try
     uiwait_state = get (h, "__uiwait_state__");
     if (strcmp (uiwait_state, "active"))
       set (h, "__uiwait_state__", "triggered");
     endif
   catch
-    # Ignore exception
+    ## Ignore exception
   end_try_catch
 
 endfunction
diff --git a/scripts/plot/zlabel.m b/scripts/plot/zlabel.m
--- a/scripts/plot/zlabel.m
+++ b/scripts/plot/zlabel.m
@@ -72,15 +72,13 @@ endfunction
 
 %!test
 %! hf = figure ("visible", "off");
 %! plot3 (0, 0, 0);
 %! unwind_protect
 %!   z = zlabel ("zlabel_string");
 %!   assert (get (gca, "zlabel"), z);
 %!   assert (get (z, "type"), "text");
-%!   ## FIXME: visible test is failing.  Not sure why.
-%!   #assert (get (z, "visible"), "off");
 %!   assert (get (z, "string"), "zlabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -40,22 +40,22 @@
 ## In any case @var{coefs} is reshaped to a 2-D matrix of
 ## size @code{[@var{ni}*prod(@var{d} @var{m})] }
 ##
 ## @seealso{unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps}
 ## @end deftypefn
 
 function pp = mkpp (x, P, d)
 
-  # check number of arguments
+  ## check number of arguments
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
-  # check x
+  ## check x
   if (length (x) < 2)
     error ("mkpp: at least one interval is needed");
   endif
 
   if (!isvector (x))
     error ("mkpp: x must be a vector");
   endif
 
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -90,17 +90,17 @@ function yi = ppval (pp, xi)
   endif
 
   if (isvector (xi) && (d == 1))
     yi = reshape (yi, sxi);
   elseif (isfield (pp, "orient") && strcmp (pp.orient, "first"))
     yi = shiftdim (yi, nd);
   endif
 
-  ##
+  ## FIXME: Why is this commented out, rather than just removed?
   #if (d == 1)
   #  yi = reshape (yi, sxi);
   #endif
 
 endfunction
 
 
 %!shared b, c, pp, pp2, xi, abserr
diff --git a/scripts/set/intersect.m b/scripts/set/intersect.m
--- a/scripts/set/intersect.m
+++ b/scripts/set/intersect.m
@@ -55,29 +55,29 @@ function [c, ia, ib] = intersect (a, b, 
     if (nargin > 2)
       c = [a; b];
       [c, ic] = sortrows (c);
       ii = find (all (c(1:end-1,:) == c(2:end,:), 2));
       c = c(ii,:);
       len_a = rows (a);
     else
       c = [a(:); b(:)];
-      [c, ic] = sort (c);               ## [a(:);b(:)](ic) == c
+      [c, ic] = sort (c);               # [a(:);b(:)](ic) == c
       if (iscellstr (c))
         ii = find (strcmp (c(1:end-1), c(2:end)));
       else
         ii = find (c(1:end-1) == c(2:end));
       endif
       c = c(ii);
       len_a = length (a);
     endif
 
     if (nargout > 1)
-      ia = ja(ic(ii));                  ## a(ia) == c
-      ib = jb(ic(ii+1) - len_a);        ## b(ib) == c
+      ia = ja(ic(ii));                  # a(ia) == c
+      ib = jb(ic(ii+1) - len_a);        # b(ib) == c
     endif
 
     if (nargin == 2 && (rows (b) == 1 || rows (a) == 1))
       c = c.';
     endif
   endif
 
 endfunction
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -173,17 +173,17 @@ function [h_r, f_r] = freqz (b, a, n, re
     ## Plot and don't return values.
     freqz_plot (f, h);
   endif
 
 endfunction
 
 
 %!test # correct values and fft-polyval consistency
-%! # butterworth filter, order 2, cutoff pi/2 radians
+%! ## butterworth filter, order 2, cutoff pi/2 radians
 %! b = [0.292893218813452  0.585786437626905  0.292893218813452];
 %! a = [1  0  0.171572875253810];
 %! [h,w] = freqz (b,a,32);
 %! assert (h(1),1,10*eps);
 %! assert (abs (h(17)).^2,0.5,10*eps);
 %! assert (h,freqz (b,a,w),10*eps); # fft should be consistent with polyval
 
 %!test # whole-half consistency
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -386,150 +386,150 @@ function [x, flag, relres, iter, resvec,
     if (nargout < 2)
       warning ("pcg: matrix not positive definite?\n");
     endif
   endif
 endfunction
 
 
 %!demo
-%!  # Simplest usage of pcg (see also 'help pcg')
-%! 
-%!  N = 10;
-%!  A = diag ([1:N]); b = rand (N, 1);
-%!  y = A \ b;  # y is the true solution
-%!  x = pcg (A, b);
-%!  printf ("The solution relative error is %g\n", norm (x - y) / norm (y));
-%! 
-%!  # You shouldn't be afraid if pcg issues some warning messages in this
-%!  # example: watch out in the second example, why it takes N iterations
-%!  # of pcg to converge to (a very accurate, by the way) solution
+%! ## Simplest usage of pcg (see also 'help pcg')
+%!
+%! N = 10;
+%! A = diag ([1:N]); b = rand (N, 1);
+%! y = A \ b;  # y is the true solution
+%! x = pcg (A, b);
+%! printf ("The solution relative error is %g\n", norm (x - y) / norm (y));
+%!
+%! ## You shouldn't be afraid if pcg issues some warning messages in this
+%! ## example: watch out in the second example, why it takes N iterations
+%! ## of pcg to converge to (a very accurate, by the way) solution
 
 %!demo
-%!  # Full output from pcg, except for the eigenvalue estimates
-%!  # We use this output to plot the convergence history
-%! 
-%!  N = 10;
-%!  A = diag ([1:N]); b = rand (N, 1);
-%!  X = A \ b;  # X is the true solution
-%!  [x, flag, relres, iter, resvec] = pcg (A, b);
-%!  printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
-%!  title ("Convergence history");
-%!  semilogy ([0:iter], resvec / resvec(1), "o-g");
-%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
-%!  legend ("relative residual");
+%! ## Full output from pcg, except for the eigenvalue estimates
+%! ## We use this output to plot the convergence history
+%!
+%! N = 10;
+%! A = diag ([1:N]); b = rand (N, 1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter, resvec] = pcg (A, b);
+%! printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
+%! title ("Convergence history");
+%! semilogy ([0:iter], resvec / resvec(1), "o-g");
+%! xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
+%! legend ("relative residual");
 
 %!demo
-%!  # Full output from pcg, including the eigenvalue estimates
-%!  # Hilbert matrix is extremely ill-conditioned, so pcg WILL have problems
-%! 
-%!  N = 10;
-%!  A = hilb (N); b = rand (N, 1);
-%!  X = A \ b;  # X is the true solution
-%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], 200);
-%!  printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
-%!  printf ("Condition number estimate is %g\n", eigest(2) / eigest(1));
-%!  printf ("Actual condition number is   %g\n", cond (A));
-%!  title ("Convergence history");
-%!  semilogy ([0:iter], resvec, ["o-g";"+-r"]);
-%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
-%!  legend ("absolute residual", "absolute preconditioned residual");
+%! ## Full output from pcg, including the eigenvalue estimates
+%! ## Hilbert matrix is extremely ill-conditioned, so pcg WILL have problems
+%!
+%! N = 10;
+%! A = hilb (N); b = rand (N, 1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], 200);
+%! printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
+%! printf ("Condition number estimate is %g\n", eigest(2) / eigest(1));
+%! printf ("Actual condition number is   %g\n", cond (A));
+%! title ("Convergence history");
+%! semilogy ([0:iter], resvec, ["o-g";"+-r"]);
+%! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%! legend ("absolute residual", "absolute preconditioned residual");
 
 %!demo
-%!  # Full output from pcg, including the eigenvalue estimates
-%!  # We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
-%!  # and that's the reason we need some preconditioner; here we take
-%!  # a very simple and not powerful Jacobi preconditioner,
-%!  # which is the diagonal of A
+%! ## Full output from pcg, including the eigenvalue estimates
+%! ## We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
+%! ## and that's the reason we need some preconditioner; here we take
+%! ## a very simple and not powerful Jacobi preconditioner,
+%! ## which is the diagonal of A.
 %!
-%!  N = 100;
-%!  A = zeros (N, N);
-%!  for i = 1 : N - 1 # form 1-D Laplacian matrix
-%!    A(i:i+1, i:i+1) = [2 -1; -1 2];
-%!  endfor
-%!  b = rand (N, 1);
-%!  X = A \ b;  # X is the true solution
-%!  maxit = 80;
-%!  printf ("System condition number is %g\n", cond (A));
-%!  # No preconditioner: the convergence is very slow!
+%! N = 100;
+%! A = zeros (N, N);
+%! for i = 1 : N - 1 # form 1-D Laplacian matrix
+%!   A(i:i+1, i:i+1) = [2 -1; -1 2];
+%! endfor
+%! b = rand (N, 1);
+%! X = A \ b;  # X is the true solution
+%! maxit = 80;
+%! printf ("System condition number is %g\n", cond (A));
+%! ## No preconditioner: the convergence is very slow!
 %!
-%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit);
-%!  printf ("System condition number estimate is %g\n", eigest(2) / eigest(1));
-%!  title ("Convergence history");
-%!  semilogy ([0:iter], resvec(:,1), "o-g");
-%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
-%!  legend ("NO preconditioning: absolute residual");
+%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit);
+%! printf ("System condition number estimate is %g\n", eigest(2) / eigest(1));
+%! title ("Convergence history");
+%! semilogy ([0:iter], resvec(:,1), "o-g");
+%! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%! legend ("NO preconditioning: absolute residual");
 %!
-%!  pause (1);
-%!  # Test Jacobi preconditioner: it will not help much!!!
+%! pause (1);
+%! ## Test Jacobi preconditioner: it will not help much!!!
 %!
-%!  M = diag (diag (A)); # Jacobi preconditioner
-%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
-%!  printf ("JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
-%!  hold on;
-%!  semilogy ([0:iter], resvec(:,1), "o-r");
-%!  legend ("NO preconditioning: absolute residual", ...
-%!          "JACOBI preconditioner: absolute residual");
+%! M = diag (diag (A)); # Jacobi preconditioner
+%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
+%! printf ("JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
+%! hold on;
+%! semilogy ([0:iter], resvec(:,1), "o-r");
+%! legend ("NO preconditioning: absolute residual", ...
+%!         "JACOBI preconditioner: absolute residual");
 %!
-%!  pause (1);
-%!  # Test nonoverlapping block Jacobi preconditioner: it will help much!
+%! pause (1);
+%! ## Test nonoverlapping block Jacobi preconditioner: it will help much!
 %!
-%!  M = zeros (N, N); k = 4;
-%!  for i = 1 : k : N # form 1-D Laplacian matrix
-%!    M(i:i+k-1, i:i+k-1) = A(i:i+k-1, i:i+k-1);
-%!  endfor
-%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
-%!  printf ("BLOCK JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
-%!  semilogy ([0:iter], resvec(:,1), "o-b");
-%!  legend ("NO preconditioning: absolute residual", ...
-%!          "JACOBI preconditioner: absolute residual", ...
-%!          "BLOCK JACOBI preconditioner: absolute residual");
-%!  hold off;
+%! M = zeros (N, N); k = 4;
+%! for i = 1 : k : N # form 1-D Laplacian matrix
+%!   M(i:i+k-1, i:i+k-1) = A(i:i+k-1, i:i+k-1);
+%! endfor
+%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
+%! printf ("BLOCK JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
+%! semilogy ([0:iter], resvec(:,1), "o-b");
+%! legend ("NO preconditioning: absolute residual", ...
+%!         "JACOBI preconditioner: absolute residual", ...
+%!         "BLOCK JACOBI preconditioner: absolute residual");
+%! hold off;
 
 %!test
-%! # solve small diagonal system
+%! ## solve small diagonal system
 %!
 %! N = 10;
 %! A = diag ([1:N]); b = rand (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag] = pcg (A, b, [], N+1);
 %! assert (norm (x - X) / norm (X), 0, 1e-10);
 %! assert (flag, 0);
 
 %!test
-%! # solve small indefinite diagonal system
-%! # despite A is indefinite, the iteration continues and converges
-%! # indefiniteness of A is detected
+%! ## solve small indefinite diagonal system
+%! ## despite A is indefinite, the iteration continues and converges
+%! ## indefiniteness of A is detected
 %!
 %! N = 10;
 %! A = diag([1:N] .* (-ones(1, N) .^ 2)); b = rand (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag] = pcg (A, b, [], N+1);
 %! assert (norm (x - X) / norm (X), 0, 1e-10);
 %! assert (flag, 3);
 
 %!test
-%! # solve tridiagonal system, do not converge in default 20 iterations
+%! ## solve tridiagonal system, do not converge in default 20 iterations
 %!
 %! N = 100;
 %! A = zeros (N, N);
 %! for i = 1 : N - 1 # form 1-D Laplacian matrix
 %!   A(i:i+1, i:i+1) = [2 -1; -1 2];
 %! endfor
 %! b = ones (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, 1e-12);
 %! assert (flag);
 %! assert (relres > 1.0);
 %! assert (iter, 20); # should perform max allowable default number of iterations
 
 %!test
-%! # solve tridiagonal system with 'perfect' preconditioner
-%! # which converges in one iteration, so the eigest does not
-%! # work and issues a warning
+%! ## solve tridiagonal system with 'perfect' preconditioner
+%! ## which converges in one iteration, so the eigest does not
+%! ## work and issues a warning
 %!
 %! N = 100;
 %! A = zeros (N, N);
 %! for i = 1 : N - 1 # form 1-D Laplacian matrix
 %!         A (i:i+1, i:i+1) = [2 -1; -1 2];
 %! endfor
 %! b = ones (N, 1);
 %! X = A \ b;  # X is the true solution
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -298,140 +298,140 @@ function [x, flag, relres, iter, resvec]
       warning ("system matrix singular or preconditioner indefinite?\n");
     endif
   endif
 
 endfunction
 
 
 %!demo
-%! # Simplest usage of PCR (see also 'help pcr')
+%! ## Simplest usage of PCR (see also 'help pcr')
 %!
 %! N = 20;
 %! A = diag (linspace (-3.1,3,N)); b = rand (N,1);
 %! y = A \ b;  # y is the true solution
 %! x = pcr (A,b);
 %! printf ("The solution relative error is %g\n", norm (x-y) / norm (y));
 %!
-%! # You shouldn't be afraid if PCR issues some warning messages in this
-%! # example: watch out in the second example, why it takes N iterations
-%! # of PCR to converge to (a very accurate, by the way) solution
+%! ## You shouldn't be afraid if PCR issues some warning messages in this
+%! ## example: watch out in the second example, why it takes N iterations
+%! ## of PCR to converge to (a very accurate, by the way) solution.
 
 %!demo
-%! # Full output from PCR
-%! # We use this output to plot the convergence history
+%! ## Full output from PCR
+%! ## We use this output to plot the convergence history
 %!
 %! N = 20;
 %! A = diag (linspace (-3.1,30,N)); b = rand (N,1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag, relres, iter, resvec] = pcr (A,b);
 %! printf ("The solution relative error is %g\n", norm (x-X) / norm (X));
 %! clf;
 %! title ("Convergence history");
 %! xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
 %! semilogy ([0:iter], resvec/resvec(1), "o-g;relative residual;");
 
 %!demo
-%! # Full output from PCR
-%! # We use indefinite matrix based on the Hilbert matrix, with one
-%! # strongly negative eigenvalue
-%! # Hilbert matrix is extremely ill conditioned, so is ours,
-%! # and that's why PCR WILL have problems
+%! ## Full output from PCR
+%! ## We use indefinite matrix based on the Hilbert matrix, with one
+%! ## strongly negative eigenvalue
+%! ## Hilbert matrix is extremely ill conditioned, so is ours,
+%! ## and that's why PCR WILL have problems
 %!
 %! N = 10;
 %! A = hilb (N); A(1,1) = -A(1,1); b = rand (N,1);
 %! X = A \ b;  # X is the true solution
 %! printf ("Condition number of A is   %g\n", cond (A));
 %! [x, flag, relres, iter, resvec] = pcr (A,b,[],200);
 %! if (flag == 3)
 %!   printf ("PCR breakdown.  System matrix is [close to] singular\n");
 %! end
 %! clf;
 %! title ("Convergence history");
 %! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
 %! semilogy ([0:iter], resvec, "o-g;absolute residual;");
 
 %!demo
-%! # Full output from PCR
-%! # We use an indefinite matrix based on the 1-D Laplacian matrix for A,
-%! # and here we have cond(A) = O(N^2)
-%! # That's the reason we need some preconditioner; here we take
-%! # a very simple and not powerful Jacobi preconditioner,
-%! # which is the diagonal of A
+%! ## Full output from PCR
+%! ## We use an indefinite matrix based on the 1-D Laplacian matrix for A,
+%! ## and here we have cond(A) = O(N^2)
+%! ## That's the reason we need some preconditioner; here we take
+%! ## a very simple and not powerful Jacobi preconditioner,
+%! ## which is the diagonal of A.
 %!
-%! # Note that we use here indefinite preconditioners!
+%! ## Note that we use here indefinite preconditioners!
 %!
 %! N = 100;
 %! A = zeros (N,N);
 %! for i=1:N-1 # form 1-D Laplacian matrix
 %!   A(i:i+1,i:i+1) = [2 -1; -1 2];
 %! endfor
 %! A = [A, zeros(size(A)); zeros(size(A)), -A];
 %! b = rand (2*N,1);
 %! X = A \ b;  # X is the true solution
 %! maxit = 80;
 %! printf ("System condition number is %g\n", cond (A));
-%! # No preconditioner: the convergence is very slow!
+%! ## No preconditioner: the convergence is very slow!
 %!
 %! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit);
 %! clf;
 %! title ("Convergence history");
 %! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
 %! semilogy ([0:iter], resvec, "o-g;NO preconditioning: absolute residual;");
 %!
 %! pause (1);
-%! # Test Jacobi preconditioner: it will not help much!!!
+%! ## Test Jacobi preconditioner: it will not help much!!!
 %!
 %! M = diag (diag (A)); # Jacobi preconditioner
 %! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
 %! hold on;
 %! semilogy ([0:iter],resvec,"o-r;JACOBI preconditioner: absolute residual;");
 %!
 %! pause (1);
-%! # Test nonoverlapping block Jacobi preconditioner: this one should give
-%! # some convergence speedup!
+%! ## Test nonoverlapping block Jacobi preconditioner: this one should give
+%! ## some convergence speedup!
 %!
 %! M = zeros (N,N); k = 4;
 %! for i=1:k:N # get k x k diagonal blocks of A
 %!   M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
 %! endfor
 %! M = [M, zeros(size (M)); zeros(size(M)), -M];
 %! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
 %! semilogy ([0:iter], resvec, "o-b;BLOCK JACOBI preconditioner: absolute residual;");
 %! hold off;
 
 %!test
-%! # solve small indefinite diagonal system
+%! ## solve small indefinite diagonal system
 %!
 %! N = 10;
 %! A = diag (linspace (-10.1,10,N)); b = ones (N,1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag] = pcr (A,b,[],N+1);
 %! assert (norm (x-X) / norm (X) < 1e-10);
 %! assert (flag, 0);
 
 %!test
-%! # solve tridiagonal system, do not converge in default 20 iterations
-%! # should perform max allowable default number of iterations
+%! ## solve tridiagonal system, do not converge in default 20 iterations
+%! ## should perform max allowable default number of iterations
 %!
 %! N = 100;
 %! A = zeros (N,N);
 %! for i=1:N-1 # form 1-D Laplacian matrix
 %!   A(i:i+1,i:i+1) = [2 -1; -1 2];
 %! endfor
 %! b = ones (N,1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag, relres, iter, resvec] = pcr (A,b,1e-12);
 %! assert (flag, 1);
 %! assert (relres > 0.6);
 %! assert (iter, 20);
 
 %!test
-%! # solve tridiagonal system with "perfect" preconditioner
-%! # converges in one iteration
+%! ## solve tridiagonal system with "perfect" preconditioner
+%! ## converges in one iteration
 %!
 %! N = 100;
 %! A = zeros (N,N);
 %! for i=1:N-1 # form 1-D Laplacian matrix
 %!   A(i:i+1,i:i+1) = [2 -1; -1 2];
 %! endfor
 %! b = ones (N,1);
 %! X = A \ b;  # X is the true solution
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -98,25 +98,25 @@ function [u, s, v, flag] = svds (A, k, s
     print_usage ();
   endif
 
   if (ndims (A) > 2)
     error ("svds: A must be a 2-D matrix");
   endif
 
   if (nargin < 4)
-    opts.tol = 0;   ## use ARPACK default
+    opts.tol = 0;    # use ARPACK default
     opts.disp = 0;
     opts.maxit = 300;
   else
     if (!isstruct (opts))
       error ("svds: OPTS must be a structure");
     endif
     if (!isfield (opts, "tol"))
-      opts.tol = 0;   ## use ARPACK default
+      opts.tol = 0;  # use ARPACK default
     else
       opts.tol = opts.tol / root2;
     endif
     if (isfield (opts, "v0"))
       if (!isvector (opts.v0) || (length (opts.v0) != sum (size (A))))
         error ("svds: OPTS.v0 must be a vector with rows(A)+columns(A) entries");
       endif
     endif
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -139,17 +139,17 @@ function [x_coordinate, y_coordinate, he
       ## Add to idx the vector of parent descendants.
       stk = [stk; [idx', ones(fliplr(size(idx))) * par_number]];
 
       ## We are in top level separator when we have one child and the
       ## flag is 1
       if (columns (idx) == 1 && top_level == 1)
         s++;
       else
-        # We aren't in top level separator now.
+        ## We aren't in top level separator now.
         top_level = 0;
       endif
       ## If there is not any descendant of "parent node":
       if (stk(end,2) != par_number)
        left_most++;
        x_coordinate_r(par_number) = left_most;
        max_ht = min (max_ht, level);
        if (length (stk) > 1 && find ((shift (stk,1) - stk) == 0) > 1
diff --git a/scripts/specfun/ellipke.m b/scripts/specfun/ellipke.m
--- a/scripts/specfun/ellipke.m
+++ b/scripts/specfun/ellipke.m
@@ -93,23 +93,24 @@ function [k, e] = ellipke (m)
     k(idx) = 0.5*pi./a;
     e(idx) = 0.5*pi.*(1 - sum)./a;
     k(idx_neg) = mult_k.*k(idx_neg);
     e(idx_neg) = mult_e.*e(idx_neg);
   endif
 
 endfunction
 
-%% Test complete elliptic functions of first and second kind
-%% against "exact" solution from Mathematica 3.0
+
+## Test complete elliptic functions of first and second kind
+## against "exact" solution from Mathematica 3.0
 %!test
 %! m = [0.0; 0.01; 0.1; 0.5; 0.9; 0.99; 1.0 ];
 %! [k,e] = ellipke (m);
 %!
-%! # K(1.0) is really infinity - see below
+%! ## K(1.0) is really infinity - see below
 %! k_exp = [1.5707963267948966192;
 %!          1.5747455615173559527;
 %!          1.6124413487202193982;
 %!          1.8540746773013719184;
 %!          2.5780921133481731882;
 %!          3.6956373629898746778;
 %!          0.0 ];
 %! e_exp = [1.5707963267948966192;
@@ -118,17 +119,17 @@ endfunction
 %!          1.3506438810476755025;
 %!          1.1047747327040733261;
 %!          1.0159935450252239356;
 %!          1.0 ];
 %! if (k(7)==Inf), k(7)=0; endif;
 %! assert (k, k_exp, 8*eps);
 %! assert (e, e_exp, 8*eps);
 
-%% Test against A&S Table 17.1
+## Test against A&S Table 17.1
 %!test
 %! m = [0:5:50]'/100;
 %! k_exp = [1.570796326794897;
 %!          1.591003453790792;
 %!          1.612441348720219;
 %!          1.635256732264580;
 %!          1.659623598610528;
 %!          1.685750354812596;
@@ -147,11 +148,12 @@ endfunction
 %!          1.422691133;
 %!          1.399392139;
 %!          1.375401972;
 %!          1.350643881 ];
 %! [k,e] = ellipke (m);
 %! assert (k, k_exp, 1e-15);
 %! assert (e, e_exp, 1e-8);
 
-%% Test input validation
+## Test input validation
 %!error ellipke ()
 %!error ellipke (1,2,3)
+
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -91,18 +91,18 @@ function retval = toeplitz (c, r)
   ## Hermitian-symmetric matrix (actually, this will really only be
   ## Hermitian-symmetric if the first element of the vector is real).
   if (nargin == 1 && iscomplex (c))
     c = conj (c);
     c(1) = conj (c(1));
   endif
 
   if (issparse (c) && issparse (r))
-    c = c(:).';  ## enforce row vector
-    r = r(:).';  ## enforce row vector
+    c = c(:).';  # enforce row vector
+    r = r(:).';  # enforce row vector
     cidx = find (c);
     ridx = find (r);
 
     ## Ignore the first element in r.
     ridx = ridx(ridx > 1);
 
     ## Form matrix.
     retval = spdiags (repmat (c(cidx),nr,1),1-cidx,nr,nc) + ...
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -57,17 +57,17 @@ function retval = dec2base (d, base, len
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (iscell (d))
     d = cell2mat (d);
   endif
 
-  # Create column vector for algorithm
+  ## Create column vector for algorithm
   if (! iscolumn (d))
     d = d(:);
   endif
   
   ## Treat logical as numeric for compatibility with ML
   if (islogical (d))
     d = double (d);
   elseif (! isnumeric (d) || iscomplex (d) || any (d < 0 | d != fix (d)))
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -154,17 +154,17 @@ function [result, matches] = strsplit (s
       print_usage ();
     endif
   endfor
 
   if (strcmpi (args.delimitertype, "default"))
     args.delimitertype = "simple";
   endif
 
-  # Save the length of the "delimitertype" parameter
+  ## Save the length of the "delimitertype" parameter
   length_deltype = numel (args.delimitertype);
 
   if (nargin == 1 || (nargin > 1 && (islogical (del) || isnumeric (del))))
     if (nargin > 1)
       ## Second input is the "collapsedelimiters" parameter
       args.collapsedelimiters = del;
     endif
     ## Set proper default for the delimiter type
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -353,17 +353,17 @@ function [__ret1, __ret2, __ret3, __ret4
       if (isempty (__name_position))
         __success = 0;
         __msg = sprintf ("%stest failed: missing function name\n",
                          __signal_fail);
       else
         __name = __block(__name_position(1):__name_position(2));
         __code = __block;
         try
-          eval (__code); ## Define the function
+          eval (__code);  # Define the function
           __clear = sprintf ("%sclear %s;\n", __clear, __name);
         catch
           __success = 0;
           __msg = sprintf ("%stest failed: syntax error\n%s",
                            __signal_fail, lasterr ());
         end_try_catch
       endif
       __code = "";
@@ -745,19 +745,19 @@ endfunction
 %! S = abs (S (2:fftn*4000/Fs,:)); # magnitude in range 0<f<=4000 Hz.
 %! S = S/max(max(S));          # normalize magnitude so that max is 0 dB.
 %! S = max (S, 10^(-40/10));   # clip below -40 dB.
 %! S = min (S, 10^(-3/10));    # clip above -3 dB.
 %! imagesc (flipud (20*log10 (S)), 1);
 %! % you should now see a spectrogram in the image window
 
 
-### now test test itself
+## now test 'test' itself
 
-%!## usage and error testing
+## usage and error testing
 % !fail ('test','usage.*test')           # no args, generates usage()
 % !fail ('test (1,2,3,4)','usage.*test') # too many args, generates usage()
 %!fail ('test ("test", "bogus")','unknown flag')  # incorrect args
 %!fail ('garbage','garbage.*undefined')  # usage on nonexistent function should be
 
 %!error test                     # no args, generates usage()
 %!error test (1,2,3,4)           # too many args, generates usage()
 %!error <unknown flag> test ("test", 'bogus'); # incorrect args, generates error()
@@ -765,17 +765,17 @@ endfunction
 
 %!error test ("test", 'bogus');  # test without pattern
 
 %!test
 %! lastwarn();            # clear last warning just in case
 
 %!warning <warning message> warning ('warning message');
 
-%!## test of shared variables
+## test of shared variables
 %!shared a                # create a shared variable
 %!test   a=3;             # assign to a shared variable
 %!test   assert (a,3)     # variable should equal 3
 %!shared b,c              # replace shared variables
 %!test assert (!exist ("a", "var"));  # a no longer exists
 %!test assert (isempty (b));   # variables start off empty
 %!shared a,b,c            # recreate a shared variable
 %!test assert (isempty (a));   # value is empty even if it had a previous value
@@ -803,27 +803,27 @@ endfunction
 %! x = 2*y;
 %! z = 3*y;
 %!endfunction
 %!test                   # Test a test function with multiple returns
 %! [x,z] = __test_a (3);
 %! assert (x,6);
 %! assert (z,9);
 
-%!## test of assert block
+## test of assert block
 %!assert (isempty ([]))      # support for test assert shorthand
 
-%!## demo blocks
+## demo blocks
 %!demo                   # multiline demo block
 %! t = [0:0.01:2*pi]; x = sin (t);
 %! plot (t,x);
 %! % you should now see a sine wave in your figure window
 %!demo a=3               # single line demo blocks work too
 
-%!## this is a comment block. it can contain anything.
+## this is a comment block. it can contain anything.
 %!##
 %! it is the "#" as the block type that makes it a comment
 %! and it stays as a comment even through continuation lines
 %! which means that it works well with commenting out whole tests
 
 % !# failure tests.  All the following should fail. These tests should
 % !# be disabled unless you are developing test() since users don't
 % !# like to be presented with expected failures.  I use % ! to disable.
diff --git a/test/build-sparse-tests.sh b/test/build-sparse-tests.sh
--- a/test/build-sparse-tests.sh
+++ b/test/build-sparse-tests.sh
@@ -648,44 +648,44 @@ gen_square_tests() {
 
 %!testif HAVE_UMFPACK   # permuted LU
 %! [L,U] = lu (bs);
 %! assert (L*U, bs, 1e-10);
 
 %!testif HAVE_UMFPACK   # simple LU + row permutations
 %! [L,U,P] = lu (bs);
 %! assert (P'*L*U, bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # simple LU + row/col permutations
 %! [L,U,P,Q] = lu (bs);
 %! assert (P'*L*U*Q', bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # LU with vector permutations
 %! [L,U,P,Q] = lu (bs,'vector');
 %! assert (L(P,:)*U(:,Q), bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # LU with scaling
 %! [L,U,P,Q,R] = lu (bs);
 %! assert (R*P'*L*U*Q', bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # inverse
 %! assert (inv (bs)*bs, sparse (eye (rows (bs))), 1e-10);
 
@@ -752,44 +752,44 @@ gen_rectangular_tests() {
     cat >>$TESTS <<EOF
 %!testif HAVE_UMFPACK   # permuted LU
 %! [L,U] = lu (bs);
 %! assert (L*U, bs, 1e-10);
 
 %!testif HAVE_UMFPACK   # simple LU + row permutations
 %! [L,U,P] = lu (bs);
 %! assert (P'*L*U, bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # simple LU + row/col permutations
 %! [L,U,P,Q] = lu (bs);
 %! assert (P'*L*U*Q', bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # LU with vector permutations
 %! [L,U,P,Q] = lu (bs,'vector');
 %! assert (L (P,:)*U (:,Q), bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # LU with scaling
 %! [L,U,P,Q,R] = lu (bs);
 %! assert (R*P'*L*U*Q', bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 EOF
 }
 
diff --git a/test/index.tst b/test/index.tst
--- a/test/index.tst
+++ b/test/index.tst
@@ -129,17 +129,17 @@
 %!assert (b(1,[]), zeros (1,0))
 %!assert (b(:,3), [5;7])
 %!assert (b([1,2],3), [5;7])
 %!assert (b(true (2,1), 3), [5;7])
 %!assert (b(false (2,1), 3), zeros (0,1))
 %!assert (b([],3), zeros (0,1))
 
 %!shared x
-%! # Dummy shared block to clear any previous definitions
+%! ## Dummy shared block to clear any previous definitions
 %! x = 1;
 
 %!test
 %! a(1,:) = [1,3];
 %! assert (a, [1,3]);
 
 %!test
 %! a(1,:) = [1;3];
diff --git a/test/system.tst b/test/system.tst
--- a/test/system.tst
+++ b/test/system.tst
@@ -135,17 +135,17 @@
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! s2 = stat (nm);
 %! fclose (id);
 %! unlink (nm);
 %!
 %! assert (deblank (s1.modestr), "-rw-rw-rw-");
 %! assert (deblank (s2.modestr), "----------");
-%! # Restore original umask value
+%! ## Restore original umask value
 %! umask (orig_umask);
 
 %!error <Invalid call to umask> umask ()
 
 %!error <Invalid call to umask> umask (1, 2)
 
 %!test
 %! [s, err, msg] = stat (filesep);
@@ -280,17 +280,17 @@
 %! warning (wns.state, "Octave:num-to-str");
 
 %!test
 %! xdir = pwd ();
 %! cd /
 %! d1 = pwd ();
 %! cd (xdir);
 %! if (ispc () && ! isunix ())
-%!   # should be a drive letter
+%!   ## should be a drive letter
 %!   assert (length (d1), 3);
 %!   assert (d1(2), ":");
 %!   assert (d1(3), "\\");
 %! else
 %!   assert ("/", d1);
 %! endif
 %! assert (pwd (), xdir);
 
