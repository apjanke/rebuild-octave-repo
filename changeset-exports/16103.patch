# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1361845851 18000
#      Mon Feb 25 21:30:51 2013 -0500
# Node ID 6434f70f0ee045ce9c3b54f9ce8757026f193c2f
# Parent  679a54d274d92cc1b36814579f3cbd27687bc3e3
move input_line_number and current_input_column to lexical_feedback class

* lex.h, lex.ll (input_line_number, current_input_column): Move global
variables to lexical_feedback class.  Change all uses.
(reset_parser): Don't reset input_line_number or current_input_column.
* oct-parse.yy (eval_string, parse_fcn_file): Don't protect
input_line_number or current_input_column here.
(parse_fcn_file): Protect lexer_flags prior to calling
gobble_leading_whitespace.  Use reset_parser to reset lexer_flags.

diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -67,16 +67,17 @@ public:
       looking_at_anon_fcn_args (false), looking_at_return_list (false),
       looking_at_parameter_list (false), looking_at_decl_list (false),
       looking_at_initializer_expression (false),
       looking_at_matrix_or_assign_lhs (false),
       looking_for_object_index (false), 
       looking_at_indirect_ref (false), parsing_class_method (false),
       maybe_classdef_get_set_method (false), parsing_classdef (false),
       quote_is_transpose (false), parser_end_of_input (false),
+      input_line_number (1), current_input_column (1),
       bracketflag (0), braceflag (0),
       looping (0), defining_func (0), looking_at_function_handle (0),
       looking_at_object_index (), parsed_function_name (),
       pending_local_variables ()
   {
     init ();
   }
 
@@ -92,16 +93,18 @@ public:
       looking_at_matrix_or_assign_lhs (lf.looking_at_matrix_or_assign_lhs),
       looking_for_object_index (lf.looking_for_object_index),
       looking_at_indirect_ref (lf.looking_at_indirect_ref),
       parsing_class_method (lf.parsing_class_method),
       maybe_classdef_get_set_method (lf.maybe_classdef_get_set_method),
       parsing_classdef (lf.parsing_classdef),
       quote_is_transpose (lf.quote_is_transpose),
       parser_end_of_input (lf.parser_end_of_input),
+      input_line_number (lf.input_line_number),
+      current_input_column (lf.current_input_column),
       bracketflag (lf.bracketflag),
       braceflag (lf.braceflag),
       looping (lf.looping),
       defining_func (lf.defining_func),
       looking_at_function_handle (lf.looking_at_function_handle),
       looking_at_object_index (lf.looking_at_object_index),
       parsed_function_name (lf.parsed_function_name),
       pending_local_variables (lf.pending_local_variables)
@@ -122,16 +125,18 @@ public:
         looking_at_matrix_or_assign_lhs = lf.looking_at_matrix_or_assign_lhs;
         looking_for_object_index = lf.looking_for_object_index;
         looking_at_indirect_ref = lf.looking_at_indirect_ref;
         parsing_class_method = lf.parsing_class_method;
         maybe_classdef_get_set_method = lf.maybe_classdef_get_set_method;
         parsing_classdef = lf.parsing_classdef;
         quote_is_transpose = lf.quote_is_transpose;
         parser_end_of_input = lf.parser_end_of_input;
+        input_line_number = lf.input_line_number;
+        current_input_column = lf.current_input_column;
         bracketflag = lf.bracketflag;
         braceflag = lf.braceflag;
         looping = lf.looping;
         defining_func = lf.defining_func;
         looking_at_function_handle = lf.looking_at_function_handle;
         looking_at_object_index = lf.looking_at_object_index;
         parsed_function_name = lf.parsed_function_name;
         pending_local_variables = lf.pending_local_variables;
@@ -200,16 +205,22 @@ public:
   bool parsing_classdef;
 
   // Return transpose or start a string?
   bool quote_is_transpose;
 
   // TRUE means that we have encountered EOF on the input stream.
   bool parser_end_of_input;
 
+  // The current input line number.
+  int input_line_number;
+
+  // The column of the current token.
+  int current_input_column;
+
   // Square bracket level count.
   int bracketflag;
 
   // Curly brace level count.
   int braceflag;
 
   // TRUE means we're in the middle of defining a loop.
   int looping;
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -143,39 +143,40 @@ along with Octave; see the file COPYING.
       Vtoken_count++; \
       DISPLAY_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
 #define TOK_RETURN(tok) \
   do \
     { \
-      current_input_column += yyleng; \
+      lexer_flags.current_input_column += yyleng; \
       lexer_flags.quote_is_transpose = false; \
       lexer_flags.convert_spaces_to_comma = true; \
       COUNT_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
 #define TOK_PUSH_AND_RETURN(name, tok) \
   do \
     { \
-      yylval.tok_val = new token (name, input_line_number, \
-                                  current_input_column); \
+      yylval.tok_val = new token (name, lexer_flags.input_line_number, \
+                                  lexer_flags.current_input_column); \
       token_stack.push (yylval.tok_val); \
       TOK_RETURN (tok); \
     } \
   while (0)
 
 #define BIN_OP_RETURN_INTERNAL(tok, convert, bos, qit) \
   do \
     { \
-      yylval.tok_val = new token (input_line_number, current_input_column); \
+      yylval.tok_val = new token (lexer_flags.input_line_number, \
+                                  lexer_flags.current_input_column); \
       token_stack.push (yylval.tok_val); \
-      current_input_column += yyleng; \
+      lexer_flags.current_input_column += yyleng; \
       lexer_flags.quote_is_transpose = qit; \
       lexer_flags.convert_spaces_to_comma = convert; \
       lexer_flags.looking_for_object_index = false; \
       lexer_flags.at_beginning_of_statement = bos; \
       COUNT_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
@@ -373,18 +374,18 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 %{
 // Help and other command-style functions.
 %}
 
 <COMMAND_START>{NL} {
     LEXER_DEBUG ("<COMMAND_START>{NL}");
 
     BEGIN (INITIAL);
-    input_line_number++;
-    current_input_column = 1;
+    lexer_flags.input_line_number++;
+    lexer_flags.current_input_column = 1;
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
     lexer_flags.looking_for_object_index = false;
     lexer_flags.at_beginning_of_statement = true;
 
     COUNT_TOK_AND_RETURN ('\n');
   }
@@ -403,17 +404,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
       TOK_RETURN (';');
   }
 
 <COMMAND_START>[\"\'] {
     LEXER_DEBUG ("<COMMAND_START>[\\\"\\']");
 
     lexer_flags.at_beginning_of_statement = false;
 
-    current_input_column++;
+    lexer_flags.current_input_column++;
     int tok = handle_string (yytext[0]);
 
     COUNT_TOK_AND_RETURN (tok);
   }
 
 <COMMAND_START>[^#% \t\r\n\;\,\"\'][^ \t\r\n\;\,]*{S}* {
     LEXER_DEBUG ("<COMMAND_START>[^#% \\t\\r\\n\\;\\,\\\"\\'][^ \\t\\r\\n\\;\\,]*{S}*");
 
@@ -491,17 +492,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // Commas are element separators in matrix constants.  If we don't
 // check for continuations here we can end up inserting too many
 // commas.
 %}
 
 <MATRIX_START>{S}*\,{S}* {
     LEXER_DEBUG ("<MATRIX_START>{S}*\\,{S}*");
 
-    current_input_column += yyleng;
+    lexer_flags.current_input_column += yyleng;
 
     int tmp = eat_continuation ();
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
     lexer_flags.looking_for_object_index = false;
     lexer_flags.at_beginning_of_statement = false;
 
@@ -523,17 +524,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // If commas are required, spaces are not important in matrix
 // constants so we just eat them.  If we don't check for continuations
 // here we can end up inserting too many commas.
 %}
 
 <MATRIX_START>{S}+ {
     LEXER_DEBUG ("<MATRIX_START>{S}+");
 
-    current_input_column += yyleng;
+    lexer_flags.current_input_column += yyleng;
 
     lexer_flags.at_beginning_of_statement = false;
 
     int tmp = eat_continuation ();
 
     if (! lexer_flags.looking_at_object_index.front ())
       {
         bool bin_op = next_token_is_bin_op (true);
@@ -619,17 +620,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
 \[{S}* {
     LEXER_DEBUG ("\\[{S}*");
 
     nesting_level.bracket ();
 
     lexer_flags.looking_at_object_index.push_front (false);
 
-    current_input_column += yyleng;
+    lexer_flags.current_input_column += yyleng;
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
     lexer_flags.looking_for_object_index = false;
     lexer_flags.at_beginning_of_statement = false;
 
     if (lexer_flags.defining_func
         && ! lexer_flags.parsed_function_name.top ())
       lexer_flags.looking_at_return_list = true;
@@ -681,50 +682,50 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
   }
 
 %{
 // Eat whitespace.  Whitespace inside matrix constants is handled by
 // the <MATRIX_START> start state code above.
 %}
 
 {S}* {
-    current_input_column += yyleng;
+    lexer_flags.current_input_column += yyleng;
   }
 
 %{
 // Continuation lines.  Allow comments after continuations.
 %}
 
 {CONT}{S}*{NL} |
 {CONT}{S}*{COMMENT} {
     LEXER_DEBUG ("{CONT}{S}*{NL}|{CONT}{S}*{COMMENT}");
 
     if (yytext[0] == '\\')
       gripe_matlab_incompatible_continuation ();
     scan_for_comments (yytext);
     promptflag--;
-    input_line_number++;
-    current_input_column = 1;
+    lexer_flags.input_line_number++;
+    lexer_flags.current_input_column = 1;
   }
 
 %{
 // End of file.
 %}
 
 <<EOF>> {
     LEXER_DEBUG ("<<EOF>>");
 
     if (block_comment_nesting_level != 0)
       {
         warning ("block comment open at end of input");
 
         if ((reading_fcn_file || reading_script_file || reading_classdef_file)
             && ! curr_fcn_file_name.empty ())
           warning ("near line %d of file '%s.m'",
-                   input_line_number, curr_fcn_file_name.c_str ());
+                   lexer_flags.input_line_number, curr_fcn_file_name.c_str ());
       }
 
     TOK_RETURN (END_OF_INPUT);
   }
 
 %{
 // Identifiers.  Truncate the token at the first space or tab but
 // don't write directly on yytext.
@@ -777,17 +778,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
 %{
 // Function handles and superclass references
 %}
 
 "@" {
     LEXER_DEBUG ("@");
 
-    current_input_column++;
+    lexer_flags.current_input_column++;
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = false;
     lexer_flags.looking_at_function_handle++;
     lexer_flags.looking_for_object_index = false;
     lexer_flags.at_beginning_of_statement = false;
 
     COUNT_TOK_AND_RETURN ('@');
@@ -798,18 +799,18 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // A new line character.  New line characters inside matrix constants
 // are handled by the <MATRIX_START> start state code above.  If closest
 // nesting is inside parentheses, don't return a row separator.
 %}
 
 {NL} {
     LEXER_DEBUG ("{NL}");
 
-    input_line_number++;
-    current_input_column = 1;
+    lexer_flags.input_line_number++;
+    lexer_flags.current_input_column = 1;
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
 
     if (nesting_level.none ())
       {
         lexer_flags.at_beginning_of_statement = true;
         COUNT_TOK_AND_RETURN ('\n');
@@ -826,17 +827,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 %{
 // Single quote can either be the beginning of a string or a transpose
 // operator.
 %}
 
 "'" {
     LEXER_DEBUG ("'");
 
-    current_input_column++;
+    lexer_flags.current_input_column++;
     lexer_flags.convert_spaces_to_comma = true;
 
     if (lexer_flags.quote_is_transpose)
       {
         do_comma_insert_check ();
         COUNT_TOK_AND_RETURN (QUOTE);
       }
     else
@@ -848,17 +849,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
 %{
 // Double quotes always begin strings.
 %}
 
 \" {
     LEXER_DEBUG ("\"");
 
-    current_input_column++;
+    lexer_flags.current_input_column++;
     int tok = handle_string ('"');
 
     COUNT_TOK_AND_RETURN (tok);
 }
 
 %{
 // Gobble comments.
 %}
@@ -883,18 +884,18 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // Block comments.
 %}
 
 ^{S}*{CCHAR}\{{S}*{NL} {
     LEXER_DEBUG ("^{S}*{CCHAR}\\{{S}*{NL}");
 
     lexer_flags.looking_for_object_index = false;
 
-    input_line_number++;
-    current_input_column = 1;
+    lexer_flags.input_line_number++;
+    lexer_flags.current_input_column = 1;
     block_comment_nesting_level++;
     promptflag--;
 
     bool eof = false;
     process_comment (true, eof);
   }
 
 %{
@@ -966,17 +967,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
     TOK_RETURN ('(');
   }
 
 ")" {
     LEXER_DEBUG (")");
 
     nesting_level.remove ();
-    current_input_column++;
+    lexer_flags.current_input_column++;
 
     lexer_flags.looking_at_object_index.pop_front ();
 
     lexer_flags.quote_is_transpose = true;
     lexer_flags.convert_spaces_to_comma
       = (nesting_level.is_bracket_or_brace ()
          && ! lexer_flags.looking_at_anon_fcn_args);
     lexer_flags.looking_for_object_index = true;
@@ -1019,17 +1020,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 \{{S}* {
     LEXER_DEBUG ("\\{{S}*");
 
     nesting_level.brace ();
 
     lexer_flags.looking_at_object_index.push_front
       (lexer_flags.looking_for_object_index);
 
-    current_input_column += yyleng;
+    lexer_flags.current_input_column += yyleng;
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
     lexer_flags.looking_for_object_index = false;
     lexer_flags.at_beginning_of_statement = false;
 
     promptflag--;
     eat_whitespace ();
 
@@ -1059,21 +1060,21 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     LEXER_DEBUG (".");
 
     xunput (yytext[0], yytext);
 
     int c = text_yyinput ();
 
     if (c != EOF)
       {
-        current_input_column++;
+        lexer_flags.current_input_column++;
 
         error ("invalid character '%s' (ASCII %d) near line %d, column %d",
                undo_string_escape (static_cast<char> (c)), c,
-               input_line_number, current_input_column);
+               lexer_flags.input_line_number, lexer_flags.current_input_column);
 
         return LEXICAL_ERROR;
       }
     else
       TOK_RETURN (END_OF_INPUT);
   }
 
 %%
@@ -1123,23 +1124,16 @@ reset_parser (void)
   // Clear out the stack of token info used to track line and column
   // numbers.
   while (! token_stack.empty ())
     {
       delete token_stack.top ();
       token_stack.pop ();
     }
 
-  // Can be reset by defining a function.
-  if (! (reading_script_file || reading_fcn_file || reading_classdef_file))
-    {
-      current_input_column = 1;
-      input_line_number = command_editor::current_command_number ();
-    }
-
   // Only ask for input from stdin if we are expecting interactive
   // input.
 
   if (! quitting_gracefully
       && (interactive || forced_interactive)
       && ! (reading_fcn_file
             || reading_classdef_file
             || reading_script_file
@@ -1329,53 +1323,53 @@ text_yyinput (void)
       if (c != '\n')
         {
           xunput (c, yytext);
           c = '\n';
         }
     }
 
   if (c == '\n')
-    input_line_number++;
+    lexer_flags.input_line_number++;
 
   return c;
 }
 
 static void
 xunput (char c, char *buf)
 {
   if (lexer_debug_flag)
     {
       std::cerr << "U: ";
       display_character (c);
       std::cerr << std::endl;
     }
 
   if (c == '\n')
-    input_line_number--;
+    lexer_flags.input_line_number--;
 
   yyunput (c, buf);
 }
 
 // If we read some newlines, we need figure out what column we're
 // really looking at.
 
 static void
 fixup_column_count (char *s)
 {
   char c;
   while ((c = *s++) != '\0')
     {
       if (c == '\n')
         {
-          input_line_number++;
-          current_input_column = 1;
+          lexer_flags.input_line_number++;
+          lexer_flags.current_input_column = 1;
         }
       else
-        current_input_column++;
+        lexer_flags.current_input_column++;
     }
 }
 
 // Include these so that we don't have to link to libfl.a.
 
 int
 yywrap (void)
 {
@@ -1468,18 +1462,18 @@ inside_any_object_index (void)
   return retval;
 }
 
 // Handle keywords.  Return -1 if the keyword should be ignored.
 
 static int
 is_keyword_token (const std::string& s)
 {
-  int l = input_line_number;
-  int c = current_input_column;
+  int l = lexer_flags.input_line_number;
+  int c = lexer_flags.current_input_column;
 
   int len = s.length ();
 
   const octave_kw *kw = octave_kw_hash::in_word_set (s.c_str (), len);
 
   if (kw)
     {
       yylval.tok_val = 0;
@@ -1497,22 +1491,22 @@ is_keyword_token (const std::string& s)
           break;
 
         case static_kw:
           if ((reading_fcn_file || reading_script_file
                || reading_classdef_file)
               && ! curr_fcn_file_full_name.empty ())
             warning_with_id ("Octave:deprecated-keyword",
                              "the 'static' keyword is obsolete and will be removed from a future version of Octave; please use 'persistent' instead; near line %d of file '%s'",
-                             input_line_number,
+                             lexer_flags.input_line_number,
                              curr_fcn_file_full_name.c_str ());
           else
             warning_with_id ("Octave:deprecated-keyword",
                              "the 'static' keyword is obsolete and will be removed from a future version of Octave; please use 'persistent' instead; near line %d",
-                             input_line_number);
+                             lexer_flags.input_line_number);
           // fall through ...
 
         case persistent_kw:
           break;
 
         case case_kw:
         case elseif_kw:
         case global_kw:
@@ -1647,17 +1641,17 @@ is_keyword_token (const std::string& s)
         case function_kw:
           promptflag--;
 
           lexer_flags.defining_func++;
           lexer_flags.parsed_function_name.push (false);
 
           if (! (reading_fcn_file || reading_script_file
                  || reading_classdef_file))
-            input_line_number = 1;
+            lexer_flags.input_line_number = 1;
           break;
 
         case magic_file_kw:
           {
             if ((reading_fcn_file || reading_script_file
                  || reading_classdef_file)
                 && ! curr_fcn_file_full_name.empty ())
               yylval.tok_val = new token (curr_fcn_file_full_name, l, c);
@@ -1702,45 +1696,45 @@ grab_block_comment (stream_reader& reade
   bool look_for_marker = false;
 
   bool warned_incompatible = false;
 
   int c = 0;
 
   while ((c = reader.getc ()) != EOF)
     {
-      current_input_column++;
+      lexer_flags.current_input_column++;
 
       if (look_for_marker)
         {
           at_bol = false;
           look_for_marker = false;
 
           if (c == '{' || c == '}')
             {
               std::string tmp_buf (1, static_cast<char> (c));
 
               int type = c;
 
               bool done = false;
 
               while ((c = reader.getc ()) != EOF && ! done)
                 {
-                  current_input_column++;
+                  lexer_flags.current_input_column++;
 
                   switch (c)
                     {
                     case ' ':
                     case '\t':
                       tmp_buf += static_cast<char> (c);
                       break;
 
                     case '\n':
                       {
-                        current_input_column = 0;
+                        lexer_flags.current_input_column = 0;
                         at_bol = true;
                         done = true;
 
                         if (type == '{')
                           {
                             block_comment_nesting_level++;
                             promptflag--;
                           }
@@ -1782,17 +1776,17 @@ grab_block_comment (stream_reader& reade
           look_for_marker = true;
         }
       else
         {
           buf += static_cast<char> (c);
 
           if (c == '\n')
             {
-              current_input_column = 0;
+              lexer_flags.current_input_column = 0;
               at_bol = true;
             }
         }
     }
 
   if (c == EOF)
     eof = true;
 
@@ -1812,45 +1806,45 @@ grab_comment_block (stream_reader& reade
   bool in_comment = false;
 
   bool warned_incompatible = false;
 
   int c = 0;
 
   while ((c = reader.getc ()) != EOF)
     {
-      current_input_column++;
+      lexer_flags.current_input_column++;
 
       if (begin_comment)
         {
           if (c == '%' || c == '#')
             {
               at_bol = false;
               continue;
             }
           else if (at_bol && c == '{')
             {
               std::string tmp_buf (1, static_cast<char> (c));
 
               bool done = false;
 
               while ((c = reader.getc ()) != EOF && ! done)
                 {
-                  current_input_column++;
+                  lexer_flags.current_input_column++;
 
                   switch (c)
                     {
                     case ' ':
                     case '\t':
                       tmp_buf += static_cast<char> (c);
                       break;
 
                     case '\n':
                       {
-                        current_input_column = 0;
+                        lexer_flags.current_input_column = 0;
                         at_bol = true;
                         done = true;
 
                         block_comment_nesting_level++;
                         promptflag--;
 
                         buf += grab_block_comment (reader, eof);
 
@@ -1879,17 +1873,17 @@ grab_comment_block (stream_reader& reade
 
       if (in_comment)
         {
           buf += static_cast<char> (c);
 
           if (c == '\n')
             {
               at_bol = true;
-              current_input_column = 0;
+              lexer_flags.current_input_column = 0;
               in_comment = false;
 
               // FIXME -- bailing out here prevents things like
               //
               //    octave> # comment
               //    octave> x = 1
               //
               // from failing at the command line, while still
@@ -1919,17 +1913,17 @@ grab_comment_block (stream_reader& reade
               // fall through...
 
             case '%':
               in_comment = true;
               begin_comment = true;
               break;
 
             default:
-              current_input_column--;
+              lexer_flags.current_input_column--;
               reader.ungetc (c);
               goto done;
             }
         }
     }
 
  done:
 
@@ -1986,17 +1980,17 @@ process_comment (bool start_in_block, bo
       if (! help_buf.empty ())
         help_buf.pop ();
 
       help_buf.push (txt);
     }
 
   octave_comment_buffer::append (txt);
 
-  current_input_column = 1;
+  lexer_flags.current_input_column = 1;
   lexer_flags.quote_is_transpose = false;
   lexer_flags.convert_spaces_to_comma = true;
   lexer_flags.at_beginning_of_statement = true;
 
   if (YY_START == COMMAND_START)
     BEGIN (INITIAL);
 
   if (nesting_level.none ())
@@ -2297,17 +2291,17 @@ eat_whitespace (void)
 
   bool in_comment = false;
   bool beginning_of_comment = false;
 
   int c = 0;
 
   while ((c = text_yyinput ()) != EOF)
     {
-      current_input_column++;
+      lexer_flags.current_input_column++;
 
       switch (c)
         {
         case ' ':
         case '\t':
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
@@ -2321,17 +2315,17 @@ eat_whitespace (void)
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
               octave_comment_buffer::append (comment_buf);
               comment_buf.resize (0);
               in_comment = false;
               beginning_of_comment = false;
             }
-          current_input_column = 0;
+          lexer_flags.current_input_column = 0;
           break;
 
         case '#':
         case '%':
           if (in_comment)
             {
               if (! beginning_of_comment)
                 comment_buf += static_cast<char> (c);
@@ -2386,17 +2380,17 @@ eat_whitespace (void)
         }
     }
 
   if (! comment_buf.empty ())
     octave_comment_buffer::append (comment_buf);
 
  done:
   xunput (c, yytext);
-  current_input_column--;
+  lexer_flags.current_input_column--;
   return retval;
 }
 
 static inline bool
 looks_like_hex (const char *s, int len)
 {
   return (len > 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X'));
 }
@@ -2433,22 +2427,22 @@ handle_number (void)
 
   assert (nread == 1);
 
   lexer_flags.quote_is_transpose = true;
   lexer_flags.convert_spaces_to_comma = true;
   lexer_flags.looking_for_object_index = false;
   lexer_flags.at_beginning_of_statement = false;
 
-  yylval.tok_val = new token (value, yytext, input_line_number,
-                              current_input_column);
+  yylval.tok_val = new token (value, yytext, lexer_flags.input_line_number,
+                              lexer_flags.current_input_column);
 
   token_stack.push (yylval.tok_val);
 
-  current_input_column += yyleng;
+  lexer_flags.current_input_column += yyleng;
 
   do_comma_insert_check ();
 }
 
 // We have seen a backslash and need to find out if it should be
 // treated as a continuation character.  If so, this eats it, up to
 // and including the new line character.
 //
@@ -2507,17 +2501,17 @@ have_continuation (bool trailing_comment
           break;
 
         case '\n':
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
               octave_comment_buffer::append (comment_buf);
             }
-          current_input_column = 0;
+          lexer_flags.current_input_column = 0;
           promptflag--;
           gripe_matlab_incompatible_continuation ();
           return true;
 
         default:
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
@@ -2589,25 +2583,25 @@ eat_continuation (void)
   return retval;
 }
 
 static int
 handle_string (char delim)
 {
   std::ostringstream buf;
 
-  int bos_line = input_line_number;
-  int bos_col = current_input_column;
+  int bos_line = lexer_flags.input_line_number;
+  int bos_col = lexer_flags.current_input_column;
 
   int c;
   int escape_pending = 0;
 
   while ((c = text_yyinput ()) != EOF)
     {
-      current_input_column++;
+      lexer_flags.current_input_column++;
 
       if (c == '\\')
         {
           if (delim == '\'' || escape_pending)
             {
               buf << static_cast<char> (c);
               escape_pending = 0;
             }
@@ -3169,21 +3163,22 @@ handle_superclass_identifier (void)
       error ("method, class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
 
   yylval.tok_val
     = new token (meth.empty () ? 0 : &(symbol_table::insert (meth)),
                  cls.empty () ? 0 : &(symbol_table::insert (cls)),
                  pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-                 input_line_number, current_input_column);
+                 lexer_flags.input_line_number,
+                 lexer_flags.current_input_column);
   token_stack.push (yylval.tok_val);
 
   lexer_flags.convert_spaces_to_comma = true;
-  current_input_column += yyleng;
+  lexer_flags.current_input_column += yyleng;
 
   return SUPERCLASSREF;
 }
 
 static int
 handle_meta_identifier (void)
 {
   eat_continuation ();
@@ -3203,22 +3198,23 @@ handle_meta_identifier (void)
     {
        error ("class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
 
   yylval.tok_val
     = new token (cls.empty () ? 0 : &(symbol_table::insert (cls)),
                  pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-                 input_line_number, current_input_column);
+                 lexer_flags.input_line_number,
+                 lexer_flags.current_input_column);
 
   token_stack.push (yylval.tok_val);
 
   lexer_flags.convert_spaces_to_comma = true;
-  current_input_column += yyleng;
+  lexer_flags.current_input_column += yyleng;
 
   return METAQUERY;
 }
 
 // Figure out exactly what kind of token to return when we have seen
 // an identifier.  Handles keywords.  Return -1 if the identifier
 // should be ignored.
 
@@ -3241,26 +3237,26 @@ handle_identifier (void)
   // decide whether to insert a comma.
 
   if (lexer_flags.looking_at_indirect_ref)
     {
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
 
-      yylval.tok_val = new token (tok, input_line_number,
-                                  current_input_column);
+      yylval.tok_val = new token (tok, lexer_flags.input_line_number,
+                                  lexer_flags.current_input_column);
 
       token_stack.push (yylval.tok_val);
 
       lexer_flags.quote_is_transpose = true;
       lexer_flags.convert_spaces_to_comma = true;
       lexer_flags.looking_for_object_index = true;
 
-      current_input_column += yyleng;
+      lexer_flags.current_input_column += yyleng;
 
       return STRUCT_ELT;
     }
 
   lexer_flags.at_beginning_of_statement = false;
 
   // The is_keyword_token may reset
   // lexer_flags.at_beginning_of_statement.  For example, if it sees
@@ -3278,38 +3274,38 @@ handle_identifier (void)
       if (kw_token)
         {
           error ("function handles may not refer to keywords");
 
           return LEXICAL_ERROR;
         }
       else
         {
-          yylval.tok_val = new token (tok, input_line_number,
-                                      current_input_column);
+          yylval.tok_val = new token (tok, lexer_flags.input_line_number,
+                                      lexer_flags.current_input_column);
 
           token_stack.push (yylval.tok_val);
 
-          current_input_column += yyleng;
+          lexer_flags.current_input_column += yyleng;
           lexer_flags.quote_is_transpose = false;
           lexer_flags.convert_spaces_to_comma = true;
           lexer_flags.looking_for_object_index = true;
 
           return FCN_HANDLE;
         }
     }
 
   // If we have a regular keyword, return it.
   // Keywords can be followed by identifiers.
 
   if (kw_token)
     {
       if (kw_token >= 0)
         {
-          current_input_column += yyleng;
+          lexer_flags.current_input_column += yyleng;
           lexer_flags.quote_is_transpose = false;
           lexer_flags.convert_spaces_to_comma = true;
           lexer_flags.looking_for_object_index = false;
         }
 
       return kw_token;
     }
 
@@ -3362,17 +3358,18 @@ handle_identifier (void)
 
   // Find the token in the symbol table.  Beware the magic
   // transformation of the end keyword...
 
   if (tok == "end")
     tok = "__end__";
 
   yylval.tok_val = new token (&(symbol_table::insert (tok)),
-                              input_line_number, current_input_column);
+                              lexer_flags.input_line_number,
+                              lexer_flags.current_input_column);
 
   token_stack.push (yylval.tok_val);
 
   // After seeing an identifer, it is ok to convert spaces to a comma
   // (if needed).
 
   lexer_flags.convert_spaces_to_comma = true;
 
@@ -3380,17 +3377,17 @@ handle_identifier (void)
     {
       lexer_flags.quote_is_transpose = true;
 
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
     }
 
-  current_input_column += yyleng;
+  lexer_flags.current_input_column += yyleng;
 
   if (tok != "__end__")
     lexer_flags.looking_for_object_index = true;
 
   return NAME;
 }
 
 bool
@@ -3542,51 +3539,51 @@ octave_read (char *buf, unsigned max_siz
 static void
 maybe_warn_separator_insert (char sep)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:separator-insert",
                      "potential auto-insertion of '%c' near line %d",
-                     sep, input_line_number);
+                     sep, lexer_flags.input_line_number);
   else
     warning_with_id ("Octave:separator-insert",
                      "potential auto-insertion of '%c' near line %d of file %s",
-                     sep, input_line_number, nm.c_str ());
+                     sep, lexer_flags.input_line_number, nm.c_str ());
 }
 
 static void
 gripe_single_quote_string (void)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:single-quote-string",
                      "single quote delimited string near line %d",
-                     input_line_number);
+                     lexer_flags.input_line_number);
   else
     warning_with_id ("Octave:single-quote-string",
                      "single quote delimited string near line %d of file %s",
-                     input_line_number, nm.c_str ());
+                     lexer_flags.input_line_number, nm.c_str ());
 }
 
 static void
 gripe_matlab_incompatible (const std::string& msg)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:matlab-incompatible",
                      "potential Matlab compatibility problem: %s",
                      msg.c_str ());
   else
     warning_with_id ("Octave:matlab-incompatible",
                      "potential Matlab compatibility problem: %s near line %d offile %s",
-                     msg.c_str (), input_line_number, nm.c_str ());
+                     msg.c_str (), lexer_flags.input_line_number, nm.c_str ());
 }
 
 static void
 maybe_gripe_matlab_incompatible_comment (char c)
 {
   if (c == '#')
     gripe_matlab_incompatible ("# used as comment character");
 }
diff --git a/libinterp/parse-tree/oct-parse.yy b/libinterp/parse-tree/oct-parse.yy
--- a/libinterp/parse-tree/oct-parse.yy
+++ b/libinterp/parse-tree/oct-parse.yy
@@ -81,22 +81,16 @@ along with Octave; see the file COPYING.
 // Calls to the following functions appear in the generated output from
 // Bison without the namespace tag.  Redefine them so we will use them
 // via the gnulib namespace.
 #define fclose GNULIB_NAMESPACE::fclose
 #define fprintf GNULIB_NAMESPACE::fprintf
 #define malloc GNULIB_NAMESPACE::malloc
 #endif
 
-// The current input line number.
-int input_line_number = 1;
-
-// The column of the current token.
-int current_input_column = 1;
-
 // Buffer for help text snagged from function files.
 std::stack<std::string> help_buf;
 
 // Buffer for comments appearing before a function statement.
 static std::string fcn_comment_header;
 
 // TRUE means we are using readline.
 // (--no-line-editing)
@@ -1340,18 +1334,18 @@ return_list1    : identifier
 
 // ===========
 // Script file
 // ===========
 
 script_file     : SCRIPT_FILE opt_list END_OF_INPUT
                   {
                     tree_statement *end_of_script
-                      = make_end ("endscript", input_line_number,
-                                  current_input_column);
+                      = make_end ("endscript", lexer_flags.input_line_number,
+                                  lexer_flags.current_input_column);
 
                     make_script ($2, end_of_script);
 
                     $$ = 0;
                   }
                 ;
 
 // =============
@@ -1464,18 +1458,18 @@ function_end    : END
                       }
 
                     if (reading_classdef_file)
                       {
                         yyerror ("classdef body open at end of input");
                         YYABORT;
                       }
 
-                    $$ = make_end ("endfunction", input_line_number,
-                                   current_input_column);
+                    $$ = make_end ("endfunction", lexer_flags.input_line_number,
+                                   lexer_flags.current_input_column);
                   }
                 ;
 
 // ========
 // Classdef
 // ========
 
 classdef_beg    : CLASSDEF stash_comment
@@ -1688,22 +1682,22 @@ opt_comma       : // empty
 
 %%
 
 // Generic error messages.
 
 static void
 yyerror (const char *s)
 {
-  int err_col = current_input_column - 1;
+  int err_col = lexer_flags.current_input_column - 1;
 
   std::ostringstream output_buf;
 
   if (reading_fcn_file || reading_script_file || reading_classdef_file)
-    output_buf << "parse error near line " << input_line_number
+    output_buf << "parse error near line " << lexer_flags.input_line_number
                << " of file " << curr_fcn_file_full_name;
   else
     output_buf << "parse error:";
 
   if (s && strcmp (s, "parse error") != 0)
     output_buf << "\n\n  " << s;
 
   output_buf << "\n\n";
@@ -2125,18 +2119,18 @@ make_fcn_handle (token *tok_val)
 }
 
 // Make an anonymous function handle.
 
 static tree_anon_fcn_handle *
 make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt)
 {
   // FIXME -- need to get these from the location of the @ symbol.
-  int l = input_line_number;
-  int c = current_input_column;
+  int l = lexer_flags.input_line_number;
+  int c = lexer_flags.current_input_column;
 
   tree_parameter_list *ret_list = 0;
 
   symbol_table::scope_id fcn_scope = symbol_table::current_scope ();
 
   if (parser_symtab_context.empty ())
     panic_impossible ();
 
@@ -2904,17 +2898,18 @@ frob_function (const std::string& fname,
            && reading_script_file
            && curr_fcn_file_name == id_name)
     {
       warning ("function '%s' defined within script file '%s'",
                id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
-  fcn->stash_fcn_location (input_line_number, current_input_column);
+  fcn->stash_fcn_location (lexer_flags.input_line_number,
+                           lexer_flags.current_input_column);
 
   if (! help_buf.empty () && current_function_depth == 1
       && ! parsing_subfunctions)
     {
       fcn->document (help_buf.top ());
 
       help_buf.pop ();
     }
@@ -3313,32 +3308,32 @@ text_getc (FILE *f)
       if (c != '\n')
         {
           ungetc (c, f);
           c = '\n';
         }
     }
 
   if (c == '\n')
-    input_line_number++;
+    lexer_flags.input_line_number++;
 
   return c;
 }
 
 class
 stdio_stream_reader : public stream_reader
 {
 public:
   stdio_stream_reader (FILE *f_arg) : stream_reader (), f (f_arg) { }
 
   int getc (void) { return ::text_getc (f); }
   int ungetc (int c)
   {
     if (c == '\n')
-      input_line_number--;
+      lexer_flags.input_line_number--;
 
     return ::ungetc (c, f);
   }
 
 private:
   FILE *f;
 
   // No copying!
@@ -3354,21 +3349,21 @@ skip_white_space (stream_reader& reader)
   int c = 0;
 
   while ((c = reader.getc ()) != EOF)
     {
       switch (c)
         {
         case ' ':
         case '\t':
-          current_input_column++;
+          lexer_flags.current_input_column++;
           break;
 
         case '\n':
-          current_input_column = 1;
+          lexer_flags.current_input_column = 1;
           break;
 
         default:
           reader.ungetc (c);
           goto done;
         }
     }
 
@@ -3468,29 +3463,25 @@ parse_fcn_file (const std::string& ff, c
   // Open function file and parse.
 
   FILE *in_stream = command_editor::get_input_stream ();
 
   frame.add_fcn (command_editor::set_input_stream, in_stream);
 
   frame.protect_var (ff_instream);
 
-  frame.protect_var (input_line_number);
-  frame.protect_var (current_input_column);
   frame.protect_var (reading_fcn_file);
   frame.protect_var (line_editing);
   frame.protect_var (current_class_name);
   frame.protect_var (current_function_depth);
   frame.protect_var (function_scopes);
   frame.protect_var (max_function_depth);
   frame.protect_var (parsing_subfunctions);
   frame.protect_var (endfunction_found);
 
-  input_line_number = 1;
-  current_input_column = 1;
   reading_fcn_file = true;
   line_editing = false;
   current_class_name = dispatch_type;
   current_function_depth = 0;
   function_scopes.clear ();
   max_function_depth = 0;
   parsing_subfunctions = false;
   endfunction_found = false;
@@ -3503,35 +3494,36 @@ parse_fcn_file (const std::string& ff, c
   FILE *ffile = get_input_from_file (ff, 0);
 
   frame.add_fcn (safe_fclose, ffile);
 
   if (ffile)
     {
       bool eof;
 
+      frame.protect_var (lexer_flags);
+
+      // Also resets lexer_flags.
+      reset_parser ();
+
       std::string help_txt = gobble_leading_white_space (ffile, eof);
 
       if (! help_txt.empty ())
         help_buf.push (help_txt);
 
       if (! eof)
         {
           std::string file_type;
 
-          frame.protect_var (lexer_flags);
-
           frame.protect_var (get_input_from_eval_string);
           frame.protect_var (reading_fcn_file);
           frame.protect_var (reading_script_file);
           frame.protect_var (reading_classdef_file);
           frame.protect_var (Vecho_executing_commands);
 
-          lexer_flags = lexical_feedback ();
-
           get_input_from_eval_string = false;
 
           if (! force_script && looking_at_function_keyword (ffile))
             {
               file_type = "function";
 
               Vecho_executing_commands = ECHO_OFF;
 
@@ -3570,18 +3562,16 @@ parse_fcn_file (const std::string& ff, c
           frame.add_fcn (switch_to_buffer, old_buf);
           frame.add_fcn (delete_buffer, new_buf);
 
           switch_to_buffer (new_buf);
 
           frame.protect_var (primary_fcn_ptr);
           primary_fcn_ptr = 0;
 
-          reset_parser ();
-
           // Do this with an unwind-protect cleanup function so that
           // the forced variables will be unmarked in the event of an
           // interrupt.
           symbol_table::scope_id scope = symbol_table::top_scope ();
           frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
           if (! help_txt.empty ())
             help_buf.push (help_txt);
@@ -3609,17 +3599,18 @@ parse_fcn_file (const std::string& ff, c
 
           if (status != 0)
             error ("parse error while reading %s file %s",
                    file_type.c_str (), ff.c_str ());
         }
       else
         {
           tree_statement *end_of_script
-            = make_end ("endscript", input_line_number, current_input_column);
+            = make_end ("endscript", lexer_flags.input_line_number,
+                        lexer_flags.current_input_column);
 
           make_script (0, end_of_script);
 
           fcn_ptr = primary_fcn_ptr;
         }
     }
   else if (require_file)
     error ("no such file, '%s'", ff.c_str ());
@@ -4310,34 +4301,30 @@ octave_value_list
 eval_string (const std::string& s, bool silent, int& parse_status, int nargout)
 {
   octave_value_list retval;
 
   unwind_protect frame;
 
   frame.protect_var (lexer_flags);
 
-  frame.protect_var (input_line_number);
-  frame.protect_var (current_input_column);
   frame.protect_var (get_input_from_eval_string);
   frame.protect_var (line_editing);
   frame.protect_var (current_eval_string);
   frame.protect_var (current_function_depth);
   frame.protect_var (function_scopes);
   frame.protect_var (max_function_depth);
   frame.protect_var (parsing_subfunctions);
   frame.protect_var (endfunction_found);
   frame.protect_var (reading_fcn_file);
   frame.protect_var (reading_script_file);
   frame.protect_var (reading_classdef_file);
 
   lexer_flags = lexical_feedback ();
 
-  input_line_number = 1;
-  current_input_column = 1;
   get_input_from_eval_string = true;
   line_editing = false;
   current_function_depth = 0;
   function_scopes.clear ();
   max_function_depth = 0;
   parsing_subfunctions = false;
   endfunction_found = false;
   reading_fcn_file = false;
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -39,22 +39,16 @@ class tree_identifier;
 class tree_statement_list;
 class octave_function;
 
 #include "oct-obj.h"
 
 // Nonzero means print parser debugging info (-d).
 extern int octave_debug;
 
-// The current input line number.
-extern int input_line_number;
-
-// The column of the current token.
-extern int current_input_column;
-
 // Buffer for help text snagged from function files.
 extern std::stack<std::string> help_buf;
 
 // TRUE means we are using readline.
 extern bool line_editing;
 
 // TRUE means we printed messages about reading startup files.
 extern bool reading_startup_message_printed;
