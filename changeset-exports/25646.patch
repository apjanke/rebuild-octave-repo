# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1532033747 14400
#      Thu Jul 19 16:55:47 2018 -0400
# Node ID 4d565baa475e17429992d64a556c2244d6b66aa0
# Parent  0214d9dabba2f5e1f083ba24c935191a8bf16e36
move libinterp/utils functions inside octave namespace

* utils.h, utils.cc: Move functions inside octave namespace.
Change all uses.

diff --git a/build-aux/mk-opts.pl b/build-aux/mk-opts.pl
--- a/build-aux/mk-opts.pl
+++ b/build-aux/mk-opts.pl
@@ -741,17 +741,17 @@ set_$CLASS_NAME (const std::string& keyw
   $STRUCT_NAME *list = $STATIC_TABLE_NAME;\n\n";
 
   my $iftok = "if";
 
   for (my $i = 0; $i < $OPT_NUM; $i++)
     {
       $iftok = "else if" if ($i > 0);
 
-      print "  $iftok (keyword_almost_match (list[$i].kw_tok, list[$i].min_len,
+      print "  $iftok (octave::keyword_almost_match (list[$i].kw_tok, list[$i].min_len,
            keyword, list[$i].min_toks_to_match, MAX_TOKENS))
     {\n";
 
       if ($TYPE[$i] eq "double")
         {
           print "      double tmp = val.double_value ();\n\n";
           print "      $STATIC_OBJECT_NAME.set_$OPT[$i] (tmp);\n";
         }
@@ -810,17 +810,17 @@ show_$CLASS_NAME (const std::string& key
   $STRUCT_NAME *list = $STATIC_TABLE_NAME;\n\n";
 
   my $iftok = "if";
 
   for (my $i = 0; $i < $OPT_NUM; $i++)
     {
       $iftok = "else if" if ($i > 0);
 
-      print "  $iftok (keyword_almost_match (list[$i].kw_tok, list[$i].min_len,
+      print "  $iftok (octave::keyword_almost_match (list[$i].kw_tok, list[$i].min_len,
            keyword, list[$i].min_toks_to_match, MAX_TOKENS))
     {\n";
 
       if ($TYPE[$i] eq "double")
         {
           print "      double val = $STATIC_OBJECT_NAME.$OPT[$i] ();\n\n";
           print "      retval = val;\n";
         }
diff --git a/libgui/graphics/ObjectProxy.cc b/libgui/graphics/ObjectProxy.cc
--- a/libgui/graphics/ObjectProxy.cc
+++ b/libgui/graphics/ObjectProxy.cc
@@ -130,21 +130,21 @@ namespace QtHandles
     QMetaObject::invokeMethod (m_object, "slotGetPixels", t,
                                Q_RETURN_ARG (uint8NDArray, retval));
 
     // FIXME: The following may fail for obscure reasons, see bug #53328.
     //        In absence of a solution, we retry twice before calling error().
     if (! QMetaObject::invokeMethod (m_object, "slotGetPixels", t,
                                      Q_RETURN_ARG (uint8NDArray, retval)))
       {
-        octave_sleep (0.1);
+        octave::sleep (0.1);
         if (! QMetaObject::invokeMethod (m_object, "slotGetPixels", t,
                                          Q_RETURN_ARG (uint8NDArray, retval)))
           {
-            octave_sleep (0.2);
+            octave::sleep (0.2);
             if (! QMetaObject::invokeMethod (m_object, "slotGetPixels", t,
                                              Q_RETURN_ARG (uint8NDArray, retval)))
               error ("getframe: unable to retrieve figure pixels");
           }
       }
 
     return retval;
   }
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -1944,17 +1944,17 @@ namespace octave
                                              QMessageBox::Save | QMessageBox::Cancel);
 
             if (ans == QMessageBox::Save)
               {
                 emit execute_command_in_terminal_signal ("dbquit");
                 // Wait until dbquit has actually occurred
                 while (names.numel () > i)
                   {
-                    octave_sleep (0.01);
+                    octave::sleep (0.01);
                     stk = cs.backtrace (nskip, curr_frame, false);
                     names = stk.contents ("name");
                   }
               }
             else
               retval = false;
             break;
           }
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -420,17 +420,17 @@ v = cellfun (@@det, a); # faster
 
       if (! retval.empty ())
         return retval;
 
       // See if we can convert the string into a function.
 
       std::string name = args(0).string_value ();
 
-      if (! valid_identifier (name))
+      if (! octave::valid_identifier (name))
         {
           std::string fcn_name = unique_symbol_name ("__cellfun_fcn__");
           std::string fname = "function y = " + fcn_name + "(x) y = ";
 
           octave_function *ptr_func
             = extract_function (args(0), "cellfun", fcn_name,
                                 fname, "; endfunction");
 
@@ -1127,17 +1127,17 @@ arrayfun (@@str2num, [1234],
 
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (func.is_string ())
     {
       // See if we can convert the string into a function.
       std::string name = args(0).string_value ();
 
-      if (! valid_identifier (name))
+      if (! octave::valid_identifier (name))
         {
           std::string fcn_name = unique_symbol_name ("__arrayfun_fcn__");
           std::string fname = "function y = " + fcn_name + "(x) y = ";
 
           octave_function *ptr_func
             = extract_function (args(0), "arrayfun", fcn_name,
                                 fname, "; endfunction");
 
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -2598,17 +2598,18 @@ indexing, i.e., @code{object@{@dots{}@}}
   octave_value retval;
 
   if (nargin == 1)
     retval = args(0).numel ();
   else if (nargin > 1)
     {
       // Don't use numel (const octave_value_list&) here as that corresponds to
       // an overloaded call, not to builtin!
-      retval = dims_to_numel (args(0).dims (), args.slice (1, nargin-1));
+      retval = octave::dims_to_numel (args(0).dims (),
+                                      args.slice (1, nargin-1));
     }
 
   return retval;
 }
 
 DEFUN (size, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{sz} =} size (@var{a})
@@ -3866,33 +3867,33 @@ fill_matrix (const octave_value_list& ar
     }
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
-      get_dimensions (args(0), fcn, dims);
+      octave::get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
           dims(i) = (args(i).isempty ()
                      ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
-  check_dimensions (dims, fcn);
+  octave::check_dimensions (dims, fcn);
 
   // FIXME: perhaps this should be made extensible by
   // using the class name to lookup a function to call to create
   // the new value.
 
   // Note that automatic narrowing will handle conversion from
   // NDArray to scalar.
 
@@ -3976,33 +3977,33 @@ fill_matrix (const octave_value_list& ar
     }
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
-      get_dimensions (args(0), fcn, dims);
+      octave::get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
           dims(i) = (args(i).isempty ()
                      ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
-  check_dimensions (dims, fcn);
+  octave::check_dimensions (dims, fcn);
 
   // Note that automatic narrowing will handle conversion from
   // NDArray to scalar.
 
   switch (dt)
     {
     case oct_data_conv::dt_single:
       retval = FloatNDArray (dims, fval);
@@ -4040,33 +4041,33 @@ fill_matrix (const octave_value_list& ar
     }
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
-      get_dimensions (args(0), fcn, dims);
+      octave::get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
           dims(i) = (args(i).isempty ()
                      ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
-  check_dimensions (dims, fcn);
+  octave::check_dimensions (dims, fcn);
 
   // Note that automatic narrowing will handle conversion from
   // NDArray to scalar.
 
   switch (dt)
     {
     case oct_data_conv::dt_single:
       retval = FloatNDArray (dims, static_cast<float> (val));
@@ -4105,33 +4106,33 @@ fill_matrix (const octave_value_list& ar
     }
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
-      get_dimensions (args(0), fcn, dims);
+      octave::get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
           dims(i) = (args(i).isempty ()
                      ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
-  check_dimensions (dims, fcn);
+  octave::check_dimensions (dims, fcn);
 
   // Note that automatic narrowing will handle conversion from
   // NDArray to scalar.
 
   switch (dt)
     {
     case oct_data_conv::dt_single:
       retval = FloatComplexNDArray (dims,
@@ -4160,33 +4161,33 @@ fill_matrix (const octave_value_list& ar
   dim_vector dims (1, 1);
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
-      get_dimensions (args(0), fcn, dims);
+      octave::get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
           dims(i) = (args(i).isempty ()
                      ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
-  check_dimensions (dims, fcn);
+  octave::check_dimensions (dims, fcn);
 
   // Note that automatic narrowing will handle conversion from
   // NDArray to scalar.
 
   retval = boolNDArray (dims, val);
 
   return retval;
 }
@@ -5004,24 +5005,24 @@ definitions are for compatibility with @
 
   octave_value retval;
 
   if (nargin == 0)
     retval = identity_matrix (1, 1, dt);
   else if (nargin == 1)
     {
       octave_idx_type nr, nc;
-      get_dimensions (args(0), "eye", nr, nc);
+      octave::get_dimensions (args(0), "eye", nr, nc);
 
       retval = identity_matrix (nr, nc, dt);
     }
   else
     {
       octave_idx_type nr, nc;
-      get_dimensions (args(0), args(1), "eye", nr, nc);
+      octave::get_dimensions (args(0), args(1), "eye", nr, nc);
 
       retval = identity_matrix (nr, nc, dt);
     }
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -593,17 +593,17 @@ is stopped.
     octave_stdout << "<unknown line>" << std::endl;
 
   return ovl ();
 }
 
 static void
 do_dbtype (std::ostream& os, const std::string& name, int start, int end)
 {
-  std::string ff = fcn_file_in_path (name);
+  std::string ff = octave::fcn_file_in_path (name);
 
   if (ff.empty ())
     os << "dbtype: unknown function " << name << "\n";
   else
     {
       std::string ascii_fname = octave::sys::get_ASCII_filename (ff);
 
       std::ifstream fs (ascii_fname.c_str (), std::ios::in);
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -214,17 +214,17 @@ such as text, are also replaced by the @
 
   if (args(0).is_string ())
     {
       // Filename.
       std::string fname (args(0).string_value ());
 
       std::string tname = octave::sys::file_ops::tilde_expand (fname);
 
-      tname = find_data_file_in_load_path ("dlmread", tname);
+      tname = octave::find_data_file_in_load_path ("dlmread", tname);
 
       std::string ascii_fname = octave::sys::get_ASCII_filename (tname);
 
       input_file.open (ascii_fname.c_str (), std::ios::in);
 
       if (! input_file)
         error ("dlmread: unable to open file '%s'", fname.c_str ());
 
@@ -244,17 +244,17 @@ such as text, are also replaced by the @
   else
     error ("dlmread: FILE argument must be a string or file id");
 
   // Set default separator.
   std::string sep;
   if (nargin > 1)
     {
       if (args(1).is_sq_string ())
-        sep = do_string_escapes (args(1).string_value ());
+        sep = octave::do_string_escapes (args(1).string_value ());
       else
         sep = args(1).string_value ();
     }
 
   // Take a subset if a range was given.
   octave_idx_type r0 = 0;
   octave_idx_type c0 = 0;
   octave_idx_type r1 = idx_max;
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -161,17 +161,17 @@ verror (bool save_last_error, std::ostre
     octave::flush_stdout ();
 
   // FIXME: we really want to capture the message before it has all the
   //        formatting goop attached to it.  We probably also want just the
   //        message, not the traceback information.
 
   std::ostringstream output_buf;
 
-  octave_vformat (output_buf, fmt, args);
+  octave::vformat (output_buf, fmt, args);
 
   std::string base_msg = output_buf.str ();
 
   bool to_beep_or_not_to_beep_p = Vbeep_on_error;
 
   std::string msg_string;
 
   if (to_beep_or_not_to_beep_p)
@@ -400,17 +400,17 @@ vwarning (const char *name, const char *
 {
   if (discard_warning_messages)
     return;
 
   octave::flush_stdout ();
 
   std::ostringstream output_buf;
 
-  octave_vformat (output_buf, fmt, args);
+  octave::vformat (output_buf, fmt, args);
 
   // FIXME: we really want to capture the message before it has all the
   //        formatting goop attached to it.  We probably also want just the
   //        message, not the traceback information.
 
   std::string base_msg = output_buf.str ();
   std::string msg_string;
 
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -419,17 +419,17 @@ do_stream_open (const std::string& name,
   octave::mach_info::float_format flt_fmt =
     octave::mach_info::string_to_float_format (arch);
 
   std::string fname = octave::sys::file_ops::tilde_expand (name);
 
   octave::sys::file_stat fs (fname);
 
   if (! (md & std::ios::out))
-    fname = find_data_file_in_load_path ("fopen", fname);
+    fname = octave::find_data_file_in_load_path ("fopen", fname);
 
   if (! fs.is_dir ())
     {
 #if defined (HAVE_ZLIB)
       if (use_zlib)
         {
           FILE *fptr = std::fopen (fname.c_str (), mode.c_str ());
 
@@ -1193,17 +1193,17 @@ textscan_internal (octave::interpreter& 
       // ommited format = %f.  explicit "" = width from file
       fmt = "%f";
     }
   else if (args(1).is_string ())
     {
       fmt = args(1).string_value ();
 
       if (args(1).is_sq_string ())
-        fmt = do_string_escapes (fmt);
+        fmt = octave::do_string_escapes (fmt);
 
       nskip++;
     }
   else
     error ("%s: FORMAT must be a string", who.c_str ());
 
   octave_idx_type ntimes = -1;
 
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -12810,17 +12810,17 @@ In all cases, typing CTRL-C stops progra
             {
               if (! pname.empty () && waitfor_results[id])
                 break;
             }
           else
             break;
         }
 
-      octave_sleep (0.1); // FIXME: really needed?
+      octave::sleep (0.1); // FIXME: really needed?
 
       octave_quit ();
 
       octave::command_editor::run_event_hooks ();
 
       if (timeout > 0)
         {
           octave::sys::time now;
diff --git a/libinterp/corefcn/gsvd.cc b/libinterp/corefcn/gsvd.cc
--- a/libinterp/corefcn/gsvd.cc
+++ b/libinterp/corefcn/gsvd.cc
@@ -175,39 +175,39 @@ and zggsvd routines.
             retval(0) = FloatMatrix (0, 1);
           else
             retval(0) = Matrix (0, 1);
         }
       else  // [U, V, X, C, S, R] = gsvd (A, B)
         {
           if (argA.is_single_type () || argB.is_single_type ())
             {
-              retval(0) = float_identity_matrix (nc, nc);
-              retval(1) = float_identity_matrix (nc, nc);
+              retval(0) = octave::float_identity_matrix (nc, nc);
+              retval(1) = octave::float_identity_matrix (nc, nc);
               if (nargout > 2)
-                retval(2) = float_identity_matrix (nr, nr);
+                retval(2) = octave::float_identity_matrix (nr, nr);
               if (nargout > 3)
                 retval(3) = FloatMatrix (nr, nc);
               if (nargout > 4)
-                retval(4) = float_identity_matrix (nr, nr);
+                retval(4) = octave::float_identity_matrix (nr, nr);
               if (nargout > 5)
-                retval(5) = float_identity_matrix (nr, nr);
+                retval(5) = octave::float_identity_matrix (nr, nr);
             }
           else
             {
-              retval(0) = identity_matrix (nc, nc);
-              retval(1) = identity_matrix (nc, nc);
+              retval(0) = octave::identity_matrix (nc, nc);
+              retval(1) = octave::identity_matrix (nc, nc);
               if (nargout > 2)
-                retval(2) = identity_matrix (nr, nr);
+                retval(2) = octave::identity_matrix (nr, nr);
               if (nargout > 3)
                 retval(3) = Matrix (nr, nc);
               if (nargout > 4)
-                retval(4) = identity_matrix (nr, nr);
+                retval(4) = octave::identity_matrix (nr, nr);
               if (nargout > 5)
-                retval(5) = identity_matrix (nr, nr);
+                retval(5) = octave::identity_matrix (nr, nr);
             }
         }
     }
   else
     {
       if (nc != np)
         print_usage ();
 
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -504,17 +504,17 @@ do_load (std::istream& stream, const std
     retval = retstruct;
 
   return retval;
 }
 
 static std::string
 find_file_to_load (const std::string& name, const std::string& orig_name)
 {
-  std::string fname = find_data_file_in_load_path ("load", name, true);
+  std::string fname = octave::find_data_file_in_load_path ("load", name, true);
 
   size_t dot_pos = fname.rfind ('.');
   size_t sep_pos = fname.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
   if (dot_pos == std::string::npos
       || (sep_pos != std::string::npos && dot_pos < sep_pos))
     {
       // Either no '.' in name or no '.' appears after last directory
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -376,33 +376,33 @@ hdf5_read_next_data_internal (hid_t grou
   hid_t type_id = -1;
   hid_t type_class_id = -1;
   hid_t data_id = -1;
   hid_t subgroup_id = -1;
   hid_t space_id = -1;;
 
   H5G_stat_t info;
   herr_t retval = 0;
-  bool ident_valid = valid_identifier (name);
+  bool ident_valid = octave::valid_identifier (name);
 
   std::string vname = name;
 
   octave::type_info& type_info
     = octave::__get_type_info__ ("hdf5_read_next_data_internal");
 
   // Allow identifiers as all digits so we can load lists saved by
   // earlier versions of Octave.
 
   if (! ident_valid)
     {
       // fix the identifier, replacing invalid chars with underscores
       vname = make_valid_identifier (vname);
 
       // check again (in case vname was null, empty, or some such thing):
-      ident_valid = valid_identifier (vname);
+      ident_valid = octave::valid_identifier (vname);
     }
 
   H5Gget_objinfo (group_id, name, 1, &info);
 
   if (info.type == H5G_GROUP && ident_valid)
     {
 #if defined (HAVE_HDF5_18)
       subgroup_id = H5Gopen (group_id, name, octave_H5P_DEFAULT);
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -246,17 +246,17 @@ read_mat_ascii_data (std::istream& is, c
       char c = varname[i];
       if (! (isalnum (c) || c == '_'))
         varname[i] = '_';
     }
 
   if (octave::is_keyword (varname) || ! isalpha (varname[0]))
     varname.insert (0, "X");
 
-  if (! valid_identifier (varname))
+  if (! octave::valid_identifier (varname))
     error ("load: unable to convert filename '%s' to valid identifier",
            filename.c_str ());
 
   octave_idx_type nr = 0;
   octave_idx_type nc = 0;
 
   int total_count = 0;
 
diff --git a/libinterp/corefcn/ls-oct-text.cc b/libinterp/corefcn/ls-oct-text.cc
--- a/libinterp/corefcn/ls-oct-text.cc
+++ b/libinterp/corefcn/ls-oct-text.cc
@@ -247,17 +247,17 @@ read_text_data (std::istream& is, const 
       if (count == 0)
         error ("load: empty name keyword or no data found in file '%s'",
                filename.c_str ());
 
       return "";
     }
 
   if (! (name == ".nargin." || name == ".nargout."
-         || name == CELL_ELT_TAG || valid_identifier (name)))
+         || name == CELL_ELT_TAG || octave::valid_identifier (name)))
     error ("load: invalid identifier '%s' found in file '%s'",
            name.c_str (), filename.c_str ());
 
   // Look for type keyword.
 
   std::string tag = extract_keyword (is, "type");
 
   if (tag.empty ())
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3432,17 +3432,17 @@ mexWarnMsgIdAndTxt (const char *id, cons
 }
 
 int
 mexPrintf (const char *fmt, ...)
 {
   int retval;
   va_list args;
   va_start (args, fmt);
-  retval = octave_vformat (octave_stdout, fmt, args);
+  retval = octave::vformat (octave_stdout, fmt, args);
   va_end (args);
   return retval;
 }
 
 mxArray *
 mexGetVariable (const char *space, const char *name)
 {
   mxArray *retval = nullptr;
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -5528,25 +5528,25 @@ namespace octave
   do_printf_conv (std::ostream& os, const char *fmt, int nsa, int sa_1,
                   int sa_2, T arg, const std::string& who)
   {
     int retval = 0;
 
     switch (nsa)
       {
       case 2:
-        retval = octave_format (os, fmt, sa_1, sa_2, arg);
+        retval = octave::format (os, fmt, sa_1, sa_2, arg);
         break;
 
       case 1:
-        retval = octave_format (os, fmt, sa_1, arg);
+        retval = octave::format (os, fmt, sa_1, arg);
         break;
 
       case 0:
-        retval = octave_format (os, fmt, arg);
+        retval = octave::format (os, fmt, arg);
         break;
 
       default:
         ::error ("%s: internal error handling format", who.c_str ());
         break;
       }
 
     return retval;
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -2659,17 +2659,17 @@ octave_print_internal (std::ostream& os,
           for (octave_idx_type i = 0; i < nstr; i++)
             {
               octave_quit ();
 
               std::string row = chm.row_as_string (i);
 
               if (pr_as_read_syntax)
                 {
-                  os << '"' << undo_string_escapes (row) << '"';
+                  os << '"' << octave::undo_string_escapes (row) << '"';
 
                   if (i < nstr - 1)
                     os << "; ";
                 }
               else
                 {
                   os << row;
 
@@ -3477,17 +3477,17 @@ of properly displaying the object's name
   // object type.
 
   octave_value value = args(0);
 
   // If print_name_tag displays a newline, then also print one after
   // disp is done.
 
   bool print_newlines = false;
-  if (valid_identifier (name))
+  if (octave::valid_identifier (name))
     print_newlines = value.print_name_tag (octave_stdout, name);
 
   // Use feval so that dispatch will also work for disp.
 
   octave::feval ("disp", ovl (value));
 
   if (print_newlines)
     octave_stdout << std::endl;
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -146,17 +146,17 @@ Compressed Column Sparse (rows = 3, cols
       else
         err_wrong_type_arg ("sparse", arg);
     }
   else if (nargin == 2)
     {
       octave_idx_type m = 0;
       octave_idx_type n = 0;
 
-      get_dimensions (args(0), args(1), "sparse", m, n);
+      octave::get_dimensions (args(0), args(1), "sparse", m, n);
 
       if (m >= 0 && n >= 0)
         retval = SparseMatrix (m, n);
       else
         error ("sparse: dimensions must be non-negative");
     }
   else if (nargin >= 3)
     {
@@ -179,17 +179,17 @@ Compressed Column Sparse (rows = 3, cols
       if (nargin == 6)
         {
           nzmax = args(5).idx_type_value ();
           nargin--;
         }
 
       if (nargin == 5)
         {
-          get_dimensions (args(3), args(4), "sparse", m, n);
+          octave::get_dimensions (args(3), args(4), "sparse", m, n);
 
           if (m < 0 || n < 0)
             error ("sparse: dimensions must be non-negative");
         }
 
       int k = 0;    // index we're checking when index_vector throws
       try
         {
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -250,17 +250,17 @@ strfind (@{"abababa", "bebebe", "ab"@}, 
             }
 
           retval = retc;
         }
       else
         error ("strfind: first argument must be a string or cell array of strings");
     }
   else if (argpat.iscell ())
-    retval = do_simple_cellfun (Fstrfind, "strfind", args);
+    retval = octave::do_simple_cellfun (Fstrfind, "strfind", args);
   else
     error ("strfind: PATTERN must be a string or cell array of strings");
 
   return retval;
 }
 
 /*
 %!assert (strfind ("abababa", "aba"), [1, 3, 5])
@@ -428,17 +428,17 @@ strrep ("This is a test string", "is", "
             }
 
           retval = retc;
         }
       else
         error ("strrep: S must be a string or cell array of strings");
     }
   else if (argpat.iscell () || argrep.iscell ())
-    retval = do_simple_cellfun (Fstrrep, "strrep", args);
+    retval = octave::do_simple_cellfun (Fstrrep, "strrep", args);
   else
     error ("strrep: PTN and REP arguments must be strings or cell arrays of strings");
 
   return retval;
 }
 
 /*
 %!assert (strrep ("This is a test string", "is", "&%$"),
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -1105,17 +1105,17 @@ clc;
           Fdrawnow ();
 
           if (octave::math::isinf (dval))
             {
               octave::flush_stdout ();
               octave_kbhit ();
             }
           else
-            octave_sleep (dval);
+            octave::sleep (dval);
         }
     }
   else
     {
       Fdrawnow ();
       octave::flush_stdout ();
       octave_kbhit ();
     }
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -62,35 +62,36 @@ along with Octave; see the file COPYING.
 #include "ov-range.h"
 #include "pager.h"
 #include "parse.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
-// Return TRUE if S is a valid identifier.
-
-bool
-valid_identifier (const char *s)
+namespace octave
 {
-  if (! s || ! (isalpha (*s) || *s == '_' || *s == '$'))
-    return false;
+  // Return TRUE if S is a valid identifier.
 
-  while (*++s != '\0')
-    if (! (isalnum (*s) || *s == '_' || *s == '$'))
+  bool valid_identifier (const char *s)
+  {
+    if (! s || ! (isalpha (*s) || *s == '_' || *s == '$'))
       return false;
 
-  return true;
-}
+    while (*++s != '\0')
+      if (! (isalnum (*s) || *s == '_' || *s == '$'))
+        return false;
 
-bool
-valid_identifier (const std::string& s)
-{
-  return valid_identifier (s.c_str ());
+    return true;
+  }
+
+  bool valid_identifier (const std::string& s)
+  {
+    return valid_identifier (s.c_str ());
+  }
 }
 
 DEFUN (isvarname, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} isvarname (@var{name})
 Return true if @var{name} is a valid variable name.
 @seealso{iskeyword, exist, who}
 @end deftypefn */)
@@ -99,17 +100,18 @@ Return true if @var{name} is a valid var
     print_usage ();
 
   octave_value retval = false;
 
   if (args(0).is_string ())
     {
       std::string varname = args(0).string_value ();
 
-      retval = valid_identifier (varname) && ! octave::is_keyword (varname);
+      retval = (octave::valid_identifier (varname)
+                && ! octave::is_keyword (varname));
     }
 
   return retval;
 }
 
 /*
 %!assert (isvarname ("foo"), true)
 %!assert (isvarname ("_foo"), true)
@@ -118,165 +120,164 @@ Return true if @var{name} is a valid var
 %!assert (isvarname (""), false)
 %!assert (isvarname (12), false)
 %!assert (isvarname ("foo+bar"), false)
 
 %!error isvarname ()
 %!error isvarname ("foo", "bar")
 */
 
-// Return TRUE if F and G are both names for the same file.
-
-bool
-same_file (const std::string& f, const std::string& g)
+namespace octave
 {
-  return same_file_internal (f, g);
-}
+  // Return TRUE if F and G are both names for the same file.
 
-int
-almost_match (const std::string& std, const std::string& s, int min_match_len,
-              int case_sens)
-{
-  int stdlen = std.length ();
-  int slen = s.length ();
+  bool same_file (const std::string& f, const std::string& g)
+  {
+    return same_file_internal (f, g);
+  }
+
+  int almost_match (const std::string& std, const std::string& s,
+                    int min_match_len, int case_sens)
+  {
+    int stdlen = std.length ();
+    int slen = s.length ();
 
-  return (slen <= stdlen
-          && slen >= min_match_len
-          && (case_sens
-              ? (strncmp (std.c_str (), s.c_str (), slen) == 0)
-              : (octave_strncasecmp (std.c_str (), s.c_str (), slen) == 0)));
-}
+    return (slen <= stdlen
+            && slen >= min_match_len
+            && (case_sens
+                ? (strncmp (std.c_str (), s.c_str (), slen) == 0)
+                : (octave_strncasecmp (std.c_str (), s.c_str (), slen) == 0)));
+  }
 
-// Ugh.
+  // Ugh.
 
-int
-keyword_almost_match (const char * const *std, int *min_len,
-                      const std::string& s,
-                      int min_toks_to_match, int max_toks)
-{
-  int status = 0;
-  int tok_count = 0;
-  int toks_matched = 0;
+  int keyword_almost_match (const char * const *std, int *min_len,
+                            const std::string& s,
+                            int min_toks_to_match, int max_toks)
+  {
+    int status = 0;
+    int tok_count = 0;
+    int toks_matched = 0;
 
-  if (s.empty () || max_toks < 1)
-    return status;
+    if (s.empty () || max_toks < 1)
+      return status;
 
-  char *kw = strsave (s.c_str ());
+    char *kw = strsave (s.c_str ());
 
-  char *t = kw;
-  while (*t != '\0')
-    {
-      if (*t == '\t')
-        *t = ' ';
-      t++;
-    }
+    char *t = kw;
+    while (*t != '\0')
+      {
+        if (*t == '\t')
+          *t = ' ';
+        t++;
+      }
 
-  char *beg = kw;
-  while (*beg == ' ')
-    beg++;
+    char *beg = kw;
+    while (*beg == ' ')
+      beg++;
 
-  if (*beg == '\0')
-    return status;
+    if (*beg == '\0')
+      return status;
 
-  const char **to_match = new const char * [max_toks + 1];
-  const char * const *s1 = std;
-  const char **s2 = to_match;
+    const char **to_match = new const char * [max_toks + 1];
+    const char * const *s1 = std;
+    const char **s2 = to_match;
 
-  if (! s1 || ! s2)
-    goto done;
+    if (! s1 || ! s2)
+      goto done;
 
-  s2[tok_count] = beg;
-  char *end;
-  while ((end = strchr (beg, ' ')) != nullptr)
-    {
-      *end = '\0';
-      beg = end + 1;
+    s2[tok_count] = beg;
+    char *end;
+    while ((end = strchr (beg, ' ')) != nullptr)
+      {
+        *end = '\0';
+        beg = end + 1;
 
-      while (*beg == ' ')
-        beg++;
+        while (*beg == ' ')
+          beg++;
 
-      if (*beg == '\0')
-        break;
+        if (*beg == '\0')
+          break;
 
-      tok_count++;
-      if (tok_count >= max_toks)
-        goto done;
+        tok_count++;
+        if (tok_count >= max_toks)
+          goto done;
 
-      s2[tok_count] = beg;
-    }
-  s2[tok_count+1] = nullptr;
+        s2[tok_count] = beg;
+      }
+    s2[tok_count+1] = nullptr;
 
-  s2 = to_match;
+    s2 = to_match;
 
-  for (;;)
-    {
-      if (! almost_match (*s1, *s2, min_len[toks_matched], 0))
-        goto done;
+    for (;;)
+      {
+        if (! almost_match (*s1, *s2, min_len[toks_matched], 0))
+          goto done;
 
-      toks_matched++;
+        toks_matched++;
 
-      s1++;
-      s2++;
+        s1++;
+        s2++;
 
-      if (! *s2)
-        {
-          status = (toks_matched >= min_toks_to_match);
-          goto done;
-        }
+        if (! *s2)
+          {
+            status = (toks_matched >= min_toks_to_match);
+            goto done;
+          }
 
-      if (! *s1)
-        goto done;
-    }
+        if (! *s1)
+          goto done;
+      }
 
-done:
+  done:
 
-  delete [] kw;
-  delete [] to_match;
+    delete [] kw;
+    delete [] to_match;
 
-  return status;
-}
+    return status;
+  }
 
-// See if the given file is in the path.
+  // See if the given file is in the path.
 
-std::string
-search_path_for_file (const std::string& path, const string_vector& names)
-{
-  octave::directory_path p (path);
+  std::string search_path_for_file (const std::string& path,
+                                    const string_vector& names)
+  {
+    directory_path p (path);
 
-  return octave::sys::env::make_absolute (p.find_first_of (names.std_list ()));
-}
+    return sys::env::make_absolute (p.find_first_of (names.std_list ()));
+  }
 
-// Find all locations of the given file in the path.
+  // Find all locations of the given file in the path.
 
-string_vector
-search_path_for_all_files (const std::string& path, const string_vector& names)
-{
-  octave::directory_path p (path);
+  string_vector search_path_for_all_files (const std::string& path,
+                                           const string_vector& names)
+  {
+    directory_path p (path);
 
-  string_vector sv = p.find_all_first_of (names.std_list ());
+    string_vector sv = p.find_all_first_of (names.std_list ());
 
-  octave_idx_type len = sv.numel ();
+    octave_idx_type len = sv.numel ();
 
-  for (octave_idx_type i = 0; i < len; i++)
-    sv[i] = octave::sys::env::make_absolute (sv[i]);
+    for (octave_idx_type i = 0; i < len; i++)
+      sv[i] = sys::env::make_absolute (sv[i]);
 
-  return sv;
-}
+    return sv;
+  }
 
-static string_vector
-make_absolute (const string_vector& sv)
-{
-  octave_idx_type len = sv.numel ();
+  static string_vector make_absolute (const string_vector& sv)
+  {
+    octave_idx_type len = sv.numel ();
+
+    string_vector retval (len);
 
-  string_vector retval (len);
+    for (octave_idx_type i = 0; i < len; i++)
+      retval[i] = sys::env::make_absolute (sv[i]);
 
-  for (octave_idx_type i = 0; i < len; i++)
-    retval[i] = octave::sys::env::make_absolute (sv[i]);
-
-  return retval;
+    return retval;
+  }
 }
 
 DEFMETHOD (file_in_loadpath, interp, args, ,
            doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{fname} =} file_in_loadpath (@var{file})
 @deftypefnx {} {@var{fname} =} file_in_loadpath (@var{file}, "all")
 Return the absolute name of @var{file} if it can be found in the list of
 directories specified by @code{path}.
@@ -313,17 +314,17 @@ If no files are found, return an empty c
     return ovl (octave::sys::env::make_absolute (lp.find_first_of (names)));
   else
     {
       std::string opt = args(1).xstring_value ("file_in_loadpath: optional second argument must be a string");
 
       if (opt != "all")
         error (R"(file_in_loadpath: "all" is only valid second argument)");
 
-      return ovl (Cell (make_absolute (lp.find_all_first_of (names))));
+      return ovl (Cell (octave::make_absolute (lp.find_all_first_of (names))));
     }
 }
 
 /*
 %!test
 %! f = file_in_loadpath ("plot.m");
 %! assert (ischar (f));
 %! assert (! isempty (f));
@@ -376,25 +377,25 @@ If no files are found, return an empty c
   std::string path = args(0).xstring_value ("file_in_path: PATH must be a string");
 
   string_vector names = args(1).xstring_vector_value ("file_in_path: FILE argument must be a string");
 
   if (names.empty ())
     error ("file_in_path: FILE argument must not be empty");
 
   if (nargin == 2)
-    return ovl (search_path_for_file (path, names));
+    return ovl (octave::search_path_for_file (path, names));
   else
     {
       std::string opt = args(2).xstring_value ("file_in_path: optional third argument must be a string");
 
       if (opt != "all")
         error (R"(file_in_path: "all" is only valid third argument)");
 
-      return ovl (Cell (make_absolute (search_path_for_all_files (path, names))));
+      return ovl (Cell (octave::make_absolute (octave::search_path_for_all_files (path, names))));
     }
 }
 
 /*
 %!test
 %! f = file_in_path (path (), "plot.m");
 %! assert (ischar (f));
 %! assert (! isempty (f));
@@ -410,259 +411,257 @@ If no files are found, return an empty c
 %!error file_in_path ()
 %!error file_in_path ("foo")
 %!error file_in_path ("foo", "bar", "baz", 1)
 %!error file_in_path ([])
 %!error file_in_path (path (), [])
 %!error file_in_path (path (), "plot.m", "bar")
 */
 
-std::string
-file_in_path (const std::string& name, const std::string& suffix)
+namespace octave
 {
-  std::string nm = name;
+  std::string file_in_path (const std::string& name, const std::string& suffix)
+  {
+    std::string nm = name;
 
-  if (! suffix.empty ())
-    nm.append (suffix);
-
-  octave::load_path& lp = octave::__get_load_path__ ("file_in_path");
+    if (! suffix.empty ())
+      nm.append (suffix);
 
-  return octave::sys::env::make_absolute (lp.find_file (nm));
-}
+    load_path& lp = __get_load_path__ ("file_in_path");
+
+    return sys::env::make_absolute (lp.find_file (nm));
+  }
 
-std::string
-find_data_file_in_load_path  (const std::string& fcn,
-                              const std::string& file,
-                              bool require_regular_file)
-{
-  std::string fname = file;
+  std::string find_data_file_in_load_path  (const std::string& fcn,
+                                            const std::string& file,
+                                            bool require_regular_file)
+  {
+    std::string fname = file;
 
-  if (! (octave::sys::env::absolute_pathname (fname)
-         || octave::sys::env::rooted_relative_pathname (fname)))
-    {
-      // Load path will also search "." first, but we don't want to
-      // issue a warning if the file is found in the current directory,
-      // so do an explicit check for that.
-      octave::sys::file_stat fs (fname);
+    if (! (sys::env::absolute_pathname (fname)
+           || sys::env::rooted_relative_pathname (fname)))
+      {
+        // Load path will also search "." first, but we don't want to
+        // issue a warning if the file is found in the current directory,
+        // so do an explicit check for that.
+        sys::file_stat fs (fname);
 
-      bool local_file_ok
-        = fs.exists () && (fs.is_reg () || ! require_regular_file);
-
-      if (! local_file_ok)
-        {
-          octave::load_path& lp =
-            octave::__get_load_path__ ("find_data_file_in_load_path");
+        bool local_file_ok
+          = fs.exists () && (fs.is_reg () || ! require_regular_file);
 
-          // Not directly found; search load path.
-          std::string tmp
-            = octave::sys::env::make_absolute (lp.find_file (fname));
-
-          if (! tmp.empty ())
-            {
-              warn_data_file_in_path (fcn, tmp);
+        if (! local_file_ok)
+          {
+            load_path& lp =
+              __get_load_path__ ("find_data_file_in_load_path");
 
-              fname = tmp;
-            }
-        }
-    }
+            // Not directly found; search load path.
+            std::string tmp
+              = sys::env::make_absolute (lp.find_file (fname));
 
-  return fname;
-}
+            if (! tmp.empty ())
+              {
+                warn_data_file_in_path (fcn, tmp);
 
-// See if there is an function file in the path.
-// If so, return the full path to the file.
+                fname = tmp;
+              }
+          }
+      }
 
-std::string
-fcn_file_in_path (const std::string& name)
-{
-  std::string retval;
+    return fname;
+  }
 
-  int len = name.length ();
+  // See if there is an function file in the path.
+  // If so, return the full path to the file.
 
-  if (len > 0)
-    {
-      if (octave::sys::env::absolute_pathname (name))
-        {
-          octave::sys::file_stat fs (name);
+  std::string fcn_file_in_path (const std::string& name)
+  {
+    std::string retval;
+
+    int len = name.length ();
 
-          if (fs.exists () && ! fs.is_dir ())
-            retval = name;
-        }
-      else if (len > 2 && name[len - 2] == '.' && name[len - 1] == 'm')
-        {
-          octave::load_path& lp = octave::__get_load_path__ ("fcn_file_in_path");
+    if (len > 0)
+      {
+        if (sys::env::absolute_pathname (name))
+          {
+            sys::file_stat fs (name);
 
-          retval = lp.find_fcn_file (name.substr (0, len-2));
-        }
-      else
-        {
-          std::string fname = name;
-          size_t pos = name.find_first_of ('>');
-          if (pos != std::string::npos)
-            fname = name.substr (0, pos);
-
-          octave::load_path& lp = octave::__get_load_path__ ("fcn_file_in_path");
-
-          retval = lp.find_fcn_file (fname);
-        }
-    }
+            if (fs.exists () && ! fs.is_dir ())
+              retval = name;
+          }
+        else if (len > 2 && name[len - 2] == '.' && name[len - 1] == 'm')
+          {
+            load_path& lp = __get_load_path__ ("fcn_file_in_path");
 
-  return retval;
-}
-
-// See if there is a directory called "name" in the path and if it
-// contains a Contents.m file.  If so, return the full path to this file.
+            retval = lp.find_fcn_file (name.substr (0, len-2));
+          }
+        else
+          {
+            std::string fname = name;
+            size_t pos = name.find_first_of ('>');
+            if (pos != std::string::npos)
+              fname = name.substr (0, pos);
 
-std::string
-contents_file_in_path (const std::string& dir)
-{
-  std::string retval;
+            load_path& lp = __get_load_path__ ("fcn_file_in_path");
+
+            retval = lp.find_fcn_file (fname);
+          }
+      }
 
-  if (! dir.empty ())
-    {
-      octave::load_path& lp = octave::__get_load_path__ ("contents_in_file_path");
+    return retval;
+  }
 
-      std::string tcontents
-        = octave::sys::file_ops::concat (lp.find_dir (dir), "Contents.m");
+  // See if there is a directory called "name" in the path and if it
+  // contains a Contents.m file.  If so, return the full path to this file.
 
-      octave::sys::file_stat fs (tcontents);
+  std::string contents_file_in_path (const std::string& dir)
+  {
+    std::string retval;
 
-      if (fs.exists ())
-        retval = octave::sys::env::make_absolute (tcontents);
-    }
+    if (! dir.empty ())
+      {
+        load_path& lp = __get_load_path__ ("contents_in_file_path");
 
-  return retval;
-}
-
-// Replace backslash escapes in a string with the real values.
+        std::string tcontents
+          = sys::file_ops::concat (lp.find_dir (dir), "Contents.m");
 
-std::string
-do_string_escapes (const std::string& s)
-{
-  std::string retval;
+        sys::file_stat fs (tcontents);
 
-  size_t i = 0;
-  size_t j = 0;
-  size_t len = s.length ();
+        if (fs.exists ())
+          retval = sys::env::make_absolute (tcontents);
+      }
 
-  retval.resize (len);
+    return retval;
+  }
+
+  // Replace backslash escapes in a string with the real values.
 
-  while (j < len)
-    {
-      if (s[j] == '\\' && j+1 < len)
-        {
-          switch (s[++j])
-            {
-            case 'a': // alarm
-              retval[i] = '\a';
-              break;
+  std::string do_string_escapes (const std::string& s)
+  {
+    std::string retval;
 
-            case 'b': // backspace
-              retval[i] = '\b';
-              break;
+    size_t i = 0;
+    size_t j = 0;
+    size_t len = s.length ();
+
+    retval.resize (len);
 
-            case 'f': // formfeed
-              retval[i] = '\f';
-              break;
-
-            case 'n': // newline
-              retval[i] = '\n';
-              break;
+    while (j < len)
+      {
+        if (s[j] == '\\' && j+1 < len)
+          {
+            switch (s[++j])
+              {
+              case 'a': // alarm
+                retval[i] = '\a';
+                break;
 
-            case 'r': // carriage return
-              retval[i] = '\r';
-              break;
+              case 'b': // backspace
+                retval[i] = '\b';
+                break;
 
-            case 't': // horizontal tab
-              retval[i] = '\t';
-              break;
+              case 'f': // formfeed
+                retval[i] = '\f';
+                break;
 
-            case 'v': // vertical tab
-              retval[i] = '\v';
-              break;
+              case 'n': // newline
+                retval[i] = '\n';
+                break;
+
+              case 'r': // carriage return
+                retval[i] = '\r';
+                break;
 
-            case '\\': // backslash
-              retval[i] = '\\';
-              break;
+              case 't': // horizontal tab
+                retval[i] = '\t';
+                break;
 
-            case '\'': // quote
-              retval[i] = '\'';
-              break;
+              case 'v': // vertical tab
+                retval[i] = '\v';
+                break;
 
-            case '"': // double quote
-              retval[i] = '"';
-              break;
+              case '\\': // backslash
+                retval[i] = '\\';
+                break;
+
+              case '\'': // quote
+                retval[i] = '\'';
+                break;
 
-            case '0':
-            case '1':
-            case '2':
-            case '3':
-            case '4':
-            case '5':
-            case '6':
-            case '7': // octal input
-            {
-              size_t k;
-              int tmpi = s[j] - '0';
-              for (k = j+1; k < std::min (j+3, len); k++)
+              case '"': // double quote
+                retval[i] = '"';
+                break;
+
+              case '0':
+              case '1':
+              case '2':
+              case '3':
+              case '4':
+              case '5':
+              case '6':
+              case '7': // octal input
                 {
-                  int digit = s[k] - '0';
-                  if (digit < 0 || digit > 7)
-                    break;
-                  tmpi <<= 3;
-                  tmpi += digit;
-                }
-              retval[i] = tmpi;
-              j = k - 1;
-              break;
-            }
-
-            case 'x': // hex input
-            {
-              size_t k;
-              int tmpi = 0;
-              for (k = j+1; k < std::min (j+3, len); k++)
-                {
-                  if (! isxdigit (s[k]))
-                    break;
-
-                  tmpi <<= 4;
-                  int digit = s[k];
-                  if (digit >= 'a')
-                    tmpi += digit - 'a' + 10;
-                  else if (digit >= 'A')
-                    tmpi += digit - 'A' + 10;
-                  else
-                    tmpi += digit - '0';
+                  size_t k;
+                  int tmpi = s[j] - '0';
+                  for (k = j+1; k < std::min (j+3, len); k++)
+                    {
+                      int digit = s[k] - '0';
+                      if (digit < 0 || digit > 7)
+                        break;
+                      tmpi <<= 3;
+                      tmpi += digit;
+                    }
+                  retval[i] = tmpi;
+                  j = k - 1;
+                  break;
                 }
 
-              if (k == j+1)
-                warning (R"(malformed hex escape sequence '\x' -- converting to '\0')");
+              case 'x': // hex input
+                {
+                  size_t k;
+                  int tmpi = 0;
+                  for (k = j+1; k < std::min (j+3, len); k++)
+                    {
+                      if (! isxdigit (s[k]))
+                        break;
 
-              retval[i] = tmpi;
-              j = k - 1;
-              break;
-            }
+                      tmpi <<= 4;
+                      int digit = s[k];
+                      if (digit >= 'a')
+                        tmpi += digit - 'a' + 10;
+                      else if (digit >= 'A')
+                        tmpi += digit - 'A' + 10;
+                      else
+                        tmpi += digit - '0';
+                    }
+
+                  if (k == j+1)
+                    warning (R"(malformed hex escape sequence '\x' -- converting to '\0')");
 
-            default:
-              warning (R"(unrecognized escape sequence '\%c' -- converting to '%c')", s[j], s[j]);
-              retval[i] = s[j];
-              break;
-            }
-        }
-      else
-        retval[i] = s[j];
+                  retval[i] = tmpi;
+                  j = k - 1;
+                  break;
+                }
 
-      i++;
-      j++;
-    }
+              default:
+                warning (R"(unrecognized escape sequence '\%c' -- converting to '%c')", s[j], s[j]);
+                retval[i] = s[j];
+                break;
+              }
+          }
+        else
+          retval[i] = s[j];
 
-  retval.resize (i);
+        i++;
+        j++;
+      }
 
-  return retval;
+    retval.resize (i);
+
+    return retval;
+  }
 }
 
 DEFUN (do_string_escapes, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} do_string_escapes (@var{string})
 Convert escape sequences in @var{string} to the characters they represent.
 
 Escape sequences begin with a leading backslash
@@ -671,17 +670,17 @@ Escape sequences begin with a leading ba
 @seealso{undo_string_escapes}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string str = args(0).xstring_value ("do_string_escapes: STRING argument must be of type string");
 
-  return ovl (do_string_escapes (str));
+  return ovl (octave::do_string_escapes (str));
 }
 
 /*
 %!assert (do_string_escapes ('foo\nbar'), "foo\nbar")
 %!assert (do_string_escapes ("foo\\nbar"), "foo\nbar")
 %!assert (do_string_escapes ("foo\\nbar"), ["foo", char(10), "bar"])
 %!assert ("foo\nbar", ["foo", char(10), "bar"])
 
@@ -711,73 +710,74 @@ Escape sequences begin with a leading ba
 
 %!error do_string_escapes ()
 %!error do_string_escapes ("foo", "bar")
 %!error <STRING argument> do_string_escapes (3)
 %!warning <malformed hex escape sequence> do_string_escapes ('\xG');
 %!warning <unrecognized escape sequence> do_string_escapes ('\G');
 */
 
-const char *
-undo_string_escape (char c)
+namespace octave
 {
-  if (! c)
-    return "";
+  const char * undo_string_escape (char c)
+  {
+    if (! c)
+      return "";
 
-  switch (c)
-    {
-    case '\0':
-      return R"(\0)";
-
-    case '\a':
-      return R"(\a)";
+    switch (c)
+      {
+      case '\0':
+        return R"(\0)";
 
-    case '\b': // backspace
-      return R"(\b)";
+      case '\a':
+        return R"(\a)";
 
-    case '\f': // formfeed
-      return R"(\f)";
+      case '\b': // backspace
+        return R"(\b)";
 
-    case '\n': // newline
-      return R"(\n)";
+      case '\f': // formfeed
+        return R"(\f)";
 
-    case '\r': // carriage return
-      return R"(\r)";
+      case '\n': // newline
+        return R"(\n)";
 
-    case '\t': // horizontal tab
-      return R"(\t)";
+      case '\r': // carriage return
+        return R"(\r)";
 
-    case '\v': // vertical tab
-      return R"(\v)";
+      case '\t': // horizontal tab
+        return R"(\t)";
 
-    case '\\': // backslash
-      return R"(\\)";
+      case '\v': // vertical tab
+        return R"(\v)";
 
-    case '"': // double quote
-      return R"(\")";
+      case '\\': // backslash
+        return R"(\\)";
 
-    default:
-      {
-        static char retval[2] {'\0', '\0'};
+      case '"': // double quote
+        return R"(\")";
+
+      default:
+        {
+          static char retval[2] {'\0', '\0'};
 
-        retval[0] = c;
-        return retval;
+          retval[0] = c;
+          return retval;
+        }
       }
-    }
-}
+  }
 
-std::string
-undo_string_escapes (const std::string& s)
-{
-  std::string retval;
+  std::string undo_string_escapes (const std::string& s)
+  {
+    std::string retval;
 
-  for (size_t i = 0; i < s.length (); i++)
-    retval.append (undo_string_escape (s[i]));
+    for (size_t i = 0; i < s.length (); i++)
+      retval.append (undo_string_escape (s[i]));
 
-  return retval;
+    return retval;
+  }
 }
 
 DEFUN (undo_string_escapes, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} undo_string_escapes (@var{s})
 Convert special characters in strings back to their escaped forms.
 
 For example, the expression
@@ -806,17 +806,17 @@ replaces the unprintable alert character
 @seealso{do_string_escapes}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string str = args(0).xstring_value ("undo_string_escapes: S argument must be a string");
 
-  return ovl (undo_string_escapes (str));
+  return ovl (octave::undo_string_escapes (str));
 }
 
 /*
 %!assert (undo_string_escapes ("foo\nbar"), 'foo\nbar')
 %!assert (undo_string_escapes ("foo\nbar"), "foo\\nbar")
 %!assert (undo_string_escapes (["foo", char(10), "bar"]), "foo\\nbar")
 
 %!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), '\a\b\f\n\r\t\v')
@@ -1037,305 +1037,298 @@ Return a structure containing the system
 }
 
 /*
 %!assert (isstruct (errno_list ()))
 
 %!error errno_list ("foo")
 */
 
-static void
-check_dimensions (octave_idx_type& nr, octave_idx_type& nc, const char *warnfor)
+namespace octave
 {
-  if (nr < 0 || nc < 0)
-    {
+  static void check_dimensions (octave_idx_type& nr, octave_idx_type& nc,
+                                const char *warnfor)
+  {
+    if (nr < 0 || nc < 0)
+      {
+        warning_with_id ("Octave:neg-dim-as-zero",
+                         "%s: converting negative dimension to zero", warnfor);
+
+        nr = (nr < 0) ? 0 : nr;
+        nc = (nc < 0) ? 0 : nc;
+      }
+  }
+
+  void check_dimensions (dim_vector& dim, const char *warnfor)
+  {
+    bool neg = false;
+
+    for (int i = 0; i < dim.ndims (); i++)
+      {
+        if (dim(i) < 0)
+          {
+            dim(i) = 0;
+            neg = true;
+          }
+      }
+
+    if (neg)
       warning_with_id ("Octave:neg-dim-as-zero",
                        "%s: converting negative dimension to zero", warnfor);
-
-      nr = (nr < 0) ? 0 : nr;
-      nc = (nc < 0) ? 0 : nc;
-    }
-}
-
-void
-check_dimensions (dim_vector& dim, const char *warnfor)
-{
-  bool neg = false;
+  }
 
-  for (int i = 0; i < dim.ndims (); i++)
-    {
-      if (dim(i) < 0)
-        {
-          dim(i) = 0;
-          neg = true;
-        }
-    }
+  void get_dimensions (const octave_value& a, const char *warn_for,
+                       dim_vector& dim)
+  {
+    // We support dimensions to be specified by any vector, even if it's a
+    // vector of dimensions 0x1, 1x0, 1x1x0, or 1x1x6.  If the vector ends
+    // up being empty, the final dimensions end up being 0x0.
+    if (! a.dims ().isvector ())
+      error ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
 
-  if (neg)
-    warning_with_id ("Octave:neg-dim-as-zero",
-                     "%s: converting negative dimension to zero", warnfor);
-}
+    const Array<octave_idx_type> v = a.octave_idx_type_vector_value ();
+    const octave_idx_type n = v.numel ();
 
-void
-get_dimensions (const octave_value& a, const char *warn_for,
-                dim_vector& dim)
-{
-  // We support dimensions to be specified by any vector, even if it's a
-  // vector of dimensions 0x1, 1x0, 1x1x0, or 1x1x6.  If the vector ends
-  // up being empty, the final dimensions end up being 0x0.
-  if (! a.dims ().isvector ())
-    error ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
+    dim.resize (n); // even if n < 2, resize sets it back to 2
+    if (n == 0)
+      {
+        dim(0) = 0;
+        dim(1) = 0;
+      }
+    else if (n == 1)
+      {
+        dim(0) = v(0);
+        dim(1) = v(0);
+      }
+    else
+      for (octave_idx_type i = 0; i < n; i++)
+        dim(i) = v(i);
 
-  const Array<octave_idx_type> v = a.octave_idx_type_vector_value ();
-  const octave_idx_type n = v.numel ();
+    octave::check_dimensions (dim, warn_for);
+  }
 
-  dim.resize (n); // even if n < 2, resize sets it back to 2
-  if (n == 0)
-    {
-      dim(0) = 0;
-      dim(1) = 0;
-    }
-  else if (n == 1)
-    {
-      dim(0) = v(0);
-      dim(1) = v(0);
-    }
-  else
-    for (octave_idx_type i = 0; i < n; i++)
-      dim(i) = v(i);
+  void get_dimensions (const octave_value& a, const char *warn_for,
+                       octave_idx_type& nr, octave_idx_type& nc)
+  {
+    if (a.is_scalar_type ())
+      {
+        nr = nc = a.idx_type_value ();
+      }
+    else
+      {
+        nr = a.rows ();
+        nc = a.columns ();
 
-  check_dimensions (dim, warn_for);
-}
+        if ((nr != 1 || nc != 2) && (nr != 2 || nc != 1))
+          error ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
 
-void
-get_dimensions (const octave_value& a, const char *warn_for,
-                octave_idx_type& nr, octave_idx_type& nc)
-{
-  if (a.is_scalar_type ())
-    {
-      nr = nc = a.idx_type_value ();
-    }
-  else
-    {
-      nr = a.rows ();
-      nc = a.columns ();
+        Array<double> v = a.vector_value ();
+        nr = static_cast<octave_idx_type> (math::fix (v(0)));
+        nc = static_cast<octave_idx_type> (math::fix (v(1)));
+      }
+
+    octave::check_dimensions (nr, nc, warn_for);
+  }
 
-      if ((nr != 1 || nc != 2) && (nr != 2 || nc != 1))
-        error ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
-
-      Array<double> v = a.vector_value ();
-      nr = static_cast<octave_idx_type> (octave::math::fix (v(0)));
-      nc = static_cast<octave_idx_type> (octave::math::fix (v(1)));
-    }
-
-  check_dimensions (nr, nc, warn_for);
-}
+  void get_dimensions (const octave_value& a, const octave_value& b,
+                       const char *warn_for, octave_idx_type& nr,
+                       octave_idx_type& nc)
+  {
+    nr = a.isempty ()
+      ? 0 : a.idx_type_value ("%s: row dimension must be a scalar", warn_for);
+    nc = b.isempty ()
+      ? 0 : b.idx_type_value ("%s: column dimension must be a scalar", warn_for);
 
-void
-get_dimensions (const octave_value& a, const octave_value& b,
-                const char *warn_for, octave_idx_type& nr, octave_idx_type& nc)
-{
-  nr = a.isempty ()
-       ? 0 : a.idx_type_value ("%s: row dimension must be a scalar", warn_for);
-  nc = b.isempty ()
-       ? 0 : b.idx_type_value ("%s: column dimension must be a scalar", warn_for);
+    octave::check_dimensions (nr, nc, warn_for);
+  }
 
-  check_dimensions (nr, nc, warn_for);
-}
+  octave_idx_type dims_to_numel (const dim_vector& dims,
+                                 const octave_value_list& idx_arg)
+  {
+    octave_idx_type retval;
 
-octave_idx_type
-dims_to_numel (const dim_vector& dims, const octave_value_list& idx_arg)
-{
-  octave_idx_type retval;
-
-  octave_idx_type len = idx_arg.length ();
+    octave_idx_type len = idx_arg.length ();
 
-  if (len == 0)
-    retval = dims.numel ();
-  else
-    {
-      const dim_vector dv = dims.redim (len);
-      retval = 1;
-      for (octave_idx_type i = 0; i < len; i++)
-        {
-          octave_value idxi = idx_arg(i);
-          if (idxi.is_magic_colon ())
-            retval *= dv(i);
-          else if (idxi.isnumeric ())
-            retval *= idxi.numel ();
-          else
-            {
-              try
-                {
-                  idx_vector jdx = idxi.index_vector ();
+    if (len == 0)
+      retval = dims.numel ();
+    else
+      {
+        const dim_vector dv = dims.redim (len);
+        retval = 1;
+        for (octave_idx_type i = 0; i < len; i++)
+          {
+            octave_value idxi = idx_arg(i);
+            if (idxi.is_magic_colon ())
+              retval *= dv(i);
+            else if (idxi.isnumeric ())
+              retval *= idxi.numel ();
+            else
+              {
+                try
+                  {
+                    idx_vector jdx = idxi.index_vector ();
 
-                  retval *= jdx.length (dv(i));
-                }
-              catch (const octave::index_exception& e)
-                {
-                  std::string idx = e.idx ();
-                  std::string msg = e.details ();
+                    retval *= jdx.length (dv(i));
+                  }
+                catch (const index_exception& e)
+                  {
+                    std::string idx = e.idx ();
+                    std::string msg = e.details ();
+
+                    error ("dims_to_numel: Invalid IDX %s. %s",
+                           idx.c_str (), msg.c_str ());
+                  }
+              }
+          }
+      }
 
-                  error ("dims_to_numel: Invalid IDX %s. %s",
-                         idx.c_str (), msg.c_str ());
-                }
-            }
-        }
-    }
+    return retval;
+  }
+
+  Matrix identity_matrix (octave_idx_type nr, octave_idx_type nc)
+  {
+    Matrix m (nr, nc, 0.0);
 
-  return retval;
-}
+    if (nr > 0 && nc > 0)
+      {
+        octave_idx_type n = std::min (nr, nc);
 
-Matrix
-identity_matrix (octave_idx_type nr, octave_idx_type nc)
-{
-  Matrix m (nr, nc, 0.0);
+        for (octave_idx_type i = 0; i < n; i++)
+          m (i, i) = 1.0;
+      }
+
+    return m;
+  }
 
-  if (nr > 0 && nc > 0)
-    {
-      octave_idx_type n = std::min (nr, nc);
-
-      for (octave_idx_type i = 0; i < n; i++)
-        m (i, i) = 1.0;
-    }
+  FloatMatrix float_identity_matrix (octave_idx_type nr, octave_idx_type nc)
+  {
+    FloatMatrix m (nr, nc, 0.0);
 
-  return m;
-}
+    if (nr > 0 && nc > 0)
+      {
+        octave_idx_type n = std::min (nr, nc);
 
-FloatMatrix
-float_identity_matrix (octave_idx_type nr, octave_idx_type nc)
-{
-  FloatMatrix m (nr, nc, 0.0);
+        for (octave_idx_type i = 0; i < n; i++)
+          m (i, i) = 1.0;
+      }
 
-  if (nr > 0 && nc > 0)
-    {
-      octave_idx_type n = std::min (nr, nc);
+    return m;
+  }
 
-      for (octave_idx_type i = 0; i < n; i++)
-        m (i, i) = 1.0;
-    }
+  size_t format (std::ostream& os, const char *fmt, ...)
+  {
+    size_t retval;
 
-  return m;
-}
+    va_list args;
+    va_start (args, fmt);
+
+    retval = vformat (os, fmt, args);
 
-size_t
-octave_format (std::ostream& os, const char *fmt, ...)
-{
-  size_t retval;
+    va_end (args);
 
-  va_list args;
-  va_start (args, fmt);
+    return retval;
+  }
 
-  retval = octave_vformat (os, fmt, args);
+  size_t vformat (std::ostream& os, const char *fmt, va_list args)
+  {
+    std::string s = vasprintf (fmt, args);
 
-  va_end (args);
-
-  return retval;
-}
+    os << s;
 
-size_t
-octave_vformat (std::ostream& os, const char *fmt, va_list args)
-{
-  std::string s = octave_vasprintf (fmt, args);
+    return s.length ();
+  }
 
-  os << s;
+  std::string vasprintf (const char *fmt, va_list args)
+  {
+    std::string retval;
 
-  return s.length ();
-}
+    char *result;
 
-std::string
-octave_vasprintf (const char *fmt, va_list args)
-{
-  std::string retval;
+    int status = octave_vasprintf_wrapper (&result, fmt, args);
 
-  char *result;
-
-  int status = octave_vasprintf_wrapper (&result, fmt, args);
+    if (status >= 0)
+      {
+        retval = result;
+        ::free (result);
+      }
 
-  if (status >= 0)
-    {
-      retval = result;
-      ::free (result);
-    }
+    return retval;
+  }
 
-  return retval;
-}
+  std::string asprintf (const char *fmt, ...)
+  {
+    std::string retval;
+
+    va_list args;
+    va_start (args, fmt);
 
-std::string
-octave_asprintf (const char *fmt, ...)
-{
-  std::string retval;
+    retval = vasprintf (fmt, args);
+
+    va_end (args);
 
-  va_list args;
-  va_start (args, fmt);
-
-  retval = octave_vasprintf (fmt, args);
+    return retval;
+  }
 
-  va_end (args);
-
-  return retval;
-}
+  // FIXME: sleep is complicated because we want it to be interruptible.
+  // With the way this program handles signals, the sleep system call
+  // won't respond to SIGINT.  Maybe there is a better way than
+  // breaking this up into multiple shorter intervals?
 
-// FIXME: sleep is complicated because we want it to be interruptible.
-// With the way this program handles signals, the sleep system call
-// won't respond to SIGINT.  Maybe there is a better way than
-// breaking this up into multiple shorter intervals?
+  void sleep (double seconds)
+  {
+    if (seconds <= 0)
+      return;
+
+    // Split delay into whole seconds and the remainder as a decimal
+    // fraction.
 
-void
-octave_sleep (double seconds)
-{
-  if (seconds <= 0)
-    return;
+    double fraction = std::modf (seconds, &seconds);
+
+    // Further split the fractional seconds into whole tenths and the
+    // nearest number of nanoseconds remaining.
 
-  // Split delay into whole seconds and the remainder as a decimal
-  // fraction.
+    double tenths = 0;
+    fraction = std::modf (fraction * 10, &tenths) / 10;
+    fraction = std::round (fraction * 1000000000);
 
-  double fraction = std::modf (seconds, &seconds);
-
-  // Further split the fractional seconds into whole tenths and the
-  // nearest number of nanoseconds remaining.
+    // Sleep for the hundredths portion.
 
-  double tenths = 0;
-  fraction = std::modf (fraction * 10, &tenths) / 10;
-  fraction = std::round (fraction * 1000000000);
+    struct timespec hundredths_delay = { 0, static_cast<long> (fraction) };
 
-  // Sleep for the hundredths portion.
+    octave_nanosleep_wrapper (&hundredths_delay, nullptr);
 
-  struct timespec hundredths_delay = { 0, static_cast<long> (fraction) };
+    // Sleep for the whole tenths portion, allowing interrupts every
+    // tenth.
 
-  octave_nanosleep_wrapper (&hundredths_delay, nullptr);
-
-  // Sleep for the whole tenths portion, allowing interrupts every
-  // tenth.
+    struct timespec one_tenth = { 0, 100000000 };
 
-  struct timespec one_tenth = { 0, 100000000 };
+    for (int i = 0; i < static_cast<int> (tenths); i++)
+      {
+        octave_nanosleep_wrapper (&one_tenth, nullptr);
 
-  for (int i = 0; i < static_cast<int> (tenths); i++)
-    {
-      octave_nanosleep_wrapper (&one_tenth, nullptr);
+        octave_quit ();
+      }
 
-      octave_quit ();
-    }
+    // Sleep for the whole seconds portion, allowing interrupts every
+    // tenth.
 
-  // Sleep for the whole seconds portion, allowing interrupts every
-  // tenth.
-
-  time_t sec = ((seconds > std::numeric_limits<time_t>::max ())
-                ? std::numeric_limits<time_t>::max ()
-                : static_cast<time_t> (seconds));
+    time_t sec = ((seconds > std::numeric_limits<time_t>::max ())
+                  ? std::numeric_limits<time_t>::max ()
+                  : static_cast<time_t> (seconds));
 
-  for (time_t s = 0; s < sec; s++)
-    {
-      for (int i = 0; i < 10; i++)
-        {
-          octave_nanosleep_wrapper (&one_tenth, nullptr);
+    for (time_t s = 0; s < sec; s++)
+      {
+        for (int i = 0; i < 10; i++)
+          {
+            octave_nanosleep_wrapper (&one_tenth, nullptr);
 
-          octave_quit ();
-        }
-    }
+            octave_quit ();
+          }
+      }
+  }
 }
 
 DEFUN (isindex, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} isindex (@var{ind})
 @deftypefnx {} {} isindex (@var{ind}, @var{n})
 Return true if @var{ind} is a valid index.
 
@@ -1391,96 +1384,99 @@ character @nospell{"@xbackslashchar{}0"}
 %!assert (isindex (1:3))
 %!assert (isindex (1:3, 2), false)
 %!assert (isindex ([1, 2, -3]), false)
 
 %!error isindex ()
 %!error isindex (1:3, 2, 3)
 */
 
-octave_value_list
-do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
-                   const char *fun_name, const octave_value_list& args,
-                   int nargout)
+namespace octave
 {
-  octave_value_list new_args = args;
-  octave_value_list retval;
-  int nargin = args.length ();
-  OCTAVE_LOCAL_BUFFER (bool, iscell, nargin);
-  OCTAVE_LOCAL_BUFFER (Cell, cells, nargin);
-  OCTAVE_LOCAL_BUFFER (Cell, rcells, nargout);
+  octave_value_list
+  do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
+                     const char *fun_name, const octave_value_list& args,
+                     int nargout)
+  {
+    octave_value_list new_args = args;
+    octave_value_list retval;
+    int nargin = args.length ();
+    OCTAVE_LOCAL_BUFFER (bool, iscell, nargin);
+    OCTAVE_LOCAL_BUFFER (Cell, cells, nargin);
+    OCTAVE_LOCAL_BUFFER (Cell, rcells, nargout);
 
-  const Cell *ccells = cells;
+    const Cell *ccells = cells;
 
-  octave_idx_type numel = 1;
-  dim_vector dims (1, 1);
+    octave_idx_type numel = 1;
+    dim_vector dims (1, 1);
 
-  for (int i = 0; i < nargin; i++)
-    {
-      octave_value arg = new_args(i);
-      iscell[i] = arg.iscell ();
-      if (iscell[i])
-        {
-          cells[i] = arg.cell_value ();
-          octave_idx_type n = ccells[i].numel ();
-          if (n == 1)
-            {
-              iscell[i] = false;
-              new_args(i) = ccells[i](0);
-            }
-          else if (numel == 1)
-            {
-              numel = n;
-              dims = ccells[i].dims ();
-            }
-          else if (dims != ccells[i].dims ())
-            error ("%s: cell arguments must have matching sizes", fun_name);
-        }
-    }
+    for (int i = 0; i < nargin; i++)
+      {
+        octave_value arg = new_args(i);
+        iscell[i] = arg.iscell ();
+        if (iscell[i])
+          {
+            cells[i] = arg.cell_value ();
+            octave_idx_type n = ccells[i].numel ();
+            if (n == 1)
+              {
+                iscell[i] = false;
+                new_args(i) = ccells[i](0);
+              }
+            else if (numel == 1)
+              {
+                numel = n;
+                dims = ccells[i].dims ();
+              }
+            else if (dims != ccells[i].dims ())
+              error ("%s: cell arguments must have matching sizes", fun_name);
+          }
+      }
 
-  for (int i = 0; i < nargout; i++)
-    rcells[i].clear (dims);
+    for (int i = 0; i < nargout; i++)
+      rcells[i].clear (dims);
 
-  for (octave_idx_type j = 0; j < numel; j++)
-    {
-      for (int i = 0; i < nargin; i++)
-        if (iscell[i])
-          new_args(i) = ccells[i](j);
+    for (octave_idx_type j = 0; j < numel; j++)
+      {
+        for (int i = 0; i < nargin; i++)
+          if (iscell[i])
+            new_args(i) = ccells[i](j);
 
-      octave_quit ();
+        octave_quit ();
 
-      const octave_value_list tmp = fun (new_args, nargout);
+        const octave_value_list tmp = fun (new_args, nargout);
 
-      if (tmp.length () < nargout)
-        error ("%s: do_simple_cellfun: internal error", fun_name);
+        if (tmp.length () < nargout)
+          error ("%s: do_simple_cellfun: internal error", fun_name);
 
-      for (int i = 0; i < nargout; i++)
-        rcells[i](j) = tmp(i);
-    }
+        for (int i = 0; i < nargout; i++)
+          rcells[i](j) = tmp(i);
+      }
 
-  retval.resize (nargout);
+    retval.resize (nargout);
 
-  for (int i = 0; i < nargout; i++)
-    retval(i) = rcells[i];
+    for (int i = 0; i < nargout; i++)
+      retval(i) = rcells[i];
 
-  return retval;
-}
+    return retval;
+  }
 
-octave_value
-do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
-                   const char *fun_name, const octave_value_list& args)
-{
-  octave_value retval;
+  octave_value
+  do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
+                     const char *fun_name, const octave_value_list& args)
+  {
+    octave_value retval;
 
-  const octave_value_list tmp = do_simple_cellfun (fun, fun_name, args, 1);
+    const octave_value_list tmp = octave::do_simple_cellfun (fun, fun_name, args, 1);
 
-  if (tmp.length () > 0)
-    retval = tmp(0);
+    if (tmp.length () > 0)
+      retval = tmp(0);
 
-  return retval;
+    return retval;
+  }
 }
 
 DEFUN (isstudent, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} isstudent ()
 Return true if running in the student edition of @sc{matlab}.
 
 @code{isstudent} always returns false in Octave.
@@ -1493,8 +1489,184 @@ Return true if running in the student ed
   return ovl (false);
 }
 
 /*
 %!assert (isstudent (), false)
 
 %!error isstudent (1)
 */
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+#include "ov.h"
+#include "ovl.h"
+#include "str-vec.h"
+
+bool
+valid_identifier (const char *s)
+{
+  return octave::valid_identifier (s);
+}
+
+bool
+valid_identifier (const std::string& s)
+{
+  return octave::valid_identifier (s);
+}
+
+bool
+same_file (const std::string& f, const std::string& g)
+{
+  return octave::same_file (f, g);
+}
+
+int
+almost_match (const std::string& std, const std::string& s,
+              int min_match_len, int case_sens)
+{
+  return octave::almost_match (std, s, min_match_len, case_sens);
+}
+
+int
+keyword_almost_match (const char * const *std, int *min_len,
+                      const std::string& s, int min_toks_to_match,
+                      int max_toks)
+{
+  return octave::keyword_almost_match (std, min_len, s, min_toks_to_match,
+                                       max_toks);
+}
+
+std::string
+search_path_for_file (const std::string& path, const string_vector& names)
+{
+  return octave::search_path_for_file (path, names);
+}
+
+string_vector
+search_path_for_all_files (const std::string& path, const string_vector& names)
+{
+  return octave::search_path_for_all_files (path, names);
+}
+
+std::string
+file_in_path (const std::string& name, const std::string& suffix)
+{
+  return octave::file_in_path (name, suffix);
+}
+
+std::string
+find_data_file_in_load_path  (const std::string& fcn, const std::string& file,
+                              bool require_regular_file)
+{
+  return octave::find_data_file_in_load_path  (fcn, file, require_regular_file);
+}
+
+std::string
+contents_file_in_path (const std::string& s)
+{
+  return octave::contents_file_in_path (s);
+}
+
+std::string
+fcn_file_in_path (const std::string& s)
+{
+  return octave::fcn_file_in_path (s);
+}
+
+std::string
+do_string_escapes (const std::string& s)
+{
+  return octave::do_string_escapes (s);
+}
+
+const char *
+undo_string_escape (char c)
+{
+  return octave::undo_string_escape (c);
+}
+
+std::string
+undo_string_escapes (const std::string& s)
+{
+  return octave::undo_string_escapes (s);
+}
+
+void
+check_dimensions (dim_vector& dim, const char *warnfor)
+{
+  return octave::check_dimensions (dim, warnfor);
+}
+
+void
+get_dimensions (const octave_value& a, const char *warn_for,
+                dim_vector& dim)
+{
+  return octave::get_dimensions (a, warn_for, dim);
+}
+
+void
+get_dimensions (const octave_value& a, const octave_value& b,
+                const char *warn_for, octave_idx_type& nr,
+                octave_idx_type& nc)
+{
+  return octave::get_dimensions (a, b, warn_for, nr, nc);
+}
+
+void
+get_dimensions (const octave_value& a, const char *warn_for,
+                octave_idx_type& nr, octave_idx_type& nc)
+{
+  return octave::get_dimensions (a, warn_for, nr, nc);
+}
+
+octave_idx_type
+dims_to_numel (const dim_vector& dims, const octave_value_list& idx)
+{
+  return octave::dims_to_numel (dims, idx);
+}
+
+Matrix
+identity_matrix (octave_idx_type nr, octave_idx_type nc)
+{
+  return octave::identity_matrix (nr, nc);
+}
+
+FloatMatrix
+float_identity_matrix (octave_idx_type nr, octave_idx_type nc)
+{
+  return octave::float_identity_matrix (nr, nc);
+}
+
+size_t
+octave_vformat (std::ostream& os, const char *fmt, va_list args)
+{
+  return octave::vformat (os, fmt, args);
+}
+
+std::string
+octave_vasprintf (const char *fmt, va_list args)
+{
+  return octave::vasprintf (fmt, args);
+}
+
+void
+octave_sleep (double seconds)
+{
+  octave::sleep (seconds);
+}
+
+octave_value_list
+do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
+                   const char *fun_name, const octave_value_list& args,
+                   int nargout)
+{
+  return octave::do_simple_cellfun (fun, fun_name, args, nargout);
+}
+
+octave_value
+do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
+                   const char *fun_name, const octave_value_list& args)
+{
+  return octave::do_simple_cellfun (fun, fun_name, args);
+}
+
+#endif
diff --git a/libinterp/corefcn/utils.h b/libinterp/corefcn/utils.h
--- a/libinterp/corefcn/utils.h
+++ b/libinterp/corefcn/utils.h
@@ -33,98 +33,236 @@ along with Octave; see the file COPYING.
 
 #include "dMatrix.h"
 #include "lo-utils.h"
 
 class octave_value;
 class octave_value_list;
 class string_vector;
 
-extern OCTINTERP_API bool valid_identifier (const char *s);
-extern OCTINTERP_API bool valid_identifier (const std::string& s);
+namespace octave
+{
+  extern OCTINTERP_API bool valid_identifier (const char *s);
+  extern OCTINTERP_API bool valid_identifier (const std::string& s);
+
+  extern OCTINTERP_API bool
+  same_file (const std::string& f, const std::string& g);
+
+  extern OCTINTERP_API int almost_match (const std::string& std,
+                                         const std::string& s,
+                                         int min_match_len = 1,
+                                         int case_sens = 1);
+
+  extern OCTINTERP_API int
+  keyword_almost_match (const char * const *std, int *min_len,
+                        const std::string& s, int min_toks_to_match,
+                        int max_toks);
+
+  extern OCTINTERP_API std::string
+  search_path_for_file (const std::string&, const string_vector&);
+
+  extern OCTINTERP_API string_vector
+  search_path_for_all_files (const std::string&, const string_vector&);
+
+  extern OCTINTERP_API std::string
+  file_in_path (const std::string&, const std::string&);
+
+  extern OCTINTERP_API std::string
+  find_data_file_in_load_path  (const std::string& fcn,
+                                const std::string& file,
+                                bool require_regular_file = false);
+
+  extern OCTINTERP_API std::string contents_file_in_path (const std::string&);
+
+  extern OCTINTERP_API std::string fcn_file_in_path (const std::string&);
+
+  extern OCTINTERP_API std::string do_string_escapes (const std::string& s);
+
+  extern OCTINTERP_API const char * undo_string_escape (char c);
+
+  extern OCTINTERP_API std::string undo_string_escapes (const std::string& s);
+
+  extern OCTINTERP_API void
+  check_dimensions (dim_vector& dim, const char *warnfor);
+
+  extern OCTINTERP_API void
+  get_dimensions (const octave_value& a, const char *warn_for,
+                  dim_vector& dim);
 
+  extern OCTINTERP_API void
+  get_dimensions (const octave_value& a, const octave_value& b,
+                  const char *warn_for, octave_idx_type& nr,
+                  octave_idx_type& nc);
+
+  extern OCTINTERP_API void
+  get_dimensions (const octave_value& a, const char *warn_for,
+                  octave_idx_type& nr, octave_idx_type& nc);
+
+  extern OCTINTERP_API octave_idx_type
+  dims_to_numel (const dim_vector& dims, const octave_value_list& idx);
+
+  extern OCTINTERP_API Matrix
+  identity_matrix (octave_idx_type nr, octave_idx_type nc);
+
+  extern OCTINTERP_API FloatMatrix
+  float_identity_matrix (octave_idx_type nr, octave_idx_type nc);
+
+  extern OCTINTERP_API size_t
+  format (std::ostream& os, const char *fmt, ...);
+
+  extern OCTINTERP_API size_t
+  vformat (std::ostream& os, const char *fmt, va_list args);
+
+  extern OCTINTERP_API std::string
+  vasprintf (const char *fmt, va_list args);
+
+  extern OCTINTERP_API std::string asprintf (const char *fmt, ...);
+
+  extern OCTINTERP_API void sleep (double seconds);
+
+  extern OCTINTERP_API
+  octave_value_list
+  do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
+                     const char *fun_name, const octave_value_list& args,
+                     int nargout);
+
+  extern OCTINTERP_API
+  octave_value
+  do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
+                     const char *fun_name, const octave_value_list& args);
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED (5, "use 'octave::valid_identifier' instead")
+extern OCTINTERP_API bool
+valid_identifier (const char *s);
+
+OCTAVE_DEPRECATED (5, "use 'octave::valid_identifier' instead")
+extern OCTINTERP_API bool
+valid_identifier (const std::string& s);
+
+OCTAVE_DEPRECATED (5, "use 'octave::same_file' instead")
 extern OCTINTERP_API bool
 same_file (const std::string& f, const std::string& g);
 
-extern OCTINTERP_API int almost_match (const std::string& std,
-                                       const std::string& s,
-                                       int min_match_len = 1,
-                                       int case_sens = 1);
+OCTAVE_DEPRECATED (5, "use 'octave::almost_match' instead")
+extern OCTINTERP_API int
+almost_match (const std::string& std, const std::string& s,
+              int min_match_len = 1, int case_sens = 1);
 
+OCTAVE_DEPRECATED (5, "use 'octave::keyword_almost_match' instead")
 extern OCTINTERP_API int
 keyword_almost_match (const char * const *std, int *min_len,
                       const std::string& s, int min_toks_to_match,
                       int max_toks);
 
+OCTAVE_DEPRECATED (5, "use 'octave::search_path_for_file' instead")
 extern OCTINTERP_API std::string
-search_path_for_file (const std::string&, const string_vector&);
+search_path_for_file (const std::string& path, const string_vector& names);
 
+OCTAVE_DEPRECATED (5, "use 'octave::search_path_for_all_files' instead")
 extern OCTINTERP_API string_vector
-search_path_for_all_files (const std::string&, const string_vector&);
+search_path_for_all_files (const std::string& path, const string_vector& names);
 
+OCTAVE_DEPRECATED (5, "use 'octave::file_in_path' instead")
 extern OCTINTERP_API std::string
-file_in_path (const std::string&, const std::string&);
+file_in_path (const std::string& name, const std::string& suffix);
 
+OCTAVE_DEPRECATED (5, "use 'octave::find_data_file_in_load_path ' instead")
 extern OCTINTERP_API std::string
-find_data_file_in_load_path  (const std::string& fcn,
-                              const std::string& file,
+find_data_file_in_load_path  (const std::string& fcn, const std::string& file,
                               bool require_regular_file = false);
 
-extern OCTINTERP_API std::string contents_file_in_path (const std::string&);
+OCTAVE_DEPRECATED (5, "use 'octave::contents_file_in_path' instead")
+extern OCTINTERP_API std::string
+contents_file_in_path (const std::string& s);
 
-extern OCTINTERP_API std::string fcn_file_in_path (const std::string&);
+OCTAVE_DEPRECATED (5, "use 'octave::fcn_file_in_path' instead")
+extern OCTINTERP_API std::string
+fcn_file_in_path (const std::string& s);
 
-extern OCTINTERP_API std::string do_string_escapes (const std::string& s);
+OCTAVE_DEPRECATED (5, "use 'octave::do_string_escapes' instead")
+extern OCTINTERP_API std::string
+do_string_escapes (const std::string& s);
 
-extern OCTINTERP_API const char * undo_string_escape (char c);
+OCTAVE_DEPRECATED (5, "use 'octave::undo_string_escape' instead")
+extern OCTINTERP_API const char *
+undo_string_escape (char c);
 
-extern OCTINTERP_API std::string undo_string_escapes (const std::string& s);
+OCTAVE_DEPRECATED (5, "use 'octave::undo_string_escapes' instead")
+extern OCTINTERP_API std::string
+undo_string_escapes (const std::string& s);
 
+OCTAVE_DEPRECATED (5, "use 'octave::check_dimensions' instead")
 extern OCTINTERP_API void
 check_dimensions (dim_vector& dim, const char *warnfor);
 
+OCTAVE_DEPRECATED (5, "use 'octave::get_dimensions' instead")
 extern OCTINTERP_API void
 get_dimensions (const octave_value& a, const char *warn_for,
                 dim_vector& dim);
 
+OCTAVE_DEPRECATED (5, "use 'octave::get_dimensions' instead")
 extern OCTINTERP_API void
 get_dimensions (const octave_value& a, const octave_value& b,
                 const char *warn_for, octave_idx_type& nr,
                 octave_idx_type& nc);
 
+OCTAVE_DEPRECATED (5, "use 'octave::get_dimensions' instead")
 extern OCTINTERP_API void
-get_dimensions (const octave_value& a,const char *warn_for,
+get_dimensions (const octave_value& a, const char *warn_for,
                 octave_idx_type& nr, octave_idx_type& nc);
 
+OCTAVE_DEPRECATED (5, "use 'octave::dims_to_numel' instead")
 extern OCTINTERP_API octave_idx_type
 dims_to_numel (const dim_vector& dims, const octave_value_list& idx);
 
+OCTAVE_DEPRECATED (5, "use 'octave::identity_matrix' instead")
 extern OCTINTERP_API Matrix
 identity_matrix (octave_idx_type nr, octave_idx_type nc);
 
+OCTAVE_DEPRECATED (5, "use 'octave::float_identity_matrix' instead")
 extern OCTINTERP_API FloatMatrix
 float_identity_matrix (octave_idx_type nr, octave_idx_type nc);
 
-extern OCTINTERP_API size_t
-octave_format (std::ostream& os, const char *fmt, ...);
+template <typename ... Args>
+OCTAVE_DEPRECATED (5, "use 'octave::format' instead")
+size_t
+octave_format (std::ostream& os, const char *fmt, Args&& ... args)
+{
+  return octave::format (os, fmt, std::forward<Args> (args) ...);
+}
 
+OCTAVE_DEPRECATED (5, "use 'octave::vformat' instead")
 extern OCTINTERP_API size_t
 octave_vformat (std::ostream& os, const char *fmt, va_list args);
 
+OCTAVE_DEPRECATED (5, "use 'octave::vasprintf' instead")
 extern OCTINTERP_API std::string
 octave_vasprintf (const char *fmt, va_list args);
 
-extern OCTINTERP_API std::string octave_asprintf (const char *fmt, ...);
+template <typename ... Args>
+OCTAVE_DEPRECATED (5, "use 'octave::asprintf' instead")
+std::string
+octave_asprintf (const char *fmt, Args&& ... args)
+{
+  return octave::asprintf (fmt, std::forward<Args> (args) ...);
+}
 
-extern OCTINTERP_API void octave_sleep (double seconds);
+OCTAVE_DEPRECATED (5, "use 'octave::sleep' instead")
+extern OCTINTERP_API void
+octave_sleep (double seconds);
 
-extern OCTINTERP_API
-octave_value_list
+OCTAVE_DEPRECATED (5, "use 'octave::do_simple_cellfun' instead")
+extern OCTINTERP_API octave_value_list
 do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
                    const char *fun_name, const octave_value_list& args,
                    int nargout);
 
-extern OCTINTERP_API
-octave_value
+OCTAVE_DEPRECATED (5, "use 'octave::do_simple_cellfun' instead")
+extern OCTINTERP_API octave_value
 do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
                    const char *fun_name, const octave_value_list& args);
 
 #endif
+
+#endif
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -275,17 +275,17 @@ symbol_exist (octave::interpreter& inter
               if (len > 4 && (file_name.substr (len-4) == ".oct"
                               || file_name.substr (len-4) == ".mex"))
                 return 3;
               else
                 return 2;
             }
         }
 
-      file_name = file_in_path (name, "");
+      file_name = octave::file_in_path (name, "");
 
       if (file_name.empty ())
         file_name = name;
 
       octave::sys::file_stat fs (file_name);
 
       if (fs)
         {
diff --git a/libinterp/dldfcn/__init_gnuplot__.cc b/libinterp/dldfcn/__init_gnuplot__.cc
--- a/libinterp/dldfcn/__init_gnuplot__.cc
+++ b/libinterp/dldfcn/__init_gnuplot__.cc
@@ -184,25 +184,25 @@ have_gnuplot_binary (void)
       octave_value_list tmp
         = octave::feval ("gnuplot_binary", octave_value_list ());
 
       if (tmp(0).is_string ())
         {
           std::string gnuplot_binary = tmp(0).string_value ();
 
           string_vector args (gnuplot_binary);
-          std::string gnuplot_path = search_path_for_file (path, args);
+          std::string gnuplot_path = octave::search_path_for_file (path, args);
 
           octave::sys::file_stat fs (gnuplot_path);
 
           if (! fs.exists () && ! exeext.empty ())
             {
               args[0] += exeext;
 
-              gnuplot_path = search_path_for_file (path, args);
+              gnuplot_path = octave::search_path_for_file (path, args);
 
               fs = octave::sys::file_stat (gnuplot_path);
             }
 
           retval = fs.exists ();
         }
     }
   catch (octave::execution_exception&)
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -188,17 +188,17 @@ octave_base_value::size (void)
   for (octave_idx_type i = 0; i < dv.ndims (); i++)
     mdv(i) = dv(i);
   return mdv;
 }
 
 octave_idx_type
 octave_base_value::numel (const octave_value_list& idx)
 {
-  return dims_to_numel (dims (), idx);
+  return octave::dims_to_numel (dims (), idx);
 }
 
 octave_value
 octave_base_value::subsref (const std::string&,
                             const std::list<octave_value_list>&)
 {
   std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1246,33 +1246,33 @@ dimensions.
 
   switch (nargin)
     {
     case 0:
       dims = dim_vector (0, 0);
       break;
 
     case 1:
-      get_dimensions (args(0), "cell", dims);
+      octave::get_dimensions (args(0), "cell", dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
           dims(i) = (args(i).isempty ()
                      ? 0 : args(i).xidx_type_value ("cell: dimension must be a scalar integer"));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
-  check_dimensions (dims, "cell");
+  octave::check_dimensions (dims, "cell");
 
   return ovl (Cell (dims));
 }
 
 /*
 ## This might work on some system someday, but for now, who has a system
 ## where a 16 yottabyte array can be allocated?  See bug #50934.
 %!error <out of memory> cell (1e24, 1);
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -284,17 +284,17 @@ octave_char_matrix_str::edit_display (co
 {
   if (i == 0)
     {
       if (rows () == 1)
         {
           std::string retval = string_value ();
 
           if (! is_sq_string ())
-            retval = undo_string_escapes (retval);
+            retval = octave::undo_string_escapes (retval);
 
           return retval;
         }
       else if (is_zero_by_zero ())
         return "";
     }
 
   std::string tname = type_name ();
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -103,17 +103,17 @@ static void
 err_invalid_index_type (const std::string& nm, char t)
 {
   error ("%s cannot be indexed with %c", nm.c_str (), t);
 }
 
 static void
 maybe_warn_invalid_field_name (const std::string& key, const char *who)
 {
-  if (! valid_identifier (key))
+  if (! octave::valid_identifier (key))
     {
       if (who)
         warning_with_id ("Octave:language-extension",
                          "%s: invalid structure field name '%s'",
                          who, key.c_str ());
       else
         warning_with_id ("Octave:language-extension",
                          "invalid structure field name '%s'",
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -327,17 +327,17 @@ octave_user_function::mark_as_system_fcn
       // when we looked it up, to avoid possible race conditions...
       // FIXME
       //
       // We probably also don't need to get the library directory
       // every time, but since this function is only called when the
       // function file is parsed, it probably doesn't matter that
       // much.
 
-      std::string ff_name = fcn_file_in_path (file_name);
+      std::string ff_name = octave::fcn_file_in_path (file_name);
 
       std::string fcn_file_dir = octave::config::fcn_file_dir ();
       if (fcn_file_dir == ff_name.substr (0, fcn_file_dir.length ()))
         system_fcn_file = true;
     }
   else
     system_fcn_file = false;
 }
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -1749,17 +1749,17 @@ ANY_INCLUDING_NL (.|{NL})
       return -1;
     else if (c == EOF)
       return curr_lexer->handle_end_of_input ();
     else
       {
         std::ostringstream buf;
 
         buf << "invalid character '"
-            << undo_string_escape (static_cast<char> (c))
+            << octave::undo_string_escape (static_cast<char> (c))
             << "' (ASCII " << c << ")";
 
         octave::token *tok
           = new octave::token (LEXICAL_ERROR, buf.str (),
                                curr_lexer->m_input_line_number,
                                curr_lexer->m_current_input_column);
 
         curr_lexer->push_token (tok);
diff --git a/libinterp/parse-tree/oct-parse.yy b/libinterp/parse-tree/oct-parse.yy
--- a/libinterp/parse-tree/oct-parse.yy
+++ b/libinterp/parse-tree/oct-parse.yy
@@ -5643,17 +5643,17 @@ may be either @qcode{"base"} or @qcode{"
     cs.goto_base_frame ();
   else
     error ("assignin: CONTEXT must be \"caller\" or \"base\"");
 
   frame.add_method (cs, &octave::call_stack::pop);
 
   std::string nm = args(1).xstring_value ("assignin: VARNAME must be a string");
 
-  if (valid_identifier (nm))
+  if (octave::valid_identifier (nm))
     {
       // Put the check here so that we don't slow down assignments
       // generally.  Any that go through Octave's parser should have
       // already been checked.
 
       if (octave::is_keyword (nm))
         error ("assignin: invalid assignment to keyword '%s'", nm.c_str ());
 
