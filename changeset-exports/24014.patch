# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1504716808 14400
#      Wed Sep 06 12:53:28 2017 -0400
# Node ID bffd7d8268877369313401499917f41d2afe6930
# Parent  26ec2e2648261b8d15511b83e45d31a9a5492d9a
style fixes for some GUI source files

* files-dock-widget.cc, files-dock-widget.h, octave-cmd.cc,
octave-cmd.h, octave-dock-widget.cc, octave-dock-widget.h,
resource-manager.cc, resource-manager.h, shortcut-manager.cc,
shortcut-manager.h, variable-editor-model.cc, variable-editor-model.h,
variable-editor.cc, variable-editor.h, welcome-wizard.cc,
welcome-wizard.h, workspace-model.cc, workspace-model.h,
workspace-view.cc, workspace-view.h: Use m_ prefix for member
variables, order functions consistently in header and source files,
and follow more Octave coding conventions.

diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -49,103 +49,105 @@ along with Octave; see the file COPYING.
 #include "oct-env.h"
 
 class FileTreeViewer : public QTreeView
 {
 public:
 
   FileTreeViewer (QWidget *p) : QTreeView (p) { }
 
+  ~FileTreeViewer (void) = default;
+
   void mousePressEvent (QMouseEvent *e)
   {
     if (e->button () != Qt::RightButton)
       QTreeView::mousePressEvent (e);
   }
 };
 
 files_dock_widget::files_dock_widget (QWidget *p)
   : octave_dock_widget (p)
 {
   setObjectName ("FilesDockWidget");
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("File Browser"));
   setToolTip (tr ("Browse your files"));
 
-  _sig_mapper = nullptr;
+  m_sig_mapper = nullptr;
 
-  _columns_shown = QStringList ();
-  _columns_shown.append (tr ("File size"));
-  _columns_shown.append (tr ("File type"));
-  _columns_shown.append (tr ("Date modified"));
-  _columns_shown.append (tr ("Show hidden"));
-  _columns_shown.append (tr ("Alternating row colors"));
+  m_columns_shown = QStringList ();
+  m_columns_shown.append (tr ("File size"));
+  m_columns_shown.append (tr ("File type"));
+  m_columns_shown.append (tr ("Date modified"));
+  m_columns_shown.append (tr ("Show hidden"));
+  m_columns_shown.append (tr ("Alternating row colors"));
 
-  _columns_shown_keys = QStringList ();
-  _columns_shown_keys.append ("filesdockwidget/showFileSize");
-  _columns_shown_keys.append ("filesdockwidget/showFileType");
-  _columns_shown_keys.append ("filesdockwidget/showLastModified");
-  _columns_shown_keys.append ("filesdockwidget/showHiddenFiles");
-  _columns_shown_keys.append ("filesdockwidget/useAlternatingRowColors");
+  m_columns_shown_keys = QStringList ();
+  m_columns_shown_keys.append ("filesdockwidget/showFileSize");
+  m_columns_shown_keys.append ("filesdockwidget/showFileType");
+  m_columns_shown_keys.append ("filesdockwidget/showLastModified");
+  m_columns_shown_keys.append ("filesdockwidget/showHiddenFiles");
+  m_columns_shown_keys.append ("filesdockwidget/useAlternatingRowColors");
 
   QWidget *container = new QWidget (this);
 
   setWidget (container);
 
   connect (this, SIGNAL (open_file (const QString&)),
            main_win (), SLOT (open_file (const QString&)));
 
   connect (this, SIGNAL (displayed_directory_changed (const QString&)),
            main_win (), SLOT (set_current_working_directory (const QString&)));
 
   // Create a toolbar
-  _navigation_tool_bar = new QToolBar ("", container);
-  _navigation_tool_bar->setAllowedAreas (Qt::TopToolBarArea);
-  _navigation_tool_bar->setMovable (false);
+  m_navigation_tool_bar = new QToolBar ("", container);
+  m_navigation_tool_bar->setAllowedAreas (Qt::TopToolBarArea);
+  m_navigation_tool_bar->setMovable (false);
 
-  _current_directory = new QComboBox (_navigation_tool_bar);
-  _current_directory->setToolTip (tr ("Enter the path or filename"));
-  _current_directory->setEditable (true);
-  _current_directory->setMaxCount (MaxMRUDirs);
-  _current_directory->setInsertPolicy (QComboBox::NoInsert);
-  _current_directory->setSizeAdjustPolicy (
+  m_current_directory = new QComboBox (m_navigation_tool_bar);
+  m_current_directory->setToolTip (tr ("Enter the path or filename"));
+  m_current_directory->setEditable (true);
+  m_current_directory->setMaxCount (MaxMRUDirs);
+  m_current_directory->setInsertPolicy (QComboBox::NoInsert);
+  m_current_directory->setSizeAdjustPolicy (
     QComboBox::AdjustToMinimumContentsLengthWithIcon);
   QSizePolicy sizePol (QSizePolicy::Expanding, QSizePolicy::Preferred);
-  _current_directory->setSizePolicy (sizePol);
+  m_current_directory->setSizePolicy (sizePol);
 
   QAction *directory_up_action = new QAction (resource_manager::icon ("go-up"),
-                                              "", _navigation_tool_bar);
+                                              "", m_navigation_tool_bar);
   directory_up_action->setToolTip (tr ("One directory up"));
 
-  _sync_browser_directory_action
+  m_sync_browser_directory_action
     = new QAction (resource_manager::icon ("go-first"),
-                   tr ("Show Octave directory"), _navigation_tool_bar);
-  _sync_browser_directory_action->setToolTip (
+                   tr ("Show Octave directory"), m_navigation_tool_bar);
+  m_sync_browser_directory_action->setToolTip (
     tr ("Go to current Octave directory"));
-  _sync_browser_directory_action->setEnabled ("false");
+  m_sync_browser_directory_action->setEnabled ("false");
 
-  _sync_octave_directory_action
+  m_sync_octave_directory_action
     = new QAction (resource_manager::icon ("go-last"),
-                   tr ("Set Octave directory"), _navigation_tool_bar);
-  _sync_octave_directory_action->setToolTip (
+                   tr ("Set Octave directory"), m_navigation_tool_bar);
+  m_sync_octave_directory_action->setToolTip (
     tr ("Set Octave directory to current browser directory"));
-  _sync_octave_directory_action->setEnabled ("false");
+  m_sync_octave_directory_action->setEnabled ("false");
 
   QToolButton *popdown_button = new QToolButton ();
   popdown_button->setToolTip (tr ("Actions on current directory"));
   QMenu *popdown_menu = new QMenu ();
   popdown_menu->addAction (resource_manager::icon ("user-home"),
                            tr ("Show Home Directory"),
                            this, SLOT (popdownmenu_home (bool)));
-  popdown_menu->addAction (_sync_browser_directory_action);
-  popdown_menu->addAction (_sync_octave_directory_action);
+  popdown_menu->addAction (m_sync_browser_directory_action);
+  popdown_menu->addAction (m_sync_octave_directory_action);
   popdown_button->setMenu (popdown_menu);
   popdown_button->setPopupMode (QToolButton::InstantPopup);
   popdown_button->setDefaultAction (new QAction (
                             resource_manager::icon ("applications-system"), "",
-                            _navigation_tool_bar));
+                            m_navigation_tool_bar));
 
   popdown_menu->addSeparator ();
   popdown_menu->addAction (resource_manager::icon ("folder"),
                            tr ("Set Browser Directory..."),
                            this, SLOT (popdownmenu_search_dir (bool)));
   popdown_menu->addSeparator ();
   popdown_menu->addAction (resource_manager::icon ("edit-find"),
                            tr ("Find Files..."),
@@ -153,25 +155,25 @@ files_dock_widget::files_dock_widget (QW
   popdown_menu->addSeparator ();
   popdown_menu->addAction (resource_manager::icon ("document-new"),
                            tr ("New File..."),
                            this, SLOT (popdownmenu_newfile (bool)));
   popdown_menu->addAction (resource_manager::icon ("folder-new"),
                            tr ("New Directory..."),
                            this, SLOT (popdownmenu_newdir (bool)));
 
-  _navigation_tool_bar->addWidget (_current_directory);
-  _navigation_tool_bar->addAction (directory_up_action);
-  _navigation_tool_bar->addWidget (popdown_button);
+  m_navigation_tool_bar->addWidget (m_current_directory);
+  m_navigation_tool_bar->addAction (directory_up_action);
+  m_navigation_tool_bar->addWidget (popdown_button);
 
   connect (directory_up_action, SIGNAL (triggered ()), this,
            SLOT (change_directory_up ()));
-  connect (_sync_octave_directory_action, SIGNAL (triggered ()), this,
+  connect (m_sync_octave_directory_action, SIGNAL (triggered ()), this,
            SLOT (do_sync_octave_directory ()));
-  connect (_sync_browser_directory_action, SIGNAL (triggered ()), this,
+  connect (m_sync_browser_directory_action, SIGNAL (triggered ()), this,
            SLOT (do_sync_browser_directory ()));
 
   QSettings *settings = resource_manager::get_settings ();
   // FIXME: what should happen if settings is 0?
 
   // Create the QFileSystemModel starting in the desired directory
   QDir startup_dir;  // take current dir
 
@@ -191,200 +193,200 @@ files_dock_widget::files_dock_widget (QW
     }
 
   if (! startup_dir.exists ())
     {
       // the configured startup dir does not exist, take actual one
       startup_dir = QDir ();
     }
 
-  _file_system_model = new QFileSystemModel (this);
-  QModelIndex rootPathIndex = _file_system_model->setRootPath (
+  m_file_system_model = new QFileSystemModel (this);
+  QModelIndex rootPathIndex = m_file_system_model->setRootPath (
                                 startup_dir.absolutePath ());
 
   // Attach the model to the QTreeView and set the root index
-  _file_tree_view = new FileTreeViewer (container);
-  _file_tree_view->setSelectionMode (QAbstractItemView::ExtendedSelection);
-  _file_tree_view->setModel (_file_system_model);
-  _file_tree_view->setRootIndex (rootPathIndex);
-  _file_tree_view->setSortingEnabled (true);
-  _file_tree_view->setAlternatingRowColors (true);
-  _file_tree_view->setAnimated (true);
-  _file_tree_view->setToolTip (
+  m_file_tree_view = new FileTreeViewer (container);
+  m_file_tree_view->setSelectionMode (QAbstractItemView::ExtendedSelection);
+  m_file_tree_view->setModel (m_file_system_model);
+  m_file_tree_view->setRootIndex (rootPathIndex);
+  m_file_tree_view->setSortingEnabled (true);
+  m_file_tree_view->setAlternatingRowColors (true);
+  m_file_tree_view->setAnimated (true);
+  m_file_tree_view->setToolTip (
     tr ("Activate to open in editor, right click for alternatives"));
 
   // get sort column and order as well as cloumn state (order and width)
 
-  _file_tree_view->sortByColumn (
+  m_file_tree_view->sortByColumn (
     settings->value ("filesdockwidget/sort_files_by_column",0).toInt (),
     static_cast<Qt::SortOrder>
     (settings->value ("filesdockwidget/sort_files_by_order",
                       Qt::AscendingOrder).toUInt ())
   );
-  _file_tree_view->header ()->restoreState (
+  m_file_tree_view->header ()->restoreState (
     settings->value ("filesdockwidget/column_state").toByteArray ());
 
   QStringList mru_dirs =
     settings->value ("filesdockwidget/mru_dir_list").toStringList ();
-  _current_directory->addItems (mru_dirs);
+  m_current_directory->addItems (mru_dirs);
 
-  _current_directory->setEditText (
-    _file_system_model->fileInfo (rootPathIndex).  absoluteFilePath ());
+  m_current_directory->setEditText (
+    m_file_system_model->fileInfo (rootPathIndex).  absoluteFilePath ());
 
-  connect (_file_tree_view, SIGNAL (activated (const QModelIndex &)),
+  connect (m_file_tree_view, SIGNAL (activated (const QModelIndex &)),
            this, SLOT (item_double_clicked (const QModelIndex &)));
 
   // add context menu to tree_view
-  _file_tree_view->setContextMenuPolicy (Qt::CustomContextMenu);
-  connect (_file_tree_view,
+  m_file_tree_view->setContextMenuPolicy (Qt::CustomContextMenu);
+  connect (m_file_tree_view,
            SIGNAL (customContextMenuRequested (const QPoint &)),
            this, SLOT (contextmenu_requested (const QPoint &)));
 
-  _file_tree_view->header ()->setContextMenuPolicy (Qt::CustomContextMenu);
-  connect (_file_tree_view->header (),
+  m_file_tree_view->header ()->setContextMenuPolicy (Qt::CustomContextMenu);
+  connect (m_file_tree_view->header (),
            SIGNAL (customContextMenuRequested (const QPoint &)),
            this, SLOT (headercontextmenu_requested (const QPoint &)));
 
   // Layout the widgets vertically with the toolbar on top
   QVBoxLayout *vbox_layout = new QVBoxLayout ();
   vbox_layout->setSpacing (0);
-  vbox_layout->addWidget (_navigation_tool_bar);
-  vbox_layout->addWidget (_file_tree_view);
+  vbox_layout->addWidget (m_navigation_tool_bar);
+  vbox_layout->addWidget (m_file_tree_view);
   vbox_layout->setMargin (1);
 
   container->setLayout (vbox_layout);
 
   // FIXME: Add right-click contextual menus for copying, pasting,
   //        deleting files (and others).
 
-  connect (_current_directory->lineEdit (), SIGNAL (returnPressed ()),
+  connect (m_current_directory->lineEdit (), SIGNAL (returnPressed ()),
            this, SLOT (accept_directory_line_edit ()));
 
-  connect (_current_directory, SIGNAL (activated (const QString &)),
+  connect (m_current_directory, SIGNAL (activated (const QString &)),
            this, SLOT (set_current_directory (const QString &)));
 
   connect (this, SIGNAL (run_file_signal (const QFileInfo&)),
            main_win (), SLOT (run_file_in_terminal (const QFileInfo&)));
 
-  QCompleter *completer = new QCompleter (_file_system_model, this);
-  _current_directory->setCompleter (completer);
+  QCompleter *completer = new QCompleter (m_file_system_model, this);
+  m_current_directory->setCompleter (completer);
 
-  setFocusProxy (_current_directory);
+  setFocusProxy (m_current_directory);
 
-  _sync_octave_dir = true;   // default, overwirtten with notice_settings ()
-  _octave_dir = "";
+  m_sync_octave_dir = true;   // default, overwirtten with notice_settings ()
+  m_octave_dir = "";
 }
 
 void
 files_dock_widget::save_settings (void)
 {
   QSettings *settings = resource_manager::get_settings ();
 
   if (! settings)
     return;
 
-  int sort_column = _file_tree_view->header ()->sortIndicatorSection ();
-  Qt::SortOrder sort_order = _file_tree_view->header ()->sortIndicatorOrder ();
+  int sort_column = m_file_tree_view->header ()->sortIndicatorSection ();
+  Qt::SortOrder sort_order = m_file_tree_view->header ()->sortIndicatorOrder ();
   settings->setValue ("filesdockwidget/sort_files_by_column", sort_column);
   settings->setValue ("filesdockwidget/sort_files_by_order", sort_order);
   settings->setValue ("filesdockwidget/column_state",
-                      _file_tree_view->header ()->saveState ());
+                      m_file_tree_view->header ()->saveState ());
 
   QStringList dirs;
-  for (int i=0; i< _current_directory->count (); i++)
+  for (int i=0; i< m_current_directory->count (); i++)
     {
-      dirs.append (_current_directory->itemText (i));
+      dirs.append (m_current_directory->itemText (i));
     }
   settings->setValue ("filesdockwidget/mru_dir_list", dirs);
 
   settings->sync ();
 
   octave_dock_widget::save_settings ();
 
-  if (_sig_mapper)
-    delete _sig_mapper;
+  if (m_sig_mapper)
+    delete m_sig_mapper;
 }
 
 void
 files_dock_widget::item_double_clicked (const QModelIndex& index)
 {
   // Retrieve the file info associated with the model index.
-  QFileInfo fileInfo = _file_system_model->fileInfo (index);
+  QFileInfo fileInfo = m_file_system_model->fileInfo (index);
   set_current_directory (fileInfo.absoluteFilePath ());
 }
 
 void
 files_dock_widget::set_current_directory (const QString& dir)
 {
   display_directory (dir);
 }
 
 void
 files_dock_widget::accept_directory_line_edit (void)
 {
-  display_directory (_current_directory->currentText ());
+  display_directory (m_current_directory->currentText ());
 }
 
 void
 files_dock_widget::change_directory_up (void)
 {
   QDir dir
-    = QDir (_file_system_model->filePath (_file_tree_view->rootIndex ()));
+    = QDir (m_file_system_model->filePath (m_file_tree_view->rootIndex ()));
 
   dir.cdUp ();
   display_directory (dir.absolutePath ());
 }
 
 void
 files_dock_widget::do_sync_octave_directory (void)
 {
   QDir dir
-    = QDir (_file_system_model->filePath (_file_tree_view->rootIndex ()));
+    = QDir (m_file_system_model->filePath (m_file_tree_view->rootIndex ()));
 
   emit displayed_directory_changed (dir.absolutePath ());
 }
 
 void
 files_dock_widget::do_sync_browser_directory (void)
 {
-  display_directory (_octave_dir,false);  // false: no sync of octave dir
+  display_directory (m_octave_dir,false);  // false: no sync of octave dir
 }
 
 void
 files_dock_widget::update_octave_directory (const QString& dir)
 {
-  _octave_dir = dir;
-  if (_sync_octave_dir)
-    display_directory (_octave_dir,false);  // false: no sync of octave dir
+  m_octave_dir = dir;
+  if (m_sync_octave_dir)
+    display_directory (m_octave_dir,false);  // false: no sync of octave dir
 }
 
 void
 files_dock_widget::display_directory (const QString& dir, bool set_octave_dir)
 {
   QFileInfo fileInfo (dir);
   if (fileInfo.exists ())
     {
       if (fileInfo.isDir ())
         {
-          _file_tree_view->setRootIndex (_file_system_model->
+          m_file_tree_view->setRootIndex (m_file_system_model->
                                          index (fileInfo.absoluteFilePath ()));
-          _file_system_model->setRootPath (fileInfo.absoluteFilePath ());
-          if (_sync_octave_dir && set_octave_dir)
+          m_file_system_model->setRootPath (fileInfo.absoluteFilePath ());
+          if (m_sync_octave_dir && set_octave_dir)
             process_set_current_dir (fileInfo.absoluteFilePath ());
 
           // see if its in the list, and if it is,
           // remove it and then, put at top of the list
           int index
-            = _current_directory->findText (fileInfo.absoluteFilePath ());
+            = m_current_directory->findText (fileInfo.absoluteFilePath ());
           if (index != -1)
             {
-              _current_directory->removeItem (index);
+              m_current_directory->removeItem (index);
             }
-          _current_directory->insertItem (0, fileInfo.absoluteFilePath ());
-          _current_directory->setCurrentIndex (0);
+          m_current_directory->insertItem (0, fileInfo.absoluteFilePath ());
+          m_current_directory->setCurrentIndex (0);
         }
       else
         {
           QString abs_fname = fileInfo.absoluteFilePath ();
 
           QString suffix = fileInfo.suffix ().toLower ();
           QSettings *settings = resource_manager::get_settings ();
           QString ext = settings->value ("filesdockwidget/txt_file_extensions",
@@ -393,99 +395,99 @@ files_dock_widget::display_directory (co
 
           if (QFile::exists (abs_fname))
             {
               if (is_octave_data_file (abs_fname.toStdString ()))
                 emit load_file_signal (abs_fname);
               else if (extensions.contains (suffix))
                 emit open_file (fileInfo.absoluteFilePath ());
               else
-                open_item_in_app (_file_tree_view->selectionModel ()
+                open_item_in_app (m_file_tree_view->selectionModel ()
                                   ->currentIndex ());
             }
         }
     }
 }
 
 void
 files_dock_widget::open_item_in_app (const QModelIndex& index)
 {
   // Retrieve the file info associated with the model index.
-  QFileInfo fileInfo = _file_system_model->fileInfo (index);
+  QFileInfo fileInfo = m_file_system_model->fileInfo (index);
 
   QString file = fileInfo.absoluteFilePath ();
 
   QDesktopServices::openUrl (QUrl::fromLocalFile (file));
 }
 
 void files_dock_widget::toggle_header (int col)
 {
   QSettings *settings = resource_manager::get_settings ();
 
-  QString key = _columns_shown_keys.at (col);
+  QString key = m_columns_shown_keys.at (col);
   bool shown = settings->value (key,false).toBool ();
   settings->setValue (key, ! shown);
   settings->sync ();
 
   switch (col)
     {
     case 0:
     case 1:
     case 2:
       // toggle column visibility
-      _file_tree_view->setColumnHidden (col + 1, shown);
+      m_file_tree_view->setColumnHidden (col + 1, shown);
       break;
     case 3:
     case 4:
       // other actions depending on new settings
       notice_settings (settings);
       break;
     }
 }
 
 void
 files_dock_widget::headercontextmenu_requested (const QPoint& mpos)
 {
   QMenu menu (this);
 
-  if (_sig_mapper)
-    delete _sig_mapper;
-  _sig_mapper = new QSignalMapper (this);
+  if (m_sig_mapper)
+    delete m_sig_mapper;
+  m_sig_mapper = new QSignalMapper (this);
 
   QSettings *settings = resource_manager::get_settings ();
 
-  for (int i = 0; i < _columns_shown.size (); i++)
+  for (int i = 0; i < m_columns_shown.size (); i++)
     {
-      QAction *action = menu.addAction (_columns_shown.at (i),
-                                        _sig_mapper, SLOT (map ()));
-      _sig_mapper->setMapping (action, i);
+      QAction *action = menu.addAction (m_columns_shown.at (i),
+                                        m_sig_mapper, SLOT (map ()));
+      m_sig_mapper->setMapping (action, i);
       action->setCheckable (true);
       action->setChecked (
-            settings->value (_columns_shown_keys.at (i),true).toBool ());
+            settings->value (m_columns_shown_keys.at (i),true).toBool ());
     }
 
-  connect (_sig_mapper, SIGNAL (mapped (int)),
+  connect (m_sig_mapper, SIGNAL (mapped (int)),
            this, SLOT (toggle_header (int)));
 
-  menu.exec (_file_tree_view->mapToGlobal (mpos));
+  menu.exec (m_file_tree_view->mapToGlobal (mpos));
 }
 
 void
 files_dock_widget::contextmenu_requested (const QPoint& mpos)
 {
 
   QMenu menu (this);
 
-  QModelIndex index = _file_tree_view->indexAt (mpos);
+  QModelIndex index = m_file_tree_view->indexAt (mpos);
 
   if (index.isValid ())
     {
-      QFileInfo info = _file_system_model->fileInfo (index);
+      QFileInfo info = m_file_system_model->fileInfo (index);
 
-      QItemSelectionModel *m = _file_tree_view->selectionModel ();
+      QItemSelectionModel *m = m_file_tree_view->selectionModel ();
       QModelIndexList sel = m->selectedRows ();
 
       // check if item at mouse position is seleccted
       if (! sel.contains (index))
         {
           // is not selected -> clear actual selection and select this item
           m->setCurrentIndex (index,
                               QItemSelectionModel::Clear
@@ -541,122 +543,122 @@ files_dock_widget::contextmenu_requested
                           tr ("New File..."),
                           this, SLOT (contextmenu_newfile (bool)));
           menu.addAction (resource_manager::icon ("folder-new"),
                           tr ("New Directory..."),
                           this, SLOT (contextmenu_newdir (bool)));
         }
 
       // show the menu
-      menu.exec (_file_tree_view->mapToGlobal (mpos));
+      menu.exec (m_file_tree_view->mapToGlobal (mpos));
 
     }
 }
 
 void
 files_dock_widget::contextmenu_open (bool)
 {
 
-  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QItemSelectionModel *m = m_file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     {
-      QFileInfo file = _file_system_model->fileInfo (*it);
+      QFileInfo file = m_file_system_model->fileInfo (*it);
       if (file.exists ())
         display_directory (file.absoluteFilePath ());
     }
 }
 
 void
 files_dock_widget::contextmenu_open_in_editor (bool)
 {
 
-  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QItemSelectionModel *m = m_file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     {
-      QFileInfo file = _file_system_model->fileInfo (*it);
+      QFileInfo file = m_file_system_model->fileInfo (*it);
       if (file.exists ())
         emit open_file (file.absoluteFilePath ());
     }
 }
 
 void
 files_dock_widget::contextmenu_open_in_app (bool)
 {
-  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QItemSelectionModel *m = m_file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     open_item_in_app (*it);
 }
 
 void
 files_dock_widget::contextmenu_copy_selection (bool)
 {
-  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QItemSelectionModel *m = m_file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   QStringList selection;
 
   for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     {
-      QFileInfo info = _file_system_model->fileInfo (*it);
+      QFileInfo info = m_file_system_model->fileInfo (*it);
 
       selection << info.fileName ();
     }
 
   QClipboard *clipboard = QApplication::clipboard ();
 
   clipboard->setText (selection.join ("\n"));
 }
 
 void
 files_dock_widget::contextmenu_load (bool)
 {
-  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QItemSelectionModel *m = m_file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo (index);
+      QFileInfo info = m_file_system_model->fileInfo (index);
 
       emit load_file_signal (info.fileName ());
     }
 }
 
 void
 files_dock_widget::contextmenu_run (bool)
 {
-  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QItemSelectionModel *m = m_file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo (index);
+      QFileInfo info = m_file_system_model->fileInfo (index);
       emit run_file_signal (info);
     }
 }
 
 void
 files_dock_widget::contextmenu_rename (bool)
 {
-  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QItemSelectionModel *m = m_file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
   if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo (index);
+      QFileInfo info = m_file_system_model->fileInfo (index);
       QDir path = info.absoluteDir ();
       QString old_name = info.fileName ();
       bool ok;
 
       QString new_name
         = QInputDialog::getText (this, tr ("Rename file/directory"),
                                  tr ("Rename file/directory:\n")
                                  + old_name + tr ("\n to: "),
@@ -667,33 +669,33 @@ files_dock_widget::contextmenu_rename (b
           old_name = path.absolutePath () + '/' + old_name;
           // editor: close old
           emit file_remove_signal (old_name, new_name);
           // Do the renaming
           bool st = path.rename (old_name, new_name);
           // editor: load new/old file depending on success
           emit file_renamed_signal (st);
           // Clear cache of file browser
-          _file_system_model->revert ();
+          m_file_system_model->revert ();
         }
     }
 
 }
 
 void
 files_dock_widget::contextmenu_delete (bool)
 {
-  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QItemSelectionModel *m = m_file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     {
       QModelIndex index = *it;
 
-      QFileInfo info = _file_system_model->fileInfo (index);
+      QFileInfo info = m_file_system_model->fileInfo (index);
 
       if (QMessageBox::question (this, tr ("Delete file/directory"),
                                  tr ("Are you sure you want to delete\n")
                                  + info.filePath (),
                                  QMessageBox::Yes | QMessageBox::No)
           == QMessageBox::Yes)
         {
           if (info.isDir ())
@@ -702,99 +704,99 @@ files_dock_widget::contextmenu_delete (b
               QDir path (info.absoluteFilePath ());
               QList<QFileInfo> fileLst = path.entryInfoList (QDir::AllEntries |
                                          QDir::NoDotAndDotDot);
 
               if (fileLst.count () != 0)
                 QMessageBox::warning (this, tr ("Delete file/directory"),
                                       tr ("Can not delete a directory that is not empty"));
               else
-                _file_system_model->rmdir (index);
+                m_file_system_model->rmdir (index);
             }
           else
             {
               // Close the file in the editor if open
               emit file_remove_signal (info.filePath (), QString ());
               // Remove the file.
-              bool st = _file_system_model->remove (index);
+              bool st = m_file_system_model->remove (index);
               // reload the old file if removing was not successful
               if (! st)
                 emit file_renamed_signal (false);
             }
 
-          _file_system_model->revert ();
+          m_file_system_model->revert ();
 
         }
     }
 }
 
 void
 files_dock_widget::contextmenu_newfile (bool)
 {
-  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QItemSelectionModel *m = m_file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo (index);
+      QFileInfo info = m_file_system_model->fileInfo (index);
       QString parent_dir = info.filePath ();
 
       process_new_file (parent_dir);
     }
 }
 
 void
 files_dock_widget::contextmenu_newdir (bool)
 {
-  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QItemSelectionModel *m = m_file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo (index);
+      QFileInfo info = m_file_system_model->fileInfo (index);
       QString parent_dir = info.filePath ();
 
       process_new_dir (parent_dir);
     }
 }
 
 void
 files_dock_widget::contextmenu_setcurrentdir (bool)
 {
-  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QItemSelectionModel *m = m_file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo (index);
+      QFileInfo info = m_file_system_model->fileInfo (index);
 
       if (info.isDir ())
         {
           process_set_current_dir (info.absoluteFilePath ());
         }
     }
 }
 
 void
 files_dock_widget::contextmenu_findfiles (bool)
 {
-  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QItemSelectionModel *m = m_file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo (index);
+      QFileInfo info = m_file_system_model->fileInfo (index);
 
       if (info.isDir ())
         {
           process_find_files (info.absoluteFilePath ());
         }
     }
 }
 
@@ -807,42 +809,42 @@ files_dock_widget::notice_settings (cons
   QStyle *st = style ();
   int icon_size = st->pixelMetric (QStyle::PM_ToolBarIconSize);
 
   if (icon_size_settings == 1)
     icon_size = st->pixelMetric (QStyle::PM_LargeIconSize);
   else if (icon_size_settings == -1)
     icon_size = st->pixelMetric (QStyle::PM_SmallIconSize);
 
-  _navigation_tool_bar->setIconSize (QSize (icon_size,icon_size));
+  m_navigation_tool_bar->setIconSize (QSize (icon_size,icon_size));
 
   // filenames are always shown, other columns can be hidden by settings
   for (int i = 0; i < 3; i++)
-    _file_tree_view->setColumnHidden (i + 1,
-        ! settings->value (_columns_shown_keys.at (i),false).toBool ());
+    m_file_tree_view->setColumnHidden (i + 1,
+        ! settings->value (m_columns_shown_keys.at (i),false).toBool ());
 
-  if (settings->value (_columns_shown_keys.at (3),false).toBool ())
-    _file_system_model->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries
+  if (settings->value (m_columns_shown_keys.at (3),false).toBool ())
+    m_file_system_model->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries
                                    | QDir::Hidden);
   else
-    _file_system_model->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries);
+    m_file_system_model->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries);
 
-  _file_tree_view->setAlternatingRowColors (
-    settings->value (_columns_shown_keys.at (4),true).toBool ());
-  _file_tree_view->setModel (_file_system_model);
+  m_file_tree_view->setAlternatingRowColors (
+    settings->value (m_columns_shown_keys.at (4),true).toBool ());
+  m_file_tree_view->setModel (m_file_system_model);
 
   // enable the buttons to sync octave/browser dir
   // only if this is not done by default
-  _sync_octave_dir
+  m_sync_octave_dir
     = settings->value ("filesdockwidget/sync_octave_directory",false).toBool ();
-  _sync_octave_directory_action->setEnabled (! _sync_octave_dir);
-  _sync_browser_directory_action->setEnabled (! _sync_octave_dir);
+  m_sync_octave_directory_action->setEnabled (! m_sync_octave_dir);
+  m_sync_browser_directory_action->setEnabled (! m_sync_octave_dir);
 
-  if (_sync_octave_dir)
-    display_directory (_octave_dir);  // sync browser to octave dir
+  if (m_sync_octave_dir)
+    display_directory (m_octave_dir);  // sync browser to octave dir
 
 }
 
 void
 files_dock_widget::popdownmenu_home (bool)
 {
   QString dir
     = QString::fromStdString (octave::sys::env::get_home_directory ());
@@ -853,120 +855,120 @@ files_dock_widget::popdownmenu_home (boo
   set_current_directory (dir);
 }
 
 void
 files_dock_widget::popdownmenu_search_dir (bool)
 {
   QString dir = QFileDialog::getExistingDirectory
                   (this, tr ("Set directory of file browser"),
-                   _file_system_model->rootPath (),
+                   m_file_system_model->rootPath (),
                    QFileDialog::ShowDirsOnly
                    | QFileDialog::DontUseNativeDialog);
   set_current_directory (dir);
 }
 
 void
 files_dock_widget::popdownmenu_findfiles (bool)
 {
-  process_find_files (_file_system_model->rootPath ());
+  process_find_files (m_file_system_model->rootPath ());
 }
 
 void
 files_dock_widget::popdownmenu_newdir (bool)
 {
-  process_new_dir (_file_system_model->rootPath ());
+  process_new_dir (m_file_system_model->rootPath ());
 }
 
 void
 files_dock_widget::popdownmenu_newfile (bool)
 {
-  process_new_file (_file_system_model->rootPath ());
+  process_new_file (m_file_system_model->rootPath ());
 }
 
 void
 files_dock_widget::process_new_file (const QString& parent_dir)
 {
   bool ok;
 
   QString name = QInputDialog::getText (this, tr ("Create File"),
        tr ("Create file in\n","String ends with \\n!") + parent_dir,
        QLineEdit::Normal, tr ("New File.txt"), &ok);
   if (ok && name.length () > 0)
     {
       name = parent_dir + '/' + name;
 
       QFile file (name);
       file.open (QIODevice::WriteOnly);
-      _file_system_model->revert ();
+      m_file_system_model->revert ();
     }
 }
 
 void
 files_dock_widget::process_new_dir (const QString& parent_dir)
 {
   bool ok;
 
   QString name = QInputDialog::getText (this, tr ("Create Directory"),
                 tr ("Create folder in\n","String ends with \\n!") + parent_dir,
                 QLineEdit::Normal, tr ("New Directory"), &ok);
   if (ok && name.length () > 0)
     {
       QDir dir (parent_dir);
       dir.mkdir (name);
-      _file_system_model->revert ();
+      m_file_system_model->revert ();
     }
 }
 
 void files_dock_widget::process_set_current_dir (const QString & dir)
 {
   emit displayed_directory_changed (dir);
 }
 
 void files_dock_widget::process_find_files (const QString & dir)
 {
   emit find_files_signal (dir);
 }
 
 void
 files_dock_widget::copyClipboard ()
 {
-  if (_file_tree_view->hasFocus ())
+  if (m_file_tree_view->hasFocus ())
     contextmenu_copy_selection (true);
-  if (_current_directory->hasFocus ())
+  if (m_current_directory->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
 
-      QLineEdit *edit = _current_directory->lineEdit ();
+      QLineEdit *edit = m_current_directory->lineEdit ();
       if (edit && edit->hasSelectedText ())
         {
           clipboard->setText (edit->selectedText ());
         }
     }
 }
 
 void
 files_dock_widget::pasteClipboard ()
 {
-  if (_current_directory->hasFocus ())
+  if (m_current_directory->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
       QString str = clipboard->text ();
-      QLineEdit *edit = _current_directory->lineEdit ();
+      QLineEdit *edit = m_current_directory->lineEdit ();
       if (edit && str.length () > 0)
         edit->insert (str);
     }
 }
 
 void
 files_dock_widget::selectAll ()
 {
-  if (_file_tree_view->hasFocus ())
-    _file_tree_view->selectAll ();
-  if (_current_directory->hasFocus ())
+  if (m_file_tree_view->hasFocus ())
+    m_file_tree_view->selectAll ();
+  if (m_current_directory->hasFocus ())
     {
-      QLineEdit *edit = _current_directory->lineEdit ();
+      QLineEdit *edit = m_current_directory->lineEdit ();
       if (edit)
         {
           edit->selectAll ();
         }
     }
 }
diff --git a/libgui/src/files-dock-widget.h b/libgui/src/files-dock-widget.h
--- a/libgui/src/files-dock-widget.h
+++ b/libgui/src/files-dock-widget.h
@@ -55,29 +55,29 @@ public:
   ~files_dock_widget (void) = default;
 
 public slots:
 
   /** Slot for handling a change in directory via double click. */
   void item_double_clicked (const QModelIndex & index);
 
   /** Slot for handling the up-directory button in the toolbar. */
-  void change_directory_up ();
+  void change_directory_up (void);
 
   /** Slot for handling the sync octave directory button in the toolbar. */
-  void do_sync_octave_directory ();
+  void do_sync_octave_directory (void);
 
   /** Slot for handling the sync browser directory button in the toolbar. */
-  void do_sync_browser_directory ();
+  void do_sync_browser_directory (void);
 
   /** Sets the current directory being displayed. */
   void set_current_directory (const QString& dir);
 
   /** Accepts user input a the line edit for the current directory. */
-  void accept_directory_line_edit ();
+  void accept_directory_line_edit (void);
 
   /** set the internal variable that holds the actual octave variable **/
   void update_octave_directory (const QString& dir);
 
   /** Tells the widget to react on changed settings. */
   void notice_settings (const QSettings *settings);
 
   void save_settings (void);
@@ -145,31 +145,35 @@ private:
   void process_find_files (const QString& dir_name);
 
   /** set a new directory or open a file **/
   void display_directory (const QString& dir, bool set_octave_dir = true);
 
   void open_item_in_app (const QModelIndex& index);
 
   /** Variables for the actions **/
-  QToolBar *        _navigation_tool_bar;
-  QAction *         _sync_octave_directory_action;
-  QAction *         _sync_browser_directory_action;
+  QToolBar *m_navigation_tool_bar;
+  QAction *m_sync_octave_directory_action;
+  QAction *m_sync_browser_directory_action;
 
   /** The file system model. */
-  QFileSystemModel *_file_system_model;
+  QFileSystemModel *m_file_system_model;
 
   /** The file system view. */
-  QTreeView *       _file_tree_view;
-  QComboBox *       _current_directory;
+  QTreeView *m_file_tree_view;
+  QComboBox *m_current_directory;
 
   /** Internal variables **/
-  bool              _sync_octave_dir;    // flag if syncing with octave
-  QString           _octave_dir;         // the actual octave dir
+
+  // flag if syncing with octave
+  bool m_sync_octave_dir;
+
+  // the actual octave dir
+  QString m_octave_dir;
 
   enum { MaxMRUDirs = 10 };
 
-  QStringList _columns_shown;
-  QStringList _columns_shown_keys;
-  QSignalMapper *_sig_mapper;
+  QStringList m_columns_shown;
+  QStringList m_columns_shown_keys;
+  QSignalMapper *m_sig_mapper;
 };
 
 #endif
diff --git a/libgui/src/octave-cmd.cc b/libgui/src/octave-cmd.cc
--- a/libgui/src/octave-cmd.cc
+++ b/libgui/src/octave-cmd.cc
@@ -33,42 +33,42 @@ along with Octave; see the file COPYING.
 #include "builtin-defun-decls.h"
 #include "utils.h"
 
 
 // ---------------------------------------------------------------------
 //  class octave_cmd_exec: executing a command
 
 void
-octave_cmd_exec::execute ()
+octave_cmd_exec::execute (void)
 {
   std::string pending_input = octave::command_editor::get_current_line ();
 
   octave::command_editor::set_initial_input (pending_input);
-  octave::command_editor::replace_line (_cmd.toStdString ());
+  octave::command_editor::replace_line (m_cmd.toStdString ());
   octave::command_editor::redisplay ();
   octave::command_editor::accept_line ();
 }
 
 // ---------------------------------------------------------------------
 //  class octave_cmd_eval: running a file
 
 void
-octave_cmd_eval::execute ()
+octave_cmd_eval::execute (void)
 {
-  QString function_name = _info.fileName ();
-  function_name.chop (_info.suffix ().length () + 1);
-  std::string file_path = _info.absoluteFilePath ().toStdString ();
+  QString function_name = m_info.fileName ();
+  function_name.chop (m_info.suffix ().length () + 1);
+  std::string file_path = m_info.absoluteFilePath ().toStdString ();
 
   std::string pending_input = octave::command_editor::get_current_line ();
 
   if (valid_identifier (function_name.toStdString ()))
     {
       // valid identifier: call as function with possibility to debug
-      std::string path = _info.absolutePath ().toStdString ();
+      std::string path = m_info.absolutePath ().toStdString ();
       if (octave_qt_link::file_in_path (file_path, path))
         octave::command_editor::replace_line (function_name.toStdString ());
     }
   else
     {
       // no valid identifier: use Fsource (), no debug possible
       Fsource (ovl (file_path));
       octave::command_editor::replace_line ("");
@@ -79,75 +79,72 @@ octave_cmd_eval::execute ()
 
   octave::command_editor::accept_line ();
 }
 
 // ---------------------------------------------------------------------
 //  class octave_cmd_debug: executing a debugger command
 
 void
-octave_cmd_debug::execute ()
+octave_cmd_debug::execute (void)
 {
-  if (_cmd == "step")
+  if (m_cmd == "step")
     {
-      F__db_next_breakpoint_quiet__ (ovl (_suppress_dbg_location));
+      F__db_next_breakpoint_quiet__ (ovl (m_suppress_dbg_location));
       Fdbstep ();
     }
-  else if (_cmd == "cont")
+  else if (m_cmd == "cont")
     {
-      F__db_next_breakpoint_quiet__ (ovl (_suppress_dbg_location));
+      F__db_next_breakpoint_quiet__ (ovl (m_suppress_dbg_location));
       Fdbcont ();
     }
-  else if (_cmd == "quit")
+  else if (m_cmd == "quit")
     Fdbquit ();
   else
     {
-      F__db_next_breakpoint_quiet__ (ovl (_suppress_dbg_location));
-      Fdbstep (ovl (_cmd.toStdString ()));
+      F__db_next_breakpoint_quiet__ (ovl (m_suppress_dbg_location));
+      Fdbstep (ovl (m_cmd.toStdString ()));
     }
 
   octave::command_editor::interrupt (true);
 }
 
 // ---------------------------------------------------------------------
 //  class octave_command_queue: queue of octave commands
 
 // add_cmd: add a command to the queue
 void
 octave_command_queue::add_cmd (octave_cmd *cmd)
 {
-  _queue_mutex.lock ();
-  _queue.append (cmd);
-  _queue_mutex.unlock ();
+  m_queue_mutex.lock ();
+  m_queue.append (cmd);
+  m_queue_mutex.unlock ();
 
-  if (_processing.tryAcquire ())  // if callback not processing, post event
-    octave_link::post_event (this,
-                             &octave_command_queue::execute_command_callback);
+  if (m_processing.tryAcquire ())  // if callback not processing, post event
+    octave_link::post_event (this, &octave_command_queue::execute_command_callback);
 }
 
 // callback for executing the command by the worker thread
 void
-octave_command_queue::execute_command_callback ()
+octave_command_queue::execute_command_callback (void)
 {
   bool repost = false;          // flag for reposting event for this callback
 
-  if (! _queue.isEmpty ())  // list can not be empty here, just to make sure
+  if (! m_queue.isEmpty ())  // list can not be empty here, just to make sure
     {
-      _queue_mutex.lock ();     // critical path
+      m_queue_mutex.lock ();     // critical path
 
-      octave_cmd *cmd = _queue.takeFirst ();
+      octave_cmd *cmd = m_queue.takeFirst ();
 
-      if (_queue.isEmpty ())
-        _processing.release (); // cmd queue empty, processing will stop
+      if (m_queue.isEmpty ())
+        m_processing.release (); // cmd queue empty, processing will stop
       else
         repost = true;          // not empty, repost at end
-      _queue_mutex.unlock ();
+      m_queue_mutex.unlock ();
 
       cmd->execute ();
 
       delete cmd;
     }
 
   if (repost)  // queue not empty, so repost event for further processing
-    octave_link::post_event (this,
-                             &octave_command_queue::execute_command_callback);
-
+    octave_link::post_event (this, &octave_command_queue::execute_command_callback);
 }
diff --git a/libgui/src/octave-cmd.h b/libgui/src/octave-cmd.h
--- a/libgui/src/octave-cmd.h
+++ b/libgui/src/octave-cmd.h
@@ -31,102 +31,104 @@ along with Octave; see the file COPYING.
 #include <QFileInfo>
 
 #include "octave-qt-link.h"
 
 class octave_cmd
 {
 public:
 
-  octave_cmd () { };
-  virtual ~octave_cmd () { };
+  octave_cmd (void) = default;
 
-  virtual void execute () { };
+  virtual ~octave_cmd (void) = default;
+
+  virtual void execute (void) { }
 };
 
 // ---------------------------------------------------------------------
 //  class octave_cmd_exec
 
 class octave_cmd_exec : public octave_cmd
 {
 public:
 
-  octave_cmd_exec (const QString& cmd) : octave_cmd () { _cmd = cmd; };
-  void execute ();
+  octave_cmd_exec (const QString& cmd) : octave_cmd () { m_cmd = cmd; }
+
+  void execute (void);
 
 protected:
 
-  QString _cmd;
+  QString m_cmd;
 };
 
 // ---------------------------------------------------------------------
 //  class octave_cmd_eval
 
 class octave_cmd_eval : public octave_cmd
 {
 public:
 
-  octave_cmd_eval (const QFileInfo& info) : octave_cmd () { _info = info; };
-  void execute ();
+  octave_cmd_eval (const QFileInfo& info) : octave_cmd () { m_info = info; }
+
+  void execute (void);
 
 protected:
 
-  QFileInfo _info;
+  QFileInfo m_info;
 };
 
 // ---------------------------------------------------------------------
 //  class octave_cmd_debug
 
 class octave_cmd_debug : public octave_cmd_exec
 {
 public:
 
   octave_cmd_debug (const QString& cmd, bool suppress_location)
-    : octave_cmd_exec (cmd)
-  {
-    _suppress_dbg_location = suppress_location;
-  };
+    : octave_cmd_exec (cmd), m_suppress_dbg_location (suppress_location) { }
 
-  void execute ();
+  void execute (void);
 
 protected:
 
-  bool _suppress_dbg_location;
+  bool m_suppress_dbg_location;
 };
 
 /**
  * @class octave_command_queue
  *
  * Queuing commands from the GUI for the worker thread
  */
 // ---------------------------------------------------------------------
 //  class octave_command_queue: queue of octave commands
 
 class octave_command_queue : QObject
 {
   Q_OBJECT;
 
 public:
 
-  octave_command_queue (void) : QObject (),
-      _queue (QList<octave_cmd *> ()),
-      _processing (1),
-      _queue_mutex () { };
-  ~octave_command_queue (void) = default;;
+  octave_command_queue (void)
+    : QObject (), m_queue (QList<octave_cmd *> ()), m_processing (1),
+      m_queue_mutex ()
+  { }
+
+  ~octave_command_queue (void) = default;
 
   /**
    * Adds a new octave command to the command queue.
    * @param cmd The octave command to be queued
    */
   void add_cmd (octave_cmd *cmd);
+
   /**
    * Callback routine for executing the command by the worker thread
    */
   void execute_command_callback (void);
 
 private:
 
-  QList<octave_cmd *>  _queue;
-  QSemaphore   _processing;
-  QMutex       _queue_mutex;
+  QList<octave_cmd *> m_queue;
+  QSemaphore m_processing;
+  QMutex m_queue_mutex;
 };
 
 #endif
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -35,73 +35,73 @@ along with Octave; see the file COPYING.
 
 #include "resource-manager.h"
 #include "octave-dock-widget.h"
 
 
 octave_dock_widget::octave_dock_widget (QWidget *p)
   : QDockWidget (p)
 {
-  _parent = static_cast<QMainWindow *> (p);     // store main window
-  _floating = false;
-  _predecessor_widget = nullptr;
+  m_parent = static_cast<QMainWindow *> (p);     // store main window
+  m_floating = false;
+  m_predecessor_widget = nullptr;
 
   connect (this, SIGNAL (visibilityChanged (bool)),
            this, SLOT (handle_visibility_changed (bool)));
 
   connect (p, SIGNAL (settings_changed (const QSettings*)),
            this, SLOT (handle_settings (const QSettings*)));
 
   connect (p, SIGNAL (active_dock_changed (octave_dock_widget*,
                                            octave_dock_widget*)),
            this, SLOT (handle_active_dock_changed (octave_dock_widget*,
                                                    octave_dock_widget*)));
 
   QStyle *st = style ();
-  _icon_size = 0.75*st->pixelMetric (QStyle::PM_SmallIconSize);
+  m_icon_size = 0.75*st->pixelMetric (QStyle::PM_SmallIconSize);
 
 #if defined (Q_OS_WIN32)
   // windows: add an extra title bar that persists when floating
 
   setFeatures (QDockWidget::DockWidgetMovable); // not floatable or closeable
 
   // the custom (extra) title bar of the widget
-  _dock_action = new QAction
+  m_dock_action = new QAction
                    (QIcon (":/actions/icons/widget-undock.png"), "", this);
-  _dock_action-> setToolTip (tr ("Undock widget"));
-  connect (_dock_action, SIGNAL (triggered (bool)),
+  m_dock_action-> setToolTip (tr ("Undock widget"));
+  connect (m_dock_action, SIGNAL (triggered (bool)),
            this, SLOT (change_floating (bool)));
-  _dock_button = new QToolButton (this);
-  _dock_button->setDefaultAction (_dock_action);
-  _dock_button->setFocusPolicy (Qt::NoFocus);
-  _dock_button->setIconSize (QSize (_icon_size,_icon_size));
+  m_dock_button = new QToolButton (this);
+  m_dock_button->setDefaultAction (m_dock_action);
+  m_dock_button->setFocusPolicy (Qt::NoFocus);
+  m_dock_button->setIconSize (QSize (m_icon_size,m_icon_size));
 
-  _close_action = new QAction
+  m_close_action = new QAction
                    (QIcon (":/actions/icons/widget-close.png"), "", this);
-  _close_action-> setToolTip (tr ("Hide widget"));
-  connect (_close_action, SIGNAL (triggered (bool)),
+  m_close_action-> setToolTip (tr ("Hide widget"));
+  connect (m_close_action, SIGNAL (triggered (bool)),
            this, SLOT (change_visibility (bool)));
-  _close_button = new QToolButton (this);
-  _close_button->setDefaultAction (_close_action);
-  _close_button->setFocusPolicy (Qt::NoFocus);
-  _close_button->setIconSize (QSize (_icon_size,_icon_size));
+  m_close_button = new QToolButton (this);
+  m_close_button->setDefaultAction (m_close_action);
+  m_close_button->setFocusPolicy (Qt::NoFocus);
+  m_close_button->setIconSize (QSize (m_icon_size,m_icon_size));
 
-  _icon_color = "";
-  _title_3d = 50;
+  m_icon_color = "";
+  m_title_3d = 50;
 
   QHBoxLayout *h_layout = new QHBoxLayout ();
   h_layout->addStretch (100);
-  h_layout->addWidget (_dock_button);
-  h_layout->addWidget (_close_button);
+  h_layout->addWidget (m_dock_button);
+  h_layout->addWidget (m_close_button);
   h_layout->setSpacing (0);
   h_layout->setContentsMargins (5,2,2,2);
 
-  _title_widget = new QWidget ();
-  _title_widget->setLayout (h_layout);
-  setTitleBarWidget (_title_widget);
+  m_title_widget = new QWidget ();
+  m_title_widget->setLayout (h_layout);
+  setTitleBarWidget (m_title_widget);
 
 #else
 
   // non windows: qt takes control of floating widgets
   setFeatures (QDockWidget::DockWidgetMovable |
                QDockWidget::DockWidgetClosable |
                QDockWidget::DockWidgetFloatable); // floatable and closeable
 
@@ -120,105 +120,47 @@ octave_dock_widget::octave_dock_widget (
   // undo handling
   connect (p, SIGNAL (undo_signal ()), this, SLOT (do_undo ()));
 
   installEventFilter (this);
 
   setFocusPolicy (Qt::StrongFocus);
 }
 
-void
-octave_dock_widget::save_settings (void)
-{
-  // save state of this dock-widget
-  QString name = objectName ();
-  QSettings *settings = resource_manager::get_settings ();
-
-  if (! settings)
-    return;
-
-  settings->beginGroup ("DockWidgets");
-
-#if defined (Q_OS_WIN32)
-  if (_floating) // widget is floating (windows), save actual floating geometry
-    settings->setValue (name+"_floating_geometry", geometry ());
-  else           // not floating save docked (normal) geometry
-#endif
-    settings->setValue (name, saveGeometry ());
-
-  settings->setValue (name+"Visible", isVisible ()); // store visibility
-  settings->setValue (name+"Floating", _floating);    // store visibility
-  settings->setValue (name+"_minimized", isMinimized ()); // store minimized
-
-  settings->endGroup ();
-  settings->sync ();
-}
-
 // connect signal visibility changed to related slot (called from main-window)
 void
 octave_dock_widget::connect_visibility_changed (void)
 {
   connect (this, SIGNAL (visibilityChanged (bool)),
            this, SLOT (handle_visibility (bool)));
   emit active_changed (isVisible ());  // emit once for init of window menu
 }
 
-// set the widget which previously had focus when tabified
-void
-octave_dock_widget::set_predecessor_widget (octave_dock_widget *prev_widget)
-{
-  _predecessor_widget = prev_widget;
-}
-
-// set the title in the dockwidgets title bar
-void
-octave_dock_widget::set_title (const QString& title)
-{
-#if defined (Q_OS_WIN32)
-  QHBoxLayout *h_layout
-    = static_cast<QHBoxLayout *> (titleBarWidget ()->layout ());
-  QLabel *label = new QLabel (title);
-  label->setStyleSheet ("background: transparent;");
-  h_layout->insertWidget (0,label);
-#endif
-  setWindowTitle (title);
-}
-
-// set focus to previously active widget in tabbed widget stack
-void
-octave_dock_widget::set_focus_predecessor ()
-{
-  if (_predecessor_widget)    // only != 0 if widget was tabbed
-    _predecessor_widget->focus ();
-
-  _predecessor_widget = nullptr;
-}
-
 // make the widget floating
 void
-octave_dock_widget::make_window ()
+octave_dock_widget::make_window (void)
 {
 #if defined (Q_OS_WIN32)
 
   // windows: the widget has to be reparented (parent = 0)
 
   QSettings *settings = resource_manager::get_settings ();
 
   // save the docking area and geometry for later redocking
   // FIXME: dockWidgetArea always returns 2
   settings->setValue ("DockWidgets/" + objectName () + "_dock_area",
-                      _parent->dockWidgetArea (this));
+                      m_parent->dockWidgetArea (this));
   settings->setValue ("DockWidgets/" + objectName (), saveGeometry ());
   settings->sync ();
 
   // remove parent and adjust the (un)dock icon
   setParent (0, Qt::Window);
-  _dock_action->setIcon (QIcon (":/actions/icons/widget-dock"
-                                + _icon_color + ".png"));
-  _dock_action->setToolTip (tr ("Dock widget"));
+  m_dock_action->setIcon (QIcon (":/actions/icons/widget-dock"
+                                + m_icon_color + ".png"));
+  m_dock_action->setToolTip (tr ("Dock widget"));
 
   // restore the last geometry when floating
   setGeometry (settings->value ("DockWidgets/" + objectName ()
                                 + "_floating_geometry",
                                 QRect (50,100,480,480)).toRect ());
 
 #else
 
@@ -226,152 +168,278 @@ octave_dock_widget::make_window ()
   setWindowFlags (Qt::Window);
 
   QString css = styleSheet ();
   css.replace ("widget-undock", "widget-dock");
   setStyleSheet (css);
 
 #endif
 
-  _floating = true;
+  m_floating = true;
 
   set_focus_predecessor ();  // set focus previously active widget if tabbed
 }
 
 // dock the widget
 void
 octave_dock_widget::make_widget (bool dock)
 {
 #if defined (Q_OS_WIN32)
 
   // windows: Since floating widget has no parent, we have to read it
 
   QSettings *settings = resource_manager::get_settings ();
 
   // save last floating geometry if widget really was floating
-  if (_floating)
+  if (m_floating)
     settings->setValue ("DockWidgets/" + objectName () + "_floating_geometry",
                         geometry ());
   settings->sync ();
 
   if (dock)
     {
       // add widget to last saved docking area (dock=true is default)
       int area
         = settings->value ("DockWidgets/" + objectName () + "_dock_area",
                            Qt::TopDockWidgetArea).toInt ();
-      _parent->addDockWidget (static_cast<Qt::DockWidgetArea> (area), this);
+      m_parent->addDockWidget (static_cast<Qt::DockWidgetArea> (area), this);
 
       // FIXME: restoreGeometry is ignored for docked widgets
       //        and its child widget
       restoreGeometry (settings->value
              ("DockWidgets/" + objectName ()).toByteArray ());
     }
   else  // only reparent, no docking
-    setParent (_parent);
+    setParent (m_parent);
 
   // adjust the (un)dock icon
-  _dock_action->setIcon (QIcon (":/actions/icons/widget-undock"
-                                + _icon_color + ".png"));
-  _dock_action->setToolTip (tr ("Undock widget"));
+  m_dock_action->setIcon (QIcon (":/actions/icons/widget-undock"
+                                + m_icon_color + ".png"));
+  m_dock_action->setToolTip (tr ("Undock widget"));
 
 #else
 
   // non windows: just say we are a docked widget again
 
   Q_UNUSED (dock);
 
   setWindowFlags (Qt::Widget);
 
   QString css = styleSheet ();
   css.replace ("widget-dock", "widget-undock");
   setStyleSheet (css);
 
 #endif
 
-  _floating = false;
+  m_floating = false;
+}
+
+// set the title in the dockwidgets title bar
+void
+octave_dock_widget::set_title (const QString& title)
+{
+#if defined (Q_OS_WIN32)
+  QHBoxLayout *h_layout
+    = static_cast<QHBoxLayout *> (titleBarWidget ()->layout ());
+  QLabel *label = new QLabel (title);
+  label->setStyleSheet ("background: transparent;");
+  h_layout->insertWidget (0,label);
+#endif
+  setWindowTitle (title);
+}
+
+// set the widget which previously had focus when tabified
+void
+octave_dock_widget::set_predecessor_widget (octave_dock_widget *prev_widget)
+{
+  m_predecessor_widget = prev_widget;
+}
+
+// close event
+void
+octave_dock_widget::closeEvent (QCloseEvent *e)
+{
+  emit active_changed (false);
+  set_focus_predecessor ();
+  QDockWidget::closeEvent (e);
+}
+
+// get focus widget
+QWidget *
+octave_dock_widget::focusWidget (void)
+{
+  QWidget *w = QApplication::focusWidget ();
+  if (w && w->focusProxy ()) w = w->focusProxy ();
+  return w;
+}
+
+void
+octave_dock_widget::handle_settings (const QSettings *settings)
+{
+  m_custom_style
+    = settings->value ("DockWidgets/widget_title_custom_style",false).toBool ();
+
+  m_title_3d
+    = settings->value ("DockWidgets/widget_title_3d",50).toInt ();
+
+  QColor default_var = QColor (0,0,0);
+  m_fg_color = settings->value ("Dockwidgets/title_fg_color",
+                               default_var).value<QColor> ();
+  default_var = QColor (0,0,0);
+  m_fg_color_active = settings->value ("Dockwidgets/title_fg_color_active",
+                                      default_var).value<QColor> ();
+
+  default_var = QColor (255,255,255);
+  m_bg_color = settings->value ("Dockwidgets/title_bg_color",
+                               default_var).value<QColor> ();
+  default_var = QColor (192,192,192);
+  m_bg_color_active = settings->value ("Dockwidgets/title_bg_color_active",
+                                      default_var).value<QColor> ();
+
+  int r, g, b;
+  m_bg_color.getRgb (&r, &g, &b);
+  if (r+g+b < 400)
+    m_icon_color = "-light";
+  else
+    m_icon_color = "";
+
+  m_bg_color_active.getRgb (&r, &g, &b);
+  if (r+g+b < 400)
+    m_icon_color_active = "-light";
+  else
+    m_icon_color_active = "";
+
+  notice_settings (settings);  // call individual handler
+
+  set_style (false);
+}
+
+void
+octave_dock_widget::handle_active_dock_changed (octave_dock_widget *w_old,
+                                                octave_dock_widget *w_new)
+{
+  if (m_custom_style && this == w_old)
+    {
+      set_style (false);
+      update ();
+    }
+
+  if (m_custom_style && this == w_new)
+    {
+      set_style (true);
+      update ();
+    }
+}
+
+void
+octave_dock_widget::save_settings (void)
+{
+  // save state of this dock-widget
+  QString name = objectName ();
+  QSettings *settings = resource_manager::get_settings ();
+
+  if (! settings)
+    return;
+
+  settings->beginGroup ("DockWidgets");
+
+#if defined (Q_OS_WIN32)
+  if (m_floating) // widget is floating (windows), save actual floating geometry
+    settings->setValue (name+"_floating_geometry", geometry ());
+  else           // not floating save docked (normal) geometry
+#endif
+    settings->setValue (name, saveGeometry ());
+
+  settings->setValue (name+"Visible", isVisible ()); // store visibility
+  settings->setValue (name+"Floating", m_floating);    // store visibility
+  settings->setValue (name+"_minimized", isMinimized ()); // store minimized
+
+  settings->endGroup ();
+  settings->sync ();
+}
+
+bool octave_dock_widget::eventFilter (QObject *obj, QEvent *e)
+{
+  if (e->type () == QEvent::NonClientAreaMouseButtonDblClick)
+    {
+      e->ignore (); // ignore double clicks into window decoration elements
+      return true;
+    }
+
+  return QDockWidget::eventFilter (obj,e);
 }
 
 // slot for (un)dock action
 void
 octave_dock_widget::change_floating (bool)
 {
-  if (_floating)
+  if (m_floating)
     make_widget ();
   else
     {
       make_window ();
       focus ();
     }
 }
 
 // slot for hiding the widget
 void
 octave_dock_widget::change_visibility (bool)
 {
   setVisible (false);
   emit active_changed (false);
 }
 
-// get focus widget
-QWidget *
-octave_dock_widget::focusWidget ()
-{
-  QWidget *w = QApplication::focusWidget ();
-  if (w && w->focusProxy ()) w = w->focusProxy ();
-  return w;
-}
-
 void
 octave_dock_widget::set_style (bool active)
 {
   QString css;
   QString css_button;
   QString dock_icon;
 
-  QString icon_col = _icon_color;
+  QString icon_col = m_icon_color;
 
-  if (_floating)
+  if (m_floating)
     dock_icon = "widget-dock";
   else
     dock_icon = "widget-undock";
 
 #if defined (Q_OS_MAC)
   QString alignment = "center";
 #else
   QString alignment = "center left";
 #endif
-  if (_custom_style)
+  if (m_custom_style)
     {
 
       QColor bg_col, fg_col;
 
       if (active)
         {
-          bg_col = _bg_color_active;
-          fg_col = _fg_color_active;
-          icon_col = _icon_color_active;
+          bg_col = m_bg_color_active;
+          fg_col = m_fg_color_active;
+          icon_col = m_icon_color_active;
         }
       else
         {
-          bg_col = _bg_color;
-          fg_col = _fg_color;
-          icon_col = _icon_color;
+          bg_col = m_bg_color;
+          fg_col = m_fg_color;
+          icon_col = m_icon_color;
         }
 
       QColor bg_col_top, bg_col_bottom;
-      if (_title_3d > 0)
+      if (m_title_3d > 0)
         {
-          bg_col_top = bg_col.lighter (100 + _title_3d);
-          bg_col_bottom = bg_col.darker (100 + _title_3d);
+          bg_col_top = bg_col.lighter (100 + m_title_3d);
+          bg_col_bottom = bg_col.darker (100 + m_title_3d);
         }
       else
         {
-          bg_col_top = bg_col.darker (100 - _title_3d);
-          bg_col_bottom = bg_col.lighter (100 - _title_3d);
+          bg_col_top = bg_col.darker (100 - m_title_3d);
+          bg_col_bottom = bg_col.lighter (100 - m_title_3d);
         }
 
       QString background =
         QString ("background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,"
                  "            stop: 0 %1, stop: 0.60 %2, stop: 0.95 %2 stop: 1.0 %3);").
         arg (bg_col_top.name ()).
         arg (bg_col.name ()).
         arg (bg_col_bottom.name ());
@@ -383,118 +451,50 @@ octave_dock_widget::set_style (bool acti
                      "                     text-align: " + alignment + ";"
                      "                     padding: 0px 0px 0px 4px;}\n"
                      "QDockWidget { color: %1 ; "
                      "  titlebar-close-icon: url(:/actions/icons/widget-close%2.png);"
                      "  titlebar-normal-icon: url(:/actions/icons/"+dock_icon+"%2); }"
                      "QDockWidget::close-button,"
                      "QDockWidget::float-button { border: 0px; icon-size: %3px; width: %3px}"
                      ).
-                     arg (fg_col.name ()).arg (icon_col).arg (_icon_size);
+                     arg (fg_col.name ()).arg (icon_col).arg (m_icon_size);
 #endif
     }
   else
     {
 #if defined (Q_OS_WIN32)
       css = QString ("");
 #else
       css = QString ("QDockWidget::title { text-align: " + alignment + ";"
                      "                     padding: 0px 0px 0px 4px;}"
                      "QDockWidget {"
                      "  titlebar-close-icon: url(:/actions/icons/widget-close.png);"
                      "  titlebar-normal-icon: url(:/actions/icons/"+dock_icon+"); }"
                      "QDockWidget::close-button,"
                      "QDockWidget::float-button { border: 0px; icon-size: %1px; width: %1px}"
-                    ).arg (_icon_size);
+                    ).arg (m_icon_size);
 #endif
     }
 
 #if defined (Q_OS_WIN32)
-  _title_widget->setStyleSheet (css);
+  m_title_widget->setStyleSheet (css);
   css_button = QString ("background: transparent; border: 0px;");
-  _dock_button->setStyleSheet (css_button);
-  _close_button->setStyleSheet (css_button);
-  _dock_action->setIcon (QIcon (":/actions/icons/" + dock_icon + icon_col +
+  m_dock_button->setStyleSheet (css_button);
+  m_close_button->setStyleSheet (css_button);
+  m_dock_action->setIcon (QIcon (":/actions/icons/" + dock_icon + icon_col +
                                 ".png"));
-  _close_action->setIcon (QIcon (":/actions/icons/widget-close" + icon_col +
+  m_close_action->setIcon (QIcon (":/actions/icons/widget-close" + icon_col +
                                  ".png"));
 #else
   setStyleSheet (css);
 #endif
 }
 
+// set focus to previously active widget in tabbed widget stack
 void
-octave_dock_widget::handle_settings (const QSettings *settings)
+octave_dock_widget::set_focus_predecessor (void)
 {
-  _custom_style
-    = settings->value ("DockWidgets/widget_title_custom_style",false).toBool ();
-
-  _title_3d
-    = settings->value ("DockWidgets/widget_title_3d",50).toInt ();
-
-  QColor default_var = QColor (0,0,0);
-  _fg_color = settings->value ("Dockwidgets/title_fg_color",
-                               default_var).value<QColor> ();
-  default_var = QColor (0,0,0);
-  _fg_color_active = settings->value ("Dockwidgets/title_fg_color_active",
-                                      default_var).value<QColor> ();
-
-  default_var = QColor (255,255,255);
-  _bg_color = settings->value ("Dockwidgets/title_bg_color",
-                               default_var).value<QColor> ();
-  default_var = QColor (192,192,192);
-  _bg_color_active = settings->value ("Dockwidgets/title_bg_color_active",
-                                      default_var).value<QColor> ();
-
-  int r, g, b;
-  _bg_color.getRgb (&r, &g, &b);
-  if (r+g+b < 400)
-    _icon_color = "-light";
-  else
-    _icon_color = "";
-
-  _bg_color_active.getRgb (&r, &g, &b);
-  if (r+g+b < 400)
-    _icon_color_active = "-light";
-  else
-    _icon_color_active = "";
-
-  notice_settings (settings);  // call individual handler
+  if (m_predecessor_widget)    // only != 0 if widget was tabbed
+    m_predecessor_widget->focus ();
 
-  set_style (false);
-}
-
-bool octave_dock_widget::eventFilter (QObject *obj, QEvent *e)
-{
-  if (e->type () == QEvent::NonClientAreaMouseButtonDblClick)
-    {
-      e->ignore (); // ignore double clicks into window decoration elements
-      return true;
-    }
-
-  return QDockWidget::eventFilter (obj,e);
+  m_predecessor_widget = nullptr;
 }
-
-void
-octave_dock_widget::handle_active_dock_changed (octave_dock_widget *w_old,
-                                                octave_dock_widget *w_new)
-{
-  if (_custom_style && this == w_old)
-    {
-      set_style (false);
-      update ();
-    }
-
-  if (_custom_style && this == w_new)
-    {
-      set_style (true);
-      update ();
-    }
-}
-
-// close event
-void
-octave_dock_widget::closeEvent (QCloseEvent *e)
-{
-  emit active_changed (false);
-  set_focus_predecessor ();
-  QDockWidget::closeEvent (e);
-}
diff --git a/libgui/src/octave-dock-widget.h b/libgui/src/octave-dock-widget.h
--- a/libgui/src/octave-dock-widget.h
+++ b/libgui/src/octave-dock-widget.h
@@ -32,35 +32,38 @@ along with Octave; see the file COPYING.
 
 class octave_dock_widget : public QDockWidget
 {
   Q_OBJECT
 
 public:
 
   octave_dock_widget (QWidget *p = nullptr);
+
   virtual ~octave_dock_widget (void) = default;
 
   virtual void connect_visibility_changed (void);
+
   void make_window (void);
   void make_widget (bool dock=true);
   void set_title (const QString&);
   void set_predecessor_widget (octave_dock_widget *prev_widget);
+
 signals:
 
   /** Custom signal that tells whether a user has clicked away
    *  that dock widget, i.e the active dock widget has
    *  changed. */
   void active_changed (bool active);
 
 protected:
 
   virtual void closeEvent (QCloseEvent *e);
 
-  QWidget * focusWidget ();
+  QWidget * focusWidget (void);
 
 public slots:
 
   virtual void focus (void)
   {
     if (! isVisible ())
       setVisible (true);
 
@@ -70,70 +73,70 @@ public slots:
   }
 
   virtual void handle_visibility (bool visible)
   {
     if (visible && ! isFloating ())
       focus ();
   }
 
-  virtual void notice_settings (const QSettings*)
-  { }
+  virtual void notice_settings (const QSettings*) { }
+
   void handle_settings (const QSettings*);
 
   void handle_active_dock_changed (octave_dock_widget*, octave_dock_widget*);
 
-  QMainWindow * main_win () { return _parent; }
+  QMainWindow * main_win (void) { return m_parent; }
 
   void save_settings (void);
 
 protected slots:
 
   /** Slot to steer changing visibility from outside. */
   virtual void handle_visibility_changed (bool visible)
   {
     if (visible)
       emit active_changed (true);
   }
+
   /** slots to handle copy & paste */
-  virtual void copyClipboard () {  }
-  virtual void pasteClipboard () {  }
-  virtual void selectAll () {  }
+  virtual void copyClipboard (void) {  }
+  virtual void pasteClipboard (void) {  }
+  virtual void selectAll (void) {  }
   /** slots to handle undo */
-  virtual void do_undo () {  }
+  virtual void do_undo (void) {  }
 
   // event filter for double clicks into the window decoration elements
   bool eventFilter (QObject *obj, QEvent *e);
 
 private slots:
 
   void change_floating (bool);
   void change_visibility (bool);
 
 private:
 
   void set_style (bool active);
-  void set_focus_predecessor ();
+  void set_focus_predecessor (void);
 
-  QMainWindow *_parent;  // store the parent since we are reparenting to 0
-  bool _floating;
-  bool _custom_style;
-  int _title_3d;
-  int _icon_size;
-  QColor _bg_color;
-  QColor _bg_color_active;
-  QColor _fg_color;
-  QColor _fg_color_active;
-  QString _icon_color;
-  QString _icon_color_active;
-  octave_dock_widget *_predecessor_widget;
+  QMainWindow *m_parent;  // store the parent since we are reparenting to 0
+  bool m_floating;
+  bool m_custom_style;
+  int m_title_3d;
+  int m_icon_size;
+  QColor m_bg_color;
+  QColor m_bg_color_active;
+  QColor m_fg_color;
+  QColor m_fg_color_active;
+  QString m_icon_color;
+  QString m_icon_color_active;
+  octave_dock_widget *m_predecessor_widget;
 
 #if defined (Q_OS_WIN32)
-  QWidget *_title_widget;
-  QToolButton *_dock_button;
-  QToolButton *_close_button;
-  QAction *_dock_action;
-  QAction *_close_action;
+  QWidget *m_title_widget;
+  QToolButton *m_dock_button;
+  QToolButton *m_close_button;
+  QAction *m_dock_action;
+  QAction *m_close_action;
 #endif
-
 };
 
 #endif
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -59,39 +59,39 @@ default_qt_settings_file (void)
     dsf = (octave::config::oct_etc_dir ()
            + octave::sys::file_ops::dir_sep_str ()
            + "default-qt-settings");
 
   return QString::fromStdString (dsf);
 }
 
 resource_manager::resource_manager (void)
-  : settings_directory (), settings_file (), settings (nullptr),
-    default_settings (nullptr)
+  : m_settings_directory (), m_settings_file (), m_settings (nullptr),
+    m_default_settings (nullptr)
 {
 #if defined (HAVE_QT4)
   QString home_path
     = QDesktopServices::storageLocation (QDesktopServices::HomeLocation);
 #else
   QString home_path
     = QStandardPaths::writableLocation (QStandardPaths::HomeLocation);
 #endif
 
-  settings_directory = home_path + "/.config/octave";
+  m_settings_directory = home_path + "/.config/octave";
 
-  settings_file = settings_directory + "/qt-settings";
+  m_settings_file = m_settings_directory + "/qt-settings";
 
-  default_settings = new QSettings (default_qt_settings_file (),
+  m_default_settings = new QSettings (default_qt_settings_file (),
                                     QSettings::IniFormat);
 }
 
 resource_manager::~resource_manager (void)
 {
-  delete settings;
-  delete default_settings;
+  delete m_settings;
+  delete m_default_settings;
 }
 
 QString
 resource_manager::get_gui_translation_dir (void)
 {
   // get environment variable for the locale dir (e.g. from run-octave)
   std::string dldir = octave::sys::env::getenv ("OCTAVE_LOCALE_DIR");
   if (dldir.empty ())
@@ -133,16 +133,52 @@ resource_manager::config_translators (QT
 
   if (! loaded) // try lower case
     qsci_tr->load ("qscintilla_" + language.toLower (), qt_trans_dir);
 
   // load the translator file for gui strings
   gui_tr->load (language, get_gui_translation_dir ());
 }
 
+QStringList
+resource_manager::storage_class_names (void)
+{
+  return workspace_model::storage_class_names ();
+}
+
+QList<QColor>
+resource_manager::storage_class_default_colors (void)
+{
+  return workspace_model::storage_class_default_colors ();
+}
+
+QStringList
+resource_manager::terminal_color_names (void)
+{
+  return QTerminal::color_names ();
+}
+
+QList<QColor>
+resource_manager::terminal_default_colors (void)
+{
+  return QTerminal::default_colors ();
+}
+
+QList<QColor>
+resource_manager::varedit_default_colors(void)
+{
+  return variable_editor::default_colors ();
+}
+
+QStringList
+resource_manager::varedit_color_names(void)
+{
+  return variable_editor::color_names ();
+}
+
 bool
 resource_manager::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
     instance = new resource_manager ();
 
@@ -154,43 +190,43 @@ resource_manager::instance_ok (void)
     }
 
   return retval;
 }
 
 QSettings *
 resource_manager::do_get_settings (void) const
 {
-  return settings;
+  return m_settings;
 }
 
 QSettings *
 resource_manager::do_get_default_settings (void) const
 {
-  return default_settings;
+  return m_default_settings;
 }
 
 QString
 resource_manager::do_get_settings_directory (void)
 {
-  return settings_directory;
+  return m_settings_directory;
 }
 
 QString
 resource_manager::do_get_settings_file (void)
 {
-  return settings_file;
+  return m_settings_file;
 }
 
 void
 resource_manager::do_reload_settings (void)
 {
-  if (! QFile::exists (settings_file))
+  if (! QFile::exists (m_settings_file))
     {
-      QDir ("/").mkpath (settings_directory);
+      QDir ("/").mkpath (m_settings_directory);
       QFile qt_settings (default_qt_settings_file ());
 
       if (! qt_settings.open (QFile::ReadOnly))
         return;
 
       QTextStream in (&qt_settings);
       QString settings_text = in.readAll ();
       qt_settings.close ();
@@ -215,128 +251,92 @@ resource_manager::do_reload_settings (vo
       QString custom_editor = "emacs +%l %f";
 #endif
 
       // Replace placeholders
       settings_text.replace ("__default_custom_editor__", custom_editor);
       settings_text.replace ("__default_font__", default_family);
       settings_text.replace ("__default_font_size__", "10");
 
-      QFile user_settings (settings_file);
+      QFile user_settings (m_settings_file);
 
       if (! user_settings.open (QIODevice::WriteOnly))
         return;
 
       QTextStream out (&user_settings);
 
       out << settings_text;
 
       user_settings.close ();
     }
 
-  do_set_settings (settings_file);
+  do_set_settings (m_settings_file);
 }
 
 void
 resource_manager::do_set_settings (const QString& file)
 {
-  delete settings;
-  settings = new QSettings (file, QSettings::IniFormat);
+  delete m_settings;
+  m_settings = new QSettings (file, QSettings::IniFormat);
 
-  if (! (settings
-         && QFile::exists (settings->fileName ())
-         && settings->isWritable ()
-         && settings->status () == QSettings::NoError))
+  if (! (m_settings
+         && QFile::exists (m_settings->fileName ())
+         && m_settings->isWritable ()
+         && m_settings->status () == QSettings::NoError))
     {
       QString msg = QString (QT_TR_NOOP (
         "The settings file\n%1\n"
         "does not exist and can not be created.\n"
         "Make sure you have read and write permissions to\n%2\n\n"
         "Octave GUI must be closed now."));
       QMessageBox::critical (nullptr, QString (QT_TR_NOOP ("Octave Critical Error")),
           msg.arg (do_get_settings_file ()).arg (do_get_settings_directory ()));
       exit (1);
     }
 }
 
 bool
 resource_manager::do_is_first_run (void) const
 {
-  return ! QFile::exists (settings_file);
+  return ! QFile::exists (m_settings_file);
 }
 
 void
 resource_manager::do_update_network_settings (void)
 {
-  if (settings)
+  if (m_settings)
     {
       QNetworkProxy::ProxyType proxyType = QNetworkProxy::NoProxy;
 
-      if (settings->value ("useProxyServer",false).toBool ())
+      if (m_settings->value ("useProxyServer",false).toBool ())
         {
-          QString proxyTypeString = settings->value ("proxyType").toString ();
+          QString proxyTypeString = m_settings->value ("proxyType").toString ();
 
           if (proxyTypeString == "Socks5Proxy")
             proxyType = QNetworkProxy::Socks5Proxy;
           else if (proxyTypeString == "HttpProxy")
             proxyType = QNetworkProxy::HttpProxy;
         }
 
       QNetworkProxy proxy;
 
       proxy.setType (proxyType);
-      proxy.setHostName (settings->value ("proxyHostName").toString ());
-      proxy.setPort (settings->value ("proxyPort",80).toInt ());
-      proxy.setUser (settings->value ("proxyUserName").toString ());
-      proxy.setPassword (settings->value ("proxyPassword").toString ());
+      proxy.setHostName (m_settings->value ("proxyHostName").toString ());
+      proxy.setPort (m_settings->value ("proxyPort",80).toInt ());
+      proxy.setUser (m_settings->value ("proxyUserName").toString ());
+      proxy.setPassword (m_settings->value ("proxyPassword").toString ());
 
       QNetworkProxy::setApplicationProxy (proxy);
     }
   else
     {
       // FIXME: Is this an error?  If so, what should we do?
     }
 }
 
-QStringList
-resource_manager::storage_class_names (void)
-{
-  return workspace_model::storage_class_names ();
-}
-
-QList<QColor>
-resource_manager::storage_class_default_colors (void)
-{
-  return workspace_model::storage_class_default_colors ();
-}
-
-QStringList
-resource_manager::terminal_color_names (void)
-{
-  return QTerminal::color_names ();
-}
-
-QList<QColor>
-resource_manager::terminal_default_colors (void)
-{
-  return QTerminal::default_colors ();
-}
-
-QList<QColor>
-resource_manager::varedit_default_colors(void)
-{
-  return variable_editor::default_colors ();
-}
-
-QStringList
-resource_manager::varedit_color_names(void)
-{
-  return variable_editor::color_names ();
-}
-
 QIcon
 resource_manager::do_icon (const QString& icon_name, bool fallback)
 {
   if (fallback)
     return QIcon::fromTheme (icon_name,
                              QIcon (":/actions/icons/" + icon_name + ".png"));
   else
     return QIcon::fromTheme (icon_name);
@@ -363,17 +363,17 @@ resource_manager::do_combo_encoding (QCo
 #else
   QString def_enc = "UTF-8";
 #endif
 
   // get the value from the settings file if no current encoding is given
   QString enc = current;
   if (enc.isEmpty ())
     {
-      enc = settings->value ("editor/default_encoding",def_enc).toString ();
+      enc = m_settings->value ("editor/default_encoding",def_enc).toString ();
       if (enc.isEmpty ())  // still empty?
         enc = def_enc;     // take default
     }
 
   // fill the combo box
   foreach (QString c, all_codecs)
     combo->addItem (c);
 
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -121,38 +121,38 @@ public slots:
   static QString varedit_color_chars (void) {return "fbsha"; }
   static QStringList varedit_color_names (void);
   static QList<QColor> varedit_default_colors (void);
 
 private:
 
   static bool instance_ok (void);
 
-  QString settings_directory;
-
-  QString settings_file;
-
-  QSettings *settings;
-
-  QSettings *default_settings;
-
   QSettings * do_get_settings (void) const;
 
   QSettings * do_get_default_settings (void) const;
 
-  QString do_get_settings_file (void);
+  QString do_get_settings_directory (void);
 
-  QString do_get_settings_directory (void);
+  QString do_get_settings_file (void);
 
   void do_reload_settings (void);
 
   void do_set_settings (const QString& file);
 
-  void do_update_network_settings (void);
+  bool do_is_first_run (void) const;
 
-  bool do_is_first_run (void) const;
+  void do_update_network_settings (void);
 
   QIcon do_icon (const QString& icon, bool fallback);
 
   void do_combo_encoding (QComboBox *combo, QString current);
+
+  QString m_settings_directory;
+
+  QString m_settings_file;
+
+  QSettings *m_settings;
+
+  QSettings *m_default_settings;
 };
 
 #endif
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -37,32 +37,141 @@ along with Octave; see the file COPYING.
 #include <QHeaderView>
 #include <QAction>
 #include <QFileDialog>
 
 #include "error.h"
 #include "resource-manager.h"
 #include "shortcut-manager.h"
 
+// enter_shortcut:
+// class derived from QLineEdit for directly entering key sequences which
+
+enter_shortcut::enter_shortcut (QWidget *p) : QLineEdit (p)
+{
+  m_direct_shortcut = true;      // the shortcut is directly entered
+}
+
+// new keyPressEvent
+void
+enter_shortcut::keyPressEvent (QKeyEvent *e)
+{
+  if (! m_direct_shortcut)
+    {
+      QLineEdit::keyPressEvent (e);
+      return;
+    }
+
+  if (e->type () == QEvent::KeyPress)
+    {
+      int key = e->key ();
+
+      if (key == Qt::Key_unknown || key == 0)
+        return;
+
+      Qt::KeyboardModifiers modifiers = e->modifiers ();
+
+      if (modifiers & Qt::ShiftModifier)
+        key += Qt::SHIFT;
+      if (modifiers & Qt::ControlModifier)
+        key += Qt::CTRL;
+      if (modifiers & Qt::AltModifier)
+        key += Qt::ALT;
+      if (modifiers & Qt::MetaModifier)
+        key += Qt::META;
+
+      setText (QKeySequence (key).toString ());
+    }
+}
+
+// slot for checkbox whether the shortcut is directly entered or not
+void
+enter_shortcut::handle_direct_shortcut (int state)
+{
+  if (state)
+    m_direct_shortcut = true;  // the shortcut is directly entered
+  else
+    m_direct_shortcut = false; // the shortcut has to be written as text
+}
+
 shortcut_manager *shortcut_manager::instance = nullptr;
 
-shortcut_manager::shortcut_manager ()
+shortcut_manager::shortcut_manager (void)
 {
   setObjectName ("Shortcut_Manager");
 
   // Mac: don't let Qt interpret CMD key ("Meta" in Qt terminology) as Ctrl
 #if defined (Q_OS_MAC)
   QCoreApplication::setAttribute (Qt::AA_MacDontSwapCtrlAndMeta, true);
 #endif
 
-  _settings = resource_manager::get_settings ();
+  m_settings = resource_manager::get_settings ();
+}
+
+void
+shortcut_manager::handle_double_clicked (QTreeWidgetItem *item, int col)
+{
+  if (col != 2)
+    return;
+
+  int i = m_item_index_hash[item];
+  if (i == 0)
+    return;  // top-level-item clicked
+
+  shortcut_dialog (i-1); // correct to index starting at 0
 }
 
-shortcut_manager::~shortcut_manager ()
-{ }
+void
+shortcut_manager::shortcut_dialog_finished (int result)
+{
+  if (result == QDialog::Rejected)
+    return;
+
+  // check for duplicate
+  int double_index = m_shortcut_hash[m_edit_actual->text ()] - 1;
+
+  if (double_index >= 0 && double_index != m_handled_index)
+    {
+      int ret = QMessageBox::warning (this, tr ("Double Shortcut"),
+                  tr ("The chosen shortcut\n  \"%1\"\n"
+                      "is already used for the action\n  \"%2\".\n"
+                      "Do you want to use the shortcut anyhow removing it "
+                      "from the previous action?")
+                     .arg (m_edit_actual->text ())
+                     .arg (m_sc.at (double_index).m_description),
+                  QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
+
+      if (ret == QMessageBox::Yes)
+        {
+          shortcut_t double_shortcut = m_sc.at (double_index);
+          double_shortcut.m_actual_sc = QKeySequence ();
+          m_sc.replace (double_index, double_shortcut);
+          m_index_item_hash[double_index]->setText (2, QString ());
+        }
+      else
+        return;
+    }
+
+  shortcut_t shortcut = m_sc.at (m_handled_index);
+  if (! shortcut.m_actual_sc.isEmpty ())
+    m_shortcut_hash.remove (shortcut.m_actual_sc.toString ());
+  shortcut.m_actual_sc = m_edit_actual->text ();
+  m_sc.replace (m_handled_index, shortcut);
+
+  m_index_item_hash[m_handled_index]->setText (2, shortcut.m_actual_sc.toString ());
+
+  if (! shortcut.m_actual_sc.isEmpty ())
+    m_shortcut_hash[shortcut.m_actual_sc.toString ()] = m_handled_index + 1;
+}
+
+void
+shortcut_manager::shortcut_dialog_set_default (void)
+{
+  m_edit_actual->setText (m_label_default->text ());
+}
 
 bool
 shortcut_manager::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
     instance = new shortcut_manager ();
@@ -73,17 +182,43 @@ shortcut_manager::instance_ok (void)
 
       retval = false;
     }
 
   return retval;
 }
 
 void
-shortcut_manager::do_init_data ()
+shortcut_manager::init (const QString& description, const QString& key,
+                        const QKeySequence& def_sc)
+{
+  QKeySequence actual
+    = QKeySequence (m_settings->value ("shortcuts/" + key, def_sc).toString ());
+
+  // append the new shortcut to the list
+  shortcut_t shortcut_info;
+  shortcut_info.m_description = description;
+  shortcut_info.m_settings_key = key;
+  shortcut_info.m_actual_sc = actual;
+  shortcut_info.m_default_sc = def_sc;
+  m_sc << shortcut_info;
+
+  // insert shortcut in order check for duplicates later
+  if (! actual.isEmpty ())
+    m_shortcut_hash[actual.toString ()] = m_sc.count ();
+  m_action_hash[key] = m_sc.count ();
+
+  // check whether ctrl+d is used from main window, i.e. is a global shortcut
+  if (key.startsWith ("main_")
+      && actual == QKeySequence (Qt::ControlModifier+Qt::Key_D))
+    m_settings->setValue ("shortcuts/main_ctrld",true);
+}
+
+void
+shortcut_manager::do_init_data (void)
 {
   Qt::KeyboardModifier ctrl;
   int prefix;
 #if defined (Q_OS_MAC)
   // Use CMD key as an equivalent of Ctrl key on other platforms
   ctrl = Qt::MetaModifier;
   // Some of octave default shortcuts on windows/linux are already defined
   // as system wide shortcuts on Mac Os X (almost all Function keys).
@@ -94,17 +229,17 @@ shortcut_manager::do_init_data ()
   prefix = Qt::NoModifier;
 #endif
 
   Qt::KeyboardModifiers ctrl_shift = ctrl | Qt::ShiftModifier;
   Qt::KeyboardModifiers ctrl_alt = ctrl | Qt::AltModifier;
 
   // actions of the main window
 
-  _settings->setValue ("shortcuts/main_ctrld",false); // reset use fo ctrl-d
+  m_settings->setValue ("shortcuts/main_ctrld",false); // reset use fo ctrl-d
 
   // file
   init (tr ("New File"), "main_file:new_file", QKeySequence::New);
   init (tr ("New Function"), "main_file:new_function",
         QKeySequence (ctrl_shift + Qt::Key_N));
   init (tr ("New Figure"), "main_file:new_figure", QKeySequence ());
   init (tr ("Open File"), "main_file:open_file", QKeySequence::Open);
   init (tr ("Load Workspace"), "main_file:load_workspace", QKeySequence ());
@@ -329,47 +464,63 @@ shortcut_manager::do_init_data ()
         QKeySequence (ctrl + Qt::Key_PageDown));
   init (tr ("Move Tab Left"), "editor_tabs:move_tab_left",
         QKeySequence (Qt::AltModifier + Qt::Key_PageUp));
   init (tr ("Move Tab Right"), "editor_tabs:move_tab_right",
         QKeySequence (Qt::AltModifier + Qt::Key_PageDown));
 
 }
 
+// write one or all actual shortcut set(s) into a settings file
 void
-shortcut_manager::init (const QString& description, const QString& key,
-                        const QKeySequence& def_sc)
+shortcut_manager::do_write_shortcuts (QSettings *settings,
+                                      bool closing)
 {
-  QKeySequence actual
-    = QKeySequence (_settings->value ("shortcuts/"+key, def_sc).toString ());
+  bool sc_ctrld = false;
+
+  for (int i = 0; i < m_sc.count (); i++)  // loop over all shortcuts
+    {
+      settings->setValue ("shortcuts/" + m_sc.at (i).m_settings_key,
+                          m_sc.at (i).m_actual_sc.toString ());
+      // special: check main-window for Ctrl-D (Terminal)
+      if (m_sc.at (i).m_settings_key.startsWith ("main_")
+          && m_sc.at (i).m_actual_sc == QKeySequence (Qt::ControlModifier+Qt::Key_D))
+        sc_ctrld = true;
+    }
+
+  settings->setValue ("shortcuts/main_ctrld",sc_ctrld);
 
-  // append the new shortcut to the list
-  shortcut_t shortcut_info;
-  shortcut_info.description = description;
-  shortcut_info.settings_key = key;
-  shortcut_info.actual_sc = actual;
-  shortcut_info.default_sc = def_sc;
-  _sc << shortcut_info;
+  if (closing)
+    {
+      delete m_dialog;     // the dialog for key sequences can be removed now
+      m_dialog = nullptr;  // make sure it is zero again
+    }
+
+  settings->sync ();      // sync the settings file
+}
 
-  // insert shortcut in order check for duplicates later
-  if (! actual.isEmpty ())
-    _shortcut_hash[actual.toString ()] = _sc.count ();
-  _action_hash[key] = _sc.count ();
+void
+shortcut_manager::do_set_shortcut (QAction *action, const QString& key)
+{
+  int index;
 
-  // check whether ctrl+d is used from main window, i.e. is a global shortcut
-  if (key.startsWith ("main_")
-      && actual == QKeySequence (Qt::ControlModifier+Qt::Key_D))
-    _settings->setValue ("shortcuts/main_ctrld",true);
+  index = m_action_hash[key] - 1;
+
+  if (index > -1 && index < m_sc.count ())
+    action->setShortcut (QKeySequence (
+      m_settings->value ("shortcuts/" + key, m_sc.at (index).m_default_sc).toString ()));
+  else
+    qDebug () << "Key: " << key << " not found in m_action_hash";
 }
 
 void
 shortcut_manager::do_fill_treewidget (QTreeWidget *tree_view)
 {
-  _dialog = nullptr;
-  _level_hash.clear ();
+  m_dialog = nullptr;
+  m_level_hash.clear ();
 
 #if defined (HAVE_QT4)
   tree_view->header ()->setResizeMode (QHeaderView::ResizeToContents);
 #else
   tree_view->header ()->setSectionResizeMode (QHeaderView::ResizeToContents);
 #endif
 
   QTreeWidgetItem *main = new QTreeWidgetItem (tree_view);
@@ -383,22 +534,22 @@ shortcut_manager::do_fill_treewidget (QT
   main_debug->setText (0, tr ("Debug"));
   QTreeWidgetItem *main_window = new QTreeWidgetItem (main);
   main_window->setText (0, tr ("Window"));
   QTreeWidgetItem *main_help = new QTreeWidgetItem (main);
   main_help->setText (0, tr ("Help"));
   QTreeWidgetItem *main_news = new QTreeWidgetItem (main);
   main_news->setText (0, tr ("News"));
 
-  _level_hash["main_file"]   = main_file;
-  _level_hash["main_edit"]   = main_edit;
-  _level_hash["main_debug"]   = main_debug;
-  _level_hash["main_window"]   = main_window;
-  _level_hash["main_help"]   = main_help;
-  _level_hash["main_news"]   = main_news;
+  m_level_hash["main_file"]   = main_file;
+  m_level_hash["main_edit"]   = main_edit;
+  m_level_hash["main_debug"]   = main_debug;
+  m_level_hash["main_window"]   = main_window;
+  m_level_hash["main_help"]   = main_help;
+  m_level_hash["main_news"]   = main_news;
 
   QTreeWidgetItem *editor = new QTreeWidgetItem (tree_view);
   editor->setText (0, tr ("Editor"));
   editor->setExpanded (true);
   QTreeWidgetItem *editor_file = new QTreeWidgetItem (editor);
   editor_file->setText (0, tr ("File"));
   QTreeWidgetItem *editor_edit = new QTreeWidgetItem (editor);
   editor_edit->setText (0, tr ("Edit"));
@@ -408,276 +559,48 @@ shortcut_manager::do_fill_treewidget (QT
   editor_debug->setText (0, tr ("Debug"));
   QTreeWidgetItem *editor_run = new QTreeWidgetItem (editor);
   editor_run->setText (0, tr ("Run"));
   QTreeWidgetItem *editor_help = new QTreeWidgetItem (editor);
   editor_help->setText (0, tr ("Help"));
   QTreeWidgetItem *editor_tabs = new QTreeWidgetItem (editor);
   editor_tabs->setText (0, tr ("Tabs"));
 
-  _level_hash["editor_file"] = editor_file;
-  _level_hash["editor_edit"] = editor_edit;
-  _level_hash["editor_view"] = editor_view;
-  _level_hash["editor_debug"] = editor_debug;
-  _level_hash["editor_run"] = editor_run;
-  _level_hash["editor_help"] = editor_help;
-  _level_hash["editor_tabs"] = editor_tabs;
+  m_level_hash["editor_file"] = editor_file;
+  m_level_hash["editor_edit"] = editor_edit;
+  m_level_hash["editor_view"] = editor_view;
+  m_level_hash["editor_debug"] = editor_debug;
+  m_level_hash["editor_run"] = editor_run;
+  m_level_hash["editor_help"] = editor_help;
+  m_level_hash["editor_tabs"] = editor_tabs;
 
   connect (tree_view, SIGNAL (itemDoubleClicked (QTreeWidgetItem*, int)),
            this, SLOT (handle_double_clicked (QTreeWidgetItem*, int)));
 
-  for (int i = 0; i < _sc.count (); i++)
+  for (int i = 0; i < m_sc.count (); i++)
     {
-      shortcut_t sc = _sc.at (i);
+      shortcut_t sc = m_sc.at (i);
 
-      QTreeWidgetItem *section = _level_hash[sc.settings_key.section (':',0,0)];
+      QTreeWidgetItem *section = m_level_hash[sc.m_settings_key.section (':',0,0)];
       QTreeWidgetItem *tree_item = new QTreeWidgetItem (section);
 
       // set a slightly transparent foreground for default columns
       QColor fg = QColor (tree_item->foreground (1).color ());
       fg.setAlpha (128);
       tree_item->setForeground (1, QBrush (fg));
 
       // write the shortcuts
-      tree_item->setText (0, sc.description);
-      tree_item->setText (1, sc.default_sc.toString ());
-      tree_item->setText (2, sc.actual_sc.toString ());
-
-      _item_index_hash[tree_item] = i + 1; // index+1 to avoid 0
-      _index_item_hash[i] = tree_item;
-    }
-
-}
-
-// write one or all actual shortcut set(s) into a settings file
-void
-shortcut_manager::do_write_shortcuts (QSettings *settings,
-                                      bool closing)
-{
-  bool sc_ctrld = false;
+      tree_item->setText (0, sc.m_description);
+      tree_item->setText (1, sc.m_default_sc.toString ());
+      tree_item->setText (2, sc.m_actual_sc.toString ());
 
-  for (int i = 0; i < _sc.count (); i++)  // loop over all shortcuts
-    {
-      settings->setValue ("shortcuts/"+_sc.at (i).settings_key,
-                          _sc.at (i).actual_sc.toString ());
-      // special: check main-window for Ctrl-D (Terminal)
-      if (_sc.at (i).settings_key.startsWith ("main_")
-          && _sc.at (i).actual_sc == QKeySequence (Qt::ControlModifier+Qt::Key_D))
-        sc_ctrld = true;
-    }
-
-  settings->setValue ("shortcuts/main_ctrld",sc_ctrld);
-
-  if (closing)
-    {
-      delete _dialog;     // the dialog for key sequences can be removed now
-      _dialog = nullptr;  // make sure it is zero again
+      m_item_index_hash[tree_item] = i + 1; // index+1 to avoid 0
+      m_index_item_hash[i] = tree_item;
     }
 
-  settings->sync ();      // sync the settings file
-}
-
-void
-shortcut_manager::do_set_shortcut (QAction *action, const QString& key)
-{
-  int index;
-
-  index = _action_hash[key] - 1;
-
-  if (index > -1 && index < _sc.count ())
-    action->setShortcut (QKeySequence (
-      _settings->value ("shortcuts/" + key, _sc.at (index).default_sc).toString ()));
-  else
-    qDebug () << "Key: " << key << " not found in _action_hash";
-}
-
-void
-shortcut_manager::handle_double_clicked (QTreeWidgetItem *item, int col)
-{
-  if (col != 2)
-    return;
-
-  int i = _item_index_hash[item];
-  if (i == 0)
-    return;  // top-level-item clicked
-
-  shortcut_dialog (i-1); // correct to index starting at 0
-}
-
-void
-shortcut_manager::shortcut_dialog (int index)
-{
-  if (! _dialog)
-    {
-      _dialog = new QDialog (this);
-
-      _dialog->setWindowTitle (tr ("Enter new Shortcut"));
-
-      QVBoxLayout *box = new QVBoxLayout (_dialog);
-
-      QLabel *help = new QLabel (tr ("Apply the desired shortcut or click "
-                                     "on the right button to reset the "
-                                     "shortcut to its default."));
-      help->setWordWrap (true);
-      box->addWidget (help);
-
-      QCheckBox *direct = new QCheckBox (
-        tr ("Enter shortcut directly by performing it"));
-      direct->setCheckState (Qt::Checked);
-      box->addWidget (direct);
-
-      QGridLayout *grid = new QGridLayout ();
-
-      QLabel *actual = new QLabel (tr ("Actual shortcut"));
-      _edit_actual = new enter_shortcut (_dialog);
-      _edit_actual->setAlignment (Qt::AlignHCenter);
-      grid->addWidget (actual, 0, 0);
-      grid->addWidget (_edit_actual, 0, 1);
-
-      QLabel *def = new QLabel (tr ("Default shortcut"));
-      _label_default = new QLabel (_dialog);
-      _label_default->setAlignment (Qt::AlignHCenter);
-      grid->addWidget (def, 1, 0);
-      grid->addWidget (_label_default, 1, 1);
-
-      QPushButton *set_default = new QPushButton (tr ("Set to default"));
-      grid->addWidget (set_default, 0, 2);
-      connect (set_default, SIGNAL (clicked ()),
-               this, SLOT (shortcut_dialog_set_default ()));
-
-      box->addLayout (grid);
-
-      QDialogButtonBox *button_box = new QDialogButtonBox (QDialogButtonBox::Ok
-                                                   | QDialogButtonBox::Cancel);
-      QList<QAbstractButton *> buttons = button_box->buttons ();
-      for (int i = 0; i < buttons.count (); i++)
-        buttons.at (i)->setShortcut (QKeySequence ());
-      connect (button_box, SIGNAL (accepted ()), _dialog, SLOT (accept ()));
-      connect (button_box, SIGNAL (rejected ()), _dialog, SLOT (reject ()));
-      box->addWidget (button_box);
-
-      _dialog->setLayout (box);
-
-      connect (direct, SIGNAL (stateChanged (int)),
-               _edit_actual, SLOT (handle_direct_shortcut (int)));
-      connect (_dialog, SIGNAL (finished (int)),
-               this, SLOT (shortcut_dialog_finished (int)));
-
-    }
-
-  _edit_actual->setText (_sc.at (index).actual_sc.toString ());
-  _label_default->setText (_sc.at (index).default_sc.toString ());
-  _handled_index = index;
-
-  _edit_actual->setFocus ();
-  _dialog->setFocusProxy (_edit_actual);
-  _dialog->exec ();
-}
-
-void
-shortcut_manager::shortcut_dialog_finished (int result)
-{
-  if (result == QDialog::Rejected)
-    return;
-
-  // check for duplicate
-  int double_index = _shortcut_hash[_edit_actual->text ()] - 1;
-
-  if (double_index >= 0 && double_index != _handled_index)
-    {
-      int ret = QMessageBox::warning (this, tr ("Double Shortcut"),
-                  tr ("The chosen shortcut\n  \"%1\"\n"
-                      "is already used for the action\n  \"%2\".\n"
-                      "Do you want to use the shortcut anyhow removing it "
-                      "from the previous action?")
-                     .arg (_edit_actual->text ())
-                     .arg (_sc.at (double_index).description),
-                  QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
-
-      if (ret == QMessageBox::Yes)
-        {
-          shortcut_t double_shortcut = _sc.at (double_index);
-          double_shortcut.actual_sc = QKeySequence ();
-          _sc.replace (double_index, double_shortcut);
-          _index_item_hash[double_index]->setText (2, QString ());
-        }
-      else
-        return;
-    }
-
-  shortcut_t shortcut = _sc.at (_handled_index);
-  if (! shortcut.actual_sc.isEmpty ())
-    _shortcut_hash.remove (shortcut.actual_sc.toString ());
-  shortcut.actual_sc = _edit_actual->text ();
-  _sc.replace (_handled_index, shortcut);
-
-  _index_item_hash[_handled_index]->setText (2, shortcut.actual_sc.toString ());
-
-  if (! shortcut.actual_sc.isEmpty ())
-    _shortcut_hash[shortcut.actual_sc.toString ()] = _handled_index + 1;
-}
-
-void
-shortcut_manager::shortcut_dialog_set_default ()
-{
-  _edit_actual->setText (_label_default->text ());
-}
-
-// import a shortcut set from a given settings file or reset to
-// the defaults (settings = 0) and refresh the tree view
-void
-shortcut_manager::import_shortcuts (QSettings *settings)
-{
-  for (int i = 0; i < _sc.count (); i++)
-    {
-      // update the list of all shortcuts
-      shortcut_t sc = _sc.at (i);           // make a copy
-
-      if (settings)
-        sc.actual_sc = QKeySequence (         // get new shortcut from settings
-          settings->value ("shortcuts/"+sc.settings_key,sc.actual_sc).
-                          toString ());       // and use the old one as default
-      else
-        sc.actual_sc = QKeySequence (sc.default_sc); // get default shortcut
-
-      _sc.replace (i,sc);                   // replace the old with the new one
-
-      // update the tree view
-      QTreeWidgetItem *tree_item = _index_item_hash[i]; // get related tree item
-      tree_item->setText (2, sc.actual_sc.toString ()); // display new shortcut
-    }
-}
-
-// ask the user whether to save the current shortcut set;
-// returns true to proceed with import action, false to abort it
-bool
-shortcut_manager::overwrite_all_shortcuts ()
-{
-  QMessageBox msg_box;
-  msg_box.setWindowTitle (tr ("Overwriting Shortcuts"));
-  msg_box.setIcon (QMessageBox::Warning);
-  msg_box.setText (tr ("You are about to overwrite all shortcuts.\n"
-     "Would you like to save the current shortcut set or cancel the action?"));
-  msg_box.setStandardButtons (QMessageBox::Save | QMessageBox::Cancel);
-  QPushButton *discard = msg_box.addButton (tr ("Don't save"),
-                                            QMessageBox::DestructiveRole);
-  msg_box.setDefaultButton (QMessageBox::Save);
-
-  int ret = msg_box.exec ();
-
-  if (msg_box.clickedButton () == discard)
-    return true;  // do not save and go ahead
-
-  if (ret == QMessageBox::Save)
-    {
-      if (do_import_export (OSC_EXPORT))
-        return true;  // go ahead
-    }
-
-  return false; // abort the import
 }
 
 // import or export of shortcut sets,
 // called from settings dialog when related buttons are clicked;
 // returns true on success, false otherwise
 bool
 shortcut_manager::do_import_export (int action)
 {
@@ -727,59 +650,131 @@ shortcut_manager::do_import_export (int 
   else
     {
       import_shortcuts (nullptr);
     }
 
   return true;
 }
 
-// enter_shortcut:
-// class derived from QLineEdit for directly entering key sequences which
-enter_shortcut::enter_shortcut (QWidget *p) : QLineEdit (p)
+void
+shortcut_manager::shortcut_dialog (int index)
 {
-  _direct_shortcut = true;      // the shortcut is directly entered
-}
+  if (! m_dialog)
+    {
+      m_dialog = new QDialog (this);
+
+      m_dialog->setWindowTitle (tr ("Enter new Shortcut"));
+
+      QVBoxLayout *box = new QVBoxLayout (m_dialog);
+
+      QLabel *help = new QLabel (tr ("Apply the desired shortcut or click "
+                                     "on the right button to reset the "
+                                     "shortcut to its default."));
+      help->setWordWrap (true);
+      box->addWidget (help);
+
+      QCheckBox *direct = new QCheckBox (
+        tr ("Enter shortcut directly by performing it"));
+      direct->setCheckState (Qt::Checked);
+      box->addWidget (direct);
+
+      QGridLayout *grid = new QGridLayout ();
+
+      QLabel *actual = new QLabel (tr ("Actual shortcut"));
+      m_edit_actual = new enter_shortcut (m_dialog);
+      m_edit_actual->setAlignment (Qt::AlignHCenter);
+      grid->addWidget (actual, 0, 0);
+      grid->addWidget (m_edit_actual, 0, 1);
 
-enter_shortcut::~enter_shortcut ()
-{ }
+      QLabel *def = new QLabel (tr ("Default shortcut"));
+      m_label_default = new QLabel (m_dialog);
+      m_label_default->setAlignment (Qt::AlignHCenter);
+      grid->addWidget (def, 1, 0);
+      grid->addWidget (m_label_default, 1, 1);
+
+      QPushButton *set_default = new QPushButton (tr ("Set to default"));
+      grid->addWidget (set_default, 0, 2);
+      connect (set_default, SIGNAL (clicked ()),
+               this, SLOT (shortcut_dialog_set_default ()));
+
+      box->addLayout (grid);
 
-// slot for checkbox whether the shortcut is directly entered or not
-void
-enter_shortcut::handle_direct_shortcut (int state)
-{
-  if (state)
-    _direct_shortcut = true;  // the shortcut is directly entered
-  else
-    _direct_shortcut = false; // the shortcut has to be written as text
+      QDialogButtonBox *button_box = new QDialogButtonBox (QDialogButtonBox::Ok
+                                                   | QDialogButtonBox::Cancel);
+      QList<QAbstractButton *> buttons = button_box->buttons ();
+      for (int i = 0; i < buttons.count (); i++)
+        buttons.at (i)->setShortcut (QKeySequence ());
+      connect (button_box, SIGNAL (accepted ()), m_dialog, SLOT (accept ()));
+      connect (button_box, SIGNAL (rejected ()), m_dialog, SLOT (reject ()));
+      box->addWidget (button_box);
+
+      m_dialog->setLayout (box);
+
+      connect (direct, SIGNAL (stateChanged (int)),
+               m_edit_actual, SLOT (handle_direct_shortcut (int)));
+      connect (m_dialog, SIGNAL (finished (int)),
+               this, SLOT (shortcut_dialog_finished (int)));
+
+    }
+
+  m_edit_actual->setText (m_sc.at (index).m_actual_sc.toString ());
+  m_label_default->setText (m_sc.at (index).m_default_sc.toString ());
+  m_handled_index = index;
+
+  m_edit_actual->setFocus ();
+  m_dialog->setFocusProxy (m_edit_actual);
+  m_dialog->exec ();
 }
 
-// new keyPressEvent
+// import a shortcut set from a given settings file or reset to
+// the defaults (settings = 0) and refresh the tree view
 void
-enter_shortcut::keyPressEvent (QKeyEvent *e)
+shortcut_manager::import_shortcuts (QSettings *settings)
 {
-  if (! _direct_shortcut)
+  for (int i = 0; i < m_sc.count (); i++)
     {
-      QLineEdit::keyPressEvent (e);
-      return;
+      // update the list of all shortcuts
+      shortcut_t sc = m_sc.at (i);           // make a copy
+
+      if (settings)
+        sc.m_actual_sc = QKeySequence (         // get new shortcut from settings
+          settings->value ("shortcuts/" + sc.m_settings_key,sc.m_actual_sc).
+                          toString ());       // and use the old one as default
+      else
+        sc.m_actual_sc = QKeySequence (sc.m_default_sc); // get default shortcut
+
+      m_sc.replace (i,sc);                   // replace the old with the new one
+
+      // update the tree view
+      QTreeWidgetItem *tree_item = m_index_item_hash[i]; // get related tree item
+      tree_item->setText (2, sc.m_actual_sc.toString ()); // display new shortcut
+    }
+}
+
+// ask the user whether to save the current shortcut set;
+// returns true to proceed with import action, false to abort it
+bool
+shortcut_manager::overwrite_all_shortcuts (void)
+{
+  QMessageBox msg_box;
+  msg_box.setWindowTitle (tr ("Overwriting Shortcuts"));
+  msg_box.setIcon (QMessageBox::Warning);
+  msg_box.setText (tr ("You are about to overwrite all shortcuts.\n"
+     "Would you like to save the current shortcut set or cancel the action?"));
+  msg_box.setStandardButtons (QMessageBox::Save | QMessageBox::Cancel);
+  QPushButton *discard = msg_box.addButton (tr ("Don't save"),
+                                            QMessageBox::DestructiveRole);
+  msg_box.setDefaultButton (QMessageBox::Save);
+
+  int ret = msg_box.exec ();
+
+  if (msg_box.clickedButton () == discard)
+    return true;  // do not save and go ahead
+
+  if (ret == QMessageBox::Save)
+    {
+      if (do_import_export (OSC_EXPORT))
+        return true;  // go ahead
     }
 
-  if (e->type () == QEvent::KeyPress)
-    {
-      int key = e->key ();
-
-      if (key == Qt::Key_unknown || key == 0)
-        return;
-
-      Qt::KeyboardModifiers modifiers = e->modifiers ();
-
-      if (modifiers & Qt::ShiftModifier)
-        key += Qt::SHIFT;
-      if (modifiers & Qt::ControlModifier)
-        key += Qt::CTRL;
-      if (modifiers & Qt::AltModifier)
-        key += Qt::ALT;
-      if (modifiers & Qt::MetaModifier)
-        key += Qt::META;
-
-      setText (QKeySequence (key).toString ());
-    }
+  return false; // abort the import
 }
diff --git a/libgui/src/shortcut-manager.h b/libgui/src/shortcut-manager.h
--- a/libgui/src/shortcut-manager.h
+++ b/libgui/src/shortcut-manager.h
@@ -30,26 +30,30 @@ along with Octave; see the file COPYING.
 #include <QLabel>
 #include <QSettings>
 
 class enter_shortcut : public QLineEdit
 {
   Q_OBJECT
 
 public:
+
   enter_shortcut (QWidget *p = nullptr);
-  ~enter_shortcut ();
+
+  ~enter_shortcut (void) = default;
 
   virtual void keyPressEvent (QKeyEvent *e);
 
 public slots:
+
   void handle_direct_shortcut (int);
 
 private:
-  bool _direct_shortcut;
+
+  bool m_direct_shortcut;
 
 };
 
 
 class shortcut_manager : public QWidget
 {
   Q_OBJECT
 
@@ -57,27 +61,27 @@ public:
 
   enum
   {
     OSC_IMPORT  = 0,
     OSC_EXPORT  = 1,
     OSC_DEFAULT = 2
   };
 
-  shortcut_manager ();
+  shortcut_manager (void);
 
   // No copying!
 
   shortcut_manager (const shortcut_manager&) = delete;
 
   shortcut_manager& operator = (const shortcut_manager&) = delete;
 
-  ~shortcut_manager ();
+  ~shortcut_manager (void) = default;
 
-  static void init_data ()
+  static void init_data (void)
   {
     if (instance_ok ())
       instance->do_init_data ();
   }
 
   static void write_shortcuts (QSettings *settings, bool closing)
   {
     if (instance_ok ())
@@ -103,20 +107,16 @@ public:
   }
 
   static shortcut_manager *instance;
 
 public slots:
 
   static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
-signals:
-
-protected:
-
 protected slots:
 
   void handle_double_clicked (QTreeWidgetItem*, int);
   void shortcut_dialog_finished (int);
   void shortcut_dialog_set_default ();
 
 private:
 
@@ -132,65 +132,63 @@ private:
   void import_shortcuts (QSettings *settings);
   bool overwrite_all_shortcuts (void);
 
   class shortcut_t
   {
   public:
 
     shortcut_t (void)
-      : tree_item (nullptr), description (), settings_key (),
-        actual_sc (QKeySequence ()), default_sc (QKeySequence ())
-    {  }
+      : m_tree_item (nullptr), m_description (), m_settings_key (),
+        m_actual_sc (QKeySequence ()), m_default_sc (QKeySequence ())
+    { }
 
     shortcut_t (const shortcut_t& x)
-      : tree_item (x.tree_item), description (x.description),
-        settings_key (x.settings_key)
+      : m_tree_item (x.m_tree_item), m_description (x.m_description),
+        m_settings_key (x.m_settings_key)
     {
-      actual_sc = x.actual_sc;
-      default_sc = x.default_sc;
+      m_actual_sc = x.m_actual_sc;
+      m_default_sc = x.m_default_sc;
     }
 
     shortcut_t& operator = (const shortcut_t& x)
     {
       if (&x != this)
         {
-          tree_item = x.tree_item;
-          description = x.description;
-          settings_key = x.settings_key;
+          m_tree_item = x.m_tree_item;
+          m_description = x.m_description;
+          m_settings_key = x.m_settings_key;
 
-          actual_sc = QKeySequence ();
-          default_sc = QKeySequence ();
+          m_actual_sc = QKeySequence ();
+          m_default_sc = QKeySequence ();
 
-          actual_sc = x.actual_sc;
-          default_sc = x.default_sc;
+          m_actual_sc = x.m_actual_sc;
+          m_default_sc = x.m_default_sc;
         }
 
       return *this;
     }
 
-    ~shortcut_t (void)
-    { }
+    ~shortcut_t (void) = default;
 
-    QTreeWidgetItem *tree_item;
-    QString description;
-    QString settings_key;
-    QKeySequence actual_sc;
-    QKeySequence default_sc;
+    QTreeWidgetItem *m_tree_item;
+    QString m_description;
+    QString m_settings_key;
+    QKeySequence m_actual_sc;
+    QKeySequence m_default_sc;
   };
 
-  QList<shortcut_t> _sc;
-  QHash<QString, int> _shortcut_hash;
-  QHash<QString, int> _action_hash;
-  QHash <QString, QTreeWidgetItem*> _level_hash;
-  QHash<int, QTreeWidgetItem*> _index_item_hash;
-  QHash<QTreeWidgetItem*, int> _item_index_hash;
+  QList<shortcut_t> m_sc;
+  QHash<QString, int> m_shortcut_hash;
+  QHash<QString, int> m_action_hash;
+  QHash <QString, QTreeWidgetItem*> m_level_hash;
+  QHash<int, QTreeWidgetItem*> m_index_item_hash;
+  QHash<QTreeWidgetItem*, int> m_item_index_hash;
 
-  QDialog *_dialog;
-  enter_shortcut *_edit_actual;
-  QLabel *_label_default;
-  int _handled_index;
+  QDialog *m_dialog;
+  enter_shortcut *m_edit_actual;
+  QLabel *m_label_default;
+  int m_handled_index;
 
-  QSettings *_settings;
-
+  QSettings *m_settings;
 };
 
 #endif
diff --git a/libgui/src/variable-editor-model.cc b/libgui/src/variable-editor-model.cc
--- a/libgui/src/variable-editor-model.cc
+++ b/libgui/src/variable-editor-model.cc
@@ -41,153 +41,165 @@ along with Octave; see the file COPYING.
 #include "parse.h"
 #include "variables.h"
 
 /// Pimpl/Dpointer for variable_editor_model.
 struct variable_editor_model::impl
 {
   struct cell
   {
-    enum state_t {
-      avail,
-      notavail,
-      pending,
-      unset
-    };
+    enum state_t
+      {
+        avail,
+        notavail,
+        pending,
+        unset
+      };
 
     cell ()
-      : state (unset)
+      : m_state (unset)
     { }
 
     cell (state_t s)
-      : state (s)
+      : m_state (s)
     { }
 
-    cell (const QString &d, const QString &s, const QString &t,
+    cell (const QString& d, const QString& s, const QString& t,
           bool rse, sub_editor_types edtype)
-      : state (avail), data (d), status_tip (s), tool_tip (t),
-        requires_sub_editor (rse), editor_type (edtype)
+      : m_state (avail), m_data (d), m_status_tip (s), m_tool_tip (t),
+        m_requires_sub_editor (rse), m_editor_type (edtype)
     { }
 
-    state_t state;
-    QVariant data;
-    QVariant status_tip;
-    QVariant tool_tip;
-    QVariant background;
-    bool requires_sub_editor;
+    state_t m_state;
+    QVariant m_data;
+    QVariant m_status_tip;
+    QVariant m_tool_tip;
+    QVariant m_background;
+    bool m_requires_sub_editor;
 
-    sub_editor_types editor_type;
+    sub_editor_types m_editor_type;
 
     // FIXME: Other variables needed?
   };
 
-  void set (const QModelIndex &idx, const cell &dat)
+  void set (const QModelIndex& idx, const cell& dat)
   {
     if (idx.isValid ())
-      table[model_to_index (idx)] = dat;
+      m_table[model_to_index (idx)] = dat;
   }
-  void set (int r, int c, const cell &dat)
+
+  void set (int r, int c, const cell& dat)
   {
-    if (0 <= r && r < _rows && 0 <= c && c <= columns ())
-      table[c * _rows + r] = dat;
+    if (0 <= r && r < m_rows && 0 <= c && c <= columns ())
+      m_table[c * m_rows + r] = dat;
   }
-  bool is_set (const QModelIndex &idx) const
+
+  bool is_set (const QModelIndex& idx) const
   {
     return idx.isValid ()
-           && table[model_to_index (idx)].state == cell::avail;
+           && m_table[model_to_index (idx)].m_state == cell::avail;
   }
-  bool is_notavail (const QModelIndex &idx) const
+
+  bool is_notavail (const QModelIndex& idx) const
   {
     return idx.isValid ()
-           && table[model_to_index (idx)].state == cell::notavail;
+           && m_table[model_to_index (idx)].m_state == cell::notavail;
   }
-  bool is_pending (const QModelIndex &idx) const
+
+  bool is_pending (const QModelIndex& idx) const
   {
     return idx.isValid ()
-           && table[model_to_index (idx)].state == cell::pending;
+           && m_table[model_to_index (idx)].m_state == cell::pending;
   }
-  void pending (const QModelIndex &idx)
+
+  void pending (const QModelIndex& idx)
   {
     if (idx.isValid ())
-      table[model_to_index (idx)].state = cell::pending;
+      m_table[model_to_index (idx)].m_state = cell::pending;
   }
+
   void notavail (int r, int c)
   {
-    if (0 <= r && r < _rows && 0 <= c && c <= columns ())
-      table[c * _rows + r].state = cell::notavail;
+    if (0 <= r && r < m_rows && 0 <= c && c <= columns ())
+      m_table[c * m_rows + r].m_state = cell::notavail;
   }
-  bool requires_sub_editor (const QModelIndex &idx)
+
+  bool requires_sub_editor (const QModelIndex& idx)
   {
     return idx.isValid ()
-           && table[model_to_index (idx)].requires_sub_editor;
+           && m_table[model_to_index (idx)].m_requires_sub_editor;
   }
 
-  sub_editor_types sub_editor_type (const QModelIndex &idx)
+  sub_editor_types sub_editor_type (const QModelIndex& idx)
   {
-    return idx.isValid () ? table[model_to_index (idx)].editor_type : sub_none;
+    return idx.isValid () ? m_table[model_to_index (idx)].m_editor_type : sub_none;
   }
 
   void unset (int r, int c)
   {
-    if (0 <= r && r < _rows && 0 <= c && c <= columns ())
-      table[c * _rows + r].state = cell::unset;
+    if (0 <= r && r < m_rows && 0 <= c && c <= columns ())
+      m_table[c * m_rows + r].m_state = cell::unset;
   }
-  void clear ()
+
+  void clear (void)
   {
-    for (int i = 0; i < table.size (); ++i)
-      table[i].state = cell::unset;
+    for (int i = 0; i < m_table.size (); ++i)
+      m_table[i].m_state = cell::unset;
   }
-  QVariant data (const QModelIndex &idx, int role) const
+
+  QVariant data (const QModelIndex& idx, int role) const
   {
     if (idx.isValid ())
       {
         const int i = model_to_index (idx);
         switch (role)
           {
           case Qt::DisplayRole:
           case Qt::EditRole:
-            return table[i].data;
+            return m_table[i].m_data;
           case Qt::StatusTipRole:
-            return table[i].status_tip;
+            return m_table[i].m_status_tip;
           case Qt::ToolTipRole:
-            return table[i].tool_tip;
+            return m_table[i].m_tool_tip;
           case Qt::BackgroundRole:
-            return table[i].background;
+            return m_table[i].m_background;
           }
       }
     return QVariant ();
   }
-  octave_idx_type rows () const { return _rows; }
-  octave_idx_type columns () const { return _cols; }
+
+  octave_idx_type rows (void) const { return m_rows; }
 
-  int model_to_index (const QModelIndex &idx) const
+  octave_idx_type columns (void) const { return m_cols; }
+
+  int model_to_index (const QModelIndex& idx) const
   {
-    return idx.column () * _rows + idx.row ();
+    return idx.column () * m_rows + idx.row ();
   }
 
-  impl (const QString &n, QLabel *l)
-    : name (n.toStdString ()), type (),
-      _rows (0), _cols (0), table (), label (l),
-      _validity (true), validtext ()
+  impl (const QString& n, QLabel *l)
+    : m_name (n.toStdString ()), m_type (),
+      m_rows (0), m_cols (0), m_table (), m_label (l),
+      m_validity (true), m_validtext ()
   { }
 
-  const std::string name;
-  std::string type;
-  octave_idx_type _rows;
-  octave_idx_type _cols;
-  QVector<cell> table;
-  QLabel *label;
-  bool _validity;
-  QString validtext;
+  const std::string m_name;
+  std::string m_type;
+  octave_idx_type m_rows;
+  octave_idx_type m_cols;
+  QVector<cell> m_table;
+  QLabel *m_label;
+  bool m_validity;
+  QString m_validtext;
 };
 
-variable_editor_model::variable_editor_model (const QString &expr,
+variable_editor_model::variable_editor_model (const QString& expr,
                                               QLabel *label,
                                               QObject *parent)
-  : QAbstractTableModel (parent), p (parent), d (new impl (expr, label))
+  : QAbstractTableModel (parent), m_p (parent), m_d (new impl (expr, label))
 {
   connect (this, SIGNAL (data_ready (int, int, const QString&,
                                      const QString&,
                                      int, int)),
            this, SLOT (received_data (int, int, const QString&,
                                       const QString&,
                                       int, int)));
   connect (this, SIGNAL (no_data (int, int)),
@@ -200,216 +212,216 @@ variable_editor_model::variable_editor_m
                                           int, int)),
            this, SLOT (received_initialize_data (const QString&,
                                                  const QString&,
                                                  int, int)));
 
   clear_data_cache (); // initializes everything
 }
 
-variable_editor_model::~variable_editor_model ()
+variable_editor_model::~variable_editor_model (void)
 {
-  delete d;
+  delete m_d;
 }
 
 void
-variable_editor_model::clear_data_cache ()
+variable_editor_model::clear_data_cache (void)
 {
   octave_link::post_event
-    (this, &variable_editor_model::init_from_oct, d->name);
+    (this, &variable_editor_model::init_from_oct, m_d->m_name);
 }
 
 bool
-variable_editor_model::requires_sub_editor (const QModelIndex &idx) const
+variable_editor_model::requires_sub_editor (const QModelIndex& idx) const
 {
-  return d->requires_sub_editor (idx);
+  return m_d->requires_sub_editor (idx);
 }
 
-bool variable_editor_model::editor_type_matrix (const QModelIndex &idx) const
+bool variable_editor_model::editor_type_matrix (const QModelIndex& idx) const
 {
-  return d->sub_editor_type (idx) == sub_matrix;
+  return m_d->sub_editor_type (idx) == sub_matrix;
 }
 
-bool variable_editor_model::editor_type_string (const QModelIndex &idx) const
+bool variable_editor_model::editor_type_string (const QModelIndex& idx) const
 {
-  return d->sub_editor_type (idx) == sub_string;
+  return m_d->sub_editor_type (idx) == sub_string;
 }
 
-sub_editor_types variable_editor_model::editor_type (const QModelIndex &idx) const
+sub_editor_types variable_editor_model::editor_type (const QModelIndex& idx) const
 {
-  return d->sub_editor_type (idx);
+  return m_d->sub_editor_type (idx);
 }
 
 QString
-variable_editor_model::parens () const
+variable_editor_model::parens (void) const
 {
-  if (d->type == "{")
+  if (m_d->m_type == "{")
     return "{%1, %2}";
   else
     return "(%1, %2)";
 }
 
 int
 variable_editor_model::rowCount (const QModelIndex&) const
 {
-  if (d->_validity)
-    return d->rows ();
+  if (m_d->m_validity)
+    return m_d->rows ();
 
   return 1;
 }
 
 int
 variable_editor_model::columnCount (const QModelIndex&) const
 {
-  if (d->_validity)
-    return d->columns ();
+  if (m_d->m_validity)
+    return m_d->columns ();
 
   return 1;
 }
 
 QVariant
-variable_editor_model::data (const QModelIndex &idx, int role) const
+variable_editor_model::data (const QModelIndex& idx, int role) const
 {
-  if (! d->_validity)
+  if (! m_d->m_validity)
     {
       if (idx.isValid ())
         {
           if (role == Qt::DisplayRole)
             return QVariant (QString ("Variable %d not found")
-                             .arg (QString::fromStdString (d->name)));
+                             .arg (QString::fromStdString (m_d->m_name)));
         }
       return QVariant (QString ("x"));
     }
 
   if (idx.isValid ())
     {
-      if (d->is_set (idx))
-        return d->data (idx, role);
+      if (m_d->is_set (idx))
+        return m_d->data (idx, role);
       else
         {
-          if (! d->is_pending (idx))
+          if (! m_d->is_pending (idx))
             {
               octave_link::post_event<variable_editor_model, int, int,
                                       const std::string&>
                 (const_cast<variable_editor_model *> (this),
                  &variable_editor_model::get_data_oct,
-                 idx.row (), idx.column (), d->name);
-              d->pending (idx);
+                 idx.row (), idx.column (), m_d->m_name);
+              m_d->pending (idx);
             }
           if (role == Qt::DisplayRole)
-            return QVariant (QString (d->is_notavail (idx) ? "⌛" : "✗"));
+            return QVariant (QString (m_d->is_notavail (idx) ? "⌛" : "✗"));
           else
             return QVariant ();
         }
     }
 
   return QVariant (); // invalid
 }
 
 bool
-variable_editor_model::setData (const QModelIndex &idx, const QVariant &v,
+variable_editor_model::setData (const QModelIndex& idx, const QVariant& v,
                                 int role)
 {
   if (idx.isValid () && role == Qt::EditRole)
     {
       if (v.type () != QVariant::String)
         {
           qDebug () << v.typeName () << " Expected String!";
           return false;
         }
       octave_link::post_event<variable_editor_model, const std::string&,
-                              int, int, std::string>
+                              int, int, const std::string&>
         (this, &variable_editor_model::set_data_oct,
-         d->name, idx.row (), idx.column (),
+         m_d->m_name, idx.row (), idx.column (),
          v.toString ().toStdString ());
       return true;
     }
   else
     return false;
 }
 
 bool
 variable_editor_model::insertRows (int row, int count, const QModelIndex&)
 {
   // FIXME: cells?
   octave_link::post_event <variable_editor_model, const std::string&,
-                           std::string>
-    (this, &variable_editor_model::eval_oct, d->name,
+                           const std::string&>
+    (this, &variable_editor_model::eval_oct, m_d->m_name,
      QString ("%1 = [ %1(1:%2,:) ; zeros(%3, columns(%1)) ; %1(%2+%3:end,:) ]")
-     .arg (QString::fromStdString (d->name))
+     .arg (QString::fromStdString (m_d->m_name))
      .arg (row)
      .arg (count)
      .toStdString ());
 
   return true;
 }
 
 bool
 variable_editor_model::removeRows (int row, int count, const QModelIndex&)
 {
-  if (row + count > d->_rows)
+  if (row + count > m_d->m_rows)
     {
-      qDebug () << "Try to remove too many rows " << d->_rows << " "
+      qDebug () << "Try to remove too many rows " << m_d->m_rows << " "
                 << count << " (" << row << ")";
       return false;
     }
 
   octave_link::post_event <variable_editor_model, const std::string&,
-                           std::string>
-    (this, &variable_editor_model::eval_oct, d->name,
+                           const std::string&>
+    (this, &variable_editor_model::eval_oct, m_d->m_name,
      QString ("%1 (%2:%3, :) = []")
-     .arg (QString::fromStdString (d->name))
+     .arg (QString::fromStdString (m_d->m_name))
      .arg (row)
      .arg (row + count)
      .toStdString ());
 
   return true;
 }
 
 bool
 variable_editor_model::insertColumns (int col, int count, const QModelIndex&)
 {
   octave_link::post_event <variable_editor_model, const std::string&,
-                           std::string>
-    (this, &variable_editor_model::eval_oct, d->name,
+                           const std::string&>
+    (this, &variable_editor_model::eval_oct, m_d->m_name,
      QString ("%1 = [ %1(:,1:%2) ; zeros(rows(%1), %3) %1(:,%2+%3:end) ]")
-     .arg (QString::fromStdString (d->name))
+     .arg (QString::fromStdString (m_d->m_name))
      .arg (col)
      .arg (count)
      .toStdString ());
 
   return true;
 }
 
 bool
 variable_editor_model::removeColumns (int col, int count, const QModelIndex&)
 {
-  if (col + count > d->_cols)
+  if (col + count > m_d->m_cols)
     {
-      qDebug () << "Try to remove too many cols " << d->_cols << " "
+      qDebug () << "Try to remove too many cols " << m_d->m_cols << " "
                 << count << " (" << col << ")";
       return false;
     }
 
   octave_link::post_event <variable_editor_model, const std::string&,
-                           std::string>
-    (this, &variable_editor_model::eval_oct, d->name,
+                           const std::string&>
+    (this, &variable_editor_model::eval_oct, m_d->m_name,
      QString ("%1 (:, %2:%3) = []")
-     .arg (QString::fromStdString (d->name))
+     .arg (QString::fromStdString (m_d->m_name))
      .arg (col)
      .arg (col + count)
      .toStdString ());
 
   return true;
 }
 
 Qt::ItemFlags
-variable_editor_model::flags (const QModelIndex &idx) const
+variable_editor_model::flags (const QModelIndex& idx) const
 {
-  if (d->_validity)
+  if (m_d->m_validity)
     {
       if (requires_sub_editor (idx))
         {
           if (editor_type (idx) != sub_string)
             return QAbstractTableModel::flags (idx);
         }
       return QAbstractTableModel::flags (idx) | Qt::ItemIsEditable;
       //return requires_sub_editor(idx) ?  QAbstractTableModel::flags (idx) : QAbstractTableModel::flags (idx) | Qt::ItemIsEditable;
@@ -417,18 +429,18 @@ variable_editor_model::flags (const QMod
 
   return 0;
 }
 
 // private slots
 
 void
 variable_editor_model::received_data (int r, int c,
-                                      const QString &dat,
-                                      const QString &class_info,
+                                      const QString& dat,
+                                      const QString& class_info,
                                       int rows, int cols)
 {
   // trim data
   const QString status_tip;
   const QString tool_tip = class_info +
                            QString (": %1x%2").arg (rows).arg (cols);
 
   bool subedit = rows != 1 || cols != 1 || class_info == QString ("struct");
@@ -443,115 +455,115 @@ variable_editor_model::received_data (in
       else
         edittype = sub_matrix;
     }
   if (class_info == QString ("struct"))
     edittype = sub_struct;
 
 
 
-  d->set (r, c, impl::cell (dat, status_tip, tool_tip,
+  m_d->set (r, c, impl::cell (dat, status_tip, tool_tip,
                             rows > 1 || cols > 1
                             || class_info == QString ("struct"),
                             edittype));
 
   QModelIndex idx = QAbstractTableModel::index (r, c);
 
   emit dataChanged (idx, idx);
 }
 
 void
 variable_editor_model::received_no_data (int r, int c)
 {
-  d->notavail (r, c);
+  m_d->notavail (r, c);
 }
 
 void
 variable_editor_model::received_unset_data (int r, int c)
 {
-  d->unset (r, c);
+  m_d->unset (r, c);
 }
 
 void
-variable_editor_model::received_user_error (const QString &title,
-                                            const QString &msg)
+variable_editor_model::received_user_error (const QString& title,
+                                            const QString& msg)
 {
   QMessageBox::critical (0x0, title, msg);
 }
 
 void
-variable_editor_model::received_initialize_data (const QString &class_name,
-                                                 const QString &paren,
+variable_editor_model::received_initialize_data (const QString& class_name,
+                                                 const QString& paren,
                                                  int rows, int cols)
 {
-  if (!(d->_validity))
+  if (!(m_d->m_validity))
   {
     return;
   }
-  d->type = paren.toStdString ();
+  m_d->m_type = paren.toStdString ();
 
-  const int r = d->_rows - rows;
+  const int r = m_d->m_rows - rows;
   if (r > 0)
-    emit beginRemoveRows (QModelIndex (), rows, d->_rows - 1);
+    emit beginRemoveRows (QModelIndex (), rows, m_d->m_rows - 1);
   else if (r < 0)
-    emit beginInsertRows (QModelIndex (), d->_rows, rows - 1);
+    emit beginInsertRows (QModelIndex (), m_d->m_rows, rows - 1);
 
-  const int c = d->_cols - cols;
+  const int c = m_d->m_cols - cols;
   if (c > 0)
-    emit beginRemoveColumns (QModelIndex (), cols, d->_cols - 1);
+    emit beginRemoveColumns (QModelIndex (), cols, m_d->m_cols - 1);
   else if (c < 0)
-    emit beginInsertColumns (QModelIndex (), d->_cols, cols - 1);
+    emit beginInsertColumns (QModelIndex (), m_d->m_cols, cols - 1);
 
-  d->_rows = rows;
-  d->_cols = cols;
-  d->table.clear ();
-  d->table.resize (rows * cols);
+  m_d->m_rows = rows;
+  m_d->m_cols = cols;
+  m_d->m_table.clear ();
+  m_d->m_table.resize (rows * cols);
 
   if (c > 0)
     emit endRemoveColumns ();
   else if (c < 0)
     emit endInsertColumns ();
 
   if (r > 0)
     emit endRemoveRows ();
   else if (r < 0)
     emit endInsertRows ();
 
   emit dataChanged (QAbstractTableModel::index (0, 0),
-                    QAbstractTableModel::index (d->_rows - 1, d->_cols - 1));
+                    QAbstractTableModel::index (m_d->m_rows - 1, m_d->m_cols - 1));
 
-  d->label->setTextFormat (Qt::PlainText);
+  m_d->m_label->setTextFormat (Qt::PlainText);
   QString description = QString ("%1: %2 %3x%4")
-                        .arg (QString::fromStdString (d->name))
+                        .arg (QString::fromStdString (m_d->m_name))
                         .arg (class_name)
                         .arg (rows)
                         .arg (cols);
-  d->label->setText (description);
-  d->validtext=description;
+  m_d->m_label->setText (description);
+  m_d->m_validtext = description;
 }
 
 // private
 
 void
-variable_editor_model::get_data_oct (int row, int col, const std::string &x)
+variable_editor_model::get_data_oct (int row, int col, const std::string& x)
 {
   int parse_status = 0;
 
   octave_value v = retrieve_variable (x, parse_status);
   //eval_string (x, true, parse_status);//retrieve_variable(x, parse_status);
   //symbol_exist(x,"var") > 0 ? eval_string (x, true, parse_status) : octave_value();
 
   if (parse_status != 0 || ! v.is_defined ())
     {
       emit no_data (row, col);
-      d->_validity = false;
+      m_d->m_validity = false;
       return;
     }
   octave_value_list ovlidx = ovl (row + 1, col + 1);
-  /*const*/ octave_value elem = v.single_subsref (d->type, ovlidx);
+  /*const*/ octave_value elem = v.single_subsref (m_d->m_type, ovlidx);
 
   if (elem.is_defined ())
     {
       std::stringstream ss;
       elem.print (ss, true);
       /*const*/ QString dat = QString::fromStdString (ss.str ()).trimmed ();
       const QString cname = QString::fromStdString (elem.class_name ());
 
@@ -564,20 +576,20 @@ variable_editor_model::get_data_oct (int
       emit data_ready (row, col, dat, cname, elem.rows (), elem.columns ());
     }
   else
     emit no_data (row, col);
 }
 
 // val has to be copied!
 void
-variable_editor_model::set_data_oct (const std::string &x, int row, int col,
-                                     std::string val)
+variable_editor_model::set_data_oct (const std::string& x, int row, int col,
+                                     const std::string& val)
 {
-  d->_validity = true;
+  m_d->m_validity = true;
   int parse_status = 0;
   // Accessing directly since
   // 1) retrieve_variable does not support writeback, and
   // 2) we can be reasonably sure that this variable exists.
   octave_value ret = octave::eval_string (val, true, parse_status);
   //retrieve_variable(x, parse_status);//eval_string (val, true, parse_status);
   if (parse_status != 0 || ret.is_undefined ())
     {
@@ -587,99 +599,99 @@ variable_editor_model::set_data_oct (con
       return;
     }
 
   parse_status = 0;
   octave_value v = retrieve_variable (x, parse_status);
   //eval_string (x, true, parse_status);
   if (parse_status != 0 || ! v.is_defined ())
     {
-      d->_validity = false;
+      m_d->m_validity = false;
       emit user_error ("Table invalid",
                        QString ("Table expression `%1' invalid")
                        .arg (QString::fromStdString (x)));
       return;
     }
 
   octave_value_list ovlidx = ovl (row + 1, col + 1);
   std::list<octave_value_list> idxl;
   idxl.push_back (ovlidx);
-  v.subsasgn (d->type, idxl, ret);
+  v.subsasgn (m_d->m_type, idxl, ret);
   emit unset_data (row, col);
   QModelIndex idx = QAbstractTableModel::index (row, col);
   emit dataChanged (idx, idx);
 }
 
 /**
  * If the variable exists, load it into the data model. If it doesn't exist,
  * flag the data model as referring to a nonexistant variable.
  *
  * This allows the variable to be opened before it is created.
  */
 octave_value
-variable_editor_model::retrieve_variable (const std::string &x,
-                                          int &parse_status)
+variable_editor_model::retrieve_variable (const std::string& x,
+                                          int& parse_status)
 {
   std::string name = x;
 
   if (x.back () == ')' || x.back () == '}')
     name = x.substr (0, x.find (x.back () == ')' ? "(" : "{"));
 
   if (symbol_exist (name, "var") > 0)
     return octave::eval_string (x, true, parse_status);
 
   parse_status = -1;
 
   return octave_value ();
 }
 
 
 void
-variable_editor_model::init_from_oct (const std::string &x)
+variable_editor_model::init_from_oct (const std::string& x)
 {
   int parse_status = 0;
   const octave_value ov = retrieve_variable (x, parse_status);//eval_string (x, true, parse_status);
-  d->_validity = true;
+  m_d->m_validity = true;
   if (parse_status != 0 || ! ov.is_defined ())
     {
-      d->_validity = false;
+      m_d->m_validity = false;
       display_invalid ();
       return;
     }
   const QString class_name = QString::fromStdString (ov.class_name ());
   const QString paren = ov.iscell () ? "{" : "("; // FIXME: cells?
   const octave_idx_type rows = ov.rows ();
   const octave_idx_type cols = ov.columns ();
 
   display_valid ();
   emit initialize_data (class_name, paren, rows, cols);
 }
 
 void
-variable_editor_model::eval_oct (const std::string &name, std::string x)
+variable_editor_model::eval_oct (const std::string& name, const std::string& x)
 {
   int parse_status = 0;
   octave::eval_string (x, true, parse_status);
   if (parse_status != 0)
     emit user_error ("Evaluation failed",
                      QString ("Evaluation of `%s' failed")
                      .arg (QString::fromStdString (x)));
   init_from_oct (name);
 }
 
 void
-variable_editor_model::display_invalid ()
+variable_editor_model::display_invalid (void)
 {
-  d->label->setTextFormat (Qt::PlainText);
+  m_d->m_label->setTextFormat (Qt::PlainText);
   QString description = QString ("%1: [not found or out-of-scope]")
-                        .arg (QString::fromStdString (d->name));
-  d->label->setText (description);
-  dynamic_cast<QWidget *> (p)->setVisible (false);
+                        .arg (QString::fromStdString (m_d->m_name));
+  m_d->m_label->setText (description);
+  dynamic_cast<QWidget *> (m_p)->setVisible (false);
 }
 
 void
-variable_editor_model::display_valid ()
+variable_editor_model::display_valid (void)
 {
-  d->label->setTextFormat (Qt::PlainText);
-  d->label->setText (d->validtext);
-  dynamic_cast<QWidget *> (p)->setVisible (true);
+  m_d->m_label->setTextFormat (Qt::PlainText);
+  m_d->m_label->setText (m_d->m_validtext);
+  dynamic_cast<QWidget *> (m_p)->setVisible (true);
 }
 
diff --git a/libgui/src/variable-editor-model.h b/libgui/src/variable-editor-model.h
--- a/libgui/src/variable-editor-model.h
+++ b/libgui/src/variable-editor-model.h
@@ -43,17 +43,17 @@ class
 variable_editor_model : public QAbstractTableModel
 {
   Q_OBJECT
 
 public:
 
   variable_editor_model (const QString &expr, QLabel *label, QObject *p = 0);
 
-  ~variable_editor_model ();
+  ~variable_editor_model (void);
 
   int rowCount (const QModelIndex& = QModelIndex ()) const;
 
   int columnCount (const QModelIndex& = QModelIndex ()) const;
 
   QVariant data (const QModelIndex& idx, int role = Qt::DisplayRole) const;
 
   bool setData (const QModelIndex& idx, const QVariant& v,
@@ -68,85 +68,86 @@ public:
                    const QModelIndex& parent = QModelIndex());
 
   bool insertColumns (int column, int count,
                       const QModelIndex& parent = QModelIndex());
 
   bool removeColumns (int column, int count,
                       const QModelIndex& parent = QModelIndex());
 
-  void clear_data_cache ();
+  void clear_data_cache (void);
 
   // Is cell at idx complex enough to require a sub editor?
   bool requires_sub_editor (const QModelIndex& idx) const;
 
   // If a sub editor is required, is it a standard type?
   bool editor_type_matrix (const QModelIndex& idx) const;
   bool editor_type_string (const QModelIndex& idx) const;
 
   /** Return the proper parens to access the data structure.
    *
    * {%1,%2} for cell and (%1,%2) for matrices.  Use QString::arg to
    * set the index.
    */
-  QString parens () const;
+  QString parens (void) const;
 
 signals: // private
 
   void data_ready (int r, int c, const QString& data,
                    const QString& class_info, int rows, int cols);
 
   void no_data (int r, int c);
 
   void unset_data (int r, int c);
 
   void user_error (const QString& title, const QString& msg);
 
   void initialize_data (const QString& class_name, const QString& paren,
                         int rows, int cols);
 
-  void updated ();
+  void updated (void);
 
 private slots:
 
   void received_data (int r, int c, const QString& dat,
                       const QString& class_info, int rows, int cols);
 
   void received_no_data (int r, int c);
 
   void received_unset_data (int r, int c);
 
   void received_user_error (const QString& title, const QString& msg);
 
   void received_initialize_data (const QString& class_name,
                                  const QString& paren, int rows, int cols);
 
 private:
+
   /** Get data for ov(row, col)
    * This must be executed in the octave thread!
    */
   void get_data_oct (int row, int col, const std::string& v) /*const*/;
 
   void set_data_oct (const std::string& v, int row, int col,
-                     std::string val);
+                     const std::string& val);
 
   void init_from_oct (const std::string& x);
 
-  void eval_oct (const std::string& name, std::string expr);
+  void eval_oct (const std::string& name, const std::string& expr);
 
   octave_value retrieve_variable (const std::string& x, int& parse_status);
 
   sub_editor_types editor_type (const QModelIndex& idx) const;
 
   Q_DISABLE_COPY (variable_editor_model)
 
   // Change the display if the variable does not exist (Yet)
-  void display_invalid ();
-  // Change the display now that the variable exists
-  void display_valid ();
+  void display_invalid (void);
 
-  QObject *p;
+  // Change the display now that the variable exists
+  void display_valid (void);
+
+  QObject *m_p;
   struct impl;
-  impl *d;
-
+  impl *m_d;
 };
 
 #endif
diff --git a/libgui/src/variable-editor.cc b/libgui/src/variable-editor.cc
--- a/libgui/src/variable-editor.cc
+++ b/libgui/src/variable-editor.cc
@@ -48,171 +48,111 @@ along with Octave; see the file COPYING.
 #include "octave-qt-link.h"
 #include "resource-manager.h"
 #include "variable-editor.h"
 #include "variable-editor-model.h"
 
 #include "operators/ops.h"
 #include "ov.h"
 
-variable_editor::variable_editor (QWidget *p)
-  : octave_dock_widget (p),
-    main (new QMainWindow ()),
-    tool_bar (new QToolBar (main)),
-    tab_widget (new QTabWidget (main)),
-    default_width (20), default_height (100),
-    add_font_height (0),
-    autofit (false), autofit_max (false),
-    use_terminal_font (true), alternate_rows (true),
-    stylesheet (""), font (), sel_font (),
-    table_colors ()
-{
-  // Use a MainWindow
-  setObjectName ("variable_editor");
-  set_title (tr ("Variable Editor"));
-  setStatusTip (tr ("Edit variables."));
-  setWindowIcon (QIcon (":/actions/icons/logo.png"));
-
-  // Tool Bar
-  construct_tool_bar ();
-  main->addToolBar (tool_bar);
-
-  for (int i = 0; i < resource_manager::varedit_color_chars ().length (); i++)
-    table_colors.append (QColor (Qt::white));
-
-  // Tab Widget
-  tab_widget->setTabsClosable (true);
-  tab_widget->setMovable (true);
-  connect (tab_widget, SIGNAL (tabCloseRequested (int)),
-           this, SLOT (closeTab (int)));
-  main->setCentralWidget (tab_widget);
-
-  // Main
-  main->setParent (this);
-  setWidget (main);
-
-  connect (this, SIGNAL (command_requested (const QString&)),
-           p, SLOT (execute_command_in_terminal (const QString&)));
-}
-
-void
-variable_editor::construct_tool_bar ()
-{
-  tool_bar->setObjectName ("VariableEditorToolBar");
-  tool_bar->setWindowTitle (tr ("Variable Editor Toolbar"));
-
-  tool_bar->addAction (resource_manager::icon ("document-save"), tr ("Save"),
-                       this, SLOT (save ()));
-  tool_bar->addSeparator ();
-
-  tool_bar->addAction (resource_manager::icon ("edit-cut"), tr ("Cut"),
-                       this, SLOT (cutClipboard ()));
-  tool_bar->addAction (resource_manager::icon ("edit-copy"), tr ("Copy"),
-                       this, SLOT (copyClipboard ()));
-  tool_bar->addAction (resource_manager::icon ("edit-paste"), tr ("Paste"),
-                       this, SLOT (pasteClipboard ()));
-  // FIXME: Different icon for Paste Table?
-  tool_bar->addAction (resource_manager::icon ("edit-paste"), tr ("Paste Table"),
-                       this, SLOT (pasteTableClipboard ()));
-  tool_bar->addSeparator ();
-
-  // FIXME: Add a print item?
-  //QAction *print_action; /icons/fileprint.png
-  //tool_bar->addSeparator ();
-
-  QToolButton *plot_tool_button = new QToolButton (tool_bar);
-  plot_tool_button->setText (tr ("Plot"));
-  plot_tool_button->setIcon (resource_manager::icon ("applications-system"));
-
-  plot_tool_button->setPopupMode (QToolButton::InstantPopup);
-
-  QMenu *plot_menu = new QMenu (tr ("Plot"), plot_tool_button);
-  plot_menu->setSeparatorsCollapsible (false);
-  QSignalMapper *plot_mapper = new QSignalMapper (plot_menu);
-  plot_mapper->setMapping (plot_menu->addAction ("plot",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                          "figure (); plot (%1);");
-  plot_mapper->setMapping (plot_menu->addAction ("bar",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                          "figure (); bar (%1);");
-  plot_mapper->setMapping (plot_menu->addAction ("stem",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                          "figure (); stem (%1);");
-  plot_mapper->setMapping (plot_menu->addAction ("stairs",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                          "figure (); stairs (%1);");
-  plot_mapper->setMapping (plot_menu->addAction ("area",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                          "figure (); area (%1);");
-  plot_mapper->setMapping (plot_menu->addAction ("pie",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                          "figure (); pie (%1);");
-  plot_mapper->setMapping (plot_menu->addAction ("hist",
-                                                 plot_mapper,
-                                                 SLOT (map ())),
-                          "figure (); hist (%1);");
-  connect (plot_mapper, SIGNAL (mapped (const QString &)),
-           this, SLOT (relay_command (const QString &)));
-
-  plot_tool_button->setMenu (plot_menu);
-  tool_bar->addWidget (plot_tool_button);
-
-  tool_bar->addSeparator ();
-  tool_bar->addAction (QIcon (resource_manager::icon ("go-up")), tr ("Up"),
-                       this, SLOT (up ()));
-
-  tool_bar->setEnabled (false);  // Disabled when no tab is present
-}
-
-// FIXME: Why is there no destructor?  And if there isn't, can this be deleted?
-//variable_editor::~variable_editor () { }
-
 namespace
 {
   // Helper struct to store widget pointers in "data" Tab property.
   struct table_data
   {
     table_data (QTableView *t = nullptr)
-      : table (t)
+      : m_table (t)
     { }
-    QTableView *table;
+
+    QTableView *m_table;
   };
 
   table_data get_table_data (QTabWidget *w, int tidx)
   {
     return w->widget (tidx)->property ("data").value<table_data> ();
   }
 
   table_data get_table_data (QTabWidget *w)
   {
     return get_table_data (w, w->currentIndex ());
   }
 }
+
 Q_DECLARE_METATYPE (table_data)
 
+static
+QString idx_to_expr (int32_t from, int32_t to)
+{
+  if (from == to)
+    return QString ("%1").arg (from + 1);
+  else
+    return QString ("%1:%2").arg (from + 1).arg (to + 1);
+}
+
+variable_editor::variable_editor (QWidget *p)
+  : octave_dock_widget (p),
+    m_main (new QMainWindow ()),
+    m_tool_bar (new QToolBar (m_main)),
+    m_tab_widget (new QTabWidget (m_main)),
+    m_default_width (20), m_default_height (100),
+    m_add_font_height (0),
+    m_autofit (false), m_autofit_max (false),
+    m_use_terminal_font (true), m_alternate_rows (true),
+    m_stylesheet (""), m_font (), m_sel_font (),
+    m_table_colors ()
+{
+  // Use a MainWindow
+  setObjectName ("variable_editor");
+  set_title (tr ("Variable Editor"));
+  setStatusTip (tr ("Edit variables."));
+  setWindowIcon (QIcon (":/actions/icons/logo.png"));
+
+  // Tool Bar
+  construct_tool_bar ();
+  m_main->addToolBar (m_tool_bar);
+
+  for (int i = 0; i < resource_manager::varedit_color_chars ().length (); i++)
+    m_table_colors.append (QColor (Qt::white));
+
+  // Tab Widget
+  m_tab_widget->setTabsClosable (true);
+  m_tab_widget->setMovable (true);
+  connect (m_tab_widget, SIGNAL (tabCloseRequested (int)),
+           this, SLOT (closeTab (int)));
+  m_main->setCentralWidget (m_tab_widget);
+
+  // Main
+  m_main->setParent (this);
+  setWidget (m_main);
+
+  connect (this, SIGNAL (command_requested (const QString&)),
+           p, SLOT (execute_command_in_terminal (const QString&)));
+}
+
+variable_editor::~variable_editor (void)
+{
+  delete m_main;
+  delete m_tool_bar;
+  delete m_tab_widget;
+}
+
 void
-variable_editor::edit_variable (const QString &name)
+variable_editor::edit_variable (const QString& name)
 {
-  if (stylesheet.isEmpty ())
+  if (m_stylesheet.isEmpty ())
     {
       QSettings *settings = resource_manager::get_settings ();
       notice_settings (settings);
     }
 
-  const int tab_count = tab_widget->count ();
+  const int tab_count = m_tab_widget->count ();
   for (int i = 0; i < tab_count; ++i)
-    if (tab_widget->tabText (i) == name)
+    if (m_tab_widget->tabText (i) == name)
       {
-        tab_widget->setCurrentIndex (i);
+        m_tab_widget->setCurrentIndex (i);
         return;  // already open
       }
 
   QWidget *page = new QWidget;  // Do not set parent.
 
   QVBoxLayout *vbox = new QVBoxLayout (page);
   page->setLayout (vbox);
 
@@ -231,114 +171,245 @@ variable_editor::edit_variable (const QS
   table->setSelectionMode (QAbstractItemView::ContiguousSelection);
 
 
   table->horizontalHeader ()->setContextMenuPolicy (Qt::CustomContextMenu);
   table->verticalHeader ()->setContextMenuPolicy (Qt::CustomContextMenu);
 
   connect (table->horizontalHeader (),
            SIGNAL (customContextMenuRequested (const QPoint&)),
-           this, SLOT (columnmenu_requested (const QPoint &)));
+           this, SLOT (columnmenu_requested (const QPoint&)));
   connect (table->verticalHeader (),
            SIGNAL (customContextMenuRequested (const QPoint&)),
-           this, SLOT (rowmenu_requested (const QPoint &)));
+           this, SLOT (rowmenu_requested (const QPoint&)));
   connect (table, SIGNAL (customContextMenuRequested (const QPoint&)),
            this, SLOT (contextmenu_requested (const QPoint&)));
   connect (table, SIGNAL (doubleClicked (const QModelIndex&)),
            this, SLOT (double_click (const QModelIndex&)));
   connect (model, SIGNAL (dataChanged (const QModelIndex&, const QModelIndex&)),
            this, SLOT (callUpdate (const QModelIndex&, const QModelIndex&)));
 
   vbox->addWidget (table);
 
   page->setProperty ("data", QVariant::fromValue (table_data (table)));
-  int tab_idx = tab_widget->addTab (page, name);
-  tab_widget->setCurrentIndex (tab_idx);
+  int tab_idx = m_tab_widget->addTab (page, name);
+  m_tab_widget->setCurrentIndex (tab_idx);
 
-  if (tab_widget->count () == 1)
-    tool_bar->setEnabled (true);  // This is the first tab -> enable tool bar
+  if (m_tab_widget->count () == 1)
+    m_tool_bar->setEnabled (true);  // This is the first tab -> enable tool bar
 
-  if (autofit)
+  if (m_autofit)
     {
       table->resizeColumnsToContents ();
-      if (autofit_max)
+      if (m_autofit_max)
         {
           int mx = 0;
           for (int i = 0; i < table->model ()->columnCount (); i++)
             {
               if (table->columnWidth (i) > mx)
                 mx = table->columnWidth (i);
             }
           table->horizontalHeader ()->setDefaultSectionSize (mx);
         }
     }
   else
     {
-      table->horizontalHeader ()->setDefaultSectionSize (default_width);
+      table->horizontalHeader ()->setDefaultSectionSize (m_default_width);
     }
-  table->setFont (font);
-  table->setStyleSheet (stylesheet);
-  table->setAlternatingRowColors (alternate_rows);
+  table->setFont (m_font);
+  table->setStyleSheet (m_stylesheet);
+  table->setAlternatingRowColors (m_alternate_rows);
 #if defined (HAVE_QT4)
   table->verticalHeader ()->setResizeMode (QHeaderView::Interactive);
 #else
   table->verticalHeader ()->setSectionResizeMode (QHeaderView::Interactive);
 #endif
-  table->verticalHeader ()->setDefaultSectionSize (default_height
-                                                   + add_font_height);
+  table->verticalHeader ()->setDefaultSectionSize (m_default_height
+                                                   + m_add_font_height);
+}
+
+void variable_editor::clear_data_cache (void)
+{
+  for (int i = 0; i < m_tab_widget->count (); ++i)
+    {
+      QTableView *const table = get_table_data (m_tab_widget, i).m_table;
+      QAbstractItemModel *const model = table->model ();
+      qobject_cast<variable_editor_model *> (model)->clear_data_cache ();
+    }
+}
+
+bool
+variable_editor::has_focus (void)
+{
+  // FIXME: This only generates exceptions in certain circumstances.
+  //        Get a definitive list and eliminate the need to handle exceptions.
+  if (m_tab_widget->currentIndex () == -1)
+    return false;  // No tabs
+
+  try
+    {
+      QTableView *view = get_table_data (m_tab_widget).m_table;
+      if (view)
+        return view->hasFocus ();
+
+      return false;
+    }
+  catch (...)
+    {
+      return false;
+    }
+
+  return false;
+}
+
+QList<QColor> variable_editor::default_colors (void)
+{
+  QList<QColor> colorlist;
+
+  colorlist << qApp->palette ().color (QPalette::WindowText);
+  colorlist << qApp->palette ().color (QPalette::Base);
+  colorlist << qApp->palette ().color (QPalette::HighlightedText);
+  colorlist << qApp->palette ().color (QPalette::Highlight);
+  colorlist << qApp->palette ().color (QPalette::AlternateBase);
+
+  return colorlist;
+}
+
+QStringList variable_editor::color_names (void)
+{
+  QStringList output;
+
+  output << "Foreground";
+  output << "Background";
+  output << "Selected Foreground";
+  output << "Selected Background";
+  output << "Alternate Background";
+
+  return output;
 }
 
 void
 variable_editor::callUpdate (const QModelIndex&, const QModelIndex&)
 {
-  if (autofit)
+  if (m_autofit)
     {
-      QTableView *view = get_table_data (tab_widget).table;
+      QTableView *view = get_table_data (m_tab_widget).m_table;
       view->resizeColumnsToContents ();
-      if (autofit_max)
+      if (m_autofit_max)
         {
           int mx = 0;
           for (int i = 0; i < view->model ()->columnCount (); i++)
             {
               if (view->columnWidth (i) > mx)
                 mx = view->columnWidth (i);
             }
           view->horizontalHeader ()->setDefaultSectionSize (mx);
         }
 
     }
 
   emit updated ();
 }
 
-void
-variable_editor::closeTab (int idx)
+void variable_editor::notice_settings (const QSettings *settings)
 {
-  if (idx < 0 || idx > tab_widget->count ())
-    return;
+  // FIXME: Why use object->tostring->toint?  Why not just 100?
+  m_default_width = settings->value ("variable_editor/column_width",
+                                     QVariant ("100")).toString ().toInt ();
+  m_autofit = settings->value ("variable_editor/autofit_column_width",
+                               QVariant (false)).toBool ();
+  // FIXME: Magic Number 1 here, why not use enum?
+  if (m_autofit)
+    {
+      if (settings->value ("variable_editor/autofit_type", 0).toInt () == 1)
+        m_autofit_max = true;
+    }
+
+  m_default_height = settings->value ("variable_editor/row_height",
+                                    QVariant ("10")).toString ().toInt ();
+  m_alternate_rows = settings->value ("variable_editor/alternate_rows",
+                                    QVariant (false)).toBool ();
+
+  QList<QColor> _default_colors = resource_manager::varedit_default_colors ();
+  QString class_chars = resource_manager::varedit_color_chars ();
+
+  m_use_terminal_font = settings->value ("variable_editor/use_terminal_font", true).toBool ();
+
+  QString font_name;
+  int font_size;
 
-  QWidget *const wdgt = tab_widget->widget (idx);
-  tab_widget->removeTab (idx);
-  delete wdgt;
+  if (m_use_terminal_font)
+    {
+      font_name = settings->value ("terminal/fontName", "").toString ();
+      font_size = settings->value ("terminal/fontSize", 10).toInt ();
+    }
+  else
+    {
+      font_name = settings->value ("variable_editor/font_name", "").toString ();
+      font_size = settings->value ("variable_editor/font_size", 10).toInt ();
+    }
+  m_font = QFont (font_name, font_size);
+
+  if (settings->value ("variable_editor/autofit_row_height", false).toBool ())
+    {
+      QFontMetrics fm (m_font);
+      m_add_font_height = fm.height ();
+    }
+  else
+    m_add_font_height = 0;
 
-  if (tab_widget->count () == 0)
-    tool_bar->setEnabled (false);  // This was the last tab, disable tool bar.
+  for (int i = 0; i < class_chars.length (); i++)
+    {
+      QVariant default_var = _default_colors.at (i);
+      QColor setting_color = settings->value ("variable_editor/color_"
+                                              + class_chars.mid (i, 1),
+                                              default_var).value<QColor> ();
+      m_table_colors.replace (i, setting_color);
+    }
+  update_colors ();
+
+  // Icon size in the toolbar
+  int icon_size_settings = settings->value ("toolbar_icon_size", 0).toInt ();
+  QStyle *st = style ();
+  int icon_size = st->pixelMetric (QStyle::PM_ToolBarIconSize);
+
+  // FIXME: Magic numbers.  Use enum?
+  if (icon_size_settings == 1)
+    icon_size = st->pixelMetric (QStyle::PM_LargeIconSize);
+  else if (icon_size_settings == -1)
+    icon_size = st->pixelMetric (QStyle::PM_SmallIconSize);
+
+  m_tool_bar->setIconSize (QSize (icon_size, icon_size));
 }
 
 void
 variable_editor::closeEvent (QCloseEvent *e)
 {
   emit finished ();
   octave_dock_widget::closeEvent (e);
 }
 
 void
-variable_editor::contextmenu_requested (const QPoint &qpos)
+variable_editor::closeTab (int idx)
 {
-  QTableView *view = get_table_data (tab_widget).table;
+  if (idx < 0 || idx > m_tab_widget->count ())
+    return;
+
+  QWidget *const wdgt = m_tab_widget->widget (idx);
+  m_tab_widget->removeTab (idx);
+  delete wdgt;
+
+  if (m_tab_widget->count () == 0)
+    m_tool_bar->setEnabled (false);  // This was the last tab, disable tool bar.
+}
+
+void
+variable_editor::contextmenu_requested (const QPoint& qpos)
+{
+  QTableView *view = get_table_data (m_tab_widget).m_table;
   QModelIndex index = view->indexAt (qpos);
 
   if (index.isValid ())
     {
       QMenu *menu = new QMenu (this);
       menu->addAction (resource_manager::icon ("edit-cut"), tr ("Cut"),
                        this, SLOT (cutClipboard ()));
       menu->addAction (resource_manager::icon ("edit-copy"), tr ("Copy"),
@@ -365,140 +436,53 @@ variable_editor::contextmenu_requested (
       QList<QModelIndex> indices = sel->selectedIndexes ();
       if (! indices.isEmpty ())
         {
           menu->addSeparator ();
           QSignalMapper *plot_mapper = new QSignalMapper (menu);
           plot_mapper->setMapping (menu->addAction ("plot",
                                                     plot_mapper,
                                                     SLOT (map ())),
-                                  "figure (); plot (%1);");
+                                   "figure (); plot (%1);");
           plot_mapper->setMapping (menu->addAction ("bar",
                                                     plot_mapper,
                                                     SLOT (map ())),
-                                  "figure (); bar (%1);");
+                                   "figure (); bar (%1);");
           plot_mapper->setMapping (menu->addAction ("stem",
                                                     plot_mapper,
                                                     SLOT (map ())),
-                                  "figure (); stem (%1);");
+                                   "figure (); stem (%1);");
           plot_mapper->setMapping (menu->addAction ("stairs",
                                                     plot_mapper,
                                                     SLOT (map ())),
-                                  "figure (); stairs (%1);");
+                                   "figure (); stairs (%1);");
           plot_mapper->setMapping (menu->addAction ("area",
                                                     plot_mapper,
                                                     SLOT (map ())),
-                                  "figure (); area (%1);");
+                                   "figure (); area (%1);");
           plot_mapper->setMapping (menu->addAction ("pie",
                                                     plot_mapper,
                                                     SLOT (map ())),
-                                  "figure (); pie (%1);");
+                                   "figure (); pie (%1);");
           plot_mapper->setMapping (menu->addAction ("hist",
                                                     plot_mapper,
                                                     SLOT (map ())),
-                                  "figure (); hist (%1);");
-          connect (plot_mapper, SIGNAL (mapped (const QString &)),
-                   this, SLOT (relay_command (const QString &)));
+                                   "figure (); hist (%1);");
+          connect (plot_mapper, SIGNAL (mapped (const QString&)),
+                   this, SLOT (relay_command (const QString&)));
         }
 
       menu->exec (view->mapToGlobal (qpos));
     }
 }
 
-QList<int>
-variable_editor::octave_to_coords (QString& selection)
+void
+variable_editor::columnmenu_requested (const QPoint& pt)
 {
-  // FIXME: Is this necessary or would it be quicker to clone the function that
-  // gives us the QString?
-
-  // sanity check
-  if (selection.count (",") != 1)
-    return QList<int> ();
-
-  QList<int> output;
-  output.clear ();
-  // remove braces
-  int firstbracket = std::max (selection.indexOf ("("),
-                               selection.indexOf ("{"));
-  selection = selection.mid (firstbracket + 1,
-                             selection.length () - (firstbracket + 2));
-
-  QString rows = selection.left (selection.indexOf (","));
-  if (! rows.contains (":"))
-    {
-      // Only one row
-      output.push_back (rows.toInt ());
-      output.push_back (output.last ());
-    }
-  else
-    {
-      output.push_back (rows.left (rows.indexOf (":")).toInt ());
-      output.push_back (rows.right (rows.length () - (rows.indexOf (":") + 1))
-                                   .toInt ());
-    }
-
-  QString cols;
-  cols = selection.right (selection.length () - (selection.indexOf (",") + 1));
-  if (cols.left (1) == " ")
-    cols = cols.right (cols.length () - 1);
-
-  if (! cols.contains (":"))
-    {
-      // Only one row
-      output.push_back (cols.toInt ());
-      output.push_back (output.last ());
-    }
-  else
-    {
-      output.push_back (cols.left (cols.indexOf (":")).toInt ());
-      output.push_back (cols.right (cols.length () - (cols.indexOf (":") + 1))
-                                   .toInt ());
-    }
-
-  return output;
-}
-
-void
-variable_editor::delete_selected ()
-{
-  QTableView *view = get_table_data (tab_widget).table;
-  QString selection = selected_to_octave ();
-  QList<int> coords = octave_to_coords (selection);
-
-  if (coords.isEmpty ())
-    return;
-
-  bool whole_columns_selected = coords[0] == 1
-                                && coords[1] == view->model ()->rowCount ();
-  bool whole_rows_selected = coords[2] == 1
-                             && coords[3] == view->model ()->columnCount ();
-
-  emit command_requested (QString ("disp ('")
-                          + QString::number (coords[0]) + ","
-                          + QString::number (coords[1]) + ","
-                          + QString::number (coords[2]) + ","
-                          + QString::number (coords[3]) + "');");
-
-  // Must be deleting whole columns or whole rows, and not the whole thing.
-  if (whole_columns_selected == whole_rows_selected)  // all or nothing
-    return;
-
-  if (whole_rows_selected)
-    view->model ()->removeRows (coords[0], coords[1] - coords[0]);
-
-  if (whole_columns_selected)
-    view->model ()->removeColumns (coords[2], coords[3] - coords[2]);
-
-  emit updated ();
-}
-
-void
-variable_editor::columnmenu_requested (const QPoint &pt)
-{
-  QTableView *view = get_table_data (tab_widget).table;
+  QTableView *view = get_table_data (m_tab_widget).m_table;
 
   int index = view->horizontalHeader ()->logicalIndexAt (pt);
 
   //emit command_requested (QString ("disp ('") + QString::number (index) + "');");
 
   if (index < 0 || index > view->model ()->columnCount ())
     return;
 
@@ -506,18 +490,18 @@ variable_editor::columnmenu_requested (c
   QList<int> coords = octave_to_coords (selection);
 
   bool nothingSelected = false;
   if (coords.isEmpty ())
     nothingSelected = true;
 
   bool whole_columns_selected =
     nothingSelected ? false
-                    : (coords[0] == 1
-                       && coords[1] == view->model ()->rowCount ());
+    : (coords[0] == 1
+       && coords[1] == view->model ()->rowCount ());
 
   bool current_column_selected =
     nothingSelected ? false : (coords[2] <= index+1 && coords[3] > index);
 
   int column_selection_count =
     nothingSelected ? 0 : (coords[3] - coords[2] + 1);
 
   if (! whole_columns_selected || ! current_column_selected)
@@ -584,29 +568,29 @@ variable_editor::columnmenu_requested (c
   plot_mapper->setMapping (menu->addAction ("pie",
                                             plot_mapper,
                                             SLOT (map ())),
                            "figure (); pie (%1);");
   plot_mapper->setMapping (menu->addAction ("hist",
                                             plot_mapper,
                                             SLOT (map ())),
                            "figure (); hist (%1);");
-  connect (plot_mapper, SIGNAL (mapped (const QString &)),
-           this, SLOT (relay_command (const QString &)));
+  connect (plot_mapper, SIGNAL (mapped (const QString&)),
+           this, SLOT (relay_command (const QString&)));
 
   QPoint menupos = pt;
   menupos.setY (view->horizontalHeader ()->height ());
 
   menu->exec (view->mapToGlobal (menupos));
 }
 
 void
-variable_editor::rowmenu_requested (const QPoint &pt)
+variable_editor::rowmenu_requested (const QPoint& pt)
 {
-  QTableView *view = get_table_data (tab_widget).table;
+  QTableView *view = get_table_data (m_tab_widget).m_table;
 
   int index = view->verticalHeader ()->logicalIndexAt (pt);
 
   //emit command_requested (QString ("disp ('") + QString::number (index) + "');");
 
   if (index < 0 || index > view->model ()->columnCount ())
     return;
 
@@ -616,22 +600,22 @@ variable_editor::rowmenu_requested (cons
   bool nothingSelected;
   if (coords.isEmpty ())
     nothingSelected = true;
   else
     nothingSelected = false;
 
   bool whole_rows_selected =
     nothingSelected ? false
-                    : (coords[2] == 1
-                       && coords[3] == view->model ()->columnCount ());
+    : (coords[2] == 1
+       && coords[3] == view->model ()->columnCount ());
 
   bool current_row_selected =
     nothingSelected ? false
-                    : (coords[0] <= index+1 && coords[1] > index);
+    : (coords[0] <= index+1 && coords[1] > index);
 
   int rowselection_count = nothingSelected ? 0 : (coords[3] - coords[2] + 1);
 
   if (! whole_rows_selected || ! current_row_selected)
     {
       view->selectRow (index);
       rowselection_count = 1;
       current_row_selected = true;
@@ -693,144 +677,97 @@ variable_editor::rowmenu_requested (cons
   plot_mapper->setMapping (menu->addAction ("pie",
                                             plot_mapper,
                                             SLOT (map ())),
                            "figure (); pie (%1);");
   plot_mapper->setMapping (menu->addAction ("hist",
                                             plot_mapper,
                                             SLOT (map ())),
                            "figure (); hist (%1);");
-  connect (plot_mapper, SIGNAL (mapped (const QString &)),
-           this, SLOT (relay_command (const QString &)));
+  connect (plot_mapper, SIGNAL (mapped (const QString&)),
+           this, SLOT (relay_command (const QString&)));
 
   QPoint menupos = pt;
   menupos.setX (view->verticalHeader ()->width ());
   //setY (view->verticalHeader ()->sectionPosition (index+1) +
   //             view->verticalHeader ()->sectionSize (index));
 
   menu->exec (view->mapToGlobal (menupos));
 }
 
-static
-QString idx_to_expr (int32_t from, int32_t to)
-{
-  if (from == to)
-    return QString ("%1").arg (from + 1);
-  else
-    return QString ("%1:%2").arg (from + 1).arg (to + 1);
-}
-
-QString
-variable_editor::selected_to_octave ()
+void
+variable_editor::double_click (const QModelIndex& idx)
 {
-  QString name = tab_widget->tabText (tab_widget->currentIndex ());
-  QTableView *view = get_table_data (tab_widget).table;
-  QItemSelectionModel *sel = view->selectionModel ();
-
-  if (! sel->hasSelection ())
-    return name;  // Nothing selected
-
-  QList<QModelIndex> indices = sel->selectedIndexes ();  // it's indices!
-
-  int32_t from_row = std::numeric_limits<int32_t>::max ();
-  int32_t to_row = 0;
-  int32_t from_col = std::numeric_limits<int32_t>::max ();
-  int32_t to_col = 0;
-
-  for (const auto& idx : indices)
-    {
-      from_row = std::min (from_row, idx.row ());
-      to_row = std::max (to_row, idx.row ());
-      from_col = std::min (from_col, idx.column ());
-      to_col = std::max (to_col, idx.column ());
-    }
-
-  QString rows = idx_to_expr (from_row, to_row);
-  QString cols = idx_to_expr (from_col, to_col);
-
-  // FIXME: Cells?
-  return QString ("%1 (%2, %3)").arg (name).arg (rows).arg (cols);
-}
-
-void
-variable_editor::double_click (const QModelIndex &idx)
-{
-  QString name = tab_widget->tabText (tab_widget->currentIndex ());
-  QTableView *const table = get_table_data (tab_widget).table;
+  QString name = m_tab_widget->tabText (m_tab_widget->currentIndex ());
+  QTableView *const table = get_table_data (m_tab_widget).m_table;
   variable_editor_model *const model =
     qobject_cast<variable_editor_model *> (table->model ());
   if (model->requires_sub_editor (idx))
     {
       if (model ->editor_type_matrix (idx))
         edit_variable (name +
-                      model->parens ()
-                      .arg (idx.row () + 1)
-                      .arg (idx.column () + 1));
+                       model->parens ()
+                       .arg (idx.row () + 1)
+                       .arg (idx.column () + 1));
       /*        emit command_requested ("openvar ('" + name +
-                                      model->parens ()
-                                      .arg (idx.row () + 1)
-                                      .arg (idx.column () + 1)
-                                      + "');");
+                model->parens ()
+                .arg (idx.row () + 1)
+                .arg (idx.column () + 1)
+                + "');");
       */
 
     }
 }
 
 void
-variable_editor::relay_command (const QString &cmd)
+variable_editor::save (void)
 {
-  emit command_requested (cmd.arg (selected_to_octave ()));
-}
-
-void
-variable_editor::save ()
-{
-  QString name = tab_widget->tabText (tab_widget->currentIndex ());
+  QString name = m_tab_widget->tabText (m_tab_widget->currentIndex ());
   QString file =
     QFileDialog::getSaveFileName (this,
                                   tr ("Save Variable %1 As").arg (name),
                                   ".", 0, 0,
                                   QFileDialog::DontUseNativeDialog);
   // FIXME: Type? binary, float-binary, ascii, text, hdf5, matlab format?
   if (! file.isEmpty ())
     // FIXME: Use octave_value::save_*?
     emit command_requested (QString ("save ('%1', '%2');")
                             .arg (file)
                             .arg (name));
 }
 
 void
-variable_editor::clearContent ()
+variable_editor::clearContent (void)
 {
   // FIXME: shift?
-  QTableView *view = get_table_data (tab_widget).table;
+  QTableView *view = get_table_data (m_tab_widget).m_table;
   QAbstractItemModel *model = view->model ();
   QItemSelectionModel *sel = view->selectionModel ();
   QList<QModelIndex> indices = sel->selectedIndexes ();
   for (const auto& idx : indices)
     model->setData (idx, QVariant ("0"));  // FIXME: Use [] for empty cells
 }
 
 void
-variable_editor::cutClipboard ()
+variable_editor::cutClipboard (void)
 {
   if (! has_focus ())
     return;
 
   copyClipboard ();
   clearContent ();
 }
 
 void
-variable_editor::copyClipboard ()
+variable_editor::copyClipboard (void)
 {
   if (! has_focus ())
     return;
 
-  QTableView *view = get_table_data (tab_widget).table;
+  QTableView *view = get_table_data (m_tab_widget).m_table;
   QAbstractItemModel *model = view->model ();
   QItemSelectionModel *sel = view->selectionModel ();
   QList<QModelIndex> indices = sel->selectedIndexes ();
   qSort (indices);
   if (indices.isEmpty ())
     return;
 
   // Convert selected items into TSV format and copy that.
@@ -845,51 +782,27 @@ variable_editor::copyClipboard ()
       previous = idx;
     }
   copy.push_back ('\n');
 
   QClipboard *clipboard = QApplication::clipboard ();
   clipboard->setText (copy);
 }
 
-bool
-variable_editor::has_focus ()
-{
-  // FIXME: This only generates exceptions in certain circumstances.
-  //        Get a definitive list and eliminate the need to handle exceptions.
-  if (tab_widget->currentIndex () == -1)
-    return false;  // No tabs
-
-  try
-    {
-      QTableView *view = get_table_data (tab_widget).table;
-      if (view)
-        return view->hasFocus ();
-
-      return false;
-    }
-  catch (...)
-    {
-      return false;
-    }
-
-  return false;
-}
-
 void
-variable_editor::pasteClipboard ()
+variable_editor::pasteClipboard (void)
 {
   // FIXME: ???
   if (! has_focus ())
     return;
 
   QClipboard *clipboard = QApplication::clipboard ();
   QString text = clipboard->text ();
 
-  QTableView *view = get_table_data (tab_widget).table;
+  QTableView *view = get_table_data (m_tab_widget).m_table;
   QItemSelectionModel *sel = view->selectionModel ();
   QList<QModelIndex> indices = sel->selectedIndexes ();
 
   variable_editor_model *model
     = static_cast<variable_editor_model *> (view->model ());
 
   if (indices.isEmpty ())
     {
@@ -908,25 +821,25 @@ variable_editor::pasteClipboard ()
     {
       for (int i = 0; i < indices.size (); i++)
         view->model ()->setData (indices[i], text.toDouble ());
     }
 
   emit updated ();
 }
 
-void variable_editor::pasteTableClipboard ()
+void variable_editor::pasteTableClipboard (void)
 {
   if (! has_focus ())
     return;
 
   QClipboard *clipboard = QApplication::clipboard ();
   QString text = clipboard->text ();
 
-  QTableView *view = get_table_data (tab_widget).table;
+  QTableView *view = get_table_data (m_tab_widget).m_table;
   QItemSelectionModel *sel = view->selectionModel ();
   QList<QModelIndex> indices = sel->selectedIndexes ();
 
   variable_editor_model *model =
     static_cast<variable_editor_model *> (view->model ());
 
   QPoint start, end;
 
@@ -983,186 +896,279 @@ void variable_editor::pasteTableClipboar
             continue;
           if (colnum > end.y () - start.y () )
             continue;
 
           model->setData (model->index (rownum + start.x (),
                                         colnum + start.y ()),
                           QVariant (col));
 
-//          relay_command ("disp ('" + QString::number (colnum+start.y ()) + "," + QString::number (rownum+start.x ()) +"');");
+          //          relay_command ("disp ('" + QString::number (colnum+start.y ()) + "," + QString::number (rownum+start.x ()) +"');");
           colnum++;
         }
       colnum = 0;
       rownum++;
     }
 
   emit updated ();
 }
 
 void
-variable_editor::createVariable ()
+variable_editor::createVariable (void)
 {
   // FIXME: unnamed1..n if exist ('unnamed', 'var')
   relay_command ("unnamed = %1");
 }
 
 void
-variable_editor::transposeContent ()
+variable_editor::transposeContent (void)
 {
-  QString name = tab_widget->tabText (tab_widget->currentIndex ());
+  QString name = m_tab_widget->tabText (m_tab_widget->currentIndex ());
   emit command_requested (QString ("%1 = %1';").arg (name));
   emit updated ();
 }
 
 void
-variable_editor::up ()
+variable_editor::up (void)
 {
-  QString name = tab_widget->tabText (tab_widget->currentIndex ());
+  QString name = m_tab_widget->tabText (m_tab_widget->currentIndex ());
   // FIXME: is there a better way?
   if (name.endsWith (')') || name.endsWith ('}'))
     {
       qDebug () << "up";
       name.remove (QRegExp ("(\\(|\\{)[^({]*(\\)|\\})$"));
       edit_variable (name);
       //emit command_requested (QString ("openvar ('%1');").arg (name));
     }
 }
 
-void variable_editor::clear_data_cache ()
+void
+variable_editor::delete_selected (void)
 {
-  for (int i = 0; i < tab_widget->count (); ++i)
-    {
-      QTableView *const table = get_table_data (tab_widget, i).table;
-      QAbstractItemModel *const model = table->model ();
-      qobject_cast<variable_editor_model *> (model)->clear_data_cache ();
-    }
+  QTableView *view = get_table_data (m_tab_widget).m_table;
+  QString selection = selected_to_octave ();
+  QList<int> coords = octave_to_coords (selection);
+
+  if (coords.isEmpty ())
+    return;
+
+  bool whole_columns_selected = coords[0] == 1
+    && coords[1] == view->model ()->rowCount ();
+  bool whole_rows_selected = coords[2] == 1
+    && coords[3] == view->model ()->columnCount ();
+
+  emit command_requested (QString ("disp ('")
+                          + QString::number (coords[0]) + ","
+                          + QString::number (coords[1]) + ","
+                          + QString::number (coords[2]) + ","
+                          + QString::number (coords[3]) + "');");
+
+  // Must be deleting whole columns or whole rows, and not the whole thing.
+  if (whole_columns_selected == whole_rows_selected)  // all or nothing
+    return;
+
+  if (whole_rows_selected)
+    view->model ()->removeRows (coords[0], coords[1] - coords[0]);
+
+  if (whole_columns_selected)
+    view->model ()->removeColumns (coords[2], coords[3] - coords[2]);
+
+  emit updated ();
 }
 
-void variable_editor::notice_settings (const QSettings *settings)
+void
+variable_editor::relay_command (const QString& cmd)
 {
-  // FIXME: Why use object->tostring->toint?  Why not just 100?
-  default_width = settings->value ("variable_editor/column_width",
-                                   QVariant ("100")).toString ().toInt ();
-  autofit = settings->value ("variable_editor/autofit_column_width",
-                             QVariant (false)).toBool ();
-  // FIXME: Magic Number 1 here, why not use enum?
-  if (autofit)
-    {
-      if (settings->value ("variable_editor/autofit_type", 0).toInt () == 1)
-        autofit_max = true;
-    }
+  emit command_requested (cmd.arg (selected_to_octave ()));
+}
+
+QList<int>
+variable_editor::octave_to_coords (QString& selection)
+{
+  // FIXME: Is this necessary or would it be quicker to clone the function that
+  // gives us the QString?
 
-  default_height = settings->value ("variable_editor/row_height",
-                                    QVariant ("10")).toString ().toInt ();
-  alternate_rows = settings->value ("variable_editor/alternate_rows",
-                                    QVariant (false)).toBool ();
-
-  QList<QColor> _default_colors = resource_manager::varedit_default_colors ();
-  QString class_chars = resource_manager::varedit_color_chars ();
+  // sanity check
+  if (selection.count (",") != 1)
+    return QList<int> ();
 
-  use_terminal_font = settings->value ("variable_editor/use_terminal_font", true).toBool ();
-
-  QString font_name;
-  int font_size;
+  QList<int> output;
+  output.clear ();
+  // remove braces
+  int firstbracket = std::max (selection.indexOf ("("),
+                               selection.indexOf ("{"));
+  selection = selection.mid (firstbracket + 1,
+                             selection.length () - (firstbracket + 2));
 
-  if (use_terminal_font)
+  QString rows = selection.left (selection.indexOf (","));
+  if (! rows.contains (":"))
     {
-      font_name = settings->value ("terminal/fontName", "").toString ();
-      font_size = settings->value ("terminal/fontSize", 10).toInt ();
+      // Only one row
+      output.push_back (rows.toInt ());
+      output.push_back (output.last ());
     }
   else
     {
-      font_name = settings->value ("variable_editor/font_name", "").toString ();
-      font_size = settings->value ("variable_editor/font_size", 10).toInt ();
+      output.push_back (rows.left (rows.indexOf (":")).toInt ());
+      output.push_back (rows.right (rows.length () - (rows.indexOf (":") + 1))
+                        .toInt ());
     }
-  font = QFont (font_name, font_size);
 
-  if (settings->value ("variable_editor/autofit_row_height", false).toBool ())
+  QString cols;
+  cols = selection.right (selection.length () - (selection.indexOf (",") + 1));
+  if (cols.left (1) == " ")
+    cols = cols.right (cols.length () - 1);
+
+  if (! cols.contains (":"))
     {
-      QFontMetrics fm (font);
-      add_font_height = fm.height ();
+      // Only one row
+      output.push_back (cols.toInt ());
+      output.push_back (output.last ());
     }
   else
-    add_font_height = 0;
+    {
+      output.push_back (cols.left (cols.indexOf (":")).toInt ());
+      output.push_back (cols.right (cols.length () - (cols.indexOf (":") + 1))
+                        .toInt ());
+    }
+
+  return output;
+}
 
-  for (int i = 0; i < class_chars.length (); i++)
-    {
-      QVariant default_var = _default_colors.at (i);
-      QColor setting_color = settings->value ("variable_editor/color_"
-                                              + class_chars.mid (i, 1),
-                                              default_var).value<QColor> ();
-      table_colors.replace (i, setting_color);
-    }
-  update_colors ();
+QString
+variable_editor::selected_to_octave (void)
+{
+  QString name = m_tab_widget->tabText (m_tab_widget->currentIndex ());
+  QTableView *view = get_table_data (m_tab_widget).m_table;
+  QItemSelectionModel *sel = view->selectionModel ();
+
+  if (! sel->hasSelection ())
+    return name;  // Nothing selected
 
-  // Icon size in the toolbar
-  int icon_size_settings = settings->value ("toolbar_icon_size", 0).toInt ();
-  QStyle *st = style ();
-  int icon_size = st->pixelMetric (QStyle::PM_ToolBarIconSize);
+  QList<QModelIndex> indices = sel->selectedIndexes ();  // it's indices!
+
+  int32_t from_row = std::numeric_limits<int32_t>::max ();
+  int32_t to_row = 0;
+  int32_t from_col = std::numeric_limits<int32_t>::max ();
+  int32_t to_col = 0;
 
-  // FIXME: Magic numbers.  Use enum?
-  if (icon_size_settings == 1)
-    icon_size = st->pixelMetric (QStyle::PM_LargeIconSize);
-  else if (icon_size_settings == -1)
-    icon_size = st->pixelMetric (QStyle::PM_SmallIconSize);
+  for (const auto& idx : indices)
+    {
+      from_row = std::min (from_row, idx.row ());
+      to_row = std::max (to_row, idx.row ());
+      from_col = std::min (from_col, idx.column ());
+      to_col = std::max (to_col, idx.column ());
+    }
 
-  tool_bar->setIconSize (QSize (icon_size, icon_size));
+  QString rows = idx_to_expr (from_row, to_row);
+  QString cols = idx_to_expr (from_col, to_col);
+
+  // FIXME: Cells?
+  return QString ("%1 (%2, %3)").arg (name).arg (rows).arg (cols);
 }
 
 /// Also updates the font
-void variable_editor::update_colors ()
+void variable_editor::update_colors (void)
 {
-  stylesheet = "";
-  stylesheet += "QTableView::item{ foreground-color: "
-                + table_colors[0].name () +" }";
-  stylesheet += "QTableView::item{ background-color: "
-                + table_colors[1].name () +" }";
-  stylesheet += "QTableView::item{ selection-color: "
-                + table_colors[2].name () +" }";
-  stylesheet += "QTableView::item:selected{ background-color: "
-                + table_colors[3].name () +" }";
-  if (table_colors.length () > 4 && alternate_rows)
+  m_stylesheet = "";
+  m_stylesheet += "QTableView::item{ foreground-color: "
+    + m_table_colors[0].name () +" }";
+  m_stylesheet += "QTableView::item{ background-color: "
+    + m_table_colors[1].name () +" }";
+  m_stylesheet += "QTableView::item{ selection-color: "
+    + m_table_colors[2].name () +" }";
+  m_stylesheet += "QTableView::item:selected{ background-color: "
+    + m_table_colors[3].name () +" }";
+  if (m_table_colors.length () > 4 && m_alternate_rows)
     {
-      stylesheet += "QTableView::item:alternate{ background-color: "
-                    + table_colors[4].name () +" }";
-      stylesheet += "QTableView::item:alternate:selected{ background-color: "
-                    + table_colors[3].name () +" }";
+      m_stylesheet += "QTableView::item:alternate{ background-color: "
+        + m_table_colors[4].name () +" }";
+      m_stylesheet += "QTableView::item:alternate:selected{ background-color: "
+        + m_table_colors[3].name () +" }";
     }
 
-  if (tab_widget->count () < 1)
+  if (m_tab_widget->count () < 1)
     return;
 
-  for (int i=0; i < tab_widget->count (); i++)
+  for (int i=0; i < m_tab_widget->count (); i++)
     {
-      QTableView *view = get_table_data (tab_widget).table;
-      view->setAlternatingRowColors (alternate_rows);
-      view->setStyleSheet (stylesheet);
-      view->setFont (font);
+      QTableView *view = get_table_data (m_tab_widget).m_table;
+      view->setAlternatingRowColors (m_alternate_rows);
+      view->setStyleSheet (m_stylesheet);
+      view->setFont (m_font);
     }
 
 }
 
-QStringList variable_editor::color_names ()
+void
+variable_editor::construct_tool_bar (void)
 {
-  QStringList output;
+  m_tool_bar->setObjectName ("VariableEditorToolBar");
+  m_tool_bar->setWindowTitle (tr ("Variable Editor Toolbar"));
+
+  m_tool_bar->addAction (resource_manager::icon ("document-save"), tr ("Save"),
+                         this, SLOT (save ()));
+  m_tool_bar->addSeparator ();
 
-  output << "Foreground";
-  output << "Background";
-  output << "Selected Foreground";
-  output << "Selected Background";
-  output << "Alternate Background";
+  m_tool_bar->addAction (resource_manager::icon ("edit-cut"), tr ("Cut"),
+                         this, SLOT (cutClipboard ()));
+  m_tool_bar->addAction (resource_manager::icon ("edit-copy"), tr ("Copy"),
+                         this, SLOT (copyClipboard ()));
+  m_tool_bar->addAction (resource_manager::icon ("edit-paste"), tr ("Paste"),
+                         this, SLOT (pasteClipboard ()));
+  // FIXME: Different icon for Paste Table?
+  m_tool_bar->addAction (resource_manager::icon ("edit-paste"), tr ("Paste Table"),
+                         this, SLOT (pasteTableClipboard ()));
+  m_tool_bar->addSeparator ();
 
-  return output;
-}
+  // FIXME: Add a print item?
+  //QAction *print_action; /icons/fileprint.png
+  //m_tool_bar->addSeparator ();
+
+  QToolButton *plot_tool_button = new QToolButton (m_tool_bar);
+  plot_tool_button->setText (tr ("Plot"));
+  plot_tool_button->setIcon (resource_manager::icon ("applications-system"));
+
+  plot_tool_button->setPopupMode (QToolButton::InstantPopup);
 
-QList<QColor> variable_editor::default_colors ()
-{
-  QList<QColor> colorlist;
+  QMenu *plot_menu = new QMenu (tr ("Plot"), plot_tool_button);
+  plot_menu->setSeparatorsCollapsible (false);
+  QSignalMapper *plot_mapper = new QSignalMapper (plot_menu);
+  plot_mapper->setMapping (plot_menu->addAction ("plot",
+                                                 plot_mapper,
+                                                 SLOT (map ())),
+                           "figure (); plot (%1);");
+  plot_mapper->setMapping (plot_menu->addAction ("bar",
+                                                 plot_mapper,
+                                                 SLOT (map ())),
+                           "figure (); bar (%1);");
+  plot_mapper->setMapping (plot_menu->addAction ("stem",
+                                                 plot_mapper,
+                                                 SLOT (map ())),
+                           "figure (); stem (%1);");
+  plot_mapper->setMapping (plot_menu->addAction ("stairs",
+                                                 plot_mapper,
+                                                 SLOT (map ())),
+                           "figure (); stairs (%1);");
+  plot_mapper->setMapping (plot_menu->addAction ("area",
+                                                 plot_mapper,
+                                                 SLOT (map ())),
+                           "figure (); area (%1);");
+  plot_mapper->setMapping (plot_menu->addAction ("pie",
+                                                 plot_mapper,
+                                                 SLOT (map ())),
+                           "figure (); pie (%1);");
+  plot_mapper->setMapping (plot_menu->addAction ("hist",
+                                                 plot_mapper,
+                                                 SLOT (map ())),
+                           "figure (); hist (%1);");
+  connect (plot_mapper, SIGNAL (mapped (const QString&)),
+           this, SLOT (relay_command (const QString&)));
 
-  colorlist << qApp->palette ().color (QPalette::WindowText);
-  colorlist << qApp->palette ().color (QPalette::Base);
-  colorlist << qApp->palette ().color (QPalette::HighlightedText);
-  colorlist << qApp->palette ().color (QPalette::Highlight);
-  colorlist << qApp->palette ().color (QPalette::AlternateBase);
+  plot_tool_button->setMenu (plot_menu);
+  m_tool_bar->addWidget (plot_tool_button);
 
-  return colorlist;
+  m_tool_bar->addSeparator ();
+  m_tool_bar->addAction (QIcon (resource_manager::icon ("go-up")), tr ("Up"),
+                         this, SLOT (up ()));
+
+  m_tool_bar->setEnabled (false);  // Disabled when no tab is present
 }
diff --git a/libgui/src/variable-editor.h b/libgui/src/variable-editor.h
--- a/libgui/src/variable-editor.h
+++ b/libgui/src/variable-editor.h
@@ -39,27 +39,27 @@ class QModelIndex;
 class variable_editor : public octave_dock_widget
 {
   Q_OBJECT
 
 public:
 
   variable_editor (QWidget *parent = nullptr);
 
-  //~variable_editor ();
+  ~variable_editor (void);
 
   void edit_variable (const QString& name);
 
   /// Clear all the models' data cache
-  void clear_data_cache ();
+  void clear_data_cache (void);
 
-  bool has_focus ();
+  bool has_focus (void);
 
-  static QList<QColor> default_colors ();
-  static QStringList color_names ();
+  static QList<QColor> default_colors (void);
+  static QStringList color_names (void);
 
 public slots:
 
   void callUpdate (const QModelIndex&,const QModelIndex&);
 
   void notice_settings (const QSettings *);
 
 protected slots:
@@ -69,65 +69,66 @@ protected slots:
   void closeTab (int idx);
 
   void contextmenu_requested (const QPoint& pt);
   void columnmenu_requested (const QPoint& pt);
   void rowmenu_requested (const QPoint& pt);
 
   void double_click (const QModelIndex& idx);
 
-  void save ();
-  void clearContent ();
-  void cutClipboard ();
-  void copyClipboard ();
-  void pasteClipboard ();
-  void pasteTableClipboard ();
-  void createVariable ();
-  void transposeContent ();
-  void up ();
+  void save (void);
+  void clearContent (void);
+  void cutClipboard (void);
+  void copyClipboard (void);
+  void pasteClipboard (void);
+  void pasteTableClipboard (void);
+  void createVariable (void);
+  void transposeContent (void);
+  void up (void);
 
-  void delete_selected();
+  void delete_selected (void);
 
   /** Send command to Octave interpreter.
    * %1 in CMD is replaced with the value of selected_to_octave.
    */
   void relay_command (const QString& cmd);
 
 signals:
 
-  void updated ();
-  void finished ();
+  void updated (void);
+  void finished (void);
   void command_requested (const QString& cmd);
 
 private:
-  QMainWindow *main;
-  QToolBar *tool_bar;
-  QTabWidget *tab_widget;
 
-  int default_width;
-  int default_height;
-  int add_font_height;
+  QMainWindow *m_main;
+  QToolBar *m_tool_bar;
+  QTabWidget *m_tab_widget;
+
+  int m_default_width;
+  int m_default_height;
+  int m_add_font_height;
 
-  bool autofit;
-  bool autofit_max;
-  bool use_terminal_font;
-  bool alternate_rows;
+  bool m_autofit;
+  bool m_autofit_max;
+  bool m_use_terminal_font;
+  bool m_alternate_rows;
 
-  QString stylesheet;
+  QString m_stylesheet;
 
-  QFont font;
+  QFont m_font;
 
   // If use_terminal_font is true then this will be different since
   // "font" will contain the terminal font.
-  QFont sel_font;
-  QList<QColor> table_colors;
+  QFont m_sel_font;
+  QList<QColor> m_table_colors;
 
-  void update_colors ();
-
-  void construct_tool_bar ();
+  QList<int> octave_to_coords (QString&);
 
   // Convert selection to an Octave expression.
-  QString selected_to_octave ();
+  QString selected_to_octave (void);
 
-  QList<int> octave_to_coords (QString&);
+  void update_colors (void);
+
+  void construct_tool_bar (void);
 };
 
 #endif
diff --git a/libgui/src/welcome-wizard.cc b/libgui/src/welcome-wizard.cc
--- a/libgui/src/welcome-wizard.cc
+++ b/libgui/src/welcome-wizard.cc
@@ -42,244 +42,26 @@ static QLabel *
 make_octave_logo (QWidget *p = nullptr, int height = 100)
 {
   QLabel *logo = new QLabel (p);
   QPixmap logo_pixmap (":/actions/icons/logo.png");
   logo->setPixmap (logo_pixmap.scaledToHeight (height));
   return logo;
 };
 
-
-initial_page::initial_page (welcome_wizard *wizard)
-  : QWidget (wizard),
-    title (new QLabel (tr ("Welcome to Octave!"), this)),
-    message (new QLabel (this)),
-    logo (make_octave_logo (this)),
-    next (new QPushButton (tr ("Next"), this)),
-    cancel (new QPushButton (tr ("Cancel"), this))
+welcome_wizard::welcome_wizard (QWidget *p)
+  : QDialog (p), m_page_ctor_list (), m_page_list_iterator (),
+    m_current_page (initial_page::create (this)),
+    m_allow_web_connect_state (true)
 {
-  QFont ft;
-  ft.setPointSize (20);
-  title->setFont (ft);
-
-  message->setText
-  (tr ("<html><body>\n"
-       "<p>You seem to be using the Octave graphical interface for the first time on this computer.\n"
-       "Click 'Next' to create a configuration file and launch Octave.</p>\n"
-       "<p>The configuration file is stored in<br>%1.</p>\n"
-       "</body></html>").
-   arg (resource_manager::get_settings_file ()));
-  message->setWordWrap (true);
-  message->setMinimumWidth (400);
-
-  QVBoxLayout *message_layout = new QVBoxLayout;
-
-  message_layout->addWidget (title);
-  message_layout->addWidget (message);
-
-  QHBoxLayout *message_and_logo = new QHBoxLayout;
-
-  message_and_logo->addLayout (message_layout);
-  message_and_logo->addStretch (10);
-  message_and_logo->addWidget (logo, 0, Qt::AlignTop);
-
-  QHBoxLayout *button_bar = new QHBoxLayout;
-
-  button_bar->addStretch (10);
-  button_bar->addWidget (next);
-  button_bar->addWidget (cancel);
-
-  QVBoxLayout *page_layout = new QVBoxLayout (this);
-  setLayout (page_layout);
-
-  page_layout->addLayout (message_and_logo);
-  page_layout->addStretch (10);
-  page_layout->addLayout (button_bar);
-
-  next->setDefault (true);
-  next->setFocus ();
-
-  connect (next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
-  connect (cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
-}
-
-setup_community_news::setup_community_news (welcome_wizard *wizard)
-  : QWidget (wizard),
-    title (new QLabel (tr ("Community News"), this)),
-    message (new QLabel (this)),
-    checkbox (new QCheckBox (this)),
-    checkbox_message (new QLabel (this)),
-    logo (make_octave_logo (this)),
-    previous (new QPushButton (tr ("Previous"), this)),
-    next (new QPushButton (tr ("Next"), this)),
-    cancel (new QPushButton (tr ("Cancel"), this))
-{
-  QFont ft;
-  ft.setPointSize (20);
-  title->setFont (ft);
-
-  message->setText
-  (tr ("<html><body>\n"
-       "<p>When the Octave GUI starts, it will check the Octave web site for current news and information about the Octave community.\n"
-       "The check will happen at most once each day and news will only be displayed if there is something new since the last time you viewed the news.</p>\n"
-       "<p>You may also view the news by selecting the \"Community News\" item in the \"Help\" menu in the GUI, or by visiting\n"
-       "<a href=\"http://octave.org/community-news.html\">http://octave.org/community-news.html</a>.</p>\n"
-       "</body></html>"));
-  message->setWordWrap (true);
-  message->setMinimumWidth (400);
-  message->setOpenExternalLinks (true);
-
-  QVBoxLayout *message_layout = new QVBoxLayout;
-
-  message_layout->addWidget (title);
-  message_layout->addWidget (message);
-
-  QHBoxLayout *message_and_logo = new QHBoxLayout;
-
-  message_and_logo->addLayout (message_layout);
-  message_and_logo->addStretch (10);
-  message_and_logo->addWidget (logo, 0, Qt::AlignTop);
-
-  QHBoxLayout *checkbox_layout = new QHBoxLayout;
-
-  checkbox->setCheckState (Qt::Checked);
-
-  checkbox_message->setText
-  (tr ("<html><head>\n"
-       "<style>\n"
-       "a:link { text-decoration: underline; color: #0000ff; }\n"
-       "</style>\n"
-       "<head/><body>\n"
-       "<p>Allow Octave to connect to the Octave web site when it starts to display current news and information about the Octave community.</p>\n"
-       "</body></html>"));
-  checkbox_message->setWordWrap (true);
-  checkbox_message->setOpenExternalLinks (true);
-  checkbox_message->setMinimumWidth (500);
-
-  checkbox_layout->addWidget (checkbox, 0, Qt::AlignTop);
-  checkbox_layout->addSpacing (20);
-  checkbox_layout->addWidget (checkbox_message, 0, Qt::AlignTop);
-  checkbox_layout->addStretch (10);
-
-  QVBoxLayout *message_logo_and_checkbox = new QVBoxLayout;
+  m_page_ctor_list.push_back (initial_page::create);
+  m_page_ctor_list.push_back (setup_community_news::create);
+  m_page_ctor_list.push_back (final_page::create);
 
-  message_logo_and_checkbox->addLayout (message_and_logo);
-  message_logo_and_checkbox->addSpacing (20);
-  message_logo_and_checkbox->addLayout (checkbox_layout);
-
-  QHBoxLayout *button_bar = new QHBoxLayout;
-
-  button_bar->addStretch (10);
-  button_bar->addWidget (previous);
-  button_bar->addWidget (next);
-  button_bar->addWidget (cancel);
-
-  QVBoxLayout *page_layout = new QVBoxLayout (this);
-  setLayout (page_layout);
-
-  page_layout->addLayout (message_logo_and_checkbox);
-  page_layout->addStretch (10);
-  page_layout->addLayout (button_bar);
-
-  next->setDefault (true);
-  next->setFocus ();
-
-  connect (checkbox, SIGNAL (stateChanged (int)),
-           wizard, SLOT (handle_web_connect_option (int)));
-
-  connect (previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
-  connect (next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
-  connect (cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
-}
-
-final_page::final_page (welcome_wizard *wizard)
-  : QWidget (wizard),
-    title (new QLabel (tr ("Enjoy!"), this)),
-    message (new QLabel (this)),
-    logo (make_octave_logo (this)),
-    links (new QLabel (this)),
-    previous (new QPushButton (tr ("Previous"), this)),
-    finish (new QPushButton (tr ("Finish"), this)),
-    cancel (new QPushButton (tr ("Cancel"), this))
-{
-  QFont ft;
-  ft.setPointSize (20);
-  title->setFont (ft);
-
-  message->setText
-  (tr ("<html><body>\n"
-       "<p>We hope you find Octave to be a useful tool.</p>\n"
-       "<p>If you encounter problems, there are a number of ways to get help, including commercial support options, a mailing list, a wiki, and other community-based support channels.\n"
-       "You can find more information about each of these by visiting <a href=\"http://octave.org/support.html\">http://octave.org/support.html</a> (opens in external browser).</p>\n"
-       "</body></html>"));
-  message->setWordWrap (true);
-  message->setMinimumWidth (400);
-  message->setOpenExternalLinks (true);
-
-  QVBoxLayout *message_layout = new QVBoxLayout;
-
-  message_layout->addWidget (title);
-  message_layout->addWidget (message);
-
-  QHBoxLayout *message_and_logo = new QHBoxLayout;
-
-  message_and_logo->addLayout (message_layout);
-  message_and_logo->addStretch (10);
-  message_and_logo->addWidget (logo, 0, Qt::AlignTop);
-
-  links->setText
-  (tr ("<html><head>\n"
-       "<style>\n"
-       "a:link { text-decoration: underline; color: #0000ff; }\n"
-       "</style>\n"
-       "<head/><body>\n"
-       "<p>For more information about Octave:</p>\n"
-       "<ul>\n"
-       "<li>Visit <a href=\"http://octave.org\">http://octave.org</a> (opens in external browser)</li>\n"
-       "<li>Get the documentation online as <a href=\"http://www.gnu.org/software/octave/doc/interpreter/index.html\">html</a>- or <a href=\"http://www.gnu.org/software/octave/octave.pdf\">pdf</span></a>-document (opens in external browser)</li>\n"
-       "<li>Open the documentation browser of the Octave GUI with the help menu</li>\n"
-       "</ul>\n"
-       "</body></html>"));
-  links->setWordWrap (true);
-  links->setOpenExternalLinks (true);
-
-  QHBoxLayout *button_bar = new QHBoxLayout;
-
-  button_bar->addStretch (10);
-  button_bar->addWidget (previous);
-  button_bar->addWidget (finish);
-  button_bar->addWidget (cancel);
-
-  QVBoxLayout *page_layout = new QVBoxLayout (this);
-  setLayout (page_layout);
-
-  page_layout->addLayout (message_and_logo);
-  page_layout->addSpacing (20);
-  page_layout->addWidget (links);
-  page_layout->addStretch (10);
-  page_layout->addLayout (button_bar);
-
-  finish->setDefault (true);
-  finish->setFocus ();
-
-  connect (previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
-  connect (finish, SIGNAL (clicked ()), wizard, SLOT (accept ()));
-  connect (cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
-}
-
-welcome_wizard::welcome_wizard (QWidget *p)
-  : QDialog (p), page_ctor_list (), page_list_iterator (),
-    current_page (initial_page::create (this)),
-    allow_web_connect_state (true)
-{
-  page_ctor_list.push_back (initial_page::create);
-  page_ctor_list.push_back (setup_community_news::create);
-  page_ctor_list.push_back (final_page::create);
-
-  page_list_iterator = page_ctor_list.begin ();
+  m_page_list_iterator = m_page_ctor_list.begin ();
 
   setWindowTitle (tr ("Welcome to GNU Octave"));
 
   setEnabled (true);
   resize (600, 480);
   setMinimumSize (QSize (600, 480));
 
   show_page ();
@@ -288,60 +70,277 @@ welcome_wizard::welcome_wizard (QWidget 
   // HACK to forceshow of dialog if started minimized
   ShowWindow ((HWND)winId (), SW_SHOWNORMAL);
 #endif
 }
 
 void
 welcome_wizard::handle_web_connect_option (int state)
 {
-  allow_web_connect_state = state == Qt::Checked;
+  m_allow_web_connect_state = state == Qt::Checked;
 }
 
 void
 welcome_wizard::show_page (void)
 {
-  delete current_page;
+  delete m_current_page;
   delete layout ();
 
-  current_page = (*page_list_iterator) (this);
+  m_current_page = (*m_page_list_iterator) (this);
 
   QVBoxLayout *new_layout = new QVBoxLayout ();
   setLayout (new_layout);
 
-  new_layout->addWidget (current_page);
+  new_layout->addWidget (m_current_page);
 }
 
 void
 welcome_wizard::previous_page (void)
 {
-  --page_list_iterator;
+  --m_page_list_iterator;
 
   show_page ();
 }
 
 void
 welcome_wizard::next_page (void)
 {
-  ++page_list_iterator;
+  ++m_page_list_iterator;
 
   show_page ();
 }
 
 void
 welcome_wizard::accept (void)
 {
   // Create default settings file.
 
   resource_manager::reload_settings ();
 
   QSettings *settings = resource_manager::get_settings ();
 
   if (settings)
     {
       settings->setValue ("news/allow_web_connection",
-                          allow_web_connect_state);
+                          m_allow_web_connect_state);
 
       settings->sync ();
     }
 
   QDialog::accept ();
 }
+
+initial_page::initial_page (welcome_wizard *wizard)
+  : QWidget (wizard),
+    m_title (new QLabel (tr ("Welcome to Octave!"), this)),
+    m_message (new QLabel (this)),
+    m_logo (make_octave_logo (this)),
+    m_next (new QPushButton (tr ("Next"), this)),
+    m_cancel (new QPushButton (tr ("Cancel"), this))
+{
+  QFont ft;
+  ft.setPointSize (20);
+  m_title->setFont (ft);
+
+  m_message->setText
+  (tr ("<html><body>\n"
+       "<p>You seem to be using the Octave graphical interface for the first time on this computer.\n"
+       "Click 'Next' to create a configuration file and launch Octave.</p>\n"
+       "<p>The configuration file is stored in<br>%1.</p>\n"
+       "</body></html>").
+   arg (resource_manager::get_settings_file ()));
+  m_message->setWordWrap (true);
+  m_message->setMinimumWidth (400);
+
+  QVBoxLayout *message_layout = new QVBoxLayout;
+
+  message_layout->addWidget (m_title);
+  message_layout->addWidget (m_message);
+
+  QHBoxLayout *message_and_logo = new QHBoxLayout;
+
+  message_and_logo->addLayout (message_layout);
+  message_and_logo->addStretch (10);
+  message_and_logo->addWidget (m_logo, 0, Qt::AlignTop);
+
+  QHBoxLayout *button_bar = new QHBoxLayout;
+
+  button_bar->addStretch (10);
+  button_bar->addWidget (m_next);
+  button_bar->addWidget (m_cancel);
+
+  QVBoxLayout *page_layout = new QVBoxLayout (this);
+  setLayout (page_layout);
+
+  page_layout->addLayout (message_and_logo);
+  page_layout->addStretch (10);
+  page_layout->addLayout (button_bar);
+
+  m_next->setDefault (true);
+  m_next->setFocus ();
+
+  connect (m_next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
+  connect (m_cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
+}
+
+setup_community_news::setup_community_news (welcome_wizard *wizard)
+  : QWidget (wizard),
+    m_title (new QLabel (tr ("Community News"), this)),
+    m_message (new QLabel (this)),
+    m_checkbox (new QCheckBox (this)),
+    m_checkbox_message (new QLabel (this)),
+    m_logo (make_octave_logo (this)),
+    m_previous (new QPushButton (tr ("Previous"), this)),
+    m_next (new QPushButton (tr ("Next"), this)),
+    m_cancel (new QPushButton (tr ("Cancel"), this))
+{
+  QFont ft;
+  ft.setPointSize (20);
+  m_title->setFont (ft);
+
+  m_message->setText
+  (tr ("<html><body>\n"
+       "<p>When the Octave GUI starts, it will check the Octave web site for current news and information about the Octave community.\n"
+       "The check will happen at most once each day and news will only be displayed if there is something new since the last time you viewed the news.</p>\n"
+       "<p>You may also view the news by selecting the \"Community News\" item in the \"Help\" menu in the GUI, or by visiting\n"
+       "<a href=\"http://octave.org/community-news.html\">http://octave.org/community-news.html</a>.</p>\n"
+       "</body></html>"));
+  m_message->setWordWrap (true);
+  m_message->setMinimumWidth (400);
+  m_message->setOpenExternalLinks (true);
+
+  QVBoxLayout *message_layout = new QVBoxLayout;
+
+  message_layout->addWidget (m_title);
+  message_layout->addWidget (m_message);
+
+  QHBoxLayout *message_and_logo = new QHBoxLayout;
+
+  message_and_logo->addLayout (message_layout);
+  message_and_logo->addStretch (10);
+  message_and_logo->addWidget (m_logo, 0, Qt::AlignTop);
+
+  QHBoxLayout *checkbox_layout = new QHBoxLayout;
+
+  m_checkbox->setCheckState (Qt::Checked);
+
+  m_checkbox_message->setText
+  (tr ("<html><head>\n"
+       "<style>\n"
+       "a:link { text-decoration: underline; color: #0000ff; }\n"
+       "</style>\n"
+       "<head/><body>\n"
+       "<p>Allow Octave to connect to the Octave web site when it starts to display current news and information about the Octave community.</p>\n"
+       "</body></html>"));
+  m_checkbox_message->setWordWrap (true);
+  m_checkbox_message->setOpenExternalLinks (true);
+  m_checkbox_message->setMinimumWidth (500);
+
+  checkbox_layout->addWidget (m_checkbox, 0, Qt::AlignTop);
+  checkbox_layout->addSpacing (20);
+  checkbox_layout->addWidget (m_checkbox_message, 0, Qt::AlignTop);
+  checkbox_layout->addStretch (10);
+
+  QVBoxLayout *message_logo_and_checkbox = new QVBoxLayout;
+
+  message_logo_and_checkbox->addLayout (message_and_logo);
+  message_logo_and_checkbox->addSpacing (20);
+  message_logo_and_checkbox->addLayout (checkbox_layout);
+
+  QHBoxLayout *button_bar = new QHBoxLayout;
+
+  button_bar->addStretch (10);
+  button_bar->addWidget (m_previous);
+  button_bar->addWidget (m_next);
+  button_bar->addWidget (m_cancel);
+
+  QVBoxLayout *page_layout = new QVBoxLayout (this);
+  setLayout (page_layout);
+
+  page_layout->addLayout (message_logo_and_checkbox);
+  page_layout->addStretch (10);
+  page_layout->addLayout (button_bar);
+
+  m_next->setDefault (true);
+  m_next->setFocus ();
+
+  connect (m_checkbox, SIGNAL (stateChanged (int)),
+           wizard, SLOT (handle_web_connect_option (int)));
+
+  connect (m_previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
+  connect (m_next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
+  connect (m_cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
+}
+
+final_page::final_page (welcome_wizard *wizard)
+  : QWidget (wizard),
+    m_title (new QLabel (tr ("Enjoy!"), this)),
+    m_message (new QLabel (this)),
+    m_logo (make_octave_logo (this)),
+    m_links (new QLabel (this)),
+    m_previous (new QPushButton (tr ("Previous"), this)),
+    m_finish (new QPushButton (tr ("Finish"), this)),
+    m_cancel (new QPushButton (tr ("Cancel"), this))
+{
+  QFont ft;
+  ft.setPointSize (20);
+  m_title->setFont (ft);
+
+  m_message->setText
+  (tr ("<html><body>\n"
+       "<p>We hope you find Octave to be a useful tool.</p>\n"
+       "<p>If you encounter problems, there are a number of ways to get help, including commercial support options, a mailing list, a wiki, and other community-based support channels.\n"
+       "You can find more information about each of these by visiting <a href=\"http://octave.org/support.html\">http://octave.org/support.html</a> (opens in external browser).</p>\n"
+       "</body></html>"));
+  m_message->setWordWrap (true);
+  m_message->setMinimumWidth (400);
+  m_message->setOpenExternalLinks (true);
+
+  QVBoxLayout *message_layout = new QVBoxLayout;
+
+  message_layout->addWidget (m_title);
+  message_layout->addWidget (m_message);
+
+  QHBoxLayout *message_and_logo = new QHBoxLayout;
+
+  message_and_logo->addLayout (message_layout);
+  message_and_logo->addStretch (10);
+  message_and_logo->addWidget (m_logo, 0, Qt::AlignTop);
+
+  m_links->setText
+  (tr ("<html><head>\n"
+       "<style>\n"
+       "a:link { text-decoration: underline; color: #0000ff; }\n"
+       "</style>\n"
+       "<head/><body>\n"
+       "<p>For more information about Octave:</p>\n"
+       "<ul>\n"
+       "<li>Visit <a href=\"http://octave.org\">http://octave.org</a> (opens in external browser)</li>\n"
+       "<li>Get the documentation online as <a href=\"http://www.gnu.org/software/octave/doc/interpreter/index.html\">html</a>- or <a href=\"http://www.gnu.org/software/octave/octave.pdf\">pdf</span></a>-document (opens in external browser)</li>\n"
+       "<li>Open the documentation browser of the Octave GUI with the help menu</li>\n"
+       "</ul>\n"
+       "</body></html>"));
+  m_links->setWordWrap (true);
+  m_links->setOpenExternalLinks (true);
+
+  QHBoxLayout *button_bar = new QHBoxLayout;
+
+  button_bar->addStretch (10);
+  button_bar->addWidget (m_previous);
+  button_bar->addWidget (m_finish);
+  button_bar->addWidget (m_cancel);
+
+  QVBoxLayout *page_layout = new QVBoxLayout (this);
+  setLayout (page_layout);
+
+  page_layout->addLayout (message_and_logo);
+  page_layout->addSpacing (20);
+  page_layout->addWidget (m_links);
+  page_layout->addStretch (10);
+  page_layout->addLayout (button_bar);
+
+  m_finish->setDefault (true);
+  m_finish->setFocus ();
+
+  connect (m_previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
+  connect (m_finish, SIGNAL (clicked ()), wizard, SLOT (accept ()));
+  connect (m_cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
+}
diff --git a/libgui/src/welcome-wizard.h b/libgui/src/welcome-wizard.h
--- a/libgui/src/welcome-wizard.h
+++ b/libgui/src/welcome-wizard.h
@@ -37,20 +37,20 @@ public:
   typedef QWidget *(*page_creator_fptr) (welcome_wizard *wizard);
 
   welcome_wizard (QWidget *parent = nullptr);
 
   ~welcome_wizard (void) = default;
 
 private:
 
-  QList<page_creator_fptr> page_ctor_list;
-  QList<page_creator_fptr>::iterator page_list_iterator;
-  QWidget *current_page;
-  bool allow_web_connect_state;
+  QList<page_creator_fptr> m_page_ctor_list;
+  QList<page_creator_fptr>::iterator m_page_list_iterator;
+  QWidget *m_current_page;
+  bool m_allow_web_connect_state;
 
 private slots:
 
   void handle_web_connect_option (int state);
 
   void show_page (void);
   void previous_page (void);
   void next_page (void);
@@ -69,21 +69,21 @@ public:
 
   ~initial_page (void) = default;
 
   static QWidget *
   create (welcome_wizard *wizard) { return new initial_page (wizard); }
 
 private:
 
-  QLabel *title;
-  QLabel *message;
-  QLabel *logo;
-  QPushButton *next;
-  QPushButton *cancel;
+  QLabel *m_title;
+  QLabel *m_message;
+  QLabel *m_logo;
+  QPushButton *m_next;
+  QPushButton *m_cancel;
 };
 
 
 class setup_community_news : public QWidget
 {
   Q_OBJECT
 
 public:
@@ -92,24 +92,24 @@ public:
 
   ~setup_community_news (void) = default;
 
   static QWidget *
   create (welcome_wizard *wizard) { return new setup_community_news (wizard); }
 
 private:
 
-  QLabel *title;
-  QLabel *message;
-  QCheckBox *checkbox;
-  QLabel *checkbox_message;
-  QLabel *logo;
-  QPushButton *previous;
-  QPushButton *next;
-  QPushButton *cancel;
+  QLabel *m_title;
+  QLabel *m_message;
+  QCheckBox *m_checkbox;
+  QLabel *m_checkbox_message;
+  QLabel *m_logo;
+  QPushButton *m_previous;
+  QPushButton *m_next;
+  QPushButton *m_cancel;
 };
 
 
 class final_page : public QWidget
 {
   Q_OBJECT
 
 public:
@@ -118,18 +118,18 @@ public:
 
   ~final_page (void) = default;
 
   static QWidget *
   create (welcome_wizard *wizard) { return new final_page (wizard); }
 
 private:
 
-  QLabel *title;
-  QLabel *message;
-  QLabel *logo;
-  QLabel *links;
-  QPushButton *previous;
-  QPushButton *finish;
-  QPushButton *cancel;
+  QLabel *m_title;
+  QLabel *m_message;
+  QLabel *m_logo;
+  QLabel *m_links;
+  QPushButton *m_previous;
+  QPushButton *m_finish;
+  QPushButton *m_cancel;
 };
 
 #endif
diff --git a/libgui/src/workspace-model.cc b/libgui/src/workspace-model.cc
--- a/libgui/src/workspace-model.cc
+++ b/libgui/src/workspace-model.cc
@@ -30,40 +30,40 @@ along with Octave; see the file COPYING.
 
 #include "utils.h"
 #include "resource-manager.h"
 #include "workspace-model.h"
 
 workspace_model::workspace_model (QObject *p)
   : QAbstractTableModel (p)
 {
-  _columnNames.append (tr ("Name"));
-  _columnNames.append (tr ("Class"));
-  _columnNames.append (tr ("Dimension"));
-  _columnNames.append (tr ("Value"));
-  _columnNames.append (tr ("Attribute"));
+  m_columnNames.append (tr ("Name"));
+  m_columnNames.append (tr ("Class"));
+  m_columnNames.append (tr ("Dimension"));
+  m_columnNames.append (tr ("Value"));
+  m_columnNames.append (tr ("Attribute"));
 
   for (int i = 0; i < resource_manager::storage_class_chars ().length (); i++)
-    _storage_class_colors.append (QColor (Qt::white));
+    m_storage_class_colors.append (QColor (Qt::white));
 
 }
 
 QList<QColor>
 workspace_model::storage_class_default_colors (void)
 {
   QList<QColor> colors;
 
   if (colors.isEmpty ())
     {
-      colors << QColor (190,255,255)
-             << QColor (220,255,220)
-             << QColor (220,220,255)
-             << QColor (255,255,190)
-             << QColor (255,220,220)
-             << QColor (255,190,255);
+      colors << QColor (190, 255, 255)
+             << QColor (220, 255, 220)
+             << QColor (220, 220, 255)
+             << QColor (255, 255, 190)
+             << QColor (255, 220, 220)
+             << QColor (255, 190, 255);
     }
 
   return colors;
 }
 
 QStringList
 workspace_model::storage_class_names (void)
 {
@@ -80,113 +80,113 @@ workspace_model::storage_class_names (vo
     }
 
   return names;
 }
 
 int
 workspace_model::rowCount (const QModelIndex&) const
 {
-  return _symbols.size ();
+  return m_symbols.size ();
 }
 
 int
 workspace_model::columnCount (const QModelIndex&) const
 {
-  return _columnNames.size ();
+  return m_columnNames.size ();
 }
 
 Qt::ItemFlags
 workspace_model::flags (const QModelIndex& idx) const
 {
   Qt::ItemFlags retval = nullptr;
 
   if (idx.isValid ())
     {
       retval |= Qt::ItemIsEnabled;
 
-      if (_top_level && idx.column () == 0)
+      if (m_top_level && idx.column () == 0)
         retval |= Qt::ItemIsSelectable;
     }
 
   return retval;
 }
 
 QVariant
 workspace_model::headerData (int section, Qt::Orientation orientation,
                              int role) const
 {
   if (orientation == Qt::Horizontal && role == Qt::DisplayRole)
-    return _columnNames[section];
+    return m_columnNames[section];
   else
     return QVariant ();
 }
 
 QVariant
 workspace_model::data (const QModelIndex& idx, int role) const
 {
   QVariant retval;
 
   if (idx.isValid ())
     {
       if (role == Qt::BackgroundColorRole)
         {
           QString class_chars = resource_manager::storage_class_chars ();
           int actual_class
-            = class_chars.indexOf (_scopes[idx.row ()].toLatin1 ());
+            = class_chars.indexOf (m_scopes[idx.row ()].toLatin1 ());
           if (actual_class >= 0)
-            return QVariant (_storage_class_colors.at (actual_class));
+            return QVariant (m_storage_class_colors.at (actual_class));
           else
             return retval;
         }
 
       if (role == Qt::DisplayRole
           || (idx.column () == 0 && role == Qt::EditRole)
           || (idx.column () == 0 && role == Qt::ToolTipRole))
         {
           switch (idx.column ())
             {
             case 0:
               if (role == Qt::ToolTipRole)
                 retval
                   = QVariant (tr ("Right click to copy, rename, or display"));
               else
-                retval = QVariant (_symbols[idx.row ()]);
+                retval = QVariant (m_symbols[idx.row ()]);
               break;
 
             case 1:
-              retval = QVariant (_class_names[idx.row ()]);
+              retval = QVariant (m_class_names[idx.row ()]);
               break;
 
             case 2:
-              retval = QVariant (_dimensions[idx.row ()]);
+              retval = QVariant (m_dimensions[idx.row ()]);
               break;
 
             case 3:
-              retval = QVariant (_values[idx.row ()]);
+              retval = QVariant (m_values[idx.row ()]);
               break;
 
             case 4:
               {
                 QString sclass;
 
                 QString class_chars = resource_manager::storage_class_chars ();
 
                 int actual_class
-                  = class_chars.indexOf (_scopes[idx.row ()].toLatin1 ());
+                  = class_chars.indexOf (m_scopes[idx.row ()].toLatin1 ());
 
                 if (actual_class >= 0)
                   {
                     QStringList class_names
                       = resource_manager::storage_class_names ();
 
                     sclass = class_names.at (actual_class);
                   }
 
-                if (_complex_flags[idx.row ()])
+                if (m_complex_flags[idx.row ()])
                   {
                     if (sclass.isEmpty ())
                       sclass = tr ("complex");
                     else
                       sclass += ", " + tr ("complex");
                   }
 
                 retval = QVariant (sclass);
@@ -202,17 +202,17 @@ workspace_model::data (const QModelIndex
 bool
 workspace_model::setData (const QModelIndex& idx, const QVariant& value,
                           int role)
 {
   bool retval = false;
 
   if (idx.column () == 0 && role == Qt::EditRole)
     {
-      QString qold_name = _symbols[idx.row ()];
+      QString qold_name = m_symbols[idx.row ()];
 
       QString qnew_name = value.toString ();
 
       std::string new_name = qnew_name.toStdString ();
 
       if (valid_identifier (new_name))
         {
           emit rename_variable (qold_name, qnew_name);
@@ -229,66 +229,66 @@ workspace_model::set_workspace (bool top
                                 bool /* debug */,
                                 const QString& scopes,
                                 const QStringList& symbols,
                                 const QStringList& class_names,
                                 const QStringList& dimensions,
                                 const QStringList& values,
                                 const QIntList& complex_flags)
 {
-  _top_level = top_level;
-  _scopes = scopes;
-  _symbols = symbols;
-  _class_names = class_names;
-  _dimensions = dimensions;
-  _values = values;
-  _complex_flags = complex_flags;
+  m_top_level = top_level;
+  m_scopes = scopes;
+  m_symbols = symbols;
+  m_class_names = class_names;
+  m_dimensions = dimensions;
+  m_values = values;
+  m_complex_flags = complex_flags;
 
   update_table ();
 }
 
 void
 workspace_model::clear_workspace (void)
 {
   clear_data ();
   update_table ();
 }
 
 void
-workspace_model::clear_data (void)
-{
-  _top_level = false;
-  _scopes = QString ();
-  _symbols = QStringList ();
-  _class_names = QStringList ();
-  _dimensions = QStringList ();
-  _values = QStringList ();
-  _complex_flags = QIntList ();
-}
-
-void
-workspace_model::update_table (void)
-{
-  beginResetModel ();
-
-  // Nothing to do except tell the world to recalc.
-
-  endResetModel ();
-
-  emit model_changed ();
-}
-
-void
 workspace_model::notice_settings (const QSettings *settings)
 {
   QList<QColor> default_colors =
     resource_manager::storage_class_default_colors ();
   QString class_chars = resource_manager::storage_class_chars ();
 
   for (int i = 0; i < class_chars.length (); i++)
     {
       QVariant default_var = default_colors.at (i);
       QColor setting_color = settings->value ("workspaceview/color_"
                                               + class_chars.mid (i,1),
                                               default_var).value<QColor> ();
-      _storage_class_colors.replace (i,setting_color);
+      m_storage_class_colors.replace (i,setting_color);
     }
 }
+
+void
+workspace_model::clear_data (void)
+{
+  m_top_level = false;
+  m_scopes = QString ();
+  m_symbols = QStringList ();
+  m_class_names = QStringList ();
+  m_dimensions = QStringList ();
+  m_values = QStringList ();
+  m_complex_flags = QIntList ();
+}
+
+void
+workspace_model::update_table (void)
+{
+  beginResetModel ();
+
+  // Nothing to do except tell the world to recalc.
+
+  endResetModel ();
+
+  emit model_changed ();
+}
diff --git a/libgui/src/workspace-model.h b/libgui/src/workspace-model.h
--- a/libgui/src/workspace-model.h
+++ b/libgui/src/workspace-model.h
@@ -46,34 +46,36 @@ public:
   workspace_model (QObject *parent = nullptr);
 
   ~workspace_model (void) = default;
 
   static QList<QColor> storage_class_default_colors (void);
 
   static QStringList storage_class_names (void);
 
-  QVariant data (const QModelIndex& index, int role) const;
+  int rowCount (const QModelIndex& parent = QModelIndex ()) const;
 
-  bool setData (const QModelIndex& index, const QVariant& value,
-                int role = Qt::EditRole);
+  int columnCount (const QModelIndex& parent = QModelIndex ()) const;
 
   Qt::ItemFlags flags (const QModelIndex& index) const;
 
   QVariant headerData (int section, Qt::Orientation orientation,
                        int role = Qt::DisplayRole) const;
 
-  int rowCount (const QModelIndex& parent = QModelIndex ()) const;
+  QVariant data (const QModelIndex& index, int role) const;
 
-  int columnCount (const QModelIndex& parent = QModelIndex ()) const;
+  bool setData (const QModelIndex& index, const QVariant& value,
+                int role = Qt::EditRole);
 
-  bool is_top_level (void) const { return _top_level; }
+  bool is_top_level (void) const { return m_top_level; }
 
   QColor storage_class_color (int s_class)
-  { return _storage_class_colors.at (s_class); }
+  {
+    return m_storage_class_colors.at (s_class);
+  }
 
 public slots:
 
   void set_workspace (bool top_level,
                       bool debug,
                       const QString& scopes,
                       const QStringList& symbols,
                       const QStringList& class_names,
@@ -92,23 +94,23 @@ signals:
 
   void rename_variable (const QString& old_name, const QString& new_name);
 
 private:
 
   void clear_data (void);
   void update_table (void);
 
-  bool _top_level;
-  QString _scopes;
-  QStringList _symbols;
-  QStringList _class_names;
-  QStringList _dimensions;
-  QStringList _values;
-  QIntList _complex_flags;
+  bool m_top_level;
+  QString m_scopes;
+  QStringList m_symbols;
+  QStringList m_class_names;
+  QStringList m_dimensions;
+  QStringList m_values;
+  QIntList m_complex_flags;
 
-  QStringList _columnNames;
+  QStringList m_columnNames;
 
-  QList<QColor>  _storage_class_colors;
+  QList<QColor>  m_storage_class_colors;
 
 };
 
 #endif
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -41,276 +41,303 @@ along with Octave; see the file COPYING.
 
 #include "workspace-view.h"
 #include "resource-manager.h"
 
 #include "interpreter-private.h"
 #include "symtab.h"
 
 workspace_view::workspace_view (QWidget *p)
-  : octave_dock_widget (p), view (new QTableView (this))
+  : octave_dock_widget (p), m_view (new QTableView (this))
 {
   setObjectName ("WorkspaceView");
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("Workspace"));
   setStatusTip (tr ("View the variables in the active workspace."));
 
-  _filter = new QComboBox (this);
-  _filter->setToolTip (tr ("Enter text to filter the workspace"));
-  _filter->setEditable (true);
-  _filter->setMaxCount (MaxFilterHistory);
-  _filter->setInsertPolicy (QComboBox::NoInsert);
-  _filter->setSizeAdjustPolicy (
-    QComboBox::AdjustToMinimumContentsLengthWithIcon);
+  m_filter = new QComboBox (this);
+  m_filter->setToolTip (tr ("Enter text to filter the workspace"));
+  m_filter->setEditable (true);
+  m_filter->setMaxCount (MaxFilterHistory);
+  m_filter->setInsertPolicy (QComboBox::NoInsert);
+  m_filter->setSizeAdjustPolicy (QComboBox::AdjustToMinimumContentsLengthWithIcon);
   QSizePolicy sizePol (QSizePolicy::Expanding, QSizePolicy::Preferred);
-  _filter->setSizePolicy (sizePol);
-  _filter->completer ()->setCaseSensitivity (Qt::CaseSensitive);
+  m_filter->setSizePolicy (sizePol);
+  m_filter->completer ()->setCaseSensitivity (Qt::CaseSensitive);
 
   QLabel *filter_label = new QLabel (tr ("Filter"));
 
-  _filter_checkbox = new QCheckBox ();
+  m_filter_checkbox = new QCheckBox ();
 
-  view->setWordWrap (false);
-  view->setContextMenuPolicy (Qt::CustomContextMenu);
-  view->setShowGrid (false);
-  (view->verticalHeader) ()->hide ();
-  view->setAlternatingRowColors (true);
-  view_previous_row_count = 0;
+  m_view->setWordWrap (false);
+  m_view->setContextMenuPolicy (Qt::CustomContextMenu);
+  m_view->setShowGrid (false);
+  (m_view->verticalHeader) ()->hide ();
+  m_view->setAlternatingRowColors (true);
+  m_view_previous_row_count = 0;
 
   // Set an empty widget, so we can assign a layout to it.
   setWidget (new QWidget (this));
 
   // Create the layouts
-  _filter_widget = new QWidget (this);
+  m_filter_widget = new QWidget (this);
   QHBoxLayout *filter_layout = new QHBoxLayout ();
 
   filter_layout->addWidget (filter_label);
-  filter_layout->addWidget (_filter_checkbox);
-  filter_layout->addWidget (_filter);
+  filter_layout->addWidget (m_filter_checkbox);
+  filter_layout->addWidget (m_filter);
   filter_layout->setMargin(0);
-  _filter_widget->setLayout (filter_layout);
+  m_filter_widget->setLayout (filter_layout);
 
   QVBoxLayout *ws_layout = new QVBoxLayout ();
-  ws_layout->addWidget (_filter_widget);
-  ws_layout->addWidget (view);
+  ws_layout->addWidget (m_filter_widget);
+  ws_layout->addWidget (m_view);
 
   QSettings *settings = resource_manager::get_settings ();
 
   if (settings)
     {
-      _filter_shown = settings->value ("workspaceview/filter_shown",true).toBool ();
-      _filter_widget->setVisible (_filter_shown);
+      m_filter_shown = settings->value ("workspaceview/filter_shown",true).toBool ();
+      m_filter_widget->setVisible (m_filter_shown);
 
       ws_layout->setMargin (2);
 
       // Set the empty widget to have our layout.
       widget ()->setLayout (ws_layout);
 
       // Initialize collapse/expand state of the workspace subcategories.
 
       //enable sorting (setting column and order after model was set)
-      view->setSortingEnabled (true);
+      m_view->setSortingEnabled (true);
       // Initialize column order and width of the workspace
-      view->horizontalHeader ()->restoreState (settings->value ("workspaceview/column_state").toByteArray ());
+      m_view->horizontalHeader ()->restoreState (settings->value ("workspaceview/column_state").toByteArray ());
 
       // Set header properties for sorting
 #if defined (HAVE_QT4)
-      view->horizontalHeader ()->setClickable (true);
-      view->horizontalHeader ()->setMovable (true);
+      m_view->horizontalHeader ()->setClickable (true);
+      m_view->horizontalHeader ()->setMovable (true);
 #else
-      view->horizontalHeader ()->setSectionsClickable (true);
-      view->horizontalHeader ()->setSectionsMovable (true);
+      m_view->horizontalHeader ()->setSectionsClickable (true);
+      m_view->horizontalHeader ()->setSectionsMovable (true);
 #endif
-      view->horizontalHeader ()->setSortIndicator (settings->value ("workspaceview/sort_by_column",0).toInt (),
+      m_view->horizontalHeader ()->setSortIndicator (settings->value ("workspaceview/sort_by_column",0).toInt (),
                                                    static_cast<Qt::SortOrder>
                                                    (settings->value ("workspaceview/sort_order", Qt::AscendingOrder).toUInt ()));
-      view->horizontalHeader ()->setSortIndicatorShown (true);
+      m_view->horizontalHeader ()->setSortIndicatorShown (true);
 
-      view->horizontalHeader ()->setContextMenuPolicy (Qt::CustomContextMenu);
-      connect (view->horizontalHeader (),
+      m_view->horizontalHeader ()->setContextMenuPolicy (Qt::CustomContextMenu);
+      connect (m_view->horizontalHeader (),
                SIGNAL (customContextMenuRequested (const QPoint &)),
                this, SLOT (header_contextmenu_requested (const QPoint &)));
 
       // Init state of the filter
-      _filter->addItems (settings->value ("workspaceview/mru_list").toStringList ());
+      m_filter->addItems (settings->value ("workspaceview/mru_list").toStringList ());
 
       bool filter_state =
         settings->value ("workspaceview/filter_active", false).toBool ();
-      _filter_checkbox->setChecked (filter_state);
+      m_filter_checkbox->setChecked (filter_state);
       filter_activate (filter_state);
     }
 
   // Connect signals and slots.
 
-  connect (_filter, SIGNAL (editTextChanged (const QString&)),
+  connect (m_filter, SIGNAL (editTextChanged (const QString&)),
            this, SLOT (filter_update (const QString&)));
-  connect (_filter_checkbox, SIGNAL (toggled (bool)),
+  connect (m_filter_checkbox, SIGNAL (toggled (bool)),
            this, SLOT (filter_activate (bool)));
-  connect (_filter->lineEdit (), SIGNAL (editingFinished ()),
+  connect (m_filter->lineEdit (), SIGNAL (editingFinished ()),
            this, SLOT (update_filter_history ()));
 
-  connect (view, SIGNAL (customContextMenuRequested (const QPoint&)),
+  connect (m_view, SIGNAL (customContextMenuRequested (const QPoint&)),
            this, SLOT (contextmenu_requested (const QPoint&)));
 
-  connect (view, SIGNAL (doubleClicked (QModelIndex)),
+  connect (m_view, SIGNAL (doubleClicked (QModelIndex)),
            this, SLOT (handle_contextmenu_edit (void)));
 
   connect (this, SIGNAL (command_requested (const QString&)),
            p, SLOT (execute_command_in_terminal (const QString&)));
 
   connect (this, SIGNAL (edit_variable_signal (const QString&)),
            p, SLOT (edit_variable (const QString&)));
 }
 
+void workspace_view::setModel (workspace_model *model)
+{
+  m_filter_model.setSourceModel (model);
+  m_filter_model.setFilterKeyColumn(0);
+
+  m_view->setModel (&m_filter_model);
+
+  // set the sorting after a model was set, it would be ignored otherwise
+  QSettings *settings = resource_manager::get_settings ();
+  m_view->sortByColumn (settings->value ("workspaceview/sort_by_column",0).toInt (),
+                        static_cast<Qt::SortOrder> (settings->value ("workspaceview/sort_order", Qt::AscendingOrder).toUInt ()));
+
+  m_model = model;
+}
+
+void
+workspace_view::notice_settings (const QSettings *settings)
+{
+  int i;
+
+  m_model->notice_settings (settings); // update colors of model first
+
+  for (i = 0; i < m_columns_shown_keys.size (); i++)
+    m_view->setColumnHidden (i + 1, ! settings->value (m_columns_shown_keys.at (i),true).toBool ());
+
+  QString tool_tip;
+
+  if (! settings->value ("workspaceview/hide_tool_tips",false).toBool ())
+    {
+      tool_tip  = QString (tr ("View the variables in the active workspace.<br>"));
+      tool_tip += QString (tr ("Colors for variable attributes:"));
+      for (i = 0; i < resource_manager::storage_class_chars ().length (); i++)
+        {
+          tool_tip +=
+            QString (R"(<div style="background-color:%1;color:#000000">%2</div>)")
+            .arg (m_model->storage_class_color (i).name ())
+            .arg (resource_manager::storage_class_names ().at (i));
+        }
+    }
+
+  setToolTip (tool_tip);
+
+  m_columns_shown = QStringList ();
+  m_columns_shown.append (tr ("Class"));
+  m_columns_shown.append (tr ("Dimension"));
+  m_columns_shown.append (tr ("Value"));
+  m_columns_shown.append (tr ("Attribute"));
+
+  m_columns_shown_keys = QStringList ();
+  m_columns_shown_keys.append ("workspaceview/show_class");
+  m_columns_shown_keys.append ("workspaceview/show_dimension");
+  m_columns_shown_keys.append ("workspaceview/show_value");
+  m_columns_shown_keys.append ("workspaceview/show_attribute");
+
+  m_sig_mapper = nullptr;
+}
+
 void
 workspace_view::save_settings (void)
 {
   QSettings *settings = resource_manager::get_settings ();
 
   if (! settings)
     return;
 
   settings->setValue ("workspaceview/column_state",
-                      view->horizontalHeader ()->saveState ());
+                      m_view->horizontalHeader ()->saveState ());
 
-  int sort_column = view->horizontalHeader ()->sortIndicatorSection ();
-  Qt::SortOrder sort_order = view->horizontalHeader ()->sortIndicatorOrder ();
+  int sort_column = m_view->horizontalHeader ()->sortIndicatorSection ();
+  Qt::SortOrder sort_order = m_view->horizontalHeader ()->sortIndicatorOrder ();
   settings->setValue ("workspaceview/sort_by_column", sort_column);
   settings->setValue ("workspaceview/sort_order", sort_order);
 
   settings->setValue ("workspaceview/filter_active",
-                      _filter_checkbox->isChecked ());
-  settings->setValue ("workspaceview/filter_shown", _filter_shown);
+                      m_filter_checkbox->isChecked ());
+  settings->setValue ("workspaceview/filter_shown", m_filter_shown);
 
   QStringList mru;
-  for (int i = 0; i < _filter->count (); i++)
-    mru.append (_filter->itemText (i));
+  for (int i = 0; i < m_filter->count (); i++)
+    mru.append (m_filter->itemText (i));
   settings->setValue ("workspaceview/mru_list", mru);
 
   settings->sync ();
 
-  if (_sig_mapper)
-    delete _sig_mapper;
-}
-
-void workspace_view::setModel (workspace_model *model)
-{
-  _filter_model.setSourceModel (model);
-  _filter_model.setFilterKeyColumn(0);
-
-  view->setModel (&_filter_model);
-
-  // set the sorting after a model was set, it would be ignored otherwise
-  QSettings *settings = resource_manager::get_settings ();
-  view->sortByColumn (
-    settings->value ("workspaceview/sort_by_column",0).toInt (),
-    static_cast<Qt::SortOrder>
-    (settings->value ("workspaceview/sort_order", Qt::AscendingOrder).toUInt ())
-  );
-
-  _model = model;
+  if (m_sig_mapper)
+    delete m_sig_mapper;
 }
 
 void
 workspace_view::closeEvent (QCloseEvent *e)
 {
   emit active_changed (false);
   QDockWidget::closeEvent (e);
 }
 
 void
 workspace_view::filter_update (const QString& expression)
 {
-  _filter_model.setFilterWildcard (expression);
+  m_filter_model.setFilterWildcard (expression);
   handle_model_changed ();
 }
 
 void
 workspace_view::filter_activate (bool state)
 {
-  _filter->setEnabled (state);
-  _filter_model.setDynamicSortFilter (state);
+  m_filter->setEnabled (state);
+  m_filter_model.setDynamicSortFilter (state);
 
   if (state)
-    filter_update (_filter->currentText ());
+    filter_update (m_filter->currentText ());
   else
     filter_update (QString ());
 }
 
 void
-workspace_view::update_filter_history ()
+workspace_view::update_filter_history (void)
 {
-  QString text = _filter->currentText ();   // get current text
-  int index = _filter->findText (text);     // and its actual index
+  QString text = m_filter->currentText ();   // get current text
+  int index = m_filter->findText (text);     // and its actual index
 
   if (index > -1)
-    _filter->removeItem (index);    // remove if already existing
-
-  _filter->insertItem (0, text);    // (re)insert at beginning
-  _filter->setCurrentIndex (0);
-}
+    m_filter->removeItem (index);    // remove if already existing
 
-QString
-workspace_view::get_var_name (QModelIndex index)
-{
-  index = index.sibling (index.row (), 0);
-  QAbstractItemModel *m = view->model ();
-  QMap<int, QVariant> item_data = m->itemData (index);
-
-  return item_data[0].toString ();
+  m_filter->insertItem (0, text);    // (re)insert at beginning
+  m_filter->setCurrentIndex (0);
 }
 
 void
 workspace_view::header_contextmenu_requested (const QPoint& mpos)
 {
   QMenu menu (this);
 
-  if (_sig_mapper)
-    delete _sig_mapper;
-  _sig_mapper = new QSignalMapper (this);
+  if (m_sig_mapper)
+    delete m_sig_mapper;
+  m_sig_mapper = new QSignalMapper (this);
 
   QSettings *settings = resource_manager::get_settings ();
 
-  for (int i = 0; i < _columns_shown.size (); i++)
+  for (int i = 0; i < m_columns_shown.size (); i++)
     {
-      QAction *action = menu.addAction (_columns_shown.at (i),
-                                        _sig_mapper, SLOT (map ()));
-      _sig_mapper->setMapping (action, i);
+      QAction *action = menu.addAction (m_columns_shown.at (i),
+                                        m_sig_mapper, SLOT (map ()));
+      m_sig_mapper->setMapping (action, i);
       action->setCheckable (true);
-      action->setChecked (
-            settings->value (_columns_shown_keys.at (i),true).toBool ());
+      action->setChecked (settings->value (m_columns_shown_keys.at (i),true).toBool ());
     }
 
-  connect (_sig_mapper, SIGNAL (mapped (int)), this, SLOT (toggle_header (int)));
+  connect (m_sig_mapper, SIGNAL (mapped (int)), this, SLOT (toggle_header (int)));
 
-  menu.exec (view->mapToGlobal (mpos));
+  menu.exec (m_view->mapToGlobal (mpos));
 }
 
 void
 workspace_view::toggle_header (int col)
 {
   QSettings *settings = resource_manager::get_settings ();
 
-  QString key = _columns_shown_keys.at (col);
+  QString key = m_columns_shown_keys.at (col);
   bool shown = settings->value (key,true).toBool ();
 
-  view->setColumnHidden (col + 1, shown);
+  m_view->setColumnHidden (col + 1, shown);
 
   settings->setValue (key, ! shown);
   settings->sync ();
 
   octave_dock_widget::save_settings ();
 }
 
 void
 workspace_view::contextmenu_requested (const QPoint& qpos)
 {
   QMenu menu (this);
 
-  QModelIndex index = view->indexAt (qpos);
+  QModelIndex index = m_view->indexAt (qpos);
 
   // if it isnt Local, Glocal etc, allow the ctx menu
   if (index.isValid () && index.column () == 0)
     {
       QString var_name = get_var_name (index);
 
       menu.addAction (tr ("Open in Variable Editor"), this,
                       SLOT (handle_contextmenu_edit ()));
@@ -319,17 +346,17 @@ workspace_view::contextmenu_requested (c
                       SLOT (handle_contextmenu_copy ()));
 
       menu.addAction (tr ("Copy value"), this,
                       SLOT (handle_contextmenu_copy_value ()));
 
       QAction *rename = menu.addAction (tr ("Rename"), this,
                                         SLOT (handle_contextmenu_rename ()));
 
-      QAbstractItemModel *m = view->model ();
+      QAbstractItemModel *m = m_view->model ();
       const workspace_model *wm = static_cast<const workspace_model *> (m);
 
       if (! wm->is_top_level ())
         {
           rename->setDisabled (true);
           rename->setToolTip (tr ("Only top-level symbols may be renamed"));
         }
 
@@ -343,45 +370,45 @@ workspace_view::contextmenu_requested (c
 
       menu.addAction ("stem (" + var_name + ')', this,
                       SLOT (handle_contextmenu_stem ()));
 
       menu.addSeparator ();
 
     }
 
-  if (_filter_shown)
+  if (m_filter_shown)
     menu.addAction (tr ("Hide filter"), this,
                     SLOT (handle_contextmenu_filter ()));
   else
     menu.addAction (tr ("Show filter"), this,
                     SLOT (handle_contextmenu_filter ()));
 
-  menu.exec (view->mapToGlobal (qpos));
+  menu.exec (m_view->mapToGlobal (qpos));
 }
 
 void
 workspace_view::handle_contextmenu_copy (void)
 {
-  QModelIndex index = view->currentIndex ();
+  QModelIndex index = m_view->currentIndex ();
 
   if (index.isValid ())
     {
       QString var_name = get_var_name (index);
 
       QClipboard *clipboard = QApplication::clipboard ();
 
       clipboard->setText (var_name);
     }
 }
 
 void
 workspace_view::handle_contextmenu_copy_value (void)
 {
-  QModelIndex index = view->currentIndex ();
+  QModelIndex index = m_view->currentIndex ();
 
   if (index.isValid ())
     {
       QString var_name = get_var_name (index);
 
       octave::symbol_table::scope *scope
         = octave::__get_current_scope__ ("workspace_view::handle_contextmenu_copy_value");
 
@@ -392,17 +419,17 @@ workspace_view::handle_contextmenu_copy_
       QClipboard *clipboard = QApplication::clipboard ();
       clipboard->setText (QString::fromStdString (buf.str ()));
     }
 }
 
 void
 workspace_view::handle_contextmenu_rename (void)
 {
-  QModelIndex index = view->currentIndex ();
+  QModelIndex index = m_view->currentIndex ();
 
   if (index.isValid ())
     {
       QString var_name = get_var_name (index);
 
       QInputDialog *inputDialog = new QInputDialog ();
 
       inputDialog->setOptions (QInputDialog::NoButtons);
@@ -410,32 +437,32 @@ workspace_view::handle_contextmenu_renam
       bool ok = false;
 
       QString new_name
         = inputDialog->getText (nullptr, "Rename Variable", "New name:",
                                 QLineEdit::Normal, var_name, &ok);
 
       if (ok && ! new_name.isEmpty ())
         {
-          QAbstractItemModel *m = view->model ();
+          QAbstractItemModel *m = m_view->model ();
           m->setData (index, new_name, Qt::EditRole);
         }
     }
 }
 
 void
 workspace_view::handle_contextmenu_edit (void)
 {
-  QModelIndex index = view->currentIndex ();
+  QModelIndex index = m_view->currentIndex ();
 
   if (index.isValid ())
     {
       index = index.sibling (index.row (), 0);
 
-      QAbstractItemModel *m = view->model ();
+      QAbstractItemModel *m = m_view->model ();
 
       QMap<int, QVariant> item_data = m->itemData (index);
 
       QString var_name = item_data[0].toString ();
 
       emit edit_variable_signal (var_name);
     }
 }
@@ -454,99 +481,64 @@ workspace_view::handle_contextmenu_plot 
 
 void
 workspace_view::handle_contextmenu_stem (void)
 {
   relay_contextmenu_command ("figure (); stem");
 }
 
 void
+workspace_view::handle_contextmenu_filter (void)
+{
+  m_filter_shown = ! m_filter_shown;
+  m_filter_widget->setVisible (m_filter_shown);
+}
+
+void
+workspace_view::handle_model_changed (void)
+{
+  // m_view->resizeRowsToContents ();
+  // Just modify those rows that have been added rather than go through
+  // the whole list.  For-loop test will handle when number of rows reduced.
+  QFontMetrics fm = m_view->fontMetrics ();
+  int row_height = fm.height ();
+  int new_row_count = m_filter_model.rowCount ();
+  for (int i = m_view_previous_row_count; i < new_row_count; i++)
+    m_view->setRowHeight (i, row_height);
+  m_view_previous_row_count = new_row_count;
+}
+
+void
+workspace_view::copyClipboard ()
+{
+  if (m_view->hasFocus ())
+    handle_contextmenu_copy ();
+}
+
+void
+workspace_view::selectAll ()
+{
+  if (m_view->hasFocus ())
+    m_view->selectAll ();
+}
+
+void
 workspace_view::relay_contextmenu_command (const QString& cmdname)
 {
-  QModelIndex index = view->currentIndex ();
+  QModelIndex index = m_view->currentIndex ();
 
   if (index.isValid ())
     {
       QString var_name = get_var_name (index);
 
       emit command_requested (cmdname + " (" + var_name + ");");
     }
 }
 
-void
-workspace_view::handle_contextmenu_filter (void)
-{
-  _filter_shown = not _filter_shown;
-  _filter_widget->setVisible (_filter_shown);
-}
-
-void
-workspace_view::handle_model_changed (void)
+QString
+workspace_view::get_var_name (QModelIndex index)
 {
-//  view->resizeRowsToContents ();
-  // Just modify those rows that have been added rather than go through
-  // the whole list.  For-loop test will handle when number of rows reduced.
-  QFontMetrics fm = view->fontMetrics ();
-  int row_height = fm.height ();
-  int new_row_count = _filter_model.rowCount ();
-  for (int i = view_previous_row_count; i < new_row_count; i++)
-    view->setRowHeight (i, row_height);
-  view_previous_row_count = new_row_count;
-}
-
-void
-workspace_view::notice_settings (const QSettings *settings)
-{
-  int i;
-
-  _model->notice_settings (settings); // update colors of model first
-
-  for (i = 0; i < _columns_shown_keys.size (); i++)
-    {
-      view->setColumnHidden (i + 1,
-            ! settings->value (_columns_shown_keys.at (i),true).toBool ());
-    }
-
-  QString tool_tip;
+  index = index.sibling (index.row (), 0);
+  QAbstractItemModel *m = m_view->model ();
+  QMap<int, QVariant> item_data = m->itemData (index);
 
-  if (! settings->value ("workspaceview/hide_tool_tips",false).toBool ())
-    {
-      tool_tip  = QString (tr ("View the variables in the active workspace.<br>"));
-      tool_tip += QString (tr ("Colors for variable attributes:"));
-      for (i = 0; i < resource_manager::storage_class_chars ().length (); i++)
-        {
-          tool_tip +=
-            QString (R"(<div style="background-color:%1;color:#000000">%2</div>)")
-            .arg (_model->storage_class_color (i).name ())
-            .arg (resource_manager::storage_class_names ().at (i));
-        }
-    }
-
-  setToolTip (tool_tip);
-
-  _columns_shown = QStringList ();
-  _columns_shown.append (tr ("Class"));
-  _columns_shown.append (tr ("Dimension"));
-  _columns_shown.append (tr ("Value"));
-  _columns_shown.append (tr ("Attribute"));
-
-  _columns_shown_keys = QStringList ();
-  _columns_shown_keys.append ("workspaceview/show_class");
-  _columns_shown_keys.append ("workspaceview/show_dimension");
-  _columns_shown_keys.append ("workspaceview/show_value");
-  _columns_shown_keys.append ("workspaceview/show_attribute");
-
-  _sig_mapper = nullptr;
+  return item_data[0].toString ();
 }
-
-void
-workspace_view::copyClipboard ()
-{
-  if (view->hasFocus ())
-    handle_contextmenu_copy ();
-}
-
-void
-workspace_view::selectAll ()
-{
-  if (view->hasFocus ())
-    view->selectAll ();
-}
diff --git a/libgui/src/workspace-view.h b/libgui/src/workspace-view.h
--- a/libgui/src/workspace-view.h
+++ b/libgui/src/workspace-view.h
@@ -42,19 +42,19 @@ class workspace_view : public octave_doc
 public:
 
   workspace_view (QWidget *parent = nullptr);
 
   ~workspace_view (void) = default;
 
 public slots:
 
-  void notice_settings (const QSettings *);
+  void setModel (workspace_model *model);
 
-  void setModel (workspace_model *model);
+  void notice_settings (const QSettings *);
 
   void save_settings (void);
 
 signals:
 
   /** signal that user had requested a command on a variable */
   void command_requested (const QString& cmd);
 
@@ -62,55 +62,56 @@ signals:
   void edit_variable_signal (const QString&);
 
 protected:
 
   void closeEvent (QCloseEvent *event);
 
 protected slots:
 
+  void filter_update (const QString& expression);
+  void filter_activate (bool enable);
+  void update_filter_history (void);
+
+  void header_contextmenu_requested (const QPoint& mpos);
+
+  void toggle_header (int column);
+
   void contextmenu_requested (const QPoint& pos);
 
-  // context menu slots
   void handle_contextmenu_copy (void);
   void handle_contextmenu_copy_value (void);
   void handle_contextmenu_rename (void);
   void handle_contextmenu_edit (void);
   void handle_contextmenu_disp (void);
   void handle_contextmenu_plot (void);
   void handle_contextmenu_stem (void);
   void handle_contextmenu_filter (void);
 
-  void header_contextmenu_requested (const QPoint& mpos);
-  void toggle_header (int column);
-
   void handle_model_changed (void);
 
-  void copyClipboard ();
-  void selectAll ();
-
-  void filter_update (const QString& expression);
-  void filter_activate (bool enable);
-  void update_filter_history ();
+  void copyClipboard (void);
+  void selectAll (void);
 
 private:
 
   void relay_contextmenu_command (const QString& cmdname);
 
   QString get_var_name (QModelIndex index);
-  QTableView *view;
-  int view_previous_row_count;
-  workspace_model *_model;
+
+  QTableView *m_view;
+  int m_view_previous_row_count;
+  workspace_model *m_model;
 
-  QSortFilterProxyModel _filter_model;
-  QCheckBox *_filter_checkbox;
-  QComboBox *_filter;
-  QWidget *_filter_widget;
-  bool _filter_shown;
+  QSortFilterProxyModel m_filter_model;
+  QCheckBox *m_filter_checkbox;
+  QComboBox *m_filter;
+  QWidget *m_filter_widget;
+  bool m_filter_shown;
 
   enum { MaxFilterHistory = 10 };
 
-  QStringList _columns_shown;
-  QStringList _columns_shown_keys;
-  QSignalMapper *_sig_mapper;
+  QStringList m_columns_shown;
+  QStringList m_columns_shown_keys;
+  QSignalMapper *m_sig_mapper;
 };
 
 #endif
