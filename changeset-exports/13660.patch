# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1315223565 18000
#      Mon Sep 05 06:52:45 2011 -0500
# Node ID 632f653a29a0fcd69759525aa7968f37d4c9b1d5
# Parent  d98c6ef06dff1c0048e0e0239afdffd7b8a78ea3
# Parent  bf61bc52380516c21558ba1b44c68443f6e99ac0
Merge with Savannah

diff --git a/build-aux/common.mk b/build-aux/common.mk
--- a/build-aux/common.mk
+++ b/build-aux/common.mk
@@ -157,18 +157,16 @@ SH_LDFLAGS = @SH_LDFLAGS@
 
 DL_LD = @DL_LD@
 DL_LDFLAGS = @DL_LDFLAGS@
 
 SONAME_FLAGS = @SONAME_FLAGS@
 
 RDYNAMIC_FLAG = @RDYNAMIC_FLAG@
 
-RLD_FLAG = @RLD_FLAG@
-
 FLIBS = @FLIBS@
 
 LIBOCTINTERP = @LIBOCTINTERP@
 LIBOCTAVE = @LIBOCTAVE@
 LIBCRUFT = @LIBCRUFT@
 
 FT2_CFLAGS = @FT2_CFLAGS@
 FT2_LIBS = @FT2_LIBS@
@@ -530,33 +528,36 @@ echo "making $@ from $<"
   -e "s|%OCTAVE_CONF_LIBOCTAVE%|\"${LIBOCTAVE}\"|" \
   -e "s|%OCTAVE_CONF_LIBOCTINTERP%|\"${LIBOCTINTERP}\"|" \
   -e "s|%OCTAVE_CONF_LIBS%|\"${LIBS}\"|" \
   -e "s|%OCTAVE_CONF_LN_S%|\"${LN_S}\"|" \
   -e "s|%OCTAVE_CONF_MAGICK_CPPFLAGS%|\"${MAGICK_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_MAGICK_LDFLAGS%|\"${MAGICK_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_MAGICK_LIBS%|\"${MAGICK_LIBS}\"|" \
   -e 's|%OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%|\"@MKOCTFILE_DL_LDFLAGS@\"|' \
+  -e "s|%OCTAVE_CONF_OCTAVE_LINK_DEPS%|\"${OCTAVE_LINK_DEPS}\"|" \
+  -e "s|%OCTAVE_CONF_OCTAVE_LINK_OPTS%|\"${OCTAVE_LINK_OPTS}\"|" \
   -e "s|%OCTAVE_CONF_OCTINCLUDEDIR%|\"${octincludedir}\"|" \
   -e "s|%OCTAVE_CONF_OCTLIBDIR%|\"${octlibdir}\"|" \
+  -e "s|%OCTAVE_CONF_OCT_LINK_DEPS%|\"${OCT_LINK_DEPS}\"|" \
+  -e "s|%OCTAVE_CONF_OCT_LINK_OPTS%|\"${OCT_LINK_OPTS}\"|" \
   -e "s|%OCTAVE_CONF_OPENGL_LIBS%|\"${OPENGL_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_PREFIX%|\"${prefix}\"|" \
   -e "s|%OCTAVE_CONF_PTHREAD_CFLAGS%|\"${PTHREAD_CFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_PTHREAD_LIBS%|\"${PTHREAD_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_QHULL_CPPFLAGS%|\"${QHULL_CPPFLAGSS}\"|" \
   -e "s|%OCTAVE_CONF_QHULL_LDFLAGS%|\"${QHULL_LDFLAGSS}\"|" \
   -e "s|%OCTAVE_CONF_QHULL_LIBS%|\"${QHULL_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_QRUPDATE_CPPFLAGS%|\"${QRUPDATE_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_QRUPDATE_LDFLAGS%|\"${QRUPDATE_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_QRUPDATE_LIBS%|\"${QRUPDATE_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_RANLIB%|\"${RANLIB}\"|" \
   -e "s|%OCTAVE_CONF_RDYNAMIC_FLAG%|\"${RDYNAMIC_FLAG}\"|" \
   -e "s|%OCTAVE_CONF_READLINE_LIBS%|\"${READLINE_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_REGEX_LIBS%|\"${REGEX_LIBS}\"|" \
-  -e "s|%OCTAVE_CONF_RLD_FLAG%|\"${RLD_FLAG}\"|" \
   -e "s|%OCTAVE_CONF_SED%|\"${SED}\"|" \
   -e "s|%OCTAVE_CONF_SHARED_LIBS%|\"${SHARED_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_SHLEXT%|\"${SHLEXT}\"|" \
   -e "s|%OCTAVE_CONF_SHLLINKEXT%|\"${SHLLINKEXT}\"|" \
   -e "s|%OCTAVE_CONF_SHLEXT_VER%|\"${SHLEXT_VER}\"|" \
   -e "s|%OCTAVE_CONF_SH_LD%|\"${SH_LD}\"|" \
   -e "s|%OCTAVE_CONF_SH_LDFLAGS%|\"${SH_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_SONAME_FLAGS%|\"${SONAME_FLAGS}\"|" \
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -1152,39 +1152,29 @@ fi
 
 ### Enable dynamic linking.  --enable-shared implies this, so
 ### --enable-dl is only need if you are only building static libraries
 ### and want to try dynamic linking too (works on some systems, for
 ### example, OS X and Windows).
 
 AC_ARG_ENABLE([dl],
   [AS_HELP_STRING([--enable-dl],
-    [create shared libraries (not all systems)])], [
+    [allow loading of dynamically linked modules (not all systems)])], [
   case "${enableval}" in
     yes) ENABLE_DYNAMIC_LINKING=true ;;
     no) ENABLE_DYNAMIC_LINKING=false ;;
     *) AC_MSG_ERROR([bad value ${enableval} for --enable-dl]) ;;
   esac], [ENABLE_DYNAMIC_LINKING=true])
 
 if $STATIC_LIBS || $SHARED_LIBS; then
   true
 else
   AC_MSG_ERROR([You can't disable building static AND shared libraries!])
 fi
 
-AC_ARG_ENABLE(rpath,
-  [AS_HELP_STRING([--enable-rpath],
-     [override the default link options for rpath; e.g., --enable-rpath='-rpath $(octlibdir)'])],
-  [ if test "$enableval" = no; then use_rpath=false;
-    else
-      use_rpath=true
-      if test "$enableval" = yes; then true;
-      else enable_rpath_arg="$enableval"; fi
-    fi], [use_rpath=true])
-
 CPICFLAG=-fPIC
 CXXPICFLAG=-fPIC
 FPICFLAG=-fPIC
 SHLEXT=so
 SHLLIB='$(SHLEXT)'
 SHLBIN=
 SHLEXT_VER='$(SHLEXT).$(version)'
 SHLLIB_VER='$(SHLLIB).$(version)'
@@ -1195,17 +1185,16 @@ SHLPRE=lib
 SHLLIBPRE=lib
 SHLBINPRE=lib
 SH_LD='$(CXX)'
 SH_LDFLAGS=-shared
 DL_LD='$(SH_LD)'
 DL_LDFLAGS='$(SH_LDFLAGS)'
 MKOCTFILE_DL_LDFLAGS='$(DL_LDFLAGS)'
 SONAME_FLAGS=
-RLD_FLAG=
 NO_OCT_FILE_STRIP=false
 TEMPLATE_AR='$(AR)'
 TEMPLATE_ARFLAGS="$ARFLAGS"
 CRUFT_DLL_DEFS=
 OCTAVE_DLL_DEFS=
 OCTINTERP_DLL_DEFS=
 OCTGRAPHICS_DLL_DEFS=
 library_path_var=LD_LIBRARY_PATH
@@ -1216,24 +1205,22 @@ case "$canonical_host_type" in
     SH_LD=ld
     SH_LDFLAGS=-Bshareable
   ;;
   *-*-openbsd*)
     SH_LDFLAGS='-shared -fPIC'
   ;;
   *-*-freebsd*)
     SH_LDFLAGS="-shared -Wl,-x"
-    RLD_FLAG='-Wl,-rpath -Wl,$(octlibdir)'
   ;;
   alpha*-dec-osf*)
     CPICFLAG=
     CXXPICFLAG=
     FPICFLAG=
     SH_LDFLAGS="-shared -Wl,-expect_unresolved -Wl,'*'"
-    RLD_FLAG='-Wl,-rpath -Wl,$(octlibdir)'
   ;;
   *-*-darwin*)
     DL_LDFLAGS='-bundle -bundle_loader $(top_builddir)/src/octave $(LDFLAGS)'
     MKOCTFILE_DL_LDFLAGS='-bundle -bundle_loader $$BINDIR/octave-$$OCTAVE_VERSION$$EXEEXT'
     SH_LDFLAGS='-dynamiclib -single_module $(LDFLAGS)'
     case "$canonical_host_type" in
       powerpc-*)
         CXXPICFLAG=
@@ -1330,64 +1317,58 @@ case "$canonical_host_type" in
     CRUFT_DLL_DEFS="-DCRUFT_DLL"
     OCTAVE_DLL_DEFS="-DOCTAVE_DLL"
     OCTINTERP_DLL_DEFS="-DOCTINTERP_DLL"
     OCTGRAPHICS_DLL_DEFS="-DOCTGRAPHICS_DLL"
   ;;
   *-*-linux* | *-*-gnu*)
     MKOCTFILE_DL_LDFLAGS="-shared -Wl,-Bsymbolic"
     SONAME_FLAGS='-Wl,-soname -Wl,$@'
-    RLD_FLAG='-Wl,-rpath -Wl,$(octlibdir)'
   ;;
   i[[3456]]86-*-sco3.2v5*)
     SONAME_FLAGS='-Wl,-h -Wl,$@'
-    RLD_FLAG=
     SH_LDFLAGS=-G
   ;;
   rs6000-ibm-aix* | powerpc-ibm-aix*)
     CPICFLAG=
     CXXPICFLAG=
     FPICFLAG=
     library_path_var=LIBPATH
   ;;
   hppa*-hp-hpux*)
     if test "$ac_cv_f77_compiler_gnu" = yes; then
       FPICFLAG=-fPIC
     else
       FPICFLAG=+Z
     fi
     SHLEXT=sl
     SH_LDFLAGS="-shared -fPIC"
-    RLD_FLAG='-Wl,+b -Wl,$(octlibdir)'
     library_path_var=SHLIB_PATH
   ;;
   ia64*-hp-hpux*)
     if test "$ac_cv_f77_compiler_gnu" = yes; then
       FPICFLAG=-fPIC
     else
       FPICFLAG=+Z
     fi
     SH_LDFLAGS="-shared -fPIC"
-    RLD_FLAG='-Wl,+b -Wl,$(octlibdir)'
   ;;
   *-sgi-*)
     CPICFLAG=
     CXXPICFLAG=
     FPICFLAG=
-    RLD_FLAG='-rpath $(octlibdir)'
   ;;
   sparc-sun-sunos4*)
     if test "$ac_cv_f77_compiler_gnu" = yes; then
       FPICFLAG=-fPIC
     else
       FPICFLAG=-PIC
     fi
     SH_LD=ld
     SH_LDFLAGS="-assert nodefinitions"
-    RLD_FLAG='-L$(octlibdir)'
   ;;
   sparc-sun-solaris2* | i386-pc-solaris2*)
     if test "$ac_cv_f77_compiler_gnu" = yes; then
       FPICFLAG=-fPIC
     else
       FPICFLAG=-KPIC
     fi
     if test "$GCC" = yes; then
@@ -1397,38 +1378,29 @@ case "$canonical_host_type" in
     fi
     if test "$GXX" = yes; then
       CXXPICFLAG=-fPIC
       SH_LDFLAGS=-shared
     else
       CXXPICFLAG=-KPIC
       SH_LDFLAGS=-G
     fi
-    RLD_FLAG='-R $(octlibdir)'
     ## Template closures in archive libraries need a different mechanism.
     if test "$GXX" = yes; then
       true
     else
       TEMPLATE_AR='$(CXX)'
       TEMPLATE_ARFLAGS="-xar -o"
     fi
   ;;
 esac
 
 AM_CONDITIONAL([AMCOND_BUILD_COMPILED_AUX_PROGRAMS],
   [test x$BUILD_COMPILED_AUX_PROGRAMS = xtrue])
 
-if $use_rpath; then
-  if test -n "$enable_rpath_arg"; then
-    RLD_FLAG="$enable_rpath_arg"
-  fi
-else
-  RLD_FLAG=""
-fi
-
 AC_MSG_NOTICE([defining FPICFLAG to be $FPICFLAG])
 AC_MSG_NOTICE([defining CPICFLAG to be $CPICFLAG])
 AC_MSG_NOTICE([defining CXXPICFLAG to be $CXXPICFLAG])
 AC_MSG_NOTICE([defining SHLEXT to be $SHLEXT])
 AC_MSG_NOTICE([defining SHLLIB to be $SHLLIB])
 AC_MSG_NOTICE([defining SHLBIN to be $SHLBIN])
 AC_MSG_NOTICE([defining SHLEXT_VER to be $SHLEXT_VER])
 AC_MSG_NOTICE([defining SHLLIB_VER to be $SHLLIB_VER])
@@ -1440,17 +1412,16 @@ AC_MSG_NOTICE([defining SHLLIBPRE to be 
 AC_MSG_NOTICE([defining SHLBINPRE to be $SHLBINPRE])
 AC_MSG_NOTICE([defining SH_LD to be $SH_LD])
 AC_MSG_NOTICE([defining SH_LDFLAGS to be $SH_LDFLAGS])
 AC_MSG_NOTICE([defining DL_LD to be $DL_LD])
 AC_MSG_NOTICE([defining DL_LDFLAGS to be $DL_LDFLAGS])
 AC_MSG_NOTICE([defining MKOCTFILE_DL_LDFLAGS to be $MKOCTFILE_DL_LDFLAGS])
 AC_MSG_NOTICE([defining SONAME_FLAGS to be $SONAME_FLAGS])
 AC_MSG_NOTICE([defining NO_OCT_FILE_STRIP to be $NO_OCT_FILE_STRIP])
-AC_MSG_NOTICE([defining RLD_FLAG to be $RLD_FLAG])
 AC_MSG_NOTICE([defining TEMPLATE_AR to be $TEMPLATE_AR])
 AC_MSG_NOTICE([defining TEMPLATE_ARFLAGS to be $TEMPLATE_ARFLAGS])
 AC_MSG_NOTICE([defining CRUFT_DLL_DEFS to be $CRUFT_DLL_DEFS])
 AC_MSG_NOTICE([defining OCTAVE_DLL_DEFS to be $OCTAVE_DLL_DEFS])
 AC_MSG_NOTICE([defining OCTINTERP_DLL_DEFS to be $OCTINTERP_DLL_DEFS])
 AC_MSG_NOTICE([defining OCTGRAPHICS_DLL_DEFS to be $OCTGRAPHICS_DLL_DEFS])
 AC_MSG_NOTICE([defining library_path_var to be $library_path_var])
 AC_SUBST(FPICFLAG)
@@ -1469,52 +1440,65 @@ AC_SUBST(SHLLIBPRE)
 AC_SUBST(SHLBINPRE)
 AC_SUBST(SH_LD)
 AC_SUBST(SH_LDFLAGS)
 AC_SUBST(DL_LD)
 AC_SUBST(DL_LDFLAGS)
 AC_SUBST(MKOCTFILE_DL_LDFLAGS)
 AC_SUBST(SONAME_FLAGS)
 AC_SUBST(NO_OCT_FILE_STRIP)
-AC_SUBST(RLD_FLAG)
 AC_SUBST(TEMPLATE_AR)
 AC_SUBST(TEMPLATE_ARFLAGS)
 AC_SUBST(CRUFT_DLL_DEFS)
 AC_SUBST(OCTAVE_DLL_DEFS)
 AC_SUBST(OCTINTERP_DLL_DEFS)
 AC_SUBST(OCTGRAPHICS_DLL_DEFS)
 AC_SUBST(library_path_var)
 AC_SUBST(ldpreloadsep)
 
 ### special checks for odd OS specific things.
 
 AC_CHECK_FUNCS(getpwnam, [], [AC_CHECK_LIB(sun, getpwnam)])
 
-NO_UNDEFINED_LDFLAG=
 case "$canonical_host_type" in
   *-*-mingw*)
     if test "$have_msvc" = "yes"; then
       AC_CHECK_LIB(dirent, opendir)
       LIBS="$LIBS -ladvapi32 -lgdi32 -lws2_32 -luser32 -lkernel32"
-      NO_UNDEFINED_LDFLAG=-no-undefined
     else
       LIBS="$LIBS -lgdi32 -lws2_32 -luser32 -lkernel32"
-      NO_UNDEFINED_LDFLAG=-no-undefined
     fi
     LIBS="$LIBS -lgdi32 -lws2_32 -luser32 -lkernel32"
-    NO_UNDEFINED_LDFLAG=-no-undefined
   ;;
   *-*-msdosmsvc*)
     AC_CHECK_LIB(dirent, opendir)
     LIBS="$LIBS -ladvapi32 -lgdi32 -lws2_32 -luser32 -lkernel32"
-    NO_UNDEFINED_LDFLAG=-no-undefined
   ;;
 esac
+
+AC_ARG_ENABLE([no-undefined],
+  [AS_HELP_STRING([--enable-no-undefined],
+    [pass -no-undefined to libtool when linking linking Octave and its shared libraries (on by default)])],
+  [case "${enableval}" in
+    yes) NO_UNDEFINED_LDFLAG="-no-undefined" ;;
+    no)  NO_UNDEFINED_LDFLAG="" ;;
+    *) AC_MSG_ERROR([bad value ${enableval} for --enable-link-all-depenencies]) ;;
+   esac], [NO_UNDEFINED_LDFLAG="-no-undefined"])
 AC_SUBST(NO_UNDEFINED_LDFLAG)
 
+AC_ARG_ENABLE([link-all-dependencies],
+  [AS_HELP_STRING([--enable-link-all-dependencies],
+    [link Octave and its shared libraries with all dependencies, not just those immediately referenced (should not be needed on most systems)])],
+  [case "${enableval}" in
+    yes) link_all_deps=true ;;
+    no)  link_all_deps=false ;;
+    *) AC_MSG_ERROR([bad value ${enableval} for --enable-link-all-depenencies]) ;;
+   esac], [link_all_deps=false])
+AM_CONDITIONAL([AMCOND_LINK_ALL_DEPS], [test x$link_all_deps = xtrue])
+
 ### Type stuff.
 
 AC_TYPE_MODE_T
 AC_TYPE_OFF_T
 AC_TYPE_PID_T
 AC_TYPE_SIZE_T
 AC_TYPE_UID_T
 AC_CHECK_TYPES([dev_t, ino_t])
@@ -1680,17 +1664,17 @@ if $SHARED_LIBS || $ENABLE_DYNAMIC_LINKI
   case "$lt_cv_dlopen" in
     dlopen)
       dlopen_api=true
       DL_API_MSG="(dlopen)"
       AC_DEFINE(HAVE_DLOPEN_API, 1, [Define if your system has dlopen, dlsym, dlerror, and dlclose for dynamic linking])
       OCTAVE_CXX_FLAG(-rdynamic, [RDYNAMIC_FLAG=-rdynamic])
     ;;
     shl_load)
-      shl_load_api=true
+      shl_load_api=truenn
       DL_API_MSG="(shl_load)"
       AC_DEFINE(HAVE_SHL_LOAD_API, 1, [Define if your system has shl_load and shl_findsym for dynamic linking])
     ;;
     LoadLibrary)
       loadlibrary_api=true
       DL_API_MSG="(LoadLibrary)"
       AC_DEFINE(HAVE_LOADLIBRARY_API, 1, [Define if your system has LoadLibrary for dynamic linking])
     ;;
@@ -1699,22 +1683,28 @@ if $SHARED_LIBS || $ENABLE_DYNAMIC_LINKI
       DL_API_MSG="(dyld)"
       AC_DEFINE(HAVE_DYLD_API, 1, [Define if your system has dyld for dynamic linking])
     ;;
   esac
 
   DL_LIBS="$lt_cv_dlopen_libs"
   AC_SUBST(DL_LIBS)
 
+  ## Disable dynamic linking if capability is not present.
   if $dlopen_api || $shl_load_api || $loadlibrary_api || $dyld_api; then
-    ENABLE_DYNAMIC_LINKING=true
-    AC_DEFINE(ENABLE_DYNAMIC_LINKING, 1, [Define if using dynamic linking])
+    true
+  else
+    ENABLE_DYNAMIC_LINKING=false
   fi
 fi
 
+if $ENABLE_DYNAMIC_LINKING; then
+  AC_DEFINE(ENABLE_DYNAMIC_LINKING, 1, [Define if using dynamic linking])
+fi
+
 AM_CONDITIONAL([AMCOND_ENABLE_DYNAMIC_LINKING],
   [test x$ENABLE_DYNAMIC_LINKING = xtrue])
 
 if $SHARED_LIBS; then
    LIBOCTINTERP=-loctinterp$SHLLINKEXT
    LIBOCTAVE=-loctave$SHLLINKEXT
    LIBCRUFT=-lcruft$SHLLINKEXT
 else
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -4,16 +4,17 @@ Giles Anderson
 Joel Andersson
 Muthiah Annamalai
 Shai Ayal
 Roger Banks
 Ben Barrowes
 Alexander Barth
 David Bateman
 Heinz Bauschke
+Roman Belov
 Karl Berry
 David Billinghurst
 Don Bindner
 Jakub Bogusz
 Moritz Borgmann
 Richard Bovey
 Marcus Brinkmann
 Remy Bruno
diff --git a/doc/interpreter/linalg.txi b/doc/interpreter/linalg.txi
--- a/doc/interpreter/linalg.txi
+++ b/doc/interpreter/linalg.txi
@@ -182,13 +182,15 @@ flag a non-Hermitian matrix.
 
 @DOCSTRING(blkmm)
 
 @DOCSTRING(syl)
 
 @node Specialized Solvers
 @section Specialized Solvers
 
+@DOCSTRING(bicg)
+
 @DOCSTRING(bicgstab)
 
 @DOCSTRING(cgs)
 
 @DOCSTRING(gmres)
diff --git a/doc/interpreter/matrix.txi b/doc/interpreter/matrix.txi
--- a/doc/interpreter/matrix.txi
+++ b/doc/interpreter/matrix.txi
@@ -76,16 +76,19 @@ Note that in conditional contexts (like 
 @DOCSTRING(isfinite)
 
 @DOCSTRING(common_size)
 
 @DOCSTRING(find)
         
 @DOCSTRING(lookup)
 
+If you wish to check if a variable exists at all, instead of properties
+its elements may have, consult @ref{Status of Variables}.
+
 @node Rearranging Matrices
 @section Rearranging Matrices
 
 @DOCSTRING(fliplr)
 
 @DOCSTRING(flipud)
 
 @DOCSTRING(flipdim)
diff --git a/doc/interpreter/mkoctfile.1 b/doc/interpreter/mkoctfile.1
--- a/doc/interpreter/mkoctfile.1
+++ b/doc/interpreter/mkoctfile.1
@@ -90,38 +90,39 @@ Create a MEX file.  Set the default outp
 .B \-o \fIfile\fP\fR,\fB \-\-output \fIfile\fP
 Output file name.  Default extension is \fB.oct\fP (or \fB.mex\fP if \-\-mex is
 specified) unless linking a stand-alone executable.
 .TP
 .B \-p \fIVAR\fP\fR,\fB \-\-print \fIVAR\fP
 Print configuration variable \fIVAR\fP.  Recognized variables are:
 .RS
 .Vb
-   ALL_CFLAGS                FFTW3F_LDFLAGS
-   ALL_CXXFLAGS              FFTW3F_LIBS
-   ALL_FFLAGS                FLIBS
-   ALL_LDFLAGS               FPICFLAG
-   BLAS_LIBS                 INCFLAGS
-   CC                        LAPACK_LIBS
-   CFLAGS                    LDFLAGS
-   CPICFLAG                  LD_CXX
-   CPPFLAGS                  LD_STATIC_FLAG
-   CXX                       LFLAGS
-   CXXFLAGS                  LIBCRUFT
-   CXXPICFLAG                LIBOCTAVE
-   DEPEND_EXTRA_SED_PATTERN  LIBOCTINTERP
-   DEPEND_FLAGS              LIBS
-   DL_LD                     OCTAVE_LIBS
-   DL_LDFLAGS                RDYNAMIC_FLAG
-   EXEEXT                    READLINE_LIBS
-   F77                       RLD_FLAG
-   F77_INTEGER_8_FLAG        SED
-   FFLAGS                    XTRA_CFLAGS
-   FFTW3_LDFLAGS             XTRA_CXXFLAGS
-   FFTW3_LIBS
+    ALL_CFLAGS                FFTW3F_LIBS
+    ALL_CXXFLAGS              FLIBS
+    ALL_FFLAGS                FPICFLAG
+    ALL_LDFLAGS               INCFLAGS
+    BLAS_LIBS                 LAPACK_LIBS
+    CC                        LDFLAGS
+    CFLAGS                    LD_CXX
+    CPICFLAG                  LD_STATIC_FLAG
+    CPPFLAGS                  LFLAGS
+    CXX                       LIBCRUFT
+    CXXFLAGS                  LIBOCTAVE
+    CXXPICFLAG                LIBOCTINTERP
+    DEPEND_EXTRA_SED_PATTERN  LIBS
+    DEPEND_FLAGS              OCTAVE_LIBS
+    DL_LD                     OCTAVE_LINK_DEPS
+    DL_LDFLAGS                OCT_LINK_DEPS
+    EXEEXT                    RDYNAMIC_FLAG
+    F77                       READLINE_LIBS
+    F77_INTEGER_8_FLAG        SED
+    FFLAGS                    XTRA_CFLAGS
+    FFTW3_LDFLAGS             XTRA_CXXFLAGS
+    FFTW3_LIBS
+    FFTW3F_LDFLAGS
 .Ve
 .RE
 .TP
 .B \-v\fR,\fB --verbose
 Echo commands as they are executed.
 .TP
 .B file
 Compile or link file.  Recognized file types are
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -831,8 +831,12 @@ variable.
 
 @DOCSTRING(ishermitian)
 
 @DOCSTRING(isdefinite)
 
 @DOCSTRING(islogical)
 
 @DOCSTRING(isprime)
+
+If instead of knowing properties of variables, you wish to know which
+variables are defined and to gather other information about the
+workspace itself, see @ref{Status of Variables}.
diff --git a/libcruft/Makefile.am b/libcruft/Makefile.am
--- a/libcruft/Makefile.am
+++ b/libcruft/Makefile.am
@@ -29,35 +29,37 @@ octlib_LTLIBRARIES = libcruft.la
 libcruft_la_SOURCES =
 
 libcruft_la_FFLAGS = $(F77_INTEGER_8_FLAG)
 
 libcruft_la_CPPFLAGS = \
   @CRUFT_DLL_DEFS@ \
   $(AM_CPPFLAGS)
 
+include link-deps.mk
+
+libcruft_la_LIBADD = \
+  libranlib.la \
+  ../libgnu/libgnu.la \
+  $(LIBCRUFT_LINK_DEPS)
+
 # Increment these as needed and according to the rules in the libtool
 # manual:
 libcruft_current = 0
 libcruft_revision = 0
 libcruft_age = 0
 
 libcruft_version_info = $(libcruft_current):$(libcruft_revision):$(libcruft_age)
 
 libcruft_la_LDFLAGS = \
   -version-info $(libcruft_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
   @XTRA_CRUFT_SH_LDFLAGS@ \
-  -bindir $(bindir)
-
-libcruft_la_LIBADD = \
-  ../libgnu/libgnu.la \
-  libranlib.la \
-  $(LAPACK_LIBS) $(BLAS_LIBS) \
-  $(FLIBS)
+  -bindir $(bindir) \
+  $(LIBCRUFT_LINK_OPTS)
 
 libcruft_la_DEPENDENCIES = cruft.def
 
 noinst_LTLIBRARIES = libranlib.la
 
 libranlib_la_SOURCES =
 
 libranlib_la_DEPENDENCIES = ranlib.def
diff --git a/libcruft/link-deps.mk b/libcruft/link-deps.mk
new file mode 100644
--- /dev/null
+++ b/libcruft/link-deps.mk
@@ -0,0 +1,30 @@
+## The following libraries may be needed to satisfy gnulib dependencies:
+##
+##   $(COPYSIGN_LIBM)
+##   $(FLOOR_LIBM)
+##   $(GETHOSTNAME_LIB)
+##   $(LIBSOCKET)
+##   $(LIB_NANOSLEEP)
+##   $(LTLIBINTL)
+##   $(ROUNDF_LIBM)
+##   $(ROUND_LIBM)
+##   $(TRUNCF_LIBM)
+##   $(TRUNC_LIBM)
+
+LIBCRUFT_LINK_DEPS = \
+  $(COPYSIGN_LIBM) \
+  $(FLOOR_LIBM) \
+  $(GETHOSTNAME_LIB) \
+  $(LIBSOCKET) \
+  $(LIB_NANOSLEEP) \
+  $(LTLIBINTL) \
+  $(ROUNDF_LIBM) \
+  $(ROUND_LIBM) \
+  $(TRUNCF_LIBM) \
+  $(TRUNC_LIBM) \
+  $(LAPACK_LIBS) \
+  $(BLAS_LIBS) \
+  $(FLIBS) \
+  $(LIBS)
+
+LIBCRUFT_LINK_OPTS =
diff --git a/liboctave/MSparse.h b/liboctave/MSparse.h
--- a/liboctave/MSparse.h
+++ b/liboctave/MSparse.h
@@ -60,16 +60,18 @@ public:
 
   MSparse (const Array<T>& a, const idx_vector& r, const idx_vector& c,
            octave_idx_type nr = -1, octave_idx_type nc = -1,
            bool sum_terms = true, octave_idx_type nzm = -1)
     : Sparse<T> (a, r, c, nr, nc, sum_terms, nzm) { }
 
   explicit MSparse (octave_idx_type r, octave_idx_type c, T val) : Sparse<T> (r, c, val) { }
 
+  explicit MSparse (const PermMatrix& a) : Sparse<T>(a) { }
+
   MSparse (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : Sparse<T> (r, c, num_nz) { }
 
   ~MSparse (void) { }
 
   MSparse<T>& operator = (const MSparse<T>& a)
     {
       Sparse<T>::operator = (a);
       return *this;
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -487,42 +487,31 @@ LIBOCTAVE_C_SOURCES = \
   tempname.c
 
 LIBOCT_READLINE_CXX_SOURCES = cmd-edit.cc cmd-hist.cc
 
 LIBOCT_READLINE_C_SOURCES = oct-rl-edit.c oct-rl-hist.c
 
 LIBOCT_READLINE_SOURCES = $(LIBOCT_READLINE_CXX_SOURCES) $(LIBOCT_READLINE_C_SOURCES)
 
-LINK_DEPS = \
-  $(RLD_FLAG) \
-  ../libcruft/libcruft.la \
-  ../libcruft/libranlib.la \
-  ../libgnu/libgnu.la \
-  $(SPARSE_XLIBS) \
-  $(ARPACK_LIBS) \
-  $(QRUPDATE_LIBS) \
-  $(FFTW_XLIBS) \
-  $(LAPACK_LIBS) $(BLAS_LIBS) \
-  $(READLINE_LIBS) $(TERM_LIBS) \
-  $(LIBGLOB) $(REGEX_LIBS) $(DL_LIBS) \
-  $(FLIBS) \
-  $(PTHREAD_LIBS) $(LIBS)
-
 liboctave_la_SOURCES = \
   $(LIBOCTAVE_CXX_SOURCES) \
   $(LIBOCTAVE_C_SOURCES) \
   $(LIBOCTAVE_SOURCES) \
   $(LIBOCT_READLINE_SOURCES) \
   $(LIBOCT_PATHSEARCH_SOURCES)
 
 nodist_liboctave_la_SOURCES = \
   $(BUILT_LIBOCTAVE_CXX_SOURCES)
 
-liboctave_la_LIBADD = $(LINK_DEPS)
+include link-deps.mk
+
+liboctave_la_LIBADD = \
+  ../libcruft/libcruft.la \
+  $(LIBOCTAVE_LINK_DEPS)
 
 liboctave_la_CPPFLAGS = \
   @OCTAVE_DLL_DEFS@ \
   $(SPARSE_XCPPFLAGS) \
   $(FFTW_XCPPFLAGS) \
   $(ARPACK_CPPFLAGS) \
   $(AM_CPPFLAGS)
 
@@ -533,20 +522,17 @@ liboctave_revision = 0
 liboctave_age = 0
 
 liboctave_version_info = $(liboctave_current):$(liboctave_revision):$(liboctave_age)
 
 liboctave_la_LDFLAGS = \
   -version-info $(liboctave_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
   -bindir $(bindir) \
-  $(SPARSE_XLDFLAGS) \
-  $(ARPACK_LDFLAGS) \
-  $(QRUPDATE_LDFLAGS) \
-  $(FFTW_XLDFLAGS)
+  $(LIBOCTAVE_LINK_OPTS)
 
 octinclude_HEADERS = \
   $(INCS) \
   $(OTHER_INC) \
   $(TEMPLATE_SRC) \
   $(EXTRA_HEADERS)
 
 nodist_octinclude_HEADERS = \
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -45,16 +45,44 @@ along with Octave; see the file COPYING.
 #include "oct-locbuf.h"
 
 #include "Sparse.h"
 #include "sparse-sort.h"
 #include "sparse-util.h"
 #include "oct-spparms.h"
 #include "mx-inlines.cc"
 
+#include "PermMatrix.h"
+
+template <class T>
+Sparse<T>::Sparse (const PermMatrix& a)
+  : rep (new typename Sparse<T>::SparseRep (a.rows (), a.cols (), a.rows ())),
+         dimensions (dim_vector (a.rows (), a.cols()))
+{
+  octave_idx_type n = a.rows ();
+  for (octave_idx_type i = 0; i <= n; i++)
+    cidx (i) = i;
+
+  const Array<octave_idx_type> pv = a.pvec ();
+
+  if (a.is_row_perm ())
+    {
+      for (octave_idx_type i = 0; i < n; i++)
+        ridx (pv (i)) = i;
+    }
+  else
+    {
+      for (octave_idx_type i = 0; i < n; i++)
+        ridx (i) = pv (i);
+    }
+
+  for (octave_idx_type i = 0; i < n; i++)
+    data (i) = 1.0;
+}
+
 template <class T>
 T&
 Sparse<T>::SparseRep::elem (octave_idx_type _r, octave_idx_type _c)
 {
   octave_idx_type i;
 
   if (nzmx > 0)
     {
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -36,16 +36,17 @@ along with Octave; see the file COPYING.
 #include "dim-vector.h"
 #include "lo-error.h"
 #include "lo-utils.h"
 
 #include "oct-sort.h"
 #include "oct-mem.h"
 
 class idx_vector;
+class PermMatrix;
 
 // Two dimensional sparse class.  Handles the reference counting for
 // all the derived classes.
 
 template <class T>
 class
 Sparse
 {
@@ -190,16 +191,20 @@ public:
   Sparse (const dim_vector& dv, octave_idx_type nz)
     : rep (new typename Sparse<T>::SparseRep (dv(0), dv(1), nz)),
     dimensions (dv) { }
 
   Sparse (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz)
     : rep (new typename Sparse<T>::SparseRep (nr, nc, nz)),
       dimensions (dim_vector (nr, nc)) { }
 
+  // Both SparseMatrix and SparseBoolMatrix need this ctor, and this
+  // is their only common ancestor.
+  explicit Sparse (const PermMatrix& a);
+
   // Type conversion case. Preserves capacity ().
   template <class U>
   Sparse (const Sparse<U>& a)
     : rep (new typename Sparse<T>::SparseRep (a.rep->nrows, a.rep->ncols, a.rep->nzmx)),
     dimensions (a.dimensions)
     {
       octave_idx_type nz = a.nnz ();
       std::copy (a.rep->d, a.rep->d + nz, rep->d);
diff --git a/liboctave/boolSparse.h b/liboctave/boolSparse.h
--- a/liboctave/boolSparse.h
+++ b/liboctave/boolSparse.h
@@ -52,16 +52,18 @@ public:
 
   SparseBoolMatrix (const SparseBoolMatrix& a, const dim_vector& dv)
     : Sparse<bool> (a, dv) { }
 
   explicit SparseBoolMatrix (const boolMatrix& a) : Sparse<bool> (a) { }
 
   explicit SparseBoolMatrix (const boolNDArray& a) : Sparse<bool> (a) { }
 
+  explicit SparseBoolMatrix (const PermMatrix& a) : Sparse<bool> (a) { };
+
   SparseBoolMatrix (const Array<bool>& a, const idx_vector& r,
                     const idx_vector& c, octave_idx_type nr = -1,
                     octave_idx_type nc = -1, bool sum_terms = true,
                     octave_idx_type nzm = -1)
     : Sparse<bool> (a, r, c, nr, nc, sum_terms, nzm) { }
 
   SparseBoolMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : Sparse<bool> (r, c, num_nz) { }
 
diff --git a/liboctave/bsxfun-decl.h b/liboctave/bsxfun-decl.h
--- a/liboctave/bsxfun-decl.h
+++ b/liboctave/bsxfun-decl.h
@@ -37,16 +37,22 @@ extern API boolNDArray bsxfun_ ## OP (co
   BSXFUN_OP_DECL (add, ARRAY, API) \
   BSXFUN_OP_DECL (sub, ARRAY, API) \
   BSXFUN_OP_DECL (mul, ARRAY, API) \
   BSXFUN_OP_DECL (div, ARRAY, API) \
   BSXFUN_OP_DECL (pow, ARRAY, API) \
   BSXFUN_OP_DECL (min, ARRAY, API) \
   BSXFUN_OP_DECL (max, ARRAY, API)
 
+#define BSXFUN_MIXED_INT_DECLS(INT_TYPE, API)         \
+  BSXFUN_OP2_DECL (pow, INT_TYPE, INT_TYPE, NDArray, API)       \
+  BSXFUN_OP2_DECL (pow, INT_TYPE, INT_TYPE, FloatNDArray, API)  \
+  BSXFUN_OP2_DECL (pow, INT_TYPE, NDArray, INT_TYPE, API)       \
+  BSXFUN_OP2_DECL (pow, INT_TYPE, FloatNDArray, INT_TYPE, API)
+
 #define BSXFUN_STDREL_DECLS(ARRAY, API) \
   BSXFUN_REL_DECL (eq, ARRAY, API) \
   BSXFUN_REL_DECL (ne, ARRAY, API) \
   BSXFUN_REL_DECL (lt, ARRAY, API) \
   BSXFUN_REL_DECL (le, ARRAY, API) \
   BSXFUN_REL_DECL (gt, ARRAY, API) \
   BSXFUN_REL_DECL (ge, ARRAY, API) \
 
diff --git a/liboctave/bsxfun-defs.cc b/liboctave/bsxfun-defs.cc
--- a/liboctave/bsxfun-defs.cc
+++ b/liboctave/bsxfun-defs.cc
@@ -169,9 +169,16 @@ boolNDArray bsxfun_ ## OP (const ARRAY& 
 #define BSXFUN_STDREL_DEFS_MXLOOP(ARRAY) \
   BSXFUN_REL_DEF_MXLOOP (eq, ARRAY, mx_inline_eq) \
   BSXFUN_REL_DEF_MXLOOP (ne, ARRAY, mx_inline_ne) \
   BSXFUN_REL_DEF_MXLOOP (lt, ARRAY, mx_inline_lt) \
   BSXFUN_REL_DEF_MXLOOP (le, ARRAY, mx_inline_le) \
   BSXFUN_REL_DEF_MXLOOP (gt, ARRAY, mx_inline_gt) \
   BSXFUN_REL_DEF_MXLOOP (ge, ARRAY, mx_inline_ge)
 
+//For bsxfun power with mixed integer/float types
+#define BSXFUN_POW_MIXED_MXLOOP(INT_TYPE)                              \
+  BSXFUN_OP2_DEF_MXLOOP (pow, INT_TYPE, INT_TYPE, NDArray, mx_inline_pow) \
+  BSXFUN_OP2_DEF_MXLOOP (pow, INT_TYPE, INT_TYPE, FloatNDArray, mx_inline_pow)\
+  BSXFUN_OP2_DEF_MXLOOP (pow, INT_TYPE, NDArray, INT_TYPE,  mx_inline_pow) \
+  BSXFUN_OP2_DEF_MXLOOP (pow, INT_TYPE, FloatNDArray, INT_TYPE, mx_inline_pow)
+
 #endif
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -3112,21 +3112,21 @@ Sylvester (const Matrix& a, const Matrix
 
 /* Test some simple identities
 %!shared M, cv, rv, Mt, rvt
 %! M = randn(10,10)+100*eye(10,10);
 %! Mt = M';
 %! cv = randn(10,1);
 %! rv = randn(1,10);
 %! rvt = rv';
-%!assert([M*cv,M*cv],M*[cv,cv],1e-14)
-%!assert([M'*cv,M'*cv],M'*[cv,cv],3e-14)
-%!assert([rv*M;rv*M],[rv;rv]*M,3e-14)
-%!assert([rv*M';rv*M'],[rv;rv]*M',3e-14)
-%!assert(2*rv*cv,[rv,rv]*[cv;cv],3e-14)
+%!assert([M*cv,M*cv],M*[cv,cv],1e-13)
+%!assert([M'*cv,M'*cv],M'*[cv,cv],1e-13)
+%!assert([rv*M;rv*M],[rv;rv]*M,1e-13)
+%!assert([rv*M';rv*M'],[rv;rv]*M',1e-13)
+%!assert(2*rv*cv,[rv,rv]*[cv;cv],1e-13)
 %!assert(M'\cv,Mt\cv,1e-14)
 %!assert(M'\rv',Mt\rvt,1e-14)
 */
 
 static inline char
 get_blas_trans_arg (bool trans)
 {
   return trans ? 'T' : 'N';
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -175,39 +175,16 @@ SparseMatrix::SparseMatrix (const DiagMa
           ridx (j) = i;
           j++;
         }
     }
   for (octave_idx_type i = l; i <= a.cols (); i++)
     cidx(i) = j;
 }
 
-SparseMatrix::SparseMatrix (const PermMatrix& a)
-  : MSparse<double> (a.rows (), a.cols (), a.rows ())
-{
-  octave_idx_type n = a.rows ();
-  for (octave_idx_type i = 0; i <= n; i++)
-    cidx (i) = i;
-  const Array<octave_idx_type> pv = a.pvec ();
-
-  if (a.is_row_perm ())
-    {
-      for (octave_idx_type i = 0; i < n; i++)
-        ridx (pv (i)) = i;
-    }
-  else
-    {
-      for (octave_idx_type i = 0; i < n; i++)
-        ridx (i) = pv (i);
-    }
-
-  for (octave_idx_type i = 0; i < n; i++)
-    data (i) = 1.0;
-}
-
 bool
 SparseMatrix::operator == (const SparseMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz = nnz ();
   octave_idx_type nr_a = a.rows ();
   octave_idx_type nc_a = a.cols ();
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -77,17 +77,17 @@ SparseMatrix : public MSparse<double>
   SparseMatrix (const Array<double>& a, const idx_vector& r,
                 const idx_vector& c, octave_idx_type nr = -1,
                 octave_idx_type nc = -1, bool sum_terms = true,
                 octave_idx_type nzm = -1)
     : MSparse<double> (a, r, c, nr, nc, sum_terms, nzm) { }
 
   explicit SparseMatrix (const DiagMatrix& a);
 
-  explicit SparseMatrix (const PermMatrix& a);
+  explicit SparseMatrix (const PermMatrix& a) : MSparse<double>(a) { }
 
   SparseMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : MSparse<double> (r, c, num_nz) { }
 
   SparseMatrix& operator = (const SparseMatrix& a)
     {
       MSparse<double>::operator = (a);
       return *this;
     }
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -880,8 +880,10 @@ NDND_CMP_OPS (FloatNDArray, FloatNDArray
 NDND_BOOL_OPS (FloatNDArray, FloatNDArray)
 
 BSXFUN_STDOP_DEFS_MXLOOP (FloatNDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (FloatNDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, FloatNDArray, mx_inline_pow)
 BSXFUN_OP2_DEF_MXLOOP (pow, FloatComplexNDArray, FloatComplexNDArray,
                        FloatNDArray, mx_inline_pow)
+BSXFUN_OP2_DEF_MXLOOP (pow, FloatComplexNDArray, FloatNDArray,
+                       FloatComplexNDArray, mx_inline_pow)
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -177,10 +177,12 @@ NDND_BOOL_OP_DECLS (FloatNDArray, FloatN
 MARRAY_FORWARD_DEFS (MArray, FloatNDArray, float)
 
 BSXFUN_STDOP_DECLS (FloatNDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (FloatNDArray, OCTAVE_API)
 
 BSXFUN_OP_DECL (pow, FloatNDArray, OCTAVE_API)
 BSXFUN_OP2_DECL (pow, FloatComplexNDArray, FloatComplexNDArray,
                  FloatNDArray, OCTAVE_API)
+BSXFUN_OP2_DECL (pow, FloatComplexNDArray, FloatNDArray,
+                 FloatComplexNDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/int16NDArray.cc b/liboctave/int16NDArray.cc
--- a/liboctave/int16NDArray.cc
+++ b/liboctave/int16NDArray.cc
@@ -51,8 +51,10 @@ NDND_CMP_OPS (int16NDArray, int16NDArray
 NDND_BOOL_OPS (int16NDArray, int16NDArray)
 
 MINMAX_FCNS (int16NDArray, octave_int16)
 
 BSXFUN_STDOP_DEFS_MXLOOP (int16NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (int16NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, int16NDArray, mx_inline_pow)
+
+BSXFUN_POW_MIXED_MXLOOP (int16NDArray)
diff --git a/liboctave/int16NDArray.h b/liboctave/int16NDArray.h
--- a/liboctave/int16NDArray.h
+++ b/liboctave/int16NDArray.h
@@ -39,11 +39,12 @@ SND_BOOL_OP_DECLS (octave_int16, int16ND
 NDND_CMP_OP_DECLS (int16NDArray, int16NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (int16NDArray, int16NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, int16NDArray, octave_int16)
 
 MINMAX_DECLS (int16NDArray, octave_int16, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (int16NDArray, OCTAVE_API)
+BSXFUN_MIXED_INT_DECLS(int16NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (int16NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/int32NDArray.cc b/liboctave/int32NDArray.cc
--- a/liboctave/int32NDArray.cc
+++ b/liboctave/int32NDArray.cc
@@ -51,8 +51,9 @@ NDND_CMP_OPS (int32NDArray, int32NDArray
 NDND_BOOL_OPS (int32NDArray, int32NDArray)
 
 MINMAX_FCNS (int32NDArray, octave_int32)
 
 BSXFUN_STDOP_DEFS_MXLOOP (int32NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (int32NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, int32NDArray, mx_inline_pow)
+BSXFUN_POW_MIXED_MXLOOP (int32NDArray)
diff --git a/liboctave/int32NDArray.h b/liboctave/int32NDArray.h
--- a/liboctave/int32NDArray.h
+++ b/liboctave/int32NDArray.h
@@ -39,11 +39,12 @@ SND_BOOL_OP_DECLS (octave_int32, int32ND
 NDND_CMP_OP_DECLS (int32NDArray, int32NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (int32NDArray, int32NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, int32NDArray, octave_int32)
 
 MINMAX_DECLS (int32NDArray, octave_int32, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (int32NDArray, OCTAVE_API)
+BSXFUN_MIXED_INT_DECLS(int32NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (int32NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/int64NDArray.cc b/liboctave/int64NDArray.cc
--- a/liboctave/int64NDArray.cc
+++ b/liboctave/int64NDArray.cc
@@ -51,8 +51,10 @@ NDND_CMP_OPS (int64NDArray, int64NDArray
 NDND_BOOL_OPS (int64NDArray, int64NDArray)
 
 MINMAX_FCNS (int64NDArray, octave_int64)
 
 BSXFUN_STDOP_DEFS_MXLOOP (int64NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (int64NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, int64NDArray, mx_inline_pow)
+
+BSXFUN_POW_MIXED_MXLOOP (int64NDArray)
diff --git a/liboctave/int64NDArray.h b/liboctave/int64NDArray.h
--- a/liboctave/int64NDArray.h
+++ b/liboctave/int64NDArray.h
@@ -39,11 +39,12 @@ SND_BOOL_OP_DECLS (octave_int64, int64ND
 NDND_CMP_OP_DECLS (int64NDArray, int64NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (int64NDArray, int64NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, int64NDArray, octave_int64)
 
 MINMAX_DECLS (int64NDArray, octave_int64, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (int64NDArray, OCTAVE_API)
+BSXFUN_MIXED_INT_DECLS(int64NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (int64NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/int8NDArray.cc b/liboctave/int8NDArray.cc
--- a/liboctave/int8NDArray.cc
+++ b/liboctave/int8NDArray.cc
@@ -51,8 +51,9 @@ NDND_CMP_OPS (int8NDArray, int8NDArray)
 NDND_BOOL_OPS (int8NDArray, int8NDArray)
 
 MINMAX_FCNS (int8NDArray, octave_int8)
 
 BSXFUN_STDOP_DEFS_MXLOOP (int8NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (int8NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, int8NDArray, mx_inline_pow)
+BSXFUN_POW_MIXED_MXLOOP (int8NDArray)
diff --git a/liboctave/int8NDArray.h b/liboctave/int8NDArray.h
--- a/liboctave/int8NDArray.h
+++ b/liboctave/int8NDArray.h
@@ -39,11 +39,12 @@ SND_BOOL_OP_DECLS (octave_int8, int8NDAr
 NDND_CMP_OP_DECLS (int8NDArray, int8NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (int8NDArray, int8NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, int8NDArray, octave_int8)
 
 MINMAX_DECLS (int8NDArray, octave_int8, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (int8NDArray, OCTAVE_API)
+BSXFUN_MIXED_INT_DECLS(int8NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (int8NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/link-deps.mk b/liboctave/link-deps.mk
new file mode 100644
--- /dev/null
+++ b/liboctave/link-deps.mk
@@ -0,0 +1,27 @@
+include ../libcruft/link-deps.mk
+
+LIBOCTAVE_LINK_DEPS = \
+  $(SPARSE_XLIBS) \
+  $(ARPACK_LIBS) \
+  $(QRUPDATE_LIBS) \
+  $(FFTW_XLIBS) \
+  $(LAPACK_LIBS) \
+  $(BLAS_LIBS) \
+  $(READLINE_LIBS) \
+  $(TERM_LIBS) \
+  $(LIBGLOB) \
+  $(REGEX_LIBS) \
+  $(DL_LIBS) \
+  $(PTHREAD_LIBS) \
+  $(LIBS)
+
+LIBOCTAVE_LINK_OPTS = \
+  $(SPARSE_XLDFLAGS) \
+  $(ARPACK_LDFLAGS) \
+  $(QRUPDATE_LDFLAGS) \
+  $(FFTW_XLDFLAGS)
+
+if AMCOND_LINK_ALL_DEPS
+  LIBOCTAVE_LINK_DEPS += $(LIBCRUFT_LINK_DEPS)
+  LIBOCTAVE_LINK_OPTS += $(LIBCRUFT_LINK_OPTS)
+endif
diff --git a/liboctave/oct-inttypes.cc b/liboctave/oct-inttypes.cc
--- a/liboctave/oct-inttypes.cc
+++ b/liboctave/oct-inttypes.cc
@@ -573,16 +573,33 @@ pow (const octave_int<T>& a, const doubl
 {
   return ((b >= 0 && b < std::numeric_limits<T>::digits && b == xround (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (pow (a.double_value (), b)));
 }
 
 template <class T>
 octave_int<T>
+pow (const float& a, const octave_int<T>& b)
+{ return octave_int<T> (pow (a, b.float_value ())); }
+
+template <class T>
+octave_int<T>
+pow (const octave_int<T>& a, const float& b)
+{
+  return ((b >= 0 && b < std::numeric_limits<T>::digits && b == xround (b))
+          ? pow (a, octave_int<T> (static_cast<T> (b)))
+          : octave_int<T> (pow (a.double_value (), static_cast<double> (b))));
+}
+
+// FIXME: Do we really need a differently named single-precision
+//        function integer power function here instead of an overloaded
+//        one?
+template <class T>
+octave_int<T>
 powf (const float& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.float_value ())); }
 
 template <class T>
 octave_int<T>
 powf (const octave_int<T>& a, const float& b)
 {
   return ((b >= 0 && b < std::numeric_limits<T>::digits && b == xround (b))
@@ -590,16 +607,18 @@ powf (const octave_int<T>& a, const floa
           : octave_int<T> (pow (a.double_value (), static_cast<double> (b))));
 }
 
 #define INSTANTIATE_INTTYPE(T) \
   template class OCTAVE_API octave_int<T>; \
   template OCTAVE_API octave_int<T> pow (const octave_int<T>&, const octave_int<T>&); \
   template OCTAVE_API octave_int<T> pow (const double&, const octave_int<T>&); \
   template OCTAVE_API octave_int<T> pow (const octave_int<T>&, const double&); \
+  template OCTAVE_API octave_int<T> pow (const float&, const octave_int<T>&);  \
+  template OCTAVE_API octave_int<T> pow (const octave_int<T>&, const float&);  \
   template OCTAVE_API octave_int<T> powf (const float&, const octave_int<T>&); \
   template OCTAVE_API octave_int<T> powf (const octave_int<T>&, const float&); \
   template OCTAVE_API octave_int<T> \
   bitshift (const octave_int<T>&, int, const octave_int<T>&); \
 
 INSTANTIATE_INTTYPE (int8_t);
 INSTANTIATE_INTTYPE (int16_t);
 INSTANTIATE_INTTYPE (int32_t);
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -869,16 +869,27 @@ extern OCTAVE_API octave_int<T>
 pow (const double& a, const octave_int<T>& b);
 
 template <class T>
 extern OCTAVE_API octave_int<T>
 pow (const octave_int<T>& a, const double& b);
 
 template <class T>
 extern OCTAVE_API octave_int<T>
+pow (const float& a, const octave_int<T>& b);
+
+template <class T>
+extern OCTAVE_API octave_int<T>
+pow (const octave_int<T>& a, const float& b);
+
+// FIXME: Do we really need a differently named single-precision
+//        function integer power function here instead of an overloaded
+//        one?
+template <class T>
+extern OCTAVE_API octave_int<T>
 powf (const float& a, const octave_int<T>& b);
 
 template <class T>
 extern OCTAVE_API octave_int<T>
 powf (const octave_int<T>& a, const float& b);
 
 // Binary relations
 
diff --git a/liboctave/uint16NDArray.cc b/liboctave/uint16NDArray.cc
--- a/liboctave/uint16NDArray.cc
+++ b/liboctave/uint16NDArray.cc
@@ -51,8 +51,9 @@ NDND_CMP_OPS (uint16NDArray, uint16NDArr
 NDND_BOOL_OPS (uint16NDArray, uint16NDArray)
 
 MINMAX_FCNS (uint16NDArray, octave_uint16)
 
 BSXFUN_STDOP_DEFS_MXLOOP (uint16NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (uint16NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, uint16NDArray, mx_inline_pow)
+BSXFUN_POW_MIXED_MXLOOP (uint16NDArray)
diff --git a/liboctave/uint16NDArray.h b/liboctave/uint16NDArray.h
--- a/liboctave/uint16NDArray.h
+++ b/liboctave/uint16NDArray.h
@@ -39,11 +39,12 @@ SND_BOOL_OP_DECLS (octave_uint16, uint16
 NDND_CMP_OP_DECLS (uint16NDArray, uint16NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (uint16NDArray, uint16NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, uint16NDArray, octave_uint16)
 
 MINMAX_DECLS (uint16NDArray, octave_uint16, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (uint16NDArray, OCTAVE_API)
+BSXFUN_MIXED_INT_DECLS(uint16NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (uint16NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/uint32NDArray.cc b/liboctave/uint32NDArray.cc
--- a/liboctave/uint32NDArray.cc
+++ b/liboctave/uint32NDArray.cc
@@ -51,8 +51,9 @@ NDND_CMP_OPS (uint32NDArray, uint32NDArr
 NDND_BOOL_OPS (uint32NDArray, uint32NDArray)
 
 MINMAX_FCNS (uint32NDArray, octave_uint32)
 
 BSXFUN_STDOP_DEFS_MXLOOP (uint32NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (uint32NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, uint32NDArray, mx_inline_pow)
+BSXFUN_POW_MIXED_MXLOOP (uint32NDArray)
diff --git a/liboctave/uint32NDArray.h b/liboctave/uint32NDArray.h
--- a/liboctave/uint32NDArray.h
+++ b/liboctave/uint32NDArray.h
@@ -39,11 +39,12 @@ SND_BOOL_OP_DECLS (octave_uint32, uint32
 NDND_CMP_OP_DECLS (uint32NDArray, uint32NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (uint32NDArray, uint32NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, uint32NDArray, octave_uint32)
 
 MINMAX_DECLS (uint32NDArray, octave_uint32, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (uint32NDArray, OCTAVE_API)
+BSXFUN_MIXED_INT_DECLS(uint32NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (uint32NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/uint64NDArray.cc b/liboctave/uint64NDArray.cc
--- a/liboctave/uint64NDArray.cc
+++ b/liboctave/uint64NDArray.cc
@@ -51,8 +51,10 @@ NDND_CMP_OPS (uint64NDArray, uint64NDArr
 NDND_BOOL_OPS (uint64NDArray, uint64NDArray)
 
 MINMAX_FCNS (uint64NDArray, octave_uint64)
 
 BSXFUN_STDOP_DEFS_MXLOOP (uint64NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (uint64NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, uint64NDArray, mx_inline_pow)
+BSXFUN_POW_MIXED_MXLOOP (uint64NDArray)
+
diff --git a/liboctave/uint64NDArray.h b/liboctave/uint64NDArray.h
--- a/liboctave/uint64NDArray.h
+++ b/liboctave/uint64NDArray.h
@@ -39,11 +39,12 @@ SND_BOOL_OP_DECLS (octave_uint64, uint64
 NDND_CMP_OP_DECLS (uint64NDArray, uint64NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (uint64NDArray, uint64NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, uint64NDArray, octave_uint64)
 
 MINMAX_DECLS (uint64NDArray, octave_uint64, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (uint64NDArray, OCTAVE_API)
+BSXFUN_MIXED_INT_DECLS(uint64NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (uint64NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/uint8NDArray.cc b/liboctave/uint8NDArray.cc
--- a/liboctave/uint8NDArray.cc
+++ b/liboctave/uint8NDArray.cc
@@ -50,9 +50,11 @@ SND_BOOL_OPS (octave_uint8, uint8NDArray
 NDND_CMP_OPS (uint8NDArray, uint8NDArray)
 NDND_BOOL_OPS (uint8NDArray, uint8NDArray)
 
 MINMAX_FCNS (uint8NDArray, octave_uint8)
 
 BSXFUN_STDOP_DEFS_MXLOOP (uint8NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (uint8NDArray)
 
+BSXFUN_POW_MIXED_MXLOOP (uint8NDArray)
 BSXFUN_OP_DEF_MXLOOP (pow, uint8NDArray, mx_inline_pow)
+
diff --git a/liboctave/uint8NDArray.h b/liboctave/uint8NDArray.h
--- a/liboctave/uint8NDArray.h
+++ b/liboctave/uint8NDArray.h
@@ -39,11 +39,12 @@ SND_BOOL_OP_DECLS (octave_uint8, uint8ND
 NDND_CMP_OP_DECLS (uint8NDArray, uint8NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (uint8NDArray, uint8NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, uint8NDArray, octave_uint8)
 
 MINMAX_DECLS (uint8NDArray, octave_uint8, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (uint8NDArray, OCTAVE_API)
+BSXFUN_MIXED_INT_DECLS(uint8NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (uint8NDArray, OCTAVE_API)
 
 #endif
diff --git a/scripts/general/celldisp.m b/scripts/general/celldisp.m
--- a/scripts/general/celldisp.m
+++ b/scripts/general/celldisp.m
@@ -75,9 +75,13 @@ function s = indices (dv, i)
     s(end) = [];
   else
     s = sprintf("%i", i);
   endif
 endfunction
 
 %!demo
 %! c = {1, 2, {31, 32}};
-%! celldisp(c, "b")
\ No newline at end of file
+%! celldisp(c, "b")
+
+%!error celldisp ();
+%!error celldisp ({}, "name", 1);
+%!error celldisp (1);
diff --git a/scripts/general/profile.m b/scripts/general/profile.m
--- a/scripts/general/profile.m
+++ b/scripts/general/profile.m
@@ -108,8 +108,43 @@ endfunction
 %! A = rand (100);
 %! B = expm (A);
 %! profile ('off');
 %! profile ('resume');
 %! C = sqrtm (A);
 %! profile ('off');
 %! T = profile ('info');
 %! profshow (T);
+
+%!error profile ();
+%!error profile ('on', 2);
+
+%!test
+%! on_struct.ProfilerStatus = "on";
+%! off_struct.ProfilerStatus = "off";
+%! profile ('on');
+%! result = logm (rand (200) + 10 * eye (200));
+%! assert (profile ('status'), on_struct);
+%! profile ('off');
+%! assert (profile ('status'), off_struct);
+%! profile ('resume');
+%! result = logm (rand (200) + 10 * eye (200));
+%! profile ('off');
+%! assert (profile ('status'), off_struct);
+%! info = profile ('info');
+%! assert (isstruct (info));
+%! assert (size (info), [1, 1]);
+%! assert (fieldnames (info), {'FunctionTable'; 'Hierarchical'});
+%! ftbl = info.FunctionTable;
+%! assert (fieldnames (ftbl), {'FunctionName'; 'TotalTime'; 'NumCalls'; 'IsRecursive'; 'Parents'; 'Children'});
+%! hier = info.Hierarchical;
+%! assert (fieldnames (hier), {'Index'; 'SelfTime'; 'NumCalls'; 'Children'});
+%! profile ('clear');
+%! info = profile ('info');
+%! assert (isstruct (info));
+%! assert (size (info), [1, 1]);
+%! assert (fieldnames (info), {'FunctionTable'; 'Hierarchical'});
+%! ftbl = info.FunctionTable;
+%! assert (size (ftbl), [0, 1]);
+%! assert (fieldnames (ftbl), {'FunctionName'; 'TotalTime'; 'NumCalls'; 'IsRecursive'; 'Parents'; 'Children'});
+%! hier = info.Hierarchical;
+%! assert (size (hier), [0, 1]);
+%! assert (fieldnames (hier), {'Index'; 'SelfTime'; 'NumCalls'; 'Children'});
diff --git a/scripts/general/profshow.m b/scripts/general/profshow.m
--- a/scripts/general/profshow.m
+++ b/scripts/general/profshow.m
@@ -95,8 +95,12 @@ endfunction
 %!   else
 %!     f = myfib (n - 1) + myfib (n - 2);
 %!   endif
 %! endfunction
 %! profile ("on");
 %! myfib (20);
 %! profile ("off");
 %! profshow (profile ("info"), 5);
+
+%!error profshow ();
+%!error profshow (1, 2, 3);
+%!error profshow (struct (), 1.2);
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -125,8 +125,19 @@ endfunction
 %! hold on
 %! plot(x(inside),y(inside),"@g")
 %! plot(x(~in),y(~in),"@m")
 %! plot(x(on),y(on),"@b")
 %! hold off
 %! disp("Green points are inside polygon, magenta are outside,");
 %! disp("and blue are on boundary.");
 
+%!error inpolygon ();
+%!error inpolygon (1, 2);
+%!error inpolygon (1, 2, 3);
+
+%!error inpolygon (1, [1,2], [3, 4], [5, 6]);
+%!error inpolygon ([1,2], [3, 4], [5, 6], 1);
+
+%!test
+%! [in, on] = inpolygon ([1, 0], [1, 0], [-1, -1, 1, 1], [-1, 1, 1, -1]);
+%! assert (in, [false, true]);
+%! assert (on, [true, false]);
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -114,8 +114,11 @@ function [retval, status] = __makeinfo__
 
   unwind_protect_cleanup
     if (exist (name, "file"))
       delete (name);
     endif
   end_unwind_protect
 endfunction
 
+## No test needed for internal helper function.
+%!assert (1)
+
diff --git a/scripts/help/gen_doc_cache.m b/scripts/help/gen_doc_cache.m
--- a/scripts/help/gen_doc_cache.m
+++ b/scripts/help/gen_doc_cache.m
@@ -27,16 +27,17 @@
 ##
 ## If no directory is given (or it is the empty matrix), a cache for builtin
 ## operators, etc. is generated.
 ##
 ## @seealso{lookfor, path}
 ## @end deftypefn
 
 function gen_doc_cache (out_file = "doc-cache", directory = [])
+
   ## Check input
   if (!ischar (out_file))
     print_usage ();
   endif
 
   ## Generate cache
   if (isempty (directory))
     cache = gen_builtin_cache ();
@@ -138,8 +139,13 @@ function cache = gen_builtin_cache ()
   operators = __operators__ ();
   keywords = __keywords__ ();
   builtins = __builtins__ ();
   list = {operators{:}, keywords{:}, builtins{:}};
 
   cache = create_cache (list);
 endfunction
 
+
+%% No true tests desirable for this function.
+%% Test input validation
+%!error gen_doc_cache (1)
+
diff --git a/scripts/io/beep.m b/scripts/io/beep.m
--- a/scripts/io/beep.m
+++ b/scripts/io/beep.m
@@ -21,15 +21,18 @@
 ## Produce a beep from the speaker (or visual bell).
 ## @seealso{puts, fputs, printf, fprintf}
 ## @end deftypefn
 
 ## Author: jwe
 
 function beep ()
 
-  if (nargin == 0)
-    puts ("\a");
-  else
+  if (nargin != 0)
     print_usage ();
   endif
 
+  puts ("\a");
+
 endfunction
+
+
+%!error (beep (1))
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -85,8 +85,31 @@ function z = cross (x, y, dim)
     y2 = y(idx2{:});
     y3 = y(idx3{:});
     z = cat (dim, (x2.*y3 - x3.*y2), (x3.*y1 - x1.*y3), (x1.*y2 - x2.*y1));
   else
     error ("cross: X and Y must have the same dimensions");
   endif
 
 endfunction
+
+%!test
+%! x = [1 0 0];
+%! y = [0 1 0];
+%! r = [0 0 1];
+%! assert(cross(x, y), r, 2e-8);
+
+%!test
+%! x = [1 2 3];
+%! y = [4 5 6];
+%! r = [(2*6-3*5) (3*4-1*6) (1*5-2*4)];
+%! assert(cross(x, y), r, 2e-8);
+
+%!test
+%! x = [1 0 0; 0 1 0; 0 0 1];
+%! y = [0 1 0; 0 0 1; 1 0 0];
+%! r = [0 0 1; 1 0 0; 0 1 0];
+%! assert(cross(x, y, 2), r, 2e-8);
+%! assert(cross(x, y, 1), -r, 2e-8);
+
+%!error cross(0,0);
+%!error cross();
+
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -81,8 +81,40 @@ function d = duplication_matrix (n)
     for i = (j + 1) : n
       d ((j - 1) * n + i, count + i) = 1;
       d ((i - 1) * n + j, count + i) = 1;
     endfor
     count = count + n - j;
   endfor
 
 endfunction
+
+%!test
+%! N = 2;
+%! A = rand(N);
+%! B = A * A';
+%! C = A + A';
+%! D = duplication_matrix (N);
+%! assert (D * vech (B), vec (B), 1e-6);
+%! assert (D * vech (C), vec (C), 1e-6);
+
+%!test
+%! N = 3;
+%! A = rand(N);
+%! B = A * A';
+%! C = A + A';
+%! D = duplication_matrix (N);
+%! assert (D * vech (B), vec (B), 1e-6);
+%! assert (D * vech (C), vec (C), 1e-6);
+
+%!test
+%! N = 4;
+%! A = rand(N);
+%! B = A * A';
+%! C = A + A';
+%! D = duplication_matrix (N);
+%! assert (D * vech (B), vec (B), 1e-6);
+%! assert (D * vech (C), vec (C), 1e-6);
+
+%!error duplication_matrix ();
+%!error duplication_matrix (0.5);
+%!error duplication_matrix (-1);
+%!error duplication_matrix (ones(1,4));
diff --git a/scripts/linear-algebra/housh.m b/scripts/linear-algebra/housh.m
--- a/scripts/linear-algebra/housh.m
+++ b/scripts/linear-algebra/housh.m
@@ -18,18 +18,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{housv}, @var{beta}, @var{zer}] =} housh (@var{x}, @var{j}, @var{z})
 ## Compute Householder reflection vector @var{housv} to reflect @var{x}
 ## to be the j-th column of identity, i.e.,
 ##
 ## @example
 ## @group
-## (I - beta*housv*housv')x =  norm(x)*e(j) if x(1) < 0,
-## (I - beta*housv*housv')x = -norm(x)*e(j) if x(1) >= 0
+## (I - beta*housv*housv')x =  norm(x)*e(j) if x(j) < 0,
+## (I - beta*housv*housv')x = -norm(x)*e(j) if x(j) >= 0
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## Inputs
 ##
 ## @table @var
 ## @item x
@@ -86,8 +86,48 @@ function [housv, beta, zer] = housh (x, 
       endif
     else
       beta = 0.0;
     endif
     zer = (beta == 0);
   endif
 
 endfunction
+
+%!test
+%! x = [1 2 3]';
+%! j = 3;
+%! [hv, b, z] = housh(x, j, 0);
+%! r = (eye(3) - b*hv*hv') * x;
+%! d = - norm(x) * [0 0 1]';
+%! assert(r, d, 2e-8);
+%! assert(z, 0, 2e-8);
+
+%!test
+%! x = [7 -3 1]';
+%! j = 2;
+%! [hv, b, z] = housh(x, j, 0);
+%! r = (eye(3) - b*hv*hv') * x;
+%! d = norm(x) * [0 1 0]';
+%! assert(r, d, 2e-8);
+%! assert(z, 0, 2e-8);
+
+%!test
+%! x = [1 0 0]';
+%! j = 1;
+%! [hv, b, z] = housh(x, j, 10);
+%! r = (eye(3) - b*hv*hv') * x;
+%! d = norm(x) * [1 0 0]';
+%! assert(r, d, 2e-8);
+%! assert(z, 1, 2e-8);
+
+%!test
+%! x = [5 0 4 1]';
+%! j = 2;
+%! [hv, b, z] = housh(x, j, 0);
+%! r = (eye(4) - b*hv*hv') * x;
+%! d = - norm(x) * [0 1 0 0]';
+%! assert(r, d, 2e-8);
+%! assert(z, 0, 2e-8);
+
+%!error housh([0]);
+%!error housh();
+
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -58,21 +58,24 @@ function [s, iters] = logm (A, opt_iters
   endif
 
   [u, s] = schur (A);
 
   if (isreal (A))
     [u, s] = rsf2csf (u, s);
   endif
 
-  if (any (diag (s) < 0))
+  eigv = diag (s);
+  if (any (eigv < 0))
     warning ("Octave:logm:non-principal",
              "logm: principal matrix logarithm is not defined for matrices with negative eigenvalues; computing non-principal logarithm");
   endif
 
+  real_eig = all (eigv >= 0);
+
   k = 0;
   ## Algorithm 11.9 in "Function of matrices", by N. Higham
   theta = [0, 0, 1.61e-2, 5.38e-2, 1.13e-1, 1.86e-1, 2.6429608311114350e-1];
   p = 0;
   m = 7;
   while (k < opt_iters)
     tau = norm (s - eye (size (s)),1);
     if (tau <= theta (7))
@@ -95,16 +98,21 @@ function [s, iters] = logm (A, opt_iters
   s = s - eye (size (s));
 
   if (m > 1)
     s = logm_pade_pf (s, m);
   endif
 
   s = 2^k * u * s * u';
 
+  ## Remove small complex values (O(eps)) which may have entered calculation
+  if (real_eig)
+    s = real (s);
+  endif
+
   if (nargout == 2)
     iters = k;
   endif
 
 endfunction
 
 ################## ANCILLARY FUNCTIONS ################################
 ######  Taken from the mfttoolbox (GPL 3) by D. Higham.
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -74,8 +74,17 @@ function retval = orth (A, tol)
 
   else
 
     print_usage ();
 
   endif
 
 endfunction
+
+%!test
+%! for ii=1:20
+%!   A = rand (10, 10);
+%!   V = orth (A);
+%!   if (det (A) != 0)
+%!     assert (V'*V, eye (10), 100*eps)
+%!   endif
+%! endfor
diff --git a/scripts/linear-algebra/planerot.m b/scripts/linear-algebra/planerot.m
--- a/scripts/linear-algebra/planerot.m
+++ b/scripts/linear-algebra/planerot.m
@@ -29,8 +29,19 @@
 ## @code{@var{y} = @var{g} * @var{x}} and @code{@var{y}(2) = 0}.
 ## @seealso{givens}
 ## @end deftypefn
 
 function [G, y] = planerot (x)
   G = givens (x(1), x(2));
   y = G * x(:);
 endfunction
+
+%!test
+%! x = [3 4];
+%! [g y] = planerot(x);
+%! assert(g - [x(1) x(2); -x(2) x(1)] / sqrt(x(1)^2 + x(2)^2), zeros(2), 2e-8);
+%! assert(y(2), 0, 2e-8);
+
+%!error planerot([0]);
+%!error planerot([0 0 0]);
+%!error planerot();
+
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -85,8 +85,57 @@ function [aa, bb, q, z] = qzhess (A, B)
 
   bb (2, 1) = 0.0;
   for i = 3:na
     bb (i, 1:(i-1)) = zeros (1, i-1);
     aa (i, 1:(i-2)) = zeros (1, i-2);
   endfor
 
 endfunction
+
+%!test
+%! a = [1 2 1 3;
+%!      2 5 3 2;
+%!      5 5 1 0;
+%!      4 0 3 2];
+%! b = [0 4 2 1;
+%!      2 3 1 1;
+%!      1 0 2 1;
+%!      2 5 3 2];
+%! mask = [0 0 0 0;
+%!         0 0 0 0;
+%!         1 0 0 0;
+%!         1 1 0 0];
+%! [aa, bb, q, z] = qzhess(a, b);
+%! assert(inv(q) - q', zeros(4), 2e-8);
+%! assert(inv(z) - z', zeros(4), 2e-8);
+%! assert(q * a * z, aa, 2e-8);
+%! assert(aa .* mask, zeros(4), 2e-8);
+%! assert(q * b * z, bb, 2e-8);
+%! assert(bb .* mask, zeros(4), 2e-8);
+
+%!test
+%! a = [1 2 3 4 5;
+%!      3 2 3 1 0;
+%!      4 3 2 1 1;
+%!      0 1 0 1 0;
+%!      3 2 1 0 5];
+%! b = [5 0 4 0 1;
+%!      1 1 1 2 5;
+%!      0 3 2 1 0;
+%!      4 3 0 3 5;
+%!      2 1 2 1 3];
+%! mask = [0 0 0 0 0;
+%!         0 0 0 0 0;
+%!         1 0 0 0 0;
+%!         1 1 0 0 0;
+%!         1 1 1 0 0];
+%! [aa, bb, q, z] = qzhess(a, b);
+%! assert(inv(q) - q', zeros(5), 2e-8);
+%! assert(inv(z) - z', zeros(5), 2e-8);
+%! assert(q * a * z, aa, 2e-8);
+%! assert(aa .* mask, zeros(5), 2e-8);
+%! assert(q * b * z, bb, 2e-8);
+%! assert(bb .* mask, zeros(5), 2e-8);
+
+%!error qzhess([0]);
+%!error qzhess();
+
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -81,8 +81,48 @@ function [A, k] = rref (A, tol)
       if (r++ == rows)
         break;
       endif
     endif
   endfor
   k = find (used);
 
 endfunction
+
+%!test
+%! a = [1];
+%! [r k] = rref(a);
+%! assert(r, [1], 2e-8);
+%! assert(k, [1], 2e-8);
+
+%!test
+%! a = [1 3; 4 5];
+%! [r k] = rref(a);
+%! assert(rank(a), rank(r), 2e-8);
+%! assert(r, eye(2), 2e-8);
+%! assert(k == [1, 2] || k == [2, 1]);
+
+
+%!test
+%! a = [1 3; 4 5; 7 9];
+%! [r k] = rref(a);
+%! assert(rank(a), rank(r), 2e-8);
+%! assert(r, eye(3)(:,1:2), 2e-8);
+%! assert(k, [1 2], 2e-8);
+
+%!test
+%! a = [1 2 3; 2 4 6; 7 2 0];
+%! [r k] = rref(a);
+%! assert(rank(a), rank(r), 2e-8);
+%! assert(r, [1 0 (3-7/2); 0 1 (7/4); 0 0 0], 2e-8);
+%! assert(k, [1 2], 2e-8);
+
+%!test
+%! a = [1 2 1; 2 4 2.01; 2 4 2.1];
+%! tol = 0.02;
+%! [r k] = rref(a, tol);
+%! assert(rank(a, tol), rank(r, tol), 2e-8);
+%! tol = 0.2;
+%! [r k] = rref(a, tol);
+%! assert(rank(a, tol), rank(r, tol), 2e-8);
+
+%!error rref();
+
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -70,36 +70,40 @@
 ## (or .mex if @samp{--mex} is specified) unless linking
 ## a stand-alone executable.
 ##
 ## @item -p VAR
 ## @itemx --print VAR
 ## Print the configuration variable VAR@.  Recognized variables are:
 ##
 ## @example
-##    ALL_CFLAGS                FFTW_LIBS
+##    ALL_CFLAGS                FFTW3F_LIBS
 ##    ALL_CXXFLAGS              FLIBS
 ##    ALL_FFLAGS                FPICFLAG
 ##    ALL_LDFLAGS               INCFLAGS
-##    BLAS_LIBS                 LDFLAGS
-##    CC                        LD_CXX
-##    CFLAGS                    LD_STATIC_FLAG
-##    CPICFLAG                  LFLAGS
-##    CPPFLAGS                  LIBCRUFT
-##    CXX                       LIBOCTAVE
-##    CXXFLAGS                  LIBOCTINTERP
-##    CXXPICFLAG                LIBREADLINE
+##    BLAS_LIBS                 LAPACK_LIBS
+##    CC                        LDFLAGS
+##    CFLAGS                    LD_CXX
+##    CPICFLAG                  LD_STATIC_FLAG
+##    CPPFLAGS                  LFLAGS
+##    CXX                       LIBCRUFT
+##    CXXFLAGS                  LIBOCTAVE
+##    CXXPICFLAG                LIBOCTINTERP
 ##    DEPEND_EXTRA_SED_PATTERN  LIBS
 ##    DEPEND_FLAGS              OCTAVE_LIBS
-##    DL_LD                     RDYNAMIC_FLAG
-##    DL_LDFLAGS                RLD_FLAG
-##    F2C                       SED
-##    F2CFLAGS                  XTRA_CFLAGS
-##    F77                       XTRA_CXXFLAGS
-##    FFLAGS
+##    DL_LD                     OCTAVE_LINK_DEPS
+##    DL_LDFLAGS                OCT_LINK_DEPS
+##    EXEEXT                    RDYNAMIC_FLAG
+##    F77                       READLINE_LIBS
+##    F77_INTEGER_8_FLAG        SED
+##    FFLAGS                    XTRA_CFLAGS
+##    FFTW3_LDFLAGS             XTRA_CXXFLAGS
+##    FFTW3_LIBS
+##    FFTW3F_LDFLAGS
+##
 ## @end example
 ##
 ## @item --link-stand-alone
 ## Link a stand-alone executable file.
 ##
 ## @item --mex
 ## Assume we are creating a MEX file.  Set the default output extension
 ## to ".mex".
diff --git a/scripts/miscellaneous/tempdir.m b/scripts/miscellaneous/tempdir.m
--- a/scripts/miscellaneous/tempdir.m
+++ b/scripts/miscellaneous/tempdir.m
@@ -32,8 +32,24 @@ function dirname = tempdir ()
     dirname = cstrcat (dirname, filesep);
   endif
 
   if (! isdir (dirname))
     warning ("tempdir: `%s' does not exist or is not a directory", dirname);
   endif
 
 endfunction
+
+
+%!assert (ischar (tempdir ()))
+
+%!test
+%! old_wstate = warning ("query");
+%! warning ("off");
+%! old_tmpdir = getenv ("TMPDIR");
+%! unwind_protect
+%!   setenv ("TMPDIR", "__MY_TMP_DIR__");
+%!   assert (tempdir (), ["__MY_TMP_DIR__" filesep()]); 
+%! unwind_protect_cleanup
+%!   setenv ("TMPDIR", old_tmpdir);
+%!   warning (old_wstate);
+%! end_unwind_protect 
+
diff --git a/scripts/miscellaneous/tempname.m b/scripts/miscellaneous/tempname.m
--- a/scripts/miscellaneous/tempname.m
+++ b/scripts/miscellaneous/tempname.m
@@ -24,8 +24,12 @@
 ## @seealso{tmpnam}
 ## @end deftypefn
 
 function filename = tempname (varargin)
 
   filename = tmpnam (varargin{:});
 
 endfunction
+
+
+%% No tests needed for alias.
+%!assert (1)
diff --git a/scripts/optimization/__all_opts__.m b/scripts/optimization/__all_opts__.m
--- a/scripts/optimization/__all_opts__.m
+++ b/scripts/optimization/__all_opts__.m
@@ -62,8 +62,12 @@ function names = __all_opts__ (varargin)
       names = names(idx);
     endif
     saved_names = names;
     recursive = false;
   endif
 
 endfunction
 
+
+## No test needed for internal helper function.
+%!assert (1)
+
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -44,17 +44,18 @@
 ## The algorithm has been terminated from user output function.
 ## @end itemize
 ## @seealso{optimset, fzero, fminunc}
 ## @end deftypefn
 
 ## This is patterned after opt/fmin.f from Netlib, which in turn is taken from
 ## Richard Brent: Algorithms For Minimization Without Derivatives, Prentice-Hall (1973)
 
-## PKG_ADD: __all_opts__ ("fminbnd");
+## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+## PKG_ADD: [~] = __all_opts__ ("fminbnd");
 
 function [x, fval, info, output] = fminbnd (fun, xmin, xmax, options = struct ())
 
   ## Get default options if requested.
   if (nargin == 1 && ischar (fun) && strcmp (fun, 'defaults'))
     x = optimset ("MaxIter", Inf, "MaxFunEvals", Inf, "TolX", 1e-8, \
     "OutputFcn", [], "FunValCheck", "off");
     return;
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -72,17 +72,18 @@
 ## (@var{output}), the output gradient (@var{grad}) and approximate Hessian
 ## (@var{hess}).
 ##
 ## Note: If you only have a single nonlinear equation of one variable, using
 ## @code{fminbnd} is usually a much better idea.
 ## @seealso{fminbnd, optimset}
 ## @end deftypefn
 
-## PKG_ADD: __all_opts__ ("fminunc");
+## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+## PKG_ADD: [~] = __all_opts__ ("fminunc");
 
 function [x, fval, info, output, grad, hess] = fminunc (fcn, x0, options = struct ())
 
   ## Get default options if requested.
   if (nargin == 1 && ischar (fcn) && strcmp (fcn, 'defaults'))
     x = optimset ("MaxIter", 400, "MaxFunEvals", Inf, \
     "GradObj", "off", "TolX", 1e-7, "TolFun", 1e-7,
     "OutputFcn", [], "FunValCheck", "off",
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -122,17 +122,18 @@
 ## endfunction
 ##
 ## ## @dots{}.
 ##
 ## fsolve (@@user_func, x0, optimset ("OutputFcn", @@user_func, @dots{}))
 ## @end example
 ## @end deftypefn
 
-## PKG_ADD: __all_opts__ ("fsolve");
+## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+## PKG_ADD: [~] = __all_opts__ ("fsolve");
 
 function [x, fvec, info, output, fjac] = fsolve (fcn, x0, options = struct ())
 
   ## Get default options if requested.
   if (nargin == 1 && ischar (fcn) && strcmp (fcn, 'defaults'))
     x = optimset ("MaxIter", 400, "MaxFunEvals", Inf, \
     "Jacobian", "off", "TolX", 1e-7, "TolFun", 1e-7,
     "OutputFcn", [], "Updating", "on", "FunValCheck", "off",
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -88,17 +88,18 @@
 ## been transformed non-trivially; instead of the authors' approach of
 ## sequentially calling building blocks subprograms we implement here a
 ## FSM version using one interior point determination and one bracketing
 ## per iteration, thus reducing the number of temporary variables and
 ## simplifying the algorithm structure. Further, this approach reduces
 ## the need for external functions and error handling. The algorithm has
 ## also been slightly modified.
 
-## PKG_ADD: __all_opts__ ("fzero");
+## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+## PKG_ADD: [~] = __all_opts__ ("fzero");
 
 function [x, fval, info, output] = fzero (fun, x0, options = struct ())
 
   ## Get default options if requested.
   if (nargin == 1 && ischar (fun) && strcmp (fun, 'defaults'))
     x = optimset ("MaxIter", Inf, "MaxFunEvals", Inf, "TolX", 1e-8, \
     "OutputFcn", [], "FunValCheck", "off");
     return;
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -58,17 +58,18 @@
 ##
 ## @item lambda
 ##
 ## Not implemented.
 ## @end itemize
 ## @seealso{optimset, pqpnonneg}
 ## @end deftypefn
 
-## PKG_ADD: __all_opts__ ("lsqnonneg");
+## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+## PKG_ADD: [~] = __all_opts__ ("lsqnonneg");
 
 ## This is implemented from Lawson and Hanson's 1973 algorithm on page
 ## 161 of Solving Least Squares Problems.
 
 function [x, resnorm, residual, exitflag, output, lambda] = lsqnonneg (c, d, x = [], options = struct ())
 
   if (nargin == 1 && ischar (c) && strcmp (c, 'defaults'))
     x = optimset ("MaxIter", 1e5);
diff --git a/scripts/optimization/pqpnonneg.m b/scripts/optimization/pqpnonneg.m
--- a/scripts/optimization/pqpnonneg.m
+++ b/scripts/optimization/pqpnonneg.m
@@ -53,17 +53,18 @@
 ##
 ## @item lambda
 ##
 ## Not implemented.
 ## @end itemize
 ## @seealso{optimset, lsqnonneg, qp}
 ## @end deftypefn
 
-## PKG_ADD: __all_opts__ ("pqpnonneg");
+## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+## PKG_ADD: [~] = __all_opts__ ("pqpnonneg");
 
 ## This is analogical to the lsqnonneg implementation, which is
 ## implemented from Lawson and Hanson's 1973 algorithm on page
 ## 161 of Solving Least Squares Problems.
 ## It shares the convergence guarantees.
 
 function [x, minval, exitflag, output, lambda] = pqpnonneg (c, d, x = [], options = struct ())
 
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -103,17 +103,18 @@
 ##
 ## @item 6
 ## The problem is infeasible.
 ## @end table
 ## @end table
 ## @end table
 ## @end deftypefn
 
-## PKG_ADD: __all_opts__ ("qp");
+## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+## PKG_ADD: [~] = __all_opts__ ("qp");
 
 function [x, obj, INFO, lambda] = qp (x0, H, varargin)
 
   nargs = nargin;
 
   if (nargin == 1 && ischar (x0) && strcmp (x0, 'defaults'))
     x = optimset ("MaxIter", 200);
     return;
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -381,8 +381,12 @@ function retval = have_non_legend_axes (
     all_axes_tags = get (all_axes, "tag");
     legend_axes = strcmp (all_axes_tags, "legend");
     if (! isempty (legend_axes))
       n_legend_axes = sum (legend_axes);
       retval = (n_all_axes - n_legend_axes) > 1;
     endif
   endif
 endfunction
+
+
+## No test needed for internal helper function.
+%!assert (1)
diff --git a/scripts/plot/__go_close_all__.m b/scripts/plot/__go_close_all__.m
--- a/scripts/plot/__go_close_all__.m
+++ b/scripts/plot/__go_close_all__.m
@@ -21,8 +21,12 @@
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function __go_close_all__ ()
   close ("all", "hidden");
 endfunction
+
+
+## No test needed for internal helper function.
+%!assert (1)
diff --git a/scripts/plot/__plt_get_axis_arg__.m b/scripts/plot/__plt_get_axis_arg__.m
--- a/scripts/plot/__plt_get_axis_arg__.m
+++ b/scripts/plot/__plt_get_axis_arg__.m
@@ -71,8 +71,12 @@ function [h, varargin, narg] = __plt_get
 
   if (ishandle (h) && strcmp (get (h, "nextplot"), "new"))
     h = axes ();
   endif
 
   narg = length (varargin);
 
 endfunction
+
+
+## No test needed for internal helper function.
+%!assert (1)
diff --git a/scripts/plot/allchild.m b/scripts/plot/allchild.m
--- a/scripts/plot/allchild.m
+++ b/scripts/plot/allchild.m
@@ -43,8 +43,17 @@ function h = allchild (handles)
         h{i} = get (handles, "children");
       endfor
     endif
   unwind_protect_cleanup
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
 
 endfunction
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   l = line;
+%!   assert(get(allchild(hf),'type'),{'axes'; 'uimenu'; 'uimenu'; 'uimenu'})
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
diff --git a/scripts/plot/ancestor.m b/scripts/plot/ancestor.m
--- a/scripts/plot/ancestor.m
+++ b/scripts/plot/ancestor.m
@@ -69,8 +69,18 @@ function p = ancestor (h, type, toplevel
     else
       error ("ancestor: second argument must be a string or cell array of strings");
     endif
   else
     print_usage ();
   endif
 
 endfunction
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   l = line;
+%!   assert (ancestor (l, "axes"), gca);
+%!   assert (ancestor (l, "figure"), hf);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
diff --git a/scripts/plot/clf.m b/scripts/plot/clf.m
--- a/scripts/plot/clf.m
+++ b/scripts/plot/clf.m
@@ -70,8 +70,19 @@ function clf (varargin)
     ## Select only the chilren with visible handles.
     hc = get (hfig, "children");
   endif
 
   ## Delete the children.
   delete (hc);
 
 endfunction
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   l = line;
+%!   assert (!isempty (get (gcf, "children")));
+%!   clf;
+%!   assert (isempty (get (gcf, "children")));
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
diff --git a/scripts/plot/findall.m b/scripts/plot/findall.m
--- a/scripts/plot/findall.m
+++ b/scripts/plot/findall.m
@@ -37,8 +37,18 @@ function h = findall (varargin)
     shh = get (0, "showhiddenhandles");
     set (0, "showhiddenhandles", "on");
     h = findobj (varargin{:});
   unwind_protect_cleanup
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
 
 endfunction
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   h = findall;
+%!   all_handles = {"uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "root"; "figure"};
+%!   assert (get (h, 'type'), all_handles)
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -237,8 +237,23 @@ function h = findobj (varargin)
         endif
       endfor
     endfor
   endif
 
   h = h (keepers != 0);
   h = reshape (h, [numel(h), 1]);
 endfunction
+
+%!test
+%! fign = 1232;
+%! hf = figure (fign, "visible", "off");
+%! unwind_protect  
+%!   l = line;
+%!   obj = findobj ("type", "line");
+%!   assert (l, obj);
+%!   assert (gca, findobj ("type", "axes"));
+%!   assert (fign, findobj ("type", "figure"));
+%!   assert (0, findobj ("type", "root"));
+%!   assert (isempty (findobj ("type", "xyzxyz")));
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
diff --git a/scripts/plot/gcf.m b/scripts/plot/gcf.m
--- a/scripts/plot/gcf.m
+++ b/scripts/plot/gcf.m
@@ -48,8 +48,18 @@ function h = gcf ()
       ## object and make it the current figure.
       h = figure (1);
     endif
   else
     print_usage ();
   endif
 
 endfunction
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   line;
+%!   clf;
+%!   assert (isempty (get (gcf, "children")));
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
diff --git a/scripts/plot/line.m b/scripts/plot/line.m
--- a/scripts/plot/line.m
+++ b/scripts/plot/line.m
@@ -37,8 +37,22 @@ function h = line (varargin)
   ## the current figure.
   tmp = __line__ (gca (), varargin{:});
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   h = line;
+%!   assert (get (h, "xdata"), [0 1], eps);
+%!   assert (get (h, "ydata"), [0 1], eps);
+%!   assert (get (h, "type"), "line");
+%!   assert (get (h, "color"), [0 0 0]);
+%!   assert (get (h, "linestyle"), "-");
+%!   assert (get (h, "linewidth"), 0.5, eps);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -55,8 +55,16 @@ function retval = loglog (varargin)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+%!demo
+%! t = 1:0.01:10;
+%! x = sort ((t .* (1 + rand (size (t)))) .^ 2);
+%! y = ((t .* (1 + rand (size (t)))) .^ 2);
+%! loglog (x, y);
+
+## Remove from test statistics.  No real tests possible.
+%!assert (1)
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -565,17 +565,17 @@ function [papersize, paperposition] = gs
 
 endfunction
 
 function value = convert2points (value, units)
     switch (units)
     case "inches"
       value = value * 72;
     case "centimeters"
-      value = value * 72 / 25.4;
+      value = value * 72 / 2.54;
     case "normalized"
       error ("print:customnormalized",
              "print.m: papersize=='<custom>' and paperunits='normalized' may not be combined");
     endswitch
 endfunction
 
 function device_list = gs_device_list ();
   ## Graphics formats/languages, not priners.
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -54,8 +54,16 @@ function retval = semilogx (varargin)
     if (nargout > 0)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
+
+%!demo
+%! x = 1:0.01:10;
+%! y = (x .* (1 + rand (size (x)))) .^ 2;
+%! semilogx (y, x);
+
+## Remove from test statistics.  No real tests possible.
+%!assert (1)
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -55,8 +55,16 @@ function retval = semilogy (varargin)
       retval = tmp;
     endif
 
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
+
+%!demo
+%! x = 1:0.01:10;
+%! y = (x .* (1 + rand (size (x)))) .^ 2;
+%! semilogy (x, y);
+
+## Remove from test statistics.  No real tests possible.
+%!assert (1)
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -32,8 +32,25 @@ function h = title (string, varargin)
     else
       __axis_label__ ("title", string, varargin{:});
     endif
   else
     print_usage ();
   endif
 
 endfunction
+
+%!demo
+%! clf ();
+%! ax=axes();
+%! xl = get(ax,"title");
+%! title("Testing title")
+%! assert(get(xl,"string"),"Testing title")
+
+%!demo
+%! clf ();
+%! plot3 ([0,1], [0,1], [0,1]);
+%! xl = get(gca (), "title");
+%! title("Testing title")
+%! assert(get(xl,"string"),"Testing title")
+
+## Remove from test statistics.  No real tests possible.
+%!assert (1)
diff --git a/scripts/plot/view.m b/scripts/plot/view.m
--- a/scripts/plot/view.m
+++ b/scripts/plot/view.m
@@ -88,8 +88,39 @@ function [azimuth, elevation] = view (va
       azimuth = az;
       elevation = el;
     endif
   else
     print_usage ();
   endif
 
 endfunction
+
+%!test
+%! fign = 1232;
+%! hf = figure (fign, "visible", "off");
+%! unwind_protect  
+%!   plot3 ([0,1], [0,1], [0,1]);
+%!   [az, el] = view;
+%!   assert ([az, el], [-37.5, 30], eps);
+%!   view (2);
+%!   [az, el] = view;
+%!   assert ([az, el], [0, 90], eps);
+%!   view ([1 1 0]);
+%!   [az, el] = view;
+%!   assert ([az, el], [135, 0], eps);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!test
+%! fign = 1232;
+%! hf = figure (fign, "visible", "off");
+%! unwind_protect  
+%!   line;
+%!   [az, el] = view;
+%!   assert ([az, el], [0, 90], eps);
+%!   view (3);
+%!   [az, el] = view;
+%!   assert ([az, el], [-37.5, 30], eps);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
diff --git a/scripts/plot/whitebg.m b/scripts/plot/whitebg.m
--- a/scripts/plot/whitebg.m
+++ b/scripts/plot/whitebg.m
@@ -138,8 +138,26 @@ function whitebg (varargin)
       defs = get (0, "default");
       if (isfield (defs, "defaultaxescolor")
           && strcmp (defs.defaultaxescolor, "none"))
         set (0, "defaultaxescolor", color);
       endif
     endif
   endif
 endfunction
+
+%!test
+%! set (0, "defaultaxescolor", [1 1 1]);
+%! set (0, "defaultfigurecolor", [1 1 1]);
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   l = line;
+%!   assert (get (hf, "color"), [1 1 1]);
+%!   assert (get (gca, "color"), [1 1 1]);
+%!   whitebg;
+%!   assert (get (hf, "color"), [0 0 0]);
+%!   assert (get (gca, "color"), [0 0 0]);
+%!   whitebg([0.2 0.2 0.2])
+%!   assert (get (hf, "color"), [0 0 0]);
+%!   assert (get (gca, "color"), [0.2 0.2 0.2]);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
diff --git a/scripts/plot/xlim.m b/scripts/plot/xlim.m
--- a/scripts/plot/xlim.m
+++ b/scripts/plot/xlim.m
@@ -39,8 +39,58 @@
 
 function retval = xlim (varargin)
   ret = __axes_limits__ ("xlim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
+
+%!demo
+%! clf ();
+%! line ();
+%! xlim ([0.2, 0.8]);
+%! title ("xlim is [0.2, 0.8]");
+%! assert (xlim (), [0.2, 0.8]);
+
+%!demo
+%! clf ();
+%! line ();
+%! xlim ('auto');
+%! title ("xlim is auto");
+%! assert (xlim ("mode"), "auto");
+
+%!demo
+%! clf ();
+%! plot3 ([0,1], [0,1], [0,1]);
+%! xlim ([0.2, 0.8]);
+%! title ("xlim is [0.2, 0.8]");
+%! assert (xlim (), [0.2, 0.8]);
+
+%!demo
+%! clf ();
+%! plot3 ([0,1], [0,1], [0,1]);
+%! xlim ('auto');
+%! title ("xlim is auto");
+%! assert (xlim ("mode"), "auto");
+
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   plot3 ([0,1], [0,1], [0,1]);
+%!   xlim ([0, 1.1]);
+%!   assert (get (gca, "xlim"), [0, 1.1], eps);
+%!   assert (xlim ("mode"), "manual");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   h = plot3 ([0,1.1], [0,1], [0, 1]);
+%!   assert (get (gca, "xlim"), [0, 1.4], eps);
+%!   assert (xlim ("mode"), "auto");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
diff --git a/scripts/plot/ylim.m b/scripts/plot/ylim.m
--- a/scripts/plot/ylim.m
+++ b/scripts/plot/ylim.m
@@ -39,8 +39,58 @@
 
 function retval = ylim (varargin)
   ret = __axes_limits__ ("ylim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
+
+%!demo
+%! clf ();
+%! line ();
+%! ylim ([0.2, 0.8]);
+%! title ("ylim is [0.2, 0.8]");
+%! assert (ylim (), [0.2, 0.8]);
+
+%!demo
+%! clf ();
+%! line ();
+%! ylim ('auto');
+%! title ("ylim is auto");
+%! assert (ylim ("mode"), "auto");
+
+%!demo
+%! clf ();
+%! plot3 ([0,1], [0,1], [0,1]);
+%! ylim ([0.2, 0.8]);
+%! title ("ylim is [0.2, 0.8]");
+%! assert (ylim (), [0.2, 0.8]);
+
+%!demo
+%! clf ();
+%! plot3 ([0,1], [0,1], [0,1]);
+%! ylim ('auto');
+%! title ("ylim is auto");
+%! assert (ylim ("mode"), "auto");
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   limy = [0, 1.1];
+%!   plot3 ([0,1], [0,1], [0,1]);
+%!   ylim (limy);
+%!   assert (get (gca, "ylim"), limy, eps);
+%!   assert (ylim ("mode"), "manual");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   plot3 ([0,1], [0,1.1], [0, 1]);
+%!   assert (get (gca, "ylim"), [0, 1.4], eps);
+%!   assert (ylim ("mode"), "auto");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
diff --git a/scripts/plot/zlim.m b/scripts/plot/zlim.m
--- a/scripts/plot/zlim.m
+++ b/scripts/plot/zlim.m
@@ -39,8 +39,58 @@
 
 function retval = zlim (varargin)
   ret = __axes_limits__ ("zlim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
+
+%!demo
+%! clf ();
+%! line ();
+%! zlim ([0.2, 0.8]);
+%! title ("zlim is [0.2, 0.8]");
+%! assert (zlim (), [0.2, 0.8]);
+
+%!demo
+%! clf ();
+%! line ();
+%! zlim ('auto');
+%! title ("zlim is auto");
+%! assert (zlim ("mode"), "auto");
+
+%!demo
+%! clf ();
+%! plot3 ([0,1], [0,1], [0,1]);
+%! zlim ([0.2, 0.8]);
+%! title ("zlim is [0.2, 0.8]");
+%! assert (zlim (), [0.2, 0.8]);
+
+%!demo
+%! clf ();
+%! plot3 ([0,1], [0,1], [0,1]);
+%! zlim ('auto');
+%! title ("zlim is auto");
+%! assert (zlim ("mode"), "auto");
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   limz = [0, 1.1];
+%!   plot3 ([0,1], [0,1], [0,1]);
+%!   zlim (limz);
+%!   assert (get (gca, "zlim"), limz, eps);
+%!   assert (zlim ("mode"), "manual");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   plot3 ([0,1], [0,1], [0, 1.1]);
+%!   assert (get (gca, "zlim"), [0, 1.4], eps);
+%!   assert (zlim ("mode"), "auto");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -76,8 +76,29 @@ function x = polygcd (b, a, tol)
         a = r / r(1);
       endwhile
     endif
   else
     print_usage ();
   endif
 
 endfunction
+
+
+%!test
+%! poly1 = [1 6 11 6]; % (x+1)(x+2)(x+3)
+%! poly2 = [1 3 2]; % (x+1)(x+2)
+%! poly3 = polygcd (poly1, poly2);
+%! assert (poly3, poly2, sqrt (eps))
+
+%!test
+%! assert (polygcd (poly(1:8), poly(3:12)), poly(3:8), sqrt (eps))
+
+%!test
+%! assert (deconv (poly(1:8), polygcd (poly(1:8), poly(3:12))), poly(1:2), sqrt (eps))
+
+%!test 
+%! for ii=1:10
+%!   p  = (unique (randn (10, 1)) * 10).';
+%!   p1 = p(3:end);
+%!   p2 = p(1:end-2);
+%!   assert (polygcd (poly (-p1), poly (-p2)), poly (- intersect (p1, p2)), sqrt (eps))
+%! endfor
diff --git a/scripts/polynomial/ppjumps.m b/scripts/polynomial/ppjumps.m
--- a/scripts/polynomial/ppjumps.m
+++ b/scripts/polynomial/ppjumps.m
@@ -51,8 +51,34 @@ function jumps = ppjumps (pp)
   for i = 2 : k;
     llim .*= dx;
     llim += shiftdim (reshape (P(1:(n-1) * prod (d), i), [d, n-1]), nd - 1);
   endfor
   
   rlim = shiftdim (ppval (pp, x(2:end-1)), nd - 1);
   jumps = shiftdim (rlim - llim, 1);
 endfunction
+
+
+%!test
+%! p = [1 6 11 6];
+%! x = linspace (5, 6, 4);
+%! y = polyval (p, x);
+%! pp = spline (x, y);
+%! jj = ppjumps (pp);
+%! assert (jj, [0 0], eps)
+
+%!test
+%!
+%! breaks = [0 1 2];
+%! pp1 = poly (-[1 2 3]);
+%! pp2 = poly (-([1 2 3]+1));
+%! pp = mkpp (breaks, [pp1;pp2]);
+%! assert (ppjumps (pp), 0, eps)
+
+%!test
+%!
+%! breaks = [0 1 2];
+%! pp1 = poly (-[1 2 3]);
+%! pp2 = poly (([1 2 3]+1));
+%! pp = mkpp (breaks, [pp1;pp2]);
+%! j  = - 2 * polyval (pp1, 1);
+%! assert (ppjumps (pp), j, eps)
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -42,8 +42,22 @@ function c = bartlett (m)
     c = 1;
   else
     m = m - 1;
     n = fix (m / 2);
     c = [2*(0:n)/m, 2-2*(n+1:m)/m]';
   endif
 
 endfunction
+
+%!assert (bartlett (1), 1);
+%!assert (bartlett (2), zeros (2,1));
+%!assert (bartlett (16), fliplr (bartlett (16)));
+%!assert (bartlett (15), fliplr (bartlett (15)));
+%!test
+%! N = 9;
+%! A = bartlett (N);
+%! assert (A (ceil (N/2)), 1);
+
+%!error bartlett ();
+%!error bartlett (0.5);
+%!error bartlett (-1);
+%!error bartlett (ones(1,4));
\ No newline at end of file
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -41,8 +41,23 @@ function c = blackman (m)
     c = 1;
   else
     m = m - 1;
     k = (0 : m)' / m;
     c = 0.42 - 0.5 * cos (2 * pi * k) + 0.08 * cos (4 * pi * k);
   endif
 
 endfunction
+
+%!assert (blackman (1), 1);
+%!assert (blackman (2), zeros(2,1), 1e-6);
+%!assert (blackman (16), fliplr (blackman (16)));
+%!assert (blackman (15), fliplr (blackman (15)));
+%!test
+%! N = 9;
+%! A = blackman (N);
+%! assert (A (ceil (N/2)), 1, 1e-6);
+%! assert ([A(1), A(length (A))], zeros (1, 2), 1e-6);
+
+%!error blackman ();
+%!error blackman (0.5);
+%!error blackman (-1);
+%!error blackman (ones(1,4));
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -49,60 +49,103 @@ function y = fftfilt (b, x, n)
 
   if (transpose)
     x = x.';
   endif
 
   [r_x, c_x] = size (x);
   [r_b, c_b] = size (b);
 
-  if min ([r_b, c_b]) != 1
-    error ("fftfilt: B should be a vector");
+  if (! isvector (b))
+    error ("fftfilt: B must be a vector");
+  endif
+
+  if (ndims (x) != 2)
+    error ("fftfilt: X must be a 1-D or 2-D array");
   endif
 
   l_b = r_b * c_b;
   b = reshape (b, l_b, 1);
 
   if (nargin == 2)
     ## Use FFT with the smallest power of 2 which is >= length (x) +
     ## length (b) - 1 as number of points ...
-    n = 2 ^ (ceil (log (r_x + l_b - 1) / log (2)));
+    n = 2 ^ nextpow2 (r_x + l_b - 1);
     B = fft (b, n);
-    y = ifft (fft (x, n) .* B(:,ones (1, c_x)));
+    y = ifft (fft (x, n) .* B(:, ones (1, c_x)));
   else
     ## Use overlap-add method ...
     if (! (isscalar (n)))
       error ("fftfilt: N has to be a scalar");
     endif
-    n = 2 ^ (ceil (log (max ([n, l_b])) / log (2)));
+    n = 2 ^ nextpow2 (max ([n, l_b]));
     L = n - l_b + 1;
     B = fft (b, n);
-    B = B(:,ones (c_x,1));
+    B = B(:, ones (c_x,1));
     R = ceil (r_x / L);
     y = zeros (r_x, c_x);
     for r = 1:R;
       lo = (r - 1) * L + 1;
       hi = min (r * L, r_x);
       tmp = zeros (n, c_x);
       tmp(1:(hi-lo+1),:) = x(lo:hi,:);
       tmp = ifft (fft (tmp) .* B);
       hi  = min (lo+n-1, r_x);
       y(lo:hi,:) = y(lo:hi,:) + tmp(1:(hi-lo+1),:);
     endfor
   endif
 
-  y = y(1:r_x,:);
+  y = y(1:r_x, :);
   if (transpose)
     y = y.';
   endif
 
-  ## Final cleanups: if both x and b are real respectively integer, y
-  ## should also be
+  ## Final cleanups: If both x and b are real, y should be real.
+  ## If both x and b are integer, y should be integer.
 
   if (isreal (b) && isreal (x))
     y = real (y);
   endif
-  if (! any (b - round (b)))
-    idx = !any (x - round (x));
-    y(:,idx) = round (y(:,idx));
+  if (! any (b - fix (b)))
+    idx = !any (x - fix (x));
+    y(:, idx) = round (y(:, idx));
   endif
 
 endfunction
+
+
+%!shared b, x, r
+%!test
+%!  b = [1 1];
+%!  x = [1, zeros(1,9)];
+%!  assert(fftfilt(b,  x  ), [1 1 0 0 0 0 0 0 0 0]  , eps);
+%!  assert(fftfilt(b,  x.'), [1 1 0 0 0 0 0 0 0 0].', eps);
+%!  assert(fftfilt(b.',x  ), [1 1 0 0 0 0 0 0 0 0]  , eps);
+%!  assert(fftfilt(b.',x.'), [1 1 0 0 0 0 0 0 0 0].', eps);
+
+%!test
+%!  r = sqrt(1/2) * (1+i);
+%!  b = b*r;
+%!  assert(fftfilt(b, x  ), r*[1 1 0 0 0 0 0 0 0 0]  , eps);
+%!  assert(fftfilt(b, r*x), r*r*[1 1 0 0 0 0 0 0 0 0], eps);
+%!  assert(fftfilt(b, x.'), r*[1 1 0 0 0 0 0 0 0 0].', eps);
+
+%!test
+%!  b = [1 1];
+%!  x = zeros (10,3); x(1,1)=-1; x(1,2)=1;
+%!  y0 = zeros (10,3); y0(1:2,1)=-1; y0(1:2,2)=1;
+%!  y = fftfilt (b, x);
+%!  assert (y,y0);
+
+%!test
+%!  b  = rand (10, 1);
+%!  x  = rand (10, 1);
+%!  y0 = filter (b, 1, x);
+%!  y  = filter (b, 1, x);
+%!  assert (y, y0);
+
+%% Test input validation
+%!error fftfilt (1)
+%!error fftfilt (1, 2, 3, 4)
+%!error fftfilt (ones (2), 1)
+%!error fftfilt (2, ones (3,3,3))
+%!error fftfilt (2, 1, ones (2))
+
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -40,8 +40,22 @@ function c = hamming (m)
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     c = 0.54 - 0.46 * cos (2 * pi * (0:m)' / m);
   endif
 
 endfunction
+
+%!assert (hamming (1), 1);
+%!assert (hamming (2), (0.54 - 0.46)*ones(2,1));
+%!assert (hamming (16), fliplr (hamming (16)));
+%!assert (hamming (15), fliplr (hamming (15)));
+%!test
+%! N = 15;
+%! A = hamming (N);
+%! assert (A (ceil (N/2)), 1);
+
+%!error hamming ();
+%!error hamming (0.5);
+%!error hamming (-1);
+%!error hamming (ones(1,4));
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -40,8 +40,22 @@ function c = hanning (m)
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     c = 0.5 - 0.5 * cos (2 * pi * (0 : m)' / m);
   endif
 
 endfunction
+
+%!assert (hanning (1), 1);
+%!assert (hanning (2), zeros(2,1));
+%!assert (hanning (16), fliplr (hanning (16)));
+%!assert (hanning (15), fliplr (hanning (15)));
+%!test
+%! N = 15;
+%! A = hanning (N);
+%! assert (A (ceil (N/2)), 1);
+
+%!error hanning ();
+%!error hanning (0.5);
+%!error hanning (-1);
+%!error hanning (ones(1,4));
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
new file mode 100644
--- /dev/null
+++ b/scripts/sparse/bicg.m
@@ -0,0 +1,254 @@
+## Copyright (C) 2006   Sylvain Pelissier   <sylvain.pelissier@gmail.com>
+## Copyright (C) 2011   Carlo de Falco
+##
+## This program is free software; you can redistribute it and/or modify
+## it under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2 of the License, or
+## (at your option) any later version.
+##
+## This program is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with this program; If not, see <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+##  
+## @deftypefn {Function File} {@var{x} =} bicg (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
+## @deftypefnx {Function File} {@var{x} =} bicg (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
+## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicg (@var{A}, @var{b}, ...)
+## Solve @code{A x = b} using the Bi-conjugate gradient iterative method.
+##
+## @itemize @minus
+## @item @var{rtol} is the relative tolerance, if not given 
+## or set to [] the default value 1e-6 is used.
+## @item @var{maxit} the maximum number of outer iterations, 
+## if not given or set to [] the default value 
+## @code{min (20, numel (b))} is used.
+## @item @var{x0} the initial guess, if not given or set to [] 
+## the default value @code{zeros (size (b))} is used. 
+## @end itemize
+##
+## @var{A} can be passed as a matrix or as a function handle or 
+## inline function @code{f} such that @code{f(x, "notransp") = A*x}
+## and @code{f(x, "transp") = A'*x}.
+##
+## The preconditioner @var{P} is given as @code{P = M1 * M2}. 
+## Both @var{M1} and @var{M2} can be passed as a matrix or as 
+## a function handle or inline function @code{g} such that 
+## @code{g(x, 'notransp') = M1 \ x} or @code{g(x, 'notransp') = M2 \ x} and 
+## @code{g(x, 'transp') = M1' \ x} or @code{g(x, 'transp') = M2' \ x}.
+##
+## If colled with more than one output parameter
+##
+## @itemize @minus
+## @item @var{flag} indicates the exit status:
+## @itemize @minus
+## @item 0: iteration converged to the within the chosen tolerance
+## @item 1: the maximum number of iterations was reached before convergence
+## @item 3: the algorithm reached stagnation
+## @end itemize
+## (the value 2 is unused but skipped for compatibility).
+## @item @var{relres} is the final value of the relative residual.
+## @item @var{iter} is the number of iterations performed. 
+## @item @var{resvec} is a vector containing the relative residual at each iteration.
+## @end itemize
+##
+## @seealso{bicgstab,cgs,gmres,pcg}
+##
+## @end deftypefn
+
+
+function [x, flag, res1, k, resvec] = bicg (A, b, tol, maxit, M1, M2, x0)
+
+  if (nargin >= 2 && isvector (full (b)))
+    
+    if (ischar (A))
+      fun = str2func (A);
+      Ax  = @(x) feval (fun, x, "notransp");
+      Atx = @(x) feval (fun, x, "transp");
+    elseif (ismatrix (A))
+      Ax  = @(x) A  * x;
+      Atx = @(x) A' * x;
+    elseif (isa (A, "function_handle"))
+      Ax  = @(x) feval (A, x, "notransp");
+      Atx = @(x) feval (A, x, "transp");
+    else
+      error (["bicg: first argument is expected to " ...
+              "be a function or a square matrix"]);
+    endif
+
+    if (nargin < 3 || isempty (tol))
+      tol = 1e-6;
+    endif
+
+    if (nargin < 4 || isempty (maxit))
+      maxit = min (rows (b), 20);
+    endif
+
+    if (nargin < 5 || isempty (M1))
+      M1m1x = @(x, ignore) x;
+      M1tm1x = M1m1x;
+    elseif (ischar (M1))
+      fun = str2func (M1);
+      M1m1x  = @(x) feval (fun, x, "notransp");
+      M1tm1x = @(x) feval (fun, x, "transp");
+    elseif (ismatrix (M1))
+      M1m1x  = @(x) M1  \ x;
+      M1tm1x = @(x) M1' \ x;
+    elseif (isa (M1, "function_handle"))
+      M1m1x  = @(x) feval (M1, x, "notransp");
+      M1tm1x = @(x) feval (M1, x, "transp");
+    else
+      error (["bicg: preconditioner is expected to " ...
+              "be a function or matrix"]);
+    endif
+    
+    if (nargin < 6 || isempty (M2))
+      M2m1x = @(x, ignore) x;
+      M2tm1x = M2m1x;
+    elseif (ischar (M2))
+      fun = str2func (M2);
+      M2m1x  = @(x) feval (fun, x, "notransp");
+      M2tm1x = @(x) feval (fun, x, "transp");
+    elseif (ismatrix (M2))
+      M2m1x  = @(x) M2  \ x;
+      M2tm1x = @(x) M2' \ x;
+    elseif (isa (M2, "function_handle"))
+      M2m1x  = @(x) feval (M2, x, "notransp");
+      M2tm1x = @(x) feval (M2, x, "transp");
+    else
+      error (["bicg: preconditioner is expected to " ...
+              "be a function or matrix"]);
+    endif
+
+    Pm1x  = @(x) M2m1x  (M1m1x (x));
+    Ptm1x = @(x) M1tm1x (M2tm1x (x));
+
+    if (nargin < 7 || isempty (x0))
+      x0 = zeros (size (b));
+    endif
+
+    y = x = x0;
+    c = b;
+
+    r0 = b - Ax (x);
+    s0 = c - Atx (y);
+
+    d = Pm1x (r0);
+    f = Ptm1x (s0);
+
+    bnorm = norm (b);
+    res0  = Inf;
+
+    if (any (r0 != 0))
+      
+      for k = 1:maxit
+
+	a  = (s0' * Pm1x (r0)) ./ (f' * Ax (d));
+
+	x += a * d;
+	y += conj (a) * f;
+
+	r1 = r0 - a * Ax (d);
+	s1 = s0 - conj (a) * Atx (f);
+
+	beta = (s1' * Pm1x (r1)) ./ (s0' * Pm1x (r0));
+
+	d = Pm1x (r1) + beta * d;
+	f = Ptm1x (s1) + conj (beta) * f;
+
+	r0 = r1;
+	s0 = s1;
+
+	res1 = norm (b - Ax (x)) / bnorm;
+	if (res1 < tol)
+          flag = 0;
+          if (nargout < 2)
+	    printf ("bicg converged at iteration %i ", k);
+            printf ("to a solution with relative residual %e\n", res1);
+          endif
+	  break;
+	endif
+	
+	if (res0 <= res1)
+          flag = 3;
+	  printf ("bicg stopped at iteration %i ", k);
+          printf ("without converging to the desired tolerance %e\n", tol);
+          printf ("because the method stagnated.\n");
+          printf ("The iterate returned (number %i) ", k-1);
+          printf ("has relative residual %e\n", res0);
+	  break
+	endif
+        res0 = res1;
+        if (nargout > 4)
+          resvec(k) = res0;
+        endif
+      endfor
+
+      if (k == maxit)
+        flag = 1;
+	printf ("bicg stopped at iteration %i ", maxit);
+        printf ("without converging to the desired tolerance %e\n", tol);
+        printf ("because the maximum number of iterations was reached. ");
+        printf ("The iterate returned (number %i) has ", maxit);
+        printf ("relative residual %e\n", res1);
+      endif
+
+    else
+      flag = 0;
+      if (nargout < 2)
+        printf ("bicg converged after 0 interations\n");
+      endif
+    endif
+  
+  else
+    print_usage ();
+  endif
+  
+endfunction;
+
+
+%!test
+%! n = 100; 
+%! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
+%! b = sum (A, 2); 
+%! tol = 1e-8; 
+%! maxit = 15;
+%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n); 
+%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n); 
+%! [x, flag, relres, iter, resvec] = bicg (A, b, tol, maxit, M1, M2);
+%! assert (x, ones (size (b)), 1e-7);
+%!
+%!test
+%! n = 100; 
+%! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
+%! b = sum (A, 2); 
+%! tol = 1e-8; 
+%! maxit = 15;
+%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n); 
+%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n); 
+%!
+%! function y = afun (x, t, a)
+%!  switch t
+%!   case "notransp"
+%!     y = a * x;
+%!   case "transp"
+%!     y = a' * x;
+%!  endswitch
+%! endfunction
+%!
+%! [x, flag, relres, iter, resvec] = bicg (@(x, t) afun (x, t, A), 
+%!                                         b, tol, maxit, M1, M2);
+%! assert (x, ones (size (b)), 1e-7);
+
+%!test
+%! n = 100; 
+%! tol = 1e-8; 
+%! a = sprand (n, n, .1);
+%! A = a' * a + 100 * eye (n);
+%! b = sum (A, 2); 
+%! [x, flag, relres, iter, resvec] = bicg (A, b, tol, [], diag (diag (A)));
+%! assert (x, ones (size (b)), 1e-7);
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -1,9 +1,10 @@
 ## Copyright (C) 2008-2011 Radek Salac
+## Copyright (C) 2011 Carlo de Falco
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,167 +13,226 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} bicgstab (@var{A}, @var{b})
-## @deftypefnx {Function File} {} bicgstab (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
-## This procedure attempts to solve a system of linear equations A*x = b for x.
-## The @var{A} must be square, symmetric and positive definite real matrix N*N.
-## The @var{b} must be a one column vector with a length of N.
-## The @var{tol} specifies the tolerance of the method, the default value is
-## 1e-6.
-## The @var{maxit} specifies the maximum number of iterations, the default value
-## is min(20,N).
-## The @var{M1} specifies a preconditioner, can also be a function handler which
-## returns M\X.
-## The @var{M2} combined with @var{M1} defines preconditioner as
-## preconditioner=M1*M2.
-## The @var{x0} is the initial guess, the default value is zeros(N,1).
+##  
+## @deftypefn {Function File} {@var{x} =} bicgstab (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
+## @deftypefnx {Function File} {@var{x} =} bicgstab (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
+## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicgstab (@var{A}, @var{b}, ...)
+## Solve @code{A x = b} using the stabilizied Bi-conjugate gradient iterative method.
+##
+## @itemize @minus
+## @item @var{rtol} is the relative tolerance, if not given or set to
+## [] the default value 1e-6 is used.
+## @item @var{maxit} the maximum number of outer iterations, if not
+## given or set to [] the default value @code{min (20, numel (b))} is
+## used.
+## @item @var{x0} the initial guess, if not given or set to [] the
+## default value @code{zeros (size (b))} is used.
+## @end itemize
+##
+## @var{A} can be passed as a matrix or as a function handle or 
+## inline function @code{f} such that @code{f(x) = A*x}.
 ##
-## The value @var{x} is a computed result of this procedure.
-## The value @var{flag} can be 0 when we reach tolerance in @var{maxit}
-## iterations, 1 when
-## we don't reach tolerance in @var{maxit} iterations and 3 when the procedure
-## stagnates.
-## The value @var{relres} is a relative residual - norm(b-A*x)/norm(b).
-## The value @var{iter} is an iteration number in which x was computed.
-## The value @var{resvec} is a vector of @var{relres} for each iteration.
+## The preconditioner @var{P} is given as @code{P = M1 * M2}. 
+## Both @var{M1} and @var{M2} can be passed as a matrix or as a function handle or 
+## inline function @code{g} such that @code{g(x) = M1 \ x} or @code{g(x) = M2 \ x}.
+##
+## If called with more than one output parameter
+##
+## @itemize @minus
+## @item @var{flag} indicates the exit status:
+## @itemize @minus
+## @item 0: iteration converged to the within the chosen tolerance
+## @item 1: the maximum number of iterations was reached before convergence
+## @item 3: the algorithm reached stagnation
+## @end itemize
+## (the value 2 is unused but skipped for compatibility).
+## @item @var{relres} is the final value of the relative residual.
+## @item @var{iter} is the number of iterations performed. 
+## @item @var{resvec} is a vector containing the relative residual at each iteration.
+## @end itemize
+##
+## @seealso{bicg,cgs,gmres,pcg}
 ##
 ## @end deftypefn
 
-function [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, maxit, M1, M2, x0)
+function [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, maxit, 
+                                                     M1, M2, x0)
 
-  if (nargin < 2 || nargin > 7 || nargout > 5)
-    print_usage ();
-  elseif (!(isnumeric (A) && issquare (A)))
-    error ("bicgstab: A must be a square numeric matrix");
-  elseif (!isvector (b))
-    error ("bicgstab: B must be a vector");
-  elseif (!any (b))
-    error ("bicgstab: B must not be a vector of all zeros");
-  elseif (rows (A) != rows (b))
-    error ("bicgstab: A and B must have the same number of rows");
-  elseif (nargin > 2 && !isscalar (tol))
-    error ("bicgstab: TOL must be a scalar");
-  elseif (nargin > 3 && !isscalar (maxit))
-    error ("bicgstab: MAXIT must be a scalar");
-  elseif (nargin > 4 && ismatrix (M1) && (rows (M1) != rows (A) || columns (M1) != columns (A)))
-    error ("bicgstab: M1 must have the same number of rows and columns as A");
-  elseif (nargin > 5 && (!ismatrix (M2) || rows (M2) != rows (A) || columns (M2) != columns (A)))
-    error ("bicgstab: M2 must have the same number of rows and columns as A");
-  elseif (nargin > 6 && !isvector (x0))
-    error ("bicgstab: X0 must be a vector");
-  elseif (nargin > 6 && rows (x0) != rows (b))
-    error ("bicgstab: X0 must have the same number of rows as B");
-  endif
+  if (nargin >= 2 && nargin <= 7 && isvector (full (b)))
+    
+    if (ischar (A))
+      A = str2func (A);
+    elseif (ismatrix (A))
+      Ax  = @(x) A  * x;
+    elseif (isa (A, "function_handle"))
+      Ax  = @(x) feval (A, x);
+    else
+      error (["bicgstab: first argument is expected " ...
+              "to be a function or a square matrix"]);
+    endif
+    
+    if (nargin < 3 || isempty (tol))
+      tol = 1e-6;
+    endif
 
-  ## Default tolerance.
-  if (nargin < 3)
-    tol = 1e-6;
-  endif
-
-  ## Default maximum number of iteration.
-  if (nargin < 4)
-    maxit = min (rows (b), 20);
-  endif
+    if (nargin < 4 || isempty (maxit))
+      maxit = min (rows (b), 20);
+    endif
 
-  ## Left preconditioner.
-  if (nargin == 5)
-    if (isnumeric (M1))
-      precon = @(x) M1 \ x;
+    if (nargin < 5 || isempty (M1))
+      M1m1x = @(x) x;
+    elseif (ischar (M1))
+      M1m1x = str2func (M1);
+    elseif (ismatrix (M1))
+      M1m1x = @(x) M1  \ x;
+    elseif (isa (M1, "function_handle"))
+      M1m1x = @(x) feval (M1, x);
+    else
+      error (["bicgstab: preconditioner is " ...
+              "expected to be a function or matrix"]);
     endif
-  elseif (nargin > 5)
-    if (issparse (M1) && issparse (M2))
-      precon = @(x) M2 \ (M1 \ x);
+    
+    if (nargin < 6 || isempty (M2))
+      M2m1x = @(x) x;
+    elseif (ischar (M2))
+      M2m1x = str2func (M2);
+    elseif (ismatrix (M2))
+      M2m1x = @(x) M2  \ x;
+    elseif (isa (M2, "function_handle"))
+      M2m1x = @(x) feval (M2, x);
     else
-      M = M1*M2;
-      precon = @(x) M \ x;
+      error (["bicgstab: preconditioner is "...
+              "expected to be a function or matrix"]);
     endif
-  else
-    precon = @(x) x;
-  endif
 
-  ## specifies initial estimate x0
-  if (nargin < 7)
-    x = zeros (rows (b), 1);
-  else
-    x = x0;
-  endif
-
-  norm_b = norm (b);
-
-  res = b - A*x;
-  rr = res;
+    precon = @(x) M2m1x (M1m1x (x));
 
-  ## Vector of the residual norms for each iteration.
-  resvec = [norm(res)/norm_b];
-
-  ## Default behaviour we don't reach tolerance tol within maxit iterations.
-  flag = 1;
-
-  for iter = 1:maxit
-    rho_1 = res' * rr;
-
-    if (iter == 1)
-      p = res;
+    if (nargin < 7 || isempty (x0))
+      x0 = zeros (size (b));
+    endif
+    
+    ## specifies initial estimate x0
+    if (nargin < 7)
+      x = zeros (rows (b), 1);
     else
-      beta = (rho_1 / rho_2) * (alpha / omega);
-      p = res + beta * (p - omega * v);
+      x = x0;
     endif
 
-    phat = precon (p);
+    norm_b = norm (b);
+
+    res = b - Ax (x);
+    rr = res;
 
-    v = A * phat;
-    alpha = rho_1 / (rr' * v);
-    s = res - alpha * v;
+    ## Vector of the residual norms for each iteration.
+    resvec = norm(res) / norm_b;
 
-    shat = precon (s);
+    ## Default behaviour we don't reach tolerance tol within maxit iterations.
+    flag = 1;
+
+    for iter = 1:maxit
+      rho_1 = res' * rr;
 
-    t = A * shat;
-    omega = (t' * s) / (t' * t);
-    x = x + alpha * phat + omega * shat;
-    res = s - omega * t;
-    rho_2 = rho_1;
+      if (iter == 1)
+        p = res;
+      else
+        beta = (rho_1 / rho_2) * (alpha / omega);
+        p = res + beta * (p - omega * v);
+      endif
+
+      phat = precon (p);
 
-    relres = norm (res) / norm_b;
-    resvec = [resvec; relres];
+      v = Ax (phat);
+      alpha = rho_1 / (rr' * v);
+      s = res - alpha * v;
+
+      shat = precon (s);
+
+      t = Ax (shat);
+      omega = (t' * s) / (t' * t);
+      x = x + alpha * phat + omega * shat;
+      res = s - omega * t;
+      rho_2 = rho_1;
 
-    if (relres <= tol)
-      ## We reach tolerance tol within maxit iterations.
-      flag = 0;
-      break;
-    elseif (resvec (end) == resvec (end - 1))
-      ## The method stagnates.
-      flag = 3;
-      break;
-    endif
-  endfor
+      relres = norm (res) / norm_b;
+      resvec = [resvec; relres];
+
+      if (relres <= tol)
+        ## We reach tolerance tol within maxit iterations.
+        flag = 0;
+        break;
+      elseif (resvec(end) == resvec(end - 1))
+        ## The method stagnates.
+        flag = 3;
+        break;
+      endif
+    endfor
 
-  if (nargout < 2)
-    if (flag == 0)
-      printf (["bicgstab converged at iteration %i ",
-      "to a solution with relative residual %e\n"],iter,relres);
-    elseif (flag == 3)
-      printf (["bicgstab stopped at iteration %i ",
-      "without converging to the desired tolerance %e\n",
-      "because the method stagnated.\n",
-      "The iterate returned (number %i) has relative residual %e\n"],iter,tol,iter,relres);
-    else
-      printf (["bicgstab stopped at iteration %i ",
-      "without converging to the desired toleranc %e\n",
-      "because the maximum number of iterations was reached.\n",
-      "The iterate returned (number %i) has relative residual %e\n"],iter,tol,iter,relres);
+    if (nargout < 2)
+      if (flag == 0)
+        printf ("bicgstab converged at iteration %i ", iter);
+        printf ("to a solution with relative residual %e\n", relres);
+      elseif (flag == 3)
+        printf ("bicgstab stopped at iteration %i ", iter);
+        printf ("without converging to the desired tolerance %e\n", tol);
+        printf ("because the method stagnated.\n");
+        printf ("The iterate returned (number %i) ", iter);
+        printf ("has relative residual %e\n", relres);
+      else
+        printf ("bicgstab stopped at iteration %i ", iter);
+        printf ("without converging to the desired toleranc %e\n", tol);
+        printf ("because the maximum number of iterations was reached.\n");
+        printf ("The iterate returned (number %i) ", iter);
+        printf ("has relative residual %e\n", relres);
+      endif
     endif
+
+  else
+    print_usage ();
   endif
 
 endfunction
 
 %!demo
 %! % Solve system of A*x=b
 %! A = [5 -1 3;-1 2 -2;3 -2 3]
 %! b = [7;-1;4]
 %! [x, flag, relres, iter, resvec] = bicgstab(A, b)
 
+%!shared A, b, n, M1, M2
+%!
+%!test
+%! n = 100; 
+%! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
+%! b = sum (A, 2); 
+%! tol = 1e-8; 
+%! maxit = 15;
+%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n); 
+%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n); 
+%! [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, maxit, M1, M2);
+%! assert (x, ones (size (b)), 1e-7);
+%!
+%!test
+%! tol = 1e-8; 
+%! maxit = 15;
+%!
+%! function y = afun (x, a)
+%!     y = a * x;
+%! endfunction
+%!
+%! [x, flag, relres, iter, resvec] = bicgstab (@(x) afun (x, A), b, 
+%!                                             tol, maxit, M1, M2);
+%! assert (x, ones (size (b)), 1e-7);
+
+%!test
+%! n = 100; 
+%! tol = 1e-8; 
+%! a = sprand (n, n, .1);
+%! A = a'*a + 100 * eye (n);
+%! b = sum (A, 2); 
+%! [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, [], diag (diag (A)));
+%! assert (x, ones (size (b)), 1e-7);
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -1,9 +1,10 @@
 ## Copyright (C) 2008-2011 Radek Salac
+## Copyright (C) 2011 Carlo de Falco
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,147 +13,206 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} cgs (@var{A}, @var{b})
-## @deftypefnx {Function File} {} cgs (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
-## This procedure attempts to solve a system of linear equations A*x = b for x.
-## The @var{A} must be square, symmetric and positive definite real matrix N*N.
-## The @var{b} must be a one column vector with a length of N.
-## The @var{tol} specifies the tolerance of the method, default value is 1e-6.
-## The @var{maxit} specifies the maximum number of iteration, default value is
-## MIN(20,N).
-## The @var{M1} specifies a preconditioner, can also be a function handler which
-## returns M\X.
-## The @var{M2} combined with @var{M1} defines preconditioner as
-## preconditioner=M1*M2.
-## The @var{x0} is initial guess, default value is zeros(N,1).
+##  
+## @deftypefn {Function File} {@var{x} =} cgs (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
+## @deftypefnx {Function File} {@var{x} =} cgs (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
+## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} cgs (@var{A}, @var{b}, ...)
+## Solve @code{A x = b}, where @var{A} is a square matrix, using the
+## Conjugate Gradients Squared method.
+##
+## @itemize @minus
+## @item @var{rtol} is the relative tolerance, if not given or set to []
+## the default value 1e-6 is used.
+## @item @var{maxit} the maximum number of outer iterations, if not
+## given or set to [] the default value @code{min (20, numel (b))} is
+## used.
+## @item @var{x0} the initial guess, if not given or set to [] the
+## default value @code{zeros (size (b))} is used.
+## @end itemize
+##
+## @var{A} can be passed as a matrix or as a function handle or 
+## inline function @code{f} such that @code{f(x) = A*x}.
 ##
+## The preconditioner @var{P} is given as @code{P = M1 * M2}. 
+## Both @var{M1} and @var{M2} can be passed as a matrix or as a function
+## handle or inline function @code{g} such that @code{g(x) = M1 \ x} or
+## @code{g(x) = M2 \ x}.
+##
+## If called with more than one output parameter
+##
+## @itemize @minus
+## @item @var{flag} indicates the exit status:
+## @itemize @minus
+## @item 0: iteration converged to the within the chosen tolerance
+## @item 1: the maximum number of iterations was reached before convergence
+## @item 3: the algorithm reached stagnation
+## @end itemize
+## (the value 2 is unused but skipped for compatibility).
+## @item @var{relres} is the final value of the relative residual.
+## @item @var{iter} is the number of iterations performed. 
+## @item @var{resvec} is a vector containing the relative residual at
+## each iteration.
+## @end itemize
+##
+## @seealso{pcg,bicgstab,bicg,gmres}
 ## @end deftypefn
 
 function [x, flag, relres, iter, resvec] = cgs (A, b, tol, maxit, M1, M2, x0)
 
-  if (nargin < 2 || nargin > 7 || nargout > 5)
-    print_usage ();
-  elseif (!(isnumeric (A) && issquare (A)))
-    error ("cgs: A must be a square numeric matrix");
-  elseif (!isvector (b))
-    error ("cgs: B must be a vector");
-  elseif (rows (A) != rows (b))
-    error ("cgs: A and B must have the same number of rows");
-  elseif (nargin > 2 && !isscalar (tol))
-    error ("cgs: TOL must be a scalar");
-  elseif (nargin > 3 && !isscalar (maxit))
-    error ("cgs: MAXIT must be a scalar");
-  elseif (nargin > 4 && ismatrix (M1) && (rows (M1) != rows (A) || columns (M1) != columns (A)))
-    error ("cgs: M1 must have the same number of rows and columns as A");
-  elseif (nargin > 5 && (!ismatrix (M2) || rows (M2) != rows (A) || columns (M2) != columns (A)))
-    error ("cgs: M2 must have the same number of rows and columns as A");
-  elseif (nargin > 6 && !isvector (x0))
-    error ("cgs: X0 must be a vector");
-  elseif (nargin > 6 && rows (x0) != rows (b))
-    error ("cgs: X0 must have the same number of rows as B");
-  endif
-
-  ## Default tolerance.
-  if (nargin < 3)
-    tol = 1e-6;
-  endif
+  if (nargin >= 2 && nargin <= 7 && isvector (full (b)))
+    
+    if (ischar (A))
+      A = str2func (A);
+    elseif (ismatrix (A))
+      Ax = @(x) A * x;
+    elseif (isa (A, "function_handle"))
+      Ax = @(x) feval (A, x);
+    else
+      error (["cgs: first argument is expected to "... 
+              "be a function or a square matrix"]);
+    endif
+    
+    if (nargin < 3 || isempty (tol))
+      tol = 1e-6;
+    endif
+    
+    if (nargin < 4 || isempty (maxit))
+      maxit = min (rows (b), 20);
+    endif
+    
+    if (nargin < 5 || isempty (M1))
+      M1m1x = @(x) x;
+    elseif (ischar (M1))
+      M1m1x = str2func (M1);
+    elseif (ismatrix (M1))
+      M1m1x = @(x) M1 \ x;
+    elseif (isa (M1, "function_handle"))
+      M1m1x = @(x) feval (M1, x);
+    else
+      error ("cgs: preconditioner is expected to be a function or matrix");
+    endif
+    
+    if (nargin < 6 || isempty (M2))
+      M2m1x = @(x) x;
+    elseif (ischar (M2))
+      M2m1x = str2func (M2);
+    elseif (ismatrix (M2))
+      M2m1x = @(x) M2 \ x;
+    elseif (isa (M2, "function_handle"))
+      M2m1x = @(x) feval (M2, x);
+    else
+      error ("cgs: preconditioner is expected to be a function or matrix");
+    endif
 
-  ## Default maximum number of iteration.
-  if (nargin < 4)
-    maxit = min (rows (b),20);
-  endif
+    precon = @(x) M2m1x (M1m1x (x));
 
-  ## Left preconditioner.
-  if (nargin == 5)
-    if (isnumeric (M1))
-      precon = @(x) M1 \ x;
+    if (nargin < 7 || isempty (x0))
+      x0 = zeros (size (b));
     endif
-  elseif (nargin > 5)
-    if (issparse (M1) && issparse (M2))
-      precon = @(x) M2 \ (M1 \ x);
-    else
-      M = M1*M2;
-      precon = @(x) M \ x;
-    endif
-  else
-    precon = @(x) x;
-  endif
-
-  ## Specifies initial estimate x0.
-  if (nargin < 7)
-    x = zeros (rows (b), 1);
-  else
-    x = x0;
-  endif
 
-  res = b - A * x;
-  norm_b = norm (b);
-  ## Vector of the residual norms for each iteration.
-  resvec = [ norm(res)/norm_b ];
-  ro = 0;
-  ## Default behavior we don't reach tolerance tol within maxit iterations.
-  flag = 1;
-  for iter = 1 : maxit
+    
+    x = x0;
+    
+    res = b - Ax (x);
+    norm_b = norm (b);
+    ## Vector of the residual norms for each iteration.
+    resvec = norm (res) / norm_b;
+    ro = 0;
+    ## Default behavior we don't reach tolerance tol within maxit iterations.
+    flag = 1;
+    for iter = 1:maxit
 
-    z = precon (res);
+      z = precon (res);
 
-    ## Cache.
-    ro_old = ro;
-    ro = res' * z;
-    if (iter == 1)
-      p = z;
-    else
-      beta = ro / ro_old;
-      p = z + beta * p;
-    endif
-    ## Cache.
-    q = A * p;
-    alpha = ro / (p' * q);
-    x = x + alpha * p;
+      ## Cache.
+      ro_old = ro;
+      ro = res' * z;
+      if (iter == 1)
+        p = z;
+      else
+        beta = ro / ro_old;
+        p = z + beta * p;
+      endif
+      ## Cache.
+      q = Ax (p);
+      alpha = ro / (p' * q);
+      x = x + alpha * p;
 
-    res = res - alpha * q;
-    relres = norm(res) / norm_b;
-    resvec = [resvec;relres];
+      res = res - alpha * q;
+      relres = norm (res) / norm_b;
+      resvec = [resvec; relres];
 
-    if (relres <= tol)
-      ## We reach tolerance tol within maxit iterations.
-      flag = 0;
-      break;
-    elseif (resvec (end) == resvec (end - 1))
-      ## The method stagnates.
-      flag = 3;
-      break;
-    endif
-  endfor;
+      if (relres <= tol)
+        ## We reach tolerance tol within maxit iterations.
+        flag = 0;
+        break
+      elseif (resvec (end) == resvec (end - 1))
+        ## The method stagnates.
+        flag = 3;
+        break
+      endif
+    endfor
 
-  if (nargout < 1)
-    if ( flag == 0 )
-      printf (["cgs converged at iteration %i ",
-      "to a solution with relative residual %e\n"],iter,relres);
-    elseif (flag == 3)
-      printf (["cgs stopped at iteration %i ",
-      "without converging to the desired tolerance %e\n",
-      "because the method stagnated.\n",
-      "The iterate returned (number %i) has relative residual %e\n"],iter,tol,iter,relres);
-    else
-      printf (["cgs stopped at iteration %i ",
-      "without converging to the desired tolerance %e\n",
-      "because the maximum number of iterations was reached.\n",
-      "The iterate returned (number %i) has relative residual %e\n"],iter,tol,iter,relres);
+    if (nargout < 1)
+      if (flag == 0)
+        printf ("cgs converged at iteration %i to a solution with relative residual %e\n",
+                iter, relres);
+      elseif (flag == 3)
+        printf (["cgs stopped at iteration %i without converging to the desired tolerance %e\n",
+                 "because the method stagnated.\n",
+                 "The iterate returned (number %i) has relative residual %e\n"],
+                iter, tol, iter, relres);
+      else
+        printf (["cgs stopped at iteration %i without converging to the desired tolerance %e\n",
+                 "because the maximum number of iterations was reached.\n",
+                 "The iterate returned (number %i) has relative residual %e\n"],
+                iter, tol, iter, relres);
+      endif
     endif
+
+  else
+    print_usage ();
   endif
 
 endfunction
 
 
 
 %!demo
 %! % Solve system of A*x=b
 %! A=[5 -1 3;-1 2 -2;3 -2 3]
 %! b=[7;-1;4]
 %! [a,b,c,d,e]=cgs(A,b)
+
+%!shared A, b, n, M
+%!
+%!test
+%! n = 100; 
+%! A = spdiags ([-ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
+%! b = sum (A, 2); 
+%! tol = 1e-8; 
+%! maxit = 1000;
+%! M = 4*eye (n);  
+%! [x, flag, relres, iter, resvec] = cgs (A, b, tol, maxit, M);
+%! assert (x, ones (size (b)), 1e-7);
+%!
+%!test
+%! tol = 1e-8; 
+%! maxit = 15;
+%!
+%! [x, flag, relres, iter, resvec] = cgs (@(x) A * x, b, tol, maxit, M);
+%! assert (x, ones (size (b)), 1e-7);
+
+%!test
+%! n = 100; 
+%! tol = 1e-8; 
+%! a = sprand (n, n, .1);
+%! A = a'*a + 100 * eye (n);
+%! b = sum (A, 2); 
+%! [x, flag, relres, iter, resvec] = cgs (A, b, tol, [], diag (diag (A)));
+%! assert (x, ones (size (b)), 1e-7);
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -44,40 +44,33 @@
 ## The preconditioner @var{P} is given as @code{P = M1 * M2}.
 ## Both @var{M1} and @var{M2} can be passed as a matrix, function handle, or
 ## inline function @code{g} such that @code{g(x) = M1\x} or @code{g(x) = M2\x}.
 ##
 ## Besides the vector @var{x}, additional outputs are:
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
-##
 ## @table @asis
-##   @item 0 : iteration converged to within the specified tolerance
-##
-##   @item 1 : maximum number of iterations exceeded
-##
-##   @item 2 : unused, but skipped for compatibility
-##
-##   @item 3 : algorithm reached stagnation
+## @item 0 : iteration converged to within the specified tolerance
+## @item 1 : maximum number of iterations exceeded
+## @item 2 : unused, but skipped for compatibility
+## @item 3 : algorithm reached stagnation
 ## @end table
-##
 ## @item @var{relres} is the final value of the relative residual.
-##
 ## @item @var{iter} is a vector containing the number of outer iterations and
 ## total iterations performed.
-##
 ## @item @var{resvec} is a vector containing the relative residual at each
 ## iteration.
 ## @end itemize
 ##
-## @seealso{pcg, cgs, bicgstab}
+## @seealso{bicg, bicgstab, cgs, pcg}
 ## @end deftypefn
 
-function [x, flag, prec_res_norm, itcnt] = gmres (A, b, restart, rtol, maxit, M1, M2, x0)
+function [x, flag, presn, it] = gmres (A, b, restart, rtol, maxit, M1, M2, x0)
 
   if (nargin < 2 || nargin > 8)
     print_usage ();    
   end
       
   if (ischar (A))
     Ax = str2func (A);
   elseif (ismatrix (A))
@@ -128,69 +121,74 @@ function [x, flag, prec_res_norm, itcnt]
 
   if (nargin < 8 || isempty (x0))
     x0 = zeros (size (b));
   endif
 
   x_old = x0; 
   x = x_old;
   prec_res = Pm1x (b - Ax (x_old));
-  prec_res_norm = norm (prec_res, 2);
+  presn = norm (prec_res, 2);
   
   B = zeros (restart + 1, 1);
   V = zeros (rows (x), restart);
   H = zeros (restart + 1, restart);
 
   ## begin loop
   iter = 1;
   restart_it  = restart + 1; 
   resids      = zeros (maxit, 1);
-  resids(1)   = prec_res_norm;
+  resids(1)   = presn;
   prec_b_norm = norm (Pm1x (b), 2);
   flag        = 1;
 
-  while ((iter <= maxit * restart) && (prec_res_norm > rtol * prec_b_norm))
+  while (iter <= maxit * restart && presn > rtol * prec_b_norm)
   
     ## restart
     if (restart_it > restart)
       restart_it = 1;
       x_old = x;	      
       prec_res = Pm1x (b - Ax (x_old));
-      prec_res_norm = norm (prec_res, 2);
-      B(1) = prec_res_norm;
+      presn = norm (prec_res, 2);
+      B(1) = presn;
       H(:) = 0;
-      V(:, 1) = prec_res / prec_res_norm;
+      V(:, 1) = prec_res / presn;
     endif  
     
     ## basic iteration
     tmp = Pm1x (Ax (V(:, restart_it)));
-    [V(:,restart_it+1), H(1:restart_it+1, restart_it)] = mgorth (tmp, V(:,1:restart_it));
+    [V(:,restart_it+1), H(1:restart_it+1, restart_it)] = ...
+        mgorth (tmp, V(:,1:restart_it));
     
     Y = (H(1:restart_it+1, 1:restart_it) \ B (1:restart_it+1));
 	      
-    little_res = B(1:restart_it+1) - H(1:restart_it+1, 1:restart_it) * Y(1:restart_it);
-    prec_res_norm = norm (little_res, 2);
+    little_res = B(1:restart_it+1) - ...
+        H(1:restart_it+1, 1:restart_it) * Y(1:restart_it);
+
+    presn = norm (little_res, 2);
 	      
     x = x_old + V(:, 1:restart_it) * Y(1:restart_it);
     
-    resids(iter) = prec_res_norm ;
+    resids(iter) = presn;
     if (norm (x - x_old, inf) <= eps)
       flag = 3;
       break
     endif
 
-    restart_it++ ; iter++;
+    restart_it++ ; 
+    iter++;
   endwhile
 
-  if (prec_res_norm > rtol * prec_b_norm)
+  if (presn > rtol * prec_b_norm)
     flag = 0;
   endif
 
   resids = resids(1:iter-1);
-  itcnt = [floor(maxit/restart), rem(maxit, restart)];
+  it = [floor(maxit/restart), rem(maxit, restart)];
+
 endfunction
 
 
 %!shared A, b, dim
 %! dim = 100;
 %!test
 %! A = spdiags ([-ones(dim,1) 2*ones(dim,1) ones(dim,1)], [-1:1], dim, dim);
 %! b = ones(dim, 1); 
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -49,8 +49,36 @@ function [x, y] = gplot (A, xy, line_sty
   if (nargout == 0)
     plot (xcoord, ycoord, line_style);
   else
     x = xcoord;
     y = ycoord;
   endif
 
 endfunction
+
+
+%!demo
+%! ## Binary Tree Representation
+%! A = [0 1 0 0 0 0 0
+%!      1 0 1 1 0 0 0
+%!      0 1 0 0 0 0 0
+%!      0 1 0 0 1 0 0
+%!      0 0 0 1 0 1 1
+%!      0 0 0 0 1 0 0
+%!      0 0 0 0 1 0 0];
+%!
+%! xy = [1, 0
+%!       1.5, 1
+%!       2, 0
+%!       2.5, 2
+%!       3.5, 1
+%!       3, 0
+%!       4, 0];
+%!
+%! clf;
+%! gplot (A, xy, "o-");
+%! set (get (gca, ("children")), "markersize", 12);
+%! title ("gplot() of Binary Tree Adjacency matrix");
+
+%% Mark graphical function as tested by demo block
+%!assert (1);
+
diff --git a/scripts/sparse/module.mk b/scripts/sparse/module.mk
--- a/scripts/sparse/module.mk
+++ b/scripts/sparse/module.mk
@@ -1,11 +1,12 @@
 FCN_FILE_DIRS += sparse
 
 sparse_FCN_FILES = \
+  sparse/bicg.m \
   sparse/bicgstab.m \
   sparse/cgs.m \
   sparse/colperm.m \
   sparse/etreeplot.m \
   sparse/gmres.m \
   sparse/gplot.m \
   sparse/nonzeros.m \
   sparse/pcg.m \
diff --git a/scripts/sparse/spconvert.m b/scripts/sparse/spconvert.m
--- a/scripts/sparse/spconvert.m
+++ b/scripts/sparse/spconvert.m
@@ -38,8 +38,30 @@ function s = spconvert (m)
     elseif (sz(2) == 3)
       s = sparse (m(:,1), m(:,2), m(:,3));
     else
       s = sparse (m(:,1), m(:,2), m(:,3) + 1i*m(:,4));
     endif
   endif
 
 endfunction
+
+
+%!test
+%! i = [1; 3; 5];
+%! j = [2; 4; 6];
+%! v = [7; 8; 9];
+%! s = spconvert ([i, j, v]); 
+%! assert (issparse (s));
+%! [fi, fj, fv] = find (s);
+%! assert (isequal (i, fi) && isequal (j, fj) && isequal (v, fv));
+%! s = spconvert ([i, j, v, j]);
+%! [fi, fj, fv] = find (s);
+%! assert (isequal (i, fi) && isequal (j, fj) && isequal (complex (v, j), fv));
+%! assert (size (spconvert ([1, 1, 3; 5, 15, 0])), [5, 15]);
+
+%% Test input validation
+%!error spconvert ()
+%!error spconvert (1, 2)
+%!error spconvert ({[1 2 3]})
+%!error spconvert ([1 2])
+%!error spconvert ([1 2 3i])
+%!error spconvert ([1 2 3 4 5])
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -47,19 +47,19 @@
 
 function S = sprand (m, n, d)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
   if (nargin == 1)
-    [i, j, v] = find (m);
+    [i, j] = find (m);
     [nr, nc] = size (m);
-    S = sparse (i, j, rand (size (v)), nr, nc);
+    S = sparse (i, j, rand (size (i)), nr, nc);
     return;
   endif
 
   if (!(isscalar (m) && m == fix (m) && m > 0))
     error ("sprand: M must be an integer greater than 0");
   endif
 
   if (!(isscalar (n) && n == fix (n) && n > 0))
@@ -87,8 +87,35 @@ function S = sprand (m, n, d)
   if (isempty (i))
     S = sparse (m, n);
   else
     S = sparse (i, j+1, rand (k, 1), m, n);
   endif
 
 endfunction
 
+## FIXME: Test for density can't happen until code of sprand is improved
+%!test
+%! s = sprand (4, 10, 0.1);
+%! assert (size (s), [4, 10]);
+##%! assert (nnz (s) / numel (s), 0.1, .01);
+
+%% Test 1-input calling form
+%!test
+%! s = sprand (sparse ([1 2 3], [3 2 3], [2 2 2]));
+%! [i, j, v] = find (s);
+%! assert (sort (i), [1 2 3]');
+%! assert (sort (j), [2 3 3]');
+%! assert (all (v > 0 & v < 1));
+
+%% Test input validation
+%!error sprand ()
+%!error sprand (1, 2)
+%!error sprand (1, 2, 3, 4)
+%!error sprand (ones(3), 3, 0.5)
+%!error sprand (3.5, 3, 0.5)
+%!error sprand (0, 3, 0.5)
+%!error sprand (3, ones(3), 0.5)
+%!error sprand (3, 3.5, 0.5)
+%!error sprand (3, 0, 0.5)
+%!error sprand (3, 3, -1)
+%!error sprand (3, 3, 2)
+
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -33,35 +33,80 @@
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero.
 ## @seealso{sprand}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 function S = sprandn (m, n, d)
-  if (nargin == 1)
-    [i, j, v] = find (m);
-    [nr, nc] = size (m);
-    S = sparse (i, j, randn (size (v)), nr, nc);
-  elseif (nargin == 3)
-    mn = m*n;
-    k = round (d*mn);
-    idx = unique (fix (rand (min (k*1.01, k+10), 1) * mn)) + 1;
-    ## idx contains random numbers in [1,mn]
-    ## generate 1% or 10 more random values than necessary in order to
-    ## reduce the probability that there are less than k distinct
-    ## values; maybe a better strategy could be used but I don't think
-    ## it's worth the price.
 
-    ## actual number of entries in S
-    k = min (length (idx), k);
-    j = floor ((idx(1:k)-1)/m);
-    i = idx(1:k) - j*m;
-    if (isempty (i))
-      S = sparse (m, n);
-    else
-      S = sparse (i, j+1, randn (k, 1), m, n);
-    endif
-  else
+  if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
+
+  if (nargin == 1)
+    [i, j] = find (m);
+    [nr, nc] = size (m);
+    S = sparse (i, j, randn (size (i)), nr, nc);
+    return;
+  endif
+
+  if (!(isscalar (m) && m == fix (m) && m > 0))
+    error ("sprand: M must be an integer greater than 0");
+  endif
+
+  if (!(isscalar (n) && n == fix (n) && n > 0))
+    error ("sprand: N must be an integer greater than 0");
+  endif
+
+  if (d < 0 || d > 1)
+    error ("sprand: density D must be between 0 and 1");
+  endif
+
+  mn = m*n;
+  k = round (d*mn);
+  idx = unique (fix (rand (min (k*1.01, k+10), 1) * mn)) + 1;
+  ## idx contains random numbers in [1,mn]
+  ## generate 1% or 10 more random values than necessary in order to
+  ## reduce the probability that there are less than k distinct
+  ## values; maybe a better strategy could be used but I don't think
+  ## it's worth the price.
+
+  ## actual number of entries in S
+  k = min (length (idx), k);
+  j = floor ((idx(1:k)-1)/m);
+  i = idx(1:k) - j*m;
+  if (isempty (i))
+    S = sparse (m, n);
+  else
+    S = sparse (i, j+1, randn (k, 1), m, n);
+  endif
+
 endfunction
+
+
+## FIXME: Test for density can't happen until code of sprandn is improved
+%!test
+%! s = sprandn (4, 10, 0.1);
+%! assert (size (s), [4, 10]);
+##%! assert (nnz (s) / numel (s), 0.1, .01);
+
+%% Test 1-input calling form
+%!test
+%! s = sprandn (sparse ([1 2 3], [3 2 3], [2 2 2]));
+%! [i, j] = find (s);
+%! assert (sort (i), [1 2 3]');
+%! assert (sort (j), [2 3 3]');
+
+%% Test input validation
+%!error sprandn ()
+%!error sprandn (1, 2)
+%!error sprandn (1, 2, 3, 4)
+%!error sprandn (ones(3), 3, 0.5)
+%!error sprandn (3.5, 3, 0.5)
+%!error sprandn (0, 3, 0.5)
+%!error sprandn (3, ones(3), 0.5)
+%!error sprandn (3, 3.5, 0.5)
+%!error sprandn (3, 0, 0.5)
+%!error sprandn (3, 3, -1)
+%!error sprandn (3, 3, 2)
+
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -29,49 +29,88 @@
 ##
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero in its lower
 ## triangular part.
 ## @seealso{sprand, sprandn}
 ## @end deftypefn
 
 function S = sprandsym (n, d)
-  if (nargin == 1)
-    [i, j, v] = find (tril (n));
-    [nr, nc] = size (n);
-    S = sparse (i, j, randn (size (v)), nr, nc);
-    S = S + tril (S, -1)';
-  elseif (nargin == 2)
-    m1 = floor (n/2);
-    n1 = m1 + rem (n, 2);
-    mn1 = m1*n1;
-    k1 = round (d*mn1);
-    idx1 = unique (fix (rand (min (k1*1.01, k1+10), 1) * mn1)) + 1;
-    ## idx contains random numbers in [1,mn] generate 1% or 10 more
-    ## random values than necessary in order to reduce the probability
-    ## that there are less than k distinct values; maybe a better
-    ## strategy could be used but I don't think it's worth the price.
 
-    ## Actual number of entries in S.
-    k1 = min (length (idx1), k1);
-    j1 = floor ((idx1(1:k1)-1)/m1);
-    i1 = idx1(1:k1) - j1*m1;
-
-    n2 = ceil (n/2);
-    nn2 = n2*n2;
-    k2 = round (d*nn2);
-    idx2 = unique (fix (rand (min (k2*1.01, k1+10), 1) * nn2)) + 1;
-    k2 = min (length (idx2), k2);
-    j2 = floor ((idx2(1:k2)-1)/n2);
-    i2 = idx2(1:k2) - j2*n2;
-
-    if (isempty (i1) && isempty (i2))
-      S = sparse (n, n);
-    else
-      S1 = sparse (i1, j1+1, randn (k1, 1), m1, n1);
-      S = [tril(S1), sparse(m1,m1); ...
-           sparse(i2,j2+1,randn(k2,1),n2,n2), triu(S1,1)'];
-      S = S + tril (S, -1)';
-    endif
-  else
+  if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
+
+  if (nargin == 1)
+    [i, j] = find (tril (n));
+    [nr, nc] = size (n);
+    S = sparse (i, j, randn (size (i)), nr, nc);
+    S = S + tril (S, -1)';
+    return;
+  endif
+
+  if (!(isscalar (n) && n == fix (n) && n > 0))
+    error ("sprand: N must be an integer greater than 0");
+  endif
+
+  if (d < 0 || d > 1)
+    error ("sprand: density D must be between 0 and 1");
+  endif
+
+  m1 = floor (n/2);
+  n1 = m1 + rem (n, 2);
+  mn1 = m1*n1;
+  k1 = round (d*mn1);
+  idx1 = unique (fix (rand (min (k1*1.01, k1+10), 1) * mn1)) + 1;
+  ## idx contains random numbers in [1,mn] generate 1% or 10 more
+  ## random values than necessary in order to reduce the probability
+  ## that there are less than k distinct values; maybe a better
+  ## strategy could be used but I don't think it's worth the price.
+
+  ## Actual number of entries in S.
+  k1 = min (length (idx1), k1);
+  j1 = floor ((idx1(1:k1)-1)/m1);
+  i1 = idx1(1:k1) - j1*m1;
+
+  n2 = ceil (n/2);
+  nn2 = n2*n2;
+  k2 = round (d*nn2);
+  idx2 = unique (fix (rand (min (k2*1.01, k1+10), 1) * nn2)) + 1;
+  k2 = min (length (idx2), k2);
+  j2 = floor ((idx2(1:k2)-1)/n2);
+  i2 = idx2(1:k2) - j2*n2;
+
+  if (isempty (i1) && isempty (i2))
+    S = sparse (n, n);
+  else
+    S1 = sparse (i1, j1+1, randn (k1, 1), m1, n1);
+    S = [tril(S1), sparse(m1,m1); ...
+         sparse(i2,j2+1,randn(k2,1),n2,n2), triu(S1,1)'];
+    S = S + tril (S, -1)';
+  endif
+
 endfunction
+
+
+## FIXME: Test for density can't happen until code of sprandsym is improved
+%!test
+%! s = sprandsym (10, 0.1);
+%! assert (issparse (s));
+%! assert (issymmetric (s));
+%! assert (size (s), [10, 10]);
+##%! assert (nnz (s) / numel (s), 0.1, .01);
+
+%% Test 1-input calling form
+%!test
+%! s = sprandsym (sparse ([1 2 3], [3 2 3], [2 2 2]));
+%! [i, j] = find (s);
+%! assert (sort (i), [2 3]');
+%! assert (sort (j), [2 3]');
+
+%% Test input validation
+%!error sprandsym ()
+%!error sprandsym (1, 2, 3)
+%!error sprandsym (ones(3), 0.5)
+%!error sprandsym (3.5, 0.5)
+%!error sprandsym (0, 0.5)
+%!error sprandsym (3, -1)
+%!error sprandsym (3, 2)
+
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -56,8 +56,16 @@ function spy (x, varargin)
     plot (j, i, line_spec);
   else
     plot (j, i, line_spec, "markersize", markersize);
   endif
 
   axis ([0, n+1, 0, m+1], "ij");
 
 endfunction
+
+
+%!demo
+%! clf;
+%! spy (sprand (10,10, 0.2));
+
+%% Mark graphical function as tested by demo block
+%!assert (1);
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -197,15 +197,31 @@ function [x_coordinate, y_coordinate, he
     ## Calculate the x coordinates (the known values are the position
     ## of most left and most right descendants).
     x_coordinate = (x_coordinate_l + x_coordinate_r) / 2;
 
     height = num_nodes - max_ht - 1;
   endif
 endfunction
 
-%!demo
+%!test
 %! % Compute a simple tree layout
-%! [x,y,h,s]=treelayout([0 1 2 2])
+%! [x, y, h, s] = treelayout ([0, 1, 2, 2]);
+%! assert (x, [1.5, 1.5, 2, 1]);
+%! assert (y, [3, 2, 1, 1]);
+%! assert (h, 2);
+%! assert (s, 2);
 
-%!demo
+%!test
 %! % Compute a simple tree layout with defined postorder permutation
-%! [x,y,h,s]=treelayout([0 1 2 2],[1 2 3 4])
+%! [x, y, h, s] = treelayout ([0, 1, 2, 2], [1, 2, 4, 3]);
+%! assert (x, [1.5, 1.5, 1, 2]);
+%! assert (y, [3, 2, 1, 1]);
+%! assert (h, 2);
+%! assert (s, 2);
+
+%!test
+%! % Compute a simple tree layout with defined postorder permutation
+%! [x, y, h, s] = treelayout ([0, 1, 2, 2], [4, 2, 3, 1]);
+%! assert (x, [0, 0, 0, 1]);
+%! assert (y, [0, 0, 0, 3]);
+%! assert (h, 0);
+%! assert (s, 1);
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -136,8 +136,11 @@ function demo (name, n)
 
 endfunction
 
 %!demo
 %! t=0:0.01:2*pi; x = sin(t);
 %! plot (t,x)
 %! %-------------------------------------------------
 %! % the figure window shows one cycle of a sine wave
+
+%!error demo ();
+%!error demo (1, 2, 3);
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -124,20 +124,21 @@ function ret = fail (code, pattern, warn
     end_try_catch
   endif
 
   ## If we get here, then code didn't fail or error didn't match.
   error (msg);
 
 endfunction
 
-%!fail ('[1,2]*[2,3]','nonconformant')
-%!fail ("fail('[1,2]*[2;3]','nonconformant')","expected error <nonconformant> but got none")
-%!fail ("fail('[1,2]*[2,3]','usage:')","expected error <usage:>\nbut got.*nonconformant")
-%!fail ("warning('test warning')",'warning','test warning');
+
+%!fail ('[1,2]*[2,3]', 'nonconformant')
+%!fail ("fail('[1,2]*[2;3]', 'nonconformant')", "expected error <nonconformant> but got none")
+%!fail ("fail('[1,2]*[2,3]','usage:')", "expected error <usage:>\nbut got.*nonconformant")
+%!fail ("warning('test warning')", 'warning','test warning');
 
-%!# fail ("warning('next test')",'warning','next test');  ## only allowed one warning test?!?
+##% !fail ("warning('next test')",'warning','next test');  ## only allowed one warning test?!?
 
-## Comment out the following tests if you don't want to see what
-## errors look like
-% !fail ('a*[2;3]', 'nonconformant')
-% !fail ('a*[2,3]', 'usage:')
-% !fail ("warning('warning failure')", 'warning', 'success')
+%% Test that fail() itself will generate an error
+%!error fail ("1");
+%!error <undefined> fail ('a*[2;3]', 'nonconformant')
+%!error <expected error>  fail ('a*[2,3]', 'usage:')
+%!error <warning failure> fail ("warning('warning failure')", 'warning', 'success')
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -76,8 +76,10 @@ function retval = has_demos (f)
   if (f < 0)
     error ("rundemos: fopen failed: %s", f);
   else
     str = fscanf (fid, "%s");
     fclose (fid);
     retval = findstr (str, "%!demo");
   endif
 endfunction
+
+%!error rundemos ("foo", 1);
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -20,17 +20,18 @@
 ## @deftypefn  {Function File} {} speed (@var{f}, @var{init}, @var{max_n}, @var{f2}, @var{tol})
 ## @deftypefnx {Function File} {[@var{order}, @var{n}, @var{T_f}, @var{T_f2}] =} speed (@dots{})
 ##
 ## Determine the execution time of an expression (@var{f}) for various input
 ## values (@var{n}).  The @var{n} are log-spaced from 1 to @var{max_n}.  For
 ## each @var{n}, an initialization expression (@var{init}) is computed to
 ## create any data needed for the test.  If a second expression (@var{f2}) is
 ## given then the execution times of the two expressions are compared.  When
-## called without output arguments the results are displayed graphically.
+## called without output arguments the results are printed to stdout and
+## displayed graphically.
 ##
 ## @table @code
 ## @item @var{f}
 ## The expression to evaluate.
 ##
 ## @item @var{max_n}
 ## The maximum test length to run.  Default value is 100.  Alternatively,
 ## use @code{[min_n, max_n]} or specify the @var{n} exactly with
@@ -110,32 +111,32 @@
 ## of the line on the speedup ratio graph should be larger than 1 if the new
 ## expression is faster.  Better algorithms have a shallow slope.  Generally,
 ## vectorizing an algorithm will not change the slope of the execution
 ## time graph, but will shift it relative to the original.  For
 ## example:
 ##
 ## @example
 ## @group
-## speed ("v = sum (x)", "", [10000, 100000], ...
+## speed ("sum (x)", "", [10000, 100000], ...
 ##        "v = 0; for i = 1:length (x), v += x(i); end")
 ## @end group
 ## @end example
 ##
 ## The following is a more complex example.  If there was an original version
 ## of @code{xcorr} using for loops and a second version using an FFT, then
 ## one could compare the run speed for various lags as follows, or for a fixed
 ## lag with varying vector lengths as follows:
 ##
 ## @example
 ## @group
-## speed ("v = xcorr (x, n)", "x = rand (128, 1);", 100,
-##        "v2 = xcorr_orig (x, n)", -100*eps)
-## speed ("v = xcorr (x, 15)", "x = rand (20+n, 1);", 100,
-##        "v2 = xcorr_orig (x, n)", -100*eps)
+## speed ("xcorr (x, n)", "x = rand (128, 1);", 100,
+##        "xcorr_orig (x, n)", -100*eps)
+## speed ("xcorr (x, 15)", "x = rand (20+n, 1);", 100,
+##        "xcorr_orig (x, n)", -100*eps)
 ## @end group
 ## @end example
 ##
 ## Assuming one of the two versions is in xcorr_orig, this
 ## would compare their speed and their output values.  Note that the
 ## FFT version is not exact, so we specify an acceptable tolerance on
 ## the comparison @code{100*eps}, and that the errors should be computed
 ## relatively, as @code{abs ((@var{x} - @var{y}) ./ @var{y})} rather than
@@ -186,35 +187,42 @@ function [__order, __test_n, __tnew, __t
     __test_n = __max_n;
   endif
   ## Force n to be an integer.
   __test_n = unique (round (__test_n));
   assert (__test_n >= 1);
 
   __torig = __tnew = zeros (size (__test_n));
 
-  disp (cstrcat ("testing ", __f1, "\ninit: ", __init));
+  ## Print and plot the data if no output is requested.
+  do_display = (nargout == 0);
+
+  if (do_display)
+    disp (cstrcat ("testing ", __f1, "\ninit: ", __init));
+  endif
 
   ## Make sure the functions are freshly loaded by evaluating them at
   ## test_n(1); first have to initialize the args though.
   n = 1;
   k = 0;
   eval (cstrcat (__init, ";"));
   if (! isempty (__f2))
     eval (cstrcat (__f2, ";"));
   endif
   eval (cstrcat (__f1, ";"));
 
   ## Run the tests.
   for k = 1:length (__test_n)
     n = __test_n(k);
     eval (cstrcat (__init, ";"));
 
-    printf ("n%i = %i  ",k, n);
-    fflush (stdout);
+    if (do_display)
+      printf ("n%i = %i  ",k, n);
+      fflush (stdout);
+    endif
     eval (cstrcat ("__t = time();", __f1, "; __v1=ans; __t = time()-__t;"));
     if (__t < 0.25)
       eval (cstrcat ("__t2 = time();", __f1, "; __t2 = time()-__t2;"));
       eval (cstrcat ("__t3 = time();", __f1, "; __t3 = time()-__t3;"));
       __t = min ([__t, __t2, __t3]);
     endif
     __tnew(k) = __t;
 
@@ -246,24 +254,22 @@ function [__order, __test_n, __tnew, __t
   ## Approximate time complexity and return it if requested.
   tailidx = ceil(length(__test_n)/2):length(__test_n);
   p = polyfit (log (__test_n(tailidx)), log (__tnew(tailidx)), 1);
   if (nargout > 0)
     __order.p = p(1);
     __order.a = exp (p(2));
   endif
 
-  ## Plot the data if no output is requested.
-  doplot = (nargout == 0);
-
-  if (doplot)
+  if (do_display)
     figure;
   endif
 
-  if (doplot && ! isempty (__f2))
+  if (do_display && ! isempty (__f2))
+
     subplot (1, 2, 1);
     semilogx (__test_n, __torig./__tnew,
               cstrcat ("-*r;", strrep (__f1, ";", "."), "/",
                       strrep (__f2, ";", "."), ";"),
                __test_n, __tnew./__torig,
               cstrcat ("-*g;", strrep (__f2, ";", "."), "/",
                       strrep (__f1, ";", "."), ";"));
     xlabel ("test length");
@@ -279,26 +285,26 @@ function [__order, __test_n, __tnew, __t
     xlabel ("test length");
     ylabel ("best execution time (ms)");
     title (cstrcat ("init: ", __init));
 
     ratio = mean (__torig ./ __tnew);
     printf ("\n\nMean runtime ratio = %.3g for '%s' vs '%s'\n",
             ratio, __f2, __f1);
 
-  elseif (doplot)
+  elseif (do_display)
 
     loglog (__test_n, __tnew*1000, "*-g;execution time;");
     xlabel ("test length");
     ylabel ("best execution time (ms)");
     title (cstrcat (__f1, "  init: ", __init));
 
   endif
 
-  if (doplot)
+  if (do_display)
 
     ## Plot time complexity approximation (using milliseconds).
     order = sprintf ("O(n^%g)", round (10*p(1))/10);
     v = polyval (p, log (__test_n(tailidx)));
 
     loglog (__test_n(tailidx), exp(v)*1000, sprintf ("b;%s;", order));
 
     ## Get base time to 1 digit of accuracy.
@@ -309,20 +315,22 @@ function [__order, __test_n, __tnew, __t
     elseif (log10 (dt) >= -3.5)
       time = sprintf ("%g ms", dt*1e3);
     elseif (log10 (dt) >= -6.5)
       time = sprintf ("%g us", dt*1e6);
     else
       time = sprintf ("%g ns", dt*1e9);
     endif
 
-    ## Display nicely formatted complexity.
-    printf ("\nFor %s:\n", __f1);
-    printf ("  asymptotic power: %s\n", order);
-    printf ("  approximate time per operation: %s\n", time);
+    if (do_display)
+      ## Display nicely formatted complexity.
+      printf ("\nFor %s:\n", __f1);
+      printf ("  asymptotic power: %s\n", order);
+      printf ("  approximate time per operation: %s\n", time);
+    endif
 
   endif
 
 endfunction
 
 %!demo if 1
 %!  function x = build_orig(n)
 %!    ## extend the target vector on the fly
@@ -373,8 +381,35 @@ endfunction
 %!
 %!  disp("Vectorized test.\nThis takes a little while...");
 %!  speed('build(n)', '', 1000, 'build_orig(n)');
 %!  clear build build_orig
 %!  disp("-----------------------");
 %!  disp("This time, the for loop is done away with entirely.");
 %!  disp("Notice how much bigger the speedup is than in example 1.");
 %! endif
+
+%!error speed ();
+%!error speed (1, 2, 3, 4, 5, 6, 7);
+
+%!test
+%! [order, n, T_f1, T_f2] = speed ("airy (x)", "x = rand (n, 10)", [100, 1000]);
+%! assert (isstruct (order));
+%! assert (size (order), [1, 1]);
+%! assert (fieldnames (order), {"p"; "a"});
+%! assert (isnumeric (n));
+%! assert (size (n), [1, 15]);
+%! assert (isnumeric (T_f1));
+%! assert (size (T_f1), [1, 15]);
+%! assert (isnumeric (T_f1));
+%! assert (size (T_f2), [1, 15]);
+
+%!test
+%! [order, n, T_f1, T_f2] = speed ("sum (x)", "", [100, 1000], "v = 0; for i = 1:length (x), v += x(i); end");
+%! assert (isstruct (order));
+%! assert (size (order), [1, 1]);
+%! assert (fieldnames (order), {"p"; "a"});
+%! assert (isnumeric (n));
+%! assert (size (n), [1, 15]);
+%! assert (isnumeric (T_f1));
+%! assert (size (T_f1), [1, 15]);
+%! assert (isnumeric (T_f1));
+%! assert (size (T_f2), [1, 15]);
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -62,16 +62,19 @@ endfunction
 %! plot(yr,pr);
 %! xlabel('year')
 %! ylabel('average price')
 %! ax=gca;
 %! set(ax,'xtick',datenum(1990:5:2005,1,1))
 %! datetick(2,'keepticks')
 %! set(ax,'ytick',12:16)
 
+## Remove from test statistics.  No real tests possible.
+%!assert (1)
+
 function __datetick__ (varargin)
 
   keeplimits = false;
   keepticks = false;
   idx = [];
   for i = 1 : nargin
     arg = varargin {i};
     if (ischar (arg))
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -665,18 +665,17 @@ encode_uint_image (std::vector<Magick::I
 
   bool is_color = ((dsizes.length () > 2) && (dsizes(2) > 2));
   bool has_alpha = (dsizes.length () > 2 && (dsizes(2) == 2 || dsizes(2) == 4));
 
   Array<octave_idx_type> idx (dim_vector (dsizes.length (), 1));
   octave_idx_type rows = m.rows ();
   octave_idx_type columns = m.columns ();
 
-  // FIXME -- maybe simply using bit shifting would be better?
-  unsigned int div_factor = pow (2.0, static_cast<int> (bitdepth)) - 1;
+  unsigned int div_factor = (1 << bitdepth) - 1;
 
   for (unsigned int ii = 0; ii < nframes; ii++)
     {
       Magick::Image im (Magick::Geometry (columns, rows), "black");
 
       im.depth (bitdepth);
 
       if (has_map)
@@ -755,17 +754,17 @@ encode_uint_image (std::vector<Magick::I
 
                   c.shade (static_cast<double>(m(idx)) / div_factor);
 
                   im.pixelColor (y, x, c);
                 }
             }
 
           im.quantizeColorSpace (Magick::GRAYColorspace);
-          im.quantizeColors (pow (2, bitdepth));
+          im.quantizeColors (1 << bitdepth);
           im.quantize ();
         }
 
       imvec.push_back (im);
     }
 }
 
 static void
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -764,9 +764,50 @@ dimensionality as the other array.\n\
 %!assert (bsxfun (@lt, a, b), aa < bb);
 %!assert (bsxfun (@le, a, b), aa <= bb);
 %!assert (bsxfun (@gt, a, b), aa > bb);
 %!assert (bsxfun (@ge, a, b), aa >= bb);
 %!assert (bsxfun (@min, a, b), min (aa, bb));
 %!assert (bsxfun (@max, a, b), max (aa, bb));
 %!assert (bsxfun (@and, a > 0, b > 0), (aa > 0) & (bb > 0));
 %!assert (bsxfun (@or, a > 0, b > 0), (aa > 0) | (bb > 0));
+
+%% Test automatic bsxfun
+%
+%!test
+%! funs = {@plus, @minus, @times, @rdivide, @ldivide, @power, @max, @min, \
+%!         @rem, @mod, @atan2, @hypot, @eq, @ne, @lt, @le, @gt, @ge, \
+%!         @and, @or, @xor };
+%!
+%! float_types = {@single, @double};
+%! int_types = {@int8, @int16, @int32, @int64, \
+%!             @uint8, @uint16, @uint32, @uint64};
+%!
+%! x = rand (3)*10-5;
+%! y = rand (3,1)*10-5;
+%!
+%! for i=1:length (funs)
+%!   for j = 1:length(float_types)
+%!     for k = 1:length(int_types)
+%!
+%!       fun = funs{i};
+%!       f_type = float_types{j};
+%!       i_type = int_types{k};
+%!
+%!         assert (bsxfun (fun, f_type (x), i_type (y)), \
+%!                 fun (f_type(x), i_type (y)));
+%!         assert (bsxfun (fun, f_type (y), i_type (x)), \
+%!                 fun (f_type(y), i_type (x)));
+%!
+%!         assert (bsxfun (fun, i_type (x), i_type (y)), \
+%!                 fun (i_type (x), i_type (y)));
+%!         assert (bsxfun (fun, i_type (y), i_type (x)), \
+%!                 fun (i_type (y), i_type (x)));
+%!
+%!         assert (bsxfun (fun, f_type (x), f_type (y)), \
+%!                 fun (f_type (x), f_type (y)));
+%!         assert (bsxfun (fun, f_type(y), f_type(x)), \
+%!                 fun (f_type (y), f_type (x)));
+%!     endfor
+%!   endfor
+%! endfor
+%!
 */
diff --git a/src/DLD-FUNCTIONS/config-module.awk b/src/DLD-FUNCTIONS/config-module.awk
--- a/src/DLD-FUNCTIONS/config-module.awk
+++ b/src/DLD-FUNCTIONS/config-module.awk
@@ -1,58 +1,76 @@
 BEGIN {
+  FS = "|";
+  nfiles = 0;
+
   print "## DO NOT EDIT -- generated from module-files by config-module.awk";
   print ""
   print "EXTRA_DIST += \\"
   print "  DLD-FUNCTIONS/config-module.sh \\"
   print "  DLD-FUNCTIONS/config-module.awk \\"
   print "  DLD-FUNCTIONS/module-files"
   print ""
-  nfiles = 0;
-} {
-  files[++nfiles] = $1;
+}
+/^#.*/ { next; }
+{
+  nfiles++;
+  files[nfiles] = $1;
+  cppflags[nfiles] = $2;
+  ldflags[nfiles] = $3;
+  libraries[nfiles] = $4;
 } END {
   sep = " \\\n";
   print "DLD_FUNCTIONS_SRC = \\";
   for (i = 1; i <= nfiles; i++) {
     if (i == nfiles)
       sep = "\n";
     printf ("  DLD-FUNCTIONS/%s%s", files[i], sep);
   }
   print "";
 
   sep = " \\\n";
   print "DLD_FUNCTIONS_LIBS = $(DLD_FUNCTIONS_SRC:.cc=.la)";
   print "";
-  print "octlib_LTLIBRARIES += $(DLD_FUNCTIONS_LIBS)";
+  print "if AMCOND_ENABLE_DYNAMIC_LINKING";
   print "";
-  print "if AMCOND_ENABLE_DYNAMIC_LINKING";
+  print "octlib_LTLIBRARIES += $(DLD_FUNCTIONS_LIBS)";
   print "";
   print "## Use stamp files to avoid problems with checking timestamps";
   print "## of symbolic links";
   print "";
   for (i = 1; i <= nfiles; i++) {
     basename = files[i];
     sub (/\.cc$/, "", basename);
     printf ("DLD-FUNCTIONS/$(am__leading_dot)%s.oct-stamp: DLD-FUNCTIONS/%s.la\n", basename, basename);
     print "\trm -f $(<:.la=.oct)";
     print "\tla=$(<F) && \\";
     print "\t  of=$(<F:.la=.oct) && \\";
     print "\t  cd DLD-FUNCTIONS && \\";
     print "\t  $(LN_S) .libs/`$(SED) -n -e \"s/dlname='\\([^']*\\)'/\\1/p\" < $$la` $$of && \\";
     print "\t  touch $(@F)";
     print "";
   }
+  print "else";
+  print "";
+  print "noinst_LTLIBRARIES = $(DLD_FUNCTIONS_LIBS)";
+  print "";
   print "endif";
-  print "";
 
   for (i = 1; i <= nfiles; i++) {
     basename = files[i];
     sub (/\.cc$/, "", basename);
+    print "";
     printf ("DLD_FUNCTIONS_%s_la_SOURCES = DLD-FUNCTIONS/%s\n",
 	    basename, files[i]);
-    printf ("DLD_FUNCTIONS_%s_la_LDFLAGS = @NO_UNDEFINED_LDFLAG@ -module\n",
-	    basename);
-    printf ("DLD_FUNCTIONS_%s_la_LIBADD = $(OCT_LINK_DEPS)\n", basename);
+    if (cppflags[i])
+      {
+        printf ("DLD-FUNCTIONS/%s.df: CPPFLAGS += %s\n",
+                basename, cppflags[i]);
+        printf ("DLD_FUNCTIONS_%s_la_CPPFLAGS = $(AM_CPPFLAGS) %s\n",
+                basename, cppflags[i]);
+      }
+    printf ("DLD_FUNCTIONS_%s_la_LDFLAGS = -avoid-version -module $(NO_UNDEFINED_LDFLAG) %s $(OCT_LINK_OPTS)\n",
+            basename, ldflags[i]);
+    printf ("DLD_FUNCTIONS_%s_la_LIBADD = liboctinterp.la ../liboctave/liboctave.la ../libcruft/libcruft.la %s $(OCT_LINK_DEPS)\n",
+            basename, libraries[i]);
   }
-  print "";
-
 }
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -105,17 +105,17 @@ Given the string argument 'vector', @cod
     error ("luinc: incorrect number of arguments");
   else
     {
       bool zero_level = false;
       bool milu = false;
       bool udiag = false;
       Matrix thresh;
       double droptol = -1.;
-      bool vecout;
+      bool vecout = false;
 
       if (args(1).is_string ())
         {
           if (args(1).string_value () == "0")
             zero_level = true;
           else
             error ("luinc: unrecognized string argument");
         }
@@ -231,17 +231,17 @@ Given the string argument 'vector', @cod
                         SparseLU fact (sm, Qinit, thresh, false, true, droptol,
                                        milu, udiag);
 
                         if (! error_state)
                           {
                             if (vecout)
                               retval(2) = fact.Pr_vec ();
                             else
-                              retval(2) = fact.Pr ();
+                              retval(2) = fact.Pr_mat ();
                             retval(1) = octave_value (fact.U (),
                                                       MatrixType (MatrixType::Upper));
                             retval(0) = octave_value (fact.L (),
                                                       MatrixType (MatrixType::Lower));
                           }
                       }
                       break;
 
@@ -255,18 +255,18 @@ Given the string argument 'vector', @cod
                           {
                             if (vecout)
                               {
                                 retval(3) = fact.Pc_vec ();
                                 retval(2) = fact.Pr_vec ();
                               }
                             else
                               {
-                                retval(3) = fact.Pc ();
-                                retval(2) = fact.Pr ();
+                                retval(3) = fact.Pc_mat ();
+                                retval(2) = fact.Pr_mat ();
                               }
                             retval(1) = octave_value (fact.U (),
                                                       MatrixType (MatrixType::Upper));
                             retval(0) = octave_value (fact.L (),
                                                       MatrixType (MatrixType::Lower));
                           }
                       }
                       break;
@@ -314,17 +314,17 @@ Given the string argument 'vector', @cod
                         SparseComplexLU fact (sm, Qinit, thresh, false, true,
                                               droptol, milu, udiag);
 
                         if (! error_state)
                           {
                             if (vecout)
                               retval(2) = fact.Pr_vec ();
                             else
-                              retval(2) = fact.Pr ();
+                              retval(2) = fact.Pr_mat ();
                             retval(1) = octave_value (fact.U (),
                                                       MatrixType (MatrixType::Upper));
                             retval(0) = octave_value (fact.L (),
                                                       MatrixType (MatrixType::Lower));
                           }
                       }
                       break;
 
@@ -338,18 +338,18 @@ Given the string argument 'vector', @cod
                           {
                             if (vecout)
                               {
                                 retval(3) = fact.Pc_vec ();
                                 retval(2) = fact.Pr_vec ();
                               }
                             else
                               {
-                                retval(3) = fact.Pc ();
-                                retval(2) = fact.Pr ();
+                                retval(3) = fact.Pc_mat ();
+                                retval(2) = fact.Pr_mat ();
                               }
                             retval(1) = octave_value (fact.U (),
                                                       MatrixType (MatrixType::Upper));
                             retval(0) = octave_value (fact.L (),
                                                       MatrixType (MatrixType::Lower));
                           }
                       }
                       break;
diff --git a/src/DLD-FUNCTIONS/module-files b/src/DLD-FUNCTIONS/module-files
--- a/src/DLD-FUNCTIONS/module-files
+++ b/src/DLD-FUNCTIONS/module-files
@@ -1,45 +1,46 @@
+# FILE|CPPFLAGS|LDFLAGS|LIBRARIES
 __contourc__.cc
-__delaunayn__.cc
+__delaunayn__.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
 __dispatch__.cc
 __dsearchn__.cc
-__fltk_uigetfile__.cc
-__glpk__.cc
-__init_fltk__.cc
+__fltk_uigetfile__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS)
+__glpk__.cc|$(GLPK_CPPFLAGS)|$(GLPK_LDFLAGS)|$(GLPK_LIBS)
+__init_fltk__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS)
 __lin_interpn__.cc
-__magick_read__.cc
+__magick_read__.cc|$(MAGICK_CPPFLAGS)|$(MAGICK_LDFLAGS)|$(MAGICK_LIBS)
 __pchip_deriv__.cc
 __qp__.cc
-__voronoi__.cc
-amd.cc
+__voronoi__.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
+amd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 balance.cc
 besselj.cc
 betainc.cc
 bsxfun.cc
-ccolamd.cc
+ccolamd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 cellfun.cc
-chol.cc
-colamd.cc
+chol.cc|$(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(QRUPDATE_LDFLAGS) $(SPARSE_XLDFLAGS)|$(QRUPDATE_LIBS) $(SPARSE_XLIBS)
+colamd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 colloc.cc
 conv2.cc
-convhulln.cc
+convhulln.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
 daspk.cc
 dasrt.cc
 dassl.cc
 det.cc
 dlmread.cc
-dmperm.cc
+dmperm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 dot.cc
 eig.cc
-eigs.cc
-fft.cc
-fft2.cc
-fftn.cc
-fftw.cc
+eigs.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
+fft.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
+fft2.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
+fftn.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
+fftw.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 filter.cc
 find.cc
 gammainc.cc
 gcd.cc
 getgrent.cc
 getpwent.cc
 getrusage.cc
 givens.cc
@@ -53,30 +54,30 @@ lu.cc
 luinc.cc
 matrix_type.cc
 max.cc
 md5sum.cc
 mgorth.cc
 nproc.cc
 onCleanup.cc
 pinv.cc
-qr.cc
+qr.cc|$(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(QRUPDATE_LDFLAGS) $(SPARSE_XLDFLAGS)|$(QRUPDATE_LIBS) $(SPARSE_XLIBS)
 quad.cc
 quadcc.cc
-qz.cc
+qz.cc|||$(LAPACK_LIBS) $(BLAS_LIBS)
 rand.cc
 rcond.cc
-regexp.cc
+regexp.cc|$(REGEX_CPPFLAGS)|$(REGEX_LDFLAGS)|$(REGEX_LIBS)
 schur.cc
 spparms.cc
 sqrtm.cc
 strfind.cc
 str2double.cc
 sub2ind.cc
 svd.cc
 syl.cc
-symbfact.cc
-symrcm.cc
+symbfact.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
+symrcm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 time.cc
 tril.cc
 tsearch.cc
 typecast.cc
-urlwrite.cc
+urlwrite.cc|$(CURL_CPPFLAGS)|$(CURL_LDFLAGS)|$(CURL_LIBS)
diff --git a/src/DLD-FUNCTIONS/onCleanup.cc b/src/DLD-FUNCTIONS/onCleanup.cc
--- a/src/DLD-FUNCTIONS/onCleanup.cc
+++ b/src/DLD-FUNCTIONS/onCleanup.cc
@@ -269,8 +269,24 @@ For similar functionality @xref{The @cod
 
       retval = new octave_oncleanup (args(0));
     }
   else
     print_usage ();
 
   return retval;
 }
+
+/*
+
+%!test
+%! old_wstate = warning ("query");
+%! unwind_protect
+%!   trigger = onCleanup (@() warning ("on", "__MY_WARNING__"));
+%!   warning ("off", "__MY_WARNING__");
+%!   assert ((warning ("query", "__MY_WARNING__")).state, "off");
+%!   clear trigger
+%!   assert ((warning ("query", "__MY_WARNING__")).state, "on");
+%! unwind_protect_cleanup
+%!   warning (old_wstate);
+%! end_unwind_protect
+
+*/
diff --git a/src/DLD-FUNCTIONS/pinv.cc b/src/DLD-FUNCTIONS/pinv.cc
--- a/src/DLD-FUNCTIONS/pinv.cc
+++ b/src/DLD-FUNCTIONS/pinv.cc
@@ -164,8 +164,28 @@ where @code{sigma_max (@var{x})} is the 
       else
         {
           gripe_wrong_type_arg ("pinv", arg);
         }
     }
 
   return retval;
 }
+
+/*
+%!shared a, b, tol, hitol, d, u, x, y
+%! a = reshape (rand*[1:16], 4, 4);   ## Rank 2 matrix
+%! b = pinv (a);
+%! tol = 1e-14;
+%! hitol = 15*sqrt(eps);
+%! d = diag ([rand, rand, hitol, hitol]);
+%! u = rand (4);                      ## Could be singular by freak accident
+%! x = inv (u)*d*u;
+%! y = pinv (x, sqrt(eps));
+%!assert(a*b*a, a, tol);
+%!assert(b*a*b, b, tol);
+%!assert((b*a)', b*a, tol);
+%!assert((a*b)', a*b, tol);
+%!assert(x*y*x, x, -hitol);
+%!assert(y*x*y, y, -hitol);
+%!assert((x*y)', x*y, hitol);
+%!assert((y*x)', y*x, hitol);
+*/
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -282,16 +282,19 @@ fout (const octave_idx_type& lsize, cons
       const double& beta, const double&, const double& p)
 {
   if (lsize == 1)
     return (fabs (alpha) >= fabs (beta) ? 1 : -1);
   else
     return (fabs (p) >= 1 ? 1 : -1);
 }
 
+
+//FIXME: Matlab does not produce lambda as the first output argument.
+//       Compatibility problem?
 DEFUN_DLD (qz, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{lambda} =} qz (@var{A}, @var{B})\n\
 @deftypefnx {Loadable Function} {@var{lambda} =} qz (@var{A}, @var{B}, @var{opt})\n\
 QZ@tie{}decomposition of the generalized eigenvalue problem\n\
 (@math{A x = s B x}).  There are three ways to call this function:\n\
 @enumerate\n\
 @item @code{@var{lambda} = qz (@var{A}, @var{B})}\n\
@@ -1231,8 +1234,35 @@ compatibility with @sc{matlab}.\n\
   }
 
 #ifdef DEBUG
   std::cout << "qz: exiting (at long last)" << std::endl;
 #endif
 
   return retval;
 }
+
+/*
+%!shared a, b, c
+%!  a = [1 2; 0 3];
+%!  b = [1 0; 0 0];
+%!  c = [0 1; 0 0];
+%!assert(qz (a,b), 1);
+%!assert(isempty (qz (a,c)));
+
+%% Exaple 7.7.3 in Golub & Van Loan
+%!test
+%! a = [ 10  1  2;
+%!        1  2 -1;
+%!        1  1  2];
+%! b = reshape(1:9,3,3);
+%! [aa, bb, q, z, v, w, lambda] = qz (a, b);
+%! sz = length(lambda);
+%! observed =  (b * v * diag ([lambda;0])) (:, 1:sz);
+%! assert ( (a*v) (:, 1:sz), observed, norm (observed) * 1e-14);
+%! observed = (diag ([lambda;0]) * w' * b) (1:sz, :);
+%! assert ( (w'*a) (1:sz, :) , observed, norm (observed) * 1e-13);
+%! assert (q * a * z, aa, norm (aa) * 1e-14);
+%! assert (q * b * z, bb, norm (bb) * 1e-14);
+
+%% FIXME: Still need a test for third form of calling qz
+
+*/
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -172,17 +172,16 @@ do_rand (const octave_value_list& args, 
             if (r.all_elements_are_ints ())
               {
                 octave_idx_type n = r.nelem ();
 
                 dims.resize (n);
 
                 octave_idx_type base = NINTbig (r.base ());
                 octave_idx_type incr = NINTbig (r.inc ());
-                octave_idx_type lim = NINTbig (r.limit ());
 
                 for (octave_idx_type i = 0; i < n; i++)
                   {
                     //Negative dimensions are treated as zero for Matlab
                     //compatibility
                     dims(i) = base >= 0 ? base : 0;
                     base += incr;
                   }
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -131,29 +131,29 @@ time.\n\
           if (str == "defaults")
             octave_sparse_params::defaults ();
           else if (str == "tight")
             octave_sparse_params::tight ();
           else
             {
               double val = octave_sparse_params::get_key (str);
               if (xisnan (val))
-                error ("spparams: KEY not recognized");
+                error ("spparms: KEY not recognized");
               else
                 retval (0) = val;
             }
         }
       else
         {
           NDArray vals = args(0).array_value ();
 
           if (error_state)
             error ("spparms: input must be a string or a vector");
           else if (vals.numel () > OCTAVE_SPARSE_CONTROLS_SIZE)
-            error ("spparams: too many elements in vector VALS");
+            error ("spparms: too many elements in vector VALS");
           else
             octave_sparse_params::set_vals (vals);
         }
     }
   else if (nargin == 2)
     {
       if (args(0).is_string ())
         {
@@ -171,8 +171,38 @@ time.\n\
       else
         error ("spparms: first argument must be a string");
     }
   else
     error ("spparms: too many input arguments");
 
   return retval;
 }
+
+/*
+
+%!test
+%! old_vals = spparms ();  # save state
+%! spparms ("defaults");
+%! vals = spparms ();
+%! assert (vals, [0 1 1 0 3 3 0.5 1.0 1.0 0.1 0.5 1.0 0.001]');
+%! [keys, vals] = spparms ();
+%! assert (rows (keys), 13);
+%! assert (keys(2,:), "ths_rel");
+%! assert (vals, [0 1 1 0 3 3 0.5 1.0 1.0 0.1 0.5 1.0 0.001]');
+%! spparms ([3 2 1]);
+%! assert (spparms ()(1:3), [3, 2, 1]');
+%! assert (spparms ("ths_rel"), 2);
+%! spparms ("exact_d", 5);
+%! assert (spparms ("exact_d"), 5);
+%! spparms (old_vals);     # restore state
+
+%% Test input validation
+%!error (spparms (1, 2, 3))
+%!error ([x, y, z] = spparms ())
+%!error (spparms ("UNKNOWN_KEY"))
+%!error (spparms ({1, 2, 3}))
+%!error (spparms (ones (14, 1)))
+%!error (spparms (1, 1))
+%!error (spparms ("ths_rel", "hello"))
+%!error (spparms ("UNKNOWN_KEY", 1))
+
+*/
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -475,250 +475,91 @@ include DLD-FUNCTIONS/module.mk
 
 $(srcdir)/DLD-FUNCTIONS/module.mk: $(srcdir)/DLD-FUNCTIONS/config-module.sh $(srcdir)/DLD-FUNCTIONS/config-module.awk $(srcdir)/DLD-FUNCTIONS/module-files
 	$(srcdir)/DLD-FUNCTIONS/config-module.sh $(top_srcdir)
 
 include OPERATORS/module.mk
 include TEMPLATE-INST/module.mk
 
 if AMCOND_ENABLE_DYNAMIC_LINKING
-  DLD_DYNAMIC_SRC = $(DLD_FUNCTIONS_SRC)
-  DLD_STATIC_SRC =
   OCT_FILES = $(DLD_FUNCTIONS_LIBS:.la=.oct)
   OCT_STAMP_FILES = $(subst DLD-FUNCTIONS/,DLD-FUNCTIONS/$(am__leading_dot),$(DLD_FUNCTIONS_LIBS:.la=.oct-stamp))
 else
-  DLD_DYNAMIC_SRC =
-  DLD_STATIC_SRC = $(DLD_FUNCTIONS_SRC)
   OCT_FILES =
   OCT_STAMP_FILES =
 endif
 
 liboctinterp_la_SOURCES = \
   $(DIST_SRC) \
-  $(DLD_STATIC_SRC) \
   $(OPERATORS_SRC) \
   $(TEMPLATE_INST_SRC)
 
 nodist_liboctinterp_la_SOURCES = \
   builtins.cc \
   defaults.h \
   graphics.h \
   mxarray.h \
   oct-conf.h \
   oct-errno.cc \
   ops.cc \
   version.h \
   $(OPT_INC)
 
+liboctinterp_la_CPPFLAGS = @OCTINTERP_DLL_DEFS@ $(AM_CPPFLAGS)
 
-if AMCOND_ENABLE_DYNAMIC_LINKING
-  OCTAVE_LIBS = \
-    ./liboctinterp.la \
-    ../liboctave/liboctave.la \
-    ../libcruft/libcruft.la \
-    ../libcruft/libranlib.la \
-    ../libgnu/libgnu.la \
-    $(SPARSE_XLDFLAGS) $(SPARSE_XLIBS) \
-    $(QRUPDATE_LDFLAGS) $(QRUPDATE_LIBS) \
-    $(FFTW_XLDFLAGS) $(FFTW_XLIBS) \
-    $(LAPACK_LIBS) $(BLAS_LIBS) \
-    $(GRAPHICS_LDFLAGS) $(GRAPHICS_LIBS) \
-    $(FT2_LDFLAGS) $(FT2_LIBS) \
-    $(HDF5_LDFLAGS) $(HDF5_LIBS) $(Z_LDFLAGS) $(Z_LIBS) \
-    $(OPENGL_LIBS) $(X11_LIBS) $(CARBON_LIBS) \
-    $(READLINE_LIBS) $(TERM_LIBS) \
-    $(LIBGLOB) \
-    $(REGEX_LDFLAGS) $(REGEX_LIBS) \
-    $(LAPACK_LIBS) $(BLAS_LIBS) \
-    $(DL_LIBS) $(PTHREAD_LIBS) \
-    $(LIBS) \
-    $(FLIBS)
-else
-  ## FIXME -- this list is probably not complete now.  It may not even
-  ## be possible to build a statically linked copy of Octave that is
-  ## fully functional.
-  OCTAVE_LIBS = \
-    ./liboctinterp.la \
-    ../liboctave/liboctave.la \
-    ../libcruft/libcruft.la \
-    ../libcruft/libranlib.la \
-    ../libgnu/libgnu.la \
-    $(FFTW_XLDFLAGS) $(FFTW_XLIBS) \
-    $(QHULL_LDFLAGS) $(QHULL_LIBS) \
-    $(QRUPDATE_LDFLAGS) $(QRUPDATE_LIBS) \
-    $(SPARSE_XLDFLAGS) $(SPARSE_XLIBS) \
-    $(REGEX_LDFLAGS) $(REGEX_LIBS) \
-    $(CURL_LDFLAGS) $(CURL_LIBS) \
-    $(GLPK_LDFLAGS) $(GLPK_LIBS) \
-    $(MAGICK_LDFLAGS) $(MAGICK_LIBS) \
-    $(GRAPHICS_LDFLAGS) $(GRAPHICS_LIBS) \
-    $(FT2_LDFLAGS) $(FT2_LIBS) \
-    $(HDF5_LDFLAGS) $(HDF5_LIBS) $(Z_LDFLAGS) $(Z_LIBS) \
-    $(OPENGL_LIBS) $(X11_LIBS) $(CARBON_LIBS) \
-    $(READLINE_LIBS) $(TERM_LIBS) \
-    $(LIBGLOB) \
-    $(LAPACK_LIBS) $(BLAS_LIBS) \
-    $(DL_LIBS) $(PTHREAD_LIBS) \
-    $(LIBS) \
-    $(FLIBS)
-endif
+include link-deps.mk
 
-OCTINTERP_LINK_DEPS = \
-  $(RLD_FLAG) \
+liboctinterp_la_LIBADD = \
   ../liboctave/liboctave.la \
   ../libcruft/libcruft.la \
-  ../libcruft/libranlib.la \
-  ../libgnu/libgnu.la \
-  $(FFTW_XLDFLAGS) $(FFTW_XLIBS) \
-  $(FT2_LDFLAGS) $(FT2_LIBS) \
-  $(HDF5_LDFLAGS) $(HDF5_LIBS) $(Z_LDFLAGS) $(Z_LIBS) \
-  $(OPENGL_LIBS) $(X11_LIBS) $(CARBON_LIBS) \
-  $(READLINE_LIBS) $(TERM_LIBS) \
-  $(LIBGLOB) \
-  $(LAPACK_LIBS) $(BLAS_LIBS) \
-  $(LIBS) \
-  $(FLIBS)
-
-liboctinterp_la_LIBADD = $(OCTINTERP_LINK_DEPS)
-
-## Additional library dependencies used by module.mk files
-OCT_LINK_DEPS = \
-  $(RLD_FLAG) $(LDFLAGS) \
-  ./liboctinterp.la \
-  ../liboctave/liboctave.la \
-  ../libcruft/libcruft.la \
-  ../libcruft/libranlib.la \
-  ../libgnu/libgnu.la
-
-liboctinterp_la_CPPFLAGS = @OCTINTERP_DLL_DEFS@ $(AM_CPPFLAGS)
+  $(LIBOCTINTERP_LINK_DEPS)
 
 # Increment these as needed and according to the rules in the libtool manual:
 liboctinterp_current = 0
 liboctinterp_revision = 0
 liboctinterp_age = 0
 
 liboctinterp_version_info = $(liboctinterp_current):$(liboctinterp_revision):$(liboctinterp_age)
 
 liboctinterp_la_LDFLAGS = \
   -version-info $(liboctinterp_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
-  -bindir $(bindir)
+  -bindir $(bindir) \
+  $(LIBOCTINTERP_LINK_OPTS)
 
 display.df display.lo: CPPFLAGS += $(X11_FLAGS)
 
-DLD-FUNCTIONS/__magick_read__.df: CPPFLAGS += $(MAGICK_CPPFLAGS)
-DLD_FUNCTIONS___magick_read___la_CPPFLAGS = $(AM_CPPFLAGS) $(MAGICK_CPPFLAGS)
-DLD_FUNCTIONS___magick_read___la_LIBADD += $(MAGICK_LDFLAGS) $(MAGICK_LIBS)
-
-DLD-FUNCTIONS/convhulln.df: CPPFLAGS += $(QHULL_CPPFLAGS)
-DLD_FUNCTIONS_convhulln_la_CPPFLAGS = $(AM_CPPFLAGS) $(QHULL_CPPFLAGS)
-DLD_FUNCTIONS_convhulln_la_LIBADD += $(QHULL_LDFLAGS) $(QHULL_LIBS)
-
-DLD-FUNCTIONS/__delaunayn__.df: CPPFLAGS += $(QHULL_CPPFLAGS)
-DLD_FUNCTIONS___delaunayn___la_CPPFLAGS = $(AM_CPPFLAGS) $(QHULL_CPPFLAGS)
-DLD_FUNCTIONS___delaunayn___la_LIBADD += $(QHULL_LDFLAGS) $(QHULL_LIBS)
-
-DLD-FUNCTIONS/__voronoi__.df: CPPFLAGS += $(QHULL_CPPFLAGS)
-DLD_FUNCTIONS___voronoi___la_CPPFLAGS = $(AM_CPPFLAGS) $(QHULL_CPPFLAGS)
-DLD_FUNCTIONS___voronoi___la_LIBADD += $(QHULL_LDFLAGS) $(QHULL_LIBS)
-
-DLD-FUNCTIONS/eigs.df: CPPFLAGS += $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_eigs_la_CPPFLAGS = $(AM_CPPFLAGS) $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_eigs_la_LIBADD += $(SPARSE_XLDFLAGS) $(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
-
-#DLD-FUNCTIONS/qz.df DLD-FUNCTIONS/qz.lo:
-DLD_FUNCTIONS_qz_la_LIBADD += $(LAPACK_LIBS) $(BLAS_LIBS)
-
-DLD-FUNCTIONS/qr.df: CPPFLAGS += $(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_qr_la_CPPFLAGS = $(AM_CPPFLAGS) $(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_qr_la_LIBADD += $(QRUPDATE_LDFLAGS) $(QRUPDATE_LIBS) $(SPARSE_XLDFLAGS) $(SPARSE_XLIBS)
-
-DLD-FUNCTIONS/chol.df: CPPFLAGS += $(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_chol_la_CPPFLAGS = $(AM_CPPFLAGS) $(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_chol_la_LIBADD += $(QRUPDATE_LDFLAGS) $(QRUPDATE_LIBS) $(SPARSE_XLDFLAGS) $(SPARSE_XLIBS)
-
-DLD-FUNCTIONS/regexp.df: CPPFLAGS += $(REGEX_CPPFLAGS)
-DLD_FUNCTIONS_regexp_la_CPPFLAGS = $(AM_CPPFLAGS) $(REGEX_CPPFLAGS)
-DLD_FUNCTIONS_regexp_la_LIBADD += $(REGEX_LDFLAGS) $(REGEX_LIBS)
-
-DLD-FUNCTIONS/urlwrite.df: CPPFLAGS += $(CURL_CPPFLAGS)
-DLD_FUNCTIONS_urlwrite_la_CPPFLAGS = $(AM_CPPFLAGS) $(CURL_CPPFLAGS)
-DLD_FUNCTIONS_urlwrite_la_LIBADD += $(CURL_LDFLAGS) $(CURL_LIBS)
-
-DLD-FUNCTIONS/__fltk_uigetfile__.df: CPPFLAGS += $(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)
-DLD_FUNCTIONS___fltk_uigetfile___la_CPPFLAGS = $(AM_CPPFLAGS) $(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)
-DLD_FUNCTIONS___fltk_uigetfile___la_LIBADD += $(GRAPHICS_LDFLAGS) $(GRAPHICS_LIBS) $(FT2_LDFLAGS) $(FT2_LIBS)
-
-DLD-FUNCTIONS/__glpk__.df: CPPFLAGS += $(GLPK_CPPFLAGS)
-DLD_FUNCTIONS___glpk___la_CPPFLAGS = $(AM_CPPFLAGS) $(GLPK_CPPFLAGS)
-DLD_FUNCTIONS___glpk___la_LIBADD += $(GLPK_LDFLAGS) $(GLPK_LIBS)
-
-DLD-FUNCTIONS/__init_fltk__.df: CPPFLAGS += $(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)
-DLD_FUNCTIONS___init_fltk___la_CPPFLAGS = $(AM_CPPFLAGS) $(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)
-DLD_FUNCTIONS___init_fltk___la_LIBADD += $(GRAPHICS_LDFLAGS) $(GRAPHICS_LIBS) $(FT2_LDFLAGS) $(FT2_LIBS)
-
-DLD-FUNCTIONS/amd.df: CPPFLAGS += $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_amd_la_CPPFLAGS = $(AM_CPPFLAGS) $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_amd_la_LIBADD += $(SPARSE_XLDFLAGS) $(SPARSE_XLIBS)
-
-DLD-FUNCTIONS/colamd.df: CPPFLAGS += $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_colamd_la_CPPFLAGS = $(AM_CPPFLAGS) $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_colamd_la_LIBADD += $(SPARSE_XLDFLAGS) $(SPARSE_XLIBS)
-
-DLD-FUNCTIONS/ccolamd.df: CPPFLAGS += $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_ccolamd_la_CPPFLAGS = $(AM_CPPFLAGS) $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_ccolamd_la_LIBADD += $(SPARSE_XLDFLAGS) $(SPARSE_XLIBS)
-
-DLD-FUNCTIONS/symbfact.df: CPPFLAGS += $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_symbfact_la_CPPFLAGS = $(AM_CPPFLAGS) $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_symbfact_la_LIBADD += $(SPARSE_XLDFLAGS) $(SPARSE_XLIBS)
-
-DLD-FUNCTIONS/dmperm.df: CPPFLAGS += $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_dmperm_la_CPPFLAGS = $(AM_CPPFLAGS) $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_dmperm_la_LIBADD += $(SPARSE_XLDFLAGS) $(SPARSE_XLIBS)
-
-DLD-FUNCTIONS/symrcm.df: CPPFLAGS += $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_symrcm_la_CPPFLAGS = $(AM_CPPFLAGS) $(SPARSE_XCPPFLAGS)
-DLD_FUNCTIONS_symrcm_la_LIBADD += $(SPARSE_XLDFLAGS) $(SPARSE_XLIBS)
-
-DLD-FUNCTIONS/fft.df: CPPFLAGS += $(FFTW_XCPPFLAGS)
-DLD_FUNCTIONS_fft_la_CPPFLAGS = $(AM_CPPFLAGS) $(FFTW_XCPPFLAGS)
-DLD_FUNCTIONS_fft_la_LIBADD += $(FFTW_XLDFLAGS) $(FFTW_XLIBS)
-
-DLD-FUNCTIONS/fft2.df: CPPFLAGS += $(FFTW_XCPPFLAGS)
-DLD_FUNCTIONS_fft2_la_CPPFLAGS = $(AM_CPPFLAGS) $(FFTW_XCPPFLAGS)
-DLD_FUNCTIONS_fft2_la_LIBADD += $(FFTW_XLDFLAGS) $(FFTW_XLIBS)
-
-DLD-FUNCTIONS/fftn.df: CPPFLAGS += $(FFTW_XCPPFLAGS)
-DLD_FUNCTIONS_fftn_la_CPPFLAGS = $(AM_CPPFLAGS) $(FFTW_XCPPFLAGS)
-DLD_FUNCTIONS_fftn_la_LIBADD += $(FFTW_XLDFLAGS) $(FFTW_XLIBS)
-
-DLD-FUNCTIONS/fftw.df: CPPFLAGS += $(FFTW_XCPPFLAGS)
-DLD_FUNCTIONS_fftw_la_CPPFLAGS = $(AM_CPPFLAGS) $(FFTW_XCPPFLAGS)
-DLD_FUNCTIONS_fftw_la_LIBADD += $(FFTW_XLDFLAGS) $(FFTW_XLIBS)
-
-
 octave_SOURCES = main.c
 
-octave_LDADD = $(OCTAVE_LIBS)
+octave_LDADD = \
+  liboctinterp.la \
+  ../liboctave/liboctave.la \
+  ../libcruft/libcruft.la \
+  $(OCTAVE_LINK_DEPS)
 
+octave_LDFLAGS = \
+  $(NO_UNDEFINED_LDFLAG) \
+  $(OCTAVE_LINK_OPTS)
 
 ## Section for defining and creating DEF_FILES
 SRC_DEF_FILES := $(shell $(srcdir)/find-defun-files.sh "$(srcdir)" $(DIST_SRC))
 
-DLD_STATIC_DEF_FILES  = $(DLD_STATIC_SRC:.cc=.df)
-DLD_DYNAMIC_DEF_FILES = $(DLD_DYNAMIC_SRC:.cc=.df)
+DLD_FUNCTIONS_DEF_FILES = $(DLD_FUNCTIONS_SRC:.cc=.df)
 
 ## builtins.cc depends on $(DEF_FILES), so DEF_FILES should only include
 ## .df files that correspond to sources included in liboctave.
-DEF_FILES = $(SRC_DEF_FILES) $(DLD_STATIC_DEF_FILES)
+if AMCOND_ENABLE_DYNAMIC_LINKING
+  DEF_FILES = $(SRC_DEF_FILES)
+else
+  DEF_FILES = $(SRC_DEF_FILES) $(DLD_FUNCTIONS_DEF_FILES)
+endif
 
-ALL_DEF_FILES = $(DEF_FILES) $(DLD_DYNAMIC_DEF_FILES)
+ALL_DEF_FILES = $(SRC_DEF_FILES) $(DLD_FUNCTIONS_DEF_FILES)
 
-$(DEF_FILES) $(DYNAMIC_DLD_DEF_FILES): mkdefs Makefile
+$(SRC_DEF_FILES): mkdefs Makefile
 
 $(DEF_FILES): $(OPT_HANDLERS) $(OPT_INC)
 
 DLL_CDEFS = @OCTINTERP_DLL_DEFS@
 DLL_CXXDEFS = @OCTINTERP_DLL_DEFS@
 
 ## Rule to build a DEF file from a .cc file
 %.df: %.cc
@@ -791,19 +632,23 @@ oct-errno.cc: oct-errno.cc.in Makefile
 
 $(OPT_HANDLERS) : %.cc : $(top_srcdir)/liboctave/%.in $(top_srcdir)/build-aux/mk-opts.pl
 	$(PERL) $(top_srcdir)/build-aux/mk-opts.pl --opt-handler-fcns $< > $@-t
 	mv $@-t $@
 
 $(OPT_INC) : %.h : %.in
 	$(MAKE) -C $(@D) $(@F)
 
-DLD-FUNCTIONS/PKG_ADD: $(DLD_DYNAMIC_DEF_FILES) mk-pkg-add
-	$(srcdir)/mk-pkg-add $(DLD_DYNAMIC_DEF_FILES) > $@-t
+if AMCOND_ENABLE_DYNAMIC_LINKING
+DLD_FUNCTIONS_PKG_ADD_FILE = DLD-FUNCTIONS/PKG_ADD
+
+DLD-FUNCTIONS/PKG_ADD: $(DLD_FUNCTIONS_DEF_FILES) mk-pkg-add
+	$(srcdir)/mk-pkg-add $(DLD_FUNCTIONS_DEF_FILES) > $@-t
 	mv $@-t $@
+endif
 
 lex.lo lex.o oct-parse.lo oct-parse.o: \
   AM_CXXFLAGS := $(filter-out -Wold-style-cast, $(AM_CXXFLAGS))
 
 __fltk_uigetfile__.lo __fltk_uigetfile__.o: \
   AM_CXXFLAGS := $(filter-out $(DLL_CXXDEFS), $(AM_CXXFLAGS) $(GRAPHICS_CFLAGS))
 
 __init_fltk__.lo __init_fltk__.o: \
@@ -825,18 +670,17 @@ doc-files: $(ALL_DEF_FILES)
 
 gendoc.cc: doc-files mkgendoc
 	$(srcdir)/mkgendoc doc-files > $@-t
 	mv $@-t $@
 
 gendoc$(BUILD_EXEEXT): gendoc.cc
 	$(BUILD_CXX) $(BUILD_CXXFLAGS) -o $@ $^ $(BUILD_LDFLAGS)
 
-
-all-local: $(OCT_STAMP_FILES) DLD-FUNCTIONS/PKG_ADD .DOCSTRINGS
+all-local: $(OCT_STAMP_FILES) $(DLD_FUNCTIONS_PKG_ADD_FILE) .DOCSTRINGS
 
 if AMCOND_BUILD_COMPILED_AUX_PROGRAMS
 octave-config.cc: octave-config.cc.in Makefile
 	@$(do_subst_default_vals)
 
 mkoctfile.cc: mkoctfile.cc.in Makefile
 	@$(do_subst_config_vals)
 else
@@ -879,18 +723,18 @@ if ! AMCOND_BUILD_COMPILED_AUX_PROGRAMS
 	done
 endif
 
 .PHONY: make-version-links remove-version-links
 
 if AMCOND_ENABLE_DYNAMIC_LINKING
 install-oct:
 	$(top_srcdir)/build-aux/mkinstalldirs $(DESTDIR)$(octfiledir)
-	if [ -n "`cat DLD-FUNCTIONS/PKG_ADD`" ]; then \
-	  $(INSTALL_DATA) DLD-FUNCTIONS/PKG_ADD $(DESTDIR)$(octfiledir)/PKG_ADD; \
+	if [ -n "`cat $(DLD_FUNCTIONS_PKG_ADD_FILE)`" ]; then \
+	  $(INSTALL_DATA) $(DLD_FUNCTIONS_PKG_ADD_FILE) $(DESTDIR)$(octfiledir)/PKG_ADD; \
 	fi
 	cd $(DESTDIR)$(octlibdir) && \
 	for ltlib in $(DLD_FUNCTIONS_LIBS); do \
 	  f=`echo $$ltlib | $(SED) 's,.*/,,'`; \
 	  dl=`$(SED) -n -e "s/dlname='\([^']*\)'/\1/p" < $$f`; \
 	  if [ -n "$$dl" ]; then \
 	    $(INSTALL_PROGRAM) $$dl $(DESTDIR)$(octfiledir)/`echo $$f | $(SED) 's,^lib,,; s,\.la$$,.oct,'`; \
 	  else \
@@ -908,17 +752,17 @@ uninstall-oct:
 	  rm -f $(DESTDIR)$(octfiledir)/$$f; \
 	done
 	rm -f $(DESTDIR)$(octfiledir)/PKG_ADD
 endif
 .PHONY: install-oct uninstall-oct
 
 CLEANFILES = \
   $(bin_SCRIPTS) \
-  DLD-FUNCTIONS/PKG_ADD \
+  $(DLD_FUNCTIONS_PKG_ADD_FILE) \
   doc-files \
   gendoc.cc \
   gendoc$(BUILD_EXEEXT) \
   graphics-props.cc \
   oct-parse.output
 
 DISTCLEANFILES = \
   .DOCSTRINGS \
diff --git a/src/OPERATORS/op-int.h b/src/OPERATORS/op-int.h
--- a/src/OPERATORS/op-int.h
+++ b/src/OPERATORS/op-int.h
@@ -727,17 +727,17 @@ octave_value elem_xpow (FloatNDArray a, 
   elem_xpow (const T1 ## NDArray& a, const NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun (a_dims, b_dims)) \
           { \
-            return bsxfun_pow (a, static_cast<T1 ## NDArray> (b)); \
+            return bsxfun_pow (a, b); \
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
       } \
     T1 ## NDArray result (a_dims); \
@@ -753,17 +753,17 @@ octave_value elem_xpow (FloatNDArray a, 
   elem_xpow (const NDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun (a_dims, b_dims)) \
           { \
-            return bsxfun_pow (static_cast<T2 ## NDArray> (a), b); \
+            return bsxfun_pow (a, b); \
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
       } \
     T2 ## NDArray result (a_dims); \
@@ -779,17 +779,17 @@ octave_value elem_xpow (FloatNDArray a, 
   elem_xpow (const T1 ## NDArray& a, const FloatNDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun (a_dims, b_dims)) \
           { \
-            return bsxfun_pow (a, static_cast<T1 ## NDArray> (b)); \
+            return bsxfun_pow (a, b); \
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
       } \
     T1 ## NDArray result (a_dims); \
@@ -805,17 +805,17 @@ octave_value elem_xpow (FloatNDArray a, 
   elem_xpow (const FloatNDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun (a_dims, b_dims)) \
           { \
-            return bsxfun_pow (static_cast<T1 ## NDArray> (a), b); \
+            return bsxfun_pow (a, b); \
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
       } \
     T2 ## NDArray result (a_dims); \
diff --git a/src/OPERATORS/op-pm-sm.cc b/src/OPERATORS/op-pm-sm.cc
--- a/src/OPERATORS/op-pm-sm.cc
+++ b/src/OPERATORS/op-pm-sm.cc
@@ -27,16 +27,59 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #include "ov-perm.h"
 #include "ov-re-sparse.h"
+#include "ov-bool-sparse.h"
+
+// Unary permutation ops, some cast to sparse
+
+//Avoid casting to a full matrix
+DEFUNOP_OP (uplus, perm_matrix, /* no-op */)
+
+// Not calling standard CAST_UNOP_ARG for these next two because a
+// dynamic_cast would fail.
+DEFUNOP (not, perm_matrix)
+{
+  // Obviously negation of a permutation matrix destroys sparsity
+  return octave_value ( ! a.bool_array_value ());
+}
+
+DEFUNOP (uminus, perm_matrix)
+{
+  return octave_value ( - a.sparse_matrix_value ());
+}
+
+// Most other logical operations cast to SparseBoolMatrix
+DEFBINOP (eq_pm, perm_matrix, perm_matrix)
+{
+  CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_perm_matrix&);
+  return v1.sparse_bool_matrix_value () == v2.sparse_bool_matrix_value ();
+}
+DEFBINOP (ne_pm, perm_matrix, perm_matrix)
+{
+  CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_perm_matrix&);
+  return v1.sparse_bool_matrix_value () != v2.sparse_bool_matrix_value ();
+}
+DEFBINOP (el_and_pm, perm_matrix, perm_matrix)
+{
+  CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_perm_matrix&);
+  return mx_el_and(v1.sparse_bool_matrix_value (),
+                   v2.sparse_bool_matrix_value ());
+}
+DEFBINOP (el_or_pm,  perm_matrix, perm_matrix)
+{
+  CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_perm_matrix&);
+  return mx_el_or(v1.sparse_bool_matrix_value (),
+                  v2.sparse_bool_matrix_value ());
+}
 
 // permutation matrix by sparse matrix ops
 
 DEFBINOP (mul_pm_sm, perm_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
@@ -81,17 +124,27 @@ DEFBINOP (div_sm_pm, sparse_matrix, perm
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_perm_matrix&);
 
   return v1.sparse_matrix_value () * v2.perm_matrix_value ().inverse ();
 }
 
 void
 install_pm_sm_ops (void)
 {
+  INSTALL_UNOP (op_not, octave_perm_matrix, not);
+  INSTALL_UNOP (op_uplus, octave_perm_matrix, uplus);
+  INSTALL_UNOP (op_uminus, octave_perm_matrix, uminus);
+
+
   INSTALL_BINOP (op_mul, octave_perm_matrix, octave_sparse_matrix,
                  mul_pm_sm);
   INSTALL_BINOP (op_ldiv, octave_perm_matrix, octave_sparse_matrix,
                  ldiv_pm_sm);
   INSTALL_BINOP (op_mul, octave_sparse_matrix, octave_perm_matrix,
                  mul_sm_pm);
   INSTALL_BINOP (op_div, octave_sparse_matrix, octave_perm_matrix,
                  div_sm_pm);
+
+  INSTALL_BINOP (op_eq, octave_perm_matrix, octave_perm_matrix, eq_pm);
+  INSTALL_BINOP (op_ne, octave_perm_matrix, octave_perm_matrix, ne_pm);
+  INSTALL_BINOP (op_el_and, octave_perm_matrix, octave_perm_matrix, el_and_pm);
+  INSTALL_BINOP (op_el_or,  octave_perm_matrix, octave_perm_matrix, el_or_pm);
 }
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -2027,17 +2027,17 @@ DEFUN (ndims, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ndims (@var{a})\n\
 Return the number of dimensions of @var{a}.\n\
 For any array, the result will always be larger than or equal to 2.\n\
 Trailing singleton dimensions are not counted.\n\
 \n\
 @example\n\
 @group\n\
-  ndims (ones (4, 1, 2, 1)\n\
+  ndims (ones (4, 1, 2, 1))\n\
      @result{} 3\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
diff --git a/src/link-deps.mk b/src/link-deps.mk
new file mode 100644
--- /dev/null
+++ b/src/link-deps.mk
@@ -0,0 +1,38 @@
+include ../liboctave/link-deps.mk
+
+if AMCOND_ENABLE_DYNAMIC_LINKING
+  LIBOCTINTERP_LINK_DEPS =
+else
+  LIBOCTINTERP_LINK_DEPS = $(DLD_FUNCTIONS_LIBS)
+endif
+
+LIBOCTINTERP_LINK_DEPS += \
+  $(GRAPHICS_LIBS) \
+  $(FT2_LIBS) \
+  $(HDF5_LIBS) \
+  $(Z_LIBS) \
+  $(OPENGL_LIBS) \
+  $(X11_LIBS) \
+  $(CARBON_LIBS)
+
+LIBOCTINTERP_LINK_OPTS = \
+  $(GRAPHICS_LDFLAGS) \
+  $(FT2_LDFLAGS) \
+  $(HDF5_LDFLAGS) \
+  $(Z_LDFLAGS) \
+  $(REGEX_LDFLAGS)
+
+OCT_LINK_DEPS =
+
+OCT_LINK_OPTS = $(LDFLAGS)
+
+if AMCOND_LINK_ALL_DEPS
+  LIBOCTINTERP_LINK_DEPS += $(LIBOCTAVE_LINK_DEPS)
+  LIBOCTINTERP_LINK_OPTS += $(LIBOCTAVE_LINK_OPTS)
+
+  OCTAVE_LINK_DEPS = $(LIBOCTINTERP_LINK_DEPS)
+  OCTAVE_LINK_OPTS = $(LIBOCTINTERP_LINK_OPTS)
+
+  OCT_LINK_DEPS += $(LIBOCTINTERP_LINK_DEPS)
+  OCT_LINK_OPTS += $(LIBOCTINTERP_LINK_OPTS)
+endif
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -659,17 +659,18 @@ Force Octave to assume the file is in Oc
   // user preference variable since we can determine the type of file
   // as we are reading.
 
   load_save_format format = LS_UNKNOWN;
 
   bool list_only = false;
   bool verbose = false;
 
-  for (i; i < argc; i++)
+  //for (i; i < argc; i++)
+  for (; i < argc; i++)
     {
       if (argv[i] == "-force" || argv[i] == "-f")
         {
           // Silently ignore this
           // warning ("load: -force ignored");
         }
       else if (argv[i] == "-list" || argv[i] == "-l")
         {
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -207,17 +207,23 @@ arg (3 + 4i)\n\
 %!assert(arg (1), 0);
 %!assert(arg (i), pi/2);
 %!assert(arg (-1), pi);
 %!assert(arg (-i), -pi/2);
 %!assert(arg ([1, i; -1, -i]), [0, pi/2; pi, -pi/2]);
 
 %!assert(arg (single(1)), single(0));
 %!assert(arg (single(i)), single(pi/2));
-%!assert(arg (single(-1)), single(pi));
+%!test
+%! if (ismac ())
+%!   ## Avoid failing for a MacOS feature
+%!   assert(arg (single(-1)), single(pi), 2*eps(single(1)));
+%! else
+%!   assert(arg (single(-1)), single(pi));
+%! endif
 %!assert(arg (single(-i)), single(-pi/2));
 %!assert(arg (single([1, i; -1, -i])), single([0, pi/2; pi, -pi/2]), 2e1*eps('single'));
 
 %!error arg ();
 %!error arg (1, 2);
 
 */
 
diff --git a/src/mkoctfile.cc.in b/src/mkoctfile.cc.in
--- a/src/mkoctfile.cc.in
+++ b/src/mkoctfile.cc.in
@@ -214,30 +214,33 @@ initialize (void)
   vars["XTRA_CXXFLAGS"] = get_variable ("XTRA_CXXFLAGS", %OCTAVE_CONF_XTRA_CXXFLAGS%);
 
   vars["DEPEND_FLAGS"] = get_variable ("DEPEND_FLAGS", %OCTAVE_CONF_DEPEND_FLAGS%);
   vars["DEPEND_EXTRA_SED_PATTERN"] = get_variable ("DEPEND_EXTRA_SED_PATTERN", %OCTAVE_CONF_DEPEND_EXTRA_SED_PATTERN%);
 
   vars["DL_LD"] = get_variable ("DL_LD", %OCTAVE_CONF_DL_LD%);
   vars["DL_LDFLAGS"] = get_variable ("DL_LDFLAGS", %OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%);
 
-  vars["RLD_FLAG"] = get_variable ("RLD_FLAG", %OCTAVE_CONF_RLD_FLAG%);
   vars["RDYNAMIC_FLAG"] = get_variable ("RDYNAMIC_FLAG", %OCTAVE_CONF_RDYNAMIC_FLAG%);
   vars["LIBOCTAVE"] = "-loctave";
   vars["LIBOCTINTERP"] = "-loctinterp";
   vars["READLINE_LIBS"] = "-lreadline";
   vars["LIBCRUFT"] = "-lcruft";
   vars["LAPACK_LIBS"] = get_variable ("LAPACK_LIBS", %OCTAVE_CONF_LAPACK_LIBS%);
   vars["BLAS_LIBS"] = get_variable ("BLAS_LIBS", %OCTAVE_CONF_BLAS_LIBS%);
   vars["FFTW3_LDFLAGS"] = get_variable ("FFTW3_LDFLAGS", %OCTAVE_CONF_FFTW3_LDFLAGS%);
   vars["FFTW3_LIBS"] = get_variable ("FFTW3_LIBS", %OCTAVE_CONF_FFTW3_LIBS%);
   vars["FFTW3F_LDFLAGS"] = get_variable ("FFTW3F_LDFLAGS", %OCTAVE_CONF_FFTW3F_LDFLAGS%);
   vars["FFTW3F_LIBS"] = get_variable ("FFTW3F_LIBS", %OCTAVE_CONF_FFTW3F_LIBS%);
   vars["LIBS"] = get_variable ("LIBS", %OCTAVE_CONF_LIBS%);
   vars["FLIBS"] = get_variable ("FLIBS", %OCTAVE_CONF_FLIBS%);
+  vars["OCTAVE_LINK_DEPS"] = get_variable ("FLIBS", %OCTAVE_CONF_OCTAVE_LINK_DEPS%);
+  vars["OCT_LINK_DEPS"] = get_variable ("FLIBS", %OCTAVE_CONF_OCT_LINK_DEPS%);
+  vars["FLIBS"] = get_variable ("FLIBS", %OCTAVE_CONF_FLIBS%);
+
   vars["LD_CXX"] = get_variable ("LD_CXX", %OCTAVE_CONF_LD_CXX%);
   vars["LDFLAGS"] = get_variable ("LDFLAGS", %OCTAVE_CONF_LDFLAGS%);
   vars["LD_STATIC_FLAG"] = get_variable ("LD_STATIC_FLAG", %OCTAVE_CONF_LD_STATIC_FLAG%);
   vars["LFLAGS"] = get_variable ("LFLAGS", DEFAULT_LFLAGS);
   vars["F77_INTEGER8_FLAG"] = get_variable ("F77_INTEGER8_FLAG", %OCTAVE_CONF_F77_INTEGER_8_FLAG%);
 
   vars["ALL_FFLAGS"] = vars["FFLAGS"] + " " + vars["F77_INTEGER8_FLAG"];
 
@@ -291,35 +294,40 @@ static string help_msg =
 "                          (or .mex if --mex is specified) unless linking\n"
 "                          a stand-alone executable.\n"
 "\n"
 "  -g                      Enable debugging options for compilers.\n"
 "\n"
 "  -p VAR, --print VAR     Print configuration variable VAR.  Recognized\n"
 "                          variables are:\n"
 "\n"
-"                           ALL_CFLAGS                FLIBS\n"
-"                           ALL_CXXFLAGS              FPICFLAG\n"
-"                           ALL_FFLAGS                INCFLAGS\n"
-"                           ALL_LDFLAGS               LAPACK_LIBS\n"
-"                           BLAS_LIBS                 LDFLAGS\n"
-"                           CC                        LD_CXX\n"
-"                           CFLAGS                    LD_STATIC_FLAG\n"
-"                           CPICFLAG                  LFLAGS\n"
-"                           CPPFLAGS                  LIBCRUFT\n"
-"                           CXX                       LIBOCTAVE\n"
-"                           CXXFLAGS                  LIBOCTINTERP\n"
-"                           CXXPICFLAG                LIBS\n"
-"                           DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS\n"
-"                           DEPEND_FLAGS              RDYNAMIC_FLAG\n"
-"                           DL_LD                     READLINE_LIBS\n"
-"                           DL_LDFLAGS                RLD_FLAG\n"
-"                           F77                       SED\n"
-"                           FFLAGS                    XTRA_CFLAGS\n"
-"                           FFTW_LIBS                 XTRA_CXXFLAGS\n"
+"                            ALL_CFLAGS                FLIBS\n"
+"                            ALL_CXXFLAGS              FPICFLAG\n"
+"                            ALL_FFLAGS                INCFLAGS\n"
+"                            ALL_LDFLAGS               LAPACK_LIBS\n"
+"                            BLAS_LIBS                 LDFLAGS\n"
+"                            CC                        LD_CXX\n"
+"                            CFLAGS                    LD_STATIC_FLAG\n"
+"                            CPICFLAG                  LFLAGS\n"
+"                            CPPFLAGS                  LIBCRUFT\n"
+"                            CXX                       LIBOCTAVE\n"
+"                            CXXFLAGS                  LIBOCTINTERP\n"
+"                            CXXPICFLAG                LIBS\n"
+"                            DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS\n"
+"                            DEPEND_FLAGS              OCTAVE_LINK_DEPS\n"
+"                            DL_LD                     OCTAVE_LINK_OPTS\n"
+"                            DL_LDFLAGS                OCT_LINK_DEPS\n"
+"                            EXEEXT                    OCT_LINK_OPTS\n"
+"                            F77                       RDYNAMIC_FLAG\n"
+"                            F77_INTEGER_8_FLAG        READLINE_LIBS\n"
+"                            FFLAGS                    SED\n"
+"                            FFTW3_LDFLAGS             XTRA_CFLAGS\n"
+"                            FFTW3_LIBS                XTRA_CXXFLAGS\n"
+"                            FFTW3F_LDFLAGS\n"
+"                            FFTW3F_LIBS\n"
 "\n"
 "  --link-stand-alone      Link a stand-alone executable file.\n"
 "\n"
 "  --mex                   Assume we are creating a MEX file.  Set the\n"
 "                          default output extension to \".mex\".\n"
 "\n"
 "  -s, --strip             Strip output file.\n"
 "\n"
@@ -737,38 +745,36 @@ main (int argc, char **argv)
       if (link_stand_alone)
         {
           if (!vars["LD_CXX"].empty ())
             {
               string cmd = vars["LD_CXX"] + " " + vars["CPPFLAGS"] + " "
                 + vars["ALL_CXXFLAGS"] + " " + vars["RDYNAMIC_FLAG"]
                 + " " + vars["ALL_LDFLAGS"] + " " +  pass_on_options
                 + " " + output_option + " " + objfiles + " " + libfiles
-                + " " + ldflags + " " + vars["LFLAGS"] + " "
-                + vars["RLD_FLAG"] + " " + vars["OCTAVE_LIBS"] + " "
-                + vars["LAPACK_LIBS"] + " " + vars["BLAS_LIBS"] + " "
-                + vars["FFTW_LIBS"] + " " + vars["READLINE_LIBS"] + " "
-                + vars["LIBS"] + " " + vars["FLIBS"];
+                + " " + ldflags + " " + vars["LFLAGS"]
+                + " -loctinterp -loctave -lcruft "
+                + " " + vars["OCT_LINK_OPTS"]
+                + " " + vars["OCTAVE_LINK_DEPS"];
               result = run_command (cmd);
             }
           else
             {
               cerr << "mkoctfile: no way to link stand-alone executable file"
                    << endl;
               return 1;
             }
         }
       else
         {
-          string LINK_DEPS = vars["LFLAGS"] + " " + vars["OCTAVE_LIBS"]
-            + " " + vars["LDFLAGS"] + " " + vars["BLAS_LIBS"] + " "
-            + vars["FFTW_LIBS"] + " " + vars["LIBS"] + " " + vars["FLIBS"];
           string cmd = vars["DL_LD"] + " " + vars["DL_LDFLAGS"] + " "
             + pass_on_options + " -o " + octfile + " " + objfiles + " "
-            + libfiles + " " + ldflags + " " + LINK_DEPS;
+            + libfiles + " " + ldflags + " " + vars["LFLAGS"]
+            + " -loctinterp -loctave -lcruft "
+            + vars["OCT_LINK_OPTS"] + " " + vars["OCT_LINK_DEPS"];
           result = run_command (cmd);
         }
 
       if (strip)
         {
           string cmd = "strip " + octfile;
           result = run_command (cmd);
         }
diff --git a/src/mkoctfile.in b/src/mkoctfile.in
--- a/src/mkoctfile.in
+++ b/src/mkoctfile.in
@@ -80,30 +80,33 @@ fi
 : ${XTRA_CXXFLAGS=%OCTAVE_CONF_XTRA_CXXFLAGS%}
 
 : ${DEPEND_FLAGS=%OCTAVE_CONF_DEPEND_FLAGS%}
 : ${DEPEND_EXTRA_SED_PATTERN=%OCTAVE_CONF_DEPEND_EXTRA_SED_PATTERN%}
 
 : ${DL_LD=%OCTAVE_CONF_DL_LD%}
 : ${DL_LDFLAGS=%OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%}
 
-: ${RLD_FLAG=%OCTAVE_CONF_RLD_FLAG%}
 : ${RDYNAMIC_FLAG=%OCTAVE_CONF_RDYNAMIC_FLAG%}
 : ${LIBOCTAVE=-loctave}
 : ${LIBOCTINTERP=-loctinterp}
 : ${READLINE_LIBS=-lreadline}
 : ${LIBCRUFT=-lcruft}
 : ${LAPACK_LIBS=%OCTAVE_CONF_LAPACK_LIBS%}
 : ${BLAS_LIBS=%OCTAVE_CONF_BLAS_LIBS%}
 : ${FFTW3_LDFLAGS=%OCTAVE_CONF_FFTW3_LDFLAGS%}
 : ${FFTW3_LIBS=%OCTAVE_CONF_FFTW3_LIBS%}
 : ${FFTW3F_LDFLAGS=%OCTAVE_CONF_FFTW3F_LDFLAGS%}
 : ${FFTW3F_LIBS=%OCTAVE_CONF_FFTW3F_LIBS%}
 : ${LIBS=%OCTAVE_CONF_LIBS%}
 : ${FLIBS=%OCTAVE_CONF_FLIBS%}
+: ${OCTAVE_LINK_DEPS=%OCTAVE_CONF_OCTAVE_LINK_DEPS%}
+: ${OCTAVE_LINK_DEPS=%OCTAVE_CONF_OCTAVE_LINK_OPTS%}
+: ${OCT_LINK_DEPS=%OCTAVE_CONF_MKOCTFILE_OCT_LINK_DEPS%}
+: ${OCT_LINK_DEPS=%OCTAVE_CONF_MKOCTFILE_OCT_LINK_OPTS%}
 : ${LD_CXX=%OCTAVE_CONF_LD_CXX%}
 : ${LDFLAGS=%OCTAVE_CONF_LDFLAGS%}
 : ${LD_STATIC_FLAG=%OCTAVE_CONF_LD_STATIC_FLAG%}
 : ${LFLAGS=$DEFAULT_LFLAGS}
 : ${F77_INTEGER_8_FLAG=%OCTAVE_CONF_F77_INTEGER_8_FLAG%}
 
 : ${ALL_FFLAGS="$FFLAGS $F77_INTEGER_8_FLAG"}
 
@@ -216,48 +219,49 @@ Options:
                           source files.
 
   -c, --compile           Compile, but do not link.
 
   --link-stand-alone      Link a stand-alone executable file.
 
   -s, --strip             Strip output file.
 
-  --mex                   Create a MEX file.  
+  --mex                   Create a MEX file.
                           Set the default output extension to ".mex".
 
   -o FILE, --output FILE  Output file name.  Default extension is .oct
                           (or .mex if --mex is specified) unless linking
                           a stand-alone executable.
 
   -p VAR, --print VAR     Print configuration variable VAR.  Recognized
                           variables are:
 
-                            ALL_CFLAGS                FFTW3F_LDFLAGS
-                            ALL_CXXFLAGS              FFTW3F_LIBS
-                            ALL_FFLAGS                FLIBS
-                            ALL_LDFLAGS               FPICFLAG
-                            BLAS_LIBS                 INCFLAGS
-                            CC                        LAPACK_LIBS
-                            CFLAGS                    LDFLAGS
-                            CPICFLAG                  LD_CXX
-                            CPPFLAGS                  LD_STATIC_FLAG
-                            CXX                       LFLAGS
-                            CXXFLAGS                  LIBCRUFT
-                            CXXPICFLAG                LIBOCTAVE
-                            DEPEND_EXTRA_SED_PATTERN  LIBOCTINTERP
-                            DEPEND_FLAGS              LIBS
-                            DL_LD                     OCTAVE_LIBS
-                            DL_LDFLAGS                RDYNAMIC_FLAG
-                            EXEEXT                    READLINE_LIBS
-                            F77                       RLD_FLAG
+                            ALL_CFLAGS                FFTW3F_LIBS
+                            ALL_CXXFLAGS              FLIBS
+                            ALL_FFLAGS                FPICFLAG
+                            ALL_LDFLAGS               INCFLAGS
+                            BLAS_LIBS                 LAPACK_LIBS
+                            CC                        LDFLAGS
+                            CFLAGS                    LD_CXX
+                            CPICFLAG                  LD_STATIC_FLAG
+                            CPPFLAGS                  LFLAGS
+                            CXX                       LIBCRUFT
+                            CXXFLAGS                  LIBOCTAVE
+                            CXXPICFLAG                LIBOCTINTERP
+                            DEPEND_EXTRA_SED_PATTERN  LIBS
+                            DEPEND_FLAGS              OCTAVE_LIBS
+                            DL_LD                     OCTAVE_LINK_DEPS
+                            DL_LDFLAGS                OCT_LINK_DEPS
+                            EXEEXT                    RDYNAMIC_FLAG
+                            F77                       READLINE_LIBS
                             F77_INTEGER_8_FLAG        SED
                             FFLAGS                    XTRA_CFLAGS
                             FFTW3_LDFLAGS             XTRA_CXXFLAGS
                             FFTW3_LIBS
+                            FFTW3F_LDFLAGS
 
   -v, --verbose           Echo commands as they are executed.
 
   FILE                    Compile or link FILE.  Recognized file types are:
 
                             .c    C source
                             .cc   C++ source
                             .C    C++ source
@@ -524,26 +528,25 @@ fi
 ##   eval $cmd
 ## fi
 
 # Link all the object files.
 
 if $link && [ -n "$objfiles" ]; then
   if $link_stand_alone; then
     if [ -n "$LD_CXX" ]; then
-      cmd="$LD_CXX $CPPFLAGS $ALL_CXXFLAGS $RDYNAMIC_FLAG $ALL_LDFLAGS $pass_on_options $output_option $objfiles $libfiles $ldflags $LFLAGS $RLD_FLAG $OCTAVE_LIBS $LAPACK_LIBS $BLAS_LIBS $FFTW_LIBS $READLINE_LIBS $LIBS $FLIBS"
+      cmd="$LD_CXX $CPPFLAGS $ALL_CXXFLAGS $RDYNAMIC_FLAG $ALL_LDFLAGS $pass_on_options $output_option $objfiles $libfiles $ldflags $LFLAGS -loctinterp -loctave -lcruft $OCTAVE_LINK_OPTS $OCTAVE_LINK_DEPS"
       $dbg $cmd
       eval $cmd
     else
       echo "mkoctfile: no way to link stand-alone executable file" 1>&2
       exit 1
     fi
   else
-    LINK_DEPS="$LFLAGS $OCTAVE_LIBS $LDFLAGS $LAPACK_LIBS $BLAS_LIBS $FFTW_LIBS $LIBS $FLIBS"
-    cmd="$DL_LD $DL_LDFLAGS $pass_on_options -o $octfile $objfiles $libfiles $ldflags $LINK_DEPS"
+    cmd="$DL_LD $DL_LDFLAGS $pass_on_options -o $octfile $objfiles $libfiles $ldflags $LFLAGS -loctinterp -loctave -lcruft $OCT_LINK_OPTS $OCT_LINK_DEPS"
     $dbg $cmd
     eval $cmd
   fi
 
 # Maybe strip it.
 
   if $strip; then
     cmd="strip $octfile"
diff --git a/src/oct-conf.h.in b/src/oct-conf.h.in
--- a/src/oct-conf.h.in
+++ b/src/oct-conf.h.in
@@ -371,24 +371,40 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_CONF_MAGICK_LIBS
 #define OCTAVE_CONF_MAGICK_LIBS %OCTAVE_CONF_MAGICK_LIBS%
 #endif
 
 #ifndef OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS
 #define OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS %OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%
 #endif
 
+#ifndef OCTAVE_CONF_OCTAVE_LINK_DEPS
+#define OCTAVE_CONF_OCTAVE_LINK_DEPS %OCTAVE_CONF_OCTAVE_LINK_DEPS%
+#endif
+
+#ifndef OCTAVE_CONF_OCTAVE_LINK_OPTS
+#define OCTAVE_CONF_OCTAVE_LINK_OPTS %OCTAVE_CONF_OCTAVE_LINK_OPTS%
+#endif
+
 #ifndef OCTAVE_CONF_OCTINCLUDEDIR
 #define OCTAVE_CONF_OCTINCLUDEDIR %OCTAVE_CONF_OCTINCLUDEDIR%
 #endif
 
 #ifndef OCTAVE_CONF_OCTLIBDIR
 #define OCTAVE_CONF_OCTLIBDIR %OCTAVE_CONF_OCTLIBDIR%
 #endif
 
+#ifndef OCTAVE_CONF_OCT_LINK_DEPS
+#define OCTAVE_CONF_OCT_LINK_DEPS %OCTAVE_CONF_OCT_LINK_DEPS%
+#endif
+
+#ifndef OCTAVE_CONF_OCT_LINK_OPTS
+#define OCTAVE_CONF_OCT_LINK_OPTS %OCTAVE_CONF_OCT_LINK_OPTS%
+#endif
+
 #ifndef OCTAVE_CONF_OPENGL_LIBS
 #define OCTAVE_CONF_OPENGL_LIBS %OCTAVE_CONF_OPENGL_LIBS%
 #endif
 
 #ifndef OCTAVE_CONF_PREFIX
 #define OCTAVE_CONF_PREFIX %OCTAVE_CONF_PREFIX%
 #endif
 
@@ -435,20 +451,16 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_CONF_READLINE_LIBS
 #define OCTAVE_CONF_READLINE_LIBS %OCTAVE_CONF_READLINE_LIBS%
 #endif
 
 #ifndef OCTAVE_CONF_REGEX_LIBS
 #define OCTAVE_CONF_REGEX_LIBS %OCTAVE_CONF_REGEX_LIBS%
 #endif
 
-#ifndef OCTAVE_CONF_RLD_FLAG
-#define OCTAVE_CONF_RLD_FLAG %OCTAVE_CONF_RLD_FLAG%
-#endif
-
 #ifndef OCTAVE_CONF_SED
 #define OCTAVE_CONF_SED %OCTAVE_CONF_SED%
 #endif
 
 #ifndef OCTAVE_CONF_SHARED_LIBS
 #define OCTAVE_CONF_SHARED_LIBS %OCTAVE_CONF_SHARED_LIBS%
 #endif
 
diff --git a/src/ov-perm.cc b/src/ov-perm.cc
--- a/src/ov-perm.cc
+++ b/src/ov-perm.cc
@@ -212,16 +212,22 @@ octave_perm_matrix::PREFIX ## _value (bo
 }
 
 SparseMatrix
 octave_perm_matrix::sparse_matrix_value (bool) const
 {
   return SparseMatrix (matrix);
 }
 
+SparseBoolMatrix
+octave_perm_matrix::sparse_bool_matrix_value (bool) const
+{
+  return SparseBoolMatrix (matrix);
+}
+
 SparseComplexMatrix
 octave_perm_matrix::sparse_complex_matrix_value (bool) const
 {
   return SparseComplexMatrix (sparse_matrix_value ());
 }
 
 FORWARD_MATRIX_VALUE (Matrix, matrix)
 FORWARD_MATRIX_VALUE (FloatMatrix, float_matrix)
diff --git a/src/ov-perm.h b/src/ov-perm.h
--- a/src/ov-perm.h
+++ b/src/ov-perm.h
@@ -155,16 +155,18 @@ public:
   charNDArray char_array_value (bool = false) const;
 
   NDArray array_value (bool = false) const;
 
   FloatNDArray float_array_value (bool = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
+  SparseBoolMatrix sparse_bool_matrix_value (bool = false) const;
+
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   int8NDArray
   int8_array_value (void) const { return to_dense ().int8_array_value (); }
 
   int16NDArray
   int16_array_value (void) const { return to_dense ().int16_array_value (); }
 
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -590,25 +590,96 @@ octave_value_typeinfo::do_installed_type
 }
 
 DEFUN (typeinfo, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} typeinfo ()\n\
 @deftypefnx {Built-in Function} {} typeinfo (@var{expr})\n\
 \n\
 Return the type of the expression @var{expr}, as a string.  If\n\
-@var{expr} is omitted, return an array of strings containing all the\n\
+@var{expr} is omitted, return an cell array of strings containing all the\n\
 currently installed data types.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = Cell (octave_value_typeinfo::installed_type_names ());
   else if (nargin == 1)
     retval = args(0).type_name ();
   else
     print_usage ();
 
   return retval;
 }
+
+/*
+%!error typeinfo ("foo", 1);
+
+%!assert (iscellstr (typeinfo ()));
+
+%!assert (typeinfo (false), "bool");
+%!assert (typeinfo ([true, false]), "bool matrix");
+
+%!assert (typeinfo (1:2), "range");
+
+%!assert (typeinfo ("string"), "string");
+%!assert (typeinfo ('string'), "sq_string");
+
+%!assert (typeinfo (diag ([1, 2])), "diagonal matrix")
+%!assert (typeinfo (diag ([i, 2])), "complex diagonal matrix")
+%!assert (typeinfo (single (diag ([1, 2]))), "float diagonal matrix")
+%!assert (typeinfo (single (diag ([i, 2]))), "float complex diagonal matrix")
+%!assert (typeinfo (diag (single ([1, 2]))), "float diagonal matrix")
+%!assert (typeinfo (diag (single ([i, 2]))), "float complex diagonal matrix")
+
+%!assert (typeinfo ([]), "null_matrix");
+%!assert (typeinfo (""), "null_string");
+%!assert (typeinfo (''), "null_sq_string");
+
+%!assert (typeinfo (1), "scalar");
+%!assert (typeinfo (double (1)), "scalar");
+%!assert (typeinfo ([1, 2]), "matrix");
+%!assert (typeinfo (double ([1, 2])), "matrix");
+
+%!assert (typeinfo (i), "complex scalar");
+%!assert (typeinfo ([i, 2]), "complex matrix");
+
+%!assert (typeinfo (single (1)), "float scalar");
+%!assert (typeinfo (single ([1, 2])), "float matrix");
+
+%!assert (typeinfo (single (i)), "float complex scalar");
+%!assert (typeinfo (single ([i, 2])), "float complex matrix");
+
+%!assert (typeinfo (sparse (eye (10))), "sparse matrix");
+%!assert (typeinfo (sparse (i * eye (10))), "sparse complex matrix");
+%!assert (typeinfo (logical (sparse (i * eye (10)))), "sparse bool matrix");
+
+%!assert (typeinfo (int8 (1)), "int8 scalar");
+%!assert (typeinfo (int16 (1)), "int16 scalar");
+%!assert (typeinfo (int32 (1)), "int32 scalar");
+%!assert (typeinfo (int64 (1)), "int64 scalar");
+%!assert (typeinfo (uint8 (1)), "uint8 scalar");
+%!assert (typeinfo (uint16 (1)), "uint16 scalar");
+%!assert (typeinfo (uint32 (1)), "uint32 scalar");
+%!assert (typeinfo (uint64 (1)), "uint64 scalar");
+
+%!test
+%! s.a = 1;
+%! assert (typeinfo (s), "scalar struct");
+
+%!test
+%! s(2).a = 1;
+%! assert (typeinfo (s), "struct");
+
+%!assert (typeinfo ({"cell"}), "cell");
+
+%!assert (typeinfo (@sin), "function handle");
+%!assert (typeinfo (@(x) x), "function handle");
+
+%!assert (typeinfo (inline ('x^2')), "inline function");
+
+%!test
+%! [l, u, p] = lu (rand (3));
+%! assert (typeinfo (p), "permutation matrix");
+*/
diff --git a/src/profiler.cc b/src/profiler.cc
--- a/src/profiler.cc
+++ b/src/profiler.cc
@@ -169,17 +169,17 @@ profile_data_accumulator::tree_node::get
       rv_times(i) = octave_value (entry.time);
       rv_calls(i) = octave_value (entry.calls);
       rv_children(i) = entry.get_hierarchical ();
 
       ++i;
     }
   assert (i == n);
 
-  Octave_map retval;
+  octave_map retval;
 
   retval.assign ("Index", rv_indices);
   retval.assign ("SelfTime", rv_times);
   retval.assign ("NumCalls", rv_calls);
   retval.assign ("Children", rv_children);
 
   return retval;
 }
@@ -285,56 +285,99 @@ profile_data_accumulator::reset (void)
     }
 
   last_time = -1.0;
 }
 
 octave_value
 profile_data_accumulator::get_flat (void) const
 {
+  octave_value retval;
+
   const octave_idx_type n = known_functions.size ();
 
   flat_profile flat (n);
-  assert (call_tree);
-  call_tree->build_flat (flat);
 
-  Cell rv_names (n, 1);
-  Cell rv_times (n, 1);
-  Cell rv_calls (n, 1);
-  Cell rv_recursive (n, 1);
-  Cell rv_parents (n, 1);
-  Cell rv_children (n, 1);
-
-  for (octave_idx_type i = 0; i != n; ++i)
+  if (call_tree)
     {
-      rv_names(i) = octave_value (known_functions[i]);
-      rv_times(i) = octave_value (flat[i].time);
-      rv_calls(i) = octave_value (flat[i].calls);
-      rv_recursive(i) = octave_value (flat[i].recursive);
-      rv_parents(i) = stats::function_set_value (flat[i].parents);
-      rv_children(i) = stats::function_set_value (flat[i].children);
-    }
+      call_tree->build_flat (flat);
+
+      Cell rv_names (n, 1);
+      Cell rv_times (n, 1);
+      Cell rv_calls (n, 1);
+      Cell rv_recursive (n, 1);
+      Cell rv_parents (n, 1);
+      Cell rv_children (n, 1);
+
+      for (octave_idx_type i = 0; i != n; ++i)
+        {
+          rv_names(i) = octave_value (known_functions[i]);
+          rv_times(i) = octave_value (flat[i].time);
+          rv_calls(i) = octave_value (flat[i].calls);
+          rv_recursive(i) = octave_value (flat[i].recursive);
+          rv_parents(i) = stats::function_set_value (flat[i].parents);
+          rv_children(i) = stats::function_set_value (flat[i].children);
+        }
+
+      octave_map m;
 
-  Octave_map retval;
+      m.assign ("FunctionName", rv_names);
+      m.assign ("TotalTime", rv_times);
+      m.assign ("NumCalls", rv_calls);
+      m.assign ("IsRecursive", rv_recursive);
+      m.assign ("Parents", rv_parents);
+      m.assign ("Children", rv_children);
 
-  retval.assign ("FunctionName", rv_names);
-  retval.assign ("TotalTime", rv_times);
-  retval.assign ("NumCalls", rv_calls);
-  retval.assign ("IsRecursive", rv_recursive);
-  retval.assign ("Parents", rv_parents);
-  retval.assign ("Children", rv_children);
+      retval = m;
+    }
+  else
+    {
+      static const char *fn[] =
+        {
+          "FunctionName",
+          "TotalTime",
+          "NumCalls",
+          "IsRecursive",
+          "Parents",
+          "Children",
+          0
+        };
+
+      static octave_map m (dim_vector (0, 1), string_vector (fn));
+
+      retval = m;
+    }
 
   return retval;
 }
 
 octave_value
 profile_data_accumulator::get_hierarchical (void) const
 {
-  assert (call_tree);
-  return call_tree->get_hierarchical ();
+  octave_value retval;
+
+  if (call_tree)
+    retval = call_tree->get_hierarchical ();
+  else
+    {
+      static const char *fn[] =
+        {
+          "Index",
+          "SelfTime",
+          "NumCalls",
+          "Children",
+          0
+        };
+
+      static octave_map m (dim_vector (0, 1), string_vector (fn));
+
+      retval = m;
+    }
+
+  return retval;
 }
 
 double
 profile_data_accumulator::query_time (void) const
 {
   octave_time now;
   return now.double_value ();
 }
diff --git a/src/profiler.h b/src/profiler.h
old mode 100644
new mode 100755
--- a/src/profiler.h
+++ b/src/profiler.h
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 #include <map>
 #include <set>
 #include <string>
 #include <vector>
 
 class octave_value;
 
 class
-OCTAVE_API
+OCTINTERP_API
 profile_data_accumulator
 {
 public:
 
   // This is a utility class that can be used to call the enter/exit
   // functions in a manner protected from stack unwinding.
   class enter
   {
@@ -168,17 +168,17 @@ private:
   void add_current_time (void);
 
   // No copying!
   profile_data_accumulator (const profile_data_accumulator&);
   profile_data_accumulator& operator = (const profile_data_accumulator&);
 };
 
 // The instance used.
-extern profile_data_accumulator profiler;
+extern OCTINTERP_API profile_data_accumulator profiler;
 
 // Helper macro to profile a block of code.
 #define BEGIN_PROFILER_BLOCK(name) \
   { \
     profile_data_accumulator::enter pe (profiler, (name));
 #define END_PROFILER_BLOCK \
   }
 
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1458,17 +1458,19 @@ search path if they change.  If set to @
 recompile any function files unless their definitions are removed with\n\
 @code{clear}.  If set to \"none\", Octave will always check time stamps\n\
 on files to determine whether functions defined in function files\n\
 need to recompiled.\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (nargout > 0)
+  int nargin = args.length ();
+
+  if (nargout > 0 || nargin == 0)
     {
       switch (Vignore_function_time_stamp)
         {
         case 1:
           retval = "system";
           break;
 
         case 2:
@@ -1476,18 +1478,16 @@ need to recompiled.\n\
           break;
 
         default:
           retval = "none";
           break;
         }
     }
 
-  int nargin = args.length ();
-
   if (nargin == 1)
     {
       std::string sval = args(0).string_value ();
 
       if (! error_state)
         {
           if (sval == "all")
             Vignore_function_time_stamp = 2;
@@ -1502,16 +1502,35 @@ need to recompiled.\n\
         error ("ignore_function_time_stamp: expecting argument to be character string");
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
+/*
+%!shared old_state
+%! old_state = ignore_function_time_stamp ();
+%!test
+%! state = ignore_function_time_stamp ("all");  
+%! assert (state, old_state);
+%! assert (ignore_function_time_stamp (), "all");
+%! state = ignore_function_time_stamp ("system");  
+%! assert (state, "all");
+%! assert (ignore_function_time_stamp (), "system");
+%! ignore_function_time_stamp (old_state);
+
+%% Test input validation
+%!error (ignore_function_time_stamp ("all", "all"))
+%!error (ignore_function_time_stamp ("UNKNOWN_VALUE"))
+%!error (ignore_function_time_stamp (42))
+
+*/
+
 DEFUN (__current_scope__, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{scope}, @var{context}]} __dump_symtab_info__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -1295,30 +1295,33 @@ specified option.\n\
       { false, "LIBOCTAVE", OCTAVE_CONF_LIBOCTAVE },
       { false, "LIBOCTINTERP", OCTAVE_CONF_LIBOCTINTERP },
       { false, "LIBS", OCTAVE_CONF_LIBS },
       { false, "LN_S", OCTAVE_CONF_LN_S },
       { false, "MAGICK_CPPFLAGS", OCTAVE_CONF_MAGICK_CPPFLAGS },
       { false, "MAGICK_LDFLAGS", OCTAVE_CONF_MAGICK_LDFLAGS },
       { false, "MAGICK_LIBS", OCTAVE_CONF_MAGICK_LIBS },
       { false, "MKOCTFILE_DL_LDFLAGS", OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS },
+      { false, "OCTAVE_LINK_DEPS", OCTAVE_CONF_OCTAVE_LINK_DEPS },
+      { false, "OCTAVE_LINK_OPTS", OCTAVE_CONF_OCTAVE_LINK_OPTS },
+      { false, "OCT_LINK_DEPS", OCTAVE_CONF_OCT_LINK_DEPS },
+      { false, "OCT_LINK_OPTS", OCTAVE_CONF_OCT_LINK_OPTS },
       { false, "OPENGL_LIBS", OCTAVE_CONF_OPENGL_LIBS },
       { false, "PTHREAD_CFLAGS", OCTAVE_CONF_PTHREAD_CFLAGS },
       { false, "PTHREAD_LIBS", OCTAVE_CONF_PTHREAD_LIBS },
       { false, "QHULL_CPPFLAGS", OCTAVE_CONF_QHULL_CPPFLAGS },
       { false, "QHULL_LDFLAGS", OCTAVE_CONF_QHULL_LDFLAGS },
       { false, "QHULL_LIBS", OCTAVE_CONF_QHULL_LIBS },
       { false, "QRUPDATE_CPPFLAGS", OCTAVE_CONF_QRUPDATE_CPPFLAGS },
       { false, "QRUPDATE_LDFLAGS", OCTAVE_CONF_QRUPDATE_LDFLAGS },
       { false, "QRUPDATE_LIBS", OCTAVE_CONF_QRUPDATE_LIBS },
       { false, "RANLIB", OCTAVE_CONF_RANLIB },
       { false, "RDYNAMIC_FLAG", OCTAVE_CONF_RDYNAMIC_FLAG },
       { false, "READLINE_LIBS", OCTAVE_CONF_READLINE_LIBS },
       { false, "REGEX_LIBS", OCTAVE_CONF_REGEX_LIBS },
-      { false, "RLD_FLAG", OCTAVE_CONF_RLD_FLAG },
       { false, "SED", OCTAVE_CONF_SED },
       { false, "SHARED_LIBS", OCTAVE_CONF_SHARED_LIBS },
       { false, "SHLEXT", OCTAVE_CONF_SHLEXT },
       { false, "SHLEXT_VER", OCTAVE_CONF_SHLEXT_VER },
       { false, "SH_LD", OCTAVE_CONF_SH_LD },
       { false, "SH_LDFLAGS", OCTAVE_CONF_SH_LDFLAGS },
       { false, "SONAME_FLAGS", OCTAVE_CONF_SONAME_FLAGS },
       { false, "STATIC_LIBS", OCTAVE_CONF_STATIC_LIBS },
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -109,16 +109,27 @@ Return true if @var{name} is a valid var
   if (argc == 2)
     retval = valid_identifier (argv[1]) && ! is_keyword (argv[1]);
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error isvarname ();
+%!error isvarname ("foo", "bar");
+
+%!assert (isvarname ("foo"), true);
+%!assert (isvarname ("_foo"), true);
+%!assert (isvarname ("_1"), true);
+%!assert (isvarname ("1foo"), false);
+%!assert (isvarname (""), false);
+*/
+
 // Return TRUE if F and G are both names for the same file.
 
 bool
 same_file (const std::string& f, const std::string& g)
 {
   return same_file_internal (f, g);
 }
 
@@ -320,16 +331,34 @@ name in the path.  If no files are found
         error ("file_in_loadpath: FILE argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error file_in_loadpath ();
+%!error file_in_loadpath ("foo", "bar", 1);
+
+%!test
+%! f = file_in_loadpath ("plot.m");
+%! assert (ischar (f));
+%! assert (! isempty (f));
+
+%!test
+%! f = file_in_loadpath ("$$probably_!!_not_&&_a_!!_file$$");
+%! assert (f, "");
+
+%!test
+%! lst = file_in_loadpath ("$$probably_!!_not_&&_a_!!_file$$", "all");
+%! assert (lst, {});
+*/
+
 DEFUN (file_in_path, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} file_in_path (@var{path}, @var{file})\n\
 @deftypefnx {Built-in Function} {} file_in_path (@var{path}, @var{file}, \"all\")\n\
 Return the absolute name of @var{file} if it can be found in\n\
 @var{path}.  The value of @var{path} should be a colon-separated list of\n\
 directories in the format described for @code{path}.  If no file\n\
 is found, return an empty character string.  For example:\n\
@@ -385,16 +414,35 @@ name in the path.  If no files are found
         error ("file_in_path: PATH must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error file_in_path ();
+%!error file_in_path ("foo");
+%!error file_in_path ("foo", "bar", "baz", 1);
+
+%!test
+%! f = file_in_path (path (), "plot.m");
+%! assert (ischar (f));
+%! assert (! isempty (f));
+
+%!test
+%! f = file_in_path (path (), "$$probably_!!_not_&&_a_!!_file$$");
+%! assert (f, "");
+
+%!test
+%! lst = file_in_path (path (), "$$probably_!!_not_&&_a_!!_file$$", "all");
+%! assert (lst, {});
+*/
+
 std::string
 file_in_path (const std::string& name, const std::string& suffix)
 {
   std::string nm = name;
 
   if (! suffix.empty ())
     nm.append (suffix);
 
@@ -618,16 +666,30 @@ Convert special characters in @var{strin
         error ("do_string_escapes: STRING argument must be of type string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error do_string_escapes ();
+%!error do_string_escapes ("foo", "bar");
+
+%!assert (do_string_escapes ('foo\nbar'), "foo\nbar");
+%!assert (do_string_escapes ("foo\\nbar"), "foo\nbar");
+%!assert (do_string_escapes ("foo\\nbar"), ["foo", char(10), "bar"]);
+
+%!assert (do_string_escapes ('\a\b\f\n\r\t\v'), "\a\b\f\n\r\t\v");
+%!assert (do_string_escapes ("\\a\\b\\f\\n\\r\\t\\v"), "\a\b\f\n\r\t\v");
+%!assert (do_string_escapes ("\\a\\b\\f\\n\\r\\t\\v"),
+%!        char ([7, 8, 12, 10, 13, 9, 11]));
+*/
+
 const char *
 undo_string_escape (char c)
 {
   if (! c)
     return "";
 
   switch (c)
     {
@@ -724,16 +786,30 @@ representation.\n\
         error ("undo_string_escapes: S argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error undo_string_escapes ();
+%!error undo_string_escapes ("foo", "bar");
+
+%!assert (undo_string_escapes ("foo\nbar"), 'foo\nbar');
+%!assert (undo_string_escapes ("foo\nbar"), "foo\\nbar");
+%!assert (undo_string_escapes (["foo", char(10), "bar"]), "foo\\nbar");
+
+%!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), '\a\b\f\n\r\t\v');
+%!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), "\\a\\b\\f\\n\\r\\t\\v");
+%!assert (undo_string_escapes (char ([7, 8, 12, 10, 13, 9, 11])),
+%!        "\\a\\b\\f\\n\\r\\t\\v");
+*/
+
 DEFUN (is_absolute_filename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_absolute_filename (@var{file})\n\
 Return true if @var{file} is an absolute filename.\n\
 @seealso{is_rooted_relative_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = false;
@@ -742,16 +818,23 @@ Return true if @var{file} is an absolute
     retval = (args(0).is_string ()
               && octave_env::absolute_pathname (args(0).string_value ()));
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error is_absolute_filename ();
+%!error is_absolute_filename ("foo", "bar");
+
+FIXME -- we need system-dependent tests here.
+*/
+
 DEFUN (is_rooted_relative_filename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_rooted_relative_filename (@var{file})\n\
 Return true if @var{file} is a rooted-relative filename.\n\
 @seealso{is_absolute_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = false;
@@ -760,16 +843,23 @@ Return true if @var{file} is a rooted-re
     retval = (args(0).is_string ()
               && octave_env::rooted_relative_pathname (args(0).string_value ()));
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error is_rooted_relative_filename ();
+%!error is_rooted_relative_filename ("foo", "bar");
+
+FIXME -- we need system-dependent tests here.
+*/
+
 DEFUN (make_absolute_filename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} make_absolute_filename (@var{file})\n\
 Return the full name of @var{file}, relative to the current directory.\n\
 @seealso{is_absolute_filename, is_rooted_relative_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = std::string ();
@@ -784,16 +874,23 @@ Return the full name of @var{file}, rela
         error ("make_absolute_filename: FILE argument must be a file name");
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error make_absolute_filename ();
+%!error make_absolute_filename ("foo", "bar");
+
+FIXME -- we need system-dependent tests here.
+*/
+
 DEFUN (find_dir_in_path, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} find_dir_in_path (@var{dir})\n\
 @deftypefnx {Built-in Function} {} find_dir_in_path (@var{dir}, \"all\")\n\
 Return the full name of the path element matching @var{dir}.  The\n\
 match is performed at the end of each path element.  For example, if\n\
 @var{dir} is @code{\"foo/bar\"}, it matches the path element\n\
 @code{\"/some/dir/foo/bar\"}, but not @code{\"/some/dir/foo/bar/baz\"}\n\
@@ -824,16 +921,23 @@ containing all name matches rather than 
         error ("find_dir_in_path: DIR must be a directory name");
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error find_dir_in_path ();
+%!error find_dir_in_path ("foo", "bar", 1);
+
+FIXME -- need to create tests using current path, pathsep, and dirsep.
+*/
+
 DEFUNX ("errno", Ferrno, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{err} =} errno ()\n\
 @deftypefnx {Built-in Function} {@var{err} =} errno (@var{val})\n\
 @deftypefnx {Built-in Function} {@var{err} =} errno (@var{name})\n\
 Return the current value of the system-dependent variable errno,\n\
 set its value to @var{val} and return the previous value, or return\n\
 the named error code given @var{name} as a character string, or -1\n\
@@ -868,32 +972,53 @@ if @var{name} is not found.\n\
   else if (nargin == 0)
     retval = octave_errno::get ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error errno ("foo", 1);
+
+%!assert (isnumeric (errno ()));
+
+%!test
+%! lst = errno_list ();
+%! fns = fieldnames (lst);
+%! oldval = errno (fns{1});
+%! assert (isnumeric (oldval));
+%! errno (oldval);
+%! newval = errno ();
+%! assert (oldval, newval);
+*/
+
 DEFUN (errno_list, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} errno_list ()\n\
 Return a structure containing the system-dependent errno values.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = octave_errno::list ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error errno_list ("foo");
+
+%!assert (isstruct (errno_list ()));
+*/
+
 static void
 check_dimensions (octave_idx_type& nr, octave_idx_type& nc, const char *warnfor)
 {
   if (nr < 0 || nc < 0)
     {
       warning_with_id ("Octave:neg-dim-as-zero",
                        "%s: converting negative dimension to zero", warnfor);
 
@@ -1347,16 +1472,24 @@ subsequent indexing using @var{ind} will
         {
           retval = false;
         }
     }
 
   return retval;
 }
 
+/*
+%!error isindex ();
+
+%!assert (isindex ([1, 2, 3]));
+%!assert (isindex (1:3));
+%!assert (isindex ([1, 2, -3]), false);
+*/
+
 octave_value_list
 do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
                    const char *fun_name, const octave_value_list& args,
                    int nargout)
 {
   octave_value_list new_args = args, retval;
   int nargin = args.length ();
   OCTAVE_LOCAL_BUFFER (bool, iscell, nargin);
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -2593,18 +2593,31 @@ elem_xpow (const FloatNDArray& a, const 
 {
   octave_value retval;
 
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      gripe_nonconformant ("operator .^", a_dims, b_dims);
-      return octave_value ();
+      if (is_valid_bsxfun (a_dims, b_dims))
+        {
+          //Potentially complex results
+          FloatNDArray xa = octave_value_extract<FloatNDArray> (a);
+          FloatNDArray xb = octave_value_extract<FloatNDArray> (b);
+          if (! xb.all_integers () && xa.any_element_is_negative ())
+            return octave_value (bsxfun_pow (FloatComplexNDArray (xa), xb));
+          else
+            return octave_value (bsxfun_pow (xa, xb));
+        }
+      else
+        {
+          gripe_nonconformant ("operator .^", a_dims, b_dims);
+          return octave_value ();
+        }
     }
 
   int len = a.length ();
 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
@@ -2668,18 +2681,25 @@ elem_xpow (const FloatNDArray& a, const 
 octave_value
 elem_xpow (const FloatNDArray& a, const FloatComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      gripe_nonconformant ("operator .^", a_dims, b_dims);
-      return octave_value ();
+      if (is_valid_bsxfun (a_dims, b_dims))
+        {
+          return bsxfun_pow (a, b);
+        }
+      else
+        {
+          gripe_nonconformant ("operator .^", a_dims, b_dims);
+          return octave_value ();
+        }
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
@@ -2760,18 +2780,25 @@ elem_xpow (const FloatComplexNDArray& a,
 octave_value
 elem_xpow (const FloatComplexNDArray& a, const FloatNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      gripe_nonconformant ("operator .^", a_dims, b_dims);
-      return octave_value ();
+      if (is_valid_bsxfun (a_dims, b_dims))
+        {
+          return bsxfun_pow (a, b);
+        }
+      else
+        {
+          gripe_nonconformant ("operator .^", a_dims, b_dims);
+          return octave_value ();
+        }
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
       octave_quit ();
       float btmp = b(i);
@@ -2803,18 +2830,25 @@ elem_xpow (const FloatComplexNDArray& a,
 octave_value
 elem_xpow (const FloatComplexNDArray& a, const FloatComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      gripe_nonconformant ("operator .^", a_dims, b_dims);
-      return octave_value ();
+      if (is_valid_bsxfun (a_dims, b_dims))
+        {
+          return bsxfun_pow (a, b);
+        }
+      else
+        {
+          gripe_nonconformant ("operator .^", a_dims, b_dims);
+          return octave_value ();
+        }
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
diff --git a/test/fntests.m b/test/fntests.m
--- a/test/fntests.m
+++ b/test/fntests.m
@@ -86,17 +86,17 @@ function retval = has_functions (f)
   endif
 endfunction
 
 function retval = has_tests (f)
   fid = fopen (f);
   if (fid >= 0)
     str = fread (fid, "*char")';
     fclose (fid);
-    retval = ! isempty (regexp (str, '^%!(test|assert|error|warning)', "lineanchors"));
+    retval = ! isempty (regexp (str, '^%!(assert|error|fail|test|warning)', "lineanchors"));
   else
     error ("fopen failed: %s", f);
   endif
 endfunction
 
 function retval = has_demos (f)
   fid = fopen (f);
   if (fid >= 0)
@@ -119,18 +119,18 @@ function [dp, dn, dxf, dsk] = run_test_d
         && strcmp (nm((end-1):end), ".m"))
       p = n = xf = sk = 0;
       ffnm = fullfile (d, nm);
       if (has_tests (ffnm))
         print_test_file_name (nm);
         [p, n, xf, sk] = test (nm(1:(end-2)), "quiet", fid);
         print_pass_fail (n, p);
         files_with_tests(end+1) = ffnm;
-      elseif (has_demos (ffnm))
-        files_with_tests(end+1) = ffnm;
+      ##elseif (has_demos (ffnm))
+      ##  files_with_tests(end+1) = ffnm;
       else
         files_with_no_tests(end+1) = ffnm;
       endif
       dp += p;
       dn += n;
       dxf += xf;
       dsk += sk;
     endif
@@ -172,18 +172,18 @@ function [dp, dn, dxf, dsk] = run_test_s
         print_test_file_name (tmp);
         [p, n, xf, sk] = test (f, "quiet", fid);
         print_pass_fail (n, p);
         dp += p;
         dn += n;
         dxf += xf;
         dsk += sk;
         files_with_tests(end+1) = f;
-      elseif (has_demos (f))
-        files_with_tests(end+1) = f;
+      ##elseif (has_demos (f))
+      ##  files_with_tests(end+1) = f;
       elseif (has_functions (f))
         ## To reduce the list length, only mark .cc files that contain
         ## DEFUN definitions.
         files_with_no_tests(end+1) = f;
       endif
     endif
   endfor 
   ##  printf("%s%s -> passes %d of %d tests\n", ident, d, dp, dn);
@@ -210,17 +210,17 @@ function n = num_elts_matching_pattern (
   n = sum (cellfun (@(x) !isempty (x), regexp (lst, pat, 'once')));
 endfunction
 
 function report_files_with_no_tests (with, without, typ)
   pat = cstrcat ('\', typ, "$");
   n_with = num_elts_matching_pattern (with, pat);
   n_without = num_elts_matching_pattern (without, pat);
   n_tot = n_with + n_without;
-  printf ("\n%d (of %d) %s files have no tests or demos.\n", n_without, n_tot, typ);
+  printf ("\n%d (of %d) %s files have no tests.\n", n_without, n_tot, typ);
 endfunction
 
 pso = page_screen_output ();
 warn_state = warning ("query", "quiet");
 warning ("on", "quiet");
 try
   page_screen_output (0);
   warning ("off", "Octave:deprecated-functions");
